[site]: stackoverflow
[post_id]: 4023320
[parent_id]: 
[tags]: 
How to implement memmove in standard C without an intermediate copy?

From the man page on my system: void *memmove(void *dst, const void *src, size_t len); DESCRIPTION The memmove() function copies len bytes from string src to string dst. The two strings may overlap ; the copy is always done in a non-destructive manner. From the C99 standard: 6.5.8.5 When two pointers are compared, the result depends on the relative locations in the address space of the objects pointed to. If two pointers to object or incomplete types both point to the same object, or both point one past the last element of the same array object, theycompare equal. If the objects pointed to are members of the same aggregate object, pointers to structure members declared later compare greater than pointers to members declared earlier in the structure, and pointers to array elements with larger subscript values compare greater than pointers to elements of the same array with lower subscript values. All pointers to members of the same union object compare equal. If the expression P points to an element of an array object and the expression Q points to the last element of the same array object, the pointer expression Q+1 compares greater than P . In all other cases, the behavior is undefined . The emphasis is mine. The arguments dst and src can be converted to pointers to char so as to alleviate strict aliasing problems, but is it possible to compare two pointers that may point inside different blocks, so as to do the copy in the correct order in case they point inside the same block? The obvious solution is if (src , but that is undefined if src and dst point to different blocks. "Undefined" means you should not even assume that the condition returns 0 or 1 (this would have been called "unspecified" in the standard's vocabulary). An alternative is if ((uintptr_t)src , which is at least unspecified, but I am not sure that the standard guarantees that when src is defined, it is equivalent to (uintptr_t)src . Pointer comparison is defined from pointer arithmetic. For instance, when I read section 6.5.6 on addition, it seems to me that pointer arithmetic could go in the direction opposite to uintptr_t arithmetic, that is, that a compliant compiler might have, when p is of type char* : ((uintptr_t)p)+1==((uintptr_t)(p-1) This is only an example. Generally speaking very little seems to be guaranteed when converting pointers to integers. This is a purely academic question, because memmove is provided together with the compiler. In practice, the compiler authors can simply promote undefined pointer comparison to unspecified behavior, or use the relevant pragma to force their compiler to compile their memmove correctly. For instance, this implementation has this snippet: if ((uintptr_t)dst I would still like to use this example as proof that the standard goes too far with undefined behaviors, if it is true that memmove cannot be implemented efficiently in standard C. For instance, no-one ticked when answering this SO question .
