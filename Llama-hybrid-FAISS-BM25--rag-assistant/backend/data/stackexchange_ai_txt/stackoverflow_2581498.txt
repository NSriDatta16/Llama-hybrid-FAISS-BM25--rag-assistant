[site]: stackoverflow
[post_id]: 2581498
[parent_id]: 978222
[tags]: 
OpenMP (at least 2.0) supports reduction for some simple operations, but not for max and min. In the following example the reduction clause is used to make a sum and a critical section is used to update a shared variable using a thread-local one without conflicts. #include #include int main() { double sum = 0; uint64_t ii; uint64_t maxii = 0; uint64_t maxii_shared = 0; #pragma omp parallel shared(maxii_shared) private(ii) firstprivate(maxii) { #pragma omp for reduction(+:sum) nowait for(ii=0; ii maxii) maxii = ii; } #pragma omp critical { if(maxii > maxii_shared) maxii_shared = maxii; } } std::cerr EDIT: a cleaner implementation: #include #include #include #include #include #include // sum the elements of v double sum(const std::vector & v) { double sum = 0.0; #pragma omp parallel for reduction(+:sum) for(size_t ii=0; ii & v) { double shared_min; #pragma omp parallel { double min = std::numeric_limits ::max(); #pragma omp for nowait for(size_t ii=0; ii unigen(-1000.0,1000.0); std::tr1::variate_generator >gen(engine, unigen); std::vector random(1000000); std::generate(random.begin(), random.end(), gen); cout
