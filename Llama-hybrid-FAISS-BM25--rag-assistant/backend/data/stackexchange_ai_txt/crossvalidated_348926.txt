[site]: crossvalidated
[post_id]: 348926
[parent_id]: 348686
[tags]: 
Since the mean of the simulated residuals is not exactly zero, the model cannot possibly disentangle the mean residual from the true effect. Nevertheless, the model clearly does a good job in taking sampling variability into account, because both your estimates are less than one standard error from their true values. And if you increase the number of observations you can get as close as you want to the original values used in the simulation. Edit : In your code the mean of the residual is zero but only when summed over the whole dataset, i.e. pooling together the two conditions A and B. The residuals' means are not zero when averaged separately in the two conditions, hence the difference between the estimates and the true generative values. I don't think it is possible to obtain the same exact values of the fixed-effects used in the simulation, unless you force the residuals to sum to zero within conditions, e.g. code below. library("lme4") set.seed(123) d Edit 2 : When setting empirical=TRUE the values generated are such that the sample variance computed using Bessel correction (that is by using of $n-1$ instead of $n$ in the denominator) correspond exactly to the one used for generating the values. In the code above the residuals are generated for two smaller vectors of length 30 instead of a single one of length 60, hence the estimated sample variance would be different from the intended value, unless this value is corrected as pointed out by @amoeba in his comment. In this particular case one needs to multiply the desired value by $\frac{60-1}{60-2}$, and more generally if one wants to generate a sample of length $n$ by concatenating $k$ vectors of equal length, the standard deviation used to generate each of the $k$ vectors should be multiplied by the factor $\frac{n-1}{n-k}$.
