[site]: stackoverflow
[post_id]: 659888
[parent_id]: 659865
[tags]: 
Do child processes spawned via multiprocessing share objects created earlier in the program? No for Python yes for Python ≥ 3.8 . Processes have independent memory space. Solution 1 To make best use of a large structure with lots of workers, do this. Write each worker as a "filter" – reads intermediate results from stdin , does work, writes intermediate results on stdout . Connect all the workers as a pipeline: process1 result Each process reads, does work and writes. This is remarkably efficient since all processes are running concurrently. The writes and reads pass directly through shared buffers between the processes. Solution 2 In some cases, you have a more complex structure – often a fan-out structure. In this case you have a parent with multiple children. Parent opens source data. Parent forks a number of children. Parent reads source, farms parts of the source out to each concurrently running child. When parent reaches the end, close the pipe. Child gets end of file and finishes normally. The child parts are pleasant to write because each child simply reads sys.stdin . The parent has a little bit of fancy footwork in spawning all the children and retaining the pipes properly, but it's not too bad. Fan-in is the opposite structure. A number of independently running processes need to interleave their inputs into a common process. The collector is not as easy to write, since it has to read from many sources. Reading from many named pipes is often done using the select module to see which pipes have pending input. Solution 3 Shared lookup is the definition of a database. Solution 3A – load a database. Let the workers process the data in the database. Solution 3B – create a very simple server using werkzeug (or similar) to provide WSGI applications that respond to HTTP GET so the workers can query the server. Solution 4 Shared filesystem object. Unix OS offers shared memory objects. These are just files that are mapped to memory so that swapping I/O is done instead of more convention buffered reads. You can do this from a Python context in several ways Write a startup program that (1) breaks your original gigantic object into smaller objects, and (2) starts workers, each with a smaller object. The smaller objects could be pickled Python objects to save a tiny bit of file reading time. Write a startup program that (1) reads your original gigantic object and writes a page-structured, byte-coded file using seek operations to assure that individual sections are easy to find with simple seeks. This is what a database engine does – break the data into pages, make each page easy to locate via a seek . Spawn workers with access to this large page-structured file. Each worker can seek to the relevant parts and do their work there.
