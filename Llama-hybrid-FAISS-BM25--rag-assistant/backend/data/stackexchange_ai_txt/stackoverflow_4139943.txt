[site]: stackoverflow
[post_id]: 4139943
[parent_id]: 4139917
[tags]: 
By "linked list", do you mean std::list ? template bool isPalindrome(BiDiIterator first, BiDiIterator last) { if (first == last) return true; --last; if (first == last) return true; if (*first != *last) return false; return isPalindrome(++first, last); // tail recursion FTW } isPalindrome(mylist.begin(), mylist.end()); I've used the fact that it's possible to iterate back from the end as well as forward from the start. It is not clear whether this is given by the question. With a singly linked list you can run two iterators, one fast and one slow. On each call, increment the fast one twice and the slow one once. When the fast one reaches the end of the list, the slow one is at the midpoint (um, +/- 1 and taking account of odd-length and even-length lists). At that point, back out of your recursion comparing character values. Î˜(n) complexity for runtime and memory use (not tail recursive). I'd write the code, but it's time for bed here in the UK. [Edit: morning all template std::pair isPalindrome(FwdIterator slow, FwdIterator fast, FwdIterator last) { if (fast == last) return std::make_pair(slow, true); ++fast; if (fast == last) return std::make_pair(++slow, true); ++fast; FwdIterator next = slow; std::pair result = isPalindrome(++next, fast, last); if (result.second == false) return result; if (*slow != *(result.first)) return std::make_pair(slow, false); ++(result.first); return result; } ... isPalindrome(mylist.begin(), mylist.begin(), mylist.end()).second; If, for some bizarre reason, your linked list doesn't provide an iterator, then hopefully the equivalent code with if (fast->next == 0) , fast = fast->next , etc, is obvious. And of course you can tidy up the user interface with a wrapper. I think you can avoid the additional storage if you're allowed to temporarily modify the list, by reversing the list up to "slow" as you descend, then reversing it again as you ascend. That way you don't need to store a copy of slow across the recursive call: instead you can return an extra pointer for the caller to follow. I'm not going to bother, though. ]
