[site]: stackoverflow
[post_id]: 4468111
[parent_id]: 4412279
[tags]: 
This is how I would begin to approach the issue. A custom model binder would be pretty easy to build based on the FormKey property (which could be determined by the index and/or label, depending). public class CustomFormModel { public string FormId { get; set; } public string Label { get; set; } public CustomFieldModel[] Fields { get; set; } } public class CustomFieldModel { public DataType DateType { get; set; } // System.ComponentModel.DataAnnotations public string FormKey { get; set; } public string Label { get; set; } public object Value { get; set; } } public class CustomFieldModel : CustomFieldModel { public new T Value { get; set; } } Also, I noticed one of the comments below had a filtered model binder system. Jimmy Bogard from Automapper made a really helpful post about this method at http://www.lostechies.com/blogs/jimmy_bogard/archive/2009/03/17/a-better-model-binder.aspx , and later revised in, http://www.lostechies.com/blogs/jimmy_bogard/archive/2009/11/19/a-better-model-binder-addendum.aspx . It has been very helpful for me in building custom model binders. Update I realized that I misinterpreted the question, and that he was specifically asking how to handle posting of the form "with a variable number of input fields that represent different data types". I think the best way to do this is to use a structure similar to above but leverage the Composite Pattern . Basically, you will need to create an interface like IFormComponent and implement it for each datatype that would be represented. I wrote and commented an example interface to help explain how this would be accomplished: public interface IFormComponent { // the id on the html form field. In the case of a composite Id, that doesn't have a corresponding // field you should still use something consistent, since it will be helpful for model binding // (For example, a CompositeDateField appearing as the third field in the form should have an id // something like "frmId_3_date" and its child fields would be "frmId_3_date_day", "frmId_3_date_month", // and "frmId_3_date_year". string FieldId { get; } // the human readable field label string Label { get; } // some functionality may require knowledge of the // Parent component. For example, a DayField with a value of "30" // would need to ask its Parent, a CompositeDateField // for its MonthField's value in order to validate // that the month is not "February" IFormComponent Parent { get; } // Gets any child components or null if the // component is a leaf component (has no children). IList GetChildren(); // For leaf components, this method should accept the AttemptedValue from the value provider // during Model Binding, and create the appropriate value. // For composites, the input should be delimited in someway, and this method should parse the // string to create the child components. void BindTo(string value); // This method should parse the Children or Underlying value to the // default used by your business models. (e.g. a CompositeDateField would // return a DateTime. You can get type safety by creating a FormComponent // which would help to avoid issues in binding. object GetValue(); // This method would render the field to the http response stream. // This makes it easy to render the forms simply by looping through // the array. Implementations could extend this for using an injected // formatting void Render(TextWriter writer); } I am assuming that the custom forms can be accessed via some sort of id which can be contained as a form parameter. With that assumption, the model binder and provider could look something like this. public interface IForm : IFormComponent { Guid FormId { get; } void Add(IFormComponent component); } public interface IFormRepository { IForm GetForm(Guid id); } public class CustomFormModelBinder : IModelBinder { private readonly IFormRepository _repository; public object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext) { ValueProviderResult result; if(bindingContext.ValueProvider.TryGetValue("_customFormId", out result)) { var form = _repository.GetForm(new Guid(result.AttemptedValue)); var fields = form.GetChildren(); // loop through the fields and bind their values return form; } throw new Exception("Form ID not found."); } } Obviously, all the code here is just to get the point across, and would need to be completed and cleaned up for actual use. Also, even if completed this would only bind to an implementation of the IForm interface, not a strongly typed business object. (It wouldn't be a huge step to convert it to a dictionary and build a strongly typed proxy using the Castle DictionaryAdapter, but since your users are dynamically creating the forms on the site, there is probably no strongly typed model in your solution and this is irrelevant). Hope this helps more.
