[site]: stackoverflow
[post_id]: 3877101
[parent_id]: 3876943
[tags]: 
In my opinion, the best approach is to keep an epoch based representation as an integer. The most standard one is to maintain seconds since 1970. Since you want to keep a higher resolution, you could extend this and keep microseconds or milliseconds since 1970. In order to accomplish this, you would need to use at least a 64 bit integer (long long). The posix gettimeofday() will give you resolution up to microseconds and you can combine this with the gmtime_r() function to get the rest of the stamp. For windows, I use the GetSystemTime() function to get time in resolution up to milli-seconds (actually, I think that it is tens of milliseconds). The following code fragment shows this approach (not that my time units are nanoseconds). LgrDate rtn; #ifdef _WIN32 SYSTEMTIME sys; GetSystemTime(&sys); rtn.setDate( sys.wYear, sys.wMonth, sys.wDay); rtn.setTime( sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds*uint4(nsecPerMSec)); #else struct timeval time_of_day; struct tm broken_down; gettimeofday(&time_of_day,0); gmtime_r( &time_of_day.tv_sec, &broken_down); rtn.setDate( broken_down.tm_year + 1900, broken_down.tm_mon + 1, broken_down.tm_mday); rtn.setTime( broken_down.tm_hour, broken_down.tm_min, broken_down.tm_sec, time_of_day.tv_usec * nsecPerUSec); #endif return rtn;
