[site]: stackoverflow
[post_id]: 5480102
[parent_id]: 
[tags]: 
Setting default exception handlers in a base class - good or bad

So, I have a simple base class for Server - and I realised that for a number of Exceptions that I'm throwing, the handling would be fairly consistent for all Server types (for example, HTTP 4xx errors). So I've setup a callback and default handler like so: Server class: methodsAllowed)) { throw new Exception_Server_MethodNotAllowed($_SERVER['REQUEST_METHOD'], $this->methodsAllowed); } } protected function areParametersCorrect() { foreach ($this->requiredParameters as $parameter) { if (!in_array($parameter, array_keys($_REQUEST))) { throw new Exception_Server_MissingParameter('Missing parameter "' . $parameter . '" in request'); } } } protected function init() { $this->isMethodAllowed(); $this->areParametersCorrect(); } protected function sendXML($xml) { header('Content-Type: text/xml'); echo $xml; exit; } abstract public function respond(); public static function exceptionHandler($exception) { switch (true) { case $exception instanceof Exception_HTTP_400: error_log($exception->getMessage()); header('HTTP/1.1 400 Not Found'); exit; case $exception instanceof Exception_HTTP_404: error_log($exception->getMessage()); header('HTTP/1.1 404 Not Found'); exit; case $exception instanceof Exception_HTTP_405: error_log($exception->getMessage()); header('HTTP/1.1 405 Method Not Allowed'); header('Allow: ' . implode(', ', $exception->getMethodsAllowed())); exit; } } } Exception_Handler::register('Server_Factory::exceptionHandler'); class Exception_Server_MethodNotAllowed extends Exception_HTTP_405 { } class Exception_Server_MissingParameter extends Exception_HTTP_400 { } Default handler: class Exception_Handler { protected static $callbacks = array(); public static function register($callback) { if (!in_array($callback, self::$callbacks)) { self::$callbacks[] = $callback; } } public static function handle($exception) { foreach (self::$callbacks as $callback) { call_user_func($callback, $exception); } } } set_exception_handler('Exception_Handler::handle'); Now - any application that uses this base class can override the default exception handling by catching the Exceptions, but it also allows for a default handling. Is this a good design decision? The pro's as I see it is - it allows for a base behaviour, and allows keeps the Server exceptions group with the Server code, and ??? The con's are - it is using callbacks (and I'm finding PHPUnit is not reporting coverage of the callbacks), and ??? NB - I may not be using the best methods to determine the nature of the Exception - instanceof 'felt' about right, but if there's better, I'd like to know...
