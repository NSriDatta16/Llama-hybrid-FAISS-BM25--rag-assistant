[site]: stackoverflow
[post_id]: 3922621
[parent_id]: 3922258
[tags]: 
I start by anchoring the most valuable behaviour of the code. For instance, if it's a validator, I'll start by making sure it says that valid objects are valuable. Now we can showcase the code, train users not to do stupid things, etc. - even if the validator never gets implemented any further. After that, I start adding the edge cases, with the most dangerous validation mistakes first. If I start with a parser, rather than start with an empty string, I might start with something typical but simple that I want to parse and something I'd like to get out of that. For me unit tests are more like examples of how I'm going to want to use the code. I also follow BDD's practice of naming the tests should - so for your example I'd have shouldReturnNullIfTheInputIsEmpty() . This helps me identify the next most important thing the code should do. This is also related to BDD's "outside-in". Here are a couple of blog posts I wrote which might help: Pixie Driven Development and Bug Driven Development . Bug Driven Development helps me to work out what the next bit of system-level functionality I need should be, which then helps me find the next unit test. Hope this gives you a slightly different perspective, anyway - good luck!
