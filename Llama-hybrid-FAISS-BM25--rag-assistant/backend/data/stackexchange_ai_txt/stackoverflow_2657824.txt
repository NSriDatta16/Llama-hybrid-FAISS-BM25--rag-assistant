[site]: stackoverflow
[post_id]: 2657824
[parent_id]: 2657810
[tags]: 
Shallow copy: Some members of the copy may reference the same objects as the original: class X { private: int i; int *pi; public: X() : pi(new int) { } X(const X& copy) // Here, the pi member of the original and copied X object will both point to the same int . Deep copy: All members of the original are cloned (recursively, if necessary). There are no shared objects: class X { private: int i; int *pi; public: X() : pi(new int) { } X(const X& copy) // Here, the pi member of the original and copied X object will point to different int objects, but both of these have the same value. The default copy constructor (which is automatically provided if you don't provide one yourself) creates only shallow copies. Correction: Several comments below have correctly pointed out that it is wrong to say that the default copy constructor always performs a shallow copy (or a deep copy, for that matter). Whether a type's copy constructor creates a shallow copy, or deep copy, or something in-between the two , depends on the combination of each member's copy behaviour; a member's type's copy constructor can be made to do whatever it wants, after all. Here's what section 12.8, paragraph 8 of the 1998 C++ standard says about the above code examples: The implicitly defined copy constructor for class X performs a memberwise copy of its subobjects. [...] Each subobject is copied in the manner appropriate to its type: [...] [I]f the subobject is of scalar type, the builtin assignment operator is used.
