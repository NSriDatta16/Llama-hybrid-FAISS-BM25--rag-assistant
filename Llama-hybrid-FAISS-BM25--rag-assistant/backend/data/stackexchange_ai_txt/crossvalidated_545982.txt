[site]: crossvalidated
[post_id]: 545982
[parent_id]: 545971
[tags]: 
In general it's difficult to find patterns in a complex sequence. But for simple sequences like Fibonacci for which there is a linear recurrence relation involving past few terms (e.g., $f_{n}=f_{n-1}+f_{n-2}$ ), a simple linear model could be used (off course we need to know how many previous terms we need to predict the next term, e.g., for Fibonacci we need last 2 terms, for Tribonacci last 3 terms etc.), as shown in the following R code: S We can see that the linear model could discover the recurrence relation $x_n=x_{n-1}+x_{n-2}$ and predict the next Fibonacci number in the sequence, given past two Fibonacci number correctly. We can use time series to find seasonality / trend using models like ARIMA, for example to predict sequences as "1, 2 , 10, 12, 3, 4, 13, 14, ....", using the following R code: library(forecast) S Notice from above that it could predict the next 8 numbers 11, 12, 21, 22, 13, 14, 23, 24 correctly, given the past numbers in the sequence. Finally, we could use recurrent neural networks (e.g., LSTMs) for sequence prediction too. An attempt to predict the above series with LSTM (which gives poor results since we don't have much data, also did not do any preprocessing / scaling etc.) this time with python , we can use this model (when trained properly) to predict unseen data too: import tensorflow as tf from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense from tensorflow.keras.layers import LSTM def create_dataset(dataset, window=1): X, y = [], [] for i in range(len(dataset)-window-1): a = dataset[i:(i+window), 0] X.append(a) y.append(dataset[i + window, 0]) return np.array(X), np.array(y) import numpy as np series = np.array([1, 2 , 10, 12, 3, 4, 13, 14, 5, 6, 15, 16, 7, 8, 17, 18, 9, 10, 19, 20, 11, 12, 21, 22, 13, 14, 23, 24, 15, 16, 25, 26], dtype=float) series = series.reshape(-1, 1) window = 4 X, y = create_dataset(series, window) X = np.reshape(X, (X.shape[0], 1, X.shape[1])) model = Sequential() model.add(LSTM(8, input_shape=(1, look_back))) model.add(Dense(1)) model.compile(loss='mean_squared_error', optimizer='adam') model.fit(X, y, epochs=500, batch_size=4, verbose=2) # predict pred = model.predict(series) plt.plot(series) plt.plot(pred)
