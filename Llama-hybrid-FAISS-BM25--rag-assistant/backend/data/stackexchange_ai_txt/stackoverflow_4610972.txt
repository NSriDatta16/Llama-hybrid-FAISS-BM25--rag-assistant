[site]: stackoverflow
[post_id]: 4610972
[parent_id]: 4609151
[tags]: 
manage agents as data not threads an agent is a data structure that is associated with a pool of threads and a queue of events. when events are available for agents then the threads in that pool take turns doing work on the agents until the thread pool gets full or the event (work) queue becomes empty. an agent is garbage collected when the last reference to it goes out of scope. if you bind a top level var to it it will stick around forever. (def foo (agent {})) if you bind it to a name in a function it will be GCd at the end of that function (defn foo [] (let [foo (agent {})] (send do-stuff foo))) I don't see a direct message for canceling the work queue of an agent though you may be able to hack this by setting a validator on the agent that always returns false . This could cause the agent to stop working and wait for the agent error to be cleared. if you want to kill an agent from code outside of the lexical scope where the agent was created you will need to store the agent in some mutable structure like an atom so you can remove the reference to the agent to allow it to be GCd. (def my-agent (atom nil)) ;a persistent name for a transient agent (swap! my-agent (make-new-agent)) ;create the agent (send do-stuff @my-agent) ;use the agent (swap! my-agent nil) ;clean up
