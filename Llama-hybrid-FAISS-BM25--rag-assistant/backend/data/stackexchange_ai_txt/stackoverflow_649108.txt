[site]: stackoverflow
[post_id]: 649108
[parent_id]: 649090
[tags]: 
From the C99 standard, section 6.4.4.2 Floating constants, paragraph 3 (emphasis mine): The significand part is interpreted as a (decimal or hexadecimal) rational number; the digit sequence in the exponent part is interpreted as a decimal integer. For decimal floating constants, the exponent indicates the power of 10 by which the significand part is to be scaled. For hexadecimal floating constants, the exponent indicates the power of 2 by which the significand part is to be scaled. For decimal floating constants, and also for hexadecimal floating constants when FLT_RADIX is not a power of 2, the result is either the nearest representable value, or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner . For hexadecimal floating constants when FLT_RADIX is a power of 2, the result is correctly rounded. So, you're going to get a constant within one ULP in an implementation-defined manner. Recall that implementation-defined means that the implementation (in this case, the C runtime) can choose any of the options, but that choice must be documented . So, you can consult libc runtime documentation to find out how the rounding occurs.
