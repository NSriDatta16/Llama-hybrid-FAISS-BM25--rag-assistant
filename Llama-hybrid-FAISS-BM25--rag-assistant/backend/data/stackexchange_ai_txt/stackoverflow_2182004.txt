[site]: stackoverflow
[post_id]: 2182004
[parent_id]: 
[tags]: 
double free or corruption when running multithreaded

I met a runtime error "double free or corruption" in my C++ program that calls a reliable library ANN and uses OpenMP to parallize a for loop. *** glibc detected *** /home/tim/test/debug/test: double free or corruption (!prev): 0x0000000002527260 *** Does it mean that the memory at address 0x0000000002527260 is freed more than once? The error happens at "_search_struct->annkSearch(queryPt, k_max, nnIdx, dists, _eps);" inside function classify_various_k(), which is in turn inside the OpenMP for-loop inside function tune_complexity(). Note that the error happens when there are more than one threads for OpenMP, and does not happen in single thread case. Not sure why. Following is my code. If it is not enough for diagnose, just let me know. Thanks for your help! void KNNClassifier::train(int nb_examples, int dim, double **features, int * labels) { _nPts = nb_examples; _labels = labels; _dataPts = features; setting_ANN(_dist_type,1); delete _search_struct; if(strcmp(_search_neighbors, "brutal") == 0) { _search_struct = new ANNbruteForce(_dataPts, _nPts, dim); }else if(strcmp(_search_neighbors, "kdtree") == 0) { _search_struct = new ANNkd_tree(_dataPts, _nPts, dim); } } void KNNClassifier::classify_various_k(int dim, double *feature, int label, int *ks, double * errors, int nb_ks, int k_max) { ANNpoint queryPt = 0; ANNidxArray nnIdx = 0; ANNdistArray dists = 0; queryPt = feature; nnIdx = new ANNidx[k_max]; dists = new ANNdist[k_max]; if(strcmp(_search_neighbors, "brutal") == 0) { _search_struct->annkSearch(queryPt, k_max, nnIdx, dists, _eps); }else if(strcmp(_search_neighbors, "kdtree") == 0) { _search_struct->annkSearch(queryPt, k_max, nnIdx, dists, _eps); // where error occurs } for (int j = 0; j nb_examples){nb_try=i; break;} error_validation[i] = 0; } int i = 0; #pragma omp parallel shared(nb_examples_test, error_validation,features_test, labels_test, nb_try, ks) private(i) { #pragma omp for schedule(dynamic) nowait for (i=0; i UPDATE: Thanks! I am now trying to correct the conflict of writing to same memory problem in classify_various_k() by using "#pragma omp critical": void KNNClassifier::classify_various_k(int dim, double *feature, int label, int *ks, double * errors, int nb_ks, int k_max) { ANNpoint queryPt = 0; ANNidxArray nnIdx = 0; ANNdistArray dists = 0; queryPt = feature; //for (int i = 0; i content[i];} nnIdx = new ANNidx[k_max]; dists = new ANNdist[k_max]; if(strcmp(_search_neighbors, "brutal") == 0) {// search _search_struct->annkSearch(queryPt, k_max, nnIdx, dists, _eps); }else if(strcmp(_search_neighbors, "kdtree") == 0) { _search_struct->annkSearch(queryPt, k_max, nnIdx, dists, _eps); } for (int j = 0; j However, there is a new segment fault error at "result+=_labels[ nnIdx[i] ];". Some idea? Thanks!
