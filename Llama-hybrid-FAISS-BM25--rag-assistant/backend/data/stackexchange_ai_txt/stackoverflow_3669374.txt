[site]: stackoverflow
[post_id]: 3669374
[parent_id]: 3669338
[tags]: 
As a commenter pointed out, Big-O is always about the worst case scenario, so if increasing the value of R.Count would tend to make your worst-case scenarios increase at a rate greater than n*log(n), you're getting into the realm of n². Since you have a double-nested while loop, and no additional method calls, at a glance I'd have said it's O(n²). However, in this case, since i and j never increment, and n never decrements, and your loops are both based on i or j being less than n , this function will either exit right away (based on your if statements), or it never will. O(infinity)? Edit Okay, now that you increment them, the n*(n-i) bit basically averages out to n*(n/2) each time you run it (not an average of all runs, but rather an average for each run). This is because you'll be doing (n, n-1, n-2, ..., 3, 2, 1) inner loops as you move through the outer loop. If you fold this set in on itself, you can easily sum up the number of loops: n + 1 == n + 1 (n-1) + 2 == n + 1 (n-2) + 3 == n + 1 ... So you end up with n/2 instances of n + 1, which comes out to (n² + n)/2. From a big-O standpoint, this is the same as n².
