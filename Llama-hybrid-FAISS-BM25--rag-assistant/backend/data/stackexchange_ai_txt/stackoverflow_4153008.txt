[site]: stackoverflow
[post_id]: 4153008
[parent_id]: 4152799
[tags]: 
It is not the virtuality or const-ness (or lack thereof) that hides the base member, any derived method hides a base method of the same name. This was done to ameliorate the fragile base class problem. Imagine your code was working (possibly for years) as below, with non-relevant parts removed: struct Base { }; struct Derived : Base { void f(double); } void g(Derived &d) { d.f(42); } Then you need to modify Base to include a method that does something completely different, but, for some reason, you want to name it 'f': struct Base { void f(int); }; Without this rule, every use of a Derived calling f needs to be manually evaluated — and if Base is in a library given to other people, you may not even have access to those other uses! It gets worse in the face of user-defined (implicit) conversions. Instead, it was decided to require derived classes to explicitly state they want to import given names from Base with a using declaration. This rule can be surprising and I'm not sure it's a net benefit to the language today, but they didn't ask me — at the time, I could probably only have answered them with two-syllable words, anyway. :)
