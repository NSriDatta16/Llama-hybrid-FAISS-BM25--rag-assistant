[site]: stackoverflow
[post_id]: 535490
[parent_id]: 160218
[tags]: 
In small doses they can reduce the number of lines and make code more readable; particularly if the outcome is something like setting a char string to "Yes" or "No" based on the result of a calculation. Example: char* c = NULL; if(x) { c = "true"; }else { c = "false"; } compared with: char* c = x ? "Yes" : "No"; The only bug that can occur in simple tests like that is assigning an incorrect value, but since the conditional is usually simple it's less likely the programmer will get it wrong. Having your program print the wrong output isn't the end of the world, and should be caught in all of code review, bench testing and production testing phases. I'll counter my own argument with now it's more difficult to use code coverage metrics to assist in knowing how good your test cases are. In the first example you can test for coverage on both the assignment lines; if one is not covered then your tests are not exercising all possible code flows. In the second example the line will show as being executed regardless of the value of X, so you can't be certain you've tested the alternate path ( YMMV depending on the ability of your coverage tools). This matters more with the increasing complexity of the tests.
