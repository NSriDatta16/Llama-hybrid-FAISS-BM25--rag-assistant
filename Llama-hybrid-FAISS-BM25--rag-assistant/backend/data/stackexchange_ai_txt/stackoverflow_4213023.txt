[site]: stackoverflow
[post_id]: 4213023
[parent_id]: 
[tags]: 
FBO and Render to renderbuffer

Hi I am trying to use the Framebuffer object extension for offscreen rendering following the notes and example on : http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_offscreen/opengl_offscreen.html I am having a problem how to display the contents i have drawn on the FBO to the window! I am getting only a fully black screen! Also are textures preferable? I have found that renderbuffers are better in performance is that so? Can anyone help me with this pls? #include #include #include void drawfunc(); void init(int argc, char** argv); void initialise_FBO_toRenderBuf(); void onExit(); GLuint renderbufID; GLuint bufferID; int main(int argc, char** argv) { init(argc,argv); initialise_FBO_toRenderBuf(); glutDisplayFunc(drawfunc); glutMainLoop(); } void init(int argc, char** argv) { //initialising window settings glutInit(&argc, argv); glutInitDisplayMode(GLUT_SINGLE|GL_RGBA8); glutInitWindowSize(250,250); glutInitWindowPosition(100,100); glutCreateWindow("Hello Leanne mine"); /*GLubyte* versiongl; versiongl = glGetString(GL_VERSION); printf("version is: %s\n",versiongl); */ //initial background colour of the window glClearColor(0.0, 0.0, 0.0, 0.0); //the coordinate system to be used glOrtho(0.0, 1.0, 0.0, 1.0, -10.0, 1.0); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); } void initialise_FBO_toRenderBuf(void) { //generate FBO name (bufferID) and create a buffer objct with the texture name (bufferID) glGenFramebuffersEXT(1, &bufferID); glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, bufferID); //generate renderbuffer name (renderbufID) and create a renderbuffer object with the renderbuffer name (renderbufID) glGenRenderbuffersEXT(1, &renderbufID); glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, renderbufID); //Create data storage and establish the pixel format and dimensions of the renderbuffer image by calling the following function glRenderbufferStorageEXT (GL_RENDERBUFFER_EXT, GL_RGBA8,250, 250); //attach the texture to the FBO glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_RENDERBUFFER_EXT, renderbufID); switch(glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT)) { case GL_FRAMEBUFFER_COMPLETE_EXT: printf("The fbo is complete\n"); break; case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT: printf("GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT\n"); break; case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT: printf("GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT\n"); break; case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT: printf("GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT\n"); break; case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT: printf("GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT\n"); break; } } void drawfunc() { //use the FBO with name bufferID glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, bufferID); //clears the FBO to this color when glClear is called i.e it is the texture background color glClearColor(0.0, 1.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); //drawing here glColor3f(0.0, 1.0, 1.0); glBegin(GL_QUADS); glVertex2f(0.25, 0.25); glVertex2f(0.25, 0.75); glVertex2f(0.75, 0.75); glVertex2f(0.75, 0.25); glEnd(); glBegin(GL_QUADS); glColor3f(1.0, 0.0, 0.0); glVertex2f(0.5, 0.5); glVertex2f(0.5, 0.65); glVertex2f(0.65, 0.65); glVertex2f(0.65, 0.5); glEnd(); GLvoid* pixels = malloc(250*250*4); glPixelStorei(GL_UNPACK_ALIGNMENT, 1); glReadBuffer(GL_COLOR_ATTACHMENT0_EXT); glReadPixels(0,0, 250,250, GL_RGBA8, GL_UNSIGNED_BYTE, pixels); glDrawBuffer(0); //glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER, 0 ); glRasterPos2d(0, 0); glDrawPixels(250, 250, GL_RGBA8,GL_UNSIGNED_BYTE,pixels); glFlush(); onExit(); } void onExit() { //glDeleteTextures(1, &renderbufID); glDeleteFramebuffersEXT(1, &bufferID); }
