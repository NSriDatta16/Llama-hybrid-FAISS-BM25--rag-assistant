[site]: stackoverflow
[post_id]: 4939971
[parent_id]: 4939921
[tags]: 
(I assume that what you posted above is actually a fragment from some header file.) Things like that typically happen when different source files in your program are compiled with different memory-layout-related settings, like class packing and alignment settings. Your header file is included into these different translation units and is interpreted differently because of the discrepancies in memory-layout settings. Once you start passing your Test objects between these translation units, the problem reveals itself. One translation unit creates a Test object with one memory layout, then another translation units reads it or writes into it assuming a totally different memory layout. In your case it is your inline functions that get interpreted differently in each translation unit. If you define your member functions as non-inline ones, they will assume the class memory layout specific to the source file in which they are defined. This will sweep the problem under the carpet and make things "work" (since the access functions are now tied to one memory layout), but nevertheless it is still not a good situation to have. It still can lead to various problems of similar nature down the road. Make sure all source files in your program are compiled with exactly the same class memory layout settings. P.S. As Fred noted in the comments, the discrepancy in the class memory layout between translation units can be caused by something as prosaic as forgetting to recompile a source file after modifying a header file the source file depends upon. Another "popular" source of such problems is class definitions that depend on preprocessor directives (i.e. class layout "customized" by #ifdef / #endif segments). If you forget to #define something important in some source file that includes your header file, you might end up with different memory layout for the class in that source file.
