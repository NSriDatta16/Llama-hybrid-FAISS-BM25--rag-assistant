[site]: stackoverflow
[post_id]: 3998844
[parent_id]: 3998306
[tags]: 
Gaming and simulation are obvious answers. The math is not difficult, but it is clearly there. For example, say you want to build some sort of asteroids game. You'll need to figure out the position of your space ship. That's an vector. Now you want the ship to travel in a certain direction a certain direction every frame. You'll need to add some sort of delta-x to x, and delta-y to y, so your motion is another vector: . In an asteroids game, you accelerate in the direction you're pointing, so whenever you hit the 'thrust' key, you'll need to calculate the delta of dx and dy, or an acceleration vector, (yep, this is the same dx from calculus class, but now I'm building robot zombie opposums with it.) But that's not all. If you act now, I'll throw in some trig. Normally you think of motion and acceleration as angle and distance(r and theta,) but the programming language normally needs these values in dx, dy format. Here's where you'll use some trig: dx = r * cos (theta) and dy = r * sin(theta) But, let's say you want to have a planet with a gravitational pull? You'll need to approximate gravity in a way that gives you orbit behavior (elliptical orbits, firing changes the altitude of the other side of the orbit, and so on.) This is easiest to do if you understand Newton's law of universal gravitation: f = ((sqrt(m1 * m2))/d^2) * G. This tels you how much 'planetward' force to add to your ship every frame.Multiply this value by a normalized vector pointing from the spaceship to the planet, and add that as a new motion vector. Believe it or not, I encourage people who don't like math to take game programming courses. Often they discover that math can be (dare I say it) kind of fun when they're using it on problems that involve exploding cows in space. As another example, think about optimizing a sound wave. The analog wave has an infinite number of points. It's impossible to store them all in a digital signal, so we break the audio signal into a large number of small segments, then measure every segment. If we want a perfect representation, grab an infinitely large number of infinitely small time slices. Draw this out, and you've created the Riemann sum, the foundational idea of Integration (and in fact of Calculus) One more example: A friend of mine (a biology professor) was trying to build a 'sim city'-style simulation of a lake ecosystem. He was a decent programmer, but he got all bogged down in the various calculations. He wanted the user to vary usage of the lake (outboard motors, fishing restrictions, and dumping restrictions) and then to see how that affected levels of Nitrogen and other key elements. He tried all kinds of crazy if-then structures with nested conditions and ugly Boolean logic, but never had a clean solution. We took actual data, ran it through Excel, and found a trendline that accurately reflected his data with a simple logarithmic formula. Hundreds of lines of messy code were replaced with a simple formula.
