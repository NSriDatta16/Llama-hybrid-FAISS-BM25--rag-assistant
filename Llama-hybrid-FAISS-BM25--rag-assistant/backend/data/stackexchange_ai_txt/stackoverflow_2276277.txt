[site]: stackoverflow
[post_id]: 2276277
[parent_id]: 2276186
[tags]: 
Create a custom class that extends UITableViewCell @interface CustomTblCell : UITableViewCell In the corresponding NIB CustomTblCell.xib drag and drop UILabel and UIButton elements (side-by-side). Finally, in your method -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath initialize and return the CustomTblCell Hope this helps! Here is a code snippet for the cellForRowAtIndexPath: method I mentioned above -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ static NSString *CustomCellIdentifier = @"customCellIndentifier"; CustomTblCell *cell = (CustomTblCell *)[tableView dequeueReusableCellWithIdentifier:CustomCellIdentifier]; if(cell == nil){ NSArray *nib = [[NSBundle mainBundle] loadNibNamed:@"CustomTblCell" owner:self options:nil]; cell = [nib objectAtIndex:0]; } cell.label.text = @"My Product"; return cell; } If you have many rows in your table such that the user has to scroll through the table use 'dequeueReusableCellWithIdentifier`. This optimizes the code to reuse the same customTblCell object which is now not in user view. The deque method takes a String as input arg (customTableCellIdentifier). Make sure this matches the Identifier string you specify in the IB while creating the CustomTblCell
