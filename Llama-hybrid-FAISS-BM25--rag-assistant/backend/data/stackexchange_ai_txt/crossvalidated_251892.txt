[site]: crossvalidated
[post_id]: 251892
[parent_id]: 
[tags]: 
Implementing fancy PCA augmentaiton

I am really struggling to implement this fancy PCA augmentation method described in this paper , here is what I believe I must do (correct me if I am wrong): 1) Create a Matrix where the first column contains all the red pixel data, the 2n column all the green pixel data and the 3rd all the blue pixel data from all the images in the dataset. 2) Calculate the mean of every column and subtract it from every respective column. 3) Normalise the data between 0 and 1? (is this necessary? since all values are already between 0 and 255) 4) Apply PCA, i.e. create covariance matrix and compute the 3 eigenvectors and eigenvalues. 5) Then add eigenVec1 * a1 * eigenVal1 + eigenVec2 * a2 * eigenVal2 + eigenVec3 * a3 * eigenVal3 to each rgb channel in every image; Where 'a' is sampled from a gaussian with 0 mean and 0.1 std. But it seems like from this code colour_channel_weights = np.array([-0.0148366, -0.01253134, -0.01040762], dtype='float32') from link That the colour channel weights are very small and multiplying them by a random number less than 1 will make them even smaller. So wouldn't the overall effect of the augmentation have a super slim effect on the original data (like perpetuate is a miniscule amount of less than 1%)? Am I on the right track here?
