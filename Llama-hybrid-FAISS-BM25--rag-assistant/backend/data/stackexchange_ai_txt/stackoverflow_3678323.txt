[site]: stackoverflow
[post_id]: 3678323
[parent_id]: 3678235
[tags]: 
The delete [] will call the destructors on the struct pointers, which doesn't dispose of the structs or the _agent members, which itself points to memory. You could call delete _msgArr[i]._agent and then delete _msgArr[i] in a loop, which will dispose of the Agent and then the Message . First, though, you need to know who should get rid of the Agent s, and when. If these are owned by another data structure, you shouldn't get rid of them when getting rid of _msgArr , and looping over _delete _msgArr[i] followed by delete [] _msgarr; is all you need. If you do need to delete the Agent s also, you have three reasonable choices. First, you can give Message a destructor that will delete its _agent . It should also have a copy constructor and assignment operator defined then, either to pass ownership or to copy, or else define them as private so any attempt to use them will be a compile-time error. Second, you could change the Agent * to a smart pointer, so that the extra memory will be deleted when the Message goes away. Third, you could go through the loop I suggested above when getting rid of the array. Unless you have good reasons to keep the code C-compatible, I'd suggest that you use a std::vector > , and have Message contain a boost::shared_ptr rather than an Agent * (if you don't have to dispose of the Agent s, Agent * is fine). At that point, you don't need to worry: when _msgArr goes out of scope, all the memory is cleaned up properly.
