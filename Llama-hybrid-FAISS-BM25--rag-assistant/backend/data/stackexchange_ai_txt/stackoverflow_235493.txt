[site]: stackoverflow
[post_id]: 235493
[parent_id]: 
[tags]: 
Is my OCaml implementation of SHA256 sane?

I'm a novice OCaml programmer and thought I would throw myself into the deep end by attempting to implement a very tricky algorithm. I'm open to all criticisms great and small be they stylistic or security or performance related. One criticism that I'm already aware of is that the algorithm requires the entire message to fit in memory (whereas the reference implementation of SHA256 can process a block at a time). I'm especially concerned about if any of the recursive-functions are not tail-recursive. I have tested the code and it does produce proper message digests on x86_64 Linux. Thanks in advance for your consideration. Edit: Should nothing jump out at you please don't spend too much time here. I'm looking for obviously broken behavior, not rewrites. let as_bytes bits = match (bits mod 8) with | 0 -> (bits / 8) | _ -> failwith "as_bytes: bits must be multiple of 8" let as_bits bytes = bytes * 8 let k = [| 0x428a2f98l; 0x71374491l; 0xb5c0fbcfl; 0xe9b5dba5l; 0x3956c25bl; 0x59f111f1l; 0x923f82a4l; 0xab1c5ed5l; 0xd807aa98l; 0x12835b01l; 0x243185bel; 0x550c7dc3l; 0x72be5d74l; 0x80deb1fel; 0x9bdc06a7l; 0xc19bf174l; 0xe49b69c1l; 0xefbe4786l; 0x0fc19dc6l; 0x240ca1ccl; 0x2de92c6fl; 0x4a7484aal; 0x5cb0a9dcl; 0x76f988dal; 0x983e5152l; 0xa831c66dl; 0xb00327c8l; 0xbf597fc7l; 0xc6e00bf3l; 0xd5a79147l; 0x06ca6351l; 0x14292967l; 0x27b70a85l; 0x2e1b2138l; 0x4d2c6dfcl; 0x53380d13l; 0x650a7354l; 0x766a0abbl; 0x81c2c92el; 0x92722c85l; 0xa2bfe8a1l; 0xa81a664bl; 0xc24b8b70l; 0xc76c51a3l; 0xd192e819l; 0xd6990624l; 0xf40e3585l; 0x106aa070l; 0x19a4c116l; 0x1e376c08l; 0x2748774cl; 0x34b0bcb5l; 0x391c0cb3l; 0x4ed8aa4al; 0x5b9cca4fl; 0x682e6ff3l; 0x748f82eel; 0x78a5636fl; 0x84c87814l; 0x8cc70208l; 0x90befffal; 0xa4506cebl; 0xbef9a3f7l; 0xc67178f2l |] let hash s = let add_int32 x y = Int32.add x y in let left_int32 x n = Int32.shift_left x n in let right_int32 x n = Int32.shift_right_logical x n in let or_int32 x y = Int32.logor x y in let xor_int32 x y = Int32.logxor x y in let and_int32 x y = Int32.logand x y in let not_int32 x = Int32.lognot x in let rotate x n = (or_int32 (right_int32 x n) (left_int32 x (32 - n))) in let shift x n = right_int32 x n in let ch x y z = xor_int32 (and_int32 x y) (and_int32 (not_int32 x) z) in let maj x y z = (xor_int32 (and_int32 x y) (xor_int32 (and_int32 x z) (and_int32 y z))) in let sum0 x = (xor_int32 (rotate x 2) (xor_int32 (rotate x 13) (rotate x 22))) in let sum1 x = (xor_int32 (rotate x 6) (xor_int32 (rotate x 11) (rotate x 25))) in let rh00 x = (xor_int32 (rotate x 7) (xor_int32 (rotate x 18) (shift x 3))) in let rh01 x = (xor_int32 (rotate x 17) (xor_int32 (rotate x 19) (shift x 10))) in let as_bytes bits = match (bits mod 8) with | 0 -> (bits / 8) | _ -> failwith "as_bytes: bits must be multiple of 8" in let as_bits bytes = bytes * 8 in let sha = [| 0x6a09e667l; 0xbb67ae85l; 0x3c6ef372l; 0xa54ff53al; 0x510e527fl; 0x9b05688cl; 0x1f83d9abl; 0x5be0cd19l |] in let message = Buffer.create (as_bytes 512) in (* smallest possible buffer is at least 512 bits *) begin Buffer.add_string message s; let original_length = as_bits (Buffer.length message) in Buffer.add_char message '\x80'; (* append '1' bit *) let pad_start = as_bits (Buffer.length message) in let pad_blocks = if (original_length mod 512) Buffer.contents sha256 | _ -> begin Buffer.add_buffer sha256 (Bin.pack32 sha.(i)); pack_sha256 (i+1) end in pack_sha256 0 else begin let w = array_of_block i in let tem = [| 0l; 0l |] in begin let a = ref sha.(0) in let b = ref sha.(1) in let c = ref sha.(2) in let d = ref sha.(3) in let e = ref sha.(4) in let f = ref sha.(5) in let g = ref sha.(6) in let h = ref sha.(7) in for t = 0 to 63 do begin tem.(0) hx | _ -> hexdigits_inner (hx ^ (Printf.sprintf "%02x" (int_of_char s.[i]))) (i+1) in hexdigits_inner "" 0 The pack functions, defined in a separate file, are thus: let pack64 x = let b = Buffer.create 8 in for i = 0 to 7 do let shft = (7-i)*8 in Buffer.add_char b (char_of_int (Int64.to_int (Int64.logand (Int64.shift_right x shft) 0xFFL))); done; b let pack x n = if (n mod 8) = 0 then let n' = n/8 in let b = Buffer.create n' in for i = 0 to n'-1 do let shft = ((n'-1)-i)*8 in Buffer.add_char b (char_of_int (Int32.to_int (Int32.logand (Int32.shift_right x shft) 0xFFl))); done; b else raise (Invalid_argument ("pack: " ^ (string_of_int n) ^ " is not a multiple of 8")) let pack32 x = pack x 32 let pack16 x = pack x 16 let pack8 x = pack x 8
