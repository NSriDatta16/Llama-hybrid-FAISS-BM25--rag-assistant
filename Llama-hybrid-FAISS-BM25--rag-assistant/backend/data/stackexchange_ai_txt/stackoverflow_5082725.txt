[site]: stackoverflow
[post_id]: 5082725
[parent_id]: 5082680
[tags]: 
Well technically would prefer you never did (2) directly but prefered the use of a smart pointer: std::auto_ptr b(new Money(3,15)); // auto_ptr is just an example of a smart pointer But the overall question remains. Use (1) when the lifespan of the object does not exceed the function or object that is using it. Use (2) when the lifespan of the object extends for longer than you can predict at compile time. Is refereed to as a automatic storage duration object. This means that it is automatically created and destroyed (important bit) by code that is generated by the compiler. Is referred to as dynamic storage duration object. This means that it is your responsibility to both manually create and destroy the object. Destroying the object requires that we maintain the concept of ownership associated with the object and only allow the owner to destroy it (otherwise we get multiple sources trying to destroy the object). To aid in the ownership tracking we introduce smart pointers that own the pointer. It then becomes the responsibility of the smart pointer to do the actual work of destroying the object. Which makes building classes and functions with pointers a lot easier. If your object is cheap to create an copy(which it looks like it is). Then you shouls hardly ever need to create the object dynamically. Passing an object to a function or returning a result can all be done quite normally: Money CalcInterest(Money const& m, double interest) { Money result(m.doallas * interest, m.cent * interest); return result; // Return a copy quite happily. } If you were building a dynamic expression is then you can hold the pointers using smart pointers. struct Expression { char op; std::auto_ptr lhs; std::auto_ptr rhs; }; std::auto_ptr getExpressionFromUserInput() { std::auto_ptr result(new Expressions(/* etc */); return result; }
