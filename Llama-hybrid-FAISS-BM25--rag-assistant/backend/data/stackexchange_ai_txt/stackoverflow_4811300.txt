[site]: stackoverflow
[post_id]: 4811300
[parent_id]: 4775650
[tags]: 
Finally, I got it working (still need some modifcations). :) I must admit that I wasn't able to do draw the background in the ViewGroup itself. Well, it worked, but I couldn't control the scrolling (scrolled too much). What I basically did, was merging 2 tutorials. First one from here: Android Homescreen It switches between different layouts. So first of all, I set transparent backgrounds. Second one from here: Draggable Symbols It drags symbols over the screen by touch (using the onDraw , as suggested). I reduced the symbols to a single one and changed it from ImageView to LinearLayout . In that Layout I put the ViewGroup , did some little changes in the onTouchEvent and onInterceptTouchEvent , added some bad code and at last it worked. :) If someone's interested, I'll clean up the code and post it here, but I'm ashamed of my coding style, it's a mess. ;) Thank you very much, I appreciate your help! :) UPDATE: So, here is the code: MainActivity.java package de.android.projects; import android.app.Activity; import android.os.Bundle; public class MainActivity extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } } MoveBackground.java package de.android.projects; import android.content.Context; import android.graphics.Canvas; import android.graphics.drawable.Drawable; import android.util.AttributeSet; import android.widget.LinearLayout; /* * LinearLayout which moves the background image by touchEvents. * Taken from: http://eagle.phys.utk.edu/guidry/android/DraggableSymbols.html * and changed a little bit */ public class MoveBackground extends LinearLayout{ private Drawable background; // background picture private float X = -300; // Current x coordinate, upper left corner - 300 private int scroll; public MoveBackground(Context context) { super(context); } public MoveBackground(Context context, AttributeSet attrs) { super(context); background = context.getResources().getDrawable(R.drawable.backgroundpicture); //just for tests, not really optimized yet :) background.setBounds(0,0,1000,getResources().getDisplayMetrics().heightPixels); setWillNotDraw(false); } /* * Don't need these methods, maybe later for gesture improvements */ /* @Override public boolean onInterceptTouchEvent(MotionEvent ev) { onTouchEvent(ev); return false; } @Override public boolean onTouchEvent(MotionEvent ev) { final int action = ev.getAction(); switch (action) { // MotionEvent class constant signifying a finger-drag event case MotionEvent.ACTION_MOVE: { // Request a redraw invalidate(); break; } // MotionEvent class constant signifying a finger-up event case MotionEvent.ACTION_UP: invalidate(); // Request redraw break; } return true; } */ // This method will be called each time the screen is redrawn. // When to redraw is under Android control, but we can request a redraw // using the method invalidate() inherited from the View superclass. @Override public void onDraw(Canvas canvas) { super.onDraw(canvas); // get the object movement if (BadScrollHelp.getScrollX() != scroll){ //reduce the scrolling X -= scroll / 5; scroll = BadScrollHelp.getScrollX(); } // Draw background image at its current locations canvas.save(); canvas.translate(X,0); background.draw(canvas); canvas.restore(); } } ViewFlipper.java package de.android.projects; import android.content.Context; import android.os.Parcel; import android.os.Parcelable; import android.util.Log; import android.content.res.TypedArray; import android.util.AttributeSet; import android.view.MotionEvent; import android.view.VelocityTracker; import android.view.View; import android.view.ViewGroup; import android.view.ViewConfiguration; import android.widget.Scroller; /* * Flip different views. Taken from tutorial there http://android-projects.de/2011/01/04/android-homescreen-view-flipper/ */ public class ViewFlipper extends ViewGroup { private Scroller mScroller; private VelocityTracker mVelocityTracker; private int mScrollX = 0; private int mCurrentScreen = 0; private float mLastMotionX; private static final String LOG_TAG = "DragableSpace"; private static final int SNAP_VELOCITY = 1000; private final static int TOUCH_STATE_REST = 0; private final static int TOUCH_STATE_SCROLLING = 1; private int mTouchState = TOUCH_STATE_REST; private int mTouchSlop = 0; public ViewFlipper(Context context) { super(context); mScroller = new Scroller(context); mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop(); this.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.FILL_PARENT)); setWillNotDraw(false); requestDisallowInterceptTouchEvent(true); } public ViewFlipper(Context context, AttributeSet attrs) { super(context, attrs); TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.DragableSpace); mCurrentScreen = a.getInteger(R.styleable.DragableSpace_default_screen, 0); mScroller = new Scroller(context); mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop(); this.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT , ViewGroup.LayoutParams.FILL_PARENT)); setWillNotDraw(false); requestDisallowInterceptTouchEvent(true); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { /* * This method JUST determines whether we want to intercept the motion. * If we return true, onTouchEvent will be called and we do the actual * scrolling there. */ /* * Shortcut the most recurring case: the user is in the dragging state * and he is moving his finger. We want to intercept this motion. */ final int action = ev.getAction(); if ((action == MotionEvent.ACTION_MOVE) && (mTouchState != TOUCH_STATE_REST)) { return true; } final float x = ev.getX(); switch (action) { case MotionEvent.ACTION_MOVE: /* * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check * whether the user has moved far enough from his original down touch. */ /* * Locally do absolute value. mLastMotionX is set to the y value * of the down event. */ final int xDiff = (int) Math.abs(x - mLastMotionX); boolean xMoved = xDiff > mTouchSlop + 50; if (xMoved) { // Scroll if the user moved far enough along the X axis then mTouchState = TOUCH_STATE_SCROLLING; } break; case MotionEvent.ACTION_DOWN: // Remember location of down touch mLastMotionX = x; /* * If being flinged and user touches the screen, initiate drag; * otherwise don't. mScroller.isFinished should be false when * being flinged. */ mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING; break; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: // Release the drag mTouchState = TOUCH_STATE_REST; break; } /* * The only time we want to intercept motion events is if we are in the * drag mode. */ return mTouchState != TOUCH_STATE_REST; } @Override public boolean onTouchEvent(MotionEvent event) { if (mVelocityTracker == null) { mVelocityTracker = VelocityTracker.obtain(); } mVelocityTracker.addMovement(event); final int action = event.getAction(); final float x = event.getX(); switch (action) { case MotionEvent.ACTION_DOWN: Log.i(LOG_TAG, "event : down"); /* * If being flinged and user touches, stop the fling. isFinished * will be false if being flinged. */ if (!mScroller.isFinished()) { mScroller.abortAnimation(); } // Remember where the motion event started mLastMotionX = x; break; case MotionEvent.ACTION_MOVE: // Scroll to follow the motion event final int deltaX = (int) (mLastMotionX - x); mLastMotionX = x; if (deltaX 0) { BadScrollHelp.setScrollX(deltaX); scrollBy(Math.max(-mScrollX, deltaX), 0); } } else if (deltaX > 0) { final int availableToScroll = getChildAt(getChildCount() - 1) .getRight() - mScrollX - getWidth(); if (availableToScroll > 0) { BadScrollHelp.setScrollX(deltaX); scrollBy(Math.min(availableToScroll, deltaX), 0); } } // Request a redraw invalidate(); break; case MotionEvent.ACTION_UP: Log.i(LOG_TAG, "event : up"); final VelocityTracker velocityTracker = mVelocityTracker; velocityTracker.computeCurrentVelocity(1000); int velocityX = (int) velocityTracker.getXVelocity(); if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) { // Fling hard enough to move left snapToScreen(mCurrentScreen - 1); } else if (velocityX CREATOR = new Parcelable.Creator () { public SavedState createFromParcel(Parcel in) { return new SavedState(in); } public SavedState[] newArray(int size) { return new SavedState[size]; } }; } } BadScrollHelp.java package de.android.projects; public class BadScrollHelp { private static int scrollX = 0; private static int currentScreen = 0; public static synchronized void setScrollX(int scroll){ scrollX = scroll; } public static synchronized void setCurrentScreen(int screen){ currentScreen = screen; } public static synchronized int getScrollX(){ return scrollX; } public static synchronized int getCurrentScreen(){ return currentScreen; } } main.xml left_screen.xml, right_screen.xml and initial_screen.xml attrs.xml (in values folder) So, finally, that's it. The onDraw method still needs some modification. I'm unhappy with this solution so far, because it must be possible to use the onDraw method in the ViewGroup , I think. But I couldn't figure it out. Also, setting variables with static methods seems to be a dirty trick. Would be glad if someone could give me advice how to pass those events from the ViewFlipper to the parent MoveBackground class. Or how to include the MoveBackground drawing method into the ViewFlipper . I could integrate the ViewFlipper class into the MoveBackground class and do a addView(viewFlipper) programmatically. Than I would not need that static workaround anymore. :)
