[site]: stackoverflow
[post_id]: 5281473
[parent_id]: 4881175
[tags]: 
I solve this problem by inheriting NSURLCache. Firstly, create a inheritance of NSURLCache #import "VURLCache.h" #import @implementation VURLCache -(NSString*)mimeTypeForExtension:(NSString*)ext { NSAssert( ext, @"Extension cannot be nil" ); NSString* mimeType = nil; CFStringRef UTI = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (CFStringRef)ext, NULL); if( !UTI ) return nil; CFStringRef registeredType = UTTypeCopyPreferredTagWithClass(UTI, kUTTagClassMIMEType); if( !registeredType ) // check for edge case { if( [ext isEqualToString:@"m4v"] ) mimeType = @"video/x-m4v"; else if( [ext isEqualToString:@"m4p"] ) mimeType = @"audio/x-m4p"; // handle anything else here that you know is not registered } else { mimeType = NSMakeCollectable(registeredType); } CFRelease(UTI); return mimeType; } -(void)parseBundleURL:(NSURL*)url name:(NSString**)name ext:(NSString**)ext bundleDirectory:(NSString**)bundleDirectory { NSString* path = [url path]; NSUInteger nameStart = NSNotFound; // locate the last '/' NSRange pathStop = [path rangeOfString:@"/" options:NSBackwardsSearch]; if( 0 == pathStop.location ) { nameStart = 1; } else if ( NSNotFound != pathStop.location ) { // there is a path nameStart = pathStop.location+1; NSRange pathRange = NSMakeRange(0, nameStart); *bundleDirectory = [path substringWithRange:pathRange]; } NSRange fileRange = NSMakeRange(nameStart, path.length - nameStart); if( fileRange.length > 0 ) { NSRange extStop = [path rangeOfString:@"." options:0 range:fileRange]; if( NSNotFound != extStop.location ) { NSUInteger sep = extStop.location; NSRange nameRange = NSMakeRange( nameStart, sep - nameStart); *name = [path substringWithRange:nameRange]; NSRange extRange = NSMakeRange( sep+1, path.length -(sep+1)); *ext = [path substringWithRange:extRange]; } } } -(NSCachedURLResponse*)bundleResourceForRequest:(NSURLRequest *)request { NSURL* url = [request URL]; NSString* name = nil; NSString* ext = nil; NSString* bundleDirectory = nil; NSString* path = nil; [self parseBundleURL:url name:&name ext:&ext bundleDirectory:&bundleDirectory]; if( name && ext ) { NSBundle* bundle = [NSBundle mainBundle]; if( nil == bundleDirectory ) { path = [bundle pathForResource:name ofType:ext]; } else { path = [bundle pathForResource:name ofType:ext inDirectory:bundleDirectory]; } } NSCachedURLResponse* rep = nil; if( path ) { NSData* content = [NSData dataWithContentsOfFile:path]; NSString* mime = [self mimeTypeForExtension:ext]; NSString* encoding = nil; NSURLResponse* response = [[NSURLResponse alloc] initWithURL:request.URL MIMEType:mime expectedContentLength:[content length] textEncodingName:encoding]; rep = [[NSCachedURLResponse alloc] initWithResponse:response data:content]; } return rep; } #pragma mark NSURLCache -(NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request { NSURL* url = [request URL]; if( [[url absoluteString] hasPrefix:VBUNDLE_URL_PREFIX] ) { return [self bundleResourceForRequest:request]; } return [super cachedResponseForRequest: request]; } @end Then, replace the default NSURLCache in app delegate NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docDir = [paths objectAtIndex:0]; NSString *path = docDir; // the path to the cache file NSUInteger discCapacity = 0; NSUInteger memoryCapacity = 5120*1024; VURLCache *cache = [[VURLCache alloc] initWithMemoryCapacity:memoryCapacity diskCapacity:discCapacity diskPath:path]; [NSURLCache setSharedURLCache:cache]; [cache release]; Then, you could load file in your app bundle. For example, That will show your app icon. You could also load css with it.
