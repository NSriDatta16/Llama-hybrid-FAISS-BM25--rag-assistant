[site]: stackoverflow
[post_id]: 3261415
[parent_id]: 3261242
[tags]: 
I would look at this from a different perspective. If the data is stored as float , then that is all the precision it will ever have. There is no point in converting to double until the rules of floating point arithmetic require it. So I would allocate a buffer for the 500 (or whatever) float s, and read them from the data file with one suitable call to fread() : float *databuffer; //... databuffer = malloc(500 * sizeof(float)); fread(databuffer, sizeof(Float), 500, f); Later, use the data in whatever math it needs to participate in. It will be promoted to double if required. Don't forget to eventually free the buffer after it is no longer needed. If your results really do have all the precision of a double , then use a fresh buffer of double s to hold them. However, if they are to be written back to file as float , then you will eventually need to put them into a buffer of float s. Note that reading and writing files for interchange often needs to be considered a separate problem from efficient storage and usage of data in memory. It is often necessary to read a file and process each individual value in some way. For example, a portable program might be required to handle data written by a system using a different byte order. Less frequently today, you might find that even the layout of the bits in a float differs between systems. In general, this problem is often best solved by deferring to a library implementing a standard such as XDR (defined by RFC 4506 ) that was designed to deal with binary portability.
