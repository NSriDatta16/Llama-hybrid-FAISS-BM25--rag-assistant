[site]: stackoverflow
[post_id]: 1125317
[parent_id]: 1125304
[tags]: 
It's done so that addition doesn't need to have any special logic for dealing with negative numbers. Check out the article on Wikipedia . Say you have two numbers, 2 and -1. In your "intuitive" way of representing numbers, they would be 0010 and 1001 , respectively (I'm sticking to 4 bits for size). In the two's complement way, they are 0010 and 1111 . Now, let's say I want to add them. Two's complement addition is very simple. You add numbers normally and any carry bit at the end is discarded. So they're added as follows: 0010 + 1111 =10001 = 0001 (discard the carry) 0001 is 1, which is the expected result of "2+(-1)". But in your "intuitive" method, adding is more complicated: 0010 + 1001 = 1011 Which is -3, right? Simple addition doesn't work in this case. You need to note that one of the numbers is negative and use a different algorithm if that's the case. For this "intuitive" storage method, subtraction is a different operation than addition, requiring additional checks on the numbers before they can be added. Since you want the most basic operations (addition, subtraction, etc) to be as fast as possible, you need to store numbers in a way that lets you use the simplest algorithms possible. Additionally, in the "intuitive" storage method, there are two zeroes: 0000 "zero" 1000 "negative zero" Which are intuitively the same number but have two different values when stored. Every application will need to take extra steps to make sure that non-zero values are also not negative zero. There's another bonus with storing ints this way, and that's when you need to extend the width of the register the value is being stored in. With two's complement, storing a 4-bit number in an 8-bit register is a matter of repeating its most significant bit: 0001 (one, in four bits) 00000001 (one, in eight bits) 1110 (negative two, in four bits) 11111110 (negative two, in eight bits) It's just a matter of looking at the sign bit of the smaller word and repeating it until it pads the width of the bigger word. With your method you would need to clear the existing bit, which is an extra operation in addition to padding: 0001 (one, in four bits) 00000001 (one, in eight bits) 1010 (negative two, in four bits) 10000010 (negative two, in eight bits) You still need to set those extra 4 bits in both cases, but in the "intuitive" case you need to clear the 5th bit as well. It's one tiny extra step in one of the most fundamental and common operations present in every application.
