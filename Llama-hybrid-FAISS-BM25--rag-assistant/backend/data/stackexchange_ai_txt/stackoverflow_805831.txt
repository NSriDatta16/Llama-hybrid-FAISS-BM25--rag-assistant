[site]: stackoverflow
[post_id]: 805831
[parent_id]: 805814
[tags]: 
The usual recipe is to call it setting the size to zero and it is guaranteed to fail and provide the size needed to allocate sufficient buffer. Allocate a buffer (don't forget room for nul-termination) and call it a second time. In a lot of cases MAX_PATH is sufficient because many of the file systems restrict the total length of a path name. However, it is possible to construct legal and useful file names that exceed MAX_PATH , so it is probably good advice to query for the required buffer. Don't forget to eventually return the buffer from the allocator that provided it. Edit: Francis points out in a comment that the usual recipe doesn't work for GetModuleFileName() . Unfortunately, Francis is absolutely right on that point, and my only excuse is that I didn't go look it up to verify before providing a "usual" solution. I don't know what the author of that API was thinking, except that it is possible that when it was introduced, MAX_PATH really was the largest possible path, making the correct recipe easy. Simply do all file name manipulation in a buffer of length no less than MAX_PATH characters. Oh, yeah, don't forget that path names since 1995 or so allow Unicode characters. Because Unicode takes more room, any path name can be preceeded by \\?\ to explicitly request that the MAX_PATH restriction on its byte length be dropped for that name. This complicates the question. MSDN has this to say about path length in the article titled File Names, Paths, and Namespaces : Maximum Path Length In the Windows API (with some exceptions discussed in the following paragraphs), the maximum length for a path is MAX_PATH , which is defined as 260 characters. A local path is structured in the following order: drive letter, colon, backslash, components separated by backslashes, and a terminating null character. For example, the maximum path on drive D is " D:\ " where " " represents the invisible terminating null character for the current system codepage. (The characters > are used here for visual clarity and cannot be part of a valid path string.) Note File I/O functions in the Windows API convert " / " to " \ " as part of converting the name to an NT-style name, except when using the " \\?\ " prefix as detailed in the following sections. The Windows API has many functions that also have Unicode versions to permit an extended-length path for a maximum total path length of 32,767 characters. This type of path is composed of components separated by backslashes, each up to the value returned in the lpMaximumComponentLength parameter of the GetVolumeInformation function. To specify an extended-length path, use the " \\?\ " prefix. For example, " \\?\D:\ ". (The characters > are used here for visual clarity and cannot be part of a valid path string.) Note The maximum path of 32,767 characters is approximate, because the " \\?\ " prefix may be expanded to a longer string by the system at run time, and this expansion applies to the total length. The " \\?\ " prefix can also be used with paths constructed according to the universal naming convention (UNC). To specify such a path using UNC, use the " \\?\UNC\ " prefix. For example, " \\?\UNC\server\share ", where "server" is the name of the machine and "share" is the name of the shared folder. These prefixes are not used as part of the path itself. They indicate that the path should be passed to the system with minimal modification, which means that you cannot use forward slashes to represent path separators, or a period to represent the current directory. Also, you cannot use the " \\?\ " prefix with a relative path, therefore relative paths are limited to MAX_PATH characters as previously stated for paths not using the " \\?\ " prefix. When using an API to create a directory, the specified path cannot be so long that you cannot append an 8.3 file name (that is, the directory name cannot exceed MAX_PATH minus 12). The shell and the file system have different requirements. It is possible to create a path with the Windows API that the shell user interface might not be able to handle. So an easy answer would be to allocate a buffer of size MAX_PATH , retrieve the name and check for errors. If it fit, you are done. Otherwise, if it begins with " \\?\ ", get a buffer of size 64KB or so (the phrase "maximum path of 32,767 characters is approximate" above is a tad troubling here so I'm leaving some details for further study) and try again. Overflowing MAX_PATH but not beginning with " \\?\ " appears to be a "can't happen" case. Again, what to do then is a detail you'll have to deal with. There may also be some confusion over what the path length limit is for a network name which begins " \\Server\Share\ ", not to mention names from the kernel object name space which begin with " \\.\ ". The above article does not say, and I'm not certain about whether this API could return such a path.
