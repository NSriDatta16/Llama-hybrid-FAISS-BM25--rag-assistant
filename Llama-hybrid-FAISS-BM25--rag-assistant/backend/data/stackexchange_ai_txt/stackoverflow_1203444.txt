[site]: stackoverflow
[post_id]: 1203444
[parent_id]: 1203248
[tags]: 
If you want to draw the tree with a minimum of wasted space and short connections, then you're in for a computationally expensive solution. It will be hard to get this to be realtime on a tree of decent size, not to mention that making small changes to the tree might result in a radically different equilibrium. Another approach would be to abandon the physical simulation and just build it iteratively. I've done something similar last week, but my trees are probably a lot less involved than yours. For this tree-layout, each node object has to store an angle and an offset. These two numbers control where on the graphics surface they end up. Here is my basic algorithm: 1) recurse over your entire tree-data and find all the Leaf nodes. 2) while you're doing this, be sure to measure the length of each branching structure, so you know which is the longest. 3) once you have all your leaf nodes, distribute them equally over a concentric circle. You can either use the entire circle, or only some part of the angle domain. 4) once all Leaf nodes have been solved, you recurse again over the tree, going from the outside in. Each node you encounter that is not a leaf node is in need of layout. Essentially, every node from here on has an angle which is the average of all it's child nodes, and the offset is the graph_radius * (depth_of_node / maximum_depth) I found this gives me a very decent and humanly readable distribution, albeit not a very efficient one in terms of screen usage. I uploaded an animation of my tree-display here: GIF anim
