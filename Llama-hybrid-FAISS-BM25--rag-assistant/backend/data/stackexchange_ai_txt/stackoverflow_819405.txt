[site]: stackoverflow
[post_id]: 819405
[parent_id]: 818299
[tags]: 
Re the enum edit (added as a second answer to keep things simple)... Firstly - is there a direct 1:1 mapping between the enum and the values? For example, if Basic is 7 and Administrator is 12, then: enum AccessLevels { Basic = 7, Administrator = 12 } Then change the type of that property in the dbml (via the designer) from int to your (fully-qualified) enum: Entities.AccessLevel . LINQ-to-SQL supports enums either as direct integer mappings, or as direct string mappings. If this isn't possible (more complex scenerios), you can isolate the storage (int) and object-oriented (enum) models; rename the property to AccessLevelStorage (or anything else you like), and in a partial class do the mapping: partial class User { public AccessLevel AccessLevel { get { switch(AccessLevelStorage) { case 1: return AccessLevelStorage.Foo; ... etc default: ...throw an exception? } } set { switch(value) { case AccessLevel.Foo: AccessLevelStorage = 1; break; ...etc default: ...throw an exception? } } } The only caveat here is that LINQ queries will only work against the storage properties - not the custom mapped property. If you do your queries at the level that declares the context, you can change the access of the storage property to internal - but if you do queries outside of this assembly you'll need to leave is public. You might want to add [Browsable(false)] to stop it appearing in UI models, but that is about it.
