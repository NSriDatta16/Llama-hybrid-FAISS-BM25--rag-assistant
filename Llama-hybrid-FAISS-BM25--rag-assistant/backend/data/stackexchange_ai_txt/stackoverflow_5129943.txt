[site]: stackoverflow
[post_id]: 5129943
[parent_id]: 
[tags]: 
Tightly coupled parallel class hierarchies in C++

For context, I'm working on a C++ artificial-life system involving agents controlled by recurrent neural networks, but the details aren't important. I'm facing a need to keep two object hierarchies for the "brain" and "body" of my agents separate. I want a variety of different brain and body types that can be coupled to each other at run-time. I need to do this to avoid a combinatorial explosion caused by the multiplicative enumeration of the separate concerns of how a body works and how a brain works . For example, there are many topologies and styles of recurrent neural network with a variety of different transfer functions and input/output conventions. These details don't depend on how the body of the agent works, however, as long as sensory inputs can be encoded into neural activity and then decoded into actions. Here is a simple class hierarchy that illustrates the problem and one potential solution: // Classes we are going to declare class Image2D; // fake class Angle2D; // fake class Brain; class Body; class BodyWithEyes; class BrainWithVisualCortex; // Brain and Body base classes know about their parallels class Brain { public: Body* base_body; Body* body() { return base_body; } virtual Brain* copy() { return 0; } // fake // ...etc }; class Body { public: Brain* base_brain; Brain* brain() { return base_brain; } virtual Body* reproduce() { return 0; } // fake // ...etc }; // Now introduce two strongly coupled derived classes, with overloaded access // methods to each-other that return the parallel derived type class BrainWithVisualCortex : public Brain { public: BodyWithEyes* body(); virtual void look_for_snakes(); virtual Angle2D* where_to_look_next() { return 0; } // fake }; class BodyWithEyes : public Body { public: BrainWithVisualCortex* brain(); virtual void swivel_eyeballs(); virtual Image2D* get_image() { return 0; } // fake }; // Member functions of these derived classes void BrainWithVisualCortex::look_for_snakes() { Image2D* image = body()->get_image(); // ... find snakes and respond } void BodyWithEyes::swivel_eyeballs() { Angle2D* next = brain()->where_to_look_next(); // ... move muscles to achieve the brain's desired gaze } // Sugar to allow derived parallel classes to refer to each-other BodyWithEyes* BrainWithVisualCortex::body() { return dynamic_cast (base_body); } BrainWithVisualCortex* BodyWithEyes::brain() { return dynamic_cast (base_brain); } // pretty vacuous test int main() { BodyWithEyes* body = new BodyWithEyes; BrainWithVisualCortex* brain = new BrainWithVisualCortex; body->base_brain = brain; brain->base_body = body; brain->look_for_snakes(); body->swivel_eyeballs(); } The trouble with this approach is that it's clunky and not particularly type-safe. It does have the benefit that the body() and brain() member functions provide a bit of sugar for derived classes to refer to their partners. Does anyone know of a better way of accomplishing this tight coupling between 'parallel' hierarchies of classes? Does this pattern come up often enough to have warranted a well-known general solution? A perusal of the usual sources didn't reveal any established patterns that match this problem. Any help appreciated!
