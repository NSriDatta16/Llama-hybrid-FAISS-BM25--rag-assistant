[site]: crossvalidated
[post_id]: 525557
[parent_id]: 
[tags]: 
State space model to invert moving average of AR1 process whose mean temporarily jumps up once

This is a follow up query of this question . Here is the problem statement: I have an AR1 process say x[t] whose mean jumps up in a given time period. ie. $x[t]-\mu[t] = \phi (x[t-1] -\mu[t-1]) + \epsilon_x[t]$ For the sake of an example, let's say t=1,...,100. Then $\mu[t] = \mu_0$ in the period t=1,...,60 and t=81,...,100. and $\mu[t] = \mu_0 + \mu_1$ in the period t=61,...,80. Further, y[t] is the 4 period (trailing) moving average of x[t] which is measured with noise. ie. $ y[t] = 1/4 *(x[t] + x[t-1] + x[t-2] + x[t-3]) + \epsilon_y[t] $ The problem is to go from the observed y[t] to x[t] and recover $\phi,\mu_0,\mu_1,Var(\epsilon_x), Var(\epsilon_y)$ I can formulate this as a time varying dynamic linear model in 2 ways. Attempt 1: I model this problem as:- $x[t]=\mu_0 (1 -\phi) + \phi x[t-1] + \epsilon_x[t]$ for $t$ in $\in$ [1,60],[81,100] and $x[t]=( \mu_0 + \mu_1 )(1 -\phi) + \phi x[t-1] + \epsilon_x[t]$ for $t$ in $\in$ [61,80] Note : $x[t]-\mu[t] = \phi (x[t-1] -\mu[t-1]) + \epsilon_x[t]$ is true for all points except t = 61, 81. That is why I think this approach is wrong. Am I right in thinking so? Lets examine the model at t=61/81. At t=61, we have:- $x[61] - \mu_0 - \mu_1 = \phi( x[60] - \mu_0 - \mu_1) + \epsilon_x[t]$ The $\mu_1$ term should not be there in the right hand side above. That is why it is incorrect. At t=81, we have:- $x[81] - \mu_0 = \phi( x[80] - \mu_0) + \epsilon_x[t]$ The $\mu_1$ is missing on the right hand side. That is why this is incorrect. I have still programmed this solution. In the language of the package dlm in R, we have to, pen down FF,GG,V and W. The state vector is : $ \begin{bmatrix} x[t] \\ x[t-1] \\ x[t-2] \\ x[t-3] \\ \mu_0 \\ \mu_1 \end{bmatrix} $ The state evolution matrix is : $ GG = \begin{bmatrix} \phi && 0 && 0 && 0 && (1-\phi) && (1-\phi) I_t \\ 1 && 0 && 0 && 0 && 0 && 0 \\ 0 && 1 && 0 && 0 && 0 && 0 \\ 0 && 0 && 1 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 1 && 0 \\ 0 && 0 && 0 && 0 && 0 && 1 \end{bmatrix} $ where $ I_t $ = 1 in [61,80] and 0 outside. That is why I need a time varying dlm. The GG is different inside the time interval [60,80] and outside it. $ W = \begin{bmatrix} \sigma_x^2 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ \end{bmatrix} $ where $ Var(\epsilon_x) = \sigma_x^2 $ $ JGG = \begin{bmatrix} 0 && 0 && 0 && 0 && 0 && 1 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ \end{bmatrix} $ $ X = (1-\phi) Indicator_t $ where $Indicator_t$ = 1 $\in$ [61,80] and 0 zero outside and Indicator_t has 100 rows and 1 column. In words, I need JGG and X to implement the time varying nature of GG in the language of dlm. JGG[1,6]=1 means that the (1,6) element of GG is time varying and to be found in the 1st column of X. I use it to tell the software that $\mu_1$ kicks in only in a certain time period $I_t / Indicator_t$ . $ FF = \begin{bmatrix} .25 && .25 && .25 && .25 && 0 && 0 \end{bmatrix} $ $ V= \begin{bmatrix} \sigma_y^2 \end{bmatrix} $ where $ Var(\epsilon_y) = \sigma_y^2 $ Here is the code which implements this. library(dlm) library(zoo) # Set parameter restrictions # parm[1] = Phi, the AR1 parameter of the x series.I have constrained this to be between -1 and 1. # parm[2] = the error variance in the x series. I have constrained this to be positive. # parm[3] = the error variance in the y series. I have constrained this to be positive. parm_rest $par[1])/(1+exp(fit1$ par[1]))^2 dg2 $par[2]) dg3 par[3]) dg Notice: I had set $\phi$ =.4 and it is NOT covered in the computed confidence interval. > coef + 2 * coef.se Phi e_x_variance e_y_variance 0.20322352 4.35943466 0.01695791 > > coef - 2 * coef.se Phi e_x_variance e_y_variance -0.0017584815 2.2680911327 0.0003373454 > Attempt 2: Outline: I make $\mu[t]=\mu[t-1]$ a state variable with zero variance, except at t=61 and t=81, where the variance is allowed to be huge ( but equal at both t=61/81). This will make $\mu$ constant except that it will jump up at t=61 and jump down to the same level at t=81. Is this the right approach? Is there any other way of modelling this problem? This is inspired by: the example on Page 8 of this vignette The state vector is : $\theta[t+1]$ = $ \begin{bmatrix} x[t] \\ x[t-1] \\ x[t-2] \\ x[t-3] \\ \mu[t+1] \\ \mu[t] \end{bmatrix} $ The matrix $GG$ is then: $ GG = \begin{bmatrix} \phi && 0 && 0 && 0 && 1 && -\phi \\ 1 && 0 && 0 && 0 && 0 && 0 \\ 0 && 1 && 0 && 0 && 0 && 0 \\ 0 && 0 && 1 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 1 && 0 \\ 0 && 0 && 0 && 0 && 1 && 0 \end{bmatrix} $ $ W = \begin{bmatrix} \epsilon_x[t] && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \end{bmatrix} $ $ JW = \begin{bmatrix} 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \\ 0 && 0 && 0 && 0 && 1 && 0 \\ 0 && 0 && 0 && 0 && 0 && 0 \end{bmatrix} $ and $ X = \sigma_{\mu}^2 * I_t$ where $I_t = 1$ for t $\in$ [61,81] and 0 otherwise. It is a matrix with 100 rows and 1 column. Let $ FF = \begin{bmatrix} .25 \\ .25 \\ .25 \\ .25 \\ 0 \\ 0 \end{bmatrix} $ The measurement equation is :- $ z[t+1] = FF * \theta[t+1] = .25 * (x[t] + x[t-1] + x[t-2] + x[t-3]) + \epsilon_z[t+1]$ $ V =$ Variance in the measurement equation. = $Var(\epsilon_z) $ $z[t]$ seems to be a lagged version of $y[t]$ . I am not sure. $y[t] = .25 ( x[t] + x[t-1] + x[t-2] + x[t-3] ) + \epsilon_y[t]$ . Can I say : Let $\epsilon_y[t] = \epsilon_z[t+1]$ and hence, $y[t] = z[t+1]$ Would that be correct? Here is a program that implements the above,it gives me an error,I do not know how to fix this. Can someone please help me ? library(dlm) library(zoo) # Set parameter restrictions # parm[1] = Phi, the AR1 parameter of the x series.I have constrained this to be between -1 and 1. # parm[2] = the error variance in the x series. I have constrained this to be positive. # parm[3] = the error variance in the z series. I have constrained this to be positive. # parm[4] = the variance of mu at t=61 and t=81. parm_rest $par[1])/(1+exp(fit1$ par[1]))^2 dg2 $par[2]) dg3 par[3]) dg Here is where the code breaks: > # estimate parameters > fit1 ```
