[site]: stackoverflow
[post_id]: 2597163
[parent_id]: 2596448
[tags]: 
As others have pointed out, you can't return a pointer to an object with automatic storage duration - when eout goes out of scope, it no longer exists. GCC actually warns you about this: ether_ntoa.c: In function ‘ether_ntoa’: ether_ntoa.c:26: warning: function returns address of local variable The usual way to achieve the desired result is to have the caller responsible for allocating the destination. For example: int ether_ntoa(unsigned char etheraddr[ETHER_ADDR_LEN], char *dest, size_t len) { return snprintf(dest, len, "%02x:%02x:%02x:%02x:%02x:%02x", (unsigned)etheraddr[0], (unsigned)etheraddr[1], (unsigned)etheraddr[2], (unsigned)etheraddr[3], (unsigned)etheraddr[4], (unsigned)etheraddr[5]); } (Note also that your handcoded conversion routine can be replaced with a simple snprintf() call). You'd call it like so: char eout[32]; ether_ntoa(etheraddr, eout, sizeof eout); /* Converted address is now in eout */ The ether_ntoa() function on Linux uses a different approach - it declares the buffer in the function as static . If you did that, then your eout would live for the life of the program, so you can return a pointer to it. The downside is that there is only one eout - each time you call ether_ntoa , it will overwrite the previous one.
