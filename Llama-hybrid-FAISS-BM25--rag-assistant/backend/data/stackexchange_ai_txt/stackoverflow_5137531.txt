[site]: stackoverflow
[post_id]: 5137531
[parent_id]: 5137436
[tags]: 
One option you may want to explore would be to use a decision tree . The idea would be something like this. Pick some arbitrary string, then split all of your sets into two groups - groups containing that string and groups not containing that string. Then, recursively repeat this procedure on both groups and construct a tree from all of the decisions you've made. For example, let's introduce a shorthand for your notation: A = Aero R = Aerora F = Fire T = Thunder W = Water B = Blizzard Then you could build a tree like this: start ──▶ A? ── NO ──▶ R? ── YES ──▶ B? ── YES ──▶ "hailstorm" │ └─── YES ──▶ F? ── YES ──▶ T? ── YES ──▶ "firestorm" │ │ │ └───── NO ──▶ "searing wind" │ └───── NO ──▶ T? ── YES ──▶ "storm" │ └───── B? ── YES ──▶ "snowstorm" Once you have a tree like this, you could store your attributes as a set of strings and then look up all matches as follows. Starting from the root of the tree, look at the string indicated by the given node. If that string is contained in your set of strings, then recursively continue down the YES branch and find all matches in that part of the tree. Then, regardless of whether you looked down that branch, explore down the NO branch to get all other strings that could match your query. The advantage of this approach is that, assuming you have a small number of strings as keywords, the depth of the tree can be very small - at most O(k) for k keywords - and so in the best case your search will take as little as O(k) time. In the worst case, you just explore the entire tree, which takes time O(n). Moreover, using techniques from machine learning, it's possible to construct a very good tree structure that will have a solid tradeoff between size and lookup speed. Hope this helps!
