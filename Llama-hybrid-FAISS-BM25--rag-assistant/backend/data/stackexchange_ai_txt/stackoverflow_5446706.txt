[site]: stackoverflow
[post_id]: 5446706
[parent_id]: 5397785
[tags]: 
A safe implementation is the following: let rot1 l = let rec aux acc = function [] -> [] | [x] -> x :: List.rev acc | x :: l -> aux (x :: acc) l in aux [] l It is safe in the sense that passing the empty list returns the empty list instead of raising an exception. Note that I strongly discourage the use of List.hd and List.tl because they may fail, with a generic error message. Also, the recursive call to aux is a tail call (last thing to do before returning). The OCaml compilers will detect this and avoid growing the stack with each function call (and possibly raise an exception or crash). This is something to be aware of when dealing with long lists and recursive functions. In order to do this operation efficiently, i.e. in O(1) rather than O(length), you cannot use a regular list. You can use the Queue module from the standard library or implementations of doubly-linked lists provided by third parties. Here is an example using the Queue module: let rotate_queue q = if not (Queue.is_empty q) then let x = Queue.take q in Queue.add x q # let q = Queue.create ();; val q : '_a Queue.t = # Queue.add 1 q;; - : unit = () # Queue.add 2 q;; - : unit = () # Queue.add 3 q;; - : unit = () # Queue.iter print_int q;; 123- : unit = () # rotate_queue q;; - : unit = () # Queue.iter print_int q;; 231- : unit = () #
