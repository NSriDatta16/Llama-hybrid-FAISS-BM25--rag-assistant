[site]: stackoverflow
[post_id]: 5065318
[parent_id]: 
[tags]: 
end pointer problem of a circular buffer

I'm using Visual c++. I'm trying to implement a circular buffer, this CB must handle a specific type of data...in fact, it's a structure data where we have some kind of raw data to be stored in a char type and a date associated to that data...this has been implemented using a strucuture. here is the code for more details: #include #include #include //data=date_label+raw_data typedef struct DataFragment { char data[4]; clock_t date; }DataFragment; typedef struct CircularBuffer { DataFragment *buffer; // data buffer DataFragment *buffer_end; // end of data buffer size_t capacity; // maximum number of items in the buffer size_t count; // number of items in the buffer size_t sz; // size of each item in the buffer DataFragment *head; // pointer to head DataFragment *tail; // pointer to tail } CircularBuffer; void cb_init(struct CircularBuffer *cb, size_t capacity, size_t sz) { if((cb->buffer = (DataFragment*) malloc(capacity * sz))!=NULL) puts("success alocation"); //if(cb->buffer == NULL) //handle error cb->buffer_end = (DataFragment *)cb->buffer + (capacity-1)*sz; cb->capacity = capacity; cb->count = 0; cb->sz = sz; cb->head = cb->buffer; cb->tail = cb->buffer; } void cb_free(struct CircularBuffer *cb) { free(cb->buffer); // clear out other fields too, just to be safe } void cb_push_back(struct CircularBuffer *cb, const DataFragment *item) { //if(cb->count == cb->capacity) //handle error when it's full memcpy(cb->head->data, item->data,4); cb->head->date=item->date; cb->head = (DataFragment*)cb->head + cb->sz; if(cb->head == cb->buffer_end) cb->head = cb->buffer; cb->count++; } void cb_pop_front(struct CircularBuffer *cb, DataFragment *item) { //if(cb->count == 0) //handle error memcpy(item->data, cb->tail->data,4); item->date=cb->tail->date; cb->tail = (DataFragment*)cb->tail + cb->sz; if(cb->tail == cb->buffer_end) cb->tail = cb->buffer; cb->count--; } int main(int argc, char *argv[]) { struct CircularBuffer pbuf; pbuf.buffer=NULL; pbuf.buffer_end=NULL; pbuf.capacity=0; pbuf.count=0; pbuf.head=NULL; pbuf.sz=0; pbuf.tail=NULL; struct CircularBuffer *buf= &pbuf; size_t sizz = sizeof(DataFragment); //initialisation of the circlar buffer to a total bytes //of capacity*sizz=100*sizeof(struct DataFragment) cb_init(buf,100,sizz); //temporary container of data DataFragment temp,temp2; for(int i=0;i When I compile the code, everything is fine, but when I debug, I noticed a problem with the buffer_end pointer, it says bad_pointer....this happens if the capacity is greater than 56...I don't know why the pointer can't point to end of the buffer.But if the capacity is less than 56 the pointer points exactly on the end of the buffer If anyone knows why this happens like this, and how to fix it, please help me.. thanks in advance
