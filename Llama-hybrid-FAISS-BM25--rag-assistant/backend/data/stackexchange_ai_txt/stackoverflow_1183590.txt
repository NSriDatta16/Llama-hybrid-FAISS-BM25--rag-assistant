[site]: stackoverflow
[post_id]: 1183590
[parent_id]: 
[tags]: 
XAML - How Do I Bind an Element of a Derived to an Element of the Base ?

How do I bind an element of a derived to an element of the base ? I have defined a UserControl called Tile as my base class. This would be an abstract base class, if XAML wouldn't balk when I tried to instantiate an object derived from it ... Anyway, so far Tile only contains a single dependency property: OuterShape. It is a System.Windows.Shapes.Shape object (also abstract). Thus: all tiles will have some kind of visual shape associated with them, for rendering. But there are many different types of Tiles --- some with System.Windows.Shapes.Paths, some with System.Windows.Shapes.Polygons, etc. So now I am working on the first derived UserControl: PolyTile. As the name implies, this is a Tile that uses a System.Windows.Shapes.Polygon as its "OuterShape" property. The problem I am running into is that I can't figure out how to successfully bind the XAML element to the Shape property in the base class. /************ ** Tile.cs ** ************/ // This class contains a generic shape, and that's all. // This class does NOT have a XAML file to go with it. It is purely code implemented. public class Tile : System.Windows.Controls.UserControl { public static readonly System.Windows.DependencyProperty OuterShapeProperty = System.Windows.DependencyProperty.Register( "OuterShape", typeof(System.Windows.Shapes.Shape), typeof(Tile)); public System.Windows.Shapes.Shape OuterShape { get { return (System.Windows.Shapes.Shape)GetValue(OuterShapeProperty); } set { SetValue(OuterShapeProperty, (System.Windows.Shapes.Shape)value); } } } ........................ element, OuterShape will show up on the screen as a --> ........................ /**************** ** PolyTile.cs ** ****************/ // This class encapsulates a tile that is in the shape of a specified element. /// /// Interaction logic for PolyTile.xaml /// public partial class PolyTile : Tile // Derived from Tile { public PolyTile() { InitializeComponent(); System.Windows.Data.BindingExpressionBase BindExp; PolyConverter polyConverter = new PolyConverter(); System.Windows.Data.Binding PolyBinding = new System.Windows.Data.Binding("OuterPoly"); PolyBinding.Source = __PolyTile__; PolyBinding.Mode = System.Windows.Data.BindingMode.OneWayToSource; PolyBinding.Converter = polyConverter; BindExp = __PolyTile__.SetBinding(Tile.OuterShapeProperty, PolyBinding); } // The framework won't convert a base object into a derived object without an explicit cast ... // ... in this case, that means I have to make a custom DataConverter. [System.Windows.Data.ValueConversion(typeof(System.Windows.Shapes.Polygon), typeof(System.Windows.Shapes.Shape))] protected class PolyConverter : System.Windows.Data.IValueConverter { public object Convert(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { return value; } // OneWayToSource binding: Thus the Convert method is never used. // Rather, ConverBack is used to cast the base into a derived public object ConvertBack(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { if (value.GetType() == typeof(System.Windows.Shapes.Polygon)) return value; else return System.Windows.DependencyProperty.UnsetValue; } } } I don't see any possible way to set this binding in XAML. (Although I don't understand DataContexts well enough to say that I've thought of everything ...) Therefore, I tried setting the binding manually in the back-code. I've tried many different ways of organizing the binding path and source and target elements. Every time I get a fatal exception or a PathError or an UpdateSourceError something similar. Does anyone know what I am doing wrong? Any advice is greatly appreciated!
