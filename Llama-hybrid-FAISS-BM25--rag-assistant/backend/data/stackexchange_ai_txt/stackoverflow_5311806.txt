[site]: stackoverflow
[post_id]: 5311806
[parent_id]: 5311445
[tags]: 
If you are happy enough to: work only on POSIX You know the pattern you are looking for You can use the glob() function in POSIX to get the list. You can then use std::max with a custom comparison on the result set with your iterator range being globres.gl_pathv[0], globres.gl_pathv[globres.gl_pathc] and a comparison being something like: bool strless(const char* str1, const char* str2 ) { return strcmp( str1, str2 ) although there is most likely something already that does that The start of the "man" page for glob: #include int glob(const char *pattern, int flags, int (*errfunc) (const char *epath, int eerrno), glob_t *pglob); void globfree(glob_t *pglob); DESCRIPTION The glob() function searches for all the pathnames matching pattern according to the rules used by the shell (see glob (7)). No tilde expansion or parameter substitution is done; if you want these, use wordexp (3). The globfree() function frees the dynamically allocated storage from an earlier call to glob() . The results of a glob() call are stored in the structure pointed to by pglob. This structure is of type glob_t (declared in ) and includes the following elements defined by POSIX.2 (more may be present as an extension): typedef struct { size_t gl_pathc; /* Count of paths matched so far */ char **gl_pathv; /* List of matched pathnames. */ size_t gl_offs; /* Slots to reserve in gl_pathv. */ } glob_t; There was a discussion in October 2004 about bringing glob into boost I don't think it ever got implemented:
