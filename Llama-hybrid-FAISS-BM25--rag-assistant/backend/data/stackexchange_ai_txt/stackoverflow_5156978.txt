[site]: stackoverflow
[post_id]: 5156978
[parent_id]: 4753681
[tags]: 
In case someone is wondering how to do it on their own, it's actually quite simple. Here's the code from my app: class ImageView : public QGraphicsView { public: ImageView(QWidget *parent); ~ImageView(); private: virtual void mouseMoveEvent(QMouseEvent *event); virtual void mousePressEvent(QMouseEvent *event); virtual void mouseReleaseEvent(QMouseEvent *event); bool _pan; int _panStartX, _panStartY; }; You need to store the start position of the drag, for example like this (I used the right button): void ImageView::mousePressEvent(QMouseEvent *event) { if (event->button() == Qt::RightButton) { _pan = true; _panStartX = event->x(); _panStartY = event->y(); setCursor(Qt::ClosedHandCursor); event->accept(); return; } event->ignore(); } Also, you need to clear the flag and restore the cursor once the button is released: void ImageView::mouseReleaseEvent(QMouseEvent *event) { if (event->button() == Qt::RightButton) { _pan = false; setCursor(Qt::ArrowCursor); event->accept(); return; } event->ignore(); } To actually manage the drag, you need to override the mouse move event. QGraphicsView inherits a QAbstractScrollArea, and its scrollbars are easily accessible. You also need to update the pan position: void ImageView::mouseMoveEvent(QMouseEvent *event) { if (_pan) { horizontalScrollBar()->setValue(horizontalScrollBar()->value() - (event->x() - _panStartX)); verticalScrollBar()->setValue(verticalScrollBar()->value() - (event->y() - _panStartY)); _panStartX = event->x(); _panStartY = event->y(); event->accept(); return; } event->ignore(); }
