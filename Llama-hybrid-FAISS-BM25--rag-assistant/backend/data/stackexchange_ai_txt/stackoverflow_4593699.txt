[site]: stackoverflow
[post_id]: 4593699
[parent_id]: 
[tags]: 
UIPickerView crashing when switching segemented control

I have four NSDictionaries that I would like to use to populate a pickerview depending on a segemented control. With the code I have, the first segmented control/pickerview works fine but when I switch to the second segment the picker view only loads part of the second dictionary, that is it loads the same number of rows as it counted in the first dictionary. When I change the segmented control to the third or fourth segment it simply crashes with a sigabrt error indicating that it cannot index item43 when only 27 exist. This I suspect stems from a UItextfield population based on the upickerview row and object. I think the problem is with the way I have the data source and delegate set up. #pragma mark - #pragma mark UIPickerViewDelegate - (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { if ([wine selectedSegmentIndex] == 0) { return [robskeys objectAtIndex:row]; } if ([wine selectedSegmentIndex] == 1) { return [esabskeys objectAtIndex:row]; } if ([wine selectedSegmentIndex] == 2) { return [lebskeys objectAtIndex:row]; } else if ([wine selectedSegmentIndex] == 3) { return [sbskeys objectAtIndex:row]; } return @"Unknown title"; } #pragma mark - #pragma mark UIPickerViewDataSource - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView { return 1; } - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { if ([wine selectedSegmentIndex] == 0) { return robskeys.count; } if ([wine selectedSegmentIndex] == 1) { return esabskeys.count; } if ([wine selectedSegmentIndex] == 2) { return lebskeys.count; } else if ([wine selectedSegmentIndex] == 3) { return sbskeys.count; } return 1; } #pragma mark - Any help would be much appreciated Thank you UPDATE Using the following when the segmentedcontrol is changed works. Does anyone see any problems in alloc, init, release the same picker view in viewDidLoad and in this IBAction. As you may have guessed the UItextfield winespec calls the coPicker not a keypad. -(IBAction)ValueChanged:(id)sender { [winespec resignFirstResponder]; UIPickerView *coPicker = [[UIPickerView alloc] initWithFrame:CGRectZero]; coPicker.tag = kCountryPickerTag; coPicker.delegate = self; coPicker.dataSource = self; [coPicker setShowsSelectionIndicator:YES]; winespec.inputView = countryPicker; [winespec becomeFirstResponder]; [coPicker release]; }
