[site]: stackoverflow
[post_id]: 3510850
[parent_id]: 3510673
[tags]: 
In bash , using only the basic tools listed in your question (1) , you should be able to do: kill $(ps aux | grep '[p]ython csp_build.py' | awk '{print $2}') Details on its workings are as follows: The ps gives you the list of all the processes. The grep filters that based on your search string, [p] is a trick to stop you picking up the actual grep process itself. The awk just gives you the second field of each line, which is the PID. The $(x) construct means to execute x then take its output and put it on the command line. The output of that ps pipeline inside that construct above is the list of process IDs so you end up with a command like kill 1234 1122 7654 . Here's a transcript showing it in action: pax> sleep 3600 & [1] 2225 pax> sleep 3600 & [2] 2226 pax> sleep 3600 & [3] 2227 pax> sleep 3600 & [4] 2228 pax> sleep 3600 & [5] 2229 pax> kill $(ps aux | grep '[s]leep' | awk '{print $2}') [5]+ Terminated sleep 3600 [1] Terminated sleep 3600 [2] Terminated sleep 3600 [3]- Terminated sleep 3600 [4]+ Terminated sleep 3600 and you can see it terminating all the sleepers. Explaining the grep '[p]ython csp_build.py' bit in a bit more detail: when you do sleep 3600 & followed by ps -ef | grep sleep , you tend to get two processes with sleep in it, the sleep 3600 and the grep sleep (because they both have sleep in them, that's not rocket science). However, ps -ef | grep '[s]leep' won't create a grep process with sleep in it, it instead creates one with the command grep '[s]leep' and here's the tricky bit: the grep doesn't find that one, because it's looking for the regular expression "any character from the character class [s] (which is basically just s ) followed by leep . In other words, it's looking for sleep but the grep process is grep '[s]leep' which doesn't have the text sleep in it. When I was shown this (by someone here on SO), I immediately started using it because it's one less process than adding | grep -v grep ; and it's elegant and sneaky, a rare combination :-) (1) If you're not limited to using those basic tools, there's a nifty pgrep command which will find processes based on certain criteria (assuming you have it available on your system, of course). For example, you can use pgrep sleep to output the process IDs for all sleep commands (by default, it matches the process name). If you want to match the entire command line as shown in ps , you can do something like pgrep -f 'sleep 9999' . As an aside, it doesn't list itself if you do pgrep pgrep , so the tricky filter method shown above is not necessary in this case. You can check that the processes are the ones you're interested in by using -a to show the full process names. You can also limit the scope to your own processes (or a specific set of users) with -u or -U . See the man page for pgrep / pkill for more options. Once you're satisfied it will only show the processes you're interested in, you can then use pkill with the same parameters to send a signal to all those processes.
