[site]: stackoverflow
[post_id]: 3134061
[parent_id]: 3133909
[tags]: 
To pass by reference, you'd typically change this: vector DFS(vector > mat){ to: vector DFS(vector > const &mat) { Technically, this is passing a const reference, but that's what you normally want to use when/if you're not planning to modify the original object. On another note, I'd probably change this: for_each((*row).begin(), (*row).end(), utilShow ); to something like: std::copy(row->begin(), row->end(), std::ostream_iterator (std::cout, " ")); Likewise: for_each(dfsResult.begin(), dfsResult.end(), utilShow ); would become: std::copy(dfsResult.begin(), dfsResult.end(), std::ostream_iterator (std::cout, " ")); (...which looks like it would obviate utilShow entirely). As far as 2D matrices go, unless you need a ragged matrix (where different rows can be different lengths), you typically use a simple front-end to handle indexing in a single vector: template class matrix { std::vector data_; size_t columns_; public: matrix(size_t rows, size_t columns) : columns_(columns), data_(rows * columns) {} T &operator()(size_t row, size_t column) { return data[row * columns_ + column]; } }; Note that this uses operator() for indexing, so instead of m[x][y] , you'd use m(x,y) , about like in BASIC or Fortran. You can overload operator[] in a way that allows you to use that notation if you prefer, but it's a fair amount of extra work with (IMO) little real benefit.
