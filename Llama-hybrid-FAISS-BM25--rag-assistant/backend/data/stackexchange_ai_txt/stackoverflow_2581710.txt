[site]: stackoverflow
[post_id]: 2581710
[parent_id]: 2580158
[tags]: 
I don't see why your "weight" lookups have to be in the form of ["weight"] (nodes are dictionaries?) instead of .weight (nodes are objects). If your nodes are objects, and don't have a lot of fields, you can take advantage of the __slots__ directive to optimize their storage: class Node(object): # ... class stuff goes here ... __slots__ = ('weight',) # tuple of member names. EDIT: So I looked at the NetworkX link you provided, and there are several things that bother me. First is that, right at the top, the definition of "dictionary" is "FIXME". Overall, it seems insistent on using dictionaries, rather than using classes that can be subclassed, to store attributes. While attribute lookup on an object may be essentially a dictionary lookup, I don't see how working with an object can be worse . If anything, it could be better since an object attribute lookup is more likely to be optimized, because: object attribute lookups are so common, the keyspace for object attributes is far more restricted than for dictionary keys, thus an optimized comparison algorithm can be used in the search, and objects have the __slots__ optimization for exactly these cases, where you have an object with only a couple fields and need optimized access to them. I frequently use __slots__ on classes that represent coordinates, for example. A tree node would seem, to me, another obvious use. So that's why when I read: node A node can be any hashable Python object except None. I think, okay, no problem, but then immediately following is node attribute Nodes can have arbitrary Python objects assigned as attributes by using keyword/value pairs when adding a node or assigning to the G.node[n] attribute dictionary for the specified node n. I think, if a node needs attributes, why would it be stored separately? Why not just put it in the node? Is writing a class with contentString and weight members detrimental? Edges seem even crazier, since they're dictated to be tuples and not objects which you could subclass. So I'm rather lost as to the design decisions behind NetworkX. If you're stuck with it, I'd recommend moving attributes from those dictionaries into the actual nodes, or if that's not an option, using integers for keys into your attribute dictionary instead of strings, so searches use a much faster comparison algorithm. Finally, what if you combined your generators: neighbor_z_scores = (interaction_graph.node[neighbor]['weight'] for neighbor in node_neighbors if neighbor in selected_nodes)
