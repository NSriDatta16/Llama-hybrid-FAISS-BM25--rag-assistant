[site]: stackoverflow
[post_id]: 2619231
[parent_id]: 2618998
[tags]: 
The F# language has some constructs that don't have any equivalent in C#, but it has almost everything that you can use in C#. This means that if you simply translate code from C# to F#, you'll end up using only a subset of F#. As a result, it is sometimes better to look for some specific F# constructs. I think this is also the case of static members. In addition to classes, you can also organize F# code using modules and modules provide a natural way for declaring static data and functions. Here is an example of module for greeting: // modules are automatically 'static' (from the C# point of viedw) module Greetings = // public mutable field inside a module let mutable how = "Hello " // global function that uses the field let greet name = Console.WriteLine(how + name) // modify the global field and invoke global function Greetings.how If you need some static functionality and some instance functionality, it is usually easy to split the functionality between a module and a standard class. The obvious benefit is that it gives you easier syntax, but it may also help structuring the code: type Person(name) = member GreetMe() = Greetings.greet(name) Members inside module can be declared as private or internal if you want to keep them hidden from the user. For example if you wanted to make the how field accessible only to your assembly, you could write: let mutable internal how = "Hello " I think this gives you more idiomatic F# code, so I would probably prefer this style of programming when writing F# code. If you plan to use this from C#, then modules will appear as static classes, which are also easy to use. As a side-note, it is generally recomended to avoid using too many mutable members. However, if you're using them for some kind of configuration then I suppose it is OK.
