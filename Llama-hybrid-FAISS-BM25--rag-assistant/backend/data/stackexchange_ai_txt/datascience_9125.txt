[site]: datascience
[post_id]: 9125
[parent_id]: 2587
[tags]: 
Unfortunately, there isn't any. However, the AbstractDifferenceRecommenderEvaluator can be extended for the purpose. The class would look something like this: public abstract class AbstractKFoldRecommenderEvaluator extends AbstractDifferenceRecommenderEvaluator { private final Random random; public double noEstimateCounterAverage = 0.0; public double totalEstimateCount = 0.0; public double totalEstimateCountAverage = 0.0; private static final Logger log = LoggerFactory .getLogger(AbstractKFoldRecommenderEvaluator.class); public AbstractKFoldRecommenderEvaluator() { super(); random = RandomUtils.getRandom(); } public double getNoEstimateCounterAverage(){ return noEstimateCounterAverage; } public double getTotalEstimateCount(){ return totalEstimateCount; } public double getTotalEstimateCountAverage(){ return totalEstimateCountAverage; } /** * We use the same evaluate function from the RecommenderEvaluator interface * the trainingPercentage is used as the number of folds, so it can have * values bigger than 0 to the number of folds. */ @Override public double evaluate(RecommenderBuilder recommenderBuilder, DataModelBuilder dataModelBuilder, DataModel dataModel, double trainingPercentage, double evaluationPercentage) throws TasteException { Preconditions.checkNotNull(recommenderBuilder); Preconditions.checkNotNull(dataModel); Preconditions.checkArgument(trainingPercentage >= 0.0, "Invalid trainingPercentage: " + trainingPercentage); Preconditions.checkArgument(evaluationPercentage >= 0.0 && evaluationPercentage > folds = new ArrayList >(); for (int i = 0; i ( 1 + (int) (i / noFolds * numUsers))); } // Split the dataModel into K folds per user LongPrimitiveIterator it = dataModel.getUserIDs(); while (it.hasNext()) { long userID = it.nextLong(); if (random.nextDouble() intermediateResults = new ArrayList<>(); List unableToRecoomend = new ArrayList<>(); List averageEstimateCounterIntermediate = new ArrayList<>(); noEstimateCounterAverage = 0.0; totalEstimateCount = 0.0; totalEstimateCountAverage = 0.0; int totalEstimateCounter = 0; // Rotate the folds. Each time only one is used for testing and the rest // k-1 folds are used for training for (int k = 0; k trainingPrefs = new FastByIDMap ( 1 + (int) (evaluationPercentage * numUsers)); FastByIDMap testPrefs = new FastByIDMap ( 1 + (int) (evaluationPercentage * numUsers)); for (int i = 0; i entry : folds.get(i) .entrySet()) { if (!trainingPrefs.containsKey(entry.getKey())) { trainingPrefs.put(entry.getKey(), entry.getValue()); } else { List userPreferences = new ArrayList (); PreferenceArray existingPrefs = trainingPrefs .get(entry.getKey()); for (int j = 0; j 0) { // Get an average for the folds result = sum / intermediateResults.size(); } double noEstimateCount = 0; if(noEstimateSum>0){ noEstimateCount = noEstimateSum / unableToRecoomend.size(); } double avgEstimateCount = 0; if(totalEstimateSum>0){ avgEstimateCount = totalEstimateSum / averageEstimateCounterIntermediate.size(); } log.info("Average Evaluation result: {} ", result); log.info("Average Unable to recommend in: {} cases out of avg. {} cases or total {} ", noEstimateCount, avgEstimateCount, totalEstimateCounter); noEstimateCounterAverage = noEstimateCount; totalEstimateCount = totalEstimateCounter; totalEstimateCountAverage = avgEstimateCount; return result; } /** * Split the preference values for one user into K folds, randomly * Generate random number until is not the same as the previously generated on * in order to make sure that at least two buckets are populated. * * @param k * @param folds * @param userID * @param dataModel * @throws TasteException */ private void splitOneUsersPrefs(int k, List > folds, long userID, DataModel dataModel) throws TasteException { List > oneUserPrefs = Lists .newArrayListWithCapacity(k + 1); for (int i = 0; i ()); } oneUserPrefs.get(rand.intValue()).add(newPref); previousBucket = rand.intValue(); } for (int i = 0; i > folds, long userID, DataModel dataModel) throws TasteException { List > oneUserPrefs = Lists.newArrayListWithCapacity(k + 1); for (int i = 0; i userPrefs = new ArrayList<>(); Iterator it = prefs.iterator(); while (it.hasNext()) { userPrefs.add(it.next()); } // Shuffle the items Collections.shuffle(userPrefs); int currentBucket = 0; for (int i = 0; i ()); } oneUserPrefs.get(currentBucket).add(newPref); currentBucket++; } for (int i = 0; i testPrefs, Recommender recommender) throws TasteException { reset(); Collection > estimateCallables = Lists.newArrayList(); AtomicInteger noEstimateCounter = new AtomicInteger(); AtomicInteger totalEstimateCounter = new AtomicInteger(); for (Map.Entry entry : testPrefs.entrySet()) { estimateCallables.add(new PreferenceEstimateCallable(recommender, entry.getKey(), entry.getValue(), noEstimateCounter, totalEstimateCounter)); } log.info("Beginning evaluation of {} users", estimateCallables.size()); RunningAverageAndStdDev timing = new FullRunningAverageAndStdDev(); execute(estimateCallables, noEstimateCounter, timing); Double[] retVal = new Double[3]; retVal[0] = computeFinalEvaluation(); retVal[1] = (double) noEstimateCounter.get(); retVal[2] = (double) totalEstimateCounter.get(); //retVal.put(computeFinalEvaluation(), noEstimateCounter.get()); //return computeFinalEvaluation(); return retVal; }} The implementation can be something like this: public class RMSRecommenderEvaluatorModified extends AbstractKFoldRecommenderEvaluator { private RunningAverage average; @Override protected void reset() { average = new FullRunningAverage(); } @Override protected void processOneEstimate(float estimatedPreference, Preference realPref) { double diff = realPref.getValue() - estimatedPreference; average.addDatum(diff * diff); } @Override protected double computeFinalEvaluation() { return Math.sqrt(average.getAverage()); } @Override public String toString() { return "RMSRecommenderEvaluator"; }} Source
