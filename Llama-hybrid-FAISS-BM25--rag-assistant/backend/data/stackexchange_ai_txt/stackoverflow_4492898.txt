[site]: stackoverflow
[post_id]: 4492898
[parent_id]: 2652126
[tags]: 
Edit 2023-07-13: Now a decade later the world has moved towards small, self contained deployments which mean that your program brings its own web server so you are not dependent on being deployed inside an application server and using what it provides (CDI in this answer). If so, you should not think of CDI (unless it is a hard requirement) but instead strongly consider spring boot which provides the bits and pieces you need, and very good documentation. ——- The most important feature CDI has opposed to Guice, is that it is a standard part of Java EE 6. The importance of this cannot be underestimated, as it means that CDI is the DI-standard you should use when coding web applications. A while back I had a look at the technologies to be able to determine how we could have a standard core distribution - suitably prepared - where we could add extra modules at will which could override existing functionality without having to change the core modules. I.e. add an extra jar, and the functionality activates automatically. It turned out that the best way for us to do this for a code base used in both desktop and web applications, was to use JSR-330 annotations for our code, and then use either CDI or Guice (SVN, coming real soon now in 3.0) as the engine. After a few projects I've found that I like the Guice configuration best instead of the opaque magic happening in Weld. Additionally I found that the way to do what we want as described above with Weld, I have to mark the class in the extra jar as @Alternative, and then mention in beans.xml that I want the alternative class enforced (and that is not robust against refactoring). But, all in all, JSR-330 allows us to do something which was very tedious and fragile before (because new binds so extremely tightly), and that is a great win. I can strongly recommend looking into DI if you have any need like this.
