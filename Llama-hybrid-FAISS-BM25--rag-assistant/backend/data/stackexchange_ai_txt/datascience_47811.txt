[site]: datascience
[post_id]: 47811
[parent_id]: 47617
[tags]: 
I couldn't find any useful literature out there for using deep learning for this specific problem. Most methods seem to rely on non-machine learning methods like string similarities and Levenstein distances. A reasonable deep learning based approach to this problem would be a Recurrent Neural Network . An LSTM (Long short term memory) or GRU (Gated Recurrent Unit) would be ideal. The idea is to have an RNN which has an internal state and respects the order in which the inputs are fed. Unlike text classification, sentiment analysis or sequence generation, the preferred encoding for the text here would be at a character level instead of word level . For example Christian Douglas,Chris,1 Jhon Stevens,Charlie,0 would become [C,h,r,i,s,t,i,a,n, ,D,o,u,g,l,a,s, ,C,h,r,i,s] --> [1] [J,h,o,n, ,S,t,e,v,e,n,s, ,C,h,a,r,l,i,e] --> [0] The two strings to be matched are concatenated into a single sequence. The intuition here is that the RNN would process the sequence character by character and learn (read update weights) that the characters at the end have a similar pattern to what it saw earlier in the same sequence to deduce that it should be a 1 instead of 0. The vector of [1/0] is the target variable. The standard RNN pre-processing steps apply as usual - we'll pad the sequences in the beginning so that they're all the same length (say 50), the characters would be encoded as numeric instead of string etc. Since the dictionary here is pretty small (26 alphabets + space + pad), the network architecture can be a fairly simple one. A single embedding layer + recurrent layer should suffice. Framing the problem in this manner allows us to use a vanilla RNN or an out-of-the-box LSTM/GRU instead of creating a custom architecture that takes two separate strings as input for each data point and throws out a number. You could give this approach a shot and see if is able to satisfactorily beats baseline models. A good reading for character level RNNs is Andrej Karpathy's blog and code . The problem he's trying to solve is different and the code is in pure numpy but it still captures the idea pretty well.
