[site]: stackoverflow
[post_id]: 1860714
[parent_id]: 1860461
[tags]: 
The underlying reason is because of the way the compiler handles reading and writing of values. The compiler is allowed to store an intermediate value in memory and only actually commit the value at the end of the expression. We read the expression ++i as "increase i by one and return it", but a compiler might see it as "load the value of i , add one, return it, and the commit it back to memory before someone uses it again. The compiler is encouraged to avoid reading/writing to the actual memory location as much as possible, because that would slow the program down. In the specific case of i = ++i + 1 , it suffers largely due to the need of consistent behavioral rules. Many compilers will do the 'right thing' in such a situation, but what if one of the i s was actually a pointer, pointing to i ? Without this rule, the compiler would have to be very careful to make sure it performed the loads and stores in the right order. This rule serves to allow for more optimization opportunities. A similar case is that of the so-called strict-aliasing rule. You can't assign a value (say, an int ) through a value of an unrelated type (say, a float ) with only a few exceptions. This keeps the compiler from having to worry that some float * being used will change the value of an int , and greatly improves optimization potential.
