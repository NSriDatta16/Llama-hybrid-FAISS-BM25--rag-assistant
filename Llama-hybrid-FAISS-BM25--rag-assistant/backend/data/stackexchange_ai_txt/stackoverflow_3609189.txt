[site]: stackoverflow
[post_id]: 3609189
[parent_id]: 3609103
[tags]: 
You can just get a list of indices using the range operator ( .. ) by subtracting the upstream window from $i and adding the downstream window to $i . You will need to remember to skip the iterator when the iterator is equal to $i if you don't want that $i th value. You will need to use the modulo operator ( % ) to keep the index within the bounds of the array. Given an array of size 11 , we can see that by modifying the index with 11 it will always point to the right place in the array: #!/usr/bin/perl use strict; use warnings; for my $i (-22 .. 22) { print "$i => ", $i % 11, "\n"; } You may run into problems with huge numbers (i.e., numbers larger than what your platform holds in an unsigned integer), because Perl 5 changes the algorithm the modulus uses around there. It becomes more like C's fmod (but there are some differences). You may also want to not use the integer pragma. It makes % faster, but you get the behavior of the C modulo operator. Neither ANSI nor ISO define what C should do with negative numbers, so you may or may not get a valid index back. Of course, so long as the version of C spits back either X -5 -4 -3 -2 -1 0 1 X%5 0 -4 -3 -2 -1 0 1 or X -5 -4 -3 -2 -1 0 1 X%5 0 1 2 3 4 0 1 it should be fine (if not very portable). It looks like C99 defines the modulo operator to return the second case, so long as perl gets compiled with a C99 compiler (with the C99 flag on) it should be safe to use the integer pragma.
