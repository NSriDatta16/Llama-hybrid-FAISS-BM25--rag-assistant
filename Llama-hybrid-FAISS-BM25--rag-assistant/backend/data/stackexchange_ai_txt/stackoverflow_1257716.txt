[site]: stackoverflow
[post_id]: 1257716
[parent_id]: 1257477
[tags]: 
Disclaimer: I did not seriously explore this field, but hope this small write-up might be useful to you - and awaiting to see more answers from the others. I think there are multiple questions in one: 1) Equation solvers. if you mean "solving for unknowns" symbolically - it's a pretty big pile of work that you are about to get started with, IMHO :-) You're about to embark on creating a computer algebra system . Term rewriting is a rather big topic on its own. If you are specifically interested in the manipulations at this level, C might be not the easiest to work with - you'd probably be more at ease with Lisp for that task. Notably, not every set of equations is going to have a solution - and "just" figuring out the fact whether it does have a solution or not is a tough task on its own. On the other hand, if you look up to solving the equations numerically, something like this might be interesting to look at. 2) Functional programming in general. Haskell is a great language for that (although I am still a very beginner in it - I think it might be one of the most elegant ones). OCaml might be another path to explore. Then, of course, there is Scheme. A language with immediate practical implications could be XSLT if you are dealing with web programming. And of course you can easily write functional style in Ruby and Python. It is very interesting to observe how learning the new languages changes your programming patterns in "main" language overall. So, language theory or not - the more languages you touch, the better. 3) Writing the interpreters, etc. I suspect that given the flavour of the question, the most interesting practical application for what you would like to do would be not the interpreter, but the optimization code in the compiler. For that - Dragon book and MIT computer language engineering course would be useful in my opinion to start with. Then you could grab e.g. a copy of TCC and play with it. If you want to tinker with something less conventional, take a look at potion - a very interesting language experiment that has x86 machine code as its "bytecode" (hence the performance on x86 machines is pretty spectacular). This question on SO actually references most of the of the links from (3) above, and quite a few more.
