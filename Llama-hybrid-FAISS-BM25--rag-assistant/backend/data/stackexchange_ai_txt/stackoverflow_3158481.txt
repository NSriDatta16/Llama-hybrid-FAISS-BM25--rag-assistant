[site]: stackoverflow
[post_id]: 3158481
[parent_id]: 3158280
[tags]: 
If you have: // structs.hpp #define LC_ERR_LEN 300 typedef struct dLC_ERRMSG { short nr; short strategy; char tx[LC_ERR_LEN]; } LC_ERRMSG; and: // main.cpp #include "structs.hpp" LC_ERRMSG err; int main() { // ... char *szError; szError = strerror(sStatus); snprintf(err.tx, LC_ERR_LEN, "%s - %s", szFilename, szError); } then this should work. However, if you switch the second line of main.cpp to: extern LC_ERRMSG err; then you need to make sure that the storage for err is compiled into one of your object files. For example, you could compile this source: // globals.cpp #include "structs.hpp" LC_ERRMSG err; and link the resulting globals.o into main.o . Either of the approaches should not cause a segmentation fault. If you are getting a segmentation fault, then the problem could be that LC_ERR_LEN has a different value when globals.cpp is being compiled than when main.cpp is being compiled. Or, perhaps szFilename or szError are NULL /bad. The printf family cannot print NULL or bad pointers with format flag %s ; the following code causes a segmentation fault: #include int main() { printf("%s\n", NULL); } EDIT: I thought of another potential cause of the problem. You could have a symbol clash if you are using a C compiler as err is a symbol that could be in use as the name of several, different global variables in a large project. If you are using a C++ compiler, then the name mangling process should ensure that each err has its own symbol. Just make sure that you are compiling as C++.
