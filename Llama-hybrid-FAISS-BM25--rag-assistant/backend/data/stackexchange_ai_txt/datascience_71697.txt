[site]: datascience
[post_id]: 71697
[parent_id]: 71692
[tags]: 
You have to prepare your data as a numpy array with the following shape: ( Number of observations , Input length , Number of variables ) Assuming you are working with Keras, the input of the LSTM() layer is as above, but you don't need to report the number of observations: input_shape = (Input length , Number of variables). Input length is an hyperparameter of your choice. I pushed this Notebook on GitHub that contains a function to preprocess your dataset for RNNs: def univariate_processing(variable, window): ''' RNN preprocessing for single variables. Can be iterated for multidimensional datasets. ''' import numpy as np # create empty 2D matrix from variable V = np.empty((len(variable)-window+1, window)) # take each row/time window for i in range(V.shape[0]): V[i,:] = variable[i : i+window] V = V.astype(np.float32) # set common data type return V def RNN_regprep(df, y, len_input, len_pred): #, test_size): ''' RNN preprocessing for multivariate regression. Builds multidimensional dataset by iterating univariate preprocessing steps. Requires univariate_processing() function. Args: df, y: X and y data in numpy.array() format len_input, len_pred: length of input and prediction sequences Returns: X, Y matrices ''' import numpy as np # create 3D matrix for multivariate input X = np.empty((df.shape[0]-len_input+1, len_input, df.shape[1])) # Iterate univariate preprocessing on all variables - store them in XM for i in range(df.shape[1]): X[ : , : , i ] = univariate_processing(df[:,i], len_input) # create 2D matrix of y sequences y = y.reshape((-1,)) # reshape to 1D if needed Y = univariate_processing(y, len_pred) ## Trim dataframes as explained X = X[ :-(len_pred + 1) , : , : ] Y = Y[len_input:-1 , :] # Set common datatype X = X.astype(np.float32) Y = Y.astype(np.float32) return X, Y Let me know if that's what you were looking for.
