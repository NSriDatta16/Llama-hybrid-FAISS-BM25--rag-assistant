[site]: stackoverflow
[post_id]: 61982
[parent_id]: 60269
[tags]: 
I liked Terai Atsuhiro san's DnDTabbedPane , but I wanted more from it. The original Terai implementation transfered tabs within the TabbedPane, but it would be nicer if I could drag from one TabbedPane to another. Inspired by @ Tom 's effort, I decided to modify the code myself. There are some details I added. For example, the ghost tab now slides along the tabbed pane instead of moving together with the mouse. setAcceptor(TabAcceptor a_acceptor) should let the consumer code decide whether to let one tab transfer from one tabbed pane to another. The default acceptor always returns true . /** Modified DnDTabbedPane.java * http://java-swing-tips.blogspot.com/2008/04/drag-and-drop-tabs-in-jtabbedpane.html * originally written by Terai Atsuhiro. * so that tabs can be transfered from one pane to another. * eed3si9n. */ import java.awt.*; import java.awt.datatransfer.*; import java.awt.dnd.*; import java.awt.geom.*; import java.awt.image.*; import javax.swing.*; public class DnDTabbedPane extends JTabbedPane { public static final long serialVersionUID = 1L; private static final int LINEWIDTH = 3; private static final String NAME = "TabTransferData"; private final DataFlavor FLAVOR = new DataFlavor( DataFlavor.javaJVMLocalObjectMimeType, NAME); private static GhostGlassPane s_glassPane = new GhostGlassPane(); private boolean m_isDrawRect = false; private final Rectangle2D m_lineRect = new Rectangle2D.Double(); private final Color m_lineColor = new Color(0, 100, 255); private TabAcceptor m_acceptor = null; public DnDTabbedPane() { super(); final DragSourceListener dsl = new DragSourceListener() { public void dragEnter(DragSourceDragEvent e) { e.getDragSourceContext().setCursor(DragSource.DefaultMoveDrop); } public void dragExit(DragSourceEvent e) { e.getDragSourceContext() .setCursor(DragSource.DefaultMoveNoDrop); m_lineRect.setRect(0, 0, 0, 0); m_isDrawRect = false; s_glassPane.setPoint(new Point(-1000, -1000)); s_glassPane.repaint(); } public void dragOver(DragSourceDragEvent e) { //e.getLocation() //This method returns a Point indicating the cursor location in screen coordinates at the moment TabTransferData data = getTabTransferData(e); if (data == null) { e.getDragSourceContext().setCursor( DragSource.DefaultMoveNoDrop); return; } // if /* Point tabPt = e.getLocation(); SwingUtilities.convertPointFromScreen(tabPt, DnDTabbedPane.this); if (DnDTabbedPane.this.contains(tabPt)) { int targetIdx = getTargetTabIndex(tabPt); int sourceIndex = data.getTabIndex(); if (getTabAreaBound().contains(tabPt) && (targetIdx >= 0) && (targetIdx != sourceIndex) && (targetIdx != sourceIndex + 1)) { e.getDragSourceContext().setCursor( DragSource.DefaultMoveDrop); return; } // if e.getDragSourceContext().setCursor( DragSource.DefaultMoveNoDrop); return; } // if */ e.getDragSourceContext().setCursor( DragSource.DefaultMoveDrop); } public void dragDropEnd(DragSourceDropEvent e) { m_isDrawRect = false; m_lineRect.setRect(0, 0, 0, 0); // m_dragTabIndex = -1; if (hasGhost()) { s_glassPane.setVisible(false); s_glassPane.setImage(null); } } public void dropActionChanged(DragSourceDragEvent e) { } }; final DragGestureListener dgl = new DragGestureListener() { public void dragGestureRecognized(DragGestureEvent e) { // System.out.println("dragGestureRecognized"); Point tabPt = e.getDragOrigin(); int dragTabIndex = indexAtLocation(tabPt.x, tabPt.y); if (dragTabIndex = 0) { return true; } // if if (DnDTabbedPane.this != data.getTabbedPane()) { if (m_acceptor != null) { return m_acceptor.isDropAcceptable(data.getTabbedPane(), data.getTabIndex()); } // if } // if return false; } public boolean isDropAcceptable(DropTargetDropEvent e) { Transferable t = e.getTransferable(); if (t == null) { return false; } // if DataFlavor[] flavor = e.getCurrentDataFlavors(); if (!t.isDataFlavorSupported(flavor[0])) { return false; } // if TabTransferData data = getTabTransferData(e); if (DnDTabbedPane.this == data.getTabbedPane() && data.getTabIndex() >= 0) { return true; } // if if (DnDTabbedPane.this != data.getTabbedPane()) { if (m_acceptor != null) { return m_acceptor.isDropAcceptable(data.getTabbedPane(), data.getTabIndex()); } // if } // if return false; } } private boolean m_hasGhost = true; public void setPaintGhost(boolean flag) { m_hasGhost = flag; } public boolean hasGhost() { return m_hasGhost; } /** * returns potential index for drop. * @param a_point point given in the drop site component's coordinate * @return returns potential index for drop. */ private int getTargetTabIndex(Point a_point) { boolean isTopOrBottom = getTabPlacement() == JTabbedPane.TOP || getTabPlacement() == JTabbedPane.BOTTOM; // if the pane is empty, the target index is always zero. if (getTabCount() == 0) { return 0; } // if for (int i = 0; i a_targetIndex) { //System.out.println(" >: press="+prev+" next="+next); source.remove(sourceIndex); insertTab(str, null, cmp, null, a_targetIndex); setSelectedIndex(a_targetIndex); } else { //System.out.println("
