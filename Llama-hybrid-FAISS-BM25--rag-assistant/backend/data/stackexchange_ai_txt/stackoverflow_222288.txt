[site]: stackoverflow
[post_id]: 222288
[parent_id]: 222195
[tags]: 
If you look at what va_start expands out to, you'll see what's happening: va_start(argptr, format); becomes (roughly) argptr = (va_list) (&format+1); If format is a value-type, it gets placed on the stack right before all the variadic arguments. If format is a reference type, only the address gets placed on the stack. When you take the address of the reference variable, you get the address or the original variable (in this case of a temporary AnsiString created before calling Broken), not the address of the argument. If you don't want to pass around full classes, your options are to either pass by pointer, or put in a dummy argument: AnsiString working_ptr(const AnsiString *format,...) { ASSERT(format != NULL); va_list argptr; AnsiString buff; va_start(argptr, format); buff.vprintf(format->c_str(), argptr); va_end(argptr); return buff; } ... AnsiString format = "Hello %s"; s1 = working_ptr(&format, "World"); or AnsiString working_dummy(const AnsiString &format, int dummy, ...) { va_list argptr; AnsiString buff; va_start(argptr, dummy); buff.vprintf(format.c_str(), argptr); va_end(argptr); return buff; } ... s1 = working_dummy("Hello %s", 0, "World");
