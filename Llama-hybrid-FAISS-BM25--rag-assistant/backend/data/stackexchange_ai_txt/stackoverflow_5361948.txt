[site]: stackoverflow
[post_id]: 5361948
[parent_id]: 5361513
[tags]: 
Edit : This answer is wrong. Take a look at accepted answer. I think the issue comes down this: compiler does not see the type of f2 (i.e. Field) and the inferred type of formal parameter (i.e. Field -> Field) as the same type. In other words, it looks like type of f2 (Field) is considered to be a subtype of the type of formal parameter Field (Field). Since Field is at the same type a subtype of Object, compiler cannot pick one method over another. Edit : Let me expand my statement a bit Both methods are applicable and it looks like the Phase 1: Identify Matching Arity Methods Applicable by Subtyping is used to decide which method to call and than rules from Choosing the Most Specific Method applied, but failed for some reason to pick second method over first one. Phase 1 section uses this notation: X (X is subtype of S). Based on my understanding of , X is a valid expression, i.e. the is not strict and includes the type itself (X is subtype of X) in this context. This explains the result of Phase 1: both methods are picked as candidates, since Field and Field . Choosing the Most Specific Method section uses same notation to say that one method is more specific than another. The interesting part the paragraph that starts with "One fixed-arity member method named m is more specific than another member...". It has, among other things: For all j from 1 to n, Tj This makes me think that in our case second method must be chosen over the first one, because following holds: Parameter Field while the other way around does not hold due to Object being false (Object is not a subtype of Field). Note: In case of String examples, Phase 1 will simply pick the only method applicable: the second one. So, to answer your questions: I think this is a bug in compiler implementation. Eclipse has it is own incremental compiler which does not have this bug it seems.
