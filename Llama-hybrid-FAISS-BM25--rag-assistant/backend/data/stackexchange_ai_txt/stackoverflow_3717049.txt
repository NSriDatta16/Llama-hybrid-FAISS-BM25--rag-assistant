[site]: stackoverflow
[post_id]: 3717049
[parent_id]: 
[tags]: 
C# generics - possible to create a method with n Generic types..?

I don't think this is possible but here goes... I want to add method that can handle n numer of generics. for example : bool MyMethod() where T: Isomething { } will work for one type bool MyMethod() where T: Isomething { } will work for two types Is there a way to work with n types - e.g. bool MyMethod() where T: Isomething { } the reason I want to do this is to implement a static nhibernate helper method which can load from multiple assemblies - right now it works great for one assembly. My current method is as shown below: public static ISessionFactory GetMySqlSessionFactory (string connectionString, bool BuildSchema) { //configuring is meant to be costly so just do it once for each db and store statically if (!AllFactories.ContainsKey(connectionString)) { var configuration = Fluently.Configure() .Database(MySQLConfiguration.Standard .ConnectionString(connectionString) .ShowSql() //for development/debug only.. .UseOuterJoin() .QuerySubstitutions("true 1, false 0, yes 'Y', no 'N'")) .Mappings(m => { m.FluentMappings.AddFromAssemblyOf (); m.AutoMappings.Add(AutoMap.AssemblyOf ().Conventions.Add ); }) .ExposeConfiguration(cfg => { new SchemaExport(cfg) .Create(BuildSchema, BuildSchema); }); AllFactories[connectionString] = configuration.BuildSessionFactory(); } return AllFactories[connectionString]; } Where the line: m.FluentMappings.AddFromAssemblyOf(), I would like to add multiple types e.g. foreach(T in T[]){ m.FluentMappings.AddFromAssemblyOf () } Obviously this couldn't work I'm not completely dumb but I am not so hot on generics - can someone confirm that this isn't possible :-) ..? What would be the most elegant way of achieving this effect in your opinion..?
