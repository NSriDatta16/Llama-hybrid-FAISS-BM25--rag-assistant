[site]: stackoverflow
[post_id]: 5414671
[parent_id]: 4495485
[tags]: 
I don't really know the inner workings, but I'll give it a guess ;-) First of all, it has nothing to do with whether or not its an [HttpGet] or a [HttpPost] -- that's just the way it usually works. Your average [HttpGet] methods look something like this: [HttpGet] public ActionResult Index() { // Get some data from the database return View(data); } There aren't any parameters in this method, because we want the user to hit this controller when they just type in the URL (i.e. Home/Index ). Your usual [HttpPost] method might look like this: [HttpPost] public ActionResult Create(MyModel myModel) { if (ModelState.IsValid) { // Do stuff } else { return View(myModel); } } I believe the validation attributes aren't triggered until you actually bind the form values to the model and hit that Create(...) controller. If your [HttpGet] happened to take in a model as a parameter, then validation would get triggered at that point as well. When you return the View with the existing, invalid model, somehow the ValidationMessageFor(m => m.SomeProperty) method knows that the validation for that property failed. That's the part I'm not sure about. By contrast, when you return a new View() as the ActionResult (as you usually do for an HTTP GET), a brand-new, shiny model is instantiated. Creating a new model is just as simple as creating a POCO (Plain Old C# Object) -- the validation is not triggered. As for the client-side validation, that is handled completely through JavaScript once you click the form's submit button. When your [HttpGet] request displays the blank form, the submit button hasn't yet been clicked (so the JavaScript validation hasn't been started). In addition, I believe that once you begin typing the validation also kicks in through various JavaScript events such as change , keydown , keypress , etc.
