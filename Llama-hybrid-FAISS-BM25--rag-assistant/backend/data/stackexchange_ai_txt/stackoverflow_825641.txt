[site]: stackoverflow
[post_id]: 825641
[parent_id]: 817998
[tags]: 
You could try implementing a custom ScoreDocComparator . For example: public class ScaledScoreDocComparator implements ScoreDocComparator { private int[][] values; private float[] scalars; public ScaledScoreDocComparator(IndexReader reader, String[] fields, float[] scalars) throws IOException { this.scalars = scalars; this.values = new int[fields.length][]; for (int i = 0; i sortValue(ScoreDoc i) { float score = score(i); return Float.valueOf(score); } } Here is an example of ScaledScoreDocComparator in action. I believe it works in my test, but I encourage you to prove it against your data. final String[] fields = new String[]{ "field1", "field2", "field3" }; final float[] scalars = new float[]{ 0.5f, 1.4f, 1.8f }; Sort sort = new Sort( new SortField( "", new SortComparatorSource() { public ScoreDocComparator newComparator(IndexReader reader, String fieldName) throws IOException { return new ScaledScoreDocComparator(reader, fields, scalars); } } ) ); IndexSearcher indexSearcher = ...; Query query = ...; Filter filter = ...; // can be null int nDocs = 100; TopFieldDocs topFieldDocs = indexSearcher.search(query, filter, nDocs, sort); ScoreDoc[] scoreDocs = topFieldDocs.scoreDocs; Bonus! It appears that the Lucene developers are deprecating the ScoreDocComparator interface (it's currently deprecated in the Subversion repository). Here is an example of the ScaledScoreDocComparator modified to adhere to ScoreDocComparator 's successor, FieldComparator : public class ScaledComparator extends FieldComparator { private String[] fields; private float[] scalars; private int[][] slotValues; private int[][] currentReaderValues; private int bottomSlot; public ScaledComparator(int numHits, String[] fields, float[] scalars) { this.fields = fields; this.scalars = scalars; this.slotValues = new int[this.fields.length][]; for (int fieldIndex = 0; fieldIndex value(int slot) { float score = scoreSlot(slot); return Float.valueOf(score); } } Using this new class is very similar to the original, except that the definition of the sort object is a bit different: final String[] fields = new String[]{ "field1", "field2", "field3" }; final float[] scalars = new float[]{ 0.5f, 1.4f, 1.8f }; Sort sort = new Sort( new SortField( "", new FieldComparatorSource() { public FieldComparator newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException { return new ScaledComparator(numHits, fields, scalars); } } ) );
