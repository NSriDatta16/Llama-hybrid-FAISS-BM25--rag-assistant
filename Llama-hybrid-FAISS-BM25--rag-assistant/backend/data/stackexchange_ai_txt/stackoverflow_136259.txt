[site]: stackoverflow
[post_id]: 136259
[parent_id]: 135845
[tags]: 
Enums can certainly make the code more readable. There are still a few things to watch out for (in .net at least) Because the underlying storage of an enum is an int, the default value will be zero, so you should make sure that 0 is a sensible default. (E.g. structs have all fields set to zero when created, so there's no way to specify a default other than 0. If you don't have a 0 value, you can't even test the enum without casting to int, which would be bad style.) If your enum's are private to your code (never exposed publicly) then you can stop reading here. If your enums are published in any way to external code and/or are saved outside of the program, consider numbering them explicitly. The compiler automatically numbers them from 0, but if you rearrange your enums without giving them values you can end up with defects. I can legally write WriteMode illegalButWorks = (WriteMode)1000000; file.Write( data, illegalButWorks ); To combat this, any code that consumes an enum that you can't be certain of (e.g. public API) needs to check if the enum is valid. You do this via if (!Enum.IsDefined(typeof(WriteMode), userValue)) throw new ArgumentException("userValue"); The only caveat of Enum.IsDefined is that it uses reflection and is slower. It also suffers a versioning issue. If you need to check the enum value often, you would be better off the following: public static bool CheckWriteModeEnumValue(WriteMode writeMode) { switch( writeMode ) { case WriteMode.Append: case WriteMode.OverWrite: break; default: Debug.Assert(false, "The WriteMode '" + writeMode + "' is not valid."); return false; } return true; } The versioning issue is that old code may only know how to handle the 2 enums you have. If you add a third value, Enum.IsDefined will be true, but the old code can't necessarily handle it. Whoops. There's even more fun you can do with [Flags] enums, and the validation code for that is slightly different. I'll also note that for portability, you should use call ToString() on the enum, and use Enum.Parse() when reading them back in. Both ToString() and Enum.Parse() can handle [Flags] enum's as well, so there's no reason not to use them. Mind you, it's yet another pitfall, because now you can't even change the name of the enum without possibly breaking code. So, sometimes you need to weigh all of the above in when you ask yourself Can I get away with just an bool?
