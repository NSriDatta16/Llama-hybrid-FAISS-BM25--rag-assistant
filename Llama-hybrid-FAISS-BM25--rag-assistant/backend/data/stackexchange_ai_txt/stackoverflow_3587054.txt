[site]: stackoverflow
[post_id]: 3587054
[parent_id]: 3586798
[tags]: 
You could use recursive trials. You would need at least the move count and to pass a copy of the vector. You'd also want to set a maximum move cutoff to set a limit to the breadth of branches coming out of at each node of the search tree. Note this is a "brute force" approach." Your general algorithm structure would be: const int MAX_FLIPS=10; const unsigned int TREE_BREADTH=10; int run_recursion(std::vector > my_grid, int current flips) { bool found = true; int temp_val = -1; int result = -1; //Search for solution with for loops; if true is found in grid, found=false; ... if ( ! found && flips ...sorry in advance for any typos/minor syntax errors. Wanted to prototype a fast solution for you, not write the full code... Or easier still, you could just use a brute force of linear trials. Use an outer for loop would be number of trials, inner for loop would be flips in trial. On each loop you'd flip and check if you'd succeeded, recycling your success and flip code from above. Success would short circuit the inner loop. At the end of the inner loop, store the result in the array. If failure after max_moves, store -1. Search for the max value. A more elegant solution would be to use a multithreading library to start a bunch of threads flipping, and have one thread signal to others when it finds a match, and if the match is lower than the # of steps run thus far in another thread, that thread exits with failure. I suggest MPI, but CUDA might win you brownie points as it's hot right now. Hope that helps, good luck!
