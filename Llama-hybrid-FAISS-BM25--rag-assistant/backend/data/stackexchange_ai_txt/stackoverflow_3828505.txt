[site]: stackoverflow
[post_id]: 3828505
[parent_id]: 3828358
[tags]: 
The MMU (Memory Management Unit) is a fundamental block of systems that want to have separate and protected memory spaces. I am going to keep this simple, as whole books can be written about memory management hardware and strategies... Without protection, a program running in any process would be able to access the memory of any other process. Even if you ignore the security implications, this means that a bug in one program could overwrite memory belonging to some other process. It is not easy to debug this class of problem because the symptoms show up very far removed from the cause. So, some kind of organizing principle is required so that each process can only see and modify memory assigned to it. And, because bugs happen, it is important that this organization be supported by hardware so that even accidental access to the wrong part of memory is difficult. An advantage of this is that it also becomes possible to make the memory map of every process appear identical. The linker can locate every program at the same start address, put stack and heap in predictable areas, and reserve memory for interaction with the kernel. The MMU is the hardware component that implements the translation from the logical addresses that a process uses to the physical addresses that the hardware uses. It also provides security features such as marking only some parts of memory as executable. It provide the data structures that the kernel needs to implement process swapping and virtual memory, so that the memory pages belonging to process A cannot even be seen by process B, but both A and B can be seen by the trusted kernel. To achieve this in a practical way, the physical memory is divided into pages, typically 4KB in size. Each logical address is broken into a page number and an offset. The page numbers index a table in the MMU that translates each logical page to some physical address. This translation happens during every memory access cycle. A single physical page can be mapped into no processes (its probably also in a pool of free pages in that case), exactly one, or several. The stack, data, and heap of a process is generally made up of pages mapped into exactly that one process. That helps prevent a bug in one process from affecting others, because each process can only write to its own stack, data and heap pages. If the same page of physical memory is mapped into more than one process, then it is visible to those. This is how a DLL on Windows or a .so on Unix is shared: the pages holding its program text are mapped into every process that is linked to it. The MMU has a mechanism that throws an exception when a page is accessed that hasn't been mapped to a process. Handling that exception makes it possible to implement virtual memory, and to grow the amount of memory allocated to a process as its needs change.
