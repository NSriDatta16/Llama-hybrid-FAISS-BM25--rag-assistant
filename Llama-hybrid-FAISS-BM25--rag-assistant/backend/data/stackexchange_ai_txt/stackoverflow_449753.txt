[site]: stackoverflow
[post_id]: 449753
[parent_id]: 449731
[tags]: 
Patterns are complex All design patterns should be used with care. In my opinion you should refactor towards patterns when there is a valid reason to do so instead of implementing a pattern right away. The general problem with using patterns is that they add complexity. Overuse of patterns makes a given application or system cumbersome to further develop and maintain. Most of the time, there is a simple solution, and you won't need to apply any specific pattern. A good rule of thumb is to use a pattern whenever pieces of code tend to be replaced or need to be changed often and be prepared to take on the caveat of complex code when using a pattern. Remember that your goal should be simplicity and employ a pattern if you see a practical need to support change in your code. Principles over patterns It may seem like a moot to use patterns if they can evidently lead to over-engineered and complex solutions. However it is instead much more interesting for a programmer to read up on design techniques and principles that lay the foundation for most of the patterns. In fact one of my favorite books on 'design patterns' stresses this by reiterating on what principles are applicable on the pattern in question. They are simple enough to be useful than patterns in terms of relevance. Some of the principles are general enough to encompass more than object oriented programming (OOP), such as Liskov Substitution Principle , as long as you can build modules of your code. There are a multitude of design principles but those described in the first chapter of GoF book are quite useful to start with. Program to an 'interface', not an 'implementation'. (Gang of Four 1995:18) Favor 'object composition' over 'class inheritance'. (Gang of Four 1995:20) Let those sink in on you for a while. It should be noted that when GoF was written an interface means anything that is an abstraction (which also means super classes), not to be confused with the interface as a type in Java or C#. The second principle comes from the observed overuse of inheritance which is sadly still common today . From there you can read up on SOLID principles which was made known by Robert Cecil Martin (aka. Uncle Bob) . Scott Hanselman interviewed Uncle Bob in a podcast about these principles : S ingle Responsibility Principle O pen Closed Principle L iskov Substitution Principle I nterface Segregation Principle D ependency Inversion Principle These principles are a good start to read up on and discuss with your peers. You may find that the principles interweave with each other and with other processes such as separation of concerns and dependency injection . After doing TDD for a while you also may find that these principles come naturally in practice as you need to follow them to some degree in order to create isolated and repeatable unit tests.
