[site]: stackoverflow
[post_id]: 5127760
[parent_id]: 5127500
[tags]: 
I corrected your program and indicated all errors you should pay attention to in the comments. Please take a good look at them and try to see what you did wrong, so you can learn from this. #include using namespace std; struct list { char name[20]; int age; double height; list *next; }; list *first = NULL, *current = NULL; // Init current to NULL so you can test whether current is set at all int optn = 0; void currentfor() { if(current == NULL) { cout next == NULL) cout next; } } void currentbac() { if (current == first) cout next != current) { previous = previous->next; } current = previous; } } void addbeginning() { list *newlist; newlist = new list; cout > newlist->name; cout > newlist->age; cout > newlist->height; newlist->next = first; first = newlist; if(current == NULL) // Set the current pointer to first, because this is the first element you add current = first; } void addending() { list *newlist, *newlist2; newlist = new list; cout > newlist->name; cout > newlist->age; cout > newlist->height; newlist->next = NULL; if (first == NULL) { first = newlist; current=first; } else { newlist2 = first; while (newlist2->next != NULL) { newlist2 = newlist2->next; } newlist2->next = newlist; } } void addmiddle() { if (current->next == NULL) // You were assigning here. Use == instead of = or you will assign NULL to // current->next! Which is incorrect. addending(); else { list *newlist; newlist = new list; cout > newlist->name; cout > newlist->age; cout > newlist->height; newlist->next = current->next; current->next = newlist; } } void deletebegin() { list *newlist; newlist = first; first = first->next; // You need to update the current pointer first if(newlist == current) { current = current->next; } delete newlist; } void deletemiddle() { list *newlist; newlist = first; // If we delete the first element if(current == first) { list *deleteMe = first; first = first->next; delete deleteMe; current = current->next; } else { // Otherwise // Search until newlist->next == current // Als test for newlist != NULL or you will try to get a next value from NULL -> crash! while(newlist != NULL && newlist->next != current) newlist = newlist->next; if(newlist != NULL) { delete newlist->next; newlist->next = current->next; // Also update the next from the previous node in the list! Or it will not disappear when displaying if (current->next == NULL) // You did it again here. Use == for comparing values instead of = current = first; // It doesn't mean that you don't have to delete if // you don't have a current->next. If you don't have a current->next, // just set it to first. The element does need to be deleted. else current = current->next; } } } void deleteend() { list *newlist, *newlist2; if (first == NULL) cout next == NULL) { delete newlist; first = NULL; current = NULL; // Current should also be null } else { while (newlist->next != NULL) { newlist2 = newlist; newlist = newlist->next; } delete newlist; newlist2->next = NULL; current = newlist2; // You forgot to update the current pointer. } } } void display() { list *newlist; newlist = first; cout name age height; if(current == newlist) // You need to check whether you really are at the current position cout next; } } while(newlist!=NULL); if(newlist != NULL) // What if the newList was initially NULL? You will print twice. cout > " ; cin >> optn; switch (optn) { case 1 : currentfor(); break; case 2 : currentbac(); break; case 3 : addbeginning(); break; case 4 : addmiddle(); break; case 5 : addending(); break; case 6 : deletebegin(); break; case 7 : deletemiddle(); break; case 8 : deleteend(); break; } } while (optn!= 9); }
