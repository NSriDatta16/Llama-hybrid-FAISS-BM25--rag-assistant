[site]: stackoverflow
[post_id]: 922421
[parent_id]: 922352
[tags]: 
Edit Ok... I think I see your confusion now. You would have expected DoStuff(string) to have kept the parameter as a string and walked the BaseClass Method List first looking for a suitable signature, and failing that fallback to trying to cast the parameter to some other type. But it happened the other way around... Instead Container.DoStuff(string) went, meh "theres a base class method there that fits the bill, but I'm going to convert to an IEnumerable and have a heart attack about what's available in the current class instead... Hmmm... I'm sure Jon or Marc would be able to chime in at this point with the specific C# Spec paragraph covering this particular corner case Original Both Methods expect an IEnumerable Collection You're passing an individual string. The compiler is taking that string and going, Ok, I have a string, Both methods expect an IEnumerable , So I'll turn this string into an IEnumerable ... Done Right, Check the first method... hmmm... this class is a Container but I have an IEnumerable so that's not right. Check the second method, hmmm.... I have an IEnumerable but char doesn't implement string so that's not right either. COMPILER ERROR So what#s the fix, well it completely depends what your trying to achieve... both of the following would be valid, essentially, your types usage is just incorrect in your incarnation. Container c1 = new Container (); c1.DoStuff("Hello World"); Container c2 = new Container (); c2.DoStuff(new List () { "Hello", "World" });
