[site]: stackoverflow
[post_id]: 1088703
[parent_id]: 1088216
[tags]: 
This is a problem not specific to java. Using == to compare two floats/doubles/any decimal type number can potentially cause problems because of the way they are stored. A single-precision float (as per IEEE standard 754) has 32 bits, distributed as follows: 1 bit - Sign (0 = positive, 1 = negative) 8 bits - Exponent (a special (bias-127) representation of the x in 2^x) 23 bits - Mantisa. The actuall number that is stored. The mantisa is what causes the problem. It's kinda like scientific notation, only the number in base 2 (binary) looks like 1.110011 x 2^5 or something similar. But in binary, the first 1 is always a 1 (except for the representation of 0) Therefore, to save a bit of memory space (pun intended), IEEE deccided that the 1 should be assumed. For example, a mantisa of 1011 really is 1.1011. This can cause some issues with comparison, esspecially with 0 since 0 cannot possibly be represented exactly in a float. This is the main reason the == is discouraged, in addition to the floating point math issues described by other answers. Java has a unique problem in that the language is universal across many different platforms, each of which could have it's own unique float format. That makes it even more important to avoid ==. The proper way to compare two floats (not-language specific mind you) for equality is as follows: if(ABS(float1 - float2) where ACCEPTABLE_ERROR is #defined or some other constant equal to 0.000000001 or whatever precision is required, as Victor mentioned already. Some languages have this functionality or this constant built in, but generally this is a good habit to be in.
