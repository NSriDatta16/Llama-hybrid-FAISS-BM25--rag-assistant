[site]: stackoverflow
[post_id]: 1418146
[parent_id]: 
[tags]: 
Interfaces and unit tests - always white-box testing?

I have finally got in my mind what worried me about Dependency Injection and similar techniques that should make unit tests easier. Let's take this example: public interface IRepository { void Item Find(); a lot of other methods here; } [Test] public void Test() { var repository = Mock (); repository.Expect(x => x.Find()); var service = new Service(repository); service.ProcessWithItem(); } Now, what's wrong with the code above? It's that our test roughly peeks into ProcessWithItem() implementation. What if it wants to do "from x in GetAll() where x..." - but no, our test knows what is going to happen there. And that's just a simple example. Imaging few calls that our test now is tied with, and when we want to change from GetAll() to a better GetAllFastWithoutStuff() inside the method... our test(s) are broken. Please change them. A lot of crappy work that happens so often without any real need. And that's what often makes me to stop write tests. I just don't see how I can test without knowing implementation details. And knowing them, tests are now very fragile and pain to do. Sure, it's not about interface (or DI) only. POCOs (and POJOs, why not) also suffer from the same thing, but they're now tied with the data, not with the interface. But the principle is the same - our final assertion is tightly coupled with our knowledge of what our SUT is going to do. "Yes you HAVE to provide this field, sir, and this better be of this value". As a consequence, tests ARE going to fail - soon and often. This is pain. And the problem. Are there any techniques to deal with this? AutoMockingContainer (which basically takes care all ALL methods and nested DI hierarchies) looks promising, but with its own drawback. Anything else?
