[site]: stackoverflow
[post_id]: 1223334
[parent_id]: 1223305
[tags]: 
Actually, the section from where you took that code offers an explanation as well: To move n discs from peg A to peg C: move n−1 discs from A to B. This leaves disc #n alone on peg A move disc #n from A to C move n−1 discs from B to C so they sit on disc #n It's pretty clear that you first have to remove n − 1 discs to get access to the n th one. And that you have to move them first to another peg than where you want the full tower to appear. The code in your post has three arguments, besides the number of discs: A source peg, a destination peg and a temporary peg on which discs can be stored in between (where every disc with size n − 1 fits). The recursion happens actually twice, there, once before the writeln , once after. The one before the writeln will move n − 1 discs onto the temporary peg, using the destination peg as temporary storage (the arguments in the recursive call are in different order). After that, the remaining disc will be moved to the destination peg and afterwards the second recursion compeltes the moving of the entire tower, by moving the n − 1 tower from the temp peg to the destination peg, above disc n.
