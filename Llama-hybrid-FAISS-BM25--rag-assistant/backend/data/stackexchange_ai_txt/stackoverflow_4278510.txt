[site]: stackoverflow
[post_id]: 4278510
[parent_id]: 4278264
[tags]: 
It sounds like you're doing something fairly insane! :) That said, I see a few options, none of which are particularly automated. If you've got a ton of commits with that file present, just admit the mistake, make a new branch off of your HEAD, and put further commits with that feature into that branch until they're stable. If you're repo's shared, this becomes the only real option. No one wants to have divergent history, especially if that feature was committed deep in the history. If you're only talking about 10 or so commits that have actually touched that file, and they're fairly recently committed without many other commits interleaved, you could check out a new branch on HEAD, and revert the branch you don't want this feature in back to before you added the feature, and then cherry pick commits you need out of the feature branch until you're ready to commit them all in at a later date. If you're dealing with a ton of history, lots of interleaved commits, and you really don't want to have that feature present at all, you could write up a little shell script that takes the output of git log and cherry picks it into a new branch. Something along the lines of: $ cd git-repo $ git checkout -b feature-x $ the-perfect-shell-script `git log --pretty=format:"%H" path/to/feature.c` Once you have that feature branch with all of the commits cherry picked out, you can then use git filter-branch to filter out all of the commits that reference that file. The man page has a simple example that does exactly that. Once you've got that, you can then git rebase feature-x --onto and you should be good to go. Of course that should be quite discouraged, especially if any of that is published.
