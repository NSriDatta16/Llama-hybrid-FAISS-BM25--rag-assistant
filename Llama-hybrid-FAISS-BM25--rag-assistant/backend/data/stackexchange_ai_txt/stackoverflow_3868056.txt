[site]: stackoverflow
[post_id]: 3868056
[parent_id]: 
[tags]: 
Data Repository Organization

So, I'm developing some software, and trying to keep myself using TDD and other best practices. I'm trying to write tests to define the classes and repository. Let's say I have the classes, Customer , Order , OrderLine . Now, do I create the Order class as something like abstract class Entity { int ID { get; set; } } class Order : Entity { Customer Customer { get; set; } List OrderLines { get; set; } } Which will serialize nice, but, if I don't care about the OrderLines , or Customer details is not as lightweight as one would like. Or do I just store IDs to items and add a function for getting them? class Order : Entity { int CustomerID { get; set; } List GetOrderLines() {}; } class OrderLine : Entity { int OrderID { get; set; } } And how would you structure the repository for something like this? Do I use an abstract CRUD repository with methods GetByID(int) , Save(entity) , Delete(entity) that each items repository inherits from, and adds it's own specific methods too, something like this? public abstract class RepositoryBase : IRepository where T : AEntity { private static List Entities { get; set; } public RepositoryBase() { Entities = new List (); } public T GetByID(TID id) { return Entities.Where(x => x.Id.Equals(id)).SingleOrDefault(); } public T Save(T entity) { Entities.RemoveAll(x => x.Id.Equals(entity.Id)); Entities.Add(entity); return entity; } public T Delete(T entity) { Entities.RemoveAll(x => x.Id.Equals(entity.Id)); return entity; } } What's the 'best practice' here?
