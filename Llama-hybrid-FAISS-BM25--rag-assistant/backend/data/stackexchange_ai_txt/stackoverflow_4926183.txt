[site]: stackoverflow
[post_id]: 4926183
[parent_id]: 1337208
[tags]: 
Aside from using mmap and munmap to eliminate the excess you don't need (or mremap , which could do the same but is non-standard), there is no way to reduce the size of an allocated block of memory. And mmap has page granularity (normally 4k) so unless you're dealing with very large objects, using it would be worse than just leaving the over-sized objects and not shrinking them at all. With that said, shrinking memory in-place is probably not a good idea, since the freed memory will be badly fragmented. A good realloc implementation will want to move blocks when significantly shrinking them as an opportunity to defragment memory. I would guess your situation is that you have an allocated block of memory with lots of other structures holding pointers into it, and you don't want to invalidate those pointers. If this is the case, here is a possible general solution: Break your resizable object up into two allocations, a "head" object of fixed size which points to the second variable-sized object. For other objects which need to point into the variable-size object, store a pointer to the head object and an integer offset ( size_t or ptrdiff_t ) into the variable-size object. Now, even if the variable-size object moves to a new address, none of the references to it are invalidated. If you're using these objects from multiple threads, you should put a read-write lock in the head object, read-locking it whenever you need to access the variable-sized object, and write-locking it whenever resizing the variable-sized object.
