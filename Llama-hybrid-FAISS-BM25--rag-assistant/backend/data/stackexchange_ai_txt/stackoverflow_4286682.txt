[site]: stackoverflow
[post_id]: 4286682
[parent_id]: 4266733
[tags]: 
Long Disclaimer, actual answer below If you really want information about how to build a compiler from scratch and need to be up to speed with all the related practical parsing, compilation, generation and optimization techniques, then the dragon book would be the better option. If you want to build a clean programming language from scratch using an interpreter, I would recommend Friedman's EPL book. If what you are after with your bachelor paper is a deeper understanding of all the fundamental issues in both previous books, then read on to my answer below. SICP is an educational work, it tries to convey the essential concepts in a clear a language as possible. It will not go into details about left-recursive parsers, common sub-expression elimination, x86 SSE extensions and so forth. SICP CH4-5 The technique used to explain the complex concepts involved is by constructing a series of computer languages from scratch before your eyes. Chapter 4 starts by building a meta-circular Scheme interpreter: a small Scheme interpreter written in Scheme itself. This will give you the basics of a recursive interpreter, and forms a basis for the construction of a series of mini-languages in the rest of ch4-5. It answers the question of how to represent your parsed code, what datastructures are involved, how to separate the host from the base language, etc. Importantly, it shows you that a language interpreter is itself just another computer program. The rest of Chapter 4 shows you how you can vary the flavor of your language by modifying the previous interpreter. The two big ones are lazy evaluation and logic programming. Chapter 5 makes a rough model of 'register machines', to represent your current day computer at an abstract level. They construct a little register machine language that acts as an assembly-language for all intents and purpose. They introduce all the datastructures and control flow constructs needed to do the next bit: building a scheme interpreter in this machine language. Somehow still similar to the meta-circular interpreter. Afterwards they jump off the deep end and construct a scheme compiler in their register machine language; complete with assembly step, tail-recursion optimization, garbage-collection, lexical addressing, tracing, etc. Although SICP constructs toy interpreters and compilers, these are conceptually complete enough to get you up to speed in no time with current practical techniques. GCC's intermediate code looks a lot like SICP's register machine code for example and these guys implemented SICP's interpreter for ARM micro-controllers straight in assembly.
