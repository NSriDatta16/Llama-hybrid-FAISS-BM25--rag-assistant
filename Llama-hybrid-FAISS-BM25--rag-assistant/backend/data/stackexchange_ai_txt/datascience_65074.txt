[site]: datascience
[post_id]: 65074
[parent_id]: 
[tags]: 
Expected performance of training tf.keras.Sequential model with model.fit, model.fit_generator and model.train_on_batch

I am using Keras with Tensorflow backend to train a simple 1D CNN to detect specific events from sensor data. While the data with tens of millions samples easily fits to the ram in the form of an 1D float array, it obviously takes a huge amount of memory to store the data as a N x inputDim array that can be passed to model.fit for training. While I can use model.fit_generator or model.train_on_batch to generate the required mini batches on the fly, for some reason I am observing a huge performance gap between model.fit and model.fit_generator & model.train_on_batch even though everything is stored in memory and mini batch generation is fast as it basically only consists of reshaping the data. Therefore, I'm wondering whether I am doing something terribly wrong or if this kind of performance gap is to be expected. I am using the cpu version of Tensorflow 2.0 with 3.2 GHz Intel Core i7 processor (4 cores with multithreading support) and Python 3.6.3. on Mac Os X Mojave. In short, I created a dummy python script to recreate the issue, and it reveals that with batch size of 64, it takes 407 seconds to run 10 epochs with model.fit, 1852 seconds with model.fit_generator, and 1985 seconds with model.train_on_batch. CPU loads are ~220%, ~130%, and ~120% respectively, and it seems especially odd that model.fit_generator & model.train_on_batch are practically on par, while model.fit_generator should be able to parallelise mini batch creation and model.train_on_batch definitely does not. That is, model.fit (with huge memory requirements) beats the other solution candidates with easily manageable memory requirements by a factor of four. Obviously, CPU loads increase and total training times decrease by increasing batch size, but model.fit is always fastest with a a margin of at least two up to batch size of 8096. In that case, model.fit takes 99 seconds to run 10 epochs with cpu load of ~860% (or pretty much everything I have got), model.fit_generator takes 179 seconds with cpu load of ~700%, and model.train_on_batch takes 198 seconds with CPU load of ~680%. Is this kind of behaviour normal (when there is no GPU involved) or what could/should be done in order to increase the computational performance of the less memory intensive options with sensible batch sizes? Specifically model.fit_generator fails to provide decent performance. It seems that no such option is available to divide all data into manageable pieces, and then run model.fit in iterative manner with constantly changing training data. Please do note that the provided dummy script is just what the name suggests, and the amount of data has been trimmed so that it makes all three options feasible. The used model, however, is similar to what I am actually using (to provide a realistic situation). from tqdm import tqdm import numpy as np import tensorflow as tf import time import sys import argparse inputData = None outputData = None batchIndices = None opts = None class DataGenerator(tf.keras.utils.Sequence): global inputData global outputData global batchIndices 'Generates data for Keras' def __init__(self, batchSize, shuffle): 'Initialization' self.batchIndices = batchIndices self.batchSize = batchSize self.shuffle = shuffle self.on_epoch_end() def __len__(self): 'Denotes the number of batches per epoch' return int( np.floor( inputData.size / self.batchSize ) ) def __getitem__(self, index): 'Generate one batch of data' # Generate data X, y = self.__data_generation(self.indexes[index*self.batchSize:(index+1)*self.batchSize]) return X, y def on_epoch_end(self): 'Updates indexes after each epoch' self.indexes = np.arange(inputData.size) if self.shuffle == True: np.random.shuffle(self.indexes) def __data_generation(self, INDX): 'Generates data containing batch_size samples' # Generate data X = np.expand_dims( inputData[ np.mod( batchIndices + np.reshape(INDX,(INDX.size,1)) , inputData.size ) ], axis=2) y = outputData[INDX,:] return X, y def main( ): global inputData global outputData global batchIndices global opts # Data generation print(' ') print('Generating data...') np.random.seed(0) # For reproducible results inputDim = int(104) # Input dimension outputDim = int( 2) # Output dimension N = int(1049344) # Total number of samples M = int(5e4) # Number of anomalies trainINDX = np.arange(N, dtype=np.uint32) inputData = np.sin(trainINDX) + np.random.normal(loc=0.0, scale=0.20, size=N) # Source data stored in a single array anomalyLocations = np.random.choice(N, M, replace=False) inputData[anomalyLocations] += 0.5 outputData = np.zeros((N,outputDim)) # One-hot encoded target array without ones for i in range(N): if( np.any( np.logical_and( anomalyLocations >= i, anomalyLocations ```
