[site]: stackoverflow
[post_id]: 1968863
[parent_id]: 1968589
[tags]: 
Your design should be maintenable. This is what I have in my project. 1.) Application.Infrastructure Base classes for all businessobjects, busines object collection, data-access classes and my custom attributes and utilities as extension methods, Generic validation framework. This determines overall behavior organization of my final .net application. 2.) Application.DataModel Typed Dataset for the Database. TableAdapters extended to incorporate Transactions and other features I may need. 3.) Application.DataAccess Data access classes. Actual place where Database actions are queried using underlying Typed Dataset. 4.) Application.DomainObjects Business objects and Business object collections. Enums. 5.) Application.BusinessLayer Provides manager classes accessible from Presentation layer. HttpHandlers. My own Page base class. More things go here.. 6.) Application.WebClient or Application.WindowsClient My presentation layer Takes references from Application.BusinessLayer and Application.BusinessObjects. Application.BusinessObjects are used across the application and they travel across all layers whenever neeeded [except Application.DataModel and Application.Infrastructure] All my queries are defined only Application.DataModel. Application.DataAccess returns or takes Business objects as part of any data-access operation. Business objects are created with the help of reflection attributes. Each business object is marked with an attribute mapping to target table in database and properties within the business object are marked with attributes mapping to target coloumn in respective data-base table. My validation framework lets me validate each field with the help of designated ValidationAttribute. My framrwork heavily uses Attributes to automate most of the tedious tasks like mapping and validation. I can also new feature as new aspect in the framework. A sample business object would look like this in my application. User.cs [TableMapping("Users")] public class User : EntityBase { #region Constructor(s) public AppUser() { BookCollection = new BookCollection(); } #endregion #region Properties #region Default Properties - Direct Field Mapping using DataFieldMappingAttribute private System.Int32 _UserId; private System.String _FirstName; private System.String _LastName; private System.String _UserName; private System.Boolean _IsActive; [DataFieldMapping("UserID")] [DataObjectFieldAttribute(true, true, false)] [NotNullOrEmpty(Message = "UserID From Users Table Is Required.")] public override int Id { get { return _UserId; } set { _UserId = value; } } [DataFieldMapping("UserName")] [Searchable] [NotNullOrEmpty(Message = "Username Is Required.")] public string UserName { get { return _UserName; } set { _UserName = value; } } [DataFieldMapping("FirstName")] [Searchable] public string FirstName { get { return _FirstName; } set { _FirstName = value; } } [DataFieldMapping("LastName")] [Searchable] public string LastName { get { return _LastName; } set { _LastName = value; } } [DataFieldMapping("IsActive")] public bool IsActive { get { return _IsActive; } set { _IsActive = value; } } #region One-To-Many Mappings public BookCollection Books { get; set; } #endregion #region Derived Properties public string FullName { get { return this.FirstName + " " + this.LastName; } } #endregion #endregion public override bool Validate() { bool baseValid = base.Validate(); bool localValid = Books.Validate(); return baseValid && localValid; } } BookCollection.cs /// /// The BookCollection class is designed to work with lists of instances of Book. /// public class BookCollection : EntityCollectionBase { /// /// Initializes a new instance of the BookCollection class. /// public BookCollection() { } /// /// Initializes a new instance of the BookCollection class. /// public BookCollection (IList initialList) : base(initialList) { } }
