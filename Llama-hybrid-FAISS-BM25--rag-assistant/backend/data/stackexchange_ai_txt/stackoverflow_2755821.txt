[site]: stackoverflow
[post_id]: 2755821
[parent_id]: 827014
[tags]: 
In the above example where I commented, this is bad: // Don't use: - (BOOL)isPartialStringValid:(NSString *)partialString newEditingString:(NSString **)newString errorDescription:(NSString **)error { if ((int)[partialString length] > maxLength) { *newString = nil; return NO; } } Use this (or something like it) instead: // Good to use: - (BOOL)isPartialStringValid:(NSString **)partialStringPtr proposedSelectedRange:(NSRangePointer)proposedSelRangePtr originalString:(NSString *)origString originalSelectedRange:(NSRange)origSelRange errorDescription:(NSString **)error { int size = [*partialStringPtr length]; if ( size > maxLength ) { return NO; } return YES; } Both are NSFormatter methods. The first one has an issue. Say you limit text-entry to 10 characters. If you type characters in one-by-one into an NSTextField, it'll work fine and prevent users from going beyond 10 characters. However, if a user was to paste a string of, say, 25 characters into the Text Field, what'll happen is something like this: 1) User will paste into TextField 2) TextField will accept the string of characters 3) TextField will apply the formatter to the "last" character in the 25-length string 4) Formatter does stuff to the "last" character in the 25-length string, ignoring the rest 5) TextField will end up with 25 characters in it, even though it's limited to 10. This is because, I believe, the first method only applies to the "very last character" typed into an NSTextField. The second method shown above applies to "all characters" typed into the NSTextField. So it's immune to the "paste" exploit. I discovered this just now trying to break my application, and am not an expert on NSFormatter, so please correct me if I'm wrong. And very much thanks to you carlosb for posting that example. It helped a LOT! :)
