[site]: stackoverflow
[post_id]: 2795479
[parent_id]: 2795460
[tags]: 
So if I understand you correctly, the queue itself is not changed (no elements are added or removed to/from it), only its elements are modified, at most by one thread ata time. And these elements (Runnables) are not thread-safe. I think you may still run into a problem with visibility of changes between different threads. If Thread A induced a change in a Runnable R, there is no guarantee that the next thread, B (or any other thread ever, for that matter!) will see the change(s) made by Thread A unless R itself is thread-safe. More precisely, if a field R.f is modified, the modified value of f is guaranteed to be visible to other threads only if f is declared as volatile , or it is only accessed via synchronized blocks (or if it is declared final , but then obviously you can't change its value - only the state of the referenced object if f is a reference. In which case the question becomes whether or not the referenced object itself is thread-safe). Update : you ask in your comment: how can I achieve what I want besides making the Runnable thread-safe? What you want is practically to make your Runnable thread-safe regarding visibility. So your question is almost a contradiction in terms. Quoting from Java Concurrency in Practice , section 3.1.3. Locking and Visibility: Intrinsic locking can be used to guarantee that one thread sees the effects of another in a predictable manner [...]. When thread A executes a synchronized block, and subsequently thread B enters a synchronized block guarded by the same lock, the values of variables that were visible to A prior to releasing the lock are guaranteed to be visible to B upon acquiring the lock. In other words, everything A did in or prior to a synchronized block is visible to B when it executes a synchronized block guarded by the same lock. Without synchronization, there is no such guarantee. And from section 3.1.4. Volatile Variables: The visibility effects of volatile variables extend beyond the value of the volatile variable itself. When thread A writes to a volatile variable and subsequently thread B reads that same variable, the values of all variables that were visible to A prior to writing to the volatile variable become visible to B after reading the volatile variable. So from a memory visibility perspective, writing a volatile variable is like exiting a synchronized block and reading a volatile variable is like entering a synchronized block. However, we do not recommend relying too heavily on volatile variables for visibility; code that relies on volatile variables for visibility of arbitrary state is more fragile and harder to understand than code that uses locking. Use volatile variables only when they simplify implementing and verifying your synchronization policy; avoid using volatile variables when verifying correctness would require subtle reasoning about visibility . Good uses of volatile variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event (such as initialization or shutdown) has occurred. The bottom line of all this is: if you want your class to be thread safe, it is best to make it thread safe :-) Note that even if you can't modify the code of the original Runnable class, you can still create a thread-safe wrapper around it and publish it via the wrapper, effectively making its use thread-safe. However, if (for some reason unknown to me) you don't want or can't make it fully thread-safe, you can (at your own risk) try playing around with the rules explained above: if you can organize your code such that the order of updates to the fields of your Runnable R is always the same accross all threads, you could try declaring the last modified field volatile (or its accessors synchronized ); this would then in theory guarantee that all the other modifications to other fields become visible to other threads together with the update of that last field. To me, such trickery clearly falls into the category which - according to the advice quoted in bold above - should be avoided.
