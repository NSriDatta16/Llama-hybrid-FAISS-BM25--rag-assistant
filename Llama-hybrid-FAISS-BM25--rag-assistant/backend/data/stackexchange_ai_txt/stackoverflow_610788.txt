[site]: stackoverflow
[post_id]: 610788
[parent_id]: 610743
[tags]: 
It really depends on what recursive algorithm you're using. If it's simple recursion, you can do something like this: public int CalculateSomethingRecursively(int someNumber) { return doSomethingRecursively(someNumber, 0); } private int doSomethingRecursively(int someNumber, int level) { if (level >= MAX_LEVEL || !shouldKeepCalculating(someNumber)) return someNumber; return doSomethingRecursively(someNumber, level + 1); } It's worth noting that this approach is really only useful where the level of recursion can be defined as a logical limit. In the case that this cannot occur (such as a divide and conquer algorithm), you will have to decide how you want to balance simplicity versus performance versus resource limitations. In these cases, you may have to switch between methods once you hit an arbritrary pre-defined limit. An effective means of doing this that I have used in the quicksort algorithm is to do it as a ratio of the total size of the list. In this case, the logical limit is a result of when conditions are no longer optimal.
