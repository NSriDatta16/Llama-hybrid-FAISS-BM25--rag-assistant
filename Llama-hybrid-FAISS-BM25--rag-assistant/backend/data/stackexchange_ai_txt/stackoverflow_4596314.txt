[site]: stackoverflow
[post_id]: 4596314
[parent_id]: 4534467
[tags]: 
The depth buffer is more obscured than you think in OpenGL ES; not only is glDrawPixels absent but gl_FragDepth has been removed from GLSL. So you can't write a custom fragment shader to spool values to the depth buffer as you might push colours. The most obvious solution is to pack your depth information into a texture and to use a custom fragment shader that does a depth comparison between the fragment it generates and one looked up from a texture you supply. Only if the generated fragment is closer is it allowed to proceed. The normal depth buffer will catch other cases of occlusion and — in principle — you could use a framebuffer object to create the depth texture in the first place, giving you a complete on-GPU round trip, though it isn't directly relevant to your problem. Disadvantages are that drawing will cost you an extra texture unit and textures use integer components. EDIT: for the purposes of keeping the example simple, suppose you were packing all of your depth information into the red channel of a texture. That'd give you a really low precision depth buffer, but just to keep things clear, you could write a quick fragment shader like: void main() { // write a value to the depth map gl_FragColor = vec4(gl_FragCoord.w, 0.0, 0.0, 1.0); } To store depth in the red channel. So you've partially recreated the old depth texture extension — you'll have an image that has a brighter red in pixels that are closer, a darker red in pixels that are further away. I think that in your question, you'd actually load this image from disk. To then use the texture in a future fragment shader, you'd do something like: uniform sampler2D depthMap; void main() { // read a value from the depth map lowp vec3 colourFromDepthMap = texture2D(depthMap, gl_FragCoord.xy); // discard the current fragment if it is less close than the stored value if(colourFromDepthMap.r > gl_FragCoord.w) discard; ... set gl_FragColor appropriately otherwise ... } EDIT2: you can see a much smarter mapping from depth to an RGBA value here . To tie in directly to that document, OES_depth_texture definitely isn't supported on the iPad or on the third generation iPhone. I've not run a complete test elsewhere.
