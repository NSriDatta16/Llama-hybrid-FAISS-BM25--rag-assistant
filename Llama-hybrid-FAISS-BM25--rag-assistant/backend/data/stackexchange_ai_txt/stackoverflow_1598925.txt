[site]: stackoverflow
[post_id]: 1598925
[parent_id]: 1597949
[tags]: 
Your question is not clear. Define amorphous subsystems . You are " just looking for an abstract approach " but then you seem to want details about an implementation in a conventional programming language (" common pattern for state-machines "). So, what are you asking for? How to implement nested finite state-machines? Some more detail will help the conversation. For a real abstract approach, look at something like Stream X-Machines : ... The X-machine model is structurally the same as the finite state machine , except that the symbols used to label the machine's transitions denote relations of type X→X. ... The Stream X-Machine differs from Eilenberg's model, in that the fundamental data type X = Out* × Mem × In*, where In* is an input sequence, Out* is an output sequence, and Mem is the (rest of the) memory. The advantage of this model is that it allows a system to be driven, one step at a time, through its states and transitions, while observing the outputs at each step. These are witness values, that guarantee that particular functions were executed on each step. As a result, complex software systems may be decomposed into a hierarchy of Stream X-Machines , designed in a top-down way and tested in a bottom-up way. This divide-and-conquer approach to design and testing is backed by Florentin Ipate's proof of correct integration, which proves how testing the layered machines independently is equivalent to testing the composed system. ... But I don't see how the presentation is related to this. He seems to speak about a quite mainstream approach to programming, nothing similar to X-Machines. Anyway, the presentation is quite confusing and I have no time to see the video right now. First impression of the talk, reading the slides only The author touches haphazardly on numerous fields/problems/solutions, apparently without recognizing it: from Peopleware (for example Psychology of programming ), to Software Engineering (for example software product lines ), to various programming techniques. How the various parts are linked and what exactly he is advocating is not clear at all (I'm accustomed to just reading slides and they are usually consequential): Dataflow programming ? Constraints solving for User Interfaces ? For practical implementations, see Garnet for Common Lisp, Amulet / OpenAmulet for C++. What advantages gives us this "new" concept-based generic programming with respect to well-known approaches (for example, tools based on Hoare logic pre/post conditions and invariants or, better, Hoare's Communicating Sequential Processes (CSP) or Hehner's Practical Theory of Programming or some programming language with a sophisticated type-system like ATS , Qi or Epigram and so on)? It seems to me that introducing "concepts" - which, as-is , are specific to C++ - is not more simple than using the alternatives. Is it just about jargon and "politics"? (Finally formal methods... but disguised). Why organizing program modules as a DAG and not as a tree, like David Parnas advocated decades ago in Designing software for ease of extension and contraction ? ( here a directly accessible .pdf and here slides from a lecture). The work on X-Machines probably is an answer to this question (going even beyond DAGs), but, again, the author seems to speak about a quite conventional program development regime in which Parnas' approach is the only sensible. If/when I will see the video I will update this answer.
