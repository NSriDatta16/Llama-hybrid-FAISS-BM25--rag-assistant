[site]: stackoverflow
[post_id]: 5739153
[parent_id]: 4797112
[tags]: 
You actually don't know what you are removing, because it doesn't work like static events which have add,remove if the dlr doesn't see a static event property, it does the following equivalent operations dynamically when you do += and -= . //d.MyEvent += new EventHandler(this.MyHandler); var temp = d.MyEvent; //temp is null temp += new EventHandler(this.MyHandler) //temp is now MyHandler d.MyEvent = temp; //set it back //d.MyEvent -= new EventHandler(this.MyHandler); var temp = d.MyEvent; //temp is MyHandler temp -= new EventHandler(this.MyHandler) //temp is now null d.MyEvent = temp; //set it back EventHandler is a MulticastDelegate so you should think of it like a collection, so if it only had the event handler that you are removing, the set property at the end should be null, as there is nothing left. If you had more events added in the mix it would be clearer. //d.MyEvent += new EventHandler(this.MyHandler); var temp = d.MyEvent; //temp is null temp += new EventHandler(this.MyHandler) //temp is now MyHandler d.MyEvent = temp; //set it back //d.MyEvent += new EventHandler(this.MyHandler2); var temp = d.MyEvent; //temp is MyHandler temp += new EventHandler(this.MyHandler2) //temp is now MyHandler,MyHandler2 d.MyEvent = temp; //set it back //d.MyEvent -= new EventHandler(this.MyHandler); var temp = d.MyEvent; //temp is MyHandler,MyHandler2 temp -= new EventHandler(this.MyHandler) //temp is now MyHandler2 d.MyEvent = temp; //set it back If you have to store it differently and need an add and remove then make a storage class to wrap your behavior and make sure you return it on your TryGet. public DelegateStoreage { public void Add(T del){ //Do your stuff } public void Remove(T del){ //Do your stuff } public static T operator +(DelegateStoreage x, T y) { x.Add(y) return x } public static T operator -( DelegateStoreage x, T y) { x.Remove(y) return y; } }
