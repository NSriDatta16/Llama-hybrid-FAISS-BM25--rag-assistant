[site]: stackoverflow
[post_id]: 2588525
[parent_id]: 2588043
[tags]: 
The XMLEncoder is a generic utility for encoding beans as text. I don't think it is suitable in your case. I wrote a piece of code that does the job, assuming that I understand well your needs. You only have to pass the tree model as a parameter to the toXml method. Note that this is just a draft; You will probably want to handle exceptions differently, and manage your transformation parameters differently. More important, you can manipulate the recursive createTree method in order to change the structure of the XML node created per tree node. public static String toXml(TreeModel model) throws ParserConfigurationException, TransformerException { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); DOMImplementation impl = builder.getDOMImplementation(); // Build an XML document from the tree model Document doc = impl.createDocument(null,null,null); Element root = createTree(doc, model, model.getRoot()); doc.appendChild(root); // Transform the document into a string DOMSource domSource = new DOMSource(doc); TransformerFactory tf = TransformerFactory.newInstance(); Transformer transformer = tf.newTransformer(); transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes"); transformer.setOutputProperty(OutputKeys.METHOD, "xml"); transformer.setOutputProperty(OutputKeys.ENCODING,"UTF-8"); transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4"); transformer.setOutputProperty(OutputKeys.INDENT, "yes"); StringWriter sw = new StringWriter(); StreamResult sr = new StreamResult(sw); transformer.transform(domSource, sr); return sw.toString(); } private static Element createTree(Document doc, TreeModel model, Object node) { Element el = doc.createElement(node.toString()); for(int i=0;i
