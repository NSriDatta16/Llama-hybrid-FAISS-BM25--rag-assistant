[site]: stackoverflow
[post_id]: 2274047
[parent_id]: 1258335
[tags]: 
Here's a shot at it. With this method, you don't need to write any global utility functions. You can use the Zend_Log interface for all your method calls. In your bootstrap, initialize your logger. Make sure to include the file and line event types in your formatter. Then, create the Logger with a custom writer, which will set the values of the file and line event types at runtime. $format = '%file% %line% %message%' . PHP_EOL; $formatter = new Zend_Log_Formatter_Simple($format); $writer = new My_Log_Writer_Stream('file://' . $traceLogPath); $writer->setFormatter($formatter); $log = new Zend_Log($writer); In the custom writer, go through the backtrace and find the first class that isn't related to your logging libraries. There is probably a more elegant way to write this piece, but it seems to work in my environment (I'll vote you up for any good suggestions). When you have found the desired item in the backtrace, add it to the event array and then call the parent's write method. If you have initialized the formatter correctly, it will write the event values to the log string. class My_Log_Writer_Stream extends Zend_Log_Writer_Stream { protected function _write($event) { $backtrace = debug_backtrace(); foreach($backtrace as $traceItem) { $class = $traceItem['class']; if(!is_subclass_of($class, 'Zend_Log') && !is_subclass_of($class, 'Zend_Log_Writer_Abstract') && $class !== 'Zend_Log' && $class !== 'Zend_Log_Writer_Abstract') { break; } } $event['file'] = $traceItem['file']; $event['line'] = $traceItem['line']; parent::_write($event); }
