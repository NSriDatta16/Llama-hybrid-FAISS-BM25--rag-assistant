[site]: stackoverflow
[post_id]: 4672469
[parent_id]: 4671999
[tags]: 
The long delay you observe is due to reading and decoding the images, which UIImageView does before the animation begins. Core Animation performs the animation for you, and it does its drawing in the render server, which is in a separate process. Remember that what you see on the screen doesn't necessarily represent your app's instantaneous picture of your layer tree: Core Animation Rendering Architecture . UIImageView doesn't provide facilities to give you accurate results here. I'd suggest: Make a UIView of your own. Create a CAKeyframeAnimation with discrete calculation mode and your images' CGImageRefs as its values. Set the animation's delegate to your IntroViewController . Add the animation to your view's layer for the "contents" key. Your IntroViewController will get animationDidStop:finished: when it's done. Two things to consider, though: First, you'll get better results using a movie rather than a series of images, since the movie can be streamed from storage. Second, and more importantly, this solution will improve the timing situation but will not totally mitigate it. animationDidStop:finished: is called when your app thinks the animation is doneâ€¦ which is not necessarily exactly when it appears to finish. You'll do better if you don't rely on delegate callbacks for media timing: instead, add this animation and the animation transitioning your views (using a CAAnimationGroup if necessary) in the same turn of the run loop. Delay the latter with a beginTime of the first animation's duration. Depending on what you're doing, you may have to set the second animation's fill mode as well to get the correct behavior during the first.
