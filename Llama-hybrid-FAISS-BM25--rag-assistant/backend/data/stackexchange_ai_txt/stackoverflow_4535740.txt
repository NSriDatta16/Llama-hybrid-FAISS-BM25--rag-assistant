[site]: stackoverflow
[post_id]: 4535740
[parent_id]: 
[tags]: 
Generic class for performing mass-parallel queries. Feedback?

I don't understand why, but there appears to be no mechanism in the client library for performing many queries in parallel for Windows Azure Table Storage. I've created a template class that can be used to save considerable time, and you're welcome to use it however you wish. I would appreciate however, if you could pick it apart, and provide feedback on how to improve this class. public class AsyncDataQuery where T: new() { public AsyncDataQuery(bool preserve_order) { m_preserve_order = preserve_order; this.Queries = new List >(1000); } public void AddQuery(IQueryable query) { var data_query = (DataServiceQuery )query; var uri = data_query.RequestUri; // required this.Queries.Add(new CloudTableQuery (data_query)); } /// /// Blocking but still optimized. /// public List Execute() { this.BeginAsync(); return this.EndAsync(); } public void BeginAsync() { if (m_preserve_order == true) { this.Items = new List (Queries.Count); for (var i = 0; i (Queries.Count * 2); } m_wait = new ManualResetEvent(false); for (var i = 0; i EndAsync() { m_wait.WaitOne(); m_wait.Dispose(); return this.Items; } private List Items { get; set; } private List > Queries { get; set; } private bool m_preserve_order; private ManualResetEvent m_wait; private int m_completed = 0; private object m_lock = new object(); private void callback(IAsyncResult ar) { int i = (int)ar.AsyncState; CloudTableQuery query = Queries[i]; var response = query.EndExecuteSegmented(ar); if (m_preserve_order == true) { // preserve ordering only supports one result per query lock (m_lock) { this.Items[i] = response.Results.Single(); } } else { // add any number of items lock (m_lock) { this.Items.AddRange(response.Results); } } if (response.HasMoreResults == true) { // more data to pull query.BeginExecuteSegmented(response.ContinuationToken, callback, i); return; } m_completed = Interlocked.Increment(ref m_completed); if (m_completed == Queries.Count) { m_wait.Set(); } } }
