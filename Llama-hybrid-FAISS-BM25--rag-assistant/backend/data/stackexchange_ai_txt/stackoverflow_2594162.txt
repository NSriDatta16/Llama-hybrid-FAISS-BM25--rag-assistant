[site]: stackoverflow
[post_id]: 2594162
[parent_id]: 2589948
[tags]: 
It appears that another workaround is to revert to software rendering as opposed to taking advantage of hardware acceleration. This was the suggestion by Marco Zhou on the MSDN Forums. public partial class UserControl1 : UserControl { public UserControl1() { InitializeComponent(); this.Loaded += delegate { var source = PresentationSource.FromVisual(this); var hwndTarget = source.CompositionTarget as HwndTarget; if (hwndTarget != null) { hwndTarget.RenderMode = RenderMode.SoftwareOnly; } }; } } I've tested this and this solution seems to work very well and so far is the only solution that I've found for solving this problem within a FoxPro interop scenario which is very similar to the WinForms one I posted about originally. For now I'm planning to use my original Refresh on the MDI Parent solution for my WinForms project but then for my other native interop applications such as when my WPF controls are hosted in Visual FoxPro I'll use this solution. That is unless of course if a more elegant solution is discovered for either of the cases. Also it's important to note that from what I'm aware software rendering is the only option on XP systems and normally Visual FoxPro nore WinForms normally take advantage of the same type of hardware acceleration that native WPF apps do on Vista OS and up. So using this option may not be as bad as it sounds when you do have to deal with interop. Currently I'm not aware of any related side effects when using this solution but if there are any those would have to be taken into serious consideration.
