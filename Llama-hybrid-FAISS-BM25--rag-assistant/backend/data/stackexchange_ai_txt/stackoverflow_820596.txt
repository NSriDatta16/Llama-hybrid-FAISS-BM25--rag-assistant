[site]: stackoverflow
[post_id]: 820596
[parent_id]: 818981
[tags]: 
I see nothing particularly weird about connecting a widget to itself. Having a single method of detecting and responding to data updates actually sounds like a good thing because you have fewer points of failure to check when you are debugging. In your specific case, it is causing some undesired behavior, but in general it is a fine solution. Now, having expressed the opinion that a reflexive connection isn't inherently inelegant, I am going to suggest a less than "elegant" solution to prevent the calling of valueChanged after construction. You can have a flag to determine whether the object was just constructed and return early to prevent the code being run immediately after construction. In your example: class ValueWriterInt: public QSpinBox { Q_OBJECT public: ValueWriterInt(vector const& value): myValue(value), myAfterInit(true) { QObject::connect(this, SIGNAL(valueChanged(int)), this, SLOT(valueChanged(int))); } ~ValueWriterInt() {} private slots: void valueChanged(int new_value) { if (myAfterInit) { myAfterInit = false; return; } for (auto it = myValue.begin(); it != myValue.end(); ++it) **it = new_value; } private: vector myValue; boolean myAfterInit; }; That isn't too bad of a solution. It will at least give you your desired behavior until (and if) you can find a more elegant method.
