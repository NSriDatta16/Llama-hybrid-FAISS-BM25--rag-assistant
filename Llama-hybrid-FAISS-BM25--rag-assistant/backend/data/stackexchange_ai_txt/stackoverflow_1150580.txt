[site]: stackoverflow
[post_id]: 1150580
[parent_id]: 1150558
[tags]: 
Building a self-balancing binary tree like a red-black tree or AVL tree will allow for Θ(lg n) insertion and removal, and Θ(n) retrieval of all elements in sorted order (by doing a depth-first traversal), with Θ(n) memory usage. The implementation is somewhat complex, but they're efficient, and most languages will have library implementations, so they're a good first choice in most cases. Additionally, retreiving the i-th element can be done by annotating each edge (or, equivalently, node) in the tree with the total number of nodes below it. Then one can find the i-th element in Θ(lg n) time and Θ(1) space with something like: node *find_index(node *root, int i) { while (node) { if (i == root->left_count) return root; else if (i left_count) root = root->left; else { i -= root->left_count + 1; root = root->right; } } return NULL; // i > number of nodes } An implementation that supports this can be found in debian's libavl ; unfortunately, the maintainer's site seems down, but it can be retrieved from debian's servers .
