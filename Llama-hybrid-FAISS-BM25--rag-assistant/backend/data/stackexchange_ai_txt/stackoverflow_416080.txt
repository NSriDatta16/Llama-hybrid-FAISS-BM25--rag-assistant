[site]: stackoverflow
[post_id]: 416080
[parent_id]: 415991
[tags]: 
You can use a parameter in the constructor to pass it in: public ApplicationController(string movieCategory) { ViewData["categories"] = DataContext.spMovieCategories(movieCategory); } Obviously, you'd need to be able to supply this from the derived controllers, which may be an issue unless the category is specific to each derived controller which seems unlikely: public DerivedController() : base("Derived Movie Category") { // ... } What is probably best is to move the categories retrieval out of the constructor, and move it into a separate method in ApplicationController. The simplest way of getting this called is then to insert a call to it in each Action once you have the category parameter (I'm assuming it's one of the parameters to the Action call?). This is a bit of a pain though. The intended way to solve this problem is ActionFilters, if you create a new ActionFilter like this: public class CategoryAttribute : ActionFilterAttribute, IActionFilter { #region IActionFilter Members void IActionFilter.OnActionExecuted(ActionExecutedContext filterContext) { string category = (string)filterContext.RouteData.Values["category"]; ((ApplicationController)filterContext.Controller).PopulateCategory(category); } void IActionFilter.OnActionExecuting(ActionExecutingContext filterContext) { } #endregion } Any action with the Category attribute applied will execute this code. (I've assumed that you've moved the code in ApplicationController into a method called PopulateCategory . You can also apply it at the Controller level, which then will cause this ActionFilter to be called for every action in the controller. Since you want it to be called for every action on every controller, you can apply it to your ApplicationController so that every derived controller will inherit it: [Category] public class ApplicationController : Controller { // ... } [Edit - Slightly better solution] However, an even further step to simplify is to not use an attribute, but instead to override the OnActionExecuted method of Controller (that I just noticed after I wrote this answer). That means you can get rid of the CategoryAttribute class and the Category attribute on the ApplicationController class and just add this to the ApplicationController class: protected override void OnActionExecuted(ActionExecutedContext filterContext) { string category = (string)filterContext.RouteData.Values["category"]; this.PopulateCategory(category); base.OnActionExecuted(filterContext); }
