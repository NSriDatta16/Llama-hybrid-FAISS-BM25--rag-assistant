[site]: stackoverflow
[post_id]: 5502776
[parent_id]: 5502135
[tags]: 
What I would do is take a step back. Your analysis seems to be wedded to an implementation detail, namely that you have chosen bool[] as how you represent a string of bits. Clear your mind of bools and arrays and make a complete list of the operations you actually need to perform, how frequently they happen, and how fast they have to be. Ideally consider whether your speed requirement is average speed or worst case speed . (There are many data structures that attain high average speed by having one expensive operation for every thousand cheap operations; if having any expensive operations is unacceptable then you need to know that up front.) Once you have that list, you can then do research on what data structures work well. For example, suppose your list of operations is: construct bit sequences on the order of 32 bits concatenate on the order of 3000 bit sequences together to form new bit sequences insert new bit sequences into existing long bit sequences at specific locations, quickly Given just that list of operations, I'd think that the data structure you want is a catenable deque . Catenable deques support fast insertion on either end, and can be broken up into two deques efficiently. Inserting stuff into the middle of a deque is then easily done: break the deque up, insert the item into the end of one half, and join them back up again. However, if you then add another operation to the problem, say, "search for a particular bit string anywhere in the 90000-bit sequence, and find the result in sublinear time " then just a catenable deque isn't going to do it. Searching a deque is slow. There are other data structures that support that operation.
