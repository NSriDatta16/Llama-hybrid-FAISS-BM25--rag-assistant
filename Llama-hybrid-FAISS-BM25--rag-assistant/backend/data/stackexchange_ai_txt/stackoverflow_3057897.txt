[site]: stackoverflow
[post_id]: 3057897
[parent_id]: 2845183
[tags]: 
As announced in the question, edit 3: Here is another solution which, as far as I can judge, fulfills the requirements in the question. It is similar to the solution described in the original question, but uses boost::shared_ptr instead of a custom smart pointer. The central idea of this solution is to provide a release() operation on shared_ptr . If we can make the shared_ptr give up its ownership, we are free to call a cleanup function, delete the object, and throw an exception in case an error occurred during cleanup. Boost has a good reason to not provide a release() operation on shared_ptr : shared_ptr cannot give away ownership unless it's unique() because the other copy will still destroy the object. Consider: shared_ptr a(new int); shared_ptr b(a); // a.use_count() == b.use_count() == 2 int * p = a.release(); // Who owns p now? b will still call delete on it in its destructor. Furthermore, the pointer returned by release() would be difficult to deallocate reliably, as the source shared_ptr could have been created with a custom deleter. The first argument against a release() operation is that, by the nature of shared_ptr , many pointers share ownership of the object, so no single one of them can simply release that ownership. But what if the release() function returned a null pointer if there were still other references left? The shared_ptr can reliably determine this, without race conditions. The second argument against the release() operation is that, if a custom deleter was passed to the shared_ptr , you should use that to deallocate the object, rather than simply deleting it. But release() could return a function object, in addition to the raw pointer, to enable its caller to deallocate the pointer reliably. However, in our specific szenario, custom deleters will not be an issue, because we do not have to deal with arbitrary custom deleters. This will become clearer from the code given below. Providing a release() operation on shared_ptr without modifying its implementation is, of course, not possible without a hack. The hack which is used in the code below relies on a thread-local variable to prevent our custom deleter from actually deleting the object. That said, here's the code, consisting mostly of the header Resource.hpp , plus a small implementation file Resource.cpp . Note that it must be linked with -lboost_thread-mt due to the thread-local variable. // --------------------------------------------------------------------- // Resource.hpp // --------------------------------------------------------------------- #include #include #include #include /// Factory for a resource. template struct ResourceFactory { /// Create a resource. static boost::shared_ptr create() { return boost::shared_ptr (new T, ResourceFactory()); } template static boost::shared_ptr create(const A1& a1) { return boost::shared_ptr (new T(a1), ResourceFactory()); } template static boost::shared_ptr create(const A1& a1, const A2& a2) { return boost::shared_ptr (new T(a1, a2), ResourceFactory()); } // ... /// Destroy a resource. static void destroy(boost::shared_ptr & resource); /// Deleter for boost::shared_ptr . void operator()(T* resource); }; namespace impl { // --------------------------------------------------------------------- /// Return the last reference to the resource, or zero. Resets the pointer. template T* release(boost::shared_ptr & resource); /// Return true if the resource should be deleted (thread-local). bool wantDelete(); // --------------------------------------------------------------------- } // namespace impl template inline void ResourceFactory ::destroy(boost::shared_ptr & ptr) { T* resource = impl::release(ptr); if (resource != 0) // Is it the last reference? { try { resource->close(); } catch (...) { delete resource; throw; } delete resource; } } // --------------------------------------------------------------------- template inline void ResourceFactory ::operator()(T* resource) { if (impl::wantDelete()) { try { resource->close(); } catch (...) { } delete resource; } } namespace impl { // --------------------------------------------------------------------- /// Flag in thread-local storage. class Flag { public: ~Flag() { m_ptr.release(); } Flag& operator=(bool value) { if (value != static_cast (*this)) { if (value) { m_ptr.reset(s_true); // may throw boost::thread_resource_error! } else { m_ptr.release(); } } return *this; } operator bool() { return m_ptr.get() == s_true; } private: boost::thread_specific_ptr m_ptr; static char* s_true; }; // --------------------------------------------------------------------- /// Flag to prevent deletion. extern Flag t_nodelete; // --------------------------------------------------------------------- /// Return the last reference to the resource, or zero. template T* release(boost::shared_ptr & resource) { try { BOOST_ASSERT(!t_nodelete); t_nodelete = true; // may throw boost::thread_resource_error! } catch (...) { t_nodelete = false; resource.reset(); throw; } T* rv = resource.get(); resource.reset(); return wantDelete() ? rv : 0; } // --------------------------------------------------------------------- } // namespace impl And the implementation file: // --------------------------------------------------------------------- // Resource.cpp // --------------------------------------------------------------------- #include "Resource.hpp" namespace impl { // --------------------------------------------------------------------- bool wantDelete() { bool rv = !t_nodelete; t_nodelete = false; return rv; } // --------------------------------------------------------------------- Flag t_nodelete; // --------------------------------------------------------------------- char* Flag::s_true((char*)0x1); // --------------------------------------------------------------------- } // namespace impl And here is an example of a resource class implemented using this solution: // --------------------------------------------------------------------- // example.cpp // --------------------------------------------------------------------- #include "Resource.hpp" #include #include #include #include // uncomment to test failed resource allocation, usage, and deallocation //#define TEST_CREAT_FAILURE //#define TEST_USAGE_FAILURE //#define TEST_CLOSE_FAILURE // --------------------------------------------------------------------- /// The low-level resource type. struct foo { char c; }; // --------------------------------------------------------------------- /// The low-level function to allocate the resource. foo* foo_open() { #ifdef TEST_CREAT_FAILURE return 0; #else return (foo*) std::malloc(sizeof(foo)); #endif } // --------------------------------------------------------------------- /// Some low-level function using the resource. int foo_use(foo*) { #ifdef TEST_USAGE_FAILURE return -1; #else return 0; #endif } // --------------------------------------------------------------------- /// The low-level function to free the resource. int foo_close(foo* foo) { std::free(foo); #ifdef TEST_CLOSE_FAILURE return -1; #else return 0; #endif } // --------------------------------------------------------------------- /// The C++ wrapper around the low-level resource. class Foo { public: void use() { if (foo_use(m_foo) ; }; // --------------------------------------------------------------------- typedef ResourceFactory FooFactory; // --------------------------------------------------------------------- /// Main function. int main() { try { boost::shared_ptr resource = FooFactory::create(); resource->use(); FooFactory::destroy(resource); } catch (const std::exception& e) { std::cerr Finally, here is a small Makefile to build all that: # Makefile CXXFLAGS = -g -Wall example: example.cpp Resource.hpp Resource.o $(CXX) $(CXXFLAGS) -o example example.cpp Resource.o -lboost_thread-mt Resource.o: Resource.cpp Resource.hpp $(CXX) $(CXXFLAGS) -c Resource.cpp -o Resource.o clean: rm -f Resource.o example
