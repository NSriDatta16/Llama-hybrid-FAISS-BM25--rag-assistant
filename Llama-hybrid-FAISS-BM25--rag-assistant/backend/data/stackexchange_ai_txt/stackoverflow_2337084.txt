[site]: stackoverflow
[post_id]: 2337084
[parent_id]: 2328495
[tags]: 
Because the function p() monotonically increasing you can avoid comparing the values as g > i implies p(g) > p(i) . Also, the inner loop can be broken early because p(g) - p(i) >= diff implies p(g+1) - p(i) >= diff . Also for correctness, I changed the equality comparison in quickCheck to compare difference against an epsilon because exact comparison with floating point is pretty fragile. On my machine this reduced the runtime to 7.8ms using Python 2.6. Using PyPy with JIT reduced this to 0.77ms. This shows that before turning to micro-optimization it pays to look for algorithmic optimizations. Micro-optimizations make spotting algorithmic changes much harder for relatively tiny gains. EPS = 0.00000001 def quickCheck(n): partial_c = sqrt(1 + 24*n) / -6 c = 1/6 + partial_c if abs(int(c) - c) = diff: break if quickCheck(p(g) - p(i)) and quickCheck(p(g) + p(i)): print('New couple ', p(g), p(i), p(g) - p(i)) diff = p(g) - p(i)
