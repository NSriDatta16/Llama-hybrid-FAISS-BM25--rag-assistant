[site]: stackoverflow
[post_id]: 2234796
[parent_id]: 2233509
[tags]: 
I'm by far no expert here, but some more information that might be useful: According to this , GC threads are created on CLR startup, at least for server GC, so not having enough threads for a GC run is possibly not even possible ;-) The "Disabled" in the "GC" column of thread 21 just means that it decided to not be preemted by an eventual GC operation. This happends when the code on thread decides that it is doing a critical operation that should not be disturbed by a GC (like loading and assembly, hence fusion). From the "kb" command output I would guess that you are actually using the server GC (stackframe "mscorwks!SVR::gc_heap::make_heap_segment"; workstation GC would have something with the class/namespace "WKS"). This is not unexpected as it should be the default on a "server operating" system. You should make sure about this using the "!eeversion" command. Additionally you should find out how many cores you have, because if the server GC runs, it will use as many threads (one per logical/physical core). Could it be, that the timer is firing pretty often, or faster than the previous one is finished. You can get an overview of threadpool thread usage using the "!ThreadPool" command. Also, you might want to check the actual arguments to the methods and locals (!clrstack -a) and/or the current objects on the stack (!dso). Maybe that can shed some more light. As wild guess, some googling for "System.Net.ConnectionPool.CleanupCallbackWrapper" yield the following links, maybe that could be your problem? Debugging high cpu usage SmtpClient does not close session after sending message issue with high cpu usage in web app with no load
