[site]: stackoverflow
[post_id]: 4612301
[parent_id]: 4611302
[tags]: 
The standard has std::locale for locale-specific things such as collation (sorting). If the environment contains LC_COLLATE=en_US.utf8 or similar, this program will sort lines as desired. #include #include #include #include #include #include #include class collate_in : public std::binary_function { protected: const std::collate &coll; public: collate_in(std::locale loc) : coll(std::use_facet >(loc)) {} bool operator()(const std::string &a, const std::string &b) const { // std::collate::compare() takes C-style string (begin, end)s and // returns values like strcmp or strcoll. Compare to 0 for results // expected for a less<>-style comparator. return coll.compare(a.c_str(), a.c_str() + a.size(), b.c_str(), b.c_str() + b.size()) v; copy(std::istream_iterator (std::cin), std::istream_iterator (), back_inserter(v)); // std::locale("") is the locale from the environment. One could also // std::locale::global(std::locale("")) to set up this program's global // first, and then use locale() to get the global locale, or choose a // specific locale instead of using the environment's. sort(v.begin(), v.end(), collate_in(std::locale(""))); copy(v.begin(), v.end(), std::ostream_iterator (std::cout, "\n")); return 0; } $ cat >file f é e d ^D $ LC_COLLATE=C ./a.out file d e f é $ LC_COLLATE=en_US.utf8 ./a.out file d e é f It's been brought to my attention that std::locale::operator()(a, b) exists, obviating the std::collate<>::compare(a, b) wrapper I wrote above. #include #include #include #include #include #include int main() { std::vector v; copy(std::istream_iterator (std::cin), std::istream_iterator (), back_inserter(v)); sort(v.begin(), v.end(), std::locale("")); copy(v.begin(), v.end(), std::ostream_iterator (std::cout, "\n")); return 0; }
