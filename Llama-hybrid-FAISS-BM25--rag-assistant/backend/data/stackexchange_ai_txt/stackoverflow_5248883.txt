[site]: stackoverflow
[post_id]: 5248883
[parent_id]: 4540463
[tags]: 
I reckon the easiest route to go is to use the old Windows multimedia API because it's really straight forward. Here's the link to MSDN: http://msdn.microsoft.com/en-us/library/dd743586(v=VS.85).aspx What you do is that you use the waveInOpen function to get an input device. To figure out what device to use you don't enumerate all the devices but you can query each and one of them. The number of installed devices is returned by calling waveInGetNumDevs . You can then call waveInGetDevCaps for each device and inspect those properties. When you have your device handle you then repeatedly call waveInAddBuffer to get small chunks of data. Depending on the format you specified during waveInOpen the bytes represent the raw audio data. Amplitude in 8 or 16-bit signed or unisnged sampled at some frequency. You could then apply a rolling average to smooth the signal and just print that. C# doesn't have a sound API that I know of, so what you do is that you use P/Invoke to get at the Win32 API functions. This is fairly straight forward, you only need to port small versions of the Win32 headers to be able to call them from C# directly. If you're more hardcore you could write a wrapper library in C++/CLI. That's not that bad of an idea because it let's you use existing Windows C/C++ header files and mix C++ and managed code in intresting ways. Just be careful with the unmanaged resources and you'll have a very powerful intropability library in no time. But there's also more advanced audio APIs starting with Windows Vista, the Windows Core Audio components which could be more interesting further along the line. But for basic I/O operation the Windows multimedia functions will get you there faster. I've used these functions on a number of occasions when building simple software synthesizers. Sadly that code is long gone.
