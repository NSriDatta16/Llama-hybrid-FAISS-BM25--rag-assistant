[site]: stackoverflow
[post_id]: 3267377
[parent_id]: 3266209
[tags]: 
I think your last paragraph suggests a good solution. Using the MVVM Light Toolkit , I would use messaging with a callback to send the message out and allow any number of subscribers to call back with a cancellation. public class AccountSelectedMessage : NotificationMessageAction { public AccountSelectedMessage(Account selectedAccount, Action callback) : base("AccountSelectedWithCancelCallback", callback) { SelectedAccount = selectedAccount; } public AccountSelectedMessage(object sender, Account selectedAccount, Action callback) : base(sender, "AccountSelectedWithCancelCallback", callback) { SelectedAccount = selectedAccount; } public AccountSelectedMessage(object sender, object target, Account selectedAccount, Action callback) : base(sender, target, "AccountSelectedWithCancelCallback", callback) { SelectedAccount = selectedAccount; } public Account SelectedAccount { get; private set; } } public class AccountListViewModel : ViewModelBase { public RelayCommand AccountSelectedCommand = new RelayCommand (AccountSelectedCommandExecute); private void AccountSelectedCommandExecute(Account selectedAccount) { MessengerInstance.Send(new AccountSelectedMessage(this, AccountSelectionCanceled)); } private void AccountSelectionCanceled(bool canceled) { if (canceled) { // cancel logic here } } } public class SomeOtherViewModel : ViewModelBase { public SomeOtherViewModel() { MessengerInstance.Register (this, AccountSelectedMessageReceived); } private void AccountSelectedMessageReceived(AccountSelectedMessage msg) { bool someReasonToCancel = true; msg.Execute(someReasonToCancel); } } As you can see, this process would need to be asynchronous and take into account that you don't know how many recipients of the message could cancel, or how long they would take to respond.
