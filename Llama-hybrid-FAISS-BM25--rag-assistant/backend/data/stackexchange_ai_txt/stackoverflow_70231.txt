[site]: stackoverflow
[post_id]: 70231
[parent_id]: 70074
[tags]: 
Ok, I'll try to help here : First a module is not a class, it allows you to mix behaviour in a class. second see the following example : module A module B module Error def foobar puts "foo" end end end end class StandardError include A::B::Error end StandardError.new.kind_of?(A::B::Error) StandardError.new.kind_of?(A::B) StandardError.included_modules #=> [A::B::Error,Kernel] kind_of? tells you that yes, Error does possess All of A::B::Error behaviour (which is normal since it includes A::B::Error) however it does not include all the behaviour from A::B and therefore is not of the A::B kind. (duck typing) Now there is a very good chance that ruby-aws reopens one of the superclass of NameError and includes Amazon::AWS:Error in there. (monkey patching) You can find out programatically where the module is included in the hierarchy with the following : class Class def has_module?(module_ref) if self.included_modules.include?(module_ref) and not self.superclass.included_modules.include?(module_ref) puts self.name+" has module "+ module_ref.name else self.superclass.nil? ? false : self.superclass.has_module?(module_ref) end end end StandardError.has_module?(A::B::Error) NameError.has_module?(A::B::Error) Regarding your second question I can't see anything better than begin #do AWS error prone stuff rescue Exception => e if Amazon::AWS::Error.constants.include?(e.class.name) #awsError else whatever end end (edit -- above code doesn't work as is : name includes module prefix which is not the case of the constants arrays. You should definitely contact the lib maintainer the AWSError class looks more like a factory class to me :/ ) I don't have ruby-aws here and the caliban site is blocked by the company's firewall so I can't test much further. Regarding the include : that might be the thing doing the monkey patching on the StandardError hierarchy. I am not sure anymore but most likely doing it at the root of a file outside every context is including the module on Object or on the Object metaclass. (this is what would happen in IRB, where the default context is Object, not sure about in a file) from the pickaxe on modules : A couple of points about the include statement before we go on. First, it has nothing to do with files. C programmers use a preprocessor directive called #include to insert the contents of one file into another during compilation. The Ruby include statement simply makes a reference to a named module. If that module is in a separate file, you must use require to drag that file in before using include. (edit -- I can't seem to be able to comment using this browser :/ yay for locked in platforms)
