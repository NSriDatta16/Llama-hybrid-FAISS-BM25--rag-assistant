[site]: stackoverflow
[post_id]: 4155109
[parent_id]: 4155009
[tags]: 
That "All" item has to be part of the list you bind your ListBox against. Natuarally you can not add that item to the DataHolder list because it holds items of type Customer (or similar). You could of course add a "magic" Customer that always acts as the "All" item but that is for obvious reasons a serious case of design smell (it is a list of Customers after all). What you could do, is to not bind against the DataHolder list directly but introduce a wrapper. This wrapper would be your ViewModel. You would bind your ListBox agains a list of CustomerListItemViewModel that represents either a Customer or the "All" item. CustomerViewModel { string Id { get; private set; } string Name { get; set; } public static readonly CustomerViewModel All { get; private set; } static CustomerViewModel() { // set up the one and only "All" item All = new CustomerViewModel(); All.Name = ResourceStrings.All; } private CustomerViewModel() { } public CustomerViewModel(Customer actualCustomer) { this.Name = actualCustomer.Name; this.Id = actualCustomer.Id; } } someOtherViewModel.Customers = new ObservableCollection (); // add all the wrapping CustomerViewModel instances to the collection someOtherViewModel.Customers.Add(CustomerViewModel.All); And then in your Drag&Drop code somewhere in the ViewModel: if(tragetCustomerViewModelItem = CustomerViewModel.All) { // something was dropped to the "All" item } I might have just introduced you to the benefits of MVVM in WPF. It saves you a lot of hassle in the long run.
