[site]: stackoverflow
[post_id]: 3266626
[parent_id]: 3266493
[tags]: 
I do the following (array type is container/iterator range concept): ublas::matrix A; foreach (double & element, A.data()) { } However, this will not work for slices: your best solution is to write an iterator for them. Here is an example of using multi_array to provide storage of a custom class. Perhaps you could do the same: template struct tensor_array : boost::multi_array_ref { typedef boost::multi_array_ref base_type; typedef T value_type; typedef T& reference; typedef const T& const_reference; tensor_array() : base_type(NULL, extents()) { // std::cout tensor_array(const A &dims) : base_type(NULL, extents()) { //std::cout void resize(const U (&dims)[N]) { boost::array dims_; std::copy(dims, dims + N, dims_.begin()); resize(dims_); } template void resize(const boost::array &dims) { size_t size = 1; boost::array shape; for (size_t i = 0; i num_elements_ = size; reshape(shape); } size_t size() const { return data_.size(); } size_t size(size_t i) const { return this->shape()[N-(i+1)]; } tensor_array& fill(const T &value) { std::fill(data_.begin(), data_.end(), value); return *this; } private: typedef boost::detail::multi_array::extent_gen extents; std::vector data_; };
