[site]: stackoverflow
[post_id]: 2431450
[parent_id]: 2253950
[tags]: 
Well the preferred way in C++ for file IO is by stream. So in the example above it would make much more sense maybe to inject a stream instead of a file name. For example, Foo(const std::stream& file) : file_(file) In that way you could use std::stringstream for unit testing and have full control of the test. If you do not want to use streams then the standard example of a RAII pattern defining a File class can be used. The "simple" way to proceed then is to create a pure virtual interface class File and then an implementation of the interface. The Foo class would then use the interface class File. For example, Foo(const File& file) : file_(file) Testing is then done by simply creating a simple subclass to File and injecting that instead (stubbing). Creating a mock class (see Google Mock for example) can also be done. However, you probable want to unit test the File implementation class as well and since it is RAII, it in turn needs some dependency injection. I usually try to create an pure virtual interface class that just provide the basic C file operations (open, close, read, write, etc. or fopen, fclose, fwrite, fread, etc). For example, class FileHandler { public: virtual ~FileHandler() {} virtual int open(const char* filename, int flags) = 0; // ... and all the rest }; class FileHandlerImpl : public FileHandlerImpl { public: virtual int open(const char* filename, int flags) { return ::open(filename, flags); } // ... and all the rest in exactly the same maner }; This FileHandlerImpl class is so simple that I do not unit test it. However, the benefit is that using it in the constructor of the FileImpl class I can easily unit test the FileImpl class. For example, FileImple(const FileHandler& fileHandler, const std::string& fileName) : mFileHandler(fileHandler), mFileName(fileName) The only drawback so far is that the FileHandler has to be passed around. I have thought of using the FileHandle interface to actually provide a static instance set/get-methods that can be used to get a single global instance of a FileHandler object. Although not really a singleton and thus still unit testable it is not a elegant solution. I guess passing a handler around is the best option right now.
