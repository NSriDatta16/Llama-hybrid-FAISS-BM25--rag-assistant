[site]: stackoverflow
[post_id]: 210994
[parent_id]: 210821
[tags]: 
Here is a solution: function appendToSelect() { $("#mySelect").children().remove(); $("#mySelect").html( ' ' + obj.data[0].name + ' ' ); obj.data.splice(0, 1); // we only want remaining data var appendOptions = function() { var dataChunk = obj.data.splice(0, 10); // configure this last number (the size of the 'chunk') to suit your needs for(var i = 0; i ' + dataChunk[i].name + ' ' ); } if(obj.data.length > 0) { setTimeout(appendOptions, 100); // change time to suit needs } }; appendOptions(); // kicks it off } Not as elegant as @Borgar's solution, but you get the idea. Basically, I am doing the same thing, but all in your one function rather than breaking it into a higher-order function like he does. I like his solution, but if you don't, perhaps this will work for you. EDIT: For those that don't immediately see it, one of the main differences between this solution and @Borgar's is that this solution allows you to set the size of the 'chunks' of data that is processed between each timeout. @Borgar's times-out after every single member of the array is processed. If I get time, I will try to create a higher-order function to handle this so it is more elegant. No promises though! ;) EDIT: So, here is my adaptation of @Borgar's solution, which allows for setting a 'chunk' size and configuring the timeout value more easily: function incrementallyProcess(workerCallback, data, chunkSize, timeout, completionCallback) { var itemIndex = 0; (function() { var remainingDataLength = (data.length - itemIndex); var currentChunkSize = (remainingDataLength >= chunkSize) ? chunkSize : remainingDataLength; if(itemIndex ' + obj.data[0].name + ' ' ); obj.data.splice(0,1); // we only want remaining data incrementallyProcess(function(data) { $("#mySelect").append( ' ' + data.name + ' ' ); }, obj.data, 10, 100, removeAnimatedGifFunction); // last function not required... } Hope that helps - I think this combines the best of both solutions. Notice , the second anonymous function no longer uses the index value, but simply passes in the entire object (with the value and name properties); that makes it a bit cleaner, since the index of the current object really isn't usually that useful when iterating over things, IMO. I am sure there are still things that could be done to make this even better, but that is left as an exercise for the reader. ;)
