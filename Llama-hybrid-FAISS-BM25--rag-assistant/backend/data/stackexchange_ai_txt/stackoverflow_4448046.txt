[site]: stackoverflow
[post_id]: 4448046
[parent_id]: 4445509
[tags]: 
C++0x provides a new construct (in [meta.type.synop] 20.7.6.6 other transformations ): std::aligned_storage which is guaranteed to be always correctly aligned as far as I recall. The second parameter is optional, and defaults to the most stringent requirement possible (so that it's always safe not to precise it, but that you may pack your types more compactly if you are willing to try). Apart from bugs , the compiler is bound to honor the requirement. If you do not have C++0x, this may be found in the tr1 namespace or on Boost . You're the only one who can test that your particular compiler does honor this request :) Note: on gcc-4.3.2 , it is implemented as: template struct aligned_storage { union type { unsigned char __data[_Len]; struct __attribute__((__aligned__((_Align)))) { } __align; }; };
