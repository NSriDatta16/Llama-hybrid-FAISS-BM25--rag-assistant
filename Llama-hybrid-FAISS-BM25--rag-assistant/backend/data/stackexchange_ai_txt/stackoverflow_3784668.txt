[site]: stackoverflow
[post_id]: 3784668
[parent_id]: 3780921
[tags]: 
Adding zeros as the imaginary is conceptually the first step in what you want to do. Initially you have a real only signal that looks like this in the frequency domain: [r0, r1, r2, r3, ...] /-~--------\ DC +Fs/2 If you stuff it with zeros for the imaginary value, you'll see that you really have both positive and negative frequencies as mirror images: [r0 + 0i, r1 + 0i, r2 + 0i, r3 + 0i, ...] /--------~-\ /-~--------\ -Fs/2 DC +Fs/2 Next, you multiply that signal in the time domain by a complex tone at -Fs/4 (tuning the signal). Your signal will look like ----~-\ /-~--------\ /------ DC So now, you filter out the center half and you get: ________/-~--------\________ DC Then you decimate by two and you end up with: /-~--------\ Which is what you want. All of these steps can be performed efficiently in the time domain. If you pay attention to all of the intermediate steps, you'll notice that there are many places where you're multiplying by 0, +1, -1, +i, or -i. Furthermore, the half band low pass filter will have a lot of zeros and some symmetry to exploit. Since you know you're going to decimate by 2, you only have to calculate the samples you intend to keep. If you work through the algebra, you'll find a lot of places to simplify it for a clean and fast implementation. Ultimately, this is all equivalent to a Hilbert transform, but I think it's much easier to understand when you decompose it into pieces like this. Converting back to real from complex is similar. You'll stuff it with zeroes for every other sample to undo the decimation. You'll filter the complex signal to remove an alias you just introduced. You'll tune it up by Fs/4, and then throw away the imaginary component. (Sorry, I'm all ascii-arted out... :-) Note that this conversion is lossy near the boundaries. You'd have to use an infinite length filter to do it perfectly.
