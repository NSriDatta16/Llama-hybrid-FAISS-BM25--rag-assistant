[site]: stackoverflow
[post_id]: 2693450
[parent_id]: 2693199
[tags]: 
First of all, the Standard is ambivalent on the use of "name", i think. First, it says (added the other forms of names below, as corrected by the C++0x draft) A name is a use of an identiÔ¨Åer (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1). Then in parts of the Standard it uses "name" as if it would contain qualifier portions like foo::bar . And in other parts, it excludes such portions from a "name". One paragraph even says that a name prefixed by :: refers to a global name. But in our example, bar was prefixed by such a token, even though its intentionally not referring to a global name. The construct in our example is not a name, i think, but rather two names, one qualifying the other. A destructor is referenced by the construct ~ class-name (see 3.4.5/3 and 3.4.3/6 ). Such a construct consists of a ~ token and a name, refering to the constructor's class. It's conventional to call it the destructor's "name" (just like the Standard at 3.4.3.1/2 talks about a "constructor name") - but pedantically, it isn't a name. So, if you are pedantical, you would say that a destructor does not have an own name, but rather special mechanisms are used for referring to it. Likewise for constructors, special constructs are used to refer to them (otherwise, you couldn't declare a constructor out of class - the declaration has to refer to it!). And in C++0x using declarations have to be able to refer to them too, using the special constructs provided (see 3.4.3.1/2 for how you can refer to a constructor). The destructor lookup is quite convoluted, and has quite a few bugs in the Standard. See this issue report for further details.
