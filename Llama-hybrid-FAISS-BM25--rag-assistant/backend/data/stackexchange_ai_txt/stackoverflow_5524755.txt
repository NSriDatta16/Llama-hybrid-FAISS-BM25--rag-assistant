[site]: stackoverflow
[post_id]: 5524755
[parent_id]: 5524552
[tags]: 
What you are trying to do is not possible to do in any elegant way. It is not possible to reliably access consecutive struct members as an array. The currently accepted answer is a hack, not a solution. The proper solution would be to switch to an array, regardless of how much work it is going to require. If you use enum constants for array indexing (as @digEmAll suggested in his now-deleted answer), the names and the code will be as clear as what you have now. If you still don't want to or can't switch to an array, the only more-or-less acceptable way to do what you are trying to do is to create an "index-array" or "map-array" (see below). C++ has a dedicated language feature that helps one to implement it elegantly - pointers-to-members. In C you are forced to emulate that C++ feature using offsetof macro static const size_t values_offsets[] = { offsetof(values, v_move), offsetof(values, v_read), offsetof(values, v_suck), /* and so on */ }; static const size_t quantities_offsets[] = { offsetof(quantities, qtt_move), offsetof(quantities, qtt_read), offsetof(quantities, qtt_suck), /* and so on */ }; And if now you are given values v; quantities q; and index int i; you can generate the pointers to individual fields as int *pvalue = (int *) ((char *) &v + values_offsets[i]); int *pquantity = (int *) ((char *) &q + quantities_offsets[i]); *pvalue += *pquantity; Of course, you can now iterate over i in any way you want. This is also far from being elegant, but at least it bears some degree of reliability and validity, as opposed to any ugly hack. The whole thing can be made to look more elegantly by wrapping the repetitive pieces into appropriately named functions/macros.
