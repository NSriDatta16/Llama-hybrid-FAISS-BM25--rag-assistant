[site]: stackoverflow
[post_id]: 5574817
[parent_id]: 5572519
[tags]: 
After some tinkering I think I've got this figured out. Josh, I used your suggestion to get started. I'm not sure if you edited your suggestion or just deleted it, but it's gone so I can't quote it in my answer. Anyways, you have to shift the ranges you are going to replace after each invocation of replaceCharactersInRange:withString: or else bad things happen as the ranges don't match up. Here is what I ended up with: // array of NSValue objects storing an NSRange NSArray *replaceRanges = [self replaceRanges]; NSString *replaceString = [self replaceString]; // array of NSString objects you are going to use for the replace operation, just replaceString repeated [replaceRanges count] times NSArray *replaceStrings = [self replaceStrings]; NSTextView *textView = [self textView]; // the amount we have to shift subequent replace ranges after each call to replaceCharactersInRange:withString: NSInteger locationShift = 0; // check to makes sure the replace can occur if ([textView shouldChangeTextInRanges:replaceRanges replacementStrings:replaceStrings]) { // we want to treat all these replacements as a single replacement for undo purposes [[textView textStorage] beginEditing]; for (NSValue *rangeValue in replaceRanges) { NSRange range = [rangeValue rangeValue]; // replace the range shifted by locationShift with our replaceString [[textView textStorage] replaceCharactersInRange:NSMakeRange(range.location + locationShift, range.length) withString:replaceString]; // update the shift amount, which is the difference between our replaced string length and the original match length locationShift += [replaceString length] - range.length; } // end the grouping operation [[textView textStorage] endEditing]; } This works great and supports undo as expected, undoing this operation results in all the replacements being undone at once. Anyways thanks to Josh, as his answer got me pointed in the right direction.
