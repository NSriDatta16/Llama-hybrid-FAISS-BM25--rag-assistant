[site]: stackoverflow
[post_id]: 3885828
[parent_id]: 3885657
[tags]: 
It's hard to see the whole picture but some general points and even more general suggestions. While attempting to debug it, I put in the while loop to try and force the method to eventually run the for loop, but all that happens is it outputs "Stopping all threads" and then I never see anything else This is probably because another Thread is sitting in a sychronized block using the same lock and preventing your code from running. The easiest way to find out is to run it in a debugger and pause/break the program when you think it may be stuck. You should be able to inspect the threads and check their state. Look for BLOCKED status. The while( !stopped ) in stopAllThreads is redundant because it can never loop. In AddThread you have this private boolean running = true; When using a boolean to as a stop flag (which I think is what you are trying to achieve) AND that stop flag is polled by one thread but set by another then you MUST make it volatile . There is a whole area of Java multithreading coding that deals with data visibility and volatile is one of the tools used to ensure correctness. Often programs work "fine most of the time" without "correct" multithreading logic. But they ARE broken and will most likely break at the most inconvenient time (usually as soon as a customer gets hold of it)! (If you remember one thing in my answer remember the previous sentence :D ) Leverage the java.util.concurrent package as much as you can. Although it is very important to understand the fundamentals too, this package has lots of very useful constructs designed by very clever people that will solve many common concurrency problems. Read Java Concurrent In Practice . For the topic it is describing (potentially very dry) it explains the concepts very well in an accessible way with plenty of examples. It was written by the same group who worked on the java.util.concurrent package. From my own experience I think that "visibility" of data in concurrent programs is the most important and the least understood part of Java thread programming. If you can get your head round that you will be well on your way. JCIP can help you with this. Hope the above helps and good luck! EDIT: Spotted another problem in your additional code with this construct for( int i = 0; i Doing a remove() inside an indexed scan of a list like this will not work as expected because the remove() interferes with the indexes of other items in the list (all subsequent items get shifted down one index).
