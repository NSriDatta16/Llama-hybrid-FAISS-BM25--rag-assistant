[site]: stackoverflow
[post_id]: 740653
[parent_id]: 740577
[tags]: 
It depends on the compiler, and on the options. int main() { union { char all[13]; int foo; } record; printf("%d\n",sizeof(record.all)); printf("%d\n",sizeof(record.foo)); printf("%d\n",sizeof(record)); } This outputs: 13 4 16 If I remember correctly, it depends on the alignment that the compiler puts into the allocated space. So, unless you use some special option, the compiler will put padding into your union space. edit: with gcc you need to use a pragma directive int main() { #pragma pack(push, 1) union { char all[13]; int foo; } record; #pragma pack(pop) printf("%d\n",sizeof(record.all)); printf("%d\n",sizeof(record.foo)); printf("%d\n",sizeof(record)); } this outputs 13 4 13 You can also see it from the disassemble (removed some printf, for clarity) 0x00001fd2 : push %ebp | 0x00001fd2 : push %ebp 0x00001fd3 : mov %esp,%ebp | 0x00001fd3 : mov %esp,%ebp 0x00001fd5 : push %ebx | 0x00001fd5 : push %ebx 0x00001fd6 : sub $0x24,%esp | 0x00001fd6 : sub $0x24,%esp 0x00001fd9 : call 0x1fde | 0x00001fd9 : call 0x1fde 0x00001fde : pop %ebx | 0x00001fde : pop %ebx 0x00001fdf : movl $0xd,0x4(%esp) | 0x00001fdf : movl $0x10,0x4(%esp) 0x00001fe7 : lea 0x1d(%ebx),%eax | 0x00001fe7 : lea 0x1d(%ebx),%eax 0x00001fed : mov %eax,(%esp) | 0x00001fed : mov %eax,(%esp) 0x00001ff0 : call 0x3005 | 0x00001ff0 : call 0x3005 0x00001ff5 : add $0x24,%esp | 0x00001ff5 : add $0x24,%esp 0x00001ff8 : pop %ebx | 0x00001ff8 : pop %ebx 0x00001ff9 : leave | 0x00001ff9 : leave 0x00001ffa : ret | 0x00001ffa : ret Where the only difference is in main+13, where the compiler allocates on the stack 0xd instead of 0x10
