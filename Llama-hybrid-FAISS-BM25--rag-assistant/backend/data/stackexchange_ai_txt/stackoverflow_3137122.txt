[site]: stackoverflow
[post_id]: 3137122
[parent_id]: 2829624
[tags]: 
With regard to your abstract class consider getting rid of it and replacing it with an extension method. This will allow you to use the MapAll function regardless of whether you implement the interface or use some sort of inheritance chain. public static class MapperExtensions { public static IEnumerable MapAll (this IMapper mapper, IEnumerable input) { return input.Select(x => mapper.Map(x)); } } This will now make it easier when trying to solve your problem above because you no longer have to inherit from a base class you can now implement the mapping interface for the types you want to map. public class BillHistoryMapper : IMapper , IMapper { public BillHistory Map (Invoice obj) {} public BillHistory Map (Payment obj) {} } Also consider changing your IMapper generic parameters to be the other way round (I took the liberty in the previous examples): public interface IMapper { TOutput Map(TInput input); } The reason for this is that it directly maps to the System.Converter delegate and you can do something like: IMapper myAToBMapper = new MyAToBMapper(); ObjectA[] aArray = { new ObjectA(), new ObjectA() }; ObjectB[] bArray = Array.ConvertAll (aArray, myAToBMapper.Map); List aList = new List { new ObjectA(), new ObjectA() }; List bList = aList.ConvertAll (myAToBMapper.Map); // Or var aToBConverter = new Converter (myAToBMapper.Map); bArray = Array.ConvertAll(aArray, aToBConverter); bList = aList.ConvertAll(aToBConverter); AutoMapper has also been suggested which will make your life easier. However if you wanted to keep your mapping abstraction and have your code agnostic to your mapping strategy then it is very easy to use the above interface to inject a wrapper around AutoMapper. It will also mean you can continue to use the MapAll extension method explained above. public class AutoMapperWrapper : IMapper { public TOutput Map(TInput input) { return Mapper.Map (input); } } Final word Also keep in mind you are not always going to find that your mapping strategy will work across the board so don't try to fight your domain and force it to fit your mapping strategy. One particular example is you might have to map from two input items into one. You can obviously make this fit your strategy but you may find it becomes messy. In this particular example consider it a merge.
