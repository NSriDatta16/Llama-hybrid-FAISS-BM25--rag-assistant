[site]: stackoverflow
[post_id]: 2909633
[parent_id]: 2909254
[tags]: 
The way I see it, you are looking at a method that returns a collection of filtered log, rather than a collection class wrapping your business logic. Like so: class SpecialArray { [...] public IEnumerable Filter() { // validate inputs // filter and validate logs in collection // in end, return filtered logs, as an enumerable } [...] } However, it does look like what you really wish is actually to separate the business logic in charge of filtering the logs from the SpecialArray class, perhaps because you feel like the logic touches many things that do not really concern SpecialArray , or because Filter does not apply to all generic cases of SpecialArray . In that case my suggestion would be to isolate your business logic in another namespace , perhaps one that uses and/or requires other components in order to apply said business logic, and offer your functionality as an extension method, concretly : namespace MyNamespace.Collections { public class SpecialArray { // Shenanigans } } namespace MyNamespace.BusinessLogic.Filtering { public static class SpecialArrayExtensions { public static IEnumerable Filter (this SpecialArray array) { // validate inputs // filter and validate logs in collection // in end, return filtered logs, as an enumerable } } } And when you need to use that business logic, it would look like this : using MyNamespace.Collections; // to use SpecialArray using MyNamespace.BusinessLogic.Filtering; // to use custom log filtering business logic namespace MyNamespace { public static class Program { /// /// The main entry point for the application. /// [STAThread] static void Main2() { SpecialArray logs; var filteredLogs = logs.Filter(); } } }
