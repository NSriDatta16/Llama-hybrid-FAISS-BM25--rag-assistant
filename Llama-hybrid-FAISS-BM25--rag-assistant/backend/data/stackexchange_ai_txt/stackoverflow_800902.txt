[site]: stackoverflow
[post_id]: 800902
[parent_id]: 800730
[tags]: 
this is a class I scripted using boost.interrprocess , I use it to sync between the GUI and CLI versions. You might find it useful: #pragma once #include #include #ifndef max #define max(a,b) (((a) > (b)) ? (a) : (b)) #endif using boost::interprocess::windows_shared_memory; using boost::interprocess::mapped_region; using boost::interprocess::open_or_create; using boost::interprocess::read_write; using boost::interprocess::interprocess_exception; class CProcessMutex { public: CProcessMutex() : m_region() , m_status(false) { initSharedMemory(); Increment(); } ~CProcessMutex() { Decrease(); } public: int GetCount() { return m_status ? *(static_cast (m_region.get_address())) : 0; } private: void initSharedMemory() { try { //Create a native windows shared memory object. windows_shared_memory shm (open_or_create, "shared_memory", read_write, 1); //Map the whole shared memory in this process m_region.swap(mapped_region(shm, read_write)); m_status = true; } catch(interprocess_exception &ex) { ex.what(); m_status = false; } } void Increment() { if(m_status) (*(static_cast (m_region.get_address())))++; } void Decrease() { if(m_status) (*(static_cast (m_region.get_address())))--; } private: mapped_region m_region; bool m_status; }; the usage is simple: CProcessMutex pm; size_t current_process_count = pm.GetCount(); if(current_process_count > 1) { ... } so you can easily limit how many processes in parallel.
