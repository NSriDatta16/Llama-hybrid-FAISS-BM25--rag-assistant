[site]: stackoverflow
[post_id]: 5035718
[parent_id]: 5035542
[tags]: 
The aliased pragma does this: use aliased 'FooFoo::BarBar::BazBaz::Bill'; my $bill = Bill->new; aliased is syntactic sugar for use constant Bill => 'FooFoo::BarBar::BazBaz::Bill'; # or sub Bill () {'FooFoo::BarBar::BazBaz::Bill'} The downside of this is that normal usage of package names as arguments is done with quoted strings: $obj->isa('FooFoo::BarBar::BazBaz::Bill') But the constant subroutine needs to be a bare word: $obj->isa(Bill); Which just seems like a bug waiting to happen. Alternatively, you could just use Perl's builtin support for namespace aliasing: package Foo::Bar::Baz::Bill; sub new {bless {}} package Foo::Bar::Baz::Tom; sub new {bless {}} package main; BEGIN {*FBB:: = *Foo::Bar::Baz::} # the magic happens here say FBB::Bill->new; # Foo::Bar::Baz::Bill=HASH(0x80fd10) say FBB::Tom->new; # Foo::Bar::Baz::Tom=HASH(0xfd1080) Regarding the ->isa('shortname') requirement, the aliased stash method works with quoted strings as usual: my $obj = FBB::Bill->new; say $obj->isa('FBB::Bill'); # prints 1 say $obj->isa('Foo::Bar::Baz::Bill'); # prints 1 The effect of a compile time alias BEGIN {*short:: = *long::package::name::} is global across all packages and scopes. This is fine as long as you pick an empty package to alias into.
