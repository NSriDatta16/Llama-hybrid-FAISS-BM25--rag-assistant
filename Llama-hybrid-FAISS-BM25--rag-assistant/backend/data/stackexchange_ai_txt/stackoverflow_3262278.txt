[site]: stackoverflow
[post_id]: 3262278
[parent_id]: 3215833
[tags]: 
Djangoâ€™s default behavior is to run with an open transaction which it commits automatically when any built-in, data-altering model function is called. In case of commit_on_success or commit_manually decorators, django does not commit upon save(), but rather on function execution successful completion or on transaction.commit() command respectively. Therefore, the elegant approach would be to separate the transaction handling code and other time consuming code if possible: from django.db import transaction from my_app.models import MyModel @transaction.commit_on_success def do_transaction(instances_to_save): for inst in instances_to_save: inst.save() def model_altering_method(): instances_to_save = [] for inst in MyModel.objects.all()[0:5000]: inst.name = 'Joel Spolsky' # Some models independent time consuming operations... instances_to_save.append(inst) do_transaction(instances_to_save) If this is impossible design wise, e.g. you need instance.id information which for new instances you can only get only after the first save(), try breaking up your flow to reasonably sized workunits, as not to keep the transaction open for long minutes. Also notice that having long transactions is not always a bad thing. If your application is the only entity modifying the db, it could actually be ok. You should however check the specific configuration of your db to see the time limit for transactions (or idle transaction).
