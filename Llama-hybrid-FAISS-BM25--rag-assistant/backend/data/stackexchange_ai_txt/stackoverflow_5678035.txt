[site]: stackoverflow
[post_id]: 5678035
[parent_id]: 5677679
[tags]: 
1) Your method is sound to calculate the average size of a row. (Though be aware that if your column contains null, you should use avg(nvl(vsize(col1), 0)) instead of avg(vsize(COL1)) ). However, it doesn't take into account the physical arrangement of rows. First of all, it doesn't take into account the header info (from both blocks and rows): you can't fit 8k data into 8k blocks. See the documentation on data block format for more information. Then, rows are not always stored neatly packed. Oracle lets some space in each blocks so that the rows can grow when they are updated (governed by the pctfree parameter). Also when the rows are deleted the empty space is not reclaimed right away (if you're not using ASSM with locally managed tablespaces, the amount of free space required for a block to return to the list of available blocks depends on pctused ). If you already have some representative data in your table, you can estimate the amount of extra space you will need by comparing the space physically used ( all_tables.blocks*block_size after having gathered statistics) to the average row length. By the way Oracle can easily give you a good estimate of the average row length: gather statistics on the table and query all_tables.avg_row_len . 2) Most of the time (read: unless there is a bug or you fall into an atypical use of the index), the index will grow proportionaly to the number of rows. If you have representative data, you can have a good estimation of its future size by multiplying its actual size by the relative growth of the number of rows.
