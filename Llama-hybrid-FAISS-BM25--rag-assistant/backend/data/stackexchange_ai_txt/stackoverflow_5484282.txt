[site]: stackoverflow
[post_id]: 5484282
[parent_id]: 5468235
[tags]: 
Flash Uploader: Undoubtedly, SWFUpload or Uploadify (based on the latter). File Transfer : Use PHP CURL to do an HTTP POST form transfer ( http://www.php.net/manual/en/function.curl-setopt.php see the 2nd example). Before doing the transfer do the following: set_time_limit(-1); // PHP won't timeout ignore_user_abort(true); // PHP won't quit if the user aborts Edit: I don't see a valid reason why you would need a CRON job unless the file in question changes at some time (which is the real definition of sync-ing). On the other hand, if what you want is to just copy the file to a remote server, there's no reason you can't do it with plain PHP. Also, one thing you should be aware of is file sizes. If the file size in anything less than 20mb, you're safe. Edit 2: By the way, with the right conditions, (output buffering off, and implicit output on), you can show the user the current remote transfer progress. I've done, it ain't hard really. You just need a hidden iframe which sends progress requests to update the parent window. It works kind of like AJAX, but using an iframe in place of XHR (since XHR returns as a bulk, not in blocks, unlike an iframe). If interested, I can help you out with this, just ask. Edit3: Dynamic remote upload example/explanation: To make things short, I'll assume that your file has already been uploaded to the server by the user, but not the target remote server. I'll also assume the user landed on handle.php after uploading the file. handle.php would look like: // This current script is only cosmetic - though you might want to // handle the user upload here (as I did) $name = 'userfile'; // name of uploaded file (input box) YOU MUST CHANGE THIS $new_name = time().'.'.pathinfo($_FILES[$name]['name'],PATHINFO_EXTESION); // the (temporary) filename move_uploaded_file($_FILES[$name]['tmp_name'],'uploads/'.$new_name); $url = 'remote.php?file='.$new_name; ?> " width="1" height="1" frameborder="0" scrolling="no"> 0% function progress(percent){ document.getElementById('progress').innerHTML='%'+percent; } Doesn't look difficult so far, no? The next part is a little more complex. The file remote.php would look like: set_time_limit(0); // PHP won't timeout // if you want the user to be able to cancel the upload, simply comment out the following line ignore_user_abort(true); // PHP won't quit if the user aborts // to make this system work, we need to tweak output buffering while(ob_get_level())ob_end_clean(); // remove all buffers ob_implicit_flush(true); // ensures everything we output is sent to browser directly function progress($percent){ // since we're in an iframe, we need "parent" to be able to call the js // function "progress" which we defined in the other file. echo ' parent.progress('.$percent.'); '; } function curlPostFile($url,$file=null,$onprogress=null){ curl_setopt($ch,CURLOPT_URL,$url); if(substr($url,0,8)=='https://'){ curl_setopt($ch,CURLOPT_HTTPAUTH,CURLAUTH_ANY); curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,false); } if($onprogress){ curl_setopt($ch,CURLOPT_NOPROGRESS,false); curl_setopt($ch,CURLOPT_PROGRESSFUNCTION,$onprogress); } curl_setopt($ch,CURLOPT_HEADER,false); curl_setopt($ch,CURLOPT_USERAGENT,K2FUAGENT); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); curl_setopt($ch,CURLOPT_FOLLOWLOCATION,true); curl_setopt($ch,CURLOPT_MAXREDIRS,50); if($file){ $fh=fopen($file); curl_setopt($ch,CURLOPT_INFILE,$fh); curl_setopt($ch,CURLOPT_INFILESIZE,filesize($file)); } $data=curl_exec($ch); curl_close($ch); fclose($fh); return $data; } $file = 'uploads/'.basename($_REQUEST['file']); function onprogress($download_size,$downloaded,$upload_size,$uploaded){ progress($uploaded/$upload_size*100); // call our progress function } curlPostFile('http://someremoteserver.com/handle-uplaods.php',$file,'onprogress'); progress(100); // finished!
