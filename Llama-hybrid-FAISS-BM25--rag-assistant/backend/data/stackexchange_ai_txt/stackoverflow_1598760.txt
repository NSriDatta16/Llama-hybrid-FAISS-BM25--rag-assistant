[site]: stackoverflow
[post_id]: 1598760
[parent_id]: 1598673
[tags]: 
I'm not sure what you are looking for here but fake_int_ctor(int) is printing uninitialized memory in the allocated array. Try something like this instead: void fake_int_ctor(int& _this) { printf("born at %p\n", (void*)&_this); } void fake_int_dtor(int& _this) { printf("dies at %p\n", (void*)&_this); } This should print out the addresses. I'm guessing that this is more along the lines of what you want to see. This little program isn't really showing anything since you are just allocating a chunk of contiguous storage (ala malloc ) and printing out the range of addresses. Nothing really surprising there. The actual storage of arrays is implementation defined. The only thing that is guaranteed is that when you do something like C *p = new C[10] , p will point to enough contiguous storage for 10 C objects. How the environment keeps track of what was allocated so that delete [] p calls the destructors for each allocated element is completely implementation defined. If you really want to dig into this, then start with something like the following snippet. Compile it with assembly listings enabled and look at the generated assembly code. struct C { C(): x(0) {} int x; }; int main() { C *p = new C[10]; for (int i=0; i You should be able to figure out how the compiler represents arrays as long as you turn off all of the optimizations.
