[site]: stackoverflow
[post_id]: 2867819
[parent_id]: 2838196
[tags]: 
Can you be more specific about the kind of problems do you have? For example, there is an elegant approach to editing variable length list with validation support provided. While it doesn't use templates still remains DRY with partial views. While the ids are inconsistent - the names are OK and only problem I encountered is that using jquery.infieldlabel it appeared that label's for attribute (generated by GetFullHtmlFieldId inside LabelFor helper) didn't match id of the appropriate TextBoxFor input. So I created LabelForCollectionItem helper method that just uses the same method for id generation as the TextBox - TagBuilder.GenerateId(fullName) Maybe the code doesn't correspond to your need but hope it will help somebody since I found your question among the first searching for solution to my problem. public static class LabelExtensions { /// /// Generates Label with "for" attribute corresponding to the id rendered by input (e.g. TextBoxFor), /// for the case when input is a collection item (full name contains []). /// GetFullHtmlFieldId works incorrect inside Html.BeginCollectionItem due to brackets presense. /// This method copies TextBox's id generation. /// public static MvcHtmlString LabelForCollectionItem (this HtmlHelper html, Expression > expression, string labelText = null, object htmlAttributes = null) where TModel : class { var tag = new TagBuilder("label"); tag.MergeAttributes(new RouteValueDictionary(htmlAttributes)); // to convert an object into an IDictionary // set inner text string htmlFieldName = ExpressionHelper.GetExpressionText(expression); string innerText = labelText ?? GetDefaultLabelText(html, expression, htmlFieldName); if (string.IsNullOrEmpty(innerText)) { return MvcHtmlString.Empty; } tag.SetInnerText(innerText); // set for attribute string forId = GenerateTextBoxId(tag, html, htmlFieldName); tag.Attributes.Add("for", forId); return MvcHtmlString.Create(tag.ToString(TagRenderMode.Normal)); } /// /// Extracted from System.Web.Mvc.Html.InputExtensions /// private static string GenerateTextBoxId (TagBuilder tagBuilder, HtmlHelper html, string htmlFieldName) { string fullName = html.ViewContext.ViewData.TemplateInfo.GetFullHtmlFieldName(htmlFieldName); tagBuilder.GenerateId(fullName); string forId = tagBuilder.Attributes["id"]; tagBuilder.Attributes.Remove("id"); return forId; } /// /// Extracted from System.Web.Mvc.Html.LabelExtensions /// private static string GetDefaultLabelText (HtmlHelper htmlHelper, Expression > expression, string htmlFieldName) { var metadata = ModelMetadata.FromLambdaExpression(expression, htmlHelper.ViewData); string labelText = metadata.DisplayName ?? metadata.PropertyName ?? htmlFieldName.Split('.').Last(); return labelText; } }
