[site]: stackoverflow
[post_id]: 2779674
[parent_id]: 2779484
[tags]: 
What is the potential damage if it was possible to invoke wait() outside a synchronized block, retaining it's semantics - suspending the caller thread? Let's illustrate what issues we would run into if wait() could be called outside of a synchronized block with a concrete example . Suppose we were to implement a blocking queue (I know, there is already one in the API :) A first attempt (without synchronization) could look something along the lines below class BlockingQueue { Queue buffer = new LinkedList (); public void give(String data) { buffer.add(data); notify(); // Since someone may be waiting in take! } public String take() throws InterruptedException { while (buffer.isEmpty()) // don't use "if" due to spurious wakeups. wait(); return buffer.remove(); } } This is what could potentially happen: A consumer thread calls take() and sees that the buffer.isEmpty() . Before the consumer thread goes on to call wait() , a producer thread comes along and invokes a full give() , that is, buffer.add(data); notify(); The consumer thread will now call wait() (and miss the notify() that was just called). If unlucky, the producer thread won't produce more give() as a result of the fact that the consumer thread never wakes up, and we have a dead-lock. Once you understand the issue, the solution is obvious: Use synchronized to make sure notify is never called between isEmpty and wait . This synchronization issue turns out to be universal . As Michael Borgwardt points out, wait/notify is all about communication between threads, so without synchronization you'll always end up with a race condition similar to the one described above. This is why the "only wait inside synchronized" rule is enforced. A paragraph from the link posted by @Willie summarizes it quite well: You need an absolute guarantee that the waiter and the notifier agree about the state of the predicate. The waiter checks the state of the predicate at some point slightly BEFORE it goes to sleep, but it depends for correctness on the predicate being true WHEN it goes to sleep. There's a period of vulnerability between those two events, which can break the program. The predicate that the producer and consumer need to agree upon is in the above example buffer.isEmpty() . And the agreement is resolved by ensuring that the wait and notify are performed in synchronized blocks. This post has been rewritten as an article here: Java: Why wait must be called in a synchronized block
