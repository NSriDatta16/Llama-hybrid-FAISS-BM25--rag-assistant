[site]: stackoverflow
[post_id]: 3450179
[parent_id]: 3446668
[tags]: 
To Add a Class-Path Entry to the Manifest , you need to tell the Maven Jar Plugin to do so by adding an element with the appropriate configuration. From Manifest customization (slightly adapted): Customization the Manifest The default manifest can be altered with the archive configuration element. Below you will find some of the configuration options that are available. For more info see the Maven Archiver reference. This version of Maven JAR Plugin uses Maven Archiver 2.4. ... org.apache.maven.plugins maven-jar-plugin 2.3.1 true true development ${pom.url} value ... ... But the problem in your case is that you are (ab)using the evil system scope which by definition is for dependencies that are supposed to be always available and [are] not looked up in a repository . So don't expect Maven to put them in the Class-Path entry of the Manifest.mf. I guess I'll never repeat enough that people should not use it system scoped dependencies, but their use is strongly discouraged : system : This dependency is required in some phase of your project's lifecycle, but is system-specific. Use of this scope is discouraged: This is considered an "advanced" kind of feature and should only be used when you truly understand all the ramifications of its use, which can be extremely hard if not actually impossible to quantify . This scope by definition renders your build non-portable. It may be necessary in certain edge cases. The system scope includes the element which points to the physical location of this dependency on the local machine. It is thus used to refer to some artifact expected to be present on the given local machine an not in a repository; and whose path may vary machine-to-machine. The systemPath element can refer to environment variables in its path: ${JAVA_HOME} for instance. Either install your jars in your local repository, or use a corporate repository, or use a file based repository. But don't use the system scope.
