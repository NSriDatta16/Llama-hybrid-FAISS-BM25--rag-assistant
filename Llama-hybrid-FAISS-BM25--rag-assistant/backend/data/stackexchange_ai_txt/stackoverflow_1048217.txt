[site]: stackoverflow
[post_id]: 1048217
[parent_id]: 1047905
[tags]: 
Well, first you'll need to parse the XML. You could use a library like Hpricot or Nokogiri for that. Here's an example that will create a Man class given that type node from Nokogiri: def define_class_from_xml(node, in_module = Object) class_name = node['name'].dup class_name[0] = class_name[0].upcase new_class = in_module.const_set(class_name, Class.new) attributes = node.search('property').map {|child| child['name']} attribute_values = node.search('property[@value]').inject({}) do |hash, child| hash[child['name']] = child['value'] hash end new_class.class_eval do attr_accessor *attributes define_method(:initialize) do |*args| needed_args_count = attributes.size - attribute_values.size if args.size It's not the most elegant bit of metaprogramming you'll ever see, but I can't think of how to make it any simpler at the moment. The first bit gets the class name and makes an empty class by that name, the second gets the attributes from the XML, and the third is the only real metaprogramming. It's a class definition using that information (with the minor added hassle of needing to check the argument count, since we can't tell Ruby "X number of arguments is required").
