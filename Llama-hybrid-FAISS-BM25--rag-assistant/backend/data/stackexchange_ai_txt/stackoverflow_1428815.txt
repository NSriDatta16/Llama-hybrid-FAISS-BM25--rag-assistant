[site]: stackoverflow
[post_id]: 1428815
[parent_id]: 1428348
[tags]: 
I'd suggest using a dictionary. Use strings as keys and a list of strings as the value. Tokenize the strings that will be searched, and add the entire string to your dictionary once for each token. (Youn can use the split method to tokenize your strings. Use space as the delimiter.) Thereafter, whenever you need to do a look up, you tokenize the search string and perform a look up for each token in your dictionary. Thus if you have added the following strings: foo, baz, bar, blah, foo bar, foo baz Your dictionary has entries: foo: foo, foo bar, foo baz baz: baz, foo baz bar: bar, foo bar blah: blah Should you then search for "foo bar", your output is the union of the entries stored under foo and bar like so: "foo bar":= foo, bar foo: foo, foo bar, foo baz union bar: bar, foo bar giving: foo, foo bar, foo baz, bar EDIT: I've just noticed that you only want complete or partial matches, i.e. foo baz is not acceptable. The easy solution is to post process the results - restrict the longer of the search string and target string to the length of the shorter one and then compare the truncated string with the unmodified string. Accept only those that are equivalent. EDIT: So it turns out foo baz is indeed a match. Disregard the paragraph above (first edit). See (C#) code as follows: class DictionarySearch { private Dictionary > dict; public DictionarySearch() { dict = new Dictionary >(); } /// /// Add a string e.g. foo bar to the dictionary /// /// string to be added public void addString(string s) { //tokenize string string[] words = s.Split(new char[] { ' ' }); //add each token to the dictionary as a key with the matching value being s foreach (string w in words) { if (dict.ContainsKey(w)) { dict[w].Add(s); } else { dict.Add(w, new List ()); dict[w].Add(s); } } } /// /// Find all strings which match at least one token /// /// string of tokens (words) to be matched /// List of strings matching at least one word public IList getMatches(string s) { //split search string into words string[] words = s.Split(new char[] { ' ' }); List output = new List (); //retrieve from dictionary list of strings matching each word. foreach (string w in words) { if (dict.ContainsKey(w)) { output.AddRange(dict[w]); } else { continue; } } return output; } } Given a dictionary with m strings with q words per string and n unique words, and a search string with l words the time complexities are as follows: Populate data structure: O(q m T[dictionary-insert]). An insert needs to be performed for each word Find a string: O(l*T[dictionary-find]). A dictionary lookup per word in search string. The actual cost depends on your dictionary implementation. A hash table based dictionary incurs O(1) cost for both insert and find. A binary tree based dictionary incurs O(lg n) cost for both insert and find.
