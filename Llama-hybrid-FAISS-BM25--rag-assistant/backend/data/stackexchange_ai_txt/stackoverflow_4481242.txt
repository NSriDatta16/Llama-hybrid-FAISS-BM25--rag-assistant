[site]: stackoverflow
[post_id]: 4481242
[parent_id]: 3207370
[tags]: 
I think there is a bug in the implementation of read(byte[], int, int) on all BlackBerry operating systems I've worked with - 4.5 to 6.0. I wrote an adapter for InputStream that turns read(byte[], int, int) into a single call to read() and that solved the stream hanging issue in the app I am working on. If you read the RIM specification for read(byte[], int, int) it says: The read(b, off, len) method for class InputStream simply calls the method read() repeatedly. If the first such call results in an IOException, that exception is returned from the call to the read(b, off, len) method. If any subsequent call to read() results in a IOException, the exception is caught and treated as if it were end of file; the bytes read up to that point are stored into b and the number of bytes read before the exception occurred is returned. Subclasses are encouraged to provide a more efficient implementation of this method. I wrote my own version, following this spec, and ran into the same problem. I believe the issue is that the method needs to return without blocking once some data is available. The only way to do that is to make use of available() to see how many bytes can be read without blocking. Since the RIM documentation doesn't mention the use of available() , I think it just calls read() until the buffer is full or read() returns -1. This could be a long time if your data comes in small bursts. And if that "long time" is beyond the connection timeout, the connection just dies. Here's the code I used, which solved the hanging connection problem: public int read(byte[] bts, int st, int len) throws IOException { if(len == 0) { return 0; } int readByte = this.read(); if(readByte == -1) { return 0; } bts[st] = (byte)readByte; return 1; }
