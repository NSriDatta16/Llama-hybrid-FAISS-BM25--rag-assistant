[site]: stackoverflow
[post_id]: 4701442
[parent_id]: 4701366
[tags]: 
After a bit more research, I realized that UIScrollView has a built-in delegate protocol. This means you shouldn't have to subclass it at all. In your view controller header file, find this line: @interface MyViewController : UIViewController { And change it to: @interface MyViewController : UIViewController { Assuming you're using Interface Builder, open it up and find your scroll view object. Select it, open the connections inspector, and connect the "delegate" outlet to your view controller. Go back to Xcode and open up the implementation file of your view controller. Add the method: - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { NSLog(@"Here is where you do whatever it is that you're trying to do!"); } That should be it. Let me know if you need more clarification. Previous version of my answer: The best way to do this is via the delegate system. Your scrollview will have a property like so: @property(nonatomic,assign) id delegate; Then you can define a protocol for your delegate like so: @protocol MyScrollViewDelegate - (void)methodName; @end Note: you will need to put a forward-reference to the delegate before the property line, then define the methods afterwards. A forward reference for it would just be @protocol MyScrollViewDelegate; . In your view controller's header file, make sure to import the header of the scroll view, and then change the parent class of the object from UIViewController to UIViewController . Then, when you create the scroll view in your view controller, set its delegate property to self (you might do this in Interface Builder if that is how you are making your UI. In that case, make sure to add the IBOutlet keyword before the id type in your @property .) Finally, to call through from your scroll view to the view controller, you would run the following code: [self.delegate methodName]; And that's it!
