[site]: stackoverflow
[post_id]: 1794750
[parent_id]: 1794682
[tags]: 
You can use constraints to ensure that every ContractEmployees row has a corresponding Employees row, and likewise for SalariedExployees. I don't know of a way to use constraints to enforce the opposite: making sure that for every Employees row, there is a row either in ContractEmployees or SalariedEmployees. Backing up a bit... there are three main ways to model OO inheritance in a relational DB. The terminology is from Martin Fowler's Patterns of Enterprise Application Architecture : Single table inheritance: everything is just in one big table, with lots of optional columns that apply only to certain subclasses. Easy to do but not very elegant. Concrete table inheritance: one table for each concrete type. So if all employees are either salaried or contract, you'd have two tables: SalariedEmployees and ContractEmployees. I don't like this approach either, since it makes it harder to query all employees regardless of type. Class table inheritance: one table for the base class and one per subclass. So three tables: Employees, SalariedEmployeees, and ContractEmployees. Here is an example of class table inheritance with constraints (code for MS SQL Server): CREATE TABLE Employees ( ID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, FirstName VARCHAR(100) NOT NULL DEFAULT '', LastName VARCHAR(100) NOT NULL DEFAULT '' ); CREATE TABLE SalariedEmployees ( ID INT NOT NULL PRIMARY KEY REFERENCES Employees(ID), Salary DECIMAL(12,2) NOT NULL ); CREATE TABLE ContractEmployees ( ID INT NOT NULL PRIMARY KEY REFERENCES Employees(ID), HourlyRate DECIMAL(12,2) NOT NULL ); The "REFERENCES Employees(ID)" part on the two subclass tables defines a foreign key constraint. This ensures that there must be a row in Employees for every row in SalariedEmployees or ContractEmployees. The ID column is what links everything together. In the subclass tables, the ID is both a primary key for that table, and a foreign key pointing at the base class table.
