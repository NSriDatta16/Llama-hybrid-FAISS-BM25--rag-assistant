[site]: stackoverflow
[post_id]: 379823
[parent_id]: 379558
[tags]: 
Option 1 Of course you always can choose the way of /car/search/?vendor=Toyota&color=Red&model=Corola and I think it will be good for you. routes.MapRoute( "CarSearch", "car/search", new { controller = "car", action = "search" } ); You can get params from Request.Params in action in this case. Option 2 Or you can define params in the routing table, but AFAIK it will be required to make a set of rules for all possible combinations, because an order of the params matter, for example: routes.MapRoute( "CarSearch1", "car/search/vendor/{vendor}/color/{color}/model/{model}", new {controller = "car", action = "search"} ); routes.MapRoute( "CarSearch2", "car/search/color/{color}/vendor/{vendor}/model/{model}", new {controller = "car", action = "search"} ); routes.MapRoute( "CarSearch3", "car/search/model/{model}/color/{color}/vendor/{vendor}", new {controller = "car", action = "search"} ); ... an so on. It's true if you are going with the standard MvcRouteHandler. But it was an easy ways :) Option 3 The hard, but, I think, most elegant way, is to make your own IRouteHandler implementation - it will give you much more flexibility in params order. But again, its a hard way, dont go with it if you have a simple app. So, just for example of how to make it this way (very simple example): Add new route to the list of routes: routes.Add ( new Route ( "car/search/{*data}", new RouteValueDictionary(new {controller = "car", action = "search", data = ""}), new MyRouteHandler() ) ); Add classes that will tweak the standard request processing chain: class MyRouteHandler : IRouteHandler { public IHttpHandler GetHttpHandler(RequestContext requestContext) { return new MyHttpHandler(requestContext); } } class MyHttpHandler : MvcHandler { public MyHttpHandler(RequestContext requestContext) : base(requestContext) { } protected override void ProcessRequest(HttpContextBase httpContext) { IController controller = new CarController(); (controller as Controller).ActionInvoker = new MyActionInvoker(); controller.Execute(RequestContext); } } class MyActionInvoker : ControllerActionInvoker { protected override ActionResult InvokeActionMethod(MethodInfo methodInfo, IDictionary parameters) { // if form of model/{model}/color/{color}/vendor/{vendor} var data = ControllerContext.RouteData.GetRequiredString("data"); var tokens = data.Split('/'); var searchParams = new Dictionary (); for (var i = 0; i In controller: public ActionResult Search(IDictionary searchParams) { ViewData.Add ( // output 'model = Corola, color = red, vendor = Toyota' "SearchParams", string.Join(", ", searchParams.Select(pair => pair.Key + " = " + pair.Value).ToArray()) ); return View(); } And it will work with any search parameters order: /car/search/vendor/Toyota/color/red/model/Corola /car/search/color/red/model/Corola/vendor/Toyota /car/search/model/Corola/color/red/vendor/Toyota But also dont forget to make a link generation logic, because Html.ActionLink and Html.RenderLink will not give you url in pretty form of /car/search/model/Corola/color/red/vendor/Toyota, so you'll need to make a custom link generator. So, if you need a really flexible routing - you'd better go with this hard way :)
