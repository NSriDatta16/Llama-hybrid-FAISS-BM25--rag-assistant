[site]: stackoverflow
[post_id]: 1685214
[parent_id]: 1026774
[tags]: 
Ok I managed to get this working on Weblogic. Again my aim was to get java package names in all applications deployed on a given WebLogic server. Why? I had my reasons :) First you have to get hold of the ear, war or jar file locations of all deployed apps. To do this we get the AppDeployment MBeans from WebLogic and iterate as shown below. Set set = utils.getConfigMBeansByType("AppDeployment"); for (ObjectName objectName : set) { String name = objectName.getKeyProperty("Name"); if (!appCache.contains(name)) { //System.out.println("Config bean: " + objectName); Object path = utils.getPropertyValue(objectName, "AbsoluteSourcePath"); //System.out.println("Path: " + path); if(path != null){ PackageFinder finder = new PackageFinder(); packages.addAll(finder.findPackages(path.toString())); } appCache.add(name); } } In the above code we get the path to the war, ear, jar or the exploded folder and passes it to the PackageFinder class's findPakages method which does all the work. public Set findPackages(String path){ File file = new File(path); if(file.exists() && file.isFile()){ InputStream in = null; try { in = new BufferedInputStream(new FileInputStream(file)); if(path.toLowerCase().endsWith(".war")){ processWar(in); }else if(path.toLowerCase().endsWith(".ear")){ processEar(in); }/* Rest of the method body removed, I guess you get the idea */ return packageNames; } public void processJar(InputStream in){ ZipInputStream zin = null; try { zin = new ZipInputStream(in); ZipEntry entry; while((entry = zin.getNextEntry()) != null){ if(entry.getName().endsWith(".class")){ addPackage(entry.getName()); } } } catch (Exception e) { } }
