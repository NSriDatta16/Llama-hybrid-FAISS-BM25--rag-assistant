[site]: stackoverflow
[post_id]: 2032612
[parent_id]: 2031940
[tags]: 
You're missing some basic points. You can have: A statically allocated array - char arr[10]; A dynamically allocated array - char* arr = new arr[10]; The first one's size is known during compile time (because the size is a constant ), hence you can preallocate a memory space for it, the other one isn't, hence you need to allocate memory for it during run-time. STL/TR1/Boost provides wrappers for both types of arrays. Those are not only wrappers for convieniece, but also for safety (range checking in some situations) and power (iterators). For both cases we have a separate wrapper: Statically allocated array wrapper boost::array arr; Dynamically allocated array wrapper std::vector arr; The latter has the benefit of being self resizing, and allowing resizing, in addition to being dynamically allocatable. boost::array on the other hand, mimics a type arr[const] construct. Hence, you need to decide whether you want the class to have statically allocated memory, or dynamically. The former, only makes sense if the classes storage is either fixed size, or one of a few fixed sizes. The latter makes sense in all other cases. Statically allocated would use templates template class MyClass { private: boost::array array; public: MyClass(boost::array array) : array(array) {}; }; // ... boost::array array = {{1,2,3,4}}; MyClass obj(array); But would create separate code for every size of the class, and they would not be inter-operable (this can be circumvented though). Dynamically allocated would use vectors class MyClass { private: std::vector array; public: MyClass(const std::vector & array) : array(array) {}; }; Don't be afraid of vectors, treat them as dynamically allocated arrays -- the resizingness of vectors is an added benefit that doesn't affect performance almost at all.
