[site]: stackoverflow
[post_id]: 2226383
[parent_id]: 2226291
[tags]: 
You can have that for fixed-size arrays: int a[] = { foo ::value, foo ::value, ... }; Arbitrarily sized arrays however can't be done without preprocessor meta-programming - Boost.Preprocessor can help here. Another thing you might want to look into are compile-time sequences of integral constants, e.g. using Boost.MPL : template struct squares { typedef typename squares ::type seq; typedef typename boost::mpl::integral_c ::type val; typedef typename boost::mpl::push_back ::type type; }; template<> struct squares { typedef boost::mpl::vector_c ::type type; }; // ... typedef squares ::type sqr; std::cout ::type::value ::type::value ::type::value (Note that this could probably be done more elegantly using MPLs algorithms) If you're more curious about the compile-time subject the books "Modern C++ Design" (TMP basics) and "C++ Template Metaprogramming" (mainly MPL explained in depth) are worth looking into.
