[site]: stackoverflow
[post_id]: 3114891
[parent_id]: 3111501
[tags]: 
You can do something like what Matthieu said, write out separate functions for each type you support (it can still call a template function in the backend), or use dynamic polymorphism and inheritance. Those should be the only kinds of options you should consider to do what you want to do. However, the question you're asking leads me to believe that's a misunderstanding of templates and static polymorphism. A function/class template imposes restriction on the types that it can work with through the actual code being generated. The public interface that's used in such functions/classes are what define the constraints on the types that can be accepted. There is no need to superfluously impose additional constraints over that. Why would you want to restrict the types a class/function template can support more than the restrictions placed already? Let's say you write a function template which can only work on types that implement a public interface which consists of a life accessor, a kill function, and an eat function (basically any living organism). That's the constraint it places: you don't need to limit the flexibility by reducing the number of types that will work with the function template beyond that or define any specific organism types that will work that way. The template already requires this living organism-type interface to be implemented.
