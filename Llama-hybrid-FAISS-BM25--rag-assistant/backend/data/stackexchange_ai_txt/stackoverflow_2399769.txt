[site]: stackoverflow
[post_id]: 2399769
[parent_id]: 
[tags]: 
Is it okay to pass injected EntityManagers to EJB bean's helper classes and use it?

We have some JavaEE5 stateless EJB bean that passes the injected EntityManager to its helpers. Is this safe? It has worked well until now, but I found out some Oracle document that states its implementation of EntityManager is thread-safe. Now I wonder whether the reason we did not have issues until now, was only because the implementation we were using happened to be thread-safe (we use Oracle). @Stateless class SomeBean { @PersistenceContext private EntityManager em; private SomeHelper helper; @PostConstruct public void init(){ helper = new SomeHelper(em); } @Override public void business(){ helper.doSomethingWithEm(); } } Actually it makes sense.. If EntityManager is thread-unsafe, a container would have to do inercept business() this.em = newEntityManager(); business(); which will not propagate to its helper classes. If so, what is the best practice in this kind of a situation? Passing EntityManagerFactory instead of EntityManager? EDIT: This question is very interesting so if you are interested in this question, you probably want to check out this one, too: EDIT: More info. ejb3.0 spec 4.7.11 Non-reentrant Instances The container must ensure that only one thread can be executing an instance at any time. If a client request arrives for an instance while the instance is executing another request, the container may throw the javax.ejb.ConcurrentAccessException to the second client[24]. If the EJB 2.1 client view is used, the container may throw the java.rmi.RemoteException to the second request if the client is a remote client, or the javax.ejb.EJBException if the client is a local client.[25] Note that a session object is intended to support only a single client. Therefore, it would be an application error if two clients attempted to invoke the same session object. One implication of this rule is that an application cannot make loopback calls to a session bean instance. And, 4.3.2 Dependency Injection A session bean may use dependency injection mechanisms to acquire references to resources or other objects in its environment (see Chapter 16, “Enterprise Bean Environment”). If a session bean makes use of dependency injection, the container injects these references after the bean instance is created, and before any business methods are invoked on the bean instance. If a dependency on the SessionContext is declared, or if the bean class implements the optional SessionBean interface (see Section 4.3.5), the SessionContext is also injected at this time. If dependency injection fails, the bean instance is discarded. Under the EJB 3.0 API, the bean class may acquire the SessionContext interface through dependency injection without having to implement the SessionBean interface. In this case, the Resource annotation (or resource-env-ref deployment descriptor element) is used to denote the bean’s dependency on the SessionContext. See Chapter 16, “Enterprise Bean Environment”.
