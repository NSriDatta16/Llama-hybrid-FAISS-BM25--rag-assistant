[site]: stackoverflow
[post_id]: 295604
[parent_id]: 295336
[tags]: 
Here's a (corrected, I hope) F# version of the Haskell solution proposed here . EDIT: Now tail-recursive, not any faster, but doesn't explode with n = 50000. (see edit history for non-tail-recursive version) let LimitedAverage n ls = let rec loop acc i n ls = match i with | 0 -> acc //i counts down from n to 0, when we hit 0 we stop | _ -> match ls with | [] -> acc //if we hit empty list before end of n, we stop too | x::xs -> (loop (acc + (x / float n)) (i - 1) n xs) //divide this value by n, perform average on 'rest' of list loop 0. n n ls LimitedAverage 50000 (List.map float [1..9999999]) //>val it : float = 25000.5 let rec MovingAverage3 n ls = let rec acc loop i n ls = match i with | 0 -> List.rev acc //i counts down from n to 0, when we hit 0 we stop | _ -> match ls with | [] -> List.rev acc //if we hit empty list before end of n, we stop too | x::xs -> loop (LimitedAverage2 n ls :: acc) (i - 1) n xs // limited average on whole list, then moving average on tail loop [] (n + 1) n ls MovingAverage3 50000 (List.map float [1..9999999]) //>val it : float list = [25000.5; 25001.5; 25002.5; ...]
