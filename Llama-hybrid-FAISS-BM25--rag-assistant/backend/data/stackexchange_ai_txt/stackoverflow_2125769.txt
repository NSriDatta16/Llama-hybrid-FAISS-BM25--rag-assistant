[site]: stackoverflow
[post_id]: 2125769
[parent_id]: 2125674
[tags]: 
I think part of the issue is that two, largely unrelated, restrictions are in play: No type synonym instances means that instances can only be things declared with data or newtype , not type . This forbids String , but not [Char] . No flexible instances means that instances can only mention one type that isn't a variable, and only that type can be used as a type constructor. This forbids Maybe Int and f Int , but not Maybe a . Here's what GHCi says about Int , Char , and String : data Char = GHC.Types.C# GHC.Prim.Char# data Int = GHC.Types.I# GHC.Prim.Int# type String = [Char] Int and Char are both simple types without type variable parameters; there's no type constructor involved, so you can make instances with them pretty much freely. String, however, fails on both counts . It's a type synonym, which isn't allowed, and it's also a type constructor applied to a non-variable , namely the list type constructor applied to Char. For comparison, note that [a] , Maybe a , and Either a b are all valid in instances, but [Int] , Maybe [a] , and Either String a are forbidden; hopefully you can now see why. As for your direct questions, I don't know what the original motivations were for designing the language that way, and I'm in no way qualified to make authoritative statements about "best practices", but for my own personal coding I don't really hesitate to use these pragmas: {-# LANGUAGE GeneralizedNewtypeDeriving #-} {-# LANGUAGE EmptyDataDecls #-} {-# LANGUAGE TypeSynonymInstances #-} {-# LANGUAGE FlexibleInstances #-} {-# LANGUAGE FlexibleContexts #-} You could always go look at packages that use pragmas . Flexible instances, it seems, do get a fair amount of use, and from "respectable" packages (there's a couple hits in the source for Parsec, for instance).
