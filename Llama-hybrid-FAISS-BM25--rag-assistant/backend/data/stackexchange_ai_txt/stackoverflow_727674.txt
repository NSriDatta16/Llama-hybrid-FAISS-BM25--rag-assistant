[site]: stackoverflow
[post_id]: 727674
[parent_id]: 727541
[tags]: 
If you're not afraid of using templates, you can make your function a template and use SFINAE to check for the two interfaces: template void my_function(const T& data, typename enable_if_c ::value && is_convertible ::value>::type*=0) { ... } This will create a method for every type that extends both feature interfaces (note that the SFINAE trick is not needed for it to work; an unconstrained template would work, but just fail to compile when you pass a type that doesn't meet the requirements). Another possibility is to create an interface IFeatureXY extending both, and use this in the function parameters; this has the drawback that types that do implement both interfaces, but not this joint interface would not be usable with this method. Also, you can pass two arguments to the function, one per interface, and require they are pointers to the same object; this is fragile, but could be hardened by making some template class to hold the two pointers - eg. product_type , which would be initialized by the single object in question and which would hold the two types. In Java, you could probably do the same thing with bounded type variables (if they allow multiple bounds; I'm not sure now).
