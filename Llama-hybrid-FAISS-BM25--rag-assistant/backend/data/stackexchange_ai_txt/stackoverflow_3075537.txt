[site]: stackoverflow
[post_id]: 3075537
[parent_id]: 3075427
[tags]: 
If you are appending INTERSECT clauses then each query will be different. I suspect (based on what you've said) that eventually you have a cached plan for each number of INTERSECT clauses. Once you have the cached plan, it runs OK. You could try plan guides , one for each number of INTERSECT clauses. Otherwise, you could always have a single select and spool results in a temp table and self join. Not sure how it would run though or whether it's good idea. Your index should also be on Term with INCLUDE for EntityType, EntityID to be covering too Edit, after comment. You could try KEEP PLAN or plan forcing too given the relative simplicity to help avoid what sounds like recompiles. If it was SQL Server 2008, I'd suggest OPTIMISE FOR UNKNOWN Finally, another thought: do datatypes match across the board? Edit: You should change the index to ( Term, EntityType, Ordinal, EntityID) with no INCLUDES. You are using all columns in JOINs or filters You also need a primary key (Term? Ordinal) which should be unqiue and clustered too,. There is no advantage in not having one apart from poor performance and fragmented data And change the query to this: WITH Search AS ( SELECT Ordinal, EntityType, EntityID FROM InvertedIndex WHERE Term LIKE @p0 AND EntityType = @pPersonEntityType INTERSECT SELECT Ordinal, EntityType, EntityID FROM InvertedIndex WHERE Term LIKE @p1 AND EntityType = @pPersonEntityType INTERSECT SELECT Ordinal, EntityType, EntityID FROM InvertedIndex WHERE Term LIKE @p2 AND EntityType = @pPersonEntityType ) SELECT p.PersonID, p.FullName, p.Email, p.MobilePhone, p.HomeAddress, p.HomeCity FROM Search AS s INNER JOIN Person AS p ON p.PersonID = s.EntityID LEFT JOIN (SELECT 0 AS Ranking, @p3 AS RankOrdinal) O3 LEFT JOIN (SELECT 0 AS Ranking, @p4 AS RankOrdinal) O4 LEFT JOIN (SELECT 0 AS Ranking, @p5 AS RankOrdinal) O5 ORDER BY --although, I can't see why you are doing + ISNULL(O3.Ranking, 1) + ISNULL(O4.Ranking, 1) + ISNULL(O5.Ranking, 1)
