[site]: stackoverflow
[post_id]: 1847340
[parent_id]: 1847310
[tags]: 
Build a KD-tree of the points, this should give you much better complexity than O(n), on average O(log(n)) I think. You can use a 2D tree since the points are constrained to a plane. Assuming that we have transformed the problem into 2D, we'll have something like this for the points: struct Node { Pos2 point; enum { X, Y } splitaxis; Node* greater; Node* less; }; greater and less contains points with greater and lesser coordinates respectively along the splitaxis. void findPoints(Node* node, std::vector & result, const Pos2& origin, float radius) { if (squareDist(origin - node->point) point); } if (!node->greater) { //No children return; } if (node->splitaxis == X) { if (node->point.x - origin.x > radius) { findPoints(node->greater, result, origin radius); return; } if (node->point.x - origin.x less, result, origin radius); return; } findPoints(node->greater, result, origin radius); findPoints(node->less, result, origin radius); } else { //Same for Y } } Then you call this function with the root of the KD-tree
