[site]: stackoverflow
[post_id]: 1252925
[parent_id]: 782911
[tags]: 
int IndexOfAny(String[] rgs) would indeed be nice but it's nominally an O(n^2) operation. If, in your application, the set of strings rgs is large and always the same, the most efficient approach is to load them into a trie data structure once, and then use the trie repeatedly to search for them within the unknown strings given at runtime. Here is the relevant code, adapted from a C# trie source I found on the web, attributed to "Kerry D. Wong." In my version, each string in the trie has a "payload" of generic type TValue . To use this trie to simply search for substrings, the payload could always be set to true , as illustrated with simple_trie . The other thing I changed here is that this trie automatically adapts allow for storage of arbitrary Unicode strings. The array at each node—which characterizes a trie—adjusts its base and length to accomodate the range of Unicode characters which need to be stored at that node. This allows for case-sensitive matching, for example. The C# 3.0 initialization syntax is handy for this trie, but enabling it requires a dummy implementation of IEnumerable in order to compile. The CLR doesn't seem to call GetEnumerator() and I suggest that you don't try to enumerate with its result either. using System; using System.Collections.Generic; using System.Linq; // only used in Main() class Program { // trie with payload of type static Trie value_trie = new Trie { { "rabbit", "cute" }, { "giraffe", "tall" }, { "ape", "smart" }, { "hippo", "large" }, }; // degenerate case of a trie without payload static Trie simple_trie = new Trie { { "rabbit", true }, { "giraffe", true }, { "ape", true }, { "hippo", true }, }; static void Main(String[] args) { String s = "Once upon a time, a rabbit met an ape in the woods."; // Retrieve payloads for words in the string. // // output: // cute // smart foreach (String word in value_trie.AllSubstringValues(s)) Console.WriteLine(word); // Simply test a string for any of the words in the trie. // Note that the Any() operator ensures that the input is no longer // traversed once a single result is found. // // output: // True Console.WriteLine(simple_trie.AllSubstringValues(s).Any(e=>e)); s = "Four score and seven years ago."; // output: // False Console.WriteLine(simple_trie.AllSubstringValues(s).Any(e => e)); } } class TrieNode { private TrieNode [] nodes = null; private TValue m_value = default(TValue); private Char m_base; public Char Base { get { return m_base; } } public bool IsEnd { get { return !m_value.Equals(default(TValue)); } } public TValue Value { get { return m_value; } set { m_value = value; } } public IEnumerable > Nodes { get { return nodes; } } public TrieNode this[char c] { get { if (nodes != null && m_base AddChild(char c) { if (nodes == null) { m_base = c; nodes = new TrieNode [1]; } else if (c >= m_base + nodes.Length) { Array.Resize(ref nodes, c - m_base + 1); } else if (c [] tmp = new TrieNode [nodes.Length + c_new]; nodes.CopyTo(tmp, c_new); m_base = c; nodes = tmp; } TrieNode node = nodes[c - m_base]; if (node == null) { node = new TrieNode (); nodes[c - m_base] = node; } return node; } }; class Trie : System.Collections.IEnumerable { private TrieNode _root = new TrieNode (); // This dummy enables C# 3.0 initialization syntax public System.Collections.IEnumerator GetEnumerator() { return null; } public void Add(String s, TValue v) { TrieNode node = _root; foreach (Char c in s) node = node.AddChild(c); node.Value = v; } public bool Contains(String s) { TrieNode node = _root; foreach (Char c in s) { node = node[c]; if (node == null) return false; } return node.IsEnd; } public TValue Find(String s_in) { TrieNode node = _root; foreach (Char c in s_in) { node = node[c]; if (node == null) return default(TValue); } return node.Value; } public IEnumerable FindAll(String s_in) { TrieNode node = _root; foreach (Char c in s_in) { node = node[c]; if (node == null) break; if (node.Value != null) yield return node.Value; } } public IEnumerable AllSubstringValues(String s) { int i_cur = 0; while (i_cur node = _root; int i = i_cur; while (i
