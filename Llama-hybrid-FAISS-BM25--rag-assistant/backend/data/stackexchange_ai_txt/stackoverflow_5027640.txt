[site]: stackoverflow
[post_id]: 5027640
[parent_id]: 5023743
[tags]: 
I have recently submitted an issue where I requested / discussed something similar. This is what would be needed in my implementation /** * Aggregate the selected values from the supplied {@link Iterable} using * the provided selector and aggregator functions. * * @param * the element type over which to iterate * @param * type of the values to be aggregated * @param * type of the aggregated value * @param data * elements for aggregation * @param selectorFunction * a selector function that extracts the values to be aggregated * from the elements * @param aggregatorFunction * function that performs the aggregation on the selected values * @return the aggregated value */ public static A aggregate(final Iterable data, final Function selectorFunction, final Function , A> aggregatorFunction){ checkNotNull(aggregatorFunction); return aggregatorFunction.apply( Iterables.transform(data, selectorFunction) ); } (The selector function can pull the value to aggregate from the object to query, but in many cases it will be Functions.identity() , i.e. the object itself is what's aggregated) This is not a classic fold, but it requires a Function ,X> to do the work. But since the actual code is a one-liner, I have instead chosen to request some standard aggregator functions (I'd put them in a class called something like Aggregators , AggregatorFunctions or even Functions.Aggregators ): /** A Function that returns the average length of the Strings in an Iterable. */ public static Function ,Integer> averageLength() /** A Function that returns a BigDecimal that corresponds to the average of all numeric values passed from the iterable. */ public static Function ,BigDecimal> averageOfFloats() /** A Function that returns a BigInteger that corresponds to the average of all numeric values passed from the iterable. */ public static Function ,BigInteger> averageOfIntegers() /** A Function that returns the length of the longest String in an Iterable. */ public static Function ,Integer> maxLength() /** A Function that returns the length of the shortest String in an Iterable. */ public static Function ,Integer> minLength() /** A Function that returns a BigDecimal that corresponds to the sum of all numeric values passed from the iterable. */ public static Function ,BigDecimal> sumOfFloats() /** A Function that returns a BigInteger that corresponds to the integer sum of all numeric values passed from the iterable. */ public static Function ,BigInteger> sumOfIntegers() (You can see my sample implementations in the issue) That way, you can do things like this: int[] numbers = { 1, 5, 6, 9, 11111, 54764576, 425623 }; int sum = Aggregators.sumOfIntegers().apply(Ints.asList(numbers)).intValue(); This is definitely not what you are asking for, but it would make like easier in many cases and would overlap with your request (even if the approach is different).
