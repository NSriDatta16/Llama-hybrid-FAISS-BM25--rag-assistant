[site]: stackoverflow
[post_id]: 1752603
[parent_id]: 1752556
[tags]: 
You can use these queries "safely," that is, without getting ambiguous results, if the extra columns are functionally dependent on the column(s) you group by: SELECT c.parent_id, COUNT(*), p.any_column FROM child_table c JOIN parent_table p USING (parent_id) GROUP BY c.parent_id; The example above would work in SQLite, and produce an unambiguous result, because there's no way p.any_column could have multiple values per group. However, this query is strictly in violation of the SQL standard, and most brands of RDBMS would raise an error. It's too easy to write a query that produces ambiguous results, though. When you name a column that has multiple values per group, you can't control which value is returned in your result set. In practice, MySQL returns the value from the first row with respect to physical storage, and SQLite returns the value from the last row. But it's totally implementation-dependent and not reliable. If the next version of either software changes its internals, you could get different query results after you upgrade. So it's best not to rely on this behavior. Regarding your example, where content should "intuitively" have the value from the row where sequence is MAX. But is this really intuitive? Consider these other cases: SELECT MAX(sequence), MIN(sequence), type, content FROM message GROUP BY type So which row now supplies the value for content ? The row where sequence is MAX, or the row where sequence is MIN? What if you use a non-unique column (e.g. date ), and there are multiple rows with the same MAX value for date , but different values for content ? SELECT MAX(date), type, content FROM message GROUP BY type What about other aggregate functions like AVG() or SUM() ? It could be that the value of the aggregate corresponds to no individual row in the table. So now which row should supply the value for content ? SELECT AVG(sequence), type, content FROM message GROUP BY type
