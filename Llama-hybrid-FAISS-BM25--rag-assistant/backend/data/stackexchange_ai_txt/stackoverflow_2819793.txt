[site]: stackoverflow
[post_id]: 2819793
[parent_id]: 2817891
[tags]: 
No one is going to laugh. In fact, you did a pretty good job for a first try. Of course, there's room for improvement! :) First some remarks: you can only negate single characters. Since your NL rule can possibly consist of two characters, you can't negate it. Also, when negating from within your parser rule(s), you don't negate single characters, but you're negating lexer rules. This may sound a bit confusing so let me clarify with an example. Take the combined (parser & lexer) grammar T : grammar T; // parser rule foo : ~A ; // lexer rules A : 'a' ; B : 'b' ; C : 'c' ; As you can see, I'm negating the A lexer-rule in the foo parser-rule. The foo rule does now not match any character except the 'a' , but it matches any lexer rule except A . In other words, it will only match a 'b' or 'c' character. Also, you don't need to put: options { language = Java; } in your grammar: the default target is Java (it does not hurt to leave it in there of course). Now, in your grammar, you can already make a distinction between data - and text -lines in your lexer grammar. Here's a possible way to do so: logfile : line+ ; line : dataline | textline ; dataline : DataLine ; textline : TextLine ; DataLine : TwoDigits TwoDigits '.' TwoDigits '.' TwoDigits Space+ TwoDigits ':' TwoDigits ':' TwoDigits Space+ ':' TextLine ; TextLine : ~('\r' | '\n')* (NewLine | EOF) ; fragment NewLine : '\r'? '\n' | '\r' ; fragment TwoDigits : '0'..'9' '0'..'9' ; fragment Space : ' ' | '\t' ; Note that the fragment part in the lexer rules mean that no tokens are being created from those rules: they are only used in other lexer rules. So the lexer will only create two different type of tokens: DataLine 's and TextLine 's.
