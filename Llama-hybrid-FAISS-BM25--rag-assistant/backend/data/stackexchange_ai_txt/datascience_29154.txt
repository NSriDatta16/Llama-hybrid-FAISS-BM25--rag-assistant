[site]: datascience
[post_id]: 29154
[parent_id]: 29052
[tags]: 
You can write your own algorithm. I drafted something up quickly. It can be significantly optimized. Let's make some random data import numpy as np import matplotlib.pyplot as plt %matplotlib inline n = 9 x = np.random.rand(n,2) y = np.zeros((n,)) y[n//3:2*n//3] = 1 y[2*n//3::] = 2 plt.scatter(x[:,0], x[:,1], c=y) plt.show() Now let's get the interdistance of each of these points. dists = np.asarray([np.linalg.norm(i-j) for i in x for j in x]).reshape(n,n) plt.imshow(dists) plt.show() We will make a list which will hold the radius of each circle for each point. For each point we will iterate over the other points by their relative nearness. If an associated label is not yet seen, add it to the temporary list. Otherwise, we end the function and take the average of the last distance and the current illegal point. radii = [] for row in dists: labels = [] dis = [] for i in np.argsort(row): if y[i] not in labels: labels.append(y[i]) dis = row[i] else: dis = (dis + row[i])/2 break radii.append(dis) Now we can plot these circles by fig, ax = plt.subplots(figsize=(10,10)) for ix, i in enumerate(radii): circle = plt.Circle((x[ix, 0], x[ix, 1]), i, color='b', fill=False, alpha = 0.5) ax.add_artist(circle) plt.scatter(x[:,0], x[:,1], c=y) plt.xlim([-0.2,1.4]) plt.ylim([-0.2,1.4]) plt.show() If we increase the number of datapoints $n$ we get
