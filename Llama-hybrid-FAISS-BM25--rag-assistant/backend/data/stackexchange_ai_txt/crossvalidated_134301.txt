[site]: crossvalidated
[post_id]: 134301
[parent_id]: 
[tags]: 
Simple Multivariate Bayesian Method in Python

I am trying to follow the Bayesian method described in this text . The python notebook goes through the example of creating two Poisson functions describing a change in SMS frequency at some point tau. But I want to explore multivariate methods, so instead will start with simply two time changes (tau1 and tau2) with three exponentials (lambda1, lambda2, lambda3). As described in the text, I can create the exponential multivariate lambdas_ as follows: import pymc as pm alpha = 1.0/count_data.mean() lambdas_ = pm.Exponential("lambda_1", alpha, size=3) tau = pm.DiscreteUniform("tau", lower=0, upper=n_count_data, size=2) My simple and obvious (not to me!) mistake occurs in defining the deterministic lambda_ function @pm.deterministic def lambda_(tau=tau, lambdas_=lambdas_): out = np.zeros(n_count_data) out[:tau[0]] = lambda_[0] # lambda before tau is lambda1 out[tau[0]:tau[1]] = lambda_[1] # lambda between tau1 and tau2 is lambda2 out[tau[1]:] = lambda_1[2] # lambda after tau2 is lambda3 return out I am wondering if this is the proper method for determining the expectations based on the posteriors, as in determining when are we in the regime of which lambda and particularly for determining idx2 which seems odd to use a product (otherwise i get the numpy complaint of using a.any() or a.all() if i just do tau_samples[:,0] ): # tau_samples, lambdas_samples contain # N samples from the corresponding posterior distribution N = tau_samples.shape[0] expected_texts_per_day = np.zeros(n_count_data) for day in range(0, n_count_data): # ix is a bool index of all tau samples corresponding to # the switchpoint occurring prior to value of 'day' ix1 = day I would appreciate any feedback, thank you for your time and guidance. I have pasted the full code below import json, matplotlib s = json.load( open("bmh_matplotlibrc.json") ) matplotlib.rcParams.update(s) %matplotlib osx from IPython.core.pylabtools import figsize import numpy as np from matplotlib import pyplot as plt figsize(11, 9) import scipy.stats as stats figsize(12.5, 3.5) count_data = np.loadtxt("txtdata.csv") n_count_data = len(count_data) plt.bar(np.arange(n_count_data), count_data, color="#348ABD") plt.xlabel("Time (days)") plt.ylabel("count of text-msgs received") plt.title("Did the user's texting habits change over time?") plt.xlim(0, n_count_data); import pymc as pm alpha = 1.0 / count_data.mean() # Recall count_data is the # variable that holds our txt counts lambdas_ = pm.Exponential("lambda_", alpha, size=3) tau = pm.DiscreteUniform("tau", lower=0, upper=n_count_data, size=2) @pm.deterministic def lambda_(tau=tau, lambdas_=lambdas_): out = np.zeros(n_count_data) out[:tau[0]] = lambdas_[0] # lambda before tau is lambda1 out[tau[0]:tau[1]] = lambdas_[1] # lambda between tau1 and tau2 is lambda2 out[tau[1]:] = lambdas_[2] # lambda after tau2 is lambda3 return out observation = pm.Uniform("obs", lambda_, value=count_data, observed=True) model = pm.Model([observation, lambdas_, taus]) mcmc = pm.MCMC(model) mcmc.sample(40000, 10000, 1) lambdas_samples = mcmc.trace('lambdas_')[:] tau_samples = mcmc.trace('tau')[:] import random r = lambda: random.randint(0,255) cols=[] [cols.append('#%02X%02X%02X' % (r(),r(),r())) for i in range(5)] figsize(8.5, 14) # histogram of the samples: ax = plt.subplot(511) ax.set_autoscaley_on(False) plt.hist(lambdas_samples[:,0], histtype='stepfilled', bins=30, alpha=0.85, label="posterior of $\lambda_1$", color=cols[0], normed=True) plt.legend(loc="upper left") plt.title(r"""Posterior distributions of the variables $\lambda_1,\;\lambda_2,\;\lambda_3,\;\tau_1,\;\tau_2$""") plt.xlim([0, 30]) plt.xlabel("$\lambda_1$ value") ax = plt.subplot(512) ax.set_autoscaley_on(False) plt.hist(lambdas_samples[:,1], histtype='stepfilled', bins=30, alpha=0.85, label="posterior of $\lambda_2$", color=cols[1], normed=True) plt.legend(loc="upper left") plt.xlim([0, 30]) plt.xlabel("$\lambda_2$ value") ax = plt.subplot(513) ax.set_autoscaley_on(False) plt.hist(lambdas_samples[:,2], histtype='stepfilled', bins=30, alpha=0.85, label="posterior of $\lambda_3$", color=cols[2], normed=True) plt.legend(loc="upper left") plt.xlim([0, 30]) plt.xlabel("$\lambda_3$ value") plt.subplot(514) w = 1.0 / tau_samples[:,0].shape[0] * np.ones_like(tau_samples[:,0]) plt.hist(tau_samples[:,0], bins=n_count_data, alpha=1, label=r"posterior of $\tau_1$", color=cols[3], weights=w, rwidth=2.) plt.xticks(np.arange(n_count_data)) plt.legend(loc="upper left") plt.ylim([0, .75]) plt.xlim([20, len(count_data) - 20]) plt.xlabel(r"$\tau_1$ (in days)") plt.ylabel("probability"); plt.subplot(515) w = 1.0 / tau_samples[:,1].shape[0] * np.ones_like(tau_samples[:,1]) plt.hist(tau_samples[:,1], bins=n_count_data, alpha=1, label=r"posterior of $\tau_2$", color=cols[4], weights=w, rwidth=2.) plt.xticks(np.arange(n_count_data)) plt.legend(loc="upper left") plt.ylim([0, .75]) plt.xlim([20, len(count_data) - 20]) plt.xlabel(r"$\tau_2$ (in days)") plt.ylabel("probability"); figsize(12.5, 5) # tau_samples, lambdas_samples contain # N samples from the corresponding posterior distribution N = tau_samples.shape[0] expected_texts_per_day = np.zeros(n_count_data) for day in range(0, n_count_data): # ix is a bool index of all tau samples corresponding to # the switchpoint occurring prior to value of 'day' ix1 = day
