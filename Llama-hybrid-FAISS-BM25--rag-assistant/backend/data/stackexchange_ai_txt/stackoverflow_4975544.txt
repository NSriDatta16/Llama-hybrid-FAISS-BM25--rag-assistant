[site]: stackoverflow
[post_id]: 4975544
[parent_id]: 4975195
[tags]: 
I'm assuming you're using either an OpenGL 3.0 or OpenGL ES library. I think you could do something like this, though I'm not sure how supported it is. This should be a bit more supported than my original answer, but you're stuck with using 1.5 as the modulation value. // Setup... glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, tex1); // Combine: Result.rgb = Texture + Texture - 0.5 glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE); glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_ADD_SIGNED); glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_TEXTURE); glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_TEXTURE); glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR); glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB, GL_SRC_COLOR); // Combine: Result.a = Texture glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_REPLACE); glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE); glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA); If you can do it using shaders, you'd be much better off: //Fragment shader uniform sampler2D texture; uniform float blend; varying vec2 texcoord; void main() { vec4 texel0 = texture2D(texture, texcoord); texel0 *= blend; gl_FragColor = texel; }
