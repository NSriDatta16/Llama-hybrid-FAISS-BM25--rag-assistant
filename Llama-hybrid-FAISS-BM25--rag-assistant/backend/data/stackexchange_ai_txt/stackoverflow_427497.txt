[site]: stackoverflow
[post_id]: 427497
[parent_id]: 426941
[tags]: 
Your basic problem is that the type of an expression must be knowable at compile time . Is the condition fixed and known at compile time? If so, it will be possible to use a metafunction to choose each parameter: template struct choose { typedef X type; }; template <> struct choose { typedef Y type; }; ... func(choose ::type()); (Simplified for a 1-parameter case; for 3 parameters you would define e.g. struct choose1 , struct choose2 , struct choose3 .) Otherwise, your best option is to derive all types from a common base as John Zwinck suggested. The only alternative to that is a gigantic switch statement or list of if s. Actually, maybe this is something that Boost.Variant would be good for?
