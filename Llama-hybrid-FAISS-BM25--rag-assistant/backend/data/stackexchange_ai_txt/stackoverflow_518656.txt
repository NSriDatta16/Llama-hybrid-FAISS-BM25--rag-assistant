[site]: stackoverflow
[post_id]: 518656
[parent_id]: 516098
[tags]: 
I don't use generated proxies at all. I just have a shared assembly between my client and server that defines service contract interfaces + the following sleight of hand. // this class can be used to instantiate a unidirectional proxy (one that doesn't require callbacks from the server) public class UniDirectionalServiceProxy : System.ServiceModel.ClientBase where T : class { public UniDirectionalServiceProxy() { } public UniDirectionalServiceProxy(string endpointConfigurationName) : base(endpointConfigurationName) { } public UniDirectionalServiceProxy(string endpointConfigurationName, string remoteAddress) : base(endpointConfigurationName, remoteAddress) { } public UniDirectionalServiceProxy(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : base(endpointConfigurationName, remoteAddress) { } public UniDirectionalServiceProxy(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : base(binding, remoteAddress) { } // new keyword allows us to supercede the inherited protected member and make it public. public new T Channel { get { return base.Channel; } } } Looks familiar, right? Construct that object and then you just change your calls to use the Channel member. You can also use ChannelFactory to get much the same result (I presume they made Channel a protected member of ClientBase to encourage developers to use ChannelFactory), but I prefer this mechanism since you end up with a single object that encapsulates communication control and the calls across the wire. Obviously, this way you lose the async methods from svcutil, but that's pretty easy to do yourself with delegates anyway.
