[site]: stackoverflow
[post_id]: 547061
[parent_id]: 547022
[tags]: 
Normally I'll add an int or smallint column named something like 'Ordinal' or 'PositionOrdinal' as you suggest, and with the exact caveat you mention â€” the need to update a potentially significant number of records every time a single record is re-ordered. The benefit is that given a key for a specific task and a new position for that task, the code to move an item is just two statements: UPDATE `Tasks` SET Ordinal= Ordinal+1 WHERE Ordinal>=@NewPosition UPDATE `Tasks` SET Ordinal= @NewPosition WHERE TaskID= @TaskID There are other suggestions for a doubly linked list or lexical order. Either can be faster, but at the cost of much more complicated code, and the performance will only matter when you have a lot of items in the same group. Whether performance or code-complexity is more important will depend on your situation. If you have millions of records the extra complexity might worth it. However, I normally prefer the simpler code because users normally only order small lists by hand . If there aren't all that many items in the list the extra updates won't matter. This can typically handle thousands of records without any noticeable impact in performance. The one thing to keep in mind with your updated example is that the column is only used for sorting and not otherwise shown directly to the user. Thus, when dragging an item from the top to the bottom as shown the only thing you need to change is that one record. It doesn't matter that you'll leave the first position empty. This means there is a small potential to overflow your integer sort with enough re-ordering, but let me say again: users normally only order small lists by hand . I've never heard of this risk actually causing a problem.
