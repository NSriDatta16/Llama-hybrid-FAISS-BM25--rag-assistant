[site]: stackoverflow
[post_id]: 4721970
[parent_id]: 4721938
[tags]: 
if(pid==0){*ptr=44;} // Child modifies data, which is ignored by parent Question1) Can anyone tell me, how the values are different? Although the pointer address is same for both the parent and the child? This is the whole idea. They may have the same address, but these addresses are virtual . Each process has its own address space. What fork() does is creates a new process, and makes its virtual memory layout look like the parent. See the Wikipedia article on page tables and similar topics for some illustrations of how this works. -- (Long aside follows) -- What typically happens at a fork() is that page tables for both the parent and child are set up such that the pages are marked as read-only. When a write instruction happens for some location the kernel gets a page fault , which the CPU generates at a bad memory access. The kernel will allocate new memory for the trapped process, map it into the right address by manipulating its page table, copy the old buffer to the newly allocated one and let the write continue. This is called copy-on-write . This makes the initial fork quick and keeps memory consumption down for pages that are not written in either process. The previous paragraph is all just an optimization of the fork programming model. They say early Unix didn't do this -- it did a full memory copy of the whole process. I've also heard that Cygwin's fork() does a full copy. But the virtual address has nothing to do with the physical address of the memory. The CPU uses it as a "key" for the page table, which defines where the actual memory is. The page table may also say that the page is not valid, in which case the kernel has an opportunity to do a "fixup" (perform copy-on-write, recall the page from swap space, etc.) or kill the process in the case of a legitimately invalid pointer access.
