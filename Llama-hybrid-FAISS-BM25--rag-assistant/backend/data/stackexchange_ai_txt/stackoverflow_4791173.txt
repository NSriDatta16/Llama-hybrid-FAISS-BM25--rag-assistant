[site]: stackoverflow
[post_id]: 4791173
[parent_id]: 
[tags]: 
Crash with CALayer, memory problem

My thanks to hotpaw2 for the solution to my incremental drawing problem. Alas, I discovered an issue with the solution as I implemented it. It reveals itself as a memory-induced crash when I press the botton at the bottom of the iphone to suspend the app and then restart it. (I can run the app indefinitely as long as I don't do this). The crash occurs at the indicated line below, which occurs in FooBar, a subclass of UIView: - (void)drawRect:(CGRect)rect { CGContextRef ctx = UIGraphicsGetCurrentContext(); // @@CRASH here: Program received signal EXC_BAD_ACCESS [backingLayer renderInContext:ctx]; // Render the backing layer into current context [self randomRectangle: ctx]; } In the interface of FooBar I have declared backing layer as instance variable: @private NSTimer* timer; CALayer *backingLayer; In the implementation of FooBar, backingLayer occurs just once more, in initWithFrame , in the following paragraph: backingLayer = self.layer; // [backingLayer retain]; // Set its color space and background color CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGFloat components[4] = {0.0f, 0.0f, 0.0f, 1.0f}; CGColorRef bgColor = CGColorCreate(colorSpace, components); backingLayer.backgroundColor = bgColor; CGColorRelease(bgColor); CGColorSpaceRelease(colorSpace); I should also say that there is an NSTimer timer that is defined in initWithFrame fires off the tick method below 12 times a second: - (void)tick { // Tell the view that it needs to re-draw itself if (running) { // Go! // NSLog(@"frameRate: %2.1f, frameCount: %d", frameRate, frameCount); [self setNeedsDisplay]; frameCount++; } } I've run Instruments on this app. No memory leaks are detected. But when I run Allocations and (a) suspend app with physical button, (b) touch the app icon to make it run again, then I see huge cluster of allocations (~2 GB) --- and CRASH. -- Jim
