[site]: stackoverflow
[post_id]: 4755585
[parent_id]: 4755541
[tags]: 
In C , they can be stored wherever the implementation sees fit. The C standard does not dictate how the implementation does things, only how it behaves. Typically, all static storage duration variables (statics within a function and all variables outside a function) will be stored in the same region, regardless of whether they at at file level or within a function. That bit in parentheses above is important. Outside of a function, static doesn't decide the storage duration of a variable like it does within a function. It decides whether the variable is visible outside of the current translation unit. All variables outside of functions are static storage duration. And, regarding the symbol table, that's a construct that exists only during the build process. Once an executable is generated, there are no symbols (debugging information excluded of course, but that has nothing to do with the execution of code). All references to variables at that point will almost certainly be hard-coded addresses or offsets. In other words, it's the compiler that figures out which variable you're referring to with a name. You can see an example here as to how the variables are stored. Consider the following little C program: #include int var1; static int var2; int main (void) { int var3; static int var4; var1 = 111; var2 = 222; var3 = 333; var4 = 444; return 0; } This generates the following assembly: .file "qq.c" .comm var1,4,4 .local var2 .comm var2,4,4 .text .globl main .type main, @function main: pushl %ebp movl %esp, %ebp subl $16, %esp movl $111, var1 movl $222, var2 movl $333, -4(%ebp) movl $444, var4.1705 movl $0, %eax leave ret .size main, .-main .local var4.1705 .comm var4.1705,4,4 .ident "GCC: (Ubuntu 4.4.3-4ubuntu5) 4.4.3" .section .note.GNU-stack,"",@progbits And you can see that var1 , var2 and var4 (the static storage duration ones) all have a .comm line to mark them as common entries, subject to consolidation by the linker. In addition, var2 , var3 and var4 (the ones that are invisible outside the current transdlation unit) all have a .local line, so that the linker won't use them for satisfying unresolved externals in other object file. And, by examining the output of ld --verbose while linking a file, you can see that all common entries end up in the .bss area: .bss : { *(.dynbss) *(.bss .bss.* .gnu.linkonce.b.*) *(COMMON) : : : }
