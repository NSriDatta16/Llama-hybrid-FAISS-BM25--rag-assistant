[site]: stackoverflow
[post_id]: 4952853
[parent_id]: 
[tags]: 
IEnumerable where All meet X and at least one meets y

I have 2 IEnumerable . for example {0,0.1,0.5,1} and {a,b,c,d} assume equal lengths Sample Domain Object Code: public class Foo //does not implement IEnumerable because nothing outside of itself should treat it as such { private readonly decimal _a; private readonly decimal _b; private readonly decimal _c; //another class also has private readonly decimal _d; public decimal A {get{return _a;}} //... public decimal C {get{return _c;}} } I want to define Foo1>Foo2 if all meet >= (as in Foo1.A>=Foo2.A && ' .. 'Foo1.C>=Foo2.C ..) At least one > (as in Foo1.B>Foo2.B ) Sample iterative code: //DRY violation, but probably the shortest route to the goal private static IEnumerable > Accessors= new List{f=>f.A,f=>f.B,f=>f.C}; public static bool operator>(Foo foo1, Foo foo2) { if (foo1==null||foo2==null) return false; bool foundGreater=false; foreach (var accessor in _Accessors) { if (accessor(foo1) accessor(foo2)) foundGreater=true; } return foundGreater; } information and answers involving zip are welcomed from a learning perspective, as are attacking the entire problem of variable property lengths using the same comparison functionality that don't involve reflection. However, I'm currently working within the confines of .net 2.0 with LinqBridge. I'm considering something like the following to cover all classes that need the same functionality //Needs a better name for sure public static bool AllWithAny (IEnumerable > accessors,T item1, T item2, Func shortCircuitBreak,Func atLeastOneCondition) { GuardStrategy.ThrowIfNull(accessors,"accessors"); GuardStrategy.ThrowIfNull(item1, "item1"); GuardStrategy.ThrowIfNull(item2, "item2"); var foundOne=false; foreach(var accessor in accessors) { var values=new {Value1=accessor(item1),Value2=accessor(item2)}; if (shortCircuitBreak(values.Value1, values.Value2)) return false; if(foundOne==false && atLeastOneCondition(values.Value1,values.Value2)) { foundOne=true; } } return foundOne; } The Question(s): Is there an existing Linq keyword/operator combination that will do all this more gracefully? Is there a more elegant/simpler way to do this type of comparison that is better DRY, less coding, and more reuse?
