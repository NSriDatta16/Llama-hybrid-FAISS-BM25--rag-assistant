[site]: stackoverflow
[post_id]: 1167391
[parent_id]: 1167342
[tags]: 
They're more limited. You can say ++ on a pointer, but not on a ref or out . EDIT Some confusion in the comments, so to be absolutely clear: the point here is to compare with the capabilities of pointers. You can't perform the same operation as ptr++ on a ref / out , i.e. make it address an adjacent location in memory. It's true (but irrelevant here) that you can perform the equivalent of (*ptr)++ , but that would be to compare it with the capabilities of values , not pointers. It's a safe bet that they are internally just pointers, because the stack doesn't get moved and C# is carefully organised so that ref and out always refer to an active region of the stack. EDIT To be absolutely clear again (if it wasn't already clear from the example below), the point here is not that ref / out can only point to the stack. It's that when it points to the stack, it is guaranteed by the language rules not to become a dangling pointer. This guarantee is necessary (and relevant/interesting here) because the stack just discards information in accordance with method call exits, with no checks to ensure that any referrers still exist. Conversely when ref / out refers to objects in the GC heap it's no surprise that those objects are able to be kept alive as long as necessary: the GC heap is designed precisely for the purpose of retaining objects for any length of time required by their referrers, and provides pinning (see example below) to support situations where the object must not be moved by GC compacting. If you ever play with interop in unsafe code, you will find that ref is very closely related to pointers. For example, if a COM interface is declared like this: HRESULT Write(BYTE *pBuffer, UINT size); The interop assembly will turn it into this: void Write(ref byte pBuffer, uint size); And you can do this to call it (I believe the COM interop stuff takes care of pinning the array): byte[] b = new byte[1000]; obj.Write(ref b[0], b.Length); In other words, ref to the first byte gets you access to all of it; it's apparently a pointer to the first byte.
