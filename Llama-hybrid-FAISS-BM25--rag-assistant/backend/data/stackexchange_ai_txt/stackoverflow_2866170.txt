[site]: stackoverflow
[post_id]: 2866170
[parent_id]: 2866048
[tags]: 
I'll try my best to answer: Point (1): No, it does not call the assignment operator. Instead it calls a constructor. Since you need to construct the object anyway (since operator+ returns a copy), this does not introduce extra operations. Point (2): The temporary result is created in stack and hence does not introduce memory problem (it is destroyed when function exits). On return , a temporary is created so that an assignment (or copy constructor) can be used to assign the results to a (in a=b+c; ) even after result is destroyed. This temporary is destroyed automatically by the compiler. Point (3): The above is what the standard prescribes. Remember that compiler implementors are allowed to optimize the implementation as long as the effect is the same as what the standard prescribed. I believe, compilers in reality optimize away many of the copying that occurs here. Using the idiom above is readable and is not actually inefficient. P.S. I sometime prefer to implement operator+ as a non-member to leverage implicit conversion for both sides of the operators (only if it makes sense).
