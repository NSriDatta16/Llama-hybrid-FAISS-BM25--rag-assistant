[site]: stackoverflow
[post_id]: 4361369
[parent_id]: 4361170
[tags]: 
The generally-preferred way to define a callback function is to use a function handle instead of a string. When you use a string, the code in the string is evaluated in the base workspace . This means that all the variables and functions used in the string have to exist in the base workspace when the callback is evaluated. This makes for a poor GUI design, since you don't really want the operation of your GUI dependent on the base workspace (which the user can modify easily, thus potentially breaking your GUI). This also explains the error you are getting. The function delete_graphic is defined as a subfunction in your file rr_intervals.m . Subfunctions can only be called by other functions defined in the same m-file, so delete_graphic is not visible in the base workspace (where your string callback is evaluated). Using a function handle callback is a better alternative. Here's how you would do it: Change the callback of your button (line 216) from 'delete_graphic' to @delete_graphic . Change the function definition of delete_graphic (line 185) to: function delete_graphic(hObject,eventdata) where hObject is the handle of the object issuing the callback and eventdata is optional data provided when the callback is issued. EDIT: If you want to pass other arguments to delete_graphic , you can perform the following steps: Add the additional input arguments to the end of the function definition. For example: function delete_graphic(hObject,eventdata,argA,argB) Use a cell array when you set the callback for your button, where the first cell contains the function handle and the subsequent cells each contain an input argument. For example: set(delete_btn,'Callback',{@delete_graphic,A,B}); There is one caveat to this, which is that the values A and B stored in the cell array are fixed at what they are when you set the callback . If you change A or B in your code it will not change the values stored in the cell-array callback. If you aren't able to use the above solution (i.e. if A and B need to change value), there are a few other options for how you can share data among a GUI's callbacks : You can rework the organization of your code to make use of nested functions . This makes it very easy to share data between callbacks. Some nice examples of using nested functions to create GUIs can be found in the MathWorks File Exchange submission GUI Examples using Nested Functions by Steven Lord . You can store data in the UserData property of a uicontrol object. To access or update it, you just need the object handle. You can use the functions SETAPPDATA / GETAPPDATA to attach data to a handle graphics object (i.e. uicontrol). Since it appears your code was created using GUIDE, you can make use of the handles structure GUIDE creates to store data using the GUIDATA function.
