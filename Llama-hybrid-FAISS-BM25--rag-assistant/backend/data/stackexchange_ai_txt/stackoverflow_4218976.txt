[site]: stackoverflow
[post_id]: 4218976
[parent_id]: 4218812
[tags]: 
maulkye, There is something going wrong if you have to refresh your ObservableCollection . Usually, you should not need it because the ObservableCollection will notify about item changes. Never do this: FruitBasket = new ObservableCollection (FruitBasket); Your public ObservableCollection FruitBasket should have no public setter , it should be read only. Just Add or Remove Items to/from the list. If you want to handle multiple selections, you will probably need an extended CollectionView which can handle this, get more hints here . I hope this helps a little bit, even if I probably didn't answer all questions : ) EDIT: Ok, I guess i got some things wrong. Now i guess i fully understand what you're trying to accomplish. You are not getting notified when your property is changed, right? Well, for this reason, we've adapted " BindableLinq " in one of our projects, which you can compile in Silverlight without problems. (there are similar solutions available, called Continuous Linq or Obtics , make your choice). Using BindableLinq , you can transform your ObservableCollection to a BindableCollection using one single extension method. The BindableCollection will then reflect all changes properly. Give it a try. EDIT2: To implement a proper ViewModel, Please consider the following Changes. 1) Fruit is your Model . Since it doesn't implement INotifyPropertyChanged , it won't propagate any changes. Create a FruitViewModel , embedding your Fruit Model and invoke RaisePropertyChanged for each property setter. 2) Change your FruitBasket to be an ObservableCollection of FruitViewModel . Slowly it starts to make sense :) 3) SelectedFruit has to be a FruitViewModel as well. Now it makes even more sense. 4) Now it already works for me, even without BindableLinq . Did you have any success? HTH best regards, thomas
