[site]: stackoverflow
[post_id]: 5243015
[parent_id]: 5242925
[tags]: 
The first of these two implementations is incorrect. The string::reserve function does not change the size of the string; rather it just allocates internal buffer space for it. This means that if you start writing into the string, you're overwriting characters that are physically part of the string but not logically part of the string. That is, the characters are there, but the string's length won't report them as being a part of the string. However, I see why it is that you're trying to use reserve this way: If you use resize to make the string larger, then all the characters will have to have some value assigned to them, and this can contribute some inefficiency to the program. Therefore, you're looking for some way to avoid this cost. If you want to do this, consider using the following code: string ToUpper(const std::string& source) { std::string result; result.reserve(source.length()); for (string::const_iterator itr = source.begin(); itr != source.end(); ++itr) result += std::toupper(*itr); return result; } This first calls reserve on the result string to preallocate storage space for it. We then just walk across the elements of the first string, converting each to upper case and appending it to the resulting string using operator += . Since space already exists in the string because of the call to reserve , there shouldn't be any new allocations involved, and the buffer will just be written to with the characters that you want. Hope this helps!
