[site]: stackoverflow
[post_id]: 3740531
[parent_id]: 3738381
[tags]: 
This is an interesting problem. It seems like Greg has a good solution . But that's no fun ;) jsbueno as a very elegant solution but that only applies to strings (as you requested). The trick to a 'general' self referential dictionary is to use a surrogate object. It takes a few (understatement) lines of code to pull off, but the usage is about what you want: S = SurrogateDict(AdditionSurrogateDictEntry) d = S.resolve({'user': 'gnucom', 'home': '/home/' + S['user'], 'config': [S['home'] + '/.emacs', S['home'] + '/.bashrc']}) The code to make that happen is not nearly so short. It lives in three classes: import abc class SurrogateDictEntry(object): __metaclass__ = abc.ABCMeta def __init__(self, key): """record the key on the real dictionary that this will resolve to a value for """ self.key = key def resolve(self, d): """ return the actual value""" if hasattr(self, 'op'): # any operation done on self will store it's name in self.op. # if this is set, resolve it by calling the appropriate method # now that we can get self.value out of d self.value = d[self.key] return getattr(self, self.op + 'resolve__')() else: return d[self.key] @staticmethod def make_op(opname): """A convience class. This will be the form of all op hooks for subclasses The actual logic for the op is in __op__resolve__ (e.g. __add__resolve__) """ def op(self, other): self.stored_value = other self.op = opname return self op.__name__ = opname return op Next, comes the concrete class. simple enough. class AdditionSurrogateDictEntry(SurrogateDictEntry): __add__ = SurrogateDictEntry.make_op('__add__') __radd__ = SurrogateDictEntry.make_op('__radd__') def __add__resolve__(self): return self.value + self.stored_value def __radd__resolve__(self): return self.stored_value + self.value Here's the final class class SurrogateDict(object): def __init__(self, EntryClass): self.EntryClass = EntryClass def __getitem__(self, key): """record the key and return""" return self.EntryClass(key) @staticmethod def resolve(d): """I eat generators resolve self references""" stack = [d] while stack: cur = stack.pop() # This just tries to set it to an appropriate iterable it = xrange(len(cur)) if not hasattr(cur, 'keys') else cur.keys() for key in it: # sorry for being a duche. Just register your class with # SurrogateDictEntry and you can pass whatever. while isinstance(cur[key], SurrogateDictEntry): cur[key] = cur[key].resolve(d) # I'm just going to check for iter but you can add other # checks here for items that we should loop over. if hasattr(cur[key], '__iter__'): stack.append(cur[key]) return d In response to gnucoms's question about why I named the classes the way that I did. The word surrogate is generally associated with standing in for something else so it seemed appropriate because that's what the SurrogateDict class does: an instance replaces the 'self' references in a dictionary literal. That being said, (other than just being straight up stupid sometimes) naming is probably one of the hardest things for me about coding. If you (or anyone else) can suggest a better name, I'm all ears. I'll provide a brief explanation. Throughout S refers to an instance of SurrogateDict and d is the real dictionary. A reference S[key] triggers S.__getitem__ and SurrogateDictEntry(key) to be placed in the d . When S[key] = SurrogateDictEntry(key) is constructed, it stores key . This will be the key into d for the value that this entry of SurrogateDictEntry is acting as a surrogate for. After S[key] is returned, it is either entered into the d , or has some operation(s) performed on it. If an operation is performed on it, it triggers the relative __op__ method which simple stores the value that the operation is performed on and the name of the operation and then returns itself. We can't actually resolve the operation because d hasn't been constructed yet. After d is constructed, it is passed to S.resolve . This method loops through d finding any instances of SurrogateDictEntry and replacing them with the result of calling the resolve method on the instance. The SurrogateDictEntry.resolve method receives the now constructed d as an argument and can use the value of key that it stored at construction time to get the value that it is acting as a surrogate for. If an operation was performed on it after creation, the op attribute will have been set with the name of the operation that was performed. If the class has a __op__ method, then it has a __op__resolve__ method with the actual logic that would normally be in the __op__ method. So now we have the logic (self. op__resolve ) and all necessary values (self.value, self.stored_value) to finally get the real value of d[key] . So we return that which step 4 places in the dictionary. finally the SurrogateDict.resolve method returns d with all references resolved. That'a a rough sketch. If you have any more questions, feel free to ask.
