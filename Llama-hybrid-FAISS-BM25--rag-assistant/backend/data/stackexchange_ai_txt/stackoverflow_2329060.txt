[site]: stackoverflow
[post_id]: 2329060
[parent_id]: 2328697
[tags]: 
Here's one solution: let combine weights arrs = Array.map2 (fun w -> Array.map ((*) w)) weights arrs |> Array.reduce (Array.map2 (+)) EDIT Here's some (much needed) explanation of how this works. Logically, we want to do the following: Apply each weight to its corresponding row. Add together the weight-adjusted rows. The two lines above do just that. We use the Array.map2 function to combine corresponding weights and rows; the way that we combine them is to multiply each element in the row by the weight, which is accomplished via the inner Array.map . Now we have an array of weighted rows and need to add them together. We can do this one step at a time by keeping a running sum, adding each array in turn. The way we sum two arrays pointwise is to use Array.map2 again, using (+) as the function for combining the elements from each. We wrap this in an Array.reduce to apply this addition function to each row in turn, starting with the first row. Hopefully this is a reasonably elegant approach to the problem, though the point-free style admittedly makes it a bit tricky to follow. However, note that it's not especially performant; doing in-place updates rather than creating new arrays with each application of map , map2 , and reduce would be more efficient. Unfortunately, the standard library doesn't contain nice analogues of these operations which work in-place. It would be relatively easy to create such analogues, though, and they could be used in almost exactly the same way as I've done here.
