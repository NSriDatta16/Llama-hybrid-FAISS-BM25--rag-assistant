[site]: stackoverflow
[post_id]: 211894
[parent_id]: 211875
[tags]: 
Curious - it should work IIRC; I'll see if I can do a quick example - however, you might want to check that you have the fully-qualified enum name (i.e. including the namespace). [update] From here it seems that the RTM version shipped with a bug when resolving the enum. One workaround suggested (on that page) was to add the global:: prefix. It works fine for me without this workaround, so maybe it is fixed in 3.5 SP1? It also allegedly works fine in 3.5 if you use the unqualified name if the enum is in the same namespace. [example] Yup, worked fine: with Northwind, I defined an enum for the shipping country: namespace Foo.Bar { public enum MyEnum { France, Belgium, Brazil, Switzerland } } I then edited the dbml to have: This generated: private Foo.Bar.MyEnum _ShipCountry; //... [Column(Storage="_ShipCountry", DbType="NVarChar(15)", CanBeNull=true)] public Foo.Bar.MyEnum ShipCountry { get {...} set {...} } And finally wrote a query: using (DataClasses1DataContext ctx = new DataClasses1DataContext()) { var qry = from order in ctx.Orders where order.ShipCountry == Foo.Bar.MyEnum.Brazil || order.ShipCountry == Foo.Bar.MyEnum.Belgium select order; foreach (var order in qry.Take(10)) { Console.WriteLine("{0}, {1}", order.OrderID, order.ShipCountry); } } Worked fine; results: 10250, Brazil 10252, Belgium 10253, Brazil 10256, Brazil 10261, Brazil 10287, Brazil 10290, Brazil 10291, Brazil 10292, Brazil 10299, Brazil
