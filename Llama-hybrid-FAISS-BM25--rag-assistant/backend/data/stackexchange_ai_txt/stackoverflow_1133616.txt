[site]: stackoverflow
[post_id]: 1133616
[parent_id]: 1133289
[tags]: 
Let me completely ignore your example and give you an example of where we do method type inference in C#. (If this topic interests you then I encourage you to read the " type inference " archive of my blog.) Consider: void M (IDictionary > x) {} Here we have a generic method M that takes a dictionary that maps strings onto lists of T. Suppose you have a variable: var d = new Dictionary >() { ...initializers here... }; M(d); We have called M without providing a type argument, so the compiler must infer it. The compiler does so by "unifying" Dictionary > with IDictionary > . First it determines that Dictionary implements IDictionary . From that we deduce that Dictionary > implements IDictionary > . Now we have a match on the IDictionary part. We unify string with string, which is obviously all good but we learn nothing from it. Then we unify List with List, and realize that we have to recurse again. Then we unify int with T, and realize that int is a bound on T. The type inference algorithm chugs away until it can make no more progress, and then it starts making further deductions from its inferences. The only bound on T is int, so we deduce that the caller must have wanted T to be int. So we call M . Is that clear?
