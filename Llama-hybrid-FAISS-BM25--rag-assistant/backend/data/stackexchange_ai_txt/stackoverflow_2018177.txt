[site]: stackoverflow
[post_id]: 2018177
[parent_id]: 
[tags]: 
Modify code from an ATmega32 to an Arduino Mega - error in function `main' even if there is none

I'm trying to modify this code in an attempt to make it work on an Arduino Mega. I'm pretty much new to C so, I may have made some major mistakes. By the way, this is for a self balancing skateboard. This code is taken from an ATmega32 (from here and I'm trying to make it work on a Arduino Mega ). This code was writen for an ATmega32 development board . But I encounter this error: o: In function main': C:\Users\*******\AppData\Local\Temp\build27006.tmp/Test2.cpp:406: undefined reference to setup' How come? I don't even have a reference to setup in here! Here is my code: #include #include #include #include #define CLOCK_SPEED 16000000 #define OCR1_MAX 1023 typedef unsigned char u8; void set_motor_idle(void); void InitPorts(void); float level = 0; float Throttle_pedal; float aa; float accelraw; float x_acc; float accsum; float x_accdeg; float gyrosum; float gangleratedeg; float gangleraterads; float ti = 2.2; float overallgain; float gaincontrol; float batteryvolts = 24; float gyroangledt; float angle; float anglerads; float balance_torque; float softstart; float cur_speed; float cycle_time = 0.0064; float Balance_point; float a0, a1, a2, a3, a4, a5, a6; //Savitzky-Golay variables for accelerometer. float TCCR0; int i; int j; int tipstart; void InitPorts(void) { PORTC = 0x00; //Port C pullups set to low (no output voltage) to begin with. DDRC = 0xFF; //Port C pins all set as output via the port C direction register. //PORTC |= (1 OSMC pin 6 PD4/OC1B BLI -> OSMC pin 8 PC1 Disable -> OSMC pin 4 PC2 BHI -> OSMC pin 7 PC3 AHI -> OSMC pin 5 PA6/ADC6 Vbatt/10 -> OSMC pin 3 PA1/ADC1 pitch rate gyro PA0/ADC0 accelerometer */ void adc_init(void) { /* Turn off analogue comparator as we don't use it */ ACSR = (1 100) Balance_point = 534; if (adc5>100) Balance_point = 494; PORTB |= (1 250) x_acc = 250; /* Accelerometer angle change is about 3.45 units per degree tilt in range 0-30 degrees(sin theta). Convert tilt to degrees of tilt from accelerometer sensor. Sin angle roughly = angle for small angles so no need to do trigonometry. x_acc below is now in DEGREES */ x_accdeg= (float) x_acc/-3.45; //The minus sign corrects for a back //to front accelerometer mounting! /* GYRO signal processing*/ /* Subtract offsets: Sensor reading is 0-1024 so "balance point" i.e. my required zero point will be that reading minus 512. */ /* Gyro angle change of 20mV per deg per sec from datasheet gives change of 4.096 units (on the scale of 0 - 1023) per degree per sec angle change. This limits the rate of change of gyro angle to just less than the maximum rate it is actually capable of measuring (100 deg/sec). Note all these fractions are rounded up to an integer later just before it is sent to the PWM generator which in turn is connected to the motor controller. */ gangleratedeg = (float)((gyrosum/7) - 508)/4.096; //gyrosum is a sum of a group //of 7 samples so divide by 7 for gyro value if (gangleratedeg 92) gangleratedeg = 92; /* I turn port B2 on and off once per main program cycle so I can attach an oscilloscope to it and work out the program cycle time. I use the cycle time to work out gyro angle change per cycle where you have to know the length of this time interval. */ PORTB &= (0 0.9) level=0.9; int16_t leveli = (int16_t)(level*1023); //NOTE: here we take the floating //point value we have ended up with //for "level", we multiply it by 1023 //and then make it into an integer //before feeding the value into //the PWM generator as "leveli" if (leveli 1020) leveli=1020; /* Set up LED or buzzer on Port B1 to warn me to slow down if torque to be delivered is more than 50% of max possible. The reason for this is that you always need some reserve motor power in case you start tipping forward at speed. If the motor is already running flat-out you would be about to fall over at high speed! Some use an auto-tip back routine to automatically limit top speed. For now I will do it this way as easier. */ if (level 0.7) { PORTB |= (1 1.0) softstart=1.0; //PORTC |= (0 524) { // if (x_accdeg>0) { tipstart=0; } else { tipstart=1; softstart=0.4; } } angle=0; cur_speed=0; /* End of tilt start code. If go beyond this point then machine has become level and is active. */ sei(); while (1) { sample_inputs(); set_motor(); } } BTW, I'm using the Arduino compiler (you can find it at Download the Arduino Software ).
