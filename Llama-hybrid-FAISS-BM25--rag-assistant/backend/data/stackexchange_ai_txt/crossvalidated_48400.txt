[site]: crossvalidated
[post_id]: 48400
[parent_id]: 48396
[tags]: 
ThePawn has the right idea to attack the problem with a recurrence relationship. Consider a Markov chain with states $\{0, \dotsc, 6\}$ corresponding to the count of the number of distinct dice rolls that have happened. State 0 is the start state, and state 6 is the finish state. Then, the probability of transition from state $i$ to itself is $\frac{i}{6}$. The probability of transition from state $i$ to state $i+1$ is $\frac{6-i}{6}$. Therefore the hitting time of the finish state is \begin{align} \sum_{i=0}^5 \frac{6}{6-i} = 14.7 \end{align} For the maximum of four trials, consider states that are quadruples. You want to find the expected hitting time for the target state $(6,6,6,6)$. The expected hitting time of any state $j$ is the weighted average for each source state $i$ of the expected hitting time $T_i$ plus the time to go from $i$ to $j$, weighted by $p_ip_{ij}$, the probability of arriving at state $i$ and moving to $j$. You can discover the hitting times and probabilities by dynamic programming. It's not so hard since there is a traversal order to fill in the hitting times and probabilities. For example, for two die: first calculate T and p for (0,0), then for (1,0), then (1, 1), (2, 0), then (2, 1), etc. In Python: import numpy as np import itertools as it from tools.decorator import memoized # A standard memoization decorator SIDES = 6 @memoized def get_t_and_p(state): if all(s == 0 for s in state): return 0, 1.0 n = len(state) choices = [[s - 1, s] if s > 0 else [s] for s in state] ts = [] ps = [] for last_state in it.product(*choices): if last_state == state: continue last_t, last_p = get_t_and_p(tuple(sorted(last_state))) if last_p == 0.0: continue transition_p = 1.0 stay_p = 1.0 for ls, s in zip(last_state, state): if ls
