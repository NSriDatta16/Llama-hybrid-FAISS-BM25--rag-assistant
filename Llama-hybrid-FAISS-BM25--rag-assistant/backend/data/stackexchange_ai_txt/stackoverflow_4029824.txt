[site]: stackoverflow
[post_id]: 4029824
[parent_id]: 4029797
[tags]: 
The answer is 'it depends' - most notably on the machine, and also on how the data is written to the file. Consider: unsigned short x = 0x0102; write(fd, &x, sizeof(x)); On some machines (Intel), the low-order byte (0x02) will be written before the high-order byte (0x01); on others (PPC, SPARC), the high-order byte will be written before the low-order one. So, from a little-endian (Intel) machine, you'd see the bytes: 0x02 0x01 But from a big-endian (PPC) machine, you'd see the bytes: 0x01 0x02 Your bytes appear to be 0x01 and 0x04. Your calculation for 0x02 appears flawed. The C code you show doesn't write anything. The value in nDayOfYear is the bottom 9 bits of the input value; the nTimeOfDay appears to be the next 5 bits (so 14 of the 16 bits are used). For example, if the value in strInput is 12141 decimal, 0x2F6D, then the value in nDayOfYear would be 365 (0x16D) and the value in nTimeOfDay would be 23 (0x17). It is a funny storage order; you can't simply compare the two values whereas if you packed the day of year in the more significant portion of the value and time into the less significant, then you could compare values as simple integers and get the correct comparison.
