[site]: stackoverflow
[post_id]: 5129072
[parent_id]: 5128727
[tags]: 
Try adding close_fds=True to your Popen call (see discussion here ). If you have other pipes open in other threads, it may be the case that they are interacting somehow (forcing a particular ordering of threads). Consider using Popen.communicate() rather than reading from the process' stdout stream directly. With that said, it seems unlikely that your ping implementation would return different readings based on how well its output is being buffered. At a higher level, you should keep in mind that ping timing data is inherently unreliable. If you can't fix the spike, and you're convinced it is an artefact from the Popen call (rather than just random noise), then it is probably reasonable to post-process the data. For example, you could collect 5 datapoints at a time and take the median. (Note that the median is less sensitive to outliers than the average). This is no worse than what ping is already doing. Update 26/02 Sorry to hear ^ didn't help. Couple of other ideas: 1. It might be helpful if we know a bit more about how you're running ping from the shell. In python, you're using -c1 to limit ping to a single try. I am guessing that, in the shell, you are simply running ping hostname and watching the results in real time -- is this true? If so, please try running a bash script as follows: #! /bin/bash for i in {1..50} do ping -c1 somehostname # maybe 'sleep 1' here done And look very carefully at the results. It is possible that the spikes are the result of how you're calling ping . 2. Your sample code doesn't have your regex definitions. Are you 100% sure they are capturing the exact right values from ping's output?
