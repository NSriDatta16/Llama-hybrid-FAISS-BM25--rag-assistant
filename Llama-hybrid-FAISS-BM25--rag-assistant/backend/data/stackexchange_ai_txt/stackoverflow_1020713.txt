[site]: stackoverflow
[post_id]: 1020713
[parent_id]: 1018679
[tags]: 
Assuming that your Linq2Sql implementation has the same relationships in it as the database (which if you did drag and drop to the designer, they definitely do), here's how I would approach it. I would create a strongly typed partial view of type Agency that would represent each section (Agency, in your case), call it AgencyReportSection.ascx. This control will take an agency, iterate through its business units, which in turn iterate through its clients. Wherever you are packaging up your data, do something like this: DataContext context = new DataContext(); DataLoadOptions options = new DataLoadOptions(); options.LoadWith (a => a.BusinessUnit); options.LoadWith (b => b.Client); context.LoadOptions = options; What this will give you is that when the context gets an agency, it will follow the defined relationships and give you those objects as well. So you get: Agency a = context.Agency.FirstOrDefault(); IEnumerable units = a.BusinessUnits; IEnumerable clients = units.Clients; Your view could do something like: The reason you are doing the data load option is to avoid lazy loading in the view, let the model pack up all the necessary data. I hope I've understood your question correctly...
