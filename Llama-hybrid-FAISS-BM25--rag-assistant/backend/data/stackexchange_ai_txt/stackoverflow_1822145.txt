[site]: stackoverflow
[post_id]: 1822145
[parent_id]: 1821302
[tags]: 
I tracked down the problem and it's a rather interesting one. When the DefaultModelBinder attempts to resolve a model item one of the first things it does is check to see if there are any prefixed fields in the data being bound; it does this by checking for any form items that begin with the name of the model object (this seems extremely arbitrary , if you ask me). If any "prefixed" fields are found then it results in different binding logic being invoked. ASP.NET MVC 2 Preview 2 BindModel() Source public virtual object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext) { if (bindingContext == null) { throw new ArgumentNullException("bindingContext"); } bool performedFallback = false; if (!String.IsNullOrEmpty(bindingContext.ModelName) && !DictionaryHelpers.DoesAnyKeyHavePrefix(bindingContext.ValueProvider, bindingContext.ModelName)) { // We couldn't find any entry that began with the prefix. If this is the top-level element, fall back // to the empty prefix. if (bindingContext.FallbackToEmptyPrefix) { /* omitted for brevity */ }; performedFallback = true; } else { return null; } } // Simple model = int, string, etc.; determined by calling TypeConverter.CanConvertFrom(typeof(string)) // or by seeing if a value in the request exactly matches the name of the model we're binding. // Complex type = everything else. if (!performedFallback) { /* omitted for brevity */ } if (!bindingContext.ModelMetadata.IsComplexType) { return null; } return BindComplexModel(controllerContext, bindingContext); } The controller action I defined to handle the Add action defines a PageContent item called "content" and in my domain PageContent has a property called "Content" which "matched" with the model name of "content" thus causing the DefaultModelBinder to assume I had a prefixed value when in fact it was simply a member of PageContent. By changing the signature- from: [HttpPost, ValidateInput(false)] public ActionResult AddContent(PageContent content, FormCollection formCollection) {} to: [HttpPost, ValidateInput(false)] public ActionResult AddContent(PageContent pageContent, FormCollection formCollection) {} The DefaultModelBinder was once again able to correctly bind to my PageContent model item. I'm not sure why the Edit view didn't also display this behavior, but either way I've tracked down the source of the issue. It seems to me that this issue falls very close to "bug" status. It makes sense that my view worked initially with the ViewModel because "content" was getting prefixed with "PageContent_", but a core framework feature/bug like this ought not be unaddressed IMHO.
