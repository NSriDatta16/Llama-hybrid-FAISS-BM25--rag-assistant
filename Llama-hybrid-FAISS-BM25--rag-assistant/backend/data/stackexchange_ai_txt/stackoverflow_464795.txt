[site]: stackoverflow
[post_id]: 464795
[parent_id]: 455046
[tags]: 
Essentially all code coverage tools instrument the code in order to check which parts of the code were executed. As defined in the link you provided, C0 and C1 are pretty similar from the point of view of the person writing the instrumentation. The only difference is where you place the code. I'll go further to speculate that C1 is even easier than C0, because the instrumentation happens on the, let's say, abstract syntax level, where line ends do not count very much. Another reason I'm saying C1 is easier is because it deals with syntactic entities as opposed to lexical entities: how would you instrument: if c > 1 && c Well, just a thought. As for C2, I have never seen it done in practice. The reason is that you can get an exponential blowup: if c1 then * else * end if c2 then * else * end ... if cn then * else * end For n lines of code, you would need 2^n tests. Also, what do you do for loops? Typically, you abstract them away as simple if statements (i.e. for each loop you test that its body was executed 0 times for one test and at least once in another test). I believe sampling the PC is a particularly terrible way to do code coverage because you may miss some statements because they executed too fast :D Same goes for fuzzy logic, which is used to reason about approximations; typically you want your code coverage to b deterministic. Karnaugh maps are used for minimizing boolean functions, and I do not see any useful link with code coverage tools. Also, your question is not being very clear at times: do you want techniques to achieve better code coverage or is it just the implementation of code coverage tools that interests you?
