[site]: stackoverflow
[post_id]: 4615562
[parent_id]: 4615416
[tags]: 
A type is a classification of a piece of data telling you what its permissible values and permissible operations are. (Almost?) all programming languages have types, although the typing discipline varies considerably from one language to another. A class is a particular kind of type in OOP languages which is defined with a specific syntax in the language itself (as opposed to, say, so-called "native types" like Java's int or float or the like which are defined by the language proper). A class is typically defined in terms of a memory layout and encoding of data (so-called member variables ) and the functions that work on them (so-called member functions or methods ). An interface * is a specification of what operations a type must implement to be considered part of a given set of similar types but which does not specify permissible values, memory layouts, etc. This is a very, very, very brief overview that is kind of the simplified "average form" of several languages' approach to these. It ignores a few edge cases and things like C++'s ability to make things that are part-way between an interface and a class. It also ignores what classes are in functional languages like Haskell because damaging your brain farther is not the goal here. ;) edited to add some examples Here are some Java- like declarations to help cement the concepts. int myVariable1; This variable— myVariable1 —is a native (or primitive) type consisting of a 32-bit signed integer value encoded in 2s-complement notation. It has a known range (of approximately -2 billion to +2 billion) and a known set of operations (multiplication, addition, division, modulus, subtraction, various conversions, etc.) available to it. class MyClass { int myMemberVariable; int myOtherMemberVariable; int myMethod(int p) { myMemberVariable += p; myOtherMemberVariable = p; } } MyClass myVariable2 = new MyClass(); Here myVariable2 is a type defined by the class MyClass . MyClass defines the memory layout (which in this case consists of two 32-bit signed integers in 2s-complement notation) as well as the single operation myMethod() which adds its argument to myMemberVariable and sets myOtherMemberVariable to that argument. interface MyInterface { int myInterfaceMethod(int p, int q); } Here MyInterface only declares a set of operations (consisting in this case of the single function myInterfaceMethod() ) without any member variables and without any implementation. It only tells you that any class that implements this interface is guaranteed to have a method with that specific signature of name + return value + arguments. To use it you have to make a class that implements the interface. class MyOtherClass implements MyInterface { int myMember1; int myMember2; int myMember3; int myInterfaceMethod(int p, int q) { myMember1 = p; myMember2 = q; myMember3 = p - q; } int myNonInterfaceMethod() { return myMember1; } } MyOtherClass myVariable3 = new MyOtherClass(); Now myVariable3 is defined as a type with a memory layout consisting of three signed 32-bit integers and two operations. One of those operations is one it must implement because of the whole implements MyInterface portion. This way anything that's expecting the (abstract) MyInterface type can use the (concrete) MyOtherClass type since the operation is guaranteed to be there. The other method— myNonInterfaceMethod() —does not come from MyInterface so something that is expecting only a MyInterface can't use it because it can't know it exists. further edited to add some real-world stuff by request If you've ever used an integer value, a floating point value, a string or anything like this in a program you've used types. Types are arguably the stuff of computing and everything we do is manipulation of values of given types. I'll focus, therefore, on the OOP-specific notions of classes and interfaces. Any time you have data and operations on that data you have the potential for a class. Take, for example, a bank account. A bank account will have, among other things, an account number, a current balance, a transaction limit, etc. A class representing this (badly and shown only to explain concepts) might look like this: class BankAccount { String accountNumber; float balance; /* DO NOT USE FLOATING POINT IN REAL FINANCIAL CODE! */ int transaction_limit; float transaction(float change) { balance += change > transaction_limit ? transaction_limit : change; return balance; } } Now you can make a variable of this type and know that it will carry around an account number (which is itself a String type), a balance (which is itself a float type -- but DON'T USE FLOATING POINT IN REAL WORLD FINANCIAL CODE! ) and a transaction limit (which is itself an int type). You also know you can perform a transaction (creatively called transaction ) which will check the change against the transaction limit and modify the balance. (A real class for this would contain lots more and would contain a lot of obfuscatory protection stuff that I've removed for pedagogical purposes.) Now let's say you're in a more sophisticated financial environment in which there are several kinds of transactions, not just bank accounts. Let's say further you've got some code that will process transactions that doesn't care what the specifics of the underlying types are . An offline batch processor of transactions, say, that covers bank accounts, accounts receivables accounts, etc. Rather than making it know about every kind of transaction in the book, we can do this instead: interface Transactable { float transaction(float change); } class BankAccount implements Transactable { /* interior is identical */ } class ReceivablesAccount implements Transactable { float balance; float transaction(float change) { balance += change; } } Now anything that knows about Transactable types can use both your BankAccount 's instances as well as your ReceivablesAccount 's instances. They don't have to know that bank accounts have transaction limits while receivables accounts don't. They don't have to know anything about the internal representation of the data. They don't have to know the special cases of anything. They just have to know about one function by name ( transaction() ) and that's it. (If you want more concrete real-world usage of this, look at how the collection classes, not to mention the "for in" loop, use the Iterable interface in Java.)
