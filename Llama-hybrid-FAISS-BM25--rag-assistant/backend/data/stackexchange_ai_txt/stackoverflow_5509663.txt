[site]: stackoverflow
[post_id]: 5509663
[parent_id]: 5509427
[tags]: 
You may not use the built-in Random() function per field, but globally some code with pipelined-optimized access, working with a random pre-generated array: var crc32tab: array[byte] of cardinal; procedure InitCrc32Tab; var i,n: integer; crc: cardinal; begin // this code size is only 105 bytes, generating 1 KB table content for i := 0 to 255 do begin crc := i; for n := 1 to 8 do if (crc and 1)<>0 then // $edb88320 from polynomial p=(0,1,2,4,5,7,8,10,11,12,16,22,23,26) crc := (crc shr 1) xor $edb88320 else crc := crc shr 1; crc32tab[i] := crc; end; end; type NativeUInt = cardinal; // before Delphi 2007 procedure RandomData(P: PAnsiChar; Len: integer); var i: integer; seed0, seed1, seed2, seed3: cardinal; begin if Len>=16 then begin seed0 := Random(maxInt); seed1 := seed0*$8088405; seed2 := seed1*$8088405; seed3 := seed2*$8088405; for i := 1 to Len shr 4 do begin // pipelined loop for 16 bytes at once PCardinalArray(P)[0] := crc32tab[byte(seed0)] xor seed0; seed0 := seed0 xor NativeUInt(P); PCardinalArray(P)[1] := crc32tab[byte(seed1)] xor seed1; seed1 := seed1 xor NativeUInt(P); PCardinalArray(P)[2] := crc32tab[byte(seed2)] xor seed2; seed2 := seed3 xor NativeUInt(P); PCardinalArray(P)[3] := crc32tab[byte(seed3)] xor seed3; seed3 := seed3 xor NativeUInt(P); inc(P,16); end; end; for i := 1 to Len and 15 do begin P^ := PAnsiChar(@crc32tab)[NativeUInt(P) and 1023]; inc(P); end; end; The above function can be called like this (you must call InitCrc32Tab procedure once in your program): procedure FillRandomListSignals(var ListSignals: TListSignals); begin RandomData(@ListSignals,sizeof(ListSignals)); end; It will be faster than using the Random() function, because this function uses two integer multiplications, and is not pipelined at all. The above loop will handle 16 bytes at once, with no multiplication, and multiple operations per CPU clock, because I optimized it to use as much CPU pipelines as possible. We could perhaps play with the seed? variables, or use some optimized asm, but you've got the idea. Postscriptum: Since you're filling the list with random data, there is NO NEED of clearing it before. Just waste of time.
