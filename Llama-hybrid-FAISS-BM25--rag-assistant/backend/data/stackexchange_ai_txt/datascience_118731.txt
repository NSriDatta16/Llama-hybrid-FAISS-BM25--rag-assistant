[site]: datascience
[post_id]: 118731
[parent_id]: 118707
[tags]: 
I managed to solve this myself today. I don't understand why, but explicitly passing the datetime series and value series to matplotlib, instead of the dataframe (or numpy array) directly, does the job. ## relevant imports from earlier in the project # #import polars as pl #import matplotlib #import matplotlib.pyplot as plt #%matplotlib inline fig = plt.figure(figsize=(12,8), facecolor='white') ax_cpu = fig.add_subplot(111) ax_ram = ax_cpu.twinx() ax_cpu.set_ylim(ymax=cores_max) ax_ram.set_ylim(ymax=memory_max) ax_cpu.set_ylabel('Cores', fontsize=14, color='purple') ax_ram.set_ylabel('RAM (GB)', fontsize=14, color='orange') cpu_axes_time = binned_df_cpu_all.get_column("Start") cpu_axes_value = binned_df_cpu_all.get_column("AllocCPUS") ram_axes_time = binned_df_ram_all.get_column("Start") ram_axes_value = binned_df_ram_all.get_column("ReqMem") ax_cpu.plot(cpu_axes_time, cpu_axes_value, color='purple', alpha=0.8) ax_ram.plot(ram_axes_time, ram_axes_value, color='orange', alpha=0.8) plt.title('Total Cores/RAM Allocation\n{start} through {end}'.format( start=datestamp_min.date(), end=datestamp_max.date())) # optional, rotates them a bit nicely fig.autofmt_xdate() ```
