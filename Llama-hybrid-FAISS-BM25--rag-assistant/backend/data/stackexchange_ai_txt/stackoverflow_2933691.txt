[site]: stackoverflow
[post_id]: 2933691
[parent_id]: 2933674
[tags]: 
The way that C# handles overloading from an internal perspective is what's different. The complete quote from Anders: I have always described myself as a pragmatic guy. It's funny, because versioning ended up being one of the pillars of our language design. It shows up in how you override virtual methods in C#. Also, the way we do overload resolution in C# is different from any other language I know of, for reasons of versioning. Whenever we looked at designing a particular feature, we would always cross check with versioning. We would ask, "How does versioning change this? How does this function from a versioning perspective?" It turns out that most language design before has given very little thought to that.
