[site]: stackoverflow
[post_id]: 4039323
[parent_id]: 4039158
[tags]: 
this is very dependent of the format these are in. Here's an example of how to do it assuming 2 byte wide, little-endian samples: import wave w1 = wave.open("/path/to/wav/1") w2 = wave.open("/path/to/wav/2") #get samples formatted as a string. samples1 = w1.readframes(w1.getnframes()) samples2 = w2.readframes(w2.getnframes()) #takes every 2 bytes and groups them together as 1 sample. ("123456" -> ["12", "34", "56"]) samples1 = [samples1[i:i+2] for i in xrange(0, len(samples1), 2)] samples2 = [samples2[i:i+2] for i in xrange(0, len(samples2), 2)] #convert samples from strings to ints def bin_to_int(bin): as_int = 0 for char in bin[::-1]: #iterate over each char in reverse (because little-endian) #get the integer value of char and assign to the lowest byte of as_int, shifting the rest up as_int [0x0804] samples2 = [bin_to_int(s) for s in samples2] #average the samples: samples_avg = [(s1+s2)/2 for (s1, s2) in zip(samples1, samples2)] And now all that's left to do is convert samples_avg back to a binary string and write that to a file using wave.writeframes . That's just the inverse of what we just did, so it shouldn't be too hard to figure out. For your int_to_bin function, you'll probably what to make use of the function chr(code) , which returns the character with the character code of code (opposite of ord)
