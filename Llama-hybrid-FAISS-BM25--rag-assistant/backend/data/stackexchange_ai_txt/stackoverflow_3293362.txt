[site]: stackoverflow
[post_id]: 3293362
[parent_id]: 3284369
[tags]: 
I have found an answer to my question 2: The association property Contacts is not included in the Domain Service Object types that are generated. You have to specify the [Include] attribute for them to be included. However the include attribute requires an [Association] attribute. You can not specify the [Association] attribute because this is a many to many relationship and the association attribute requires you to specify foreign keys. The solution is to wrap your objects in a data transfer object (DTO). I did not have to make major changes to the code that was already in my question. The only thing changed was the retrieval of the Customer in the domain service class: public CustomerDTO GetCustomerById(int Id) { return new CustomerDTO(this.ObjectContext.Customers.Include("Contacts").SingleOrDefault(s => s.Id == Id)); } The main part of the solution was to change add the DTO classes to the underlying entity framework model: [DataContract] public partial class CustomerDTO : Customer { public CustomerDTO() { } public CustomerDTO(Customer customer) { if (customer != null) { Id = customer.Id; Name = customer.Name; CustomerContacts = new Collection (); foreach (Contact d in customer.Contacts) { CustomerContacts.Add(new ContactDTO(d, Id)); } } } [DataMember] [Include] [Association("CustomerContacts", "CustomerId", "Id")] public Collection CustomerContacts { get; set; } } [KnownType(typeof(CustomerDTO))] public partial class Customer { } [DataContract()] public partial class ContactDTO : Contact { public ContactDTO() { } public ContactDTO(Contact contact, int customerId) { if (contact != null) { Id = contact.Id; FullName = contact.FullName; CustomerId = customerId; } } [DataMember] public int CustomerId { get; set; } } [KnownType(typeof(ContactDTO))] public partial class Contact { } The KnownType , DataMember and DataContract attributes were required to get this to work. In reality instantiating the objects will require a bit more copying of properties in the constructors. Is there an easy way to avoid code that does an explicit copy? I'm open for suggestions. I was hoping to avoid the introduction of extra classes, but it seems unavoidable in case of a many to many relationship, because of the required Association attribute that needs a foreign key specification; in my case Contact.CustomerId . Can anybody do better (== less coding) ?
