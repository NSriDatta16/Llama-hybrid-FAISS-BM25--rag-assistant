[site]: stackoverflow
[post_id]: 1473625
[parent_id]: 
[tags]: 
python multiprocessing manager & composite pattern sharing

I'm trying to share a composite structure through a multiprocessing manager but I felt in trouble with a " RuntimeError: maximum recursion depth exceeded " when trying to use just one of the Composite class methods. The class is token from code.activestate and tested by me before inclusion into the manager. When retrieving the class into a process and invoking its addChild() method I kept the RunTimeError , while outside the process it works. The composite class inheritates from a SpecialDict class, that implements a ** ____getattr()____ ** method. Could be possible that while calling addChild() the interpreter of python looks for a different ** ____getattr()____ ** because the right one is not proxied by the manager? If so It's not clear to me the right way to make a proxy to that class/method The following code reproduce exactly this condition: 1) this is the manager.py: from multiprocessing.managers import BaseManager from CompositeDict import * class PlantPurchaser(): def __init__(self): self.comp = CompositeDict('Comp') def get_cp(self): return self.comp class Manager(): def __init__(self): self.comp = QueuePurchaser().get_cp() BaseManager.register('get_comp', callable=lambda:self.comp) self.m = BaseManager(address=('127.0.0.1', 50000), authkey='abracadabra') self.s = self.m.get_server() self.s.serve_forever() 2) I want to use the composite into this consumer.py: from multiprocessing.managers import BaseManager class Consumer(): def __init__(self): BaseManager.register('get_comp') self.m = BaseManager(address=('127.0.0.1', 50000), authkey='abracadabra') self.m.connect() self.comp = self.m.get_comp() ret = self.comp.addChild('consumer') 3) run all launching by a controller.py: from multiprocessing import Process class Controller(): def __init__(self): for child in _run_children(): child.join() def _run_children(): from manager import Manager from consumer import Consumer as Consumer procs = ( Process(target=Manager, name='Manager' ), Process(target=Consumer, name='Consumer'), ) for proc in procs: proc.daemon = 1 proc.start() return procs c = Controller() Take a look this related questions on how to do a proxy for CompositeDict() class as suggested by AlberT. The solution given by tgray works but cannot avoid race conditions
