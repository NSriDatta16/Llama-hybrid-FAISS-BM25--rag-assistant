[site]: stackoverflow
[post_id]: 2105362
[parent_id]: 2105208
[tags]: 
I'm not quite sure where does the Criteria.Period value come from in your sample query. However I think you're trying to read both hires and terminations for all available months (and then you can easily filter it). Your query could go wrong if the first table (Termination) didn't include any records for some specified month (say May). Then the select clause wouldn't be called with "May" as the parameter at all and even if you had some data in the second table (representing Hires), then you wouldn't be able to find it. This can be elegantly solved using the Concat method (see MSDN samples). You could select all termniations and all hires (into a data structure of some type) and then group all the data by month: var terms = from t in HRSystemDB.Terminations select new { Month = t.TerminationDate.Month, Year = term1.TerminationDate.Year, IsHire = false }; var hires = from emp in HRSystemDB.Persons.OfType () select new { Month = emp.HireDate.Month, Year = emp.HireDate.Year IsHire = true }; // Now we can merge the two inputs into one var summary = terms.Concat(hires); // And group the data using month or year var res = from s in summary group s by new { s.Year, s.Month } into g select new { Period = g.Key, Hires = g.Count(info => info.IsHire), Terminations = g.Count(info => !info.IsHire) } When looking at the code now, I'm pretty sure there is some shorter way to write this. On the other hand, this code should be quite readable, which is a benefit. Also note that it doesn't matter that we split the code into a couple of sub-queries. Thanks to lazy evalutation of LINQ to SQL, this should be executed as a single query.
