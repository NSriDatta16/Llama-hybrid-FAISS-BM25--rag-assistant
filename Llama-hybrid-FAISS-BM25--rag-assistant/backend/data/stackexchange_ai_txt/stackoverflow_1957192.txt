[site]: stackoverflow
[post_id]: 1957192
[parent_id]: 1717288
[tags]: 
I may have an alternate solution to rotating the array inline. Rather than the old trick of reversing sets of elements, as proposed earlier, this approach works as follows: Initialization: (Note q = amount to shift left, n = length of array) Determine the first source element, which is located at x1=q%n The destination element is at x2=0 char, ch1, is the ar[x1] element char, ch2, is the ar[x2] element Loop on i=0 to n-1, where n = length of array Overwrite the destination element, ar[x2] with ch1 Set ch1 = ch2 Set x1 = x2 Set x2 = x2 - q If x2 is negative due to the above subtraction, add n to it ch2 = ar[x2] The following may help explain how this works. Example, rotate to the left by 2 characters: a b c d e f g c d e f g a b x1 ch1 x2 ch2 2 c 0 a 0 a 5 f 5 f 3 d 3 d 1 b 1 b 6 g 6 g 4 e 4 e 2 c As you can see, this requires no more than n iterations, so it is linear time algorithm that also rotates inline (requires no additional storage other than the few temporary variables). Here is a function that implements the above algorithm so you can try it out: void rotate(char *ar, int q) { if (strlen(ar)
