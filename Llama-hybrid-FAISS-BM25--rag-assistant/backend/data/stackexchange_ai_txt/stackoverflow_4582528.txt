[site]: stackoverflow
[post_id]: 4582528
[parent_id]: 4580969
[tags]: 
I understand that placement new calls are usually matched with explicit calls to the destructor. If I have no need for a destructor (no code to put there, and no member variables that have destructors) can I safely skip the explicit destructor call? Yes. If I don't need to fly to New York before posting this answer, can I safely skip the trip? :) However, if the destructor is truly unneeded because it does nothing, then what harm is there in calling it? If the compiler can figure out a destructor should be a no-op, I'd expect it to eliminate that call. If you don't write an explicit dtor, remember that your class still has a dtor, and the interesting case – here – is whether it is what the language calls trivial. Solution: destroy previously constructed objects before constructing over them, even when you believe the dtor is a no-op. I want to write C++ bindings for a C API. In the C API many objects are accessible only by pointer. Instead of creating a wrapper object that contains a single pointer (which is wasteful and semantically confusing). I want to use placement new to construct an object at the address of the C object. This is the purpose of layout-compatible classes and reinterpret_cast. Include a static assert (e.g. Boost's macro, 0x static_assert, etc.) checking size and/or alignment, as you wish, for a short sanity check, but ultimately you have to know a bit of how your implementation lays out the classes. Most provide pragmas (or other implementation-specific mechanisms) to control this, if needed. The easiest way is to contain the C struct within the C++ type: // in C header typedef struct { int n; //... } C_A; C_A* C_get_a(); // your C++ struct A { void blah(int n) { _data.num += n; } // convenience functions static A* from(C_A *p) { return reinterpret_cast (p); } static A const* from(C_A const *p) { return reinterpret_cast (p); } private: C_A _data; // the only data member }; void example() { A *p = A::from(C_get_a()); p->blah(42); } I like to keep such conversions encapsulated, rather than strewing reinterpret_casts throughout, and more uniform (i.e. compare call-site for const and non-const), hence the convenience functions. It's also a bit harder to modify the class without noticing this type of use must still be supported. Depending on the exact class, you might make the data member public.
