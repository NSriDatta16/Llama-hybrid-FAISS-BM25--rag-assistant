[site]: stackoverflow
[post_id]: 289730
[parent_id]: 272524
[tags]: 
What you describe here makes me feel like in the middle of a nightmare! I think you should first begin to make clear to everybody that it is impossible (or at least extremely expensive) to think of being able to allow the users to update all of the data through 2 different application with 2 different databases during the whole transition process! I am not even talking about the 2 seconds delay ... According to me, the basic strategy should be to gradually switch data update rights and possibilities from the legacy to the new app. Users will be able to see the data from both sides, but will be able to update it only through one of the apps. (incidentaly, this method will also force the users to switch gradually to the new version, avoiding expected and annoying resistance issue already exposed by @HLGEM ) Once this rule is clearly accepted, you could then implement the following steps. Set all procedures allowing data transfer from legacy database to new database. I guess you'll need to run them a few times in the coming months... Set all procedures allowing data transfer the other way (reverse data transfer) Here you should have identified homogeneous groups of tables than can be moved together. Merge the previous code in a way that you'll get for each of these groups a "data transfer" procedure and a "reverse transfer" one. Then, for each of these groups Put your update restrictions through code or at database level Run your "data transfer" procedure Organise your "reverse transfer" procedure as a trigger in the new database I guess the first kind of data you'll be able to transfer will be lists that do not contain any foreign keys. Working this way, you will gradually switch from a situation where you have read/write legacy app + read-only new app to read-only legacy app + read/write new app.
