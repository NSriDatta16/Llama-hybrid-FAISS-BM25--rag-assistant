[site]: stackoverflow
[post_id]: 4102359
[parent_id]: 3826020
[tags]: 
If the objects being created derived from Freezable, then you can actually create them on a different thread than the UI thread - you just have to call Freeze on them while you're on the worker thread, and then you can transfer them over. However, that doesn't help you for items that don't derive from Freezable. Have you tried creating them one at a time? The following example doesn't do any useful work but it does show how the basic structure for doing a lot of work in little bits: int count = 100; Action slow = null; slow = delegate { Thread.Sleep(100); count -= 1; if (count > 0) { Dispatcher.BeginInvoke(slow, DispatcherPriority.Background); } }; Dispatcher.BeginInvoke(slow, DispatcherPriority.Background); The 'work' here is to sleep for a tenth of a second. (So if you replace that with real work that takes about as long, you'll get the same behaviour.) This does that 100 times, so that's a total of 10 seconds of 'work'. The UI remains reasonably responsive for the whole time - things like dragging the window around become a bit less smooth, but it's perfectly usable. Change both those Background priorities to Normal, and the application locks up. The key here is that we end up returning after doing each small bit of work having queued up the next bit - we end up calling Dispatcher.BeginInvoke 100 times in all instead of once. That gives the UI a chance to respond to input on a regular basis.
