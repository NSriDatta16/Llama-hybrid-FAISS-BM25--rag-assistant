[site]: stackoverflow
[post_id]: 828104
[parent_id]: 828061
[tags]: 
DRY is just as good of a principle in Haskell as it is anywhere else :) A lot of the reason behind the terseness you speak of in haskell is that many idioms are lifted out into libraries, and that often those examples you look at have been considered very carefully to make them terse :) For example, here's an alternate way to implement your digit-to-string algorithm: asInt_fold ('-':n) = negate (asInt_fold n) asInt_fold "" = error "Need some actual digits!" asInt_fold str = foldl' step 0 str where step _ x | x '9' = error "Bad character somewhere!" step sum dig = case sum * 10 + digitToInt dig of n | n error "Overflow!" n -> n A few things to note: We detect overflow when it happens, not by deciding arbitrary-ish limits on what digits we allow. This signifigantly simplifies the overflow detection logic - and makes it work on any integer type from Int8 to Integer [as long as overflow results in wraparound, doesn't occur, or results in an assertion from the addition operator itself] By using a different fold, we don't need two seperate states. No repeating ourselves, even without going out of our way to lift things out - it falls naturally out of re-stating what we're trying to say. Now, it's not always possible to just reword the algorithm and make the duplication go away, but it's always useful to take a step back and reconsider how you've been thinking about the problem :)
