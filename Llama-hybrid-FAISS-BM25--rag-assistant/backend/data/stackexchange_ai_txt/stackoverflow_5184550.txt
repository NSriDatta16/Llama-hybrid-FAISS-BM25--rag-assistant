[site]: stackoverflow
[post_id]: 5184550
[parent_id]: 5183503
[tags]: 
The question you're actually asking is, "why do C and C++ compilers use the hardware stack to store variables with auto extent?" As others have mentioned, neither the C nor C++ language definitions explicitly say that variables must be stored on a stack. They simply define the behavior of variables with different storage durations: 6.2.4 Storage durations of objects 1 An object has a storage duration that determines its lifetime. There are three storage durations: static, automatic, and allocated. Allocated storage is described in 7.20.3. 2 The lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address ,25) and retains its last-stored value throughout its lifetime. 26) If an object is referred to outside of its lifetime, the behavior is undefined. The value of a pointer becomes indeterminate when the object it points to reaches the end of its lifetime. 3 An object whose identifier is declared with external or internal linkage, or with the storage-class specifier static has static storage duration . Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup. 4 An object whose identifier is declared with no linkage and without the storage-class specifier static has automatic storage duration . 5 For such an object that does not have a variable length array type, its lifetime extends from entry into the block with which it is associated until execution of that block ends in any way. (Entering an enclosed block or calling a function suspends, but does not end, execution of the current block.) If the block is entered recursively, a new instance of the object is created each time. The initial value of the object is indeterminate. If an initialization is specified for the object, it is performed each time the declaration is reached in the execution of the block; otherwise, the value becomes indeterminate each time the declaration is reached. C language standard, draft n1256 . No doubt that paragraph 5 was written with hardware stacks in mind, but there are oddball architectures out there that don't use a hardware stack, at least not in the same way as something like x86. The hardware stack simply makes the behavior specified in paragraph 5 easy to implement.
