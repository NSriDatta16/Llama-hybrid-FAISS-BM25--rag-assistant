[site]: stackoverflow
[post_id]: 4737709
[parent_id]: 4736247
[tags]: 
Suppose you have an assignment to a member access of the form: expr.field = value; The value of a struct instance is, by definition, its value . If you are attempting to mutate the field of a struct then you must be attempting to mutate the storage location that stores the value . That is, you must be attempting to mutate the variable . The field is a variable which is a part of another variable. Therefore, if expr is a struct type then expr must be a variable . In your example, expr is not a variable. It's a property, and the result of a property access is a value , not a variable . That might not be clear. Let's try an analogy. Imagine you have a piece of paper that represents a value of a struct. The paper has a box on it labelled "c", which contains a number. When you say "b.c = 2.0;" what that does is goes and finds the storage associated with b, and makes a photocopy of the piece of paper it finds there. You then erase the number on the copy you've been handed and replace it with 2.0. Does that do what you want? Of course not. It doesn't change the value of the piece of paper stored in b at all! Value types are copied by value . Because this doesn't do what you want, it is illegal in C#. Now suppose you have a piece of paper that represents the value of a class. The paper has a box in it labelled "y" which contains a number. When you say "x.y = 2.0;" what it does is goes and finds the storage associated with x, and hands you one end of a ribbon. The other end of the ribbon is attached to the piece of paper that is the storage associated with x. You follow the ribbon, find the box labelled y at the other end, and replace the number there with 2.0. Reference types are copied by reference ; you don't get a copy of the value in the storage, you get something that lets you find the storage . That's the difference between value types and reference types; value types are copied by value, reference types are copied by reference. Is that now clear?
