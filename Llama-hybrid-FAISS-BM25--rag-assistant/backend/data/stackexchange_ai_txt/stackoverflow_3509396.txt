[site]: stackoverflow
[post_id]: 3509396
[parent_id]: 3509208
[tags]: 
This isn't too different from static function-scoped variables in C or C++. Programming language design was in its infancy, back when FORTRAN was developed. If it were being designed from scratch today, no doubt many of the design decisions would have been different. Originally, FORTRAN didn't even support recursion, there was no dynamic memory allocation, programs played all sorts of type-punning games with COMMON blocks and EQUIVALENCE statements, procedures could have multiple entry points....so the memory model was basically for the compiler/linker to lay out everything, even local variables and numeric literal constants, into fixed storage locations, rather than on the stack. If you wanted, you could even write code that changed the value of "2" to "42"! By now, there is an awful lot of legacy FORTRAN code out there, and compiler writers go to great lengths to preserve backward-compatible semantics. I can't quote chapter and verse from the standard that mandates the behavior you've noted, nor its rationale, but it seems reasonable that backward compatibility trumped modern language design sensibilities, in this instance.
