[site]: stackoverflow
[post_id]: 2487823
[parent_id]: 2487726
[tags]: 
In short, you can't [have private ivars]. An alternative is to declare a class in your implementation file that contains all the state, then treat it like a struct. .m: @interface PrivateGoo:NSObject {... ivars ...} ... props @end @implementation PrivateGoo ... @synth or not Then, in the .h, declare an ivar like id privateGoop; . If speed of lookup is a terrible concern, use ((PrivateGoo*)privateGoop)->iVar; in your .m file. Be careful about memory management if you do. Note that this has a couple of advantages, even if it is seemingly odd at first glance. Namely, it makes refactoring out PrivateGoo trivial; if your data encapsulation suddenly finds a need to have business logic or be made more universally available, doing so is trivial. With GC, the compiler will lay down the layout information for PrivateGoo and will manage all of the memory entirely automatically. Using a structure requires a slight bit of hoop jumping to make work right -- correct allocation patterns, etc. Sorry -- didn't actually answer the question. Synthesized ivars work exactly like regular ivars except that you don't have to declare 'em in the header. There isn't anything particular private about them other than that. Note that synthesized ivars are not required to avoid the fragile base class problem. The @private , @protected and @public directives exist for the benefit of the compiler; to give it a hook to warn (or error) when you access something that is declared as inaccessible. There is still OBjective-C's relatively flat namespace to content with and that is what prevents you from having an iVar of the same name in a subclass. The fragile base class problem is orthogonal to properties and synthesized ivars. Fragile base classses were addressed in the modern Objective-C 2.0 ABI on the iPhone OS and 64 bit Mac OS X. 32 bit Mac OS X preserves the legacy behavior for binary compatibility reasons.
