[site]: stackoverflow
[post_id]: 5657857
[parent_id]: 5657709
[tags]: 
and the timeout passes and the thread hasn't returned what is the state? The state of the thread at that point is indeterminate. The best you can say is that it won't be NEW, and probably won't be TERMINATED. (But even in the latter case, it could have gone into TERMINATED state between the timeout having fired and the calling code having caught the timeout exception.) About this code: if (thread.isAlive()) { thread.interrupt(); thread = null; } That is guaranteed to deliver the interrupt if the thread is still alive. (There is a small chance that you will attempt to interrupt a thread in TERMINATED state, but my reading of the javadoc for interrupt() is that that is harmless.) What happens with the interrupt is entirely up to the thread. Specifically, there is no guarantee that the thread will either see the interrupt, or do the expected thing; i.e. finish. (A well-behaved thread should check the interrupted flag regularly, and should not squash the "interrupted" exceptions on wait(...) , sleep(...) , etc.) The assignment of null to thread will have minimal effect. If the thread is still running, it / its resources won't be garbage collected anyway. If the thread is terminated, this may render the Thread object eligible for garbage collection. But that won't make much difference. When a thread goes into TERMINATED state, its stack is automatically freed, it is removed from its thread group, and its link to its Runnable is nulled. Once that has all been done, the Thread object occupies a minimal amount of memory: nothing to be concerned about from the perspective of storage leakage.
