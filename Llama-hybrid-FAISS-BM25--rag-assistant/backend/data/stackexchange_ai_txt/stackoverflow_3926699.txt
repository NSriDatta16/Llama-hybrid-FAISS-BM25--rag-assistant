[site]: stackoverflow
[post_id]: 3926699
[parent_id]: 3926642
[tags]: 
If you associate Categories with Products via a member collection, and vica versa, then you can accomplish the same thing: public class Product { private Set categories = new HashSet (); //implement hashCode and equals, potentially by id for extra performance } public class Category { private Set contents = new HashSet (); //implement hashCode and equals, potentially by id for extra performance } The only difficult part is populating such a structure, where some intermediate maps might be needed. But the approach of using auxiliary hashmaps/trees for indexing is not a bad one. After all, most indices placed on databases for example are auxiliary data structures: they coexist with the table of rows; the rows aren't necessarily organized in the structure of the index itself. Using an external structure like this empowers you to keep optimizations and data separate from each other; that's not a bad thing. Especially if tomorrow you want to add O(1) look-ups for Products given a Vendor, e.g. Edit: By the way, it looks like what you want is an implementation of a Multimap optimized to do reverse lookups in O(1) as well. I don't think Guava has something to do that, but you could implement the Multimap interface so at least you don't have to deal with maintaining the HashMaps separately. Actually it's more like a BiMap that is also a Multimap which is contradictory given their definitions. I agree with MStodd that you probably want to roll your own layer of abstraction to encapsulate the two maps.
