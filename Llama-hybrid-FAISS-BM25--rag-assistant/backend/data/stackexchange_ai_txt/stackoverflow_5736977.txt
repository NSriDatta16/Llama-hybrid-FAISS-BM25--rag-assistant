[site]: stackoverflow
[post_id]: 5736977
[parent_id]: 5736186
[tags]: 
Bold rewrite This code is not functionally identical, but... Because you want to know about distinct ftopic.id and fpost.id I'm going to be bold and suggest two INNER JOIN's instead of LEFT JOIN's. Then because the two id's are autoincrementing they will no longer repeat, so you can drop the distinct . SELECT fcat.id , fcat.title , fcat.description , count(ftopic.id) as number_topics , count(fpost.id) as number_posts FROM fcat INNER JOIN ftopic ON fcat.id = ftopic.cat_id INNER JOIN fpost ON ftopic.id = fpost.topic_id GROUP BY fcat.id ORDER BY fcat.ord LIMIT 100; It depends on your data if this is what you are looking for, but I'm guessing it will be faster. All your indexes seem to be in order though. MySQL does not use indexes for small sample sizes! Note that the explain list that MySQL only has 11 rows to consider for fcat. This is not enough for MySQL to really start worrying about indexes, so it doesn't. Because going to the index for small row-counts slows things down. MySQL is trying to speed things up so it chooses not to use the index, this confuses a lot of people because we are trained so hard on the index. Small sample sizes don't give good explains! Increase the size of the test data so MySQL has more rows to consider and you should start seeing the index being used. Common misconceptions about force index Force index does not force MySQL to use an index as such. It hints at MySQL to use a different index from the one it might naturally use and it pushes MySQL into using an index by setting a very high cost on a table scan. (In your case MySQL is not using a table scan, so force index has no effect) MySQL (same most other DBMS's on the planet) has a very strong urge to use indexes, so if it doesn't (use any) that's because using no index at all is faster. How does MySQL know which index to use One of the parameters the query optimizer uses is the stored cardinality of the indexes. Over time these values change... But studying the table takes time, so MySQL doesn't do that unless you tell it to. Another parameter that affects index selection is the predicted disk-seek-times that MySQL expects to encounter when performing the query. Tips to improve index usage ANALYZE TABLE will instruct MySQL to re-evaluate the indexes and update its key distribution (cardinality). (consider running it daily/weekly in a cron job) SHOW INDEX FROM table will display the key distribution. MyISAM tables and indexes fragment over time. Use OPTIMIZE TABLE to unfragment the tables and recreate the indexes. FORCE/USE/IGNORE INDEX limits the options MySQL's query optimizer has to perform your query. Only consider it on complex queries. Time the effect of your meddling with indexes on a regular basis . A forced index that speeds up your query today might slow it down tomorrow because the underlying data has changed.
