[site]: stackoverflow
[post_id]: 2510342
[parent_id]: 
[tags]: 
Improving Simple JavaScript Inheritance

John Resig (of jQuery fame) provides a concise implementation of Simple JavaScript Inheritance . His approach inspired my attempt to improve things even further. I've rewritten Resig's original Class.extend function to include the following advantages: Performance – less overhead during class definition, object construction, and base class method calls Flexibility – optimized for newer ECMAScript 5-compatible browsers (e.g. Chrome), but provides equivalent "shim" for older browsers (e.g. IE6) Compatibility – validates in strict mode and provides better tool compatibility (e.g. VSDoc/JSDoc comments, Visual Studio IntelliSense, etc.) Simplicity – you don't have to be a "ninja" to understand the source code (and it's even simpler if you lose the ECMAScript 5 features) Robustness – passes more "corner case" unit tests (e.g. overriding toString in IE) Because it almost seems too good to be true, I want to ensure my logic doesn't have any fundamental flaws or bugs, and see if anyone can suggest improvements or refute the code. With that, I present the classify function: function classify(base, properties) { /// Creates a type (i.e. class) that supports prototype-chaining (i.e. inheritance). /// The base class to extend. /// The properties of the class, including its constructor and members. /// The class. // quick-and-dirty method overloading properties = (typeof(base) === "object") ? base : properties || {}; base = (typeof(base) === "function") ? base : Object; var basePrototype = base.prototype; var derivedPrototype; if (Object.create) { // allow newer browsers to leverage ECMAScript 5 features var propertyNames = Object.getOwnPropertyNames(properties); var propertyDescriptors = {}; for (var i = 0, p; p = propertyNames[i]; i++) propertyDescriptors[p] = Object.getOwnPropertyDescriptor(properties, p); derivedPrototype = Object.create(basePrototype, propertyDescriptors); } else { // provide "shim" for older browsers var baseType = function() {}; baseType.prototype = basePrototype; derivedPrototype = new baseType; // add enumerable properties for (var p in properties) if (properties.hasOwnProperty(p)) derivedPrototype[p] = properties[p]; // add non-enumerable properties (see https://developer.mozilla.org/en/ECMAScript_DontEnum_attribute) if (!{ constructor: true }.propertyIsEnumerable("constructor")) for (var i = 0, a = [ "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf" ], p; p = a[i]; i++) if (properties.hasOwnProperty(p)) derivedPrototype[p] = properties[p]; } // build the class var derived = properties.hasOwnProperty("constructor") ? properties.constructor : function() { base.apply(this, arguments); }; derived.prototype = derivedPrototype; derived.prototype.constructor = derived; derived.prototype.base = derived.base = basePrototype; return derived; } And the usage is nearly identical to Resig's except for the constructor name ( constructor vs. init ) and the syntax for base class method calls. /* Example 1: Define a minimal class */ var Minimal = classify(); /* Example 2a: Define a "plain old" class (without using the classify function) */ var Class = function() { this.name = "John"; }; Class.prototype.count = function() { return this.name + ": One. Two. Three."; }; /* Example 2b: Define a derived class that extends a "plain old" base class */ var SpanishClass = classify(Class, { constructor: function() { this.name = "Juan"; }, count: function() { return this.name + ": Uno. Dos. Tres."; } }); /* Example 3: Define a Person class that extends Object by default */ var Person = classify( { constructor: function(name, isQuiet) { this.name = name; this.isQuiet = isQuiet; }, canSing: function() { return !this.isQuiet; }, sing: function() { return this.canSing() ? "Figaro!" : "Shh!"; }, toString: function() { return "Hello, " + this.name + "!"; } }); /* Example 4: Define a Ninja class that extends Person */ var Ninja = classify(Person, { constructor: function(name, skillLevel) { Ninja.base.constructor.call(this, name, true); this.skillLevel = skillLevel; }, canSing: function() { return Ninja.base.canSing.call(this) || this.skillLevel > 200; }, attack: function() { return "Chop!"; } }); /* Example 4: Define an ExtremeNinja class that extends Ninja that extends Person */ var ExtremeNinja = classify(Ninja, { attack: function() { return "Chop! Chop!"; }, backflip: function() { this.skillLevel++; return "Woosh!"; } }); var m = new Minimal(); var c = new Class(); var s = new SpanishClass(); var p = new Person("Mary", false); var n = new Ninja("John", 100); var e = new ExtremeNinja("World", 200); And here are my QUnit tests which all pass: equals(m instanceof Object && m instanceof Minimal && m.constructor === Minimal, true); equals(c instanceof Object && c instanceof Class && c.constructor === Class, true); equals(s instanceof Object && s instanceof Class && s instanceof SpanishClass && s.constructor === SpanishClass, true); equals(p instanceof Object && p instanceof Person && p.constructor === Person, true); equals(n instanceof Object && n instanceof Person && n instanceof Ninja && n.constructor === Ninja, true); equals(e instanceof Object && e instanceof Person && e instanceof Ninja && e instanceof ExtremeNinja && e.constructor === ExtremeNinja, true); equals(c.count(), "John: One. Two. Three."); equals(s.count(), "Juan: Uno. Dos. Tres."); equals(p.isQuiet, false); equals(p.canSing(), true); equals(p.sing(), "Figaro!"); equals(n.isQuiet, true); equals(n.skillLevel, 100); equals(n.canSing(), false); equals(n.sing(), "Shh!"); equals(n.attack(), "Chop!"); equals(e.isQuiet, true); equals(e.skillLevel, 200); equals(e.canSing(), false); equals(e.sing(), "Shh!"); equals(e.attack(), "Chop! Chop!"); equals(e.backflip(), "Woosh!"); equals(e.skillLevel, 201); equals(e.canSing(), true); equals(e.sing(), "Figaro!"); equals(e.toString(), "Hello, World!"); Does anyone see anything wrong with my approach vs. John Resig's original approach ? Suggestions and feedback are welcome! NOTE: The above code has been modified significantly since I initially posted this question. The above represents the latest version. To see how it has evolved, please check the revision history.
