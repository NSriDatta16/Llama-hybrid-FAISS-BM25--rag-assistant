[site]: stackoverflow
[post_id]: 1597491
[parent_id]: 1597405
[tags]: 
0 if static or global, indeterminate if storage class is auto C has always been very specific about the initial values of objects. If global or static , they will be zeroed. If auto , the value is indeterminate . This was the case in pre-C89 compilers and was so specified by K&R and in DMR's original C report. This was the case in C89, see section 6.5.7 Initialization . If an object that has automatic storage duration is not initialized explicitely, its value is indeterminate. If an object that has static storage duration is not initialized explicitely, it is initialized implicitely as if every member that has arithmetic type were assigned 0 and every member that has pointer type were assigned a null pointer constant. This was the case in C99, see section 6.7.8 Initialization . If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static storage duration is not initialized explicitly, then: — if it has pointer type, it is initialized to a null pointer; — if it has arithmetic type, it is initialized to (positive or unsigned) zero; — if it is an aggregate, every member is initialized (recursively) according to these rules; — if it is a union, the first named member is initialized (recursively) according to these rules. As to what exactly indeterminate means, I'm not sure for C89, C99 says: 3.17.2 indeterminate value either an unspecified value or a trap representation But regardless of what standards say, in real life, each stack page actually does start off as zero, but when your program looks at any auto storage class values, it sees whatever was left behind by your own program when it last used those stack addresses. If you allocate a lot of auto arrays you will see them eventually start neatly with zeroes. You might wonder, why is it this way? A different SO answer deals with that question, see: https://stackoverflow.com/a/2091505/140740
