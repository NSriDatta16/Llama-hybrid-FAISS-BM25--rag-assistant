[site]: stackoverflow
[post_id]: 2238966
[parent_id]: 
[tags]: 
Optimisation of Ruby algorithm for grouping and counting colours

I have what seems on the surface a simple problem which I wish to solve using ruby, I have a bunch of colours with associated photo id's, e.g [[1,"red"],[1,"green"],[2,"red"],[3,"yellow"],[4,"green"],[4,"red"]] and I wish to process the data so that it is in this format : 2 photos for red,green 3 photos for red 1 photo for yellow A few things to note: The photo/photos matching the most colours are first in the list, if the number of colours matched are the same (as for red and yellow above) then put the highest count first. The count for red is 3, as 2 photos have red and green, and a third has only red. I don't display a result for the colour green on its own, as all green photos are accounted for with the entry for red and green. Ultimately, I only ever need to display the top 5 results, no matter how large the dataset is. I have written an algorithm that achieves this goal (see below) but I would appreciate any guidance on how I can make it faster, and then more elegant. Speed is the primary concern, I will be operating on lots of data (orders of a million), then if possible if it could be made more elegant that would be nice - I don't think I write elegant ruby code, I have a c++ background. I am aware of embedding c and c++ code in ruby for performance gains, but I would really like to achieve this only using ruby. Thanks very much beginning = Time.now ARR = [[1,"red"],[1,"green"],[2,"red"],[3,"yellow"],[4,"red"],[4,"green"],[4,"yellow"],[5,"green"],[5,"red"],[6,"black"]] # Group the colours by their id. groups = ARR.group_by {|x| x[0]} # output for profiling. puts "After Group BY: #{Time.now - beginning} seconds." # Remove the id's, as they are no longer useful. Sort the colours alphabetically. sorted_groups = [] groups.each do |i,j| sorted_groups q[0].size } # if colour subsets are found in colour supersets, then increment the subset count to reflect this. tags_with_count.reverse.each_with_index do |object,index| tags_with_count.reverse.each_with_index do |object2,index2| if (index2
