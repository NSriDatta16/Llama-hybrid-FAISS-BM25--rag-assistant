[site]: stackoverflow
[post_id]: 1142427
[parent_id]: 1142405
[tags]: 
It's worth remembering that operator&() might be overloaded for the variable type, have some side effects and optimizing away such statement would change program behaviour. One example is a smart pointer used for controlling the non-C++ objects - _com_ptr_t . It has an overloaded _com_ptr_t::operator&() which checks whether the pointer inside already stores some non-null address. If it turns out that the stored address is non-null it means that the pointer is already attached to some object. If that happens the _com_ptr_t::operator&() disconnects the object - calls IUnknown::Release() and sets the pointer to null. The side effect here is necessary because the typical usage is this: _com_ptr_t pointer; // some other code could be here CoCreateInstance( ..., &pointer, ...);// many irrelevant parameters here CoCreateInstance() or other object retrieval code has no idea about C++ and _com_ptr_t so it simply overwrites the address passed into it. That's why the _com_ptr_t::operator&() must first release the object the pointer is attached to if any. So for _com_ptr_t this statement: &variable; will have the same effect as variable = 0; and optimizing it away would change program behaviour.
