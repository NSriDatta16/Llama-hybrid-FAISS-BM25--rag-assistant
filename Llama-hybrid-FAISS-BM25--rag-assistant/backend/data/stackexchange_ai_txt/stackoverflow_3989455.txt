[site]: stackoverflow
[post_id]: 3989455
[parent_id]: 3989264
[tags]: 
The undesirability of having having references/pointers be nullable by default. I don't think this is the main issue with nulls, the main issue with nulls is that they can mean two things: The reference/pointer is uninitialized: the problem here is the same as mutability in general. For one, it makes it more difficult to analyze your code. The variable being null actually means something: this is the case which Option types actually formalize. Languages which support Option types typically also forbid or discourage the use of uninitialized variables as well. How option types work including strategies to ease checking null cases such as pattern matching. In order to be effective, Option types need to be supported directly in the language. Otherwise it takes a lot of boiler-plate code to simulate them. Pattern-matching and type-inference are two keys language features making Option types easy to work with. For example: In F#: //first we create the option list, and then filter out all None Option types and //map all Some Option types to their values. See how type-inference shines. let optionList = [Some(1); Some(2); None; Some(3); None] optionList |> List.choose id //evaluates to [1;2;3] //here is a simple pattern-matching example //which prints "1;2;None;3;None;". //notice how value is extracted from op during the match optionList |> List.iter (function Some(value) -> printf "%i;" value | None -> printf "None;") However, in a language like Java without direct support for Option types, we'd have something like: //here we perform the same filter/map operation as in the F# example. List > optionList = Arrays.asList(new Some (1),new Some (2),new None (),new Some (3),new None ()); List filteredList = new ArrayList (); for(Option op : list) if(op instanceof Some) filteredList.add(((Some )op).getValue()); Alternative solution such as message eating nil Objective-C's "message eating nil" is not so much a solution as an attempt to lighten the head-ache of null checking. Basically, instead of throwing a runtime exception when trying to invoke a method on a null object, the expression instead evaluates to null itself. Suspending disbelief, it's as if each instance method begins with if (this == null) return null; . But then there is information loss: you don't know whether the method returned null because it is valid return value, or because the object is actually null. It's a lot like exception swallowing, and doesn't make any progress addressing the issues with null outlined before.
