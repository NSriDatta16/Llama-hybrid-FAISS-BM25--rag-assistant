[site]: stackoverflow
[post_id]: 918359
[parent_id]: 
[tags]: 
My python program executes faster than my java version of the same program. What gives?

Update: 2009-05-29 Thanks for all the suggestions and advice. I used your suggestions to make my production code execute 2.5 times faster on average than my best result a couple of days ago. In the end I was able to make the java code the fastest. Lessons: My example code below shows the insertion of primitive ints but the production code is actually storing strings (my bad). When I corrected that the python execution time went from 2.8 seconds to 9.6. So right off the bat, the java was actually faster when storing objects. But it doesn't stop there. I had been executing the java program as follows: java -Xmx1024m SpeedTest But if you set the initial heap size as follows you get a huge improvement: java -Xms1024m -Xmx1024m SpeedTest This simple change reduced the execution time by more than 50%. So the final result for my SpeedTest is python 9.6 seconds. Java 6.5 seconds. Original Question: I had the following python code: import time import sys def main(args): iterations = 10000000 counts = set() startTime = time.time(); for i in range(0, iterations): counts.add(i) totalTime = time.time() - startTime print 'total time =',totalTime print len(counts) if __name__ == "__main__": main(sys.argv) And it executed in about 3.3 seconds on my machine but I wanted to make it faster so I decided to program it in java. I assumed that because java is compiled and is generally considered to be faster than python I would see some big paybacks. Here is the java code: import java.util.*; class SpeedTest { public static void main(String[] args) { long startTime; long totalTime; int iterations = 10000000; HashSet counts = new HashSet((2*iterations), 0.75f); startTime = System.currentTimeMillis(); for(int i=0; i So this java code does basically the same thing as the python code. But it executed in 8.3 seconds instead of 3.3. I have extracted this simple example from a real-world example to simplify things. The critical element is that I have (set or hashSet) that ends up with a lot of members much like the example. Here are my questions: How come my python implementation is faster than my java implementation? Is there a better data structure to use than the hashSet (java) to hold a unique collection? What would make the python implementation faster? What would make the java implementation faster? UPDATE: Thanks to all who have contributed so far. Please allow me to add some details. I have not included my production code because it is quite complex. And would generate a lot of distraction. The case I present above is the most simplified possible. By that I mean that the java put call seems to be much slower than the python set`s add(). The java implementation of the production code is also about 2.5 - 3 times slower than the python version -- just like the above. I am not concerned about vm warmup or startup overhead. I just want to compare the code from my startTime to my totalTime. Please do not concern yourselves with other matters. I initialized the hashset with more than enough buckets so that it should never have to rehash. (I will always know ahead of time how many elements the collection will ultimately contain.) I suppose one could argue that I should have initialized it to iterations/0.75. But if you try it you will see that execution time is not significantly impacted. I set Xmx1024m for those that were curious (my machine has 4GB of ram). I am using java version: Java(TM) SE Runtime Environment (build 1.6.0_13-b03). In the production version of I am storing a string (2-15 chars) in the hashSet so I cannot use primitives, although that is an interesting case. I have run the code many, many times. I have very high confidence that the python code is between 2.5 and 3 times faster than the java code.
