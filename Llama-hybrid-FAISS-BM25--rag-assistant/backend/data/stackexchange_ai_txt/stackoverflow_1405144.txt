[site]: stackoverflow
[post_id]: 1405144
[parent_id]: 1384811
[tags]: 
C (277 characters) #define V(c)D o;for(**s-40?*r=strtod(*s,s):(++*s,M(s,r)),o=**s?strchr(t,*(*s)++)-t:0;c;)L(r,&o,s); typedef char*S;typedef double D;D strtod(),pow();S*t=")+-*/^",strchr(); L(D*v,D*p,S*s){D u,*r=&u;V(*p The first newline is required, and I've counted it as one character. This is a completely different approach from my other answer . It's more of a functional approach. Instead of tokenizing and looping through several times, this one evaluates the expression in one pass, using recursive calls for higher-precedence operators, effectively using the call stack to store state. To satisfy strager ;) , this time I've included forward declarations of strtod() , pow() , and strchr() . Taking them out would save 26 characters. The entry point is M() . The input string is the first parameter, and the output double is the second parameter. The entry point used to be E() , which returned a string, as the OP asked. But since mine was the only C implementation doing so, I decided to yank it out (peer pressure, and all). Adding it back in would add 43 characters: E(S s,S r){D v;M(&s,&v);sprintf(r,"%g",v);} Below is the code before I compressed it: double strtod(),pow(),Solve(); int OpOrder(char op){ int i=-1; while("\0)+-*/^"[++i] != op); return i/2; } double GetValue(char **s){ if(**s == '('){ ++*s; return Solve(s); } return strtod(*s, s); } double Calculate(double left, char *op, char **s){ double right; char rightOp; if(*op == 0 || *op == ')') return left; right = GetValue(s); rightOp = *(*s)++; while(OpOrder(*op) Since the OP's " reference implementation " is in C#, I wrote a semi-compressed C# version as well: D P(D o){ return o!=6?o!=7&&o!=2?o 47&s[i] []{()=>u*r,()=>u+r,()=>0,()=>u-r,()=>Math.Pow(u,r),()=>u/r}[(int)o-2](); o=p; } D M(ref S s){ for(D o,r=V(ref s,out o);o>1) L(ref r,ref o,ref s); return r; }
