[site]: stackoverflow
[post_id]: 3343829
[parent_id]: 3343766
[tags]: 
Let's take a closer look at the two of them: // a) col.addAll(Arrays.asList(1, 2, 3, 4, 5)); Here's what happens: varags + autoboxing creates Integer[] Arrays.asList creates a List backed by the array addAll iterates over a Collection using Iterator // b) Collections.addAll(col, 1, 2, 3, 4, 5); Here's what happens: varargs + autoboxing creates Integer[] addAll iterates over an array (instead of an Iterable ) We can see now that b) may be faster because: Arrays.asList call is skipped, i.e. no intermediary List is created. Since the elements are given in an array (thanks to varargs mechanism), iterating over them may be faster than using Iterator . That said, unless profiling shows otherwise, the difference isn't likely to be "significant". Do not optimize prematurely. While Java Collection Framework classes may be slower than arrays, they perform more than adequately for most applications. API links Collections.addAll(Collection c, T... elements) - varargs i.e. array-based Collection.addAll(Collection c) - Collection -based See also Java Language Guide/Autoboxing Java Language Guide/Varargs Effective Java 2nd Edition, Item 25: Prefer lists to arrays Related questions Array or List in Java. Which is faster ? Summary If you're adding elements from an array, you can use Collections.addAll(col, arr) Remember that varargs are also done using arrays If you're adding elements from a Collection , use col.addAll(otherCol) Do NOT e.g. Collections.addAll(col, otherCol.toArray()) Such roundabout way is likely to be slower! It's not that one is supremely faster than the other It's about skipping unnecessary steps given the current situation
