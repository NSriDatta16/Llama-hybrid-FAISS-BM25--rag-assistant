[site]: stackoverflow
[post_id]: 4502236
[parent_id]: 4501977
[tags]: 
Maybe the most useful function for you is: #include #include extern void error_exit(int rc, const char *format, ...); /* In a header */ void error_exit(int rc, const char *format, ...) { va_list args; va_start(args, format); vfprintf(stderr, format, args); va_end(args); exit(rc); } You can then write: if (stat(argv[2], &inode) != -1) error_exit(2, "Warning: The file %s exists. Not going to overwrite\n", argv[2]); Which has the merit of brevity. You write functions to do sub-tasks. Deciding where to break up your code into functions is tricky - as much art as science. Your code is not so big that it is completely awful to leave it as it is - one function (though the error handling can be simplified as above). If you want to practice writing functions, consider splitting it up: open_input_file() open_output_file() checked_read() checked_write() checked_close() These functions would allow your main code to be written as: int main(int argc, char **argv) { int bytes_read; int input_fd, output_fd; char buffer[64]; if (argc != 3) error_exit(1, "Usage: %s \n", argv[0]); input_fd = open_input_file(argv[1]); output_fd = open_output_file(argv[2]); while ((bytes_read = checked_read(input_fd, buffer, sizeof(buffer)) > 0) check_write(output_fd, buffer, bytes_read); checked_close(input_fd); checked_close(output_fd); return 0; } Because you've tucked the error handling out of sight, it is now much easier to see the structure of the program. If you don't have enough functions yet, you can bury the loop into a function void file_copy(int fd_in, int fd_out) . That removes more clutter from main() and leaves you with very simple code. Given an initial attempt at a function to open the output file: void outputFile(int argc, char **argv) { /* Check that the output file doesnt exist */ if (stat(argv[argc-1], &inode) != -1) { printf("Warning: The file %s already exists. Not going to overwrite\n", argv[argc-1]); return -1; } /*Opening ouput files*/ file_desc_out = open(argv[i],O_CREAT | O_WRONLY | O_EXCL , S_IRUSR|S_IWUSR); if(file_desc_out == -1) { printf("Error: %s cannot be opened. \n",argv[i]); //insted of argv[2] have pointer i. return -1; } } Critique: You have to define the variables used by the function in the function (you will want to avoid global variables as much as possible, and there is no call for any global variable in this code). You have to define the return type. You are opening a file - how is the file descriptor going to be returned to the calling code? So, the return type should be int . You pass only the information needed to the function - a simple form of 'information hiding'. In this case, you only need to pass the name of the file; the information about file modes and the like is implicit in the name of the function. In general, you have to decide how to handle errors. Unless you have directives otherwise from your homework setter, it is reasonable to exit on error with an appropriate message. If you return an error indicator, then the calling code has to test for it, and decide what to do about the error. Errors and warnings should be written to stderr , not to stdout . The main program output (if any) goes to stdout . Your code is confused about whether argv[i] or argv[argc-1] is the name of the output file. In a sense, this criticism is irrelevant once you pass just the filename to the function. However, consistency is a major virtue in programming, and using the same expression to identify the same thing is usually a good idea. Consistency of layout is also important. Don't use both if( and if ( in your programs; use the canonical if ( notation as used by the language's founding fathers, K&R. Similarly, be consistent with no spaces before commas, a space after a comma, and be consistent with spaces around operators such as ' | '. Consistency makes your code easier to read, and you'll be reading your code a lot more often than you write it (at least, once you've finished your course, you will do more reading than writing). You cannot have return -1; inside a function that returns no value. When you a splitting up code into functions, you need to copy/move the paragraphs of code that you are extracting, leaving behind a call to the new function. You also need to copy the relevant local variables from the calling function into the new function - possibly eliminating the variables in the calling function if they are no longer used there. You do compile with most warnings enabled, don't you? You want to know about unused variables etc. When you create the new function, one of the most important parts is working out what the correct signature of the function is. Does it return a value? If so, which value, and what is its type? If not, how does it handle errors? In this case, you probably want the function to bail out (terminate the program) if it runs into an error. In bigger systems, you might need to consistently return an error indicator (0 implies success, negative implies failure, different negatives indicating different errors). When you work with function that return an error indicator, it is almost always crucial that you check the error indicators in the calling code. For big programs, big swathes of the code can be all about error handling. Similarly, you need to work out which values are passed into the function. I'm omitting advice about things such as 'be const correct' as overkill for your stage in learning to program in C.
