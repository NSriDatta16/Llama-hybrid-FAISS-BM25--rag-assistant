[site]: stackoverflow
[post_id]: 971111
[parent_id]: 970862
[tags]: 
A straightforward approach is to define your regexp in terms of simple tokens. Here I've defined the contents of the string to be zero or more instances of backslash-quote or a non-quote character. examples = [ '"foo"', '"foo\"bar\""', 'empty', 'one more "time"', 'the "last" man "standing"' ] examples.each do |example| puts "%s => %s" % [ example, example.match(/\"(?:\\"|[^"])*?\"/) ] end You can see how it performs on the various examples given. As a note about your strategy for decoding log file contents, doing verification as a series of long, tedious if statements is likely to be a serious performance drag. You may want to extensively benchmark various approaches to validating the contents of specific fields. For example, it may be more efficient to store the Fixnum equivalents of all valid numbers 0.255 in a Hash than it is to run .to_i and then do comparisons between a low and high value.
