[site]: stackoverflow
[post_id]: 4137787
[parent_id]: 4137522
[tags]: 
gcc treats uninitialised globals which are not explicitly declared extern as "common" symbols (hence "COM"). Multiple definitions of the same common symbol (across multiple object files) are merged together by the linker when creating the final executable, so that they all refer to the same storage. One of the object files may initialise it to a particular value (in which case it will end up in the data section); if no object files initialise it, is will end up in the BSS; if more than one object initialises it, you'll get a linker error. In summary, if you have, say, two definitions of int a : int a; in one object and int a; in another object is OK: both refer to the same a , initialised to 0 int a; in one object and int a = 42; in another object is OK: both refer to the same a , initialised to 42 int a = 23; in one object and int a= 42; in another object will give a link error. Do note that the use of multiple definitions of the same symbol across two objects is not technically allowed by standard C; but it is supported by many compilers, including gcc, as an extension. (It's listed under "Common extensions" - no pun intended - in the C99 spec.)
