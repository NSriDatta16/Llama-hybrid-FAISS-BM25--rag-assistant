[site]: stackoverflow
[post_id]: 1210018
[parent_id]: 1140714
[tags]: 
This question has languished for long enough. I'm going to report what I ended up doing even though there's a chance I'll be derided. I had already determined that the problem was that two threads were coming to a deadlock while trying to access an iostream object in separate read and write operations. I could see that the Visual Studio implementation of string stream insertion and extraction operators both declared a Sentry, which locked the stream buffer associated with the stream being operated on. I knew that, for the stream in question for this deadlock, the stream buffer implementation was boost::asio::basic_socket_streambuf. I inspected the implementation to see that read and write operations (underflow and overflow) actually operate on different buffers (get vs. put). With the above verified, I chose to simply circumvent the locking for this application. To do that, I used project-specific pre-processor definitions to exclude the locking code in the basic_istream implementation of the locking sentry: class _Sentry_base { // stores thread lock and reference to input stream public: __CLR_OR_THIS_CALL _Sentry_base(_Myt& _Istr) : _Myistr(_Istr) { // lock the stream buffer, if there #ifndef MY_PROJECT if (_Myistr.rdbuf() != 0) _Myistr.rdbuf()->_Lock(); #endif } __CLR_OR_THIS_CALL ~_Sentry_base() { // destroy after unlocking #ifndef MY_PROJECT if (_Myistr.rdbuf() != 0) _Myistr.rdbuf()->_Unlock(); #endif } Upside: It works Only my project (with the appropriate defines) is affected Downside: Feels a little hacky Each platform where this is built will need this modification I plan to mitigate the latter point by loudly documenting this in the code and project documentation. I realize that there may be a more elegant solution to this, but in the interest of expediency I chose a direct solution after due diligence to understand the impacts.
