[site]: stackoverflow
[post_id]: 793919
[parent_id]: 793850
[tags]: 
A very interesting question. I'm not a huge TDD user, but I'll throw some thoughts out. I'll assume that the application that you want to test is this: public static void Main() { Console.WriteLine("Hello World"); } Now, since I can't think of any good way of testing this directly I'd break out the writing task into an interface. public interface IOutputWriter { void WriteLine(string line); } public class ConsoleWriter : IOutputWriter { public void WriteLine(string line) { Console.WriteLine(line); } } And break the application down like this public static void Main() { IOutputWriter consoleOut = new ConsoleWriter(); WriteHelloWorldToOutput(consoleOut); } public static void WriteHelloWorldToOutput(IOutputWriter output) { output.WriteLine("Hello World"); } Now you have an injection point to the method that allows you to use the mocking framework of your choice to assert that the WriteLine method is called with the "Hello World" parameter. Problems that I have left unsolved (and I'd be interested in input): How to test the ConsoleWriter class, I guess you still need some UI testing framework to achieve this, and if you had that then the whole problem in moot anyway... Testing the main method. Why I feel like I've achieved something by changing one line of untested code into seven lines of code, only one of which is actually tested (though I guess coverage has gone up)
