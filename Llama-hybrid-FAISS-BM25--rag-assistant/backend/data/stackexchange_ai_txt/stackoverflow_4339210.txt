[site]: stackoverflow
[post_id]: 4339210
[parent_id]: 
[tags]: 
std::cout c_str() prints nothing

in a function, that gets unsigned char && unsigned char length, void pcap_callback(u_char *args, const struct pcap_pkthdr* pkthdr, const u_char* packet) { std::vector vec(packet, packet+pkthdr->len); // optimized from foo. std::stringstream scp; for (int i=0;i len;i++) { scp str()); std::cout len); } Results: WAS: prints nothing (guess there is a pointer to const.. case) GOOD: prints data BAD: prints nothing TEST, assert: prints that mystr.size() is equal to passed unsigned char size. I tried: string.assign(scp.rdbuf()); memcpy(char, scp.str(), 10); different methods of creating/allocating temporary chars, strings No help.. it is wanted to get a std::cout 'able std::string that contains data, (which was picked from foo , which was unsigned char , which was packet data). Guessing either the original foo may not be null-terminated, or the problem is something like this - simple, but can't get in.. what are the things to look for here? (this code is another attempt to use libpcap, just to print packets in C++ way, without using known C++ magic wrappers like libpcapp).
