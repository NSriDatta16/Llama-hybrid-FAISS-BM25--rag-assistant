[site]: stackoverflow
[post_id]: 5344010
[parent_id]: 2939406
[tags]: 
You could leverage Django's built-in way to override how Authentication happens by setting AUTHENTICATION_BACKENDS in your settings.py Here's my EmailAuthBackend: #settings.py AUTHENTICATION_BACKENDS = ( 'auth_backend.auth_email_backend.EmailBackend', 'django.contrib.auth.backends.ModelBackend', ) #auth_email_backend.py from django.contrib.auth.backends import ModelBackend from django.forms.fields import email_re from django.contrib.auth.models import User class EmailBackend(ModelBackend): """ Authenticate against django.contrib.auth.models.User """ def authenticate(self, **credentials): return 'username' in credentials and \ self.authenticate_by_username_or_email(**credentials) def authenticate_by_username_or_email(self, username=None, password=None): try: user = User.objects.get(email=username) except User.DoesNotExist: try: user = User.objects.get(username=username) except User.DoesNotExist: user = None if user: return user if user.check_password(password) else None else: return None def get_user(self, user_id): try: return User.objects.get(pk=user_id) except User.DoesNotExist: return None #forms.py #replaces the normal username CharField with an EmailField from django import forms from django.contrib.auth.forms import AuthenticationForm class LoginForm(AuthenticationForm): username = forms.EmailField(max_length=75, label='Email') next = forms.CharField(widget=forms.HiddenInput) Hope that helps!
