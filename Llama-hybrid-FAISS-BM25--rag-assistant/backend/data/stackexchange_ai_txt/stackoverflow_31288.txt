[site]: stackoverflow
[post_id]: 31288
[parent_id]: 31237
[tags]: 
You're on the right track. Cocoa's collection classes — which all have mutable an immutable variants — are: NSArray: ordered, can contain an object multiple times NSDictionary: unordered, mapping from keys to values, keys are copied NSSet: unordered, can contain an object only once NSCountedSet: unordered, can contain an object multiple times The immutable variants help a lot with efficiency. The standard pattern for accessors of classes that have mutable variants is to copy rather than retain. This is codified in the @property mechanism, by using the copy attribute on the property: // Department.h @interface Department : NSObject @property (readwrite, copy) NSSet *employees; @end This means that if you pass a mutable array to something that takes an array, it will be copied, and if you pass that to something else, it will be copied again. The trick is though that "copying" an immutable object really just retains it, so you only take a hit for that first copy. You probably want to make a copy that first time anyway so you don't pass a mutable array to something else, then mutate it behind the back of whatever you passed it to. For Cocoa on Mac OS X, I'd also strongly encourage you to take a look at Core Data. It's an alternative to the "data set" pattern you might be used to from .NET/ADO/etc. With Core Data, you don't "get all customers" and then pass that collection around. Instead you query for the customers you care about, and as you traverse relationships of the objects you've queried for, other objects will be pulled in for you automatically. Core Data also gets you features like visual modeling of your entities, automatic generation of property getters & setters, fine-grained control over migration from one schema version to another, and so on.
