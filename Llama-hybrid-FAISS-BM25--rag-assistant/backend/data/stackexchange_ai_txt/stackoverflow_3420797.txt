[site]: stackoverflow
[post_id]: 3420797
[parent_id]: 3242972
[tags]: 
Unfortunately, polynomials are too wiggly, but linear functions aren't wiggly enough. I believe the correct model is several line segments, but they'll all have different slopes. Here's a hideous workaround that does what I want. (* data in format {{x,y},z} *) data = {{{1,3},9}, {{1,4},16}, {{2,4},8}, {{2,5},10}} (* find the ranges of x and y *) datax = DeleteDuplicates[Transpose[Transpose[data][[1]]][[1]]] datay = DeleteDuplicates[Transpose[Transpose[data][[1]]][[2]]] (* extract the values of y and z for each x *) datamap[t_]:=Map[{#[[1,2]], #[[2]]} &, Select[data, #[[1,1]] == t &]] (* interpolate for each value of x, create a rectangular array, and then interpolate in y *) Map[(f[#]=Interpolation[datamap[#],InterpolationOrder->1])&, datax] (* and now apply f to the expanded grid I've created *) datatab = Flatten[Table[ {{datax[[i]], datay[[j]]}, f[datax[[i]]][datay[[j]]]}, {i,1,Length[datax]}, {j,1,Length[datay]}], 1] (* now mathematica will let me interpolate *) dataint = Interpolation[datatab, InterpolationOrder->1] (* The resulting function agrees with my original*) Flatten[Table[{{x,y},dataint[x,y]},{x,1,2},{y,3,5}],1] Out[29]= {{{1, 3}, 9}, {{1, 4}, 16}, {{1, 5}, 23}, {{2, 3}, 6}, {{2, 4}, 8}, {{2, 5}, 10}} (* above contains all my original points [plus a few extra] *) (* and does a reasonable job of interpolating *) dataint[1.5,3.5] 9.75 which is the average of the four corner values: {dataint[1,3], dataint[1,4], dataint[2,3], dataint[2,4]} {9, 16, 6, 8}
