[site]: stackoverflow
[post_id]: 2170166
[parent_id]: 2168082
[tags]: 
Since the question is tagged C++, I'll contribute an answer that shows how accessing / manipulating column-major matrices can be done using Boost.Multiarray (it may be useful to others who face a similar problem). I consider Boost to be an extension to the C++ standard library. Feel free to ignore this answer if you don't like/use Boost. :-) #include #include #include // Prints the contents of a matrix to standard output template void printMatrix(const M& matrix) { int height = matrix.shape()[0]; int width = matrix.shape()[1]; for (int row=0; row Matrix; typedef boost::general_storage_order Storage; Matrix matrix( data, boost::extents[height][width], Storage(ordering, ascending) ); // Access source data as if it's row major printMatrix(matrix); std::cout matrix2(boost::extents[height][width]); std::copy(matrix.begin(), matrix.end(), matrix2.begin()); printMatrix(matrix2); } Output: 0 1 2 3 4 5 6 7 8 9 10 11 0 1 2 3 4 5 6 7 8 9 10 11 As you can see, you can leave the source data in its column-major format, and use boost::multi_array_ref with custom storage specifications to manipulate the data directly (as if it were row-major) using the matrix[row][col] notation. If the matrix is going to be traversed often in row-major fashion, then it might be better to transpose it to an actual row-major matrix, as shown in the last part of my example.
