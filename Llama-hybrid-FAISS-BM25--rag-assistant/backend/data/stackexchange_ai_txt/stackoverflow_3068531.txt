[site]: stackoverflow
[post_id]: 3068531
[parent_id]: 3067574
[tags]: 
Of course, you can't modify the original num unless you pass the pointer to it; so in the main, num first is 0, then it is 1, and it is never really modified by the func. Address of a ( &a ) in func is the address of the local copy (by value) of the argument, likely an address on the stack in most cases. And what would ret point to? You have a 3 char buffer, and you get the address beyond it; you must consider it now a pointer to garbage, even though likely your pointing to something "interesting", according to how local variables are "organized" in memory. So you can't be 100% sure it points to the return address indeed. You're assuming the following: 0 4 bytes (for char, assuming 4bytes alignment) 4 4 bytes (for whatever, maybe argument) 8 4 bytes (return address) And it depends. It depends on the architecture; it depends on how the compiler "translate" the code of the function. Let us imagine x86. The following is a reasonable way of doing func func: push ebp ; save some regs... push eax ; or with pusha? mov ebp, esp push 0 ; for char a[3] mov eax, ebp add eax, 4 ; -4 + 8 push eax ; for int *ret ; -4(ebp) gives a ; -8(ebp) gives int *ret ; so ebp-4 is the pointer to a, we ; add 8, to obtain ebp+4, which points ; to saved ebp... missing the ret ptr ; (other code...) mov esp, ebp pop eax ; or with popa? pop ebp ret and what if the saved regs are more? what if the order of char a[4] and int *ret is swapped? How do you can know? You can't assume anything, unless, you write the code yourself directly in asm, in this case you can controll exactly what's happening. Otherwise, a working C code to do what you want would work by chance...
