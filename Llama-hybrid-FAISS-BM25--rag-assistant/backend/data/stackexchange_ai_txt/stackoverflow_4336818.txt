[site]: stackoverflow
[post_id]: 4336818
[parent_id]: 4313209
[tags]: 
One method I've used is to incorporate my own simple heap routines and take over the malloc() / calloc() / free() functions from the library. The simple, custom heap routines had an interface that allowed adding blocks of memory to the heap. The drawback to this (at least in my case) was that the custom heap routines were far less sophisticated than the built-in library routines and were probably more prone to fragmentation than the built-in routines. That wasn't a serious issue in that particular application. If you want the capabilities of the built-in library routines, you could probably have your malloc() defer to the built-in heap routines until it returns a failure, then try to allocate from your custom heap. Another drawback is that I found it much more painful to make sure the custom routines were bug-free than I thought it would be at first glance, even though I wasn't trying to do anything too fancy (just a simple list of free blocks that could be split on allocation and coalesced when freed). The one benefit to this technique is that it's pretty portable (as long as your custom routines are portable) and doesn't break if the toolchain changes it's internals. The only part that requires porting is taking over the malloc() / free() interface and making sure you get initialized early enough.
