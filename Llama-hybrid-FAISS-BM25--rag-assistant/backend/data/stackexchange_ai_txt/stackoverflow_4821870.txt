[site]: stackoverflow
[post_id]: 4821870
[parent_id]: 4821710
[tags]: 
Yes, it sends notifications multiple times for some reason. To overcome this I maintained a network status variable in application delegate, which was an observer for kReachabilityChangedNotification . The view was an observer for a custom kViewReachabilityChangedNotification , which was sent by an application delegate when the value actually changed. More than that, after getting a notification from reachability I called a Reachability function on getting a current network status and changed my application delegate variable accordingly. Then I could send a notification to a view to update itself. This workaround is ugly, but works. I spent plenty of time on understanding why notifications being sent this way and finally gave up finding this solution. EDIT: Here's your sample - I still don't have a good place to put all working examples, so please try to figure out the solution from the code sample: Subclass Reachability : @interface MyReachability : Reachability { } +(BOOL) connectedToNetwork; @end @implementation MyReachability + (BOOL) connectedToNetwork { // Create zero addy struct sockaddr_in zeroAddress; bzero(&zeroAddress, sizeof(zeroAddress)); zeroAddress.sin_len = sizeof(zeroAddress); zeroAddress.sin_family = AF_INET; // Recover reachability flags SCNetworkReachabilityRef defaultRouteReachability = SCNetworkReachabilityCreateWithAddress(NULL, (struct sockaddr *)&zeroAddress); SCNetworkReachabilityFlags flags; BOOL didRetrieveFlags = SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags); CFRelease(defaultRouteReachability); if (!didRetrieveFlags) { return NO; } BOOL isReachable = flags & kSCNetworkFlagsReachable; BOOL needsConnection = flags & kSCNetworkFlagsConnectionRequired; if (needsConnection && (flags & kSCNetworkReachabilityFlagsIsWWAN)) { needsConnection = NO; } return (isReachable && !needsConnection) ? YES : NO; } @end In YourApplicationDelegate.h: @interface YourApplicationDelegate :NSObject { BOOL connectivity; } - (void) reachabilityChanged:(NSNotification *) note; - (BOOL) checkConnectivity; @end In YourApplicationDelegate.m add function initReachability call it to init your notifications from Reachability class. - (void) initReachability { MyReachability * reachability = [ MyReachability sharedReachability ]; //[ reachability setHostName: [self hostName] ]; [ reachability setNetworkStatusNotificationsEnabled: YES ]; [self siteAvailable]; NSNotificationCenter * notificationCenter = [ NSNotificationCenter defaultCenter ]; [ notificationCenter addObserver: self selector: @selector( reachabilityChanged: ) name: @"kNetworkReachabilityChangedNotification" object: nil ]; connectivity = [MyReachability testConnection:NO]; if (!connectivity) { if (![MyReachability testConnection:NO]) { [self addConnectivityView]; } } } - (BOOL) checkConnectivity { return connectivity; } - (void) reachabilityChanged:(NSNotification *) note { BOOL newConnectivity = [MyReachability testConnection:NO]; if (connectivity != newConnectivity) { connectivity = newConnectivity; [self siteAvailable]; if (![MyReachability testConnection:NO]) { [self addConnectivityView]; } else { [self removeConnectivityView]; connectivity = YES; [[NSNotificationCenter defaultCenter] postNotificationName:@"kAppNetworkReachabilityChangedNotification" object:nil]; } } } Pay attention, that @"kAppNetworkReachabilityChangedNotification" is a custom notification, that your view should subscribe to. In your view controller's viewDidLoad function: -(void) viewDidLoad { // your customization NSNotificationCenter * notificationCenter = [ NSNotificationCenter defaultCenter ]; [ notificationCenter addObserver: self selector: @selector( reachabilityChanged: ) name: @"kAppNetworkReachabilityChangedNotification" object: nil ]; } - (void) reachabilityChanged: (NSNotification *) note { BOOL connectivity = [YourAppDelegate checkConnectivity]; if (connectivity) { // update your view accordingly } }
