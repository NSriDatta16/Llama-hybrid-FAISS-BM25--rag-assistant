[site]: stackoverflow
[post_id]: 4202095
[parent_id]: 4137379
[tags]: 
Grammatical Evolution (GE) is suitable for this kind of problem, because you are searching for an answer that adheres to a certain language. Grammatical Evolution is also used for program generation, composing music, designing, etcetera. I'd approach the task like this: Structure the problem space with a grammar . Construct a Context-free Grammar that can represent all desired recurrence patterns. Consider production rules like these: datepattern -> datepattern 'and' datepattern datepattern -> frequency bounds frequency -> 'every' ordinal weekday 'of the month' frequency -> 'every' weekday ordinal -> ordinal 'and' ordinal ordinal -> 'first' | 'second' | 'third' bounds -> 'in the year' year An example of a pattern generated by these rules is: 'every second and third wednesday of the month in the year 2010 and every tuesday in the year 2011' One way to implement such a grammar would be through a class hierarchy that you will later operate on through reflection, as I've done in the example below. Map this language to a set of dates You should create a function that takes a clause from your language and recursively returns the set of all dates covered by it. This allows you to compare your answers to the input. Guided by the grammar, search for potential solutions You could use a Genetic algorithm or Simulated Annealing to match the dates to the grammar, try your luck with Dynamic Programming or start simple with a brute force enumeration of all possible clauses. Should you go with a Genetic Algorithm, your mutation concept should consist of substituting an expression for another one based on the application of one of your production rules. Have a look at the following GE-related sites for code and information: http://www.bangor.ac.uk/~eep201/jge/ http://nohejl.name/age/ http://www.geneticprogramming.us/Home_Page.html Evaluate each solution The fitness function could take into account the textual length of the solution, the number of dates generated more than once, the number of dates missed, as well as the number of wrong dates generated. Example code By request, and because it's such an interesting challenge, I've written a rudimentary implementation of the algorithm to get you started. Although it works it is by no means finished, the design should definitively get some more thought, and once you have gleaned the fundamental take-aways from this example I recommend you consider using one the libraries I've mentioned above. /// /// This is a very basic example implementation of a grammatical evolution algorithm for formulating a recurrence pattern in a set of dates. /// It needs significant extensions and optimizations to be useful in a production setting. /// static class Program { #region "Class hierarchy that codifies the grammar" class DatePattern { public Frequency frequency; public Bounds bounds; public override string ToString() { return "" + frequency + " " + bounds; } public IEnumerable Dates() { return frequency == null ? new DateTime[] { } : frequency.FilterDates(bounds.GetDates()); } } abstract class Bounds { public abstract IEnumerable GetDates(); } class YearBounds : Bounds { /* in the year .. */ public int year; public override string ToString() { return "in the year " + year; } public override IEnumerable GetDates() { var firstDayOfYear = new DateTime(year, 1, 1); return Enumerable.Range(0, new DateTime(year, 12, 31).DayOfYear) .Select(dayOfYear => firstDayOfYear.AddDays(dayOfYear)); } } abstract class Frequency { public abstract IEnumerable FilterDates(IEnumerable Dates); } class WeeklyFrequency : Frequency { /* every .. */ public DayOfWeek dayOfWeek; public override string ToString() { return "every " + dayOfWeek; } public override IEnumerable FilterDates(IEnumerable Dates) { return Dates.Where(date => (date.DayOfWeek == dayOfWeek)); } } class MonthlyFrequency : Frequency { /* every .. */ public Ordinal ordinal; public DayOfWeek dayOfWeek; /* .. of the month */ public override string ToString() { return "every " + ordinal + " " + dayOfWeek + " of the month"; } public override IEnumerable FilterDates(IEnumerable Dates) { return Dates.Where(date => (date.DayOfWeek == dayOfWeek) && (int)ordinal == (date.Day - 1) / 7); } } enum Ordinal { First, Second, Third, Fourth, Fifth } #endregion static Random random = new Random(); const double MUTATION_RATE = 0.3; static Dictionary subtypes = new Dictionary (); static void Main() { // The input signifies the recurrence 'every first thursday of the month in 2010': var input = new DateTime[] {new DateTime(2010,12,2), new DateTime(2010,11,4),new DateTime(2010,10,7),new DateTime(2010,9,2), new DateTime(2010,8,5),new DateTime(2010,7,1),new DateTime(2010,6,3),new DateTime(2010,5,6), new DateTime(2010,4,1),new DateTime(2010,3,4),new DateTime(2010,2,4),new DateTime(2010,1,7) }; for (int cTests = 0; cTests (population)); } } private static void Run(DateTime[] input, List population) { var strongest = population[0]; int strongestFitness = int.MinValue; int bestTry = int.MaxValue; for (int cGenerations = 0; cGenerations new { Fitness = Fitness(input, individual), individual }) .OrderByDescending(pair => pair.Fitness) .Take(5) .Select(pair => pair.individual) .ToArray(); population.Clear(); // The survivers are the foundation for the next generation: foreach (var parent in survivers) { for (int cChildren = 0; cChildren strongestFitness) { bestTry = cGenerations; strongestFitness = childFitness; strongest = child; } } } } Trace.WriteLine("Found best match with fitness " + Fitness(input, strongest) + " after " + bestTry + " generations: " + strongest); } private static object Mutate(object original, ref int treeSize) { treeSize = 0; object replacement = Construct(original.GetType()); foreach (var field in original.GetType().GetFields()) { object newFieldValue = field.GetValue(original); int subtreeSize; if (field.FieldType.IsEnum) { subtreeSize = 1; if (random.NextDouble() d.Ticks / (24.0 * 60 * 60 * 10000000)) - input.Average(d => d.Ticks / (24.0 * 60 * 60 * 10000000)))); return -individual.ToString().Length // succinct patterns are preferred. - input.Except(output).Count() * 300 // Forgetting some of the dates is bad. - output.Except(input).Count() * 3000 // Spurious dates cause even more confusion to the user. - (int)(avgDateDiff) * 30000; // The difference in average date is the most important guide. } private static Type[] GetConcreteSubtypes(Type supertype) { if (subtypes.ContainsKey(supertype)) { return subtypes[supertype]; } else { var types = AppDomain.CurrentDomain.GetAssemblies().ToList() .SelectMany(s => s.GetTypes()) .Where(p => supertype.IsAssignableFrom(p) && !p.IsAbstract).ToArray(); subtypes.Add(supertype, types); return types; } } } Hope this gets you on track. Be sure to share your actual solution somewhere; I think it will be quite useful in lots of scenarios.
