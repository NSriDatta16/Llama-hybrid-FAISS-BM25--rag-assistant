[site]: stackoverflow
[post_id]: 2123649
[parent_id]: 2123599
[tags]: 
I'm not an MSTest user, but you probably have a few options. Normally with NUnit I'd use a generic or parametrised fixture, but I'm not sure whether MSTest has similar capabilities. In light of this, here's how I'd do this with NUnit, in a form that should be reproducible using any unit test framework via the template method pattern . Steps: Define an abstract base class with all of the tests in it Put in an abstract method called CreateStorageManager() that returns an IStorageManager (or whatever interface the two dependencies implement) Subclass the fixture twice and provide an implementation of CreateStorageManager() that returns the concrete type you wish to use to run the tests. Here's the code for the equivalent NUnit version; I'm sure you can extrapolate. Note: The inheritance rules for MSTest may differ slightly from what I'm used to. If it doesn't work, you could try marking the base class as a test fixture. public abstract class PasswordManagerFixtureBase { protected abstract IStorageManager CreateStorageManager(); // all tests go in this fixture [Test] public void SomeTestOrOther() { var passwordManager = CreatePasswordManager(); // do test logic } private PasswordManager CreatePasswordManager() { // calls into subclass implementation to get instance of storage IStorageManager storage = CreateStorageManager(); return new PasswordManager(storage); } } // Runs the tests in the fixture base using XmlStorageManager [TestFixture] public class PasswordManager_XMLStorageManagerImplTests { protected override IStorageManager CreateStorageManager() { return new XMLStorageManager(); } } // Runs the tests in the fixture base using DbStorageManager [TestFixture] public class PasswordManager_DbStorageManagerImplTests { protected override IStorageManager CreateStorageManager() { return new DbStorageManager(); } } There may be a more elegant way to do this with MSTest, but this should work.
