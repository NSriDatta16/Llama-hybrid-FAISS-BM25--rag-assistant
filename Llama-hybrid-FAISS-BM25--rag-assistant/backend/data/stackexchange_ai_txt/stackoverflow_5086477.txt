[site]: stackoverflow
[post_id]: 5086477
[parent_id]: 5035229
[tags]: 
Some thoughts on the first part of your question: So my question is, how random are these numbers returned by realrandom really? Your function is attempting to discover the address of a table by using a quirk of its default implementation of tostring() . I don't believe that the string returned by tostring{} has a specified format, or that the value included in that string has any documented meaning. In practice, it is derived from the address of something related to the specific table, and so distinct tables convert to distinct strings. However, the next version of Lua is free to change that to anything that is convenient. Worse, the format it takes will be highly platform dependent because it appears to use the %p format specifier to sprintf() which is only specified as being a sensible representation of a pointer. There's also a much bigger issue. While the address of the nth table created in a process might seem random on your platform, tt might not be random at all. Or it might vary in only a few bits. For example, on my win7 box only a few bits vary, and not very randomly: C:...>for /L %i in (1,1,20) do @ lua -e "print{}" table: 0042E5D8 table: 0061E5D8 table: 0024E5D8 table: 0049E5D8 table: 0042E5D8 table: 0042E5D8 table: 0042E5D8 table: 0064E5D8 table: 0042E5D8 table: 002FE5D8 table: 0042E5D8 table: 0049E5D8 table: 0042E5D8 table: 0042E5D8 table: 0042E5D8 table: 0024E5D8 table: 0042E5D8 table: 0042E5D8 table: 0061E5D8 table: 0042E5D8 Other platforms will vary, of course. I'd even expect there to be platforms where the address of the first allocated table is completely deterministic, and hence identical on every run of the program. In short, the address of an arbitrary object in your process image is not a very good source of randomness. Edit: For completeness, I'd like to add a couple of other thoughts that came to mind over night. The stock tostring() function is supplied by the base library and implemented by the function luaB_tostring() . The relevant bit is this fragment: switch (lua_type(L, 1)) { ... default: lua_pushfstring(L, "%s: %p", luaL_typename(L, 1), lua_topointer(L, 1)); break; If you really are calling this function, then the end of the string will be an address, represented by standard C sprintf() format %p , strongly related to the specific table. One observation is that I've seen several distinct implementations for %p . Windows MSVCR80.DLL (the version of the C library used by the current release of Lua for Windows) makes it equivalent to %08X . My Ubuntu Karmic Koala box appears to make it equivalent to %#x which notably drops leading zeros. If you are going to parse out that part of the string, then you should do it in a way that is more flexible in the face of variation of the meaning of %p . Note, also, that doing anything like this in library code may expose you to a couple of surprises. First, if the table passed to tostring() has a metatable that provides the function __tostring() , then that function will be called, and the fragment quoted above will never be executed at all. In your case, that issue cannot arise because tables have individual metatables, and you didn't accidentally apply a metatable to your local table. Second, by the time your module loads, some other module or user-supplied code might have replaced the stock tostring() with something else. If the replacement is benign, (such as a memoization wrapper) then it likely doesn't matter to the code as written. However, this would be a source of attack, and is entirely outside the control of your module. That doesn't strike me as a good idea if the goal is some kind of improved security for your random seed material. Third, you might not be loaded in a stock Lua interpreter at all, and the larger application (Lightroom, WoW, Wireshark, ...) may choose to replace the base library functions with their own implementations. This is a much less likely issue for tostring() , but note that the base library's print() is a frequent target for replacement or removal in alternate implementations and there are modules ( Lua Lanes , for one) that break if print is not the implementation in the base library.
