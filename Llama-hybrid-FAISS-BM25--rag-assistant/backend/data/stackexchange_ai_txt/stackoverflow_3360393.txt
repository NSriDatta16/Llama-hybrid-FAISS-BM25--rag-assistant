[site]: stackoverflow
[post_id]: 3360393
[parent_id]: 3359795
[tags]: 
There are several ways to resolve this, specifically without mutexes or locking mechanisms. The problem is that I'm not sure what the constraints on your system is. Remember that atomic operations is something that often get moved around by the compilers in C++. Generally I would solve the issue like this: Multiple-producer-single-consumer by having 1 single-producer-single-consumer per writing thread. Each thread writes into their own queue. A single consumer thread that gathers the produced data and stores it in a single-consumer-multiple-reader data storage. The implementation for this is a lot of work and only recommended if you are doing a time-critical application and that you have the time to put in for this solution. There are more things to read up about this, since the implementation is platform specific: Atomic etc operations on windows/xbox360: http://msdn.microsoft.com/en-us/library/ee418650(VS.85).aspx The multithreaded single-producer-single-consumer without locks: http://www.codeproject.com/KB/threads/LockFree.aspx#heading0005 What "volatile" really is and can be used for: http://www.drdobbs.com/cpp/212701484 Herb Sutter has written a good article that reminds you of the dangers of writing this kind of code: http://www.drdobbs.com/cpp/210600279;jsessionid=ZSUN3G3VXJM0BQE1GHRSKHWATMY32JVN?pgno=2
