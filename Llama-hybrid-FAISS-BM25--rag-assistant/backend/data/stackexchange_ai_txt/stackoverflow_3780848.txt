[site]: stackoverflow
[post_id]: 3780848
[parent_id]: 3777874
[tags]: 
Rom, you're doing it wrong. You don't want to write files to disk so that IIS can serve them up. That adds security implications as well as increases complexity. All you really need to do is save the CSV directly to the response stream. Here's the scenario: User wishes to download csv. User submits a form with details about the csv they want. You prepare the csv, then provide the user a URL to an aspx page which can be used to construct the csv file and write it to the response stream. The user clicks the link. The aspx page is blank; in the page codebehind you simply write the csv to the response stream and end it. You can add the following to the (I believe this is correct) Load event: string attachment = "attachment; filename=MyCsvLol.csv"; HttpContext.Current.Response.Clear(); HttpContext.Current.Response.ClearHeaders(); HttpContext.Current.Response.ClearContent(); HttpContext.Current.Response.AddHeader("content-disposition", attachment); HttpContext.Current.Response.ContentType = "text/csv"; HttpContext.Current.Response.AddHeader("Pragma", "public"); var sb = new StringBuilder(); foreach(var line in DataToExportToCSV) sb.AppendLine(TransformDataLineIntoCsv(line)); HttpContext.Current.Response.Write(sb.ToString()); writing to the response stream code ganked from here .
