[site]: stackoverflow
[post_id]: 3955183
[parent_id]: 
[tags]: 
Maintain frame of UIView after UIGestures

I'm working on an iPad app that will use UIGestureRecognizers to allow the user to pan, scale and rotate objects (subclass of UIView) on the screen. I understand that the [UIView frame] property isn't valid after a transform is done, so I'm trying to take the values of my UIGestureRecognizers and keep the "frame" myself. Here's the code I'm using to attempt this (you may recognize a lot of code from Apple's sample project, SimpleGestureRecognizers): // Shape.h (partial) @interface Shape : UIView { CGFloat centerX; CGFloat centerY; CGFloat rotatation; CGFloat xScale; CGFloat yScale; } // Shape.m (partial) - (void)panPiece:(UIPanGestureRecognizer *)gestureRecognizer { UIView *piece = [gestureRecognizer view]; [self adjustAnchorPointForGestureRecognizer:gestureRecognizer]; if ([gestureRecognizer state] == UIGestureRecognizerStateBegan || [gestureRecognizer state] == UIGestureRecognizerStateChanged) { CGPoint translation = [gestureRecognizer translationInView:[piece superview]]; self.centerX += translation.x; self.centerY += translation.y; [piece setCenter:CGPointMake([piece center].x + translation.x, [piece center].y + translation.y)]; for ( HandleView *h in [self handles] ) { [h setCenter:CGPointMake([h center].x + translation.x, [h center].y + translation.y)]; [h setNeedsDisplay]; } [gestureRecognizer setTranslation:CGPointZero inView:[piece superview]]; NSLog(@"(%.0f, %.0f, %.0f, %.0f) %.2f˚, (%.2fx, %.2fx)", [self frame].origin.x, [self frame].origin.y, [self frame].size.width, [self frame].size.height, [self rotation], [self xScale], [self yScale]); } } // rotate the piece by the current rotation // reset the gesture recognizer's rotation to 0 after applying so the next callback is a delta from the current rotation - (void)rotatePiece:(UIRotationGestureRecognizer *)gestureRecognizer { [self adjustAnchorPointForGestureRecognizer:gestureRecognizer]; if ([gestureRecognizer state] == UIGestureRecognizerStateBegan || [gestureRecognizer state] == UIGestureRecognizerStateChanged) { CGFloat rot = [self normalizeRotation:[gestureRecognizer rotation]]; self.rotation += rot * 180.0 / M_PI; NSLog(@"Rotation: %.12f", [gestureRecognizer rotation]); [gestureRecognizer view].transform = CGAffineTransformRotate([[gestureRecognizer view] transform], [gestureRecognizer rotation]); [gestureRecognizer setRotation:0]; NSLog(@"(%.0f, %.0f, %.0f, %.0f) %.2f˚, (%.2fx, %.2fx)", [self frame].origin.x, [self frame].origin.y, [self frame].size.width, [self frame].size.height, [self rotation], [self xScale], [self yScale]); } } // scale the piece by the current scale // reset the gesture recognizer's rotation to 0 after applying so the next callback is a delta from the current scale - (void)scalePiece:(UIPinchGestureRecognizer *)gestureRecognizer { [self adjustAnchorPointForGestureRecognizer:gestureRecognizer]; if ([gestureRecognizer state] == UIGestureRecognizerStateBegan || [gestureRecognizer state] == UIGestureRecognizerStateChanged) { self.xScale *= [gestureRecognizer scale]; self.yScale *= [gestureRecognizer scale]; [gestureRecognizer view].transform = CGAffineTransformScale([[gestureRecognizer view] transform], [gestureRecognizer scale], [gestureRecognizer scale]); [gestureRecognizer setScale:1]; NSLog(@"(%.0f, %.0f, %.0f, %.0f) %.2f˚, (%.2fx, %.2fx)", [self frame].origin.x, [self frame].origin.y, [self frame].size.width, [self frame].size.height, [self rotation], [self xScale], [self yScale]); } } Because of some weirdness I noticed with the rotations, I implemented the following method to help keep an accurate rotation value: - (CGFloat) normalizeRotation:(CGFloat)rot { if (abs(rot) > 0.05) { if (rot > 0) { rot -= M_PI; } else { rot += M_PI; } return [self normalizeRotation:rot]; } else { return rot; } } Anyway, the shape on-screen pans, scales and rotates fine. All is as you would expect and the performance is good. The problem is that, after a user moves, resizes and rotates a UIView, I want to let them tap it and give them "handles" that allow for resizing other than the "square" resizing that pinching gives (i.e., when you use the pinch gesture, you upsize or downsize in the same ratio for both x and y). Now, even with the code above, the values that are stored aren't ever quite accurate. The "handles" I'm using are simply 10x10 dots that are supposed to go at each corner and halfway down each "side" of the UIView's frame/rectangle. When I first place a square and tap it to get the handles before doing anything else, the handles appear in the appropriate place. When I move, resize and rotate an object, then tap it, the handles are all shifted off of the shape some amount. It generally seems to be about 20 pixels. Are the values in the UIGestureRecognizer objects just not accurate enough? That doesn't seem to be the case, because those values are used to change the object on-screen, and that is accurate. I'm pretty sure there's no way for me to get a real representation of the UIView's frame after messing with it so much, but where's the flaw in my custom code that's giving me bad values? Am I losing precision when converting between degrees and radians? On a related note: Apple obviously has internal code that keeps track of how to draw a view that's been translated/transformed. The box of solid color that I'm currently using is moved, zoomed and rotated correctly. So, is there any way to access the values that they use for displayed a translated/transformed UIView? Thanks!
