[site]: crossvalidated
[post_id]: 35726
[parent_id]: 34924
[tags]: 
Correctly tuning C and sigma is of course essential to getting good forecasts. It looks like what the authors of the second paper are doing is a time-series cross-validation , where they are selecting C and sigma using a training set at each cross-validation step. I've written some R code for cross-validating generic time-series forecasting functions , which might help solve this problem. Lets try to replicate the plain SVR method of Wang,L., Zhu, J. (2010) . First we load the data and build the moving averages referenced in the paper: set.seed(60444) library(quantmod) library(caret) library(forecast) library(foreach) source('https://raw.github.com/zachmayer/cv.ts/master/R/cv.ts.R') #Load data getSymbols('SPY', from='1900-01-01') SPY Note that we've loaded the cv.ts function from my github repository. Next we define the SVR forecast function, following the method described in the paper of fitting the SVM to 150 observations, tuning the kernel parameters on the next 10 observations, and then re-fitting the SVM to observations 11:160: #Define forecasting function #Modeled after https://raw.github.com/zachmayer/cv.ts/master/R/forecast%20functions.R forecastSVM Next we define the cross-validation parametersm using the tseriesControl function from the github repo: cvParameters We require 160 observations to fit the model at each step (150 for training, 10 for tuning the kernel), and after forecasting at each point in time we forecast out 10 periods (maxHorizon) and then step forward 10 periods to the next forecasting point. After defining the prediction function and the cross validation method we wish to use, it's easy to run the cross validation: model The cv.ts function makes use of the foreach package, so you can register a parallel backend if you wish, to speed up the cross-validation. The cross-validation function outputs a matrix where the rows are the points in time at which the model was fit, and the columns are the 1-10 day forecasts from that point in time: #Construct equity curves A As you can see from the table and the equity curve, the SVR strategy I've defined is terrible. Buy.and.Hold SVR annual return 0.006768856 -0.005348179 annual sharpe 0.141642865 -0.111909928 downside deviation 0.002143119 0.002193550 max drawdown 0.161992521 0.196183743 I can see 2 possible reasons why this may be: I haven't defined the input features correctly. I had a bit of trouble understanding this part of the paper (bottom of page 109, top of page 110), so I probably did it wrong. I'm tuning the SVM parameters using a heuristic for choosing gamma and a grid search for choosing cost. This could probably be improved to more closely match the results in the paper. At the least, I could change this to use a grid search for both parameters.
