[site]: stackoverflow
[post_id]: 2656716
[parent_id]: 2656642
[tags]: 
For starters you could compare byte-by-byte (or word-by-word), and when you find a difference search within that byte (or word) for the first bit of difference. It seems vaguely implausible to me that adding a node to an array of buckets will be so fast that it matters whether you do clever bit-twiddling to find the first bit of difference within a byte (or word), or just churn in a loop up to CHAR_BIT (or something). Possible, though. Also, if IDs are essentially random with uniform distribution, then you will find a difference in the first 8 bits about 255/256 of the time. If all you care about is average-case behaviour, not worst-case, then just do the stupid thing: it's very unlikely that your loop will run for long. For reference, though, the first bit of difference between numbers x and y is the first bit set in x ^ y . If you were programming in GNU C, __builtin_clz might be your friend. Or possibly __builtin_ctz , I'm kind of sleepy... Your code looks like Java, though, so I guess the bitfoo you're looking for is integer log .
