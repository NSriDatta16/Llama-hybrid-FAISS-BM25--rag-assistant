[site]: stackoverflow
[post_id]: 994135
[parent_id]: 
[tags]: 
Image from HttpHandler won't cache in browser

I'm serving up an image from a database using an IHttpHandler. The relevant code is here: public void ProcessRequest(HttpContext context) { context.Response.ContentType = "image/jpeg"; int imageID; if (int.TryParse(context.Request.QueryString["id"], out imageID)) { var photo = new CoasterPhoto(imageID); if (photo.CoasterPhotoID == 0) context.Response.StatusCode = 404; else { byte[] imageData = GetImageData(photo); context.Response.OutputStream.Write(imageData, 0, imageData.Length); context.Response.Cache.SetCacheability(HttpCacheability.Public); context.Response.Cache.SetExpires(DateTime.Now.AddMinutes(5)); context.Response.Cache.SetLastModified(photo.SubmitDate); } } else context.Response.StatusCode = 404; } The problem is that the browser won't cache the image, presumably because I'm not indicating the right thing in the response headers. The part calling methods on the HttpCachePolicy property is what I thought would force the browser to hold on to the image, but it doesn't. I think the "right" thing is for the handler to return a 304 status code without an image, right? How do I achieve that using IHttpHandler? EDIT: Per the best answer, I got this code running and it completely solves the problem. Yes, it needs some refactoring, but it generally demonstrates what I was after. The relevant parts: if (!String.IsNullOrEmpty(context.Request.Headers["If-Modified-Since"])) { CultureInfo provider = CultureInfo.InvariantCulture; var lastMod = DateTime.ParseExact(context.Request.Headers["If-Modified-Since"], "r", provider).ToLocalTime(); if (lastMod == photo.SubmitDate) { context.Response.StatusCode = 304; context.Response.StatusDescription = "Not Modified"; return; } } byte[] imageData = GetImageData(photo); context.Response.OutputStream.Write(imageData, 0, imageData.Length); context.Response.Cache.SetCacheability(HttpCacheability.Public); context.Response.Cache.SetLastModified(photo.SubmitDate);
