[site]: stackoverflow
[post_id]: 2564090
[parent_id]: 
[tags]: 
how to Compute the average probe length for success and failure - Linear probe (Hash Tables)

I'm doing an assignment for my Data Structures class. we were asked to to study linear probing with load factors of .1, .2 , .3, ...., and .9. The formula for testing is: The average probe length using linear probing is roughly Success--> ( 1 + 1/(1-L)**2)/2 or Failure--> (1+1(1-L))/2. we are required to find the theoretical using the formula above which I did(just plug the load factor in the formula), then we have to calculate the empirical (which I not quite sure how to do). here is the rest of the requirements **For each load factor, 10,000 randomly generated positive ints between 1 and 50000 (inclusive) will be inserted into a table of the "right" size, where "right" is strictly based upon the load factor you are testing. Repeats are allowed. Be sure that your formula for randomly generated ints is correct. There is a class called Random in java.util. USE it! After a table of the right (based upon L) size is loaded with 10,000 ints, do 100 searches of newly generated random ints from the range of 1 to 50000. Compute the average probe length for each of the two formulas and indicate the denominators used in each calculationSo, for example, each test for a .5 load would have a table of > > size approximately 20,000 (adjusted to be prime) and similarly each test for a .9 load would have a table of approximate size 10,000/.9 (again adjusted to be prime). The program should run displaying the various load factors tested, the average probe for each search (the two denominators used to compute the averages will add to 100), and the theoretical answers using the formula above. .** how do I calculate the empirical success? here is my code so far: import java.util.Random; /** * * @author Johnny */ class DataItem { private int iData; public DataItem(int it) {iData = it;} public int getKey() { return iData; } } class HashTable { private DataItem[] hashArray; private int arraySize; public HashTable(int size) { arraySize = size; hashArray = new DataItem[arraySize]; } public void displayTable() { int sp=0; System.out.print("Table: "); for(int j=0; j 50){System.out.println("");sp=0;} if(hashArray[j] != null){ System.out.print(hashArray[j].getKey() + " ");sp++;} else {System.out.print("** "); sp++;} } System.out.println(""); } public int hashFunc(int key) { return key %arraySize; } public void insert(DataItem item) { int key = item.getKey(); int hashVal = hashFunc(key); while(hashArray[hashVal] != null && hashArray[hashVal].getKey() != -1) { ++hashVal; hashVal %= arraySize; } hashArray[hashVal]=item; } public int hashFunc1(int key) { return key % arraySize; } public int hashFunc2(int key) { // non-zero, less than array size, different from hF1 // array size must be relatively prime to 5, 4, 3, and 2 return 5 - key % 5; } public DataItem find(int key) // find item with key // (assumes table not full) { int hashVal = hashFunc1(key); // hash the key int stepSize = hashFunc2(key); // get step size while(hashArray[hashVal] != null) // until empty cell, { // is correct hashVal? if(hashArray[hashVal].getKey() == key) return hashArray[hashVal]; // yes, return item hashVal += stepSize; // add the step hashVal %= arraySize; // for wraparound } return null; // canâ€™t find item } } public class n00645805 { /** * @param args the command line arguments */ public static void main(String[] args) { double b=1; double L; double[] tf = new double[9]; double[] ts = new double[9]; double d=0.1; DataItem aDataItem; int aKey; HashTable h1Table = new HashTable(100003); //L=.1 HashTable h2Table = new HashTable(50051); //L=.2 HashTable h3Table = new HashTable(33343); //L=.3 HashTable h4Table = new HashTable(25013); //L=.4 HashTable h5Table = new HashTable(20011); //L=.5 HashTable h6Table = new HashTable(16673); //L=.6 HashTable h7Table = new HashTable(14243); //L=.7 HashTable h8Table = new HashTable(12503); //L=.8 HashTable h9Table = new HashTable(11113); //L=.9 fillht(h1Table); fillht(h2Table); fillht(h3Table); fillht(h4Table); fillht(h5Table); fillht(h6Table); fillht(h7Table); fillht(h8Table); fillht(h9Table); pm(h1Table); pm(h2Table); pm(h3Table); pm(h4Table); pm(h5Table); pm(h6Table); pm(h7Table); pm(h8Table); pm(h9Table); for (int j=1;j }
