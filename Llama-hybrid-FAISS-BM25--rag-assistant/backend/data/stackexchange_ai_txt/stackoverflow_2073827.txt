[site]: stackoverflow
[post_id]: 2073827
[parent_id]: 2073079
[tags]: 
Getting on the language side of this, since the assembler side has already been handled: Note this sentence: " an expression of the form a[i] causes the array to decay into a pointer, following the rule above, and then to be subscripted just as would be a pointer variable in the expression p[i] (although the eventual memory accesses will be different, " I'm pretty confused of this: since a has decayed to pointer, then why does he mean about "memory accesses will be different? This is because after decaying, access is equal for the (now a pointer value) and the pointer. But the difference is how that pointer value is got in the first place. Let's look at an example: char c[1]; char cc; char *pc = &cc; Now, you have an array. This array does not take any storage other than one char! There is no pointer stored for it. And you have a pointer that points to a char. The pointer takes the size of one address, and you have one char that the pointer points to. Now let's look what happens for the array case to get the the pointer value: c[0] = 'A'; // #1: equivalent: *(c + 0) = 'A'; // #2: => 'c' appears not in address-of or sizeof // #3: => get address of "c": This is the pointer value P1 The pointer case is different: pc[0] = 'A'; // #1: equivalent: *(pc + 0) = 'A'; // #2: => pointer value is stored in 'pc' // #3: => thus: read address stored in 'pc': This is the pointer value P1 As you see, for the array case for getting the pointer value needed where we add the index value to (in this case a boring 0 ), we don't need to read from memory, because the address of the array is already the pointer value needed. But for the pointer case, the pointer value we need is stored in the pointer: We need one read from memory to get that address. After this, the path is equal for both: // #4: add "0 * sizeof(char)" to P1. This is the address P2 // #5: store 'A' to address P2 Here is the assembler code generated for the array and the pointer case: add $2, $0, 65 ; write 65 into r2 stb $2, $0, c ; store r2 into address of c # pointer case follows ldw $3, $0, pc ; load value stored in pc into r3 add $2, $0, 65 ; write 65 into r2 stb $2, $3, 0 ; store r2 into address loaded to r3 We can just store 65 (ASCII for 'A' ) at the address of c (which will be known already at compile or link time when it is global). For the pointer case, we will first have to load the address stored by it into register 3 , and then write the 65 to that address.
