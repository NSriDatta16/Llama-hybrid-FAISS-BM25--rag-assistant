[site]: stackoverflow
[post_id]: 2867832
[parent_id]: 2867758
[tags]: 
As per your update2 you are correct on Guids are predicable even the msdn references that. here is a method that uses a crptographicly strong random number generator to create the ID. static long counter; //store and load the counter from persistent storage every time the program loads or closes. public static string CreateRandomString(int length) { long count = System.Threading.Interlocked.Increment(ref counter); int PasswordLength = length; String _allowedChars = "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ23456789"; Byte[] randomBytes = new Byte[PasswordLength]; RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider(); rng.GetBytes(randomBytes); char[] chars = new char[PasswordLength]; int allowedCharCount = _allowedChars.Length; for (int i = 0; i byte.MaxValue - (byte.MaxValue % allowedCharCount)) { byte[] tmp = new byte[1]; rng.GetBytes(tmp); randomBytes[i] = tmp[0]; } chars[i] = _allowedChars[(int)randomBytes[i] % allowedCharCount]; } byte[] buf = new byte[8]; buf[0] = (byte) count; buf[1] = (byte) (count >> 8); buf[2] = (byte) (count >> 16); buf[3] = (byte) (count >> 24); buf[4] = (byte) (count >> 32); buf[5] = (byte) (count >> 40); buf[6] = (byte) (count >> 48); buf[7] = (byte) (count >> 56); return Convert.ToBase64String(buf) + new string(chars); } EDIT I know there is some biasing because allowedCharCount is not evenly divisible by 255, you can get rid of the bias throwing away and getting a new random number if it lands in the no-mans-land of the remainder. EDIT2 - This is not guaranteed to be unique, you could hold a static 64 bit(or higher if necessary) monotonic counter encode it to base46 and have that be the first 4-5 characters of the id. UPDATE - Now guaranteed to be unique UPDATE 2: Algorithm is now slower but removed biasing. EDIT: I just ran a test, I wanted to let you know that ToBase64String can return non alphnumeric charaters (like 1 encodes to "AQAAAAAAAAA=" ) just so you are aware. New Version: Taking from Matt Dotson's answer on this page, if you are no so worried about the keyspace you can do it this way and it will run a LOT faster. public static string CreateRandomString(int length) { length -= 12; //12 digits are the counter if (length > 8); buf[2] = (byte)(count >> 16); buf[3] = (byte)(count >> 24); buf[4] = (byte)(count >> 32); buf[5] = (byte)(count >> 40); buf[6] = (byte)(count >> 48); buf[7] = (byte)(count >> 56); return Convert.ToBase64String(buf) + Convert.ToBase64String(randomBytes); }
