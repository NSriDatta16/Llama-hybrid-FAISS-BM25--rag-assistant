[site]: stackoverflow
[post_id]: 1695313
[parent_id]: 
[tags]: 
.NET Client/Server Scaleability & Asynchronous I/O - Excess Thread Issues

I have a pretty simple question which perhaps someone familiar with Server/Client design & the Asynchronous I/O paradigm of .NET could answer quickly... I'm writing a server-side application which is designed to run on relatively non-sophisticated hardware (read: not-so-modern, average office desktop PCs), but accommodate a reasonably large number of users (though some users may be idle) - Because of this, I am concerned about the scalability impact of having a single thread for each client (due to excess context switching grinding the machine to a halt). This of course requires careful thought as to when a thread truly should be spawned. One solution I've considered is to have a single master thread (separate from the connection listener thread) in the Server App which tracks activity on open connections by regularly going down the list of open sockets and performing a select(...) on each. If the thread finds incoming data, it sets up an asynchronous read (to consume the message, process it and return a reply, if necessary), and then moves onto the next socket. This process repeats for however long the server has at least on client connected. In doing so, the maximal # of threads that are actually running is limited to only the number of clients actually communicating (and never higher than the maximal number of users connected); For clients that are idle, there is no idle thread which is simply taking up the CPU and bogging down the machine - The only time a thread is associated with a client is when there is actual data to be received & processed. In my mind, this makes sense, though I guess this is the first time I've ever attempted something of this manner in C#. Does anyone have any thoughts on any issues this might bring about, or suggestions on maybe a better way of doing the same task? Thanks!
