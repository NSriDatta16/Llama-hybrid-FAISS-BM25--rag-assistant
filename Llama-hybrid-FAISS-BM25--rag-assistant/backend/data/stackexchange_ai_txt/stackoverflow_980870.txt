[site]: stackoverflow
[post_id]: 980870
[parent_id]: 980702
[tags]: 
Oh my . I can't believe some of these answers. First thing, repeated subtraction, even Pax's version, will never, ever be optimal. Consider, the following: 20 % 25 that's easy and fast using repeated subtraction, but: 65535 % 25 will be horribly slow, 600+ iterations. That's an average of 300 iterations for 16 bit numbers. As for 32 bit number, well, just don't even go there. The fastest way to do this is to use long division. See Niki's answer. But, this is what the compiler will be generating anyway, at least, one would hope it is what the compiler is generating. It's always best to check if you're using a compiler for a niche processor. The best way to speed this up is to not do the modulus in the first place. Why do you need to get the modulus and can you re-factor the code / algorithm to avoid the modulus, or at least, make the modulus trivial.
