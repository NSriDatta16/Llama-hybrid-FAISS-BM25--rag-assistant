[site]: crossvalidated
[post_id]: 488829
[parent_id]: 
[tags]: 
Covariance matrix computation VECM, Lutkepohl (2005) p.287

In Lutkepohls book "New introduction to multiple time series analysis" (2005) on p.287 is outlined how to calculate your estimated parameters $[\hat \Pi,\hat \Gamma]$ sample covariance matrix $\hat \Sigma_{co}$ . It is the kronecker product between the two matrices, $\Sigma_u$ and another matrix, lets call it $\Omega$ . A consistent estimate for $\Sigma_u$ is its sample counterpart $\hat \Sigma_u$ . An estimator for $\Omega$ can be obtained by $$ \hat \Omega = T \begin{bmatrix} Y_{-1}Y_{-1}' & Y_{-1}\Delta X' \\ \Delta X Y_{-1} & \Delta X \Delta X'\\ \end{bmatrix}^{-1} $$ I get very different results when I calculate $\hat \Sigma_{co}$ myself, compared to the results obtained by using the python package statsmodels. However, when I calculate $\Omega$ without scaling by "T", I get the exact same results as the statsmodels results. This led me to inspect the source code of statsmodels to see how they calculate $\Omega$ , I notice in the construction of the definition "cov_params_default", that they do not scale $\Omega$ by a factor T. (They calculate omega a little different than I do, they use the equation 3 lines below equation 7.2.6 also on p.287, in their construction of omega they should scale by 1/T, point is, they do not use T in any way.) My question is if anyone could explain why we should not scale $\hat \Omega$ by T when calculating the covariance matrix $\hat \Sigma_{co}$ ? My assumption is that the statsmodels people are right ofcourse.
