[site]: stackoverflow
[post_id]: 504434
[parent_id]: 504268
[tags]: 
Yes. Often a hash digest is stored as the ASCII representation of hex digits, for example MD5 of the word 'hash' is: 0800fc577294c34e0b28ad2839435945 This is a 32-character ASCII string. But MD5 really produces a 128-bit binary hash value. This should require only 16 bytes to be stored as binary values instead of hex digits. So you can gain some space efficiency by using binary strings. CREATE TABLE test.foobar ( id BINARY(16) NOT NULL PRIMARY KEY ); INSERT INTO test.foobar (id) VALUES (UNHEX(MD5('hash'))); Re. your comments that you are more concerned about performance than space efficiency: I don't know of any reason that the BINARY data type would be speedier than CHAR. Being half as large can be an advantage for performance if you use cache buffers effectively. That is, a given amount of cache memory can store twice as many rows worth of BINARY data if the string is half the size of the CHAR needed to store the same value in hex. Likewise the cache memory for the index on that column can store twice as much. The result is a more effective cache, because a random query has a greater chance of hitting the cached data or index, instead of requiring a disk access. Cache efficiency is important for most database applications, because usually the bottleneck is disk I/O. If you can use cache memory to reduce frequency of disk I/O, it's a much bigger bang for the buck than the choice between one data type or another. As for the difference between a hash string stored in BINARY versus a BIGINT, I would choose BIGINT. The cache efficiency will be even greater, and also on 64-bit processors integer arithmetic and comparisons should be very fast. I don't have measurements to support the claims above. The net benefit of choosing one data type over another depends a lot on data patterns and types of queries in your database and application. To get the most precise answer, you must try both solutions and measure the difference. Re. your supposition that binary string comparison is quicker than default case-insensitive string comparison, I tried the following test: mysql> SELECT BENCHMARK(100000000, 'foo' = 'FOO'); 1 row in set (5.13 sec) mysql> SELECT BENCHMARK(100000000, 'foo' = BINARY 'FOO'); 1 row in set (4.23 sec) So binary string comparison is 17.5% faster than case-insensitive string comparison. But notice that after evaluating this expression 100 million times, the total difference is still less than 1 second. While we can measure the relative difference in speed, the absolute difference in speed is really insignificant. So I'll reiterate: Measure, don't guess or suppose. Your educated guesses will be wrong a lot of the time. Measure before and after every change you make, so you know how much it helped. Invest your time and attention where you get the greatest bang for the buck. Don't sweat the small stuff. Of course, a tiny difference adds up with enough iterations, but given those iterations, a performance improvement with greater absolute benefit is still preferable.
