[site]: stackoverflow
[post_id]: 5360432
[parent_id]: 5360412
[tags]: 
You could use a std::list instead of a std::vector. When you remove items from it, you won't invalidate iterators , so you can keep looping You could build up a vector/list of objects that are to be deleted once the loop has finished. Once the loop completes, loop through your new collection, delete them, and remove them from the original vector. The new collection could be of type pointer-to-pointer, so you don't destroy it while iterating over it You could add a return value from your callback that allows for some flow control. An example is how Win32 and WinForms event handlers set a wasHandled flag. In your case, you'd tell the handler loop whether you want to terminate (as well as any other flow control that sounds interesting/useful) You could reorganize your code to use reference counting smart pointers to automatically delete it when there are no more listeners (or other things referencing your object). For the smart pointer solution, one such class is the std::shared_ptr . You can find this in brand-spanking-new compilers (it may not be standard yet, but it will be soon), or in the Boost Smart Pointers library .
