[site]: stackoverflow
[post_id]: 2749290
[parent_id]: 2749247
[tags]: 
Well, this one is actually how you might do it in perl : # two must-have pragmas for perl development use strict; use warnings; Perl allows for variables to be created as they are used, $feldman = some_function() means that you now have the variable $feldman in your local namespace. But the bad part about this is that you can type $fldman and take a long time finding out why what you thought was $feldman has no value. Turning on strictures means that your code fails to compile if it encounters an undeclared variable. You declare a variable with a my or our statement (or in older Perl code a use vars statement. Turning on warnings just warns you when you're not getting values you expect. Often warnings tends to be too touchy, but they are generally a good thing to develop code with. my %hash; # the base object for the data Here, I've declared a hash variable that I creatively called %hash . The sigil (pronounced "sijil") "%" tells that it is a map of name-value pairs. This my statement declared the variable and makes it legal for the compiler. The compiler will warn me about any use of %hsh . The next item is a foreach loop (which can be abbreviated "for"). The loop will process the list of lines in @tmp_cycledef assigning each one in turn to $row . ( my $row ). We chomp the line first, removing the end-of-line character for that platform. We split the line on the '|' character, creating a list of strings that had been separated by a pipe. And then we store it in a two-layered hash. Since we want to group them by at least the first number. We could do this by array, and create an array at the location in the hash like so: push @{$hash{$key}}, $val , but I typically want to collapse duplicates (not that there were any duplicates in your sample.) Here: foreach my $row ( @tmp_cycledef ) { chomp $row; # removes the end-of-line character when present. my ( $key, $val ) = split /\|/, $row; # One of the best ways to merge lists is a presence-of idea # with the hash holding whether the value is present $hash{$key}{$val} = 1; } Once we have the data in the structure, we need to iterate both level of hash keys . You wanted to separate the "top level" numbers by lines, but you wanted the second numbers concatenated on the same line. So we print a line for each of the first numbers and join the list of strings stored for each number on the same line, delimited by commas. We also sort the list: { $a $b } just takes to keys and numerically compares them. So you get a numeric order. # If they were alpha keys our sort routine, we would just likely say sort keys %hash foreach my $num ( sort { $a $b } keys %hash ) { my $h = $hash{$num}; print "$num ", join( ',', sort { $a $b } keys %$h ), "\n"; } As I said in the comments, sort , by default, sorts in character order so you can just say sort keys %hash . To help you out, you really need to read some of these: strictures warnings perldata perlfunc -- especially my , foreach , chomp , split , keys , sort and join And the data structure tutorial
