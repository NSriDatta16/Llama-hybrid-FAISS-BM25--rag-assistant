[site]: stackoverflow
[post_id]: 4476269
[parent_id]: 4476155
[tags]: 
Edit: you've altered the question so most of this becomes irrelevant. Here is a simple clarification of it. var holdLowPriorities = []; for(conflict=0; conflict = nextConflictTime[1] || conflictTime[1] Then this can be made more obvious by using a helper method and a couple more variables. function conflictData(conflict) { return data[conflict[2]].stepsArr[conflict[3]; } var holdLowPriorities = []; for(conflict=0; conflict = nextConflictTime[1] || conflictTime[1] When expressed like this, I think you can start to see probable bugs; high priority has conflictTime and nextConflictTime checks as if, if, whereas low priority has if, else if. Is this what is desired? You may be able to then put this/next conflict priority in a switch or reorganise the code more. But I think it's now at the stage where it can be understood more readily.
