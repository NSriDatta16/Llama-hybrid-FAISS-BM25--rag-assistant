[site]: stackoverflow
[post_id]: 3081567
[parent_id]: 3081412
[tags]: 
+1 for a good question. Web development is not much different to any other development. P.20 of that venerable classic breaks a typical project down into 1/3 planning, 1/6 coding, 1/4 component test and 1/4 system test. I might catch some flak for that, YMMV and all, but that looks about right to me. Whether or not you agree with the proportions, the message is "don't jump right in and code; think about it first (measure twice, cut once). How often have you jumped in and coded only to get near to "then end" and discover that you have a fundamental design flaw and have to through away much of your code & rewrite chunks more? You need methodologies (Processes) and Tools, and each can necessitate the other. Methodologies Design it first! Gather requirements, make a system level design document then detailed design. If you are more than one, have these reviewed by someone (client can maybe review the high level docs?). If if you are alone, the simple act of writing it down forces you to slow down and think and will uncover problems. A good idea is to have a requirements traceability matrix to ensure that each requirement gets designed, implemented and tested somewhere. After you review the high level design, you can being the detailed design, and after you review that, you can begin to implement. When the high level design is reviewed you can, in parallel, or later, produce a high level test spec. When the detailed level design is reviewed you can, in parallel, or later, produce unit test specs. Note that test cases should be automated and should require no human interaction. Get into the habit of running regression tests after every code change - automate this if you can, with nightly build and or coupled with check-in to your version control system. When everything is thoroughly unit tested, you can begin your system level testing. Tools At the very least you ought to be considering these: A good IDE (WYSIWYG for web design), preferably with debugging capabilities, and it would be nice if it interfaced with your version control system, bug tracker, etc. A spill chuker is useful for websites ;-) A project management tool to plan the project (Open Workbench does some nice Gantt charts) A version control system. A change request and bug tracker. An automated test system. An automated build system like Hudson (it may not seem relevant if you don't compile and link, but at least it can verify that all files exist and can schedule regression testing for you) A backup system in case of disk crash, laptop loss, etc. And if all that seems like too much "extra" to do, I was sceptical too once, until I saw that it actually saves time because you discover problems earlier when they cost less to fix. In fact, I am so sure of this that I do all of my personal one-man hobby projects this way. All of them.
