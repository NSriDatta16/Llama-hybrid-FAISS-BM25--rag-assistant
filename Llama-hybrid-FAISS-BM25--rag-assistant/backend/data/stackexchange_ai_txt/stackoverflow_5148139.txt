[site]: stackoverflow
[post_id]: 5148139
[parent_id]: 
[tags]: 
OpenGL calls segfault when called from OpenMP thread

Let me start by trying to specify what I want to do: Given a grey scale image, I want to create 256 layers (assuming 8bit images), where each layer is the image thresholded with a grey scale i -- which is also the i'th layer (so, i=0:255). For all of these layers I want to compute various other things which are not very relevant to my problem, but this should explain the structure of my code. The problem is that I need to execute the code very often, so I want to speed things up as much as possible, using a short amount of time (so, simple speedup tricks only). Therefore I figured I could use the OpenMP library, as I have a quad core, and everything is CPU-based at the moment. This brings me to the following code, which executes fine (at least, it looks fine :) ): #pragma omp parallel for private(i,out,tmp,cc) for(i=0; i dimX()* in->dimY()*sizeof(int)); tmp = (*in).dupe(); tmp->threshold((float) i); if(!tmp){ printf("Could not allocate enough memory\n"); exit(-1); } cc->connected(tmp->data(),out,tmp->dimX(),tmp->dimY(),std::equal_to (), true); free(out); delete tmp; delete cc; } ConnectedComponents is just some library which implements the 2-pass floodfill, just there for illustration, it is not really part of the problem. This code finishes fine with 2,3,4,8 threads (didn't test any other number). So, now the weird part. I wanted to add some visual feedback, helping me to debug. The object tmp contains a method called saveAsTexture() , which basically does all the work for me, and returns the texture ID. This function works fine single threaded, and also works fine with 2 threads. However, as soon as I go beyond 2 threads, the method causes a segmentation fault. Even with #pragma omp critical around it (just in case saveAsTexture() is not thread-safe), or executing it only once, it still crashes. This is the code I have added to the previous loop: if(i==100){ #pragma omp critical { tmp->saveToTexture(); } } which is only executed once, since i is the iterator, and it is a critical section... Still, the code ALWAYS segfaults at the first openGL call (bruteforce tests with printf(), fflush(stdout)). So, just to make sure I am not leaving out relevant information, here is the saveAsTexture function: template GLuint FIELD ::saveToTexture() { unsigned char *buf = (unsigned char*)malloc(dimX()*dimY()*3*sizeof(unsigned char)); if(!buf){ printf("Could not allocate memory\n"); exit(-1); } float m,M,avg; minmax(m,M,avg); const float* d = data(); int j=0; for(int i=dimY()-1; i>=0; i--) { for(const float *s=d+dimX()*i, *e=s+dimX(); s 0)?v:0; if (v>M) { r=g=b=1; } else { v = (v It is good to note here that T is ALWAYS a float in my program. So, I do not understand why this program works fine when executed with 1 or 2 threads (executed ~25 times, 100% success), but segfaults when using more threads (executed ~25 times, 0% success). And ALWAYS at the first openGL call (e.g. if I remove glPixelStorei(), it segfaults at glDisable()). Am I overlooking something really obvious, am I encountering a weird OpenMP bug, or... what is happening?
