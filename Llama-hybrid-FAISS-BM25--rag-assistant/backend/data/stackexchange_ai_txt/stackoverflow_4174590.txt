[site]: stackoverflow
[post_id]: 4174590
[parent_id]: 4165138
[tags]: 
There isn't a truly safe way to check if the UDID is real. The UDID is got via liblockdown, which communicates to lockdownd via a secure channel to receive the UDID: +-----------+ | your code | +-----------+ | +----------+ +-------------+ +-----------+ | UIDevice | | liblockdown | | lockdownd | (trusted data) +----------+ +-------------+ +-----------+ untrusted user trusted user When the device is jailbroken, all 4 components can be replaced. One method to detect the presence of UDID Faker is to check if some identifications (files, functions etc.) unique to it exists. This is a very specific and fragile counter-attack, as when the method of detection is exposed, the spoofer could simply change the identification to conceal their existence. For example, UDID Faker relies on a plist file /var/mobile/Library/Preferences/com.Reilly.UDIDFaker.plist . Therefore, you could check if this file exists: NSString* fakerPrefPath = @"/var/mobile/Library/Preferences/com.Reilly.UDIDFaker.plist"; if ([[NSFileManager defaultManager] fileExistsAtPath:fakerPrefPath])) { // UDID faker exists, tell user the uninstall etc. } it also defines the method -[UIDevice orig_uniqueIdentifier] which could be used to bypass the faker: UIDevice* device = [UIDevice currentDevice]; if ([device respondsToSelector:@selector(orig_uniqueIdentifier)]) return [device orig_uniqueIdentifier]; else return device.uniqueIdentifier; Of course the spoofer could simply rename these things. A more reliable method lies in how Mobile Substrate works. Injected code must be located in a dylib/bundle, which is loaded into a memory region different from UIKit. Therefore, you just need to check if the function pointer of the -uniqueIdentifier method is within the acceptable range. // get range of code defined in UIKit uint32_t count = _dyld_image_count(); void* uikit_loc = 0; for (uint32_t i = 0; i Anyway UDID Faker is a very high level hack (i.e. it can be easily avoided). It hijacks the link between UIDevice and liblockdown by supplying a fake ID. +-----------+ | your code | +-----------+ | +----------+ +-------------+ +-----------+ | UIDevice | | lockdownd | (trusted data) +----------+ | +-------------+ +-----------+ | +------------+ ‘-->| UDID Faker | +------------+ Thus you could move the code asking the UDID lower to the liblockdown level. This can be used for apps for Jailbroken platforms, but this is not possible for AppStore apps because liblockdown is a private API. Besides, the spoofer could hijack liblockdown (it's very easy, I hope no one does it), or even replace lockdownd itself. +-----------+ | your code | +-----------+ | +----------+ +-------------+ +-----------+ | UIDevice | | lockdownd | (trusted data) +----------+ | +-------------+ +-----------+ | +------------+ ‘-->| UDID Faker | +------------+ (I'm not going to show how to use liblockdown here. You should be able to find sufficient information from the site you've linked to.)
