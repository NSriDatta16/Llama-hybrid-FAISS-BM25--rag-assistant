[site]: stackoverflow
[post_id]: 5291451
[parent_id]: 5080826
[tags]: 
I have an open source project on GitHub: LinkifyURL which you may want to consider. It has a function: linkify() which plucks URLs from text and converts them to links. Note that this is not a trivial task to do correctly! (See: The Problem With URLs - ands be sure to read the thread of comments to grasp all the things that can go wrong.) If you really need to NOT linkify specific domains (i.e. vimeo and youtube), here is a modified PHP function linkify_filtered (in the form of a working test script) that does what you need: . ( |&(?:gt|\#62|\#x3e);) # $12: ">" end delimiter (or HTML entity). | # Alternative 5: URL not delimited by (), [], {} or <>. ( # $13: Prefix proving URL not already linked. (?: ^ # Can be a beginning of line or string, or | [^=\s\'"\]] # a non-"=", non-quote, non-"]", followed by ) \s*[\'"]? # optional whitespace and optional quote; | [^=\s]\s+ # or... a non-equals sign followed by whitespace. ) # End $13. Non-prelinkified-proof prefix. ( \b # $14: Other non-delimited URL. (?:ht|f)tps?:\/\/ # Required literal http, https, ftp or ftps prefix. [a-z0-9\-._~!$\'()*+,;=:\/?#[\]@%]+ # All URI chars except "&" (normal*). (?: # Either on a "&" or at the end of URI. (?! # Allow a "&" char only if not start of an... &(?:gt|\#0*62|\#x0*3e); # HTML ">" entity, or | &(?:amp|apos|quot|\#0*3[49]|\#x0*2[27]); # a [&\'"] entity if [.!&\',:?;]? # followed by optional punctuation then (?:[^a-z0-9\-._~!$&\'()*+,;=:\/?#[\]@%]|$) # a non-URI char or EOS. ) & # If neg-assertion true, match "&" (special). [a-z0-9\-._~!$\'()*+,;=:\/?#[\]@%]* # More non-& URI chars (normal*). )* # Unroll-the-loop (special normal*)*. [a-z0-9\-_~$()*+=\/#[\]@%] # Last char can\'t be [.!&\',;:?] ) # End $14. Other non-delimited URL. /imx'; // $url_replace = '$1$4$7$10$13 $2$5$8$11$14 $3$6$9$12'; // return preg_replace($url_pattern, $url_replace, $text); $url_replace = '_linkify_filter_callback'; return preg_replace_callback($url_pattern, $url_replace, $text); } function _linkify_filter_callback($m) { // Filter out youtube and vimeo domains. $pre = $m[1].$m[4].$m[7].$m[10].$m[13]; $url = $m[2].$m[5].$m[8].$m[11].$m[14]; $post = $m[3].$m[6].$m[9].$m[12]; if (preg_match('/\b(?:youtube|vimeo)\.com\b/', $url)) { return $pre . $url . $post; } // else linkify... return $pre .' ' . $url .' ' .$post; } // Create some test data. $data = 'Plain URLs (not delimited): foo http://example.com bar... foo http://example.com:80 bar... foo http://example.com:80/path/ bar... foo http://example.com:80/path/file.txt bar... foo http://example.com:80/path/file.txt?query=val&var2=val2 bar... foo http://example.com:80/path/file.txt?query=val&var2=val2#fragment bar... foo http://example.com/(file\'s_name.txt) bar... (with \' and (parentheses)) foo http://[2001:0db8:85a3:08d3:1319:8a2e:0370:7348] bar... ([IPv6 literal]) foo http://[2001:0db8:85a3:08d3:1319:8a2e:0370:7348]/file.txt bar... ([IPv6] with path) foo http://youtube.com bar... foo http://youtube.com:80 bar... foo http://youtube.com:80/path/ bar... foo http://youtube.com:80/path/file.txt bar... foo http://youtube.com:80/path/file.txt?query=val&var2=val2 bar... foo http://youtube.com:80/path/file.txt?query=val&var2=val2#fragment bar... foo http://youtube.com/(file\'s_name.txt) bar... (with \' and (parentheses)) foo http://vimeo.com bar... foo http://vimeo.com:80 bar... foo http://vimeo.com:80/path/ bar... foo http://vimeo.com:80/path/file.txt bar... foo http://vimeo.com:80/path/file.txt?query=val&var2=val2 bar... foo http://vimeo.com:80/path/file.txt?query=val&var2=val2#fragment bar... foo http://vimeo.com/(file\'s_name.txt) bar... (with \' and (parentheses)) '; // Verify it works... echo(linkify_filtered($data) ."\n"); ?> This employs a callback function to do the filtering. Yes, the regex is complex (but so it the problem as it turns out!). You can see the interactive Javascript version of linkify() in action here: URL Linkification (HTTP/FTP) . Also, John Gruber has a pretty good regex to do linkification. See: An Improved Liberal, Accurate Regex Pattern for Matching URLs . However, his regex suffers catastrophic backtracking under certain circumstances. (I've written to him about this, but he has yet to respond.) Hope this helps! :)
