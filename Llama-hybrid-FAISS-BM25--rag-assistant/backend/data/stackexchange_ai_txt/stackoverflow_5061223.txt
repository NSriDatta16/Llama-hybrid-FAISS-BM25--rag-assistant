[site]: stackoverflow
[post_id]: 5061223
[parent_id]: 
[tags]: 
Anybody successful with NSProxy of UIView (e.g., UILabel?)

I am experimenting in adding functionality to my UIViews (configuring CALayers according to state) by setting up a NSProxy subclass to stand in for any UIView I choose. Here's what I've tried: In my NSProxy subclass, I have the following code: #pragma mark Initialization / Dealloc - (id)initWithView:(UIView *)view { delegate = view; [delegate retain]; return self; } - (void)dealloc { [delegate release]; [super dealloc]; } #pragma mark Proxy Methods - (void)forwardInvocation:(NSInvocation *)anInvocation { [anInvocation setTarget:delegate]; [anInvocation invoke]; return; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { return [delegate methodSignatureForSelector:aSelector]; } - (BOOL)respondsToSelector:(SEL)aSelector { BOOL rv = NO; if ([delegate respondsToSelector:aSelector]) { rv = YES; } return rv; } And, using my NSProxy subclass this way: UILabel *label = [[HFMultiStateProxy alloc] initWithView:[[[UILabel alloc] initWithFrame:cellFrame] autorelease]]; label.text = text; label.font = font; label.textAlignment = UITextAlignmentCenter; label.backgroundColor = [UIColor clearColor]; label.opaque = NO; [self addSubview:label]; Seems to work until I hit the addSubview: line. Turning message tracing on ( instrumentObjcMessageSends(YES); ) shows the forwarding for each of the previous messages working until deep inside of the addSubview:, where this series of method calls show up in the log (the first message shown here was invoked via the proxy): - UILabel UIView _makeSubtreePerformSelector:withObject: - UILabel UIView _makeSubtreePerformSelector:withObject:withObject:copySublayers: - CALayer CALayer sublayers - NSMethodSignature NSMethodSignature methodReturnType - NSMethodSignature NSMethodSignature _argInfo: - NSMethodSignature NSMethodSignature _frameDescriptor + UILabel NSObject resolveInstanceMethod: - UILabel NSObject forwardingTargetForSelector: - UILabel NSObject forwardingTargetForSelector: - UILabel NSObject methodSignatureForSelector: - UILabel NSObject methodSignatureForSelector: - UILabel NSObject class - UILabel NSObject doesNotRecognizeSelector: And I get the following error: 2011-02-20 16:38:52.048 FlashClass_dbg[22035:207] -[UILabel superlayer]: unrecognized selector sent to instance 0x757d470 if I do not use an NSProxy subclass and instead use a UILabel subclass (HFMultiStateLabel), it works fine. Here is the message trace that occurs once addSubview: is called (HFNoteNameControl is the superview of the label): - HFNoteNameControl UIView addSubview: - HFNoteNameControl UIView _addSubview:positioned:relativeTo: - HFMultiStateLabel UIView superview - HFMultiStateLabel UIView window - HFNoteNameControl NSObject isKindOfClass: - HFNoteNameControl NSObject class - HFNoteNameControl UIView window - UIWindow NSObject isKindOfClass: - UIWindow NSObject class - HFNoteNameControl UIView _shouldTryPromoteDescendantToFirstResponder - HFMultiStateLabel UIView _isAncestorOfFirstResponder - HFMultiStateLabel UIView _willMoveToWindow:withAncestorView: - HFMultiStateLabel UIView _willMoveToWindow: - HFMultiStateLabel UIView willMoveToWindow: - HFMultiStateLabel UIView _makeSubtreePerformSelector:withObject:withObject:copySublayers: - CALayer CALayer sublayers - HFMultiStateLabel UIView willMoveToSuperview: - HFMultiStateLabel UIView _unsubscribeToScrollNotificationsIfNecessary: - HFMultiStateLabel UIView _makeSubtreePerformSelector:withObject: - HFMultiStateLabel UIView _makeSubtreePerformSelector:withObject:withObject:copySublayers: - CALayer CALayer sublayers - CALayer CALayer superlayer I can verify that each of the methods up until -superlayer are called successfully when using NSProxy. For some reason, with the NSProxy, superlayer on UILabel is being called instead of CALayer. Perhaps somewhere something gets confused and UILabel is inserted into the sublayers instead of its CALayer? Does the UIKit do some sort of optimizations that bypass the normal mechanism that NSProxy hooks into? PS I have only tried this in the Simulator, not the device. Would that behavior be any different?
