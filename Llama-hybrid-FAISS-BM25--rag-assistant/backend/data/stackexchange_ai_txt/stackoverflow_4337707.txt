[site]: stackoverflow
[post_id]: 4337707
[parent_id]: 4337275
[tags]: 
To make sure I understand the question: In your embedded system, you have a struct that contains system settings that looks something like this: struct SubStruct{ int subSetting1; float subSetting2; } /* ... some other substructure definitions. ... */ struct Settings{ float setting1; int setting2; struct SubStruct setting3; /* ... lots of other settings ... */ } And your problem is you want to take a binary file containing said structure and modify the values on another machine? Given that you know the sizes of the integral types and the packing used by the embedded system, you may have two options. If the endianness of your embedded system and PC system is different, you will also have to deal with that, e.g. using hton when writing fields. Option 1: Declare the same structure in your PC program, with pragmas to force the same byte-alignment as the embedded system, and with any integral types that are different sizes between the embedded and PC systems "retyped" to specific sizes, e.g. by using int16_t, int32_t if you have stdint.h, or your own typedefs if not, on your PC program. Option 2: You may be able to simply make a list of types, e.g. a list that looks like: Name Type setting1 float setting2 int subStruct1SubSetting1 int subStruct1SubSetting2 float And then calculate the locations based on the sizes and packing used by the embedded system, e.g. if the embedded system uses 4-byte alignment, 4-byte floats, and 2-byte ints, the above table would calculate out: Name Type Calculated Offset setting1 float 0 setting2 int 4 subStruct1SubSetting1 int 8 subStruct1SubSetting2 float 12 or if the embedded system packs the structure to 1-byte alignment (e.g. if it's an 8-bit micro) Name Type Calculated Offset setting1 float 0 setting2 int 4 subStruct1SubSetting1 int 6 subStruct1SubSetting2 float 8
