[site]: stackoverflow
[post_id]: 3296489
[parent_id]: 
[tags]: 
Objective-C property reference count

Could someone please help me understand reference counting in Objective C properties. Suppose I have class @interface TA : NSObject { TB* tb; } - (id) init; - (void) dealloc; @property (nonatomic,retain) TB* tb; @end @implementation @synthesize tb; - (id) init {...} - (void) dealloc {...} @end My understanding is that assignment of new value to "tb", such as "ta.tb = newValue" is equivalent to the following logic: if (newValue != oldValue) { [newValue retain]; [oldValue release]; tb_storage_cell = newValue; } But how does it work inside the init method? Does [TA alloc] pre-initialize instance memory with zeroes? Do I need to execute tb = nil inside init ? If alloc does pre-initialize memory with zeroes, it appears setting tb = nil is not necessary inside the init since tb is already nil. Is that right? On the other hand if alloc does not zero out allocated memory, and it contains garbage, then an attempt by the setter to release old value inside the initializing assignment should crash and it may never work. So does it mean that alloc is indeed guaranted to return always zeroed-out block of memory? Next, to dealloc . Supposed sequence is inside dealloc is: [tb release]; tb = nil; [super dealloc]; Is that right? But if so, how again does it work? First release is supposed to release "tb". Then the assignment "tb = nil" is supposed to release tb's oldValue again, so it should amount to double release and crash... Or am I supposed to skip "[tb release]" inside the dealloc and simply do tb = nil; [super dealloc]; ?
