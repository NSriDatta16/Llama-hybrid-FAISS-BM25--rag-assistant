[site]: stackoverflow
[post_id]: 2307061
[parent_id]: 2306620
[tags]: 
What you're looking for is Applicative Functors . Specifically the "zippy" applicative from the linked paper. In Haskell notation, let's call your function f . Then with applicative programming, it would look as succinct as this: f d e as bs cs = if' ((&&) (d (e >=)) as ((/) bs cs) (repeat 0) where if' x y z = if x then y else z ( ) = zipWith ($) The result of f is a list. Simply take the average. To generify a little: f g p as bs cs = if' p as (((Some .) . g) bs cs) (repeat None) Here, p is a predicate, so you would call it with: average $ fromMaybe 0 f (/) ((&&) (d (e >=)) as bs cs ... given the same definition of as above. Note: I haven't tested this code, so there might be missing parentheses and the like, but this gets the idea across.
