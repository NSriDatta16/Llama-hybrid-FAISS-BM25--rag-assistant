[site]: stackoverflow
[post_id]: 1855665
[parent_id]: 1638859
[tags]: 
Ahm. (As far as I know) You can't hold the stick from both ends. Either you hold to your information, or you let it go. However... you can hold to some key information that would enable you to finalize. Of course, the key information must be significantly smaller then the "real information" and must not have the real information in its reachable object graph (weak references might help you there). Building on the existing example (pay attention to the key information field): public class Test1 { static class Bloat { // just a heap filler really private double a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z; private final int ii; public Bloat(final int ii) { this.ii = ii; } } // as recommended by Tom Hawtin static class MyReference extends SoftReference { private final K keyInformation; MyReference(T referent, K keyInformation, ReferenceQueue q) { super(referent, q); this.keyInformation = keyInformation; } public K getKeyInformation() { return keyInformation; } } //...meanwhile, somewhere in the neighbouring galaxy... public static void main(String[] args) throws InterruptedException { ReferenceQueue rq = new ReferenceQueue (); Set > set = new HashSet >(); int i = 0; while (i (new Bloat(i), i, rq)); final Reference polled = rq.poll(); if (polled != null) { if (polled instanceof MyReference) { final Object keyInfo = ((MyReference) polled).getKeyInformation(); System.out.println("not null, got key info: " + keyInfo + ", finalizing..."); } else { System.out.println("null, can't finalize."); } rq.remove(); System.out.println("removed reference"); } Edit: I want to elaborate on the "either hold your information or let it go". Assuming you had some way of holding to your information. That would have forced the GC to unmark your data, causing the data to actually be cleaned only after you're done with it, in a second GC cycle. This is possible - and its exactly what finalize() is for. Since you stated that you don't want the second cycle to occur, you can't hold your information (if a-->b then !b-->!a). which means you must let it go. Edit2: Actually, a second cycle would occur - but for your "key data", not your "major bloat data". The actual data would be cleared on the first cycle. Edit3: Obviously, the real solution would use a separate thread for removing from the reference queue (don't poll(), remove(), blocking on the dedicated thread).
