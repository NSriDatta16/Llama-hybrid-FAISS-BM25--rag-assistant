[site]: stackoverflow
[post_id]: 1883459
[parent_id]: 1883413
[tags]: 
Yep its the way most large websites do it. Look at nosql databases, Google's bigtable architecture etc. 1. This is the general approach I'd take. I'd use a mixture of memcached , a nosql-cloud (couch-db or mongo-db) and enterprise grade RDBMS systems (core data storage) for the data layer. I'd then write the service layer ontop of the data layer. nosql database API's are massively parallel (look at couchdb with its ngingx service layer parallizer). I'd then provide "oldschool each request is a web-page" generating web-servers and also direct access to the service layer for new style AJAX application; both these would depend on the service layer. p.s. the RDBMS is an important component here, it holds the authoritative copy of the all the data in the memchached/nosql cloud. I would use an enterprise grade RDBMS to do data-centre to data-centre replication. I don't know how the big boys do their cloud based site replication, it would scare me if they did data-cloud to data-cloud replication :P Some points: yYu do not need heartbeat , with nosql the approach taken is that if content becomes unavailable, you regenerate it onto another server using the authoratitve copy of the data. The burden of state -less web-design is carried to the nosql and memcached layer which is infinitely scalable. So you do not need to worry about this. Just have a good network infrastructure. In terms of sync , when you are talking to the RDBMS you can expect acceptable synchronous response times. Your cloud you should treat as an asynchronous resource, you will get help from the API's that interface with your cloud so you don't even have to think about this. Advice I can give about networking and redundancy is this: do not go for fancy Ethernet bonding, as its not worth it -- things always go wrong. Just set up redundant switches, ethernet cards and have multiple routes to all your machines. You can use OpenBSD and CARP for your routers, as they work great - routers are your worst point of failure -- openbsd solves this problem. 2. You've described the general components of a web 2.0 farm, so no comment:D
