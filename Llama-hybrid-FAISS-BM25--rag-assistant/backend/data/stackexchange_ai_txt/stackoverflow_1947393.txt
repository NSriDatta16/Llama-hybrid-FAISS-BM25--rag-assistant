[site]: stackoverflow
[post_id]: 1947393
[parent_id]: 1946916
[tags]: 
You don't say which flavour of SQL you want the answer for. This probably means you want the code in SQL Server (as [sql] commonly = [sql-server] in SO tag usage). But just in case you (or some future seeker) are using Oracle, this kind of query is quite straightforward with analytic functions, in this case LAG() . Check it out: SQL> select stage_range 2 , avg(time_diff)/60 as average_time_diff_in_min 3 from 4 ( 5 select event_name 6 , case when event_name = 'stage 2' then 'stage 1 to 2' 7 when event_name = 'stage 3' then 'stage 2 to 3' 8 else '!!!' end as stage_range 9 , stage_secs - lag(stage_secs) 10 over (order by ts, event_name) as time_diff 11 from 12 ( select event_name 13 , ts 14 , to_number(to_char(ts, 'sssss')) as stage_secs 15 from timings ) 16 ) 17 where event_name in ('stage 2','stage 3') 18 group by stage_range 19 / STAGE_RANGE AVERAGE_TIME_DIFF_IN_MIN ------------ ------------------------ stage 1 to 2 2.66666667 stage 2 to 3 5 SQL> The change of format in the inner query is necessary because I have stored the TIME column as a DATE datatype, so I convert it into seconds to make the mathematics clearer. An alternate solution would be to work with Day to Second Interval datatype instead. But this solution is really all about LAG() . edit In my take on this query I have explicitly not calculated the difference between a prior Stage 3 and a subsequent Stage 1. This is a matter of requirement.
