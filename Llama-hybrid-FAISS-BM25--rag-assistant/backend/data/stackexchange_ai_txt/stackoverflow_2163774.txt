[site]: stackoverflow
[post_id]: 2163774
[parent_id]: 1333044
[tags]: 
I have not tried this myself, but preventing default behavoiur immediately is the only way to stop the grid from performing the copy or move. Try preventing the default behaviour and maintaining the drag event. Then, if you user hits no, you have already stopped the event. If the user hits yes, you can (this is the part i am unsure of) re-dispatch the drop event on the grid. Hopefully it will behave normally. To get the event into your Alert handler you can simply use the data property on the Event window to track it. private function dg1_dragDropHandler(evt:DragEvent):void { // Perform some actions here... // ....... evt.preventDefault(); // Show Message to Confirm. Alert.show('Proceed?', 'Title', Alert.YES | Alert.NO, null, handleAlert, null, Alert.YES).data = evt; } private function handleAlert(evt:CloseEvent):void { if (evt.detail == Alert.YES) { // Perform the functions as necessary var dgEvt:DragEvent = Alert(evt.currentTartet).data; var newDrag:DragEvent; //need a new event because the default behaviour on the old one is still prevented //copy event values to new drag event dg1.dispatchEvent(newDrag); } else { // Execute the script to prevent the dropping of the object. // How can I call the DragEvent.preventDefault(); function from here? } Again, not entirely sure if it will work, just off the top of my head. Of course, you have to remove the custom dragDrop event handler from your grid before you redispatch the approved drag, otherwise your handler with prevent the default, then pop an alert and repeat over and over.
