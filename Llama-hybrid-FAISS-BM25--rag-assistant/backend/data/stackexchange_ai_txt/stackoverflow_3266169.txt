[site]: stackoverflow
[post_id]: 3266169
[parent_id]: 3052427
[tags]: 
Because I didn't get a reply from Botondus I decided to ask a new question in the Django Users Google Group and finally got the answer from jaymz. I figured that Botondus method was the right way of doing it, it just wasn't quite working. The reason that it doesn't work in this case is because I'm using a Through model for the field I would like to do the validation on. Because of some earlier feedback I got on a previously posted question I gathered that first the Application instance is saved and then the ManyToMany instances are saved (I believe this is right, but correct me if I'm wrong). So I thought that, if I would perform the validation on the ManyToMany Field in the Through model, this would not prevent the Application instance being saved. But in fact it does prevent that from happening. So if you have a ManyToMany Field inline in your model's admin and you would like to do validation on that field, you specify the clean function in the through model, like this: admin.py class PermissionInline(admin.TabularInline): form = PermissionForm model = Permission extra = 3 forms.py class PermissionForm(forms.ModelForm): class Meta: model = Permission def clean(self): cleaned_data = self.cleaned_data user = cleaned_data['user'] role = cleaned_data['role'] if role.id != 1: folder = cleaned_data['application'].folder if len(filter(lambda x:x in user.profile.company.all(),folder.company.all())) > 0: # this is an intersection raise forms.ValidationError("One of the users of this Application works for one of the Repository's organisations!") return cleaned_data If the validation results in an error NOTHING (neither the application instance, nor the manytomany users instances) is saved and you get the chance to correct the error.
