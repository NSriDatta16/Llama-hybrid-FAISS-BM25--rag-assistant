[site]: stackoverflow
[post_id]: 1313482
[parent_id]: 1311945
[tags]: 
I'm going out on a limb here, since I haven't used much of the Windows API in recent years and I never used WCHAR . For one, you could widen the buffer a bit and poke the quotes right into it: WCHAR buffer[MAX_PATH + 1 + 2]; buffer[0] = L'"'; buffer[sizeof(buffer)/sizeof(WCHAR)-1] = L'"'; DWORD length; HRESULT hr = GetCORSystemDirectory(buffer,MAX_PATH+1,&length); However, this seems inelegant at best. (And I'd need to think twice whether I got that sizeof(buffer)/sizeof(WCHAR)-1 right -- which I'm too lazy for.) Another way would be to use the std::basic_string<> template. Note that std::string is a typedef for std::basic_string . There's little preventing you from instantiating it for other character types, too: WCHAR buffer[MAX_PATH + 1]; DWORD length; HRESULT hr = GetCORSystemDirectory(buffer,MAX_PATH,&length); std::basic_string tbuf= L"\"" + buffer + L"\""; // use 'tbuf.c_str()' to read 'tbuf' as a C-string (there's no safe way to write to it) Note that this presumes that WCHAR expands to wchar_t . If this isn't the case (I have never worked with it, so I wouldn't know), you'd have to cast the literals: std::basic_string tbuf = static_cast (L'"') + buffer + static_cast (L'"');
