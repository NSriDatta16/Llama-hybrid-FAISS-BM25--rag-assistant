[site]: stackoverflow
[post_id]: 2837877
[parent_id]: 2837822
[tags]: 
The traditional approach is the try / finally statement: def do_something_that_needs_database (): dbConnection = MySQLdb.connect(host=args['database_host'], user=args['database_user'], passwd=args['database_pass'], db=args['database_tabl'], cursorclass=MySQLdb.cursors.DictCursor) try: # as much work as you want, including return, raising exceptions, _whatever_ finally: closeDb(dbConnection) Since Python 2.6 (and 2.5 with a from __future__ import with_statement ), there is an alternative (although try / finally still works perfectly well!): the with statement. with somecontext as whatever: # the work goes here A context has an __enter__ method, executed on entry (to return the whatever above, if you want) and an __exit__ method, executed on exit. Despite the elegance, since there is no existing context that works the way you want, the work needed to build one (although reduced in 2.6 with contextlib ) should probably suggest that good old try/finally is best. If you have 2.6 and want to try contextlib , this is one way you could do it to "hide" the try/finally...: import contextlib @contextlib.contextmanager def dbconnect(**kwds): dbConnection = MySQLdb.connect(**kwds) try: yield dbConnection finally: closeDb(dbConnection) to be used as: def do_something_that_needs_database (): with dbconnect(host=args['database_host'], user=args['database_user'], passwd=args['database_pass'], db=args['database_tabl'], cursorclass=MySQLdb.cursors.DictCursor) as dbConnection: # as much work as you want, including return, raising exceptions, _whatever_ It may be worth it if you are going to use this many, many times, just to avoid repeating the try/finally over and over for each of those many uses.
