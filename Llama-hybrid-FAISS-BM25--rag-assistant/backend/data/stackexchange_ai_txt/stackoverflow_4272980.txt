[site]: stackoverflow
[post_id]: 4272980
[parent_id]: 4272893
[tags]: 
List uses an internal array. Removing/inserting items near the beginning of the list will be more expensive than doing the same near the end of the list, since the entire contents of the internal array need to be shifted in one direction. Also, once you try to add an item when the internal list is full, a new, bigger array will be constructed, the contents copied, and the old array discarded. The Collection class, when used with the parameterless constructor, uses a List internally. So performance-wise they will be identical, with the exception of overhead caused by wrapping. (Essentially one more level of indirection, which is going to be negligible in most scenarios.) LinkedList is, as its name implies, a linked list. This will sacrifice iteration speed for insertion/removal speed. Since iterating means traversing pointers-to-pointers-to-pointers ad infinitum, this is going to take more work overall. Aside from the pointer traversal, two nodes may not be allocated anywhere near each other, reducing the effectiveness of CPU RAM caches. However, the amount of time required to insert or remove a node is constant, since it requires the same number of operations no matter the state of the list. (This does not take into account any work that must be done to actually locate the item to remove, or to traverse the list to find the insertion point!) If your primary concern with your collection is testing if something is in the collection, you might consider a HashSet instead. Addition of items to the set will be relatively fast, somewhere between insertion into a list and a linked list. Removal of items will again be relatively fast. But the real gain is in lookup time -- testing if a HashSet contains an item does not require iterating the entire list. On average it will perform faster than any list or linked list structure. However, a HashSet cannot contain equivalent items. If part of your requirements is that two items that are considered equal (by an Object.Equals(Object) overload, or by implementing IEquatable ) coexist independently in the collection, then you simply cannot use a HashSet . Also, HashSet does not guarantee insertion order, so you also can't use a HashSet if maintaining some sort of ordering is important.
