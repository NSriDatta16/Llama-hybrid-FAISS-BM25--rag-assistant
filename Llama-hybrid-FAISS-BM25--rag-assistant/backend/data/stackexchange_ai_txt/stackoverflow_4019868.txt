[site]: stackoverflow
[post_id]: 4019868
[parent_id]: 3265987
[tags]: 
Ok, so looking at the cvhough.cpp file, the structure CvLinePolar is only defined by rho and angle. This is all that is passed back as a result of our call to HoughLines. I am in the process of modifying the c++ file and see if i can get the votes out. Update oct 26: just realized these are not really answers but more like questions. apparently frowned upon. I found some instructions on recompiling OpenCV. I guess we'll have to go in the code and modify it and recompile. How to install OpenCV 2.0 on win32 update Oct 27: well, i failed at compiling the dlls for OpenCV with my new code so I ended up copy-pasting the specific parts I want to modify into my own files. I like to add new functions so to avoid overloading the already defined functions. There are 4 main things you need to copy over: 1- some random defines #define hough_cmp_gt(l1,l2) (aux[l1] > aux[l2]) static CV_IMPLEMENT_QSORT_EX( icvHoughSortDescent32s, int, hough_cmp_gt, const int* ) 2- redefining the struct for line parameters typedef struct CvLinePolar2 { float rho; float angle; float votes; } CvLinePolar2; 3- the main function that was modified static void icvHoughLinesStandard2( const CvMat* img, float rho, float theta, int threshold, CvSeq *lines, int linesMax ) { cv::AutoBuffer _accum, _sort_buf; cv::AutoBuffer _tabSin, _tabCos; const uchar* image; int step, width, height; int numangle, numrho; int total = 0; float ang; int r, n; int i, j; float irho = 1 / rho; double scale; CV_Assert( CV_IS_MAT(img) && CV_MAT_TYPE(img->type) == CV_8UC1 ); image = img->data.ptr; step = img->step; width = img->cols; height = img->rows; numangle = cvRound(CV_PI / theta); numrho = cvRound(((width + height) * 2 + 1) / rho); _accum.allocate((numangle+2) * (numrho+2)); _sort_buf.allocate(numangle * numrho); _tabSin.allocate(numangle); _tabCos.allocate(numangle); int *accum = _accum, *sort_buf = _sort_buf; float *tabSin = _tabSin, *tabCos = _tabCos; memset( accum, 0, sizeof(accum[0]) * (numangle+2) * (numrho+2) ); for( ang = 0, n = 0; n threshold && accum[base] > accum[base - 1] && accum[base] >= accum[base + 1] && accum[base] > accum[base - numrho - 2] && accum[base] >= accum[base + numrho + 2] ) sort_buf[total++] = base; } // stage 3. sort the detected lines by accumulator value icvHoughSortDescent32s( sort_buf, total, accum ); // stage 4. store the first min(total,linesMax) lines to the output buffer linesMax = MIN(linesMax, total); scale = 1./(numrho+2); for( i = 0; i 4- the function that calls that function CV_IMPL CvSeq* cvHoughLines3( CvArr* src_image, void* lineStorage, int method, double rho, double theta, int threshold, double param1, double param2 ) { CvSeq* result = 0; CvMat stub, *img = (CvMat*)src_image; CvMat* mat = 0; CvSeq* lines = 0; CvSeq lines_header; CvSeqBlock lines_block; int lineType, elemSize; int linesMax = INT_MAX; int iparam1, iparam2; img = cvGetMat( img, &stub ); if( !CV_IS_MASK_ARR(img)) CV_Error( CV_StsBadArg, "The source image must be 8-bit, single-channel" ); if( !lineStorage ) CV_Error( CV_StsNullPtr, "NULL destination" ); if( rho type ) || (mat->rows != 1 && mat->cols != 1) ) CV_Error( CV_StsBadArg, "The destination matrix should be continuous and have a single row or a single column" ); if( CV_MAT_TYPE( mat->type ) != lineType ) CV_Error( CV_StsBadArg, "The destination matrix data type is inappropriate, see the manual" ); lines = cvMakeSeqHeaderForArray( lineType, sizeof(CvSeq), elemSize, mat->data.ptr, mat->rows + mat->cols - 1, &lines_header, &lines_block ); linesMax = lines->total; cvClearSeq( lines ); } else CV_Error( CV_StsBadArg, "Destination is not CvMemStorage* nor CvMat*" ); iparam1 = cvRound(param1); iparam2 = cvRound(param2); switch( method ) { case CV_HOUGH_STANDARD: icvHoughLinesStandard2( img, (float)rho, (float)theta, threshold, lines, linesMax ); break; default: CV_Error( CV_StsBadArg, "Unrecognized method id" ); } if( mat ) { if( mat->cols > mat->rows ) mat->cols = lines->total; else mat->rows = lines->total; } else result = lines; return result; } And i guess you could uninstall opencv so it takes off all those automatic path setting and recompile it yourself using the CMake method and then the OpenCV is really whatever you make it.
