[site]: stackoverflow
[post_id]: 4805180
[parent_id]: 4803646
[tags]: 
This is a difficult one. The following knowledge is totally useless and nobody should care to posses: First thing to fix is the type of swap . The input type should not be Entry , because then it cannot accept Entry , which is not a subtype of E . However, E is a subtype of E . So our transformer should take that as input. For the output, no wild card, because the transformer can only instantiate a concrete type anyway. We just want to be honest and accurate of what can be consumed and what will be produced: /* */ Transformation , Entry > swap = new Transformation , Entry > () { public Entry apply( Entry sourceObject) { return new Pair ( sourceObject.getValue().intValue(), sourceObject.getKey() ); } }; Note String is final and nobody extends it, but I'm afraid the generic system isn't that smart to know that, so as a matter of principle, I did ? extends String anyway, for later good. Then, let's think about remapEntries() . We suspect that most transformers pass to it will have similar type declaration as the swap , because of the justifications we laid out. So we better have remapEntry( Transformation , Entry > f, ... to properly match that argument. From there, we work out the type of source and result, we want them to be as general as possible: public static > RM remapEntries( Transformation , Entry > f, Map source, RM result ) { for(Entry entry : source.entrySet()) { Entry res = f.apply(entry); result.put(res.getKey(), res.getValue()); } return result; } RM isn't necessary, it's fine to use directly Map . But it seems that you want the return type identical to the result type in caller's context. I woulda simply made the return type void - there is enough trouble already. This thing will fail, if swap does not use ? extends . For example if the input type is String-Integer , it's ridiculous to do ? extends of them. But you can have a overloading method with different parameter type declaration to match this case. Ok, that worked, out of sheer luck. But, it is totally not worth it. Your life is much better if you just forget about it, and use raw type, document the parameters in English, do type check at runtime. Ask yourself, does the generic version buy you anything? Very little, at the huge price of rendering your code completely incomprehensible. Nobody, including yourself, and myself, could make sense of it if we read the method signature tomorrow morning. It is much much worse than regex.
