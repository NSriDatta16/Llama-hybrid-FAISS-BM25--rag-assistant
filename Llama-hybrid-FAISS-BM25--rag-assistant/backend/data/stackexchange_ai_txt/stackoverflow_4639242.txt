[site]: stackoverflow
[post_id]: 4639242
[parent_id]: 4639203
[tags]: 
If you're only using the 'public key' (which isn't actually a public key, it's a nonce , and should really be random, unless you really want it to be usable over a certain timeframe, in which case make sure you use HMAC with a secret key to generate it so an adversary cannot predict the nonce ) to prevent replay attacks , and it's a fixed size, then concatenation might not be a problem. That said, I'm a bit concerned that you might not have a well-thought-out security model. What attack is this trying to prevent, anyway? The user's password hash is unsalted, so a break of your password database will reveal plaintext passwords easily enough anyway, and although having a time-limited nonce will mitigate replay attacks from a passive sniffer, such a passive sniffer could just steal the user's session key anyway. Speaking of which, why not just use the session key as the nonce instead of a timestamp-based system? But really, why not just use SSL? Cryptography is really hard to get right, and people much smarter than you or I have spent decades reviewing SSL's security to get it right. Edit : If you're worried about MITM attacks, then nothing short of SSL will save you. Period. Mallory can just replace your super-secure login form with one that sends the password in plaintext to him. Game over. And even a passive attacker can see everything going over the wire - including your session cookie . Once Eve has the session cookie, she just injects it into her browser and is already logged in. Game over. If you say you can't use SSL, you need to take a very hard look at exactly what you're trying to protect, and what kinds of attacks you will mitigate. You're going to probably need to implement a desktop application of some sort to do the cryptography - if MITMs are going around, then you cannot trust ANY of your HTML or Javascript - Mallory can replace them at will. Of course, your desktop app will need to implement key exchange, encryption and authentication on the data stream, plus authentication of the remote host - which is exactly what SSL does . And you'll probably use pretty much the same algorithms as SSL to do it, if you do it right. If you decide MITMs aren't in scope, but you want to protect against passive attacks, you'll probably need to implement some serious cryptography in Javascript - we're talking about a Diffie-Hellman exchange to generate a session key that is never sent across the wire ( HTML5 Web storage , etc), AES in Javascript to protect the key, etc. And at this point you've basically implemented half of SSL in Javascript, only chances are there are more bugs in it - not least of which is the problem that it's quite hard to get secure random numbers in Javascript. Basically, you have the choice between: Not implementing any real cryptographic security (apparently not a choice, since you're implementing all these complex authentication protocols) Implementing something that looks an awful lot like SSL, only probably not as good Using SSL. In short - if security matters, use SSL . If you don't have SSL, get it installed . Every platform that I know of that can run JS can also handle SSL, so there's really no excuse.
