[site]: stackoverflow
[post_id]: 453466
[parent_id]: 453432
[tags]: 
ISO/IEC 9899:TC3 6.7.8, paragraph 21: If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration. Arrays with static storage duration are initialized to 0 , so the C99 spec guarantees the not explicitly initialized array elements to be set to 0 as well. In my first edit to this post, I spouted some nonsense about using compound literals to assign to an array after initialization. That does not work. If you really want to use compound literals to set an array's values, you have to do something like this: #define count(ARRAY) (sizeof(ARRAY)/sizeof(*ARRAY)) int foo[16]; memcpy(foo, ((int [count(foo)]){ 1, 2, 3 }), sizeof(foo)); With some macro magic and the non-standard __typeof__ operator, this can be considerably shortened: #define set_array(ARRAY, ...) \ memcpy(ARRAY, ((__typeof__(ARRAY)){ __VA_ARGS__ }), sizeof(ARRAY)) int foo[16]; set_array(foo, 1, 2, 3);
