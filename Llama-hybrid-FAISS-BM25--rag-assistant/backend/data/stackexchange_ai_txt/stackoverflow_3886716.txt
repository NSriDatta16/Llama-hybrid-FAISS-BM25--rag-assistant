[site]: stackoverflow
[post_id]: 3886716
[parent_id]: 3886626
[tags]: 
Not sure what your real problem might be but it looks all wrong. The managed wrapper should be a pretty close facsimile to the unmanaged one. Let's work from an unmanaged declaration like this: class Unmanagedclass { public: Unmanagedclass(const char* arg) {} void mumble() {} }; Then your wrapper ought to resemble this: #pragma managed(push, off) #include "unmanagedclass.h" #pragma managed(pop) using namespace System; using namespace System::Runtime::InteropServices; public ref class ManagedWrapper { Unmanagedclass* instance; public: ManagedWrapper(String^ arg) { IntPtr mem = Marshal::StringToCoTaskMemAnsi(arg); instance = new Unmanagedclass((char*)(void*)mem); Marshal::FreeCoTaskMem(mem); } ~ManagedWrapper() { delete instance; instance = 0; } !ManagedWrapper() { delete instance; } void mumble() { instance->mumble(); } }; The recipe here is that the instance of the unmanaged class is a pointer in the wrapper. And just delegate the managed method calls to the unmanaged one. Yes, some hokeypokey with strings, as shown. And making sure that this native instance gets deleted when either the user or the garbage collector gets around to it.
