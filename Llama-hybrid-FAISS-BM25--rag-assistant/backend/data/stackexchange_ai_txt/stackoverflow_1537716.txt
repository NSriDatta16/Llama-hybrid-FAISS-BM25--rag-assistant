[site]: stackoverflow
[post_id]: 1537716
[parent_id]: 1501132
[tags]: 
I was looking for something similar and all I could achieve was expanding the rows to the number of item counts in a transaction, and grouping them into bins. Not very elegant though.. Moreover, because string aggregation is still very cumbersome in SQL Server (Oracle, i miss you!), I have to leave the last part out. I mean putting the counts in one single row.. My solution is as follows: Example transactions table: INSERT INTO transactions (trans_id, item, cnt) VALUES ('1','A','50'), ('2','A','140'), ('3','B','100'), ('4','C','80'); GO Create a dummy sequence table, which contains numbers from 1 to 1000 (I assume that maximum number allowed for an item in a single transaction is 1000): CREATE TABLE numseq (n INT NOT NULL IDENTITY) ; GO INSERT numseq DEFAULT VALUES ; WHILE SCOPE_IDENTITY() Now we can generate a temporary table from transactions table, in which each transaction and item exist "cnt" times in a subquery, and then give numbers to the bins using division, and group by bin number: SELECT bin_nr, item, count(*) count_in_bin INTO result FROM ( SELECT t.item, ((row_number() over (order by t.item, s.n) - 1) / 160) + 1 as bin_nr FROM transactions t INNER JOIN numseq s ON t.cnt >= s.n -- join conditionally to repeat transaction rows "cnt" times ) a GROUP BY bin_id, item ORDER BY bin_id, item GO Result is: bin_id item count_in_bin 1 A 160 2 A 30 2 B 100 2 C 30 3 C 50 In Oracle, the last step would be as simple as that: SELECT bin_id, WM_CONCAT(CONCAT(item,'(',count_in_bin,')')) contents FROM result GROUP BY bin_id
