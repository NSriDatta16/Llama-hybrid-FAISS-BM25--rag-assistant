[site]: stackoverflow
[post_id]: 4128024
[parent_id]: 4127959
[tags]: 
You can also use ReflectionFunctionAbstract::isClosure â€” Checks if closure Example: $poorMansLambda = create_function('', 'return TRUE;'); $rf = new ReflectionFunction($poorMansLambda); var_dump( $rf->isClosure() ); // FALSE $lambda = function() { return TRUE; }; $rf = new ReflectionFunction($lambda); var_dump( $rf->isClosure() ); // TRUE $closure = function() use ($lambda) { return $lambda(); }; $rf = new ReflectionFunction($closure); var_dump( $rf->isClosure() ); // TRUE Note that the above will only return TRUE for PHP 5.3 Lambdas and Closures. If you just want to know whether an argument can be used as a callback, is_callable will perform better. EDIT If you want to include Functors as well, you can do ( as of PHP 5.3.3 ) $rf = new ReflectionObject($functorOrClosureOrLambda); var_dump( $rf->hasMethod('__invoke') ); // TRUE or method_exists($functorOrClosureOrLambda, '__invoke'); with the latter being the faster alternative. A Closure instance is basically just a class that has an __invoke function which you fed the method body on the fly. But since this is testing for an implementation detail, I'd say it is as unreliable as testing for the Closure Class Name. EDIT Since you mention you cannot reliably test via the Reflection API due to it raising an error when passing a Functor to ReflectionFunctionAbstract::isClosure , try if the following solution suits your needs: function isClosure($arg) { if(is_callable($arg, FALSE, $name)) { is_callable(function() {}, TRUE, $implementation); return ($name === $implementation); } } This will check if the passed argument is callable. The $name argument stores the callable name. For closures, this is currently Closure::__invoke . Since this will be the same for any Closures/Lambdas, we can compare the name of the passed argument against an arbitrary other Closure/Lambda. If they are equal, the argument must be a Closure/Lambda. Determining the callable name at runtime has the added benefit that you dont have to hardcode assumptions about the implementation details into your sourcecode. Passing a functor will return FALSE , because it wont have the same callable name. Since this does not rely on the Reflection API, it is also likely a bit faster. The above could be more elegantly written as function isClosure($arg) { $test = function(){}; return $arg instanceof $test; }
