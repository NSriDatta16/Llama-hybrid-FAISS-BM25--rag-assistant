[site]: stackoverflow
[post_id]: 5508946
[parent_id]: 5508765
[tags]: 
Is it worth using a trigger? If whatever your XAML element is for the collection (listbox, grid, etc) is bound to a property exposing a collection on your viewmodel, you can leverage both databinding and the built-in MVVM Light messenger to notify you of a property change with both old and new values in a more MVVM-friendly way. This example isn't necessarily WP7-specific, but I think it would work the same. For example, this might be the databound collection: public const string BillingRecordResultsPropertyName = "BillingRecordResults"; private ObservableCollection _billingRecordResults = null; public ObservableCollection BillingRecordResults { get { return _billingRecordResults; } set { if (_billingRecordResults == value) { return; } var oldValue = _billingRecordResults; _billingRecordResults = value; // Update bindings and broadcast change using GalaSoft.MvvmLight.Messenging RaisePropertyChanged(BillingRecordResultsPropertyName, oldValue, value, true); } } I like to expose a property on my ViewModel that is a "selected item" of whatever collection I'm exposing. So, to the ViewModel, I would add this property using the MVVMINPC snippet: public const string SelectedBillingRecordPropertyName = "SelectedBillingRecord"; private BillingRecord _selectedBillingRecord = null; public BillingRecord SelectedBillingRecord { get { return _selectedBillingRecord; } set { if (_selectedBillingRecord == value) { return; } var oldValue = _selectedBillingRecord; _selectedBillingRecord = value; // Update bindings and broadcast change using GalaSoft.MvvmLight.Messenging RaisePropertyChanged(SelectedBillingRecordPropertyName, oldValue, value, true); } } Now, if you bind the SelectedItem of the XAML element to this exposed property, it will populate when selected in the View via databinding. But even better, when you leverage the snippet MVVMINPC, you get to choose whether or not to broadcast the results to anyone listening. In this case, we want to know when the SelectedBillingRecord property changes. So, you can have this in the constructor for your ViewModel: Messenger.Default.Register >(this, br => SelectedRecordChanged(br.NewValue)); And elsewhere in your ViewModel, whatever action you want to have happen: private void SelectedRecordChanged(BillingRecord br) { //Take some action here } Hope this helps...
