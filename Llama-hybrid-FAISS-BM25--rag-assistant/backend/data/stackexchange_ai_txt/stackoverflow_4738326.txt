[site]: stackoverflow
[post_id]: 4738326
[parent_id]: 4736018
[tags]: 
IMHO volatile/AtomicInteger is faster than synchronized in a multi-threaded context. In a single threaded micro-benchmark they are much the same. Part of the reson for this is that synchronized is a OS call whereas volatile is entirely user space. I get this output from the following program on Java 6 update 23. Average time to synchronized++ 10000000 times. was 110368 us Average time to synchronized on the class ++ 10000000 times. was 37140 us Average time to volatile++ 10000000 times. was 19660 us I cannot explain why synchronizing on the class is faster than a plain object. Code: static final Object o = new Object(); static int num = 0; static final AtomicInteger num2 = new AtomicInteger(); public static void main(String... args) throws InterruptedException { final int runs = 10 * 1000 * 1000; perfTest(new Runnable() { public void run() { for (int i = 0; i
