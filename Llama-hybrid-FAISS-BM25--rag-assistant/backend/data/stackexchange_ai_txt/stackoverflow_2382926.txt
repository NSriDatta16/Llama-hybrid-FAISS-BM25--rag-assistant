[site]: stackoverflow
[post_id]: 2382926
[parent_id]: 612141
[tags]: 
Well, this was asked a long time ago but I have a working answer. public static IList ExecuteQuery (HqlBasedQuery query) where T : new() { query.SetResultTransformer(new NHibernate.Transform.AliasToBeanResultTransformer(typeof(T))); var results = (ArrayList)ActiveRecordMediator.ExecuteQuery(query); List list = new List (results.Count); for (int i = 0; i This will give you back results of type T. Type T can be anything you want. Type T needs a no argument constructor and it needs public fields or properties that match the column names or aliases in the query you build. We do this all the time. Particularly when you want to use aggregate function in HQL to produce aggregate data. A companion function will allow you to just pass in your query as a string as well as any positional parameters you might have: public static IList ExecuteQuery (string hqlQuery, params object[] parameters) where T : new() { return ExecuteQuery (new HqlBasedQuery(typeof(U), hqlQuery, parameters)); } Type U is any type that is a valid ActiveRecord type. It doesn't even have to be one of the types you are referencing. If you want you could replace it will some type you know is gonna be valid int he session and ditch the extra parameter.
