[site]: stackoverflow
[post_id]: 2249716
[parent_id]: 
[tags]: 
How to design a class where the user/caller has options to provide a custom behavior using a custom class

I encounters a problem where I want to have a class in which its behavior can be customized by another class, for example, Foo's constructor accepts a parameter of some type of class: class Bar { //The default class that define behavior }; template class Foo { public: Foo(T* t = 0) t_(t) { if (t_ == 0) t_ = new T(); } ~Foo() { delete t_; } } Now if someone use Foo in a client code: Foo foo; Everything is fine. But, if we want to supply the custom class: class Bar1 { }; Foo foo(new Bar1()); // This is OK Bar1 b; Foo foo(&b); // Error, b is not dynamically allocated Is there any design pattern I can use to prevent this kind of mistakes? Or, is there any techniques or semantics where the user of Foo class can choose/specify who owns the bar object? So for example, the above Foo destructor can be like this: ~Foo() { if (t_ is owned by this object) delete t_; } Bar or Bar1 or any class passed as t in Foo(T* t) might be a big object, so if it is possible I rather not to pass it by value. Update: What I have in mind is for the user to be able to do something like: Foo foo(new Bar(1, 2, etc..)); //or this: Bar bar(1, 2, etc..); Foo foo(bar); But if bar is a big object (for example, contains an array), then it would be inefficient to pass bar by value. The only way is to have bar passed by reference or pointer, but I also want the user to be able to use bar with parameterized constructor, and hence my confusion began. Regarding to the auto variable scope, it would be safe if a user do something like: int main() { Bar1 bar1(1,2,3); Foo foo(&bar1); return 0; } As long as Foo does not delete bar1.
