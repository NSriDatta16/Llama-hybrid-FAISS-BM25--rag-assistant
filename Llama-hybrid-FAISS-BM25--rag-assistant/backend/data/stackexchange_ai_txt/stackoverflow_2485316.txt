[site]: stackoverflow
[post_id]: 2485316
[parent_id]: 2485253
[tags]: 
This sort of inheritance is always a bit trick with relational databases. What you have is one approach and it is the most traditional approach to the problem. You end up doing a lot of crossing of tables, but that might be just fine. Another approach is to employ some denormalization and collapse the tables into one table. Include a type field which represents the type of the item and then have the union of the fields all in that table. So you would have a table like ID | GUID Type | GUID [FK] Name | nvarchar(64) State | int [FK] ZipCode | int Address | nvarchar(64) Name | varchar(64) Url | nvarchar(2048) Store | GUID [ FK ] Details | GUID [FK] ... This means you have a bunch of empty fields in your table. You could also take a more fragmented approach and construct your tables like Item: ID | GUID ItemPropertyType: ID | GUID Name | nvarchar(50) ItemProperty: ID | GUID ItemID | GUID [FK] ItemPropertyTypeID | GUID charValue | varchar(64) Each item property references an item. To construct an item you simply gather up the ItemProperties which it owns. If you wanted to find all items where Name was 'bill' then you could do select ItemID from ItemProperties ip, ItemPropertyTypes ipn where ipn.ID = ip.ItemPropertyTypeID and ipt.Name='Name' and ip.charValue='bill' Jeff actually blogged a bit about this topic http://www.codinghorror.com/blog/2008/07/maybe-normalizing-isnt-normal.html
