[site]: stackoverflow
[post_id]: 3653977
[parent_id]: 3641122
[tags]: 
Found the bug: What could cause this to start miscalculating after awhile? New code: private static Move GetBestMove(Color color, Board board, int depth) { var bestMoves = new List (); IEnumerable validMoves = board.GetValidMoves(color); int highestScore = int.MinValue; Board boardAfterMove; int tmpScore; var rand = new Random(); Debug.WriteLine("{0}'s Moves:", color); foreach (Move move in validMoves) { boardAfterMove = board.Clone().ApplyMove(move); if (move.IsJump && !move.IsCrowned && boardAfterMove.GetJumps(color).Any()) tmpScore = NegaMax(color, boardAfterMove, depth); else tmpScore = -NegaMax(Board.Opposite(color), boardAfterMove, depth); Debug.WriteLine("{0}: {1}", move, tmpScore); if (tmpScore > highestScore) { bestMoves.Clear(); bestMoves.Add(move); highestScore = tmpScore; } else if (tmpScore == highestScore) { bestMoves.Add(move); } } return bestMoves[rand.Next(bestMoves.Count)]; } private static int NegaMax(Color color, Board board, int depth) { IEnumerable validMoves = board.GetValidMoves(color); int highestScore = int.MinValue; Board boardAfterMove; if (depth ().Sum(c => (c.Color == color ? 1 : -1) * (c.Class == Class.Man ? 2 : 3)); } I'm not 100% convinced this works perfectly. It seems to work for depth 0, and usually for depth 1... beyond that, I have no idea what the computer is thinking. Still doesn't appear to play super intelligently. Edit: Running this and max speed... NegaMax agent vs Random. NegaMax always wins. Watching the scores for occurrences of "1000". He always wins within a few turns after that, so it does appear to be working, finally!
