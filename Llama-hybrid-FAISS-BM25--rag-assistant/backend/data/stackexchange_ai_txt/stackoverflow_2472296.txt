[site]: stackoverflow
[post_id]: 2472296
[parent_id]: 
[tags]: 
What is the general feeling about reflection extensions in std::type_info?

I've noticed that reflection is one feature that developers from other languages find very lacking in c++. For certain applications I can really see why! It is so much easier to write things like an IDE's auto-complete if you had reflection. And certainly serialization APIs would be a world easier if we had it. On the other side, one of the main tenets of c++ is don't pay for what you don't use. Which makes complete sense. That's something I love about c++. But it occurred to me there could be a compromise. Why don't compilers add extensions to the std::type_info structure? There would be no runtime overhead. The binary could end up being larger, but this could be a simple compiler switch to enable/disable and to be honest, if you are really concerned about the space savings, you'll likely disable exceptions and RTTI anyway. Some people cite issues with templates, but the compiler happily generates std::type_info structures for template types already. I can imagine a g++ switch like -fenable-typeinfo-reflection which could become very popular (and mainstream libs like boost/Qt/etc could easily have a check to generate code which uses it if there, in which case the end user would benefit with no more cost than flipping a switch). I don't find this unreasonable since large portable libraries like this already depend on compiler extensions. So why isn't this more common? I imagine that I'm missing something, what are the technical issues with this? EDIT: Just a few metrics re-the bloat argument: I've looked at a fairly large Qt project (about 45,000 LoC) and measures the size of the metaObjects. I feel this is a reasonable metric because the Qt moc system is a fairly exhaustive reflection system (types, functions, enumerations, members and a few Qt specific concepts like "properties"). There were 67 metaobjects total , so not a trivial amount but nothing crazy, which added up to 5479 bytes . However almost all of them were 32-bytes or less ( the largest being 1427 bytes ). Considering that modern compilers produce binaries of upwards of 4K for even the simplest program, this these numbers aren't outrageous). Though I'd love to see something like this applied to the STL to see how it fairs.
