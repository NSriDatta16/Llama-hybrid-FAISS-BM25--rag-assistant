[site]: stackoverflow
[post_id]: 4142822
[parent_id]: 4140727
[tags]: 
Code-as-data is actually only one side of the coin. The other is data-as-code . The possibility to embed arbitrary data in Lisp code and load and reload it on the fly makes it (the data) very convenient to handle because it can eliminate any potential impedance mismatch between the way the data is represented and the way the code works. Let me give you an example. Let's say you want to write some kind of computer game with various monster classes. You have basically two choices: model the monster classes within your programming language or use a data-driven approach where the class descriptions are read from, say, an XML file. Doing the modelling within the programming language has the benefits of ease of use and simplicity (which is always a good thing). It's also easy to specify custom behaviour depending on the monster class as needed. Finally, the implementation is probably pretty optimised. On the other hand, loading everything from data files is much more flexible. You can do multiple inheritance where the language doesn't support it; you can do dynamic typing; you can load and reload things at run-time; you can use simple, to-the-point, domain-specific syntax, and much more. But now you need to write some kind of runtime environment for the whole thing, and specifying behaviour means either splitting the data up between the data files and the game code or embedding a scripting language, which is yet another layer of incidental complexity. Or you can do it the Lisp way: specify your own sublanguage, translate that into code, and execute it. If the programming language you're using is sufficiently dynamic and syntactically flexible, you get all the benefits from using a data-driven approach (since code is data) combined with the simplicity of keeping everything in the code (since data is code). This isn't specific to Lisp, by the way. There are various shades of code-data-equivalence gray in between Lisp and, say, C++. Ruby, for example, makes embedding data within the application easier than Python does, and Python makes it easier than Java does. Both data-as-code and code-as-data are more of a continuum than they are either-or questions.
