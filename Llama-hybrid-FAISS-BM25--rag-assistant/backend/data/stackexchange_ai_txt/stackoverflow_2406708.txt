[site]: stackoverflow
[post_id]: 2406708
[parent_id]: 2406506
[tags]: 
Here is a really ridiculous solution that I would probably use (bear in mind, ocdcoder's answer works just fine), to make sure I accounted for all possible line endings: $line_ends = array("\r\n", "\r", "\n"); //notice the order is important. $new_msg = str_replace($line_ends, " ", $orig_msg); This way, if there are double line ends, it gets rid of them, but if not, it goes back and checks for single line endings. But if you want to get more complicated, you could replace your possible carriage-returns with line-ends: $msg_newline_fix = str_replace("\r", "\n", $orig_message); $msg_double_newline_fix = str_replace("\n\n", "\n", $msg_newline_fix); $newmsg = str_replace("\n", " ", $msg_double_newline_fix); But again, I'm a bit wacky like that. Another crazy solution might be: $msg_newline_fix = str_replace("\r", "\n", $orig_message); $msg_array_lines = explode("\n", $msg_newline_fix); foreach($msg_array_lines as $msg_line){ $clean_line = rtrim($msg_line); if($clean_line !== '') { $msg_clean_array[] = $clean_line; } } $new_msg = implode(" ", $msg_clean_array); But if you know your line endings will be new lines ( \n ) and not carriage returns ( \r ) then you are probably safe with a simple one line str_replace. Finally, you might actually want to preserve line endings when it indicates a new paragraph, something like: Hello World! This is a new paragraph. In which case, I would suggest normalizing the line-endings first (making it consistently the same thing so we aren't guessing) and then replacing those empty lines with some kind of safe token you can go back and replace with your new line. Something like: $msg_carriage_fix = str_replace("\r", "\n\n", $orig_message); $msg_double_carriage_fix = str_replace("\n\n\n", "\n\n", $msg_newline_fix); Now we are at the point where we know each line, including empty lines, have only one \n at the end. By replacing the potential \r with two \n , and then replacing only three \n in a row with two \n we avoid the risk of removing any line endings if there were no carriage-return \r s in the first place. Then we can finally do: $msg_hold_true_linebreaks = str_replace("\n\n", "%line-break%", $msg_double_carriage_fix); $msg_strip_new_lines = str_replace("\n"," ",$msg_hold_true_linebreaks); and last but not least: $new_msg = str_replace("%line-break%","\n",$msg_strip_new_lines); But,that is only if you really want to keep those true line-breaks and if you want to be extra sure you are ready for carriage-returns, line-ends, and the dreaded \r\n . I would show yet another version that may shorter and involves using implode and explode, but I'm sure that's enough for now. edit Here is a slightly simpler version of that last suggestion, which tries to account for both line endings and intentional line breaks: $msg_rn_fix = str_replace("\r\n", "\n", $orig_msg); $msg_r_fix = str_replace("\r", "\n", $msg_rn_fix); We now know each line ends with a single \n , including empty lines... $msg_array = explode("\n", $msg_r_fix); Normal lines each get an array value, but we also know that if the array value is nothing, that it was an intentional hard return... foreach($msg_array as $msg_line) { $clean_msg_lines[] = ($msg_line == '') ? "\n" : $msg_line; } then we put it all back together: $new_msg = implode(" ", $clean_msg_lines); The only flaw is that there will be an extra space before and after each line end. This is easily fixed: $new_msg = str_replace(" \n ", "\n", $new_msg); I like this last solution so much, I'm going to copy it below without commentary. My favorite version $msg_rn_fix = str_replace("\r\n", "\n", $orig_msg); $msg_r_fix = str_replace("\r", "\n", $msg_rn_fix); $msg_array = explode("\n", $msg_r_fix); foreach($msg_array as $msg_line) { $clean_msg_lines[] = ($msg_line == '') ? "\n" : $msg_line; } $new_msg = implode(" ", $clean_msg_lines); $new_msg = str_replace(" \n ", "\n", $new_msg);
