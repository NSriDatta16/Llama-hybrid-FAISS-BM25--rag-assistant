[site]: stackoverflow
[post_id]: 2532432
[parent_id]: 2532350
[tags]: 
There is no fixed information which would record such a data, because SHA1 are not associated at all time with a ref path. Branches can moves, be renamed or deleted, while the SHA1 will still be stored (except if it is not referenced by any ref pattern, it will eventually be pruned) That being said: git show-ref |grep yourSHA1|awk "{print $2}" git show-ref --heads --tags -d |grep yourSHA1|awk "{print $2}" comes pretty close to what yout want: C:\Prog\Git\tests\rep\main5>git show-ref | grep f4a071 | awk "{print $2}" refs/heads/master refs/remotes/origin/HEAD refs/remotes/origin/master A lot of options are available for git show-ref and will allow you to: display also dereferenced SHA1 display SHA1 only for a pattern of refs The OP adds: it will return nothing at all if a SHA passed does not reference a head or any other dereferencable commit? Do you have an idea how we could do the intermediary step of figuring out the SHA of the most recent commit belonging to the same branch as the SHA passed? One other plumbing command that can help would be git name-rev : C:\Prog\Git\tests\rep\main5>git name-rev a7768453 a7768453 patches~1 C:\Prog\Git\tests\rep\main5>git name-rev a7768453|gawk "{gsub(/~.*/,\"\",$2);print $2} patches As Jefromi mentions in the comments, a porcelain command would be git branch --contain : C:\Prog\Git\tests\rep\main5>git branch --contain 1e73e369 master * patches tmp --contains Only list branches which contain the specified commit. It is used to find all branches which will need special attention if were to be rebased or amended, since those branches contain the specified .
