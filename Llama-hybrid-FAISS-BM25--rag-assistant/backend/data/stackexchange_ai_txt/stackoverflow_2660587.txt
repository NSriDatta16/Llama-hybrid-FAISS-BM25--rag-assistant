[site]: stackoverflow
[post_id]: 2660587
[parent_id]: 2660554
[tags]: 
I suspect many values aren't strings. So the first thing you can do is to get rid of the string object if you don't need it. Put it into an union. Another thing is that probably many of your strings are only small, thus you can get rid of heap allocation if you save small strings in the object itself. LLVM has the SmallString template for that. And then you can use string interning, as another answer says too. LLVM has the StringPool class for that: Call intern("foo") and get a smart pointer refering to a shared string potentially used by other myInterpreterValue objects too. The union can be written like this class myInterpreterValue { boost::variant value; }; boost::variant does the type tagging for you. You can implement it like this, if you don't have boost. The alignment can't be gotten portably in C++ yet, so we push some types that possibly require some large alignment into the storage union. class myInterpreterValue { union Storage { // for getting alignment long double ld_; long long ll_; // for getting size int i1; char s1[sizeof(string)]; // for access char c; }; enum type { IntValue, StringValue } m_type; Storage m_store; int *getIntP() { return reinterpret_cast (&m_store.c); } string *getStringP() { return reinterpret_cast (&m_store.c); } public: myInterpreterValue(string const& str) { m_type = StringValue; new (static_cast (&m_store.c)) string(str); } myInterpreterValue(int i) { m_type = IntValue; new (static_cast (&m_store.c)) int(i); } ~myInterpreterValue() { if(m_type == StringValue) { getStringP()->~string(); // call destructor } } string &asString() { return *getStringP(); } int &asInt() { return *getIntP(); } }; You get the idea.
