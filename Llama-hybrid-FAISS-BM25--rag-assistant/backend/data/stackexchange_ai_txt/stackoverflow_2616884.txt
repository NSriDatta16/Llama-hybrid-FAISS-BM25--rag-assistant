[site]: stackoverflow
[post_id]: 2616884
[parent_id]: 2616751
[tags]: 
Youre on the right track. The first parameter of your extension method WithProperty has to be of the type IQueryable , not IQueryable . Anyways you dont need an extension method for the IQueryable . Just use your Contains method in a lambda for filtering. This should work: List searchStrs = new List () { "text2", "text4" } IEnumerable myFilteredObjects = dataContext.MyObjects .Where(myObj => myObj.MyProperty.Contains(searchStrs, ' ')); Update: The above code snippet does not work. This is because the Contains method can not be converted into a SQL statement. I thought a while about the problem, and came to a solution by thinking about 'how would I do that in SQL?': You could do it by querying for each single keyword, and unioning all results together. Sadly the deferred execution of Linq-to-SQL prevents from doing that all in one query. So I came up with this compromise of a compromise. It queries for every single keyword. That can be one of the following: equal to the string in between two seperators at the start of the string and followed by a seperator or at the end of the string and headed by a seperator This spans a valid expression tree and is translatable into SQL via Linq-to-SQL. After the query I dont defer the execution by immediatelly fetch the data and store it in a list. All lists are unioned afterwards. public static IEnumerable ContainsOneOfTheseKeywords( this IQueryable qry, List keywords, char sep) { List > parts = new List >(); foreach (string keyw in keywords) parts.Add(( from obj in qry where obj.MyProperty == keyw || obj.MyProperty.IndexOf(sep + keyw + sep) != -1 || obj.MyProperty.IndexOf(keyw + sep) >= 0 || obj.MyProperty.IndexOf(sep + keyw) == obj.MyProperty.Length - keyw.Length - 1 select obj).ToList()); IEnumerable union = null; bool first = true; foreach (List part in parts) { if (first) { union = part; first = false; } else union = union.Union(part); } return union.ToList(); } And use it: List searchStrs = new List () { "text2", "text4" }; IEnumerable myFilteredObjects = dataContext.MyObjects .ContainsOneOfTheseKeywords(searchStrs, ' '); That solution is really everything else than elegant. For 10 keywords, I have to query the db 10 times and every time catch the data and store it in memory. This is wasting memory and has a bad performance. I just wanted to demonstrate that it is possible in Linq (maybe it can be optimized here or there, but I think it wont get perfect). I would strongly recommend to swap the logic of that function into a stored procedure of your database server. One single query, optimized by the database server, and no waste of memory. Another alternative would be to rethink your database design. If you want to query contents of one field (you are treating this field like an array of keywords, seperated by spaces), you may simply have chosen an inappropriate database design. You would rather want to create a new table with a foreign key to your table. The new table has then exactly one keyword. The queries would be much simpler, faster and more understandable.
