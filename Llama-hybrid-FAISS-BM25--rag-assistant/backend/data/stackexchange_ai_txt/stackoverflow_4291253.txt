[site]: stackoverflow
[post_id]: 4291253
[parent_id]: 
[tags]: 
Does this const initialization through const_cast have undefined behaviour?

According to my small tests this code works. But, does it have undefined behaviour? Modifying the const object through the use of const_cast resulted in run-time access violations in my previous tests, but I can't remember how they were different. So, is there fundamentally something wrong here or not? // test.h #pragma once #include typedef boost::array bigLut_t; extern const bigLut_t constBigLut; // test.cpp #include "test.h" bigLut_t& initializeConstBigLut() { bigLut_t* pBigLut = const_cast ( &constBigLut ); for(int i = 0; i at(i) = i; } return const_cast (constBigLut); } const bigLut_t constBigLut = initializeConstBigLut(); // const_test.cpp #include #include "test.h" void main() { for(int i = 0; i (Notice that sizeof(bigLut_t) is too much to fit into the stack.) EDIT: I actually like the idea in ybungalobill's small comment best for a method of initializing these big objects: // test.h #pragma once #include extern const struct BigLut : public boost::array { BigLut(); } constBigLut; // test.cpp #include "test.h" const BigLut constBigLut; BigLut::BigLut() { for(int i = 0; i at(i) = i; } }
