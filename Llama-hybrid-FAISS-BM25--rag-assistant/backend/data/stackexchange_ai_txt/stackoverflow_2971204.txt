[site]: stackoverflow
[post_id]: 2971204
[parent_id]: 2970721
[tags]: 
The real answer why: There's never been a compelling reason to make enums any more complicated than they are. If you need a simple closed list of values - they're it. In .Net, enums were given the added benefit of internal representation the string used to define them . This one little change adds some versioning downsides, but improves upon enums in C++. The enum keyword is used to declare an enumeration, a distinct type that consists of a set of named constants called the enumerator list. Ref: msdn Your question is with the chosen storage mechanism, an integer. This is just an implementation detail. We only get to peek beneath the covers of this simple type in order to maintain binary compatibility. Enums would otherwise have very limited usefulness. Q: So why do enums use integer storage? As others have pointed out: Integers are quick and easy to compare. Integers are quick and easy to combine (bitwise for [Flags] style enums) With integers, it's trivially easy to implement enums. * none of these are specific to .net, and it appears the CLR designers apparently didn't feel compelled to change anything or add any gold plating to them. Now that's not to saying your syntax isn't entirely unappealing. But is the effort to implement this feature in the CLR, and all the compilers, justified? For all the work that goes into this, has it really bought you anything you couldn't already achieve (with classes)? My gut feeling is no, there's no real benefit. (There's a post by Eric Lippert I wanted to link to, but I couldn't find it) You can write 10 lines of code to implement in user-space what you're trying to achieve without all the headache of changing a compiler. Your user-space code is easily maintained over time - although perhaps not quite as pretty as if it's built-in, but at the end of the day it's the same thing. You can even get fancy with a T4 code generation template if you need to maintain many of your custom enum-esque values in your project. So, enums are as complicated as they need to be.
