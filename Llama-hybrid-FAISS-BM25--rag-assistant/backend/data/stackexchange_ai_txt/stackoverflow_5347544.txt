[site]: stackoverflow
[post_id]: 5347544
[parent_id]: 5347444
[tags]: 
This is a community wiki answer for collecting snippets from the standard (draft 3225). section 13.3.3 "Best viable function" [over.match.best] Deﬁne ICSi(F) as follows: if F is a static member function, ICS1(F) is deﬁned such that ICS1(F) is neither better nor worse than ICS1(G) for any function G , and, symmetrically, ICS1(G) is neither better nor worse than ICS1(F); otherwise, let ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the type of the i-th parameter of viable function F . 13.3.3.1 deﬁnes the implicit conversion sequences and 13.3.3.2 deﬁnes what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another. Given these deﬁnitions, a viable function F1 is deﬁned to be a better function than another viable function F2 if for all arguments i , ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then for some argument j , ICSj(F1) is a better conversion sequence than ICSj(F2) or, if not that, the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of F2 to the destination type or, if not that, F1 is a non-template function and F2 is a function template specialization or, if not that, F1 and F2 are function template specializations, and the function template for F1 is more specialized than the template for F2 according to the partial ordering rules described in 14.5.6.2. If there is exactly one viable function that is a better function than all other viable functions, then it is the one selected by overload resolution; otherwise the call is ill-formed. section 13.3.3.1.4 "Reference binding" [over.ics.ref] When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion sequence is the identity conversion, unless the argument expression has a type that is a derived class of the parameter type, in which case the implicit conversion sequence is a derived-to-base conversion (13.3.3.1). If the parameter binds directly to the result of applying a conversion function to the argument expression, the implicit conversion sequence is a user-deﬁned conversion sequence (13.3.3.1.2), with the second standard conversion sequence either an identity conversion or, if the conversion function returns an entity of a type that is a derived class of the parameter type, a derived-to-base Conversion. When a parameter of reference type is not bound directly to an argument expression, the conversion sequence is the one required to convert the argument expression to the underlying type of the reference according to 13.3.3.1. Conceptually, this conversion sequence corresponds to copy-initializing a temporary of the underlying type with the argument expression. Any diﬀerence in top-level cv-qualiﬁcation is subsumed by the initialization itself and does not constitute a conversion. section 13.3.3.2 "Ranking implicit conversion sequences" [over.ics.rank] 13.3.3.2 deﬁnes a partial ordering of implicit conversion sequences based on the relationships better conversion sequence and better conversion. If an implicit conversion sequence S1 is deﬁned by these rules to be a better conversion sequence than S2 , then it is also the case that S2 is a worse conversion sequence than S1 . If conversion sequence S1 is neither better than nor worse than conversion sequence S2 , S1 and S2 are said to be indistinguishable conversion sequences. When comparing the basic forms of implicit conversion sequences (as deﬁned in 13.3.3.1) a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and a user-deﬁned conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3). Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of the following rules applies: Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form defined by 13.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is considered to be a subsequence of any non-identity conversion sequence) or, if not that, the rank of S1 is better than the rank of S2 , or S1 and S2 have the same rank and are distinguishable by the rules in the paragraph below or, if not that, S1 and S2 differ only in their qualification conversion and yield similar types T1 and T2 (4.4), respectively, and the cv-qualification signature of type T1 is a proper subset of the cv-qualification signature of type T2 . or, if not that, S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualiﬁer, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference.
