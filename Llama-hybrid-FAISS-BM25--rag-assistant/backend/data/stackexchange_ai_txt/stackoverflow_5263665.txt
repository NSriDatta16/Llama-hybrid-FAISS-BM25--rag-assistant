[site]: stackoverflow
[post_id]: 5263665
[parent_id]: 5262693
[tags]: 
When using reflection you should ask yourself a couple of questions first, because you may end up in an over-the-top complex solution that's hard to maintain: Is there a way to solve the problem using genericity or class/interface inheritance? Can I solve the problem using dynamic invocations (only .NET 4.0 and above)? Is performance important, i.e. will my reflected method or instantiation call be called once, twice or a million times? Can I combine technologies to get to a smart but workable/understandable solution? Am I ok with losing compile time type safety? Genericity / dynamic From your description I assume you do not know the types at compile time, you only know they share the interface ICalculation . If this is correct, then number (1) and (2) above are likely not possible in your scenario. Performance This is an important question to ask. The overhead of using reflection can impede a more than 400-fold penalty: that slows down even a moderate amount of calls. The resolution is relatively easy: instead of using Activator.CreateInstance , use a factory method (you already have that), look up the MethodInfo create a delegate, cache it and use the delegate from then on. This yields only a penalty on the first invocation, subsequent invocations have near-native performance. Combine technologies A lot is possible here, but I'd really need to know more of your situation to assist in this direction. Often, I end up combining dynamic with generics, with cached reflection. When using information hiding (as is normal in OOP), you may end up with a fast, stable and still well-extensible solution. Losing compile time type safety Of the five questions, this is perhaps the most important one to worry about. It is very important to create your own exceptions that give clear information about reflection mistakes. That means: every call to a method, constructor or property based on an input string or otherwise unchecked information must be wrapped in a try/catch. Catch only specific exceptions (as always, I mean: never catch Exception itself). Focus on TargetException (method does not exist), TargetInvocationException (method exists, but rose an exc. when invoked), TargetParameterCountException , MethodAccessException (not the right privileges, happens a lot in ASP.NET), InvalidOperationException (happens with generic types). You don't always need to try to catch all of them, it depends on the expected input and expected target objects. To sum it up Get rid of your Activator.CreateInstance and use MethodInfo to find the factory-create method, and use Delegate.CreateDelegate to create and cache the delegate. Simply store it in a static Dictionary where the key is equal to the class-string in your example code. Below is a quick but not-so-dirty way of doing this safely and without losing too much type safety. Sample code public class TestDynamicFactory { // static storage private static Dictionary > InstanceCreateCache = new Dictionary >(); // how to invoke it static int Main() { // invoke it, this is lightning fast and the first-time cache will be arranged // also, no need to give the full method anymore, just the classname, as we // use an interface for the rest. Almost full type safety! ICalculate instanceOfCalculator = this.CreateCachableICalculate("RandomNumber"); int result = instanceOfCalculator.ExecuteCalculation(); } // searches for the class, initiates it (calls factory method) and returns the instance // TODO: add a lot of error handling! ICalculate CreateCachableICalculate(string className) { if(!InstanceCreateCache.ContainsKey(className)) { // get the type (several ways exist, this is an eays one) Type type = TypeDelegator.GetType("TestDynamicFactory." + className); // NOTE: this can be tempting, but do NOT use the following, because you cannot // create a delegate from a ctor and will loose many performance benefits //ConstructorInfo constructorInfo = type.GetConstructor(Type.EmptyTypes); // works with public instance/static methods MethodInfo mi = type.GetMethod("Create"); // the "magic", turn it into a delegate var createInstanceDelegate = (Func ) Delegate.CreateDelegate(typeof (Func ), mi); // store for future reference InstanceCreateCache.Add(className, createInstanceDelegate); } return InstanceCreateCache[className].Invoke(); } } // example of your ICalculate interface public interface ICalculate { void Initialize(); int ExecuteCalculation(); } // example of an ICalculate class public class RandomNumber : ICalculate { private static Random _random; public static RandomNumber Create() { var random = new RandomNumber(); random.Initialize(); return random; } public void Initialize() { _random = new Random(DateTime.Now.Millisecond); } public int ExecuteCalculation() { return _random.Next(); } }
