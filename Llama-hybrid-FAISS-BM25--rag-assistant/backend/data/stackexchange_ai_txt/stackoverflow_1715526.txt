[site]: stackoverflow
[post_id]: 1715526
[parent_id]: 1655525
[tags]: 
I would reorganize your code if I were you. So, there are some tasks which interact with other tasks, now with 2 tasks. And there is linked list, which is responsible for storing the tasks and manage the insertion/deletion of tasks. This is a global object which should handle synchronized. That's why I advice you to create a protected object, and store the list of tasks inside that. The protected is typically used for passive objects, where some resource must be handle synchronized. You can have procedures like insert, remove etc. This will ensure that only one creation and removal will be running at a time, and the linked list will not be inconsistent. Each task should know it's "partner" tasks which could change when insertion or removal of a task. I advice the create an entry into the task which will update its neighbors. When tasks come or leave, the protected object will update the neighbors. In this case, no need to access the "this" pointer, because the protected object will organize everything. Only an ID is needed, which can identify the task (for removal). I try to write the code, but I do not have compiler now: task type computer; type computer_ptr is access all computer; task type computer is entry init(id:integer); entry set_neighbor(left,right:computer_ptr); end computer; protected comp_list is procedure insert; -- called by organizer procedure remove(from:integer); -- called by task private type comp_list is array(integer range<>) of computer_ptr; comps:comp_list(1..MAX):=(others=>null); -- or use own structure end comp_list; task body computer is id_:integer; left_n,right_n:computer_ptr:=null; begin accept init(id:integer) do id_:=id; end init; while true loop select accept set_neighbor(left,right:computer_ptr) do left_n:=left;right_n:=right; end set_neighbor; or -- do its work end select; if (some_condition) then comp_list.remove(id_); break; end if; end loop; end task computer; protected body comp_list is procedure insert is p:computer_ptr; begin p:=new computer; -- add to list -> nr; p.all.init(nr); -- call set_neighbor to its left and itself end insert; procedure remove(from: integer) is begin -- remove from list and get its neighbors -- call set_neighbor regarding new ones end remove; end comp_list;
