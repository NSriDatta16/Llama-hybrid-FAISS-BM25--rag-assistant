[site]: stackoverflow
[post_id]: 1317032
[parent_id]: 1315806
[tags]: 
When it comes to 'tree update', I think you can always do it pretty elegantly using catamorphisms (folds over trees). I have a long blog series about this, and most of the example code below comes from part 4 of the series . When first learning, I find it best to focus on a particular small, concrete problem statement. Based on your description, I invented the following problem: You have a binary tree, where each node contains a "name" and an "amount" (can think of it like bank accounts or some such). And I want to write a function which can tell someone to "steal" a certain amount from each of his direct children. Here's a picture to describe what I mean: alt text http://oljksa.bay.livefilestore.com/y1pNWjpCPP6MbI3rMfutskkTveCWVEns5xXaOf-NZlIz2Hs_CowykUmwtlVV7bPXRwh4WHJMT-5hSuGVZEhmAIPuw/FunWithTrees.png On the left I have an original tree. The middle example shows the result I want if node 'D' is asked to steal '10' from each of his children. And the right example shows what the desired result is if instead I asked 'F' to steal '30' in the original example. Note that the tree structure I use will be immutable, and the red colors in the diagram designate "new tree nodes" relative to the original tree. That is black nodes are shared with the original tree structure (Object.ReferenceEquals to one another). Now, assuming a typical tree structure like type Tree = //' | Node of 'T * Tree * Tree //' | Leaf we'd represent the original tree as let origTree = Node(("D",1000), Node(("B",1000), Node(("A",1000),Leaf,Leaf), Node(("C",1000),Leaf,Leaf)), Node(("F",1000), Node(("E",1000),Leaf,Leaf), Leaf)) and the "Steal" function is really easy to write, assuming you have the usual "fold" boilerplate: // have 'stealerName' take 'amount' from each of its children and // add it to its own value let Steal stealerName amount tree = let Subtract amount = function | Node((name,value),l,r) -> amount, Node((name,value-amount),l,r) | Leaf -> 0, Leaf tree |> XFoldTree (fun (name,value) left right -> if name = stealerName then let leftAmt, newLeft = Subtract amount left let rightAmt, newRight = Subtract amount right XNode((name,value+leftAmt+rightAmt),newLeft,newRight) else XNode((name,value), left, right)) XLeaf // examples let dSteals10 = Steal "D" 10 origTree let fSteals30 = Steal "F" 30 origTree That's it, you're done, you've written an algorithm that "updates" levels L and L+1 of an immutable tree just by authoring the core logic. Rather than explain it all here, you should go read my blog series (at least the start: parts one two three four ). Here's all the code (that drew the picture above): // Tree boilerplate // See http://lorgonblog.spaces.live.com/blog/cns!701679AD17B6D310!248.entry type Tree = | Node of 'T * Tree * Tree | Leaf let (===) x y = obj.ReferenceEquals(x,y) let XFoldTree nodeF leafV tree = let rec Loop t cont = match t with | Node(x,left,right) -> Loop left (fun lacc -> Loop right (fun racc -> cont (nodeF x lacc racc t))) | Leaf -> cont (leafV t) Loop tree (fun x -> x) let XNode (x,l,r) (Node(xo,lo,ro) as orig) = if xo = x && lo === l && ro === r then orig else Node(x,l,r) let XLeaf (Leaf as orig) = orig let FoldTree nodeF leafV tree = XFoldTree (fun x l r _ -> nodeF x l r) (fun _ -> leafV) tree // ///////////////////////////////////////// // stuff specific to this problem let origTree = Node(("D",1000), Node(("B",1000), Node(("A",1000),Leaf,Leaf), Node(("C",1000),Leaf,Leaf)), Node(("F",1000), Node(("E",1000),Leaf,Leaf), Leaf)) // have 'stealerName' take 'amount' from each of its children and // add it to its own value let Steal stealerName amount tree = let Subtract amount = function | Node((name,value),l,r) -> amount, Node((name,value-amount),l,r) | Leaf -> 0, Leaf tree |> XFoldTree (fun (name,value) left right -> if name = stealerName then let leftAmt, newLeft = Subtract amount left let rightAmt, newRight = Subtract amount right XNode((name,value+leftAmt+rightAmt),newLeft,newRight) else XNode((name,value), left, right)) XLeaf let dSteals10 = Steal "D" 10 origTree let fSteals30 = Steal "F" 30 origTree // ///////////////////////////////////////// // once again, // see http://lorgonblog.spaces.live.com/blog/cns!701679AD17B6D310!248.entry // DiffTree: Tree * Tree -> Tree // return second tree with extra bool // the bool signifies whether the Node "ReferenceEquals" the first tree let rec DiffTree(tree,tree2) = XFoldTree (fun x l r t t2 -> let (Node(x2,l2,r2)) = t2 Node((x2,t===t2), l l2, r r2)) (fun _ _ -> Leaf) tree tree2 open System.Windows open System.Windows.Controls open System.Windows.Input open System.Windows.Media open System.Windows.Shapes // Handy functions to make multiple transforms be a more fluent interface let IdentT() = new TransformGroup() let AddT t (tg : TransformGroup) = tg.Children.Add(t); tg let ScaleT x y (tg : TransformGroup) = tg.Children.Add(new ScaleTransform(x, y)); tg let TranslateT x y (tg : TransformGroup) = tg.Children.Add(new TranslateTransform(x, y)); tg // Draw: Canvas -> Tree -> unit let Draw (canvas : Canvas) tree = // assumes canvas is normalized to 1.0 x 1.0 FoldTree (fun ((name,value),b) l r trans -> // current node in top half, centered left-to-right let tb = new TextBox(Width=100.0, Height=100.0, FontSize=30.0, Text=sprintf "%s:%d" name value, // the tree is a "diff tree" where the bool represents // "ReferenceEquals" differences, so color diffs Red Foreground=(if b then Brushes.Black else Brushes.Red), HorizontalContentAlignment=HorizontalAlignment.Center, VerticalContentAlignment=VerticalAlignment.Center) tb.RenderTransform ScaleT 0.005 0.005 |> TranslateT 0.25 0.0 |> AddT trans canvas.Children.Add(tb) |> ignore // left child in bottom-left quadrant l (IdentT() |> ScaleT 0.5 0.5 |> TranslateT 0.0 0.5 |> AddT trans) // right child in bottom-right quadrant r (IdentT() |> ScaleT 0.5 0.5 |> TranslateT 0.5 0.5 |> AddT trans) ) (fun _ -> ()) tree (IdentT()) let TreeToCanvas tree = let canvas = new Canvas(Width=1.0, Height=1.0, Background = Brushes.Blue, LayoutTransform=new ScaleTransform(400.0, 400.0)) Draw canvas tree canvas let TitledControl title control = let grid = new Grid() grid.ColumnDefinitions.Add(new ColumnDefinition()) grid.RowDefinitions.Add(new RowDefinition()) grid.RowDefinitions.Add(new RowDefinition()) let text = new TextBlock(Text = title, HorizontalAlignment = HorizontalAlignment.Center) Grid.SetRow(text, 0) Grid.SetColumn(text, 0) grid.Children.Add(text) |> ignore Grid.SetRow(control, 1) Grid.SetColumn(control, 0) grid.Children.Add(control) |> ignore grid let HorizontalGrid (controls:_[]) = let grid = new Grid() grid.RowDefinitions.Add(new RowDefinition()) for i in 0..controls.Length-1 do let c = controls.[i] grid.ColumnDefinitions.Add(new ColumnDefinition()) Grid.SetRow(c, 0) Grid.SetColumn(c, i) grid.Children.Add(c) |> ignore grid type MyWPFWindow(content, title) as this = inherit Window() do this.Content ] do let app = new Application() let controls = [| TitledControl "Original" (TreeToCanvas(DiffTree(origTree,origTree))) TitledControl "D steals 10" (TreeToCanvas(DiffTree(origTree,dSteals10))) TitledControl "F steals 30" (TreeToCanvas(DiffTree(origTree,fSteals30))) |] app.Run(new MyWPFWindow(HorizontalGrid controls, "Fun with trees")) |> ignore
