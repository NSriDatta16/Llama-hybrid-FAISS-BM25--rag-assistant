[site]: stackoverflow
[post_id]: 2171186
[parent_id]: 2171081
[tags]: 
I think you should draw attention to Stanley B. Lippman's book " Inside C++ object model ". Lets look for internal presentation for your classes: Virtual Table for person and teacher |---------------| +---> |------------------------| | name | | | "type_info" for person | |---------------| | |------------------------| |__vptr__person |--+ | "person::~person" | |---------------| |------------------------| person p; | "person::show" | |------------------------| |----------------| +---> |-------------------------| |person subobject| | | "type_info" for teacher | |----------------| | |-------------------------| |__vptr__teacher |--+ | "teacher::~teacher" | |----------------| |-------------------------| teacher t; | "teacher::show" | |-------------------------| In general, we don't know the exact type of the object ptr addresses at each invocation of show(). We do know, however, that through ptr we can access the virtual table associated with the object's class. Although we don't know which instance of show() to invoke, we know that each instance's address is contained in slot 2. This information allows the compiler to internally transform the call into ( *ptr->vptr[ 2 ] )( ptr ); In this transformation, vptr represents the internally generated virtual table pointer inserted within each class object and 2 represents show()'s assigned slot within the virtual table associated with the Point hierarchy. The only thing we need to do in runtime is compute ptr's dynamic type (and appropriate vtable) using RTTI.
