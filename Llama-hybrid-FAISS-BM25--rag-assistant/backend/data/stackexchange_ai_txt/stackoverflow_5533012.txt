[site]: stackoverflow
[post_id]: 5533012
[parent_id]: 5532722
[tags]: 
If you 'suspect' that something is the problem, then your first action must be to find out whether it is or not. Profile the code. Then you'll know where the slow bits are. You can do this with a profiling tool, or just by throwing calls to System.nanoTime() in at key points and keeping some totals. Do this before doing any optimisation! Now, an interesting thing about the array you are sorting is that it is normally 'mostly sorted'. The first 90% of it is the survivors from the previous round, who are sorted. You can use this to your advantage by using an adaptive sort , which does less work on such mostly-sorted arrays. There are several known adaptive sorts, but a good general-purpose one is Timsort . This will actually become the standard sort in Java 7 - the footnotes to the Wikipedia article about it include a link to the code in OpenJDK that will be used, which you can simply steal. Even better than applying an adaptive sort would be to sort the new children first (using an adaptive sort, as you are breeding the fittest parents first, and so would expect to have, on average, the fittest children appear first), then to merge them into the already-sorted list of parents. You can merge them straightforwardly in O(n) time by walking the parent and child arrays in parallel and inserting children where needed. You could look at using a LinkedList here, as you might otherwise spend a lot of time in System.arrayCopy(). Also, in getBreedingArray(), you're saying breedingArray.contains(i) - for an array, that's an O(n) operation. You should probably use a LinkedHashSet instead of an array here. Scratch that - use a BitSet.
