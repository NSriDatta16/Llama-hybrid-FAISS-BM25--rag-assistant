[site]: stackoverflow
[post_id]: 5644362
[parent_id]: 5644338
[tags]: 
For simple cases you can use a second, private member function for the overrideable behavior: class Base { public: void Draw() { // Base-class functionality here OverrideableDraw(); } private: virtual void OverrideableDraw() { } }; class Derived : public Base { private: virtual void OverrideableDraw() { // Derived-class functionality here } }; For more complex hierarchies (e.g. where you have multiple levels of inheritance), this isn't possible since any derived class can override any virtual member function (there is no final in C++). Usually it is safe to assume that each derived class is doing the right thing. While I can think of a few times that I've run into issues because a derived class screwed up overriding, those cases were usually pretty straightforward to debug. If you are really worried about it and really want to guarantee that base-class overrides are executed first, you could use something like this, though this is quite expensive (at least this naive implementation is quite expensive): #include #include #include class Base { public: Base() { RegisterDrawCallback(std::bind(&Base::DrawCallback, this)); } void Draw() { for (auto it(drawCallbacks_.begin()); it != drawCallbacks_.end(); ++it) (*it)(); } protected: typedef std::function DrawCallbackType; typedef std::vector DrawSequence; void RegisterDrawCallback(DrawCallbackType f) { drawCallbacks_.push_back(f); } private: void DrawCallback() { std::cout [This is just one option; someone else can probably come up with a far more elegant solution. Personally, I'd just make sure the virtual member functions are well-documented and leave it at that.]
