[site]: stackoverflow
[post_id]: 3233113
[parent_id]: 3230978
[tags]: 
C - with number words 445 431 427 421 399 386 371 359 * 356 354 † 348 347 characters That's it. I don't think I can make this any shorter. All newlines are for readability and can be removed: i;P(x){char*p=",one,two,three,four,five,six,sM,eight,nine,tL,elM,twelve,NP,4P, fifP,6P,7P,8O,9P,twLQ,NQ,forQ,fifQ,6Q,7Q,8y,9Q,en,evL,thir,eL,tO,ty, is ,.\n, 4RmagicS,zero,";while(x--)if(*++p-44&&!x++)*p>95|*p 19?P(c/10+18), (c%=10)&&putchar(45):0,c:37);P(36);} Below, it is somewhat unminified, but still pretty hard to read. See below for a more readable version. i; P(x){ char*p=",one,two,three,four,five,six,sM,eight,nine,tL,elM,twelve,NP,4P,fifP,6P,7P,8O,9P,twLQ,NQ,forQ,fifQ,6Q,7Q,8y,9Q,en,evL,thir,eL,tO,ty, is ,.\n,4RmagicS,zero,"; while(x--) if(*++p-44&&!x++) *p>95|*p 19? P(c/10+18), (c%=10)&& putchar(45) :0, c :37); P(36); } Expanded and commented: int count; /* type int is assumed in the minified version */ void print(int index){ /* the minified version assumes a return type of int, but it's ignored */ /* see explanation of this string after code */ char *word = /* 1 - 9 */ ",one,two,three,four,five,six,sM,eight,nine," /* 10 - 19 */ "tL,elM,twelve,NP,4P,fifP,6P,7P,8O,9P," /* 20 - 90, by tens */ "twLQ,NQ,forQ,fifQ,6Q,7Q,8y,9Q," /* lookup table */ "en,evL,thir,eL,tO,ty, is ,.\n,4RmagicS,zero,"; while(index >= 0){ if(*word == ',') index--; else if(index == 0) /* we found the right word */ if(*word >= '0' && *word 19){ print(argc / 10/*high digit*/ + 20/*offset of "twenty"*/ - 2/*20 / 10*/); argc %= 10; /* get low digit */ if(argc != 0) /* we need a hyphen before the low digit */ putchar('-'); } print(argc/* if 0, then nothing is printed or counted */); } argc = count; print(34/*" is "*/); print(argc); /* print count as word */ print(35/*".\n"*/); } print(36/*"four is magic.\n"*/); } About the encoded string near the beginning The names of the numbers are compressed using a very simple scheme. Frequently used substrings are replaced with one-character indices into the name array. A "lookup table" of extra name entries is added to the end for substrings not used in their entirety in the first set. Lookups are recursive: entries can refer to other entries. For instance, the compressed name for 11 is elM . The print() function outputs the characters e and l (lower-case 'L', not number '1') verbatim, but then it finds the M , so it calls itself with the index of the 29th entry (ASCII 'M' - ASCII '0') into the lookup table. This string is evL , so it outputs e and v , then calls itself again with the index of the 28th entry in the lookup table, which is en , and is output verbatim. This is useful because en is also used in eL for een (used after eight in eighteen ), which is used in tO for teen (used for every other -teen name). This scheme results in a fairly significant compression of the number names, while requiring only a small amount of code to decompress. The commas at the beginning and end of the string account for the simplistic way that substrings are found within this string. Adding two characters here saves more characters later. About the abuse of main() argv is ignored (and therefore not declared in the compressed version), argc's value is ignored, but the storage is reused to hold the current number. This just saves me from having to declare an extra variable. About the lack of #include Some will complain that omitting #include is cheating. It is not at all. The given is a completely legal C program that will compile correctly on any C compiler I know of (albeit with warnings). Lacking protoypes for the stdio functions, the compiler will assume that they are cdecl functions returning int , and will trust that you know what arguments to pass. The return values are ignored in this program, anyway, and they are all cdecl ("C" calling convention) functions, and we do indeed know what arguments to pass. Output Output is as expected: 0 zero is four. four is magic. 1 one is three. three is five. five is four. four is magic. 4 four is magic. 20 twenty is six. six is three. three is five. five is four. four is magic. 21 twenty-one is nine. nine is four. four is magic. * The previous version missed the mark on two parts of the spec: it didn't handle zero, and it took input on the command line instead of stdin. Handling zeros added characters, but using stdin instead of command line args, as well as a couple of other optimzations saved the same number of characters, resulting in a wash. † The requirements have been changed to make clear that the number word should be printed on both sides of " is ". This new version meets that requirement, and implements a couple more optimizations to (more than) account for the extra size necessary.
