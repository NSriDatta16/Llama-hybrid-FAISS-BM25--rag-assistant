[site]: stackoverflow
[post_id]: 1084540
[parent_id]: 1084365
[tags]: 
This is a multipass algorithm (therefore, you must be able to generate the same list multiple times, or store the list off to secondary storage). First pass: Find the highest value and the lowest value. That's your initial range. Passes after the first: Divide the range up into 10 equally spaced bins. We don't need to store any numbers in the bins. We're just going to count membership in the bins. So we just have an array of integers (or bigints--whatever can accurately hold our counts) Note that 10 is an arbitrary choice for the number of bins. Your sample size and distribution will determine the best choice. Spin through each number in the data, incrementing the count of whichever bin holds the number you see. Figure out which bin has your answer, and add how many numbers are above that bin to a count of numbers above the winning bin. The winning bin's top and bottom range are your new range. Loop through these steps again until you have enough memory to hold the numbers in the current bin. Last pass: You should know how many numbers are above the current bin by now. You have enough storage to grab all the numbers within your range of the current bin, so you can spin through and grab the actual numbers. Just sort them and grab the correct number. Example: if the range you see is 0.0 through 1000.0, your bins' ranges will be: (- 0.0 - 100.0] (100.0 - 200.0] (200.0 - 300.0] ... (900.0 - 1000.0) If you find through the counts that your number is in the (100.0 - 2000.0] bin, your next set of bins will be: (100.0 - 110.0] (110.0 - 120.0] etc. Another multipass idea: Simply do a binary search. Choose the midpoint of the range as the first guess. Your passes just need to do an above/below count to determine the next estimate (which can be weighted by the count, or a simple average for code simplicity).
