[site]: stackoverflow
[post_id]: 3018919
[parent_id]: 
[tags]: 
Solving Naked Triples in Sudoku

I wished I paid more attention to the math classes back in Uni. :) How do I implement this math formula for naked triples? Naked Triples Take three cells C = {c1, c2, c3} that share a unit U. Take three numbers N = {n1, n2, n3}. If each cell in C has as its candidates ci ⊆ N then we can remove all ni ∈ N from the other cells in U.** I have a method that takes a Unit (e.g. a Box, a row or a column) as parameter. The unit contains 9 cells, therefore I need to compare all combinations of 3 cells at a time that from the box, perhaps put them into a stack or collection for further calculation. Next step would be taking these 3-cell-combinations one by one and compare their candidates against 3 numbers. Again these 3 numbers can be any possible combination from 1 to 9. Thats all I need. But how would I do that? How many combinations would I get? Do I get 3 x 9 = 27 combinations for cells and then the same for numbers (N)? How would you solve this in classic C# loops? No Lambda expression please I am already confused enough :) Code: I had to cut the classes short in order to represent them here. public class Cell : INotifyPropertyChanged { public ObservableCollection > CandidateActual {...} public int Id { ... } //Position of the Cell inside a box if applicable public int CellBoxPositionX { get; private set; } public int CellBoxPositionY { get; private set; } //Position of the Cell inside the game board public int CellBoardPositionX { get; private set; } public int CellBoardPositionY { get; private set; } //Position of the Box inside the game board public int BoxPositionX { get; private set; } public int BoxPositionY { get; private set; } public int CountCandidates { ... } public int? Value { ...} public Candidate this[int number] { get { if (number PossibleValues.Count) { throw new ArgumentOutOfRangeException("number", number, "Invalid Number Index"); } switch (number) { case 1: return CandidateActual[0][0]; case 2: return CandidateActual[0][1]; case 3: return CandidateActual[0][2]; case 4: return CandidateActual[1][0]; case 5: return CandidateActual[1][1]; case 6: return CandidateActual[1][2]; case 7: return CandidateActual[2][0]; case 8: return CandidateActual[2][1]; case 9: return CandidateActual[2][2]; default: return null; } } } } Candidate public class Candidate : INotifyPropertyChanged { private int? _value; public int? Value { ... } } Box: public class Box : INotifyPropertyChanged { public ObservableCollection > BoxActual { ... } public Cell this[int row, int column] { get { if(row = BoxActual.Count) { throw new ArgumentOutOfRangeException("row", row, "Invalid Row Index"); } if(column = BoxActual.Count) { throw new ArgumentOutOfRangeException("column", column, "Invalid Column Index"); } return BoxActual[row][column]; } } } Board public class Board : INotifyPropertyChanged { public ObservableCollection > GameBoard {...} public Cell this[int boardRowPosition, int boardColumnPosition] { get { int totalSize = GameBoard.Count*GameBoard.Count(); if (boardRowPosition = totalSize) throw new ArgumentOutOfRangeException("boardRowPosition", boardRowPosition, "Invalid boardRowPosition index"); if (boardColumnPosition = totalSize) throw new ArgumentOutOfRangeException("boardColumnPosition", boardColumnPosition, "Invalid boardColumnPosition index"); return GameBoard[boardRowPosition/GameBoard.Count][boardColumnPosition/GameBoard.Count][ boardRowPosition%GameBoard.Count, boardColumnPosition%GameBoard.Count]; } } public Box this[int boardRowPosition, int boardColumnPosition, bool b] { get { int totalSize = GameBoard.Count * GameBoard.Count(); if (boardRowPosition = totalSize) throw new ArgumentOutOfRangeException("boardRowPosition", boardRowPosition, "Invalid boardRowPosition index"); if (boardColumnPosition = totalSize) throw new ArgumentOutOfRangeException("boardColumnPosition", boardColumnPosition, "Invalid boardColumnPosition index"); return GameBoard[boardRowPosition / GameBoard.Count][boardColumnPosition / GameBoard.Count]; } } } Many Thanks for any help,
