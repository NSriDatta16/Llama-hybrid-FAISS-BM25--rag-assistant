[site]: stackoverflow
[post_id]: 5476355
[parent_id]: 5476059
[tags]: 
I would store this information in the user data part of the authentication cookie. So when a user logs in: public ActionResult Login(string username, string password) { // TODO: validate username/password couple and // if they are valid get the roles for the user var roles = "RoleA|RoleC"; var ticket = new FormsAuthenticationTicket( 1, username, DateTime.Now, DateTime.Now.AddMilliseconds(FormsAuthentication.Timeout.TotalMilliseconds), false, roles ); var encryptedTicket = FormsAuthentication.Encrypt(ticket); var authCookie = new HttpCookie(FormsAuthentication.FormsCookieName, encryptedTicket) { // IIRC this property is only available in .NET 4.0, // so you might need a constant here to match the domain property // in the tag of the web.config Domain = FormsAuthentication.CookieDomain, HttpOnly = true, Secure = FormsAuthentication.RequireSSL, }; Response.AppendCookie(authCookie); return RedirectToAction("SomeSecureAction"); } Then I would write a custom authroize attribute which will take care of reading and parsing the authentication ticket and store a generic user in the HttpContext.User property with its corresponding roles: public class MyAuthorizeAttribute : AuthorizeAttribute { protected override bool AuthorizeCore(HttpContextBase httpContext) { if (httpContext.User.Identity.IsAuthenticated) { var authCookie = httpContext.Request.Cookies[FormsAuthentication.FormsCookieName]; if (authCookie != null) { var ticket = FormsAuthentication.Decrypt(authCookie.Value); var roles = ticket.UserData.Split('|'); var identity = new GenericIdentity(ticket.Name); httpContext.User = new GenericPrincipal(identity, roles); } } return base.AuthorizeCore(httpContext); } } Next you could decorate your controllers/actions with this attribute to handle authorization: // Only users that have RoleA or RoleB can access this action // Note that this works only with OR => that's how the base // authorize attribute is implemented. If you need to handle AND // you will need to completely short-circuit the base method call // in your custom authroize attribute and simply handle this // case manually [MyAuthorize(Roles = "RoleA,RoleB")] public ActionResult Foo() { ... } In order to check whether a user is in a given role simply: bool isInRole = User.IsInRole("RoleC"); Armed with this information you can now start thinking of how to organize your view models. In those view models I would include boolean properties such as CanEdit , CanViewReport , ... which will be populated by the controller. Now if you need this mapping in each action and views things might get repetitive and boring. This is where global custom action filters come into play (they don't really exist in ASP.NET MVC 2, only in ASP.NET MVC 3 so you might need a base controller decorated with this action filter which simulates more or less the same functionality). You simply define such global action filter which executes after each action and injects some common view model to the ViewData (holy ...., can't believe I am pronouncing those words) and thus make it available to all views in a transverse of the other actions manner. And finally in the view you would check those boolean value properties in order to include or not different areas of the site. As far as the javascript code is concerned if it is unobtrusively AJAXifying areas of the site then if those areas are not present in the DOM then this code won't run. And if you needed more fine grained control you could always use HTML5 data-* attributes on your DOM elements to give hints to your external javascript functions on the authorizations of the user.
