[site]: stackoverflow
[post_id]: 3997872
[parent_id]: 3997581
[tags]: 
From the online C standard : 6.3.2.1 Lvalues, arrays, and function designators ... 3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type "array of type" is converted to an expression with type "pointer to type" that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined. Assume the following code snippet: int a[10]; ... foo(a); In the call to foo , the type of the expression a is "10-element array of int ". However, since the expression is not the operand of either the sizeof or & operators, and since it isn't a string literal being used to initialize another array in a declaration, its type is implicitly converted ("decays") from "10-element array of int " to "pointer to int ", and its value will be the address of the first element in the array (i.e. &a[0] ). Therefore, what foo receives is a pointer to int , not an array. Dereferencing or subscripting this pointer allows you to change the values of the array. This is a feature of the C language; arrays are not first-class objects. In fact, in most circumstances (including subscripting) array expressions will be converted to pointer types. I keep emphasizing the word expression to distinguish between the actual array object (which is always and forever an array type) and any reference to that object in the code, which may be converted to a pointer type.
