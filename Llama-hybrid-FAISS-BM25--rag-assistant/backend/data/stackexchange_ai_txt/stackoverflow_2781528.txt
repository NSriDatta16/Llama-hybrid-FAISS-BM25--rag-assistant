[site]: stackoverflow
[post_id]: 2781528
[parent_id]: 2781481
[tags]: 
You seem to have a good handle on it. "Data Access classes" can take a lot of different shapes. It's some sort of class that has something to do with data access. Your Repository is (A) a pattern for handling your data persistence, and (B) a place within your data access scheme (if you're implementing repository). A challenge in your data access strategy is providing flexibility and reusable capability at the same time. While at the same time being efficient. While at the same time working with your business logic, being decoupled but also being cohesive . Tricky. Repository is a pattern that purports to help with all this balance. Your code for translating the db (or whatever) to/from entity classes resides in one place, for each entity. Your "Data Access classes" might consist of your repository classes, as well as classes that actually handle sql work. You certainly should not be doing all the sql cruft within each of your repository classes. Example: you could start off using inefficient-but-easy reflection to fill out your entity objects, doing close to no work in your repository classes; later you can make it more efficient for high-volume entities, but this is completely hidden from other parts of your system. And then later you move some configuration to XML, but the rest of your system has no idea of this change. LINQ-to-sql and Entity framework really leverage the repository pattern, because what the repository classes return is actually an IQuerable of that entity. Business classes can apply additional criteria, and those criteria actually make it to the sql, while still providing complete encapsulation from the data persistence. It's seriously cool.
