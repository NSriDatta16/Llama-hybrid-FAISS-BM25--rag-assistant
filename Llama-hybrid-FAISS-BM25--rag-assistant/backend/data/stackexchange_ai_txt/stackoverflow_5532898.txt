[site]: stackoverflow
[post_id]: 5532898
[parent_id]: 5523832
[tags]: 
You most certainly can do it “the Lisp way”. proc mkFooBarRecord {foo bar} { # Keep index #0 for a "type" for easier debugging return [list "fooBarRecord" $foo $bar] } proc getFoo {fooBarRecord} { if {[lindex $fooBarRecord 0] ne "fooBarRecord"} {error "not fooBarRecord"} return [lindex $fooBarRecord 1] } # Etc. That works quite well. (Write it in C and you can make it more efficient too.) Mind you, as a generic data structure, it seems that many people prefer Tcl 8.5's dictionaries. There are many ways to use them; here's one: proc mkFooBarRecord {foo bar} { return [dict create "type" fooBarRecord "foo" $foo "bar" $bar] } proc getFoo {fooBarRecord} { dict with fooBarRecord { if {$type ne "fooBarRecord"} {error "not fooBarRecord"} return $foo } } As for the whole structures versus objects debate, Tcl tends to regard objects as state with operations (leading to a natural presentation as a command, a fairly heavyweight concept) whereas structures are pure values (and so lightweight). Having written a fair chunk on this, I really don't know what's best in general; I work on a case-by-case basis. If you are going with “structures”, also consider whether you should have collections that represent fields across many structures (equivalent to using column-wise storage instead of row-wise storage in a database) as that can lead to more efficient handling in some cases. Also consider using a database; SQLite integrates extremely well with Tcl, is reasonably efficient, and supports in-memory databases if you don't want to futz around with disk files.
