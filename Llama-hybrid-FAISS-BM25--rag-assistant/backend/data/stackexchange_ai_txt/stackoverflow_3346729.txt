[site]: stackoverflow
[post_id]: 3346729
[parent_id]: 3346450
[tags]: 
The typical answer to this question, unfortunately posted here already, is that one does the increment "before" remaining operations and the other does the increment "after" remaining operations. Though that intuitively gets the idea across, that statement is on the face of it completely wrong . The sequence of events in time is extremely well-defined in C#, and it is emphatically not the case that the prefix (++var) and postfix (var++) versions of ++ do things in a different order with respect to other operations. It is unsurprising that you'll see a lot of wrong answers to this question. A great many "teach yourself C#" books also get it wrong. Also, the way C# does it is different than how C does it. Many people reason as though C# and C are the same language; they are not. The design of the increment and decrement operators in C# in my opinion avoids the design flaws of these operators in C. There are two questions that must be answered to determine what exactly the operation of prefix and postfix ++ are in C#. The first question is what is the result? and the second question is when does the side effect of the increment take place? It is not obvious what the answer to either question is, but it is actually quite simple once you see it. Let me spell out for you precisely what x++ and ++x do for a variable x. For the prefix form (++x): x is evaluated to produce the variable The value of the variable is copied to a temporary location The temporary value is incremented to produce a new value (not overwriting the temporary!) The new value is stored in the variable The result of the operation is the new value (i.e. the incremented value of the temporary) For the postfix form (x++): x is evaluated to produce the variable The value of the variable is copied to a temporary location The temporary value is incremented to produce a new value (not overwriting the temporary!) The new value is stored in the variable The result of the operation is the value of the temporary Some things to notice: First, the order of events in time is exactly the same in both cases . Again, it is absolutely not the case that the order of events in time changes between prefix and postfix. It is entirely false to say that the evaluation happens before other evaluations or after other evaluations. The evaluations happen in exactly the same order in both cases as you can see by steps 1 through 4 being identical. The only difference is the last step - whether the result is the value of the temporary, or the new, incremented value. You can easily demonstrate this with a simple C# console app: public class Application { public static int currentValue = 0; public static void Main() { Console.WriteLine("Test 1: ++x"); (++currentValue).TestMethod(); Console.WriteLine("\nTest 2: x++"); (currentValue++).TestMethod(); Console.WriteLine("\nTest 3: ++x"); (++currentValue).TestMethod(); Console.ReadKey(); } } public static class ExtensionMethods { public static void TestMethod(this int passedInValue) { Console.WriteLine($"Current:{Application.currentValue} Passed-in:{passedInValue}"); } } Here are the results... Test 1: ++x Current:1 Passed-in:1 Test 2: x++ Current:2 Passed-in:1 Test 3: ++x Current:3 Passed-in:3 In the first test, you can see that both currentValue and what was passed into the TestMethod() extension show the same value, as expected. However, in the second case, people will try to tell you that the increment of currentValue happens after the call to TestMethod() , but as you can see from the results, it happens before the call as indicated by the 'Current:2' result. In this case, first the value of currentValue is stored in a temporary. Next, an incremented version of that value is stored back in currentValue but without touching the temporary which still stores the original value. Finally that temporary is passed to TestMethod() . If the increment happened after the call to TestMethod() then it would write out the same, non-incremented value twice, but it does not. It's important to note that the value returned from both the currentValue++ and ++currentValue operations are based on the temporary and not the actual value stored in the variable at the time either operation exits. Recall in the order of operations above, the first two steps copy the then-current value of the variable into the temporary. That is what's used to calculate the return value; in the case of the prefix version, it's that temporary value incremented while in the case of the suffix version, it's that value directly/non-incremented. The variable itself is not read again after the initial storage into the temporary. Put more simply, the postfix version returns the value that was read from the variable (i.e. the value of the temporary) while the prefix version returns the value that was written back to the variable (i.e. the incremented value of the temporary). Neither return the variable's value. This is important to understand because the variable itself could be volatile and have changed on another thread which means the return value of those operations could differ from the current value stored in the variable. It is surprisingly common for people to get very confused about precedence, associativity, and the order in which side effects are executed, I suspect mostly because it is so confusing in C. C# has been carefully designed to be less confusing in all these regards. For some additional analysis of these issues, including me further demonstrating the falsity of the idea that prefix and postfix operations "move stuff around in time" see: https://ericlippert.com/2009/08/10/precedence-vs-order-redux/ which led to this SO question: int[] arr={0}; int value = arr[arr[0]++]; Value = 1? You might also be interested in my previous articles on the subject: https://ericlippert.com/2008/05/23/precedence-vs-associativity-vs-order/ and https://ericlippert.com/2007/08/14/c-and-the-pit-of-despair/ and an interesting case where C makes it hard to reason about correctness: https://learn.microsoft.com/archive/blogs/ericlippert/bad-recursion-revisited Also, we run into similar subtle issues when considering other operations that have side effects, such as chained simple assignments: https://learn.microsoft.com/archive/blogs/ericlippert/chaining-simple-assignments-is-not-so-simple And here's an interesting post on why the increment operators result in values in C# rather than in variables : Why can't I do ++i++ in C-like languages?
