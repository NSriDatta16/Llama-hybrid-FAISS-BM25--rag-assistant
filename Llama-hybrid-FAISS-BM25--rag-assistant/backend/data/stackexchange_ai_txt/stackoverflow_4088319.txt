[site]: stackoverflow
[post_id]: 4088319
[parent_id]: 4087094
[tags]: 
Things that can influence the efficiency of openMP are e.g the computation of the iteration bounds. Ensure that these are computed before hand and that the iteration variables are as local as possible. If you have C99 do something like #pragma omp parallel for for (size_t i = start, is = stop; i to ensure that the expressions start and stop are evaluated at the beginning. (or use _Pragma , see my other answer.) Then the only way to see if this really was successful is to look at the assembler code (usually option -S ). If it isn't look into the other compiler options. gcc has the option -march=native that compiles optimally for the actual architecture. Other platforms might have similar options. Start by searching for the best architecture options for case 1.
