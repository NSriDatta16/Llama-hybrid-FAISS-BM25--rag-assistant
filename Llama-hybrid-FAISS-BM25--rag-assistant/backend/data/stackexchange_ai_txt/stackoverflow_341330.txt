[site]: stackoverflow
[post_id]: 341330
[parent_id]: 340413
[tags]: 
Well, first note that a cast is an explicit request to convert a value of one type to a value of another type . A cast will also always produce a new object, which is a temporary returned by the cast operator. Casting to a reference type, however, will not create a new object. The object referenced by the value is reinterpreted as a reference of a different type. Now to your question. Note that there are two major types of conversions: Promotions : This type can be thought of casting from a possibly more narrow type to a wider type. Casting from char to int, short to int, float to double are all promotions. Conversions : These allow casting from long to int, int to unsigned int and so forth. They can in principle cause loss of information. There are rules for what happens if you assign a -1 to an unsigned typed object for example. In some cases, a wrong conversion can result in undefined behavior. If you assign a double larger than what a float can store to a float, the behavior is not defined. Let's look at your casts: int i = 10; unsigned int k = (unsigned int) i; // :1 float fl = 10.123; unsigned int ufl = (unsigned int) fl; // :2 char *p = "Stackoverflow Rocks"; unsigned char *up = (unsigned char *) p; // :3 This cast causes a conversion to happen. No loss of data happens, since 10 is guaranteed to be stored by an unsigned int . If the integer were negative, the value would basically wrap around the maximal value of an unsigned int (see 4.7/2 ). The value 10.123 is truncated to 10. Here, it does cause lost of information, obviously. As 10 fits into an unsigned int, the behavior is defined. This actually requires more attention. First, there is a deprecated conversion from a string literal to char* . But let's ignore that here. (see here ). More importantly, what does happen if you cast to an unsigned type? Actually, the result of that is unspecified per 5.2.10/7 (note the semantics of that cast is the same as using reinterpret_cast in this case, since that is the only C++ cast being able to do that): A pointer to an object can be explicitly converted to a pointer to an object of different type. Except that converting an rvalue of type “pointer to T1” to the type "pointer to T2" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified. So you are only safe to use the pointer after you cast back to char * again.
