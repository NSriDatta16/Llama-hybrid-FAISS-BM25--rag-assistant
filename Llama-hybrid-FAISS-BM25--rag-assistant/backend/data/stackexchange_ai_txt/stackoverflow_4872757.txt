[site]: stackoverflow
[post_id]: 4872757
[parent_id]: 4872615
[tags]: 
Since you don't want to use virtual methods, the compiler would have to know statically (i.e. at compile time) which function to call. If you have different client objects in your container, there is now way the compiler could possibly know this. So I think there's no solution to your problem without using virtual methods (which are btw. exactly designed for this kind of situations...). Of course you could alternatively using some switch statements for manually deriving the concrete type, but this is neither elegant nor efficient (and you would have to hardcode all possible client types ...) EDIT Personally, I'd implement some base message class containing a type code and implement a switch statement in the client class to handle different message types like: struct MsgBase { int type; }; struct Consumer { virtual void callback(MsgBase msg) { }; }; struct Client : public Consumer { void callback(MsgBase msg) { switch (msg.type) { case MSGTYPE1: callback((Msg1)msg); break; case MSGTYPE2: callback((Msg2)msg); break; // ... } } void callback(Msg1 msg) { /* ... */ } void callback(Msg2 msg) { /* ... */ } }; You could also make MsgBase polymorphic (e.g. virtual destructor) and use typeid to differentiate (more elegant but slightly less efficient ...) struct Client : public Consumer { void callback(MsgBase* msg) { if (typeid(*msg) == typeof(Msg1)) callback(static_cast (msg)); else if (typeid(*msg) == typeof(Msg2)) callback(static_cast (msg)); } // ... };
