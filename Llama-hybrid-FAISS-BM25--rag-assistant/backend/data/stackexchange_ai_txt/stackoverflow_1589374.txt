[site]: stackoverflow
[post_id]: 1589374
[parent_id]: 1589321
[tags]: 
Use a bucket weighted queue: Instead of using a list, divide your collection into buckets - each bucket has an associated frequency of retrieval. Items move from higher frequency buckets to lower frequency ones as they are selected. An easy way to implement this is to assign each bucket a range of values, and generate a random number within the combined range to pick a bucket to choose from. You'll probably want to abstract this collection into some kind of class so that you don't expose consumers to the details. Algorithm: Initially, all items start in the same (top-level) bucket. When you select an item, move it from the bucket it's in, to the next lower bucket. If necessary, create the next level bucket. When a new item is added, add it to the top most (most frequently used) bucket. To randomly select an item, first pick a bucket, then pick an item within the bucket. Move the selected item down into the next level bucket. Note, that moving an item down to a lower frequency bucket is optional - you can set some cutoff point. When creating a new bucket, update the retrieval range associated with all buckets to give the new set the frequency distribution characteristic you want. C# implementation (first cut) of a generic bucketed weighted queue: using System; using System.Collections.Generic; using System.Linq; namespace Utility { public class BucketWeightedQueue { private int m_MaxFallOff; private readonly double m_FallOffRate; private readonly List > m_Buckets; private readonly List m_FallOffFactors; private readonly Random m_Rand = new Random(); public BucketWeightedQueue(IEnumerable items, double fallOffRate ) { if( fallOffRate > { items.ToList() }; m_FallOffFactors = new List { m_MaxFallOff }; } public T GetRandomItem() { var bucketIndex = GetRandomBucketIndex(); var bucket = m_Buckets[bucketIndex]; var itemIndex = m_Rand.Next( bucket.Count ); var selectedItem = bucket[itemIndex]; ReduceItemProbability( bucketIndex, itemIndex ); return selectedItem; } private int GetRandomBucketIndex() { var randFallOffValue = m_Rand.Next( m_MaxFallOff ); for (int i = 0; i () ); m_MaxFallOff = (int)(m_FallOffFactors[bucketIndex] / m_FallOffRate); m_FallOffFactors.Add( m_MaxFallOff ); } var nextBucket = m_Buckets[bucketIndex + 1]; nextBucket.Add( item ); if (m_Buckets[bucketIndex].Count == 0) // drop empty buckets m_Buckets.RemoveAt( bucketIndex ); } } }
