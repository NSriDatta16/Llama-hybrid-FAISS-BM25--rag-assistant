[site]: stackoverflow
[post_id]: 2792124
[parent_id]: 2791799
[tags]: 
The replace task doesn't observe dependencies, instead it carries out the replacement by writing a temporary file for each input file. If the temporary file is the same as the input file, it is discarded. A temporary file that differs from the input file is renamed to replace that input. This means all the files are processed, even if none of them need be - hence it can be inefficient. The original solution to this question was to carry out a copy-replace-copy. The second copy isn't needed though, as a mapper can be used in the first. In the copy, dependencies can be used to restrict processing to just the files that have changed - by means of a depend selector in an explicit fileset: That will restrict the copy fileset to just those files that have changed. An alternative syntax for the mappers is: The simplest replace would then be: That will still process all the files though, even if none of them need undergo replacements. The replace task has an implicit fileset and can operate on an explicit fileset, but unlike similar tasks the implicit fileset is not optional, hence to take advantage of selectors in an explicit fileset you must make the implicit one 'do nothing' - hence the .dummy file here: includes=".dummy" /> That will prevent the replace task from needlessly processing files that have previously undergone substitution. It doesn't, however, prevent processing of files that haven't changed and don't need substitution. Beyond that, I'm not sure there is a way to 'code golf' this problem to reduce the number of steps to one. There isn't a multiple string replacement filter that can be used in a copy task to achieve the same affect as replace , which is a shame because that feels like it would be the right solution. One other approach would be to generate the xml for a series of replace string filters and then have Ant execute that. But that will be more complex than the existing solution, and prone to problems with replacement strings that, if pasted into an xml fragment will result in something that can't be parsed. Yet another approach would be to write a custom task or script task to do the work. If there are many files and the copy-replace solution is judged to be too slow, then this might be the way to go. But again, that approach is less simple than the existing solution. If the requirement is to minimise the work done in the processing, rather than to come up with the shortest Ant solution, then this approach might do. Make a fileset containing a list of inputs that have changed. From that fileset create a comma-separated list of corresponding filtered files. Carry out the copy on the fileset. Carry out the replace on the comma-separated list. A wrinkle here is that the implicit fileset in the replace task will fall back to processing everything if no files have changed. To overcome this we insert a dummy file name.
