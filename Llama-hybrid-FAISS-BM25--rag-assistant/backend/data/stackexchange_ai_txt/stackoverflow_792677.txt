[site]: stackoverflow
[post_id]: 792677
[parent_id]: 792094
[tags]: 
If you have hand-written SQL, you can use ExecuteQuery, specifying the type of "row" class as a function template argument: var myList = DataContext.ExecuteQuery ( "select * from myview"); The "row" class exposes the columns as public properties. For example: public class MyRow { public int Id { get; set; } public string Name { get; set; } .... } You can decorate the columns with more information: public class MyRow { .... [Column(Storage="NameColumn", DbType="VarChar(50)")] public string Name { get; set; } .... } In my experience linq to sql doesn't generate very good SQL code, and the code it does generate breaks down for large databases. What linq to sql does very well is expose stored procedures to your client. For example: var result = DataContext.MyProcedure(a,b,c); This allows you to store SQL in the database, while having the benefits of an easy to use, automatically generated .NET wrapper. To see the exact SQL that's being used, you can use the SQL Server Profiler tool: http://msdn.microsoft.com/en-us/library/ms187929.aspx The Linq-to-Sql Debug Visualizer: http://weblogs.asp.net/scottgu/archive/2007/07/31/linq-to-sql-debug-visualizer.aspx Or you can write custom code to log the queries: http://goneale.wordpress.com/2008/12/31/log-linq-2-sql-query-execution-to-consoledebug-window/
