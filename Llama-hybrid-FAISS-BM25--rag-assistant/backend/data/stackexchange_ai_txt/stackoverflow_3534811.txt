[site]: stackoverflow
[post_id]: 3534811
[parent_id]: 3511268
[tags]: 
The implementation of set_retval_scalar may at first appear discouraging: sub set_retval_scalar { my $self = shift; # my blessed self my $type = shift; # type number from --dbitest=TYPE my $sql = shift; # SQL pattern for badness push @{ $scalar_retval{$type} }, { "SQL" => $sql, "retval" => $_[0] }; } The reason the first resultset appeared to be used again is successive calls to set_retval_scalar are cumulative . After the second call to set_retval_scalar , just before the second test, the internal bookkeeping for Test::MockDBI resembles [ # first resultset { SQL => "SELECT username ...", retval => [{ username => '1234567' }, ...] }, # second resultset { SQL => "SELECT username ...", retval => [] } ] Under the hood when your second test queries SELECT username ... , _force_retval_scalar in Test::MockDBI searches this data structure for the currently executing query and stops on the first hit it finds. Both resultsets are associated with the same query, so the second doesn't have a chance to match. But there's hope! Notice that set_retval_scalar copies only the outermost referenceâ€”a reference to an array that you control! Modify your test slightly: my @usernames_many = ( { username => '1234567' }, { username => '2345678' }, ); my @usernames_empty = (); my $usernames = []; $mock_dbi->set_retval_scalar( MOCKDBI_WILDCARD, "SELECT username FROM location", $usernames); With this fixture, you need only change the contents of @$usernames (that is, the array referred to by $usernames ) to change the canned result of the query: @$usernames = @usernames_many; is_deeply(find_multiple_registrations($mock_db, 15), [ '1234567', '2345678' ], "many entries"); @$usernames = @usernames_empty; is_deeply(find_multiple_registrations($mock_db, 15), [ ], "no entries"); With these modifications, both tests pass. IMPORTANT: Always assign to @$usernames ! You may be tempted to save a few keystrokes by writing $usernames = []; # empty usernames is_deeply(find_multiple_registrations($mock_db, 15), [ ], "no entries"); but this will cause your test to fail for nearly the same reason as the test from your question: the fixture will continue to have the same reference that you gave it in the call to set_retval_scalar . Doing it this way would be both incorrect and misleading, a nasty combination. For completeness, a full working example is below. #! /usr/bin/perl use warnings; use strict; BEGIN { push @ARGV, "--dbitest" } use Test::MockDBI qw/ :all /; use Test::More tests => 2; my @usernames_many = ( { username => '1234567' }, { username => '2345678' }, ); my @usernames_empty = (); my $usernames = []; my $mock_dbi = get_instance Test::MockDBI; my $mock_db = DBI->connect("dbi:SQLite:dbname=:memory:", "", ""); $mock_db->{RaiseError} = 1; $mock_db->do(q{CREATE TABLE location (username char(10))}); sub find_multiple_registrations { my($dbh,$limit) = @_; my $sth = $dbh->prepare("SELECT username FROM location"); $sth->execute; [ map $_->{username} => @{ $sth->fetchall_arrayref } ]; } $mock_dbi->set_retval_scalar( MOCKDBI_WILDCARD, "SELECT username FROM location", $usernames); @$usernames = @usernames_many; is_deeply(find_multiple_registrations($mock_db, 15), [ '1234567', '2345678' ], "many entries"); @$usernames = (); is_deeply(find_multiple_registrations($mock_db, 15), [ ], "no entries"); Output: 1..2 connect() 'CONNECT TO dbi:SQLite:dbname=:memory: AS WITH ' do() 'CREATE TABLE location (username char(10))' prepare() 'SELECT username FROM location' execute() fetchall_arrayref() ok 1 - many entries prepare() 'SELECT username FROM location' execute() fetchall_arrayref() ok 2 - no entries
