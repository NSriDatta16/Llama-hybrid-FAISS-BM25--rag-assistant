[site]: stackoverflow
[post_id]: 4398588
[parent_id]: 4397859
[tags]: 
If you organized the necessary list as a trie , then you could look in that trie to check if the fruit starts with a valid prefix. That should be faster than comparing the fruit against every prefix. For example (only mildly tested): import bisect import re class Node(object): def __init__(self): self.children = [] self.children_values = [] self.exists = False # Based on code at http://docs.python.org/library/bisect.html def _index_of(self, ch): i = bisect.bisect_left(self.children_values, ch) if i != len(self.children_values) and self.children_values[i] == ch: return (i, self.children[i]) return (i, None) def add(self, value): if len(value) == 0: self.exists = True return i, child = self._index_of(value[0]) if not child: child = Node() self.children.insert(i, child) self.children_values.insert(i, value[0]) child.add(value[1:]) def contains_prefix_of(self, value): if self.exists: return True i, child = self._index_of(value[0]) if not child: return False return child.contains_prefix_of(value[1:]) necessary = ['RED', 'GREEN', 'BLUE', 'ORANGE', 'BLACK', 'LIGHTRED', 'LIGHTGREEN', 'GRAY'] trie = Node() for value in necessary: trie.add(value) # Find lines that match values in the trie filtered = [] regexp = re.compile(r'fruit=([A-Z]+)') for line in open('whatever-file'): fruit = regexp.findall(line)[0] if trie.contains_prefix_of(fruit): filtered.append(line) This changes your algorithm from O(N * k) , where N is the number of elements of necessary and k is the length of fruit , to just O(k) (more or less). It does take more memory though, but that might be a worthwhile trade-off for your case.
