[site]: stackoverflow
[post_id]: 1203389
[parent_id]: 1203209
[tags]: 
f# has two common associative data structures: The one you are most used to, the mutable Dictionary which it inherits that's to it's presence in the BCL and uses a hashtable under the hood. let dict = new System.Collections.Generic.Dictionary () dict.["everything"] The other is known as Map and is, in common functional style, immutable and implemented with binary trees. Instead of operations that would change a Dictionary, maps provide operations which return a new map which is the result of whatever change was requested. In many cases, under the hood there is no need to make an entirely new copy of the entire map, so those parts that can be shared normally are. For example: let withDouglasAdams = Map.add "everything" 42 Map.empty The value withDouglasAdams will remain forever as an association of "everything" to 42. so if you later do: let soLong = Map.remove "everything" withDouglasAdams Then the effect of this 'removal' is only visible via the soLong value. F#'s Map is, as mentioned, implemented as a binary tree. Lookup is therefore O(log n) whereas a (well behaved) dictionary should be O(1). In practice a hash based dictionary will tend to outperform the tree based one in almost all simple (low number of elements, low probability of collision) as such is commonly used. That said the immutable aspect of the Map may allow you to use it in situations where the dictionary would instead require more complex locking or to write more 'elegant' code with fewer side effects and thus it remains a useful alternative. This is not however the source of your problem. The dict 'operator' returns an explicity immutable IDictionary implementation (despite not indicating this in it's documentation). From fslib-extra-pervasives.fs (note also the use of options on the keys): let dict l = // Use a dictionary (this requires hashing and equality on the key type) // Wrap keys in an Some(_) option in case they are null // (when System.Collections.Generic.Dictionary fails). Sad but true. let t = new Dictionary ,_>(HashIdentity.Structural) for (k,v) in l do t.[Some(k)] IDictionary ) let c = (t :> ICollection ) let ieg = (t :> IEnumerable ) let ie = (t :> System.Collections.IEnumerable) // Give a read-only view of the dictionary { new IDictionary with member s.Item with get x = d.[Some(x)] and set (x,v) = raise (NotSupportedException( "This value may not be mutated")) ...
