[site]: stackoverflow
[post_id]: 3269374
[parent_id]: 3269256
[tags]: 
istream & operator>>(istream & is, Foo & f) { is >> (string &)f; return is; } istream& operator>>(istream& is, string& f) (well, basic_istream &, basic_sttring & ) already exists. So while you can do this, why do it? So, once cin >> f is hit, the function is called and the now string is stored in the istream reference No, the stream is consumed by istream& operator>>(istream& is, string& f) , which sets the string ('s storage) to contain a representation of the consumed bytes. Then a reference to the istream is returned. int x; cin >> f >> x; is equivalent to: int x; (cin >> f) >> x; because of operator associativity rules, and is "really": int x; std::operator>>( ::operator>>(cin, f), x ) ; where the two operator>> s are two different overloaded versions of op>> , that is, your version (in the global namespace) that takes an istream and a Foo is the inner one, which return a reference to istream, which is in the turn the first argument of the outer one, the one in std namespace that takes an istream and an int. Is the ostream object just compounded each array item within itself? Each object, of whatever type array[n] is, is added to the ostream, in sequence , to the stream, follows by a newline. So "compunded" is a bad way to express it, but yes. Naturally, there needs to exist an op where "X" is whatever type array[n] is (or is implicitly convertible to).
