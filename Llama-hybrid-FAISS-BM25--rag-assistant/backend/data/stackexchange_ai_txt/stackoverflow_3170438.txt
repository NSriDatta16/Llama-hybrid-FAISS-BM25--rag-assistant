[site]: stackoverflow
[post_id]: 3170438
[parent_id]: 3170239
[tags]: 
In Fortran >=90, the best approach is use intrinsic functions to specify the precision you need -- this guarantees both portability and that you get the precision that you need. For example, to obtain integers i and my_int that will support at least 8 decimal digits, you could use: integer, parameter :: RegInt_K = selected_int_kind (8) integer (kind=RegInt_K) :: i, my_int Having defined RegInt_K (or whatever name you select) as a parameter , you can use it throughout your code as a symbol. This also makes it easy to change the precision. Requesting 8 or 9 decimal digits will typically obtain a 4-byte integer. integer*4 is an common extension going back to old FORTRAN to specify a 4-byte integer. Although, this syntax isn't and was never standard Fortran. integer (4) or integer (RegInt_K) are short for integer (kind=4) or integer (kind=RegInt_K) . integer (4) is not the same as integer*4 and is non-portable -- the language standard does not specify the numeric values of kinds. Most compilers use the kind=4 for 4-byte integers -- for these compilers integer*4 and integer(4) will provide the same integer type -- but there are exceptions, so integer(4) is non-portable and best avoided. The approach for reals is similar. UPDATE: if you don't want to specify numeric types by the required precision, but instead by the storage that they will use, Fortran 2008 provides a method. reals and integers can be specified by the number of bits of storage after use ing the ISO_FORTRAN_ENV module, for example, for a 4-byte (32-bit) integer: use ISO_FORTRAN_ENV integer (int32) :: MyInt The gfortran manual has documentation under "intrinsic modules".
