[site]: stackoverflow
[post_id]: 5054501
[parent_id]: 5054204
[tags]: 
The orthodox way to do this does not involve bitsets at all. You have a table for users, a table for objectives, and a join table, indicating which objectives a user has. Something like: create table users ( id integer primary key, name varchar(100) not null ); create table objectives ( id integer primary key, name varchar(100) not null ); create table user_objective ( user_id integer not null references users, objective_id integer not null references objectives, primary key (user_id, objective_id) ); Whenever a user has an objective, you put a row in the join table indicating the fact. If you want to get the results into a bitset for a user, do an outer join of the user onto the objectives table via the join table, such that you get a row back for every objective, which has a single column with, say, a 1 for each joined objective, or 0 if there was no join. The orthodox approach would also be to use a Set on the Java side, rather than a bitset. That maps very nicely onto the join table. Have you considered doing it this way? If you're worried about memory consumption, a set will use about one pointer per objective a user actually has; the bitset will use a bit per possible objective. Most JVMs have 32-bit pointers (only old or huge-heaped 64-bit JVMs have 64-bit pointers), so if each user has on average less than 1/32nd of the possible objectives, the set will use less memory. There are some groovy data structures which will be able to store this information more compactly than either of those structures, but let's leave that to another question.
