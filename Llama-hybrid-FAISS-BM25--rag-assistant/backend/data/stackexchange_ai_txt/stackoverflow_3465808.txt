[site]: stackoverflow
[post_id]: 3465808
[parent_id]: 3463658
[tags]: 
Here is the short summary: For references, reads/writes are ALWAYS atomic (even in 64 bit implementations!) For int , char , byte , short , boolean , float , reads/writes are ALWAYS atomic For double and long , if they're volatile , reads/writes are ALWAYS atomic Therefore there is only exception where reads/writes may not be atomic: For double and long , if they're NOT declared volatile , they're NOT GUARANTEED to be atomic So as far as atomicity of reading/writing shared data is concerned, you only need to make volatile any double or long . Everything else is already guaranteed to be atomic, regardless of how many bits are used in actual implementation. On the specification Here's the relevant section reproduced here for quick reference: JLS 17.7 Non-atomic Treatment of double and long Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32 bit values. For efficiency's sake, this behavior is implementation specific; Java virtual machines are free to perform writes to long and double values atomically or in two parts. For the purposes of the Java programming language memory model, a single write to a non- volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64 bit value from one write, and the second 32 bits from another write. Writes and reads of volatile long and double values are always atomic. Writes to and reads of references are always atomic, regardless of whether they are implemented as 32 or 64 bit values. VM implementors are encouraged to avoid splitting their 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications. See also JLS 17.6 Word Tearing - guarantees e.g. a byte can be updated without neighbor interference JLS 8.3.1.4 volatile Fields Java Tutorials/Essential Classes/Concurrency/Atomic Variables Note that given int i; , i++ is NOT atomic! Related questions Is there any point in using a volatile long? How to declare array elements volatile in Java? A volatile long[] is volatile reference to an array of long The long elements themselves are not volatile
