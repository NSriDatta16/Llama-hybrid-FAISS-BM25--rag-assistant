[site]: stackoverflow
[post_id]: 5059411
[parent_id]: 5059224
[tags]: 
Actually Java supports 4 methods to parse XML out of the box: DOM Parser/Builder: The whole XML structure is loaded into memory and you can use the well known DOM methods to work with it. DOM also allows you to write to the document with Xslt transformations. Example: public static void parse() throws ParserConfigurationException, IOException, SAXException { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setValidating(true); factory.setIgnoringElementContentWhitespace(true); DocumentBuilder builder = factory.newDocumentBuilder(); File file = new File("test.xml"); Document doc = builder.parse(file); // Do something with the document here. } SAX Parser: Solely to read a XML document. The Sax parser runs through the document and calls callback methods of the user. There are methods for start/end of a document, element and so on. They're defined in org.xml.sax.ContentHandler and there's an empty helper class DefaultHandler. public static void parse() throws ParserConfigurationException, SAXException { SAXParserFactory factory = SAXParserFactory.newInstance(); factory.setValidating(true); SAXParser saxParser = factory.newSAXParser(); File file = new File("test.xml"); saxParser.parse(file, new ElementHandler()); // specify handler } StAx Reader/Writer: This works with a datastream oriented interface. The program asks for the next element when it's ready just like a cursor/iterator. You can also create documents with it. Read document: public static void parse() throws XMLStreamException, IOException { try (FileInputStream fis = new FileInputStream("test.xml")) { XMLInputFactory xmlInFact = XMLInputFactory.newInstance(); XMLStreamReader reader = xmlInFact.createXMLStreamReader(fis); while(reader.hasNext()) { reader.next(); // do something here } } } Write document: public static void parse() throws XMLStreamException, IOException { try (FileOutputStream fos = new FileOutputStream("test.xml")){ XMLOutputFactory xmlOutFact = XMLOutputFactory.newInstance(); XMLStreamWriter writer = xmlOutFact.createXMLStreamWriter(fos); writer.writeStartDocument(); writer.writeStartElement("test"); // write stuff writer.writeEndElement(); } } JAXB: The newest implementation to read XML documents: Is part of Java 6 in v2. This allows us to serialize java objects from a document. You read the document with a class that implements a interface to javax.xml.bind.Unmarshaller (you get a class for this from JAXBContext.newInstance). The context has to be initialized with the used classes, but you just have to specify the root classes and don't have to worry about static referenced classes. You use annotations to specify which classes should be elements (@XmlRootElement) and which fields are elements(@XmlElement) or attributes (@XmlAttribute, what a surprise!) public static void parse() throws JAXBException, IOException { try (FileInputStream adrFile = new FileInputStream("test")) { JAXBContext ctx = JAXBContext.newInstance(RootElementClass.class); Unmarshaller um = ctx.createUnmarshaller(); RootElementClass rootElement = (RootElementClass) um.unmarshal(adrFile); } } Write document: public static void parse(RootElementClass out) throws IOException, JAXBException { try (FileOutputStream adrFile = new FileOutputStream("test.xml")) { JAXBContext ctx = JAXBContext.newInstance(RootElementClass.class); Marshaller ma = ctx.createMarshaller(); ma.marshal(out, adrFile); } } Examples shamelessly copied from some old lecture slides ;-) Edit: About "which API should I use?". Well it depends - not all APIs have the same capabilities as you see, but if you have control over the classes you use to map the XML document JAXB is my personal favorite, really elegant and simple solution (though I haven't used it for really large documents, it could get a bit complex). SAX is pretty easy to use too and just stay away from DOM if you don't have a really good reason to use it - old, clunky API in my opinion. I don't think there are any modern 3rd party libraries that feature anything especially useful that's missing from the STL and the standard libraries have the usual advantages of being extremely well tested, documented and stable.
