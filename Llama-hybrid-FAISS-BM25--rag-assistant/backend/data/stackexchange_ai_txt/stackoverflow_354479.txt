[site]: stackoverflow
[post_id]: 354479
[parent_id]: 348730
[tags]: 
To define a template parameter, you need either to tell the compiler the parameter is a type, or a value. In the begining... If I remember correctly, the C++ committee was reluctant to add a new keyword to the C++ language, and so, they decided to authorize the following notations: template int getTwice() { return I * 2 ; } template std::string getType(const T & t) { return typeid(t).name() ; } void doSomething() { std::cout () () Which outputs, in g++: 25 : 50 5 : 10 type(25) : i type(25.5) : d type(abc) : A4_c The first notation was a template over a value. So, we have the type of the value in the template declaration: // "I" is the value, and "int" is the type of the value template The second notation was a template over a unknown type, and the fact that type was not "known" was marked by a "class" keyword. So, in this context, "class" meant "type". // "T" is a type... And "class" is the "this-is-a-type" keyword template You'll note that with the second notation, despite the class keyword, T could be... a int, or another build-in type. But then, better to have this curiosity than add a new keyword, don't you agree?... Oops... Everything was good and Ok until someone wrote the following code: template // T could be any STL container, for example a vector void printContainerData(const T & t) { std::cout Where T::const_iterator is a type, of course... But then, it could be a static member of a class of type T, and thus, a value. The compiler could be quite confused. In the end... The solution was to tell the compiler that T::const_iterator was really a type... Which would lead with this kind of notation: for(class T::const_iterator it = t.begin(), // etc. But this was thought not possible/correct (class is about classes declarations, no?). So, dragging their feet, they decided a keyword was indeed needed to tell the compiler the symbol was a type, and not a value. "type" was not considered, I guess, because making it a keyword would break a lot of code. So typename was used instead. With typename, we can write: for(typename T::const_iterator it = t.begin(), // etc. And for consistency's sake, we are supposed to use: template When T is supposed to be a type, and not a value. But for compatibility reasons, the old notation: template is still authorized. And what about?? eben proposed an answer above, an answer I wanted to comment, because it is quite interesting: template class U> // must be "class" std::string to_string(const U & u) { return std::string(u.begin(),u.end()); } I will comment only its "meaning" (this code can't be used with STL containers on my g++ compiler, but this was not the point, I guess): One moment, it puts a constraint over U saying: "U is a class templated over the type T. This is the part: template class U Which can be also written: template class U Because U is really and only a class (and not a built-in type), while T is a type, any type. And the next line, it says that U is specialized over char: std::string to_string(const U & u) So, this "generic code" will only work for U if U is declared as: template class U { // Etc. } ; And U is instanciated over a char: U u ; // etc. to_string(u) But one thing was forgotten: The notation proposed by Eben can be written two ways: template class U> std::string to_string(const U & u) template class U> std::string to_string(const U & u) The second "class" keyword is not a "type" keyword per se. It's a type that is a templated class over T. Thus the confusing notation. Another way of writting Eben's code, removing the constraints above, would be something like: template std::string to_string(const U & u) { return std::string(u.begin(),u.end()); } And let the compiler do its magic: std::list myList ; // etc. std::cout (Eben's code didn't work with STL containers templated on "char" on my g++ compiler, for example...)
