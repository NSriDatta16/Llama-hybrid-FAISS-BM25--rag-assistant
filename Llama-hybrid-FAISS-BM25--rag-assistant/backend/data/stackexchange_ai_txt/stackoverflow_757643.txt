[site]: stackoverflow
[post_id]: 757643
[parent_id]: 748503
[tags]: 
We are in the process of doing exactly this. Three years ago I joined the development team on a project with no unit tests, almost no code reviews, and a fairly ad-hoc build process. The code base consists of a set of COM components (ATL/MFC), cross-platform C++ Oracle data cartridge and some Java components, all using a cross-platform C++ core library. Some of the code is nearly a decade old. The first step was adding some unit tests. Unfortunately, the behaviour is very data-driven, so there was some initial effort in generating a unit test framework (initially CppUnit, now extended to other modules with JUnit and NUnit), which uses test data from a database. Most of the initial tests were functional tests which excercised the outermost layers and not really unit tests. You will probably have to expend some effort (which you may need to budget for) to implement a test harness. I find it helps a lot if you make the cost of adding unit tests as low as possible. The test framework made it relatively easy to add tests when fixing bugs in existing functionality, new code can have proper unit tests. As you refactor and implementn new areas of code you can add proper unit tests which test much smaller areas of code. In the last year we have added continuous integration with CruiseControl and automated our build process. This adds much more incentive to keep tests up-to-date and passing, which was a big problem in the early days. So I would recommend that you include regular (at least nightly) unit test runs as part of your development process. We have recently focussed on improving our code review process, which was fairly infrequent and ineffective. The intent is to make it much cheaper to initiate and perform a code review so that developers are encouraged to do them more often. Also as part of our process improvement I am trying to get time for code reviews and unit tests included in project planning at a much lower level in a way that ensures individual developers have to think more about them, whereas previously there was just a fixed proportion of time devoted to them that was much easier to get lost in the schedule.
