[site]: stackoverflow
[post_id]: 3357062
[parent_id]: 3357014
[tags]: 
Remember, IEnumerable and INotifyCollectionChanged are both interfaces - they aren't a definitive type. You can design your concrete class to implement both, with no problems. Your API can return the appropriate interface for the method call. This is, in fact, a good design - not something to avoid. ObservableCollection does this (indirectly via Collection ), and also implements IList as well as other interfaces. If you are making your own custom collection, and plan to use it with data binding, I would make it implement IEnumerable (or potentially IList , if appropriate) and INotifyCollectionChanged . This will give it the best usability, both from code, but also for efficient binding. (and also depend on) However, depending on an interface to exist that isn't part of the API is bad practice. This is dangerous, and part of the reason to return an interface instead of a concrete type is to allow the implementation to change later. By putting a dependency on an interface that isn't declared, you're making your code fragile. That being said, I often do what you're attempting, but it's not a "hard" dependency. Rather, I use IEnumerable , and check for INotifyCollectionChanged - taking advantage of it if it is implemented. I do, however, allow the code to work if the "secondary" interface doesn't exist.
