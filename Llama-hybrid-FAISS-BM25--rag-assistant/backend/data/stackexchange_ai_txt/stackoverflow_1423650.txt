[site]: stackoverflow
[post_id]: 1423650
[parent_id]: 1352422
[tags]: 
It's rather unlikely that you need to help the JIT compiler much with optimizing a straightforward number crunching algorithm like LZW. ShuggyCoUk mentioned this, but I think it deserves extra attention: The cache-friendliness of your code will be a big factor. You have to reduce the size of your woking set and improve data access locality as much as possible. You mention "packing bytes into ints for performance". This sounds like using ints to hold byte values in order to have them word-aligned. Don't do that! The increased data set size will outweigh any gains (I once converted some ECC number crunching code from int[] to byte[] and got a 2x speed-up). On the off chance that you don't know this: if you need to treat some data as both bytes and ints, you don't have to shift and |-mask it - use ByteBuffer.asIntBuffer() and related methods. With current 1.6 JVM, how many elements must be copied before System.arraycopy beats a copying loop? Better do the benchmark yourself. When I did it way back when in Java 1.3 times, it was somewhere around 2000 elements.
