[site]: stackoverflow
[post_id]: 2869309
[parent_id]: 2648122
[tags]: 
I used several commercial alternatives and although they can deliver fantastic results, they also often simply fail to work because of unknown reasons: Rational Quantity: fantastic product for performance profiling, but they failed to release new versions during several years, and often (in my case) the software often refused to work AQTime: also very good (less than Rational Quantity) but also sometimes refuses to work for unknown reasons. Performance validator: same In the last years I returned to the rather crude way of sampling the application. This is not as perfect as using instrumentation, but it's much faster, can be run on any application and always works. My favorite is "Very Sleepy" ( http://www.codersnotes.com/sleepy ) but also Luke StackWalker ( http://lukestackwalker.sourceforge.net/ ) is quite good. Because the applications can be run immediately and without a noticeable slowdown, the "change app, profile" loop is very short and efficient. For finding memory leaks, there are several tools in Windows that you can use. Again, they are far from perfect, and often can only investigate running applications from the outside, not simply reporting leaks at the end of the application. Look for the "Microsoft Debugging Tools" (UMDH, LeakDiag, gflags). Personally, I find it much easier just to write my own memory manager, and let it report the leaks at the end of the application. It's not that hard to write. What you have to do is: Implement the correct new and delete operators (I think you should implement 4 new and 4 delete operators) In the implementation of new, get the call stack (look for StackWalk) and store this with the allocated memory. Make a class that starts your memory manager in the constructor, and report all the leaks (including the call stack) in the destructor. Make a global variable of that class-type. It might be needed to make it a special global variable using a #pragma(init_seg).
