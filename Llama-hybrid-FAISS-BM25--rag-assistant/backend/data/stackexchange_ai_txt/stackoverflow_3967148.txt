[site]: stackoverflow
[post_id]: 3967148
[parent_id]: 3966902
[tags]: 
In the mean time I've managed to get somewhere but, although it solves the problem, the solution is not very elegant. After defining the functions defined in my initial question, I can define the additional function 'enum_pair_cat' as let rec enum_pair_cat ls = lazy( match Lazy.force ls with | Nil -> Nil | Cons(h,t) -> match Lazy.force h with | Nil -> Lazy.force (enum_pair_cat t) | Cons (h2,t2) -> Cons (h2,enum_pair_cat (lazy (Cons (t2,t)))) ) This new function achieves the desired behavior. By doing enum_pair_cat (enum_pair ()) we get a lazy list which has the pairs enumerated as described. So, this solves the problem. However, I am not entirely satisfied with this because this solution doesn't scale up to higher enumerations (say, of three lazy lists). If you have any ideas on how to solve the general problem of enumerating all n-tuples taken from n lazy lists, let me know! Thanks, Surikator.
