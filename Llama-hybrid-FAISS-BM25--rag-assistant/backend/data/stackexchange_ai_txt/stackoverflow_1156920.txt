[site]: stackoverflow
[post_id]: 1156920
[parent_id]: 
[tags]: 
Class Design: Demeter vs. Connection Lifetimes

Okay, so here's a problem I'm running into. I have some classes in my application that have methods that require a database connection. I am torn between two different ways to design the classes, both of which are centered around dependency injection: Provide a property for the connection that is set by the caller prior to method invocation. This has a few drawbacks. Every method relying on the connection property has to validate that property to ensure that it isn't null, it's open and not involved in a transaction if that's going to muck up the operation. If the connection property is unexpectedly closed, all the methods have to either (1.) throw an exception or (2.) coerce it open. Depending on the level of robustness you want, either case is appropriate. (Note that this is different from a connection that is passed to a method in that the reference to the connection exists for the lifetime of the object, not simply for the lifetime of the method invocation. Consequently, the volatility of the connection just seems higher to me.) Providing a Connection property seems (to me, anyway) to scream out for a corresponding Transaction property. This creates additional overhead in the documentation, since you'd have to make it fairly obvious when the transaction was being used, and when it wasn't. On the other hand, Microsoft seems to favor the whole set-and-invoke paradigm. Require the connection to be passed as an argument to the method. This has a few advantages and disadvantages: The parameter list is naturally larger. This is irksome to me, primarily at the point of call. While a connection (and a transaction) must still be validated prior to use, the reference to it exists only for the duration of the method call. The point of call is, however, quite clear. It's very obvious that you must provide the connection, and that the method won't be creating one behind your back automagically. If a method doesn't require a transaction (say a method that only retrieves data from the database), no transaction is required. There's no lack of clarity due to the method signature. If a method requires a transaction, it's very clear due to the method signature. Again, there's no lack of clarity. Because the class does not expose a Connection or a Transaction property, there's no chance of callers trying to drill down through them to their properties and methods, thus enforcing the Law of Demeter. I know, it's a lot. But on the one hand, there's the Microsoft Way: Provide properties, let the caller set the properties, and then invoke methods. That way, you don't have to create complex constructors or factory methods and the like. Also, avoid methods with lots of arguments. Then, there's the simple fact that if I expose these two properties on my objects, they'll tend to encourage consumers to use them in nefarious ways. (Not that I'm responsible for that, but still.) But I just don't really want to write crappy code. If you were in my shoes, what would you do?
