[site]: stackoverflow
[post_id]: 3127403
[parent_id]: 3120035
[tags]: 
I still hope for answers, however here is what I could come up so far, following @Moron suggestion. Apparently my little Fenwick Tree idea cannot be easily adapted. It's easy to append new buckets at the end of the fenwick tree, but not in it the middle, so it's kind of a lost cause. We're left with 2 data structures: Binary Indexed Trees (ironically the very name Fenwick used to describe his structure) and Ranked Skip List. Typically, this does not separate the data from the index, however we can get this behavior by: Use indirection: the element held by the node is a pointer to a bucket, not the bucket itself Use pool allocation so that the index elements, even though allocated independently from one another, are still close in memory which shall helps the cache I tend to prefer Skip Lists to Binary Trees because they are self-organizing, so I'm spared the trouble of constantly re-balancing my tree. These structures would allow to get to the ith element in O(log N) , I don't know if it's possible to get faster asymptotic performance. Another interesting implementation detail is I have a pointer to this element, but others might have been inserted/removed, how do I know the rank of my element now? It's possible if the bucket points back to the node that owns it. But this means that either the node should not move or it should update the bucket's pointer when moved around.
