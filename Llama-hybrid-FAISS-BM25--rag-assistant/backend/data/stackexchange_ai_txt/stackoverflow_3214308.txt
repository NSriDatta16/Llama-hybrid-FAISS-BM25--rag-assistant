[site]: stackoverflow
[post_id]: 3214308
[parent_id]: 3214278
[tags]: 
Suppose you had a local variable: int member; You could make a pointer to it with: int *ptr = &member; To get the pointer to member syntax, we just append mycls:: in the appropriate places: int mycls::*member = &mycls::member; It might be clearer with an example that shows how the pointer can switch between any members of the class that are of the correct type: class C { public: int a; int b; }; void main() { // make pointer to member, initially pointing to a int C::*ptrToMember = &C::a; C x; C *ptrToObj = &x; // make pointer to object x ptrToObj->*ptrToMember = 2; // store in a; ptrToMember = &C::b; // change pointer to b ptrToObj->*ptrToMember = 3; // store in b; } Note how we create the pointer to the member a before we've created an object of type C . It's only a pointer to a member, not a pointer to the member of a specific object. In the 'store' steps, we have to say which object as well as which member. Update In the comments the OP asked if this is the same: int *ptr = &(ptrToObj->a); No, it's not. That is a pointer to any int , anywhere in memory. The easiest way to understand this is to think of what it means technically. A "pointer" is an absolute location in memory: where to find an object. A "pointer-to-member" is a relative location, sometimes called an offset: where to find an object within the storage of an outer object. Internally they are just numbers. A pointer-to-member has to be added to an ordinary pointer to make another pointer. So if you have a pointer to an object (an int is an object!), you can use it to change what is stored at that absolute location in memory: *ptr = 123; But if you have a pointer-to-member, it is not a memory location. It is an offset, an amount to be added to a memory location. You cannot use it by itself. You must "add" it to an object pointer: ptrToObj->*ptrToMember = 132; This means: go to the location in memory ptrToObj , then move along by the distance ptrToMember .
