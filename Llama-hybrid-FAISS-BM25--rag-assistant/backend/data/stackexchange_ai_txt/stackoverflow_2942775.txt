[site]: stackoverflow
[post_id]: 2942775
[parent_id]: 2942616
[tags]: 
I did the following profiling: let test() = tic() let mutable a = 0.0 for i=1 to 10 do for j=1 to 10000000 do a the average for mutable is 50ms, while ref 600ms. The performance difference is due to that mutable variables are in stack, while ref variables are in managed heap. The relative difference is big. However, 10^8 times of access is a big number. And the total time is acceptable. So don't worry too much about the performance of ref variables. And remember: Premature optimization is the root of all evil. My advice is you first finish your parser, then consider optimizing it. You won't know where the bottomneck is until you actually run the program. One good thing about F# is that its terse syntax and functional style well support code refactoring. Once the code is done, optimizing it would be convenient. Here 's an profiling example. Just another example, we use .net arrays everyday, which is also in managed heap: let test3() = tic() let a = Array.create 1 0.0 for i=1 to 10 do for j=1 to 10000000 do a.[0] test3() runs about the same as ref's. If you worry too much of variables in managed heap, then you won't use array anymore.
