[site]: stackoverflow
[post_id]: 5614526
[parent_id]: 
[tags]: 
List<> collection members changing when they aren't supposed to

I have a List that I have populated in the main method of a console project. I pass this population to a method which is meant to take two members of the population and decompose and recombine them in a way to create two new unique members which will later be added to the population. However when I manipulate the two original members to create the two new unique members the two original members change with in the initial population (hence altering the initial population).This means that when I go to add the new members I get duplication of entries into the List. I'm not doing anything overly complicated I think I am just doing something stupid. Does any one have any insight as to why this is happening ? Here is the method that gets called to choose to initial two members of the population: public static List > runEpoch(Random rand, List > population, SelectionMethod selectionMethod) { int populationSize = population.Count; int selectionCount = (int)Math.Truncate((population.Count * 0.75)); if (selectionMethod == SelectionMethod.Tournament) { for (int i = 0; i parent = selection.runTournament(rand, population); Chromosome parentTwo = selection.runTournament(rand, population); //Checks for the presence of incestuous mating. In some cases incestuous mating causes a stack overflow to occur that the program can not recover from if (parent != parentTwo) { //where runGeneOperators calls the crossOver method directly offSpring = runGeneOperators(rand, parent, parentTwo); } else { i--; } } } else { //NSGAII } //fixPopulation is meant to sort and remove any excess members return fixPopulation(rand, population, selectionMethod, populationSize); ; } And here is the code that is creating the two new unique members : public List > crossOver(Random rand, Chromosome parentOne, Chromosome parentTwo) { List > offSpring = new List >(); int crossPtOne = rand.Next(0, parentOne.Length); int crossPtTwo = rand.Next(0, parentTwo.Length); if ((crossPtOne == 0) && (crossPtTwo == 0)) { offSpring.Add(parentOne); offSpring.Add(parentTwo); return offSpring; } else { GeneNode fragOne = parentOne.Children[crossPtOne]; GeneNode fragTwo = parentTwo.Children[crossPtTwo]; crossOverPoint = crossPtOne; GeneNode genotype = performCrossOver(parentOne.Genotype, fragTwo); success = false; parentOne.repair(genotype); offSpring.Add(parentOne); crossOverPoint = crossPtTwo; GeneNode genotype2 = performCrossOver(parentTwo.Genotype, fragOne); success = false; parentTwo.repair(genotype2); offSpring.Add(parentTwo); } return offSpring; } private GeneNode performCrossOver(GeneNode tree, GeneNode frag) { if (tree != null) { if (crossOverPoint > 0) { if (!success && tree.Left != null) { crossOverPoint--; tree.Children[0] = performCrossOver(tree.Left, frag); } } if (crossOverPoint > 0) { if (!success && tree.Right != null) { crossOverPoint--; tree.Children[1] = performCrossOver(tree.Right, frag); } } } if (!success) { if (crossOverPoint == 0) { success = true; return frag; } } return tree; }
