[site]: stackoverflow
[post_id]: 2243717
[parent_id]: 2243225
[tags]: 
Given from the information in the question, I'd probably use a Command Pattern All Rooms should implement a parse() command interface Parseable { public function parse($arr, $dept); } A room instance could look like this class Room implements Parseable { protected $_price; protected $_adults; public function parse($arr, $dept) { // nonsense calculation, exchange with your parse logic $this->_price = $arr * $dept * rand(); return $this; } public function getPrice() { return $this->_price; } } To go through them, I'd add them to an Invoker that stores all rooms and knows how to invoke their parse() method and also knows what to do with the return from parse(), if necessary class RoomParser extends SplObjectStorage { // makes sure we only have objects implementing parse() in store public function attach(Parseable $obj) { parent::attach($obj); } // invoking all parse() methods in Rooms public function parseRooms($arr, $dept) { for($this->rewind(); $this->valid(); $this->next()) { $ret = $this->current()->parse($arr, $dept); // do something with $ret echo $ret->getPrice(), PHP_EOL; } } // other methods } And then you could use it like this: $parser = new RoomParser; $parser->attach(new Room); $parser->attach(new Room); $parser->attach(new Room); $parser->attach(new Room); echo $parser->count(), ' Rooms', PHP_EOL; $parser->parseRooms(1,2); Note that the Invoker extends SplObjectStorage , so it implements Countable, Iterator, Traversable, Serializable and ArrayAccess.
