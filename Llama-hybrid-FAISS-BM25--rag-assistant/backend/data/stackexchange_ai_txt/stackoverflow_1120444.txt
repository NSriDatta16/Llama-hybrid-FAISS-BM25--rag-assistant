[site]: stackoverflow
[post_id]: 1120444
[parent_id]: 1120334
[tags]: 
From my perspective, this is something I ran into when I first tried to separate out my Models, Views and Controllers in my first desktop application. With Web Applications, the MVC pattern fits VERY naturally because of the innate nature of the web, but unfortunately it's not possible to fit a pure MVC patter to a desktop app, where the Operating system plays an innate role in notifications. This usually leads to the pattern being implemented as you've shown in your diagram. However the pattern that you've shown really needs to be implemented like this, I think (I've switched over to .NET after a brief affair with Java, so please keep that in mind): public class ContactManagerMainScreenModel { ContactManagerMainScreen v; // Loading Local Storage LocalContactStorage LocalContactStorage = new LocalContactStorage(); // Favorite list boolean showFavoritesList = true; public void register(ContactManagerMainScreen v) { this.v = v; } public void ShowOrHideFavoritesList() { if(showFavoritesList) { showFavoritesList = false; v.RefreshView(this); } else { showFavoritesList = true; v.RefreshView(this); } } } Meanwhile the controller would be responsible for receiving user actions. So if you have a button that says "Toggle Favorites", this would cause the controller to call _model.ShowOrHideFavoritesList(). The model would update itself and ask the view to refresh itself using it's new state. The view would now be free from the dependency on the controller.
