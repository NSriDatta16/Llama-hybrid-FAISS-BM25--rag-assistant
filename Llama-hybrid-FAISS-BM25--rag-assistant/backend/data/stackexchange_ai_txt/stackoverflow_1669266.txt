[site]: stackoverflow
[post_id]: 1669266
[parent_id]: 1668645
[tags]: 
You can always register your types into some sort of registry (managed by a string list or dictionary) and create a factory function to then return the appropriate object. Unfortunately you would have to know in advance what types you were going to need. Something similar to the Delphi functions RegisterClass and FindClass (in the classes unit). My thinking is to put the generic template type into the list directly. An example of possible usage: RegisterCustomType('Integer',TSomeType ); RegisterCustomType('String',TSomeType ); if FindCustomType('Integer') <> nil then O := FindCustomType('Integer').Create; EDIT: Here is a specific simple implementation using a tDictionary from Generics.Collections to handle the registry storage...I'll leave extracting this into useful methods as a simple exercise for the reader. var o : TObject; begin TypeDict := TDictionary .Create; TypeDict.Add('integer',TList ); if TypeDict.ContainsKey('integer') then o := TypeDict.Items['integer'].Create; if Assigned(o) then ShowMessage(o.ClassName); end; Another EDIT: I was giving this some thought last night, and discovered another technique that you can merge into this concept. Interfaces. Here is a quick do nothing example, but can easily be extended: TYPE ITest = interface ['{0DD03794-6713-47A0-BBE5-58F4719F494E}'] end; TIntfList = class(TList ,ITest) public function QueryInterface(const IID: TGUID; out Obj): HRESULT; stdcall; function _AddRef: Integer; stdcall; function _Release: Integer; stdcall; end; procedure TForm1.Button7Click(Sender: TObject); var o : TObject; fTestIntf : ITest; begin TypeDict := TDictionary .Create; TypeDict.Add('integer',TIntfList ); if TypeDict.ContainsKey('integer') then o := TypeDict.Items['integer'].Create; if Assigned(o) and Supports(o,ITest,fTestIntf) then ShowMessage(o.ClassName); end; of course you would have to implement the QueryInterface, _AddRef and _Release methods and extend the interface to do something more useful.
