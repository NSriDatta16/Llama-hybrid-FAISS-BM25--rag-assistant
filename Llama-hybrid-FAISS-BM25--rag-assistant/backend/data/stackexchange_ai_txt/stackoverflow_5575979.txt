[site]: stackoverflow
[post_id]: 5575979
[parent_id]: 5575915
[tags]: 
The closest approximation in C99 (but not C89) is to have a flexible array member at the end of the structure: struct Var_Members_Interface { int intMember; char *charMember; Type flexArrayMember[]; }; You can now dynamically allocate the structure with an array of the type Type at the end, and access the array: struct Var_Members_Interface *vmi = malloc(sizeof(*vmi) + N * sizeof(Type)); vmi->flexArrayMember[i] = ...; Note that this cannot be used in C++. But that isn't a very close approximation to what you are after. What you are after cannot be done in C with a single structure type, and can only be approximated in C++ via inheritance - see other answers. One trick that you can get away with - usually - in C uses multiple structure types and lots of casts: struct VM_Base { int intMember; char *charMember; }; struct VM_Variant1 { int intMember; char *charMember; int intArray[3]; }; struct VM_Variant2 { int intMember; char *charMember; Type typeMember; }; struct VM_Variant3 { int intMember; char *charMember; double doubleMember; }; Now, with some sledgehammering casts, you can write functions which take ' struct VM_Base * ' arguments, and pass in a pointer to any of the VM_VariantN types. The ' intMember ' can probably be used to tell which of the variants you actually have. This is more or less what happens with the POSIX sockets functions. There are different types of socket address, and the structures have different lengths, but they have a common prefix, and the correct code ends up being called because the common prefix identifies the type of socket address. (The design is not elegant; but it was standard - a de facto standard from BSD sockets - before POSIX standardized it. And the BSD design pre-dates C89, let alone C99. Were it being designed now, from scratch, with no requirement for compatibility with existing code, it would be done differently.) This technique is ugly as sin and requires casts galore to make it compile -- and great care to make it work correctly. You shouldn't bother with this sort of mess in C++.
