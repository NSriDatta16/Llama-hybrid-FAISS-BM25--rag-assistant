[site]: stackoverflow
[post_id]: 3128343
[parent_id]: 3124001
[tags]: 
I asked this question with three intentions: memory issue (autorelease?), usage of self , and what is the best practice of Fluent Interface pattern in ObjC. Thanks for all the great answers and thoughtful analysis. However, I am not convinced. I disagree to avoid FI at all in ObjC. I think that it is actually a design and architecture issue. If you can build a class with well structured FI pattern, you will see its beauty and nice usages, and easy maintenance. Although I am a newbie in ObjC with not so much memories or experience, I do see many good practices of FI and their extensive usages in many open source projects, languages and frameworks. Here are some of my arguments: Debugging is not an issue at all. I am not a big fan of compiling-time-debugger, or doing debug in Xcode, in case of ObjC. I would be lost if I stepped in to and out several calls. I just cannot remember or track all the states of variables or instances. In addition to that, compile-time-debug is very different from run time, or just impossible in some cases. For example, events and threads would drive you crazy. Compile-time-debug, I think, just wastes time and energy, and it is my last resort. If you feel pain debugging FI, don't blame FI, sit back and ask yourself if you are doing it in the right way? Instead, I would use tools like NSLog(), some other tools(like my own wrapper class MyLogger , not finished yet, but soon), or unit tests to help me out. Unexpect nil is a very interesting feature of ObjeC(it does not cause exception). If this happen to me, I would not blame FI. Do I have have good design, is FI suitable for the case, just my careless or stupid bugs in my codes? I don't put full trust to my codes unless I can prove it with my unit tests. In other words, I would spend time and efforts to write unit tests to cover all the cases and the logic flow. By doing this, I have a safe guard not only for the current codes, but also for the future maintenance or updates. Good design and practice of FI makes refactoring much easy. FI has been used in many cases such a serials preparations for a final action, configuration, creation of instances, and more. For example, if I have fragments of codes to set up something for preparation with some temporary variables for an action, a specific configuration, or creation of a result instance, I would think about to encapsulate those fragments into a FI API class with easy-understand methods as chainable elements. The class provides fluent and flexible chain to express the logic. It is not only easy for read, but also for flexible reuse and maintenance. FI is a chained flow, one call next immediately to the next. This prevents any accidental insertions or deletions. Just image someone else come to my codes and don't fully understand the preparation and logic flow of fragment codes, accidental changes may break the app. It may looks ugly at first, and may people don't like it at first glance. However, you will see the benefices and good reason for a well design FI API if you are willing to learn, to see what in side the class if possible, and the usages of the API. I think, ugly hinds a subjective view and refusing to learn. FI is not a structure of a fixed work flow, like many fragments of codes do. FI actually provides a flexible way to chain small and well defined actions or settings together to cover various cases. In case of fragments hard to understand and/or maintain, FI may be a solution to refactory the codes into an easy read fluent chain logic. Don't abuse FI. That is the most common reason to make ugly codes and hard-to-understand codes. If FI does not fit, don't use it. FI is not a perfect solution, but it provides a pattern to encapsulate intermediate preparations and expose a flexible chained logic. Do do a well designed FI framework or API is not easy. To learn its usage needs effort. You weight the pros and cons.
