[site]: stackoverflow
[post_id]: 3282648
[parent_id]: 3282041
[tags]: 
I think I have two possible solutions. I am not particularly satisfied with either, but they do at least provide a reasonable alternative to the APM approach. The first does not meet your requirement of no blocking thread, but I think it is rather elegant because you can register callbacks and they will get called in round-robin fashion, but you still have the ability to call Take or TryTake as you normally would for a BlockingCollection . This code forces callbacks to be registered each time an item is requested. That is the signalling mechanism for the collection. The nice thing about this approach is that calls to Take do not get starved as they do in my second solution. public class NotifyingBlockingCollection : BlockingCollection { private Thread m_Notifier; private BlockingCollection > m_Callbacks = new BlockingCollection >(); public NotifyingBlockingCollection() { m_Notifier = new Thread(Notify); m_Notifier.IsBackground = true; m_Notifier.Start(); } private void Notify() { while (true) { Action callback = m_Callbacks.Take(); T item = Take(); callback.BeginInvoke(item, null, null); // Transfer to the thread pool. } } public void RegisterForTake(Action callback) { m_Callbacks.Add(callback); } } The second does meet your requirement of no blocking thread. Notice how it transfers the invocation of the callback to the thread pool. I did this because I am thinking that if it got executed synchronously then the locks would be held longer resulting in the bottlenecking of Add and RegisterForTake . I have looked it over closely and I do not think it can get live locked (both an item and a callback are available, but the callback never gets executed) but you might want to look it over yourself to verify. The only problem here is that a call to Take would get starved as callbacks always take priority. public class NotifyingBlockingCollection { private BlockingCollection m_Items = new BlockingCollection (); private Queue > m_Callbacks = new Queue >(); public NotifyingBlockingCollection() { } public void Add(T item) { lock (m_Callbacks) { if (m_Callbacks.Count > 0) { Action callback = m_Callbacks.Dequeue(); callback.BeginInvoke(item, null, null); // Transfer to the thread pool. } else { m_Items.Add(item); } } } public T Take() { return m_Items.Take(); } public void RegisterForTake(Action callback) { lock (m_Callbacks) { T item; if (m_Items.TryTake(out item)) { callback.BeginInvoke(item, null, null); // Transfer to the thread pool. } else { m_Callbacks.Enqueue(callback); } } } }
