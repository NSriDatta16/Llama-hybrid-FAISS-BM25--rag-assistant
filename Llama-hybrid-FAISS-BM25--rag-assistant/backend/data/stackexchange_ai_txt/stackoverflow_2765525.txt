[site]: stackoverflow
[post_id]: 2765525
[parent_id]: 
[tags]: 
How do I obtain the current or next event from google calendar using google API?

Introduction I am attempting to replace an "on-call" cell phone which is carried by the on-call programmer on their assigned day. If there is an emergency the help desk calls that cell phone. We are now planning to switch to a web form which the help desk will fill out in emergency instead. When the form is submitted the script will talk to Google calendar (using php api), see who is on call, and send a text message to the programmer on-call at that time alerting him/her to the emergency. If nobody is on call at the current time then the next person on call will receive an email so they can work with the issue first thing the next morning. We have all of this working, except recurring events. Playing with single events and setting it to true worked fine until I decided to let the query handle retrieval of current events (instead of retrieving a bunch of events and checking times manually myself). For example, if someone is currently on call a current event with that programmer's name should exist and be returned. This event may or may not be recurring depending on if somebody has traded days. If no events are currently scheduled then I fall to an else which emails the next on call person instead of sending a text message. In the else section I switch the start max to 7 days in the future. The query code looks like this. $now = date("c"); $gdataCal = new Zend_Gdata_Calendar($client); $query = $gdataCal->newEventQuery(); $query->setUser('[our_resource_is_here]@resource.calendar.google.com'); $query->setVisibility('private'); $query->setProjection('full'); $query->setOrderby('starttime'); $query->setStartMin($now); $query->setStartMax($now); $query->setFutureevents(false); $query->setSingleevents(true); $query->setSortorder('a'); $eventFeed = $gdataCal->getCalendarEventFeed($query); foreach ($eventFeed as $event) { foreach ($event->when as $when) { echo $when->startTime.''; echo $when->endTime.''; echo $event->title->text.''; } } Steps taken 1) I create a recurring event spanning from 8-5 with no end to the recurrence period. 2) I then delete a single event (to test someone trading days) and add another event for giggles (other event is not necessary but helps show the problem). Info on Data below: The recurring event that is deleted in the query range is titled "Ben" and the second event that is not recurring that really is scheduled on that day is called "test." Output when returning title, start time, and end time is as follows. Please remember there is not a "Ben" event on the calendar, but it shows up 3 times anyway, even with start time limits set very strictly (see $now in code). with $query->setSingleevents(false);" 2010-05-03T08:00:00.000-05:00 2010-05-03T17:00:00.000-05:00 Ben 2010-05-03T08:00:00.000-05:00 2010-05-03T17:00:00.000-05:00 Ben 2010-05-03T08:00:00.000-05:00 2010-05-03T17:00:00.000-05:00 Ben 2010-05-03T13:30:00.000-05:00 2010-05-03T15:00:00.000-05:00 test with "$query->setSingleevents(true);" 2010-05-03T13:30:00.000-05:00 2010-05-03T15:00:00.000-05:00 test Explanation of Results I really only want the function returning a single name of someone (ie. the current event only). If the current event doesn't exist then I pull the next 7 days worth of events to be sure to catch any weekends and holidays, and return the first upcoming event. The second output above (single events set to true) looks like it solves the problem, but it only solves the problem when a non-recurring event exists. If I leave everything recurring then no data is returned if I have setSingleevents(true). I have a hunch that this is related to my setting of min and max start times to $now (current time), but since this works fine with non-recurring I do not understand what the problem is (especially when I'm trying to treat recurring events as their own single events. Again, this seems to all work fine unless I use recurring events (manually adding times every week is not a very good solution in my opinion). -- Thanks for your help, Ben
