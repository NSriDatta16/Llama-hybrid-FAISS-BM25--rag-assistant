[site]: stackoverflow
[post_id]: 2004848
[parent_id]: 2004820
[tags]: 
You cannot override them separately, you must override both at once: struct Interface1 { virtual void Name() = 0; }; struct Interface2 { virtual void Name() = 0; }; struct RealClass : Interface1, Interface2 { virtual void Name(); }; // and move it out of the class definition just like any other method: void RealClass::Name() { printf("Interface1 OK?\n"); printf("Interface2 OK?\n"); } You can simulate individual overriding with intermediate base classes: struct RealClass1 : Interface1 { virtual void Name() { printf("Interface1 OK?\n"); } }; struct RealClass2 : Interface2 { virtual void Name() { printf("Interface2 OK?\n"); } }; struct RealClass : RealClass1, RealClass2 { virtual void Name() { // you must still decide what to do here, which is likely calling both: RealClass1::Name(); RealClass2::Name(); // or doing something else entirely // but note: this is the function which will be called in all cases // of *virtual dispatch* (for instances of this class), as it is the // final overrider, the above separate definition is merely // code-organization convenience } }; Additionally, you're using reinterpret_cast incorrectly, you should have: int main() { RealClass rc; // no need for dynamic allocation in this example Interface1& one = rc; one.Name(); Interface2& two = dynamic_cast (one); two.Name(); return 0; } And here's a rewrite with CRTP that might be what you want (or not): template struct RealClass1 : Interface1 { #define self (*static_cast (this)) virtual void Name() { printf("Interface1 for %s\n", self.name.c_str()); } #undef self }; template struct RealClass2 : Interface2 { #define self (*static_cast (this)) virtual void Name() { printf("Interface2 for %s\n", self.name.c_str()); } #undef self }; struct RealClass : RealClass1 , RealClass2 { std::string name; RealClass() : name("real code would have members you need to access") {} }; But note that here you cannot call Name on a RealClass now (with virtual dispatch, e.g. rc.Name() ), you must first select a base. The self macro is an easy way to clean up CRTP casts (usually member access is much more common in the CRTP base), but it can be improved . There's a brief discussion of virtual dispatch in one of my other answers , but surely a better one around if someone has a link.
