[site]: stackoverflow
[post_id]: 2576488
[parent_id]: 2537958
[tags]: 
Phil Haack has an excellent article Localizing ASP.Net MVC Validation which specifically guides you through overriding your strings. This article applies more to DataAnnotations than it does ASP.net MVC . So, this will help however your are using DataAnnotattions . Below I have listed the simplest steps to add Localized Resources in Visual Studio. Open the Project Properties dialog. Select the Resources tab. Click to create a new default resources file . This will create two files in your Properties folder. Resources.resx Resources.Designer.cs When Resources.resx has opened, change it's Access Modifier to Public . Add your strings. To add additional resource files for specific cultures you will need to. Right click your Project in the Solution Explorer . Select Add -> New Item -> Resource File. Name it Resources.en-us.resx . (replace 'en-us' with appropriate code) Click Add Drag it into the Properties folder. Open Resources.en-us.resx and change it's Access Modifier to Public . Add your strings. Repeat for each Culture you need to support. During the build VS will convert the .resx files to .resource files and build wrapper classes for you. You can then access via the namespace YourAssembly.Properties.Resources . With this using statement. using YourAssembly.Properties; You can decorate with attributes like this: [Required(ErrorMessageResourceType = typeof(Resources), ErrorMessageResourceName = "MyStringName")] Note: I used the Properties folder for consistency. To use the App_GlobalResources move your .resx files there and change your using statement to match the directory name. Like this: using YourAssembly.App_GlobalResources; Edit: The closest that you can get to Strongly Typed resource names would be to do something like this: public class ResourceNames { public const string EmailRequired = "EmailRequired"; } You can then decorate with attributes like this. [Required(ErrorMessageResourceType = typeof(Resources), ErrorMessageResourceName = ResourceNames.EmailRequired)] To enable automatic client culture detection add the globalizationsection to the web.config file. Here I have enabled a client based culture and set the culture and the uiculture to " auto " with a default of " en-us ". Creating Separate Satellite Assemblies: The MSDN Creating Satellite Assemblies article will help as well. If you are new to satellite assemblies make sure you read Packaging and Deploying Resources . When creating satellite assemblies in the past, I have found it useful to use VS build events. These are the steps I would take. Create a separate Class Library project in my solution. Create or Add my .resx files to this project. Add a Post-Build Event to the Project Properties dialog. (Like the one below) Sample VS Post-Build Script: set RESGEN="C:\Program Files\Microsoft SDKs\Windows\v6.0A\bin\resgen.exe" set LINKER="C:\Program Files\Microsoft SDKs\Windows\v6.0A\bin\al.exe" set ASSEMBLY=$(TargetName) set SOURCEDIR=$(ProjectDir) Set OUTDIR=$(TargetDir) REM Build Default Culture Resources (en) %RESGEN% %SOURCEDIR%en\%ASSEMBLY%.en.resx %SOURCEDIR%en\%ASSEMBLY%.resources REM Embed Default Culture %LINKER% /t:lib /embed:%SOURCEDIR%en\%ASSEMBLY%.resources /culture:en /out:%OUTDIR%%ASSEMBLY%.resources.dll REM Embed English Culture IF NOT EXIST %OUTDIR%en\ MKDIR $%OUTDIR%en\ %LINKER% /t:lib /embed:%SOURCEDIR%en\%ASSEMBLY%.resources /culture:en /out:%OUTDIR%en\%ASSEMBLY%.resources.dll REM These are just a byproduct of using the project build event to run the resource build script IF EXIST %OUTDIR%%ASSEMBLY%.dll DEL %OUTDIR%%ASSEMBLY%.dll IF EXIST %OUTDIR%%ASSEMBLY%.pdb DEL %OUTDIR%%ASSEMBLY%.pdb If you would prefer not to use ResGen.exe to convert your .resx files, you could do something like this. using System; using System.Collections; using System.IO; using System.Resources; namespace ResXConverter { public class ResxToResource { public void Convert(string resxPath, string resourcePath) { using (ResXResourceReader resxReader = new ResXResourceReader(resxPath)) using (IResourceWriter resWriter = new ResourceWriter( new FileStream(resourcePath, FileMode.Create, FileAccess.Write))) { foreach (DictionaryEntry entry in resxReader) { resWriter.AddResource(entry.Key.ToString(), entry.Value); } resWriter.Generate(); resWriter.Close(); } } } } One of the potential draw backs to doing the conversion this way is the need to reference the System.Windows.Forms.dll . You will still need to use Assembly Linker . Edit: As wRAR has reminded us if you are signing your assemblies your keys must match .
