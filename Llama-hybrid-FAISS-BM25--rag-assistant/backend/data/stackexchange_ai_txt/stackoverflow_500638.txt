[site]: stackoverflow
[post_id]: 500638
[parent_id]: 500424
[tags]: 
Disclaimer: I am by no means a Ruby or Rails expert. As someone who's been in the industry for nigh on 15 years I see several warning signs that make me nervous about Ruby on Rails specifically. I'm going to ignore the language here because a language is a language. Ruby is a modern language with closures, exceptions, OO, etc. Some criticize it with regards to performance. These issues are largely irrelevant in that they don't impact real world performance (if it takes 300ms to download and display a Web page, who cares that the serverside codes takes 10, 20 or even 30ms to run?) and transitory in that they are fixed in later versions (as seems to be the case with Ruby 1.9). Ruby on Rails is a closed, heavyweight stack. I mean this as an observation not an accusation. It is tightly integrated (including with Prototype) much like JBoss Seam in the Java world (being integrated tightly with JBoss/Hibernate and yes I know recent releases and articles have tackled the issue of using it with, say, Glassfish and another JPA provider) This can be both a good thing and a bad thing. J2EE, for example, being a fairly open stack was the cause for much innovation in the software industry in the last decade as almost every piece of it (notably EJB) was replaced by different projects that could be slotted together. And of course it was, if not the birthplace for Spring, it was certainly the incubator. On the other hand you have more closed stacks like .Net where their closed nature allows for rapid innovation, a model Microsoft has (generally) excelled at. In a few short years DirextX went from being a joke to completely trouncing OpenGL as a games development platform because any closed system can evolve that much faster than an open standards system. That's just how it works. The other relevant point I'll mention is that in recent years there has been a move towards ORMs ("object-relational mapping") in Java, .Net and elsewhere and this is part of the impetus behind Rails. I've commented on this previously, for example "Using an ORM or plain SQL?" and I won't reiterate those points in their entirety. As most of you would know there is a mismatch between the object and relational worlds that ORMs have sought to bridge. In the last year or two I've dealt with this mainly through Java (JPA specifically). Now when you bridge between two things that don't match you end up with "leaky abstractions" (as Joel put it): All non-trivial abstractions, to some degree, are leaky. Now what I'll add is this: there is an inverse relationship between the complexity of the abstraction and how leaky the abstraction is. Case in point: ibatis . Ibatis is an extremely lightweight yet powerful persistence framework for Java and one I'm a huge fan of. It wraps SQL in external files and on top of that puts many modern ORM behaviour, such as: Lazy-loading of relationships; Result mapping; Grouping of results to multiple levels (something JPA can't do ); and Discriminated types (ie the type is determined the data). I would estimate that ibatis has 90-95% of the functionality of Hibernate with the only complexity overhead being runtime bytecode enhancement for the lazy loading via cglib (JPA does it the same way) with the only downside that you have to write your own queries (and I don't consider that a serious downside but opnions will vary). Compare that to a JPA provider that relies on instrumentation, load-time weaving and non-standard class loaders to implemennt that extra 5-10% functionality (and the abstraction is still leaky). So there is a law of diminishing returns when it comes to making things less leaky. At some point you're better off investing in a bilge pump than you are in fixing every leak in the boat. Bringing this back to Rails: the leaky abstraction argument is my biggest problem with the Rails philosophy. What also rings alarm bells for me is the comments you get in posts like On Derek Siver’s Return to PHP… is: "Derek chose the technology for the wrong reasons.": wait... isn't RoR either a general-purpose Web application framework or a pretty close facsimile? That being the case, why can't you do a site like CDbaby in it? "Rails didn’t fit Derek’s application model for CD Baby": How so? "He ignored his existing experts for the new technology.": wait... didn't he hire an expert? "sorry Derek, you might still be getting your hands dirty with code, but you’re still management": I agree with the comment that this quote is "asinine" and will add that its misleading, irrelevant and arguably a strawman; "Derek approached the project as a whole-environment ground-up rewrite with a One Big Day deployment": arguably not advisable but if you're willing to spend the time and money on it, I don't see it as a reason why you can't do the site in RoR. Now 5-7 years ago when EJB was hyped up you got criticisms of it based on lots of things and you'd get stalwart defenders arguing: "Application X didn't fit the EJB model"; "They didn't understand how EJB works"; "EJB is not for all applications" (they'd rather concede defeat on this one than face the more glaring issue that it's not really appropriate let alone a good idea for, well, just about anything); etc. So the anti-Ruby posts (and especially their rebuttals) all sound very familiar to me. It's worth mentioning the year old rant "Rails is a Ghetto" by Zed Shaw, which is a 6000 odd word rant ("conflagration" is probably a better word) against Rails. Some notable quotes: This is exactly what makes Rails a ghetto. A bunch of half-trained former PHP morons who never bother to sit down and really learn the computer science they were too good to study in college. and Notice how it took me a few seconds to reply. This one single statement basically means that we all got duped. The main Rails application that DHH created required restarting _400 times/day. That’s a production application that can’t stay up for more than 4 minutes on average. and (on memory leaks): That’s one more reason Rails is ghetto as hell. Important patches like the above go largely ignored by the Japanese developers, and while they are very nice guys, the above just smacks of amateur hour. and The best part about the whole thing is there’s potentially 10 new web frameworks that can take on Rails. Hell, Mongrel spawned or helped 5 of those. My favorite of those frameworks is Merb which is literally “Mongrel plus Erb” but now it uses Erubis mostly. What I love about Merb is that it proved you could make a fast thread safe Ruby web framework with all the same ideas as Rails and using most of the Rails gear at the same time. However, the joke is that before Merb the Rails Core morons would scream up and down you can’t make Rails thread safe. Ezra however proved them all wrong by just writing a better Rails than Rails and all thanks to Mongrel being so easy to hack and work with. and: Ruby on Rails has become full of people like Koz, with Koz the most senior of the wannabe smarties. Koz got lucky at best and injected his shitty coding into a good project, messed it up, and then latched on to security as the way to get more control. Of course he doesn’t actually know anything about secure coding which is why his code seems to have lots of the bugs (go check out the date parsing shit. Clue: months don’t always have 30 days). And, well it goes on. So I guess I can sum it up this way: Rails smells bad .
