[site]: stackoverflow
[post_id]: 444995
[parent_id]: 436026
[tags]: 
First, I think you already considered using an ORM vs. rolling your own. I won't go into this one. My thoughts on rolling your own data access code: Over time, I found it easier not to have separate DAL/BL objects, but rather merge them into a single object (some time later after reaching this conclusion I found out it's a pretty well known pattern - namely ActiveRecord). It might look nice and decoupled to have separate DAL assemblies, but the overhead in maintenance costs will add up. Everytime you add a new feature, you'll have to create more code/modify more classes. In my experience, the team that maintains the application is often way less than the original team of developers that built it, and they'll hate the extra work required. For large teams, it might make sense to separate the DAL (and let a group work on it while the others. But this makes a good incentive for code bloat. Coming down to your specific sample: how do you use the resulting DataTable? Iterate the rows, create typed objects and get the data from the row? If the answer is yes, think of the extra DataTable you created just for moving data between the DAL and the BL. Why not take it directly from the DataReader? Also about the sample: if you return an untyped DataTable, then I guess you have to use the column names (of the result set the SP call returns) way up in the calling code. This means if I have to change something in the database, it might affect both layers. My suggestion (I tried both methods - the suggestion is the latest working approach I came up with - it sort of evolved over time). Make a base class for your typed business objects. Keep object state in the base class (new, modified etc.) Put the main data access methods in this class, as static methods. With a little effort (hint: generic methods + Activator.CreateInstance) you can create one business object per each row returned in the reader. make an abstract method in the business object for parsing the row data (directly from the DataReader!) and fill the object. make static methods in the derived business objects that prepare the stored proc parameters (depending on various filter criteria) and call the generic data access methods from the base class. The aim is to end up with usage such as: List objects = MyObject.FindMyObject(string someParam); The benefit for me was that I only have to change one file in order to cope with changes in the database column names, types etc. (small changes in general). With some well thought regions, you can organize the code so that they're separate "layers" in the same object :). The other benefit is that the base class is really reusable from one project to another. And the code bloat is minimal (well, compared with the benefits. You could also fill datasets and bind them to UI controls :D The limitations - you end up with one class per domain object (usually per main database table). And you can't load objects in existing transactions (although you could think of passing on the transaction, if you have one). Let me know if you're interested in more details - I could expand the answer a bit.
