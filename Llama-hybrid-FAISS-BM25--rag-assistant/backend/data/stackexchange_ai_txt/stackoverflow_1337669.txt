[site]: stackoverflow
[post_id]: 1337669
[parent_id]: 1310649
[tags]: 
Ok, let's do some bounty hunting ;) Step 0 - Sanitize example: As already mentioned, your example data is broken, as it does not define a valid nested set. If you took this data from an app, you should check the insert/delete logic. So for testing, I used a sanitized version like so: (MySQL here, as it was the first at hand) CREATE TABLE t_categories`( `id` INTEGER UNSIGNED NOT NULL AUTO_INCREMENT, `title` VARCHAR(45) NOT NULL, `lft` INTEGER UNSIGNED NOT NULL, `rght` INTEGER UNSIGNED NOT NULL, PRIMARY KEY (`id`) ); INSERT INTO t_categories (title, lft, rght) VALUES ('Cat 1',1,16); INSERT INTO t_categories (title, lft, rght) VALUES ('Cat 2',2,3); INSERT INTO t_categories (title, lft, rght) VALUES ('Cat 3',4,7); INSERT INTO t_categories (title, lft, rght) VALUES ('Cat 4',5,6); INSERT INTO t_categories (title, lft, rght) VALUES ('Cat 5',8,13); INSERT INTO t_categories (title, lft, rght) VALUES ('Cat 6',9,12); INSERT INTO t_categories (title, lft, rght) VALUES ('Cat 7',10,11); INSERT INTO t_categories (title, lft, rght) VALUES ('Cat 8',14,15); Step 1 - Let the database do the ordering Nested sets where primarily invented as a convenient way of storing trees in databases, as they make it pretty easy to query for subtrees, parent relations and, especially interesting in this case, for order and depth: SELECT node.title, (COUNT(parent.title) - 1) AS depth FROM t_categories AS node CROSS JOIN t_categories AS parent WHERE node.lft BETWEEN parent.lft AND parent.rght GROUP BY node.title ORDER BY node.lft This will return your set neatly ordered, starting with the root node and continuing to the end in preorder. Most importantly, it will add the depth of each node as a positive integer, indicating how many levels the node is below root (level 0). For the above example data, the result will be: title, depth 'Cat 1', 0 'Cat 2', 1 'Cat 3', 1 'Cat 4', 2 'Cat 5', 1 'Cat 6', 2 'Cat 7', 3 'Cat 8', 1 In code: // Grab ordered data $query = ''; $query .= 'SELECT node.title, (COUNT(parent.title) - 1) AS depth'; $query .= ' FROM t_categories AS node'; $query .= ' CROSS JOIN t_categories AS parent'; $query .= ' WHERE node.lft BETWEEN parent.lft AND parent.rght'; $query .= ' GROUP BY node.title'; $query .= ' ORDER BY node.lft'; $result = mysql_query($query); // Build array $tree = array(); while ($row = mysql_fetch_assoc($result)) { $tree[] = $row; } The resulting array will look like this: Array ( [0] => Array ( [title] => Cat 1 [depth] => 0 ) [1] => Array ( [title] => Cat 2 [depth] => 1 ) ... ) Step 2 - Output as HTML list fragment: Using while loop: // bootstrap loop $result = ''; $currDepth = -1; // -1 to get the outer while (!empty($tree)) { $currNode = array_shift($tree); // Level down? if ($currNode['depth'] > $currDepth) { // Yes, open $result .= ' '; } // Level up? if ($currNode['depth'] $result .= str_repeat(' ', $currDepth - $currNode['depth']); } // Always add node $result .= ' ' . $currNode['title'] . ' '; // Adjust current depth $currDepth = $currNode['depth']; // Are we finished? if (empty($tree)) { // Yes, close n open $result .= str_repeat(' ', $currDepth + 1); } } print $result; Same logic as recursive function: function renderTree($tree, $currDepth = -1) { $currNode = array_shift($tree); $result = ''; // Going down? if ($currNode['depth'] > $currDepth) { // Yes, prepend $result .= ' '; } // Going up? if ($currNode['depth'] $result .= str_repeat(' ', $currDepth - $currNode['depth']); } // Always add the node $result .= ' ' . $currNode['title'] . ' '; // Anything left? if (!empty($tree)) { // Yes, recurse $result .= renderTree($tree, $currNode['depth']); } else { // No, close remaining $result .= str_repeat(' ', $currNode['depth'] + 1); } return $result; } print renderTree($tree); Both will output the following structure: Cat 1 Cat 2 Cat 3 Cat 4 Cat 5 Cat 6 Cat 7 Cat 8 Nitpickers corner: Questioner explicitly asked for , but ordered unordered lists!? Come on... ;-)
