[site]: stackoverflow
[post_id]: 2271159
[parent_id]: 
[tags]: 
Dynamically typed class generates compiler warnings on method selection

Perhaps this is the wrong way to go about this, but it seems like such a clean and workable approach that I wonder how I can make the compiler warning go away? @interface SomeView : UIView { NSString *stringOfsomeImportance; RelatedClass *niftyService; } @property (nonatomic, copy) NSString * stringOfnoImportance; @property (nonatomic, retain) RelatedClass *niftyService; @implementation -(void)someMethod; -(void)otherMethods; @implementation RelatedClass *pvSomeObj = [[RelatedClass alloc] initWithSender:self]; [self setNiftyService:pvSomeObj]; Now, looking at the RelatedClass implementations... @interface RelatedClass : NSObject { id thesender; @property (nonatomic, retain) id thesender; @implementation [thesender otherMethods]; // this generates a compiler warning // that otherMethods cannot be found // in SomeView, though it *is* found // and seems to execute just fine This seems like a valid approach, so I'm left wondering why the warning? Is there a way to better "explain" this to the compiler? Could someone kindly share if this type of linkage is encouraged or if there is a better way to link two related, interdependent classes that need to communicate with one another? I can't statically declare the sender object (SomeView) in RelatedClass because that seems to cause a recursion problem, as SomeView is defined with RelatedClass as a member... Any suggestions?
