[site]: stackoverflow
[post_id]: 826293
[parent_id]: 391486
[tags]: 
I use L2S heavily on my current web project and I believe the biggest hangup you will find is conflicting documentation regarding the best way to do n-tier database development. First and foremost what you need to realize upfront is, DataContext objects are meant to last only as long as unit of work , period. Additionally, DataContext's are stateless. Once you come to grips with these two principals, using LINQ in an n-tier environment starts to work well. On the other hand, you will see a number of people recommending some very very very bad ways to use Linq. Do not EVER make your DataContext static, this is a mistake I made early on and it worked wonders until it didn't work, then it was absolutely horrible with incorrect data crossing across different sessions, etc. Simply put, this is perhaps the biggest most gigantic no-no of using Linq and should be written in big bold letters in every document. Also, persisting a DataContext in a Session variable is an equally bad idea. The only other major nasty I ran into with LINQ is when doing a disconnected update, you need to use the same DataContext across the entire call. For example: public static void UpdateUser(UserLibrary.User user) { using (UserLibraryDataContext dc = new UserLibraryDataContext(_conStr)) { UserLibrary.User newUser = (from user2 in dc.Users where user2.UserID == user.UserID select user2).FirstOrDefault(); newUser.Email = user.Email; newUser.FirstName = user.FirstName; newUser.LastName = user.LastName; dc.SubmitChanges(); } You can't simply pass in a User created in a different datacontext and expect Update to work, unless you set DataContext.ObjectTrackingEnabled = false, which I would not recommend. Instead, within the same DataContext you should retrieve the existing object, update its values, then submit that changes. Keep all like tasks within the same DataContext. I would recommend L2S though, once you get over a few niggling issues ( like the above ), it is a great technology and definatly a time saver. I would however recommend doing a thin wrapper around your DAL, so you can change easily. I am considering ( for economic reasons ) porting a portion of my code to using OpenAccess ORM -> MySql for a portion of my data access, and with a properly defined layer, this task should only take me a few hours.
