[site]: stackoverflow
[post_id]: 891820
[parent_id]: 49002
[tags]: 
If you understand the difference, it's easier to explain. Procedural Code An example of this is PHP without the use of classes (particularly before PHP5). All logic is encoded in a set of functions. You may include other files containing helper functions and so on and conduct your business logic by passing data around in functions. This can be very hard to manage as the application grows. PHP5 tries to remedy this by offering a more object-oriented design. Inheritance This encourages the use of classes. Inheritance is one of the three tenets of OO design (inheritance, polymorphism, encapsulation). class Person { String Title; String Name; Int Age } class Employee : Person { Int Salary; String Title; } This is inheritance at work. The Employee " is a " Person or inherits from Person . All inheritance relationships are "is-a" relationships. Employee also shadows the Title property from Person , meaning Employee.Title will return the Title for the Employee and not the Person . Composition Composition is favoured over inheritance. To put it very simply you would have: class Person { String Title; String Name; Int Age; public Person(String title, String name, String age) { this.Title = title; this.Name = name; this.Age = age; } } class Employee { Int Salary; private Person person; public Employee(Person p, Int salary) { this.person = p; this.Salary = salary; } } Person johnny = new Person ("Mr.", "John", 25); Employee john = new Employee (johnny, 50000); Composition is typically " has a " or " uses a " relationship. Here the Employee class has a Person . It does not inherit from Person but instead gets the Person object passed to it, which is why it "has a" Person. Composition over Inheritance Now say you want to create a Manager type so you end up with: class Manager : Person, Employee { ... } This example will work fine, however, what if Person and Employee both declared Title ? Should Manager.Title return "Manager of Operations" or "Mr."? Under composition this ambiguity is better handled: Class Manager { public string Title; public Manager(Person p, Employee e) { this.Title = e.Title; } } The Manager object is composed of an Employee and a Person . The Title behaviour is taken from Employee . This explicit composition removes ambiguity among other things and you'll encounter fewer bugs.
