[site]: stackoverflow
[post_id]: 2837113
[parent_id]: 2836978
[tags]: 
If you want to get technical, the minute you used __attribute__ (an identifier containing two consecutive underscores) your code has/had undefined behavior. If you get the same behavior with those removed, it looks to me like a compiler bug. The fact that a 3-bit field is being treated as 7 means that it's being treated as an unsigned, so when you overflow it should do like any other unsigned, and give you modulo arithmetic. It would also be legitimate for it to treat the bit-field as signed. In this case the first result would be -1 , -3 or -0 (which might print as just 0 ), and the second undefined (since overflow of a signed integer gives undefined behavior). In theory, other values might be possible under C89 or the current C++ standard since they don't limit the representations of signed integers. In C99 or C++0x, it can only be those three (C99 limits signed integers to one's complement, two's complement or sign-magnitude and C++0x is based on C99 instead of C90). Oops: I didn't pay close enough attention -- since it's defined as unsigned , it has to be treated as unsigned , leaving little wiggle room for getting out of its being a compiler bug.
