[site]: stackoverflow
[post_id]: 3243261
[parent_id]: 1249711
[tags]: 
The latest version of systemtap comes with lots of example scripts . One in particular seems like it would server as a good starting point for helping you accomplish your task: #! /usr/bin/env stap global thread_thislock global thread_blocktime global FUTEX_WAIT = 0 global lock_waits global process_names probe syscall.futex { if (op != FUTEX_WAIT) next t = tid () process_names[pid()] = execname() thread_thislock[t] = $uaddr thread_blocktime[t] = gettimeofday_us() } probe syscall.futex.return { t = tid() ts = thread_blocktime[t] if (ts) { elapsed = gettimeofday_us() - ts lock_waits[pid(), thread_thislock[t]] I was attempting to diagnose something similar with a MySQL process previously and observed output similar to the following using the above script: mysqld[3991] lock 0x000000000a1589e0 contended 45 times, 3 avg us mysqld[3991] lock 0x000000004ad289d0 contended 1 times, 3 avg us While the above script collects information on all processes running on the system, it would be quite easy to modify it to only work on a certain process or executable. For example, we could change the script to take a process ID argument and modify the probe on entering the futex call to look like: probe begin { process_id = strtol(@1, 10) } probe syscall.futex { if (pid() == process_id && op == FUTEX_WAIT) { t = tid () process_names[process_id] = execname() thread_thislock[t] = $uaddr thread_blocktime[t] = gettimeofday_us() } } Obviously, you could modify the script lots of ways to suit what you want to do. I'd encourage you to have a look at the various example scripts for SystemTap. They are probably the best starting point.
