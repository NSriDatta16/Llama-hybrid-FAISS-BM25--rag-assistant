[site]: stackoverflow
[post_id]: 2214138
[parent_id]: 2213791
[tags]: 
My Clojure is a bit rusty, but this seems to be a literal translation of the famous Haskell one-liner: fibs = 0 : 1 : zipWith (+) fibs (tail fibs) [I'm going to be using pseudo-Haskell, because it's a little bit more succinct.] The first thing you need to do, is simply let laziness sink in. When you look at a definition like this: zeroes = 0 : zeroes Your immediate gut reaction as a strict programmer would be "ZOMG infinite loop! Must fix bug!" But it isn't an infinite loop. This is a lazy infinite loop. If you do something stupid like print zeroes Then, yes, there will be an infinite loop. But as long as you simply use a finite number of elements, you will never notice that the recursion doesn't actually terminate. This is really hard to get. I still don't. Laziness is like the monetary system: it's based on the assumption that the vast majority of people never use the vast majority of their money. So, when you put $1000 in the bank, they don't keep it in their safe. They lend it to someone else. Actually, they leverage the money, which means that they lend $5000 to someone else. They only ever need enough money so that they can quickly reshuffle it so that it's there when you are looking at it, giving you the appearance that they actually keep your money. As long as they can manage to always give out money when you walk up to an ATM, it doesn't actually matter that the vast majority of your money isn't there: they only need the small amount you are withdrawing at the point in time when you are making your withdrawal. Laziness works the same: whenever you look at it, the value is there. If you look at the first, tenth, hundreth, quadrillionth element of zeroes , it will be there. But it will only be there, if and when you look at it, not before. That's why this inifintely recursive definition of zeroes works: as long as you don't try to look at the last element (or every element) of an infinite list, you are safe. Next step is zipWith . (Clojure's map is just a generalization of what in other programming languages are usually three different functions: map , zip and zipWith . In this example, it is used as zipWith .) The reason why the zip family of functions is named that way, is because it actually works like a zipper, and that is also how to best visualize it. Say we have some sporting event, where every contestant gets two tries, and the score from both tries is added up to give the end result. If we have two sequences, run1 and run2 with the scores from each run, we can calculate the end result like so: res = zipWith (+) run1 run2 Assuming our two lists are (3 1 6 8 6) and (4 6 7 1 3) , we line both of those lists up side by side, like the two halves of a zipper, and then we zip them together using our given function ( + in this case) to yield a new sequence: 3 1 6 8 6 + + + + + 4 6 7 1 3 = = = = = 7 7 13 9 9 Contestant #3 wins. So, what does our fib look like? Well, it starts out with a 0 , then we append a 1 , then we append the sum of the infinite list with the infinite list shifted by one element. It's easiest to just draw that out: the first element is zero: 0 the second element is one: 0 1 the third element is the first element plus the first element of the rest (i.e. the second element). We visualize this again like a zipper, by putting the two lists on top of each other. 0 1 + 1 = 1 Now, the element that we just computed is not just the output of the zipWith function, it is at the same time also the input , as it gets appended to both lists (which are actually the same list, just shifted by one): 0 1 1 + + 1 1 = = 1 2 and so forth: 0 1 1 2 + + + 1 1 2 = = = 1 2 3 0 1 1 2 3 ^ + + + + | 1 1 2 3 ^ | = = = = | | 1 2 3 5---+---+ Or if you draw it a little bit differently and merge the result list and the second input list (which really are the same, anyway) into one: 0 1 1 2 3 ^ + + + + + | 1 = 1 = 2 = 3 = 5---+ That's how I visualize it, anyway.
