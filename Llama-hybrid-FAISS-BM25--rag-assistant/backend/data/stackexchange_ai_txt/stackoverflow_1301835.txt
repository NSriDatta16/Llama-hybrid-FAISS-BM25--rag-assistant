[site]: stackoverflow
[post_id]: 1301835
[parent_id]: 1301735
[tags]: 
After your response - here's a way with a decorator factory... import inspect def make_decorators(): # Mutable shared storage... caller_L = [] callee_L = [] called_count = [0] def caller_decorator(caller): caller_L.append(caller) def counting_caller(*args, **kwargs): # Returning result here separate from the count report in case # the result needs to be used... result = caller(*args, **kwargs) print callee_L[0].__name__, \ 'was called', called_count[0], 'times' called_count[0] = 0 return result return counting_caller def callee_decorator(callee): callee_L.append(callee) def counting_callee(*args, **kwargs): # Next two lines are an alternative to # sys._getframe(1).f_code.co_name mentioned by Ned... current_frame = inspect.currentframe() caller_name = inspect.getouterframes(current_frame)[1][3] if caller_name == caller_L[0].__name__: called_count[0] += 1 return callee(*args, **kwargs) return counting_callee return caller_decorator, callee_decorator caller_decorator, callee_decorator = make_decorators() @callee_decorator def foo(z): #do something return ' foo result' @caller_decorator def bar(x,y): # complicated algorithm/logic simulation... for i in xrange(x+y): foo(i) foobar = 'some result other than the call count that you might use' return foobar bar(1,1) bar(1,2) bar(2,2) And here's the output (tested with Python 2.5.2): foo was called 2 times foo was called 3 times foo was called 4 times
