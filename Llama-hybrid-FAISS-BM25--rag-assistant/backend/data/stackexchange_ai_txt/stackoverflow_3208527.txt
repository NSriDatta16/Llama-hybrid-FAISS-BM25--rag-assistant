[site]: stackoverflow
[post_id]: 3208527
[parent_id]: 3208449
[tags]: 
You can do either of spread1 or spread2 below, but I wonder if you want to use discriminated unions rather than a class hierarchy. [ ] type Spreader () = abstract Fn : unit -> unit type Fire () = inherit Spreader () override self.Fn () = () type Disease () = inherit Spreader () override self.Fn () = () let fire = new Fire() let disease = new Disease() let spread1 Spreader>(spr:'t) : 't = spr printfn "%A" (spread1 fire) printfn "%A" (spread1 disease) let spread2(spr:Spreader) : Spreader = match spr with | :? Fire -> upcast disease | :? Disease -> upcast fire | _ -> failwith "hmmm" printfn "%A" (spread2 fire) printfn "%A" (spread2 disease) EDIT After your update, it sounds like you do want a class hierarchy, and you would just do things exactly like you'd do them in e.g. C#. So I'd do that. BTW, this let spread (spr:Spreader) : Spreader = match spr with | :? Fire -> upcast Fire () | :? Disease -> upcast Disease () | _ -> failwith "I don't get it" works fine, and is close to your original. I'd make Spread an abstract method on the base class, though. As an aside, you almost never need "flexible types" ( #type ) in F#, it is often a code smell if you think you need to use them.
