[site]: stackoverflow
[post_id]: 3421894
[parent_id]: 3421836
[tags]: 
Well, it's difficult to explain all the logic behind a loop here. The compiler will do amazing things for you in order to optimize the loops, so it does not matter if you use while or for because the compiler will translate to assembler anyway. In order to have a deeper understanding you should learn some assembler and then how a basic processor works, how it reads the instructions and how it processes them. In order to improve pipelining, it's better to place statements with the same variables far away from each other. This way, while one statement is calculated, the processor can take the next statement if it's independent from the first one and start calculating it. For example: a=0; b=3; c=5; m=8; i=0; while(i We have a dependency here between a and b and the statements are right next to each other. But we see that m and i are independent from the rest, so we can do: a=0; b=3; c=5; m=8; i=0; while(i So while a is being calculated, we can start calculating m and i . Most of the times the compiler detects this and does it automatically (it's calle code reordering). Some times for small loops the compiler copy and pastes the code inside the loop as many times as it's needed, because it's faster not to have control variables. My suggestion is that let the compiler take care about these things and focus on the costs of the algorithms you are using, it's better to reduce from O(n!) to O(logn) than to do micro-optimizations inside the loops. Update according to the question modified Well, the dependencies have to be write/write or read/write dependency. If it's read/read dependency there's no problem (because the value does not change). Have a look at the [Data Dependency article] ( http://en.wikipedia.org/wiki/Data_dependency ). In your example, there's no difference between the two codes, m depends on c and b but these two are never written, so the compiler knows their value before getting into the loop. This is a called a read/read dependency, and it's not a dependency itself. If you had written: ... m=c+GetAvarage(a); ... Then we would have a write/read dependency (we have to write in a and then read from a , so we have to wait until a is calculated) and the optimization you did would be good. But once again, the compiler does this for you and many other things. It's difficult to say that a micro-optimization in the high level code is gonna have a real impact in the assembler code, because maybe the compiler is doing that already for you, or maybe is reordering the code for you, or maybe is doing a thousand other things better than we can think of at first glance. But anyway, it's good just to know how things work under the carpet :) Update to add some links Have a look at these links to have a further understand about what the compiler can do to improve your code performance: Loop unwinding Dependency Analysis Automatic parallelization Vectorization
