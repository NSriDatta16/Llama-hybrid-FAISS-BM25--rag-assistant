[site]: stackoverflow
[post_id]: 5190820
[parent_id]: 5190671
[tags]: 
It's not required but it's rather handy. Some functions like rand and strtok use static storage duration information which is likely to be problematic when shared among threads. Say you have a random number function where you want to maintain a different sequence (hence seed) for each thread. You have two approaches. You can use something like the kludgy: int seed; srand (&seed, time (NULL)); int r = rand_r (void *seed); where the seed has to be created by the caller and passed in each time. Or you can use the rather nicer, ISO-compliant: srand (time (NULL)); int r = rand(); that uses thread-local storage to maintain a thread-specific seed. Similarly with the information used by strtok regarding the locations within the string it's processing. That way, you don't have to muck about with changing your code between threaded and non-threaded versions. Now you could create that information in the thread function but how is the rand function going to know about it's address without it being passed down. And what if rand is called 87 stack levels down? That's an awful lot of levels to be transferring a pointer through. And, even if you do something like: void pthread_fn (void *unused) { int seed; rand_set_seed_location (&seed); : } and rand subsequently uses that value regardless of how deep it is in the stack, that's still a code change from the standard. It may work but so may writing an operating system in COBOL. That doesn't make it a good idea :-)
