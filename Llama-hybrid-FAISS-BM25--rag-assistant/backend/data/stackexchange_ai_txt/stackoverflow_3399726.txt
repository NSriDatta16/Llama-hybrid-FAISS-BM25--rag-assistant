[site]: stackoverflow
[post_id]: 3399726
[parent_id]: 3394951
[tags]: 
We used a headless Eclipse to do some of the transformation between the source code and the generated Cobol code. We defined the transformation rules in several XML files, and Eclipse processed them and the source code It depends somewhat on your source input, but in our transformation process, the Data Division was a lot more difficult than the Procedure Division. We pretty much had to code each Data Division transformation as a separate Java method. We were able to use a factory model for the Procedure Division. The factory had 8 concrete class implementations, with one used in the majority of the transformations. Edited to add examples. Here's something we insert into Working Storage: 01 PROGRAM-COMPILE-INFO. 05 PGMNAME-COMPILED PIC X(08) VALUE 'J1PP2D0'. 05 PGMDATE-COMPILED PIC X(10) VALUE '2009-08-11'. 05 PGMTIME-COMPILED PIC X(08) VALUE '08:46:47'. Here's a simple Data Division transformation: $$COPY J1PP2D1 converts to COPY J1PP2D1. Here's a Procedure Division transformation: SQL-OTHER-ERROR IASN CLOSE converts to IF SQL-DEADLOCK MOVE '0329' TO ERROR-STATUS OF SUBSCHEMA-CTRL ELSE MOVE '0399' TO ERROR-STATUS OF SUBSCHEMA-CTRL END-IF MOVE 'IASN' TO ERROR-RECORD OF SUBSCHEMA-CTRL MOVE '000600,CLOSE ,0056-PROCESS' TO XI-EHK-STMT-CONTEXT PERFORM XI-SQL-ERROR GO TO IDMS-STATUS The 000600 is an error code number automatically calculated by the precompiler. The 0056-PROCESS is the paragraph name of the paragraph containing the SQL-OTHER-ERROR precompiler statement. The Java code to do the Data Division examples is pretty simple. The Java code to do the Procedure Division example is a factory method written for the SQL-OTHER-ERROR verb. Here's one of our XML transformation scripts. We have several.
