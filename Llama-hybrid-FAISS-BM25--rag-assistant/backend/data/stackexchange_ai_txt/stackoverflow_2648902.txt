[site]: stackoverflow
[post_id]: 2648902
[parent_id]: 2648560
[tags]: 
You can also use a byte array for this. You do this by using an unsafe routine and the fixed statement: static unsafe void PerformOperation() { byte[] buf = new byte[1024]; fixed (void* ptr = &buf[0]) { SomeUnmanagedFunction(new IntPtr(ptr)); } } The issue - and this is an important one - is that SomeUnmanagedFunction is not allowed to touch that pointer after it has returned and code has exited the fixed block. So if you do something like this: static void PerformFabulousTrick() { byte[] buf = new byte[1024]; fixed (void *ptr = &buf[0]) { SetBuffer(ptr, buf.Length); } FillBuffer(); // puts data in buf - NOT - may crash hard } you are asking for nothing but trouble. In this case you probably want to use a GCHandle , which can pin a managed object in the heap. This can also be troublesome in that you NEED to unpin it in a timely manner or you risk fragmenting your heap. In general, I would recommend making sure that you're P/Invoking correctly into the function so that the maybe marshaller can do this work for you. I like fixed better than GlobalAlloc since its scope is clear. I can't decide which I like least of GlobalAlloc and GCHandle. Both require you to do more work since the GC or language won't do it for you.
