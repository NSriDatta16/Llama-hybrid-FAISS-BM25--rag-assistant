[site]: stackoverflow
[post_id]: 2394474
[parent_id]: 
[tags]: 
F# elegance needed for Master-Detail scenario

The master-detail scenario. Been around forever. OK, if not forever, at least I was doing master-detail with FORTRAN on punch cards in the 70's. It's still around - plenty of master-detail questions here on STO. I looked for a good way to do a master-detail recognizer in F#, didn't find it. Apologies if I missed it, and if so, can someone just reply with the sto thread or url? thanks Here's my F#-newbie take on doing a master-detail recognizer in F#. That is: Reducing a raw/flat list of master-detail strings to a list of F#-records, where the master-strings are paired with their detail string-list. Not looking for code golf here folks. Elegance. I had hoped to end up with something elegant, but the below is just a straight-forward recursive list walk. My F#-newbie brain failed to see how to make good use here of folds, comprehensions, fold-backs, maps, active patterns, computation expressions, etc. Let's keep it to what can be done in F#. If there is a pre-built flat-file master-detail XML-data loader in .Net that makes master-detail .txt files into .Net XML in a one-line .Net call, that's quite interesting because it can be used in F#. As someone with a long imperative programming history, I was trying to stick to immutable F# for practice. But if dipping into imperative or mutable code is really the best way for this in F#, please explain away. The output could be a list of tuples, a sequence of records, an array of tuples, etc. Any comments/feedback.... thanks let testInput = ["master Homer" ; "Doh.."; "Doh!!" ; "master Has none" ; "master JoyJoyJoy"; "Yaa!" ; "Yaa!!!"; "Yaa!!!!!!"] type md = {m: string; d: string list} member x.addDetail newd = {m = x.m; d = x.d @ [newd]} static member noMaster = {m = "" ; d = []} // master records can never be null-strings, so "" works here static member isMaster (L:string) = L.StartsWith("master ") static member isDetail (L:string) = not (md.isMaster L) // There is no third kind of record - if not a master then it is a detail let rec masterDetails flatList currentMaster = if md.noMaster = currentMaster then match flatList with | [] -> [] // If no master and no more input: input list was empty and the empty list is the overall result | h :: t -> if md.isMaster h then // If no master, then head becomes the first master of the run masterDetails t {m = h; d = []} else failwith "Bad input: First record must be a master record" else match flatList with | [] -> [currentMaster] // End of input; return current master as a one-entry-list | h :: t -> if md.isMaster h then // Head will now replace the current master as the new master [currentMaster] @ masterDetails t {m = h; d = []} else // Keep current master; and add detail record to current master's detail list masterDetails t (currentMaster.addDetail h) let testSolution = // Required: 1) Preserve order of the master sets. 2) Preserve sort order of details-within-masters. [{m = "master Homer" ; d = ["Doh.."; "Doh!!" ]}; {m = "master Has none" ; d = [ ]}; {m = "master JoyJoyJoy"; d = ["Yaa!"; "Yaa!!!"; "Yaa!!!!!!"]} ] let tryIt = masterDetails testInput md.noMaster let testTry = (tryIt = testSolution)
