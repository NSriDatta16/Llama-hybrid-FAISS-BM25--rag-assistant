[site]: stackoverflow
[post_id]: 4503082
[parent_id]: 4502728
[tags]: 
This does not work. Your professor code will fail to initialize correctly in 3/4 of cases. It does not initialize objects correctly (new only affects pointers). The default constructor generated for tests has two modes. Zero Initialization (which happens after new, but POD are set to zero) Default Initialization (POD are uninitialized) Running Code (comments added by hand) $ ./a.exe Using Test::new Using Test::new A Count( 0) // zero initialized: pointer leaked. A Pointer(0) B Count( 10) // Works as expected because of default init. B Pointer(0xd20388) C Count( 1628884611) // Uninitialized as new not used. C Pointer(0x611f0108) D Count( 0) // Zero initialized because it is global (static storage duration) D Pointer(0) The Code #include #include #include class test { // code int *a; int n; public: void* operator new(size_t); // Added dredded getter so we can print the values. (Quick Hack). int* getA() const { return a;} int getN() const { return n;} }; void* test::operator new(size_t size) { std::cout n = 10; // Fixed size for simple test. p->a = new int[p->n]; return p; } // Objects that have static storage duration are zero initialized. // So here 'a' and 'n' will be set to 0 test d; int main() { // Here a is zero initialized. Resulting in a and n being reset to 0 // Thus you have memory leaks as the reset happens after new has completed. test* a = new test(); // Here b is default initialized. // So the POD values are undefined (so the results are what you prof expects). // But the standard does not gurantee this (though it will usually work because // of the it should work as a side effect of the 'zero cost principle`) test* b = new test; // Here is a normal object. // New is not called so its members are random. test c; // Print out values std::cout getN() getA() getN() getA() A valid example of what the professor failed to do: class test { // code int n; int a[1]; // Notice the zero sized array. // The new will allocate enough memory for n locations. public: void* operator new(size_t); // Added dredded getter so we can print the values. (Quick Hack). int* getA() const { return a;} int getN() const { return n;} }; void* test::operator new(size_t size) { std::cout > tmp; // This is a half arsed trick from the C days. // It should probably still work. // Note: This may be what the professor should have wrote (if he was using C) // This is totally horrible and whould not be used. // std::vector is a much:much:much better solution. // If anybody tries to convince you that an array is faster than a vector // The please read the linked question below where that myth is nailed into // its over sized coffin. test *p =(test*)malloc(size + sizeof(int) * tmp); p->n = tmp; // p->a = You can now overflow a upto n places. return p; } Is std::vector so much slower than plain arrays?
