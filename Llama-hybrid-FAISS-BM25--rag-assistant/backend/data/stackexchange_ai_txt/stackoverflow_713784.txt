[site]: stackoverflow
[post_id]: 713784
[parent_id]: 712528
[tags]: 
I think you probably made a poor naming choice: I would think RestrictedUser would be a subclass of User , not the other way around, so I'll use UnrestrictedUser as the subclass. If you upcast an UnrestrictedUser to a RestrictedUser , your reference will only be able to access methods declared in RestrictedUser . However, if you downcast it back to an UnrestrictedUser , you'll have access to all of the methods. Since Java objects know what type they really are, anything that actually is an UnrestrictedUser can always be cast back to it, no matter what type of reference you are using (even an Object ). There is unavoidable and part of the language. However, you could hide it behind some sort of proxy, but in your case that probably defeats the purpose. Also, in Java, all non-static methods are virtual by default. This means that if UnrestrictedUser overrides some method declared in RestrictedUser , then the UnrestrictedUser version will be used, even if you access it through a RestrictedUser reference. If you need to invoke the parent class version, you can make a non-virtual call by calling RestrictedUser.variableName.someMethod() . However, you probably shouldn't use this very often (the least of the reasons being that it breaks encapsulation).
