[site]: stackoverflow
[post_id]: 3193137
[parent_id]: 3193016
[tags]: 
Yes, it is. There's no specific violations of the standard there. The memset is a waste of time however since it's al going to be overwritten anyway (make your first strcat into a strcpy ). And you should always check for malloc returning NULL. No matter what! C89/90 is not the current standard, C99 is. And C1x is not that far away. GCC is keeping up with the bleeding edge. Only use local arrays if you don't need them to survive beyond the end of the function. Otherwise malloc is your best bet, particularly if you want to return the combined string. I think gcc has the -std=c89 flag or something similar. In any case, MSVC does not always follow the standard :-) Compile and test it on both platforms frequently. That's the only way to be sure. I would opt for: void foo (const char *p1, const char *p2, const char *p3) { size_t length = strlen(p1) + strlen(p2) + strlen(p3); char *combined = (char *) malloc(length + 1); if (combined == NULL) { printf("Result : \n"); } else { strcpy(combined, p1); strcat(combined, p2); strcat(combined, p3); printf("Result : %s", combined); free(combined); } } or, since you're not actually doing anything with the string except printing it: void foo (const char *p1, const char *p2, const char *p3) { printf("Result : %s%s%s", p1, p2, p3); } :-) Another strategy I've seen is the "only allocate if you have to" strategy: void foo (const char *p1, const char *p2, const char *p3) { char str1k[1024]; char *combined; size_t length = strlen (p1) + strlen (p2) + strlen (p3) + 1; if (length \n"); } else { strcpy (combined, p1); strcat (combined, p2); strcat (combined, p3); printf ("Result : %s", combined); } if (combined != str1k) free (combined); } which uses stack storage if the combined string will fit and only allocates memory if it won't. This can often lead to a substantial speed improvement if the bulk of strings combine into less than the limit.
