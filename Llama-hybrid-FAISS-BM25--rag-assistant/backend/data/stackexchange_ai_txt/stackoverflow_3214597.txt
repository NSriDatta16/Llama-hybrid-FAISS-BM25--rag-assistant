[site]: stackoverflow
[post_id]: 3214597
[parent_id]: 
[tags]: 
how to terminate retrieval from a blocking queue

I have some code where i execute a several tasks using Executors and a Blocking Queue. The results have to be returned as an iterator because that is what the application that i work on expects. However, there is a 1:N relationship between the task and the results added to the queue, so i cannot use the ExecutorCompletionService . While calling hasNext(), i need to know when all the tasks have finished and added all the results to the queue, so that i can stop the retrieval of results from the queue. Note, that once items are put on the queue, another thread should be ready to consume ( Executor.invokeAll() , blocks until all tasks have completed, which is not what i want, nor a timeout). This was my first attempt, i am using an AtomicInteger just to demonstrate the point even though it will not work. Could someone help me in undestanding how i can solve this issue? public class ResultExecutor implements Iterable { private BlockingQueue queue; private Executor executor; private AtomicInteger count; public ResultExecutor(Executor executor) { this.queue = new LinkedBlockingQueue (); this.executor = executor; count = new AtomicInteger(); } public void execute(ExecutorTask task) { executor.execute(task); } public Iterator iterator() { return new MyIterator(); } public class MyIterator implements Iterator { private T current; public boolean hasNext() { if (count.get() > 0 && current == null) { try { current = queue.take(); count.decrementAndGet(); } catch (InterruptedException e) { e.printStackTrace(); } } return current != null; } public T next() { final T ret = current; current = null; return ret; } public void remove() { throw new UnsupportedOperationException(); } } public class ExecutorTask implements Runnable{ private String name; public ExecutorTask(String name) { this.name = name; } private int random(int n) { return (int) Math.round(n * Math.random()); } @SuppressWarnings("unchecked") public void run() { try { int random = random(500); Thread.sleep(random); queue.put((T) (name + ":" + random + ":1")); queue.put((T) (name + ":" + random + ":2")); queue.put((T) (name + ":" + random + ":3")); queue.put((T) (name + ":" + random + ":4")); queue.put((T) (name + ":" + random + ":5")); count.addAndGet(5); } catch (InterruptedException e) { e.printStackTrace(); } } } } And the calling code looks like: Executor e = Executors.newFixedThreadPool(2); ResultExecutor resultExecutor = new ResultExecutor (e); resultExecutor.execute(resultExecutor.new ExecutorTask("A")); resultExecutor.execute(resultExecutor.new ExecutorTask("B")); Iterator iter = resultExecutor.iterator(); while (iter.hasNext()) { System.out.println(iter.next()); }
