[site]: stackoverflow
[post_id]: 3653766
[parent_id]: 3653250
[tags]: 
There is an issue (or perhaps a really clever feature that I haven't seen justified anywhere) with DeflateStream ( GZipStream builds on DeflateStream and inherits the issue*), where flushing can lose data. Response.Flush() will flush the filter. The solution is to use a wrapper that is aware of both the zipping and the underlying sink, and only flushes the latter: public enum CompressionType { Deflate, GZip } /// /// Provides GZip or Deflate compression, with further handling for the fact that /// .NETs GZip and Deflate filters don't play nicely with chunked encoding (when /// Response.Flush() is called or buffering is off. /// public class WebCompressionFilter : Stream { private Stream _compSink; private Stream _finalSink; public WebCompressionFilter(Stream stm, CompressionType comp) { switch(comp) { case CompressionType.Deflate: _compSink = new DeflateStream((_finalSink = stm), CompressionMode.Compress); break; case CompressionType.GZip: _compSink = new GZipStream((_finalSink = stm), CompressionMode.Compress); break; } } public override bool CanRead { get { return false; } } public override bool CanSeek { get { return false; } } public override bool CanWrite { get { return true; } } public override long Length { get { throw new NotSupportedException(); } } public override long Position { get { throw new NotSupportedException(); } set { throw new NotSupportedException(); } } public override void Flush() { //We do not flush the compression stream. At best this does nothing, at worse it //loses a few bytes. We do however flush the underlying stream to send bytes down the //wire. _finalSink.Flush(); } public override long Seek(long offset, SeekOrigin origin) { throw new NotSupportedException(); } public override void SetLength(long value) { throw new NotSupportedException(); } public override int Read(byte[] buffer, int offset, int count) { throw new NotSupportedException(); } public override void Write(byte[] buffer, int offset, int count) { _compSink.Write(buffer, offset, count); } public override void WriteByte(byte value) { _compSink.WriteByte(value); } public override void Close() { _compSink.Close(); _finalSink.Close(); base.Close(); } protected override void Dispose(bool disposing) { if(disposing) { _compSink.Dispose(); _finalSink.Dispose(); } base.Dispose(disposing); } } It's also worth noting that most user-agents that support gzip-encoding also support deflate-encoding. While the size improvement with deflate is negliable (literally a few bytes), some libraries on some architecture deals with deflate considerably better (this goes for both compressing and decompressing), so it's always worth favouring deflate over gzip with HTTP compression.
