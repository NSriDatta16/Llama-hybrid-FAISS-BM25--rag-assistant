[site]: stackoverflow
[post_id]: 1516311
[parent_id]: 1230131
[tags]: 
Personally for a long time I used the latter expression, but reversed. Using "foo == nil" (or nil == foo, to avoid bugs caused by forgetting one '=') is more pedantic. Eventually you will get tired of typing it, and the first version is also immune to the accidental nil assignment bug. It's good for new coders to be verbose in what they're coding, as it provides practise at forcing them to think about what's really going on, but later, of course switch to a version that is faster if it is equivalent. If for some insane reason, nil pointers were not 0 anymore, but some other invalid value (there's entire gigantic regions of memory which are invalid as pointers), then using '!' wouldn't work anymore, but that will never happen (or if it did, they'd add support to the compiler to overload '!' so that it meant "not invalid" when used with an object pointer and would do the right thing anyway, or else the Objective-C developers of the world would go crazy). The only subtle problem with this is that it can start to train you to confuse the value of C's boolean expressions with the values of other types, which they aren't the same thing. So, if you start to think a boolean expression is just a BOOL, say, you might assume that assigning any non-zero value to a BOOL variable will do what you want, but it won't. Since a BOOL is just a char (currently), if you do something like: - (BOOL)checkFoo { BOOL foo = [bar count]; // imagine count is > 255 if(foo) [self doSomething]; return foo; } where implicitly casting 256 or higher to BOOL gets you zero (NO) by truncation, not YES, which is what you want, versus - (BOOL)checkFoo { BOOL foo = ([bar count] > 0); if(foo) [self doSomething]; return foo; } or - (BOOL)checkFoo { if([bar count]) { [self doSomething]; return YES; } return NO; } All I'm saying is, make sure you understand the background and the subtleties.
