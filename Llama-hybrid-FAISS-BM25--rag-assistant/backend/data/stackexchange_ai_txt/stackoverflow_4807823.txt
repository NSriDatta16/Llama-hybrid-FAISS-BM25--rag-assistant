[site]: stackoverflow
[post_id]: 4807823
[parent_id]: 4807447
[tags]: 
the main problem is how to count distinct elements of the vector. as you would resolve it? If you allowed to use hashing, you could do the following init Hashtable h distinct_count := 0 for each element v of the vector V if h does not contain v (O(1) time in average) insert v into h (O(1) time in average) distinct_count := distinct_count + 1 return distinct_count This is in average O(n) time. If not here is an O(n log n) solution - this time worst case sort V (O(n log n) comparisons) Then it should be easy to determine the number of different elements in O(n) time ;-) I could also tell you an algorithm to sort V in O(n*b) where b is the bit count of the integers - if this helps you. Here is the algorithm: sort(vector, begin_index, end_index, currentBit) reorder the vector[begin_index to end_index] so that the elements that have a 1 at bit currentBit are after those that have a 0 there (O(end_index-begin_index) time) Let c be the count of elements that have a 0 at bit currentBit (O(end_index-begin_index) time; can be got from the step before) if (currentBit is not 0) call sort(vector, begin_index, begin_index+c) call sort(vector, begin_index+c+1, end_index) Call it with vector = V begin_index = 0 end_index = n-1 currentBit = bit count of the integers (=: b)-1. This even uses dynamic programming as requested. As you can determine very easily this is O(n*b) time with a recursion depth of b.
