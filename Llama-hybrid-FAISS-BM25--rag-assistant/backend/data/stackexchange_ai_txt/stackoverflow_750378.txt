[site]: stackoverflow
[post_id]: 750378
[parent_id]: 750165
[tags]: 
Isn't the creation or retrieval of the HttpSession in the first line totally atomic? By atomic, I mean that if two Threads call request.getSession(), one will block. Even if getSession blocks, as soon as one thread returned with the session, the lock is relinquished. While it is creating the new cart, other threads are able to acquire the lock, obtain the session, and find that there is, as yet, no cart in the session. So, this code is not thread-safe. There is a race condition that could easily lead to multiple ShoppingCarts being created for a single session. Unfortunately, your proposed solution is doing exactly the same thing: checking for an object in the session, and publishing one if needed, but without any locking. The fact that the session attribute is an AtomicReference doesn't matter. To do this safely, you can use something like Goetz' "Listing 5" , where the reads and writes to the session attribute are performed while synchronized on a common lock. HttpSession session = request.getSession(); ShoppingCart cart; synchronized (lock) { cart = (ShoppingCart) session.getAttribute(ATTR_CART); if (cart == null) { cart = new ShoppingCart(); session.setAttribute(ATTR_CART, cart); } } Note that this example assumes that ShoppingCart is mutable and thread-safe.
