[site]: stackoverflow
[post_id]: 4631441
[parent_id]: 4630723
[tags]: 
Here's my take on it. The first two functions are the actual implementation and the last function is for testing it. The key is the first function which looks at the last N elements of the list where N+1 is the limit of how many times you want a number to appear in a row. It counts the number of ones that occur and then returns 1 with (1 - N/n) probability where n is the amount of ones already present. Note that this probability is 0 in the case of N consecutive ones and 1 in the case of N consecutive zeros. Like a true random selection, there is no guarantee that the ratio of ones and zeros will be the 1 but averaged out over thousands of runs, it does produce as many ones as zeros. For longer lists, this will be better than repeatedly calling shuffle and checking that it satisfies your requirements. import random def next_value(selected): # Mathematically, this isn't necessary but it accounts for # potential problems with floating point numbers. if selected.count(0) == 0: return 0 elif selected.count(1) == 0: return 1 N = len(selected) selector = float(selected.count(1)) / N if random.uniform(0, 1) > selector: return 1 else: return 0 def get_sequence(N, max_run): lim = min(N, max_run - 1) seq = [random.choice((1, 0)) for _ in xrange(lim)] for _ in xrange(N - lim): seq.append(next_value(seq[-max_run+1:])) return seq def test(N, max_run, test_count): ones = 0.0 zeros = 0.0 for _ in xrange(test_count): seq = get_sequence(N, max_run) # Keep track of how many ones and zeros we're generating zeros += seq.count(0) ones += seq.count(1) # Make sure that the max_run isn't violated. counts = [0, 0] for i in seq: counts[i] += 1 counts[not i] = 0 if max_run in counts: print seq return # Print the ratio of zeros to ones. This should be around 1. print zeros/ones test(200, 5, 10000)
