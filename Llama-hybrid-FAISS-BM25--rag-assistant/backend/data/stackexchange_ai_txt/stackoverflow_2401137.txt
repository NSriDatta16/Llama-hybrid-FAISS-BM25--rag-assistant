[site]: stackoverflow
[post_id]: 2401137
[parent_id]: 2400458
[tags]: 
It does not make any sense. To elaborate: weak_ptr points to the same instance of a counter object that shared_ptr do. When the shared_ptr goes out of scope, the instance of the counter stays (with a count effectively at 0), which allows the weak_ptr instances to check that they effectively point to a freed object. With Intrusive Counting, the counter is integrated within the object. When the count reaches 0, the object is usually either recycled or deleted... but the point is the counter is no longer available. The rationale is that this allow for a more efficient storage (1 single chunk) and greater speed (cache locality). If you need Weak Reference counting and do not care for the benefits of intrusive counting, you can use a combination of shared_ptr and weak_ptr . The idea is to deassociate the counter from the objects. class Counted { // bla private: boost::shared_ptr mCounter; }; Now you can return weak handles: class WeakHandle { public: explicit WeakHandle(Counted& c): mCounter(c.mCounter), mObject(&c) {} bool expired() const { return mCounter.expired(); } private: boost::weak_ptr mCounter; Counted* mObject; }; Here, we deassociate the lifetime of the counter from the lifetime of the object, so that it will survive the destruction of the object... partially. Thus making the weak_ptr effectively possible. And of course, using shared_ptr and weak_ptr this is Thread Safe ;)
