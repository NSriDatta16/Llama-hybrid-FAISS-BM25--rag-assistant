[site]: stackoverflow
[post_id]: 1337080
[parent_id]: 1336767
[tags]: 
The statement under 3) is false. If d is slightly smaller than 2, then there is exactly 1 floating-point number between d and (1+eps) * d. Here is a program to show it: #include #include int main(int, char**) { using namespace std; double d = 1.875; cout.precision(18); cout ::epsilon())*d; cout The reason is that (1+eps) * 1.875 equals 1.875 + 1.875 * eps, which is rounded to 1.875 + 2 * eps. However, the difference between consecutive floating-point numbers between 1 and 2 is eps, so there is one floating-point number between 1.875 and 1.875 + 2 * eps, namely 1.875 + eps. The statement under 2) is true, I think. And Robert Kern probably answered your real question.
