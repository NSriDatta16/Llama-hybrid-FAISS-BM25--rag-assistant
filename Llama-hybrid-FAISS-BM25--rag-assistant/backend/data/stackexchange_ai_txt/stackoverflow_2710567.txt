[site]: stackoverflow
[post_id]: 2710567
[parent_id]: 2710260
[tags]: 
1) It is conventional to put the declarations of the attributes of a class before the constructors and methods. 2) The statement this.client = client; in the CarLoan class will give you a compilation error because the client field is declared as private in the Loan class. (And that statement is redundant anyway because you just initialized the same field using the setter ... though expect you already knew that.) 3) A better way to initialize the fields of a superclass is to pass the arguments to the superclass constructor. For example: public abstract class Loan { private Person client; private double interestRate; public Loan(Person client, double interestRate) { this.client = client; this.interestRate = interestRate; } ... } public class CarLoan extends Loan { ... public CarLoan(Person client, double vehiclePrice, double downPayment, double salesTax, double interestRate, CAR_LOAN_TERMS length) { super(client, interestRate); this.vehiclePrice = vehiclePrice; ... } } The reason this approach is better is that the Loan class takes responsibility for its initialization, and doesn't rely on the various subclass constructors doing the job. (If you add an extra field to Loan and add the corresponding parameter to the Loan constructor, the compiler reminds you to modify all of the subclass constructors to provide the initial value in the super constructor chaining. If the subclasses are responsible for setting fields in the base class during initialization, then the compiler won't notice that you forgot to add the new setter call.) 4) If you do call methods in a constructor, it is good practice to ensure that they cannot be overridden in a subclass. (No ... it is not entirely wrong for the methods to be overridden, but there are things that can go horribly wrong. Calling potentially overridable methods in a constructor makes your code fragile.) 5) If this was production code, use of float or double to represent currency values would be a big no-no!
