[site]: stackoverflow
[post_id]: 2547974
[parent_id]: 2547789
[tags]: 
To give some context, here's the start of that paragraph: The shift operators also manipulate bits. The left-shift operator ( >) produces the operand to the left of the operator shifted to the right by the number of bits specified after the operator. Now the rest, with explanations: If the value after the shift operator is greater than the number of bits in the left-hand operand, the result is undefined. If you have a 32 bit integer and you try to bit shift 33 bits, that's not allowed and the result is undefined. In other words, the result could be anything, or your program could crash. If the left-hand operand is unsigned, the right shift is a logical shift so the upper bits will be filled with zeros. This says that it's defined to write a >> b when a is an unsigned int. As you shift right, the least significant bits are removed, other bits are shifted down, and the most significant bits become zero. In other words: This: 110101000101010 >> 1 becomes: 011010100010101 If the left-hand operand is signed, the right shift may or may not be a logical shift (that is, the behavior is undefined). Actually I believe that the behaviour here is implementation defined when a is negative and defined when a is positive rather than undefined as suggested in the quote. This means that if you do a >> b when a is a negative integer, there are many different things that might happen. To see which you get, you should read the documentation for your compiler. A common implementation is to shift in zeros if the number is positive, and ones if the number is negative, but you shouldn't rely on this behaviour if you wish to write portable code.
