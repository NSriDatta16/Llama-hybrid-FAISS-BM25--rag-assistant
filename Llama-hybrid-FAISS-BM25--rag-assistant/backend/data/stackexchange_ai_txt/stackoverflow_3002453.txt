[site]: stackoverflow
[post_id]: 3002453
[parent_id]: 3002122
[tags]: 
It really shouldn't matter. If you're reading from an actual hard disk, it's going to be slow. The hard disk is your bottle neck, and that's it. Now, if you're being silly about your call to read/fread/whatever, and say, fread()-ing a byte at a time, then yes, it's going to be slow, as the overhead of fread() will outstrip the overhead of reading from the disk. If you call read/fread/whatever and request a decent portion of data. This will depend on what you're doing: sometimes all want/need is 4 bytes (to get a uint32), but sometimes you can read in large chunks (4 KiB, 64 KiB, etc. RAM is cheap, go for something significant.) If you're doing small reads, some of the higher level calls like fread() will actual help you by buffering data behind your back. If you're doing large reads, it might not be helpful, but switching from fread to read will probably not yield that much improvement, as you're bottlenecked on disk speed. In short: if you can, request a liberal amount when reading, and try to minimize what you write. For large amounts, powers of 2 tend to be friendlier than anything else, but of course, it's OS, hardware, and weather dependent. So, let's see if this might bring out any differences: #include #include #include #include #include #include #include #define BUFFER_SIZE (1 * 1024 * 1024) #define ITERATIONS (10 * 1024) double now() { struct timeval tv; gettimeofday(&tv, NULL); return tv.tv_sec + tv.tv_usec / 1000000.; } int main() { unsigned char buffer[BUFFER_SIZE]; // 1 MiB buffer double end_time; double total_time; int i, x, y; double start_time = now(); #ifdef USE_FREAD FILE *fp; fp = fopen("/dev/zero", "rb"); for(i = 0; i ...yields: $ gcc -o reading reading.c $ ./reading ; ./reading ; ./reading It took 1.141995 seconds to read 10 GiB. That's 8966.764671 MiB/s. It took 1.131412 seconds to read 10 GiB. That's 9050.637376 MiB/s. It took 1.132440 seconds to read 10 GiB. That's 9042.420953 MiB/s. $ gcc -o reading reading.c -DUSE_FREAD $ ./reading ; ./reading ; ./reading It took 1.134837 seconds to read 10 GiB. That's 9023.322991 MiB/s. It took 1.128971 seconds to read 10 GiB. That's 9070.207522 MiB/s. It took 1.136845 seconds to read 10 GiB. That's 9007.383586 MiB/s. $ gcc -o reading reading.c -DUSE_MMAP $ ./reading ; ./reading ; ./reading It took 2.037207 seconds to read 10 GiB. That's 5026.489386 MiB/s. It took 2.037060 seconds to read 10 GiB. That's 5026.852369 MiB/s. It took 2.031698 seconds to read 10 GiB. That's 5040.119180 MiB/s. ...or no noticeable difference. (fread is winning sometimes, sometimes read) Note : The slow mmap is surprising. This might be due to me asking it to allocate the buffer for me. (I wasn't sure about requirements of supplying a pointer...) In really short: Don't prematurely optimize. Make it run, make it right, make it fast, that order. Back by popular demand, I ran the test on a real file. (The first 675 MiB of the Ubuntu 10.04 32-bit desktop installation CD ISO) These were the results: # Using fread() It took 31.363983 seconds to read 675 MiB. That's 21.521501 MiB/s. It took 31.486195 seconds to read 675 MiB. That's 21.437967 MiB/s. It took 31.509051 seconds to read 675 MiB. That's 21.422416 MiB/s. It took 31.853389 seconds to read 675 MiB. That's 21.190838 MiB/s. # Using read() It took 33.052984 seconds to read 675 MiB. That's 20.421757 MiB/s. It took 31.319416 seconds to read 675 MiB. That's 21.552126 MiB/s. It took 39.453453 seconds to read 675 MiB. That's 17.108769 MiB/s. It took 32.619912 seconds to read 675 MiB. That's 20.692882 MiB/s. # Using mmap() It took 31.897643 seconds to read 675 MiB. That's 21.161438 MiB/s. It took 36.753138 seconds to read 675 MiB. That's 18.365779 MiB/s. It took 36.175385 seconds to read 675 MiB. That's 18.659097 MiB/s. It took 31.841998 seconds to read 675 MiB. That's 21.198419 MiB/s. ...and one very bored programmer later, we've read the CD ISO off disk. 12 times. Before each test, the disk cache was cleared, and during each test there was enough, and approximately the same amout of, RAM free to hold the CD ISO twice in RAM. One note of interest: I was originally using a large malloc() to fill memory and thus minimize the effects of disk caching. It may be worth noting that mmap performed terribly here. The other two solutions merely ran, mmap ran and, for reasons I can't explain, began pushing memory to swap, which killed its performance. (The program was not leaking, as far as I know (the source code is above) - the actual "used memory" stayed constant throughout the trials.) read() posted the fastest time overall, fread() posted really consistent times. This may have been to some small hiccup during the testing, however. All told, the three methods were just about equal. (Especially fread and read ...)
