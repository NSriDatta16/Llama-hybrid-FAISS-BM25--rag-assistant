[site]: stackoverflow
[post_id]: 4658271
[parent_id]: 4636547
[tags]: 
After a bit more research it appears that "Yes, really, your two options are to either subclass NSTextField or use your NSWindowDelegate to handle drops." I'll go further and make the claim that the better way of the two, for garden variety cases of, "I want multiple drop zones in a single window" is to use the NSWindowDelegate method with hit checks, since you avoid the issue of having your drop-handling code on the view side. I ended up with this draggingUpdated: method on my window delegate class: - (NSDragOperation)draggingUpdated:(id )sender { NSPasteboard *pboard = [sender draggingPasteboard]; NSDragOperation sourceDragMask = [sender draggingSourceOperationMask]; if ([pboard.types containsObject: NSFilenamesPboardType] && (sourceDragMask & NSDragOperationCopy)) { NSView* hitView = [sender.draggingDestinationWindow.contentView hitTest: sender.draggingLocation]; if (hitView && (hitView == mSourceTextField || hitView == mDestTextField)) { return NSDragOperationCopy; } } return NSDragOperationNone; } Obviously there's more to the whole picture, but this hitTest:-based approach has worked for me so far. I suspect that this would be slightly more complex if one were working with a multi-NSCell based control like an NSTableView or NSOutlineView, but unsurprisingly, those have their own drag handling methods. Hope this helps someone else.
