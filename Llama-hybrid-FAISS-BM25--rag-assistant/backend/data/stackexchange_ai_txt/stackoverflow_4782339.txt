[site]: stackoverflow
[post_id]: 4782339
[parent_id]: 4782168
[tags]: 
Simultaneous.. in its cells. So you mean within the same cell, therefore as a varchar? You could calc the avg and count values in an aggregate query before using the pivot, and concatenate them together as text. The role of the PIVOT operator here would only be to transform rows to columns, and some aggregate function (e.g. MAX/MIN) would be used only because it is required by the syntax - your pre-calculated aggregate query would only have one value per pivoted column. EDIT Following bernd_k's oracle/mssql solution, I would like to point out another way to do this in SQL Server. It requires streamlining the multiple columns into a single column. SELECT MODULE, modus + '_' + case which when 1 then 'AVG' else 'COUNT' end AS modus, case which when 1 then AVG(duration) else COUNT(duration) end AS value FROM test_data, (select 1 as which union all select 2) x GROUP BY MODULE, modus, which SELECT * FROM ( SELECT MODULE, modus + '_' + case which when 1 then 'AVG' else 'COUNT' end AS modus, case which when 1 then CAST(AVG(1.0*duration) AS NUMERIC(10,2)) else COUNT(duration) end AS value FROM test_data, (select 1 as which union all select 2) x GROUP BY MODULE, modus, which ) P PIVOT (MAX(value) FOR modus in ([A_AVG], [A_COUNT], [B_AVG], [B_COUNT]) ) AS pvt ORDER BY pvt.MODULE In the example above, AVG and COUNT are compatible (count - int => numeric). If they are not, convert both explicitly to a compatible type. Note - The first query shows AVG for M2/A as 2, due to integer averaging. The 2nd (pivoted) query shows the actual average taking into account decimals.
