[site]: datascience
[post_id]: 78426
[parent_id]: 77684
[tags]: 
As @NoahWeber mentioned, one solution is to: split by customer ids (A) do the time series split on all dataset (B) keep in the training (resp. testing) dataset only the data from training (resp. testing) customers split (A) and from training (resp. testing) time series split (B) . Below is a code sample I was writing at the same time he answered. import pandas as pd import numpy as np from sklearn.model_selection import RepeatedKFold from sklearn.model_selection import TimeSeriesSplit # Generating dates def pp(start, end, n): start_u = start.value//10**9 end_u = end.value//10**9 return pd.DatetimeIndex((10**9*np.random.randint(start_u, end_u, n, dtype=np.int64)).view('M8[ns]')) start = pd.to_datetime('2015-01-01') end = pd.to_datetime('2018-01-01') fake_date = pp(start, end, 500) # Fake dataframe df = pd.DataFrame(data=np.random.random((500,5)), index=fake_date, columns=['feat'+str(i) for i in range(5)]) df['customer_id'] = np.random.randint(0, 5, 500) df['label'] = np.random.randint(0, 3, 500) # First split by customer rkf = RepeatedKFold(n_splits=2, n_repeats=5, random_state=42) for train_cust, test_cust in rkf.split(df['customer_id'].unique()): print("training/testing with customers : " + str(train_cust)+"/"+str(test_cust)) # Then sort all the data (if not already sorted) sorted_df = df.sort_index() # Then do the time series split tscv = TimeSeriesSplit(max_train_size=None, n_splits=5) for train_index, test_index in tscv.split(sorted_df.values): df_train, df_test = sorted_df.iloc[train_index], sorted_df.iloc[test_index] # Keep the right customers for training/testing df_train_final = pd.concat( [ df_train.groupby('customer_id').get_group(i) for i in train_cust ]) df_test_final = pd.concat( [ df_test.groupby('customer_id').get_group(i) for i in test_cust ]) Note : Generating random dates is based on this post Note bis : I tested the generated training/testing dataframes ready for cross-val with this sample code that you can add right after the line df_test_final : # Test condition 1: temporality for i in range(len(df_test_final)): for j in range(len(df_train_final)): if df_test_final.index[i] Here is a pseudo-code implementation: function keep_customer_ids( data, ids ): goal: this function returns a subset of data with only the events that have an id tag that is in ids data: labeled events containing features, date and a customer id tag ids: the customer ids you want to keep for event in data: if event has a customer id tag that is in ids, keep it else, drop it return data algorithm: for the number of cross-val you want: customer_train_ids, customer_test_ids = split_by_customers( customer_ids ) train_data, test_data = split_data_in_time_series_way( data ) final_train_data = keep_customer_ids( train_data, customer_train_ids ) final_test_data = keep_customer_ids( test_data, customer_test_ids ) do_the_fit_predict_things( final_train_data, final_test_data )
