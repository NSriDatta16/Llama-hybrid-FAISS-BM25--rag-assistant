[site]: stackoverflow
[post_id]: 4640281
[parent_id]: 
[tags]: 
Design of std::ifstream class

Those of us who have seen the beauty of STL try to use it as much as possible, and also encourage others to use it wherever we see them using raw pointers and arrays . Scott Meyers have written a whole book on STL, with title Effective STL . Yet what happened to the developers of ifstream that they preferred char* over std::string . I wonder why the first parameter of ifstream::open() is of type const char* , instead of const std::string & . Please have a look at it's signature: void open(const char * filename, ios_base::openmode mode = ios_base::in ); Why this? Why not this: void open(const string & filename, ios_base::openmode mode = ios_base::in ); Is this a serious mistake with the design? Or this design is deliberate? What could be the reason? I don't see any reason why they have preferred char* over std::string . Note we could still pass char* to the latter function that takes std::string . That's not a problem! By the way, I'm aware that ifstream is a typedef, so no comment on my title.:P. It looks short that is why I used it. The actual class template is : template class basic_ifstream;
