[site]: stackoverflow
[post_id]: 1591591
[parent_id]: 
[tags]: 
Can one leverage std::basic_string to implement a string having a length limitation?

I'm working with a low-level API that accepts a char* and numeric value to represent a string and its length, respectively. My code uses std::basic_string and calls into these methods with the appropriate translation. Unfortunately, many of these methods accept string lengths of varying size (i.e. max( unsigned char ), max( short ), etc...) and I'm stuck writing code to make sure that my string instances do not exceed the maximum length prescribed by the low-level API. By default, the maximum length of an std::basic_string instance is bound by the maximum value of size_t (either max( unsigned int ) or max( __int64 )). Is there a way to manipulate the traits and allocator implementations of a std::basic_string implementation so that I may specify my own type to use in place of size_t ? By doing so, I am hoping to leverage any existing bounds checks within the std::basic_string implementation so I don't have to do so when performing the translation. My initial investigation suggests that this is not possible without writing my own string class, but I'm hoping that I overlooked something :)
