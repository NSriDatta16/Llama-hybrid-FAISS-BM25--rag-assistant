[site]: crossvalidated
[post_id]: 514569
[parent_id]: 513629
[tags]: 
This is an interesting problem. My basic approach is to fit a kernel density estimate as the question suggested, but adjust the bandwidth to see if I can find a bandwidth for $XY$ and a bandwidth for $Y$ such that $X$ is never negative. I don't think a solution is guaranteed, but it worked in my examples. To find the bandwidths, I used a machine learning approach with a cost function constructed to ensure there are no negative sections of the $X$ pdf and to ensure that the bandwidths don't get inflated. I don't have a reference for this, but I couldn't find anything directly on point here. Also, note that I think the pdf equation should be: $f_{XY} = (1-m)f_X + mf_Y$ so $f_X = \frac{1}{1-m} (f_{XY} - mf_Y)$ # x = points to evalue density # xi = data from a random sample of the distribution # bw = bandwidth my_density = 0, 0, densityA2^2)) + lambda*((par[1] - 1)^2 + (par[2] - 1)^2) }; # Generate XY sampling data set.seed(1843948) m $par[2]) density_y par[1]) density_x $par[2]) - m * my_density(z, y, o$ par[1])) / (1 - m) any(density_x [1] FALSE plot(z, density_xy, type = "l", col = "blue", xlab = "", ylab = "Density", ylim = c(0, 0.4)) lines(z, density_y, col = "red") lines(z, density_x, col = "green") # With a lambda = 0.1, you get a density that follows the mixture better, but allows for a negative X density o $par[2]) density_y par[1]) density_x $par[2]) - m * my_density(z, y, o$ par[1])) / (1 - m) any(density_x [1] TRUE plot(z, density_xy, type = "l", col = "blue", xlab = "", ylab = "Density", ylim = c(0, 0.4)) lines(z, density_y, col = "red") lines(z, density_x, col = "green")
