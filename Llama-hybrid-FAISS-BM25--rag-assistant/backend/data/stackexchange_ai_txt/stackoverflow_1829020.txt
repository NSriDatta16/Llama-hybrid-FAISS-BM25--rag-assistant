[site]: stackoverflow
[post_id]: 1829020
[parent_id]: 1828968
[tags]: 
s[0] &= 0x7F; means bit-and s[0] with hex 7F or in other words, strip the sign bit off the byte value. same with s[len-1] , so it: takes a numerical string, where the first or the last digit has a sign bit added ( 0x30 - 0x39 == '0' - '9' and 0xB0 - 0xB9 is the same range with the 0x80 bit set.) strips that sign bit, remembering it as multiplier interprets the numerical string argument using the multiplier to set the sign returns that value Edit : Reviewing your code leads me to the following remarks: it does not work as intended, be sure to write some JUnit tests for new code to check that they do what you expect place the magic numbers in separate constants use byte constants when comparing to bytes (sign issues) the dangling else's should get braces and in this case are unneeded use new String(byte[]) to reconstruct the string, not the Arrays utility class. This leads me to this version: // Bit Pattern: 0111 1111 private static final int BYTE_7F = 0x7F; // '0' with sign bit set private static final byte BYTE_NEGATIVE_0 = (byte) 0xB0; // '9' with sign bit set private static final byte BYTE_NEGATIVE_9 = (byte) 0xB9; private long getSignedValue(String value) { byte[] bytes = value.getBytes(); final int length = bytes.length; long multiplier = 1; if (0 = BYTE_NEGATIVE_0 && bytes[0] = BYTE_NEGATIVE_0 && bytes[length - 1] You still have to pay attention to adding correct comments and update the constant names to bring them in line with your documentation terminology.
