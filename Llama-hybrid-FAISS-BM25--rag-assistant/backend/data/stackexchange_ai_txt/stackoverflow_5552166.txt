[site]: stackoverflow
[post_id]: 5552166
[parent_id]: 5551330
[tags]: 
From the POV of the users of your wrapper, the best would be if they would call either an overloaded function or a function (member) template that they pass an object to of the appropriate type and which will then magically do the right thing for that type. That is, the best would be to have a function getData(unsigned int colIndex, T&) for any type T your class (or the Oracle API) supports, which will find out the necessary buffer size, allocate the buffer, determine the right enum, and call the Oracle API function. I'm sure you can work out most of the details, probably with the exception of how to map a type to the enum , so this is what I'll try to line out. Basically, I see two possibilities for this, one of which (employing a compile-time list) is better suited if you have lots of types to support, while the other one (employing traits) needs to be used if there's more type-specific to this than just mapping a type to an enum . The traits method is quite simple to use, but tedious if you have many types: template struct get_data_buffer_traits; template<> struct get_data_buffer_traits { Type type OCCIINT; }; template<> struct get_data_buffer_traits { Type type OCCIBFLOAT; }; You can then map the type passed to your template as T into the right enum value using get_data_buffer_traits ::type . This traits template is also the place where you can put any other type-specific operation your generic data retrieval function might need (like converting between what's in the buffer and the actual type, if that isn't a straight-forward cast). If you don't have anything else to put into these traits, you could use a macro to make defining these easier: #define DEFINE_GET_DATA_BUFFER_TRAITS(Type_,Enum_) \ template<> struct get_data_buffer_traits { Type type Enum_; }; DEFINE_GET_DATA_BUFFER_TRAITS(int , OCCIINT ); DEFINE_GET_DATA_BUFFER_TRAITS(float, OCCIBFLOAT); ... #undef DEFINE_GET_DATA_BUFFER_TRAITS However, if that's the case, you might as well create a compile-time map that maps the two and search that (at compile-time) for the right enum value. If you don't have a template meta library at hand that provides this, here's the outline for an idea how to do that yourself: // Beware, brain-compiled code ahead! struct nil {}; template struct set_data_buffer_type_map_node { typedef HType head_type enum { head_enum = HEnum }; typedef T tail_type; }; typedef set_data_buffer_type_map_node > // either count or keep adding these until compiler accepts :) set_data_buffer_type_map; template struct getter { // recurse towards tail Type get_enum() { return getter ::get_enum(); } }; template struct getter > { // current node has T as HType Type get_enum() { return set_data_buffer_type_map ::head_enum; } }; template struct getter > { // no function here, so compile-time error }; template Type get_type_enum() { return getter ::get_enum(); } (Note: This is just an outline. I have not even attempted to compile it. )
