[site]: stackoverflow
[post_id]: 1144089
[parent_id]: 1143405
[tags]: 
Part of the problem is you're defining a class method called find_current and an instance method called filter_my_rows. Generally you define them both within the same scope for them to work together. Another thing is you can do a lot of the filtering you need with a simple Array#reject call. For example: @models = all.reject do |m| # This block is used to remove entries that do not qualify # by having this evaluate to true. !m.current end You can modularize this somewhat by plugging in functions as required, too, but that can get wildly complicated to manage if you're not careful. # Define reusable blocks that are organized into a Hash CONDITION_FILTERS = { :current => lambda { |m| m.current } } # Array#select is the inverse of Array#reject @models = all.select(CONDITION_FILTERS[:current]) While you stated in your question that this was only required because of concerns about not being able to determine the relevance of a particular record before all the records are loaded from the database, this is generally bad form since you will probably be rejecting a large amount of data that you've gone through the trouble of retrieving and instantiating as models only to immediately discard them. If possible, you should at least cache the retrieved rows for the duration of the request so you don't have to keep fetching them over and over.
