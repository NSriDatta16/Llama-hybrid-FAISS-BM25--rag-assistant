[site]: stackoverflow
[post_id]: 4413918
[parent_id]: 4413535
[tags]: 
It's always best practice to code without the possibility for exceptions to be thrown in the first place. If you need a reason: They're slow. Quantifiably slower than coding around them in even the most inelegant ways in most cases. That being said, sometimes they are unavoidable because of the code other people have written or they are desired because you really do want the program to blow up in the face of the user (see catastrophic failure). Only in these two cases is exception handling the way to go. But this doesn't mean you wrap every IEnumerable .First() in an if(sequence.Count() > 0) . Learn to structure your code soundly, such that you don't ever call the .First() on an empty sequence in the first place. Elegant code is win. I recently wrote a quick app for my employer to be used in an automated system (where the user does not sit at the keyboard) that must require the user to enter login information in command line args (think batch file) or a config file else it intentionally blows up in their face, as per spec. In this case, an exception is warranted. All the code below demonstrates my philosophy on Exceptions. private static string _password; public static string Password { get { if (_password.IsNullOrWhiteSpace()) throw new NullReferenceException(string.Format("{0} {1}", "Password was neither found in the .cfg file nor the", "command line arguments.")); return _password; } set { _password = value ?? string.Empty; } } An example of coding without exceptions in this extension method I just wrote. public static bool All (this IEnumerable list, Func func) { if (list.Count() i && func(first,k)); } Notice below I dealt with I/O Exceptions within the scope of the I/O method, but I parsed the data in the config file in such a way that my logic will never throw an exception. Note how The .Count() is verified to be 2 in all pieces of data. At this point, I can be confident that .First() and .Last() will not only be valid to the compilier and not throw exceptions, but be guaranteed to yield potentially valid pieces of data (non-whitespace, different values). This is the kind of philosophy I recommend you adapt when you think about Exception handling -> How do I filter and control my data in a referentially transparent way to completely eliminate errors within the scope of the method? public static class ConfigParser { public static Dictionary PullFromConfigFile() { ParallelQuery > data; try { TextReader tr = new StreamReader("config.cfg"); data = tr.ReadToEnd() .Split('\n') .AsParallel() .Select(i => new string(i.TakeWhile(k => k != '#').ToArray())) .Where(i => !i.IsNullOrWhiteSpace()) .Select(i => i.Split('\t') .Where(k => !k.IsNullOrWhiteSpace()) .Select(k => k.Trim()) ) .Where(i => i.Count() == 2) .Select(i => new Tuple (i.First(), i.Last())); tr.Close(); } catch (IOException) { Logger.Bad("config.cfg file was not found"); return new Dictionary (); } return ConfigParser.ParseIntoDict(data); } private static Dictionary ParseIntoDict(ParallelQuery > data) { var agg = new Dictionary (); foreach (var entry in data) { if (!agg.ContainsKey(entry.Item1)) agg.Add(entry.Item1, entry.Item2); } var width = agg.Keys.Max(k => k.Length); agg.ForAll(i => Logger.Log("Loaded Data: {0} {1}", i.Key.SetWidth(width, '-'), i.Value)); return agg; } } Extensions used: public static class Extensions { public static string SetWidth(this string item, int width, char padder, bool right = true) { if (item == null) return new string(padder, width); if (width > item.Length) return right ? item.PadRight(width, padder) : item.PadLeft(width, padder); return item.Substring(0, width); } public static bool IsNullOrWhiteSpace(this string str) { return string.IsNullOrWhiteSpace(str); } }
