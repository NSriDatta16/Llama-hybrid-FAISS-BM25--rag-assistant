[site]: stackoverflow
[post_id]: 2474496
[parent_id]: 2474486
[tags]: 
Java char s are 2 bytes (16 bits unsigned) in size. So if you want 2MB you need one million characters. There are two obvious issues with your code: Repeatedly calling length() is unnecessary. Add any character to a Java String and it's length goes up by 1, regardless of what the character is. Perhaps you're confusing this with the size in bytes. It doesn't mean that; and You have huge memory fragmentation issues with that code. To further explain (2), the String concatenation operator ( + ) in Java causes a new String to be created because Java String s are immutable. So: String a = "a"; a += "b"; actually means: String a = "a"; String a = a + "b"; This sometimes confuses former C++ programmers as strings work differently in C++. So your code is actually allocating a million strings for a message size of one million. Only the last one is kept. The others are garbage that will be cleaned up but there is no need for it. A better version is: private static String createDataSize(int msgSize) { StringBuilder sb = new StringBuilder(msgSize); for (int i=0; i The key difference is that: A StringBuilder is mutable so doesn't need to be reallocated with each change; and The StringBuilder is preallocated to the right size in this code sample. Note: the astute may have noticed I've done: sb.append('a'); rather than: sb.append("a"); 'a' of course is a single character, "a" is a String . You could use either in this case. However, it's not that simple because it depends on how the bytes are encoded. Typically unless you specify it otherwise it'll use UTF8, which is variable width characters. So one million characters might be anywhere from 1MB to 4MB in size depending on you end up encoding it and your question doesn't contain details of that. If you need data of a specific size and that data doesn't matter, my advice would be to simply use a byte array of the right size.
