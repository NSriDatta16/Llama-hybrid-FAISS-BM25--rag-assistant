[site]: stackoverflow
[post_id]: 5500630
[parent_id]: 3130785
[tags]: 
There will be an IO completion item queued for an IO operation whenever the IO operation is able to start. Regardless of whether an error is encountered or not after the IO operation starts, a completion item will be queued to the completion port. There is a mapping problem between the NTSTATUS codes returned by the IO system and Win32 error codes that makes it hard to tell what statuses are errors and which are just informational. NTSTATUS , which is used by the kernel and the native API, has four levels of severity: success, information, warning and error. Anything but an error code would indicate that the IO operation was able to start. Win32 only has one severity ( ERROR_* ), so the success, information and warning codes had to be mapped alongside the error codes. ERROR_IO_PENDING - STATUS_PENDING is a success status ERROR_MORE_DATA - STATUS_BUFFER_OVERFLOW a warning or STATUS_MORE_ENTRIES a success status You can ignore any non-error codes that ReadFile or WriteFile return and expect a queued completion item, but determining which is which can be a bit of a pain. It would be nice if the Win32 error codes were better organized, but Microsoft does provide a mapping from NTSTATUS to Win32 error codes: http://support.microsoft.com/kb/113996 . See ntstatus.h in the platform SDK or your VS installation to determine what severity a NTSTATUS code is. It is possible for the IO operation to be completed when the original API call returns, e.g. a read request that was just copied out of the cache (nothing to wait on asynchronously). A completion message will still be queued in such cases for consistency's sake.
