[site]: stackoverflow
[post_id]: 789945
[parent_id]: 775726
[tags]: 
I agree with others that seeing a few small examples is not the best way to show off Haskell. But I'll give some anyway. Here's a lightning-fast solution to Euler Project problems 18 and 67 , which ask you to find the maximum-sum path from the base to the apex of a triangle: bottomUp :: (Ord a, Num a) => [[a]] -> a bottomUp = head . bu where bu [bottom] = bottom bu (row : base) = merge row $ bu base merge [] [_] = [] merge (x:xs) (y1:y2:ys) = x + max y1 y2 : merge xs (y2:ys) Here is a complete, reusable implementation of the BubbleSearch algorithm by Lesh and Mitzenmacher. I used it to pack large media files for archival storage on DVD with no waste: data BubbleResult i o = BubbleResult { bestResult :: o , result :: o , leftoverRandoms :: [Double] } bubbleSearch :: (Ord result) => ([a] -> result) -> -- greedy search algorithm Double -> -- probability [a] -> -- list of items to be searched [Double] -> -- list of random numbers [BubbleResult a result] -- monotone list of results bubbleSearch search p startOrder rs = bubble startOrder rs where bubble order rs = BubbleResult answer answer rs : walk tries where answer = search order tries = perturbations p order rs walk ((order, rs) : rest) = if result > answer then bubble order rs else BubbleResult answer result rs : walk rest where result = search order perturbations :: Double -> [a] -> [Double] -> [([a], [Double])] perturbations p xs rs = xr' : perturbations p xs (snd xr') where xr' = perturb xs rs perturb :: [a] -> [Double] -> ([a], [Double]) perturb xs rs = shift_all p [] xs rs shift_all p new' [] rs = (reverse new', rs) shift_all p new' old rs = shift_one new' old rs (shift_all p) where shift_one :: [a] -> [a] -> [Double] -> ([a]->[a]->[Double]->b) -> b shift_one new' xs rs k = shift new' [] xs rs where shift new' prev' [x] rs = k (x:new') (reverse prev') rs shift new' prev' (x:xs) (r:rs) | r I'm sure this code looks like random gibberish. But if you read Mitzenmacher's blog entry and understand the algorithm, you'll be amazed that it's possible to package the algorithm into code without saying anything about what you're searching for. Having given you some examples as you asked for, I will say that the best way to start to appreciate Haskell is to read the paper that gave me the ideas I needed to write the DVD packer: Why Functional Programming Matters by John Hughes. The paper actually predates Haskell, but it brilliantly explains some of the ideas that make people like Haskell.
