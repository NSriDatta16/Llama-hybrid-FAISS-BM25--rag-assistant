[site]: stackoverflow
[post_id]: 1874609
[parent_id]: 1345663
[tags]: 
I finally found the answer for this. The error in the above code (which by the way is the near-exact sample from the SDK docs ) is not in the memory management code. Autorelease is one option, manual release is another. Regardless of how you handle your NSURLConnection object, you get leaks using NSURLConnection. First up, here is the solution. Just copy these 3 lines of code directly into connectionDidFinishLoading, didFailWithError and anywhere else you release the NSURLConnection object. NSURLCache *sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:0 diskCapacity:0 diskPath:nil]; [NSURLCache setSharedURLCache:sharedCache]; [sharedCache release]; Credit to mpramodjain on http://forums.macrumors.com/showthread.php?t=573253 for the code. The problem seems to be this â€“ the SDK caches the requests and replies on the iPhone. Even it seems if your NSMutableURLRequest cachePolicy is set to not load the reply from the cache. The silly thing is that it seems to cache a lot of data by default. I'm transmitting a lot of data (split into multiple connections) and started to get memory warnings, and finally my App died. The docs we need are in NSURLCache (not NSURLConnection), they state: NSURLCache implements the caching of responses to URL load requests by mapping NSURLRequest objects to NSCachedURLResponse objects. It is a composite of an in-memory and an on-disk cache. Methods are provided to manipulate the sizes of each of these caches as well as to control the path on disk to use for persistent storage of cache data. Those three lines have the effect of nuking the cache totally. After adding them to my App ( GPS Log ), my #living object count remains steady.
