[site]: stackoverflow
[post_id]: 1695786
[parent_id]: 1695671
[tags]: 
All the other answers so far have relied on sorting the list, which is an O(n log n) operation if you don't already have it sorted. Here's a solution which is O(n) albeit it with a horrible constant factor. It uses MinBy from MoreLINQ - you could easily rewrite that in your own code if you need to, and even make it return the index directly instead of the value (and use RemoveAt instead of Remove ). // The list.Count part is in case the list starts off with // fewer than 3 elements for (int i = 0; i 0; i++) { var oldest = list.MinBy(x => x.Date); list.Remove(oldest); } You could certainly write this more efficiently to find the oldest three elements in a single pass of the list - but the code would be significantly more complicated, leading to more chances for errors. The above should work fine in O(n), even if it's lacking in elegance when you think of it going through the list 6 times :)
