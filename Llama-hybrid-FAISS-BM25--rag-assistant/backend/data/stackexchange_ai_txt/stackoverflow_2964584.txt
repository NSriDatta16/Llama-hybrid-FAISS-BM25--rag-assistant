[site]: stackoverflow
[post_id]: 2964584
[parent_id]: 2964516
[tags]: 
In this case, it sounds like you should simply use overloading. For example: #ifdef __cplusplus // Only enable this awesome thing for C++: # define PROVIDE_OVERLOAD(CLASS,TYPE) \ inline void ShowNiceDialog(const CLASS& obj){ \ ShowNiceDialog(static_cast (&obj),TYPE); \ } PROVIDE_OVERLOAD(Car,DATATYPE_CAR) PROVIDE_OVERLOAD(Bicycle,DATATYPE_BICYCLE) // ... #undef PROVIDE_OVERLOAD // undefine it so that we don't pollute with macros #endif // end C++ only If you create overloads for your various types, then you will be able to invoke ShowNiceDialog in a simple and type safe manner, but you will still be able to leverage your optimized C variant of it. With the code above, you could, in C++, write something like the following: Car c; // ... ShowNiceDialog(c); If you changed the type of c , then it would still use the appropriate overload (or give an error if there was no overload). It doesn't prevent one from using the existing type-unsafe C variant, but since the typesafe version is easier to invoke, I would expect that other developers would prefer it, anyway. Edit I should add that the above answers the question of how to make the API typesafe, not about how to make the implementation typesafe. This will help those using your system to avoid unsafe invocations. Also note that these wrappers provide a typesafe means for using types known already at compile-time... for dynamic types, it really would be necessary to use the unsafe versions. However, another possibility is that you could provide a wrapper class like the following: class DynamicObject { public: DynamicObject(void* data, int id) : _datatype_id(id), _datatype_data(data) {} // ... void showNiceDialog()const{ ShowNiceDialog(_datatype_data,_datatype_id); } // ... private: int _datatype_id; void* _datatype_data; }; For those dynamic types, you would still not have much safety when it comes to constructing the object, but once the object were constructed, you would have a much safer mechanism. It would be reasonable to combine this with a typesafe factory so that users of your API would never actually construct the DynamicObject class themselves, and so would not need to invoke the unsafe constructor.
