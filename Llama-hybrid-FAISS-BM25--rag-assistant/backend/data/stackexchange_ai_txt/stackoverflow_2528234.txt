[site]: stackoverflow
[post_id]: 2528234
[parent_id]: 2528199
[tags]: 
In "place1", you need a reference. Object1 isn't fully defined, so you can't take it by value. That said, you wouldn't want to pass by value; when you take the address of it, you'd be getting the address of the copy, not the actual object. Since you only want a pointer to a BaseClass , it might make more sense to only place that restriction on the parameter. (Of course, if you really need an Object1 , reflect that in the type of link : Object1* link; ). Also consider using an initialization list: Object1(int a) : i(a), link(0) /* Always use an initialize list. "place2" creates an unnamed instance of Object1 using a constructor. It has no storage(?) auto storage, and dies at the end of the expression . That is, once you've hit the semicolon in Object1 a(1, /*place2*/ Object1(2)); , it ceases to exist and you have a pointer to an non-existent object! This results in undefined behavior. Give it a lifetime beyond the expression: Object1 x(2); Object1 a(1, x); Always make sure that when you refer an object, it will live the entire time you refer to it. Your new compile error is because you can't have a reference to a temporary variable. You can have one with a const-reference, though. The thing is, your pointer needs to point to a const BaseClass now, which may dampen what you want. Again, your design needs reworking, unfortunately.
