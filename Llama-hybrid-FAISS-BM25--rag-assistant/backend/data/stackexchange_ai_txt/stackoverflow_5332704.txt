[site]: stackoverflow
[post_id]: 5332704
[parent_id]: 5322761
[tags]: 
you can't just ignore the survivor spaces when using CMS. CMS is not a compacting collector which means that if you (or the JVM) gets the tenuring threshold wrong then you will slowly bleed objects into tenured which will increase the rate at which tenured fragments which will bring forward the time when CMS is forced because it has insufficient contiguous free space available to handle promotions from the survivor spaces into tenured which will force a full gc cycle with no advance warning and hence it's the full thing in 1 STW pause. How long this takes will depend on the size of your heap but one thing is highly likely, it will be orders of magnitude longer than a normal eden collection. There are a few other things to note here; STW pauses do not only come from CMS, they come from the young gen collector too CMS has 2 STW phases (mark and remark) and 3-4 concurrent phases, the 1st STW phase (mark) is strictly singlethreaded which can cause issues (sample discussion on this here ) You can control the no of threads handling the concurrent phases You need to understand how long objects tend to live for, this may mean use of -XX:+PrintTenuringDistribution or you can just watch it with visualgc like you've done You can then tune this with -XX:SurvivorRatio to control the size of the survivor spaces relative to eden and -XX:MaxTenuringThreshold to control how often an object can survive a young collection before it is tenured -XX:CMSInitiatingOccupancyFraction can be used to guide CMS as to how full it needs to be before it starts the CMS phase (get this wrong and you'll pause badly) Ultimately you need to understand which collector is pausing, how often, for how long and whether there are any abnormal causes of that pause. You then need to compare this against the size of each generation to see whether you can tweak the parameters so as to minimise the number (and/or the duration) of pauses. Bear in mind that this can be timesink due to the need for long running tests to see whether it deteriorates over time. Also without a repeatable, automated workload, it's nigh on impossible to draw any firm conclusions as to whether you've actually improved things. One good source of summary info on the internals is Jon Masamitsu's blog . Another good presentation on this is GC Tuning in the HotSpot Java VM .
