[site]: stackoverflow
[post_id]: 4024877
[parent_id]: 4022594
[tags]: 
It depends on what you are doing with the data. If you are simply performing XSLT transforms on XML files to produce HTML files then you may not need to touch a parser directly: import java.io.File; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.stream.StreamResult; import javax.xml.transform.stream.StreamSource; public class Demo { public static void main(String[] args) throws Exception { TransformerFactory tf = TransformerFactory.newInstance(); StreamSource xsltTransform = new StreamSource(new File("xslt.xml")); Transformer transformer = tf.newTransformer(xsltTransform); StreamSource source = new StreamSource(new File("source.xml")); StreamResult result = new StreamResult(new File("result.html")); transformer.transform(source, result); } } If you need to make changes to the input document before you transform it, DOM is a convenient mechanism for doing this: import java.io.File; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import javax.xml.transform.stream.StreamSource; import org.w3c.dom.Document; public class Demo { public static void main(String[] args) throws Exception { TransformerFactory tf = TransformerFactory.newInstance(); StreamSource xsltTransform = new StreamSource(new File("xslt.xml")); Transformer transformer = tf.newTransformer(xsltTransform); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document document = db.parse(new File("source.xml")); // modify the document DOMSource source = new DOMSource(document); StreamResult result = new StreamResult(new File("result.html")); transformer.transform(source, result); } } If you prefer a typed model to make changes to the data then JAXB is a perfect fit: import java.io.File; import javax.xml.bind.JAXBContext; import javax.xml.bind.Unmarshaller; import javax.xml.bind.util.JAXBSource; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.stream.StreamResult; import javax.xml.transform.stream.StreamSource; public class Demo { public static void main(String[] args) throws Exception { TransformerFactory tf = TransformerFactory.newInstance(); StreamSource xsltTransform = new StreamSource(new File("xslt.xml")); Transformer transformer = tf.newTransformer(xsltTransform); JAXBContext jc = JAXBContext.newInstance("com.example.model"); Unmarshaller unmarshaller = jc.createUnmarshaller(); Model model = (Model) unmarshaller.unmarshal(new File("source.xml")); // modify the domain model JAXBSource source = new JAXBSource(jc, model); StreamResult result = new StreamResult(new File("result.html")); transformer.transform(source, result); } }
