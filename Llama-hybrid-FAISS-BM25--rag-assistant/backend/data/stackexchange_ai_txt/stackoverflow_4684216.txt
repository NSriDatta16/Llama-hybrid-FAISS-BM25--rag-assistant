[site]: stackoverflow
[post_id]: 4684216
[parent_id]: 
[tags]: 
Solving the NSInteger NSNumber problem

I've written a large social networking iPhone application, and one of the biggest issues I run into is the fact that NSInteger (and all the other NS-non-object types) are not first class citizens. This problem stems from the fact that, obviously, they have no representation for a nil value. This creates two main problems: Tons of overhead and opaqueness to convert to and from NSNumber when storing/retrieving from a collection. Can't represent nil. Oftentimes, I want to be able to represent an "unset" value. One way to solve this is to use NSNumber all the time, but that gets extremely confusing. In a User model object, I would have about 20 different NSNumbers, and no easy way to tell if each one is a float, integer, bool, etc. So here are my thoughts for potential solutions and the pros/cons. I'm not really sold on any of them, so I thought I'd ask for feedback and/or alternative solutions to this problem. Continue to use NSInteger types, and just use NSIntegerMax to represent nil. PRO - Less memory overhead PRO - Clear typing CON - NSIntegerMax is not really nil. If programmers aren't careful or don't know this convention, invalid values could leak into the display layer. CON - Can't store them in a collection without conversions in and out Use NSNumber and designate types using hungarian notation (eg NSNumber fHeight, NSNumber iAge) PRO - First-class citizens PRO - Nil problem solved CON - Increased memory overhead CON - Lose compiler type checking CON - Hungarian notation is contentious Write my own first-class primitive object types (think Java http://developer.android.com/reference/java/lang/Integer.html ) PRO - First-class citizens PRO - Nil problem solved PRO - Keeps compiler type checking PRO - Objects will be simpler than NSNumber. Internal storage will specific to data type. CON - Increased memory overhead CON - Sacrifices a bit of code portability and compatibility Looking for a convincing argument in favor of one of these techniques, or one I haven't thought of if you've got one. UPDATE I've gone ahead and started an open source project (Apache 2.0), into which I'll be pulling a number of our internal classes as I have time. It currently includes object wrappers for some of the more common native data types (BOOL, CGFloat, NSInteger, NSUInteger). We chose to do this because it upgrades these data types to first class citizens with strict typing. Maybe you disagree with this approach, but it has worked well for us, so feel free to use it if you want. I'm adding other classes we've found uses for, including a disk-backed LRU cache, a "Pair" object, a low memory release pool, etc. Enjoy github - Zoosk/ZSFoundation
