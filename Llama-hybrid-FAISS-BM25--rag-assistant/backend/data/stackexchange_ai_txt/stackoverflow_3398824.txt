[site]: stackoverflow
[post_id]: 3398824
[parent_id]: 3398504
[tags]: 
I recommend using a mocking framework , such as EasyMock . Mocks allow you to configure dependencies with the desired behaviour for your tests. In your case, you need a mock DocumentEvent and ideally another one for component , which I guess is a class member. The two aspects to unit testing how to test, i.;e. the technical details of assembling the right set of objects in the right state required for the test to run properly (aka the _test fixture), and what to test, i.e. the scenarios to validate. How to test Eclipse supports JUnit out of the box, so you may quickly generate new JUnit testcases (in Project Explorer context menu: New -> (Other ->) JUnit -> JUnit Test Case), then run it by clicking on the Run button. Setting up the test fixture in your case would look something like this, using EasyMock (and assuming you can pass the component as a constructor parameter to your tested class): private Component mockComponent; private ClassUnderTest classUnderTest; private DocumentEvent mockEvent; private Document mockDocument; private Highlighter mockHighlighter; @Before public void setUp() { mockComponent = createMock(Component.class); classUnderTest = new ClassUnderTest(mockComponent); mockEvent = createMock(DocumentEvent.class); mockDocument = createMock(Document.class); expect(mockEvent.getDocument()).andStubReturn(mockDocument); expect(mockDocument.getLength()).andReturn(1); mockHighlighter = createMock(Highlighter.class); expect(mockComponent.getHighlighter()).andReturn(mockHighlighter); } @Test public void testEmptyText() { expect(mockDocument.getText(0, 1)).andStubReturn(""); mockHighlighter.removeAllHighlights(); replay(mockComponent, mockEvent, mockDocument, mockHighlighter); classUnderTest.handle(mockEvent); verify(mockComponent, mockEvent, mockDocument, mockHighlighter); } This test assumes that maxMessageSize is at least 1 by default - setting maxMessageSize up for the test is left to you as an exercise as the code snippet you published gives no clue for that. What to test The method you show gets text from the document associated with the event, then based on its length, it does different things. I would write at least the following unit tests for this: empty document text with maxMessageSize == 0 empty document text with maxMessageSize > 0 nonempty document text with maxMessageSize == text.length() nonempty document text with maxMessageSize > text.length() nonempty document text with maxMessageSize and addHighlight() throwing BadLocationException Notes sensing the BadLocationException is a bit tricky, since all it produces is an output to stdout; luckily, you can easily reassign stdout via System.setOut . However, you may want to consider improving exception handling, at least by using a logging framework instead of printing to stdout. from the code it seems that other methods (such as removeAllHighlights() and/or getText() ) may also throw BadLocationException , however the try-catch blocks are not well organized. I would consider adding more unit tests where those methods throw, and after that, refactoring the exception handling code. Update I thought there was something wrong that I was doing...Can you please provide me with the modified/corrected code please??? Your testSetLength method is not really testing anything - you need assert statements (and/or EasyMock verification) in order for your unit tests to actually verify some behaviour. However, it provides the missing clue for setting up the tested class. So I try to unify your two test methods to create one which is hopefully working (I am writing from memory, so I can't guarantee it will all compile and run perfectly at first try) : @Test public void testEmptyText() { // set up the test class with a specific max length classUnderTest = new MaxLength(125); // this shall be called from inside decorate() mockDocument.addDocumentListener(classUnderTest); // the mock document shall always return an empty text EasyMock.expect(mockDocument.getText(0, 1)).andStubReturn(""); // we expect this to be called from inside handle() mockHighlighter.removeAllHighlights(); // start replay mode EasyMock.replay(mockComponent, mockEvent, mockDocument, mockHighlighter); // inject mock component into tested object maxListener.decorate(mockComponent); // call the tested method classUnderTest.handle(mockEvent); // verify that all expected calls to the mocks have been made EasyMock.verify(mockComponent, mockEvent, mockDocument, mockHighlighter); }
