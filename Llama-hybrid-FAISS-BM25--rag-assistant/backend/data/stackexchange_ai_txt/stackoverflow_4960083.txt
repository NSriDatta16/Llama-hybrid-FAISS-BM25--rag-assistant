[site]: stackoverflow
[post_id]: 4960083
[parent_id]: 4909356
[tags]: 
I have about zero knowledge on Ruby. However, your problem looks like a padding issue. AES/CBC encrypts data by blocks of 16 bytes, no less. Padding is about adding a few bytes such that: the padded length is a multiple of 16; upon decryption, the extra bytes can unambiguously removed. The second condition means that there cannot be a "zero-length padding" (at least, not without resorting to dark trickery such as "ciphertext stealing"). There must be at least one extra byte of padding. Otherwise, the decryptor would not know whether the end of the obtained data is really some padding, or the actual message which happens to end in some bytes which "look like" padding. A very common padding scheme is the one specified in PKCS#5 (see section 6.1.1): for blocks of length n ( n =16 for AES), at least 1 and at most n bytes are added; if k bytes are added, then they all have numerical value k . Upon decryption, one just needs to look at the numerical value of the last byte to know how many padding bytes were added. The PKCS#5 padding scheme implies the behaviour that you observe: encryption of m bytes produces n*((m/n)+1) output bytes. If your calls indeed add a PKCS#5 padding at each update , then you can recover from that by removing the last 16 bytes of what they return. You will also have to reset the IV for the next update call, so that what the next update call returns can be simply appended. Speaking of which, I see nothing in your code about the IV, and that's fishy. CBC mode requires a new random IV (selected with a "strong enough" generator) for each message; the IV must then be transmitted along with the encrypted message (whoever decrypts the data will need it; the IV can be sent "in the clear"). The paragraph above should be clearer if you know how CBC works. Wikipedia has good schematics on that.
