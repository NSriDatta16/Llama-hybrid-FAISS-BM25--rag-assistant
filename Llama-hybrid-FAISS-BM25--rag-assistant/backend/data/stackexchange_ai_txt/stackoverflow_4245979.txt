[site]: stackoverflow
[post_id]: 4245979
[parent_id]: 4245936
[tags]: 
The naive / slow / simple way is to extract the low bit of the input and shift it into another variable that accumulates a return value. #include uint32_t mirror_u32(uint32_t input) { uint32_t returnval = 0; for (int i = 0; i >= 1; } return returnval; } For other types, the number of bits of storage is sizeof(input) * CHAR_BIT , but that includes potential padding bits that aren't part of the value. The fixed-width types are a good idea here. The += instead of |= makes gcc compile it more efficiently for x86 (using x86's shift-and-add instruction, LEA). Of course, there are much faster ways to bit-reverse; see the other answers. This loop is good for small code size (no large masks), but otherwise pretty much no advantage. Compilers unfortunately don't recognize this loop as a bit-reverse and optimize it to ARM rbit or whatever. (See it on the Godbolt compiler explorer )
