[site]: stackoverflow
[post_id]: 4772203
[parent_id]: 
[tags]: 
Beginner and C++ templates: Is it an how possible using C++ template make a class oriented to work with chars work with costume structures?

So I am quite wary new to C++ and I really do not understand templates and how to use tham thow I rad wikipedia and started reading like 2000 pages long book on C++... So I am probably way 2 impatient but I wonder If using C++ templates we can make for example such simple class pair work with costume structures instead of chars. #include #include // Boost #include #ifndef _IGraphElementBase_h_ #define _IGraphElementBase_h_ #pragma once using namespace std ; class IGraphElementBase { public: boost::thread GraphWorker; mutable boost::mutex GraphItemMutex; boost::condition_variable GraphItemMutexConditionVariable; int SleepTime; // Function for preparing class to work virtual void Init(){ SetSleepTime(1);} void SetSleepTime(int timeMS) { SleepTime = timeMS; } // Function for data update // word virtual makes it possible to overwrite it virtual void updateData(){} void StartThread() { GraphWorker = boost::thread(&IGraphElementBase::Call, this); } virtual void CleanAPI(){} virtual void Clean() { GraphWorker.interrupt(); GraphWorker.join(); CleanAPI(); } virtual void CastData(){} //Here is a main class thread function in infinite loop it calls for updateData function void Call() { try { for(;;){ boost::this_thread::sleep(boost::posix_time::milliseconds(SleepTime)); boost::mutex::scoped_lock lock(GraphItemMutex); boost::this_thread::interruption_point() ; updateData(); lock.unlock(); CastData(); GraphItemMutexConditionVariable.notify_one(); } } catch (boost::thread_interrupted) { // Thread end } } }; #endif // _IGraphElementBase_h_ #include "IGraphElementBase.h" #ifndef _IGraphElement_h_ #define _IGraphElement_h_ using namespace std ; class IGraphElement : public IGraphElementBase{ // We should define prototype of functions that will be subscribers to our data typedef void FuncCharPtr(char*, int) ; public: struct GetResultStructure { int length; char* ptr; }; // initGet sets up a pointer holding a copy of pointer of data we want to return on Get() call void InitGet(char * pointerToUseInGetOperations, int pointerToUseInGetOperationsSize) { pointerToGet = pointerToUseInGetOperations; pointerToGetSize = pointerToUseInGetOperationsSize; } // Function for adding subscribers functions void Add(FuncCharPtr* f) { FuncVec.push_back(f); } // Returns pointer to copy of current graphItem processed data GetResultStructure Get() { boost::mutex::scoped_lock lock(GraphItemMutex); char * dataCopy = new char[pointerToGetSize]; memcpy (dataCopy,pointerToGet,pointerToGetSize); lock.unlock(); GraphItemMutexConditionVariable.notify_one(); GetResultStructure result; result.ptr = dataCopy; result.length = pointerToGetSize; return result; } void Clean() { GraphWorker.interrupt(); GraphWorker.join(); CleanAPI(); //delete[] pointerToGet; //pointerToGet = 0; } // Cast data to subscribers and clean up given pointer void CastData(){ for (size_t i = 0 ; i FuncVec ; }; #endif // _IGraphElement_h_ So what is most intresting for me in that classes in short: - typedef void FuncCharPtr(char*, int) ; - vector FuncVec ; - functions like void CastData(char * data, int length) It is really wary intresting for me if it is possile to somehow using templates make my classes work with costume structures. So Is it possible and how to do such thing?
