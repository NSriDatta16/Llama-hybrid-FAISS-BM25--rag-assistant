[site]: stackoverflow
[post_id]: 3179011
[parent_id]: 3178829
[tags]: 
You cannot use the ? operator to access functions in a module, because the construct Checks?test1 is not syntactically correct (this would be translated to (?) Checks "test" and you cannot use module names as values). However, it should be possible to do this for members of a type using an instance of the object (e.g. obj?test ). Alternatively you could write a "fake" object instance (that knows the name of the module). The implementation of ? would then look for the module and search static members in the module. The simplest implementation (of the first case) would look like this: let (?) obj s = let memb = obj.GetType().GetMethod(s) // Return name and a function that runs the method s, (fun args -> memb.Invoke(obj, args)) // Type that contains tests as members type Check() = member x.test1 () = 32 // We need to create instance in order to use '?' let ch = Check() let s,f = ch?test1 // Function 'f' takes array of objects as an argument and // returns object, so the call is not as elegant as it could be let n = ((f [| |]) :?> int) You could also add some wrapping to make the function 'f' a little bit nicer, but I hope this demonstrates the idea. Unfortunately, this cannot work for modules.
