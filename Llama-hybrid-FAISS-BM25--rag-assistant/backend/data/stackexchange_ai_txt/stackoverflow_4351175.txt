[site]: stackoverflow
[post_id]: 4351175
[parent_id]: 
[tags]: 
Writing a string to a file results in strange characters

My homework assignment is to create a shell (done) with a history function (done) and then write the history to a file (this is where I am having problems) so that it can be loaded on the next run. I'm normally a Java person, so I need to look up almost every c function. Anyways, I'm having issues write my string array to the file. For some reason I keep getting weird symbols depending on which encoding I use. For example, if I run the program and quit immediately, the history file contains: ??_? If I run ls then quit, the history file contains: ls _? I removed the procedures that aren't related. Thanks in advance for any pointers. This is day 3 of hairpulling. I'm at my wits end. #include /*Had to use \ so that the includes would show here. */ #include \stdlib.h> #include \signal.h> #include \sys/types.h> #include \unistd.h> #include \string.h> #include \errno.h> /* * Constant Declarations */ #define MAX_LINE 80 #define BUFFER_SIZE 50 #define HIST_SIZE 10 static char buffer[BUFFER_SIZE]; char history[HIST_SIZE][BUFFER_SIZE]; int count = 0; int caught = 0; char historyFileLoc[] = "./name.history"; void loadHistory() { int i; char histCommand[BUFFER_SIZE]; i = 0; FILE *hisFile = fopen(historyFileLoc, "r"); if( hisFile ) { /*If a user edits the history file, only the first ten entries will be loaded */ while(!feof(hisFile)) { if(fscanf(hisFile, "%s\n", histCommand) == 1){ strcpy(history[i], histCommand); i++; count++; } } } if(hisFile != NULL){ if(fclose(hisFile) != 0) { perror("History file (r) was not closed correctly"); } } } void saveHistory() { int i; char buffer[MAX_LINE]; FILE *hisFile = fopen(historyFileLoc, "w"); for(i=0; i " and then invokes setup(), which waits for the * user to enter a command. The contents of the command entered by the user are loaded into the * args array. For example, if the user enters ls Ðl at the COMMAND-> prompt, args[0] will be set * to the string ls and args[1] will be set to the string Ðl. (By ÒstringÓ, we mean a * null-terminated, C-style string variable.) */ int main(void) { char inputBuffer[MAX_LINE]; /* buffer to hold the command entered */ int background, status; /* equals 1 if a command is followed by '&' */ char *args[MAX_LINE / 2 + 1]; /* command line arguments */ pid_t pid; /* the process's id */ ... } Dump of history[][]: ./660_Lab04.c.out sh ->ls 660_Lab03_Tests.txt Lab 03 Documentation.docx 660_Lab04.c buffer.h 660_Lab04.c.out name.history 660__Lab01.c main.c 660__Lab03.c main_not_mine.c CSE_660Lab01Documentation.doc This is where the dump begins minus sh-> sh ->ls ls _? ??_? The rest of my code. loadHistory and saveHistory are before this: void printHistory() { int i; int j = 0; int histcount = count; printf("\n"); for (i=0; i "); } /* the signal handler function */ void handle_SIGINT() { write(STDOUT_FILENO,buffer,strlen(buffer)); printHistory(); caught = 1; } void setup(char inputBuffer[], char *args[], int *background) { int length, /* # of characters in the command line */ i, /* loop index for accessing inputBuffer array */ start, /* index where beginning of next command parameter is */ ct, /* index of where to place the next parameter into args[] */ k; /* Generic counter */ ct = 0; /* read what the user enters on the command line */ length = read(STDIN_FILENO, inputBuffer, MAX_LINE); if(caught == 1) { length = read(STDIN_FILENO, inputBuffer, MAX_LINE); caught = 0; } /* checks to see if the command is a history retrieval command. If it isn't then add it to the history */ if((strcmp(inputBuffer, "r\n\0") != 0) && (strncmp(inputBuffer, "r x", 2) != 0) ) { for(i= (HIST_SIZE - 1); i>0; i--) { strcpy(history[i], history[i-1]); } strcpy(history[0], inputBuffer); count++; } start = -1; if (length == 0) { saveHistory(); exit(0); /* ^d was entered, end of user command stream */ } else if ((length 80 */ } } /* The main() function presents the prompt "sh->" and then invokes setup(), which waits for the user to enter a command. The contents of the command entered by the user are loaded into the args array. For example, if the user enters ls -l at the COMMAND-> prompt, args[0] will be set to the string ls and args[1] will be set to the string -l. (By string, we mean a null-terminated, C-style string variable.) */ int main(void) { char inputBuffer[MAX_LINE]; /* buffer to hold the command entered */ int background, status; /* equals 1 if a command is followed by '&' */ char *args[MAX_LINE / 2 + 1]; /* command line arguments */ pid_t pid; /* the process's id */ /* set up the signal handler */ struct sigaction handler; handler.sa_handler = handle_SIGINT; sigaction(SIGINT, &handler, NULL); loadHistory(); while (1) { background = 0; printf("\nsh ->"); fflush(0); setup(inputBuffer, args, &background); /* get next command */ fflush(0); pid = fork(); /* assign the process id */ if (pid
