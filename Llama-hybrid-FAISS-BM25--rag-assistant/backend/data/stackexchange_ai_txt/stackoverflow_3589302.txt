[site]: stackoverflow
[post_id]: 3589302
[parent_id]: 3588341
[tags]: 
Here's a custom function -- it's longer than ysth's answer, but in my opinion it's easier to break down into useful pieces (not being all one regex), and it also has the ability to cope with multiple delimiters that you asked for. sub split_edi { my ($in, %args) = @_; die q/Usage: split_edi($input, escape => "#", delims => [ ... ]) / unless defined $in and defined $args{escape} and defined $args{delims}; my $escape = quotemeta $args{escape}; my $delims = join '|', map quotemeta, @{ $args{delims} }; my ($cur, @ret); while ($in !~ /\G\z/cg) { if ($in =~ /\G$escape(.)/mcg) { $cur .= $1; } elsif ($in =~ /\G(?:$delims)/cg) { push @ret, $cur; $cur = ''; } elsif ($in =~ /\G((?:(?!$delims|$escape).)+)/mcg) { $cur .= $1; } else { die "hobbs can't write parsers"; } } push @ret, $cur if defined $cur; @ret; } The first line is argument parsing, backslashing the escape char as necessary, and building a regex fragment that matches any of the delimiters. Then comes the matching loop: If we find the escape, skip over it and capture the following character as a literal bit of the output instead of treating it specially. If we find any of the delimiters, start a new record. Otherwise, capture characters until the next escape or delimiter. Stop when we reach end-of-string. which is pretty straightforward and still has pretty solid performance. Like ysth's regex solutions, it's ratcheting -- it won't try to backtrack unnecessarily. Correctness isn't guaranteed if the escape or any of the delimiters is multi-character, although I actually think it's pretty much right :) say for split_edi("foo*bar;baz*aster?*isk", delims => [qw(* ;)], escape => "?"); foo bar baz aster*isk
