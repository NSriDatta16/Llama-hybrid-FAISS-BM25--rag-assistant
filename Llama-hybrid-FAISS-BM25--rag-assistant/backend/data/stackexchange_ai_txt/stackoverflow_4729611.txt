[site]: stackoverflow
[post_id]: 4729611
[parent_id]: 4708235
[tags]: 
Setting aside for now the purpose for which it's needed, let's write a Prolog predicate that concatenates a list of strings into one string, placing a double newline between each consecutive pair of strings (but not at the end of the output string, judging by the example that Jerry posted). SWI-Prolog Manual: Normally I'd post "deep" links to the documentation , but the SWI-Prolog site uses a style of URL that triggers cross-site scripting (XSS) warnings with many browser/plugin combinations. So instead I'll refer than link to the appropriate section. Section 4.22 Representing text in strings says (in part), "String objects by default have no lexical representation and thus can only be created using the predicates below or through the foreign language interface." This can be a little confusing, as SWI-Prolog writes strings as double-quoted text, but reads double-quoted text (by default) as lists of character codes. Here's code for a predicate that concatenates the strings in a list, inserting another string Separator in between consecutive string pairs: strSepCat([ ],_,Empty) :- string_to_list(Empty,[ ]). strSepCat([H|T],Separator,StrCat) :- strSepCat(T,Separator,H,StrCat). strSepCat([ ],_,StrCat,StrCat). strSepCat([H|T],Sep,Str,Cat) :- string_concat(Sep,H,SepH), string_concat(Str,SepH,StrSepH), strSepCat(T,Sep,StrSepH,Cat). Note that we've defined two predicates, strSepCat/3 and strSepCat/4 . The former is defined in terms of the latter, a typical design pattern in Prolog that introduces an extra argument as an accumulator that binds to an output when recursion is complete. Such a technique is often helpful in getting a tail recursive definition. To use the predicate strSepCat/3 , we'd generally need to construct the separator string with (the escape sequence for) two newlines: ?- funs(Fs,Lisp,[ ]), string_to_list(Sep,"\n\n"), strSepCat(Fs,Sep,CProg).
