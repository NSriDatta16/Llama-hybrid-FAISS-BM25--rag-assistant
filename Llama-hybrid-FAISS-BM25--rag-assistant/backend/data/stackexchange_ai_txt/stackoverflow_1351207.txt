[site]: stackoverflow
[post_id]: 1351207
[parent_id]: 
[tags]: 
Capturing audio input from mic using SlimDX

VS 2008 SlimDX march 2009 I am using the SlimDX to capture the input audio and display it in a progress bar. I have a backgroundworker that will do the capturing in the background thread and update the progress bar. However, I am getting into the problem of what to value to use as the value to update the progress bar. Everything works ok and the capturing starts. However, the applicatin will fail when I try and update the progress bar. EDIT ==== I have edited my code in the DoWork. This time using Int16 which give a round number. However, the problem I am facing now is that the buffer will overrun. It there anyway to create a circuler buffer that once it gets to the the end it will start over again? Any suggestions? Many thanks, private DirectSoundCapture soundCapture; private WaveFormat wavFormat; private CaptureBufferDescription captureBufDescription; private CaptureBuffer captureBuff; // stopCapturing - flag to stop capturing bool stopCapturing = false; private void AudioCapture_Load(object sender, EventArgs e) { this.FillProperties(); } // Fill wave format properties private void FillProperties() { // Declare a wave audio format to use in getting the input. soundCapture = new DirectSoundCapture(); // Wave Format wavFormat = new WaveFormat(); // wavFormat.FormatTag = SlimDX.WaveFormatTag.IeeeFloat; wavFormat.BitsPerSample = 32; wavFormat.BlockAlignment = (short)(wavFormat.BitsPerSample / 8); wavFormat.Channels = 1; wavFormat.SamplesPerSecond = 44100; wavFormat.AverageBytesPerSecond = wavFormat.SamplesPerSecond * wavFormat.BlockAlignment * wavFormat.Channels; // Capture buffer description captureBufDescription = new CaptureBufferDescription(); // captureBufDescription.ControlEffects = true; captureBufDescription.WaveMapped = true; captureBufDescription.BufferBytes = 8192; captureBufDescription.Format = wavFormat; captureBuff = new CaptureBuffer(soundCapture, captureBufDescription); } // Run capture in background thread to keep the form active private void bgwAudioInput_DoWork(object sender, DoWorkEventArgs e) { Int16[] samples = new Int16[8192 / sizeof(Int16)]; Int16 audioValue = 0; int i = 0; captureBuff.Start(true); while (captureAudio) { if (!this.bgwAudioInput.CancellationPending) { captureBuff.Read(samples, 0, true); audioValue = Math.Abs(samples[captureBuff.CurrentReadPosition]); this.bgwAudioInput.ReportProgress(audioValue); } } } // Start capturing the input audio from the microphone private void btnStart_Click(object sender, EventArgs e) { btnStart.Enabled = false; btnStop.Enabled = true; this.bgwAudioInput.RunWorkerAsync(); } private void btnStop_Click(object sender, EventArgs e) { captureBuff.Stop(); // Exit while loop this.bgwAudioInput.CancelAsync(); stopCapturing = false; btnStop.Enabled = false; btnStart.Enabled = true; }
