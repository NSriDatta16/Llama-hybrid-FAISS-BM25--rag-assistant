[site]: crossvalidated
[post_id]: 291396
[parent_id]: 
[tags]: 
Logistic regression not generalizing

According to Andrew Ng's lecture on logictic regression on Coursera the following cost function can be minimized using the update expression below: Running that update function several hundred times on ~150 samples, I get the following pattern, though the cost seems to be decreasing after each iteration as expected: The circles are the samples I'm training on, where the input features are the (x, y) coordinate of each point, and the color is the target label. The red or yellow background is what the model predicts that (x, y) input classifies as (red = 0, yellow = 1). Question Is that update routine not the correct partial derivative of that corresponding cost function J? What can this output pattern be an indication of? Training method // A single pass/epoch const lr = 0.003; let params = [0.5, 0.5, 0.5]; const scores = samples.map(sample => sig(sum(sample, params)); const errors = scores.map((score, i) => score - labels[i][0]); params = params.map((param, col) => { return param - lr * errors.reduce((acc, error, row) => { return acc + error * samples[row][col]; }, 0); }); Sample training data const samples = [ [1, 142, 78], [1, 108, 182], [1, 396, 47], [1, 66, 102], [1, 165, 116], [1, 8, 106], [1, 245, 119], [1, 302, 17], [1, 96, 38], [1, 201, 132], ]; const labels = [ [0], [1], [0], [0], [1], [1], [1], [0], [1], ]; Other function definitions for completion function sum(a, b) { return a.reduce((acc, val, i) => acc + val * b[i], 0); } function sig(z) { return 1 / (1 + Math.exp(-z)); } Edit What the visualization means: Random points are created. If the y value is below some arbitrary value, that point is set as class 1 (pink). If the y value is above the threshold, that point is assigned as class 0 (blue). Those points are the training set. The input is the [x, y] coordinates for each point. The class for each point is set as the target labels. The algorithm is trained over this set. After several iterations of gradient descent, I use the model to classify each pixel in that canvas. If the classification is >= 0.5, I color that pixel yellow. Else, the pixel is colored red. The expectation is that the background will be all yellow on the upper half of the image, meaning that every one of those pixels was classified as type '0'.
