[site]: stackoverflow
[post_id]: 1147783
[parent_id]: 1018195
[tags]: 
Your code has two problems. One was identified and answered, but the other wasn't. The first was that your selector was missing the name of its parameter. However, even when you fix that, the line will still raise an exception, assuming your revised method signature still includes more than one argument. Let's say your revised method is declared as: -(void)myTestWithString:(NSString *)sourceString comparedTo:(NSString *)testString ; Creating selectors for methods that take multiple arguments is perfectly valid (e.g. @selector(myTestWithString:comparedTo:) ). However, the performSelector method only allows you to pass one value to myTest, which unfortunately has more than one parameter. It will error out and tell you that you didn't supply enough values. You could always redefine your method to take a collection as it's only parameter: -(void)myTestWithObjects:(NSDictionary *)testObjects ; However, there is a more elegant solution (that doesn't require refactoring). The answer is to use NSInvocation, along with its setArgument:atIndex: and invoke methods. I've written up an article, including a code example , if you want more details. The focus is on threading, but the basics still apply. Good luck!
