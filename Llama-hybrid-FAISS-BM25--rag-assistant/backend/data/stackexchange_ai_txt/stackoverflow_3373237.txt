[site]: stackoverflow
[post_id]: 3373237
[parent_id]: 3372981
[tags]: 
Yes a Collection would still be able to hold any descendant of TCollectionItem and to invoke methods on it. BUT, it wouldn't be able to instantiate a new instance of any descendant of a TCollectionItem. Calling TCollectionItem.Create constructs an instance of TCollectionItem, whereas private FItemClass: TCollectionItemClass; ... function AddItem: TCollectionItem; begin Result := FItemClass.Create; end; would construct an instance of whatever class of TCollectionItem descendant is held in FItemClass. I haven't done much with generic containers, but I think that given a choice, I would opt for the generic container. But in either case I'd still have to use a metaclass if I wanted to have the list instantiate and do whatever else needs to be done when an item is added in the container and I do not know the exact class beforehand. For example an observable TObjectList descendant (or generic container) could have something like: function AddItem(aClass: TItemClass): TItem; begin Result := Add(aClass.Create); FObservers.Notify(Result, cnNew); ... end; I guess in short the advantage/benefit of metaclasses is any method/class having only knowledge of type TMyThing = class(TObject) end; TMyThingClass = class of TMyThing; is able to construct instances of any descendant of TMyThing whereever they may have been declared.
