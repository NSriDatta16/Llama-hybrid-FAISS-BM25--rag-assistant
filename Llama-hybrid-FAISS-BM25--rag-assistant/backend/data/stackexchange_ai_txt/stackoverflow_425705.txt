[site]: stackoverflow
[post_id]: 425705
[parent_id]: 425655
[tags]: 
You can't, because C# 3.0 does not support variance of this kind. In C# 4.0, you should be able to. Using another example, say you had a List , and could assign it to a List : List parentList = List (); List childList = parentList; The problem is that the internal storage for parentList is for ParentInterface types. If you derived another interface from ChildInterface : public interface ParentInterface2 : ChildInterface {} And then tried to add it to childList like so: childList.Add(new ParentInterface2Implementation()); You would get an exception, since childList is really a List and can only store implementations of ParentInterface , which ParentInterface2 is not.
