[site]: stackoverflow
[post_id]: 3177760
[parent_id]: 
[tags]: 
Better way to implement filtered enumerator on TList

Using Delphi 2010, let's say I've got a class declared like this: TMyList = TList For this list Delphi kindly provides us with an enumerator, so we can write this: var L:TMyList; E:TMyObject; begin for E in L do ; end; The trouble is, I'd like to write this: var L:TMyList; E:TMyObject; begin for E in L.GetEnumerator('123') do ; end; That is, I want the ability to provide multiple enumerators for the same list, using some criteria. Unfortunately the implementation of for X in Z requires the presence of a function Z.GetEnumerator , with no parameters, that returns the given enumerator! To circumvent this problem I'm defining an interface that implements the "GetEnumerator" function, then I implement a class that implements the interface and finally I write a function on TMyList that returns the interface! And I'm returning an interface because I don't want to be bothered with manually freeing the very simple class... Any way, this requires a LOT of typing. Here's how this would look like: TMyList = class(TList ) protected // Simple enumerator; Gets access to the "root" list TSimpleEnumerator = class protected public constructor Create(aList:TList ; FilterValue:Integer); function MoveNext:Boolean; // This is where filtering happens property Current:TTipElement; end; // Interface that will create the TSimpleEnumerator. Want this // to be an interface so it will free itself. ISimpleEnumeratorFactory = interface function GetEnumerator:TSimpleEnumerator; end; // Class that implements the ISimpleEnumeratorFactory TSimpleEnumeratorFactory = class(TInterfacedObject, ISimpleEnumeratorFactory) function GetEnumerator:TSimpleEnumerator; end; public function FilteredEnum(X:Integer):ISimpleEnumeratorFactory; end; Using this I can finally write: var L:TMyList; E:TMyObject; begin for E in L.FilteredEnum(7) do ; end; Do you know a better way of doing this? Maybe Delphi does support a way of calling GetEnumerator with a parameter directly? Later Edit: I decided to use Robert Love's idea of implementing the enumerator using anonymous methods and using gabr's "record" factory to save yet an other class. This allows me to create a brand new enumerator, complete with code, using just a few lines of code in a function, no new class declaration required. Here's how my generic enumerator is declared, in a library unit: TEnumGenericMoveNext = reference to function: Boolean; TEnumGenericCurrent = reference to function: T; TEnumGenericAnonim = class protected FEnumGenericMoveNext:TEnumGenericMoveNext ; FEnumGenericCurrent:TEnumGenericCurrent ; function GetCurrent:T; public constructor Create(EnumGenericMoveNext:TEnumGenericMoveNext ; EnumGenericCurrent:TEnumGenericCurrent ); function MoveNext:Boolean; property Current:T read GetCurrent; end; TGenericAnonEnumFactory = record public FEnumGenericMoveNext:TEnumGenericMoveNext ; FEnumGenericCurrent:TEnumGenericCurrent ; constructor Create(EnumGenericMoveNext:TEnumGenericMoveNext ; EnumGenericCurrent:TEnumGenericCurrent ); function GetEnumerator:TEnumGenericAnonim ; end; And here's a way to use it. On any class I can add a function like this (and I'm intentionally creating an enumerator that doesn't use a List to show the power of this concept): type Form1 = class(TForm) protected function Numbers(From, To:Integer):TGenericAnonEnumFactory ; end; // This is all that's needed to implement an enumerator! function Form1.Numbers(From, To:Integer):TGenericAnonEnumFactory ; var Current:Integer; begin Current := From - 1; Result := TGenericAnonEnumFactory .Create( // This is the MoveNext implementation function :Boolean begin Inc(Current); Result := Current And here's how I'd use this new enumerator: procedure Form1.Button1Click(Sender: TObject); var N:Integer; begin for N in Numbers(3,10) do Memo1.Lines.Add(IntToStr(N)); end;
