[site]: stackoverflow
[post_id]: 2214321
[parent_id]: 2214154
[tags]: 
Design patterns express ideas in a general sense and not a specific class hierarchy that should be used to implement the pattern. In C#, you wouldn't implement the idea using classes and interfaces (as for example in Java), because it provides a more straightforward solution. You can use events and delegates instead. Here is a nice article that you may want to check out: Observer pattern in C# = Events + delegates Note that observer isn't the only pattern that can be encoded far more elegantly in C#. For example the Strategy pattern can be implemented using (single-line) lambda expression in C#: Strategy Pattern: Today, Tomorrow, and C# 3.0 That said, I'm quite sceptical about design patterns in many ways, but they may be useful as a reference. However they shouldn't be used blindly. Some authors maybe think that following the pattern strictly is the only way to write quality "enterprise" software, but that's not the case! EDIT Here is a succinct version of your Ruby code. I didn't read the C# version, because it is too complex (and I'd even say obfuscated): class Employee { public Employee(string name, string address, int salary) { Name = name; Address = address; this.salary = salary; } private int salary; public event Action SalaryChanged; public string Name { get; set; } public string Address { get; set; } public int Salary { get { return salary; } set { salary = value; if (SalaryChanged != null) SalaryChanged(this); } } var fred = new Employee(...); fred.SalaryChanged += (changed_employee) => Console.WriteLine("Send {0} a new tax bill!", changed_employee.Name); This is a perfectly fine use of events & delegates. C# 3.0 lambda functions make your example even simpler than in Ruby :-).
