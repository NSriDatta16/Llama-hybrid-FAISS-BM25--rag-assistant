[site]: stackoverflow
[post_id]: 4851916
[parent_id]: 
[tags]: 
Accept Interface into Collection (Covariance) troubles with nHibernate

I am using Fluent nHibernate for my persistence layer in an ASP.NET MVC application, and I have come across a bit of a quandry. I have a situation where I need to use an abstraction to store objects into a collection, in this situation, an interface is the most logical choice if you are looking at a pure C# perspective. Basically, an object ( Item ) can have Requirements . A requirement can be many things. In a native C# situation, I would merely accomplish this with the following code. interface IRequirement { // methods and properties neccessary for evaluation } class Item { virtual int Id { get; set; } virtual IList Requirements { get; set; } } A crude example. This works fine in native C# - however because the objects have to be stored in a database, it becomes a bit more complicated than that. Each object that implements IRequirement could be a completely different kind of object. Since nHibernate (or any other ORM that I have discovered) cannot really understand how to serialize an interface , I cannot think of, for the life of me, how to approach this scenario. I mean, I understand the problem. This makes no sense to the database/orm. I understand completely why, too. class SomeKindOfObject { virtual int Id { get; set; } // ... some other methods relative to this base type } class OneRequirement : SomeKindOfObject, IRequirement { virtual string Name { get; set; } // some more methods and properties } class AnotherKindOfObject { virtual int Id { get; set; } // ... more methods and properties, different from SomeKindOfObject } class AnotherRequirement : AnotherKindOfObject, IRequirement { // yet more methods and properties relative to AnotherKindOfObject's intentive hierarchy } class OneRequirementMap : ClassMap { // etc Table("OneRequirement"); } class AnotherRequirementMap : ClassMap { // Table("OtherRequirements"); } class ItemMap : ClassMap { // ... Now we have a problem. Map( x => x.Requirements ) // does not compute... // additional mapping } So, does anyone have any ideas? I cannot seem to use generics, either, so making a basic Requirement type seems out. I mean the code works and runs, but the ORM cannot grasp it. I realize what I am asking here is probably impossible, but all I can do is ask. I would also like to add, I do not have much experience with nHibernate , only Fluent nHibernate , but I have been made aware that both communities are very good and so I am tagging this as both. But my mapping at present is 100% 'fluent'. Edit I actually discovered Programming to interfaces while mapping with Fluent NHibernate that touches on this a bit, but I'm still not sure it is applicable to my scenario. Any help is appreciated. UPDATE (02/02/2011) I'm adding this update in response to some of the answers posted, as my results are ... a little awkward. Taking the advice, and doing more research, I've designed a basic interface. interface IRequirement { // ... Same as it always was } and now I establish my class mapping.. class IRequirementMap : ClassMap { public IRequirementMap() { Id( x => x.Id ); UseUnionSubclassForInheritanceMapping(); Table("Requirements"); } } And then I map something that implements it. This is where it gets very freaky. class ObjectThatImplementsRequirementMap : ClassMap { ObjectThatImplementsRequirementMap() { Id(x => x.Id); // Yes, I am base-class mapping it. // other properties Table("ObjectImplementingRequirement"); } } class AnotherObjectThatHasRequirementMap : ClassMap { AnotherObjectThatHasRequirementMap () { Id(x => x.Id); // Yes, I am base-class mapping it. // other properties Table("AnotheObjectImplementingRequirement"); } } This is not what people have suggested, but it was my first approach. Though I did it because I got some very freaky results. Results that really make no sense to me. It Actually Works... Sort Of Running the following code yields unanticipated results. // setup ISession // setup Transaction var requirements = new { new ObjectThatImplementsRequirement { // properties, etc.. }, new AnotherObjectThatHasRequirement { // other properties. } } // add to session. // commit transaction. // close writing block. // setup new session // setup new transaction var requireables = session.Query (); foreach(var requireable in requireables) Console.WriteLine( requireable.Id ); Now things get freaky. I get the results... 1 1 This makes no sense to me. It shouldn't work. I can even query the individual properties of each object, and they have retained their type. Even if I run the insertion, close the application, then run the retrieval (so as to avoid the possibility of caching), they still have the right types. But the following does not work. class SomethingThatHasRequireables { // ... public virtual IList Requirements { get; set; } } Trying to add to that collection fails (as I expect it to). Here is why I am confused. If I can add to the generic IList in my session, why not in an object? How is nHibernate understanding the difference between two entities with the same Id, if they are both mapped as the same kind of object, in one scenario, and not the other? Can someone explain to me what in the world is going on here? The suggested approach is to use SubclassMap , however the problem with that is the number of identities, and the size of the table. I am concerned about scalability and performance if multiple objects (up to about 8) are referencing identities from one table. Can someone give me some insight on this one specifically?
