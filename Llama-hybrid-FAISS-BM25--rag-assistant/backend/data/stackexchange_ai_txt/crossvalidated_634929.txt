[site]: crossvalidated
[post_id]: 634929
[parent_id]: 
[tags]: 
How do I approximate a timeseries with a sum of sin and cos functions?

I have a time series and I am trying to approximate it using an equation of the type: y = A + B*sin(2*pi*x/n) + C*cos(2*pi*x/m) + D*sin(2*pi*x/q) + ... The questions is how to find the parameters A, B, C, D, n, m, q, etc... Finding these values manually is obviously a very cumbersome process. I thought this would be a relatively simple problem for FFT, but I am getting nowhere (never done it before!). My code (in R) is this: value.ft with the following data.frame ( out.df ) as input: structure(list(out.df.SEC = c(0, 300, 600, 900, 3000, 3300, 3600, 3900, 4200, 4500, 6600, 6900, 7200, 7500, 7800, 8100, 10200, 10500, 10800, 11100, 11400, 13500, 13800, 14100, 14400, 14700, 15000, 17100, 17400, 17700, 18000, 18300, 18600, 20700, 21000, 21300, 21600, 21900, 22200, 24000, 24300, 24600, 24900, 25200, 25500, 27600, 27900, 28200, 28500, 28800, 29100, 31200, 31500, 31800, 32100, 32400, 32700, 34500, 34800, 35100, 35400, 35700, 36000, 38100, 38400, 38700, 39000, 39300, 39600, 41700, 42000, 42300, 42600, 42900, 43200, 45300, 45600, 45900, 46200, 46500, 48600, 48900, 49200, 49500, 49800, 50100, 52200, 52500, 52800, 53100, 53400, 53700, 55800, 56100, 56400, 56700, 57000, 59100, 59400, 59700, 60000, 60300, 60600, 62700, 63000, 63300, 63600, 63900, 64200, 66300, 66600, 66900, 67200, 67500, 69600, 69900, 70200, 70500, 70800, 71100, 73200, 73500, 73800, 74100, 74400, 74700, 76800, 77100, 77400, 77700, 78000, 78300, 80100, 80400, 80700, 81000, 81300, 81600), out.df.VALUE = c(4.858, 4.938, 4.724, 4.45, 3.70666666666667, 3.9, 3.83, 3.784, 3.704, 3.6775, 3.4375, 3.368, 3.394, 3.552, 3.728, 3.65, 3.46, 3.444, 3.392, 3.378, 3.444, 3.34, 3.328, 3.246, 3.192, 3.212, 3.23, 3.6475, 3.484, 3.418, 3.556, 3.778, 3.80666666666667, 4.278, 4.428, 4.62, 4.886, 4.872, 4.99, 6.7, 6.132, 5.318, 4.722, 4.556, 4.32, 4.4125, 4.442, 4.376, 4.43, 4.55, 4.58, 4.114, 4.026, 4.11, 3.994, 3.97, 4.13, 3.98, 4.006, 3.918, 3.75, 3.734, 3.652, 3.81, 3.814, 3.816, 3.674, 3.592, 3.78, 3.608, 3.446, 3.474, 3.564, 3.252, 3.17, 3.1, 3.044, 2.818, 2.868, 2.564, 2.65, 2.732, 2.76, 2.646, 2.608, 2.6075, 3.0975, 2.794, 2.962, 2.848, 2.276, 2.15, 2.326, 2.19, 2.396, 2.072, 2.758, 2.73666666666667, 2.66, 2.726, 2.556, 2.61, 2.964, 3.125, 3.014, 2.966, 2.794, 2.95, 2.91666666666667, 3.054, 3.148, 3.068, 2.97, 3.08, 2.9, 2.88, 2.904, 2.976, 3.148, 3.078, 3, 2.888, 2.914, 2.774, 2.708, 2.59666666666667, 3.008, 2.976, 3.152, 3.102, 2.954, 2.96, 2.895, 2.854, 2.832, 2.908, 2.886, 3.026)), class = "data.frame", row.names = c(NA, -138L)) The result looks like this, and I think it is not nearly as good as it could be: Changing the variable value.terms does not improve the outcome, and tend to result in overfitting. Is FFT the right approach here, or am I overcomplicating things? EDIT: just to clarify, the objective is not an exact reproduction of the data but an approximation, whose equation can be used for other calculations. In the example, if the peak around 30k seconds and the two troughs around 15k and 50k seconds were just a bit more pronounced it'd be enough.
