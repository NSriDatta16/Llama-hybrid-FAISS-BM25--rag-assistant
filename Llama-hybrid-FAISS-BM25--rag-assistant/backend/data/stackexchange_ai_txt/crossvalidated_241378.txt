[site]: crossvalidated
[post_id]: 241378
[parent_id]: 240919
[tags]: 
Ok, it seems that max and min are not among the "elementary operations" which have syntactic sugar support when building deterministic variables in pyMC. A method to generate a prior with the expected samples by using python decorators to define a new deterministic operation is written below. It might be safer to have some kind of warning when a user attempts to carry out an unsupported operation on pyMC objects, rather than just ignoring the operation? #Simplified hierarchical model import pymc as mc import numpy as np # Hyperparameters # No sample at any level of hierarchy should be outside this range K_min,K_max=0.0,0.5 priors={} K=mc.Uniform('K',K_min,K_max) K_delta=mc.Uniform('K_delta',0,(K_max-K_min)/2) priors["K"]=K priors["K_delta"]=K_delta @mc.deterministic(plot=False) def cliplowK(K=K,K_min=K_min,K_delta=K_delta): return(np.maximum(K_min,K-K_delta)) @mc.deterministic(plot=False) def cliphighK(K=K,K_min=K_min,K_delta=K_delta): return(np.minimum(K_max,K+K_delta)) grplabs=["a","b"] for grplab in grplabs: priors["K_{}".format(grplab)]=mc.Uniform("K_{}".format(grplab),cliplowK,cliphighK) M=mc.MCMC(priors) K_vals=[] K_a_vals=[] K_b_vals=[] for i in xrange(100000): M.draw_from_prior() K_vals.append(float(M.K.get_value())) K_a_vals.append(float(M.K_a.get_value())) K_b_vals.append(float(M.K_b.get_value())) assert min(K_vals)>=0 # This passes assert min(K_a_vals)>=0 # This passes assert min(K_b_vals)>=0 # This passes
