[site]: stackoverflow
[post_id]: 3442100
[parent_id]: 3442090
[tags]: 
[Ljava.lang.Object; is the name for Object[].class , the java.lang.Class representing the class of array of Object . The naming scheme is documented in Class.getName() : If this class object represents a reference type that is not an array type then the binary name of the class is returned, as specified by the Java Language Specification ( ยง13.1 ). If this class object represents a primitive type or void , then the name returned is the Java language keyword corresponding to the primitive type or void . If this class object represents a class of arrays, then the internal form of the name consists of the name of the element type preceded by one or more '[' characters representing the depth of the array nesting. The encoding of element type names is as follows: Element Type Encoding boolean Z byte B char C double D float F int I long J short S class or interface Lclassname; Yours is the last on that list. Here are some examples: // xxxxx varies System.out.println(new int[0][0][7]); // [[[I@xxxxx System.out.println(new String[4][2]); // [[Ljava.lang.String;@xxxxx System.out.println(new boolean[256]); // [Z@xxxxx The reason why the toString() method on arrays returns String in this format is because arrays do not @Override the method inherited from Object , which is specified as follows: The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of: getClass().getName() + '@' + Integer.toHexString(hashCode()) Note : you can not rely on the toString() of any arbitrary object to follow the above specification, since they can (and usually do) @Override it to return something else. The more reliable way of inspecting the type of an arbitrary object is to invoke getClass() on it (a final method inherited from Object ) and then reflecting on the returned Class object. Ideally, though, the API should've been designed such that reflection is not necessary (see Effective Java 2nd Edition, Item 53: Prefer interfaces to reflection ). On a more "useful" toString for arrays java.util.Arrays provides toString overloads for primitive arrays and Object[] . There is also deepToString that you may want to use for nested arrays. Here are some examples: int[] nums = { 1, 2, 3 }; System.out.println(nums); // [I@xxxxx System.out.println(Arrays.toString(nums)); // [1, 2, 3] int[][] table = { { 1, }, { 2, 3, }, { 4, 5, 6, }, }; System.out.println(Arrays.toString(table)); // [[I@xxxxx, [I@yyyyy, [I@zzzzz] System.out.println(Arrays.deepToString(table)); // [[1], [2, 3], [4, 5, 6]] There are also Arrays.equals and Arrays.deepEquals that perform array equality comparison by their elements, among many other array-related utility methods. Related questions Java Arrays.equals() returns false for two dimensional arrays. -- in-depth coverage
