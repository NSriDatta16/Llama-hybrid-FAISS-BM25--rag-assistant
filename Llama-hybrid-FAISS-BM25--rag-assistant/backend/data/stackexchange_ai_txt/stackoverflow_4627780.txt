[site]: stackoverflow
[post_id]: 4627780
[parent_id]: 4521832
[tags]: 
Couriosity just sparkles out of your questions ;) - try not to get lost in doing/thinking too many things at a time. So to answer them questions .. 1. Is there a way to prevent source conflicts in a social manner? If so, what is the best way to communicate about conflicting changes? No mainstream Source Control Software that I am aware of brings a well implemented notification about possibly conflicting work before such work gets integrated into one another (merged). Apart from DRY and separation of concerns, as Corbin March mentioned, I think that "update daily", "commit early, commit often" and "branch late" (see below) are bread-and-butter practices. Commiting early has its limits though. Syntax-Error Free and depending on your bugtracker / task-organizing system, only complete work-artifacts should get committed. There really is not much social skill required to ask for help when you encounter a source conflict that you can not solve yourself, IMHO. 2. I’m planning to install a CMS into that server as well. So my teammates can write or communicate that they have branches and the like, but I don’t know if there other tools to track the historic health and bugs of our project. This sounds like a pretty "distributed" approach. Not as in location but as in responsibility. You are creating software products and do some sort of release occasionaly do you? Therefore responsibility should increase and focus the further "downstream" it gets. The only branches the whole team should be familar with are the release branches for fixing things (no features there) and your mainline (trunk). All other things, feature-branches, integration branches, "backup" branches, private branches etc. are to be managed by those requesting or enforcing them. Why should you or colleague "A" care that colleague "B" branched the mainline to develop his experimental feature in peace? Colleague "B" by developing something groundbreaking, has the responsibility for his branch and to keep it COMPATIBLE with the mainline. Either constantly by merging changes from the mainline to his branch or before reintegration of his new code. Research integration branches if you want to know more. As for the toolset .. Any bugtracker that is well integratable within SVN (Jira, trac, mantis, redmine ..) should do the job. But I do not understand how this part of the question relates to your conflict problems. 3. Even though my company practice the flat management approach, how can a rookie like me could convince or enforce social communication to senior programmers without breaking the invisible “senior” hierarchy? I think you overestimate the amount of communication that is required in a well oiled workflow. What you mention indicates that you company lacks a workflow where you fight conflicts at the root (see 1. and 2.) which in your case makes more communication necessary, possibly creating unnecessarily high overhead. Having a CMS or some kind of "I work here" flagging-system might still be worthwhile to persue. You indicated that some senior developers do not like to talk or socialize so much even in conflict cases where better they should. Don't let them get away with this by doing merges for them. Merges should be done by branch-owners. When conflicts aris, at least one of the conflicting sides has to decide upon the changes. Ideally both sides sit down on the diffs together but not a third party initially uninvolved with the source in question. Failure in conflict solving (selecting the wrong changes) might result in build breakage or, even worse, undetected bugs. People need to be aware. Acting as mediator is not easy if senior developer "A" (merging mainline changes into his branch) curses about conflicts but does not talk to senior developer "B" whose mainline changes are in conflict with his. If it is not like crossing a line for you, try to talk to developer B and convince him to approach A to get the conflict resolved faster and less error-prone. But again in the end it is developer "A"'s responsibility, not yours. You seem to give an example already to your co-workers. If that is not enough, try to carefully point out that not enough communication was the reason for a broken build when it happens. Maybe talk to one senior in private about your thoughts, be open but not accusive. A "we could to better" sounds nicer than "You guys are doing it wrong". And for you as a younger professional, sentences like "I would feel better about my code if you tell me when it conflicts with yours" might be more appropriate than "You should ask for a second pair of eyes from the right person when you get conflicts", even though the later is more straightforward. If all this does not help, you might consider talking to your boss or team leader about the barriers you encounter. If he is not a fool he/she will listen. For branching and tagging 1. I don’t want other teams to do branching to add a “Hello, World!” code into the program. I want to treat branching as something out of ordinary. Can anyone give me a rule of thumb on when to add create branch? When to merge? For Merging see Question 4. below. For Branching: You are perfectly right with trying to have as few branches as necessary. Branching comes at a price. Complexity, merging overhead etc. I tend to stick to "branch on incompatible policy". What policy you ask? Each of your main branches should have a set of documented rules attached to them. Examples: tag-2.0.4 no commit allowed release-2 only fixes for existing features allowed checkins should have release-quality trunk must compile/validate Extending developed API allowed renaming and deleting API prohibited only complete bugtracker-issues receives merges from release branches feature-apirefactoring may alter the developed API and break compatibility pulling merges from trunk is feature-developers task You see there is 3 fictive branches and one tag. The "feature-apirefactoring" is an example for a correctly applied "branch on incompatible policy". Branches should be used to mitigate risks and increase efficiency by splitting different kinds of development activity. The branch policies individually define what development and risk potentials are acceptable. Want your trunk to be more stable? Define a new policy "Do not introduce W3C validator warnings". If groundbreaking development work has to break this rule for the sake of efficiency or to provide a fast proof-of-concept (we hack away first and cleanup later) it is a good candidate for its own branch. Whenever you or a co-worker feels the urge to break a rule because it would be more simple or safer to NOT comply to a given policy, you are on a good way to discussing a branch-creation. 2. In what case branching a branch is a good idea? answered above I think :). Some examples I encountered: Branch stable branch from trunk when release gets prepared (no new features) Branch integration branch from feature-branch when integration is too complex and time consuming branch a "special edition" release branch from an allready stable release that has some exclusive features or certain possibly unstable differences for a special customer. branch a translation-branch from your trunk that gets only wording changes and therefore can not break There is dozen more. The more fine-grained your policies, the more exotic your branching can get. 3. For tagging, my understanding is that tag symbolize a static point of the program ( ie : v1.0, v2.5) is that correct? Yes. For subversion it can be described as an alias. "/tags/1.7.2" could be the state of the project as it was at revision 30932. You can note down the revision number when a certain release was ready and compare your newer sources to it or create a checkout of this older state. Or you can use the easier to remember tag-name. A tag in subversion also is nothing but a branch that does not receive any commits. 4. If I create a branch and start writing my changes, should my team-mates start syncing from my branch? Or should they still develop in the trunk? Or should they create another branch for themselves? Short answer: When ever you are uncertain, use the trunk and do not merge (sync, push, pull) at all. Long answer: In an ideal world there would be no need for branches as all developers get supplied with all changes the team checks in, instantly when it happens. In an ideal world these changes would not conflict with any developers own uncommitted work. Whatever a developer checks in inside my ideal world is also completely correct, free of flaws and glitches. Alas, a programmers world is not perfect. Therefore you create branches to shield yourself from changes your co-workers do or you isolate your changes to not stain a clean mainline, sometimes both. The direction of the flow of change (Your co-workers pull from you or you pull from your co-workers) depends on the riskyness expected in a branch. How much risk would it be to "pull" (merge) changes that get checked in to a release-branch? Looking at the policies defined above it should be bugfixes only. The risk seems low. For most release-branch scenarios merging from them into the turnk is absolutely necessary as you would have to refix the bugs by hand before the next release-branch gets created from your trunk. How much risk of breaking your own precious work, or having to alter your own code, would lie in merging changes from feature-apirefactoring into your checkout of the trunk? You could develop new functionality, enhancing an api-call your co-worker owning the feature branch decided to replace with a completly new implementation. This might kill the mood. The Tofu Scale I think it was the smart people from perforce that first mentioned the "tofu" scale. (you could google it or read these slides http://www.perforce.com/perforce/conferences/us/2005/presentations/Wingerd.pdf ). Additionally to a policy per branch, you estimate their "firmness" and via that their position on the tofu scale. A feature branch is "soft" as it is in constant flow, not well tested and mostly far away from any paying customer's eyes. It is therefore also more able to absorb changes. If things break you want them to break in "softer" branches. Your trunk would be "medium" as it is not release ready but better tested than some remote feature branch. (let alone because more developers check out the trunk than feature branches). It might distract developers if huge compatibility-breaking changes appear in the trunk without proper integration, but normal sized checkins can soak in quite well. Release branches are among the "firmest" branches as they are well established, tested and sometimes only hours away from productive usage. If you break this "slice of tofu" it is a bigger pain to stitch together. On the other hand you have a better feeling about what you are delivering in this branches and higher confidence (if not unit-tested proof) that it works well. You should order the branches by their position on the tofu scale. Soft to the bottom, firm at the top. tags (very firm) release-2 (firm) trunk (medium) feature-apirefactoring (soft) The best practice saying is "Merge down, Copy up" . Even better "Merge down, Copy up at stable state " Merge down: All commits that went in release-2, you should merge into the trunk as often as possible. (Bugfix-committer should do this) All commits into the trunk, including merged down fixes from release branches, you should merge into your feature-branches as often as possible. (Feature-Owner should do this) "Copy" up: When work in a feature-branch is complete "reintegrate" it. Use the SVN --reintegrate merge or do a last merge down into the feature branch and then copy all relevant files. --reintegrate merge is highly recommended. When you decide it is time to stabilize your trunk and target a new release soon, you branch your trunk into a new "release-3" for example. In SVN branching is copying and vice versa. When your release is bugfixed, tested and working well enough you again copy up into a new release tag Last but not least read up this best practice document. Again by perforce guys ;) http://www.perforce.com/perforce/papers/bestpractices.html Search stackoverflow or have a look at my profile for more SVN-releated Q & A. Oh and knowing how you succeeded in your rightful ambitions would be nice. Have a nice weekend C
