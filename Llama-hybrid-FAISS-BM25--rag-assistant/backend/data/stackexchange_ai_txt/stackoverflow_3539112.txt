[site]: stackoverflow
[post_id]: 3539112
[parent_id]: 3538477
[tags]: 
Coming from ASM, C, then C++, and finally landing (forced) into the Java territory, I thought I may provide an opinion about the subject. First, with all due respect to the Java community, the business experience shows that while C/C++ programmers can get used to the Java principles and programming (it may not be that easy), the opposite happens more rarely. In other terms, a C++ programmer will have to learn and cope with tons of Java rules (Frameworks...) but she will eventually (and usually) be able to produce a long term working code by injecting a lot of her system experience into the process. A Java programmer going to C, used to more theoretical principles, and strict structure rules may feel insecure as she has to decide many things, like program organization and structure feel surprised with the pointers, and memory management: allocation and freeing, which has to be thought carefully - discovering the world of memory leaks feel discouraged, as the bugs won't appear black on white in a console dictated by the JVM through 200 lines of stack trace, but may happen at a deeper / system level, maybe caught thanks to an IDE in front of which the Java programmer will contemplate some assembly code for the 1st time in her life feel perplex as to what algorithm and how to implement it, the one that was integrated into Java that she never had to worry about... So, now, my task is to help you to feel secure, confident, and motivated before learning C/C++! My advice is to start with C, because C by itself owns all the very concepts you never had to face with Java as a Java programmer you already have a classes 'approach', and starting with C++, you may be tempted to stick to the Java OO principles C principles are limited to a few. C looks like the very last human thing before entering the dark world of assembly language. What I would emphasize during the C study is, for instance Pointers Java uses pointers of course, but hides its access while actually passing classes to methods as pointers. In C, you will have to learn the difference between by value and by reference . Also, the more subtle difference between char x[3] and char *x = "ab" . And how convenient pointers are to go through an array etc..., you know *++x or *x++ . A lot has been said about pointers, my advice would be always keep control, i.e. don't put too many indirections when not necessary don't typedef pointers, like typedef int *pointerToInt ; it seems easier at first ( pointerToInt pi instead of int *pi ) after a few levels, I prefer to count the stars than the 'pointerTo' [some big cies do that]. Except maybe the pointers to functions, unreadable anyway. Memory When you need memory, you allocate it, and when you don't need it anymore, you free it. Easy. The thing is to allocate the right amount, and not to free it twice... Have to get used to that. And get used to the heap, the stack... And When your program runs and address NULL (0) you may have a visible exception. Maybe not. Data structure So you want to use a convenient HashMap? Sure, after you developed it. Or there are some libraries you can link that do that kind of thing, just chose the right one. To be fair, when programming in C, you [have to] think different, and may find a more appropriate algorithm than a map for a given problem. All in all, you will feel disoriented at first, but eventually (unless you have nightmares) you will find before you a lot of room for fun and pleasure. C allows a person to program with complete freedom: C goes according to your ideas, not the opposite.
