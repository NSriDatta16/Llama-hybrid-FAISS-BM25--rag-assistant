[site]: stackoverflow
[post_id]: 3791757
[parent_id]: 3790012
[tags]: 
We do peak detection (and valley detection) using running medians and median absolute deviation. You can specify how much deviation from the running median means a peak. In a next step, we use a binomial model to check which regions contain more "extreme" values than can be expected. This model (basically a score test) results in "peak regions" instead of single peaks. Turning it around to get "valley regions" is trivial. The running median is calculated using the function weightedMedian from the package aroma.light. We use the embed() function to make a list of "windows" and apply a kernel function on it. The application of the weighted median : center Here tmp is the temporary data vector and wdw the window size (has to be uneven). tmp is constructed by adding (wdw-1)/2 NA values at every side of the data vector. the weights are constructed using a customized function. For the mad we use the same procedure, but then on diff(data) instead of the data itself. Running Sample code : require(aroma.light) # make.weights : function to make weights on basis of a normal distribution # n is window size !!!!!! make.weights The sample code above is developed to find regions with big fluctuations rather than valleys. I adapted it a bit, but it's not optimal. On top of that, for series larger than 20000 values you need a whole lot of memory, I can't run it on my computer any more. Alternatively, you could work with an approximation of the numerical derivative and second derivative to define valleys. In your case, this might even work better. A pragmatic way of calculating the derivatives and the minima/maxima of the first derivative : #first derivative f.deriv
