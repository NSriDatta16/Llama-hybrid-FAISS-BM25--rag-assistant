[site]: stackoverflow
[post_id]: 898988
[parent_id]: 
[tags]: 
Avoiding stack overflow (with F# infinite sequences of sequences)

I have this "learning code" I wrote for the morris seq in f# that suffers from stack overflow that I don't know how to avoid. "morris" returns an infinite sequence of "see and say" sequences (i.e., {{1}, {1,1}, {2,1}, {1,2,1,1}, {1,1,1,2,2,1}, {3,1,2,2,1,1},...}). let printList l = Seq.iter (fun n -> printf "%i" n) l printfn "" let rec morris s = let next str = seq { let cnt = ref 1 // Stack overflow is below when enumerating for cur in [|0|] |> Seq.append str |> Seq.windowed 2 do if cur.[0] <> cur.[1] then yield!( [!cnt ; cur.[0]] ) cnt := 0 incr cnt } seq { yield s yield! morris (next s) // tail recursion, no stack overflow } // "main" // Print the nth iteration let _ = [1] |> morris |> Seq.nth 3125 |> printList You can pick off the nth iteration using Seq.nth but you can only get so far before you hit a stack overflow. The one bit of recursion I have is tail recursion and it in essence builds a linked set of enumerators. That's not where the problem is. It's when "enum" is called on the say the 4000th sequence. Note that's with F# 1.9.6.16, the previous version topped out above 14000). It's because the way the linked sequences are resolved. The sequences are lazy and so the "recursion" is lazy. That is, seq n calls seq n-1 which calls seq n-2 and so forth to get the first item (the very first # is the worst case). I understand that [|0|] |> Seq.append str |> Seq.windowed 2 , is making my problem worse and I could triple the # I could generate if I eliminated that. Practically speaking the code works well enough. The 3125th iteration of morris would be over 10^359 characters in length. The problem I'm really trying to solve is how to retain the lazy eval and have a no limit based on stack size for the iteration I can pick off. I'm looking for the proper F# idiom to make the limit based on memory size. Update Oct '10 After learning F# a bit better, a tiny bit of Haskell, thinking & investigating this problem for over year, I finally can answer my own question. But as always with difficult problems, the problem starts with it being the wrong question. The problem isn't sequences of sequences - it's really because of a recursively defined sequence. My functional programming skills are a little better now and so it's easier to see what's going on with the version below, which still gets a stackoverflow let next str = Seq.append str [0] |> Seq.pairwise |> Seq.scan (fun (n,_) (c,v) -> if (c = v) then (n+1,Seq.empty) else (1,Seq.ofList [n;c]) ) (1,Seq.empty) |> Seq.collect snd let morris = Seq.unfold(fun sq -> Some(sq,next sq)) That basicially creates a really long chain of Seq processing function calls to generate the sequnces. The Seq module that comes with F# is what can't follow the chain without using the stack. There's an optimization it uses for append and recursively defined sequences, but that optimization only works if the recursion is implementing an append. So this will work let rec ints n = seq { yield n; yield! ints (n+1) } printf "%A" (ints 0 |> Seq.nth 100000);; And this one will get a stackoverflow. let rec ints n = seq { yield n; yield! (ints (n+1)|> Seq.map id) } printf "%A" (ints 0 |> Seq.nth 100000);; To prove the F# libary was the issue, I wrote my own Seq module that implemented append, pairwise, scan and collect using continutions and now I can begin generating and printing out the 50,000 seq without a problem (it'll never finish since it's over 10^5697 digits long). Some additional notes: Continuations were the idiom I was looking for, but in this case, they had to go into the F# library, not my code. I learned about continuations in F# from Tomas Petricek's Real-World Functional Programming book. The lazy list answer that I accepted held the other idiom; lazy evaluation. In my rewritten library, I also had to leverage the lazy type to avoid stackoverflow. The lazy list version sorta of works by luck (maybe by design but that's beyond my current ability to determine) - the active-pattern matching it uses while it's constructing and iterating causes the lists to calculate values before the required recursion gets too deep, so it's lazy, but not so lazy it needs continuations to avoid stackoverflow. For example, by the time the 2nd sequence needs a digit from the 1st sequence, it's already been calculated. In other words, the LL version is not strictly JIT lazy for sequence generation, only list management.
