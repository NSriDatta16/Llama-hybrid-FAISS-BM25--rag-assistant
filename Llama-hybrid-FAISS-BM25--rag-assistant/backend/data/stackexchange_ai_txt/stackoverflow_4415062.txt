[site]: stackoverflow
[post_id]: 4415062
[parent_id]: 4414234
[tags]: 
If you take a look at the implementation of unittest.TestCase.run , you can see that all test results are collected in the result object (typically a unittest.TestResult instance) passed as argument. No result status is left in the unittest.TestCase object. So there isn't much you can do in the unittest.TestCase.tearDown method unless you mercilessly break the elegant decoupling of test cases and test results with something like this: import unittest class MyTest(unittest.TestCase): currentResult = None # Holds last result object passed to run method def setUp(self): pass def tearDown(self): ok = self.currentResult.wasSuccessful() errors = self.currentResult.errors failures = self.currentResult.failures print ' All tests passed so far!' if ok else \ ' %d errors and %d failures so far' % \ (len(errors), len(failures)) def run(self, result=None): self.currentResult = result # Remember result for use in tearDown unittest.TestCase.run(self, result) # call superclass run method def test_onePlusOneEqualsTwo(self): self.assertTrue(1 + 1 == 2) # Succeeds def test_onePlusOneEqualsThree(self): self.assertTrue(1 + 1 == 3) # Fails def test_onePlusNoneIsNone(self): self.assertTrue(1 + None is None) # Raises TypeError if __name__ == '__main__': unittest.main() This works for Python 2.6 - 3.3 (modified for new Python below ).
