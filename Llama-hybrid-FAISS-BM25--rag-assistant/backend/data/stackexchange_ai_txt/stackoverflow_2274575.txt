[site]: stackoverflow
[post_id]: 2274575
[parent_id]: 2274503
[tags]: 
for rec in inh: reads one line at a time -- not what you want for a binary file. Read 4 bytes at a time (with a while loop and inh.read(4) ) instead (or read everything into memory with a single .read() call, then unpack successive 4-byte slices). The second approach is simplest and most practical as long as the amount of data involved isn't huge: import struct with open('test.bin', 'rb') as inh: indata = inh.read() for i in range(0, len(data), 4): pos = struct.unpack('i', data[i:i+4]) print(pos) If you do fear potentially huge amounts of data (which would take more memory than you have available), a simple generator offers an elegant alternative: import struct def by4(f): rec = 'x' # placeholder for the `while` while rec: rec = f.read(4) if rec: yield rec with open('test.bin', 'rb') as inh: for rec in by4(inh): pos = struct.unpack('i', rec) print(pos) A key advantage to this second approach is that the by4 generator can easily be tweaked (while maintaining the specs: return a binary file's data 4 bytes at a time) to use a different implementation strategy for buffering, all the way to the first approach (read everything then parcel it out) which can be seen as "infinite buffering" and coded: def by4(f): data = inf.read() for i in range(0, len(data), 4): yield data[i:i+4] while leaving the "application logic" (what to do with that stream of 4-byte chunks) intact and independent of the I/O layer (which gets encapsulated within the generator).
