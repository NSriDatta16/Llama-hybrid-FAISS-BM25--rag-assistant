[site]: stackoverflow
[post_id]: 1729666
[parent_id]: 1729164
[tags]: 
This averages the appropriate pixels. w_ratio = src.w / dest.w h_ratio = src.h / dest.h dest[x,y] = AVG( src[x * w_ratio + xi, y * h_ratio + yi] ) where xi in range (0, w_ratio - 1), inc by 1 yi in range (0, h_ratio - 1), inc by 1 For boundary conditions do a separate loop (no if's in loop). Here's a more C like code: src and dest are bitmaps that: * property src[x,y] for pixel * property src.w for width * property src.h for height pixel has been defined so that adding p1 = p1 + p2 is same as p1.r = p1.r + p2.r p1.g = p1.g + p2.g ... division p1 = p1 / c p1.r = p1.r / c p1.g = p1.g / c evaluation with a constant 0 p1 = 0 p1.r = 0 p1.g = 0 ... for simplicity sake I won't consider the problem when pixel component integer overflows... float w_ratio = src.w / dest.w; float h_ratio = src.h / dest.h; int w_ratio_i = floor(w_ratio); int h_ratio_i = floor(h_ratio); wxh = w_ratio*h_ratio; for (y = 0; y Bresenham's line optimization
