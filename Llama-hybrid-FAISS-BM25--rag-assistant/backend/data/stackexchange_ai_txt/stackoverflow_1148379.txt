[site]: stackoverflow
[post_id]: 1148379
[parent_id]: 702343
[tags]: 
There's little performance difference between them. A data binding expression is parsed and compiles out to something like control.DataBinding += new EventHandler(ControlDataBinding); and also private void ControlDataBinding(object sender, EventArgs e) { control.Text = Eval("Field"); } In this case, the OnDataBinding method is not overridden. The base Control.OnDataBinding method is executed, which raises the DataBinding event, causing the above code to execute. When you override OnDataBinding, you're simply taking over before the base code is run, and get to set the Text property yourself (for example). I dislike giving out partial answers, but I'll do it this time because I think it's neat, and it saved me recently: I said that the data binding expression are parsed. In fact, all of the markup is parsed, code in C#, VB.NET or whatever language is generated, and this is them compiled into a class. When the page is requested, an instance of this class is created, and it begins its life. You can locate these generated code files on disk sorry, I don't remember where . The interesting thing about them is that they still work, as code. For instance, I recently had some fairly complex Infragistics grids set up, had all the formatting complete, and then found that I needed to be able to set the formatting at rumtime (to get the correct format into exported Excel files). In order to do this, I opened the source file (all grids were in a single user control) and was able to extract the configuration of each grid into a separate group of methods. I was able to clean them up with ReSharper, extract common code sequences into a base class, and was left with one static method to set up each grid. I was then able to call them both for the initial setup, and for the setup of the dummy grid used for Excel export.
