[site]: stackoverflow
[post_id]: 5056466
[parent_id]: 5056297
[tags]: 
There used to be a way to do this using the undocumented fact that while the list was being built its value was stored in a local variable named _[1].__self__ . However that quit working in Python 2.7 (maybe earlier, I wasn't paying close attention). You can do what you want in a single list comprehension if you set up an external data structure first. Since all your pseudo code seemed to be doing with this_list was checking it to see if each s was already in it -- i.e. a membership test -- I've changed it into a set named seen as an optimization (checking for membership in a list can be very slow if the list is large). Here's what I mean: raw_data = [c for c in 'abcdaebfc'] seen = set() def some_function(s): seen.add(s) return s print [ some_function(s) for s in raw_data if s not in seen ] # ['a', 'b', 'c', 'd', 'e', 'f'] If you don't have access to some_function , you could put a call to it in your own wrapper function that added its return value to the seen set before returning it. Even though it wouldn't be a list comprehension, I'd encapsulate the whole thing in a function to make reuse easier: def some_function(s): # do something with or to 's'... return s def add_unique(function, data): result = [] seen = set(result) # init to empty set for s in data: if s not in seen: t = function(s) result.append(t) seen.add(t) return result print add_unique(some_function, raw_data) # ['a', 'b', 'c', 'd', 'e', 'f'] In either case, I find it odd that the list being built in your pseudo code that you want to reference isn't comprised of a subset of raw_data values, but rather the result of calling some_function on each of them -- i.e. transformed data -- which naturally makes one wonder what some_function does such that its return value might match an existing raw_data item's value.
