[site]: stackoverflow
[post_id]: 115169
[parent_id]: 114804
[tags]: 
On Linux you use a PF_PACKET socket to read data from a raw device, such as an ethernet interface running in promiscuous mode: s = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) This will send copies of every packet received up to your socket. It is quite likely that you don't really want every packet, though. The kernel can perform a first level of filtering using BPF, the Berkeley Packet Filter . BPF is essentially a stack-based virtual machine: it handles a small set of instructions such as: ldh = load halfword (from packet) jeq = jump if equal ret = return with exit code BPF's exit code tells the kernel whether to copy the packet to the socket or not. It is possible to write relatively small BPF programs directly, using setsockopt(s, SOL_SOCKET, SO_ATTACH_FILTER, ). (WARNING: The kernel takes a struct sock_fprog, not a struct bpf_program, do not mix those up or your program will not work on some platforms). For anything reasonably complex, you really want to use libpcap. BPF is limited in what it can do, in particular in the number of instructions it can execute per packet. libpcap will take care of splitting a complex filter up into two pieces, with the kernel performing a first level of filtering and the more-capable user-space code dropping the packets it didn't actually want to see. libpcap also abstracts the kernel interface out of your application code. Linux and BSD use similar APIs, but Solaris requires DLPI and Windows uses something else.
