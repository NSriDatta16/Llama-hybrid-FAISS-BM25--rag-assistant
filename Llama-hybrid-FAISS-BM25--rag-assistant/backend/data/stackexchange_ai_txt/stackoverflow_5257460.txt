[site]: stackoverflow
[post_id]: 5257460
[parent_id]: 
[tags]: 
Draw a line on top of triangles

I created a new iPhone OpenGL Project in Xcode. I filled my background with triangles and gave them a texture, see below: CGImageRef spriteImage; CGContextRef spriteContext; GLubyte *spriteData; size_t width, height; // Sets up matrices and transforms for OpenGL ES glViewport(0, 0, backingWidth, backingHeight); glMatrixMode(GL_PROJECTION); glLoadIdentity(); //glRotatef(-90,0,0,1); glOrthof(-1.0f, 1.0f, -1.5f, 1.5f, -1.0f, 1.0f); glMatrixMode(GL_MODELVIEW); // Clears the view with black glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Sets up pointers and enables states needed for using vertex arrays and textures glVertexPointer(2, GL_FLOAT, 0, vertices); glEnableClientState(GL_VERTEX_ARRAY); //glColorPointer(4, GL_FLOAT, 0, triangleColors); //glColor4f(0.0f,1.0f,0.0f,1.0f); //glEnableClientState(GL_COLOR_ARRAY); glTexCoordPointer(2, GL_FLOAT, 0, spriteTexcoords); glEnableClientState(GL_TEXTURE_COORD_ARRAY); // Creates a Core Graphics image from an image file spriteImage = [UIImage imageNamed:@"Bild.png"].CGImage; // Get the width and height of the image width = CGImageGetWidth(spriteImage); height = CGImageGetHeight(spriteImage); // Texture dimensions must be a power of 2. If you write an application that allows users to supply an image, // you'll want to add code that checks the dimensions and takes appropriate action if they are not a power of 2. if(spriteImage) { // Allocated memory needed for the bitmap context spriteData = (GLubyte *) calloc(width * height * 4, sizeof(GLubyte)); // Uses the bitmap creation function provided by the Core Graphics framework. spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width * 4, CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast); // After you create the context, you can draw the sprite image to the context. CGContextDrawImage(spriteContext, CGRectMake(0.0, 0.0, (CGFloat)width, (CGFloat)height), spriteImage); // You don't need the context at this point, so you need to release it to avoid memory leaks. CGContextRelease(spriteContext); // Use OpenGL ES to generate a name for the texture. glGenTextures(1, &spriteTexture); // Bind the texture name. glBindTexture(GL_TEXTURE_2D, spriteTexture); // Set the texture parameters to use a minifying filter and a linear filer (weighted average) glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Specify a 2D texture image, providing the a pointer to the image data in memory glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, spriteData); // Release the image data free(spriteData); // Enable use of the texture glEnable(GL_TEXTURE_2D); // Set a blending function to use glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA); // Enable blending glEnable(GL_BLEND); I have got two questions, bc. I am not so familiar with OpenGL. I want to write a method, which I give two points as parameters and I want a Line between these two points to be drawn above my triangles (background). - (void) drawLineFromPoint1:(CGPoint)point1 toPoint2:(CGPoint)point2 { GLfloat triangle[] = { //Just example points 0.0f, 0.0f, 0.1f, 0.0f, 0.1f, 0.0f, 0.1f, 0.1f }; GLfloat triangleColors[] = { 0.5f, 0.5f, 0.5f, 1.0f }; //now draw the triangle } Something like that. Now I want to have a 2nd method, which erases this line (and not the background) My drawing method looks like this: - (void)drawView { // Make sure that you are drawing to the current context [EAGLContext setCurrentContext:context]; glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer); glClear(GL_COLOR_BUFFER_BIT); glDrawElements(GL_TRIANGLES, number_vertices, GL_UNSIGNED_SHORT, indices); glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer); [context presentRenderbuffer:GL_RENDERBUFFER_OES]; } Would be great if you can give e some hints/help, cheers
