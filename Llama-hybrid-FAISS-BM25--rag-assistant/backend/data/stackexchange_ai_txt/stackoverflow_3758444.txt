[site]: stackoverflow
[post_id]: 3758444
[parent_id]: 
[tags]: 
Understanding Memory Performance Counters

[Update - Sep 30, 2010] Since I studied a lot on this & related topics, I'll write whatever tips I gathered out of my experiences and suggestions provided in answers over here- 1) Use memory profiler (try CLR Profiler, to start with) and find the routines which consume max mem and fine tune them, like reuse big arrays, try to keep references to objects to minimal. 2) If possible, allocate small objects (less than 85k for .NET 2.0) and use memory pools if you can to avoid high CPU usage by garbage collector. 3) If you increase references to objects, you're responsible to de-reference them the same number of times. You'll have peace of mind and code probably will work better. 4) If nothing works and you are still clueless, use elimination method (comment/skip code) to find out what is consuming most memory. Using memory performance counters inside your code might also help you. Hope these help! [Original question] Hi! I'm working in C#, and my issue is out of memory exception. I read an excellent article on LOH here -> http://www.simple-talk.com/dotnet/.net-framework/the-dangers-of-the-large-object-heap/ Awesome read! And, http://dotnetdebug.net/2005/06/30/perfmon-your-debugging-buddy/ My issue: I am facing out of memory issue in an enterprise level desktop application. I tried to read and understand stuff about memory profiling and performance counter (tried WinDBG also! - little bit) but am still clueless about basic stuff. I tried CLR profiler to analyze the memory usage. It was helpful in: Showing me who allocated huge chunks of memory What data type used maximum memory But, both, CLR Profiler and Performance Counters (since they share same data), failed to explain: The numbers that is collected after each run of the app - how to understand if there is any improvement?!?! How do I compare the performance data after each run - is lower/higher number of a particular counter good or bad? What I need: I am looking for the tips on: How to free (yes, right) managed data type objects (like arrays, big strings) - but not by making GC.Collect calls, if possible. I have to handle arrays of bytes of length like 500KB (unavoidable size :-( ) every now and then. If fragmentation occurs, how to compact memory - as it seems that .NET GC is not really effectively doing that and causing OOM. Also, what exactly is 85KB limit for LOH? Is this the size of the object of the overall size of the array? This is not very clear to me. What memory counters can tell if code changes are actually reducing the chances of OOM? Tips I already know Set managed objects to null - mark them garbage - so that garbage collector can collect them. This is strange - after setting a string[] object to null, the # bytes in all Heaps shot up! Avoid creating objects/arrays > 85KB - this is not in my control. So, there could be lots of LOH. 3. Memory Leaks Indicators: # bytes in all Heaps increasing Gen 2 Heap Size increasing # GC handles increasing # of Pinned Objects increasing # total committed Bytes increasing # total reserved Bytes increasing Large Object Heap increasing My situation: I have got 4 GB, 32-bit machine with Wink 2K3 server SP2 on it. I understand that an application can use Increasing the Virtual Memory (pagefile) size has no effect in this scenario. As its OOM issue, I am only focusing on memory related counters only. Please advice! I really need some help as I'm stuck because of lack of good documentation!
