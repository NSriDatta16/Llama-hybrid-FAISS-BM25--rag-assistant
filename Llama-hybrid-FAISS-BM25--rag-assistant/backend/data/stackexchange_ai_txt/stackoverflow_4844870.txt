[site]: stackoverflow
[post_id]: 4844870
[parent_id]: 4844399
[tags]: 
Here is a simple generator based implementation: def cumsum(seq): s= 0 for c in seq: s+= c yield s print [c for c in cumsum(range(7))] print [c for c in cumsum((0, 1, 2, 3, 4, 5, 6))] Which is IMHO quite Pythonic way to implement cumsum. But here is a more pragmatic implementation, which allows you to handle (allmost) all types where addition may make sense. def cumsum(seq): s= seq[0] for k in xrange(1, len(seq)): yield s s= s+ seq[k] yield s print [c for c in cumsum(range(7))] print [c for c in cumsum((0, 1, 2, 3, 4, 5, 6))] print [c for c in cumsum(['a', 'b', 'c'])] print [c for c in cumsum([['a'], ['b'], ['c']])] print [c for c in cumsum((('a', ), ('b', ), ('c', )))] So all of these examples behaves expected way, which is not true with the more Pythonic version. Try it out yourself and figure out the reason for different behaviour. Update: Based on comments, a more generic cumsum would be like: def cumsum(iterable): iterable= iter(iterable) s= iterable.next() yield s for c in iterable: s= s+ c yield s tests= [ [], [1], [1, 2], range(7), (0, 1, 2, 3, 4, 5, 6), ['a', 'b', 'c'], [['a'], ['b'], ['c']], (('a', ), ('b', ), ('c', )), xrange(7), ] for test in tests: print test, '=> ', list(cumsum(test)) Still two yields, but IMHO it's still very readable. And the implementation has now the emphasis that the type of the first element of iterable dictates how addition is expected to behave with the rest of elements.
