[site]: stackoverflow
[post_id]: 5121597
[parent_id]: 
[tags]: 
How to modify linqtosql entityref objects in handcoded MVC model?

I am trying to set up my own mvc model rather than letting the environment create one via the graphic designer tool. I had hoped that this would make it easier to keep separate repositories for parts of the model space but so far it has caused me nothing but grief. The first problem I ran into was that the entityref classes had to be updated via a selectlist control in the view. I managed to get that to work by adding an interal ID field to every entityref much like designer.cs would do. However, it has made the model class quite a bit more complex as the code below demonstrates. Unfortunately, I now run into a problem when I want to explicitly update some of the entities in the controller. If I manually set the ID field, the update is just dropped, if I change the entity I get an exception while saving. My model [Table(Name = "dbo.Jobs")] public class Job { [Column(IsPrimaryKey = true, IsDbGenerated = true, AutoSync = AutoSync.OnInsert)] public int JobID { get; set; } internal string _CompanyID; // string for legacy reasons [Column(Storage = "_CompanyID")] public string CompanyID{ get { return _CompanyID} set { if ((_CompanyID != value)) { if (_MittlerOrg.HasLoadedOrAssignedValue) { throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException(); } _CompanyID = value; } } } internal EntityRef _Company; [Association(Storage = "_Company", ThisKey = "CompanyID", OtherKey = "CompanyID", IsForeignKey = true)] public Company Company { get { return _Company.Entity; } set { Organization previousValue = this._Company.Entity; if ((previousValue != value) || (_Company.HasLoadedOrAssignedValue == false)) { if ((previousValue != null)) { _Company.Entity = null; } _Company.Entity = value; if (value != null) { _CompanyID = value.OrganizationID; } else { _CompanyID = default(string); } } } } // The contact depends on the choice of company and should be set // inside an action method once the company is determined. internal string _ContactID; [Column(Storage = "_ContactID")] public string ContactID { get { return _ContactID; } set { if ((_ContactID != value)) { if (_Contact.HasLoadedOrAssignedValue) { throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException(); } _ContactID = value; } } } internal EntityRef _Contact; [Association(Storage = "_Contact", ThisKey = "ContactID", OtherKey = "UserID", IsForeignKey = true)] public User Contact { get { return _Contact.Entity; } set { User previousValue = this._Contact.Entity; if ((previousValue != value) || (_Contact.HasLoadedOrAssignedValue == false)) { if ((previousValue != null)) { _Contact.Entity = null; } _Contact.Entity = value; if (value != null) { _ContactID = value.UserID; } else { _ContactID = default(string); } } } } } The edit function that causes problems is here. If I step though it in the debugger I see that fi.ContactID gets updated but not committed to the DB. [HttpPost] public ActionResult Edit(int id, FormCollection collection) { var user = userrep.FetchByLogin(User.Identity.Name); var job = jobrep.FetchByID(id); try { var oldvalue = job.CompanyID; UpdateModel(job, "job"); if (oldvalue != job.CompanyID) { if (job.CompanyID != null) { job.ContactID = orgrep.FetchByID(job.CompanyID).DefaultContactID; } else { job.ContactID = default(string); } } firep.Save(); return RedirectToAction("Index"); } catch (Exception e) { } } Any idea how to get those pesky entityrefs to behave? I searched up and down the internet but all model layer examples seem to cover the simplest relationships only. Should I just chuck the model completely in favor of managing my references manually though id fields. Cheers, Duffy
