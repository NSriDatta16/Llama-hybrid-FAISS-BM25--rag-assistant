[site]: stackoverflow
[post_id]: 4276087
[parent_id]: 4275504
[tags]: 
When you declare (non-extern, non-argument) and initialize variable as const , this means variable is not writable at all. So compiler is free to place it to read only section. Though it may be modifiable physically (if hardware allows it). Or not modifiable, if it protected by MMU or placed in ROM in standalone application. Standard does not state, what should happen if you try to write const (it is called "undefined behaviour"), so anything may happen: it may be written, not written, cause exception, hang, or something else you cannot imagine. C not so paranoid as, say, Ada, and all unxepected behaviour is up to programmer, not compiler or RTL. As many stated it is inlined in most cases (if compiler know that to inline), but still retains attributes of variables, such as address (and you can get a pointer), size. If all const reads and pointers to it are eliminated, storage for const will also be eliminated by compiler (if it is static or local) or linker (if it is global). Note, local pointers may also be eliminated if their locations can be computed in compile time. Also writes to local variables may be eliminated if they're not read after it, so your snippet may have no code at all. Automatic local variable may be compiled in static storage if compiler prove that only one instance of it is needed. As const is not modifiable it also compiled in static storage, but may be eliminated as stated above. In all your examples all consts may firstly be put static storage (const section) and then easily eliminated.
