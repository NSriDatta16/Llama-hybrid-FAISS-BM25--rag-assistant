[site]: stackoverflow
[post_id]: 3205229
[parent_id]: 
[tags]: 
glDrawArrays crash with EXC_BAD_ACCESS

I'm writing an iPhone application which uses UIView with a CAEAGLayer as its layer. Everything is fine and working apart from 1 small problem: sometimes it crashes with EXC_BAD_ACCESS and the following stack trace: [EAGLView draw] glDrawArrays_Exec PrepareToDraw DrawFramebufferMakeResident AttachmentMakeResident TextureMakeResident memmove it crashes on the line: glVertexPointer(3, GL_FLOAT, 0, vertexCoordinates); glTexCoordPointer(2, GL_FLOAT, 0, textureCoordinates); glBindTexture(GL_TEXTURE_2D, textures[kActiveSideLeft]); glDrawArrays(GL_TRIANGLE_STRIP, 0, totalPoints); // Application will only crash during interface rotation change (that also happens to be the only case when the view frame changes). It doesn't crash often; most of the time it takes 3-5 minutes of rotating device to reproduce this problem. I believe I'm making a mistake which is related to CAEAGLLayer initialization / frame change since that's where it crashes (I believe). So here are the init and layout subviews methods: Init: ... CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer; eaglLayer.opaque = TRUE; context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1]; if (!context || ![EAGLContext setCurrentContext:context]) { [self release]; return nil; } glGenFramebuffersOES(1, &defaultFramebuffer); glGenRenderbuffersOES(1, &colorRenderbuffer); glGenRenderbuffersOES(1, &depthRenderbuffer); glBindFramebufferOES(GL_FRAMEBUFFER_OES, defaultFramebuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, colorRenderbuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, depthRenderbuffer); glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, colorRenderbuffer); glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_DEPTH_ATTACHMENT_OES, GL_RENDERBUFFER_OES, depthRenderbuffer); ... On set frame I only set GL_MODELVIEW and GL_POJECTION matrixes, so I guess nothing bad can happen there. LayoutSubviews: - (void)layoutSubviews { [EAGLContext setCurrentContext:context]; glBindRenderbufferOES(GL_RENDERBUFFER_OES, colorRenderbuffer); [context renderbufferStorage:GL_RENDERBUFFER_OES fromDrawable:(CAEAGLLayer*)self.layer]; glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_WIDTH_OES, &backingWidth); glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_HEIGHT_OES, &backingHeight); glBindRenderbufferOES(GL_RENDERBUFFER_OES, depthRenderbuffer); glRenderbufferStorageOES(GL_RENDERBUFFER_OES, GL_DEPTH_COMPONENT16_OES, backingWidth, backingHeight); NSAssert1(glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES) == GL_FRAMEBUFFER_COMPLETE_OES, @"Failed to make complete framebuffer object: %X", glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES)); } Draw method itself looks like: if ([EAGLContext currentContext] != context) { [EAGLContext setCurrentContext:context]; } glBindFramebufferOES(GL_FRAMEBUFFER_OES, defaultFramebuffer); glViewport(0, 0, backingWidth, backingHeight); ...//drawing different triangle strips here glBindRenderbufferOES(GL_RENDERBUFFER_OES, colorRenderbuffer); [context presentRenderbuffer:GL_RENDERBUFFER_OES]; I'd appreciate any comments on the listed code or suggestions about how can I find out the cause of this bug.
