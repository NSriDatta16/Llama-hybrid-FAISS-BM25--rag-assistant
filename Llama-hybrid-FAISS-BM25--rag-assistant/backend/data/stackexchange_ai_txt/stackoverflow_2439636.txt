[site]: stackoverflow
[post_id]: 2439636
[parent_id]: 
[tags]: 
XNA: Best way to load and read a XML file?

I'm having difficulty doing this seemingly simple task. I want to load XML files with the same ease of loading art assets: content = new ContentManager(Services); content.RootDirectory = "Content"; Texture2d background = content.Load ("images\\ice"); I'm not sure how to do this. This tutorial seems helpful, but how do I get a StorageDevice instance? I do have something working now, but it feels pretty hacky: public IDictionary Get(string typeName) { IDictionary result = new Dictionary (); xmlReader.Read(); // get past the XML declaration string element = null; string text = null; while (xmlReader.Read()) { switch (xmlReader.NodeType) { case XmlNodeType.Element: element = xmlReader.Name; break; case XmlNodeType.Text: text = xmlReader.Value; break; } if (text != null && element != null) { result[element] = text; text = null; element = null; } } return result; } I apply this to the following XML file: 100 23 12 2 And it is able to pass this unit test: internal virtual IPersistentState CreateIPersistentState(string fullpath) { IPersistentState target = new ReadWriteXML(File.Open(fullpath, FileMode.Open)); return target; } /// ///A test for Get with one zombie. /// //[TestMethod()] public void SimpleGetTest() { string fullPath = "C:\\pathTo\\Data\\SavedZombies.xml"; IPersistentState target = CreateIPersistentState(fullPath); string typeName = "zombie"; IDictionary expected = new Dictionary (); expected["health"] = "100"; expected["positionX"] = "23"; expected["positionY"] = "12"; expected["speed"] = "2"; IDictionary actual = target.Get(typeName); foreach (KeyValuePair entry in expected) { Assert.AreEqual(entry.Value, expected[entry.Key]); } } Downsides to the current approach: file loading is done poorly, and matching keys to values seems like it's way more effort than necessary. Also, I suspect this approach would fall apart with more than one entry in the XML. I can't imagine that this is the optimal implementation. UPDATE : Following the advice of @Peter Lillevold, I've changed this a bit: public IDictionary Get(string typeName) { IDictionary result = new Dictionary (); IEnumerable zombieValues = root.Element(@typeName).Elements(); //result["health"] = zombie.Element("health").ToString(); IDictionary nameToElement = zombieValues.ToDictionary(element => element.Name.ToString()); foreach (KeyValuePair entry in nameToElement) { result[entry.Key] = entry.Value.FirstNode.ToString(); } return result; } public ReadWriteXML(string uri) { root = XElement.Load(uri); } internal virtual IPersistentState CreateIPersistentState(string fullpath) { return new ReadWriteXML(fullpath); } /// ///A test for Get with one zombie. /// [TestMethod()] public void SimpleGetTest() { IPersistentState target = CreateIPersistentState("../../../path/Data/SavedZombies.xml"); string typeName = "zombie"; IDictionary expected = new Dictionary (); expected["health"] = "100"; expected["positionX"] = "23"; expected["positionY"] = "12"; expected["speed"] = "2"; IDictionary actual = target.Get(typeName); foreach (KeyValuePair entry in expected) { Assert.AreEqual(entry.Value, actual[entry.Key]); } } The loading is still pretty crappy, and somehow I wasn't able to get the one-line ToDictionary to work with those two lambdas. I had to resort to that foreach loop. What am I doing wrong there?
