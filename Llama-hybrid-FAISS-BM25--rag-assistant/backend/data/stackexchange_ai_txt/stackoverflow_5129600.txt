[site]: stackoverflow
[post_id]: 5129600
[parent_id]: 5126961
[tags]: 
One approach would be to use an instance of a custom subclass of NSProxy rather than of your Device superclass to handle the initial login and device detection. You could design your NSProxy to turn itself into an instance of the appropriate Device subclass once the device type is known. NSProxy takes advantage of a feature of the Objective-C runtime system that it allows its instances to notice when they've received messages intended for an instance of the real target. The proxy can then either forward the message to its target, or turn itself into an instance of the target type and forward the message to itself. (Sounds, weird, I know, but very cool in practice.) Here's the first paragraph of the class description: NSProxy is an abstract superclass defining an API for objects that act as stand-ins for other objects or for objects that donâ€™t exist yet. Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create. Your NSProxy implementation could include the methods needed for connecting, logging in, etc., but not the methods implemented by the Device class hierarchy. The proxy instance could select the target class when it detects the device type. It would then automagically morph itself into an instance of that class as soon as you send it a message implemented by a Device , but not by the proxy.
