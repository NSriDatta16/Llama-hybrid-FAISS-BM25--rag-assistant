[site]: stackoverflow
[post_id]: 4925762
[parent_id]: 4925718
[tags]: 
Try a generic: public static T CastTo (this dynamic obj, bool safeCast) where T:class { try { return (T)obj; } catch { if(safeCast) return null; else throw; } } This is in extension method format, so its usage would be as if it were a member of dynamic objects: dynamic myDynamic = new Something(); var typedObject = myDynamic.CastTo (false); EDIT: Grr, didn't see that. Yes, you could reflectively close the generic, and it wouldn't be hard to hide in a non-generic extension method: public static dynamic DynamicCastTo(this dynamic obj, Type castTo, bool safeCast) { MethodInfo castMethod = this.GetType().GetMethod("CastTo").MakeGenericMethod(castTo); return castMethod.Invoke(null, new object[] { obj, safeCast }); } I'm just not sure what you'd get out of this. Basically you're taking a dynamic, forcing a cast to a reflected type, then stuffing it back in a dynamic. Maybe you're right, I shouldn't ask. But, this'll probably do what you want. Basically when you go into dynamic-land, you lose the need to perform most casting operations as you can discover what an object is and does through reflective methods or trial and error, so there aren't many elegant ways to do this.
