[site]: stackoverflow
[post_id]: 4024492
[parent_id]: 
[tags]: 
Can anyone help me interpret this MSVC debug-mode disassembly from a simple Hello World?

I got the following simple C++ code: #include int main(void) { ::printf("\nHello,debugger!\n"); } And from WinDbg, I got the following disassembly code: SimpleDemo!main: 01111380 55 push ebp 01111381 8bec mov ebp,esp 01111383 81ecc0000000 sub esp,0C0h 01111389 53 push ebx 0111138a 56 push esi 0111138b 57 push edi 0111138c 8dbd40ffffff lea edi,[ebp-0C0h] 01111392 b930000000 mov ecx,30h 01111397 b8cccccccc mov eax,0CCCCCCCCh 0111139c f3ab rep stos dword ptr es:[edi] 0111139e 8bf4 mov esi,esp 011113a0 683c571101 push offset SimpleDemo!`string' (0111573c) 011113a5 ff15b0821101 call dword ptr [SimpleDemo!_imp__printf (011182b0)] 011113ab 83c404 add esp,4 011113ae 3bf4 cmp esi,esp 011113b0 e877fdffff call SimpleDemo!ILT+295(__RTC_CheckEsp) (0111112c) 011113b5 33c0 xor eax,eax 011113b7 5f pop edi 011113b8 5e pop esi 011113b9 5b pop ebx 011113ba 81c4c0000000 add esp,0C0h 011113c0 3bec cmp ebp,esp 011113c2 e865fdffff call SimpleDemo!ILT+295(__RTC_CheckEsp) (0111112c) 011113c7 8be5 mov esp,ebp 011113c9 5d pop ebp 011113ca c3 ret I have some difficulties to fully understand it. What is the SimpleDemo!ILT things doing here? What's the point of the instruction comparing ebp and esp at 011113c0 ? Since I don't have any local variables in main() function, why there's still a sub esp,0C0h at the loacation of 01111383 ? Many thanks. Update 1 Though I still don't know what ILT means, but the __RTC_CheckESP is for runtime checks. These code can be elimiated by placing the following pragma before the main() function. #pragma runtime_checks( "su", off ) Reference: http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx http://msdn.microsoft.com/en-us/library/6kasb93x.aspx Update 2 The sub esp,0C0h instruction allocate another 0C0h bytes extra space on the stack. Then EAX is filled with 0xCCCCCCCC, this is 4 bytes, since ECX=30h, 4*30h=0C0h, so the instruction rep stos dword ptr es:[edi] fill exactly the extra spaces with 0xCC. But what is this extra space on stack for? Is this some kind of safe belt? Also I notice that if I turn off the runtime check as Update 1 shows, there's still such extra space on stack, though much smaller. And this space is not filled with 0xCC. The assembly code without runtime check is like below: SimpleDemo!main: 00231250 55 push ebp 00231251 8bec mov ebp,esp 00231253 83ec40 sub esp,40h
