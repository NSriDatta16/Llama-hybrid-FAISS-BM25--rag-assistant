[site]: stackoverflow
[post_id]: 5363711
[parent_id]: 5363602
[tags]: 
Actually, you have to do both : use placement new to construct the std::vector instance in shared memory AND use a custom allocator to make the vector place its data within the shared memory as well. Keep in mind that you need to synchronize any access to the vector (except if you need only read access) - std::vector is not generally thread-safe and doesn't declare any of its members volatile , which makes simultaneous access out of the compiler's scope - as it happens in a shared memory region - extremely dangerous. ... after all, I wouldn't do it . Shared memory is a very low-level, very tricky concept, it doesn't fit well with high-level data containers such as std::vector , in a language that (as of cpp03) doesn't provide good builtin solutions for concurrency problems and that is not aware that something like shared memory exists. ... it might even trigger undefined behaviour : while std::vector generally uses its allocator to fetch storage for its elements, it is (as far as I know) allowed to allocate further memory (i.e. for internal purposes, whatever that may be) using malloc or any other allocation strategy (I think Microsoft's std::vector implementation does that in debug builds) ... these pointers would only be valid for one side of the memory mapping. To avoid the std::vector , I'd simply allocate sufficient memory in the mapped range upfront and use a simple counter to keep the number of valid elements. That should be safe.
