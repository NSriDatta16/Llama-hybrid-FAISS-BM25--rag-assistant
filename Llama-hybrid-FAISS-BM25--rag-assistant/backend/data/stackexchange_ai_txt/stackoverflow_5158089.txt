[site]: stackoverflow
[post_id]: 5158089
[parent_id]: 5157274
[tags]: 
You could do it Tomalak's way, but I certainly wouldn't recommend it. You could never call that function from within another that wasn't also a template if the array was passed through params. This means almost your entire program would have to be templated code. OK, in theory, but generally impractical. You can't use the double** interface as you've found out. You could cast to that type but then you also need the size information to be passed in so that you can: my_ptrptr[row * col_size][col]; You have to be explicit about the dimensions like this because the compiler no longer knows what it needs to. The best answer to your problem is to not do it that way. Leverage the STL so that you don't have to deal with hokey crap like this. Use Stephane's answer. Yet another thing you can do though, if you're going to use templates anyway, is to write it to be generic: template void fun(Iter begin, Iter end) { // begin[x][y]... (*begin)[y]...++begin, etc... } ... double arr[arr_row_count][arr_col_count]; fun(arr, arr+arr_row_count); This one has the major benefit of working with ANYTHING that looks like an array of arrays. This means it would make an excellent 'interim' method that you can use with your double[][] types until such time as you can begin using something better like the std::vector and/or boost::array . Do it Tomalak's way and you won't be able to make this change later...yet another reason not to use that method.
