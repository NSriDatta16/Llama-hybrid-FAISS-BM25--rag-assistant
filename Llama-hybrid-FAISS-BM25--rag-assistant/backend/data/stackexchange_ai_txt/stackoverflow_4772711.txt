[site]: stackoverflow
[post_id]: 4772711
[parent_id]: 4772680
[tags]: 
Typical runtime libraries provide a feature that makes it easy to initialise data to 0. In general terms, this is stored in a specific section in the executable, organised by the compiler and linker. At program startup, the runtime startup code uses something like memset() to clear out all the initialised data to 0. This means that the zero bytes don't have to be stored inside the executable itself. The converse is that if you initialise data to something other than zero, then the bytes for that data must be stored in the executable itself, since the automatic initialiser only initialises to zero. Therefore, if you were to declare a big array of char (say a megabyte?) and initialise it with, say, {0} , then there would not be bytes stored in the executable for that array. On the other hand, if you were to initialise it with {1} under your scheme, a megabyte of 1 bytes would have to be stored in the executable itself. By changing one character in the initialiser list, the size of the executable increases by a megabyte. I believe such a scheme would violate the principle of least surprise .
