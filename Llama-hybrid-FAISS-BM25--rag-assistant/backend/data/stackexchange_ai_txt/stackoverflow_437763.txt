[site]: stackoverflow
[post_id]: 437763
[parent_id]: 434763
[tags]: 
It depends on what you mean by 'truly standards compliant'. However, the short answer is "it is a good idea to ensure that all functions have a prototype in scope before being used". A more qualified answer notes that if the function accepts variable arguments (notably the printf() family of functions), then a prototype must be in scope to be strictly standards compliant. This is true of C89 (from ANSI) and C90 (from ISO; the same as C89 except for the section numbering). Other than 'varargs' functions, though, functions which return an int do not have to be declared, and functions that return something other than an int do need a declaration that shows the return type but do not need the prototype for the argument list. Note, however, that if the function takes arguments that are subject to 'normal promotions' in the absence of prototypes (for example, a function that takes a char or short - both of which are converted to int ; more seriously, perhaps, a function that takes a float instead of a double ), then a prototype is needed. The standard was lax about this to allow old C code to compile under standard conformant compilers; older code was not written to worry about ensuring that functions were declared before use - and by definition, older code did not use prototypes since they did not become available in C until there was a standard. C99 disallows 'implicit int'...that means both oddball cases like ' static a; ' (an int by default) and also implicit function declarations. These are mentioned (along with about 50 other major changes) in the foreword to ISO/IEC 9899:1999, which compares that standard to the previous versions: remove implicit int … remove implicit function declaration In ISO/IEC 9899:1990, §6.3.2.2 Function calls stated: If the expression that precedes the parenthesized argument list in a function call consists solely of an identifier, and if no declaration is visible for this identifier, the identifier is implicitly declared exactly as if, in the innermost block containing the function call, the declaration: extern int identifier(); appeared. 38 38 That is, an identifier with block scope declared to have external linkage with type function without parameter information and returning an int . If in fact it is not defined as having type “function returning int ,” the behavior is undefined. This paragraph is missing in the 1999 standard. I've not (yet) tracked the change in verbiage that allows static a; in C90 and disallows it (requiring static int a; ) in C99. Note that if a function is static, it may be defined before it is used, and need not be preceded by a declaration. GCC can be persuaded to witter if a non-static function is defined without a declaration preceding it ( -Wmissing-prototypes ).
