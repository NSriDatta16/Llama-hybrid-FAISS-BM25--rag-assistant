[site]: stackoverflow
[post_id]: 1828222
[parent_id]: 1813483
[tags]: 
Thank you all for helping me see my problem more clearly. I found what I was looking for. It is called Mitsuta method . The inputs and output are in the range [0..360). This method is good for averaging data that was sampled using constant sampling intervals. The method assumes that the difference between successive samples is less than 180 degrees (which means that if we won't sample fast enough, a 330 degrees change in the sampled signal would be incorrectly detected as a 30 degrees change in the other direction and will insert an error into the calculation). Nyquistâ€“Shannon sampling theorem anybody ? Here is a c++ code: double AngAvrg(const vector & Ang) { vector ::const_iterator iter= Ang.begin(); double fD = *iter; double fSigD= *iter; while (++iter != Ang.end()) { double fDelta= *iter - fD; if (fDelta 180.) fD+= fDelta - 360.; else fD+= fDelta ; fSigD+= fD; } double fAvrg= fSigD / Ang.size(); if (fAvrg >= 360.) return fAvrg -360.; if (fAvrg It is explained on page 51 of Meteorological Monitoring Guidance for Regulatory Modeling Applications (PDF)(171 pp, 02-01-2000, 454-R-99-005) Thank you MaR for sending the link as a comment. If the sampled data is constant, but our sampling device has an inaccuracy with a Von Mises distribution , a unit-vectors calculation will be appropriate.
