[site]: stackoverflow
[post_id]: 2398632
[parent_id]: 2397547
[tags]: 
Related to Tony's answer, you can also use a single datetime column relative to a standard start time which is implicit for all intervals - for instance: 1/1/1900 12:00 AM. In this case it is easy enough for storage: INSERT INTO tbl (interval) VALUES (DATEADD(s, '1/1/1900', DATEDIFF(s, @starttime, @endtime)) Now this is not obviously easy for doing SUMs of rows, so you could think about adding persisted computed column(s) of DATEDIFF(s, '1/1/1900', interval) to provide seconds to perform SUMs. Now, here's where it gets interesting for SQL Server: Because of SQL Server's implementation for converting numbers to and from dates, 0 -> 1/1/1900 12:00 AM, 0.5 -> 1/1/1900 12:00 PM, 1 -> 1/2/1900 12:00 AM etc. i.e. the whole number is treated as the number of days since 1/1/1900 and the fractional part is the fraction within the day. So you CAN actually naively add these to get an interval. And in fact: SELECT CONVERT(DATETIME, 1) + CONVERT(DATETIME, 0) + CONVERT(DATETIME, 2) + CONVERT(DATETIME, 0.5) gives '1900-01-04 12:00:00.000' as expected So you can do this (going around SUM by converting): DECLARE @datetest TABLE ( dt DATETIME NOT NULL ) INSERT INTO @datetest ( dt ) VALUES ( 0 ) INSERT INTO @datetest ( dt ) VALUES ( 1 ) INSERT INTO @datetest ( dt ) VALUES ( 2 ) INSERT INTO @datetest ( dt ) VALUES ( 0.5 ) SELECT * FROM @datetest SELECT CONVERT(DATETIME, SUM(CONVERT(FLOAT, dt))) FROM @datetest I'm not advocating doing this in general, YMMV, and any design solution you choose should be verified against all your requirements.
