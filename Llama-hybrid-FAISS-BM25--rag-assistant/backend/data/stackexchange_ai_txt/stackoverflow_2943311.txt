[site]: stackoverflow
[post_id]: 2943311
[parent_id]: 2943264
[tags]: 
The following should be faster than anything using regex, and your initial attempt. public String stripGarbage(String s) { StringBuilder sb = new StringBuilder(s.length()); for (int i = 0; i = 'A' && ch = 'a' && ch = '0' && ch Key points: It is significantly faster use a StringBuilder than string concatenation in a loop. (The latter generates N - 1 garbage strings and copies N * (N + 1) / 2 characters to build a String containing N characters.) If you have a good estimate of the length of the result String, it is a good idea to preallocate the StringBuilder to hold that number of characters. (But if you don't have a good estimate, the cost of the internal reallocations etc amortizes to O(N) where N is the final string length ... so this is not normally a major concern.) Searching testing a character against (up to) 3 character ranges will be significantly faster on average than searching for a character in a 62 character String. A switch statement might be faster especially if there are more character ranges. However, in this case it will take many more lines of code to list the cases for all of the letters and digits. If the non-garbage characters match existing predicates of the Character class (e.g. Character.isLetter(char) etc) you could use those. This would be a good option if you wanted to match any letter or digit ... rather than just ASCII letters and digits. Other alternatives to consider are using a HashSet or a boolean[] indexed by character that were pre-populated with the non-garbage characters. These approaches work well if the set of non-garbage characters is not known at compile time.
