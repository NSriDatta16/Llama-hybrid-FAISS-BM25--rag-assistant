[site]: stackoverflow
[post_id]: 1890437
[parent_id]: 1889137
[tags]: 
Ok, my bad I have not try to compile the code from VS. I was simply typing it and deliberately omit some details. I must say that it was a very bad idea to not test the sample directly and only rely on a behaviour I was seeing in a real project. So a compilable version would be: /* /clr option enabled */ class Base { public: void FuncA() {} protected : Base() {} }; class Derived : public Base { public: int foo() { return 1; } }; template class SomeValueReader : protected T { public: void FuncA() { T::FuncA(); } T& Current() { return *this; } }; void main(char* args) { SomeValueReader reader; reader.FuncA(); Derived derived; derived = reader.Current(); int fooresult = derived.foo(); //reader.foo() >> ok, not allowed }; Now, I have to say that I cannot make this sample to produce an access violation. So it is irrelevant. Nevertheless, the modification that I had proposed was the only wordaround I have found to my problem in my real project and I was wondering why. Item 34: Prefer composition to inheritance I am well aware of this general guideline and I did wish to define my SomeValueReader as a composition. However, the SomeValueReader do need to access protected functions and members of T to be able to adjust itself to T. To have only a member T would not give enough information to SomeValueReader to perform its responsability. Moreover, SomeValueReader do exploit the Base public non-virtual interface by implementing a set of private virtual functions. Otherwise, it would have to duplicate some code or logic. So, I end up with these options, I either : declare SomeValueReader a friend of Base, duplicate some logic and access T protected members; promote Base protected methods to public (and expose way too much information to all); or try this curious protected inheritance (but does add complexity). I may have missed another option. Since I could not resolve myself to "cheat" with a friend class, I have decided to go with this template polymorphism. But I am open to suggestions. The missing const and destructor The const was an error due to inattention (and to not try to compile the code). The missing destructor was an omission as I did not see it as a important detail. But few people do think that could have been error. In fact, this is what I would though either. A memory corruption leads us to reach for the error inside the destructors. But in the real project, the Base destructor is in fact public and virtual. Or could have been protected and non-virtual in this example since Base* was not used.
