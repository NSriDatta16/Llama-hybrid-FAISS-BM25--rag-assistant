[site]: stackoverflow
[post_id]: 1745586
[parent_id]: 1745333
[tags]: 
However, I'd like to make my reusability criteria one notch harder: what if I need a control structure around my repeated generation? itertools often helps even there - you need to provide concrete examples where you think it doesn't. For instance, I might want to call a subgenerator forever with different parameters. itertools.chain.from_iterable . Or my subgenerators might be very costly, and I only want to start them up as and when they are reached. Both chain and chain_from_iterable do that -- no sub-iterator is "started up" until the very instant the first item from it is needed. Or (and this is a real desire) I might want to vary what I do next based on what my controller passes me using send(). A specific example would be greatly appreciated. Anyway, worst case, you'll be coding for x in blargh: yield x where the suspended Pep3080 would let you code yield from blargh -- about 4 extra characters (not a tragedy;-). And if some sophisticated coroutine-version of some itertools functionality (itertools mostly supports iterators - there's no equivalent coroutools module yet) becomes warranted, because a certain pattern of coroutine composition is often repeated in your code, then it's not too hard to code it yourself. For example, suppose we often find ourselves doing something like: first yield a certain value; then, repeatedly, if we're sent 'foo', yield the next item from fooiter, if 'bla', from blaiter, if 'zop', from zopiter, anything else, from defiter. As soon as we spot the second occurrence of this compositional pattern, we can code: def corou_chaiters(initsend, defiter, val2itermap): currentiter = iter([initsend]) while True: val = yield next(currentiter) currentiter = val2itermap(val, defiter) and call this simple compositional function as and when needed. If we need to compose other coroutines, rather than general iterators, we'll have a slightly different composer using the send method instead of the next built-in function; and so forth. If you can offer an example that's not easily tamed by such techniques, I suggest you do so in a separate question (specifically targeted to coroutine-like generators), as there's already a lot of material on this one that will have little to do with your other, much more complex/sophisticated, example.
