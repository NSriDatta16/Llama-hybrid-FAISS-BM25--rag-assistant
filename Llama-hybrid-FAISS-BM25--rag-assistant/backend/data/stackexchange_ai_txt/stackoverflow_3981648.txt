[site]: stackoverflow
[post_id]: 3981648
[parent_id]: 
[tags]: 
Is it possible to use existing classes as POCOs in Entity Framework

I was able to generate pocos using POCO template from Microsoft. It works great. My question is how I could modify this or any other template to use existing objects from a different assembly, and just load data into them. The way i tried going about it, was to create POCO's using the template, and the PocoGenerator.Context to use existing Model, and than modify generated code to return my clasess instead of its generated classes. this gives me the dreaded "Mapping and metadata information could not be found for EntityType MyType".. This may be because there are a few extra fields in database that my object's don't have. I tried modifying entity objects and removing those fields but that cause some other problems.. has anyone done this? UDPATE yep, existing classes can be used. The one thing to watch out for, is the un-informative error above will be triggered if there is a mismatch between some property names, or types. Occasionally the runtime will give a meaningful error with name of property that is incompatible, but that's only if both classes are really close. Anyways, to use existing classes as pocos, simply generate the pocos, and than comment out the generated classes. Than in xxxPocoGenerator.Context.cs add necessary namespace of your existing objects to be used. As a side note, i wrote the following code to compare my existing classes, with POCO generated ones and show any that do not match so i could fix them. var properties = typeof(MyExistingClass).GetProperties(); var tproperties = typeof(MyPOCOClass).GetProperties(); Console.WriteLine("---------------------------------Missing or Different Properties--------------------"); List missingOrDifferentProperties = new List (); foreach (var tp in tproperties) if (properties.Where(p => p.Name == tp.Name && p.PropertyType == tp.PropertyType && p.CanRead == tp.CanRead && p.CanWrite == tp.CanWrite && p.IsSpecialName == tp.IsSpecialName && p.MemberType == tp.MemberType).Count() != 1) Console.WriteLine(tp.Name + " :: " + tp.PropertyType.Name);
