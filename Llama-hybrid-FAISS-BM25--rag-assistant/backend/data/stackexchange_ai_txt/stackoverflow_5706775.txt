[site]: stackoverflow
[post_id]: 5706775
[parent_id]: 
[tags]: 
ASP.NET TCP Reset after file download in firefox

So I'm at my wit's end with this and have been searching forever to find an answer. I have an ASP .net 3.5 application which has a feature allowing users to download and view files stored in a database. After a user clicks a link to downloads the file, and then clicks on any other link in the site, they get the Firefox yellow screen (XML parsing error: element is not well-formed...) which I understand is what happens when Firefox gets a blank page. Works fine in IE though. After trying nearly everything (opening the download processing in a new windows to a generic http handler, clearing the response buffer after the file download/before/both, clearing the response headers after download) I looked at the headers in HttpFox, which said that it was getting an abort or something. So then I look at it when the error occurs in wireshark, and it turns out a bunch of TCP RST flags are getting sent from the server. One last bit of information, if you click another link very quickly after the download, it works, but will still do the same on a subsequent action, leading me to believe some asynchronous action is eventually causing a connection reset. Any help at all would be greatly appreciated, I've been banging my head against this for a week now. Following is my code, StorageItem is a class from my web host (Rackspace) where the files are stored in a cloud: public void ViewFile(string containerName, string FileName, string clientFileName, string extension) { StorageItem fileItem = conn.GetStorageItem(containerName, FileName); int readLength = 2097152; long fileLength = fileItem.FileLength; int numIterations = Convert.ToInt32(fileLength / Convert.ToInt32(readLength)) + 1; HttpResponse Response = HttpContext.Current.Response; Response.AddHeader("Content-Disposition", String.Format("attachment; filename={0}{1}", clientFileName, extension)); Response.AddHeader("Content-Length", fileItem.FileLength.ToString()); Response.ContentType = fileItem.ContentType; byte[] imageBytes = new byte[readLength]; Stream inputStream = fileItem.ObjectStream; int i = 0; Response.Flush(); for (i = 0; i fileLength) readLength = Convert.ToInt32(fileLength - curPosition); inputStream.Read(imageBytes, 0, readLength); Response.BinaryWrite(imageBytes); if (numIterations + 1 % 30 == 0) inputStream.Flush(); } inputStream.Close(); fileItem.ObjectStream.Close(); Response.End(); }
