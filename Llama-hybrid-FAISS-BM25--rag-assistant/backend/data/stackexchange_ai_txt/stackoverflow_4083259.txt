[site]: stackoverflow
[post_id]: 4083259
[parent_id]: 4083239
[tags]: 
You're supposed to set it before using it. That's the only rule you have to follow to avoid undefined behaviour. Whether you initialise it at creation time or assign to it just before using it is not relevant. Personally speaking, I prefer to never have variables set to unknown values myself so I'll usually do the first one unless it's set in close proximity (within a few lines). In fact, with C99, where you don't have to declare locals at the tops of blocks any more, I'll generally defer creating it until it's needed, at which point it can be initialised as well. Note that variables are given default values under certain circumstances (for example, if they're static storage duration such as being declared at file level, outside any function). Local variables do not have this guarantee. So, if your second declaration above ( char *str; ) is inside a function, it may have rubbish in it and attempting to use it will invoke the afore-mentioned, dreaded, undefined behaviour. The relevant part of the C99 standard 6.7.8/10 : If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static storage duration is not initialized explicitly, then: if it has pointer type, it is initialized to a null pointer; if it has arithmetic type, it is initialized to (positive or unsigned) zero; if it is an aggregate, every member is initialized (recursively) according to these rules; if it is a union, the first named member is initialized (recursively) according to these rules.
