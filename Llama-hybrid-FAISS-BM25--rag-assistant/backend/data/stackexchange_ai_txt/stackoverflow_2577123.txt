[site]: stackoverflow
[post_id]: 2577123
[parent_id]: 
[tags]: 
Need help with a memory management problem in my game model

I'm a beginner level programmer trying to make a game app for the iphone and I've encountered a possible issue with the memory management (exc_bad_access) of my program so far. I've searched and read dozens of articles regarding memory management (including apple's docs) but I still can't figure out what exactly is wrong with my codes. So I would really appreciate it if someone can help clear up the mess I made for myself. //in the .h file @property(nonatomic,retain) NSMutableArray *fencePoleArray; @property(nonatomic,retain) NSMutableArray *fencePoleImageArray; @property(nonatomic,retain) NSMutableArray *fenceImageArray; //in the .m file - (void)viewDidLoad { [super viewDidLoad]; self.gameState = gameStatePaused; fencePoleArray = [[NSMutableArray alloc] init]; fencePoleImageArray = [[NSMutableArray alloc] init]; fenceImageArray = [[NSMutableArray alloc] init]; mainField = CGRectMake(10, 35, 310, 340); .......... [NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(gameLoop) userInfo:nil repeats:YES]; } So basically, the player touches the screen to set up the fences/poles -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { if(.......) { ....... } else { UITouch *touch = [[event allTouches] anyObject]; currentTapLoc = [touch locationInView:touch.view]; NSLog(@"%i, %i", (int)currentTapLoc.x, (int)currentTapLoc.y); if(CGRectContainsPoint(mainField, currentTapLoc)) { if([self checkFence]) { onFencePole++; //this 3 set functions adds their respective objects into the 3 NSMutableArrays using addObject: [self setFencePole]; [self setFenceImage]; [self setFencePoleImage]; ....... } } else { ....... } } } } The setFence function (setFenceImage and setFencePoleImage is similar to this) -(void)setFencePole { Fence *fencePole; if (!elecFence) { fencePole = [[Fence alloc] initFence:onFencePole fenceType:1 fencePos:currentTapLoc]; } else { fencePole = [[Fence alloc] initFence:onFencePole fenceType:2 fencePos:currentTapLoc]; } [fencePoleArray addObject:fencePole]; [fencePole release]; and whenever I press a button in the game, endOpenState is called to clear away all the extra images(fence/poles) on the screen and also to remove all existing objects in the 3 NSMutableArray. Point is to remove all the objects in the NSMutableArrays but keep the array itself so it can be reused later. -(void)endOpenState { ........ int xMax = [fencePoleArray count]; int yMax = [fenceImageArray count]; for (int x = 0; x The crash happens here at the checkFence function. -(BOOL)checkFence { if (onFencePole == 0) { return YES; } else if (onFencePole >= 1 && onFencePole So the problem here is, everything works fine until checkFence is called the 2nd time after endOpenState is called. So its like tap_screen -> tap_screen -> press_button_to_call_endOpenState -> tap screen -> tap_screen -> crash What I'm thinking of is that fencePoleArray got messed up when I used [fencePoleArray removeAllObjects] because it doesn't crash when I comment it out. It would really be great if someone can explain to me what went wrong. And thanks in advance.
