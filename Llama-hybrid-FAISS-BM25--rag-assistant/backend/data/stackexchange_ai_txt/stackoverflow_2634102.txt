[site]: stackoverflow
[post_id]: 2634102
[parent_id]: 2617476
[tags]: 
Ok I believe I got the solution. This is based on Beta's idea, but with some necessary tweaks. Here it goes: local twoPi = 2.0 * math.pi -- small optimisation -- returns -1, 1 or 0 depending on whether x>0, x 0 and 1 or x math.pi, brakingAngle > differenceAngle, w > 0 if( (a and b) or (a and c) or (b and c) ) then torque = -torque end self:applyTorque(torque) end The concept behind this is simple: I need to calculate how much "space" (angle) the turret needs in order to stop completely. That depends on how fast the turret moves and how much torque can it apply to itself. In a nutshell, that's what I calculate with brakingAngle . My formula for calculating this angle is slightly different from Beta's. A friend of mine helped me out with the physics, and well, they seem to be working. Adding the sign of w was my idea. I had to implement a "normalizing" function, which puts any angle back to the 0-2Pi zone. Initially this was an entangled if-else-if-else. Since the conditions where very repetitive, I used some boolean logic in order to simplify the algorithm. The downside is that, even if it works ok and it is not complicated, it doesn't transpire why it works. Once the code is a little bit more depurated I'll post a link to a demo here. Thanks a lot. EDIT: Working LÃ–VE sample is now available here . The important stuff is inside actors/AI.lua (the .love file can be opened with a zip uncompressor)
