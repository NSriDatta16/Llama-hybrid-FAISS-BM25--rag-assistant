[site]: stackoverflow
[post_id]: 2814513
[parent_id]: 2814427
[tags]: 
(Update: Apparently my original answer wasn't very helpful for the OP... See below the second HR for an appendix.) In situations like this, what you really want to do is to launch ghci and use :t to find out the type of various expressions. E.g. :t foldr map -- answer: foldr map :: [b] -> [b -> b] -> [b] If you need to define a name first, use let (which would not be needed in a Haskell source file): let mys = undefined :: a -> a :t map mys -- answer: [a] -> [a] Note the use of undefined with an explicit type signature. It's perfectly ok for finding out the type of expressions of various forms and might even be useful in actual code as a placeholder at early planning stages. The Num a => is a type class constraint on a ; see e.g. Type Classes and Overloading from "A Gentle Introduction to Haskell, Version 98" or Chapter 6. Using Typeclasses from "Real World Haskell" for more information. (Basically, it does what you think it does. :-)) The above should be useful for verifying your answers (and the resources on type classes are good). As for how to solve problems of this kind yourself: Type inference is an application of what is called "the unification algorithm". Google for "unification" for a number of resources; if you add a name of a programming language to your query, you'll likely find example implementations. As for how to approach the examples at hand... a. map mys : map takes a function of type a -> b and returns a function of type [a] -> [b] . In general, a can be different to b , but mys is of type a -> a , so the returned function will be of type [a] -> [a] . Here's some hand-unification: (a -> b) -> [a] -> [b]` (a -> a)` ^-- at this point we unify a with b; when propagated to the return type, this produces [a] -> [a] b. mys map : mys is a function which takes an object of some type and returns an object of the same type. In particular, if you pass it an argument of type (a -> b) -> [a] -> [b] , that will be the type of the return value. Incidentally, there is only one "interesting" (not undefined ) function whose type signature is a -> a (without type class constraints), namely id . See Philip Wadler's paper "Theorems for free!" (which you can download from this page ) for an extended discussion. c. foldr map : Firstly, note that the a s and b s in foldr 's signature having nothing to do with those in map 's signature. It might be convenient to rename map 's a to c and b to d and use the signature map :: (c -> d) -> [c] -> [d] to make this more readily apparent below. Also note that (a -> b -> b) is just a simpler way of writing (a -> (b -> b)) . More hand-unification (explanation follows below): (a -> (b -> b)) (c -> d) -> [c] -> [d] What happens here is that foldr takes a function argument of type (a -> (b -> b)) . If you pass in map as that argument, the a gets unified with c -> d , the b with [c] and then again with [d] , which means c equals d . The return value of foldr has type b -> [a] -> b ; substituting the more specific types obtained in the previous paragraph we get [c] -> [c -> c] -> [c] ^-- c equals d, right? The c comes from our changed signature for map ; with the original b , this becomes [b] -> [b -> b] -> [b] d. foldr map . mys : This is actually (foldr map) . mys , not foldr (map . mys) -- function application ("the invisible operator") binds the strongest! Combining a. and c. from above to solve this one is left as an exercise to the reader. ;-)
