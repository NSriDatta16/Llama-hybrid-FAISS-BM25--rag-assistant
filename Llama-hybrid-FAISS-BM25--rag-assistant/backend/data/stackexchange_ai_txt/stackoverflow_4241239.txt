[site]: stackoverflow
[post_id]: 4241239
[parent_id]: 4240507
[tags]: 
Maximum optimization usually requires taking advantage of the specific requirements. You make the code less general to gain speed (or some other metric). You may know some corner you can cut, while we have to guess. Code fragments below use these headers: #include #include If you want to maximize performance, it would help to pre-allocate enough space for the final string, post- insert: #define MAX_STR_LEN 256 char aa[MAX_STR_LEN] = "Hello, !"; char bb[] = "World"; You don’t indicate how you know where to insert. For my sample code I define the insert point as an offset into the destination string: size_t pos = 7; If you know either of the string lengths in advance you should use a const instead of calling strlen, which has to scan the string. Here I don’t’ assume you’re that lucky. size_t srclen = strlen(bb); The memmove function properly handles overlapping source and destination: // +1 for count to include terminating null memmove(aa+pos+srclen, aa+pos, strlen(aa)-pos+1); memcpy is faster on some platforms and can be safely used to copy between strings: memcpy(aa+pos, bb, srclen); Now aa contains the result. If you can’t pre-allocate aa to the required size, then: // additional include for malloc #include char aa[] = "Hello, !"; char bb[] = "World"; size_t pos = 7; size_t srclen = strlen(bb); size_t dstlen = strlen(aa); char *m = malloc(srclen+dstlen+1); // Test for NULL or use an allocator that throws memcpy(m, aa, pos); memcpy(m+pos, bb, srclen); memcpy(m+pos+srclen, aa+pos, dstlen-pos+1); m contains the result and probably needs to be free 'd eventually. Remember if there is any chance for buffer overflow, you have to check lengths to avoid memory corruption and a possible security vulnerability. I hope this helps.
