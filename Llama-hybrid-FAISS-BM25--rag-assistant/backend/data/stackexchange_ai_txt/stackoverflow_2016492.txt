[site]: stackoverflow
[post_id]: 2016492
[parent_id]: 2016437
[tags]: 
Try it and see. Many compilers will eliminate such temporary objects when asked to optimise their output. If the disassembly is too complex, then create two functions with different numbers of such objects and see if there is any difference in the stack locations of objects surrounding them, something like: void empty1 ( int x ) { using namespace std; int a; Empty e1 ( x ); int b; cout and then try running that compared with an empty8 function with eight Empties created. With g++ on x86, if you do take the address of any of the empties you get a location between x and a on the stack, hence including x in the output. You can't assume that the storage for objects will end up in the same order as they are declared in the source code.
