[site]: stackoverflow
[post_id]: 2093805
[parent_id]: 2093359
[tags]: 
To do this, I would have three tables: Topics topic_id [whatever else you need to know for a topic] Tags tag_id [etc] Map topic_id tag_id select t.[whatever], tag.[whatever] from topics t join map m on t.topic_id = m.topic_id join tags tag on tag.tag_id = m.tag_id where [conditionals] Set up partitions and/or indexes on the map table to maximize the speed of your query. For example, if you have many more topics than tags, partition the table on topics. Then, each time you grab all the tags for a topic, it will be 1 read from 1 area, no seeking needed. Make sure to have both topics and tags indexed on their _id. Use your 'explain plan' tool. (I am not familiar with mysql, but I assume there is some tool that can tell you how a query will be run, so you can optimize it) EDIT: So you have the following tables: tbl_feedbacks tbl_users tbl_categories tbl_clients tbl_tags tbl_topics tbl_topics_tags The query you provide as a starting point shows how feedback, users, categories and clients relate to each other. I assume that tbl_topics_tags contains FKs to tags and topics, showing which topic has which tag. Is this correct? What of (feedbacks, users, categories, and clients) has a FK to topics or tags? Or, do either topics or tags have a FK to any of the initial 4? Once I know this, I'll be able to show how to modify the query. EDIT #2 There are two different ways to go about this: The easy way is the just join on your FK. This will give you one row for each tag. It is much easier and more flexible to put together the SQL to do it this way. If you are using some other language to take the results of the query and translate them to present them to the user, this method is better. If nothing else, it will be far more obvious what is going on, and will be easier to debug and maintain. However, you may want each row of the query results to contain one feedback (and the tags that go with it). SQL joining question Adapting Kevin's answer (which is supposed to work in SQL92 compliant systems): select [other stuff: same as in your post], (select tag from tbl_tag tt join tbl_feedbacks_tags tft on tft.tag_id = tt.tag_id where tft.fk_feedbackid = tbl_feedbacks.pk_feedbackid order by tag_id limit 1 offset 0 ) as tag1, (select tag from tbl_tag tt join tbl_feedbacks_tags tft on tft.tag_id = tt.tag_id where tft.fk_feedbackid = tbl_feedbacks.pk_feedbackid order by tag_id limit 1 offset 1 ) as tag2, (select tag from tbl_tag tt join tbl_feedbacks_tags tft on tft.tag_id = tt.tag_id where tft.fk_feedbackid = tbl_feedbacks.pk_feedbackid order by tag_id limit 1 offset 2 ) as tag3 from [same as in the OP] This should do the trick. Notes: This will pull the first three tags. AFAIK, there isn't a way to have an arbitrary number of tags. You can expand the number of tags shown by copying and pasting more of those parts of the query. Make sure to increase the offset setting. If this does not work, you'll probably have to write up another question, focusing on how to do the pivot in mysql. I've never used mysql, so I'm only guessing that this will work based on what others have told me. One tip: you'll usually get more attention to your question if you strip away all the extra details. In the question I linked to above, I was really joining between 4 or 5 different tables, with many different fields. But I stripped it down to just the part I didn't know (how to get oracle to aggregate my results into one row). I know some stuff, but you can usually do far better than just one person if you trim your question down to the essentials.
