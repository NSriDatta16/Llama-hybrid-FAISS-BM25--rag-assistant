[site]: stackoverflow
[post_id]: 1912120
[parent_id]: 1912056
[tags]: 
Your only providing a linkable object for the class in the translation unit, but the member function is templated on another parameter and has also to be explicitly specified. I don't know if there is a more elegant way, but one compilable version would be: template bool IShader ::getProperty (const std::string& propertyName, ShaderProperty ** outProp); VC8 and GCC 3.4 both allow to leave out the after the function name. I'm however not sure about the correct syntax in that case. But as long as you're not having problems with the compilation time in a big project, save yourself the trouble and put the method definitions (marked inline) in a header. If you're just worried about the size of the header file, move the definitions in another header file, e.g. IShaderImpl.h , that you include at the end of IShader.h . Quick sample to remove doubts: // IShader.h template struct ShaderProperty {}; template class IShader { public: template void getProperty(ShaderProperty **); }; // IShader.cpp #include #include "IShader.h" template template void IShader ::getProperty(ShaderProperty **) { std::cout ; template void IShader ::getProperty(ShaderProperty **); // main.cpp #include "IShader.h" int main() { IShader b; ShaderProperty ** p; b.getProperty(p); }
