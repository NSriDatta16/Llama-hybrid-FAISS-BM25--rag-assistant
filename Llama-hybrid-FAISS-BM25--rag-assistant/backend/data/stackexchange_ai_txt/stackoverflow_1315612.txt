[site]: stackoverflow
[post_id]: 1315612
[parent_id]: 1314592
[tags]: 
Here's a (somewhat fragile) hack: # caller_binding.rb TRACE_STACK = [] VERSION_OFFSET = { "1.8.6" => -3, "1.9.1" => -2 }[RUBY_VERSION] def caller_binding(skip=1) TRACE_STACK[ VERSION_OFFSET - skip ][:binding] end set_trace_func(lambda do |event, file, line, id, binding, classname| item = {:event=>event,:file=>file,:line=>line,:id=>id,:binding=>binding,:classname=>classname} #p item case(event) when 'line' TRACE_STACK.push(item) if TRACE_STACK.empty? when /\b(?:(?:c-)?call|class)\b/ TRACE_STACK.push(item) when /\b(?:(?:c-)?return|end|raise)\b/ TRACE_STACK.pop end end) This works with your example, but I haven't tested it with much else require 'caller_binding' class A def some_method x = 123 nonexistent_method end def method_missing( method, *args, &block ) b = caller_binding eval "puts x", b end end x = 456 A.new.some_method #=> prints 123 A.new.nonexistent_method #=> prints 456 Of course, this won't work if the binding doesn't define the variable you're trying to evaluate, but this is a general issue with bindings. If a variable is not defined, it doesn't know what it is. require 'caller_binding' def show_x(b) begin eval e puts e end end def y show_x(caller_binding) end def ex1 y #=> prints "undefined local variable or method `x' for main:Object" show_x(binding) #=> prints "undefined local variable or method `x' for main:Object" end def ex2 x = 123 y #+> prints "x = 123" show_x(binding) #+> prints "x = 123" end ex1 ex2 To get around this, you need to do some error handling within the evaluated string: require 'caller_binding' def show_x(b) begin eval e puts e end end def y show_x(caller_binding) end def ex1 y #=> prints "x not defined" show_x(binding) #=> prints "x not defined" end def ex2 x = 123 y #+> prints "x = 123" show_x(binding) #+> prints "x = 123" end ex1 ex2
