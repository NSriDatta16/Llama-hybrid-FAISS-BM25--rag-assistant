[site]: stackoverflow
[post_id]: 4084429
[parent_id]: 4083076
[tags]: 
The lower numbered errors, 15000 and below IIRC, and the higher severity levels, interrupt execution. That means the entire thread is interrupted, there is no possibility to trap it inside stored proc code. Anyway, the errors are beyond the control of SQL code or stored procs. The lower numbered errors are "hard" errors, there is nothing you can do about it, even if you did trap it. It is within the servers (not your) domain. Eg. hard disk error; 1205. The server decides, the thread cannot continue, and terminates the spid. It is not feasible to trap that outer domain of errors which you did not administer, set up, or control. So I cannot understand the basis for you expecting that you can. the only way to trapa (eg) hardware errors and deadlocks, is if you wrote your own server. But the most important thing is this. you are breaking basic laws of transaction control (which IS within your power) by processing user interaction while a transaction is open . The rule (unchanged for 40 years) is: perform all user interaction with no transaction open when that is complete, terminate further user interaction begin transaction, perform all your DML, and commit . Failure to obey these rules will lead to various problems which are easy to prevent (by compliance with the rule): uncontrolled lock duration hung transactions (waiting for users who have gone to lunch) very slow response, and the server is idle, waiting for locks . If you are driving a car, sure, you can fiddle around on suburban streets and shopping malls, but once you get one the freeway, you cannot drive less than the speed limit; you cannot stop and wait for passengers. If you do, you will hang everyone up. Trying to trap the cell phone call that will cause the police to come after you, or trying to stop the police from dragging you off, is well, somewhat beyond your powers, mighty as they may be. . In the normal circumstance, when the server experiences a hard error, and it cancels your spid (which of course includes a rollback), the issue is closed. The behaviour as per ANSI SQL 89 (predating 92) compliance. Transactions are Atomic, and Durable. Now if you do not code for that model (suppliying the Isolation and Consistency), it aint no "transaction", it is merely a string of uncontrolled SQL spread across time and space, easily interruptible; fragile and vulnerable. Obviously that means NO AUTOCOMMIT and NO CHAINED, because it breaches the ANSI SQL standard. It is very sad that (a) MS provide such a sick feature, and (b) people use it, without understanding the danger and the non-compliance. Instead of concerning yourself with what you think the server should and should not do (which is futile, because it ain't gonna change), I would suggest you take responsibility for the code you produce, and educate yourself re how the server actually works, what it actually does, before designing and writing any code. Put in your terms, oh it definitely performs try/catch/finally , and half the errors it catches cause it to blow you away, so your try/catch never gets to execute. The concept of your SQL code attempting finally does not exist. SQL is a high level database manipulation language, not a low level language which can control the hardware resources. If you are driving a car, on the freeway, you cannot trap (a) the bridge ten kilometres in front of you crashing down or (b) the police closing the freeway one kilometre in front of you Attempting to control the uncontrollable is of course ...
