[site]: stackoverflow
[post_id]: 400075
[parent_id]: 399867
[tags]: 
Take a look at this: (reprinted from the expired blog page http://jamiethompson.co.uk/web/2008/06/17/publish-subscribe-with-jquery/ based on the archived version at http://web.archive.org/web/20130120010146/http://jamiethompson.co.uk/web/2008/06/17/publish-subscribe-with-jquery/ ) Publish / Subscribe With jQuery June 17th, 2008 With a view to writing a jQuery UI integrated with the offline functionality of Google Gears i’ve been toying with some code to poll for network connection status using jQuery. The Network Detection Object The basic premise is very simple. We create an instance of a network detection object which will poll a URL at regular intervals. Should these HTTP requests fail we can assume that network connectivity has been lost, or the server is simply unreachable at the current time. $.networkDetection = function(url,interval){ var url = url; var interval = interval; online = false; this.StartPolling = function(){ this.StopPolling(); this.timer = setInterval(poll, interval); }; this.StopPolling = function(){ clearInterval(this.timer); }; this.setPollInterval= function(i) { interval = i; }; this.getOnlineStatus = function(){ return online; }; function poll() { $.ajax({ type: "POST", url: url, dataType: "text", error: function(){ online = false; $(document).trigger('status.networkDetection',[false]); }, success: function(){ online = true; $(document).trigger('status.networkDetection',[true]); } }); }; }; You can view the demo here. Set your browser to work offline and see what happens…. no, it’s not very exciting. Trigger and Bind What is exciting though (or at least what is exciting me) is the method by which the status gets relayed through the application. I’ve stumbled upon a largely un-discussed method of implementing a pub/sub system using jQuery’s trigger and bind methods. The demo code is more obtuse than it need to be. The network detection object publishes ’status ‘events to the document which actively listens for them and in turn publishes ‘notify’ events to all subscribers (more on those later). The reasoning behind this is that in a real world application there would probably be some more logic controlling when and how the ‘notify’ events are published. $(document).bind("status.networkDetection", function(e, status){ // subscribers can be namespaced with multiple classes subscribers = $('.subscriber.networkDetection'); // publish notify.networkDetection even to subscribers subscribers.trigger("notify.networkDetection", [status]) /* other logic based on network connectivity could go here use google gears offline storage etc maybe trigger some other events */ }); Because of jQuery’s DOM centric approach events are published to (triggered on) DOM elements. This can be the window or document object for general events or you can generate a jQuery object using a selector. The approach i’ve taken with the demo is to create an almost namespaced approach to defining subscribers. DOM elements which are to be subscribers are classed simply with “subscriber” and “networkDetection”. We can then publish events only to these elements (of which there is only one in the demo) by triggering a notify event on $(“.subscriber.networkDetection”) The #notifier div which is part of the .subscriber.networkDetection group of subscribers then has an anonymous function bound to it, effectively acting as a listener. $('#notifier').bind("notify.networkDetection",function(e, online){ // the following simply demonstrates notifier = $(this); if(online){ if (!notifier.hasClass("online")){ $(this) .addClass("online") .removeClass("offline") .text("ONLINE"); } }else{ if (!notifier.hasClass("offline")){ $(this) .addClass("offline") .removeClass("online") .text("OFFLINE"); } }; }); So, there you go. It’s all pretty verbose and my example isn’t at all exciting. It also doesn’t showcase anything interesting you could do with these methods, but if anyone’s at all interested to dig through the source feel free. All the code is inline in the head of the demo page
