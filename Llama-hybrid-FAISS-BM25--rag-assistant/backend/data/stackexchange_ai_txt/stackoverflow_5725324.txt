[site]: stackoverflow
[post_id]: 5725324
[parent_id]: 
[tags]: 
Expressing long chain of compositions in Haskell

(unimportant background info / motivation) I was implementing a different version of nub , inspired by the Yesod book's discouragement of using it. map head . group . sort is more efficient than a call to nub . However, in our case, order is important... So I set out writing a "better" nub akin to the order-unimportant version. And I ended up with this: mynub = unsort . map head . groupBy (\x y -> fst x == fst y) . sortBy (comparing fst) . rememberPosition rememberPosition = flip zip [0..] unsort = map fst . sortBy (comparing snd) This certainly does a lot of extra work, but it should be O(n log n) instead of original nub's O(n 2 ). But that's beside the point. The problem is, it's so long ! It's really not that complicated, but it's long (and I'm one of those people that hates going wider than 80 columns, or horizontal scrollbars on StackOverflow code blocks). (the question) What are better ways in Haskell for expressing long chains of function composition such as this?
