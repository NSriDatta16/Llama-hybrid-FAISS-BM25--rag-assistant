[site]: stackoverflow
[post_id]: 5100491
[parent_id]: 5100379
[tags]: 
If you're just learning the language, you really shouldn't worry about this. Consider it fast enough until proven otherwise. That said, there are a lot of misleading or incomplete answers here, so for the record I'll flesh out a few of the subtler implications. Consider your class: class Booth { public: int get_tickets_sold(); void set_tickets_sold(); private: int tickets_sold; }; The implementation (known as a definition ) of the get and set functions is not yet specified. If you'd specified function bodies inside the class declaration then the compiler would consider you to have implicitly requested they be inlined (but may ignore that if they're excessively large). If you specify them later using the inline keyword, that has exactly the safe effect. Summarily... class Booth { public: int get_tickets_sold() { return tickets_sold; } ... ...and... class Booth { public: int get_tickets_sold(); ... }; inline int Booth::get_tickets_sold() { return tickets_sold; } ...are equivalent (at least in terms of what the Standard encourages us to expect, but individual compiler heuristics may vary - inlining is a request that the compiler's free to ignore). If the function bodies are specified later without the inline keyword, then the compiler is under no obligation to inline them, but may still choose to do so. It's much more likely to do so if they appear in the same translation unit (i.e. in the .cc/.cpp/.c++/etc. "implementation" file you're compiling or some header directly or indirectly included by it). If the implementation is only available at link time then the functions may not be inlined at all , but it depends on the way your particular compiler and linker interact and cooperate. It is not simply a matter of enabling optimisation and expecting magic. To prove this, consider the following code: // inline.h: void f(); // inline.cc: #include void f() { printf("f()\n"); } // inline_app.cc: #include "inline.h" int main() { f(); } Building this: g++ -O4 -c inline.cc g++ -O4 -o inline_app inline_app.cc inline.o Investigating the inlining: $ gdb inline_app ... (gdb) break main Breakpoint 1 at 0x80483f3 (gdb) break f Breakpoint 2 at 0x8048416 (gdb) run Starting program: /home/delroton/dev/inline_app Breakpoint 1, 0x080483f3 in main () (gdb) next Single stepping until exit from function main, which has no line number information. Breakpoint 2, 0x08048416 in f () (gdb) step Single stepping until exit from function _Z1fv, which has no line number information. f() 0x080483fb in main () (gdb) Notice the execution went from 0x080483f3 in main() to 0x08048416 in f() then back to 0x080483fb in main()... clearly not inlined. This illustrates that inlining can't be expected just because a function's implementation is trivial. Notice that this example is with static linking of object files. Clearly, if you use library files you may actually want to avoid inlining of the functions specifically so that you can update the library without having to recompile the client code. It's even more useful for shared libraries where the linking is done implicitly at load time anyway. Very often, classes providing trivial functions use the two forms of expected-inlined function definitions (i.e. inside class or with inline keyword) if those functions can be expected to be called inside any performance-critical loops, but the countering consideration is that by inlining a function you force client code to be recompiled (relatively slow, possibly no automated trigger) and relinked (fast, for shared libraries happens on next execution), rather than just relinked, in order to pick up changes to the function implementation. These kind of considerations are annoying, but deliberate management of these tradeoffs is what allows enterprise use of C and C++ to scale to tens and hundreds of millions of lines and thousands of individual projects, all sharing various libraries over decades. One other small detail: as a ballpark figure, an out-of-line get/set function is typically about an order of magnitude (10x) slower than the equivalent inlined code. That will obviously vary with CPU, compiler, optimisation level, variable type, cache hits/misses etc..
