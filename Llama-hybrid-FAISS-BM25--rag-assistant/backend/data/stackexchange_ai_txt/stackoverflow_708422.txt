[site]: stackoverflow
[post_id]: 708422
[parent_id]: 708336
[tags]: 
Note that some of the other answers may arguably describe factories, but don't describe the GOF Factory Pattern . Now I want to replace this line with a Factory Pattern, although I am unsure as my TestMode constructor requires an extra object and I am unsure where I would need to pass this value. Well, you could think of it this way: MainMode, not TestMode, is the one that does a special thing. The special thing it does, is to ignore the given number, in order to ensure it's really random. In this way of thinking about it, it's MainMode that does something extra. Or, if other than the randomness, MainMode and TestMode are not different, then you'd be thinking perhaps that you can factor out that similarity into one class, which is provided one of two Strategies for calculating random numbers. One Strategy would actually be random, and one would be perverse, with a random range of only 1 value. But let's assume that there are other differences between MainMode and TestMode -- presumably TestMode outputs extra debugging to System.out or something. We can still factor out "how do we supply randomness" from are we testing or playing the game for real". These are orthogonal concerns. So now we know that in addition to whatever else a 'Mode does, it should accept a Randomness Strategy. Then we could, for example, when you're told that the standard platform random isn't really random enough, you can replace it with a better random. Or you can do testing where the range of randoms is constrained to only two choices, or always alternates from one to zero, or returns on each call the next value in some Vecrtor or Iterator. So we use the GOF Strategy Pattern to build the randomness strategies: interface RandomStrategy { public double random(); } public class NotSoRandom implements RandomStrategy { private double r; public NotSoRandom( final double r ) { this.r = r; } public double random() { return r; } } public class PlatformRandom implements RandomStrategy { public double random() { return Math.random(); } } Now, if your whole app only ever creates one 'Mode, there's no need for a factory; you use a factory when you need to create the same class type over and over; the Factory is in fact just a Strategy for creating the right kind of (sub) class. In production code, I've used factories where I have some generic class that creates stuff, and I need to tell how to create the right subclass to create; I pass in a factory to do that. Now we create a Factory pattern for the 'Mode; this will be surprisingly similar to the Strategy pattern: abstract class Mode() { private RandomStrategy r; public Mode( final RandomStrategy r ) { this.r = r; } // ... all the methods a Mode has } public class MainMode implements Mode { public MainMode( final RandomStrategy r ) { super(r); } } public class TestMode implements Mode { public TestMode( final RandomStrategy r ) { super(r); } } interface ModeFactory{ public Mode createMode( final RandomStrategy r ); } public class MainFactory() { public Mode createMode( final RandomStrategy r ) { return new MainMode(r); } } public class TestFactory() { public Mode createMode( final RandomStrategy r ) { return new TestMode(r); } } So now you know about the Factory Pattern and Strategy Pattern, and how they're similar in "shape", but different in how they're used: Factory Pattern is Object Creational and returns an object to be used; Strategy is Object Behavioral, and an instance is usually created explicitly and a reference is held to the instance, to encapsulate an algorithm. But in terms of the structure, they're quite similar. Edit: the OP asks, in a comment, "How would I integrate this into my GUI?" Well, none of this belongs in the GUI of your program, except possibly the 'Mode. You'd create the ConcreteStrategy and pass it to the preferred Factory in some setup routine, possibly determining which to use based on command line arguments or config files. basically, you'd select the correct factory very much as you selecting the correct class in your original post. Again, if you're only ever creating one of something, you don't need a Factory; factories are for mass production (or creating families of related concrete types -- though that's beyond the scope of this question). (Assume we have a game where the user can select on the command line whether to fight robots or dragons; then we'd want to instantiate an OpponentFactory that produce Opponents (an interface), with derived classes RobotOpponent and DragonOpponent, and pass that factory to the part of the game that spawnsNewOpponent(). Similarly, a user might select brave or cowardly opponents, which we'd set up as a Strategy. We don't need to make more Strategy instances, as a Strategy is usually idempotent (stateless and singleton).) static int main( String[] args ) { // setup game world final RandomStrategy r = "random".equals(args[0]) ? new PlatformRandom() : new NotSoRandom( Integer.intValue(args[0]) ) ; // notice the simlarity to the code you originally posted; // we factored out how to achieve "randomness" as a Strategy. // now we will use our Strategy to setup our Factory; final ModeFactory f = "test".equals(args[1]) ? new TestFactory(r) : new MainFactory(r); // also similar to your code // we've just added an extra level of indirection: // instead of creating a Mode, we've created an object that can create Modes // of the right derived type, on demand. // call something that uses our factory functionThatRunsameAndNeedstoProduceModesWhenevertNeedsTo( f ); }
