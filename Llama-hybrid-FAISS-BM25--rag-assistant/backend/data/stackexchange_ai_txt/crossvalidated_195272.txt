[site]: crossvalidated
[post_id]: 195272
[parent_id]: 195256
[tags]: 
The task you are attempting is called extrapolation and is notoriously dangerous compared to interpolation between the points. I would suggest three approaches: Linear extrapolation using the last two points. As you point out, this is of limited use as you go much further than the spacing between points. $$y = y_{n-1} + (y_n - y_{n-1}) \frac{x - x_{n-1}}{ x_n - x_{n-1}}$$ Go to higher order with quadratic and cubic using the last three or four points. This will capture some of the higher order variation at the end of the curve. Caution though, higher order interpolation can become quite unstable . To do better, you need a model for your data - some idea of the shape of the overall trend. This combined with the least squares method of interpolation that may be used to predict beyond your data. I'd suggest trying #3. You don't tell us about the nature of the data but assuming the dragon's health is primarily decreasing, you could fit it do an exponential function with a polynomial argument, such as $$\exp( - |p(t)| ) $$ where |p(t)| is the absolute value of a low order ( The example data from Lennard's comment are fairly linear (correlation of 0.99) so I'm just using a low order polynomial. The actual data may be more fine grain and it sounds like the concern is the detailed behavior at the end of the distribution. If this is the case a a global fit for plotting with a local fit over the last few hours to determine the zero crossing might be the most accurate. For the data provided: time=[0,8,16,24,36,38] health=[11,9,6,4,1,0] I found a simple quadratic fit worked best (adding a cubic term actually prevented a zero crossing). Making the fit excluding the last data point gives a predicted death at 40 hrs vs 38 in the actual data. As noted above, more samples with a fit over the last hour using a low order polynomial would likely improve this. The code in R is: require(stats) require(graphics) a=1 b=1 c=10 d=1 thefit=nls(health ~ (a*time*time+b*time+c),start=list(a=a,b=b,c=c)) plot(time,health) new = data.frame(xdata = time) p=coef(thefit) curve(p["a"]*x^2+p["b"]*x+p["c"],col='red',add=TRUE) p a b c 0.001173024 -0.325246497 11.149887563 Obviously fairly linear. For PHP, google turns up a polynomial regression class that may be useful for the question.
