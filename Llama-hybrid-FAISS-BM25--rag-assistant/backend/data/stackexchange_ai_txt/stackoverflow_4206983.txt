[site]: stackoverflow
[post_id]: 4206983
[parent_id]: 
[tags]: 
How can I simulate a hanging cable in WPF?

I have an application that is very "connection-based", i.e. multiple inputs/outputs. The UI concept of a "cable" is exactly what I'm looking for to make the concept clear to the user. Propellerhead took a similar approach in their Reason software for audio components, illustrated in this YouTube video (fast forward to 2m:50s) . I can make this concept work in GDI by painting a spline from point A to point B, there's got to be a more elegant way to use Paths or something in WPF for this, but where do you start? Is there a good way to simulate the animation of the cable swing when you grab it and shake it? I'm also open to control libraries (commercial or open source) if this wheel has already been invented for WPF. Update: Thanks to the links in the answers so far, I'm almost there. I've created a BezierCurve programmatically, with Point 1 being (0, 0) , Point 2 being the bottom "hang" point, and Point 3 being wherever the mouse cursor is. I've created a PointAnimation for Point 2 with an ElasticEase easing function applied to it to give the "Swinging" effect (i.e., bouncing the middle point around a bit). Only problem is, the animation seems to run a little late. I'm starting the Storyboard each time the mouse moves, is there a better way to do this animation? My solution so far is located here: Bezier Curve Playground Code: private Path _path = null; private BezierSegment _bs = null; private PathFigure _pFigure = null; private Storyboard _sb = null; private PointAnimation _paPoint2 = null; ElasticEase _eEase = null; private void cvCanvas_MouseMove(object sender, MouseEventArgs e) { var position = e.GetPosition(cvCanvas); AdjustPath(position.X, position.Y); } // basic idea: when mouse moves, call AdjustPath and draw line from (0,0) to mouse position with a "hang" in the middle private void AdjustPath(double x, double y) { if (_path == null) { _path = new Path(); _path.Stroke = new SolidColorBrush(Colors.Blue); _path.StrokeThickness = 2; cvCanvas.Children.Add(_path); _bs = new BezierSegment(new Point(0, 0), new Point(0, 0), new Point(0, 0), true); PathSegmentCollection psCollection = new PathSegmentCollection(); psCollection.Add(_bs); _pFigure = new PathFigure(); _pFigure.Segments = psCollection; _pFigure.StartPoint = new Point(0, 0); PathFigureCollection pfCollection = new PathFigureCollection(); pfCollection.Add(_pFigure); PathGeometry pathGeometry = new PathGeometry(); pathGeometry.Figures = pfCollection; _path.Data = pathGeometry; } double bottomOfCurveX = ((x / 2)); double bottomOfCurveY = (y + (x * 1.25)); _bs.Point3 = new Point(x, y); if (_sb == null) { _paPoint2 = new PointAnimation(); _paPoint2.From = _bs.Point2; _paPoint2.To = new Point(bottomOfCurveX, bottomOfCurveY); _paPoint2.Duration = new Duration(TimeSpan.FromMilliseconds(1000)); _eEase = new ElasticEase(); _paPoint2.EasingFunction = _eEase; _sb = new Storyboard(); Storyboard.SetTarget(_paPoint2, _path); Storyboard.SetTargetProperty(_paPoint2, new PropertyPath("Data.Figures[0].Segments[0].Point2")); _sb.Children.Add(_paPoint2); _sb.Begin(this); } _paPoint2.From = _bs.Point2; _paPoint2.To = new Point(bottomOfCurveX, bottomOfCurveY); _sb.Begin(this); }
