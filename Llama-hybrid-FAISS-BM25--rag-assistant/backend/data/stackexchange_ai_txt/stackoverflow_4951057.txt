[site]: stackoverflow
[post_id]: 4951057
[parent_id]: 4944156
[tags]: 
It turns out that there's a provision in the C++ spec that explicitly disallows specializing a template class or function nested inside of a template class unless you also explicitly specialize the outer template as well. Visual Studio doesn't enforce this rule, hence the confusion with the previous example, but g++ certainly does. If you want to specialize the template, your options will either be to also specialize the outer template or to somehow fake up the behavior of specialization by having the method dispatch to one of two different implementations based on the template parameter. Neither of these are very satisfying, I know, but unfortunately the language is designed weirdly in some template corners. :-( One way that you can emulate the behavior of the explicit specialization is to use a technique called tag dispatching . The idea is that we'll make a very simple struct that looks like this: template struct Box {}; This type is completely empty. It's not meant to be used directly, but rather is just a way of embedding an integer into the type system. In particular, Box is not the same type as Box , etc. Next, in your list class, define two functions that look like this, preferably marked private: template void doLoad(const char* file, Box ); void doLoad(const char* file, Box ); These two functions are overloads of one another, distinguishable only by their final parameter, which is either a Box in the template case or a Box in the non-template case. Note that the parameters don't have names. This is an arbitrary decision, but since we're not planning on actually reading the parameters, we don't need them. The intuition behind these functions is that this first function will be the "catch-all" implementation that will work for any N except 2. The second version will contain the implementation of loading for the case where N == 2 . Finally, implement load as follows: template template void List ::load(const char* file) { doLoad(file, Box ()); } How does this work? This function takes in a parameter, and then calls doLoad forwarding that parameter as the first argument and passing a temporary Box as the second argument. If N is not two, then this is a call to the template version of doLoad , which is the catch-all handler. If, on the other hand, N is two, then this will call the non-template version of doLoad , because non-template functions have priority over template functions during overload resolution. In short, the implementation of load just becomes a trampoline to forward you to the correct of the two implementations. You can then put the logic in the appropriate doLoad function to get the behavior you want. Hope this helps!
