[site]: stackoverflow
[post_id]: 2585759
[parent_id]: 2585571
[tags]: 
You can do that via reflection without too much trouble, and I am sure that by the time I post this there will be answers that tell you exactly how to do that. But I personally don't like the reflection option. I prefer to maintain object invariants for all of the object's members through a variety of means. For string members, the invariant is often that it not be null, and sometimes there are maximum length requirements as well (for storage in a database, for example). Other members have other sorts of invariants. The first step is to create a method that checks all the invariants that you define for the object. [Conditional("DEBUG")] private void CheckObjectInvariant() { Debug.Assert(name != null); Debug.Assert(name.Length Then you call this after any method that manipulates the object in any way. Since it is decorated with the ConditionalAttribute , none of these calls will appear in the release version of the application. Then you just have to make sure that none of the code allows any violations of these invariants. This means that the string fields need to have either initializers in their declarations or they need to be set in all the constructors for the object. A special problem, and the one that probably motivated this question, is what to do about automatic properties. public string Name { get; set; } Obviously, this can be set to null at any time, and there's nothing you can do about that. There are two options with regard to automatic properties. First, you can just not use them at all. This avoids the problem entirely. Second, you can just allow any possible string value. That is, any code that uses that property has to expect nulls, 10 mb strings or anything in between. Even if you go with the reflection option to remove nulls, you still have to know when to call the magic-null-removal method on the object to avoid NullReferenceException s, so you haven't really bought anything that way.
