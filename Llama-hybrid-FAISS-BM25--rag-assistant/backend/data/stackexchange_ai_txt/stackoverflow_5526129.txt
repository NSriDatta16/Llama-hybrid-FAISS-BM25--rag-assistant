[site]: stackoverflow
[post_id]: 5526129
[parent_id]: 
[tags]: 
PHP why is continue n slower than using break

Please consider the following code: $start = microtime(); for($i = 2; $i Given that the above code effectively uses continue 2 to break the inner loop and skip any code post the inner loop, why does the following code on average execute faster when it appears to do more: $start = microtime(); for($i = 2; $i Thanks for any input. __ _ __ Update __ _ __ _ __ _ __ _ Thanks for the feedback but we seem to have missed the point. Regardless of if this is good programming practice I was trying to understand why the performance difference (which is tiny but consistent) is not within the bias I expected. The passing of true to microtime seems insignificant as both samples are measured using the same method with the same overhead and the same inaccuracy. More than one run was tested, as implied by use of the word average. Just for illustration please consider the following small samples using microtime(true) which shows the same pattern as using microtime(). I know this is a small sample but the pattern is quite clear: Continue 0.00037288665771484 0.00048208236694336 0.00046110153198242 0.00039386749267578 0.0003662109375 Break 0.00033903121948242 0.00035715103149414 0.00033307075500488 0.00034403800964355 0.00032901763916016 Thanks for looking, and thanks for any further feedback. __ _ ___ UPDATE Further investigation __ _ __ _ __ _ ___ Interestingly if the echo statements are removed from the code the continue performs faster, with the echo statements in place break is faster. Please consider the following code sample, and consider that the results are in conflict dependant on if the echo statements are removed or not: Continue Mean " . (array_sum($continueStats) / count($continueStats)); echo " Break Mean " . (array_sum($breakStats) / count($breakStats)); function doBreakTest() { $start = microtime(true); for($i = 2; $i Echo statements present : Continue Mean 0.00014134283065796 Break Mean 0.00012669243812561 Echo statements not present : Continue Mean 0.00011746988296509 Break Mean 0.00013022310733795 Note that by removing the echo statement from the break and flag test we also remove the ($flag === true) check, so the load should reduce, but continue in this case still wins. W So in a pure continue n versus break + flag scenario, it appears that continue n is the faster contstruct. But add an equal number of identical echo statements, and the continue n performance flags. This makes sense to me logically that continue n should be faster, but I would have expected to see the same with the echo statements present. This is clearly a difference in the generated opcodes, and the position of the echo statement (inner loop vs outer loop) does anyone know a way of seeing the opcodes generated? This I suppose is ultimatley what I need as I am trying to understand what is happening internally. Thanks :)
