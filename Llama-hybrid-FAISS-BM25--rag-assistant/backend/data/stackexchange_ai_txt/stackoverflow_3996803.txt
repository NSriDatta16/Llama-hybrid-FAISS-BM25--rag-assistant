[site]: stackoverflow
[post_id]: 3996803
[parent_id]: 3995942
[tags]: 
This isn't an answer to your question proper, but my experience with embedding of functional style into imperative languages has been horrid. While the code can be almost as concise, it retains the complexity of reasoning found in imperative languages. The complexity of the embedding usually requires the most intimate knowledge of the details and corner cases of the language. This greatly increases the cost of abstraction, as these things must always be taken into careful consideration. And with a cost of abstraction so high, it is easier just to put a side-effectful function in a lazy stream generator and then die of subtle bugs. An example from FC++: struct Insert : public CFunType ,List > { List operator()( int x, const List & l ) const { if( null(l) || (x > head(l)) ) return cons( x, l ); else return cons( head(l), curry2(Insert(),x,tail(l)) ); } }; struct Isort : public CFunType ,List > { List operator()( const List & l ) const { return foldr( Insert(), List (), l ); } }; I believe this is trying to express the following Haskell code: -- transliterated, and generalized insert :: (Ord a) => a -> [a] -> [a] insert x [] = [x] insert x (a:as) | x > a = x:a:as | otherwise = a:insert x as isort :: (Ord a) => [a] -> [a] isort = foldr insert [] I will leave you to judge the complexity of the approach as your program grows. I consider code generation a much more attractive approach. You can restrict yourself to a miniscule subset of your target language, making it easy to port to a different target language. The cost of abstraction in a honest functional language is nearly zero, since, after all, they were designed for that (just as abstracting over imperative code in an imperative language is fairly cheap).
