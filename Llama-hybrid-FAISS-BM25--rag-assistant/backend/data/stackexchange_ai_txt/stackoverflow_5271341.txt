[site]: stackoverflow
[post_id]: 5271341
[parent_id]: 5271087
[tags]: 
Note that Microsoft recommend you use XPath also, here is their help page for the GetElementsByTag method, and note the comment towards the middle recommending the use of SelectNodes instead (which is XPath). http://msdn.microsoft.com/en-us/library/dc0c9ekk.aspx A variation of your method, written with XPath, would be: public static ArrayList getTwitterHandles(String ocXML) { ArrayList thisList = new ArrayList(); XmlDocument thisXmlDoc = new XmlDocument(); thisXmlDoc.LoadXml(ocXML); //get Companies XmlNodeList ocNodesCompany = thisXmlDoc.SelectNodes("//Company"); foreach (XmlElement element in ocNodesCompany) { thisList.Add(element.InnerText); } //Get Organisations XmlNodeList ocNodesOrgs = thisXmlDoc.SelectNodes("//Organization"); foreach (XmlElement element in ocNodesOrgs) { thisList.Add(element.InnerText); } //Get Organisations return thisList; } Note that the above implements what I believe is the functionality you have in your example - which is not quite the same as the xpath you've tried. Essentially in XPath "//" means any parent nodes, so "//Company" will pick up ANY subnode of the root you pass in that has a name of Company. If you only want specific Company nodes, then you can be more specific: XmlNodeList ocNodesCompany = thisXmlDoc.SelectNodes("//Company"); becomes XmlNodeList ocNodesCompany = thisXmlDoc.SelectNodes("/OpenCalaisSimple/CalaisSimpleOutputFormat/Company"); Note the key difference is that there is only ONE forward slash at the beginning. I've just tested both variations and they work great. If you're handling XML files then I would strongly recommend you read up on, and become a guru, of XPath, it's exceptionally handy for allowing you to rapidly write code to parse through XML files and pick out precisely what you need (though I should add it's not the only way to do it and it is certainly not appropriate for all circumstances of course :) ) Hope this helps.
