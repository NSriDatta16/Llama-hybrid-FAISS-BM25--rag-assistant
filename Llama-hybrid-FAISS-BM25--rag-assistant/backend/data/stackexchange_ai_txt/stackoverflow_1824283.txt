[site]: stackoverflow
[post_id]: 1824283
[parent_id]: 1824245
[tags]: 
Modify it to add a second call to printf and you'll see a different value from the first time. Compile it with optimizations turned on and you'll see another set of values. Do anything with the value and you're stepping into undefined territory, which means that the compiler is free to summon demons through your nasal passages. On my system, I see 50 and then 0 ; with optimizations I see 0 and then 32767 . If you make the local variable static , then you can return its address since it becomes just like a global (but remember that there is only one instance of it). When a function returns, the local storage it was using on the stack is now considered "unused" by the program, since the stack doesn't go that high anymore. Typically, though, the values are still there, since there's no urgent need to clear them. The memory is also still owned by the program, since there's no sense in returning memory to the operating system a few bytes at a time. So for your specific example, under the circumstances in which you compiled it, the memory pointed to still contains the value 50 . Officially, though, the value of *p is indeterminate , and attempts to use it result in undefined behavior. One existential crisis of the C language is how on the one hand, it says nothing about the stack and the various bits of hexadecimal sludge that make up a running process; on the other hand, it's necessary to understand those in order to protect yourself from crashes, buffer overflows, and undefined behavior. Just remember that you're lucky that GCC gives a warning for this.
