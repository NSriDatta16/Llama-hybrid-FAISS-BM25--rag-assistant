[site]: stackoverflow
[post_id]: 2598355
[parent_id]: 2596425
[tags]: 
The one thing that's not yet been explored by the answers is how things get from start() to run() , which is simultaneously both simple and complex. In simplistic terms, the start() method calls a native method ( start0 in the OpenJDK implementation) which allocates some memory for a new stack and asks the OS to run a thread with that space as stack and with a plain C++ function ( thread_entry in the OpenJDK implementation) as implementation function. That function in turn does the thunk back into Java to call the run() method on the Thread object. The pattern at the low level (asking the OS to start a new thread on a stack and with a function) should be familiar to anyone doing native threads in either POSIX systems or Windows. The detail makes it all a lot more complex, with all the error handling and obscure edge cases that need to be handled. If you're curious, read the OpenJDK sources, paying particular attention to Thread.java , JVM_StartThread in jvm.cpp and the JavaThread class in thread.cpp and thread.hpp . Hopefully this answer gives you enough detail for you to find your own way...
