[site]: stackoverflow
[post_id]: 3358890
[parent_id]: 3358254
[tags]: 
You need a global way to access the onPlayerStateChange method of your object. When you assign me as var me = this; , the variable me is only valid inside the object method where it is created. However, the Youtube player API requires a function that is accessible globally, since the actual call is coming from Flash and it has no direct reference to your JavaScript function. I found a very helpful blog post by James Coglan in which he discussed a nice way to communicate with the Youtube's JavaScript API and manage events for multiple videos. I have released a JavaScript wrapper library using his ideas at http://github.com/AnuragMishra/YoutubePlayer . Feel free to checkout the code. The underlying idea is simple - store all instances of the player object on the constructor. For example: function Player(id) { // id of the placeholder div that gets replaced // the element in which the flash video resides will // replace the placeholder div and take over its id this.id = id; Player.instances.push(this); } Player.instances = []; When passing a string as a callback, use a string of the form: "Player.dispatchEvent('playerId')" When the flash player evals this string, it should return a function. That function is the callback that will ultimately receive the playback event id. Player.dispatchEvent = function(id) { var player = ..; // search player object using id in "instances" return function(eventId) { // this is the callback that Flash talks to player.notify(eventId); }; }; When the flash player has loaded the video, the global onYoutubePlayerReady function is called. Inside that method, setup the event handlers for listening to playback events. function onYouTubePlayerReady(id) { var player = ..; // find player in "instances" // replace with player.id var callback = "YoutubePlayer.dispatchEvent({id})"; callback = callback.replace("{id}", player.id); player.addEventListener('onStateChange', callback); } See a working example here. .
