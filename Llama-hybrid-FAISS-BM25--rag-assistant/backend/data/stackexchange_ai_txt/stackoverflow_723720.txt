[site]: stackoverflow
[post_id]: 723720
[parent_id]: 723702
[tags]: 
What you ultimately want, i think, is to have the user type Vector And depending on N , the user will get slight different things. The first will not fulfill that, but the second will, on the price of code duplication. What you can do is to invert the inheritance: template struct VectorBase { }; template struct VectorBase { }; template struct VectorBase { }; template struct Vector : VectorBase { }; And implement the few functions that depend only on N being some specific value in the appropriate base-class. You may add a protected destructor into them, to prevent users deleting instances of Vector through pointers to VectorBase (normally they should not even be able to name VectorBase : Put those bases in some implementation namespace, like detail ). Another idea is to combine this solution with the one mentioned in another answer. Inherit privately (instead of publicly as above) and add wrapper functions into the derived class that call the implementations of the base-class. Yet another idea is to use just one class and then enable_if (using boost::enable_if ) to enable or disable them for particular values of N , or use a int-to-type transformer like this which is much simplier struct anyi { }; template struct i2t : anyi { }; template struct Vector { // forward to the "real" function void some_special_function() { some_special_function(i2t ()); } private: // case for N == 2 void some_special_function(i2t ) { ... } // case for N == 3 void some_special_function(i2t ) { ... } // general case void some_special_function(anyi) { ... } }; That way, it is completely transparent to the user of Vector . It also won't add any space overhead for compilers doing the empty base class optimization (quite common).
