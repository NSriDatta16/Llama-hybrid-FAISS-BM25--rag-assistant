[site]: stackoverflow
[post_id]: 1863195
[parent_id]: 1863094
[tags]: 
The essential problem is that although storage is ever allocated (with malloc() ) for the results you are trying to return as myfoo and mybar , the pointers to those allocations are not actually returned to main() . As a result, the later call to printf() is quite likely to dump core. The solution is to declare the arguments as ponter to pointer to char , and pass the addresses of myfoo and mybar to fn . Something like this (untested) should do the trick: void fn(char *baz, char **foo, char **bar) { char *pch; /* this is the part I'm having trouble with */ pch = strtok (baz, ":"); *foo = malloc(strlen(pch)+1); /* include space for NUL termination */ strcpy(*foo, pch); pch = strtok (NULL, ":"); *bar = malloc(strlen(pch)+1); /* include space for NUL termination */ strcpy(*bar, pch); return; } int main(void) { char mybaz[] = "hello:world"; char *myfoo, *mybar; fn(mybaz, &myfoo, &mybar); fprintf(stderr, "%s %s", myfoo, mybar); free(myfoo); free(mybar); } Don't forget the free each allocated string at some later point or you will create memory leaks. To do both the malloc() and strcpy() in one call, it would be better to use strdup() , as it also remembers to allocate room for the terminating NUL which you left out of your code as written. *foo = strdup(pch) is much clearer and easier to maintain that the alternative. Since strdup() is POSIX and not ANSI C, you might need to implement it yourself, but the effort is well repaid by the resulting clarity for this kind of usage. The other traditional way to return a string from a C function is for the caller to allocate the storage and provide its address to the function. This is the technique used by sprintf() , for example. It suffers from the problem that there is no way to make such a call site completely safe against buffer overrun bugs caused by the called function assuming more space has been allocated than is actually available. The traditional repair for this problem is to require that a buffer length argument also be passed, and to carefully validate both the actual allocation and the length claimed at the call site in code review. Edit: The actual segfault you are getting is likely to be inside strtok() , not printf() because your sample as written is attempting to pass a string constant to strtok() which must be able to modify the string. This is officially Undefined Behavior. The fix for this issue is to make sure that bybaz is declared as an initialized array, and not as a pointer to char . The initialized array will be located in writable memory, while the string constant is likely to be located in read-only memory. In many cases, string constants are stored in the same part of memory used to hold the executable code itself, and modern systems all try to make it difficult for a program to modify its own running code. In the embedded systems I work on for a living, the code is likely to be stored in a ROM of some sort, and cannot be physically modified.
