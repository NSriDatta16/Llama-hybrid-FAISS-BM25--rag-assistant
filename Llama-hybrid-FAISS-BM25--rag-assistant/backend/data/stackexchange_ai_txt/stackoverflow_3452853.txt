[site]: stackoverflow
[post_id]: 3452853
[parent_id]: 3426537
[tags]: 
I finally got a positive result, but since little discussion was spawned here, my own answer will be brief. The ASGCT_CallTrace structure (and the underlying ASGCT_CallFrame array) can simply be declared in the signal handler, thus existing only the stack: ASGCT_CallTrace trace; JNIEnv *env; global_VM_pointer->AttachCurrentThread((void **) &env, NULL); trace.env_id = env; trace.num_frames = 0; ASGCT_CallFrame storage[25]; trace.frames = storage; The following gets the uContext: ucontext_t uContext; getcontext(&uContext); And then the call is just: AsyncGetCallTrace(&trace, 25, &uContext); I am sure there are some other nuances that I had to take care of in the process, but I did not really document them. I am not sure I can disclose the full current code I have, which successfully asynchronously requests for and obtains stack traces of any java program at fixed intervals. But if someone is interested in or stuck on the same problem, I am now able to help (I think). On the other two issues: [1] If a thread is sleeping and a SIGPROF is generated, the thread handles that signal only after waking up. This is normal, since it is the thread's job to handle the signal. [2] The timer imperfections do not seem to appear anymore. Perhaps I mis-measured.
