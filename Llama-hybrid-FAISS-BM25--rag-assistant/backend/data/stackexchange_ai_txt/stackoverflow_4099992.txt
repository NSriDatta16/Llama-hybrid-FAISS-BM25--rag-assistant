[site]: stackoverflow
[post_id]: 4099992
[parent_id]: 3975826
[tags]: 
Alright, so the reason behind this has been answered already, but in case you were interested in some background: A bit is the smallest unit of storage which the computer can recognize (n.b. not the smallest number). A bit is either a 0 or a 1 . A byte is an 8 bit data type, meaning it is composed of 8 bit strings such as 10101010 or 0001110 . Using simple combinatorics, we know that there are 2^8 = 256 possible combinations of bytes. If we wanted to only represent positive numbers, we could do a straight conversion from base 2 to base 10. The way that works is, for a bit string b7b6b5b4b3b2b1b0 the number in decimal is dec = sum from n=0 to 7 of (bn * 2^n) . By only representing positive numbers ( an unsigned byte ) we can represent 256 possible numbers in the range 0 to 255 inclusive. The problem comes in when we want to represent signed data. A naive approach (n.b. this is for background, not the way java does it) is to take the left most bit and make it the sign bit where 1 is negative and 0 is positive. So for example 00010110 would be 21 and 10010110 would be -21 . There are two major problems with such a system. The first is that 00000000 is 0 and 10000000 is -0 , but as everyone knows, there is no -0 that is somehow different from 0 , but such a system allows for the number and 0 â‰  -0 . The second problem is that, due to representing two zeroes, the system only allows for representing numbers from -127 to 127 , a range of only 254 ( 2 less than before). A much better system (and the one which most systems use) is called Two's Compliment . In Two's Compliment, the positive numbers are represented with their normal bit string where the leftmost bit is 0. Negative numbers are represented with the left most bit as a 1 and then calculating the two's compliment for that number (from whence the system gets its name) Although mathematically it is a slightly more complex process, because we are dealing with the number 2 there are some short cuts. Essentially, you can take the positive version and (from right to left) take all zeroes until you hit a 1. Copy those zeroes and one, then take the NOT of the rest of the bits. So for example, to get -21 , positive 21 is 00010110 we take the 10 and not the rest to get 11101010 , the two's compliment representation of -21 . Two's Compliment is a much more difficult system to grasp, but it avoids the previously stated problems, and for an n-bit number can represent all digits from -2^(n-1) to 2^(n-1)-1 which for our byte means -128 to 127 (hence the problem in this question) A couple of notes: - This is for integer representation only. Real number representation is another system entirely (if there is a request for it, I'm sure we could make a number representation CW post) - Wikipedia has a couple more number representation systems if you're interested.
