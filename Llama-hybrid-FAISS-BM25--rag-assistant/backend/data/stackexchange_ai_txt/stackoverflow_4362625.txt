[site]: stackoverflow
[post_id]: 4362625
[parent_id]: 4362525
[tags]: 
How can I know if after calling recv first time the read buffer is empty or not? Even the first time (after accepting a client), the recv can block and fail if the client connection has been lost. You must either: use select or poll (BSD sockets) or some OS-specific equivalent, which can tell you whether there is data available on specific socket descriptors (as well as exception conditions, and buffer space you can write more output to) you can set the socket to be nonblocking, such that recv will only return whatever is immediately available (possibly nothing) you can create a thread that you can afford to have block recv -ing data, knowing other threads will be doing the other work you're concerned to continue with How can I know how many bytes I have readed into recv_buffer? I can't use strlen because the message I receive can contain null bytes. recv() returns the number of bytes read, or -1 on error. Note that TCP is a byte stream protocol, which means that you're only guaranteed to be able to read and write bytes from it in the correct order, but the message boundaries are not guaranteed to be preserved. So, even if the sender has made a large single write to their socket, it can be fragmented en route and arrive in several smaller blocks, or several smaller send() / write() s can be consolidated and retrieved by one recv() / read() . For that reason, make sure you loop calling recv until you either get all the data you need (i.e. a complete logical message you can process) or an error. You should be prepared/able to handle getting part/all of subsequent send s from your client (if you don't have a protocol where each side only sends after getting a complete message from the other, and are not using headers with message lengths). Note that doing recvs for the message header (with length) then the body can result in a lot more calls to recv() , with a potential adverse affect on performance. These reliability issues are often ignored. They manifest less often when on a single host, a reliable and fast LAN, with less routers and switches involved, and fewer or non-concurrent messages. Then they may break under load and over more complex networks.
