[site]: stackoverflow
[post_id]: 928892
[parent_id]: 928619
[tags]: 
I'd recommend against implementing your new project in F# until you get a better handle on the language, or you'll just end up writing C# code in an F# syntax. At least for projects at work, its better to use a tool you know than using company money to experiment with a new technology. But, since you asked, I'd use a mailbox processor to act as a thread-safe message handling queue for all sensors input. The message queue can recompute statistics for each message is receives. Off the top of my head, I'm thinking of a setup like this: type SensorMsg = | Fetch of 'a AsyncReplyChannel | Post of 'b | Die type SensorMessageQueue (emptyStats : 'a, compute : 'a -> 'b -> 'a) = let queue = MailboxProcessor.Start(fun inbox -> let rec loop stats = async { let! msg = inbox.Receive() match msg with | Die -> return () | Post(x) -> return! loop (compute stats x) | Fetch(x) -> x.Reply(stats); return! loop stats } loop emptyStats ) member this.Post(x) = queue.Post(Post(x)) member this.Fetch() = queue.PostAndReply(fun replyChannel -> Fetch(replyChannel)) member this.Die() = queue.Post(Die) Something like this could hold real-time running statistics of your sensors. For example, lets say I wanted to post something that would hold a running average: let averager = SensorMessageQueue( (0, 0), (* initial state of sum, total *) (fun (sum, total) input -> sum + input, total + 1) ) averager.Post(75) averager.Post(90) averager.Post(80) let x = averager.Fetch() (* returns (245, 3) *) averager.Post(100) let y = averager.Fetch() (* returns (345, 4) *) A setup like this is relatively easy to work with, thread-safe, and uses no mutable state (all "state" exists in the closure's arguments). If you think about it, this is basically a glorified seq.unfold, only implemented using mailbox processor. It might be overkill, might be just right, or could be exactly what you need for your project, it depends on your requirements.
