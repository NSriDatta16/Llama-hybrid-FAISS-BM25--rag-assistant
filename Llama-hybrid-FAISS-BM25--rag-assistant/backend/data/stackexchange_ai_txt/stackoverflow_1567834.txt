[site]: stackoverflow
[post_id]: 1567834
[parent_id]: 
[tags]: 
Why is the compiler not selecting my function-template overload in the following example?

Given the following function templates: #include #include struct Base { }; struct Derived : Base { }; // #1 template void f(const T1& a, const T2& b) { }; // #2 template void f(const std::vector >& v, Base* p) { }; Why is it that the following code always invokes overload #1 instead of overload #2? int main() { std::vector > v; Derived derived; f(100, 200); // clearly calls overload #1 f(v, &derived); // always calls overload #1 return 0; } Given that the second parameter of f is a derived type of Base , I was hoping that the compiler would choose overload #2 as it is a better match than the generic type in overload #1. Are there any techniques that I could use to rewrite these functions so that the user can write code as displayed in the main function (i.e., leveraging compiler-deduction of argument types)?
