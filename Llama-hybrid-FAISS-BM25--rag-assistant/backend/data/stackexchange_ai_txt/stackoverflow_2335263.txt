[site]: stackoverflow
[post_id]: 2335263
[parent_id]: 2335160
[tags]: 
The explaination is given in answers to this question . To sum it up here: Functions in Python are a kind of object. Because they are a kind of object, they act like objects when instantiated. A function, if defined with a mutable attribute as a default argument, is exactly the same as a class with a static attribute that is a mutable list. Lennart Regebro has a good explanation and the answer to the question by Roberto Liffredo is excellent. To adapt Lennart's answer ... if I have a BananaBunch class: class BananaBunch: bananas = [] def addBanana(self, banana): self.bananas.append(banana) bunch = BananaBunch() >>> bunch >>> bunch.addBanana(1) >>> bunch.bananas [1] >>> for i in range(6): bunch.addBanana("Banana #" + i) >>> for i in range(6): bunch.addBanana("Banana #" + str(i)) >>> bunch.bananas [1, 'Banana #0', 'Banana #1', 'Banana #2', 'Banana #3', 'Banana #4', 'Banana #5'] // And for review ... //If I then add something to the BananaBunch class ... >>> BananaBunch.bananas.append("A mutated banana") //My own bunch is suddenly corrupted. :-) >>> bunch.bananas [1, 'Banana #0', 'Banana #1', 'Banana #2', 'Banana #3', 'Banana #4', 'Banana #5', 'A mutated banana'] How does this apply to functions? Functions in Python are objects . This bears repeating. Functions in Python are object s. So when you create a function, you are creating an object. When you give a function a mutable default value, you are populating that object's attribute with a mutable value, and every time you call that function you are operating on the same attribute. So if you are using a mutable call (like append), then you are modifying the same object, just as if you were adding bananas to the bunch object.
