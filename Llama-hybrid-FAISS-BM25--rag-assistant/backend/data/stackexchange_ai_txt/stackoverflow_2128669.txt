[site]: stackoverflow
[post_id]: 2128669
[parent_id]: 2125591
[tags]: 
Value types such as int etc live on the stack. Reference types live on the managed heap however if a reference type has for example has an instance variable of type double, it will live along with its object on the heap No, this is not correct. A correct statement is "Local variables and formal parameters of value type which are neither directly in an iterator block nor closed-over outer variables of a lambda or anonymous method are allocated on the system stack of the executing thread in the Microsoft implementation of the CLI and the Microsoft implementation of C#." There is no requirement that any version of C# or any version of the CLI use the system stack for anything. Of course we do so because it is a convenient data structure for local variables and formal parameters of value type which are not directly in an iterator block or closed-over outer variables of a lambda or anonymous method. See my articles on this subject for a discussion of (1) why this is is an implementation detail, and (2) what benefits we get from this implementation choice, and (3) what restrictions the desire to make this implementation choice drives into the language design. http://blogs.msdn.com/ericlippert/archive/2009/04/27/the-stack-is-an-implementation-detail.aspx http://blogs.msdn.com/ericlippert/archive/2009/05/04/the-stack-is-an-implementation-detail-part-two.aspx Person is a reference type, when passed to UselessUtilityClass -- this is where I go - nuts... Take a deep breath. A variable is a storage location. Each storage location has an associated type. A storage location whose associated type is a reference type may contain a reference to an object of that type, or may contain a null reference. A storage location whose associated type is a value type always contains an object of that type. The value of a variable is the contents of the storage location . the VARIABLE p which is an instance of the Person reference is passed by VALUE, The variable p is a storage location. It contains a reference to an instance of Person. Therefore, the value of the variable is a reference to a Person. That value -- a reference to an instance -- is passed to the callee. Now the other variable, which you have confusingly also called "p", contains the same value -- the value is a reference to a particular object. Now, it is also possible to pass a reference to a variable , which many people find confusing. A better way to think about it is when you say void Foo(ref int x) { x = 10; } ... int p = 3456; Foo(ref p); what this means is "x is an alias for variable p". That is, x and p are two names for the same variable . So whatever the value of p is, that's also the value of x, because they are two names for the same storage location. Make sense now?
