[site]: stackoverflow
[post_id]: 956684
[parent_id]: 956658
[tags]: 
What you want is a template template parameter: template class CollectionType, class ItemType> class Test { public: CollectionType m_collection; }; What we did here is specifying that the first template parameter, i.e. CollectionType , is a type template. Therefore, Test can only be instantiated with a type that is itself a template. However, as @Binary Worrier pointed in the comments, this won't work with STL containers since they have 2 template parameters: one for the elements type, the other one for the type of the allocator used for managing storage allocation (which has a default value). Consequently, you need to change the first template parameter so that it has two parameters: template class CollectionType, class ItemType> class Test { public: CollectionType m_collection; }; But wait, that won't work either! Indeed, CollectionType awaits another parameter, the allocator... So now you have two solutions: 1 . Enforce the use of a particular allocator: CollectionType > m_collection 2 . Add a template parameter for the allocator to your class: template class CollectionType, class ItemType, class Allocator = std::allocator > class Test { public: CollectionType m_collection; }; So as you see, you end up with something rather complicated, which seems really twisted to deal with STL containers... My advice: see Greg Rogers' answer for a better approach :)!
