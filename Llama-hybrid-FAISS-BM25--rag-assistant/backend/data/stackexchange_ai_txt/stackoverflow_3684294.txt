[site]: stackoverflow
[post_id]: 3684294
[parent_id]: 3684151
[tags]: 
Short answer: No. What you want is impossible. The long answer is that what you think of as the "address" of an object is anything but. life.State.step is merely one of the ways to get a reference to the object at that particular time . The same "address" at a later point can give you a different object, or it could be an error. What's more, this "address" of yours depends on the context . In life.State.step , the end object depends not just on what life.State and life.State.step are, but what object the name life refers to in that namespace . Specific answers to your requests: The end object has no way whatsoever of finding out how you referred to it, and neither has any code that you give the object to. The "address" is not a name, it's not tied to the object, it's merely an arbitrary Python expression that results in an object reference (as all expressions do.) You can only make this work, barely , with specific objects that aren't expected to move around, such as classes and modules. Even so, those objects can move around, and frequently do move around, so what you attempt is likely to break. As mentioned, the "address" depends on many things, but this part is fairly easy: __import__() and getattr() can give you these things. They will, however, be extremely fragile, especially when there's more involved than just attribute access. It can only remotely work with things that are in modules. "Shortening" the name requires examining every possible name , meaning all modules and all local names, and all attributes of them , recrusively. It would be a very slow and time-consuming process, and extremely fragile in the face of anything with a __getattr__ or __getattribute__ method, or with properties that do more than return a value. is the same thing as 3.
