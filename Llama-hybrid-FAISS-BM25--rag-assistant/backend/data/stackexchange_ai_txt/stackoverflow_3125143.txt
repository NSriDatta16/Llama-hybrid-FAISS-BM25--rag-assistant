[site]: stackoverflow
[post_id]: 3125143
[parent_id]: 3124837
[tags]: 
Let's start backward: How is it possible to implement threading in a library ? It isn't, at least not in (pure) C++. This requires language support (the compiler is only an implementation). At the moment 2 things are used: assembly code for some parts (like in the pthread library) specific compiler instructions for others (dependent on the compiler and platform) Both are brittle and require a tremendous amount of work for portability. Basically it means lot of #ifdef portions in the code to test for the compiler and targetted architecture, test for the support of some directives etc... That is why it was deemed necessary to add threading support in C++0x. How do I do multithreading ? Even before you choose a library, you should choose a method. There are 2 ways of programming multithreaded applications (and you can combine them): Communicate by sharing : this means using mutexes, atomic operations, etc... you can use pthread on Linux platforms, but I would recommend Boost.Thread (among others) for its portability. Share by communicating : more recent, and adapted to distributed computations, this stems from the functional languages. This means passing messages from one thread to another and not sharing any resources. You can use FastFlow or Intel's Thread Building Blocks aka TBB . You can conceivably merge the two, but it would be better not to. Personally I have found the description of FastFlow totally awesome: it encourages lock-free programming. Also, the main advantage of the second method is that it's better adapted to multi-processes programming and scales to distributed environments. To begin with, I would recommend focusing on either one and build some applications with it. When you're comfortable you may try out the other, but be ready to start anew, they are that different.
