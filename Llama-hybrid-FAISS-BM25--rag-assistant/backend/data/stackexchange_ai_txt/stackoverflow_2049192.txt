[site]: stackoverflow
[post_id]: 2049192
[parent_id]: 1867944
[tags]: 
I was able to create a workaround for this, but had to go to extreme measures to do so. It appears that the behavior we are seeing occurs because the Click event is being fired both from the MouseDown and the MouseUp events (instead of just the mouse up as it would in Windows or previous versions). To show this, you can start by tapping on the checkbox, leaving your finger on the screen and dragging off the check box. It will become checked from the MouseDown event and will stay checked because the MouseUp event is not fired when you lift your finger from a different position. The same works for tapping off the checkbox and dragging on. In order to prevent the double click behavior you must suppress one of the MouseDown or MouseUp events. I ended up creating a control that inherited the TreeView and used WndProcHooker to hook the OnMouseDown method and mark it as handled so that the MouseDown Event never actually gets fired. I figured that made the most sense (you must have your finger over the checkbox when you lift it). Here is a link to the MSDN article about the WndProcHooker. Below is my code for my TreeViewInherit class. While this works, I am still astonished that these are the lengths I have to go to to get this working. Additionally, I am not looking forward to the day MS fixes this and thus breaks my workaround in the process. Imports System.Windows.Forms Imports Microsoft.WindowsCE.Forms Public Class TreeViewInherit Inherits System.Windows.Forms.TreeView #Region " Variables " Private mBlnHandleMouseDown As Boolean #End Region #Region " Methods " Public Sub New() MyBase.New() 'Set the Handle Mouse Down based on the OS. if 6.5 and up, then handle it. mBlnHandleMouseDown = (System.Environment.OSVersion.Version.Major >= 5 AndAlso System.Environment.OSVersion.Version.Minor >= 2 AndAlso System.Environment.OSVersion.Version.Build >= 21234) If mBlnHandleMouseDown Then WndProcHooker.HookWndProc(Me, New WndProcHooker.WndProcCallback(AddressOf Me.WM_LButtonDown_Handler), Win32.WM_LBUTTONDOWN) End If End Sub Protected Overrides Sub OnMouseDown(ByVal e As System.Windows.Forms.MouseEventArgs) 'Don't Call the Base to prevent the extra event from firing If Not mBlnHandleMouseDown Then MyBase.OnMouseDown(e) End If End Sub #End Region #Region " Events " Private Function WM_LButtonDown_Handler(ByVal hwnd As IntPtr, ByVal msg As Integer, ByVal wParam As Integer, ByVal lParam As Integer, ByRef handled As Boolean) As Integer Try Me.Capture = False Dim lastCursorCoordinates As Win32.POINT = Win32.LParamToPoint(lParam) If Me.ClientRectangle.Contains(lastCursorCoordinates.X, lastCursorCoordinates.Y) Then OnMouseDown(New MouseEventArgs(MouseButtons.Left, 1, lastCursorCoordinates.X, lastCursorCoordinates.Y, 0)) End If handled = True Return 0 Catch ex As Exception Throw End Try End Function #End Region End Class Good Luck!
