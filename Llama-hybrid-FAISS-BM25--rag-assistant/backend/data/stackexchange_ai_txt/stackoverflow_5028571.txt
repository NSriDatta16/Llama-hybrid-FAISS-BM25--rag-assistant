[site]: stackoverflow
[post_id]: 5028571
[parent_id]: 
[tags]: 
Memory allocator causing mysterious pause

I should probably be sleeping. Instead, I'm coding. Specifically, I've written The World's Worse Memory Allocator(TM). It's got an array of bytes (chars) to use for memory for stuff; it's got a list of used memory blocks; it's got an index to allocate memory from. It even allocates memory. Deallocates, not so much. That shouldn't be a problem, though, as to the best of my knowledge, nothing is new'd outside of the array and list classes and the destructor for those is called the proper number of times. Edit: The problem is, the program enters what appears to be an infinite loop somewhere in the c++ back-end code itself, shortly after the MemoryManager's destructor is called. In fact, if the MemoryManager is put inside the Try-Catch block, the program never makes it outside the Try-Catch block. I need to know why and how to fix it, please, thanks. This is the main loop which is doing terribly important allocations: int _tmain(int argc, _TCHAR* argv[]) { MemoryManager memoryManager = MemoryManager(1024); try { int * n; for (int t = 0; t And the MemoryManager, in all it's newbie glory: // A memory manager #pragma once #include "stdafx.h" #include "Array.h" #include "SmartPointer.h" class MemBlock { public: unsigned int Start; unsigned int End; MemBlock() { Start = 0; End = 0; } MemBlock(unsigned int start, unsigned int end) { Start = start; End = end; } ~MemBlock() { } }; class MemoryManager { private: Array memory; List memBlocks; int index; public: MemoryManager(unsigned int size) { memory = Array (size); memBlocks = List (size / 24); index = 0; } ~MemoryManager() { } void* Allocate(unsigned int size) { memBlocks.Add(&MemBlock(index, index + size)); void* r = (void*)(memory.insecureAccess + index); index += size; return r; } }; Thanks.
