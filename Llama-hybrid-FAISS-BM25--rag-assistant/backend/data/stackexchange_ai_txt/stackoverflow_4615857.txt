[site]: stackoverflow
[post_id]: 4615857
[parent_id]: 4615604
[tags]: 
I have to have Object o referencing this as I have other code to follow which depends on o. What do you mean? Are you aware that anywhere you have code that expects an Object , it can accept an ITest ? This is one of the big benefits of inheritance. As for the MissingMemberException : could you provide the definitions for ITest , Test , and Class1 ? If the Test type implements ITest.GetMember using a method with a different name (this is legal in VB.NET), that could possibly explain the exceptionâ€”though that doesn't appear to be precisely where the problem lies here. Seeing the relevant code from your Test and Class1 classes in particular should help a good deal. Edit : Based on your update, here's what's going on. You're mixing VB.NET's late binding feature with .NET's concept of interfaces . Both are supported in VB.NET, but they're not the same thing. So when you have an Object , you can call any method on it. This will be resolved at run-time. But it has to be a method that actually belongs to the object's type . In the case of Test , there is no GetMember function; there is only an ITest_GetMember function. So to utilize late binding, you would need to call o.ITest_GetMember (and this method would also need to be public, I believe). That said, I strongly advise against mixing interface implementation and late binding in this way . In fact, I would recommend against late binding at all in cases like this where you actually have an interface. I really see no good reason to be casting your strongly-typed ITest variable to one typed as Object ; as I stated before, you can always use an ITest as an Object ( Object is the root of the .NET type hierarchy; you can use anything as Object ), but what you can't always do is use an Object as something else. It just seems like you are sacrificing the usability of your i variable (in the example code you posted) for no good reason. Edit 2 : Come to think of it, are you passing Object references ByRef ? If so, I suppose that could be a legitimate reason (though I'm skeptical that you'd have good reasons for doing that). If that's the case, you'll just need to cast your Object back to an ITest in order to use the members of ITest . (See, since you already have an ITest variable in i , this is why I keep questioning your upcast to Object .)
