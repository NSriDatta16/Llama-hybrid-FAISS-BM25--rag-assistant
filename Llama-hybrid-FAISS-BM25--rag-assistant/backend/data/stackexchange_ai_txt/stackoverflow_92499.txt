[site]: stackoverflow
[post_id]: 92499
[parent_id]: 92001
[tags]: 
For a long time I didn't understand pointers, but I understood array addressing. So I'd usually put together some storage area for objects in an array, and then use an index to that array as the 'pointer' concept. SomeObject store[100]; int a_ptr = 20; SomeObject A = store[a_ptr]; One problem with this approach is that after I modified 'A', I'd have to reassign it to the 'store' array in order for the changes to be permanent: store[a_ptr] = A; Behind the scenes, the programming language was doing several copy-operations. Most of the time this didn't affect performance. It mostly made the code error-prone and repetitive. After I learned to understand pointers, I moved away from implementing the array addressing approach. The analogy is still pretty valid. Just consider that the 'store' array is managed by the programming language's run-time. SomeObject A; SomeObject* a_ptr = &A; // Any changes to a_ptr's contents hereafter will affect // the one-true-object that it addresses. No need to reassign. Nowadays, I only use pointers when I can't legitimately copy an object. There are a bunch of reasons why this might be the case: To avoid an expensive object-copy operation for the sake of performance. Some other factor doesn't permit an object-copy operation. You want a function call to have side-effects on an object (don't pass the object, pass the pointer thereto). In some languages- if you want to return more than one value from a function (though generally avoided).
