[site]: stackoverflow
[post_id]: 5320355
[parent_id]: 5320330
[tags]: 
Basic Example Here is an example from Leonid Shifrin's book Mathematica programming: an advanced introduction It is an excellent resource for this kind of question. See: (1) (2) ClearAll[a, b] a = RandomInteger[{1, 10}]; b := RandomInteger[{1, 10}] Table[a, {5}] {4, 4, 4, 4, 4} Table[b, {5}] {10, 5, 2, 1, 3} Complicated Example The example above may give the impression that once a definition for a symbol is created using Set , its value is fixed, and does not change. This is not so. f = ... assigns to f an expression as it evaluates at the time of assignment . If symbols remain in that evaluated expression, and later their values change, so does the apparent value of f . ClearAll[f, x] f = 2 x; f 2 x x = 7; f 14 x = 3; f 6 It is useful to keep in mind how the rules are stored internally. For symbols assigned a value as symbol = expression , the rules are stored in OwnValues . Usually (but not always), OwnValues contains just one rule. In this particular case, In[84]:= OwnValues[f] Out[84]= {HoldPattern[f] :> 2 x} The important part for us now is the r.h.s., which contains x as a symbol. What really matters for evaluation is this form - the way the rules are stored internally. As long as x did not have a value at the moment of assignment, both Set and SetDelayed produce (create) the same rule above in the global rule base, and that is all that matters. They are, therefore, equivalent in this context. The end result is a symbol f that has a function-like behavior, since its computed value depends on the current value of x . This is not a true function however, since it does not have any parameters, and triggers only changes of the symbol x . Generally, the use of such constructs should be discouraged, since implicit dependencies on global symbols (variables) are just as bad in Mathematica as they are in other languages - they make the code harder to understand and bugs subtler and easier to overlook. Somewhat related discussion can be found here . Set used for functions Set can be used for functions, and sometimes it needs to be. Let me give you an example. Here Mathematica symbolically solves the Sum, and then assigns that to aF(x), which is then used for the plot. ClearAll[aF, x] aF[x_] = Sum[x^n Fibonacci[n], {n, 1, \[Infinity]}]; DiscretePlot[aF[x], {x, 1, 50}] If on the other hand you try to use SetDelayed then you pass each value to be plotted to the Sum function. Not only will this be much slower, but at least on Mathematica 7, it fails entirely. ClearAll[aF, x] aF[x_] := Sum[x^n Fibonacci[n], {n, 1, \[Infinity]}]; DiscretePlot[aF[x], {x, 1, 50}] If one wants to make sure that possible global values for formal parameters ( x here) do not interfere and are ignored during the process of defining a new function, an alternative to Clear is to wrap Block around the definition: ClearAll[aF, x]; x = 1; Block[{x}, aF[x_] = Sum[x^n Fibonacci[n], {n, 1, \[Infinity]}]]; A look at the function's definition confirms that we get what we wanted: ?aF Global`aF aF[x_]=-(x/(-1+x+x^2))
