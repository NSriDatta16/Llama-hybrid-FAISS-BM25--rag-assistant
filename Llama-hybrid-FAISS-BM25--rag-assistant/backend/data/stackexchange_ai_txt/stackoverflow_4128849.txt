[site]: stackoverflow
[post_id]: 4128849
[parent_id]: 4125762
[tags]: 
the for...each construct is not the proper tool to use to gain the specific behavior you are after as the question is worded, without having more features in the Cat object. The classic Iterator is designed to provide just this type of functionality. I think the question illustrates that the design is flawed, more on that latter. Assuming that the there is a sorted list of cats called cats . A List that does not guarantee traversal order would not be a good candidate for iteration, regardless of how the list is traversed. final Iterator iterator = cats.iterator(); while (iterator.hasNext()) { final Cat cat = iterator.next(); this.feedDryCatFood(cat); // special case, if there are no more cats in the list // feed the last one tuna as well. if (!iterator.hasNext()) { this.alsoFeedTuna(cat); } } a better solution would be to have a member method on Cat . Cat.isSpecial() that returns a boolean . This would be more self documenting and move the behavior out of the loop construct. Then you could use a for...each construct with a simple test that is self contained and self documenting. if (cat.isSpecial()) { this.feedTuna(cat); } I think the "last element of a for..each loop" in the question is a red herring. I think the problem is more a design problem than a business logic problem, and the fact that the for...each loop can't accommodate the rule is indicative that a refactoring should occur. This new design would also accommodate multiple "special" cats without any complication to the code. Other more elegant Object Oriented solutions would be the Visitor Pattern or the Chain of Responsibility Pattern . The Visitor Pattern would abstract out the logic of who what the favorite from the Cat and into the Visitor implementation. Same with the Chain of Responsibility. Have a chain of CatFeeder objects, and let them decide whether to "handle" the feeding or pass it on down the chain. Either way would be looser coupling and tighter cohesion.
