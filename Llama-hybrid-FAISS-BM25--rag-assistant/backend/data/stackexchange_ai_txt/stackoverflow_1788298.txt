[site]: stackoverflow
[post_id]: 1788298
[parent_id]: 1788267
[tags]: 
It seems to me you are misunderstanding coupling with (relatively) complex software development. If you are passing the data around to be consumed, be it via a class or more than one, all the consumers can do is to access the public interface of the class with the data. This is fine regarding to coupling, because you can change how are those classes implemented internally without breaking anything as long as you have your interface constant. It is expected that data could have many clients, as long as they don't depend on anything but the specified public interface. You would have a problem with coupling if you accessed private members of the classes, or if you passed a reference of the array another class exposes to be modified by third parties, and so on. It's true though that if you want to change that public interface and the class is being consumed in many places but that would happen anyway, even if you used composition instead of parameter passing, so the most important thing is to design your public interfaces well enough so changes are not a common occurrence. Summing up, while sometimes this may point to a design problem (where a better design might translate into a class hierarchy where you don't need to pass that much data around), it isn't per se something bad, and in certain cases it's even needed. EDIT: First of all, is CartCalculations really needed or are you creating that class just to follow some rule? Then, if CartCalculations is warranted, why are you passing an int[] instead of CartItems where you can have control about what is done and how to the list of items? Finally, why do you feel that is brittle? Because you might forget to pass the parameter (compile error, no biggie)? Because somebody might modify the list where it shouldn't (somewhat controllable via having the CartItems which would be the only one loading the data)? Because if you need to change how items are represented (again no biggie if you wrap the array in a class where you could make that kind of changes). So, assuming all this hierarchy is warranted, and changing Chart to Cart because it makes more sense to me: class CartProgram () { CartItems lastItems; void main () { lastItems = getLast10ItemsSold(); Cart myChart = new Cart(lastItems); } } class Cart () { CartItems lastItems; Cart(CartItems lastItems) { this.lastItems = lastItems; CartCalulations cc = new CartCalculations(this.lastItems); cc.getAverage(); } class CartCalculations { CartItems lastItems; CartCalculations (CartItems lastItems){ this.lastItems = lastItems; // Okay so at this point I have had to forward this value 3 times and this is // a simple example. It just seems to make the code very brittle } getAverage() { // do stuff here } } class CartItems { private List itemList; public static CartItems Load(int cartId) { //return a new CartItems loaded from the backend for the cart id cartId } public void Add(Item item) { } public void Add(int item) { } public int SumPrices() { int sum = 0; foreach (Item i in itemList) { sum += i.getPrice() } return sum; } } class Item { private int price; public int getPrice() { return price; } } For a well architected chart library, see http://www.aditus.nu/jpgraph/jpgarchitecture.php
