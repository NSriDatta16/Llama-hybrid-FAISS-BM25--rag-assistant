[site]: stackoverflow
[post_id]: 2595204
[parent_id]: 
[tags]: 
Is this too much code for a header only library?

It seems like I had to inline quite a bit of code here. I'm wondering if it's bad design practice to leave this entirely in a header file like this: #include #include #include #include #include #include #include "../Exception.hpp" namespace WindowsAPI { namespace FileSystem { class NonRecursiveEnumeration; class RecursiveEnumeration; struct AllResults; struct FilesOnly; template class DirectoryIterator; template struct FileData; class NonRecursiveEnumeration : public boost::noncopyable { WIN32_FIND_DATAW currentData; HANDLE hFind; std::wstring root; public: NonRecursiveEnumeration() : hFind(INVALID_HANDLE_VALUE) { }; NonRecursiveEnumeration(const std::wstring& pathSpec) { std::wstring::const_iterator lastSlash = std::find(pathSpec.rbegin(), pathSpec.rend(), L'\\').base(); if (lastSlash != pathSpec.end()) root.assign(pathSpec.begin(), lastSlash); hFind = FindFirstFileW(pathSpec.c_str(), &currentData); if (hFind == INVALID_HANDLE_VALUE) WindowsApiException::ThrowFromLastError(); while (!wcscmp(currentData.cFileName, L".") || !wcscmp(currentData.cFileName, L"..")) { increment(); } }; void increment() { BOOL success = FindNextFile(hFind, &currentData); if (success) return; DWORD error = GetLastError(); if (error == ERROR_NO_MORE_FILES) { FindClose(hFind); hFind = INVALID_HANDLE_VALUE; } else { WindowsApiException::Throw(error); } }; ~NonRecursiveEnumeration() { if (hFind != INVALID_HANDLE_VALUE) FindClose(hFind); }; bool equal(const NonRecursiveEnumeration& other) const { if (this == &other) return true; return hFind == other.hFind; }; const std::wstring& GetPathRoot() const { return root; }; const WIN32_FIND_DATAW& GetCurrentFindData() const { return currentData; }; }; //Not implemented yet class RecursiveEnumeration : public boost::noncopyable { }; template struct FileData //Serves as a proxy to the WIN32_FIND_DATA struture inside the iterator. { const Recurse_T* impl; template FileData(const DirectoryIterator * parent) : impl(parent->impl.get()) {}; DWORD GetAttributes() const { return impl->GetCurrentFindData().dwFileAttributes; }; bool IsDirectory() const { return (GetAttributes() & FILE_ATTRIBUTE_DIRECTORY) != 0; }; bool IsFile() const { return !IsDirectory(); }; bool IsArchive() const { return (GetAttributes() & FILE_ATTRIBUTE_ARCHIVE) != 0; }; bool IsReadOnly() const { return (GetAttributes() & FILE_ATTRIBUTE_READONLY) != 0; }; unsigned __int64 GetSize() const { ULARGE_INTEGER intValue; intValue.LowPart = impl.GetCurrentFindData().nFileSizeLow; intValue.HighPart = impl.GetCurrentFindData().nFileSizeHigh; return intValue.QuadPart; }; std::wstring GetFolderPath() const { return impl->GetPathRoot(); }; std::wstring GetFileName() const { return impl->GetCurrentFindData().cFileName; }; std::wstring GetFullFileName() const { return GetFolderPath() + GetFileName(); }; std::wstring GetShortFileName() const { return impl->GetCurrentFindData().cAlternateFileName; }; FILETIME GetCreationTime() const { return impl->GetCurrentFindData().ftCreationTime; }; FILETIME GetLastAccessTime() const { return impl->GetCurrentFindData().ftLastAccessTime; }; FILETIME GetLastWriteTime() const { return impl->GetCurrentFindData().ftLastWriteTime; }; }; struct AllResults { template bool operator()(const FileData &) { return true; }; }; struct FilesOnly { template bool operator()(const FileData & arg) { return arg.IsFile(); }; }; #pragma warning(push) #pragma warning(disable: 4355) template class DirectoryIterator : public boost::iterator_facade , const FileData , std::input_iterator_tag> { friend class boost::iterator_core_access; boost::shared_ptr impl; FileData derefData; Filter_T filter; void increment() { do { impl->increment(); } while (! filter(derefData)); }; bool equal(const DirectoryIterator& other) const { return impl->equal(*other.impl); }; const FileData & dereference() const { return derefData; }; public: typedef FileData DataType; friend struct DataType; DirectoryIterator(Filter_T functor = Filter_T()) : impl(boost::make_shared ()), derefData(this), filter(functor) { }; explicit DirectoryIterator(const std::wstring& pathSpec, Filter_T functor = Filter_T()) : impl(boost::make_shared (pathSpec)), derefData(this), filter(functor) { }; }; #pragma warning(pop) }}
