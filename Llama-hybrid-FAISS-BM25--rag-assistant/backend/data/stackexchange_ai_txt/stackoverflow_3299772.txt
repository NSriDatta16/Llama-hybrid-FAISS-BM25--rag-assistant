[site]: stackoverflow
[post_id]: 3299772
[parent_id]: 3299099
[tags]: 
Paxdiablo has given a couple of valid ways to do it. Another way would be to use reference modification in addition to the STRING verb. Complete program example follows: IDENTIFICATION DIVISION. PROGRAM-ID. EXAMPLE9. DATA DIVISION. WORKING-STORAGE SECTION. 01 STRINGS. 05 STRING1 PIC X(10) VALUE 'AAAAAAAAAA'. 05 STRING2 PIC X(10) VALUE 'BBBBBBBBBB'. 05 STRING3 PIC X(10) VALUE 'CCCCCCCCCC'. 05 STRING4 PIC X(10) VALUE 'DDDDDDDDDD'. 05 STRING5 PIC X(10) VALUE 'EEEEEEEEEE'. 05 STRING6 PIC X(10) VALUE 'FFFFFFFFFF'. 05 STRING7 PIC X(10) VALUE 'GGGGGGGGGG'. 05 STRING8 PIC X(10) VALUE 'HHHHHHHHHH'. 05 STRING-OUT PIC X(40) VALUE SPACES. PROCEDURE DIVISION. STRING STRING1(1:5) STRING2(1:5) STRING3(1:5) STRING4(1:5) STRING5(1:5) STRING6(1:5) STRING7(1:5) STRING8(1:5) DELIMITED BY SIZE INTO STRING-OUT DISPLAY STRING-OUT GOBACK. This cuts down on the verbosity quite a bit and captures the concatenation in a single statement. Best advice is to read up on the STRING verb. There are a number of innovative ways it can be used. COBOL does not provide an exact analogue to the BASIC MID statement. You can accomplish similar operations by using some combination of STRING , UNSTRING , INSPECT and reference modification. An example of a reference modification is: SOME-VARIABLE-NAME(1:5) - the 1:5 bit specifies a substring of SOME-VARIABLE-NAME starting with the first character for a length of 5 characters. The modifiers may themselves be numeric variables. The STRING and UNSTRING verbs provide a number of features that can be quite powerful. In general though, COBOL is not particularly good at string manipulation (some might say its not particularly good at anything - but I would disagree with that statement).
