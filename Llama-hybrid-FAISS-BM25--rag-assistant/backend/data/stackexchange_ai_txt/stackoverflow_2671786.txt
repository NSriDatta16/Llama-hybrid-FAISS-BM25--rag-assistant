[site]: stackoverflow
[post_id]: 2671786
[parent_id]: 2671736
[tags]: 
recv cannot modify its first argument, since it is taken by value. You don't show where you've declared msg or i , but based on this line printf("S: msg says %s\n", msg->_payload); Where you use the -> operator on msg , I assume it's probably like this: struct somestruct* msg = malloc(sizeof(struct somestruct)); int i; Then you do this: num_bytes = recv(i, &msg, MAX_MSG_BYTE, 0); Note that msg is already a pointer, so &msg is a pointer to the pointer . What this will then do is receive data and try to store it in the place where the msg pointer itself is, not the place that msg points to . Typically, pointers are only 4 bytes long, so this will overflow the storage if you receive more than four bytes. If i is declared on the stack after msg , then it is likely that it is being overwritten by this overflow, and it happens to get overwritten by all zero bytes from the received packet. Since msg is already a pointer, change your receive line to eliminate the superfluous indirection: num_bytes = recv(i, msg, MAX_MSG_BYTE, 0); Similarly, you may want to consider making the same change to the line handle_request(arg, &msg) if the handle_request function is not really expecting a pointer-to-pointer.
