[site]: stackoverflow
[post_id]: 2671511
[parent_id]: 2656306
[tags]: 
If the column names in the DataTable match exactly to the column names in the destination table, then you might be able to use a OleDbCommandBuilder (Warning: I haven't tested this yet). One area you may run into problems is if the data types of the source data table do not match those of the destination table (e.g if the source column data types are all strings). EDIT I revised my original code in a number of ways. First, I switched to using the Merge method on a DataTable. This allowed me to skip using the LoadDataRow in a loop. using ( var conn = new OleDbConnection( destinationConnString ) ) { //query off the destination table. Could also use Select Col1, Col2.. //if you were not going to insert into all columns. const string selectSql = "Select * From [DestinationTable]"; using ( var adapter = new OleDbDataAdapter( selectSql, conn ) ) { using ( var builder = new OleDbCommandBuilder( adapter ) ) { conn.Open(); var destinationTable = new DataTable(); adapter.Fill( destinationTable ); //if the column names do not match exactly, then they //will be skipped destinationTable.Merge( sourceDataTable, true, MissingSchemaAction.Ignore ); //ensure that all rows are marked as Added. destinationTable.AcceptChanges(); foreach ( DataRow row in destinationTable.Rows ) row.SetAdded(); builder.QuotePrefix = "["; builder.QuoteSuffix= "]"; //forces the builder to rebuild its insert command builder.GetInsertCommand(); adapter.Update( destinationTable ); } } } ADDITION An alternate solution would be to use a framework like FileHelpers to read the CSV file and post it into your database. It does have an OleDbStorage DataLink for posting into OleDb sources. See the SqlServerStorage InsertRecord example to see how (in the end substitute OleDbStorage for SqlServerStorage).
