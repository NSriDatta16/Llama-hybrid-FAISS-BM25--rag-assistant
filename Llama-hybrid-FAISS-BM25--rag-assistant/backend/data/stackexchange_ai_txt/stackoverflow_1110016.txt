[site]: stackoverflow
[post_id]: 1110016
[parent_id]: 1109545
[tags]: 
Here's my take on Gumbo's answer. I put IteratorAggregate on there so it would be foreach-able, but you could add Countable and ArrayAccess also. factor = $factor; $this->store = $data; } public function __sleep() { array_walk( $this->store, array( $this, 'toSerialized' ) ); return array( 'factor', 'store' ); } public function __wakeup() { array_walk( $this->store, array( $this, 'fromSerialized' ) ); } protected function toSerialized( &$num ) { $num *= $this->factor; } protected function fromSerialized( &$num ) { $num /= $this->factor; } public function getIterator() { return new ArrayIterator( $this->store ); } } function random_float ($min,$max) { return ($min+lcg_value()*(abs($max-$min))); } $original = array(); for ( $i = 0; $i '; print_r( $original ); print_r( $serialized ); print_r( $unserialized ); echo ' ';
