[site]: stackoverflow
[post_id]: 4050775
[parent_id]: 1801788
[tags]: 
It sounds like what you're really after is thread local storage which is already solved much more portably than this. GCC provides __thread , MSVC provides __declspec(thread) . boost::thread provides portable thread local storage using a variety of mechanisms depending on platform/toolchain etc. If you really do want to go down this road it can be made to work however the path is fraught with dangers. Recovering from SIGSEGV is undefined behaviour technically, although it can be made to work on quite a few platforms it is neither robust nor portable. You need to be very careful what you do in the signal handler though too -- the list of async-safe functions, i.e. those which may legally be safely called from a signal handler is very small. I've used this trick successfully a few times in the past, normally for marking "pages" as "dirty" in userspace. The way I did this was by setting up a hashtable which contained the base address of all the "pages" of memory that I was interested in. When you catch a SIGSEGV in a handler you can then map an address back to a page with simple arithmetic operations. Provided the hashtable can be read without locks you can then lookup if this is a page that you care about or a segfault from somewhere else and decide how to act.
