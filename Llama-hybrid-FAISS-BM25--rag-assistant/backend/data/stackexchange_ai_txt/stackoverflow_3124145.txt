[site]: stackoverflow
[post_id]: 3124145
[parent_id]: 3123748
[tags]: 
I'm with the other answers and comments so far. Even if you could define a reduced form, it's unlikely that the reduced form is going to be any more understandable than this thing, which resembles line noise on a 1200 baud modem. If you did want to find a canonical form for regular expressions, i'd start by defining precisely what you mean by "canonical form". For example, suppose you have the regular expression [ABCDEF-I] . Is the canonical form (1) [ABCDEF-I] , (2) [ABCDEFGHI] or (3) [A-I] ? That is, for purposes of canonicalization, do you want to (1) ignore this subset of regular expressions for the purposes of canonicalization, (2) eliminate all "-" operators, thereby simplifying the expression, or (3) make it shorter? The simplest way would be to go through every part of the regular expression specification and work out which subexpressions are logically equivalent to another form, and decide which of the two is "more canonical". Then write a recursive regular expression analyzer that goes through a regular expression and replaces each subexpression with its canonical form. Keep doing that in a loop until you find the "fixed point", the regular expression that doesn't change when you put it in canonical form. That, however, will not necessarily do what you want. If what you want is to reorganize the regular expression to minimize the complexity of grouping or some such thing then what you might want to do is to canonicalize the regular expression so that it is in a form such that it only has grouping, union and Kleene star operators. Once it is in that form you can easily translate it into a deterministic finite automaton, and once it is in DFA form then you can run a graph simplification algorithm on the DFA to form an equivalent simpler DFA. Then you can turn the resulting simplified DFA back into a regular expression. Though that would be fascinating, like I said, I don't think it would actually solve your problem. Your problem, as I understand it, is a practical one. You have this mess, and you want to understand that it is right. I would approach that problem by a completely different tack. If the problem is that the literal string is hard to read, then don't write it as a literal string. I'd start "simplifying" your regular expression by making it read like a programming language instead of reading like line noise: Func group = s=>"(?:"+s+")"; Func capture = s=>"("+s+")"; Func anynumberof = s=>s+"*"; Func oneormoreof = s=>s+"+"; var beginning = "^"; var end = "$"; var newline = @"\r\n"; var tab = @"\t"; var space = " "; var semi = ";"; var comma = ","; var equal = "="; var chunked = "chunked"; var transfer = " "; var backslash = @"\\"; var escape = group(backslash + @"[\x00-\x7f]"); var or = "|"; var whitespace = group( anynumberof( group( newline + group( oneormoreof(@"[ \t]"))))); var legalchars = group( oneormoreof(@"[\x21\x23-\x27\x2A\x2B\x2D\x2E0-9A-Z\x5E\x7A\x7C\x7E-\xFE]")); var re = beginning + group( whitespace + capture( transfer + group( chunked + or + group( legalchars + group( group( semi + anynumberof( group( legalchars + equal + ... Once it looks like that it'll be a lot easier to understand and optimize.
