[site]: stackoverflow
[post_id]: 290494
[parent_id]: 39086
[tags]: 
The shortest way would probably be to use the fileinput module . For example, the following adds line numbers to a file, in-place: import fileinput for line in fileinput.input("test.txt", inplace=True): print('{} {}'.format(fileinput.filelineno(), line), end='') # for Python 3 # print "%d: %s" % (fileinput.filelineno(), line), # for Python 2 What happens here is: The original file is moved to a backup file The standard output is redirected to the original file within the loop Thus any print statements write back into the original file fileinput has more bells and whistles. For example, it can be used to automatically operate on all files in sys.args[1:] , without your having to iterate over them explicitly. Starting with Python 3.2 it also provides a convenient context manager for use in a with statement. While fileinput is great for throwaway scripts, I would be wary of using it in real code because admittedly it's not very readable or familiar. In real (production) code it's worthwhile to spend just a few more lines of code to make the process explicit and thus make the code readable. There are two options: The file is not overly large, and you can just read it wholly to memory. Then close the file, reopen it in writing mode and write the modified contents back. The file is too large to be stored in memory; you can move it over to a temporary file and open that, reading it line by line, writing back into the original file. Note that this requires twice the storage.
