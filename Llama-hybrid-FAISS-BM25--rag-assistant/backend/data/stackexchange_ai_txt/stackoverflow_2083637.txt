[site]: stackoverflow
[post_id]: 2083637
[parent_id]: 2082927
[tags]: 
There was many issues with your code snippet. I fixed your snippet adding explanation as to what was broken and added some style advice if you care. module Pass1_JFT where import Control.Monad.Identity import Control.Monad.State import Control.Monad.Writer import Data.Maybe import qualified Data.Map as Map {- replacing your import Types with simple definitions -} --import Types type Line = String type Address = String type LineNumber = Int {- Not part of your question but my 2 cents here... Say that you want to changes the collection for your states if you don't use a type alias you'll have to hunt everwhere you used it. Instead just change these definitions if required -} type Lines = [Line] type Addresses = [Address] type Messages = [Msg] data Msg = Error String | Warning String {- What is that Int in StateT Int? Name it easier to read, reason about and to change. Declarative FTW let's use LineNumber instead -} --type Pass1 a = WriterT [Msg] (StateT Int (StateT [Line] (StateT [Address] Identity))) a {- Let's use a "real" type so instances can be derived. Since Pass1 is not a monad transfer i.e. not defined as Pass1 m a, no point using StateT for the deepest StateT i.e. StateT [Address] Identity so let's just use a State [Address] -} newtype Pass1 a = Pass1 { unPass1 :: WriterT Messages (StateT LineNumber (StateT Lines (State Addresses))) a } deriving (Functor,Monad) --runIdentity (runStateT (runStateT (runStateT (runWriterT msgs) 1) instrs) addrs) {- Let's peel that stack from the outermost (lefmost in the declaration) up to the innermost was Identity in your original declaration. Note that runWriterT does NOT take a starting state... The first parameter for runStateT (and runState) is not the initial state but the monad... so let's flip! -} runPass1' :: Addresses -> Lines -> Messages -> Pass1 a -> ((((a, Messages), LineNumber), Lines), Addresses) runPass1' addrs instrs msgs = flip runState addrs . flip runStateT instrs . flip runStateT 1 . runWriterT . -- then get process the WriterT (the second outermost) unPass1 -- let's peel the outside Pass1 {- now that last function does NOT do what you want since you want to provide an initial log to append to with the WriterT. Since it is a monad transformer we'll do some trick here -} -- I keep the runStateT convention for the order of the arguments: Monad then state runWriterT' :: (Monad m,Monoid w) => WriterT w m a -> w -> m (a,w) runWriterT' writer log = do (result,log') Lines -> Messages -> Pass1 a -> ((((a, Messages), LineNumber), Lines), Addresses) runPass1 addrs instrs msgs = flip runState addrs . flip runStateT instrs . flip runStateT 1 . flip runWriterT' msgs . -- then get process the WriterT (the second outermost) unPass1 -- let's peel the outside Pass1 {- Do you intend to call popLine directly from a Pass1 stack? If so you need to "teach" Pass1 to be a "MonadState Lines" To do so let's derive Pass1 (that's why we declared it with newtype!) -} instance MonadState Lines Pass1 where -- we need to dig inside the stack and "lift" the proper get get = Pass1 . lift . lift $ get put s = Pass1 . lift . lift $ put s {- Better keep thing generic but we now could have written: popLine :: Pass1 (Maybe Line) -} popLine :: (MonadState Lines m) => m (Maybe Line) popLine = do ls do put xs return $ Just x [] -> return Nothing {- Ok now I get the Int => LineNumber.... we could make Pass1 and instance of MonadState LineNumber but LineNumber should not be messed with so instead I'd code the incLine directly and would provide a MonadReader instance for consulation if required check ":t incLineNum and :t curLineNum" -} incLineNum = Pass1 . lift $ modify (+1) curLineNum = Pass1 $ lift get evalr = do l There it is a long winded response but monad and monad stack as you see are challenging at first. I fixed the code but I encourage you to play and inspect the types of the various functions to understand what is going on and to compare against your original. Haskell's type inference means that usually type annotations are superfluous (unless to remove ambiguity). In general the type we'd give to function is less generic that was is infer so it is better not to type annotate. Type annotation is definitively a good debugging technique though ;) Cheers P.S. Real World Haskell chapter on Monad Transformer is excellent: http://book.realworldhaskell.org/read/monad-transformers.html
