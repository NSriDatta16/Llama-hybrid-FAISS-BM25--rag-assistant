[site]: stackoverflow
[post_id]: 1570643
[parent_id]: 1570471
[tags]: 
In C++, to get polymophic behavior you need to use either pointers or references. In your particular case, as the lifetime of the Token must expand beyond the function startJob you cannot return a reference into an internal stack allocated object, since at the place of use (caller of startJob ) it would be a dangling reference. So you are left with dynamically allocated memory, and at this point you can choose how you want to deal with the heap allocated object lifetime. I would advise against using raw pointers as they are inherently exception unsafe, there are already different fine answers using raw pointers as return value and managing the pointer inside a smart pointer, or already returning an smart pointer. The disadvantage of returning a raw pointer and externally managing it in a smart pointer is that it is a little more fragile for user code. The caller can use smart pointers, or can use raw pointers (or ignore the returned object) and it will loose memory. Using a shared_ptr in your user interface imposes the use of that smart pointer in caller code (the user cannot decide to change to another smart pointer type). Using a good old std::auto_ptr as return type seems like the most flexible approach at this point: std::auto_ptr startJob( int jobId ); void user_code() { std::auto_ptr job1 = startJob(1); boost::shared_ptr job2( startJob(2) ); // shared_ptr has a constructor taking auto_ptr startJob(3); // fine: the temporary auto_ptr dies and releases the memory boost::scoped_ptr job4( startJob(4).release() ); // cumbersome, but feasible } ( scoped_ptr reference) If the returned type was another type of smart pointer as the return type, then you would not be able to make it yield the resource to use in another type of smart pointer. If you returned a raw pointer job 3 token will not be released. I have not considered unique_ptr for the discussion. It seems as a good alternative to auto_ptr, but I have never used it so I cannot tell from experience.
