[site]: stackoverflow
[post_id]: 4127655
[parent_id]: 4126874
[tags]: 
I posted a recursive solution but then decided to delete it, since from the comments this sounds like a homework problem, and I'm normally a teach-to-fish person. You're on the way to a recursive solution with your definition newMap[f_, {}] := {} . Mathematica's pattern-matching is your friend. Consider how you might implement the definition for newMap[f_, {e_}] , and from there, newMap[f_, {e_, rest___}] . One last hint: once you can define that last function, you don't actually need the case for {e_} . UPDATE : Based on your comments, maybe this example will help you see how to apply an arbitrary function: func[a_, b_] := a[b] In[4]:= func[Abs, x] Out[4]= Abs[x] SOLUTION Since the OP caught a fish, so to speak, (congrats!) here are two recursive solutions, to satisfy the curiosity of any onlookers. This first one is probably what I would consider "idiomatic" Mathematica: map1[f_, {}] := {} map1[f_, {e_, rest___}] := {f[e], Sequence@@map1[f,{rest}]} Here is the approach that does not leverage pattern matching quite as much, which is basically what the OP ended up with: map2[f_, {}] := {} map2[f_, lis_] := {f[First[lis]], Sequence@@map2[f, Rest[lis]]} The {f[e], Sequence@@map[f,{rest}]} part can be expressed in a variety of equivalent ways, for example: Prepend[map[f, {rest}], f[e]] Join[{f[e]}, map[f, {rest}] (@Mike used this method) Flatten[{{f[e]}, map[f, {rest}]}, 1] I'll leave it to the reader to think of any more, and to ponder the performance implications of most of those =) Finally, for fun, here's a procedural version, even though writing it made me a little nauseous: ;-) map3[f_, lis_] := (* copy lis since it is read-only *) Module[{ret = lis, i}, For[i = 1, i
