[site]: stackoverflow
[post_id]: 5537064
[parent_id]: 5536785
[tags]: 
As I expected. In this code: byte[] bData = new byte[1024]; in.read(bData); System.out.println("In Data"+in.toString()); String st=new String (bData); You read some text and then convert the whole byte[] into a String , even if you didn't fill the whole byte[] with the read -call. Also, you ignore if there is any more data (i.e. if your content is more than 1024 bytes). The simplest solution to this is to use an InputSource with the InputStream it self directly: xr.parse(new InputSource(in)); The SAX parser already knows how to handle an InputStream and does all of that for you. There no need to re-implement that behaviour. If you absolutely must read the whole response in memory, then you'd need to use code like this (but I wouldn't encourage this): ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buf = new byte[1024]; int read; while ((read=in.read(buf))!=-1) { baos.write(buf, 0, read); } byte[] output = baos.toByteArray(); Also note that converting this to a String is non-trivial, as the XML could have any encoding and you'd need to detect the correct one to correctly convert the byte[] to a String .
