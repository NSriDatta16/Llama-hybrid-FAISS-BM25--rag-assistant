[site]: stackoverflow
[post_id]: 2140182
[parent_id]: 2140025
[tags]: 
According to paragraph 14.8.2.1 of the C++ standard, when a template parameter is used only in a non-deduced context, the corresponding template argument cannot be deduced: If a template-parameter is not used in any of the function parameters of a function template, or is used only in a non-deduced context, its corresponding template-argument cannot be deduced from a function call and the template-argument must be explicitly specified. The definition of nondeduced contexts, as stated in ยง14.8.2.4: The nondeduced contexts are: the nested-name-specifier of a type that was specified using a qualified-id . A type that is a template-id in wich one or more of the template-arguments is an expression that references a template-parameter . In Bar ::type , Bar is a nested-name-specifier and hence a non-deduced context, so you must explicitly specify the template argument when calling the constructor...which is not possible (i.e. you cannot write Foo f (v) ). I suppose the compiler cannot deduce the template argument because that would be at least cumbersome, and more probably impossible: imagine Bar is specialized: template struct Bar { typedef std::pair type; }; template<> struct Bar { typedef std::pair type; }; Now I have an ambiguity when calling Foo's constructor with std::vector > : should the template argument be int or char ? And even if there was no such ambiguity, you can easily see that the compiler would have to instantiate Bar with potentially any type before finding the instantiation with the correct typedef (well, I'm not so sure above statements are truly relevant since I often find out compilers to be much more smarter than I thought :-)!)
