[site]: stackoverflow
[post_id]: 4204486
[parent_id]: 4200211
[tags]: 
Regarding your update, I think you are misunderstanding how GC works. The basic idea is rather simple. When you create an object, flash allocates some memory in a storage called the heap. A reference to this object is returned. This reference is what you store in a variable. What is a reference? A means to access this object. Think of it as link to the object. var foo:Bar = new Bar(); Now, in some languages, at some point you have to release the memory allocated for this object when you're done with it, or you have a memory leak. In a GC environment, this is done automatically. Of course, you need some rules. This rules vary depending on the concrete GC, but in general terms, you could say the GC determines that an object is collectable if it's no longer reachable. This makes sense, because if you can't reach an object, you can't use it. You've lost your link to it. So, it's considered garbage and will be eventually collected. The specifics on how reachability is determined vary, but in flash it's a mix of reference counting and a mark and sweep algorithm. (The following is just a high level overview, the details might not be exact) One method is reference counting: it's easy and fast but it doesn't work in all situations. Basically, each object has a reference count. Each time you assign this object to a variable (i.e. you store a reference to the object), the reference count is incremented. Each time you lost this reference (for instance, you null out your var), this count is decremented. If the count reaches 0, it means the object is unreachable and so it's collectable. This works fine in some cases, but no others. Specially when there are crossed references. var foo1:Bar = new Bar(); // let's call this object Bar_1 var foo2:Bar = new Bar(); // let's call this one Bar_2 // at this point, Bar_1 has reference count of 1 (foo1) and Bar_2 has a reference of 1 (foo2) foo1.theOtherFoo = foo2; // now Bar_2 has a RC of 2: foo2 and foo1.theOtherFoo foo2.theOtherFoo = foo1; // now Bar_1 has a RC of 2: foo1 and foo2.theOtherFoo foo1 = null; // foo1 no longer references Bar_1, so its RC is decremented. foo2 = null; // foo2 no longer references Bar_2, so its RC is decremented. // but still both Bar_1 and Bar_2 have a RC of 1. As you can see, both Bar_1 and Bar_2 have a RC of 1, but are unreachable. This is one of the cases where reference counting doesn't work. Because for all intents and purposes, both objects are unreachable and yet won't be collected. That's why there's a mark/sweep algorithm. From a high level point of view, what it does is traversing your objects graph, starting from some root objects and analize its relationships to determine whether an object is reachable or not. This algorithm will determine that even though Bar_1 and Bar_2 have a RC of 1, they're not reachable and thus should be considered garbage and be collected at some point. Events, listeners and dispatchers work the same way. They're not a special case. When you do: function test():void { foo1.addEventListener("someEvent",someHandler); } function someHandler(e:Event):void { } It's the same as doing: function test():void { foo1.someProperty = this; } The effect is that foo1 now has a reference to this . You'd normally call removeEventListener when you're done for 2 reasons: 1) You no longer want foo1 to have a reference to this . 2) You no longer want to listener for "someEvent" events. Lots of people insist on using weak references, because they think that then you can pretend you don't have to call removeEventListener (which is apparently too hard...). This is wrong. removeEventListener does two things and both are important. If you want to stop receiving notifications for some event, you have to tell the dispatcher. It's really that simple. In my opinion, weak references are innecesary in most cases. Some advocate to use them by default; but in my experience, in practice this is a bad service to them, as it confuses people further, encourages them to write sloppy code and gives them the impression that you can ignore how this very basic feature of the language (which is not that hard to graps) works. Now, after this rather long (but hopefuly constructive) rant, let's look at your code: Your sprite is not going to be collected, because it has 2 references: 1) the square variable 2) the stage. The first follows the rules outline above. The second too, but it might not be so obvious at first sight. But it makes sense if you think about it for a second. When you did this: addChild(square); square got added to the Test instance, which is in turn added to the stage . The stage is always alive, so if something can be reached from the stage , it's reachable. As long as square remains added to the stage , you can be sure it won't be collected. So, if you at some point do what Sean Thayne suggested: removeChild(square) square = null; your Sprite will be collectable. That doesn't affect the fact that you told your Test object that you wanted to be called whenever a frame is entered. And that's exactly what's happening. Until you don't tell it you don't want to receive this event anymore (calling removeEventListener), it will call you back.
