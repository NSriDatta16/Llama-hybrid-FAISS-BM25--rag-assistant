[site]: stackoverflow
[post_id]: 883082
[parent_id]: 864707
[tags]: 
Both of you (Russ Hayward and Andrew) helped, the key was essentially to do the following: store the state to be made visible in the TableModel itself, not in the renderer make sure that when the TableModel's state changes, fireTableCellUpdated() is called have only one TableCellRenderer object and one JComponent for my custom column (not one per cell) within TableCellRenderer.getTableCellRendererComponent() store the cell's state for purposes of being rendering soon after (long-term storage is in the TableModel) provide that state to the JComponent return the JComponent override JComponent.PaintComponent() one convenient possibility is for a custom renderer to extend JComponent and implement TableCellRenderer, then in TableCellRenderer.getTableCellRendererComponent() you store the cell's state and return this; Here's the relevant excerpt of my code that now works: class TraceControlTableModel extends AbstractTableModel { /* handle table state here */ // convenience method for setting bar value (table model's column 2) public void setBarValue(int row, double x) { setValueAt(x, row, 2); } } // one instance of BarRenderer will be set as the // TableCellRenderer for table column 2 public static class BarRenderer extends JComponent implements TableCellRenderer { final private double xmin; final private double xmax; private double xval; public BarRenderer(double xmin, double xmax) { super(); this.xmin=xmin; this.xmax=xmax; } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); Rectangle r = g.getClipBounds(); g.drawRect(r.x, r.y, (int)(r.width * ((xval-xmin)/(xmax-xmin))), r.height); } @Override public Component getTableCellRendererComponent(JTable arg0, Object value, boolean isSelected, boolean hasFocus, int row, int col) { // save state here prior to returning this object as a component // to be painted this.xval = (Double)value; return this; } }
