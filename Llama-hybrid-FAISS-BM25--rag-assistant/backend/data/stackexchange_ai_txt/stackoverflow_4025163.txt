[site]: stackoverflow
[post_id]: 4025163
[parent_id]: 4024573
[tags]: 
I have what I think is a pretty elegant solution. Here's your user model: class User :destroy accepts_nested_attributes_for :membership def update_membership_with_history attributes self.membership.attributes = attributes return true unless self.membership.changed? self.membership.update_attribute(:active, false) self.build_membership attributes self.membership.save end end This update_membership_with_history method allows us to handle changed or unchanged records. Next the membership model: class Membership {:active => true} belongs_to :user end I changed this slightly, since active should be a boolean, not 1's and 0's. Update your migration to match. Now the update action, which is the only part of your scaffold that needs to change: def update @user = User.find(params[:id], :include => :membership) membership_attributes = params[:user].delete(:membership_attributes) if @user.update_attributes(params[:user]) && @user.update_membership_with_history(membership_attributes) redirect_to users_path else render :action => :edit end end We're simply parsing out the membership attributes (so you can still use fields_for in your view) and updating them separately, and only if needed.
