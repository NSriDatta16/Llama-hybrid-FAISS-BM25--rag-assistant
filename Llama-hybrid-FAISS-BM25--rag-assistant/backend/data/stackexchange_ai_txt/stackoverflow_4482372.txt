[site]: stackoverflow
[post_id]: 4482372
[parent_id]: 
[tags]: 
How to guarantee bits of char and short for communication to external device

Hello I am writing a library for communicating to an external device via rs-232 serial connection. Often I have to communicate a command that includes an 8 bit = 1 byte character or a 16 bit = 2 byte number. How do I do this in a portable way? Main problem From reading other questions it seems that the standard does not guarantee 1byte = 8bits, (defined in the Standard $1.7/1) The fundamental storage unit in the C + + memory model is the byte. A byte is at least large enough to contain any member of the basic execution character set and is composed of a contiguous sequence of bits, the number of which is implementation-defined . How can I guarantee the number of bits of char? My device expects 8-bits exactly, rather than at least 8 bits. I realise that almost all implementations have 1byte = 8 bits but I am curious as to how to guarantee it. Short->2 byte check I hope you don't mind, I would also like to run my proposed solution for the short -> 2 byte conversion by you. I am new to byte conversions and cross platform portability. To guarantee the the number of bytes of the short I guess I am going to need to need to do a sizeof(short). If sizeof(short)=2 Convert to bytes and check the byte ordering (as here ) if sizeof(short)>2 then convert the short to bytes, check the byte ordering (as here ), then check the most significant bytes are empty and remove them? Is this the right thing to do ? Is there a better way? Many thanks
