[site]: stackoverflow
[post_id]: 5121001
[parent_id]: 5120218
[tags]: 
Actually, your first idea (return the counts with each value) is not a bad one, and can be expressed more abstractly by the Writer monad (in Control.Monad.Writer from the mtl package or Control.Monad.Trans.Writer from the transformers package). Essentially, the writer monad allows each computation to have an associated "output", which can be anything as long as it's an instance of Monoid - a class which defines: The empty output ( mempty ), which is the output assigned to 'return' An associative function (`mappend') that combines outputs, which is used when sequencing operations In this case, your output is a count of operations, the 'empty' value is zero, and the combining operation is addition. For example, if you're tracking operations separately: data Counts = Counts { additions: Int, multiplications: Int } Make that type an instance of Monoid (which is in the module Data.Monoid ), and define your operations as something like: add :: Num a => a -> a -> Writer Counts a add x y = do tell (Counts {additions = 1, multiplications = 0}) return (x + y) The writer monad, together with your Monoid instance, then takes care of propagating all the 'tells' to the top level. If you wanted, you could even implement a Num instance for Num a => Writer Counts a (or, preferably, for a newtype so you're not creating an orphan instance), so that you can just use the normal numerical operators.
