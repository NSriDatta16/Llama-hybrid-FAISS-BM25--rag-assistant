[site]: stackoverflow
[post_id]: 4687613
[parent_id]: 4686507
[tags]: 
Conceptually, the decision of which to use is driven by the same criterion as using a named variable versus a in-place expression or constant... size_t length = strlen(x) + sizeof(y) + z++ + strlen('\0'); ... allocate(length); std::cout ...here, creating a length variable encourages the program to consider it's correctness and meaning in isolation of it's later use. The name hopefully conveys enough that it can be understood intuitively and independently of it's initial value. It then allows the value to be used several times without repeating the expression (while handling z being different). While here... allocate(strlen(x) + sizeof(y) + z++ + strlen('\0')); ...the total code is reduced and the value is localised at the point it's needed. The only thing to "carry forwards" from a reading of this line is the side effects of allocation and increment (z), but there's no extra local variable with scope or later use to consider. The programmer has to mentally juggle less state while continuing their analysis of the code. The same distinction applies to functions versus inline statements. For the purposes of answering your question, functors versus lambdas can be seen as just a particular case of this function versus inlining decision.
