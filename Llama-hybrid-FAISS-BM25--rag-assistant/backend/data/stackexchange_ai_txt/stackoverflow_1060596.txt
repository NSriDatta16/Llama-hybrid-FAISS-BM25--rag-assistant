[site]: stackoverflow
[post_id]: 1060596
[parent_id]: 1060446
[tags]: 
There are two things you have to ensure: Freeze the BitmapFrame by calling BitmapFrame.Freeze(). This turns the frame read-only, and makes it available to other threads. You may already be doing this: to let the UI thread know the frame is ready, use Dispatcher.Invoke, instead of setting the properties or calling the methods of UI objects directly. To answer Teodor's question, freezing could fail if the BitmapFrame is still being changed. This seems to happen when you use BitmapFrame.Create(Uri). The following code appears to avoid the issue by using a decoder. In case you are creating your BitmapFrame differently, the general rule is that you have to let it finish initializing, downloading, decoding, or otherwise changing before you freeze it. Disconnect any bindings too. Window1.xaml Window1.xaml.cs using System; using System.Threading; using System.Windows; using System.Windows.Media.Imaging; using System.Windows.Threading; namespace BitmapFrameDemo { public partial class Window1 : Window { private Thread thread = null; private Dispatcher dispatcher = null; private void ThreadMain() { PngBitmapDecoder decoder = new PngBitmapDecoder( new Uri("http://stackoverflow.com/content/img/so/logo.png"), BitmapCreateOptions.None, BitmapCacheOption.Default); BitmapFrame frame = decoder.Frames[0]; BitmapFrame frozen = (BitmapFrame) frame.GetAsFrozen(); dispatcher.Invoke( new Action(() => { image.Source = frozen; }), new object[] { }); } public Window1() { InitializeComponent(); dispatcher = Dispatcher.CurrentDispatcher; thread = new Thread(new ThreadStart(this.ThreadMain)); thread.Start(); } } }
