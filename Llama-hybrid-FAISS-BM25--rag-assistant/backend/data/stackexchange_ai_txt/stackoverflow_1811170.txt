[site]: stackoverflow
[post_id]: 1811170
[parent_id]: 1811116
[tags]: 
I haven't heard this has changed yet, and in a recent post by John Resig, he states: Internet Explorer doesn't support importNode or adoptNode Also see this A List Apart article on cross-browser importnode() as it includes a specific work-around for Internet Explorer. To quote for posterity, The solution to all of my problems was to not use a DOM method after all, and instead use my own implementation. Here, in all of its glory, is my final solution to the importNode() problem coded in a cross-browser compliant way: (Line wraps marked » —Ed.) if (!document.ELEMENT_NODE) { document.ELEMENT_NODE = 1; document.ATTRIBUTE_NODE = 2; document.TEXT_NODE = 3; document.CDATA_SECTION_NODE = 4; document.ENTITY_REFERENCE_NODE = 5; document.ENTITY_NODE = 6; document.PROCESSING_INSTRUCTION_NODE = 7; document.COMMENT_NODE = 8; document.DOCUMENT_NODE = 9; document.DOCUMENT_TYPE_NODE = 10; document.DOCUMENT_FRAGMENT_NODE = 11; document.NOTATION_NODE = 12; } document._importNode = function(node, allChildren) { switch (node.nodeType) { case document.ELEMENT_NODE: var newNode = document.createElement(node » .nodeName); /* does the node have any attributes to add? */ if (node.attributes && node.attributes » .length > 0) for (var i = 0; il = node.attributes.length;i 0) for (var i = 0; il = node.childNodes.length; i Here it is in use: var newNode = null, importedNode = null; newNode = xhrResponse.responseXML.getElementsByTagName('title')[0].childNodes[0]; if (newNode.nodeType != document.ELEMENT_NODE) newNode = newNode.nextSibling; if (newNode) { importedNode = document._importNode(newNode, true); document.getElementById('divTitleContainer').appendChild(importedNode); if (!document.importNode) document.getElementById('divTitleContainer').innerHTML = document.getElementById('divTitleContainer').innerHTML; }
