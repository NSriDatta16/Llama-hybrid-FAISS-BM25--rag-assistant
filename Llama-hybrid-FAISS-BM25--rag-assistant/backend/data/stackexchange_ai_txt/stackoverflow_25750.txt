[site]: stackoverflow
[post_id]: 25750
[parent_id]: 25746
[tags]: 
Let's use C++, since my Objective C is totally non-existent. If you stash a string into a constant variable: const std::string mystring = "my string"; Now when you call methods, you use my_string, you're using a string constant: someMethod(mystring); Or, you can call those methods with the string literal directly: someMethod("my string"); The reason, presumably, that they encourage you to use string constants is because Objective C doesn't do "interning"; that is, when you use the same string literal in several places, it's actually a different pointer pointing to a separate copy of the string. For dictionary keys, this makes a huge difference, because if I can see the two pointers are pointing to the same thing, that's much cheaper than having to do a whole string comparison to make sure the strings have equal value. Edit: Mike, in C# strings are immutable, and literal strings with identical values all end pointing at the same string value. I imagine that's true for other languages as well that have immutable strings. In Ruby, which has mutable strings, they offer a new data-type: symbols ("foo" vs. :foo, where the former is a mutable string, and the latter is an immutable identifier often used for Hash keys).
