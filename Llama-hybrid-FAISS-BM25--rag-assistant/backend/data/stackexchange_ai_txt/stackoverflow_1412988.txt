[site]: stackoverflow
[post_id]: 1412988
[parent_id]: 1412751
[tags]: 
If the largest is the first element, search for the second largest in [largest+1,end). Otherwise search in [begin,largest) and [largest+1,end) and take the maximum of the two. Of course, this has O(2n), so it's not optimal. If you have random-access iterators, you could do as quick sort does and use the ever-elegant recursion: template std::pair find_two_largest(const std::pair & lhs, const std::pair & rhs) { // implementation finding the two largest of the four values left as an exercise :) } template std::pair ::value_type , typename std::iterator_traits ::value_type > find_two_largest(RAIter begin, RAIter end) { const ptr_diff_t diff = end-begin; if( diff ::value_type , typename std::iterator_traits ::value_type > result_t; const result_t left = find_two_largest(begin,middle); const result_t right = find_two_largest(middle,end); return find_two_largest(left,right); } This has O(n) and shouldn't make more comparisons than NomeN's implementation .
