[site]: stackoverflow
[post_id]: 1099863
[parent_id]: 1094413
[tags]: 
As EJD said, you can't verify the absence of errors. This means there are always more tests you could write. Any of these could be useful. What you need to understand is that unit-testing (and other types of automated testing you use for development purposes) can help with development, but should never be viewed as a replacement for formal QA. Some tests are much more valuable than others. There are parts of your code that change a lot more frequently, are more prone to break, etc. These are the most economical tests. You need to balance out the amount of testing you agree to take on as a developer. You can easily overburden yourself with unmaintainable tests. IMO, unmaintainable tests are worse than no tests because they: Turn others off from trying to maintain a test suite or write new tests. Detract from you adding new, meaningful functionality. If automated testing is not a net-positive result, you should ditch it like other engineering practices. What should I test? Test the "Happy Path" - this ensures that you get interactions right, and that things are wired together properly. But you don't adequately test a bridge by driving down it on a sunny day with no traffic. Pragmatic Unit Testing recommends you use Right-BICEP to figure out what to test. "Right" for the happy path, then B oundary conditions, check any I nverse relationships, use another method (if it exists) to C ross-check results, force E rror conditions, and finally take into account any P erformance considerations that should be verified. I'd say if you are thinking about tests to write in this way, you're most likely figure out how to get to an adequate level of testing. You'll be able to figure out which ones are more useful and when. See the book for much more info. Test at the right level As others have mentioned, unit tests are not the only way to write automated tests. Other types of frameworks may be built off of unit tests, but provide mechanisms to do package level, system or integration tests. The best bang for the buck may be at a higher level, and just using unit testing to verify a single component's happy path. Don't be discouraged I'm painting a more grim picture here than I expect most developers will find in reality. The bottom line is that you make a commitment to learn how to write tests and write them well. But don't let fear of the unknown scare you into not writing any tests. Unlike production code, tests can be ditched and rewritten without many adverse effects.
