[site]: stackoverflow
[post_id]: 4839823
[parent_id]: 4839459
[tags]: 
The problem is the following line in your controller action: var repository = new PostsRepository(); Here you are tying your controller to a particular implementation of the repository making it very difficult to unit test in isolation. In order to achieve weaker coupling between your controller and data access layer I would recommend you using constructor injection: public class PostsController: Controller { private readonly IPostsRepository _repository; public PostsController(IPostsRepository repository) { _repository = repository; } public ActionResult Index() { var posts = _repository.GetAllPosts(); return View(posts); } } Now your controller is completely decoupled from a particular implementation of a repository which might depend on a database, etc. Now you could use a mocking framework such as Rhino Mocks or Moq to provide a dummy implementation of this repository for the unit test. Personally I like very much MVCContrib TestHelper which works with Rhino Mocks and allows for very elegant unit tests of controller actions. So once you've decoupled your controller from a specific implementation of the repository as I showed you could have the following unit test: [TestMethod] public void PostsController_Index_Action_Should_Fetch_All_Posts_From_Repository() { // arrange var postsRepositoryStub = MockRepository.GenerateStub (); var sut = new PostsController(postsRepositoryStub); var expectedPosts = new Post[0]; postsRepositoryStub.Stub(x => x.GetAllPosts).Return(expectedPosts); // act var actual = sut.Index(); // assert actual .AssertViewRendered() .WithViewData >() .ShouldBe(expectedPosts); }
