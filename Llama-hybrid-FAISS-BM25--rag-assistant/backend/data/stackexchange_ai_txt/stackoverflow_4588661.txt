[site]: stackoverflow
[post_id]: 4588661
[parent_id]: 4587021
[tags]: 
I think the polymorphic solution that you describe is the most elegant OO-way to do this. What do you find inelegant about it? As for using the actual data type and modifier types, I suggest that you look at using implicit operator overloads. You can define your class with all of the behaviour you need, but provide a conversion to/from the "value" type, so you can get/assign values as though it is that type. An example will help: public class MyFloat { float innerValue; // private constructor; instantiate using a float directly private MyFloat(float innerValue) { this.innerValue = innerValue; } public string Description { get { return "some metadata"; } } public int NumberOfFrames { get; set; } // conversion from MyFloat to float public static implicit operator float(MyFloat mine) { return mine.innerValue; // you can access private members here } // conversion from float to MyFloat public static implicit operator MyFloat(float val) { return new MyFloat(val); // use the private constructor } } In usage, then, you can do things like this: MyFloat mine = 9f; mine.NumberOfFrames = 15; or… if(mine > 0f)… As for the tedium of instantiation, I think this sort of scenario is the perfect candidate for an internal DSL/fluent interface. You could make up something expressive and terse, like: var animatedObject = Sprite.with(RandomMotion.animatated_between(0f).and(10f)) .lasts(4).seconds; var otherObject = Sprite.with ().starts_at(100, 0); var yetAnother = Sprite.with(SteadyMotion.at(7f)) .starts_at(100, 200) .weighing(.5f) .lasts(15).frames;
