[site]: stackoverflow
[post_id]: 701775
[parent_id]: 701699
[tags]: 
My reading of your question tells me you are confused with the lifetime of temporaries more than anything else. I think it will help if you put a couple of cout s as below: struct Test{ int i; Test(int ii):i(ii){ std::cout Now run, and you should be able to see what exactly is going on under the hoods. (Style Check:Not checking for self-assignment is not a good thing.) It will also help if you refer the standard: It discusses something similar to what you have posted: 12.2 Temporary objects 4 There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression. The first context is when a default constructor is called to initialize an element of an array. If the constructor has one or more default arguments, the destruction of every temporary created in a default argument expression is sequenced before the construction of the next array element, if any. 5 The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except as specified below. A temporary bound to a reference member in a constructor’s ctor-initializer (12.6.2) persists until the constructor exits. A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call. A temporary bound to the returned value in a function return statement (6.6.3) persists until the function exits. A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the full-expression containing the new-initializer. struct S { int mi; const std::pair & mp; }; S a { 1, {2,3} }; S* p = new S{ 1, {2,3} }; // Creates dangling reference [ Note: This may introduce a dangling reference, and implementations are encouraged to issue a warning in such a case. —end note ] The destruction of a temporary whose lifetime is not extended by being bound to a reference is sequenced before the destruction of every temporary which is constructed earlier in the same full-expression. If the lifetime of two or more temporaries to which references are bound ends at the same point, these temporaries are destroyed at that point in the reverse order of the completion of their construction. In addition, the destruction of temporaries bound to references shall take into account the ordering of destruction of objects with static, thread, or automatic storage duration (3.7.1, 3.7.2, 3.7.3); that is, if obj1 is an object with the same storage duration as the temporary and created before the temporary is created the temporary shall be destroyed before obj1 is destroyed; if obj2 is an object with the same storage duration as the temporary and created after the temporary is created the temporary shall be destroyed after obj2 is destroyed. Example: struct S { S(); S(int); friend S operator+(const S&, const S&); ~S(); }; S obj1; const S& cr = S(16)+S(23); S obj2; the expression C(16)+C(23) creates three temporaries. A first temporary T1 to hold the result of the expression C(16) , a second temporary T2 to hold the result of the expression C(23) , and a third temporary T3 to hold the result of the addition of these two expressions. The temporary T3 is then bound to the reference cr . It is unspecified whether T1 or T2 is created first. On an implementation where T1 is created before T2 , it is guaranteed that T2 is destroyed before T1 . The temporaries T1 and T2 are bound to the reference parameters of operator+ ; these temporaries are destroyed at the end of the full-expression containing the call to operator+ . The temporary T3 bound to the reference cr is destroyed at the end of cr ’s lifetime, that is, at the end of the program. In addition, the order in which T3 is destroyed takes into account the destruction order of other objects with static storage duration. That is, because obj1 is constructed before T3 , and T3 is constructed before obj2 , it is guaranteed that obj2 is destroyed before T3 , and that T3 is destroyed before obj1 .
