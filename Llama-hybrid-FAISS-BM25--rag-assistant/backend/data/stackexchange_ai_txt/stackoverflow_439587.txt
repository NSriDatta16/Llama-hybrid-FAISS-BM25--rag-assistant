[site]: stackoverflow
[post_id]: 439587
[parent_id]: 439540
[tags]: 
The reason "&MyFrameGrabber::HookFunction" cannot be converted to a BUF_HOOK_FUNCTION_PTR is that, being a member of the class, it has implicitly as first parameter the "this" pointer, thus you cannot convert a member function to a non-member function: the two signatures look the same but are actually different. I would declare an interface, defining the function to call, have your class implement it and pass the object itself instead of the callback (you can think of an interface as the object-oriented replacement of a function pointer): class IHookInterface{ public: virtual long HookFunction(long, long, void*) = 0; }; class HookClass : public IHookInterface{ public: virtual long Hook(long, long, void*) { // your code here... } }; // new definition: ThirdPartyGrab (..., IHookInterface, ...); EDIT - other possible solution in case you cannot modify the library: use a singleton rather than a static function. class HookClass{ public: static HookClass& instance(){ static HookClass _instance; return _instance; } long Hook(long, long, void*) { // your code here... } }; long call_hook(long x,long y,void * z){ return HookClass::instance().Hook(x,y,z); } SECOND EDIT: you might slightly modify the singleton class with an initialization method to call the constructor with the proper parameters, but maybe it is not more elegant than the following solution, which is simpler: class HookClass{ public: HookClass(string x,string y...){ } long Hook(long, long, void*) { // your code here... } }; static HookClass * hook_instance = 0; long call_hook(long x,long y,void * z){ if (0 != hook_instance){ return hook_instance->Hook(x,y,z); } } int main(){ hook_instance = new HookClass("x","y"); ThirdPartyGrab(..., call_hook, ...); }
