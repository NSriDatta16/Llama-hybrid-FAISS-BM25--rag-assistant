[site]: stackoverflow
[post_id]: 4573947
[parent_id]: 4573682
[tags]: 
I would strongly suggest not using threads unless you absolutely have to. The problem is that you have to be extremely careful to avoid race conditions and other synchronisation problems. For instance, your GUI framework library is probably not expecting to be called from multiple threads, and so your //show packets here routine may confuse it a lot. Instead I would suggest, if possible, reading the packets from the main thread. You don't say which GUI framework you're using; since you're using C++ I'll assume Qt since that's quite common, but all other frameworks have similar functionality. What you need to do is: Call pcap_setnonblock() to put the capture descriptor in non-blocking mode Call pcap_get_selectable_fd() to get a file descriptor to monitor for events Use a QSocketNotifier object (passing the file descriptor from the previous step as the socket parameter) to monitor the file descriptor for events When the event fires, call pcap_dispatch() to dispatch packets For maximum portability, also call pcap_dispatch() on a timer, because select() doesn't work well on pcap sockets on some OSs. (As to why your code is currently crashing - note that you probably want to pass handler rather than &handler as the parameter to pthread_create() . But just fixing that may lead to strange unreliability later - so going single-threaded is almost certainly the way forward!)
