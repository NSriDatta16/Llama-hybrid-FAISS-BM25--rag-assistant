[site]: stackoverflow
[post_id]: 3597055
[parent_id]: 3596645
[tags]: 
I'd go with SQL Server for this. Obviously you'd have to serialize your data to a blob, but any solution would have to do this (at least behind the scenes). You would then just have a table like CREATE TABLE Stack (Id int identity, Data varbinary(MAX)) Polling the database isn't necessary. SQL Server has a query notification service where you just give it a query and it will notify you when the results would be different. Your notification query would just be SELECT * FROM Stack Locking is the database's problem, not yours. You would just have every consumer run a query (or stored procedure) that uses a transaction to return the most recent entry (the row with the highest Id) and delete it at the same time. If the query returns a result, process it and run it again. If the query returns no results, see #2. Here's a sample query: BEGIN TRANSACTION SELECT Data FROM Stack WHERE Id = (SELECT MAX(Id) FROM Stack) DELETE FROM Stack WHERE Id = (SELECT MAX(Id) FROM Stack) COMMIT Here's a more elegant version that doesn't even require an explicit transaction: DELETE Stack OUTPUT DELETED.Data WHERE Id = (SELECT MAX(Id) FROM Stack) If you want to do batch processing of 10 items at a time, you would use SQL like this: DELETE Stack OUTPUT DELETED.* WHERE Id IN (SELECT TOP 10 Id FROM Stack ORDER BY Id DESC)
