[site]: stackoverflow
[post_id]: 4047747
[parent_id]: 4046192
[tags]: 
The short answer is to use madvise(addr, len, MADV_DONTFORK) on any userspace buffers you give to your driver. This tells the kernel that the mapping should not be copied from parent to child and so there is no CoW. The drawback is that the child inherits no mapping at that address, so if you want the child to then start using the driver it will need to remap that memory. But that is fairly easy to do in userspace. Update : A buffer on the stack is problematic, I'm not sure you can make it safe in general. You can't mark it DONTFORK , because your child might be running on that stack page when it forks, or (worse in a way) it might do a function return later and hit the unmapped stack page. (I even tested this, you can happily mark your stack DONTFORK, bad things happen when you fork). The other way to avoid a CoW is to create a shared mapping, but you can't map your stack shared for obvious reasons. That means you risk a CoW if you fork. Even if the child "just" execs it might still touch the stack page and cause a CoW, leading to the parent getting a different page, which is bad. The one minor point in your favor is that code using an on-stack buffer only needs to worry about code it calls forking, ie. you can't use an on-stack buffer after the function has returned. So you only need to audit your callees, and if they never fork you're safe, but that still may be infeasible, and is fragile if the code ever changes. I think you really want to have all memory that is given to your driver to come from a custom allocator in userspace. It shouldn't be that intrusive. The allocator can either mmap your device directly, as the other answer suggested, or just use anonymous mmap , madvise(DONTFORK) , and probably mlock() to avoid swap out.
