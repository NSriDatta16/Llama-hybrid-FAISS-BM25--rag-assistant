[site]: stackoverflow
[post_id]: 5567385
[parent_id]: 5567168
[tags]: 
in view of edited question: sorry, I fail to understand what you are doing. you have an element. at some point the element is turned into an object that gets serialised (all of it? prototypes etc?). you then take that data and convert to an object again but want to preserve the uid? why? I don't understand how the uid matters much here... Using global browser storage also serialises to string so that won't help much. Are we talking survival of page loads here or just attach/detach/overwrite elements? If the latter, this can work with some tweaking. (function() { var Storage = {}; Element.implement({ saveElement: function() { var uid = document.id(this).uid; Storage[uid] = this; return this; } }); this.restoreElement = function(uid) { return Storage[uid] || null; } })(); var foo = document.id("foo"), uid = foo.uid; console.log(uid); foo.saveElement().addEvent("mouseenter", function() { alert("hi"); } ); document.id("container").set("html", ""); setTimeout(function() { var newElement = restoreElement(uid); if (newElement) newElement.inject(document.body); console.log(newElement.uid); }, 2000); http://jsfiddle.net/dimitar/7mwmu/1/ this will allow you to remove an element and restore it later. keep in mind that i do container.set("html", ""); which is not a great practice. if you do .empty() , it will GC the foo and it will wipe it's storage so the event won't survive. same for foo.destroy() - you can 'visually' restore the element but nothing linked to it will work (events or fx). you can get around that by using event delegation, however. also, you may want to store parent node etc so you can put it back to its previous place.
