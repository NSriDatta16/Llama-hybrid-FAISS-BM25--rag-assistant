[site]: stackoverflow
[post_id]: 238662
[parent_id]: 
[tags]: 
Challenge: elegantly LINQify this procedural code

string[] filesOfType1 = GetFileList1(); string[] filesOfType2 = GetFileList2(); var cookieMap = new Dictionary (); Action >> addToMap = (filename, pairGetter) => { KeyValuePair cookiePair; try { cookiePair = pairGetter(filename); } catch { Console.WriteLine("An error was encountered while trying to read " + file + "."); return; } if (cookieMap.ContainsKey(cookiePair.Key)) { if (cookiePair.Value.Count > cookieMap[cookiePair.Key].Count) { cookieMap[cookiePair.Key] = cookiePair.Value; } } else { cookieMap.Add(cookiePair.Key, cookiePair.Value); } }; foreach (string file in filesOfType1) { addToMap(file, GetType1FileCookiePair); } foreach (string file in filesOfType2) { addToMap(file, GetType2FileCookiePair); } Salient features that must be preserved: Files of type 1 are more important than files of type 2; i.e. if a file of type 1 maps to a (key, value1) combination and a file of type 2 maps to a (key, value2) combination, then we add (key, value1) to cookieMap and not (key, value2). Edit: as pointed out by Bevan, this is not satisfied by my original procedural code. Secondarily, CookieContainer s with a higher Count have higher priority, i.e. if there are two (key, value) combos for the same key and both from the same filetype, we choose the one with higher value.Count . Per-case exception handling is a must; screwing up a single file-reading should just allows us to note that and continue. My best attempt started like this: var cookieMap = (filesOfType1.Select(file => GetType1FileCookiePair(file)) .Concat(filesOfType2.Select(file => GetType2FileCookiePair(file)))) .GroupBy(pair => pair.Key) .Select(/* some way of selecting per the above bullets */) .ToDictionary(pair => pair.Key, pair => pair.Value); But it's inelegant and filling in that comment block seems like a bitch. Right now I'm happy to stay procedural, but I thought that it might be a fun challenge to see if people can come up with something really clever.
