[site]: stackoverflow
[post_id]: 4239632
[parent_id]: 
[tags]: 
How would one write a "meta if else if.." in C++?

I am just learning basics of metaprogramming in C++, and I thought it would be nice to see how the following question would be solved by others. Also, it would be very nice to see a solution using Boost metaprogramming libraries because I consider them as the dark corner for me. So the question is, could this be rewritten more elegantly? Assume that we have the following struct: template struct type_factory { typedef typename type_factory_impl ::type type; }; This struct is supposed to typedef type , depending on the value of size . type_factory_impl is the implementation of type_factory . The algorithm that is used to determine type is: if(size % bits ::value == 0) typedef unsigned long long type; else if(size % bits ::value == 0) typedef unsigned long type; else if(size % bits ::value == 0) typedef unsigned int type; else if(size % bits ::value == 0) typedef unsigned short int type; else if(size % bits ::value == 0) typedef unsigned char type; else static_assert(false, "The type should be multiple of 'unsigned char' size"); I have solved this metaprogram in two ways. The first one is using pattern matching directly, and the second one using meta if-else . Consider the following as common code between both solutions: #include #include typedef unsigned char uchar; typedef unsigned short int usint; typedef unsigned int uint; typedef unsigned long ulong; typedef unsigned long long ulonglong; // Returns how many bits in Unsigned_Type template struct bits { enum { value = sizeof(Unsigned_Type)*CHAR_BIT }; }; // struct type_factory_impl ... template struct type_factory { typedef typename type_factory_impl ::type type; }; int main() { auto a = type_factory ::type(0); // unsigned char auto b = type_factory ::type(0); // unsigned short int auto c = type_factory ::type(0); // unsigned char auto d = type_factory ::type(0); // unsigned long auto e = type_factory ::type(0); // unsigned char auto f = type_factory ::type(0); // unsigned short int auto g = type_factory ::type(0); // unsigned char auto h = type_factory ::type(0); // unsigned long long } The first solution: template struct unsigned_char { typedef unsigned char type; static_assert(is_uchar, "error: size must be multiple of 'unsigned char' size"); }; template <> struct unsigned_char { typedef uchar type; }; template struct unsigned_short_int { typedef typename unsigned_char ::value == 0>::type type; }; template struct unsigned_short_int { typedef usint type; }; template struct unsigned_int { typedef typename unsigned_short_int ::value == 0, size>::type type; }; template struct unsigned_int { typedef uint type; }; template struct unsigned_long { typedef typename unsigned_int ::value == 0, size>::type type; }; template struct unsigned_long { typedef ulong type; }; template struct unsigned_long_long { typedef typename unsigned_long ::value == 0, size>::type type; }; template struct unsigned_long_long { typedef ulonglong type; }; template struct type_factory_impl { typedef typename unsigned_long_long ::value == 0, size>::type type; }; The second solution: template struct IF { typedef Else type; }; template struct IF { typedef Then type; }; template struct type_factory_impl { typedef typename IF ::value == 0, ulonglong, typename IF ::value == 0, ulong, typename IF ::value == 0, uint, typename IF ::value == 0, usint, typename IF ::value == 0, uchar, uchar>::type >::type >::type >::type >::type type; };
