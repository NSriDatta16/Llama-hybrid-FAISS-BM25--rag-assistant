[site]: stackoverflow
[post_id]: 3340002
[parent_id]: 
[tags]: 
Architecture problem: access-queue block

There's a resource manager class. It helps us to access devices. But, of course, it should look for not to give access to one device for 2 processes at the same time. At first I thought I wouldn't have any access queue. I thought there would be method like anyFree_devicename() that would return access handle if there is any free and NULL if no any. But, because of high concurrency for some devices, I've written accessQueue in every device. Now, when you try to access device your pid (process id) is inserted into such accessQueue and you can ask for your turn using special method. But, I found one problem: access Queues can block each other when you need few devicec in one command: Device1 Device2 1 2 2 1 And both of them would be blocked. inline bool API::Device::Device::ShallIUse(int pid) { if (amIFirst(pid)) return 1; // if I'm first I can use it anyway std::stack tempStorage; // we pass every element acessQ -> Temp while (acessQueue.front() != pid) // every process { //we take process pointer to look into it's queue API::ProcessManager::Process* proc = API::ProcessManager::TaskManager::me->giveProcess(acessQueue.front()); // list of devices this prosess needs now std::vector * dINeed = proc->topCommand()->devINeedPtr(); // an dsee if there any process for (int i = 0; i size() - 1); i++) { if (!dINeed[i]->mIFirst()) { while ( ! tempStorage.empty()) { acessQueue.push(tempStorage.top()); tempStorage.pop(); } return 0; } } tempStorage.push(acessQueue.front()); acessQueue.pop(); } return 1; I've written such algorithm some lime later but: It ruing all layer-based architecture Now It seems to work wrong. That's crazy! We simply look-trough all commands in nearly all processes and tring to push some of commands up on the access Queue. It works really slow.
