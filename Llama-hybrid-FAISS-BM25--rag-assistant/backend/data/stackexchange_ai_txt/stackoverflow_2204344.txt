[site]: stackoverflow
[post_id]: 2204344
[parent_id]: 2204224
[tags]: 
The thing to remember about networking is that you will be able to read as much data as has been received. Since your code is asking for 1024 bytes and you only read 1, then only 1 byte has been received. Since you are using a telnet client, it sounds like you have it configured in character mode. In this mode, as soon as you type a character, it will be sent. Try to reconfigure your telnet client in line mode. In line mode, the telnet client will wait until you hit return before it sends the entire line. On my telnet client. In order to do that, first I type ctrl-] to get to the telnet prompt and then type "mode line" to configure telnet in line mode. Update On further thought, this is actually a very good problem to have. In the real world, your data can get fragmented in unexpected ways. The client may make a single send() call of N bytes but the data may not arrive in a single packet. If your code can handle byte arriving 1 by 1, then you know it will work know matter how the data arrives. What you need to do is make sure that you accumulate your data across multiple receives. After your recv call returns, you should then append the data a buffer. Something like: char *accumulate_buffer = new char[BUF_LEN]; size_t accumulate_buffer_len = 0; ... bytes_recv = recv(fd, accumulate_buffer + accumulate_buffer_len, BUF_LEN - accumulate_buffer_len, 0); if (bytes_recv > 0) accumulate_buffer_len += bytes_recv; if (can_handle_data(accumulate_buffer, accumulate_buffer_len)) { handle_data(accumulate_buffer, accumulate_buffer_len); accumulate_buffer_len = 0; } This code keeps accumulating the recv into a buffer until there is enough data to handle. Once you handle the data, you reset the length to 0 and you start accumulating afresh.
