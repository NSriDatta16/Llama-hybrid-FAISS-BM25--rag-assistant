[site]: stackoverflow
[post_id]: 1452950
[parent_id]: 1380371
[tags]: 
So I'm a pretty critical person, and figure if I'm going to invest in a library, I'd better know what I'm getting myself into. I figure it's better to go heavy on the criticism and light on the flattery when scrutinizing; what's wrong with it has many more implications for the future than what's right. So I'm going to go overboard here a little bit to provide the kind of answer that would have helped me and I hope will help others who may journey down this path. Keep in mind that this is based on what little reviewing/testing I've done with these libs. Oh and I stole some of the positive description from Reed. I'll mention up top that I went with GMTL despite it's idiosyncrasies because the Eigen2 unsafeness was too big of a downside. But I've recently learned that the next release of Eigen2 will contain defines that will shut off the alignment code, and make it safe. So I may switch over. Update : I've switched to Eigen3. Despite it's idiosyncrasies, its scope and elegance are too hard to ignore, and the optimizations which make it unsafe can be turned off with a define. Eigen2/Eigen3 Benefits: LGPL MPL2, Clean, well designed API, fairly easy to use. Seems to be well maintained with a vibrant community. Low memory overhead. High performance. Made for general linear algebra, but good geometric functionality available as well. All header lib, no linking required. Idiocyncracies/downsides: (Some/all of these can be avoided by some defines that are available in the current development branch Eigen3) Unsafe performance optimizations result in needing careful following of rules. Failure to follow rules causes crashes. you simply cannot safely pass-by-value use of Eigen types as members requires special allocator customization (or you crash) use with stl container types and possibly other templates required special allocation customization (or you will crash) certain compilers need special care to prevent crashes on function calls (GCC windows) GMTL Benefits: LGPL, Fairly Simple API, specifically designed for graphics engines. Includes many primitive types geared towards rendering (such as planes, AABB, quatenrions with multiple interpolation, etc) that aren't in any other packages. Very low memory overhead, quite fast, easy to use. All header based, no linking necessary. Idiocyncracies/downsides: API is quirky what might be myVec.x() in another lib is only available via myVec[0] (Readability problem) an array or stl::vector of points may cause you to do something like pointsList[0][0] to access the x component of the first point in a naive attempt at optimization, removed cross(vec,vec) and replaced with makeCross(vec,vec,vec) when compiler eliminates unnecessary temps anyway normal math operations don't return normal types unless you shut off some optimization features e.g.: vec1 - vec2 does not return a normal vector so length( vecA - vecB ) fails even though vecC = vecA - vecB works. You must wrap like: length( Vec( vecA - vecB ) ) operations on vectors are provided by external functions rather than members. This may require you to use the scope resolution everywhere since common symbol names may collide you have to do length( makeCross( vecA, vecB ) ) or gmtl::length( gmtl::makeCross( vecA, vecB ) ) where otherwise you might try vecA.cross( vecB ).length() not well maintained still claimed as "beta" documentation missing basic info like which headers are needed to use normal functionalty Vec.h does not contain operations for Vectors, VecOps.h contains some, others are in Generate.h for example. cross(vec&,vec&,vec&) in VecOps.h, [make]cross(vec&,vec&) in Generate.h immature/unstable API; still changing. For example "cross" has moved from "VecOps.h" to "Generate.h", and then the name was changed to "makeCross". Documentation examples fail because still refer to old versions of functions that no-longer exist. NT2 Can't tell because they seem to be more interested in the fractal image header of their web page than the content. Looks more like an academic project than a serious software project. Latest release over 2 years ago. Apparently no documentation in English though supposedly there is something in French somewhere. Cant find a trace of a community around the project. LAPACK & BLAS Benefits: Old and mature. Downsides: old as dinosaurs with really crappy APIs
