[site]: stackoverflow
[post_id]: 5714682
[parent_id]: 5710942
[tags]: 
C++ people constantly ask "why are you using C and not C++". I would like to know why I should be using C++ and not C. First of all, one must come to the realization that these two languages are both ancient , and they both have horrible syntax. The debate often seems to be focused around "you should use C++, because C++ is modern and C is old". In reality, the debate is about one's favourite flavour of dinosaur meat. Instead of demanding a modern language suitable for embedded, people preach C++, which never was anything but a weird temporary hybrid language with C compatibility, in wait for some better language to be invented. Second, there is a myth saying that C++ is object-oriented and C is not. The buzzword object-orientation boils down to three things: 1) Modular design with autonomous objects, that aren't tightly coupled to anything else. This is a very important attribute of any program. 2) Private encapsulation of data and reduced scope of data. This is a rather important attribute of any program. 3) Polymorphism of classes: classes that inherit other classes and behave differently when inherited. Polymorphism is quite useful, but far less so in small embedded systems. 1) can be fully achieved in both C and C++, it is a matter of program design rather than language syntax. And this is the most important OO attribute by far! Unfortunately, there is nothing in any language standard telling you how to design your program. There is nothing in C++ that will automatically lead to a better modular design, it is all in the hands of the programmer. 2) can be achieved in both C and C++. Both languages have reduced scope of data. In C, private encapsulation is done through somewhat horrible syntax with the static keyword on file scope variables. In C++, it is done more elegantly with private/protected. 3) can be achieved in both C and C++. Both languages have horrible syntax for this. In C you would fiddle around with structs and function interfaces to achieve it. In C++, you can do it in less horrible ways through heritage and making functions "virtual". The C++ syntax and the needed implementation is still one big mess however, although a bit better than the C way. Neither language will give you OO-related things in pretty, elegant ways. What C++ gains from somewhat less icky syntax, it loses when you start wading through undefined/unspecified/implementation-defined behavior. It would seem that the whole OO argument isn't a big deal, C++ is not a huge improvement when it comes to OO. Then what else is there in C++ that I would need in my embedded system? One thing stands out: standardized inline assembler syntax. This is perhaps the biggest advantage C++ has over C, for embedded systems. Apart from that, excpetions, STL, templates, RTTI, overator overloading, function overloading etc etc, are all more or less useless features one can live without. Then in the end, reality comes to slap you in the face: there are extremely few, if any, embedded compilers that have managed to fully implement C++ according to the standard.
