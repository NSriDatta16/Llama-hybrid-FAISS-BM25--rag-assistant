[site]: stackoverflow
[post_id]: 2322304
[parent_id]: 
[tags]: 
How to display PDF attachment in IE6

I have an ASP.net application which returns a binary PDF file (stored from the database, which was previously uploaded) to the client. The code I have works fine for all browsers, except for internet explorer 6 (story of my life!). In IE6, when a user clicks open, Adobe reports the error: "There was an error opening this document. The file cannot be found." When the user clicks save, the PDF saves fine and can be opened by double clicking it. I am stumped. Google has given suggestions of caching (setting cachecontrol to private etc) and I have tried all of those but nothing has worked. The wierd(er) behaviour is when I generate a PDF in my ASP .net server layer (using NFop) from scratch, IE will open it fine (using the SAME code!). Here is my code for sending the binary data across the wire: // Firefox doesn't like spaces in filenames. filename = filename.Replace(" ", "_"); string extension = Path.GetExtension(filename); string contentType; switch (extension) { case "pdf": contentType = "application/pdf"; break; default: contentType = "application/x-unknown"; break; } context.Response.Clear(); context.Response.AddHeader("content-disposition", "attachment;filename=" + filename); context.Response.Charset = ""; context.Response.ContentType = contentType; context.Response.BinaryWrite(data); context.Response.Flush(); Here are application versions: ASP .net 3.5 IE6.0.2900.2180.xpsp_s List item p2_gdr.091208-2028 Adobe Reader version 8.0.0 Windows XP SP 2 SQL Server 2008 Any help/suggestions would be much appreciated. Thanks :) EDIT: I have plugged in Fiddler to view the headers and sure enough it does appear to be a caching issue. grrr! When my NFop PDF (the one that works) is uploaded, it is sending cache-control = private. When my attachment PDF (the one that doesn't work) is uploaded, it sends no-cache. I have looked in the Response object and both appear to have the same headers when I call context.Response.Flush(). Still stumped! SOLVED : Somewhere in our framework was a rogue method which was being invoked using reflection: /// /// Sets the expiratoin of the request and force no cache /// protected void SetCacheExpiration(HttpContext context) { //sets the cache to expire immediately context.Response.Cache.SetCacheability(HttpCacheability.NoCache); context.Response.Cache.SetSlidingExpiration(true); context.Response.Cache.SetExpires(DateTime.Now); context.Response.Cache.SetMaxAge(new TimeSpan(0, 0, 0)); context.Response.Cache.SetNoStore(); context.Response.Cache.SetAllowResponseInBrowserHistory(false); context.Response.Cache.SetValidUntilExpires(false); context.Response.Cache.SetRevalidation(HttpCacheRevalidation.AllCaches); } Thanks for your help, caching! It is interesting that the only browser that actually didn't cache the download (when opened) was IE6.
