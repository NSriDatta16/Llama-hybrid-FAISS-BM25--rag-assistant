[site]: stackoverflow
[post_id]: 4833751
[parent_id]: 3926164
[tags]: 
I've been hitting this error repeatedly, and was unable to figure out how to make it stop; but I finally found an end-run around the whole issue that works quite well, and only takes a little more work: Don't use Apple's MKReverseGeocoder at all -- instead, directly call Google's reverse-geocoding API (this is apparently the same service that MKReverseGeocoder does behind the scenes). You can get back either JSON or XML (your preference), which you will then have to parse, but that isn't too hard. For example, since my app is using ASIHTTPRequest , this is what it looks like (although this would also be easy to do with do with Apple's native APIs such as NSURLConnection ): #pragma mark - #pragma mark CLLocationManagerDelegate - (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation { // Be careful: My code is passing sensor=true, because I got the lat/long // from the iPhone's location services, but if you are passing in a lat/long // that was obtained by some other means, you must pass sensor=false. NSString* urlStr = [NSString stringWithFormat: @"http://maps.googleapis.com/maps/api/geocode/xml?latlng=%f,%f&sensor=true", newLocation.coordinate.latitude, newLocation.coordinate.longitude]; NSURL* url = [NSURL URLWithString:urlStr]; self.reverseGeocoderRequest = [ASIHTTPRequest requestWithURL:url]; self.reverseGeocoderRequest.delegate = self; [self.reverseGeocoderRequest startAsynchronous]; } By the way, Google's API has rules, just like Apple's does. Make sure you read the docs, especially regarding quotas.
