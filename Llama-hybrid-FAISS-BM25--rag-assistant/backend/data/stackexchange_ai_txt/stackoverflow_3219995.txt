[site]: stackoverflow
[post_id]: 3219995
[parent_id]: 3218104
[tags]: 
You need to modify your table(s) to have account_id as the first column in the clustered index. Simply adding a non-clustered index on account_id will not suffice, because queries will reach the index tipping point and ignore the index. Also, partitioning the table on account_id will not help on its own. Partitioning is a storage and ETL solution, not a performance one. So if you currently have a table name Transactions currently defined as: create table Transactions ( TransactionId int not null primary key, TransactionDate datetime not null, Amount money not null, AccountId int not null, constraint FKAccountId foreign key AccountId references Accounts(AccountId)); It would have to be changed so that the primary key is not clustered and the clustering index is on (AccountId, TransactionId): create table Transactions ( TransactionId int not null , TransactionDate datetime not null, Amount money not null, AccountId int not null, constraint FKAccountId foreign key AccountId references Accounts(AccountId), constraint PKTransactionId primary key nonclustered (TransactionId)); create clustered index cdxTransactions on Transactions (AccountId, TransactionId); This is just an example, I can't claim that I can model out of the blue yonder your correct data model. But the idea is that if your prevalent access pattern always filters by a column, that column is usually required to be part of the clustered index in a leftmost position. Only this way the query can do a range scan that limits all data read only to the relevant Account.
