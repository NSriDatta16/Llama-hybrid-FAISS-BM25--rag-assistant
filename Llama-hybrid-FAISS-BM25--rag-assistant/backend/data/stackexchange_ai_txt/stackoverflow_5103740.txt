[site]: stackoverflow
[post_id]: 5103740
[parent_id]: 2880903
[tags]: 
Boost.Spirit is not reserved to parse complicated structure. It is quite good at micro-parsing too, and almost match the compactness of the C + scanf snippet : #include #include #include using namespace boost::spirit::qi; int main() { std::string text = "foo: [3 4 5]\nbaz: 3.0"; std::istringstream iss(text); std::string line; while (std::getline(iss, line)) { int x, y, z; if(phrase_parse(line.begin(), line.end(), "foo: [">> int_ >> int_ >> int_ >> "]", space, x, y, z)) continue; float w; if(phrase_parse(line.begin(), line.end(), "baz: ">> float_, space , w)) continue; } } (Why they didn't add a "container" version is beyond me, it would be much more convenient if we could just write : if(phrase_parse(line, "foo: [">> int_ >> int_ >> int_ >> "]", space, x, y, z)) continue; But it's true that : It adds a lot of compile time overhead. Error messages are brutal. If you make a small mistake with scanf, you just run your program and immediately get a segfault or an absurd parsed value. Make a small mistake with spirit and you will get hopeless gigantic error messages from the compiler and it takes a LOT of practice with boost.spirit to understand them. So ultimately, for simple parsing I use scanf like everyone else...
