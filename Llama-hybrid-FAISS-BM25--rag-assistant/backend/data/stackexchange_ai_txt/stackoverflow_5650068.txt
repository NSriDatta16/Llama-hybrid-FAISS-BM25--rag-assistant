[site]: stackoverflow
[post_id]: 5650068
[parent_id]: 5437936
[tags]: 
I built a generic Tween Engine in java that you can use to animate anything, including your sprites. It's optimized for Android and games because it does not allocate anything at runtime, to avoid any garbage collection. Moreover, Tweens are pooled, so really: no garbage collection at all! You can see a complete demo here as an android application, or here as a WebGL html page (requires Chrome)! All you have to do is implement the TweenAccessor interface to add Tween support to all your sprites. You don't even have to change your Sprite class, just create a SpriteTweenAccessor class that implements TweenAccessor , and register it to the engine at initialization. Just have a look at the GetStarted wiki page ;) http://code.google.com/p/java-universal-tween-engine/ I'm also building a visual timeline editor that can be embedded in any application. It will feature a timeline similar to the Flash authoring tool and Expression Blend (a Silverlight dev tool). The whole engine is heavily documented (all public methods and classes have detailed javadoc), and the syntax is quite similar to Greensock's TweenMax/TweenLite engine that is used in the Flash world. Note that it supports every Robert Penner easing equation. // Arguments are (1) the target, (2) the type of interpolation, // and (3) the duration in seconds. Additional methods specify // the target values, and the easing function. Tween.to(mySprite, Type.POSITION_XY, 1.0f).target(50, 50).ease(Elastic.INOUT); // Possibilities are: Tween.to(...); // interpolates from the current values to the targets Tween.from(...); // interpolates from the given values to the current ones Tween.set(...); // apply the target values without animation (useful with a delay) Tween.call(...); // calls a method (useful with a delay) // Current options are: yourTween.delay(0.5f); yourTween.repeat(2, 0.5f); yourTween.repeatYoyo(2, 0.5f); yourTween.pause(); yourTween.resume(); yourTween.setCallback(callback); yourTween.setCallbackTriggers(flags); yourTween.setUserData(obj); // You can of course chain everything: Tween.to(...).delay(1.0f).repeat(2, 0.5f).start(); // Moreover, slow-motion, fast-motion and reverse play is easy, // you just need to change the speed of the update: yourTween.update(delta * speed); Of course, no tween engine would be complete without providing a way to build powerful sequences :) Timeline.createSequence() // First, set all objects to their initial positions .push(Tween.set(...)) .push(Tween.set(...)) .push(Tween.set(...)) // Wait 1s .pushPause(1.0f) // Move the objects around, one after the other .push(Tween.to(...)) .push(Tween.to(...)) .push(Tween.to(...)) // Then, move the objects around at the same time .beginParallel() .push(Tween.to(...)) .push(Tween.to(...)) .push(Tween.to(...)) .end() // And repeat the whole sequence 2 times // with a 0.5s pause between each iteration .repeatYoyo(2, 0.5f) // Let's go! .start(); I hope you're convinced :) There are a lot of people already using the engine in their games or for android UI animation.
