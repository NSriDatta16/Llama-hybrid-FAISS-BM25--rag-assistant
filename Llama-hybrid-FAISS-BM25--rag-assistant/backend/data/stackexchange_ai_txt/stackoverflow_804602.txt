[site]: stackoverflow
[post_id]: 804602
[parent_id]: 804196
[tags]: 
One design pattern where ref is useful is a bidirectional visitor. Suppose you had a Storage class that can be used to load or save values of various primitive types. It is either in Load mode or Save mode. It has a group of overloaded methods called Transfer , and here's an example for dealing with int values. public void Transfer(ref int value) { if (Loading) value = ReadInt(); else WriteInt(value); } There would be similar methods for other primitive types - bool , string , etc. Then on a class that needs to be "transferable", you would write a method like this: public void TransferViaStorage(Storage s) { s.Transfer(ref _firstName); s.Transfer(ref _lastName); s.Transfer(ref _salary); } This same single method can either load the fields from the Storage , or save the fields to the Storage , depending what mode the Storage object is in. Really you're just listing all the fields that need to be transferred, so it closely approaches declarative programming instead of imperative. This means that you don't need to write two functions (one for reading, one for writing) and given that the design I'm using here is order-dependent then it's very handy to know for sure that the fields will always be read/written in identical order. The general point is that when a parameter is marked as ref , you don't know whether the method is going to read it or write to it, and this allows you to design visitor classes that work in one of two directions, intended to be called in a symmetrical way (i.e. with the visited method not needing to know which direction-mode the visitor class is operating in). Comparison: Attributes + Reflection Why do this instead of attributing the fields and using reflection to automatically implement the equivalent of TransferViaStorage ? Because sometimes reflection is slow enough to be a bottleneck (but always profile to be sure of this - it's hardly ever true, and attributes are much closer to the ideal of declarative programming).
