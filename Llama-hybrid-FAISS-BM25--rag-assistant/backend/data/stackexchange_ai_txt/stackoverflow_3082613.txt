[site]: stackoverflow
[post_id]: 3082613
[parent_id]: 2955921
[tags]: 
So, the relevant part of the spec is 6.7/4: An implementation is permitted to perform early initialization of other local objects with static storage duration under the same conditions that an implementation is permitted to statically initialize an object with static storage duration in namespace scope (3.6.2). Otherwise such an object is initialized the first time control passes through its declaration; such an object is considered initialized upon the completion of its initialization. Assuming the second part holds ( object is initialized the first time control passes through its declaration ), your code can be considered thread safe. Reading through 3.6.2, it appears the early initialization permitted is converting dynamic-initialization to static-initialization . Since static-initialization must happen before any dynamic-initialization and since I can't think of any way to create a thread until you get to dynamic-initialization , such an early initialization would also guarantee the constructor would get called a single time. Update So, in respect to calling the some_type constructor for the_const_thingy , your code is correct according to the rules. This leaves the issue about overwriting the reference which is definitely not covered by the spec. That said, if you are willing to assume that references are implemented via pointers (which I believe is the most common way to do that), then all you are going to do is overwrite a pointer with the value that it already holds. So my take is that this should be safe in practice.
