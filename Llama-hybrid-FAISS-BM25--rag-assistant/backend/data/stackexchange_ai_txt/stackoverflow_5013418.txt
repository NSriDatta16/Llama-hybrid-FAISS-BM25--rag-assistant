[site]: stackoverflow
[post_id]: 5013418
[parent_id]: 5011994
[tags]: 
I solved this by making a new class derived from Gallery widget class. I called mine ZoomableGallery. I had mine implement a few gesture listeners to handle scaling and double tap for zoom on non multi-touch or pre 2.0 devices. public class ZoomableGallery extends Gallery implements OnDoubleTapListener, OnGestureListener, OnScaleGestureListener {} The key is to not have your inner widgets consume the touch events. It might seem like the right idea to create a ZoomablePannableImageView that responds to touch events and zooms in and out. And it seems like a great idea because this reusable component would work well outside of the Gallery as well. However I don't think it can be made to work well. The best way is to create a ZoomableImageView that doesn't handle touch events or set any gesturelisteners, but instead provides an api for setting the scale factor and panning in the X,Y dimensions as regular methods. Then once you've gone this route you can have your descendant of the Gallery widget handle all the touch events smartly only forwarding the pieces of the touch motion that need to go to the widget. And what I mean by this is if say we are zoomed into the image and we are viewing almost the whole image except 4 pixels are out of screen to the left. If we receive a touch event to scroll the image 8 pixels to the right. Our gallery widget needs to send the image widget a pan 4 pixels right message. And then it needs to also consume 4 pixels of horizontal motion itself. So that not only does the image view reveal it's complete left edge, but then it slides a little to the right possibly revealing the next imageview in the gallery adapter. The key functions to override in your new class that extends Gallery are: @Override public boolean onTouchEvent(MotionEvent event) {} and @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {} I don't want to copy and paste my entire implementation because it is messy and hard to understand and it also can display some glitchy behavior under stress. But I don't think that's because of the strategy I employed but simply because I haven't cleaned it up yet. The key is to remember what mode the user is in (zooming, or panning inside an image, panning the entire gallery) In the case where the user is panning inside an image here is what my code looks like handling the switch statement inside of the onScroll method: case INNERDRAG: float unhandledPan = mCurrentPannable.panHorizontally(distanceX); // Negative unhandled pan means that we are shifting over to the image to the right if (unhandledPan != 0.0f) { if (unhandledPan In this code mCurrentPannable refers to the view that is currently "selected" by the gallery. Pannable is just an interface that defines panHorizontally and panVertically as functions that do two things: attempt to pan the inner view by so many pixels AND if that amount of pan takes it beyond the edges of what it can pan, it returns the number of pixels that it couldn't handle. Then the gallery instead of passing the same arguments to super.onScroll it passes only what is left unconsumed by the pan. I hope this helps.
