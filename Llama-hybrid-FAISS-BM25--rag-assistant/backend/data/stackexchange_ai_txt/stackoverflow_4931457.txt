[site]: stackoverflow
[post_id]: 4931457
[parent_id]: 4921899
[tags]: 
I largely agree with what Sisyphus has said, particularly the bit about not constricting yourself to the 'rules' of DDD that may lead to a pretty illogical solution. In terms of your problem, I have come across the situation many times, and I would term 'ProcessType' as a lookup . Lookups are objects that 'define', and have no references to other entities; in DDD terminology, they are value objects. Other examples of what I would term a lookup may be a team member's 'RoleType', which could be a tester, developer, project manager for example. Even a person's 'Title' I would define as a lookup - Mr, Miss, Mrs, Dr. I would model your process aggregate as: public class Process { public ProcessType { get; } } As you say, these type of objects typically need to populate dropdowns in the UI and therefore need their own data access mechanism. However, I have personally NOT created 'repositories' as such for them, but rather a 'LookupService'. This for me retains the elegance of DDD by keeping 'repositories' strictly for aggregate roots. Here is an example of a command handler on my app server and how I have implemented this: Team Member Aggregate: public class TeamMember : Person { public Guid TeamMemberID { get { return _teamMemberID; } } public TeamMemberRoleType RoleType { get { return _roleType; } } public IEnumerable Availability { get { return _availability.AsReadOnly(); } } } Command Handler: public void CreateTeamMember(CreateTeamMemberCommand command) { TeamMemberRoleType role = _lookupService.GetLookupItem (command.RoleTypeID); TeamMember member = TeamMemberFactory.CreateTeamMember(command.TeamMemberID, role, command.DateOfBirth, command.FirstName, command.Surname); using (IUnitOfWork unitOfWork = UnitOfWorkFactory.CreateUnitOfWork()) _teamMemberRepository.Save(member); } The client can also make use of the LookupService to populate dropdown's etc: ILookup roles = _lookupService.GetLookup ();
