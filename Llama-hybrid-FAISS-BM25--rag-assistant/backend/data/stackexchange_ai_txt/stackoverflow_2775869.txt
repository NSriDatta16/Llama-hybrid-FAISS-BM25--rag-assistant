[site]: stackoverflow
[post_id]: 2775869
[parent_id]: 2774042
[tags]: 
A. For objects not derived from DependencyObject , you don't have access to SetBinding() or ClearBinding() methods. Instead you may call the static methods BindingOperations.SetBinding() and BindingOperations.ClearBinding() . This is to actually bind a source and a target, and it can be done from any object using the static methods. B. Now about the source and target involved in the binding, there are constraints that you can read here and that summarize to: " The target of the binding can be any accessible property or element that is derived from DependencyPropertyâ€”an example is a TextBox control's Text property. The source of the binding can be any public property, including properties of other controls, common language runtime (CLR) objects, XAML elements, ADO.NET DataSets, XML Fragments, and so forth ." In turn DependencyProperty can exist (if I'm not wrong) only in a DependencyObject . So the target needs to live in a DependencyObject , but not the source, and not the object from where the binding is created. And this is not exactly true, you can also use a target that is not a DO, look at the code in this page . Also remember that you can perform a reverse binding using OneWayToSource type of binding. In this case the target has not to be a DependencyObject .
