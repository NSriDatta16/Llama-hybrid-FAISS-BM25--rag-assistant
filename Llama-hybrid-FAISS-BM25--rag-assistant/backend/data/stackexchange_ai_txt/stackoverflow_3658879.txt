[site]: stackoverflow
[post_id]: 3658879
[parent_id]: 3658631
[tags]: 
I'm hoping that the elements are 1 byte aligned and similarly that a std::vector is 4 byte aligned ( or whatever size int happens to be on a particular platform ). To put it simply, std::vector is a wrapper for a C array. The elements of the vector are aligned as if they were in the array: elements are guaranteed to occupy continues memory block without any added gaps/etc, so that std::vector v can be accessed as a C array using the &v[0] . (Why vector has to reallocate storage sometimes when elements are added to it.) Does anyone know how standard library containers get aligned? Alignment of elements is platform specific but generally a simple variable is aligned so that its address is divisible by its size (natural alignment). Structures/etc are padded (empty filler space at the end) on the largest data type they contain to ensure that if the structure is put into an array, all fields would retain their natural alignment. For other containers (like std::list or std::map ) use data via template mechanics are made a part of internal structure and the structure is allocated by operator new . The new is guaranteed (custom implementation must obey the rule too; inherited from the malloc() ) to return memory block which is aligned on largest available primitive data type (*). That is to ensure that regardless what structure or variable would be places in the memory block, it will be accessed in aligned fashion. Unlike std::vector , obviously, the elements of most other STL containers are not guaranteed to be within the same continuous memory block: they are new ed one by one, not with new[] . (*) As per C++ standard, "The allocation function (basic.stc.dynamic.allocation) called by a new-expression (expr.new) to allocate size bytes of storage suitably aligned to represent any object of that size." That is a softer requirement compared to one malloc() generally abides, as per POSIX: "The pointer returned if the allocation succeeds shall be suitably aligned so that it may be assigned to a pointer to any type of object [...]". C++ requirement in a way reenforces the natural alignment requirement: dynamically allocated char would be aligned as char requires, but not more.
