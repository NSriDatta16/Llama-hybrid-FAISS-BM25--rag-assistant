[site]: stackoverflow
[post_id]: 4108830
[parent_id]: 
[tags]: 
DDS DataReader Cache Breaks And Is No Longer Accessible

Operating with a dds library on i386, trying to pull samples repeatedly. I am explicitly ' read ing' not ' take ing' the sample, so they should never expire or be removed. Start two blackboard applications, (1) and (2) Perform a read in both applications. This will return "Cache is empty". Write from (1), sensor id: 1, event id: 1, value: 1. Read from (1), confirm values Read from (2), confirm values Write from (2), sensor id: 1, event id: 1, value: 2. Read from (2), "cache is empty" Read from (1), "cache is empty" It seems like I "broke" it! I believe the lifetime for samples should be inifinity (or so I have come to understand... but cannot confirm!) -- but I can't set it explicitly. topicQos.lifespan.duration is of the type Duration_t , but I cannot set it to a "new Duration_t(Duration_t.DURATION_INFINITY_SEC,Duration_t.DURATION_INFINITY_NSEC) " because it is already finalized? public class Main { private static final String EVENT_TOPIC_NAME = "EVENTS"; private static BufferedReader in = null; private static PrintStream out = null; /** * @param args the command line arguments */ public static void main(String[] args) throws IOException { in = new BufferedReader(new InputStreamReader(System.in)); out = new PrintStream(new BufferedOutputStream(System.out)); DomainParticipantFactory factory = DomainParticipantFactory.TheParticipantFactory; DomainParticipant participant = factory.create_participant(100, DomainParticipantFactory.PARTICIPANT_QOS_DEFAULT, null, StatusKind.STATUS_MASK_NONE); EventTypeSupport.register_type(participant, EventTypeSupport.get_type_name()); TopicQos topicQos = new TopicQos(); topicQos.durability.direct_communication = true; topicQos.durability.kind = DurabilityQosPolicyKind.TRANSIENT_DURABILITY_QOS; topicQos.reliability.kind = ReliabilityQosPolicyKind.RELIABLE_RELIABILITY_QOS; topicQos.resource_limits.max_instances = 100; topicQos.resource_limits.max_samples = 100; topicQos.resource_limits.max_samples_per_instance = 1; topicQos.ownership.kind = OwnershipQosPolicyKind.SHARED_OWNERSHIP_QOS; topicQos.history.kind = HistoryQosPolicyKind.KEEP_LAST_HISTORY_QOS; topicQos.history.depth = 1; topicQos.history.refilter = RefilterQosPolicyKind.ALL_REFILTER_QOS; // Since this is on the same computer, and being typed by a human, we can exepct source timestamps to be useful in ordering topicQos.destination_order.kind = DestinationOrderQosPolicyKind.BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS; Topic topic = participant.create_topic(EVENT_TOPIC_NAME, EventTypeSupport.get_type_name(), topicQos, new EventTopicListener(), StatusKind.STATUS_MASK_ALL); exitIfNullBecause(topic, "Could not create topic"); Subscriber subscriber = participant.create_subscriber(DomainParticipant.SUBSCRIBER_QOS_DEFAULT, null, StatusKind.STATUS_MASK_NONE); exitIfNullBecause(subscriber, "Could not create subscriber"); DataReader reader = subscriber.create_datareader(participant.lookup_topicdescription(EVENT_TOPIC_NAME), subscriber.DATAREADER_QOS_USE_TOPIC_QOS, null, StatusKind.STATUS_MASK_NONE); exitIfNullBecause(reader, "Could not create reader"); EventDataReader eventReader = (EventDataReader) reader; Publisher publisher = participant.create_publisher(DomainParticipant.PUBLISHER_QOS_DEFAULT, null, StatusKind.STATUS_MASK_NONE); exitIfNullBecause(publisher, "Could not create publisher"); DataWriter writer = publisher.create_datawriter(topic, publisher.DATAWRITER_QOS_USE_TOPIC_QOS, null, StatusKind.STATUS_MASK_NONE); exitIfNullBecause(writer, "Could not create writer"); EventDataWriter eventWriter = (EventDataWriter)writer; boolean loop = true; byte inputBuffer[] = new byte[1024]; String command; while(loop){ print("Enter action [read|write|exit]: "); command = in.readLine(); if(command.startsWith("r")){ dumpCache(eventReader); } else if(command.startsWith("w")) { writeCache(eventWriter); } else if(command.startsWith("e")){ println("exiting..."); System.exit(0); } else { println("Unknown: '" + command + "'"); } } System.exit(0); } private static void print(String output){ out.print(output); out.flush(); } private static void println(String output){ out.println(output); out.flush(); } private static void exitIfNullBecause(Object thing, String string) { if (thing == null) { println("ERROR: " + string); System.exit(1); } } private static void dumpCache(EventDataReader eventReader) { // Something interesting here: I can creat it with a collection as a paramter. TODO: Investigate! EventSeq eventSeq = new EventSeq(); SampleInfoSeq infoSeq = new SampleInfoSeq(); Event event = null; SampleInfo info = null; try{ eventReader.read(eventSeq, infoSeq, 100, SampleStateKind.ANY_SAMPLE_STATE, ViewStateKind.ANY_VIEW_STATE, InstanceStateKind.ANY_INSTANCE_STATE); } catch (Exception e){ println("Cache is empty"); return; } Iterator infoIter = infoSeq.iterator(); out.printf("| Sensor ID | Event ID | Value |\n"); for(int i=0; i
