[site]: stackoverflow
[post_id]: 2682422
[parent_id]: 2682273
[tags]: 
What you want is to fire an ICommand in your ViewModel based on a FrameworkElement's RoutedEvent. Unfortunately, WPF doesn't support this "out-of-box". Some possibilities: 1) With Expression Blend 3 there is Microsoft.Expression.Interactivity.dll, which allows this. See WPF : Blend 3 Interactions / Behaviours for an example on how to do this. 2) You could have an event handler in your code-behind, which directly calls the appropriate ViewModel command. For example: private void FrameworkElement_DragDelta(object sender, EventArgs e) { this.MyViewModel.OnDragDelta(sender, e); } 3) As part of the Cinch framework, there is an attached command behaviour . That way, you do not have to change your code-behind. For example: Cinch:SingleEventCommand.RoutedEventName="DragDelta" Cinch:SingleEventCommand.TheCommandToRun="{Binding Path=DragDeltaCommand}" Note that this calls an ICommand and passes an object (actually an SCommandArgs) as command parameter. To get the actual routed event arguments in your command handler, do the following: var sargs = args as SCommandArgs; if (sargs == null) { return; } var routedEventArgs = sargs.EventArgs as RoutedEventArgs; // Or whatever arguments you actually expect if (routedEventArgs == null) { return; } // Do something here with the event arguments EDIT: Also take a look at Binding Commands to Events?
