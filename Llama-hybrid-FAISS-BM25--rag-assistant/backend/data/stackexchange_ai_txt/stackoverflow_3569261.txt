[site]: stackoverflow
[post_id]: 3569261
[parent_id]: 
[tags]: 
Multiple textures in GLSL - only one works

My problem is getting more than one texture accessible in a GLSL shader. Here's what I'm doing: Shader: uniform sampler2D sampler0; uniform sampler2D sampler1; uniform float blend; void main( void ) { vec2 coords = gl_TexCoord[0]; vec4 col = texture2D(sampler0, coords); vec4 col2 = texture2D(sampler1, coords); if (blend > 0.5){ gl_FragColor = col; } else { gl_FragColor = col2; } }; So, I simply choose between the two color values based on a uniform variable. Simple enough (this is a test), but instead of the expected behavior, I get all black when blend . OpenGL code: m_sampler0location = m_shader.FindUniform("sampler0"); m_sampler1location = m_shader.FindUniform("sampler1"); m_blendlocation = m_shader.FindUniform("blend"); glActiveTexture(GL_TEXTURE0); glEnable(GL_TEXTURE_2D); m_extensions.glUniform1iARB(m_sampler0location, 0); glBindTexture(GL_TEXTURE_2D, Texture0.Handle); glActiveTexture(GL_TEXTURE1); glEnable(GL_TEXTURE_2D); m_extensions.glUniform1iARB(m_sampler1location, 1); glBindTexture(GL_TEXTURE_2D, Texture1.Handle); glBegin(GL_QUADS); //lower left glTexCoord2f(0, 0); glVertex2f(-1.0, -1.0); //upper left glTexCoord2f(0, maxCoords0.t); glVertex2f(-1.0, 1.0); //upper right glTexCoord2f(maxCoords0.s, maxCoords0.t); glVertex2f(1.0, 1.0); //lower right glTexCoord2f(maxCoords0.s, 0); glVertex2f(1.0, -1.0); glEnd() The shader is compiled and bound before all this. All the sanity checks in that process indicate that it goes ok. As I said, the value of col in the shader program reflects fragments from a texture; the value of col2 is black. The texture that is displayed is the last active texture - if I change the last glBindTexture to bind Texture0.Handle , the texture changes. Fixed according to Bahbar's reply. As it is, the scene renders all black, even if I add something like gl_FragColor.r = blend; as the last line of the shader. But, if I comment out the call glActiveTexture(GL_TEXTURE1); , the shader works again, and the same texture appears in both sampler0 and sampler1. What's going on? The line in question, glActiveTexture(GL_TEXTURE1); , seems to work just fine, as evidenced by a subsequent glGetIntegerv(GL_ACTIVE_TEXTURE, &anint) . Why does it break everything so horribly? I've already tried upgrading my display drivers.
