[site]: stackoverflow
[post_id]: 991696
[parent_id]: 989618
[tags]: 
If you don't want to go the macro route, you could always just abandon cons-stream and rewrite lazy-list as follows: (define (lazy-list from) (cons from (位() (lazy-list (+ from 1))))) This is probably the easiest, most pragmatic solution, but it's only good for making lazy lists of incrementing numbers. You could generalize this by passing in a function that will generate successive elements of the list when called: (define (lazy-list-gen generator) (cons (generator) (位() (lazy-list-gen generator)))) (define (lazy-list from) (lazy-list-gen (位() (let ((ret from)) (set! from (+ from 1)) ret)))) This works pretty well: > (define x (lazy-list 1)) > (car-stream x) 1 > (car-stream (cdr-stream x)) 2 But there's a bug in the code: ... continuing from above ... > (car-stream (cdr-stream x)) 3 This error happens because the call to cdr-stream calls generator again. We can solve this by caching the return value of the lambda: (define (lazy-list-gen generator) (cons (generator) (let ((gen-cache #f)) (位() (cond ((not gen-cache) (set! gen-cache (lazy-list-gen generator)))) gen-cache)))) Now it works as it should: > (define x (lazy-list 1)) > (car-stream x) 1 > (car-stream (cdr-stream x)) 2 > (car-stream (cdr-stream x)) 2 > (car-stream (cdr-stream (cdr-stream x))) 3 > (car-stream (cdr-stream x)) 2
