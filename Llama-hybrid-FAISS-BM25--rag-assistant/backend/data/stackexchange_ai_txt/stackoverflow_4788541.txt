[site]: stackoverflow
[post_id]: 4788541
[parent_id]: 4787205
[tags]: 
Oracle specifics: The stated cost is actually an estimated execution time, but it is given in a somewhat arcane unit of measure that has to do with estimated time for block reads. It's important to realize that the calculated cost doesn't say much about the runtime anyway, unless each and every estimate made by the optimizer was 100% perfect (which is never the case). The optimizer uses the schema for a lot of things when deciding what transformations/heuristics can be applied to the query. Some examples of schema things that matter a lot when evaluating xplans: Foreign key constraints (can be used for table elimiation) Partitioning (exclude entire ranges of data) Unique constraints (index unique vs range scans for example) Not null constraints (anti-joins are not available with not in() on nullable columns Data types (type conversions, specialized date arithmetics) Materialized views (for rewriting a query against an aggregate) Dimension Hierarchies (to determine functional dependencies) Check constraints (the constraint is injected if it lowers cost) Index types (b-tree(?), bitmap, joined, function based) Column order in index ( a = 1 on {a,b} = range scan, {b,a} = skip scan or FFS) The core of the estimates comes from using the statistics gathered on actual data (or cooked). Statistics are gathered for tables, columns, indexes, partitions and probably something else too. The following information is gathered: Nr of rows in table/partition Average row/col length (important for costing full scans, hash joins, sorts, temp tables) Number of nulls in col (is_president = 'Y' is pretty much unique) Distinct values in col (last_name is not very unique) Min/max value in col (helps unbounded range conditions like date > x ) ...to help estimate the nr of expected rows/bytes returned when filtering data. This information is used to determine what access paths and join mechanisms are available and suitable given the actual values from the SQL query compared to the statistics. On top of all that, there is also the physical row order which affects how "good" or attractive an index become vs a full table scan. For indexes this is called "clustering factor" and is a measure of how much the row order matches the order of the index entries.
