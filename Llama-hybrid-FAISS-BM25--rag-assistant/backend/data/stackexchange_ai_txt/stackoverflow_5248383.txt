[site]: stackoverflow
[post_id]: 5248383
[parent_id]: 
[tags]: 
Problems with query time when accessing to information stored in the computer memory

I am working on a simple program, simulating a small database. And I have a strange problem when reading information, stored in the computer memory. The thing is that the query time is much higher that what was supposed and I can't see why. Let me explain my problem in detail, and in the end, you will find my question in capital letters. First of all I have a .txt file simulating a database table with random strings separated with "|". Here you have an example of table (with 5 rows and 5 columns). Table.txt 0|42sKuG^uM|24465\lHXP|2996fQo\kN|293cvByiV 1|14772cjZ`SN|28704HxDYjzC|6869xXj\nIe|27530EymcTU 2|9041ByZM]I|24371fZKbNk|24085cLKeIW|16945TuuU\Nc 3|16542M[Uz\|13978qMdbyF|6271ait^h|13291_rBZS 4|4032aFqa|13967r^\\`T|27754k]dOTdh|24947]v_uzg This information in a .txt file is read by my program and stored in the computer memory. Here you have the part of the code that read this information from a file and store in the computer. Code that reads data from the Table.txt file and store it in the computer memory string ruta_base("C:\\a\\Table.txt"); // Folder where my "Table.txt" is found string temp; // Variable where every row from the Table.txt file will be firstly stored vector buffer; // Variable where every different row will be stored after separating the different elements by tokens. vector RowsCols; // Variable with a class that I have created, that simulated a vector and every vector element is a row of my table ifstream ifs(ruta_base.c_str()); while(getline( ifs, temp )) // We will read and store line per line until the end of the ".txt" file. { size_t tokenPosition = temp.find("|"); // When we find the simbol "|" we will identify different element. So we separate the string temp into tokens that will be stored in vector buffer while (tokenPosition != string::npos) { string element; tokenPosition = temp.find("|"); element = temp.substr(0, tokenPosition); buffer.push_back(element); temp.erase(0, tokenPosition+1); } ElementSet ss(0,buffer); buffer.clear(); RowsCols.push_back(ss); // We store all the elements of every row (stores as vector buffer) in a different position in "RowsCols" } vector TablesDescriptor; Table TablesStorage(RowsCols); TablesDescriptor.push_back(TablesStorage); DataBase database(1, TablesDescriptor); After this, comes the IMPORTANT PART . Let's suppose that I want to make a query, and I ask for input. Let's say that my query is row "n", and also the consecutive tuples "numTuples", and the columns "y". (We must say that the number of columns is defined by a decimal number "y", that will be transformed into binary and will show us the columns to be queried, for example, if I ask for columns 54 (00110110 in binary) I will ask for columns 2, 3, 5 and 6). Then I access to the computer memory to the required information and store it in a vector shownVector. Here I show you the part of this code. Code that access to the required information upon my input int n, numTuples; unsigned long long int y; clock_t t1, t2; cout >n; // We get the row to be represented -> "n" cout >numTuples; // We get the number of followed tuples to be queried-> "numTuples" cout >y; // We get the "columns" to be represented ' "y" unsigned int r; // Auxiliar variable for the columns path int t=0; // Auxiliar variable for the tuples path int idTable; vector columnsToBeQueried; // Here we will store the columns to be queried get from the bitset binarynumber, after comparing with a mask vector shownVector; // Vector to store the final information from the query bitset mask; mask=0x1; t1=clock(); // Start of the query time bitset binaryNumber = Utilities().getDecToBin(y); // We get the columns -> change number from decimal to binary. Max number of columns: 5000 // We see which columns will be queried for(r=0;r colTab; colTab.push_back(1); // Don't really worry about this //idTable = colTab.at(i); // We identify in which table (with the id) is column_i // In this simple example we only have one table, so don't worry about this Table selectedTable = database.getPointer().at(0); // It simmulates a vector with pointers to different tables that compose the database, but our example database only have one table, so don't worry ElementSet selectedElementSet; ElementSet selectedElementSet; selectedElementSet=selectedTable.getRowsCols().at(n); shownVector.push_back(selectedElementSet.getElements().at(i)); // We save in the vector shownVector the element "i" of the row "n" } n=n+1; t++; }while(t So my question is... why query time is so different depending on the table size??? (it has nothing to do a table with 100 rows and 100 columns, and a table with 10000 rows and 1000 columns). The thing is that when i access to the information, already saved in the computer memory, i access directly to the element I am looking for and not to all the table... so the size of the table is not taken into account and query time should be the same for every query.... Thank you very much for all your help!!! :) Class definitions As some of you asked for, I add the definition of the classes Table and ElementSet: class ElementSet { private: int id; vector elements; public: ElementSet(); ElementSet(int, vector ); int getId(); void setId(int); vector getElements(); void setElements(vector ); }; class Table { private: vector RowsCols; public: Table(); Table(vector ); vector getRowsCols(); void setRowsCols(vector ); }; class DataBase { private: int id; vector pointer; public: DataBase(); DataBase(int, vector ); int getId(); void setId(int); vector getPointer(); void setPointer(vector ); }; class Utilities { public: Utilities(); static bitset getDecToBin(unsigned long long int); };
