[site]: stackoverflow
[post_id]: 1370407
[parent_id]: 1370323
[tags]: 
Besides the for-loop based solutions, you can also use an ostream_iterator<> . Here's an example that leverages the sample code in the (now retired) SGI STL reference: #include #include #include int main() { short foo[] = { 1, 3, 5, 7 }; using namespace std; copy(foo, foo + sizeof(foo) / sizeof(foo[0]), ostream_iterator (cout, "\n")); } This generates the following: ./a.out 1 3 5 7 However, this may be overkill for your needs. A straight for-loop is probably all that you need, although litb's template sugar is quite nice, too. Edit : Forgot the "printing in reverse" requirement. Here's one way to do it: #include #include #include int main() { short foo[] = { 1, 3, 5, 7 }; using namespace std; reverse_iterator begin(foo + sizeof(foo) / sizeof(foo[0])); reverse_iterator end(foo); copy(begin, end, ostream_iterator (cout, "\n")); } and the output: $ ./a.out 7 5 3 1 Edit : C++14 update that simplifies the above code snippets using array iterator functions like std::begin() and std::rbegin() : #include #include #include int main() { short foo[] = { 1, 3, 5, 7 }; // Generate array iterators using C++14 std::{r}begin() // and std::{r}end(). // Forward std::copy(std::begin(foo), std::end(foo), std::ostream_iterator (std::cout, "\n")); // Reverse std::copy(std::rbegin(foo), std::rend(foo), std::ostream_iterator (std::cout, "\n")); }
