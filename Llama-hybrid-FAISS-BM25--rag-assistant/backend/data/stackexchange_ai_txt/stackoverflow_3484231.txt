[site]: stackoverflow
[post_id]: 3484231
[parent_id]: 3484185
[tags]: 
One tip would be layering your code a bit more. Servlets shouldn't be importing from java.sql. Put that code in a separate class, test it, and let your servlet call its methods. You're creating XML in the most brain dead way possible by concatentating strings that way. Why not use a library like JDOM or at least a StringBuilder? And skaffman's right: your code makes no sense otherwise. Here are a few ideas you can think about for layering. Start with a model object for Sale - after all, Java's an object-oriented language: package badservlet.model; public class Sale { private String saleId; private String homeId; private String agentId; private String customerId; public Sale(String saleId, String homeId, String agentId, String customerId) { if ((saleId == null) || (saleId.trim().length() == 0) throw new IllegalArgumentException("sales id cannot be blank or null"); if ((homeId == null) || (homeId.trim().length() == 0) throw new IllegalArgumentException("home id cannot be blank or null"); if ((agentId == null) || (agentId.trim().length() == 0) throw new IllegalArgumentException("agent id cannot be blank or null"); if ((customerId == null) || (customerId.trim().length() == 0) throw new IllegalArgumentException("customer id cannot be blank or null"); this.saleId = saleId; this.homeId = homeId; this.agentId = agentId; this.customerId = customerId; } public String getSaleId() { return saleId; } public String getHomeId() { return homeId; } public String getAgentId() { return agentId; } public String getCustomerId() { return customerId; } @Override public String toString() { return "Sale{" + "saleId='" + saleId + '\'' + ", homeId='" + homeId + '\'' + ", agentId='" + agentId + '\'' + ", customerId='" + customerId + '\'' + '}'; } } For persistence, start with a DAO interface: package badservlet.persistence; import badservlet.model.Sale; import java.sql.SQLException; import java.util.List; public interface SaleDao { List find() throws SQLException; } And its implementation: package badservlet.persistence; import badservlet.model.Sale; import javax.sql.DataSource; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.List; public class SaleDaoImpl implements SaleDao { private static final String SELECT_ALL_SQL = "SELECT sale_id, home_id, agent_id, customer_id FROM sale"; private Connection connection; public SaleDaoImpl(Connection connection) { this.connection = connection; } public SaleDaoImpl(DataSource dataSource) throws SQLException { this(dataSource.getConnection()); } public List find() throws SQLException { List allSales = new ArrayList (); Statement st = null; ResultSet rs = null; try { st = this.connection.createStatement(); rs = st.executeQuery(SELECT_ALL_SQL); while (rs.next()) { String saleId = rs.getString("sale_id"); String homeId = rs.getString("home_id"); String agentId = rs.getString("agent_id"); String customerId = rs.getString("customer_id"); Sale sale = new Sale(saleId, homeId, agentId, customerId); allSales.add(sale); } } catch (SQLException e) { e.printStackTrace(); } finally { try { if (rs != null) rs.close(); } catch (SQLException e) { e.printStackTrace(); } try { if (st != null) st.close(); } catch (SQLException e) { e.printStackTrace(); } } return allSales; } } And an object-to-XML unmarshaller: package badservlet.xml; import badservlet.model.Sale; import org.jdom.Document; import org.jdom.Element; import org.jdom.transform.JDOMResult; import javax.xml.bind.JAXBException; import javax.xml.transform.Result; import java.util.List; public class SaleUnmarshaller { public void unmarshal(Object object, Result xml) throws JAXBException { List allSales = (List ) object; Document document = new Document(new Element("sales")); for (Sale sale : allSales) { Element child = new Element("sale"); child.setAttribute("id", sale.getSaleId()); child.addContent(new Element("home", sale.getHomeId())); child.addContent(new Element("agent", sale.getAgentId())); child.addContent(new Element("customer", sale.getCustomerId())); document.addContent(child); } JDOMResult result = new JDOMResult(); result.setDocument(document); xml = result; } } Let your servlet instantiate these objects and call their methods. It might look more complicated - more classes than just one - but you've accomplished two things: you've broken your problem down into smaller pieces, and you can test them separately.
