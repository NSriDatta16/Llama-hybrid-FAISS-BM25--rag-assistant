[site]: stackoverflow
[post_id]: 268378
[parent_id]: 268182
[tags]: 
Here's an optimized version of the query above that doesn't use dynamic SQL... Declare @selectedFeature as varchar(MAX), @searchStr as varchar(100), @pageCount as int, @startIndex as int, @searchId as int, @venueName as varchar(100), @range int, @latitude varchar(100), @longitude varchar(100), @showAll int, @OrderBy varchar(50), @SearchOrder varchar(10) Set @startIndex = 1 Set @pageCount = 50 Set @searchStr = 'e' Set @searchId = 4 Set @OrderBy = 'Address1' Set @showAll = 1 --Select dbo.GeocodeDistanceMiles(Latitude,Longitude,@latitude,@longitude) DECLARE @endIndex int SET @endIndex = @startIndex + @pageCount -1 ; WITH LogEntries as ( SELECT Row_Number() OVER (ORDER BY CASE @OrderBy WHEN 'Distance' THEN Cast(dbo.GeocodeDistanceMiles(Latitude,Longitude,@latitude,@longitude) as varchar(10)) WHEN 'Name' THEN Name WHEN 'Address1' THEN Address1 WHEN 'RecordId' THEN Cast(RecordId as varchar(10)) WHEN 'EliteStatus' THEN Cast(EliteStatus as varchar(10)) END) AS RowNumber, RecordId,EliteStatus,Name,Description, Address,TotalReviews,AverageFacilityRating,AverageServiceRating,Address1,Address2,Address3,Address4,Address5,Address6,PhoneNumber, visitCount,referalCount,requestCount,imgUrl,Latitude,Longitude, Convert(decimal(10,2),dbo.GeocodeDistanceMiles(Latitude,Longitude,@latitude,@longitude)) as distance FROM VenueAllData where Enabled=1 and EliteStatus <> 3 And ( (Address5 like @searchStr + '%' And @searchId = 1) OR (Address4 like @searchStr + '%' And @searchId = 2) OR (Address6 like @searchStr + '%' And @searchId = 3) OR ( ( @searchId = 4 And (Name like '%' + @venueName + '%' OR Address like '%'+ @searchStr+'%') ) ) ) And ID in ( Select VenueID From CachedVenueAttributes --Extra Where Clause for the processing of VenueAttributes using @selectedFeature ) And ( (@showAll = 1) Or (@showAll <> 1 and dbo.GeocodeDistanceMiles(Latitude,Longitude,@latitude,@longitude) The only thing I haven't fixed is the selection from CachedVenueAttributes that seems to build up a where statement in a loop. I think I might put this in a table valued function, and refactor it in isolation to the rest of the procedure.
