[site]: stackoverflow
[post_id]: 2737352
[parent_id]: 2736694
[tags]: 
Define an interface for your data access layer and have (at least) two implementations of it: The real database provider, which will in turn run queries on an SQL database, etc. An in-memory test provider, which can be prepopulated with test data as part of each unit test. The advantage of this is that the modules making use of the data provider do not need to whether the database is the real one or the test one, and hence more of the real code will be tested. The test database can be simple (like simple collections of objects) or complex (custom structures with indexes). It can also be a mocked implementation that will assert that it's being called appropriately as part of the test. Additionally, if you ever need to support another data storage method (or different SQL database), you just need to write another implementation that conforms to the interface, and can be confident that none of the calling code will need to be reworked. This approach is easiest if you plan for it from (or near) the start, so I'm not sure how easy it will be to apply to your situation. What it might look like If you're just loading and saving objects by id, then you can have an interface and implementations like (in Java-esque pseudo-code; I don't know much about asp.net): interface WidgetDatabase { Widget loadWidget(int id); saveWidget(Widget w); deleteWidget(int id); } class SqlWidgetDatabase extends WidgetDatabase { Connection conn; // connect to database server of choice SqlWidgetDatabase(String connectionString) { conn = new Connection(connectionString); } Widget loadWidget(int id) { conn.executeQuery("SELECT * FROM widgets WHERE id = " + id); Widget w = conn.fetchOne(); return w; } // more methods that run simple sql queries... } class MemeoryWidgetDatabase extends WidgetDatabase { Set widgets; MemoryWidgetDatabase() { widgets = new Set(); } Widget loadWidget(int id) { for (Widget w: widgets) if (w.getId() == id) return w; return null; } // more methods that find/add/delete a widget in the "widgets" set... } If you need to run more other queries (such as batch selects based on more complex criteria), you can add methods to do this to the interface. Likewise for complex updates. Transaction support is possible for the real database implementation. I'm not sure how easy it is to build an in-memory db that is capable of providing proper transaction support. To test it you'd need "open" several "connections" to the same data set, and to only apply updates to that shared dataset when a transaction is committed.
