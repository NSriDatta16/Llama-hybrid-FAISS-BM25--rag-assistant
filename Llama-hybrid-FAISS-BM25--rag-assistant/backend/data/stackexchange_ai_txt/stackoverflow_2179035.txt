[site]: stackoverflow
[post_id]: 2179035
[parent_id]: 2178909
[tags]: 
Instead of static multidimensional arrays you should probably use one-dimensional array and calculate the index by multiplication. E.g. class Array3D { size_t m_width, m_height; std::vector m_data; public: Array3D(size_t x, size_t y, size_t z, int init = 0): m_width(x), m_height(y), m_data(x*y*z, init) {} int& operator()(size_t x, size_t y, size_t z) { return m_data.at(x + y * m_width + z * m_width * m_height); } }; // Usage: Array3D arr(10, 15, 20, 100); // 10x15x20 array initialized with value 100 arr(8, 12, 17) = 3; std::vector allocates the storage dynamically, which is a good thing because the stack space is often very limited and 3D arrays easily use a lot of space. Wrapping it in a class like that also makes passing the array (by copy or by reference) to other functions trivial, while doing any passing of multidimensional static arrays is very problematic. The above code is simply an example and it could be optimized and made more complete. There also certainly are existing implementations of this in various libraries, but I don't know of any.
