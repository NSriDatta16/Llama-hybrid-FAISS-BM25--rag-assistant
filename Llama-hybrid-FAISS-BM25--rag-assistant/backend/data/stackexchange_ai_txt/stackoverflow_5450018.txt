[site]: stackoverflow
[post_id]: 5450018
[parent_id]: 5442276
[tags]: 
This is one of those cases where the most efficient approach depends upon the actual data. The first obtains all partNums from the database: HashSet partNums = new HashSet (from p in GetTable select p.PartNumber); foreach(var p in parts) p.NewPart = partNums.Contains(p.PartNumber); The second queries the database with the relevant partNumbers: HashSet partNums = new HashSet ( from p in GetTable where (from mp in parts select mp.PartNumber).Contains(p.PartNumber) select p.PartNumber); foreach(var p in parts) p.NewPart = partNums.Contains(p.PartNumber); The former will be more efficient above a certain number of rows in the database, and less efficient above it, because the latter takes a longer time to build a more complicated query, but the former returns everything. Another factor is the percentage of hits expected. If this number is relatively low (i.e. only a small number of the parts in the list will be in the database) then it could be more efficient to do: Dictionary dict = partsSource.ToDictionary(p => p.PartNumber, p); foreach(int pn in from p in GetTable where (from kv in dict select kv.Key).Contains(p.PartNumber) select p.PartNumber); dict[pn].NewPart = true; Where partsSource is the means by which the List parts was obtained in the first place, here instead of obtaining a list, we obtain a dictionary, which makes for more efficient retrieval of those we want. However, it we're going to obtain parts as a list anyway, then we can't really gain here, as we use slightly more effort building the dictionary in the first place, than iterating through the list.
