[site]: stackoverflow
[post_id]: 4506662
[parent_id]: 4506487
[tags]: 
The way you're trying to do it isn't going to work over the long haul. You can't count on any particular C++ mangling/demangling algorithm. Different compilers - and even different versions of the same compiler - have used different ones. So you could do this, and switch to a new version of Xcode, and be left in a bad situation. Also, C++ suffers from the Fragile Binary Interface Problem . To avoid that, all operations on the internals of a Grind::PluginManager instance, from creation to member access to deletion, need to happen in the same dynamic library. Solving these problems is some of the rationale behind Objective C's messaging system, and the Windows OLE system. The C++ solution is to use a wrapper system. First, you need to define an opaque pointer type to stand in for Grind::PluginManager*. The C-language Cocoa bindings do this a lot. typedef void* MyGrindPlugInManagerOpaqueHandle; Second, for each operation you want to do on a Grind::PluginManager from outside the dynamic library, you need to use extern "C" to define a function with non-mangled C binding, and that takes one of those opaque pointers as an argument. For instance: #ifdef __cplusplus extern "C" { #endif void foo_wrapper(MyGrindPlugInManagerOpaqueHandle *bar); #ifdef __cplusplus } #endif Third, the implementation in a C++ file will look something like this: void foo_wrapper(MyGrindPlugInManagerOpaqueHandle *bar) { Grind::PluginManager* baz = (Grind::PluginManager*)bar; baz->foo(); }
