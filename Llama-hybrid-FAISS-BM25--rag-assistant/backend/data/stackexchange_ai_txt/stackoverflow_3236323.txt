[site]: stackoverflow
[post_id]: 3236323
[parent_id]: 3233522
[tags]: 
There's a very easy algorithm for Your problem that runs in linear time: Given two points A and B, determine the intersection points of the line (A, B) with every vertical line of Your grid, that lies within this interval. Insert two special intersection points inside the cells containing A and B at the start/end of the list from point 1. Interpret every two sequent intersection points as the min and max vectors of a axis aligned rectangle and mark all grid cells that lie inside this rectangle (this is very easy (intersection of two axis aligned rects), especially considering, that the rectangle has a width of 1 and therefore occupies only 1 column of Your grid) Example: +------+------+------+------+ | | | | | | | | B * | | | |/ | | +------+------*------+------+ | | /| | | | | / | | | | | / | | | +------+--/---+------+------+ | | / | | | | |/ | | | | * | | | +-----/+------+------+------+ | / | | | | * A | | | | | | | | | +------+------+------+------+ "A" and "B" are the points terminating the line represented by "/". "*" marks intersection points of the line with the grid. The two special intersection points are needed in order to mark the cells that contain A & B and to handle special cases like A.x == B.x An optimized implementation needs Θ(|B.x - A.x| + |B.y - A.y|) time for a line (A, B). Further, one can write this algorithm to determine intersection points with horizontal grid lines, if that is easier for the implementer. Update: Border cases As brainjam correctly points out in his answer, the hard cases are the ones, when a line goes exactly through a grid point. Lets assume such a case occurs and the floating point arithmetic operations correctly return a intersection point with integral coordinates. In this case, the proposed algorithm marks only the correct cells (as specified by the image provided by the OP). However, floating point errors will occur sooner or later and yield incorrect results. From my opinion even using double won't suffice and one should switch to a Decimal number type. An optimized implementation will perform Θ(|max.x - min.x|) additions on that data type each one taking Θ(log max.y) time. That means in the worst case (the line ((0, 0), (N, N)) with huge N (> 10 6 ) the algorithm degrades to a O(N log N) worst case runtime. Even switching between vertical/horizontal grid line intersection detection depending on the slope of the line (A, B) doesn't help in this worst case, but it sure does in the average case - I would only consider to implement such a switch if a profiler yields the Decimal operations to be the bottle neck. Lastly, I can imagine that some clever people might be able to come up with a O(N) solution that correctly deals with this border cases. All Your suggestions are welcome! Correction brainjam pointed out, that a decimal data type is not satisfying even if it can represent arbitrary precision floating point numbers, since, for example, 1 / 3 can't be represented correctly. Therefore one should use a fraction data type, which should be able to handle border cases correctly. Thx brainjam! :)
