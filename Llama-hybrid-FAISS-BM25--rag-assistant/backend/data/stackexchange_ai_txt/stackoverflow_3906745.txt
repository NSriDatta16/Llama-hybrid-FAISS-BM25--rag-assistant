[site]: stackoverflow
[post_id]: 3906745
[parent_id]: 3906688
[tags]: 
I believe, there is no other way. After you typed 'new' you can no longer go down the class hierarchy. You can only go up. Upcasting is very logical for, i think, obvious reasons. However, upcasting of object in Java (and in every language i know) is done only by upcasting references, not underlying object. Upcasting of underlying objects is impossible, as far as i know. As for downcasting of underlying object - it is impossible too. It may be related to general design of language and, which is more important, memory allocation issues. I'll explain. Suppose class Base can have maximum 4 Mb of RAM, and class Derived - 7 Mb. So your memory looks like this(1 symbol = 1 Mb): BASEBASEOTHERDERIVED . And suppose you're telling system to convert second base class to Derived. System can do this: BASEDERIVEDERDERIVED . As you can see, object 'OTHER' is corrupted this way. System can also do this: BASEDERIVEDOTHERDERIVED . But in this case it must move addresses of OTHER and DERIVED, which is expensive, maybe even dangerous and hard, especially if there are more than two objects in RAM. So the preffered solution is: BASE____OTHERDERIVEDDERIVED , where _____ is free space, which is similar to freeing memory and allocating new object.
