[site]: stackoverflow
[post_id]: 426579
[parent_id]: 
[tags]: 
Javascript Fibonacci nth Term Optimization

I've become interested in algorithms lately, and the fibonacci sequence grabbed my attention due to its simplicity. I've managed to put something together in javascript that calculates the nth term in the fibonacci sequence in less than 15 milliseconds after reading lots of information on the web. It goes up to 1476...1477 is infinity and 1478 is NaN (according to javascript!) I'm quite proud of the code itself, except it's an utter monster. So here's my question: A) is there a faster way to calculate the sequence? B) is there a faster/smaller way to multiply two matrices? Here's the code: //Fibonacci sequence generator in JS //Cobbled together by Salty m = [[1,0],[0,1]]; odd = [[1,1],[1,0]]; function matrix(a,b) { /* Matrix multiplication Strassen Algorithm Only works with 2x2 matrices. */ c=[[0,0],[0,0]]; c[0][0]=(a[0][0]*b[0][0])+(a[0][1]*b[1][0]); c[0][1]=(a[0][0]*b[0][1])+(a[0][1]*b[1][1]); c[1][0]=(a[1][0]*b[0][0])+(a[1][1]*b[1][0]); c[1][1]=(a[1][0]*b[0][1])+(a[1][1]*b[1][1]); m1=(a[0][0]+a[1][1])*(b[0][0]+b[1][1]); m2=(a[1][0]+a[1][1])*b[0][0]; m3=a[0][0]*(b[0][1]-b[1][1]); m4=a[1][1]*(b[1][0]-b[0][0]); m5=(a[0][0]+a[0][1])*b[1][1]; m6=(a[1][0]-a[0][0])*(b[0][0]+b[0][1]); m7=(a[0][1]-a[1][1])*(b[1][0]+b[1][1]); c[0][0]=m1+m4-m5+m7; c[0][1]=m3+m5; c[1][0]=m2+m4; c[1][1]=m1-m2+m3+m6; return c; } function fib(n) { mat(n-1); return m[0][0]; } function mat(n) { if(n > 1) { mat(n/2); m = matrix(m,m); } m = (n%2 The matrix function takes two arguments: a and b, and returns a*b where a and b are 2x2 arrays. Oh, and on a side note, a magical thing happened...I was converting the Strassen algorithm into JS array notation and it worked on my first try! Fantastic, right? :P Thanks in advance if you manage to find an easier way to do this.
