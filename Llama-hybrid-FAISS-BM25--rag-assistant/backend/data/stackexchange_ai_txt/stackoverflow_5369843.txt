[site]: stackoverflow
[post_id]: 5369843
[parent_id]: 5369419
[tags]: 
This is not about dragging, when an item's both column and row are changing the change occurs in two steps. With your code, first the column, then the row. If in the column change, f.i., there happens to be already an other control, this other control is pushed aside, even if its cell is not the ultimate location of the target cell of the moving control. Begin/EndUpdate will not work, the control collection never checks the update count. What can you do is to use a protected hack to access the control item's InternalSetLocation method. This method has a 'MoveExisting' parameter which you can pass 'False'. type THackControlItem = class(TControlItem); procedure TForm1.GridPanelDragDrop(Sender, Source: TObject; X, Y: Integer); var [...] begin if Source is tbutton then begin [...] lbl1.Caption := Format('"%s" from cell %d:%d to Cell %s=%d:%d', [btnNameSrc,src_x,src_y,btnNameDest,dest_x,dest_y]); THackControlItem(GridPanel1.ControlCollection[src_ctrlindex]). InternalSetLocation(dest_x, dest_y, False, False); // GridPanel1.ControlCollection[src_ctrlindex].Column := dest_x; // GridPanel1.ControlCollection[src_ctrlindex].Row := dest_y; end; end; You might need to test if the target cell is empty or not before calling 'InternalSetLocation' depending on what you expect to be the correct control movement.
