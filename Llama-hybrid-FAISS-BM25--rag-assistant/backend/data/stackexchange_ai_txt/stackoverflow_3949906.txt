[site]: stackoverflow
[post_id]: 3949906
[parent_id]: 3949618
[tags]: 
For two concepts to be orthogonal means that they can be independently realized to any degree in any given manifestation. Considering music, for instance, you can classify a musical piece as to how harmonic it is and how rhythmic it is. The two concepts "harmonic" and "rhythmic" are orthogonal in the sense that there are harmonic and rhythmic pieces, disharmonic and arrythmic pieces, but also disharmonic and rhythmic pieces as well as harmonic and arrhythmic pieces. Applied to original question this means that there are purely functional, non-object oriented programming lanuages such as Haskell, purely object-oriented, "non-functional" languages such as Eiffel, but also languages which are neither such as C and languages which are both such as Scala. Simply speaking, Scala being object-oriented means that you can define data structures ("classes" and "traits") which encapsulate data with the methods that manipulate this data, guaranteeing that instances of these structures ("objects") are always in a defined state (the object's contract laid out in its class). On the other hand, Scala being a functional language means that it favors immutable over mutable state and that functions are first class objects, which can be used just like any other object as local variables, fields or parameters to other functions. In addition to this, almost every statement in Scala has a value, which encourages you to use a functional programming style. Orthogonality of object-orientated programming and functional programming in Scala additionaly means that you as a programmer are free to choose any mixture of these two concepts you see fit for your purpose. You can write your programs in a purely imperative style, using mutable objects only and not using functions as objects at all, on the other hand you can also write purely functional programs in Scala not using any of its object-oriented features. Scala really does not require you to use one style or the other. It lets you choose the best of both worlds to solve your problem.
