[site]: stackoverflow
[post_id]: 3731445
[parent_id]: 
[tags]: 
Using Dynamic LINQ (or Generics) to query/filter Azure tables

So here's my dilemma. I'm trying to utilize Dynamic LINQ to parse a search filter for retrieving a set of records from an Azure table. Currently, I'm able to get all records by using a GenericEntity object defined as below: public class GenericEntity { public string PartitionKey { get; set; } public string RowKey { get; set; } Dictionary properties = new Dictionary (); /* "Property" property and indexer property omitted here */ } I'm able to get this completely populated by utilizing the ReadingEntity event of the TableServiceContext object (called OnReadingGenericEvent). The following code is what actually pulls all the records and hopefully filter (once I get it working). public IEnumerable GetTableRecords(string tableName, int numRecords, string filter) { ServiceContext.IgnoreMissingProperties = true; ServiceContext.ReadingEntity -= LogType.GenericEntity.OnReadingGenericEntity; ServiceContext.ReadingEntity += LogType.GenericEntity.OnReadingGenericEntity; var result = ServiceContext.CreateQuery (tableName).Select(c => c); if (!string.IsNullOrEmpty(filter)) { result = result.Where(filter); } var query = result.Take(numRecords).AsTableServiceQuery (); IEnumerable res = query.Execute().ToList(); return res; } I have TableServiceEntity derived types for all the tables that I have defined, so I can get all properties/types using Reflection. The problem with using the GenericEntity class in the Dynamic LINQ Query for filtering is that the GenericEntity object does NOT have any of the properties that I'm trying to filter by, as they're really just dictionary entries (dynamic query errors out). I can parse out the filter for all the property names of that particular type and wrap "Property[" + propName + "]" around each property (found by using a type resolver function and reflection). However, that seems a little... overkill. I'm trying to find a more elegant solution, but since I actually have to provide a type in ServiceContext.CreateQuery<>, it makes it somewhat difficult. So I guess my ultimate question is this: How can I use dynamic classes or generic types with this construct to be able to utilize dynamic queries for filtering? That way I can just take in the filter from a textbox (such as "item_ID > 1023000") and just have the TableServiceEntity types dynamically generated. There ARE other ways around this that I can utilize, but I figured since I started using Dynamic LINQ, might as well try Dynamic Classes as well. Edit: So I've got the dynamic class being generated by the initial select using some reflection, but I'm hitting a roadblock in mapping the types of GenericEntity.Properties into the various associated table record classes (TableServiceEntity derived classes) and their property types. The primary issue is still that I have to initially use a specific datatype to even create the query, so I'm using the GenericEntity type which only contains KV pairs. This is ultimately preventing me from filtering, as I'm not able to do comparison operators (>, Here's the code I have now to do the mapping into the dynamic class: var properties = newType./* omitted */.GetProperties( System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public); string newSelect = "new(" + properties.Aggregate("", (seed, reflected) => seed += string.Format(", Properties[\"{0}\"] as {0}", reflected.Name)).Substring(2) + ")"; var result = ServiceContext.CreateQuery (tableName).Select(newSelect); Maybe I should just modify the properties.Aggregate method to prefix the "Properties[...]" section with the reflected.PropertyType? So the new select string will be made like: string newSelect = "new(" + properties.Aggregate("", (seed, reflected) => seed += string.Format(", ({1})Properties[\"{0}\"] as {0}", reflected.Name, reflected.PropertyType)).Substring(2) + ")"; Edit 2: So now I've hit quite the roadblock. I can generate the anonymous types for all tables to pull all values I need, but LINQ craps out on my no matter what I do for the filter. I've stated the reason above (no comparison operators on objects), but the issue I've been battling with now is trying to specify a type parameter to the Dynamic LINQ extension method to accept the schema of the new object type. Not much luck there, either... I'll keep you all posted.
