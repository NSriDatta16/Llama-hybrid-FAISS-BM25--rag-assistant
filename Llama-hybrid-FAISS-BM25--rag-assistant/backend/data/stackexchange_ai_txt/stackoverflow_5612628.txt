[site]: stackoverflow
[post_id]: 5612628
[parent_id]: 5612174
[tags]: 
You can have memory-efficient or you can have compute-efficient, but you can't have both at the same time. Packing booleans into an array of unsigned char means that for any random read access, you have to: Calculate the offset into the array where the bit lives Retrieve that element Calculate the offset into that byte where the bit you're interested in lives Shift the byte that many times to position the bit in the least-significant position Mask off all but the least-significant position Test for zero/nonzero Storing them in individual array elements cuts it down to: Retrieve the element containing the boolean you're interested in Test for zero/nonzero Selecting one over the other depends on how your storage and performance needs balance each other, how you intend to use the data and what trade-offs you're willing to make. In your case, the directly-accessed approach costs an eight-fold increase in storage that runs you out of memory and causes a failure, so it's off the table. That leaves packed bits at a cost of some extra processing. If you spend a lot of time iterating over all or part of the set, you can use the packed approach and cut back on some of the computation by retrieving bytes only when you need them and doing a single shift and mask each time you go after the next bit. Doing this immediately would be premature optmization, so just keep it in your back pocket until you discover that access is actually actually causing a bottleneck. Get your program to run the available memory first. Also keep in mind that the microcontroller used in Arduino is not particularly sophisticated and doesn't have large registers, so packing into anything larger like unsigned int or unsigned long might end up being couterproductive.
