[site]: stackoverflow
[post_id]: 1855497
[parent_id]: 1852293
[tags]: 
This solution uses sub-queries, and there is no need for any explicit temporary tables. I've assumed your backup data is in another database on the other machine; if not you'd only need to do up to step 2 for the result-set you need, and write your program to update the main database accordingly. The idea is to start out by producing a 'compact' result-set summarising the gap-list. I.e. the following data: MeasureDate 2009-12-06 13:00:00 2009-12-06 13:10:00 --missing data 2009-12-06 13:30:00 --missing data 2009-12-06 14:10:00 2009-12-06 14:20:00 2009-12-06 14:30:00 --missing data 2009-12-06 15:00:00 Would be transformed into the following where actual gaps are strictly between (i.e. exclusive of) the endpoints: GapStart GapEnd 2009-12-06 13:10:00 2009-12-06 13:30:00 2009-12-06 13:30:00 2009-12-06 14:10:00 2009-12-06 14:30:00 2009-12-06 15:00:00 2009-12-06 15:00:00 NULL The solution query is built up as follows: Obtain all MeasureDates that don't have an entry 10 minutes later as this will be the start of a gap. NOTE: The last entry will be included even though not strictly a gap; but this won't have any adverse effects. Augment the above by adding the end of the gap using the first MeasureDate after the start of the gap. NOTE: The gap-list is compact, and unless you have an exceptionally high prevalence of fragmented gaps, it should not consume much bandwidth in passing that result-set to the backup machine. Use an INNER JOIN with inequalities to identify any missing data that may be available in the backup. (Run tests and checks to verify the integrity of your backup data.) Assuming your backup data is sound, and won't produce anomalous unfounded spikes in your measurements, INSERT the data in your main database. The following query should be tested (preferably adjusted to run on the backup server for performance reasons). /* TiC Copyright This query is writtend (sic) by me, and cannot be used without expressed (sic) written permission. (lol) */ /*Step 3*/ SELECT gap.GapStart, gap.GapEnd, rem.MeasureDate, rem.Col1, ... FROM ( /*Step 2*/ SELECT gs.GapStart, ( SELECT MIN(wd.MeasureDate) FROM WeatherData wd WHERE wd.MeasureDate > gs.GapStart ) AS GapEnd FROM ( /*Step 1*/ SELECT wd.MeasureDate AS GapStart FROM WeatherData wd WHERE NOT EXISTS ( SELECT * FROM WeatherData nxt WHERE nxt.MeasureDate = DATEADD(mi, 10, wd.MeasureDate) ) ) gs ) gap INNER JOIN RemoteWeatherData rem ON rem.MeasureDate > gap.GapStart AND rem.MeasureDate The insert... INSERT INTO WeatherData (MeasureDate, Col1, ...) SELECT /*gap.GapStart, gap.GapEnd,*/ rem.MeasureDate, rem.Col1, ... ...
