[site]: stackoverflow
[post_id]: 240396
[parent_id]: 240320
[tags]: 
Really, you can't... The only way to do it is to either use thread.stop, agree on a 'cooperative' method (e.g. occassionally check for Thread.isInterrupted or call a method which throws an InterruptedException, e.g. Thread.sleep()), or somehow invoke the method in another JVM entirely. For certain kinds of tests, calling stop() is okay, but it will probably damage the state of your test suite, so you'll have to relaunch the JVM after each call to stop() if you want to avoid interaction effects. For a good description of how to implement the cooperative approach, check out Sun's FAQ on the deprecated Thread methods . For an example of this approach in real life, Eclipse RCP's Job API's 'IProgressMonitor' object allows some management service to signal sub-processes (via the 'cancel' method) that they should stop. Of course, that relies on the methods to actually check the isCancelled method regularly, which they often fail to do. A hybrid approach might be to ask the thread nicely with interrupt, then insist a couple of seconds later with stop. Again, you shouldn't use stop in production code, but it might be fine in this case, esp. if you exit the JVM soon after. To test this approach, I wrote a simple harness, which takes a runnable and tries to execute it. Feel free to comment/edit. public void testStop(Runnable r) { Thread t = new Thread(r); t.start(); try { t.join(2000); } catch (InterruptedException e) { throw new RuntimeException(e); } if (!t.isAlive()) { System.err.println("Finished on time."); return; } try { t.interrupt(); t.join(2000); if (!t.isAlive()) { System.err.println("cooperative stop"); return; } } catch (InterruptedException e) { throw new RuntimeException(e); } System.err.println("non-cooperative stop"); StackTraceElement[] trace = Thread.getAllStackTraces().get(t); if (null != trace) { Throwable temp = new Throwable(); temp.setStackTrace(trace); temp.printStackTrace(); } t.stop(); System.err.println("stopped non-cooperative thread"); } To test it, I wrote two competing infinite loops, one cooperative, and one that never checks its thread's interrupted bit. public void cooperative() { try { for (;;) { Thread.sleep(500); } } catch (InterruptedException e) { System.err.println("cooperative() interrupted"); } finally { System.err.println("cooperative() finally"); } } public void noncooperative() { try { for (;;) { Thread.yield(); } } finally { System.err.println("noncooperative() finally"); } } Finally, I wrote the tests (JUnit 4) to exercise them: @Test public void testStopCooperative() { testStop(new Runnable() { @Override public void run() { cooperative(); } }); } @Test public void testStopNoncooperative() { testStop(new Runnable() { @Override public void run() { noncooperative(); } }); } I had never used Thread.stop() before, so I was unaware of its operation. It works by throwing a ThreadDeath object from whereever the target thread is currently running. This extends Error. So, while it doesn't always work cleanly, it will usually leave simple programs with a fairly reasonable program state. For example, any finally blocks are called. If you wanted to be a real jerk, you could catch ThreadDeath (or Error), and keep running, anyway! If nothing else, this really makes me wish more code followed the IProgressMonitor approach - adding another parameter to methods that might take a while, and encouraging the implementor of the method to occasionally poll the Monitor object to see if the user wants the system to give up. I'll try to follow this pattern in the future, especially methods that might be interactive. Of course, you don't necessarily know in advance which methods will be used this way, but that is what Profilers are for, I guess. As for the 'start another JVM entirely' method, that will take more work. I don't know if anyone has written a delegating class loader, or if one is included in the JVM, but that would be required for this approach.
