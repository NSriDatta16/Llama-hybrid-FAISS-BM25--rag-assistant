[site]: stackoverflow
[post_id]: 2389080
[parent_id]: 2388409
[tags]: 
As a hack, convert it to a struct and see how much space that takes up. I think that will expose all the data in "regular" object fields. f = foo(); origWarn = warning(); warning off 'MATLAB:structOnObject' s = builtin('struct', f); % use 'builtin' in case @foo overrides struct() warning(origWarn); Then you can see it in whos. >> whos Name Size Bytes Class Attributes f 1x1 60 foo s 1x1 8000124 struct This is just a first order approximation. It will tell you how much memory its fields are using. If any of them contain handle objects, you need to recurse down the fields of that struct and convert any other handle objects to struct to count their fields. (If you want to include Java objects' memory, you'll also need a separate function to estimate their storage size. Probably not worth the bother.) Now that Matlab has closures, function handles may also contain data; you'll need to punch in to those using functions() if you want to count closed-over data. If you're working with handle objects, you may have aliasing and even circular references at the M-code level, so you'd need to watch out for that when recursing. (Sorry, I don't know how to handle that in the new OO system.) The memory display in whos will also double-count arrays that are sharing memory via Matlab's copy-on-write optimization. Here's a concrete example. x = NaN(1,10000); s.x = x; s.y = x; s.z = x; >> whos Name Size Bytes Class Attributes s 1x1 240372 struct x 1x10000 80000 double In reality, s is only consuming about 80K; it just contains three pointers to x. And that 80K is the same 80K that x itself is consuming. Unless you modify any of them; then a new array is allocated. Whos() won't let you differentiate those cases. Handling this is hard; AFAIK the only way to do this is to use a MEX file to get the mxarray's data pointer(s) and walk the object tree yourself, detecting aliased pointers and counting the aliased bytes. This is a general problem with measuring the size of objects in memory when their components could be shared. They're not discrete physical objects. At least you're not in C, working with pointers to arbitrary memory blocks.
