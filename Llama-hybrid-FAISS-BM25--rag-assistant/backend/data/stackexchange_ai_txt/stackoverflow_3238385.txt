[site]: stackoverflow
[post_id]: 3238385
[parent_id]: 3237889
[tags]: 
First off, you cannot verify this at commit time, because you only have access to the changeset once it gets pushed to one of your central repositories. So you could verify that whoever is pushing the cset is also the committer (by matching http or ssh authentication). This is somewhat limiting because it can be useful when people push other developer's changesets. You could use the pgp extension (from hgext) to explicitly sign changesets after committing, but it's kind of a drag if you want to do it for every changeset. commitsigs is another extension, which takes a different tack to signing. It embeds the signature directly in the changeset, thereby avoiding the clutter of an extra changeset. This adds an overhead of about 2 KB to each changeset. Mozilla uses a pushlog which just tracks who pushed what. This lets you look in the commit history on the server (but only there) to see who pushed what group of changesets, giving you a better paper trail than you normally get. This can also be provided by changegroup notifications, if you include the guy who did the push in the email (this is what Python will do once their conversion is done). So these are the technical solutions. On the other hand, think about this some more: you've already given a group of people push access to your central repositories. If they want, they can muck about with your tree already. If you trust them to push stuff into your central tree, can't you also trust them to have the best intentions about putting their own names on their changesets?
