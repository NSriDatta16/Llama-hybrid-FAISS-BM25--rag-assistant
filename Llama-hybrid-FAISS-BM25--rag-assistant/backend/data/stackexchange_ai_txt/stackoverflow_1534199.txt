[site]: stackoverflow
[post_id]: 1534199
[parent_id]: 1534111
[tags]: 
Note: this is speculation based on my understanding of how SQL query planners work, and may not be entirely accurate. I believe all the aggregate functions, or at least the "math" ones you name above, should be O(n). The query will be executed roughly as follows: Fetch rows matching the join predicates and filter predicates (ie "WHERE clause") Create row-groups according to the GROUP BY clause. A single row-group is created for queries with no GROUP BY For each row group, apply the aggregate function to the rows in the group. For things like SUM, AVG, MIN, MAX as well as non-numeric functions like CONCAT there are simple O(n) algorithms, and I suspect those are used. Create one row in the output set for each row-group created in step #2 If a HAVING predicate is present, filter output rows using this predicate Note, however, that even though the aggregate functions are O(n), the operation might not be. If you create a query which cartesian joins a table to itself, you will be looking at O(n*n) minimum just to create the initial row set (step #1). Sorting to create row-groups (step #2) may be O(n lg n), and may require disk storage for the sort operation (as opposed to in-memory operation only), so your query may still perform poorly if you are manipulating many rows.
