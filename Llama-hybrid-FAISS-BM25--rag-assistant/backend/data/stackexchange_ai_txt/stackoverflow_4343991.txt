[site]: stackoverflow
[post_id]: 4343991
[parent_id]: 4343760
[tags]: 
The compiler optimizes inlineable static final fields by embedding the value in the bytecode instead of computing the value at runtime. When you fire up a JVM and load a class for the first time (this is done by the classloader when the class is first referenced in any way) any static blocks or fields are 'loaded' into the JVM and become accessible. A demonstration: public class StaticDemo { // a static initialization block, executed once when the class is loaded static { System.out.println("Class StaticDemo loading..."); } // a constant static final long ONE_DAY_IN_MILLIS = 24 * 60 * 60 * 1000; // a static field static int instanceCounter; // a second static initialization block // static members are processed in the order they appear in the class static { // we can now acces the static fields initialized above System.out.println("ONE_DAY_IN_MILLIS=" + ONE_DAY_IN_MILLIS + " instanceCounter=" + instanceCounter); } // an instance initialization block // instance blocks are executed each time a class instance is created, // after the parent constructor, but before any own constructors (as remarked by Ahmed Hegazy) { StaticDemo.instanceCounter++; System.out.println("instanceCounter=" + instanceCounter); } public static void main(String[] args) { System.out.println("Starting StaticDemo"); new StaticDemo(); new StaticDemo(); new StaticDemo(); } static { System.out.println("Class StaticDemo loaded"); } } Output: Class StaticDemo loading... ONE_DAY_IN_MILLIS=86400000 instanceCounter=0 Class StaticDemo loaded Starting StaticDemo instanceCounter=1 instanceCounter=2 instanceCounter=3 Notice how 'Starting StaticDemo' does not appear as the first line of output. This is because the class must be loaded before the main method can be executed, which means all static fields and blocks are processed in order.
