[site]: stackoverflow
[post_id]: 4207029
[parent_id]: 4191674
[tags]: 
For things like these, numpy makes things much easier, as it provides useful functions for manipulating vector data, e.g. adding a scalar to each element, calculating the average value etc. For example, you might try with zero crossing rate of either the original data-wiggliness1 or the first difference-wiggliness2 (depending on what wiggliness is supposed to be, exactly-if global trends are to be ignored, you should probably use the difference data). For x you would take the slice or window of interest from the original data, getting a sort of measure of local wiggliness. If you use the original data, after removing the bias you might also want to set all values smaller than some threshold to 0 to ignore low-amplitude wiggles. import numpy as np def wiggliness1(x): #remove bias: x=x-np.average(x) #calculate zero crossing rate: np.sum(np.abs(np.sign(np.diff(x)))) def wiggliness(x): #calculate zero crossing rate of the first difference: return np.sum(np.abs(np.sign(np.diff(np.sign(np.diff(x))))))
