[site]: stackoverflow
[post_id]: 4271257
[parent_id]: 4271015
[tags]: 
just because an element is draggable does not mean it can not be droppable as well. I have written a little example for you, it's very trivial, half the elements are drop only, red borders, half are drop targets and draggable too. Demo: http://jsfiddle.net/63kgz/1/ HTML: (a few random objects) A B C D E F CSS: (ignore this, it's just to show up random objects) .drag { width: 100px; height: 100px; float:left; margin-bottom: 10px; margin-right: 10px; border:1px solid #f00; } .drop { width: 200px; height: 200px; float:left; margin: 10px 10px 10px 10px; border: 1px solid #000; } .drop p { width: auto; color: #00f; margin-left: 50%; margin-right: 50%; margin-top: 25%; margin-bottom: 25%; } .clear { clear: both; } div { user-select: none; -o-user-select:none; -moz-user-select: none; -khtml-user-select: none; -webkit-user-select: none; } jQuery: // Everything is draggable $('.drag,.drop').draggable(); // Only the .drop class is droppable $('.drop').droppable({ 'accept': '.drag,.drop', 'drop' : function(event, ui) { $(this).find('p').text(ui.draggable.find('span').text()); } }); // This just makes the sizes different so the objects fit in each other $('.drag').css('width', function(i, value) { return parseInt(value) * (1 / (i + 1)) + 'px'; }).css('height', function(i, value) { return parseInt(value) * (1 / (i + 1)) + 'px'; }); $('.drop').css('width', function(i, value) { return parseInt(value) * (1 / (i + 1)) + 'px'; }).css('height', function(i, value) { return parseInt(value) * (1 / (i + 1)) + 'px'; });
