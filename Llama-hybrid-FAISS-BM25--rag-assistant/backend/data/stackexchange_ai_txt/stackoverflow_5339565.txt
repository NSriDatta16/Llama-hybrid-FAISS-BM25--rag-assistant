[site]: stackoverflow
[post_id]: 5339565
[parent_id]: 5338536
[tags]: 
Named scopes in DataMapper are simply class methods that you define on your model classes. Inside those class methods, you typically call #all with some conditions to get back a DataMapper::Collection . In order for your class methods to be chainable, you must make sure to return a DataMapper::Collection . For completeness' sake, here are the installation instructions ... gem install dm-core gem install dm-migrations gem install dm-sqlite-adapter gem install dm-chunked_query And the code to get you going (put this into test.rb for maximum reproducability) require 'rubygems' require 'dm-core' require 'dm-migrations' require 'dm-chunked_query' class Person include DataMapper::Resource property :id, Serial property :name, String property :hobby, String property :country, String property :continent, String def self.european all(:continent => 'Europe') end def self.hackers all(:hobby => 'Hacking') end def self.named(name) all(:name => name) end end DataMapper::Logger.new($stdout, :debug) DataMapper.setup(:default, 'sqlite::memory:') DataMapper.finalize.auto_migrate! 1.upto(10) do |i| Person.create(:name => "Alex", :hobby => 'Hacking', :country => "Country-#{i}", :continent => 'Europe') end # you could even skip the explicit call to #all # i just left it in there because it reads nicely Person.all.european.hackers.named('Alex').chunks(5).each_with_index do |chunk, idx| puts "Rendering page #{idx + 1}" chunk.each do |person| puts "Someone named #{person.name} who lives in #{person.country}" end end __END__ ruby-1.9.2-p180@datamapper mungo:dm-rails snusnu$ ruby test.rb ~ (0.000102) SELECT sqlite_version(*) ~ (0.000132) DROP TABLE IF EXISTS "people" ~ (0.000013) PRAGMA table_info("people") ~ (0.000315) CREATE TABLE "people" ("id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, "name" VARCHAR(50), "hobby" VARCHAR(50), "country" VARCHAR(50), "continent" VARCHAR(50)) ~ (0.000049) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-1', 'Europe') ~ (0.000056) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-2', 'Europe') ~ (0.000044) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-3', 'Europe') ~ (0.000043) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-4', 'Europe') ~ (0.000037) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-5', 'Europe') ~ (0.000038) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-6', 'Europe') ~ (0.000035) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-7', 'Europe') ~ (0.000035) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-8', 'Europe') ~ (0.000036) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-9', 'Europe') ~ (0.000039) INSERT INTO "people" ("name", "hobby", "country", "continent") VALUES ('Alex', 'Hacking', 'Country-10', 'Europe') ~ (0.000069) SELECT "id", "name", "hobby", "country", "continent" FROM "people" WHERE ("continent" = 'Europe' AND "hobby" = 'Hacking' AND "name" = 'Alex') ORDER BY "id" Rendering page 1 Someone named Alex who lives in Country-1 Someone named Alex who lives in Country-2 Someone named Alex who lives in Country-3 Someone named Alex who lives in Country-4 Someone named Alex who lives in Country-5 Rendering page 2 Someone named Alex who lives in Country-6 Someone named Alex who lives in Country-7 Someone named Alex who lives in Country-8 Someone named Alex who lives in Country-9 Someone named Alex who lives in Country-10 See https://github.com/postmodern/dm-chunked_query for more information on the lowlevel approach to pagination (batch processing) that provides the #chunks method used in this example.
