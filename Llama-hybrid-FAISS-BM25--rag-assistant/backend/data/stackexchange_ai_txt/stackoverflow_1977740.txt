[site]: stackoverflow
[post_id]: 1977740
[parent_id]: 1977629
[tags]: 
the only thing that worked for me involves dumbing down the implementation. it's ugly but works (both with and without operator new): var new_ = function (cls) { var constructors = [ function () { return new cls(); } , function ($0) { return new cls($0); } , function ($0, $1) { return new cls($0, $1); } , function ($0, $1, $2) { return new cls($0, $1, $2); } , // up to a chosen limit ]; return function () { return constructors[arguments.length].apply( this , arguments ); } } edit to react to comments I have way-below-average tolerance to repetitive code, and this code hurt to write, but the functions in constructors need to be separate if arguments.length is to mean something in the real constructor function. consider a variant with a single new wrapper: var new_ = function (cls) { // arbitrary limit var constructor = function ($0, $1, $2) { return new cls($0, $1, $2); }; return function () { return constructor.apply( this , arguments ); } } var gen = new_(function () { print( arguments.length + " " + Array.prototype.toSource.call(arguments) ); }); gen("foo") // 3 ["foo", undefined, undefined] gen("foo", "bar") // 3 ["foo", "bar", undefined] gen("foo", "bar", "baz") // 3 ["foo", "bar", "baz"] the parameter list can be arbitrarily wide, but arguments.length doesn't lie only in the special case. I've been using this solution with the upper limit of 10 arguments for a few years, and I don't remember ever running into the limit. the risk that it'll ever happen is rather low: everybody knows that functions with many parameters are a no-no, and javascript has a better interface for the desired functionality: packing parameters into objects. so, the only limit is the width of the parameter list, and this limit seems to be purely theoretical. other than that, it supports completely arbitrary constructors, so I'd say it's very general.
