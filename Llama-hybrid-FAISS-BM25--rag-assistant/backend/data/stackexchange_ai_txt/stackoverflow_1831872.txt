[site]: stackoverflow
[post_id]: 1831872
[parent_id]: 1831635
[tags]: 
On the second question. (And this is not stated in the standard, and can be implemented in other ways, so just take the general ideas out of it. It is also oversimplified for single inheritance hierarchies, multiple inheritance makes everything more complex). The memory layout of a derived and a base object coincides 100% in as much as the size of the base object (including any data injected by the compiler). This means that a pointer that has base type and actually points to derived will actually point to a piece of memory that can be interpreted as a base object, the layout is the same even if the contents (vptr value) are different. base derived base_vptr base_vptr base_attrs base_attrs derived_vptr derived_attrs When you create an instance of derived the compiler will call the appropriate derived constructor, whose initialization list starts by calling the base constructor. At this point the vtable pointer base_vptr is set to point to the virtual table of the base class, and as such all pointers there refer to base::method . After the base constructor has completed, the base_vptr is updated in derived and it is set to point to the derived vtable, so instances there point to derived::method if the method is overriden in derived . At this point derived_vptr points to the derived vtable for virtual methods added in derived and would point to derived::new_method ... Just to make a point: the vtable does not necessarily store pointers into the actual methods. In some cases, intermediate code must be executed whenever a virtual method is called, and that happens whenever multiple inheritance comes into play. Things get more complicated, as the derived class can only be aligned with one of its bases (usually the first one declared). This is where things really get tricky. Upcasting to base2 modifies the pointer so that it points to the memory location that can be directly be interpreted as a base2 instance, so the contents of a pointer (memory location) of type base2 pointing to an object of type derived will not coincide with a pointer of type derived into the same object. At this point, if a virtual method from base2 is called, the system must perform some magic to recalculate the correct position of the implicit this argument that is handed into the derived::method_from2 virtual method (that must point back to the whole derived object and not just the base2 subobject.
