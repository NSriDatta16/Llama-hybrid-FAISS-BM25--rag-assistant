[site]: datascience
[post_id]: 51033
[parent_id]: 
[tags]: 
Use Machine Learning/Artificial Intelligence to predict next number (n+1) in a given sequence of random increasing integers

The AI must predict the next number in a given sequence of incremental integers (with no obvious pattern) using Python but so far I don't get the intended result! I tried changing the learning rate and iterations but so far no luck! Example sequence: [1, 3, 7, 8, 21, 49, 76, 224] Expected result: 467 Result found : 2,795.5 Cost: 504579.43 PS. The same thread exists on AI Stackexchange & Stackoverflow and I've been advised to post it here! This is what I've done so far: import numpy as np # Init sequence data =\ [ [0, 1.0], [1, 3.0], [2, 7.0], [3, 8.0], [4, 21.0], [5, 49.0], [6, 76.0], [7, 224.0] ] X = np.matrix(data)[:, 0] y = np.matrix(data)[:, 1] def J(X, y, theta): theta = np.matrix(theta).T m = len(y) predictions = X * theta sqError = np.power((predictions-y), [2]) return 1/(2*m) * sum(sqError) dataX = np.matrix(data)[:, 0:1] X = np.ones((len(dataX), 2)) X[:, 1:] = dataX # gradient descent function def gradient(X, y, alpha, theta, iters): J_history = np.zeros(iters) m = len(y) theta = np.matrix(theta).T for i in range(iters): h0 = X * theta delta = (1 / m) * (X.T * h0 - X.T * y) theta = theta - alpha * delta J_history[i] = J(X, y, theta.T) return J_history, theta print('\n'+40*'=') # Theta initialization theta = np.matrix([np.random.random(), np.random.random()]) # Learning rate alpha = 0.02 # Iterations iters = 1000000 print('\n== Model summary ==\nLearning rate: {}\nIterations: {}\nInitial theta: {}\nInitial J: {:.2f}\n' .format(alpha, iters, theta, J(X, y, theta).item())) print('Training model... ') # Train model and find optimal Theta value J_history, theta_min = gradient(X, y, alpha, theta, iters) print('Done, Model is trained') print('\nModelled prediction function is:\ny = {:.2f} * x + {:.2f}' .format(theta_min[1].item(), theta_min[0].item())) print('Cost is: {:.2f}'.format(J(X, y, theta_min.T).item())) # Calculate the predicted profit def predict(pop): return [1, pop] * theta_min # Now p = len(data) print('\n'+40*'=') print('Initial sequence was:\n', *np.array(data)[:, 1]) print('\nNext numbers should be: {:,.1f}' .format(predict(p).item())) Another method I tried but still giving wrong results import numpy as np from sklearn import datasets, linear_model # Define the problem problem = [1, 3, 7, 8, 21, 49, 76, 224] # create x and y for the problem x = [] y = [] for (xi, yi) in enumerate(problem): x.append([xi]) y.append(yi) x = np.array(x) y = np.array(y) # Create linear regression object regr = linear_model.LinearRegression() regr.fit(x, y) # create the testing set x_test = [[i] for i in range(len(x), 3 + len(x))] # The coefficients print('Coefficients: \n', regr.coef_) # The mean squared error print("Mean squared error: %.2f" % np.mean((regr.predict(x) - y) ** 2)) # Explained variance score: 1 is perfect prediction print('Variance score: %.2f' % regr.score(x, y)) # Do predictions y_predicted = regr.predict(x_test) print("Next few numbers in the series are") for pred in y_predicted: print(pred)
