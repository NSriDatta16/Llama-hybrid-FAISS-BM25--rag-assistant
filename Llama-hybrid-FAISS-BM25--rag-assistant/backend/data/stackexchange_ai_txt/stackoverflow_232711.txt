[site]: stackoverflow
[post_id]: 232711
[parent_id]: 231912
[tags]: 
Use sigaction() unless you've got very compelling reasons not to do so. The signal() interface has antiquity (and hence availability) in its favour, and it is defined in the C standard. Nevertheless, it has a number of undesirable characteristics that sigaction() avoids - unless you use the flags explicitly added to sigaction() to allow it to faithfully simulate the old signal() behaviour. The signal() function does not (necessarily) block other signals from arriving while the current handler is executing; sigaction() can block other signals until the current handler returns. The signal() function (usually) resets the signal action back to SIG_DFL (default) for almost all signals. This means that the signal() handler must reinstall itself as its first action. It also opens up a window of vulnerability between the time when the signal is detected and the handler is reinstalled during which if a second instance of the signal arrives, the default behaviour (usually terminate, sometimes with prejudice - aka core dump) occurs. The exact behaviour of signal() varies between systems — and the standards permit those variations. These are generally good reasons for using sigaction() instead of signal() . However, the interface of sigaction() is undeniably more fiddly. Whichever of the two you use, do not be tempted by the alternative signal interfaces such as sighold() , sigignore() , sigpause() and sigrelse() . They are nominally alternatives to sigaction() , but they are only barely standardized and are present in POSIX for backwards compatibility rather than for serious use. Note that the POSIX standard says their behaviour in multi-threaded programs is undefined. Multi-threaded programs and signals is a whole other complicated story. AFAIK, both signal() and sigaction() are OK in multi-threaded applications. Cornstalks observes : The Linux man page for signal() says: The effects of signal() in a multi-threaded process are unspecified. Thus, I think sigaction() is the only that can be used safely in a multi-threaded process. That's interesting. The Linux manual page is more restrictive than POSIX in this case. POSIX specifies for signal() : If the process is multi-threaded, or if the process is single-threaded and a signal handler is executed other than as the result of: The process calling abort() , raise() , kill() , pthread_kill() , or sigqueue() to generate a signal that is not blocked A pending signal being unblocked and being delivered before the call that unblocked it returns the behavior is undefined if the signal handler refers to any object other than errno with static storage duration other than by assigning a value to an object declared as volatile sig_atomic_t , or if the signal handler calls any function defined in this standard other than one of the functions listed in Signal Concepts . So POSIX clearly specifies the behaviour of signal() in a multi-threaded application. Nevertheless, sigaction() is to be preferred in essentially all circumstances — and portable multi-threaded code should use sigaction() unless there's an overwhelming reason why it can't (such as "only use functions defined by Standard C" — and yes, C11 code can be multi-threaded). Which is basically what the opening paragraph of this answer also says.
