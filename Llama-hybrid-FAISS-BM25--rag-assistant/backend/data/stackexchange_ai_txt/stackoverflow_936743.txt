[site]: stackoverflow
[post_id]: 936743
[parent_id]: 141779
[tags]: 
Here's concurrent implementation in Clojure. To calculate (items-with-price 15.05) takes about 14 combination-generation recursions, and about 10 possibility-checks. Took me about 6 minutes to calculate (items-with-price 100) on my Intel Q9300. This only gives the first found answer, or nil if there is none, as that's all the problem calls for. Why do more work that you've been told to do ;) ? ;; np-complete.clj ;; A Clojure solution to XKCD #287 "NP-Complete" ;; By Sam Fredrickson ;; ;; The function "items-with-price" returns a sequence of items whose sum price ;; is equal to the given price, or nil. (defstruct item :name :price) (def *items* #{(struct item "Mixed Fruit" 2.15) (struct item "French Fries" 2.75) (struct item "Side Salad" 3.35) (struct item "Hot Wings" 3.55) (struct item "Mozzarella Sticks" 4.20) (struct item "Sampler Plate" 5.80)}) (defn items-with-price [price] (let [check-count (atom 0) recur-count (atom 0) result (atom nil) checker (agent nil) ; gets the total price of a seq of items. items-price (fn [items] (apply + (map #(:price %) items))) ; checks if the price of the seq of items matches the sought price. ; if so, it changes the result atom. if the result atom is already ; non-nil, nothing is done. check-items (fn [unused items] (swap! check-count inc) (if (and (nil? @result) (= (items-price items) price)) (reset! result items))) ; lazily generates a list of combinations of the given seq s. ; haven't tested well... combinations (fn combinations [cur s] (swap! recur-count inc) (if (or (empty? s) (> (items-price cur) price)) '() (cons cur (lazy-cat (combinations (cons (first s) cur) s) (combinations (cons (first s) cur) (rest s)) (combinations cur (rest s))))))] ; loops through the combinations of items, checking each one in a thread ; pool until there are no more combinations or the result atom is non-nil. (loop [items-comb (combinations '() (seq *items*))] (if (and (nil? @result) (not-empty items-comb)) (do (send checker check-items (first items-comb)) (recur (rest items-comb))))) (await checker) (println "No. of recursions:" @recur-count) (println "No. of checks:" @check-count) @result))
