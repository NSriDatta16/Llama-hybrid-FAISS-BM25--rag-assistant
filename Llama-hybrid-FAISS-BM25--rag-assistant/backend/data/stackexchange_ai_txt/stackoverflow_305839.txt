[site]: stackoverflow
[post_id]: 305839
[parent_id]: 305690
[tags]: 
Keeping the idea of a converter to skip a switch block, you could use the concept of Duck Typing. Basically, you want to turn a string to X, so you make a method that will call X.TryParse(string, out X x) if X has TryParse on it, otherwise you just don't bother (Or I suppose you could throw an error). How would you do this? Reflection and Generics. Basically you would have a method that would take in a type and use reflection to see if it has TryParse on it. If you find such a method you then call it and return whatever TryParse managed to get. This works well with just about any value type like say Decimal or DateTime. public static class ConvertFromString { public static T? ConvertTo (this String numberToConvert) where T : struct { T? returnValue = null; MethodInfo neededInfo = GetCorrectMethodInfo(typeof(T)); if (neededInfo != null && !numberToConvert.IsNullOrEmpty()) { T output = default(T); object[] paramsArray = new object[2] { numberToConvert, output }; returnValue = new T(); object returnedValue = neededInfo.Invoke(returnValue.Value, paramsArray); if (returnedValue is Boolean && (Boolean)returnedValue) { returnValue = (T)paramsArray[1]; } else { returnValue = null; } } return returnValue; } } Where GetCorrectMethodInfo would look something like this: private static MethodInfo GetCorrectMethodInfo(Type typeToCheck) { MethodInfo returnValue = someCache.Get(typeToCheck.FullName); if(returnValue == null) { Type[] paramTypes = new Type[2] { typeof(string), typeToCheck.MakeByRefType() }; returnValue = typeToCheck.GetMethod("TryParse", paramTypes); if (returnValue != null) { CurrentCache.Add(typeToCheck.FullName, returnValue); } } return returnValue; } And use would be: decimal? converted = someString.ConvertTo (); I hate plugging myself, but I have this fully explained here: GetCorrectMethodInfo Rest of It
