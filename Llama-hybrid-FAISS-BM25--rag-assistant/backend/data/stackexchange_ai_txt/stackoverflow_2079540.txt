[site]: stackoverflow
[post_id]: 2079540
[parent_id]: 2077621
[tags]: 
I believe that this can be done considerably faster than O(nÂ²) on average (it is likely that input can be engineered not to allow fast analysis). You can regard consecutive additions or deletions as sets. You can analyze one operation at a time, and you will have to do some conditional transformations: If an addition follows an addition, or a set of additions, it might touch (one or more of) the previous addition(s): then, you can unite these additions not touch: you can order them (you will have to adjust the positions) If a deletion follows an addition, or a set of additions, it might only delete characters from the addition: then, you can modify the addition (unless it would split an addition) only delete characters not from the set of additions: then, you can move the deletion to a position before the set of additions, and perhaps unite additions; after that, the set of deletions before the current set of additions might have to be applied to the additions before that do both: then, you can first split it into two (or more) deletions and apply the respective method If a deletion follows a deletion, or a set of deletions, it can: touch (one or more of) the previous deletion(s): then, you can unite these deletions not touch: you can order them (you will have to adjust the positions in any case, you then have to apply analysis of the newly formed deletions on the previous additions If an addition follows a deletion, no transformation is needed at this point This is just a first rough draft. Some things may have to be done differently, e.g., it might be easier or more efficient to always apply all deletions, so that the result is always only one set of deletions followed by one set of additions.
