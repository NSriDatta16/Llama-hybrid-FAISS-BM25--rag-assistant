[site]: stackoverflow
[post_id]: 3967293
[parent_id]: 3967207
[tags]: 
Use Executor executor = Executors.newSingleThreadExecutor(); executor.execute(new Runnable() { @Override public void run() { anotherMethod(); } }); // this is called automatically when the object is gc-ed, // but you should not rely on this, hence the explicit call executor.shutdown(); To quote Effective Java: Not only should you refrain from writing your own work queues, but you should generally refrain from working directly with threads. The key abstraction is no longer Thread, which served as both the unit of work and the mechanism for executing it. Now the unit of work and mechanism are separate. The key abstraction is the unit of work, which is called a task. There are two kinds of tasks: Runnable and its close cousin, Callable (which is like Runnable, except that it returns a value). The general mechanism for executing tasks is the executor ser- vice. If you think in terms of tasks and let an executor service execute them for you, you gain great flexibility in terms of selecting appropriate execution policies. In essence, the Executor Framework does for execution what the Collections Framework did for aggregation. Note that you'd better create your executor only once, store it in an instance field and reuse it (and shut it down afterwards) If you are running in JavaEE 6 or spring, you can annotate your anotherMethod() with @Asynchronous and the container will start a new thread for you.
