[site]: stackoverflow
[post_id]: 4151183
[parent_id]: 4151142
[tags]: 
Probably the best way would be to use a dict for the outside container with strings for the keys mapping to an inner dictionary with tuples (the vector indices) mapping to doubles: d = {'abc': {(0,0,0): 1.2, (0,0,1): 1.3}} It's probably less efficient (less time-efficient at least, it's actually more space-efficient I would imagine) than actually nesting the lists, but IMHO cleaner to access: >>> d['abc'][0,0,1] 1.3 Edit Adding keys as you went: d = {} #start with empty dictionary d['abc'] = {} #insert a new string key into outer dict d['abc'][0,3,3] = 1.3 #insert new value into inner dict d['abc'][5,3,3] = 2.4 #insert another value into inner dict d['def'] = {} #insert another string key into outer dict d['def'][1,1,1] = 4.4 #... >>> d {'abc': {(0, 3, 3): 1.3, (5, 3, 3): 2.4}, 'def': {(1, 1, 1): 4.4}} Or if using Python >= 2.5, an even more elegant solution would be to use defaultdict : it works just like a normal dictionary, but can create values for keys that don't exist. import collections d = collections.defaultdict(dict) #The first parameter is the constructor of values for keys that don't exist d['abc'][0,3,3] = 1.3 d['abc'][5,3,3] = 2.4 d['def'][1,1,1] = 4.4 #... >>> d defaultdict( , {'abc': {(0, 3, 3): 1.3, (5, 3, 3): 2.4}, 'def': {(1, 1, 1): 4.4}})
