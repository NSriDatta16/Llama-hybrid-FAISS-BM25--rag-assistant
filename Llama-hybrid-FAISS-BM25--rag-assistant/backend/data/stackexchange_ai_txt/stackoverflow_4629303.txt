[site]: stackoverflow
[post_id]: 4629303
[parent_id]: 4625237
[tags]: 
You may find it easier to make numpy extensions in Cython using the Numpy C-API which simplifies the process as it allows you to mix python and c objects. In that case there is little difficult about making a variable length array, you can simply specify an array with an arbitrary shape. The Cython numpy tutorial is probably the best source on this topic. For example, here is a function I recently wrote: import numpy as np cimport numpy as np cimport cython dtype = np.double ctypedef double dtype_t np.import_ufunc() np.import_array() def ewma(a, d, axis): #Calculates the exponentially weighted moving average of array a along axis using the parameter d. cdef void *args[1] cdef double weight[1] weight[0] = np.exp(-d) args[0] = &weight[0] return apply_along_axis(&ewma_func, np.array(a, dtype = float), np.double, np.double, False, &(args[0]), axis) cdef void ewma_func(int n, void* aData,int astride, void* oData, int ostride, void** args): #Exponentially weighted moving average calculation function cdef double avg = 0.0 cdef double weight = ( (args[0]))[0] cdef int i = 0 for i in range(n): avg = ( (( aData) + i * astride))[0]*weight + avg * (1.0 - weight) ( (( oData) + i * ostride))[0] = avg ctypedef void (*func_1d)(int, void*, int, void*, int, void **) cdef apply_along_axis(func_1d function, a, adtype, odtype, reduce, void** args, int axis): #generic function for applying a cython function along a particular dimension oshape = list(a.shape) if reduce : oshape[axis] = 1 out = np.empty(oshape, odtype) cdef np.flatiter ita, ito ita = np.PyArray_IterAllButAxis(a, &axis) ito = np.PyArray_IterAllButAxis(out, &axis) cdef int axis_length = a.shape[axis] cdef int a_axis_stride = a.strides[axis] cdef int o_axis_stride = out.strides[axis] if reduce: o_axis_stride = 0 while np.PyArray_ITER_NOTDONE(ita): function(axis_length, np.PyArray_ITER_DATA (ita), a_axis_stride, np.PyArray_ITER_DATA (ito), o_axis_stride, args) np.PyArray_ITER_NEXT(ita) np.PyArray_ITER_NEXT(ito) if reduce: oshape.pop(axis) out.shape = oshape return out If this doesn't suit you, there is a function for making a new empty array with arbitrary shape ( link ).
