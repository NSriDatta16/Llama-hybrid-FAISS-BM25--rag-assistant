[site]: stackoverflow
[post_id]: 4657850
[parent_id]: 985118
[tags]: 
The problem is that the designer uses a completly different implementation than WPF runtime. There's a bug on Microsoft Connect for this issue. I wrote a workaround for this problem that solves your particular issue and could be distributed with WPF Localization Guidance. I created a wrapper called ExpressionWorkaroundServiceProvider which can be used like this: // resolve properties:Resources string typeName = this.Static.Substring(0, index); string propName = this.Static.Substring(index + 1); IServiceProvider serviceProvider = new ExpressionWorkaroundServiceProvider(_serviceProvider) { PropertyName = propName }; IXamlTypeResolver service = serviceProvider.GetService(typeof(IXamlTypeResolver)) as IXamlTypeResolver; Type memberType = service.Resolve(typeName); this._propertyInfo = memberType.GetProperty(propName, BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy | BindingFlags.NonPublic); The implementation of the ExpressionWorkaroundServiceProvider: internal class ExpressionWorkaroundServiceProvider : IServiceProvider, IXamlTypeResolver { private IServiceProvider _originalProvider; public string PropertyName { get; set; } public ExpressionWorkaroundServiceProvider(IServiceProvider originalProvider) { if (originalProvider == null) { throw new ArgumentNullException("originalProvider"); } _originalProvider = originalProvider; } public object GetService(Type serviceType) { var servicedObject = _originalProvider.GetService(serviceType); if (servicedObject == null && serviceType == typeof(IXamlTypeResolver)) { return this; } return servicedObject; } public Type Resolve(string qualifiedTypeName) { var typeName = qualifiedTypeName.Substring(qualifiedTypeName.IndexOf(':') + 1); var types = AppDomain.CurrentDomain.GetAssemblies().Aggregate(new List (), (list, asm) => { list.AddRange(asm.GetTypes().Where(p => p.Name.Contains(typeName))); return list; }); if (string.IsNullOrWhiteSpace(PropertyName)) { return types.FirstOrDefault(); } else { foreach (var type in types) { if (type.GetProperty(PropertyName, BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy | BindingFlags.NonPublic) != null) { return type; } } return null; } } } This solved the problem for me. It's not a substitute to a correct IXamlTypeResolver implementation but will get the localization working on the designer.
