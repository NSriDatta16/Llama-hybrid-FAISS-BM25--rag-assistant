[site]: stackoverflow
[post_id]: 908407
[parent_id]: 906045
[tags]: 
Unfortunately, custom brushes are not supported in WPF (the brush types are marked 'internal' and cannot be inherited from), so creating a brush that is a mixture of two brushes that can be used from XAML like a normal SolidColorBrush is not possible. As a workaround, you could use a MarkupExtension to simulate the behaviour of a custom brush, which allows you to use XAML syntax and provide a custom value, which allows us to use the built-in SolidColorBrush (no custom brush necessary) set to the value you get when mixing two colors: /// /// Markup extension to mix two SolidColorBrushes together to produce a new SolidColorBrush. /// [MarkupExtensionReturnType(typeof(SolidColorBrush))] public class MixedColorBrush : MarkupExtension, INotifyPropertyChanged { /// /// The foreground mix color; defaults to white. /// If not changed, the result will always be white. /// private SolidColorBrush foreground = Brushes.White; /// /// The background mix color; defaults to black. /// If not set, the result will be the foreground color. /// private SolidColorBrush background = Brushes.Black; /// /// PropertyChanged event for WPF binding. /// public event PropertyChangedEventHandler PropertyChanged; /// /// Gets or sets the foreground mix color. /// public SolidColorBrush Foreground { get { return this.foreground; } set { this.foreground = value; this.NotifyPropertyChanged("Foreground"); } } /// /// Gets or sets the background mix color. /// public SolidColorBrush Background { get { return this.background; } set { this.background = value; this.NotifyPropertyChanged("Background"); } } /// /// Returns a SolidColorBrush that is set as the value of the /// target property for this markup extension. /// /// Object that can provide services for the markup extension. /// The object value to set on the property where the extension is applied. public override object ProvideValue(IServiceProvider serviceProvider) { if (this.foreground != null && this.background != null) { // Create a new brush as a composite of the old ones // This does simple non-perceptual additive color, e.g // blue + red = magenta, but you can swap in a different // algorithm to do subtractive color (red + yellow = orange) return new SolidColorBrush(this.foreground.Color + this.background.Color); } // If either of the brushes was set to null, return an empty (white) brush. return new SolidColorBrush(); } /// /// Raise the property changed event. /// /// Name of the property which has changed. protected void NotifyPropertyChanged(string propertyName) { if (this.PropertyChanged != null) { this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); } } } Which can then be used from XAML as you would a normal brush: Or by using the markup extension syntax: The downside to this approach is that you cannot use DynamicResource or StaticResource references to bind the values to other resources in your application. MarkupExtension is not a DependencyObject, and resource binding only works on DependencyObjects; the built-in Brushes are DependencyObjects, which is why binding works with traditional brushes.
