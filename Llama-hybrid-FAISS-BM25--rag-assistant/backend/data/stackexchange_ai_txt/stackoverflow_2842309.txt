[site]: stackoverflow
[post_id]: 2842309
[parent_id]: 2842264
[tags]: 
I think that all the BeginXyz operations that implement the standard asynchronous programming model run the callback on a thread pool thread, which makes the application automatically multi-threaded. However, you can achieve single-threaded asynchronous programming model by synchronizing all the operations through the single GUI thread that is maintained for windows applications using Control.Invoke or more generally, SynchronizationContext . Each call to BeginXyz would have to be rewritten along these lines: // Start asynchronous operation here (1) var originalContext = SynchronizationContext.Current; obj.BeginFoo(ar => // Switch to the original thread originalContext.Post(ignored => { var res = obj.EndFoo(); // Continue here (2) })); The code marked as (2) will continue running on the same thread as the code in (1), so you'll use the thread-pool thread only for forwarding the postback back to the original (single) thread. As a side-note, this is more directly supported by asynchronous workflows in F# and it can be used for quite elegant style of GUI programming as described here . I don't know node.js , but I suppose that you may be also amazed by F# asynchronous workflows as they are really cool for asynchronous/event based/... style of programming :-)
