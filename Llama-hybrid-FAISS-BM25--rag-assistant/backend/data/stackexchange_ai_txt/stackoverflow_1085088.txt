[site]: stackoverflow
[post_id]: 1085088
[parent_id]: 1085070
[tags]: 
Great question. This is my quick attempt at an implementation (I did not try to optimise the code). I took the liberty of adding the profile method to the Module class. In this way it will be available in every class and module definition. It would be even better to extract it into a module and mix it into the class Module whenever you need it. I also didn't know if the point was to make the profile method behave like Ruby's public / protected / private keywords, but I implemented it like that anyway. All methods defined after calling profile are profiled, until noprofile is called. class Module def profile require "benchmark" @profiled_methods ||= [] class You can now use it as follows: class Foo def self.method_added(method) # This still works. puts "Method '#{method}' has been added to '#{self}'." end profile def foo(arg1, arg2, arg3 = nil) puts "> body of foo" sleep 1 end def bar(arg) puts "> body of bar" end noprofile def baz(arg) puts "> body of baz" end end Call the methods as you would normally: foo = Foo.new foo.foo(1, 2, 3) foo.bar(2) foo.baz(3) And get benchmarked output (and the result of the original method_added callback just to show that it still works): Method 'foo' has been added to 'Foo'. Method 'bar' has been added to 'Foo'. Method 'baz' has been added to 'Foo'. Foo#foo was called with params 1, 2, 3 > body of foo Foo#foo finished in 1.00018s Foo#bar was called with params 2 > body of bar Foo#bar finished in 0.00016s > body of baz One thing to note is that it is impossible to dynamically get the name of the arguments with Ruby meta-programming. You'd have to parse the original Ruby file, which is certainly possible but a little more complex. See the parse_tree and ruby_parser gems for details. A fun improvement would be to be able to define this kind of behaviour with a class method in the Module class. It would be cool to be able to do something like: class Module method_wrapper :profile do |*arguments| # Do something before calling method. yield *arguments # Call original method. # Do something afterwards. end end I'll leave this meta-meta-programming exercise for another time. :-)
