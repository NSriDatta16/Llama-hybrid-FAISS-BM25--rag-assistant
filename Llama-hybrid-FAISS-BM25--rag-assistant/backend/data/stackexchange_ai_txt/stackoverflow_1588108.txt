[site]: stackoverflow
[post_id]: 1588108
[parent_id]: 1584316
[tags]: 
Apart from the solutions by WesleyJohnson and Gannon, you can also use a task based approach. WesleyJohnson's and Gannon's solution has less complexity which is a good thing especially when the behaviour of your game's actors are statically defined. Like with a simple shooter game. But when you want the behaviour to be defined dynamically through scripting or when your actors have complex behaviours you may want to externalise behavioural management. Because else your actors' update functions have to have a complex state management. A common approach would be to have a base class called Task (or Process or Job) And specific longer running tasks subclass Job. For instance you can have a MoveActorTask, PlayAnimationTask etc. With result codes and marks whether they are finished, you can also chain Tasks in a way that they are executed one at a time waiting for the former to be finished by using composite tasks Here is what we use, slightly edited for better reading and stripped from some advanced options that may confuse else: class Task { public: /** * Constructor. * * @param isDiscardable Set this true, if the Task's goal can be reached in a single step. * For instance if a Task is supposed to slowly close a window by fading * its alpha to 0, then it is discardable, and Task#discard will just finish * the process by closing the window. * * @param destroyWhenDone Set this to true, when the TaskScheduler shall delete the * Task, after execution is finished. This should usually be the case, but * sometimes it is sensible to pool a number of Jobs for reuse. */ Task(bool isDiscardable, bool destroyWhenDone); virtual ~Task(); /** * This is the function in which the Task is supposed to do whatever it is supposed to do. * This function is called by the TaskScheduler at most once per frame. The frequency depends * on the Job's priority given with TaskScheduler#addTask. * @param time the time source time, since the last call of this function. * @return true, when the Task is done, false else. If false is returned, the Task will be * rescheduled for another execution. */ virtual bool execute(Time time) = 0; virtual TimeSource::TimeSourceType getTimeSource() const = 0; /// Returns whether the Task can be removed from the queue by the scheduler, bool isDiscardable() const; /// Returns true, if the Task shall be deleted, if the Job is finished. Returns false else. bool destroyWhenDone() const; /// Finish whatever the Task is doing. It won't get a chance to continue. /// Overloaded functions must *not* call this implementation. virtual void discard(); protected: bool mIsDiscardable; bool mDestroyWhenDone; }; The Tasks are managed by a TaskScheduler. Each frame the TaskScheduler calls the task's execute function for all tasks ( Round robin ) or you can have a different scheduling strategy.
