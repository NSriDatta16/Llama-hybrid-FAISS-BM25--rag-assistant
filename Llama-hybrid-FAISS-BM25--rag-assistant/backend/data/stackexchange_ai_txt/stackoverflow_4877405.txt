[site]: stackoverflow
[post_id]: 4877405
[parent_id]: 
[tags]: 
Dependency injection: templates (/generics) or virtual functions?

This is a question of curiosity about accepted coding practices. I'm (primarily) a Java developer, and have been increasingly making efforts to unit test my code. I've spent some time looking at how to write the most testable code, paying particular attention to Google's How to write untestable code guide (well worth a look, if you haven't seen it). Naturally, I was arguing recently with a more C++-oriented friend about the advantages of each language's inheritance model, and I thought I'd pull out a trump card by saying how much harder C++ programmers made it to test their code by constantly forgetting the virtual keyword (for C++ers - this is the default in Java; you get rid of it using final ). I posted a code example that I thought would demonstrate the advantages of Java's model quite well (the full thing is over on GitHub ). The short version: class MyClassForTesting { private final Database mDatabase; private final Api mApi; void myFunctionForTesting() { for (User u : mDatabase.getUsers()) { mRemoteApi.updateUserData(u); } } MyClassForTesting ( Database usersDatabase, Api remoteApi) { mDatabase = userDatabase; mRemoteApi = remoteApi; } } Regardless of the quality of what I've written here, the idea is that the class needs to make some (potentially quite expensive) calls to a database, and some API (maybe on a remote web server). myFunctionForTesting() doesn't have a return type, so how do you unit test this? In Java, I think the answer isn't too difficult - we mock: /*** Tests ***/ /* * This will record some stuff and we'll check it later to see that * the things we expect really happened. */ ActionRecorder ar = new ActionRecorder(); /** Mock up some classes **/ Database mockedDatabase = new Database(ar) { @Override public Set getUsers() { ar.recordAction("got list of users"); /* Excuse my abuse of notation */ return new Set ( {new User("Jim"), new User("Kyle")} ); } Database(ActionRecorder ar) { this.ar = ar; } } Api mockApi = new Api() { @Override public void updateUserData(User u) { ar.recordAction("Updated user data for " + u.name()); } Api(ActionRecorder ar) { this.ar = ar; } } /** Carry out the tests with the mocked up classes **/ MyClassForTesting testObj = new MyClassForTesting(mockDatabase, mockApi); testObj.myFunctionForTesting(); // Check that it really fetches users from the database assert ar.contains("got list of users"); // Check that it is checking the users we passed it assert ar.contains("Updated user data for Jim"); assert ar.contains("Updated user data for Kyle"); By mocking up these classes, we inject the dependencies with our own light-weight versions that we can make assertions on for unit testing, and avoid making expensive, time-consuming calls to database/api-land. The designers of Database and Api don't have to be too aware that this is what we're going to do, and the designer of MyClassForTesting certainly doesn't have to know! This seems (to me) like a pretty good way to do things. My C++ friend, however, retorted that this was a dreadful hack, and there's a good reason C++ won't let you do this! He then presented a solution based on Generics, which does much the same thing. For brevity's sake, I'll just list a part of the solution he gave, but again you can find the whole thing over on Github . template class MyClassForTesting { private: A mApi; D mDatabase; public MyClassForTesting(D database, A api) { mApi = api; mDatabase = database; } ... }; Which would then be tested much like before, but with the important bits that get replaced shown below: class MockDatabase : Database { ... } class MockApi : Api { ... } MyClassForTesting testingObj(MockApi(ar), MockDatabase(ar)); So my question is this: What's the preferred method? I always thought the polymorphism-based approach was better - and I see no reason it wouldn't be in Java - but is it normally considered better to use Generics than Virtualise everything in C++? What do you do in your code (assuming you do unit test) ?
