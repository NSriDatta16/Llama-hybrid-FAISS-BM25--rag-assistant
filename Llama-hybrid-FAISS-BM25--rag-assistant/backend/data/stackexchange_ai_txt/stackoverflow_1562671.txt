[site]: stackoverflow
[post_id]: 1562671
[parent_id]: 1562590
[tags]: 
I'd argue that this kind of logic is better isolated in the controller. Consider making a lightweight class to represent your menu items, like this: public class MenuLinkItem { public string Text { get; set; } public bool Highlight { get; set; } } Then in your controller method, build a list of these, set the CSS class on the highlighted element, and pass the result to the view via the ViewData: public class MyController : Controller { private MenuLinkItem MakeMenuLinkItem(string text, string urlFragment) { return (new MenuLinkItem() { Text = text, Highlight = (this.Context.Request.RawUrl.Contains(urlFragment)) } } private IList GetMenuLinkItems() { var items = new List (); items.Add(MakeMenuLinkItem("Something 1", something1var)); items.Add(MakeMenuLinkItem("Something 2", something2var)); items.Add(MakeMenuLinkItem("Something 3", something3var)); items.Add(MakeMenuLinkItem("Something 4", something4var)); items.Add(MakeMenuLinkItem("Something 5", something5var)); return(items); } public ActionResult Index() { ViewData["menuLinkItems"] = GetMenuLinkItems(); /* other controller logic here */ return(View()); } } Then, in your actual view code, you render your menu like this: )ViewData["menuLinkItems"])) { %> > The controller's making the decisions about which links are highlighted, and the view is converting those decisions into an HTML/CSS representation that makes sense to your users.
