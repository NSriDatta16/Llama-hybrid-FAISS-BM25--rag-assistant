[site]: stackoverflow
[post_id]: 991640
[parent_id]: 
[tags]: 
Where can I find, or how can I create an elegant C++ member function template wrapper mechanism without resporting to boost?

I want to be able to templatize a class on a member function without needing to repeat the arguments of the member function -- i e, derive them automatically. I know how to do this if I name the class based on how many arguments the function takes, but I want to derive that as well. Something like this, although this doesn't work (at least in MSVC 2008 sp1, which is my target compiler): class Foo { void func0(); int func2(char *, float); }; template class Wrapper; // specialize for zero-argument void func template class Wrapper : public Base { ... specialization goes here ... }; // specialize for two-argument value func template class Wrapper : public Base { ... specialization goes here ... }; Through "Base" I can then treat these polymorphically. In the end, I want to use this to create a simple wrapper syntax for a scripting language: WrapClass wrap( MemberFunction ("func0") + MemberFunction ("func2") ); However, that doesn't work: the specialization syntax is wrong, because you can't match a function pointer to a typename argument.
