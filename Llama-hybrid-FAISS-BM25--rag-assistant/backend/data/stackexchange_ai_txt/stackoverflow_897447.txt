[site]: stackoverflow
[post_id]: 897447
[parent_id]: 876976
[tags]: 
Ok I'm going to post this as an answer because it is doing mostly what I wanted. However I would like some feedback and also possibly the answer to my one caveat of the solution so far: I've created an interface called IPagedList. public interface IPagedList : IList , ICollection { IList GetPagedList(int pageNo, int pageSize); } Then created a base class which it inherits from IPagedList: public class PagedList : IPagedList { private List _collection = new List (); public IList GetPagedList(int pageNo, int pageSize) { return _collection.Take(pageSize).Skip((pageNo - 1) * pageSize).ToList(); } public int IndexOf(T item) { return _collection.IndexOf(item); } public void Insert(int index, T item) { _collection.Insert(index, item); } public void RemoveAt(int index) { _collection.RemoveAt(index); } public T this[int index] { get { return _collection[index]; } set { _collection[index] = value; } } public void Add(T item) { _collection.Add(item); } public void Clear() { _collection.Clear(); } public bool Contains(T item) { return _collection.Contains(item); } public void CopyTo(T[] array, int arrayIndex) { _collection.CopyTo(array, arrayIndex); } int Count { get { return _collection.Count; } } public bool IsReadOnly { get { return false; } } public bool Remove(T item) { return _collection.Remove(item); } public IEnumerator GetEnumerator() { return _collection.GetEnumerator(); } int ICollection .Count { get { return _collection.Count; } } IEnumerator IEnumerable.GetEnumerator() { return _collection.GetEnumerator(); } public void CopyTo(Array array, int index) { T[] arr = new T[array.Length]; for (int i = 0; i I then create an IUserCollectionType for NHibernate to use as the custom collection type and NHPagedList which inherits from PersistentGenericBag, IPagedList as the actual collection itself. I created two seperate classes for them because it seemed like the use of IUserCollectionType had no impact on the actual collection to be used at all, so I kept the two pieces of logic seperate. Code below for both of the above: public class PagedListFactory : IUserCollectionType { public PagedListFactory() { } #region IUserCollectionType Members public bool Contains(object collection, object entity) { return ((IList )collection).Contains((T)entity); } public IEnumerable GetElements(object collection) { return (IEnumerable)collection; } public object IndexOf(object collection, object entity) { return ((IList )collection).IndexOf((T)entity); } public object Instantiate(int anticipatedSize) { return new PagedList (); } public IPersistentCollection Instantiate(ISessionImplementor session, ICollectionPersister persister) { return new NHPagedList (session); } public object ReplaceElements(object original, object target, ICollectionPersister persister, object owner, IDictionary copyCache, ISessionImplementor session) { IList result = (IList )target; result.Clear(); foreach (object item in ((IEnumerable)original)) { result.Add((T)item); } return result; } public IPersistentCollection Wrap(ISessionImplementor session, object collection) { return new NHPagedList (session, (IList )collection); } #endregion } NHPagedList next: public class NHPagedList : PersistentGenericBag , IPagedList { public NHPagedList(ISessionImplementor session) : base(session) { _sessionImplementor = session; } public NHPagedList(ISessionImplementor session, IList collection) : base(session, collection) { _sessionImplementor = session; } private ICollectionPersister _collectionPersister = null; public NHPagedList CollectionPersister(ICollectionPersister collectionPersister) { _collectionPersister = collectionPersister; return this; } protected ISessionImplementor _sessionImplementor = null; public virtual IList GetPagedList(int pageNo, int pageSize) { if (!this.WasInitialized) { IQuery pagedList = _sessionImplementor .GetSession() .CreateFilter(this, "") .SetMaxResults(pageSize) .SetFirstResult((pageNo - 1) * pageSize); return pagedList.List (); } return this .Skip((pageNo - 1) * pageSize) .Take(pageSize) .ToList (); } public new int Count { get { if (!this.WasInitialized) { return Convert.ToInt32(_sessionImplementor.GetSession().CreateFilter(this, "select count(*)").List()[0].ToString()); } return base.Count; } } } You will notice that it will check to see if the collection has been initialized or not so that we know when to check the database for a paged list or when to just use the current in memory objects. Now you're ready to go, simply change your current IList references on your models to be IPagedList and then map NHibernate to the new custom collection, using fluent NHibernate is the below, and you are ready to go. .CollectionType >() This is the first itteration of this code so it will need some refactoring and modifications to get it perfect. My only problem at the moment is that it won't get the paged items in the order that the mapping file suggests for the parent to child relationship. I have added an order-by attribute to the map and it just won't pay attention to it. Where as any other where clauses are in each query no problem. Does anyone have any idea why this might be happening and if there is anyway around it? I will be disappointed if I can't work away around this.
