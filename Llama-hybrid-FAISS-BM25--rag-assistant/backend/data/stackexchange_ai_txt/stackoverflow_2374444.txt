[site]: stackoverflow
[post_id]: 2374444
[parent_id]: 2374341
[tags]: 
I assume append will properly handle the initial head/tail details, yes? If so, what you have now is great and simple: Go through the other list, and take its item and add a copy to my list. Perfect. Well, almost. Use an initializer list to initialize member variables: template LinkedList ::LinkedList(const LinkedList& l) : m_head(0), m_tail(0), m_size(0) { // ... } Also, maybe a matter of style, this woks instead of a while loop: // construct list from given list for (Node *n = l.m_head; n != 0; n = n->next) append(m->data); In fact, I'd recommend this instead. When you have iterators, you'd do something like: for (const_iterator iter = l.begin(); iter != l.end(); ++iter) append(*iter); It just follows the style of a for-loop better. (Initialize something, check something, do something). Though for iterators, it'll probably be different. (More later) Or should I access the data through the corresponding accessor? (I know that I don't have the accessor(s) defined). Also, I intend to create a custom iterator so that it can be possible to iterate over the LinkedList. Should I use in the copy constructor to access the data on each node? Those iterators are your accessors. You don't want to expose your internal head-tail pointers, that a recipe for disaster. The purpose of the class is to not expose the details. That said, iterators are the abstract wrapper around those details. Once you have your iterators, then you could use them to iterate through the list instead of pointer arithmetic. This ties in to this recently asked question . In general, you should use your abstractions to deal with your data. So yes once you have your iterators in place, you should use those to iterate across the data. Most classes that provide iterators also provide a way to insert data given a beginning and ending iterator. This is usually called insert , like this: insert(iterBegin, iterEnd) . This loops through the iterators, appending it's data to the list. If you had such functionality, your copy-constructor would simply be: insert(l.begin(), l.end()); // insert the other list's entire range Where insert is implemented like the for-loop we had above. Another question (completely off-topic, I know), when and/or why should we declare a pointer to a LinkedList LinkedList *l = new LinkedList(); instead of LinkedList l; The first is dynamic allocation, the second is automatic (stack) allocation. You should prefer stack allocation. It's almost always faster, and safer too (since you don't need to delete anything). In fact, a concept called RAII relies on automatic storage, so destructors are guaranteed to run. Only use dynamic allocation when you have to.
