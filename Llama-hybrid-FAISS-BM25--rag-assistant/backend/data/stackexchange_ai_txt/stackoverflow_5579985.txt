[site]: stackoverflow
[post_id]: 5579985
[parent_id]: 5579890
[tags]: 
You already cite the "implement business logic" use case. EJBs - in EJB 3.x Session Beans, Message Driven Beans and in 3.1 the new Singleton Beans indeed allow you implement the biz logic. Session Beans often server as Facade where clients connect to. Those clients can be Servlets to serve content via e.g. HTTP or also "fat" clients that talk over other (more binary) protocols to the EJBs. Message Driven Beans serve as endpoint of asynchronous communications and can themselves call methods on Session Beans as an example. All the EJBs have one thing in common, which makes them very attractive: they are managed by a container. So the container takes care of instantiation, pooling, Transactions, Security etc. If you write in an EJB @Resource DataSource x; The container makes sure that when your bean is ready to receive method calls, the variable 'x' contains a suitable data source. The pooling of Beans allows you to have many more clients connecting to a site than you could do without, as either the instances are shared (Stateless SB) or instances can be swapped out by the container to 2ndary storage if memory is tight and to re-activate them later. In EJB 3, the old EntityBeans from EJB 1.x and 2.x are gone and replaced by JPA, which builds the domain data model of POJOs, which may either be annotated to provide the relational semantics or the semantics may be provided by external XML files. With JPA (which does not require EJBs at all), the EJBs often serve to implement the handling of those entities: @Stateless public class MyBean { @PersistenceContext EntityManager em; public Foo getFoo(String name) { Query q = em.createQuery("SELECT f FROM Foo f WHERE f.name = :name"); q.setParameter("name",name); return q.getSingleValue(); } }
