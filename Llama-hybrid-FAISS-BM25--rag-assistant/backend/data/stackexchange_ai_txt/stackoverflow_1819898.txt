[site]: stackoverflow
[post_id]: 1819898
[parent_id]: 1819345
[tags]: 
First of all: Don't use the Hashtable! It's old, and very slow. Additional: Synchronisation on the lower level isn't needed if you synchronize on a higher level already (This is true for the AtomicInteger-thing, as well). I see different approaches here, according to what use case is needed here. The read/write-approach Assuming you call the isUserRegistered method very often and the other methods only now and then, a good way is a read-write-lock: It is allowed to have multiple reads at the same time, but only one write-lock to rule them all (can only be gained if no other lock is accquired). private static final Map _userSessions = new HashMap (); private ReadWriteLock rwLock = new ReentrantReadWriteLock(false); //true for fair locks public static void registerUser(String userLogin) { Lock write = rwLock.writeLock(); write.lock(); try { Integer sessionCount = _userSessions.get(userLogin); if (sessionCount != null) { sessionCount = Integer.valueOf(sessionCount.inValue()+1); } else { sessionCount = Integer.valueOf(1) } _userSessions.put(userLogin, sessionCount); } finally { write.unlock(); } } public static void unregisterUser(String userLogin) { Lock write = rwLock.writeLock(); write.lock(); try { Integer sessionCount = _userSessions.get(userLogin); if (sessionCount != null) { sessionCount = Integer.valueOf(sessionCount.inValue()-1); } else { sessionCount = Integer.valueOf(0) } _userSessions.put(userLogin, sessionCount); } finally { write.unlock(); } } public static boolean isUserRegistered(String userLogin) { boolean result; Lock read = rwLock.readLock(); read.lock(); try { Integer sessionCount = _userSessions.get(userLogin); if (sessionCount != null) { result = sessionCount.intValue()>0 } else { result = false; } } finally { read.unlock(); } return false; } Pro: simple to understand Con: Won't scale if the write methods are called frequently The small atomic-operation approach The Idea is to do small steps, that are all atomic. This will lead to a very good performance anyway, but there are many hidden traps here. public final ConcurrentMap userSessions = new ConcurrentHashMap (); //There are other concurrent Maps for different use cases public void registerUser(String userLogin) { AtomicInteger count; if (!userSession.containsKey(userLogin)){ AtomicInteger newCount = new AtomicInteger(0); count = userSessions.putIfAbsent(userLogin, newCount); if (count == null){ count=newCount; } //We need ifAbsent here, because another thread could have added it in the meantime } else { count = userSessions.get(userLogin); } count.incrementAndGet(); } public void unregisterUser(String userLogin) { AtomicInteger sessionCount = userSessions.get(userLogin); if (sessionCount != null) { sessionCount.decrementAndGet(); } } public boolean isUserRegistered(String userLogin) { AtomicInteger sessionCount = userSessions.get(userLogin); return sessionCount != null && sessionCount.intValue() > 0; } Pro: scales very well Con: Not intuitive, is going to be complex quickly, not always possible, many hidden traps The lock per user approach This will create locks for different users, assuming that there are a lot of different users. You can create locks or monitors with some small atomic operations and lock on these instead of the full list. It would be overkill for this small example, but for very complex structures it can be an elegant solution.
