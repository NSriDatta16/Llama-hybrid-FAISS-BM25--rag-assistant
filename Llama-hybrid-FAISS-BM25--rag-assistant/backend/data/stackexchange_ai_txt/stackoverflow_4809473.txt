[site]: stackoverflow
[post_id]: 4809473
[parent_id]: 4804425
[tags]: 
See Chris Okasaki's "Techniques for Embedding Postfix Languages in Haskell": http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#hw02 Also, this: {-# LANGUAGE TypeOperators #-} module Stacks where data a :* b = a :* b deriving Show data NilStack = NilStack deriving Show infixr 1 :* class Stack a where stackSize :: a -> Int instance Stack b => Stack (a :* b) where stackSize (_ :* x) = 1 + stackSize x instance Stack NilStack where stackSize _ = 0 push :: Stack b => a -> b -> a :* b push = (:*) pop :: Stack b => a :* b -> (a,b) pop (x :* y) = (x,y) dup :: Stack b => a :* b -> a :* a :* b dup (x :* y) = x :* x :* y liftBiOp :: Stack rest => (a -> b -> c) -> a :* b :* rest -> c :* rest liftBiOp f (x :* y :* rest) = push (f x y) rest add :: (Stack rest, Num a) => a :* a :* rest -> a :* rest add = liftBiOp (+) {- demo: *Stacks> stackSize $ dup (1 :* NilStack) 2 *Stacks> add $ dup (1 :* NilStack) 2 :* NilStack -} Since your stack varies in type, you can't pack it into a regular state monad (although you can pack it into a parameterized monad, but that's a different story) but other than that, this should be straightforward, pleasant, and statically checked.
