[site]: crossvalidated
[post_id]: 161638
[parent_id]: 161573
[tags]: 
I am not sure what exactly the question here is. I think the approach is valid, and I recall recently upvoting your answer in How to identify variables with significant loadings in PCA? , where you essentially suggested this bootstrapping scheme. The confidence intervals seem to be either elliptical or circular or twovariate normal or ??? Perhaps you are asking about the "weird" shape of the bootstrapped clouds that you get. I repeated your analysis on the Fisher Iris dataset: I do PCA on the full data (once on covariance, once on correlation), and then bootstrap it 1000 times (note that one should take care that all bootstrapped principal axes are aligned similarly and not flipped). In each case, I plot the standardized PC1-2 scores of the full data as black dots, full loadings as coloured lines, and 1000 resampled loadings as coloured dots: The clouds on the left look okay, but the clouds on the right look obviously circular, similar to the ones on your plots. This is easy to understand. Recall that the length of the loading vector approximates the variance of the original variable. When I do the analysis on the covariance matrix, the variance can be anything; but when I do the analysis on the correlation matrix I essentially fix the individual variances to $1$. Hence the length of the loading vectors is also approximately $1$, and the jitter happens only along its direction, not the length. Nevertheless, I think the procedure makes sense, and you can perfectly well compute the boostrapped confidence intervals e.g. on the first principal axis. For covariance, I get $$(0.36\pm 0.016, -0.085\pm 0.017, 0.86\pm 0.0045, 0.36\pm 0.0081).$$ Matlab code to produce this figure clear all close all load fisheriris n = size(meas,1); %// n = 150 varNames = {'Sepal length', 'Sepal width', 'Petal length', 'Petal width'}; col = [0 0 1; 1 0 1; 1 0 0; 0 0.6 0]; modes = {'PCA on covaraince', 'PCA on correlation'}; figure('Position', [100 100 1400 500]) %// covariance or correlation matrix for mode = 1:2 %// PCA of the full dataset X = bsxfun(@minus, meas, mean(meas)); %// centering if mode == 2 X = bsxfun(@times, X, 1./std(X)); %// scaling end [U0,S0,V0] = svd(X,0); %// SVD L0 = V0*S0/sqrt(n-1); %// loadings %// boostrapping (1000 repetitions) for rep=1:1000 ind = randi(n, n, 1); %// generating a bootstrapped dataset and SVDing it X = bsxfun(@minus, meas(ind,:), mean(meas(ind,:))); if mode == 2 X = bsxfun(@times, X, 1./std(X)); end [U,S,V] = svd(X,0); %// adjust the signs of components to align them with SVD of the full %// dataset (otherwise signs can flip) for i=1:size(U,2) if sum((V(:,i)-V0(:,i)).^2) > sum((V(:,i)+V0(:,i)).^2) V(:,i) = -V(:,i); U(:,i) = -U(:,i); end end %// saving loadings and principal axes of the first two PCs loadings(rep,:) = [V(:,1)'*S(1,1) V(:,2)'*S(2,2)] / sqrt(n-1); axes(rep,:) = [V(:,1)' V(:,2)']; end %// display principal axes of the full data, mean of the bootstrapped %// axes, standard deviations num2str([V0(:,1) mean(axes(:,1:4))' std(axes(:,1:4))'], 2) subplot(1,2,mode) hold on %// plotting standardized scores scatter(U0(:,1)*sqrt(n-1), U0(:,2)*sqrt(n-1), [], 'k') %// plotting loadings for i=1:4 scatter(loadings(:,i), loadings(:,i+4), [], col(i,:)) plot([0 L0(i,1)], [0 L0(i,2)], 'Color', col(i,:)) pos = L0(i,1:2) + L0(i,1:2)/norm(L0(i,1:2)) * 0.4; text(pos(1), pos(2), varNames{i}, 'Color', col(i,:)); end rectangle('Position', [-1 -1 2 2], 'Curvature', [1 1]) axis([-1 1 -1 1] * 3) axis square title(modes{mode}) xlabel('PC1') ylabel('PC2') end
