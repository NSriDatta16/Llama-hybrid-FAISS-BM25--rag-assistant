[site]: stackoverflow
[post_id]: 1749194
[parent_id]: 1749018
[tags]: 
I/O and non-blocking I/O selection depends from your server activity profile. E.g. if you use long-living connections and thousands of clients I/O may become too expensive because of system resources exhaustion. However, direct I/O that doesn't crowd out CPU cache is faster than non-blocking I/O. There is a good article about that - Writing Java Multithreaded Servers - whats old is new . About context switch cost - it's rather chip operation. Consider the simple test below: package com; import java.util.ArrayList; import java.util.List; import java.util.Random; import java.util.Set; import java.util.concurrent.ConcurrentSkipListSet; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicLong; public class AAA { private static final long DURATION = TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS); private static final int THREADS_NUMBER = 2; private static final ThreadLocal COUNTER = new ThreadLocal () { @Override protected AtomicLong initialValue() { return new AtomicLong(); } }; private static final ThreadLocal DUMMY_DATA = new ThreadLocal () { @Override protected AtomicLong initialValue() { return new AtomicLong(); } }; private static final AtomicLong DUMMY_COUNTER = new AtomicLong(); private static final AtomicLong END_TIME = new AtomicLong(System.nanoTime() + DURATION); private static final List > DUMMY_SOURCE = new ArrayList >(); static { for (int i = 0; i ()); } } private static final Set COUNTERS = new ConcurrentSkipListSet (); public static void main(String[] args) throws Exception { final CountDownLatch startLatch = new CountDownLatch(THREADS_NUMBER); final CountDownLatch endLatch = new CountDownLatch(THREADS_NUMBER); for (int i = 0; i threadLocal : DUMMY_SOURCE) { threadLocal.set(getRandomString()); } } private static CharSequence getRandomString() { StringBuilder result = new StringBuilder(); Random random = new Random(); for (int i = 0; i threadLocal : DUMMY_SOURCE) { for (int i = 0; i I made four tests for two and ten thread scenarios and it shows performance loss is about 2.5% (78626 iterations for two threads and 76754 for ten threads), System resources are used by the threads approximately equally. Also 'java.util.concurrent' authors suppose context switch time to be about 2000-4000 CPU cycles: public class Exchanger { ... private static final int NCPU = Runtime.getRuntime().availableProcessors(); .... /** * The number of times to spin (doing nothing except polling a * memory location) before blocking or giving up while waiting to * be fulfilled. Should be zero on uniprocessors. On * multiprocessors, this value should be large enough so that two * threads exchanging items as fast as possible block only when * one of them is stalled (due to GC or preemption), but not much * longer, to avoid wasting CPU resources. Seen differently, this * value is a little over half the number of cycles of an average * context switch time on most systems. The value here is * approximately the average of those across a range of tested * systems. */ private static final int SPINS = (NCPU == 1) ? 0 : 2000;
