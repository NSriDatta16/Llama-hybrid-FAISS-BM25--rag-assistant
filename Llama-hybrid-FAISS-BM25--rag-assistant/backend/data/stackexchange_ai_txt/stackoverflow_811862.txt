[site]: stackoverflow
[post_id]: 811862
[parent_id]: 784173
[tags]: 
So I did some tests with sqlite for very large files, and came to some conclusions (at least for my specific application). The tests involve a single sqlite file with either a single table, or multiple tables. Each table had about 8 columns, almost all integers, and 4 indices. The idea was to insert enough data until sqlite files were about 50GB. Single Table I tried to insert multiple rows into a sqlite file with just one table. When the file was about 7GB (sorry I can't be specific about row counts) insertions were taking far too long. I had estimated that my test to insert all my data would take 24 hours or so, but it did not complete even after 48 hours. This leads me to conclude that a single, very large sqlite table will have issues with insertions, and probably other operations as well. I guess this is no surprise, as the table gets larger, inserting and updating all the indices take longer. Multiple Tables I then tried splitting the data by time over several tables, one table per day. The data for the original 1 table was split to ~700 tables. This setup had no problems with the insertion, it did not take longer as time progressed, since a new table was created for every day. Vacuum Issues As pointed out by i_like_caffeine, the VACUUM command is a problem the larger the sqlite file is. As more inserts/deletes are done, the fragmentation of the file on disk will get worse, so the goal is to periodically VACUUM to optimize the file and recover file space. However, as pointed out by documentation , a full copy of the database is made to do a vacuum, taking a very long time to complete. So, the smaller the database, the faster this operation will finish. Conclusions For my specific application, I'll probably be splitting out data over several db files, one per day, to get the best of both vacuum performance and insertion/delete speed. This complicates queries, but for me, it's a worthwhile tradeoff to be able to index this much data. An additional advantage is that I can just delete a whole db file to drop a day's worth of data (a common operation for my application). I'd probably have to monitor table size per file as well to see when the speed will become a problem. It's too bad that there doesn't seem to be an incremental vacuum method other than auto vacuum . I can't use it because my goal for vacuum is to defragment the file (file space isn't a big deal), which auto vacuum does not do. In fact, documentation states it may make fragmentation worse, so I have to resort to periodically doing a full vacuum on the file.
