[site]: stackoverflow
[post_id]: 4598613
[parent_id]: 4598046
[tags]: 
Here is what I understand so far: The algorithm is to process a sequence of values {R,B}. It may choose to put the value in the current container or the next, if there is a next. I first would ask a couple of questions to clarify the things I don't know yet: Is k and n known to the algorithm in advance? I assume so. Do we know the full sequence of buttons in advance? If we don't know the sequence in advance, should the average value minimized? Or the maximum (the worst case)? Idea for a proof for the algortihm by Mark Peters Edit: Idea for a proof (sorry, couldn't fit it in a comment) Let L(i) be the length of the ith group. Let d(i) be the diff you get by collapsing container i and i+1 => d(i) = L(i)*L(i+1). We can define a distribution by the sequence of containers collapsed. As index we use the maximum index of the original containers contained in the collapsed container containing the containers with the smaller indexes. A given sequence of collapses I = [i(1), .. i(m)] results in a value which has a lower bound equal to the sum of d(i(m)) for all m from 1 to n-k. We need to proof that there can't be a sequence other then the one created by the algorithm with a smaller diff. So let the sequence above be the one resulting from the algorithm. Let J = [j(1), .. j(m)]. Here it gets skimpy: I think it should be possible to proof that the lower limit of J is larger then the actual value of I because in each step we choose by construction the collapse operation from I so it must be smaller then the matching collapse from the alternate sequence I think we might assume that the sequences are disjunct, but I'm not completely sure about it.
