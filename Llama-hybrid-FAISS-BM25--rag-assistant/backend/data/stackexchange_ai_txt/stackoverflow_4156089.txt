[site]: stackoverflow
[post_id]: 4156089
[parent_id]: 4156059
[tags]: 
Use the Minimax algorithm , potentially with alpha-beta pruning if you need to cut down on the running time. Essentially, you exhaustively search the tree of possible moves and then work back upwards to decide on the best result. Edit : Here's some code to show you how easy it is to make a perfect agent. It took about 5 minutes to code up. public class MinimaxNim { public static int getBestMove(int matchesLeft, int lastVal) { int max = Integer.MIN_VALUE; int bestMove = matchesLeft > 0 ? 1 : 0; for ( int move = 1; move max ) { bestMove = move; max = val; } } return bestMove; } private static int maxValue(int matchesLeft, int lastVal) { if ( matchesLeft == 0 ) return -1; //min has won int max = Integer.MIN_VALUE; for ( int toTake = 1; toTake max ) { max = val; } } return max; } private static int minValue(int matchesLeft, int lastVal) { if ( matchesLeft == 0 ) return 1; //max has won int min = Integer.MAX_VALUE; for ( int toTake = 1; toTake You could test with this: public static void main(String[] args) { int count = 21; int move = -1; for ( ;; ) { move = getBestMove(count, move); System.out.println("Player 1 takes " + move); count -= move; if ( count == 0 ) { System.out.println("Player 1 has won"); break; } move = getBestMove(count, move); System.out.println("Player 2 takes " + move); count -= move; if ( count == 0 ) { System.out.println("Player 2 has won"); break; } } } But I would suggest replacing either player 1 or player 2 with yourself, or a random agent, so that you examine the moves that a perfect player makes. Again, this doesn't show you the best strategy , but it will exhibit optimal play against any opponent (though untested). Edit 2 In case you're curious, from the initial state there are only 26705 terminal states (where a player has won) that need to be examined. That gets less and less as you make more moves. What makes this perfect for minimax is that progress is always made...once you're at 15 matches left in the pile, you can't go back to 17, e.g. In a game like chess you can get cycles in the search tree since players can just dance around the board, returning to previous states, etc.
