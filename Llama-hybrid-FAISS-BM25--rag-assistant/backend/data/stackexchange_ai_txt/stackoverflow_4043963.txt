[site]: stackoverflow
[post_id]: 4043963
[parent_id]: 4043930
[tags]: 
found this useful post elsewhere: Namespaces separate and organize functionality. You can have a xander333::sort() function and it won't conflict with std::sort() or boost::sort() or any other sort(). Without namespaces there can be only one sort() . Now let's say you've put "using namespace std;" in all your source files and you've implemented a simple templated function called fill() in the global namespace of one of your files. This file also depends on a header from libFoo -- foo.hpp . Version 2.1 of libFoo comes out and all of a sudden your program no longer compiles. You version of fill() suddenly conflicts with another fill() ! What happened? It turns out that the folks implementing libFoo included in the new version of foo.hpp when they didn't before. Now you have all of the standard algorithms being included in your source file, and your using namespace std; has pulled them all into the global namespace. std::fill() now directly conflicts with your fill() . More insidious, you've gotten your code to compile by renaming your fill() to xander333_fill() , but something's not working right -- your report numbers are off. It turns out that your custom divides() function, which does fixed precision math, is no longer being called because the templated function from (also newly included by foo.hpp ) makes for a better match because you're calling types did not exactly match the declared types. Thread with relevant discussion is here: http://www.cplusplus.com/forum/unices/27805/
