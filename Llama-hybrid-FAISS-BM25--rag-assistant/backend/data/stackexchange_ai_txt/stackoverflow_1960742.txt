[site]: stackoverflow
[post_id]: 1960742
[parent_id]: 1945062
[tags]: 
One of the options is EAV model (Entity-Attribute-Value). This model is good to apply if you have a single class in your domain, which table representation would result in a wide table (large number of columns, many null values) It's originally designed for medical domain, where objects may have thousands of columns (sympthoms). Basically you have Entity (Id) (for example your Product table) Attribute(Id, ColumnName) Value(EntityId, AttributeId, value) You can have some additional metadata tables. Value should better be multiple tables, one for a type. For example: ShortStringValue(EntityId, AttributeId, Value nvarchar(50)); LongStringValue(EntityId, AttributeId, Value nvarchar(2048)); MemoValue(EntityId, AttributeId, Value nvarchar(max)); IntValue(EntityId, AttributeId, Value int); or even a comple type: ColorComponentsValue(EntityId, AttributeId, R int, G int, B int ); One of the things from my experience is that you should not have EAV for everything. Just have EAV for a single class, Product for example. If you have to use extensibility for different base classes, let it be a separate set of EAV tables. Onother thing is that you have to invent a smart materialization strategy for your objects. Do not pivot these values to a wide row set, pivot just a small number of collumns for your query criteria needs, then return a narrow collection of Value rows for each of the selected objects. Otherwise pivoting would involve massive join. There are some points to consider: . Each value takes storage space for foreign keys . For example row-level locking will behave different for such queries, which may result in performance degradation. . May result in larger index sizes. Actually in a shallow hellow world test my EAV solution outperformed it's static counterpart on a 20 column table in a query with 4 columns involved in criteria.
