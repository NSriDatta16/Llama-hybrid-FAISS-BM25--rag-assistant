[site]: stackoverflow
[post_id]: 5412920
[parent_id]: 5409750
[tags]: 
What you're asking for is called a "proof of work". Here's a really simple one: The server generates a random nonce, n , and picks a number of bits, b , and sends both to the client. The client calculates h = sha1(n + x) , where x is an arbitrary suffix, and h ends with b '0' bits. The client sends x back to the server as a proof-of-work. This works because predicting the output of a secure hash function is difficult, so your only option is brute force. If the server asks for one with b trailing 0s, one average one in 2^b hashes will meet that criteria, meaning they will have to do on average O(2^(b-1)) work. One caveat to this approach: If you're dealing with a web client, you need to make the proof of work easy enough that it's doable quickly in Javascript. But javascript is slow compared to native code, and your attacker will be able to write native code to compute the proof of work much faster - so he has a substantial advantage over your legitimate clients. The standard alternative, as unpleasant as it is, is to require a CAPTCHA.
