[site]: stackoverflow
[post_id]: 2837587
[parent_id]: 2835959
[tags]: 
Treat the vector as a list of booleans, with one boolean for each number 0 to m. When you view it that way, it becomes obvious that each value is set to 0 to initialize it to false, and then set to 1 later to set it to true. The last for loop is testing all the booleans. If any of them are 0 (indicating false), then the function returns false. If all are true, then the function returns true. Explaining the if statement you asked about would require explaining what a primitive root mod n is, which is the whole point of the function. I think if your goal is to understand this program, you should first understand what it implements. If you read Wikipedia's article on it, you'll see this in the first paragraph: In modular arithmetic, a branch of number theory, a primitive root modulo n is any number g with the property that any number coprime to n is congruent to a power of g (mod n). That is, if g is a primitive root (mod n), then for every integer a that has gcd(a, n) = 1, there is an integer k such that gk â‰¡ a (mod n). k is called the index of a. That is, g is a generator of the multiplicative group of integers modulo n. The function modPow implements modular exponentiation . Once you understand how to find a primitive root mod n, you'll understand it. Perhaps the final piece of the puzzle for you is to know that two numbers are coprime if their greatest common divisor is 1. And so you see these checks in the algorithm you pasted. Bonus link: This paper has some nice background, including how to test for primitive roots near the end.
