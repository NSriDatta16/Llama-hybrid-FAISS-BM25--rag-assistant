[site]: stackoverflow
[post_id]: 2564156
[parent_id]: 2564090
[tags]: 
You should take into account that Java's HashTable uses a closed addressing (no probing) implementation, so you have separate buckets in which many items can be placed. This is not what you are looking for in your benchmarks. I'm not sure about HashMap implementation but I think it uses open addressing too. So forget about JDK classes.. since you want to calculate empirical values you should write your own version of an hashtable that uses the open addressing implementation with linear probing but you should take care of counting the probe length whenever you try to get a value from the hashmap.. For example you can write your hashmap and then take care of having class YourHashMap { int empiricalGet(K key) { // search for the key but store the probe length of this get operation return probeLength; } } Then you can easily benchmark it by searching how many keys you want and calculating the average probe length. Otherwise you can just provide the hasmap the ability of storing the total probe length and the count of gets requested and retrieve them after the benchmark run to calculate average value. This kind of exercises must prove that the empirical value concordates with the theoretical one. So take also into account the fact that you may need many benchmarks, and then do the average of them all, assuring that variance is not too high.
