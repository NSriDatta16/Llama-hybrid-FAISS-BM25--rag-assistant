[site]: crossvalidated
[post_id]: 223249
[parent_id]: 223196
[tags]: 
A fast and efficient method to generate $m$ independent uniform digits in base $r$ using a $d$-sided die is to label the faces of the die with the digits $0$ through $d-1$ and roll the die repeatedly (say $n$ times) to generate a string of such digits $$a_1\,a_2\,a_3\,\cdots\,a_n.$$ Interpret this sequence as the interval of all numbers $$[X,Y)$$ for which $$X = [0. a_1a_2a_3\cdots a_n]_d = \sum_{i=1}^n a_i d^{-i}$$ and $Y = X + d^{-n}$ is the next largest $n$-digit number in base $d$. There are $d^n$ such intervals, each of equal probability, partitioning the unit interval $[0,1)$. Thus, any method of selecting a number $U\in[X,Y)$ will approximate a continuous uniform distribution up to an error of no greater than $d^{-n}$. We may therefore use $U$ in the usual way to generate a random sequence of nearly independent uniform random base-$r$ digits: namely, expand $U$ in base $r$ $$U = [0. b_1b_2b_3\cdots]_r = \sum_{i=1}^\infty b_i r^{-i}$$ and read off the first $k$ digits $b_1, b_2, \ldots, b_k$. Stop when $r^{-k}$ becomes appreciable in size compared to $d^{-n}$. We don't actually need to construct $X, Y,$ or $U$ explicitly. Let $X_i$ be the partial sum of $X$ out to $i$ base-$d$ digits. The initial output $b_1$ will be determined once the interval $[X_i,X_i+d^{-i-1})$ is found to lie between $b_1$ and $b_1 + r^{-1}$. At this point, output $b_1$ and replace $X_i$ by $rX_i - b_1$ (which strips the first base-$r$ digit off $X$). Repeating this procedure $m$ times simultaneously expands $U$ in base $d$ and converts it to base $r$ until $m$ base-$r$ digits are reliably produced. The number of random base-$d$ digits used to generate $m$ base-$r$ digits will, with extremely high probability, be extremely close to $m\log(r)/\log(d)$. In the case $d=6$ and $r=10$ it amounts to $1.28509\ldots$ rolls of the die for each decimal digit of output on average. That's the best that can be done. This procedure is related to a method to flip one (biased) coin to emulate another coin with a different bias: see https://stats.stackexchange.com/a/209229/919 . Note that the case $d=2$ corresponds to how binary digital computers already generate uniform random variates $U$. This algorithm merely describes how we could go about generating base-$r$ digits on a computer that operates natively in base $d$ (and therefore will have a pseudorandom number generator that produces $X$ directly). Here is working R code. It is unvectorized and therefore relatively slow--but it's not too bad: it takes around $9$ seconds per million output digits. It ends by displaying the histogram of the output and performing a chi-squared test of uniformity of the distribution. m
