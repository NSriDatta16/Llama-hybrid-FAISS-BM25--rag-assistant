[site]: stackoverflow
[post_id]: 4554966
[parent_id]: 
[tags]: 
Is DTO plus UnitOfWork pattern a good approach to design a DAL for a web application?

I'm implementing a DAL using entity framework. On our application, we have three layers (DAL, business layer and presentation). This is a web app. When we began implementing the DAL, our team thought that DAL should have classes whose methods receive a ObjectContext given by services on the business layer and operate over it. The rationale behind this decision is that different ObjectContexts see diferent DB states, so some operations can be rejected due to problems with foreign keys match and other inconsistencies. We noticed that generating and propagating an object context from the services layer generates high coupling between layers. Therefore we decided to use DTOs mapped by Automapper (not unmanaged entities or self-tracking entities arguing high coupling, exposing entities to upper layers and low efficiency) and UnitOfWork. So, here are my questions: Is this the correct approach to design a web application's DAL? Why? If you answered "yes" to 1., how is this to be reconciled the concept of DTO with the UnitOfWork patterns? If you answered "no" to 1., which could be a correct approach to design a DAL for a Web application? Please, if possible give bibliography supporting your answer. About the current design: The application has been planned to be developed on three layers: Presentation, business and DAL. Business layer has both facades and services There is an interface called ITransaction (with only two methods to dispose and save changes) only visible at services. To manage a transaction, there is a class Transaction extending a ObjectContext and ITransaction. We've designed this having in mind that at business layer we do not want other ObjectContext methods to be accessible. On the DAL, we created an abstract repository using two generic types (one for the entity and the other for its associated DTO). This repository has CRUD methods implemented in a generic way and two generic methods to map the DTOs and entities of the generic repository with AutoMapper. The abstract repository constructor takes an ITransaction as argument and it expects the ITransaction to be an ObjectContext in order to assign it to its proctected ObjectContext property. The concrete repositories should only receive and return .net types and DTOs. We now are facing this problem: the generic method to create does not generate a temporal or a persistent id for the attached entities (until we use SaveChanges() , therefore breaking the transactionality we want); this implies that service methods cannot use it to associate DTOs in the BL)
