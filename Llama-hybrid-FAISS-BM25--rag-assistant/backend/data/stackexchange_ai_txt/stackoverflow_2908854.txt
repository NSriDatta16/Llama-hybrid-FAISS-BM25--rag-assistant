[site]: stackoverflow
[post_id]: 2908854
[parent_id]: 
[tags]: 
Opengl problem with texture in model from obj

I writing small program in OpenGL, and I have problem ( textures are skew, and I dont know why, this model work in another obj viewer) What I have: http://img696.imageshack.us/i/obrazo.png/ What I want http://img88.imageshack.us/i/obraz2d.jpg/ Code of project (I use devil for images): #pragma once #include #define GLUT_DISABLE_ATEXIT_HACK #include #include #include #include #include #include #include #include #include #include #include #include #include class TextureManager { struct TextureInfo{ std::string name; GLuint image; }; private: std::vector textures; public: TextureManager(void); ~TextureManager(void); bool AddTexture(std::string name, std::string fileName); int GetTexture(std::string name); }; TextureManager::TextureManager(void) { ilInit(); } TextureManager::~TextureManager(void) { } bool TextureManager::AddTexture(std::string name, std::string fileName) { bool success; ILuint texId; GLuint image; ilGenImages(1, &texId); ilBindImage(texId); success = ilLoadImage((WCHAR*)fileName.c_str()); if(success) { success = ilConvertImage(IL_RGB, IL_UNSIGNED_BYTE); if(!success) { return false; } } else { return false; } glGenTextures(1, &image); glBindTexture(GL_TEXTURE_2D, image); glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,GL_NEAREST_MIPMAP_LINEAR); gluBuild2DMipmaps( GL_TEXTURE_2D, 3, ilGetInteger(IL_IMAGE_WIDTH), ilGetInteger(IL_IMAGE_HEIGHT),GL_RGB, GL_UNSIGNED_BYTE, ilGetData()); ilDeleteImages(1, &texId); TextureInfo ti; ti.name = name; ti.image = image; textures.push_back(ti); return true; } int TextureManager::GetTexture(std::string name) { int size = textures.size(); for(int i=0;i points; vector normals; vector triangles; vector texcords; int w,h; double j = 0.0; double k = 0.0; int mode = 1; bool showNormals = false; void setCamera(double eyex,double eyey, double eyez, double centerx, double centery, double centerz) { gluLookAt(eyex,eyey,eyez,centerx,centery,centerz,0,1,0); } void DrawPoint(TexCord tc,Point p,Normal n) { glTexCoord2f(tc.x,tc.y); glNormal3f(n.x,n.y,n.z); glVertex3f(p.x,p.y,p.z); } void DrawNormal(Point p,Normal n) { glPushMatrix(); glTranslated(p.x,p.y,p.z); glBegin(GL_LINES); glVertex3f(0,0,0); glVertex3f(n.x*2,n.y*2,n.z*2); glEnd(); glPopMatrix(); } void processNormalKeys(unsigned char key, int x, int y) { if (key == 27) exit(0); if (key == 'q') { mode = 0; } if (key == 'w') { mode = 1; } if (key == 'a') { k -= 0.1; } if (key == 's') { k += 0.1; } if (key == 'z') { j -= 0.1; } if (key == 'x') { j += 0.1; } if (key == 'n') { if(showNormals == true) { showNormals = false; } else { showNormals = true; } } glutPostRedisplay(); } void renderScene(void) { //j+=0.0005; glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(60, (GLfloat)w / (GLfloat)h, 1.0, 100.0); setCamera(15*sin(j),15*cos(k),15*cos(j)*sin(k),0,0,0); glMatrixMode(GL_MODELVIEW); glEnable(GL_DEPTH_TEST); glEnable(GL_LIGHTING); //glEnable(GL_LIGHT0); float ambient[]={ 1.0, 1.0, 1.0, 0.0}; float diffuse[]={1.0, 1.0, 1.0, 1.0}; float position[]={25.0,25.0, 25.0, 1.0}; glLightfv(GL_LIGHT0, GL_AMBIENT, diffuse); glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse); glLightfv(GL_LIGHT0, GL_POSITION, position); glEnable(GL_DEPTH_TEST); glEnable(GL_LIGHTING); glEnable(GL_LIGHT0); glShadeModel(GL_SMOOTH); glClearColor(0.0f, 0.0f, 0.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glEnable(GL_TEXTURE_2D); glBindTexture(GL_TEXTURE_2D, tm.GetTexture("tex")); if(mode == 0 ) { glBegin(GL_TRIANGLES); } else { glBegin(GL_LINES); } for(int i=0;i *nn = &normals; vector *pp = &points; vector *tt = &triangles; vector *ttcc = &texcords; glutInit(&argc, argv); glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA); glutInitWindowPosition(100,100); glutInitWindowSize(320,320); glutCreateWindow("Model view"); glutKeyboardFunc(processNormalKeys); glutDisplayFunc(renderScene); //glutIdleFunc(renderScene); glutReshapeFunc(reshape); ifstream f; string cmd; f.open ("model.obj"); if (f.is_open()) { while(!f.eof()) { f>>cmd; if(cmd=="v") { Point p; f>>p.x; f>>p.y; f>>p.z; points.push_back(p); } if(cmd=="vn") { Normal n; f>>n.x; f>>n.y; f>>n.z; normals.push_back(n); } if(cmd=="vt") { TexCord tc; f>>tc.x; f>>tc.y; texcords.push_back(tc); } if(cmd=="f") { Triangle t; string str; string pointStr,normalStr,cordStr; string delimeter("/"); int pos,pos2; stringstream ss (stringstream::in | stringstream::out); f>>str; pos = str.find(delimeter); pointStr = str.substr(0,pos); cordStr = str.substr(pos+delimeter.length()); pos2 = cordStr.find(delimeter); normalStr = cordStr.substr(pos2+delimeter.length()); cordStr = cordStr.substr(0,pos2); ss >t.a; ss.clear(); ss >t.an; ss.clear(); ss >t.at; ss.clear(); f>>str; pos = str.find(delimeter); pointStr = str.substr(0,pos); cordStr = str.substr(pos+delimeter.length()); pos2 = cordStr.find(delimeter); normalStr = cordStr.substr(pos2+delimeter.length()); cordStr = cordStr.substr(0,pos2); ss >t.b; ss.clear(); ss >t.bn; ss.clear(); ss >t.bt; ss.clear(); f>>str; pos = str.find(delimeter); pointStr = str.substr(0,pos); cordStr = str.substr(pos+delimeter.length()); pos2 = cordStr.find(delimeter); normalStr = cordStr.substr(pos2+delimeter.length()); cordStr = cordStr.substr(0,pos2); ss >t.c; ss.clear(); ss >t.cn; ss.clear(); ss >t.ct; ss.clear(); triangles.push_back(t); } cmd = ""; } f.close(); } tm.AddTexture("tex","texture.png"); //glutTimerFunc(100, update, 0); glutMainLoop(); }
