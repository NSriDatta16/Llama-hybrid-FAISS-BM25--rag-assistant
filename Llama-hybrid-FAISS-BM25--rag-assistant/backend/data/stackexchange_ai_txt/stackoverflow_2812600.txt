[site]: stackoverflow
[post_id]: 2812600
[parent_id]: 2812504
[tags]: 
A couple of observed and seeming problems for you to consider: (1) What if your file's length in bytes is not exactly a multiple of sizeof(Student) ? Then this code: while (!feof(fp)) { fread(std, sizeof(*std), 1, fp); ... could read a partial struct into the memory pointed to by std . The contents of std would be partially filled and could leave an unterminated C string in memory. You must check the return value of fread() . (2) This a more important issue. You are re-using the memory allocated and pointed to by std , although you store the pointer in each element of your linked list. It seems that your intention would be to allocate new memory for each Student record. In this case, you would call malloc() within the body of the loop which reads multiple records from the file. This error depends on the file length, also -- the file must contain more than one record. (3) You could reorganize your code so that the first record is also read during a loop iteration, to remove needlessly duplicated code. (4) You might consider using calloc() to ensure that you have initialized all the records of Student . Like so: Database * dbOpen(char *fname) { FILE *fp = fopen(fname, "rb"); List *lst, *temp; Student *std; Database *db = NULL; if (!fp) return db; FileNameS = fname; db = malloc(sizeof(*db)); db->head = NULL; lst = NULL; while (!feof(fp)) { std = malloc(sizeof(*std)); if (!fread(std, sizeof(*std), 1, fp)) { free(std); fprintf(stderr, "Input file concludes in partial record.\n"); break; } temp = malloc(sizeof(*temp)); temp->s = std; temp->prev = lst; temp->next = NULL; if (lst == NULL) db->head = temp; else lst->next = temp; lst = temp; } assert(lst->next == NULL ); /* Now performed above by temp->next assignement. */ db->tail = lst; fclose(fp); return db; } I didn't compile and test the above code, but it should be close to working. Notice how a special case is added to either initialize db->head (first time through the loop, with lst equal NULL ), otherwise the previous list element is linked to the newly added element (later iterations). Of course we also should be checking the return values from malloc() , but that is left out for clarity here.
