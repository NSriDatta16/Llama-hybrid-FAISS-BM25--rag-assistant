[site]: stackoverflow
[post_id]: 5018526
[parent_id]: 5018355
[tags]: 
Where have you embedded the manifest? The EXE or the DLLs? You have two basic ways of doing this, both involve turning "common" into a private SxS assembly by creating a manifest for it. Then: If DLL and DLL2 contain manifests listing dependent assemblies, then you need to add a dependentAssembly to their manifests specifying "acme.common" (for example) as a dependent assembly. As dependent assemblies are always searched for, by default, in the loading modules folder, each DLL will load its own local copy of common. If you are just relying on the applications default activation context to do most of the heavy lifting, then you can try using the ActivationContext API. Call CreateActCtx twice, specifying two the two different folders as the base folder for the resulting context. In pseudo code: HACTCTX h1 = CreateActCtx( ... for DLL ... ); HACTCTX h2 = CreateActCtx( ... for DLL2 ...); ActivateActCtx(h1,...); LoadLibrary("C:\\DLL\\DLL1.DLL"); DeactivateActCtx(); ActivateActCtx(h2,...); LoadLibrary("C:\\DLL2\\DLL2.DLL"); DeactivateActCtx... If the dlls already contain their own manifests the system will use those. If not, this will let you specify a search directory for private assemblies without modifying the dll's themselves. To implement Option 1: First, I don't recommend trying to use the dll name as the assembly name. So, create a manifest that looks like this in each folder: You can fix the version number to match common.dll's version in each folder, but thats not important. Then, either the manifest you list, or a directive like this if you are using Visual Studio #pragma comment(linker, "/manifestdependency:\"acme.common'"\ " processorArchitecture='*' version='1.0.0.0' type='win32'\"") Just make sure the dependent assembly versions match the versions of the corresponding 'acme.common' assembly.
