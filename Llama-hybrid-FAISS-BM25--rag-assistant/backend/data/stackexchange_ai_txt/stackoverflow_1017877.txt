[site]: stackoverflow
[post_id]: 1017877
[parent_id]: 1017821
[tags]: 
I suggest an algorithm, that uses preprocessing: 1) Pre-process the T1 tree, keeping the list of all possible subtree roots (the cache list will have a millions of entries); 2) Sort the cached list of roots by the descending order of data, kept in root. You may choose more elegant sorting function, for example, parse a character tree into string. 3) Use binary search to locate the necessary sub-tree. You may quickly reject subtrees, with the number of nodes, not equal to the T2 number of nodes (or with the different depth). Note that steps 1) and 2) must be done only once, then you can test many sub-tree candidates, using the same preprocessed result.
