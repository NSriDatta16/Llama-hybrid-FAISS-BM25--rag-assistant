[site]: stackoverflow
[post_id]: 3125299
[parent_id]: 3125115
[tags]: 
The usual solution for this kind of problems is normalizing the model, i.e. to the First Normal Form . Your model, in normalized form, would have a third table, with references to the Appointment and Line_Item rows: Appointment start_time ... Line_Item name price ... Appointment_Line_Item appointment_key line_item_key There is a problem however! Since you are using Google App Engine, and their Datastore is quite limited ("GQL cannot perform an SQL-like JOIN") and mostly requires denormalization. You suggested using a list-like field. It is a possiblity to use this, but it is very hard to index it. Searching for a key (the appointment_key ) in a list per row in the database is not really performing. I propose two possiblities: Duplicate Line_Item . Line_Item appointment_key name price finished ... A Line_Item should have a finished state, when the item was finished or not by the employee. If an employee hadn't finished all line items, mark them as unfinished, create a new appointment and copy all items that were unfinished. You can index on the appointment_key field on all Line_Items , which is a Good Thing. However, the duplicated data may be a problem. Dynamic fields for Line_Item : Line_Item duplicate_key appointment_key name price finished ... Create a new field, duplicate_key , for Line_Item which points to another Line_Item or to null (reserve this key!). Null means that the Line_Item is original, any other value means that this Line_Item is a duplicate of the Line_Item the field points to. All fields of Line_Item marked as a duplicate inherit the fields of the original Line_Item , except the appointment_key : so it will take less storage. Also this solution should have appointment_key indexed, to speed up lookup times. This requires one additional query per duplicated Line_Item , which may be a problem. Now, it's a clear choice: either better speed or better storage. I would go for the first, as it reduces complexity of your model, and storage is never a problem with modern systems. Less complexity generally means less bugs and less development/testing costs, which justifies the cost of the storage requirement.
