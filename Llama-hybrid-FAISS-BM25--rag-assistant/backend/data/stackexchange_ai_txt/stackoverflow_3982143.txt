[site]: stackoverflow
[post_id]: 3982143
[parent_id]: 3981924
[tags]: 
No: Use a Future and possibly Callable and an ExecutorService . A Future is basically an exact programmatic expression of what you want: a promise of a future answer, and the ability to block until the answer is available . Future also automatically wraps and presents for you an entire, complicated farrago of potential concurrency nightmares and complexities into a few clearly defined exceptions. This is a good thing because it forces you to deal with them, when a roll-your-own solution would likely never reveal them except in some aberrant, difficult to diagnose behavior. public void askForAnAnswer() throws TimeoutException, InterruptedException, ExecutionException { Future theAnswerF = getMeAnAnswer(); String theAnswer = theAnswerF.get(); } public Future getMeAnAnswer() { Future promise = null; // spin off thread/executor, whatever. SwingUtilities.invokeAndWait(new Runnable() { public void run() { host = JOptionPane.showInputDialog("Enter host name: "); } }); // ... to wrap a Future around this. return promise; } For your specific case, you can probably build on a SwingWorker which implements Future . Rather than duplicate, please take a look at this SO question .
