[site]: stackoverflow
[post_id]: 1298251
[parent_id]: 936134
[tags]: 
Here is the solution I used to solve the problem at Hand. This solution relies on the overlaying Control to render its Parent as a bitmap image. This then gets painted as the background of the overlaying control. public class OverlayingControl : UserControl { /// /// Overrides the c# standard Paint Background to allow the custom background to be drawn /// within the OnPaint function /// /// /// Arguements used within this function protected override void OnPaintBackground( PaintEventArgs e ) { //Do Nothing } protected override void OnPaint( PaintEventArgs e ) { // Render the Parents image to a Bitmap. NB: bitmap dimensions and Parent Bounds can be changed to achieve the desitred effect Bitmap background = new Bitmap( Width, Height, PixelFormat.Format64bppArgb ); Parent.DrawToBitmap( background, Parent.Bounds ); // Paint background image g.DrawImage( background, 0, 0, new RectangleF( Location, Size ), GraphicsUnit.Pixel ); // Perform any alpha-blending here by drawing any desired overlay e.g. // g.FillRectangle( new SolidBrush( semiTransparentColor ), Bounds); } } This is performed purely within the WinForms domain, however I believe it could be possible to pass this Bitmap image to a WPF control to render as required. Currently there is no provision for updating the Bitmap when the parent changes, However, it should be trivial to create a custom method that clears the bitmap and re-draws the Overlayng control. Not an elegant solution I realise... but it appears to work well enough.
