[site]: stackoverflow
[post_id]: 5569795
[parent_id]: 5566454
[tags]: 
If you take a look at the EntityTypeConfiguration class you will see the following signature for defining a one-to-many relationship (which is your relation between Team and BirthYears ): HasMany (Expression >> navigationPropertyExpression) where TTargetEntity : class; As you can see, there is a constraint where TTargetEntity : class which requires that BirthYears is a collection of class objects. int isn't a class, so the mapping won't be possible. The only workaround I can see is to define a little class ... public class BirthYear { public int Id { get; set; } public int Value { get; set; } } ... and then use this in your collection in the class Team: public ICollection BirthYears { get; set; } The mapping conventions should automatically create a one-to-many relationship, so that you don't need the Fluent API to set up the association. Edit Correction according to Ladislav's correct critic in the comments: The class BirthYear needs an additional Key property. I've added a property Id . Also I guess that BirthYears will be a property dependent on Team . The mapping conventions will create an optional relationship from BirthYear to Team . I think it would be more suited for the model to make this relationship required by using the Fluent API: modelBuilder.Entity () .HasMany(t => t.BirthYears) .WithRequired(); This will automatically enable cascading delete - the associated BirthYears will be deleted from the database when a Team is deleted. Edit 2 (Again based on Ladislav's comment) If you don't want to replicate the years in the BirthYears table you could also setup a Many-To-Many relationship: modelBuilder.Entity () .HasMany(t => t.BirthYears) .WithMany(); This will add a join table ( TeamBirthYears ) between Team and BirthYear into the database. From the viewpoint of storage space or performance you wouldn't probably win anything (since the BirthYear class is very small and a record in the BirthYear table has the same size as a record in the join table). But it might be a better approach if you have in mind to extend the BirthYear class by additional properties sooner or later. Otherwise I would personally keep it simple with the One-To-Many relationship. But the choice is yours.
