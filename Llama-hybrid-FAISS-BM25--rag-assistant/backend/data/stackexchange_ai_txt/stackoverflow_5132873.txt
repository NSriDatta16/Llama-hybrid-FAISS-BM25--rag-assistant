[site]: stackoverflow
[post_id]: 5132873
[parent_id]: 
[tags]: 
Asynchrony in C# 5.0: How does Eric Lippert's example work?

I'm reading the great article series on Eric Lippert's blog about C#5's new asynchrony features. There he uses an example of a method fetchting documents from a remote location and, once retrieved, archives them on a storage drive. This is the code he uses: async Task ArchiveDocumentsAsync(List urls) { long count = 0; Task archive = null; for(int i = 0; i Now imagine that fetching documents is very quick. So the first document is fetched. After that, it's started to be archived, while the second document is being fetched. Now imagine the second document has been fetched and the first document is still being archived. Will this piece of code start fetching the third document or wait until the first document has been archived? As Eric says in its article, this code is converted by the compiler to this: Task ArchiveDocuments(List urls) { var taskBuilder = AsyncMethodBuilder .Create(); State state = State.Start; TaskAwaiter fetchAwaiter = null; TaskAwaiter archiveAwaiter = null; int i; long count = 0; Task archive = null; Document document; Action archiveDocuments = () => { switch(state) { case State.Start: goto Start; case State.AfterFetch: goto AfterFetch; case State.AfterArchive: goto AfterArchive; } Start: for(i = 0; i interesting part! Fetching of next document not done AfterArchive: archiveAwaiter.EndAwait(); } archive = ArchiveAsync(document); } taskBuilder.SetResult(count); return; }; archiveDocuments(); return taskBuilder.Task; } Additional question: If the execution is stopped, would it be possible to continue with fetching documents? If yes, how?
