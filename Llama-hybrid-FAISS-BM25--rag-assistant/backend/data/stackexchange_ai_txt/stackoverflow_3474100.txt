[site]: stackoverflow
[post_id]: 3474100
[parent_id]: 3472638
[tags]: 
Your two main causes of performance problems are: You call selection.GetPropertyValue() more times than necessary You recompute every time the selection changes The GetPropertyValue() method must internally scan through every element in the document, which makes it slow. So instead of calling it multiple times with the same argument, store the return values: private void HandleSelectionChange() { var family = selection.GetPropertyValue(FontFamilyProperty); var weight = selection.GetPropertyValue(FontWeightProperty); var style = selection.GetPropertyValue(FontStyleProperty); var align = selection.GetPropertyValue(Paragraph.TextAlignmentProperty); var unset = DependencyProperty.UnsetValue; SelectionFontFamily = family!=unset ? (FontFamily)family : null; SelectionIsBold = weight!=unset && (FontWeight)weight == FontWeight.Bold; SelectionIsItalic = style!=unset && (FontStyle)style == FontStyle.Italic; SelectionIsLeftAligned = align!=unset && (TextAlignment)align == TextAlignment.Left; SelectionIsCenterAligned = align!=unset && (TextAlignment)align == TextAlignment.Center; SelectionIsRightAligned = align!=unset && (TextAlignment)align == TextAlignment.Right; SelectionIsJustified = align!=unset && (TextAlignment)align == TextAlignment.Justify; } This will be about 3x faster, but to make it feel really snappy to the end-user, don't update the settings instantly on every change. Instead, update on ContextIdle: bool _queuedChange; private void richTextBox_SelectionChanged(object sender, RoutedEventArgs e) { if(!_queuedChange) { _queuedChange = true; Dispatcher.BeginInvoke(DispatcherPriority.ContextIdle, (Action)(() => { _queuedChange = false; HandleSelectionChange(); })); } } This calls the HandleSelctionChanged() method (above) to actually handle the selection change, but delays the call until ContextIdle dispatcher priority and also queues only one update no matter how many selection change events come in. Additional speedups possible The above code makes all four GetPropertyValue in a single DispatcherOperation, which means that you may still have a "lag" as long as the four calls. To reduce the lag an additional 4x, make only one GetPropertyValue per DispatcherOperation. So, for example, the first DispatcherOperation will call GetPropertyValue(FontFamilyProperty), store the result in a field, and schedule the next DispatcherOperation to get the font weight. Each subsequent DispatcherOperation will do the same. If this additional speedup is still not enough, the next step would be to split the selection into smaller pieces, call GetPropertyValue on each piece in a separate DispatcherOperation, then combine the results you get. To get the absolute maximum smoothness, you could implement your own code for GetPropertyValue (just iterate the ContentElements in the selection) that works incrementally and returns after checking, say, 100 elements. The next time you call it it would pick up where it left off. This would guarantee your ability to prevent any discernable lag by varying the amount of work done per DispatcherOperation. Would threading help? You ask in the comments whether this is possible to do using threading. The answer is that you can use a thread to orchestrate the work, but since you must always Dispatcher.Invoke back to the main thread to call GetPropertyValue, you will still block your UI thread for the entire duration of each GetPropertyValue call, so its granularity is still an issue. In other words, threading doesn't really buy you anything except perhaps the ability to avoid the use of a state machine for splitting your work up into bite-size chunks.
