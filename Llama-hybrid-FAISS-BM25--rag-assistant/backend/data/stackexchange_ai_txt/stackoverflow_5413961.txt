[site]: stackoverflow
[post_id]: 5413961
[parent_id]: 5408230
[tags]: 
I am unsure of what you are trying to do from your example. As a general rule, in Ruby, you don't check for types. It is dynamically typed for a reason: you can write code that works for any objects that happen to support the methods your code calls on them. From what I can tell from your comments, you want to extend the class Array so, when you call a method on an array like an_array.pack , the array is searched for an instance of Pack and returned. Ruby has a method called whenever a method is found not to exist called Module#method_missing . For example, if I randomly decide to call 4.to_dragon(magic: 4, height: 700) , the Ruby interpreter will attempt to find to_dragon as a public method defined on some class or module in the Fixnum (type of numbers) inheritance chain. Provided you have not done something strange to that chain, we get a call to method_missing on the object 4 with these arguments: [:to_dragon, { magic: 4, height: 700 }] . Basically, that's the name appended to the front of the arguments, and a block should one be given. Using this technique, you can override method_missing to get this code as a solution: class String def method_to_class split('_').map(&:capitalize).join end end class Array def method_missing(method_name, *arguments, &block) find do |element| element.class.name == method_name.to_s.method_to_class end || super end end You add a method to String to convert a method name to a class name. Then, you redefine method_missing on Array to check each element to see if the class name matches the given class name. If one is found, then that is returned. Otherwise (and we do this using Ruby's fancy || operator), the value returned from that function is nil and the second operand to || is returned. This happens to be the default implementation for method_missing (which we get by the super keyword) and returns the error the call deserves. The only potential issue with that is, if you have elements that have class names identical to method names that are already defined on arrays, then those will be called instead rather than this special technique. For example, calling an_array.hash will give you the hash code of the array rather than the first instance of a hash. A safer technique in this respect is more similar to what I think you were trying to do. It actually uses class objects, and you can use it to override other methods: class Array def add(class_object) class This defines new methods directly on an instance of an array. For example: an_array = [Array, Hash, Dragon].map &:new an_array.add Hash an_array.hash #=> {} If this answer does not include a solution, it should at least guide you closer!
