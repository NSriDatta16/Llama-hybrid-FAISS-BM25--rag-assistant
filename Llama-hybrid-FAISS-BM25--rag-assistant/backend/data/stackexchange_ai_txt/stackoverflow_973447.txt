[site]: stackoverflow
[post_id]: 973447
[parent_id]: 973439
[tags]: 
You do it with the setsockopt() call, by using the IP_DONTFRAG option: int val = 1; setsockopt(sd, IPPROTO_IP, IP_DONTFRAG, &val, sizeof(val)); Here's a page explaining this in further detail. For Linux, it appears you have to use the IP_MTU_DISCOVER option with the value IP_PMTUDISC_DO (or IP_PMTUDISC_DONT to turn it off): int val = IP_PMTUDISC_DO; setsockopt(sd, IPPROTO_IP, IP_MTU_DISCOVER, &val, sizeof(val)); I haven't tested this, just looked in the header files and a bit of a web search so you'll need to test it. As to whether there's another way the DF flag could be set: I find nowhere in my program where the "force DF flag" is set, yet tcpdump suggests it is. Is there any other way this could get set? From this excellent page here : IP_MTU_DISCOVER: Sets or receives the Path MTU Discovery setting for a socket. When enabled, Linux will perform Path MTU Discovery as defined in RFC 1191 on this socket. The don't fragment flag is set on all outgoing datagrams. The system-wide default is controlled by the ip_no_pmtu_disc sysctl for SOCK_STREAM sockets, and disabled on all others. For non SOCK_STREAM sockets it is the user's responsibility to packetize the data in MTU sized chunks and to do the retransmits if necessary. The kernel will reject packets that are bigger than the known path MTU if this flag is set (with EMSGSIZE ). This looks to me like you can set the system-wide default using sysctl : sysctl ip_no_pmtu_disc returns "error: "ip_no_pmtu_disc" is an unknown key" on my system but it may be set on yours. Other than that, I'm not aware of anything else (other than setsockopt() as previously mentioned) that can affect the setting.
