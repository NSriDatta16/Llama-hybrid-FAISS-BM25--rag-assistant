[site]: datascience
[post_id]: 122580
[parent_id]: 
[tags]: 
How to grid search LSTM manually using TimeSeriesSplit while preserve/load best_models?

This is a self-written LSTM tuner class. class ModelTuner_SingleLSTM: def __init__(self, params, callbacks): self.params = params self.callbacks = callbacks self.hist = [] def create_model(self, params): # (1) 创建LSTM模型 model = Sequential() # model.add(LSTM(units=params['units'], activation=params['activation'], return_sequences=False, model.add(LSTM(units=params['units'], activation='relu', return_sequences=False, input_shape=(params['n_steps'], 37))) model.add(Dropout(params['dropout_rate'])) model.add(Dense(units=1)) # (2) 编译模型 model.compile(optimizer=params['optimizer'](learning_rate=params['lr']), loss='mse', metrics=['mse', 'accuracy']) return model def grid_search(self, X_train, y_train, X_val, y_val, checkpoint_fname): X = vstack([X_train, X_val]) y = vstack([y_train.reshape(-1, 1), y_val.reshape(-1, 1)]) # 创建TimeSeriesSplit对象 tscv = TimeSeriesSplit(n_splits=5) # 迭代遍历参数组合 best_score = float('-inf') best_params = {} for params in ParameterGrid(self.params): print("Current parameters:", params) # 记录本组参数组合的全部score scores_val = [] i = 1 # 1. 每一次split迭代 (n_splits==n_fold???) for train_index, val_index in tscv.split(X): X_train, X_val = X[train_index], X[val_index] y_train, y_val = y[train_index], y[val_index] print(i) print(X_train.shape, X_val.shape) print(y_train.shape, y_val.shape) # (1) 创建LSTM模型 model = self.create_model(params) # (2) 训练模型 history = model.fit(X_train, y_train, batch_size=params['batch_size'], epochs=params['epochs'], validation_data=(X_val, y_val), callbacks=self.callbacks) # for key in history.history: # print(key) # (4) 加载最佳模型 model.load_weights(checkpoint_fname) # model.save(checkpoint_fname) # (5) 在验证集上进行预测 y_pred_val = model.predict(X_val) # (6) 计算性能指标（例如均方误差） score_val = mean_squared_error(y_val, y_pred_val) scores_val.append(score_val) # 2. 计算本组参数下的平均验证集score avg_score = np.mean(scores_val) print("Average score of current parameters:", avg_score) # 3. 更新最优score和最优参数 if avg_score > best_score: best_score = avg_score best_params = params print(f"Best_score: {best_score}; Best parameters: {best_params}") return best_score, best_params But I got an error: ValueError: Cannot assign value to variable ' lstm_10/lstm_cell_10/kernel:0': Shape mismatch. The variable shape (37, 64), and the assigned value shape (37, 256) are incompatible. It points to "model.load_weights(checkpoint_fname)" But some epochs are OK with model.load_weights(checkpoint_fname). the "model" object is just fit and then I load...so why the shape will mismatch?
