[site]: stackoverflow
[post_id]: 1389955
[parent_id]: 1389285
[tags]: 
If the data is updating more often than you can generate the chart, then you should have a task in a separate thread that regenerates the chart, and starts another regeneration when it's done. There's little point in running it ore often than that, but if it turns out to be too much of a cpu load, you can throttle back the frequency with which it restarts. If updates don't come in, you don't trigger the re-generate. I did something like that in my Zocalo project recently. It does everything but the throttling back. package net.commerce.zocalo.freechart; // Copyright 2009 Chris Hibbert. All rights reserved. // This software is published under the terms of the MIT license, a copy // of which has been included with this distribution in the LICENSE file. import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Callable; import java.util.concurrent.Future; import java.util.Map; import java.util.HashMap; /** Schedule a task like generating a price history graph. Multiple requests may come in sporadically. We want to ensure that only one is being processed at a time. If we're busy processing when a request comes in, we'll remember to start another when this one is done. Multiple requests that come in while processing will spur a single restart. */ public class ChartScheduler { static private Logger log = Logger.getLogger(ChartScheduler.class); static private Map schedulers = new HashMap (); private AtomicBoolean generating = new AtomicBoolean(false); private AtomicBoolean requested = new AtomicBoolean(false); private ExecutorService threads = Executors.newCachedThreadPool(); private Callable callable; private int runs = 0; private String name; private ChartScheduler(String name, final Runnable worker) { this.name = name; callable = new Callable () { public Boolean call() throws Exception { worker.run(); runs++; restartIfNeeded(); return true; } }; } public static ChartScheduler create(String name, Runnable worker) { ChartScheduler sched = find(name); if (sched == null) { sched = new ChartScheduler(name, worker); schedulers.put(name, sched); } return sched; } public static ChartScheduler find(String name) { return schedulers.get(name); } public boolean generateNewChart() { requested.set(true); if (generating.compareAndSet(false, true)) { startNewThread(); return true; } else { return false; } } private Future startNewThread() { generating.set(true); requested.set(false); return threads.submit(callable); } private boolean restartIfNeeded() { generating.set(false); if (requested.get()) { return generateNewChart(); } else { return false; } } public boolean isBusy() { return generating.get(); } public int runs() { return runs; } }
