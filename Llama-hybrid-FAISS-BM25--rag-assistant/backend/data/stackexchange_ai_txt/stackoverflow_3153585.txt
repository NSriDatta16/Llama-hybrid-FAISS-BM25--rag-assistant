[site]: stackoverflow
[post_id]: 3153585
[parent_id]: 2873767
[tags]: 
I'm sure there's a lot of ways code could call SynchronizedLifetimeManager, or a descendant like ContainerControlledLifetimeManager, but there were two scenarios in particular that were causing me problems. The first was my own fault - I was using constructor injection to supply a reference to the container, and in that constructor I was also adding the new instance of the class to the container for future use. This backwards approach had the effect of changing the lifetime manager from Transient to ContainerControlled so that the object Unity called GetValue on was not the same object it called SetValue on. The lesson learned is don't do anything during build-up that could change an object's lifetime manager. The second scenario was that every time RegisterInstance is called, UnityDefaultBehaviorExtension calls SetValue without calling GetValue first. Luckily, Unity is extensible enough that, with enough bloody-mindedness, you can work around the problem. Start with a new behavior extension like this: /// /// Replaces to eliminate /// exceptions that would otherwise occur /// when using RegisterInstance . /// public class UnitySafeBehaviorExtension : UnityDefaultBehaviorExtension { /// /// Adds this extension's behavior to the container. /// protected override void Initialize() { Context.RegisteringInstance += PreRegisteringInstance; base.Initialize(); } /// /// Handles the event by /// ensuring that, if the lifetime manager is a /// that its /// method has been called. /// /// The object responsible for raising the event. /// A containing the /// event's data. private void PreRegisteringInstance(object sender, RegisterInstanceEventArgs e) { if (e.LifetimeManager is SynchronizedLifetimeManager) { e.LifetimeManager.GetValue(); } } } Then you need a way to replace the default behavior. Unity doesn't have a method to remove a specific extension, so you have to remove everything and put the other extensions back in again: public static IUnityContainer InstallCoreExtensions(this IUnityContainer container) { container.RemoveAllExtensions(); container.AddExtension(new UnityClearBuildPlanStrategies()); container.AddExtension(new UnitySafeBehaviorExtension()); #pragma warning disable 612,618 // Marked as obsolete, but Unity still uses it internally. container.AddExtension(new InjectedMembers()); #pragma warning restore 612,618 container.AddExtension(new UnityDefaultStrategiesExtension()); return container; } Notice that UnityClearBuildPlanStrategies ? RemoveAllExtensions clears out all of the container's internal lists of policies and strategies except for one, so I had to use another extension to avoid inserting duplicates when I restored the default extensions: /// /// Implements a that clears the list of /// build plan strategies held by the container. /// public class UnityClearBuildPlanStrategies : UnityContainerExtension { protected override void Initialize() { Context.BuildPlanStrategies.Clear(); } } Now you can safely use RegisterInstance without fear of being driven to the brink of madness. Just to be sure, here's some tests: [TestClass] public class UnitySafeBehaviorExtensionTests : ITest { private IUnityContainer Container; private List FirstChanceExceptions; [TestInitialize] public void TestInitialize() { Container = new UnityContainer(); FirstChanceExceptions = new List (); AppDomain.CurrentDomain.FirstChanceException += FirstChanceExceptionRaised; } [TestCleanup] public void TestCleanup() { AppDomain.CurrentDomain.FirstChanceException -= FirstChanceExceptionRaised; } private void FirstChanceExceptionRaised(object sender, FirstChanceExceptionEventArgs e) { FirstChanceExceptions.Add(e.Exception); } /// /// Tests that the default behavior of UnityContainer leads to a SynchronizationLockException /// being throw on RegisterInstance . /// [TestMethod] public void UnityDefaultBehaviorRaisesExceptionOnRegisterInstance() { Container.RegisterInstance (this); Assert.AreEqual(1, FirstChanceExceptions.Count); Assert.IsInstanceOfType(FirstChanceExceptions[0], typeof(SynchronizationLockException)); } /// /// Tests that UnitySafeBehaviorExtension protects against SynchronizationLockException s being /// thrown during calls to RegisterInstance . /// [TestMethod] public void SafeBehaviorPreventsExceptionOnRegisterInstance() { Container.RemoveAllExtensions(); Container.AddExtension(new UnitySafeBehaviorExtension()); Container.AddExtension(new InjectedMembers()); Container.AddExtension(new UnityDefaultStrategiesExtension()); Container.RegisterInstance (this); Assert.AreEqual(0, FirstChanceExceptions.Count); } } public interface ITest { }
