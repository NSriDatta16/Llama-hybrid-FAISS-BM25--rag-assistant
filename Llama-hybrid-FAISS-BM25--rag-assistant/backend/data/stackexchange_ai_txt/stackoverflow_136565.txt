[site]: stackoverflow
[post_id]: 136565
[parent_id]: 104918
[tags]: 
Passing the data in via a constructor or setter works, but requires the creator of the command to know the data the command needs... The "context" idea is really good, and I was working on (an internal) framework that leveraged it a while back. If you set up your controller (UI components that interact with the user, CLI interpreting user commands, servlet interpreting incoming parameters and session data, etc) to provide named access to the available data, commands can directly ask for the data they want. I really like the separation a setup like this allows. Think about layering as follows: User Interface (GUI controls, CLI, etc) | [syncs with/gets data] V Controller / Presentation Model | ^ [executes] | V | Commands --------> [gets data by name] | [updates] V Domain Model If you do this "right", the same commands and presentation model can be used with any type of user interface. Taking this a step further, the "controller" in the above is pretty generic. The UI controls only need to know the name of the command they'll invoke -- they (or the controller) don't need to have any knowledge of how to create that command or what data that command needs. That's the real advantage here. For example, you could hold the name of the command to execute in a Map. Whenever the component is "triggered" (usually an actionPerformed), the controller looks up the command name, instantiates it, calls execute, and pushes it on the undo stack (if you use one).
