[site]: stackoverflow
[post_id]: 5097511
[parent_id]: 5097167
[tags]: 
How about this? let filterPairs f = let rec filter keepHead = function | x::(y::_ as xs) when f x y -> x::(filter true xs) | x::xs -> let rest = filter false xs if keepHead then x::rest else rest | _ -> [] filter false let test = filterPairs (fun x y -> y - x = 2) [1; 2; 4; 6; 8; 10; 15; 17] Or if all of your list's items are unique, you could do this: let rec filterPairs f s = s |> Seq.windowed 2 |> Seq.filter (fun [|a;b|] -> f a b) |> Seq.concat |> Seq.distinct let test = filterPairs (fun x y -> y - x = 2) [1; 2; 4; 6; 8; 10; 15; 17] EDIT Or here's another alternative which I find elegant. First define a function for breaking a list into a list of groups of consecutive items satisfying a predicate: let rec groupConsec f = function | [] -> [] | x::(y::_ as xs) when f x y -> let (gp::gps) = groupConsec f xs (x::gp)::gps | x::xs -> [x]::(groupConsec f xs) Then, build your function by collecting all results back together, discarding any singletons: let filterPairs f = groupConsec f >> List.collect (function | [_] -> [] | l -> l) let test = filterPairs (fun x y -> y - x = 2) [1; 2; 4; 6; 8; 10; 15; 17]
