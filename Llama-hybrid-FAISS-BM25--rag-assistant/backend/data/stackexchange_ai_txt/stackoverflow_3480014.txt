[site]: stackoverflow
[post_id]: 3480014
[parent_id]: 3478954
[tags]: 
Perl, 40 char It's a little fragile. print$/=!1,($_=<>)^substr<>x 1E4,0,y///c Perl has a built-in string xor operator. To solve this problem, the hard part is getting the two strings to have the same length. $/=!1 Sets the "record separator" to the undefined value, and doesn't cause anything to be printed. With this setting, the file readline operator will slurp in an entire file. $_=<> Loads the entire first file (containing the message) into the variable $_ . substr <> x 1E4, 0, y///c Creates another string out of the second file (the key) and adds it to itself 10,000 times. Hopefully, (1) this really long string will be longer than the message string, and (2) it won't be so long that it causes the program to run out of memory (that's how this solution is fragile). y///c is an operation to count the number of characters in $_ , and it's one character shorter than saying length . This shortens the key string to the same size as the message string.
