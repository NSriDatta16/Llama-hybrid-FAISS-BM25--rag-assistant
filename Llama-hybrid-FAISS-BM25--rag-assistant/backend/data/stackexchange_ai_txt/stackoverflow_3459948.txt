[site]: stackoverflow
[post_id]: 3459948
[parent_id]: 3458542
[tags]: 
Here's a full working example: from PyQt4 import QtCore, QtGui, Qt import cPickle import pickle Why are you using cPickle as well as pickle ? class DragTable(QtGui.QTableView): def __init__(self, parent = None): super(DragTable, self).__init__(parent) self.setDragEnabled(True) self.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows) You probably want to set the selection behavior here, because I'm assuming row-based data presentation. You may of course change that. def dragEnterEvent(self, event): if event.mimeData().hasFormat("application/pubmedrecord"): event.setDropAction(Qt.MoveAction) event.accept() else: event.ignore() def startDrag(self, event): Your code assumes only one index here, based on the event position. For a QTableView , this is unnecessary, as it already handles the mouse click itself. Instead, it's better to depend on Qt to provide you with the information that you actually need , as always. Here, I've chose to use selectedIndexes() . indices = self.selectedIndexes() Indices is now a list of QModelIndex instances, that I chose to convert to a set of row numbers. It's also possible to convert these to a list of QPersistentModelIndex es, depending on your needs. One thing that may surprise you here, is that indices contains indexes for all cells in the table, not all rows, regardless of the selection behavior. That's why I chose to use a set instead of a list . selected = set() for index in indices: selected.add(index.row()) I left the rest untouched, assuming that you know what you're doing there. bstream = cPickle.dumps(selected) mimeData = QtCore.QMimeData() mimeData.setData("application/pubmedrecord", bstream) drag = QtGui.QDrag(self) drag.setMimeData(mimeData) pixmap = QtGui.QPixmap(":/drag.png") drag.setHotSpot(QtCore.QPoint(pixmap.width()/3, pixmap.height()/3)) drag.setPixmap(pixmap) result = drag.start(QtCore.Qt.MoveAction) def mouseMoveEvent(self, event): self.startDrag(event) class TagLabel(QtGui.QLabel): def __init__(self, text, color, parent = None): super(TagLabel, self).__init__(parent) self.tagColor = color self.setText(text) self.setStyleSheet("QLabel { background-color: %s; font-size: 14pt; }" % self.tagColor) self.defaultStyle = self.styleSheet() self.setAlignment(QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter) self.setAcceptDrops(True) def dragEnterEvent(self, event): if event.mimeData().hasFormat("application/pubmedrecord"): self.set_bg(True) event.accept() else: event.reject() def dragLeaveEvent(self, event): self.set_bg(False) event.accept() def dropEvent(self, event): self.set_bg(False) data = event.mimeData() bstream = data.retrieveData("application/pubmedrecord", QtCore.QVariant.ByteArray) selected = pickle.loads(bstream.toByteArray()) event.accept() self.emit(QtCore.SIGNAL("dropAccepted(PyQt_PyObject)"), (selected, str(self.text()), str(self.tagColor))) Unless you are interfacing with C++-code with this signal, it's not necessary to add a signal argument here, you may also use dropAccepted without parentheses and PyQt4 will do the right thing. def set_bg(self, active = False): if active: style = "QLabel {background: yellow; font-size: 14pt;}" self.setStyleSheet(style) else: self.setStyleSheet(self.defaultStyle) app = QtGui.QApplication([]) l = TagLabel("bla bla bla bla bla bla bla", "red") l.show() m = QtGui.QStandardItemModel() for _ in xrange(4): m.appendRow([QtGui.QStandardItem(x) for x in ["aap", "noot", "mies"]]) t = DragTable() t.setModel(m) t.show() def h(o): print "signal handled", o l.connect(l, QtCore.SIGNAL("dropAccepted(PyQt_PyObject)"), h) app.exec_()
