[site]: stackoverflow
[post_id]: 2077415
[parent_id]: 1928011
[tags]: 
It turned out, that the best way to handle d'n'd in my case is via WebArchivePboardType . Then: - (BOOL)performDragOperation:(id )sender { NSPasteboard *pboard; NSDragOperation sourceDragMask; sourceDragMask = [sender draggingSourceOperationMask]; pboard = [sender draggingPasteboard]; // Create image data from webarchive stored in a pasteboard. NSData *image = [pboard dataForType:WebArchivePboardType]; WebArchive *webArchive = [[WebArchive alloc] initWithData:image]; // Let's see what are we dragging. for (WebResource *subresource in [webArchive subresources]) { NSString *mimeType = [subresource MIMEType]; if ([mimeType hasPrefix:expectedMimeTypeStartsWith]) { NSData *data = [subresource data]; CFDataRef imgData = (CFDataRef)data; CGDataProviderRef imgDataProvider = CGDataProviderCreateWithCFData (imgData); CGImageRef image; if ([mimeType hasSuffix:@"png"]) { image = CGImageCreateWithPNGDataProvider(imgDataProvider, NULL, true, kCGRenderingIntentDefault); } else if ([mimeType hasSuffix:@"jpeg"]) { image = CGImageCreateWithJPEGDataProvider(imgDataProvider, NULL, true, kCGRenderingIntentDefault); } [self setImage:image imageProperties:nil]; } } return YES; }
