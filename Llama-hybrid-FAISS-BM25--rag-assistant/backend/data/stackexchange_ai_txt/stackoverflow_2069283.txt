[site]: stackoverflow
[post_id]: 2069283
[parent_id]: 1995328
[tags]: 
I don't think this is better, but it does work and does not use recursion: #include #include #include ::std::uint64_t fact(unsigned int v) { ::std::uint64_t output = 1; for (unsigned int i = 2; i 2^64 const size_t strsize = s.size(); if (strsize > max_size) { throw ::std::overflow_error("This function can only permute strings of size 20 or less."); } else if (strsize 0; permleft /= i, --i) { uint64_t taken_char = permleft % i; residuals[strsize - i] = taken_char; // Translate indexes in terms of the list of remaining characters // into indexes in terms of the original string. for (unsigned int o = (strsize - i); o > 0; --o) { if (taken_char >= residuals[o - 1]) { ++taken_char; } } idxs[strsize - i] = taken_char; } cout The fun thing about this is that the only state it uses from permutation to permutation is the number of the permutation, the total number of permutations, and the original string. That means it can be easily encapsulated in an iterator or something like that without having to carefully preserve the exact correct state. It can even be a random access iterator. Of course ::std::next_permutation stores the state in the relationships between elements, but that means it can't work on unordered things, and I would really wonder what it does if you have two equal things in the sequence. You can solve that by permuting indexes of course, but that adds slightly more complication. Mine will work with any random access iterator range provided it's short enough. And if it isn't, you'll never get through all the permutations anyway. The basic idea of this algorithm is that every permutation of N items can be enumerated. The total number is N! or fact(N) . And any given permutation can be thought of as a mapping of source indices from the original sequence into a set of destination indices in the new sequence. Once you have an enumeration of all permutations the only thing left to do is map each permutation number into an actual permutation. The first element in the permuted list can be any of the N elements from the original list. The second element can be any of the N - 1 remaining elements, and so on. The algorithm uses the % operator to pull apart the permutation number into a set of selections of this nature. First it modulo's the permutation number by N to get a number from [0,N). It discards the remainder by dividing by N, then it modulo's it by the size of the list - 1 to get a number from [0,N-1) and so on. That is what the for (i = loop is doing. The second step is translating each number into an index into the original list. The first number is easy because it's just a straight index. The second number is an index into a list that contains every element but the one removed at the first index, and so on. That is what the for (o = loop is doing. residuals is a list of indices into the successively smaller lists. idxs is a list of indices into the original list. There is a one-one mapping between values in residuals and idxs . They each represent the same value in different 'coordinate spaces'. The answer pointed to by the answer you picked has the same basic idea, but has a much more elegant way of accomplishing the mapping than my rather literal and brute force method. That way will be slightly faster than my method, but they are both about the same speed and they both have the same advantage of random access into permutation space which makes a whole number of things easier, including (as the answer you picked pointed out) parallel algorithms.
