[site]: stackoverflow
[post_id]: 2006640
[parent_id]: 2006190
[tags]: 
Python does not have a preprocessor, although you could run your python source through an external preprocessor to get the same effect - e.g. sed "/logging.debug/d" will strip out all the debug logging commands. This is not very elegant though - you will end up needing some sort of build system to run all your modules through the preprocessor and perhaps create a new directory tree of the processed .py files before running the main script. Alternatively if you put all your debug statements in an if __debug__: block they will get optimised out when python is run with the -O (optimise) flag. As an aside, I checked the code with the dis module to ensure that it did get optimised away. I discovered that both if __debug__: doStuff() and if 0: doStuff() are optimised, but if False: doStuff() is not. This is because False is a regular Python object, and you can in fact do this: >>> False = True >>> if False: print "Illogical, captain" Illogical, captain Which seems to me a flaw in the language - hopefully it is fixed in Python 3. Edit: This is fixed in Python 3: Assigning to True or False now gives a SyntaxError . Since True and False are constants in Python 3, it means that if False: doStuff() is now optimised: >>> def f(): ... if False: print( "illogical") ... >>> dis.dis(f) 2 0 LOAD_CONST 0 (None) 3 RETURN_VALUE
