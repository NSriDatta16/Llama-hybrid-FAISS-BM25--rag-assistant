[site]: stackoverflow
[post_id]: 2783068
[parent_id]: 2778705
[tags]: 
Your code fragment resembles the entry code used by some processors and compilers. The entry code is assembly code that a compiler issues when entering a function. Entry code is responsible for saving function parameters and allocating space for local variables and optionally initializing them. The entry code uses pointers to the storage area of the variables. Some processors use a combination of the EBP and ESP registers to point to the location of the local variables (and function parameters). Since the compiler knows where the variables (and function parameters) are stored, it drops the variable names and uses numerical indexing. For example, the line: movl 8(%ebp), %eax would either move the contents of the 8th local variable into the register EAX , or move the value at 8 bytes from the start of the local area (assuming the the EBP register pointers to the start of the local variable area). The instruction: subl $24, %esp implies that the compiler is reserving 24 bytes on the stack. This could be to protect some information in the function calling convention. The function would be able to use the area after this for its own usage. This reserved area may contain function parameters. The code fragment you supplied looks like it is comparing two local variables inside a function: void Unknown_Function(long param1, long param2, long param3) { unsigned int local_variable_1; unsigned int local_variable_2; unsigned int local_variable_3; if (local_variable_2 Try disassembling the above function and see how close it matches your code fragment.
