[site]: stackoverflow
[post_id]: 345093
[parent_id]: 342946
[tags]: 
From the MSDN ( http://msdn.microsoft.com/en-us/library/8xx3tyca.aspx ): When a SqlConnection object is requested, it is obtained from the pool if a usable connection is available. To be usable, a connection must be unused, have a matching transaction context or be unassociated with any transaction context , and have a valid link to the server. The connection pooler satisfies requests for connections by reallocating connections as they are released back into the pool. If the maximum pool size has been reached and no usable connection is available, the request is queued. The pooler then tries to reclaim any connections until the time-out is reached (the default is 15 seconds). If the pooler cannot satisfy the request before the connection times out, an exception is thrown . Translation: Check your transaction contexts... if you have a pool size of 10 connections, and 10 connections have been created under different transactions, you're screwed. Note that a severed connection can be detected only after attempting to communicate with the server . If a connection is found that is no longer connected to the server, it is marked as invalid. Invalid connections are removed from the connection pool only when they are closed or reclaimed. If a connection exists to a server that has disappeared, this connection can be drawn from the pool even if the connection pooler has not detected the severed connection and marked it as invalid. This is the case because the overhead of checking that the connection is still valid would eliminate the benefits of having a pooler by causing another round trip to the server to occur. When this occurs, the first attempt to use the connection will detect that the connection has been severed, and an exception is thrown . Translation: You can't really rely on a connection to be connected? The article doesn't really explain how to handle this... You could try manually clearing the pool occasionally using ClearAllPools and ClearPool, but this still sounds like a band-aid to me, makes me cringe. The article also discusses Security Contexts, saying: After a SQL Server application role has been activated by calling the sp_setapprole system stored procedure, the security context of that connection cannot be reset. However, if pooling is enabled, the connection is returned to the pool, and an error occurs when the pooled connection is reused. I'm starting to wonder why I use connection pooling... And finally: Pool Fragmentation Due to Integrated Security Connections are pooled according to the connection string plus the user identity. Therefore, if you use Basic authentication or Windows Authentication on the Web site and an integrated security login, you get one pool per user. Although this improves the performance of subsequent database requests for a single user, that user cannot take advantage of connections made by other users. It also results in at least one connection per user to the database server. So if you're using integrated security on a web app, you can fill up your connection pool if you have enough users. Without knowing more specifics on your application, it's hard to zoom in on what might be tripping you up, but hopefully this gives you some ideas where to look. HTH
