[site]: stackoverflow
[post_id]: 2712125
[parent_id]: 2712076
[tags]: 
That your code compiles at all is probably because you have a using namespace std somewhere. (Otherwise vector would have to be std::vector .) That's something I would advise against and you have just provided a good case why: By accident, your call picks up std::distance() , which takes two iterators and calculates the distance between them. Remove the using directive and prefix all standard library types with std:: and the compiler will tell you that you tried to pass a vector ::iterator where a point* was required. To get a pointer to an object an iterator points to, you'd have to dereference the iterator - which gives a reference to the object - and take the address of the result: &*ii . (Note that a pointer would perfectly fulfill all requirements for a std::vector iterator and some earlier implementations of the standard library indeed used pointers for that, which allowed you to treat std::vector iterators as pointers. But modern implementations use a special iterator class for that. I suppose the reason is that using a class allows overloading functions for pointers and iterators. Also, using pointers as std::vector iterators encourages mixing pointers and iterators, which will prevent the code to compile when you change your container.) But rather than doing this, I suggest you change your function so that it takes references instead (see this answer for why that's a good idea anyway.) : float distance(const point& p1, const point& p2) { return sqrt((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y)); } Note that the points are taken by const references. This indicates to the caller that the function won't change the points it is passed. Then you can call it like this: distance(*ii,*jj) . On a side note, this typedef struct point { float x; float y; } point; is a C-ism unnecessary in C++. Just spell it struct point { float x; float y; }; That would make problems if this struct definition ever was to parse from a C compiler (the code would have to refer to struct point then, not simply point ), but I guess std::vector and the like would be far more of a challenge to a C compiler anyway.
