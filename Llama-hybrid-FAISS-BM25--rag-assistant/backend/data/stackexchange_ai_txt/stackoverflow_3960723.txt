[site]: stackoverflow
[post_id]: 3960723
[parent_id]: 3959705
[tags]: 
Let's get the important stuff out of the way first: arrays are not pointers . Array types and pointer types are completely different things and are treated differently by the compiler. Where the confusion arises is from how C treats array expressions . N1570 : 6.3.2.1 Lvalues, arrays, and function designators ... 3 Except when it is the operand of the sizeof operator, the _Alignof operator, or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type ’’ is converted to an expression with type ‘‘pointer to type ’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undeﬁned. Let's look at the following declarations: int arr[10] = {0,1,2,3,4,5,6,7,8,9}; int *parr = arr; arr is a 10-element array of int ; it refers to a contiguous block of memory large enough to store 10 int values. The expression arr in the second declaration is of array type, but since it is not the operand of & or sizeof and it isn't a string literal, the type of the expression becomes "pointer to int ", and the value is the address of the first element, or &arr[0] . parr is a pointer to int; it refers to a block of memory large enough to hold the address of a single int object. It is initialized to point to the first element in arr as explained above. Here's a hypothetical memory map showing the relationship between the two (assuming 16-bit ints and 32-bit addresses): Object Address 0x00 0x01 0x02 0x03 ------ ------- ---------------------- arr 0x10008000 0x00 0x00 0x00 0x01 0x10008004 0x00 0x02 0x00 0x03 0x10008008 0x00 0x04 0x00 0x05 0x1000800c 0x00 0x06 0x00 0x07 0x10008010 0x00 0x08 0x00 0x09 parr 0x10008014 0x10 0x00 0x80 0x00 The types matter for things like sizeof and & ; sizeof arr == 10 * sizeof (int) , which in this case is 20, whereas sizeof parr == sizeof (int *) , which in this case is 4. Similarly, the type of the expression &arr is int (*)[10] , or a pointer to a 10-element array of int , whereas the type of &parr is int ** , or pointer to pointer to int . Note that the expressions arr and &arr will yield the same value (the address of the first element in arr ), but the types of the expressions are different ( int * and int (*)[10] , respectively). This makes a difference when using pointer arithmetic. For example, given: int arr[10] = {0,1,2,3,4,5,6,7,8,9}; int *p = arr; int (*ap)[10] = &arr; printf("before: arr = %p, p = %p, ap = %p\n", (void *) arr, (void *) p, (void *) ap); p++; ap++; printf("after: arr = %p, p = %p, ap = %p\n", (void *) arr, (void *) p, (void *) ap); the "before" line should print the same values for all three expressions (in our hypothetical map, 0x10008000 ). The "after" line should show three different values: 0x10008000 , 0x10008002 (base plus sizeof (int) ), and 0x10008014 (base plus sizeof (int [10]) ). Now let's go back to the second paragraph above: array expressions are converted to pointer types in most circumstances. Let's look at the subscript expression arr[i] . Since the expression arr is not appearing as an operand of either sizeof or & , and since it is not a string literal being used to initialize another array, its type is converted from "10-element array of int " to "pointer to int ", and the subscript operation is being applied to this pointer value. Indeed, when you look at the C language definition, you see the following language: 6.5.2.1 Array subscripting ... 2 A postfix expression followed by an expression in square brackets [] is a subscripted designation of an element of an array object. The definition of the subscript operator [] is that E1[E2] is identical to (*((E1)+(E2))) . Because of the conversion rules that apply to the binary + operator, if E1 is an array object (equivalently, a pointer to the initial element of an array object) and E2 is an integer, E1[E2] designates the E2 -th element of E1 (counting from zero). In practical terms, this means you can apply the subscript operator to a pointer object as though it were an array. This is why code like int foo(int *p, size_t size) { int sum = 0; int i; for (i = 0; i works the way it does. main is dealing with an array of int , whereas foo is dealing with a pointer to int , yet both are able to use the subscript operator as though they were both dealing with an array type. It also means array subscripting is commutative : assuming a is an array expression and i is an integer expression, a[i] and i[a] are both valid expressions, and both will yield the same value.
