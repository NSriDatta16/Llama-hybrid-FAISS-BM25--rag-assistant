[site]: stackoverflow
[post_id]: 2483536
[parent_id]: 2483491
[tags]: 
You can make a class ImmutableRectangle , without any mutators and with only const methods, from which you can correctly derive both Rectangle , and, separately, ImmutableSquare and, from that, Square . Note that, shorn of mutability, the IS-A relationship does hold -- an immutable square IS-A immutable rectangle: mutability is the only serious issue, so by factoring it out you can get some substantial code reuse (for all const uses -- ones that don't in fact use, or need, mutability). Introducing mutability along the inheritance is OK as long as no class invariants of the (immutable) base actually rely on the immutability characteristic; and of course an immutable object can be properly constructed from a const pointer or reference to the mutable version (presumably in a separate inline friend function to avoid giving the base class a dependency on the derived class;-) for reasonably-handy use. Edit : one comment understandably expresses qualms because "a mutabe is not an immutable": to reason about this, you need to understand what "IS-A" means ... and it does not mean the Korzybski -denied " is of identity": it means the LSP . Go through the rigmarole of constraints this means: covariance, contravariance, weaker-equal preconditions, stronger-equal postconditions, etc, as they apply to the const methods of the base (immutable) and derived (mutable) classes. You'll see that class invariants are the only issue, as I mentioned in the previous paragraph, so just avoid asserting immutability as a class invariant and you're in clover;-). Maybe it would help to name the base class NotNecessarilyMutableRectangle since it doesn't assert immutability as a class invariant; that very precise naming might be philosophically reassuring but perhaps a trifle un-handy in everyday coding.
