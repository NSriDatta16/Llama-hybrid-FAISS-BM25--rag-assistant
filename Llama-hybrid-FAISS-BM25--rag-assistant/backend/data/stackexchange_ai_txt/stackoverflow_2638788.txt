[site]: stackoverflow
[post_id]: 2638788
[parent_id]: 2638761
[tags]: 
I'd suggest you to use LinkedList instead of array if you want to remove its elements frequently enough. It's also easy to implement it with array (array->linked list->remove elements->array) but it's not very efficient: I think, the most efficient way (if you still want to work with arrays) is to create new array with only necessary elements from old array: Object[] filteredObjects = new Object[myObjects.length - elemToRemove.length]; int j = 0; for (int i = 0; i I didn't show shouldRemove . I think you should create a set of indexes instead of elemToRemove array (indexes are unique, so it's a preferred way in any case). Then shouldRemove can be changed to elemToRemove.contains(i) . Can suggest you one more way with Google Collections (I'm not sure that it's efficient but it looks elegant for me): for (int index : elemToRemove) { myObjects[i] = null; } myObjects = Collections2.filter(Arrays.asList(myObjects), new Predicate () { @Override public boolean apply(Object obj) { return obj!= null; } }).toArray();
