[site]: crossvalidated
[post_id]: 577059
[parent_id]: 
[tags]: 
Cross-validation on the HP filter for penalty selection

I'm looking for a bit more clarification on the selection of the $\lambda$ value for the Hodrick-Prescott Filter, aka HP filter. Which stems from a time-series in the form of $$y_t=g_t+\epsilon_t$$ with $\epsilon_t$ as the residuals, $g_t$ as the trend of the time series. Kauermann and Krivobokova (2011) show that this can HP filter can be expressed as $$\sum_t(y_t-g_t)^2+\lambda \sum_{t \ge3} \{(g_t-g_{t-1})-(g_{t-1}-g_{t-2}) \}^2$$ with $\lambda$ as a tunning parameter. Now Hodrick and Prescott (1997) suggests hat $\lambda=1600$ for quarterly data. Then Ravn and Uhlig (2002), stated that $\lambda_s=s^4*1600$ with $s=\frac{1}{4}$ for annual data and $s=3$ for monthly data. The HP filter can be used very easily in R using the "mFilter" package and the trend can be pulled from the result very easily as well given some $\lambda$ . However, I want to find the ideal $\lambda$ using cross-validation/general cross-validation, CV/GCV using this filter. I do realize that CV/GCV is not an optimal method to use as stated by Paige and Trindade (2010) and that a REML approach is better when it comes to penalized spline smoothing. However, I just want to use the CV/GCV method to compare certain $\lambda$ values with one another and I am wondering if anyone knows of an algorithm that would apply to this case. I have found several packages that allow me to use CV however all of them require a model to be built in this case all I have is the data broken down into trend and white noise. So how would I go about this using only the data I have available from the HP filter? Some sample code and different plots using the HP filter are provided below with HP1 representing the data more than HP, $\lambda=1600, 6.25$ respectively. Thank you install.packages("mFilter") require("mFilter") x=seq(1,12,1) y=c(7.246012, 7.261646, 7.270661, 7.284889, 7.295939, 7.309145, 7.311218, 7.312487, 7.299865, 7.295803, 7.307001, 7.296074) hpf=hpfilter(y, type="lambda", freq=1600) hpf1=hpfilter(y, type="lambda", freq=6.25) plot(x,y,type="l", col="blue", main="Log GDP quarterly", lwd=2) lines(x,hpf $trend, col="red") lines(x,hpf1$ trend, col="black") legend("bottomright", legend = c("y", "HP trend", "HP1 trend"),lty=c(1,1,1), col=c("blue","red","black"))
