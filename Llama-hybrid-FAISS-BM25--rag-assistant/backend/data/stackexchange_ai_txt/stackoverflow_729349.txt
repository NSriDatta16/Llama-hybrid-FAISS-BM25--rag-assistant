[site]: stackoverflow
[post_id]: 729349
[parent_id]: 710392
[tags]: 
Here is the solution I came to (thanks to Javashlook whose answer put me on track). It works, but it's most probably not a production-grade way of doing it. But better than a thousand words, here is the code, I'll let you judge by yourself. Let's take a look at the revised Car enum : public enum Car { NANO(CarEnumerationInitializer.getNANO()), MERCEDES( CarEnumerationInitializer.getMERCEDES()), FERRARI( CarEnumerationInitializer.getFERRARI()); public final String cost; public final String madeIn; Car(ICarProperties properties) { this.cost = properties.getCost(); this.madeIn = properties.getMadeIn(); } } And here are the "plumbling" classes : //Car's properties placeholder interface ... public interface ICarProperties { public String getMadeIn(); public String getCost(); } //... and its implementation public class CarProperties implements ICarProperties { public final String cost; public final String madeIn; public CarProperties(String cost, String madeIn) { this.cost = cost; this.madeIn = madeIn; } @Override public String getCost() { return this.cost; } @Override public String getMadeIn() { return this.madeIn; } } //Singleton that will be provide Car's properties, that will be defined at applicationContext loading. public final class CarEnumerationInitializer { private static CarEnumerationInitializer INSTANCE; private static ICarProperties NANO; private static ICarProperties MERCEDES; private static ICarProperties FERRARI; private CarEnumerationInitializer(ICarProperties nano, ICarProperties mercedes, ICarProperties ferrari) { CarEnumerationInitializer.NANO = nano; CarEnumerationInitializer.MERCEDES = mercedes; CarEnumerationInitializer.FERRARI = ferrari; } public static void forbidInvocationOnUnsetInitializer() { if (CarEnumerationInitializer.INSTANCE == null) { throw new IllegalStateException(CarEnumerationInitializer.class .getName() + " unset."); } } public static CarEnumerationInitializer build(CarProperties nano, CarProperties mercedes, CarProperties ferrari) { if (CarEnumerationInitializer.INSTANCE == null) { CarEnumerationInitializer.INSTANCE = new CarEnumerationInitializer( nano, mercedes, ferrari); } return CarEnumerationInitializer.INSTANCE; } public static ICarProperties getNANO() { forbidInvocationOnUnsetInitializer(); return NANO; } public static ICarProperties getMERCEDES() { forbidInvocationOnUnsetInitializer(); return MERCEDES; } public static ICarProperties getFERRARI() { forbidInvocationOnUnsetInitializer(); return FERRARI; } } Finally, the applicationContext definition : It works, but there is one major weakness : CarEnumerationInitializer MUST be instantiated BEFORE any reference is made to Car enumeration, otherwise CarProperties are null, meaning that Car's properties can't be set when Car is loaded (hence the IllegalStateException thrown, to at least make it crashes in a predictable and documentated way). carInitializer bean's property lazy-init set to an explicit false , to put emphasis on the need to load it as soon as possible. I would say it may be useful in a simple application, one where you can easely guess where a first call to Car will be made. For a larger one, it will probably be such a clutter that I didn't encourage you to use it. Hope this help, comments and vote (up and down) very welcome :) I'll wait for a few days to make this one the accepted answer, to let you react.
