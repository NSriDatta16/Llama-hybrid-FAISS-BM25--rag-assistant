[site]: stackoverflow
[post_id]: 2640069
[parent_id]: 
[tags]: 
Which cast am I using?

I'm trying to cast away const from an object but it doesn't work. But if I use old C-way of casting code compiles. So which casting I'm suppose to use to achieve this same effect? I wouldn't like to cast the old way. //file IntSet.h #include "stdafx.h" #pragma once /*Class representing set of integers*/ template class IntSet { private: T** myData_; std::size_t mySize_; std::size_t myIndex_; public: #pragma region ctor/dtor explicit IntSet(); virtual ~IntSet(); #pragma endregion #pragma region publicInterface IntSet makeUnion(const IntSet&)const; IntSet makeIntersection(const IntSet&)const; IntSet makeSymmetricDifference(const IntSet&)const; void insert(const T&); #pragma endregion }; //file IntSet_impl.h #include "StdAfx.h" #include "IntSet.h" #pragma region ctor/dtor template IntSet ::IntSet():myData_(nullptr), mySize_(0), myIndex_(0) { } IntSet ::~IntSet() { } #pragma endregion #pragma region publicInterface template void IntSet ::insert(const T& obj) { /*Check if we are initialized*/ if (mySize_ == 0) { mySize_ = 1; myData_ = new T*[mySize_]; } /*Check if we have place to insert obj in.*/ if (myIndex_ Thanks.
