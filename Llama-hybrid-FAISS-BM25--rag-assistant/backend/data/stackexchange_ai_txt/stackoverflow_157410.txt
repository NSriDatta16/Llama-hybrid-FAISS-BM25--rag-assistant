[site]: stackoverflow
[post_id]: 157410
[parent_id]: 151066
[tags]: 
There is another possible way to do this: Nested Layouts i don't remember where i found this code so apologies to the original author. create a file called nested_layouts.rb in your lib folder and include the following code: module NestedLayouts def render(options = nil, &block) if options if options[:layout].is_a?(Array) layouts = options.delete(:layout) options[:layout] = layouts.pop inner_layout = layouts.shift options[:text] = layouts.inject(render_to_string(options.merge({:layout=>inner_layout}))) do |output,layout| render_to_string(options.merge({:text => output, :layout => layout})) end end end super end end then, create your various layouts in the layouts folder, (for example 'admin.rhtml' and 'application.rhtml'). Now in your controllers add this just inside the class: include NestedLayouts And finally at the end of your actions do this: def show ... render :layout => ['admin','application'] end the order of the layouts in the array is important. The admin layout will be rendered inside the application layout wherever the 'yeild' is. this method can work really well depending on the design of the site and how the various elements are organized. for instance one of the included layouts could just contain a series of divs that contain the content that needs to be shown for a particular action, and the CSS on a higher layout could control where they are positioned.
