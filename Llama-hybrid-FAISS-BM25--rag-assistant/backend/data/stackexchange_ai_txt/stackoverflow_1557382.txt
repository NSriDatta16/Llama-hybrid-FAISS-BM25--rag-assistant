[site]: stackoverflow
[post_id]: 1557382
[parent_id]: 646833
[tags]: 
As per the final sentence of the AMF3 specification ( AMF 3.0 Spec at Adobe.com ): Also note that ByteArray uses a new set of implicit reference tables for objects, object traits and strings for each readObject and writeObject call. It appears that the intention with ByteArray.writeObject is to create a serialization which could be stored or recovered on a per-object basis. The NetConnection object's behavior is similar to what you had hoped for. When updating the string-references table, it is important to not add empty strings to the reference table. When maintaining the object-references table, you may be able to implement defensive programming as follows: the object-references table is constructed recursively and at some times contains objects for which the traits are not yet completely known. If the table indices are not allocated in advance, the numbering will be inconsistent across applications. An AMF3 decoder should not use the traits from a partially-constructed object -- such input should be flagged as erroneous. The strings-reference table is implemented at the encoder by 'tagging' in-memory string objects as they are serialized. Encoding two different string objects with the same content (matching strings) do not seem to be encoded with one string referencing the other. Both strings will be output and a string-by-reference will not be used. There may be a solution to your original question. If you have a number of objects all belonging to the same class, and you would like to store those objects all in one storage, I suggest the following: Create a "parent object" with references to all the objects you intend to store. Then use ByteArray.writeObject to persist that parent object. AMF will encode all of the referenced objects and will represent the traits of repeated object classes in an efficient way.
