[site]: stackoverflow
[post_id]: 4703247
[parent_id]: 4690886
[tags]: 
Consider the parallels between: typedef struct C { int i; }; extern struct P { int i; }; GCC 4.2.1 with no explicit warnings enabled ( gcc -c xxx.c ) says of the first: xxx.c:1: warning: useless storage class specifier in empty declaration xxx.c:2: warning: useless storage class specifier in empty declaration Note that they are only warnings; they are not an error because the standard allows the notation, though it does not do very much. In each case, the example simply declares a structure type, which can be used by the name struct C or struct P . The storage classes are irrelevant because no object is named. In C++, those declarations also declare types C and P (but that would also happen if the typedef or extern was not there); in C, those types ( C and P`) are not declared. In the C standard, typedef is treated as a storage class, like extern and static are storage classes. That means that the following code is legitimate: typedef struct C { int i; } name1; extern struct P { int i; } name2; It declares the same two structure types as before, but now the typedef declares an alias for struct C which is name1 , and the extern line states that another translation unit (TU) defines a variable called name2 of the type struct P . Neither is vacuous (except that the definitions are not used later in the 2-line TU shown). The C standard allows many weird things. For example: int unsigned typedef u; It's a perfectly valid - but totally abnormal - way of writing: typedef unsigned int u; There is a section in C99 ยง6.11.5 (under Future Language Directions) which says: 6.11.5 Storage-class specifiers The placement of a storage-class specifier other than at the beginning of the declaration specifiers in a declaration is an obsolescent feature. That makes my weird example in violation of ยง6.11.5. Summary The code reviewed is syntactically correct in C, both C89 and C99. It is also, AFAIK, syntactically valid in C++ - but it is even more pointless there than in C since struct C { int i; }; with no typedef introduces the type C (as well as struct C ). The code reviewed should not be accepted - it is reasonable to require it to be fixed. The correct fix might be to remove the storage class ( typedef ), or it might be to introduce a name as an alias for struct C . Since the code compiles without the alias, it is more likely correct to remove the storage class.
