[site]: stackoverflow
[post_id]: 1023872
[parent_id]: 1023719
[tags]: 
I'm using a sum result to which I'm adding the new members and subtracting the old ones. However in this way one may suffer accumulating floating point inaccuracies. Therefore I implement a "Deque" with a list. And whenever my Deque reallocates to a smaller size. I recalculate the sum at the same occasion. I'm also calculating the average up to point x including point x so there's at least one sample point to average. def getAvgValues(data, avgSampleTime): lastTime = 0 prevValsBuf = [] prevValsStart = 0 tot = 0 for t, v in data: avgStart = t - avgSampleTime # remove too old values while prevValsStart avgStart: break tot -= pv prevValsStart += 1 # add new item tot += v prevValsBuf.append((t, v)) # yield result numItems = len(prevValsBuf) - prevValsStart yield (t, tot / numItems) # clean prevVals if it's time if prevValsStart * 2 > len(prevValsBuf): prevValsBuf = prevValsBuf[prevValsStart:] prevValsStart = 0 # recalculate tot for not accumulating float precision error tot = sum(v for (t, v) in prevValsBuf)
