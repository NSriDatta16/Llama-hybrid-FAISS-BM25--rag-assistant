[site]: stackoverflow
[post_id]: 2555960
[parent_id]: 2555904
[tags]: 
Simplest, where adate is an instance of datetime.date : def previousmonth(adate): m = adate.month - 1 return m if m else 12 There's no real way in most Unix filesystems to determine when a file was created, as they just don't keep that information around. Maybe you want the "latest inode change time" (could be creation, could be some other inode change): import os, datetime def cmonth(filename): ts = os.stat(filename).st_ctime return datetime.date.fromtimestamp(ts).month Of course, this could mean that month in any year -- you sure, in both questions, you don't want the year as well as the month? That would be the .year attribute. Anyway, sticking with month only, as per your question, for a single directory (which is the letter of your question), to get all files you can use os.listdir (for a tree rooted in the directory you'd use os.walk instead). Then to keep only those with latest-inode-change in a given month: def fileswithcmonth(dirname, whatmonth): results = [] for f in os.listdir(dirname): fullname = os.path.join(dirname, f) if whatmonth == cmonth(fullname): results.append(fullname) return results You could code this as a list comprehension, but there's just too much code there for a listcomp to be elegant and concise. To get the "latest" time, you can either repeat the os.stat call (slower but probably simpler), or change cmonth to return the timestamp as well. Taking the simple route: def filetimestamp(fullname): return os.stat(fullname).st_ctime Now, the "most recent file" given a list files of files' full names (i.e. inc. path) is max(files, key=filetimestamp) Of course there are many degrees of freedom in how you put this all together, depending on your exact specs -- given that the specs don't appear to be necessarily precise or complete I've chosen to show the building blocks that you can easily tweak and put together towards your exact needs, rather than a full-blown solution that would likely solve a problem somewhat different from your actual one;-). Edit : since the OP clarified that they need both year and month, let's see what changes would be needed, using tuples ym for (year, month) in lieu of the bare month: def previousym(adate): y = adate.year m = adate.month - 1 return (y, m) if m else (y - 1, 12) import os, datetime def cym(filename): ts = os.stat(filename).st_ctime dt datetime.date.fromtimestamp(ts) return cym.year, cym.month def fileswithcym(dirname, whatym): results = [] for f in os.listdir(dirname): fullname = os.path.join(dirname, f) # if you need to avoid subdirs, uncomment the following line # if not os.path.isfile(fullname): continue if whatym == cym(fullname): results.append(fullname) return results Nothing deep or difficult, as you can see (I also added comments to show how to skip subdirectories if you're worried about those). And btw, if what you actually need is to walk a subtree, rather than just a directory, that change, too, is pretty localized: def fileswithcymintree(treeroot_dirname, whatym): results = [] for dp, dirs, files in os.walk(treeroot_dirname): for f in files: fullname = os.path.join(dp, f) if whatym == cym(fullname): results.append(fullname) return results
