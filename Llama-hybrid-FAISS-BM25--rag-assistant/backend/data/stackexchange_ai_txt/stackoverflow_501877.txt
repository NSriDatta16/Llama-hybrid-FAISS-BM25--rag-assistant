[site]: stackoverflow
[post_id]: 501877
[parent_id]: 500649
[tags]: 
I'm sorry that I don't have an answer to your larger problem of sending a signal after X seconds to a process, but it seems that all you want to do is timeout after X seconds of waiting for input, and if that's the case then I'd say you are looking for Kernel.select :D I've personally never used this, but after doing a google for "non-blocking gets", and subsequently exploring links, I found these two to be invaluable discussions: http://www.ruby-forum.com/topic/126795 (Discussion of multi-threaded gets) http://www.ruby-forum.com/topic/121404 (Explanation of Kernel.select in 2nd post) Here's a sample of how to use it. This will print out your prompt and wait for input... If there is no input after five seconds, then the program will end. If there is input, as soon as there is input it will spit it back out and end... Obviously you can modify this for your own purposes. def prompt STDOUT.write "> " STDOUT.flush end def amusing_messages [ "You must enter something!", "Why did you even start me if you just wanted to stare at me?", "Isn't there anything better you could be doing?", "Just terminate me already... this is getting old", "I'm waiting..."] end prompt loop do read_array, write_array, error_array = Kernel.select [STDIN], nil, nil, 5 if read_array.nil? puts amusing_messages[rand(amusing_messages.length)] else puts "Result is: #{read_array[0].read_nonblock(30)}" end prompt end It's probably not as elegant as you might like, but it definitely gets the job done without mucking around with threads. Unfortunately, this won't help you should you want something more robust (timer/sending a signal to the process), and sadly, I have no clue if this works in JRuby. Would love to know if it does though :)
