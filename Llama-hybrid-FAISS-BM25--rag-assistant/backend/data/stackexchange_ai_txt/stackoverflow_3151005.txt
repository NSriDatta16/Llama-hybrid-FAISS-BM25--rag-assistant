[site]: stackoverflow
[post_id]: 3151005
[parent_id]: 3150460
[tags]: 
It seems that the code from the question works OK: compositions = {1 => {'af sum' => 100.0, 'mass' => 200.0, 'composition' => {1 => {'af' => 5.0, 'mf' => 6.0}, 2 => {'af' => 7.0, 'mf' => 8.0}, 3 => {'af' => 9.0, 'mf' => 16.0}}}} #=> {1=>{"af sum"=>100.0, "mass"=>200.0, "composition"=>{1=>{"af"=>5.0, "mf"=>6.0}, 2=>{"af"=>7.0, "mf"=>8.0}, 3=>{"af"=>9.0, "mf"=>16.0}}}} compositions.each_pair do |element,params| params['composition'].each_pair do |item,data| data['af'] /= params['af sum'] data['mf'] /= params['mass'] end end #=> {1=>{"af sum"=>100.0, "mass"=>200.0, "composition"=>{1=>{"af"=>0.05, "mf"=>0.03}, 2=>{"af"=>0.07, "mf"=>0.04}, 3=>{"af"=>0.09, "mf"=>0.08}}}} But the example structure is pretty much guessed from the code, OP should post an example he is working with so we could actually make some progress. Edit: When you perform + method on an integer, a new object is returned as a result. That object is assigned to v in your first example, but not assigned back to the hash, so it is not preserved. In your second example, you assign it back to the hash. However, if you work with mutating methods, you alter the very objects in-place, so then you don't need to reassign them to the hash. For example: {1 => 'foo', 2 => 'bar'}.each{|k,v| v.swapcase!} #=> {1=>"FOO", 2=>"BAR"} but {1 => 'foo', 2 => 'bar'}.each{|k,v| v = 'baz'} #=> {1=>"foo", 2=>"bar"} Edit 2: I think you have problem understanding what k and v in the examples are. They are just local variables in the block, they start by referencing whatever is in the hash, but what do they reference can be changed during course of a block just like with any other variable. That change won't reflect to the hash. You need to alter the very object , not the reference to it, to actually change it. Take a look at this, even simpler example, no hashes, blocks mumbo-jumbo: a = 5 b = a b += 1 a # => 5 b # => 6 It's as simple as that.
