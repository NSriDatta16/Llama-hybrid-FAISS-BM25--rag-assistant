[site]: stackoverflow
[post_id]: 4151251
[parent_id]: 4151128
[tags]: 
Numpy matrices are strictly 2-dimensional, while numpy arrays (ndarrays) are N-dimensional. Matrix objects are a subclass of ndarray, so they inherit all the attributes and methods of ndarrays. The main advantage of numpy matrices is that they provide a convenient notation for matrix multiplication: if a and b are matrices, then a*b is their matrix product. import numpy as np a = np.mat('4 3; 2 1') b = np.mat('1 2; 3 4') print(a) # [[4 3] # [2 1]] print(b) # [[1 2] # [3 4]] print(a*b) # [[13 20] # [ 5 8]] On the other hand, as of Python 3.5, NumPy supports infix matrix multiplication using the @ operator, so you can achieve the same convenience of matrix multiplication with ndarrays in Python >= 3.5. import numpy as np a = np.array([[4, 3], [2, 1]]) b = np.array([[1, 2], [3, 4]]) print(a@b) # [[13 20] # [ 5 8]] Both matrix objects and ndarrays have .T to return the transpose, but matrix objects also have .H for the conjugate transpose, and .I for the inverse. In contrast, numpy arrays consistently abide by the rule that operations are applied element-wise (except for the new @ operator). Thus, if a and b are numpy arrays, then a*b is the array formed by multiplying the components element-wise: c = np.array([[4, 3], [2, 1]]) d = np.array([[1, 2], [3, 4]]) print(c*d) # [[4 6] # [6 4]] To obtain the result of matrix multiplication, you use np.dot (or @ in Python >= 3.5, as shown above): print(np.dot(c,d)) # [[13 20] # [ 5 8]] The ** operator also behaves differently: print(a**2) # [[22 15] # [10 7]] print(c**2) # [[16 9] # [ 4 1]] Since a is a matrix, a**2 returns the matrix product a*a . Since c is an ndarray, c**2 returns an ndarray with each component squared element-wise. There are other technical differences between matrix objects and ndarrays (having to do with np.ravel , item selection and sequence behavior). The main advantage of numpy arrays is that they are more general than 2-dimensional matrices . What happens when you want a 3-dimensional array? Then you have to use an ndarray, not a matrix object. Thus, learning to use matrix objects is more work -- you have to learn matrix object operations, and ndarray operations. Writing a program that mixes both matrices and arrays makes your life difficult because you have to keep track of what type of object your variables are, lest multiplication return something you don't expect. In contrast, if you stick solely with ndarrays, then you can do everything matrix objects can do, and more, except with slightly different functions/notation. If you are willing to give up the visual appeal of NumPy matrix product notation (which can be achieved almost as elegantly with ndarrays in Python >= 3.5), then I think NumPy arrays are definitely the way to go. PS. Of course, you really don't have to choose one at the expense of the other, since np.asmatrix and np.asarray allow you to convert one to the other (as long as the array is 2-dimensional). There is a synopsis of the differences between NumPy arrays vs NumPy matrix es here .
