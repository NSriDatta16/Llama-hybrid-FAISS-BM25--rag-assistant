[site]: stackoverflow
[post_id]: 4622458
[parent_id]: 4622355
[tags]: 
Sure IFS=, echo $'one\t\tthree' | tr \\11 , | ( read one two three printf ' ' "$one" "$two" "$three"; printf '\n' ) I've rearranged the example just a bit, but only to make it work in any Posix shell. Update: Yeah, it seems that white space is special, at least if it's in IFS. See the second half of this paragraph from bash(1): The shell treats each character of IFS as a delimiter, and splits the results of the other expansions into words on these characters. If IFS is unset, or its value is exactly , the default, then any sequence of IFS characters serves to delimit words. If IFS has a value other than the default, then sequences of the whitespace characters space and tab are ignored at the beginning and end of the word, as long as the whitespace character is in the value of IFS (an IFS whitespace character). Any character in IFS that is not IFS white- space, along with any adjacent IFS whitespace characters, delimits a field. A sequence of IFS whitespace characters is also treated as a delimiter. If the value of IFS is null, no word splitting occurs.
