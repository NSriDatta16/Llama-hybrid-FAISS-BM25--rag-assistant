[site]: stackoverflow
[post_id]: 3430855
[parent_id]: 3430736
[tags]: 
At the deepest level, it means instruction sets differ. Putting a particular sequence of bits through an x86 processor will get you completely different results than if you put the same set of bits through, say, an ARM processor. Higher-level languages "overcome" this because computers all do pretty much the same things, just in different ways. ARM has ways to add two numbers together just like x86 does, it has ways to load data from RAM into registers (and vice-versa) just like x86 does, etc.. All high-level constructs can eventually be reduced to a fundamental set of operations that can be performed by all general-purpose machines (though some constructs may come out more efficient on some CPUs than on others). This is what compilers do. They parse the high-level language and, one way or another, reduce it to the machine language of the target system. Often only select bits of the compiler need to be written fresh for a new CPU. Some compilers (GCC is an excellent example) are built in layers that vastly simplify this work. A single highly-skilled developer familiar with compilers and the target platform could produce a rudimentary port fairly easily. Above the level of simply reducing constructs to the native machine language, there are, of course, issues like input/output, filesystem access, etc.. These are also usually handled in layers, often with only the lowest levels -- drivers -- being rewritten for a new platform, maintaining a consistent interface to the upper levels. And even the drivers can often be shared, in whole or in part, across machine types! x86 platforms aren't the only ones that have had, for example, a PCI bus. And even where the bus is different, the devices hooked up to them often end up being the same. Linux shares a number of device drivers across several machine types with little or no change. The compiler handles the details of translating to machine code and the more inner layers of the kernel try to abstract away what other behavioral differences they can, the driver writer just has to stick to the established interfaces. Past this, you reach questions of whether, within a given platform, any particular system has particular optional devices (or categories of devices). For example, it would be silly for most servers to have 3D accelerators. Some systems might have a hardware random number generator, some might not. Some may not have fixed storage. Unqualified, however, "machine dependence" isn't usually addressing this level of dependence.
