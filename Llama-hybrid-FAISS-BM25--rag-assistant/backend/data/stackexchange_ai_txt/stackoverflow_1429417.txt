[site]: stackoverflow
[post_id]: 1429417
[parent_id]: 1429162
[tags]: 
AFAIK there is litte difference between (int)datarow["Index"] and ConvertTo.Int32(datarow["Index"]) . However there is a big difference if you use stream mode data readers: int orderIndex = ; using (OdbcDataReader rdr = cmd.ExecuteReader(CommandBehavior.SequentialAccess)) { int Index = rdr.GetInt32(orderIndex); } The SeqentialAccess command behavior is the fastes way to process SQL results, because it does eliminate extra caching needed for random access. A second notice is that is seems you're using Data sets. Data sets are easy to use, but they are very very far from what anyone can call 'fast'. With data sets you are basically running an in memory storage engine (I think is based on Rushmore ). If you want to squeeze every CPU cycle and all the 1s from every bit of RAM, then you'll have to use leaner components (eg. raw arrays of structs instead of Datasets and DataTables). When you compare apples to apples CLR can hold its ground against native code. IL code can be nativized at deployment time with NGEN . Typical CLR overheads like bounds checks can be avoided . GC pre-emption 'pause' happens only if you're careless with your allocation (just because you have GC doesn't mean you should allocate left and right). And CLR actually has some aces up its sleve when it comes to memory layout since it can rearange object in memory to fit access patterns and improve TLB and L2 locality. BTW, if you think the debate 'C++ can run circles around C#' is something new, I remember a time when C could run circles around C++ ('virtual calls are impossibly slow' they were saying) and I hear there was a time assembly was running circles around C.
