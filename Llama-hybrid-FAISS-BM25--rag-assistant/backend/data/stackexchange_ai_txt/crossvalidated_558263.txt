[site]: crossvalidated
[post_id]: 558263
[parent_id]: 541402
[tags]: 
There is a universal algorithm. It doesn't matter whether the probability is irrational or not. It suffices to implement a procedure to output either $0$ or $1$ that will (a) almost surely terminate and (b) output $1$ with a probability $\phi,$ where $\phi$ is any number in the interval $[0,1]$ (rational or irrational). The following description relies on an arbitrarily long sequence of iid Bernoulli $(1/2)$ variables $X_1,X_2,X_3,\ldots.$ Procedure f(phi): for i in 1, 2, 3, ... if phi >= 1/2 then if X[i]==0 return(1) else return(f(2*phi-1)) else if X[i]==0 return(0) else return(f(2*phi)) It is manifestly simple, using only (a) comparison to $1/2,$ (b) multiplication by $2,$ and (c) subtraction of $1.$ This algorithm randomly walks the binary tree determined by binary expansions of real numbers in the interval $[0,1].$ It outputs $1$ as soon as it enters a branch all of whose ultimate values will be less than $\phi$ and it outputs $0$ as soon as it enters any branch all of whose ultimate values will be $\phi$ or greater. You can easily establish that the chance of outputting $1$ is no less than any finite binary number less than $\phi$ and is no greater than any finite binary number greater than $\phi,$ demonstrating $f$ implements a Bernoulli $(\phi)$ variable. It is also straightforward to show that on any call, $f$ has a $1/2$ chance of terminating, whence (a) it will terminate almost surely (b) with an expected number of calls equal to $1+1/2+1/2^2+\cdots = 2.$ Here is an R implementation. sample.int(2,1) implements the sequence of $X_i:$ it returns 1 and 2 with equal probabilities. f = 1/2)) { if (isTRUE(X == 1)) return(1) else return(f(2*phi - 1)) } else { if (isTRUE(X == 1)) return(0) else return(f(2*phi)) } } I applied this two thousand times to each of 128 randomly-generated floating point numbers in $[0,1],$ keeping track of the calls to $f$ and comparing the mean value (which estimates $\phi$ ) to $\phi$ itself with a Z score. This required generating a quarter million Bernoulli $(\phi)$ values (for various $\phi$ ). On a single core it took 2.5 seconds, showing it is practicable and reasonably efficient. These graphics summarize the results. Most Z scores are between $-2$ and $2,$ as expected of a correct procedure. All averages are close to $2,$ as claimed, and do not depend on the value of $\phi,$ as indicated by the near-horizontal Loess smooth. It is rare, in any of these simulations, for any call to $f$ to nest more deeply than $15$ in the recursion stack. In other words, there is essentially no risk that any one call to $f$ will take an inordinately long time. (This can be proven by examining the hypergeometric distribution of the number of calls to $f.$ ) R code This is the full (reproducible) simulation study. # # The algorithm. It requires 0 = 1/2)) { if (isTRUE(X == 1)) return(1) else return(f(2*phi - 1)) } else { if (isTRUE(X == 1)) return(0) else return(f(2*phi)) } } # # Simulation study. # set.seed(17) replications MAX) MAX
