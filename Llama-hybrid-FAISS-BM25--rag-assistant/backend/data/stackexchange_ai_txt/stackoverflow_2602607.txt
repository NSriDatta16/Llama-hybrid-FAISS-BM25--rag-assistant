[site]: stackoverflow
[post_id]: 2602607
[parent_id]: 
[tags]: 
How to handle IP Address rerouting with .NET Remoting

I have a process within a network that wants to talk to a service on another network. So I have two computers: Client Server 172.X.X.X reroute-> 172.X.X.X to 10.0.1.X With this setup, I can call the Server with the 172.X.X.X ip address and it maps to the 10.0.1.X address and talks fine. However, when I try to use .NET Remoting and communicate, I get an exception: System.Net.Sockets.SocketException: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond 10.0.1.240:8196 Server stack trace: at System.Net.Sockets.Socket.DoConnect(EndPoint endPointSnapshot, SocketAddress socketAddress) at System.Net.Sockets.Socket.Connect(EndPoint remoteEP) at System.Runtime.Remoting.Channels.RemoteConnection.CreateNewSocket(EndPoint ipEndPoint) at System.Runtime.Remoting.Channels.RemoteConnection.CreateNewSocket() at System.Runtime.Remoting.Channels.RemoteConnection.GetSocket() at System.Runtime.Remoting.Channels.SocketCache.GetSocket(String machinePortAndSid, Boolean openNew) at System.Runtime.Remoting.Channels.Tcp.TcpClientTransportSink.SendRequestWithRetry(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream) at System.Runtime.Remoting.Channels.Tcp.TcpClientTransportSink.ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream) at System.Runtime.Remoting.Channels.BinaryClientFormatterSink.SyncProcessMessage(IMessage msg) Exception rethrown at [0]: at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg) at System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData& msgData, Int32 type) at Aloha.Automation.IBackOfHouseFileServer.get_SecurityKey() at Aloha.Automation.Presentation.ViewModel.TerminalViewModel.RefreshSecurityKeyFromTerminal() in c:\BuildAgent\work\78a60abb233492e7\Source\Aloha.Automation.Presentation\ViewModel\TerminalViewModel.cs:line 167 at Aloha.Automation.Presentation.ViewModel.TerminalViewModel.Refresh() in c:\BuildAgent\work\78a60abb233492e7\Source\Aloha.Automation.Presentation\ViewModel\TerminalViewModel.cs:line 225 at Aloha.Automation.Presentation.ViewModel.TerminalViewModel.LabConnectorViewModelOnPropertyChanged(Object sender, PropertyChangedEventArgs args) in c:\BuildAgent\work\78a60abb233492e7\Source\Aloha.Automation.Presentation\ViewModel\TerminalViewModel.cs:line 154 at System.ComponentModel.PropertyChangedEventHandler.Invoke(Object sender, PropertyChangedEventArgs e) at Caliburn.Core.PropertyChangedBase.RaisePropertyChangedEventImmediately(String propertyName) in c:\Code\caliburn\branches\v1.1\src\Caliburn.Core\PropertyChangedBase.cs:line 49 at Aloha.Automation.Presentation.ViewModel.ExtendedPresenter.<>c__DisplayClass1. b__0() in c:\BuildAgent\work\78a60abb233492e7\Source\Aloha.Automation.Presentation\ViewModel\DetailsViewModel.cs:line 42 --- End of inner exception stack trace --- at System.RuntimeMethodHandle._InvokeMethodFast(Object target, Object[] arguments, SignatureStruct& sig, MethodAttributes methodAttributes, RuntimeTypeHandle typeOwner) at System.RuntimeMethodHandle.InvokeMethodFast(Object target, Object[] arguments, Signature sig, MethodAttributes methodAttributes, RuntimeTypeHandle typeOwner) at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks) at System.Delegate.DynamicInvokeImpl(Object[] args) at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Boolean isSingleParameter) at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Boolean isSingleParameter, Delegate catchHandler)]]> How should I handle this situation? Do I need to switch remoting technologies or roll my own?
