[site]: stackoverflow
[post_id]: 5366419
[parent_id]: 5255150
[tags]: 
The dynamic field implementation depends upon following factors: Ability to dynamically add attributes Ability to support new data types Ability to retrieve the dynamic attributes without additional query Ability to access dynamic attributes like regular attributes Ability query the objects based on dynamic attributes. (eg: find the users with skiing hobbies) Typically, a solution doesn't address all the requirements. Mike's solution addresses 1, and 5 elegantly. You should use his solution if 1 & 5 are important for you. Here is a long solution that addresses 1,2,3, 4 and 5 Update the users table Add a text field called meta to the users table. Update your User model class User Adding a new meta field u = User.first u.meta[:hobbies] = "skiing" u.save Accessing a meta field puts "hobbies=#{u.meta[:hobbies]}" Iterating the meta fields u.meta.each do |k, v| puts "#{k}=#{v}" end To address the 5th requirement you need to use Solr Or Sphinx full text search engines. They are efficient than relying on DB for LIKE queries. Here is one approach if you use Solr through Sunspot gem. class User searchable do integer(:user_id, :using => :id) meta.each do |key, value| t = solr_type(value) send(t, key.to_sym) {value} if t end end def solr_type(value) return nil if value.nil? return :integer if value.is_a?(Fixnum) return :float if value.is_a?(Float) return :string if value.is_a?(String) return :date if value.is_a?(Date) return :time if value.is_a?(Time) end def similar_users(*args) keys = args.empty? ? meta.keys : [args].flatten.compact User.search do without(:user_id, id) any_of do keys.each do |key| value = meta[key] with(key, value) if value end and end end end Looking up similar users u = User.first u.similar_users # matching any one of the meta fields u.similar_users :hobbies # with matching hobbies u.similar_users :hobbies, :city # with matching hobbies or the same city The performance gain here is significant.
