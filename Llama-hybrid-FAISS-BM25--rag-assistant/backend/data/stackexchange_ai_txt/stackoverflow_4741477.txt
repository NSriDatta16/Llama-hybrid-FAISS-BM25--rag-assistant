[site]: stackoverflow
[post_id]: 4741477
[parent_id]: 
[tags]: 
Java Drag and Drop with JTree and modal dialog

I would like to implement drag and drop on a file-system backed JTree to allow users to easily move and copy files. I would like to show a confirmation dialog when users attempt to move or copy a file to a directory that already contains a file with the same name. There is an apparent flaw with java's implementation of drag and drop in this regard (or perhaps a flaw in my understanding of it). The showing of a modal dialog during a dnd causes my TransferHandler's exportDone method to be called while I am still confirming the drop inside of the importData method. I have attached a sample application that illustrates the problem. It doesnt rely on a file system-backed JTree and it requires confirmation for every drop for simplicity. If you drag n drop 1 element, you will notice that it is copied to its destination but not removed from its original location. If you drag n drop 2 elements you can clearly see that exportDone is called before importData has finished. How can I implement reliable drag n drop in Java with user confirmation for each element when necessary? import java.awt.*; import java.awt.datatransfer.*; import java.awt.dnd.*; import java.util.*; import java.util.List; import javax.swing.*; import javax.swing.tree.*; public class TreeDragAndDrop { private JScrollPane getContent() { JTree tree = new JTree(); tree.setDragEnabled(true); tree.setDropMode(DropMode.ON_OR_INSERT); tree.setTransferHandler(new TreeTransferHandler()); tree.getSelectionModel().setSelectionMode(TreeSelectionModel.CONTIGUOUS_TREE_SELECTION); expandTree(tree); return new JScrollPane(tree); } private void expandTree(JTree tree) { DefaultMutableTreeNode root = (DefaultMutableTreeNode) tree.getModel().getRoot(); Enumeration e = root.breadthFirstEnumeration(); while (e.hasMoreElements()) { DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.nextElement(); if (node.isLeaf()) continue; int row = tree.getRowForPath(new TreePath(node.getPath())); tree.expandRow(row); } } public static void main(String[] args) { JFrame f = new JFrame(); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.add(new TreeDragAndDrop().getContent()); f.setSize(400, 400); f.setLocation(200, 200); f.setVisible(true); } } class TreeTransferHandler extends TransferHandler { DataFlavor nodesFlavor; DataFlavor[] flavors = new DataFlavor[1]; DefaultMutableTreeNode[] nodesToRemove; public TreeTransferHandler() { try { String mimeType = DataFlavor.javaJVMLocalObjectMimeType + ";class=\"" + javax.swing.tree.DefaultMutableTreeNode[].class.getName() + "\""; nodesFlavor = new DataFlavor(mimeType); flavors[0] = nodesFlavor; } catch (ClassNotFoundException e) { System.out.println("ClassNotFound: " + e.getMessage()); } } public boolean canImport(TransferHandler.TransferSupport support) { if (!support.isDrop()) { return false; } support.setShowDropLocation(true); if (!support.isDataFlavorSupported(nodesFlavor)) { return false; } // Do not allow a drop on the drag source selections. JTree.DropLocation dl = (JTree.DropLocation) support.getDropLocation(); JTree tree = (JTree) support.getComponent(); int dropRow = tree.getRowForPath(dl.getPath()); int[] selRows = tree.getSelectionRows(); for (int i = 0; i 0 && target.getLevel() 0 && selRows.length == 1) return false; // first may have children. for (int i = 1; i selRows.length - 1) { // Not all children of first are selected. return false; } } } return true; } protected Transferable createTransferable(JComponent c) { JTree tree = (JTree) c; TreePath[] paths = tree.getSelectionPaths(); if (paths != null) { // Make up a node array of copies for transfer and // another for/of the nodes that will be removed in // exportDone after a successful drop. List copies = new ArrayList (); List toRemove = new ArrayList (); DefaultMutableTreeNode node = (DefaultMutableTreeNode) paths[0].getLastPathComponent(); DefaultMutableTreeNode copy = copy(node); copies.add(copy); toRemove.add(node); for (int i = 1; i node.getLevel()) { // child node copy.add(copy(next)); // node already contains child } else { // sibling copies.add(copy(next)); toRemove.add(next); } } DefaultMutableTreeNode[] nodes = copies.toArray(new DefaultMutableTreeNode[copies.size()]); nodesToRemove = toRemove.toArray(new DefaultMutableTreeNode[toRemove.size()]); return new NodesTransferable(nodes); } return null; } /** Defensive copy used in createTransferable. */ private DefaultMutableTreeNode copy(TreeNode node) { return new DefaultMutableTreeNode(node); } protected void exportDone(JComponent source, Transferable data, int action) { System.out.println("exportDone started"); if ((action & MOVE) == MOVE) { JTree tree = (JTree) source; DefaultTreeModel model = (DefaultTreeModel) tree.getModel(); // Remove nodes saved in nodesToRemove in createTransferable. for (int i = 0; i
