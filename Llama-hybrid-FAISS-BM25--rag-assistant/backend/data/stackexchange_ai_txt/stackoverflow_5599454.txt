[site]: stackoverflow
[post_id]: 5599454
[parent_id]: 4097126
[tags]: 
If I understand the motivation for the question you want to avoid the possibility that two concurrent transactions could both execute the sub query to get the top N rows to process then proceed to update the same rows? In that case I'd use this approach. ;WITH cte As ( SELECT TOP(@numberToProcess) * FROM ToBeProcessed WITH(UPDLOCK,ROWLOCK,READPAST) WHERE ToBeProcessed.IsBeingProcessed = 0 ORDER BY ToBeProcessed.Id, ToBeProcessed.Priority DESC ) UPDATE cte SET IsBeingProcessed = 1 OUTPUT INSERTED.Id INTO #IdsToProcess I was a bit uncertain earlier whether SQL Server would take U locks when processing your version with the sub query thus blocking two concurrent transactions from reading the same TOP N rows. This does not appear to be the case. Test Table CREATE TABLE JobsToProcess ( priority INT IDENTITY(1,1), isprocessed BIT , number INT ) INSERT INTO JobsToProcess SELECT TOP (1000000) 0,0 FROM master..spt_values v1, master..spt_values v2 Test Script (Run in 2 concurrent SSMS sessions) BEGIN TRY DECLARE @FinishedMessage VARBINARY (128) = CAST('TestFinished' AS VARBINARY (128)) DECLARE @SynchMessage VARBINARY (128) = CAST('TestSynchronising' AS VARBINARY (128)) SET CONTEXT_INFO @SynchMessage DECLARE @OtherSpid int WHILE(@OtherSpid IS NULL) SELECT @OtherSpid=spid FROM sys.sysprocesses WHERE context_info=@SynchMessage and spid<>@@SPID SELECT @OtherSpid DECLARE @increment INT = @@spid DECLARE @number INT = @increment WHILE (@number = @increment AND NOT EXISTS(SELECT * FROM sys.sysprocesses WHERE context_info=@FinishedMessage)) UPDATE JobsToProcess SET @number=number +=@increment,isprocessed=1 WHERE priority = (SELECT TOP 1 priority FROM JobsToProcess WHERE isprocessed=0 ORDER BY priority DESC) SELECT * FROM JobsToProcess WHERE number not in (0,@OtherSpid,@@spid) SET CONTEXT_INFO @FinishedMessage END TRY BEGIN CATCH SET CONTEXT_INFO @FinishedMessage SELECT ERROR_MESSAGE(), ERROR_NUMBER() END CATCH Almost immediately execution stops as both concurrent transactions update the same row so the S locks taken whilst identifying the TOP 1 priority must get released before it aquires a U lock then the 2 transactions proceed to get the row U and X lock in sequence. If a CI is added ALTER TABLE JobsToProcess ADD PRIMARY KEY CLUSTERED (priority) then deadlock occurs almost immediately instead as in this case the row S lock doesn't get released, one transaction aquires a U lock on the row and waits to convert it to an X lock and the other transaction is still waiting to convert its S lock to a U lock. If the query above is changed to use MIN rather than TOP WHERE priority = (SELECT MIN(priority) FROM JobsToProcess WHERE isprocessed=0 ) Then SQL Server manages to completely eliminate the sub query from the plan and takes U locks all the way.
