[site]: stackoverflow
[post_id]: 652359
[parent_id]: 652311
[tags]: 
A faster way to iterate a collection is to take an array copy of it. This can be iterated forward and backwards without creating an object or even a method call. The downside is you need to update it as well as your collection whenever it changes. In the following example, it takes an average of 1,208 ns to iterate over 1000 element either forward or backward. import java.util.Comparator; import java.util.Random; import java.util.NavigableSet; import java.util.TreeSet; /* Average time for iteration of 1000 elements was 1,208 ns */ public class Main { public static void main(String... args) { doPerfTest(true); doPerfTest(false); } private static void doPerfTest(boolean warmup) { NavigableSet set = new TreeSet (new MyCompataror()); Random random = new Random(); for (int i = 0; i = 0; j--) { MyData md = myDatas[j]; } } long time = System.nanoTime() - start; if (!warmup) System.out.printf("Average time for iteration of 1000 elements was %,d ns", time / runs); } static class MyCompataror implements Comparator { public int compare(MyData o1, MyData o2) { int cmp = o1.text.compareTo(o2.text); if (cmp != 0) return cmp; return o1.value > o2.value ? +1 : o1.value Now replace the main loop with and the average time becomes 20,493. // forward iteration for(Iterator it = set.iterator(); it.hasNext();) { MyData md = it.next(); } // reverse iteration for(Iterator it = set.descendingIterator(); it.hasNext();) { MyData md = it.next(); } Now lets compare this with taking a copy every time (which I have stated is not as optimal as taking a copy only when changed), the time drops to 15,134 ns! So using NavigableSet could be the slowest of the three options discussed.
