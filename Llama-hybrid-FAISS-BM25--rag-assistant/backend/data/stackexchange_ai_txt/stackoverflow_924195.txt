[site]: stackoverflow
[post_id]: 924195
[parent_id]: 924121
[tags]: 
Firstly, it is important to realize the problems that Kanban in software development tries to solve: Multi-tasking / Overload of work . Kanban addresses these by its Just-in-time and Queue systems. There is sufficient in the queue to keep everyone busy, but not overloaded (this comes with practice with estimation and efficient velocity monitoring). And JIT ensures that people do not have to multi-task and hence loose productivity. Unpredictable downstream releases . If you work in a large software organization, the piece you are developing might just be one in a large juxtaposition of software. Hence, there might be downstream teams that might wait for your feature. Kanban's queue system along with its time-boxed delivery schedules ensure that there is a certain amount of predictability in the releases. Mostly, other agile practices also attempt to solve similar problems with different techniques. large complex environments with dependencies on waterfall projects This makes it hard if you have a dependency on a project that does not follow agile as then your input queue will not be predictable. If a non-agile project depends on you, the problem might be lesser - but you might end up producing more than can be consumed ('muda' in lean terminology). So, ideally you would want all dependant projects at least following some agile practices, if not kanban itself. A nice article on Kanban, Flow and Cadence can be found here .
