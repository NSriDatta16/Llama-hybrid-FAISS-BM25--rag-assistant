[site]: stackoverflow
[post_id]: 2461323
[parent_id]: 
[tags]: 
collision with moving objects

I have tried to write a collision with the moving "floats" but did not succeed. Is something maybe in the wrong place of the "collision" code? // // FruitsView.m // #import "FruitsView.h" #import "Constants.h" #import "Utilities.h" #define kFloat1Speed 0.15 #define kFloat2Speed 0.3 #define kFloat3Speed 0.2 @interface FruitsView (Private) - (void) stopTimer; @end @implementation FruitsView @synthesize apple, float1, float2, float3, posFloat1, posFloat2, posFloat3; -(void)onTimer { float1.center = CGPointMake(float1.center.x+posFloat1.x,float1.cen ter.y+posFloat1.y); if(float1.center.x > 380 || float1.center.x 100 || float1.center.y 380 || float2.center.x 150 || float2.center.y 380 || float3.center.x 100 || float3.center.y float1.center.y) { posApple.y = -posApple.y; } } if(CGRectIntersectsRect(apple.frame,float2.frame)) { if(apple.center.y > float2.center.y) { posFloat2.y = -posFloat2.y; } } if(CGRectIntersectsRect(apple.frame,float3.frame)) { if(apple.center.y > float3.center.y) { posFloat3.y = -posFloat3.y; } } } #pragma mark Initialisation/destruction - (void)awakeFromNib { [NSTimer scheduledTimerWithTimeInterval:0.0001 target:self selector:@selector(onTimer) userInfo:nil repeats:YES]; posFloat1 = CGPointMake(kFloat1Speed, 0); posFloat2 = CGPointMake(kFloat2Speed, 0); posFloat3 = CGPointMake(kFloat3Speed, 0); timer = nil; modeLock = lockNotYetChosen; defaultSize = self.bounds.size.width; modal = self.tag; [[UIAccelerometer sharedAccelerometer] setDelegate:self]; [UIView beginAnimations:nil context:nil]; [UIView setAnimationRepeatCount:1]; eadbea.transform = CGAffineTransformMakeScale(0.5,0.5); [UIView commitAnimations]; [UIView beginAnimations:nil context:nil]; [UIView setAnimationRepeatCount:1]; apple.transform = CGAffineTransformMakeScale(0.5,0.5); [UIView commitAnimations]; } #pragma mark Background animation processing - (void) startTimer { if (!timer) { timer = [[NSTimer scheduledTimerWithTimeInterval:1.0/60.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES] retain]; } } - (void) stopTimer { [timer invalidate]; [timer release]; timer = nil; } - (void) check:(CGPoint*)position delta:(CGSize*)delta halfSize:(CGSize)halfSize forBouncingAgainst:(CGSize)containerSize { if ((position->x - halfSize.width) width = fabsf(delta->width)*BOUNCE_DAMPING; position->x = halfSize.width; } if ((position->x + halfSize.width)>containerSize.width) { delta->width = fabsf(delta->width)*-BOUNCE_DAMPING; position->x = containerSize.width - halfSize.width; } if ((position->y - halfSize.height) height = fabsf(delta->height)*BOUNCE_DAMPING; position->y = halfSize.height; } if ((position->y + halfSize.height)>containerSize.height) { delta->height = fabsf(delta->height)*-BOUNCE_DAMPING; position->y = containerSize.height - halfSize.height; } } - (void) timerTick: (NSTimer*)timer { dragDelta = CGSizeScale(dragDelta, INERTIAL_DAMPING); if ((fabsf(dragDelta.width)>DELTA_ZERO_THRESHOLD) || (fabsf(dragDelta.height)>DELTA_ZERO_THRESHOLD)) { CGPoint ctr = CGPointApplyDelta(self.center, dragDelta); CGSize halfSize = CGSizeMake(self.bounds.size.width/4, self.bounds.size.height/4); [self check:&ctr delta:&dragDelta halfSize:halfSize forBouncingAgainst:self.superview.bounds.size]; self.center = ctr; } else { [self stopTimer]; } } #pragma mark Input Handling - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { NSSet* allTouches = [event touchesForView:self]; if ([allTouches count]==1) { if (modeLock>lockNotYetChosen) return; UITouch* anyTouch = [touches anyObject]; lastMove = anyTouch.timestamp; CGPoint now = [anyTouch locationInView: self.superview]; CGPoint then = [anyTouch previousLocationInView: self.superview]; dragDelta = CGPointDelta(now, then); self.center = CGPointApplyDelta(self.center, dragDelta); [self stopTimer]; } } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { NSSet* allTouches = [event touchesForView:self]; if ([touches count]==[allTouches count]) { modeLock = lockNotYetChosen; if ((event.timestamp - lastMove) > MOVEMENT_PAUSE_THRESHOLD) return; if ((fabsf(dragDelta.width)>INERTIA_THRESHOLD) || (fabsf(dragDelta.height)>INERTIA_THRESHOLD)) { [self startTimer]; } } } - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event { modeLock = lockNotYetChosen; [self stopTimer]; } - (void)dealloc { [float1 release]; [float2 release]; [float3 release]; [apple release]; [bear_head release]; [self stopTimer]; [super dealloc]; } @end
