[site]: stackoverflow
[post_id]: 4835305
[parent_id]: 4835155
[tags]: 
Depending on how many events and months you're dealing with at a time, the naive approach may well be the best. I'd start by just letting your for loops handle the iterators, and accepting the fact that you'll be doing (m*n) iterations. Then if you find that this spot is causing a significant slow-down you can try a few other techniques to speed things up without making your code overly complex. Trying to seek ahead and back will make your code difficult to understand and more prone to bugs, without necessarily gaining you much in terms of performance. Usually you won't notice a significant difference in performance until you're talking about at least hundreds of items in both collections (in which case you could start with something simple like breaking your data up into years, for example, to reduce the overhead of the double-nested for loops). Edit However, since I just can't help myself, here's a semi-elegant strategy that will take advantage of the fact that your events and months are both stored in ascending order (I'm assuming events are stored in order of their start date). It uses a LinkedList (which is very efficient at adding and removing elements from the front and back of the list) to keep track of which months the current event might span, and then breaks as soon as it finds a month that the event doesn't include: LinkedList monthList = new LinkedList (); var i = monthList.getIterator(); for(Event ev : events) { shiftList(monthList, i, ev); for(Month m : monthList) { if (!isInMonth(ev, m)) break; m.addEvent(ev); } } ... // Remove months that are not in scope from the front of the list. // Add months that are in scope to the end of the list public void shiftList(LinkedList monthList, Iterator i, Event ev) { while(!monthList.size() > 0 && !isInMonth(ev, monthList.getFirst())) { monthList.removeFirst(); } while(i.hasNext() && isInMonth(ev, monthList.getLast())) { monthList.addLast(i.next()); } } Again, you can see how much more complicated this is: it's very likely I introduced a bug on this logic, and I wouldn't feel comfortable using this in production without thorough unit-testing. You're generally much better off just keeping it simple until you have a compelling reason to optimize.
