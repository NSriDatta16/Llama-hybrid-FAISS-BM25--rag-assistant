[site]: stackoverflow
[post_id]: 2538367
[parent_id]: 2538101
[tags]: 
Ad.1. The lifetime of the list should be the same as the lifetime of the MyWidget instance, so you can safely create the list on the stack. Ad.2. You could do that, but MyObject class would need to have a default constructor, a copy constructor, and an assignment operator (see http://doc.trolltech.com/4.6/containers.html#container-classes for details). Ad.3. The ownership of the object is not transferred on append. Just like STL containers, Qt containers doesn't call delete on stored pointers. To delete all pointers stored in QList (or other Qt container) you can use qDeleteAll(list). Mind, that you probably don't want to do so in the code you posted: you pass MyWidget pointer to MyObject constructor and I assume it is then used as QObject parent. So all QObjects will be deleted when MyWidget is deleted. Ad.4. The second argument of foreach macro should be a container, not pointer to container. So you should call foreach(MyObject *obj, *list) if your list variable is a pointer to QList. Ad.5. You should be fine as long as MyOtherWidget doesn't delete the passed MyObject (because the MyWidget is already a parent of MyObject and you'd end up deleting the same object twice). It's a gross simplification, but you should try to write your code in such way that you won't need to call delete at all. Create stuff on the stack or rely on Qt parent-children mechanism (i.e. parents delete their children). Later on you might want to read about smart pointers (QSharedPointer, QScopedPointer, etc.). EDIT: Whether the parent of MyObject is set or not depends on what you're doing in MyObject constructor. If you pass parent argument to QObject constructor, i.e. your Myobject constructor looks like this: MyObject(const QString &text, QObject *parent = 0) : QObject(parent) { // more code... } the parent will be set, because it will be done in QObject constructor, which will be called because of the ":QObject(parent)" code. What if you don't have this fragment? Since the MyObject inherits QObject, and you don't specify which constructor should be called the default QObject constructor, i.e. QObject(QObject *parent = 0) will be called, so the parent of your MyObject will be NULL and it won't be deleted. I'd try to avoid setting parent explicitly through setParent method - for basic use cases setting parent in constructor should be enough. Try to use correct terminology (not "instance method", but "constructor"), read Qt documentation, use common sense and try not to think that anything will be done automatically. The parent is not set "automatically" just because you call one argument "parent" - it is set, because there is a piece of code that does it in QObject constructor and it's your responsibility to call pass proper parent to QObject constructor in the classes that inherit QObject.
