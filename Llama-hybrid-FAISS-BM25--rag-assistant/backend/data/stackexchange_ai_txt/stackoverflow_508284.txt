[site]: stackoverflow
[post_id]: 508284
[parent_id]: 295336
[tags]: 
If you do care about performance, then you can calculate a moving average efficiently using something like this (assuming we're calculating a moving average over a 3-day window) Numbers[n] Running Total[n] --------- --------------- n[0] = 7 7 = Numbers[0] n[1] = 1 8 = RunningTotal[1-1] + Numbers[1] n[2] = 2 10 = RunningTotal[2-1] + Numbers[2] n[3] = 8 11 = RunningTotal[3-1] + Numbers[3] - Numbers[3-3] n[4] = 4 14 = RunningTotal[4-1] + Numbers[4] - Numbers[4-3] n[5] = 1 13 = RunningTotal[5-1] + Numbers[5] - Numbers[5-3] n[6] = 9 14 = RunningTotal[6-1] + Numbers[6] - Numbers[6-3] ... N RunningTotal[N] = RunningTotal[N-1] + Numbers[N] - Numbers[N-3] The hard part about this is holding on your previous running total and Number N-window . I came up with the following code: let movingAverage days l = seq { let queue = new Queue (days : int) let divisor = decimal days let total = ref 0m for cur in l do queue.Enqueue(cur) total := !total + cur if queue.Count This version isn't as nice looking as the Haskell code, but it should avoid performance problems associated with recomputing your "window" on each run. It keeps a running total and holds previously used numbers in a queue, so it should be very fast. Just for fun, I wrote a simple benchmark: #light open System open System.Collections.Generic open System.Diagnostics; let windowAverage days (l : #seq ) = Seq.windowed days l |> Seq.map (Seq.average) let princessAverage days l = seq { let queue = new Queue (days : int) let divisor = decimal days let total = ref 0m for cur in l do queue.Enqueue(cur) total := !total + cur if queue.Count decimal (rnd.Next(1000)) } let benchmark msg f iterations = let rec loop = function | 0 -> () | n -> f 3 testData |> ignore; loop (n - 1) let stopWatch = Stopwatch.StartNew() loop iterations stopWatch.Stop() printfn "%s: %f" msg stopWatch.Elapsed.TotalMilliseconds let _ = let iterations = 10000000 benchmark "princessAverage" princessAverage iterations benchmark "windowAverage" windowAverage iterations printfn "Done" Results: princessAverage: 1670.791800 windowAverage: 2986.146900 My version is ~1.79x faster.
