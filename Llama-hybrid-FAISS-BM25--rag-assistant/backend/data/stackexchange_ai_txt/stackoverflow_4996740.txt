[site]: stackoverflow
[post_id]: 4996740
[parent_id]: 4996641
[tags]: 
On a 16-bit or larger processor, if you don't care how much storage things will take, use 'int' instead of 'short' or 'signed char'. If you don't care about storage requirements or wrapping behavior, use 'unsigned int' instead of 'unsigned short' or 'unsigned char'. On an 8-bit processor, 'char' types may be faster than 'int', but on 16-bit and larger processors where 16-bit math is faster than 32-bit math, 'int' is likely to be 16 bits so there's no need to use 'short' or 'char' for speed. BTW, on some processors, 'unsigned short' is much slower than 'unsigned int', because the C standard requires that operations on unsigned types 'wrap'. If unsigned short variable "foo" is stored in a register, a typical ARM compiler generating code for "foo+=1;" would generate one instruction to do the increment, and two instructions to truncate the value to 65535 [BTW, an optimizing compiler that noticed that 'foo' could never exceed 65536 could shave an instruction, but I don't know if any real compilers would]. The signed 'short' would not have to be slower than 'signed int', since no truncation is mandated by the standard; I'm not sure whether any compilers would skip the truncation for signed types, though.
