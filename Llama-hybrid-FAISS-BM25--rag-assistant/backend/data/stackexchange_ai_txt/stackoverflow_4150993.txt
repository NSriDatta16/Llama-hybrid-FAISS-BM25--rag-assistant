[site]: stackoverflow
[post_id]: 4150993
[parent_id]: 4150502
[tags]: 
You are creating the set of objects recursively. Your code "smells" with test logic in production because you create all the objects implicitly. Instead I would encourage to use dependency injection or other solutions so that you do not have hard dependencies in your constructors. In the worst-case scenario , just use ServiceLocator pattern. The last option is the easiest way to go for you as you already have too much stuff bound together. Your code would look like this: public class OrganizationService : IOrganizationService { private IValidationDictionary _validationDictionary; private IOrganizationRepository _repository; public OrganizationService() { _validationDictionary = ServiceLocator.Get (); _repository = ServiceLocator.Get (); } } Let's look at the dependency on IOrganizationRepository here. We don't need to know exact type of it. So we don't care. The ServiceLocator is the only body that does care. Usually it is just a static class (keep in mind multi-threading and synchronization though!). It can be implemented like this (I don't want to point to existing implementations because it is just too simple to do): public static class ServiceLocator { static Func _resolver; public static Setup(Func resolver) { _resolver = resolver; } public static TService Get () { if (_resolver == null) throw InvalidOperationException("Please Setup first."); return (TService)_resolver.Invoke(typeof(TService)); } } Then in your test setup (probably on the base test class) just do this: ServiceLocator.Setup(what => { if (what == typeof(IOrganizationRepository)) return organisationRepository = organisationRepository ?? new OrganizationRepository(); // Singleton throw new NotSupportedException("The service cannot be resolved: " + what.Name); }); In production you would instantiate it differently. Of course it can be easier with CastleWindsor, Microsoft Unity or other dependency injection framework. Hope that will help.
