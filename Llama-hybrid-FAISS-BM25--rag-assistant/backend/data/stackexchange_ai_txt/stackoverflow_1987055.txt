[site]: stackoverflow
[post_id]: 1987055
[parent_id]: 1986966
[tags]: 
This is generally not safe, regardless of whether the internal string sequence is stored in memory continuously or not. There's might be many other implementation details related to how the controlled sequence is stored by std::string object, besides the continuity. A real practical problem with that might be the following. The controlled sequence of std::string is not required to be stored as a zero-terminated string. However, in practice, many (most?) implementations choose to oversize the internal buffer by 1 and store the sequence as a zero-terminated string anyway because it simplifies the implementation of c_str() method: just return a pointer to the internal buffer and you are done. The code you quoted in your question does not make any effort to zero-terminate the data is copied into the internal buffer. Quite possibly it simply doesn't know whether zero-termination is necessary for this implementation of std::string . Quite possibly it relies on the internal buffer being filled with zeros after the call to resize , so the extra character allocated for the zero-terminator by the implementation is conveniently pre-set to zero. All this is an implementation detail, meaning that this technique depends on some rather fragile assumptions. In other words, in some implementations, you'd probably have to use strcpy , not memcpy to force the data into the controlled sequence like that. While in some other implementations you'd have to use memcpy and not strcpy .
