[site]: stackoverflow
[post_id]: 2165759
[parent_id]: 
[tags]: 
How do I force windows NOT to redraw anything in my dialog when the user is resizing my dialog?

When the user grabs a corner of a resizable window, and then moves it, windows first moves the contents of the window around, then issues a WM_SIZE to the window being resized. Thus, in a dialog where I want to control the movement of various child controls, and I want to eliminate flickering, the user first sees what windows OS thinks the window will look like (because, AFAICT, the OS uses a bitblt approach to moving things around inside the window before sending the WM_SIZE) - and only then does my dialog get to handle moving its child controls around, or resize them, etc., after which it must force things to repaint, which now causes flicker (at the very least). My main question is: Is there a way to force windows NOT to do this stupid bitblt thing? Its definitely going to be wrong in the case of a window with controls that move as the window is resized, or that resize themselves as their parent is resized. Either way, having the OS do a pre-paint just screws the works. I thought for a time that it might be related to CS_HREDRAW and CSVREDRAW class flags. However, the reality is that I don't want the OS to ask me to erase the window - I just want to do the repainting myself without the OS first changing the contents of my window (i.e. I want the display to be what it was before the user started resizing - without any bitblit'ing from the OS). And I don't want the OS to tell every control that it needs to be redrawn either (unless it happened to be one that was in fact obscured or revealed by the resize. What I really want: To move & resize child controls before anything gets updated onscreen. Draw all of the moved or resized child controls completely so that they appear without artifacts at their new size & location. Draw the spaces inbetween the child controls without impacting the child controls themselves. NOTE: Steps 2 and 3 could be reversed. The above three things appear to happen correctly when I use DeferSetWindowPos() in combination with the dialog resource marked as WS_CLIPCHILDREN. I'd get an additional small benefit if I could do the above to a memory DC, and then only do a single bitblt at the end of the WM_SIZE handler. I have played with this for a while now, and I cannot escape two things: I still am unable to suppress Windows from doing a 'predictive bitblt'. Answer: See below for a solution that overrides WM_NCCALCSIZE to disable this behavior. I cannot see how one can build a dialog where its child controls draw to a double buffer. Answer: See John's answer (marked as answer) below for how to ask Windows OS to double buffer your dialog (note: this disallows any GetDC() in-between paint operations, according to the docs). My Final Solution (Thank you everyone who contributed, esp. John K.): After much sweat and tears, I have found that the following technique works flawlessly, both in Aero and in XP or with Aero disabled. Flicking is non-existent(1). Hook the dialog proc. Override WM_NCCALCSIZE to force Windows to validate the entire client area, and not bitblt anything. Override WM_SIZE to do all of your moves & resizes using BeginDeferWindowPos/DeferWindowPos/EndDeferWindowPos for all visible windows. Ensure that the dialog window has the WS_CLIPCHILDREN style. Do NOT use CS_HREDRAW|CS_VREDRAW (dialogs don't, so generally not an issue). The layout code is up to you - its easy enough to find examples on CodeGuru or CodeProject of layout managers, or to roll your own. Here are some code excerpts that should get you most of the way: LRESULT ResizeManager::WinProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) { switch (msg) { case WM_ENTERSIZEMOVE: m_bResizeOrMove = true; break; case WM_NCCALCSIZE: // The WM_NCCALCSIZE idea was given to me by John Knoeller: // see: http://stackoverflow.com/questions/2165759/how-do-i-force-windows-not-to-redraw-anything-in-my-dialog-when-the-user-is-resiz // // The default implementation is to simply return zero (0). // // The MSDN docs indicate that this causes Windows to automatically move all of the child controls to follow the client's origin // and experience shows that it bitblts the window's contents before we get a WM_SIZE. // Hence, our child controls have been moved, everything has been painted at its new position, then we get a WM_SIZE. // // Instead, we calculate the correct client rect for our new size or position, and simply tell windows to preserve this (don't repaint it) // and then we execute a new layout of our child controls during the WM_SIZE handler, using DeferWindowPos to ensure that everything // is moved, sized, and drawn in one go, minimizing any potential flicker (it has to be drawn once, over the top at its new layout, at a minimum). // // It is important to note that we must move all controls. We short-circuit the normal Windows logic that moves our child controls for us. // // Other notes: // Simply zeroing out the source and destination client rectangles (rgrc[1] and rgrc[2]) simply causes Windows // to invalidate the entire client area, exacerbating the flicker problem. // // If we return anything but zero (0), we absolutely must have set up rgrc[0] to be the correct client rect for the new size / location // otherwise Windows sees our client rect as being equal to our proposed window rect, and from that point forward we're missing our non-client frame // only override this if we're handling a resize or move (I am currently unaware of how to distinguish between them) // though it may be adequate to test for wparam != 0, as we are if (bool bCalcValidRects = wparam && m_bResizeOrMove) { NCCALCSIZE_PARAMS * nccs_params = (NCCALCSIZE_PARAMS *)lparam; // ask the base implementation to compute the client coordinates from the window coordinates (destination rect) m_ResizeHook.BaseProc(hwnd, msg, FALSE, (LPARAM)&nccs_params->rgrc[0]); // make the source & target the same (don't bitblt anything) // NOTE: we need the target to be the entire new client rectangle, because we want windows to perceive it as being valid (not in need of painting) nccs_params->rgrc[1] = nccs_params->rgrc[2]; // we need to ensure that we tell windows to preserve the client area we specified // if I read the docs correctly, then no bitblt should occur (at the very least, its a benign bitblt since it is from/to the same place) return WVR_ALIGNLEFT|WVR_ALIGNTOP; } break; case WM_SIZE: ASSERT(m_bResizeOrMove); Resize(hwnd, LOWORD(lparam), HIWORD(lparam)); break; case WM_EXITSIZEMOVE: m_bResizeOrMove = false; break; } return m_ResizeHook.BaseProc(hwnd, msg, wparam, lparam); } The resizing is really done by the Resize() member, like so: // execute the resizing of all controls void ResizeManager::Resize(HWND hwnd, long cx, long cy) { // defer the moves & resizes for all visible controls HDWP hdwp = BeginDeferWindowPos(m_resizables.size()); ASSERT(hdwp); // reposition everything without doing any drawing! for (ResizeAgentVector::const_iterator it = m_resizables.begin(), end = m_resizables.end(); it != end; ++it) VERIFY(hdwp == it->Reposition(hdwp, cx, cy)); // now, do all of the moves & resizes at once VERIFY(EndDeferWindowPos(hdwp)); } And perhaps the final tricky bit can be seen in the ResizeAgent's Reposition() handler: HDWP ResizeManager::ResizeAgent::Reposition(HDWP hdwp, long cx, long cy) const { // can't very well move things that no longer exist if (!IsWindow(hwndControl)) return hdwp; // calculate our new rect const long left = IsFloatLeft() ? cx - offset.left : offset.left; const long right = IsFloatRight() ? cx - offset.right : offset.right; const long top = IsFloatTop() ? cy - offset.top : offset.top; const long bottom = IsFloatBottom() ? cy - offset.bottom : offset.bottom; // compute height & width const long width = right - left; const long height = bottom - top; // we can defer it only if it is visible if (IsWindowVisible(hwndControl)) return ::DeferWindowPos(hdwp, hwndControl, NULL, left, top, width, height, SWP_NOZORDER|SWP_NOACTIVATE); // do it immediately for an invisible window MoveWindow(hwndControl, left, top, width, height, FALSE); // indicate that the defer operation should still be valid return hdwp; } The 'tricky' being that we avoid trying to mess with any windows that have been destroyed, and we don't try to defer a SetWindowPos against a window that is not visible (as this is documented as "will fail". I've tested the above in a real project that hides some controls, and makes use of fairly complex layouts with excellent success. There is zero flickering(1) even without Aero, even when you resize using the upper left corner of the dialog window (most resizable windows will show the most flickering and problems when you grab that handle - IE, FireFox, etc.). If there is interest enough, I could be persuaded to edit my findings with a real example implementation for CodeProject.com or somewhere similar. Message me. (1) Please note that it is impossible to avoid one draw over the top of whatever used to be there. For every part of the dialog that has not changed, the user can see nothing (no flicker whatsoever). But where things have changed, there is a change visible to the user - this is impossible to avoid, and is a 100% solution.
