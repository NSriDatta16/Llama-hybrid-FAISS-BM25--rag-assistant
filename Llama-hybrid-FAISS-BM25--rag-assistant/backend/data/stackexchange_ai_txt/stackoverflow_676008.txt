[site]: stackoverflow
[post_id]: 676008
[parent_id]: 675976
[tags]: 
ISO14882:2003, section 5, paragraph 5: If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type , the behavior is undefined, unless such an expression is a constant expression (5.19), in which case the program is ill-formed. (Emphasis mine.) So, yes, the behavior is undefined. The standard makes no guarantees of behavior in the case of integer over/underflow. Edit: The standard seems slightly conflicted on the matter elsewhere. Section 3.9.1.4 says: Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2 n where n is the number of bits in the value representation of that particular size of integer. But section 4.7.2 and .3 says: 2) If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2 n where n is the number of bits used to represent the unsigned type). [Note: In a twoâ€™s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). ] 3) If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined. (Emphasis mine.)
