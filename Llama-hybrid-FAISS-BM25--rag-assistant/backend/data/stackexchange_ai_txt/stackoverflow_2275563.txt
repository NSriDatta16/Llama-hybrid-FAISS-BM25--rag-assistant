[site]: stackoverflow
[post_id]: 2275563
[parent_id]: 2274918
[tags]: 
It isn't that clear what's going on here. Getting multiple UpdateProgress calls on the UI thread for one UpdateProgress call on the worker thread is definitely bad. Your code as posted should not do this. But, yes, the Post() call is not particularly fast. It takes roughly a millisecond for the message loop on the UI thread to pick up the notification, assuming it is not busy doing something else. This is not one millisecond of hard CPU work, it is a delay induced by the Windows plumbing that handles GetMessage(). The thread context switch is part of it, but just a small part. This can have notable nasty side-effects. Calling Post() too often, or having the posted delegate doing too much hard work, can seriously affect the UI thread. To the point that it doesn't get around its regular duties anymore. Because of the delay, you can get there quickly; it only takes 1000 posts per second. Of course, it is never necessary to post that often, the human eye cannot perceive updates at a rate any faster than about 25 per second. Doing it more frequently is just wasted effort. But obtaining this ideal update rate is not particularly easy to achieve, unless the worker thread pays specific attention to elapsed time. Anyhoo, it is better to leave it up to the client code to tell you how it wants its notifications marshaled. The FileSystemWatcher.SynchronizingObject is a good example of that. If Post() falls apart, that's one way for the client code to fix the problem. Also take a look at the BackgroundWorker class.
