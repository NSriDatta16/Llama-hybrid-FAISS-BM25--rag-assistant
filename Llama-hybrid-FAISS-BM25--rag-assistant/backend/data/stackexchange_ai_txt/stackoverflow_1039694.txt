[site]: stackoverflow
[post_id]: 1039694
[parent_id]: 
[tags]: 
Displaying entity-attribute-value data in JTable?

How can I use a JTable to display & edit attribute properties for entities retrieved from an entity,attribute,value (EAV) store (a relational DBMS)? I know this is a question with a lot of possible answers, so PLEASE look at the requirements I have below before answering. I promise to vote up answers that show you've read & understand the whole thing (as long as they aren't totally silly). The user needs to be able to: Filter/Search entities by their attributes Choose which attributes to show (as columns) Sort entities by chosen attributes Edit attribute values Do operations on selected entities (Optional) Ability to save view for later use. System Requirements: Number of entities: needs to scale up to 100K+ unique entities Attributes: user can add and define new attributes, system should be able to handle this Underlying Storage: H2 Database (already designed), communicating by JDBC Memory: not everything will fit, so somehow needs to pull from DBMS queries Performance: should minimize number of queries needed to DBMS (one query per attribute OK, and I have a form with 1 query per table view, but it sucks). Queries: ONE query should be required to generate list of entities matching a search/filter. Otherwise massive performance suck. Reusing data: shouldn't have to re-query or re-sort the entire list when column is added. Things I've looked at: Glazed Lists library Pros: Flexible about column handling Easy to implement sort/filter of entities Flexible about column display format & editing Cons: One object per entity (if objects are complex, memory overhead becomes a serious memory problem!) Object responsible for all functionality... but objects should be simple for memory reasons How do I support user-selectable columns without a HashMap for EVERY entity object? Extending AbstractTableModel to map data from a JDBC ResultSet to rows,columns Pros: Paging of results avoids memory problem Searching/Filtering is directly in SQL Memory-friendly, doesn't have to make an object per-row Cons: Implementing custom columns & sorting is a pain (table header renderer, managing sort columns and order, etc)! Probably have to write custom JTableColumnModel too, and this gets messy! Has to manipulate SQL a lot, so if DB schema changes, have to rewrite multiple pieces of code! Hard to maintain entity ID info ORM Pros: Designed to map DB rows to objects Provides object management Cons: WORST POSSIBLE solution for entity-attribute-value model Have to learn & write ORM code in addition to DBMS & Java code! Entities can have any number of attributes, ORM is only good with static, limited object attributes Lose flexibility/speed of custom SQL Is there a better option that I missed, or some clever way to make Glazed Lists or custom Table Model easier? I've totally discarded ORM as an option already, because of how badly matched it is to EAV storage.
