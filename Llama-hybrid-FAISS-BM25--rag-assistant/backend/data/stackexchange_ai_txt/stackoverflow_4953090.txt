[site]: stackoverflow
[post_id]: 4953090
[parent_id]: 4953032
[tags]: 
In the interest of full disclosure: I'm no expert in TDD (I don't actually use it and never have), but I think I can argue from my ignorance for the TDD advocates in this case. Imagine a situation where you have a simple "zero logic" property/function like example two. Suppose you implemented your own version of GetProcessById which functions very slightly differently, but is interchangable with the Process object. You decide not to write a test for this function, and say "Ahh, I'm just delegating it to the well-tested library, I can't possibly screw it up." There's your first mistake. "I can't possibly screw it up" is the single worst lie that programmers ever regularly tell themselves. Suppose six months from now you realize you need to extend Process with some extra stuff. You delegate all the right methods and override GetProcessById . You now officially have to test this "zero logic" method. And that's the trouble. Polymorphism and many other features of programming languages (even ones that aren't strictly Object Oriented) lead to code which doesn't do exactly what you imagine it to do. So, that being said, if you're following a strict TDD methodology, and you're striving for 100% test coverage, you'll want to test "zero-logic" methods, just like those two. The only exception I can imagine is specific to .NET and that's automatically implemented properties, where there's no point in testing that the Getter and Setter work correctly, because even if they didn't there'd be nothing you could do about it. Test the object being wrapped in the property, not the property itself. TDD folks, does that summarize it pretty well?
