[site]: stackoverflow
[post_id]: 3119552
[parent_id]: 3083175
[tags]: 
I ran into the same problem and here's what I did to work it out. You don't extend BackupAgent with the wrapper, you extend it with the wrapped class. So you make your real backup class: public class MyBackup extends BackupAgent { @Override public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) throws IOException { // TODO Auto-generated method stub } @Override public void onRestore(BackupDataInput data, int appVersionCode, ParcelFileDescriptor newState) throws IOException { // TODO Auto-generated method stub } Okay, and then you make a wrapper like the android developer backwards compatibility article said to do. Note that this class does not extend BackupAgent: public class WrapMyBackup { private MyBackup wb; static { try { Class.forName("MyBackup"); } catch (Exception ex) { throw new RuntimeException(ex); } } /** call this wrapped in a try/catch to see if we can instantiate **/ public static void checkAvailable() {} public WrapMyBackup() { wb = new MyBackup(); } public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) throws IOException { wb.onBackup(oldState, data, newState); } public void onRestore(BackupDataInput data, int appVersionCode, ParcelFileDescriptor newState) throws IOException { wb.onRestore(data, appVersionCode, newState); } public void onCreate() { wb.onCreate(); } public void onDestroy() { wb.onDestroy(); } } Finally, in your manifest, you declare the wrapper as your backup agent: Since your wrapper has the proper methods defined you won't run into a problem when the backup manager casts it to a BackupAgent. Since lower API levels won't have a BackupManager the code will never get called, so you won't run into any runtime exceptions there either.
