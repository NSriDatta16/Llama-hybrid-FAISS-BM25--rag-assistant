[site]: stackoverflow
[post_id]: 2697296
[parent_id]: 2696257
[tags]: 
The third i can alias the first i , because they have non-overlapping scopes. The second i cannot alias the third, because their scopes do overlap. Hence, the compiler knows it needs to allocate storage for at least two integers. The space for the first integer can be shared by the first and third i , and the the space for the second i is reserved exclusively for the second i . These locations could be registers or stack slots, without loss of generality. Interim conclusion: for the compiler, it doesn't matter how often you use the name i. It only cares how many variables you have, and how their scopes overlap. So, when the debugger hits the second for-loop, it sees that you're watching the third i . The debugger looks up the location of the third i . Since that location was also used for the first i , it still contains 300. That of course doesn't matter for the program, as you start out by writing 0 to the third i , overwriting the old value 300 in that location. So, the essential step is understanding how variables can be mapped to locations.
