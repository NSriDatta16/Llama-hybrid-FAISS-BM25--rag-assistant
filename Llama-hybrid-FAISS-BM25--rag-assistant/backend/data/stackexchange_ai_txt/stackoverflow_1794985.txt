[site]: stackoverflow
[post_id]: 1794985
[parent_id]: 1746380
[tags]: 
There are two obvious paths you can go down to attempt this. The first, is to hook the OLE functions involved in mediating drag/drop operations. This assumes that the other application is using real drag and drop and not some internal only version. Determing this is beyond my ability - without access to the program - but if its possible to drag from this external application to some other applications window (including the desktop) its a good indication that the app is using the real stuff. The function you'd need to hook is RegisterDragDrop , though DoDragDrop may also be of interest. RegisterDragDrop is called to register a drop target, and gives you an opportunity to wrap the IDropTarget in the maner you desire (presumably IPC'ing into your actual app), RevokeDragDrop and then pass the registration on, but now with your wrapper object instead. IDropTarget::Drop is presumably where you'll do the bulk of your IPC. The second, is by injecting a Windows hook into the application. This is only tractable if you understand the user actions that trigger a drag, and can detect them as you're going to have to distinguish between a drag operation and normal keyboard/mouse actions. The hook in question is the WH_CALLWNDPROC hook, registered with SetWindowsHookEx . Basically, you define a WndProc which gets all the messages the applications window does (including mouse movement) and its up to you to determine when a drag operation starts and when it stops. In either case, alot of the code can be written in C#. With p\invoke you can get at SetWindowsHookEx , and you can implement COM objects (and by extension, wrappers for those COM objects) in C# as well. Infact, there's an IDropTarget class already in .NET 2.0; which might be COM visible already. Unfortunately, hooking APIs is very low level and you're generally going to have to work in C or C++ to get anything done. I've heard good things about Detours , plus its from Microsoft.
