[site]: stackoverflow
[post_id]: 5614009
[parent_id]: 5610321
[tags]: 
I've successfully used a pattern like the following: First off we must define a .query() plugin. // jQuery.fn.query() emulates the behavior of .querySelectorAll() // by allowing a full/complex selector to be matched against //a small slice of the dom. $.fn.query = function ( selector ) { var scopeElms = this, scopeIsDoc = scopeElms.length === 1 && scopeElms.is('html') , // check for obviously simple selectors.... (needs more elegance) isComplexSelector = /\s/.test( selector.replace(/\s*([|~*$\^!]?=|,)\s*/g, '$1') ), elms; if ( scopeIsDoc || isComplexSelector ) { elms = $(selector); if ( scopeElms[0] ) { elms = elms.filter(function(){ var i = scopeElms.length; while (i--) { if ( scopeElms[i] === this || $.contains(scopeElms[i], this) ) { return true; } } return false; }); } } else { elms = scopeElms.filter( selector ) .add( scopeElms.find(selector) ); } return $(elms); }; We then write our init function and bind it to the "ready" event, and also to our custom "domupdated" event. Within the init function we use .query() to find elements from either the whole document or just the updated fragment... // Here we define our DOM initializations $(document).bind('ready domupdated', function (e, updatedFragment) { var root = $( updatedFragment || 'html' ); // Begin imaginary initialization routines root.query('form').validate(); root.query('.sidebar .searchform input#search').autocomplete(); // etc... }); Then whenever we inject blocks of new elements into the DOM (like when an Ajax request has finished) we then trigger the domupdated event and pass the updated DOM fragment as a parameter - like so: ... var ajaxedDom = $(xhr.resultText).find('#message'); ajaxedDom.appendTo( '#modal' ); $(document).trigger('domupdated', [ajaxedDom]); For me, this set up takes all the pain out of initing the DOM. It allows me to maintain a single set of init routines, and focus on the fun things.
