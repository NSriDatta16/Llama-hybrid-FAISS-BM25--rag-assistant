[site]: stackoverflow
[post_id]: 5411225
[parent_id]: 5410758
[tags]: 
That's because JComboBox.html.getSelectedItem() returns Object public Object getSelectedItem() And your method expects a string public void addTopicToListner(String t) If you're 100% sure the contents of your combobox are string you just have to cast it: a.addTopicToListner( (String) topicCombobox.getSelectedItem()); And that's it. This code sample reproduces exactly your compilation error: class StringAndObject { public void workWithString( String s ) {} // We just care about public void workWithObject( Object o ) {} // the signature. public void run() { String s = ""; // s declared as String Object o = s; // o declared as Object // works because a String is also an Object workWithObject( s ); // naturally a s is and String workWithString( s ); // works because o is an Object workWithObject( o ); // compiler error.... workWithString( o ); } } Output: StringAndObject.java:19: workWithString(java.lang.String) in StringAndObject cannot be applied to (java.lang.Object) workWithString( o ); ^ 1 error As you see, the last call ( workWithString(o) ) doesn't compile even though it is a String object. It turns out the compiler only knows that o was declared as Object but it doesn't have a way to know if that object is a string or is something else ( a Date for instance ). I hope this helps.
