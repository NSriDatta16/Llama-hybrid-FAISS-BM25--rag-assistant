[site]: stackoverflow
[post_id]: 5598766
[parent_id]: 5598703
[tags]: 
First of all const T is equivalent to T const . const int* const is therefore equivalent to int const * const . When reading expressions with lots of const tokens and pointers in them, always try to read them from right to left (after applying the transformation above). So in this case the return value is a const pointer to a const int . Making the pointer itself const makes no sense here since the return value isn't a lvalue that could be modified. Making the pointee const , however, guarantees that the caller may not modify the int (or array of int s) returned by Method3 . const int*const& becomes int const*const& , so it is a reference to a const pointer to a const int . Passing a const pointer by references male no sense either - you can't modify the referenced value since the pointer is const and references and pointers occupy equal storage so there aren't any space savings either. The last const indicates that the method does not modify the this object. The this pointer within the method body will have the (theoretical) declaration T const * const this . This means that a const T* object will be able to call T::Method3() .
