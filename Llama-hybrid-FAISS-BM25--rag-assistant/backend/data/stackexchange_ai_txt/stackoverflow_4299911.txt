[site]: stackoverflow
[post_id]: 4299911
[parent_id]: 4299656
[tags]: 
TTAS (#2) is good practice. "Lurking" and waiting for the "opportunity" before doing CAS is common practice in both Java and .NET concurrent classes. With that said, cmpxchg received quite a lot of optimizations in the last few years, so it might be possible that you'd get nearly identical results on the latest crop of processors. What you should try in both cases, however is to employ some exponential backoff when you spin. Update @GJ: You should find some more up-to-date documentation on Intel's site . Note the paragraph about not locking the bus since 486 and the comparison chart of xchg and cmpxchg that shows that they are practically identical. Spinning on a read vs on a locked instruction will still be a good idea to avoid some contention on getting the cache line in exclusive mode. (So TTAS.) However this will provide a useful gain only if you implement e.g. an exponential back-off, even yielding the CPU after a while. The differences between TTAS and TAS, or w/o backoff would be smaller if you are using a single, modern multi-core CPU with a shared L3 cache between the cores and would become more visible if you are using a multi-socket - e.g. server - machine or a multi-core CPU that has no shared cache between the cores. They would also be different based on the amount of contention. (I.e. light load would see smaller difference between TTAS/TAS.)
