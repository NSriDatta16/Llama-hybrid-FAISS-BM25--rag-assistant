[site]: stackoverflow
[post_id]: 5284401
[parent_id]: 5274879
[tags]: 
Just some notes. Your 1A best case seems almost right(Kinda, but se added: at the bottom), but I think your block size calculation is wrong. Only (The value of) B and a pointer/reference to the needed disk block should be stored in the b+ index tree. Neither A nor C should be in the b+ tree at all. And your worst case is really wrong. There is no requirement that B is unique, and there is no need to do probability when talking about worst case. So imagine what happens if B=10 in all your tuples. Then you will have to read them all to find the values where A=100. (Remember you are asked for best/worst case not average). This worst case example is also your hint to solve question 1B. An index might be useful if you have so many values with equal B values that they can't be located in a few blocks. (You can do the exact math). 2A don't seem so difficult. If we don't have an index then you need to read 1 block in the best case, and all the blocks in the worst case. (This assume that A is unique. This is what A being a key means right?) But I am a bit confused about this last question. If A and B are 2 different (foreign???) keys, then having a combined index on them both seems wrong. ps: It is a few years ago I did this for university, so I may be wrong, but I hope I at least gave you something to think about :} Added: ----------------- My note about your calculations of how many entries you can have in a single node seems really off. Try this instead: (Still from memory, so sorry for any errors). An entry in your b+ tree, contains 2 values of B (min/max) and a disk block reference for the block containing the values between min and max. So each entry is 12 bytes (Assuming 4 byte block references) and you can thus store 2048/12=170 entries in each block.
