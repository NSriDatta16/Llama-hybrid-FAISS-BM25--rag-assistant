[site]: stackoverflow
[post_id]: 5327413
[parent_id]: 5321551
[tags]: 
Here's one way to do it in C++: #include #include #include #include #include int main() { std::istringstream converter("live long and prosper"); std::vector words( (std::istream_iterator (converter)), std::istream_iterator ()); std::copy(words.rbegin(), words.rend(), std::ostream_iterator (std::cout, " ")); return 0; } Efficiency is harder to guess at. Even though they produce relatively little output, both are undoubtedly I/O bound, but the relatively speed of iostreams to C streams depends heavily on the implementation. It can go either way -- at one time, iostreams were almost always slower, often significantly so. Nowadays, it's fairly frequent for iostreams to be faster (e.g., libraw recent switched to iostreams specifically to improve speed -- and it worked). The internal manipulations are probably even less certain. Some (many?) implementations of std::string include what's called the short string optimization ("SSO"). This allocates a small (e.g., 20 byte) block of storage as part of the string object itself. If the string is short enough to fit there, this avoids a separate allocation for the content. Likewise, std::vector allocates raw memory in blocks, and then creates strings in-place in that memory. Given the small size and number of strings involved here, there's a pretty fair chance that all the memory for the entire vector of strings is allocated as a single block in one allocation. In this case, this stands a pretty good chance of being faster than the C version -- in your C version, each byte of input is copied once to reverse the whole string, and again to reverse individual words, whereas this copies each only once. OTOH, if you had more strings, or they were longer (too long to fit in the SSO area) you'd have more dynamic allocation, which would probably slow things down (though exactly how much is hard to estimate, and obviously depends on the heap manager...) At the same time, this certainly uses more memory, and depending on exactly how that memory is allocated, it might use more dynamic memory allocation (e.g., if the initial allocation for std::vector is fewer than 4 items, and/or your string doesn't include SSO). The bottom line is that the speed of the C++ version depends much more on the quality of the implementation. With an old compiler/standard library (e.g., gcc 2.x, VC++ 6) I'd expect it to be slower -- possibly quite a lot slower. With a current implementation, I'd expect it to be faster -- possibly quite a bit faster. The difference between the slowest and fastest implementations might easily be 4:1 (most of that in the iostreams implementation though).
