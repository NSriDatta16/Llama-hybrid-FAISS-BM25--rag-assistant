[site]: crossvalidated
[post_id]: 243578
[parent_id]: 
[tags]: 
How to get continuous output with Convolutional network? (Keras)

I'm new in using convolutional neural networks with keras. I can train a CNN for classify somethings and in other words for discrete output, but I can't find an example for getting continuous output (linear regression,...) in keras. Could you give me a link for this? or explain it yourself? Thanks in advance. here is my code: def MakeConvNet(WindowSize): batch_size = 128 nb_classes = 2 nb_epoch = 10 # input image dimensions img_rows, img_cols = WindowSize, WindowSize # number of convolutional filters to use nb_filters = 32 # size of pooling area for max pooling nb_pool = 4 # convolution kernel size kernel_size = (4, 4) # the data, shuffled and split between train and test sets x_dim_In,y_dim_In,z_dim_In=Input.shape x_dim_Out,y_dim_Out=Output.shape temp1=int(math.floor(40*x_dim_In/100)); temp2=int(math.floor(50*x_dim_In/100)); temp3=int(math.floor(90*x_dim_In/100)); temp4=int(math.floor(40*x_dim_Out/100)); temp5=int(math.floor(50*x_dim_Out/100)); temp6=int(math.floor(90*x_dim_Out/100)); X_train_1=Input[0:temp1,:] X_train_2=Input[temp2:temp3,:] X_train=np.concatenate((X_train_1,X_train_2),axis=0) X_test_1=Input[temp1:temp2,:] X_test_2=Input[temp3:x_dim_In] X_test=np.concatenate((X_test_1,X_test_2),axis=0) y_train_1=Output[0:temp4,:] y_train_2=Output[temp5:temp6,:] y_train=np.concatenate((y_train_1,y_train_2),axis=0) y_test_1=Output[temp4:temp5,:] y_test_2=Output[temp6:x_dim_Out,:] y_test=np.concatenate((y_test_1,y_test_2),axis=0) X_train = X_train.reshape(X_train.shape[0],1,img_rows, img_cols) X_test = X_test.reshape(X_test.shape[0],1,img_rows, img_cols) X_train = X_train.astype('float32') X_test = X_test.astype('float32') X_train /= 255 X_test /= 255 print('X_train shape:', X_train.shape) print(X_train.shape[0], 'train samples') print(X_test.shape[0], 'test samples') # convert class vectors to binary class matrices y_train=y_train.astype(int) y_test=y_test.astype(int) Y_train = np_utils.to_categorical(y_train, nb_classes) Y_test = np_utils.to_categorical(y_test, nb_classes) model = Sequential() model.add(Convolution2D(nb_filters, kernel_size[0], kernel_size[1], border_mode='valid', input_shape=(1, img_rows, img_cols))) model.add(Activation('relu')) model.add(Convolution2D(nb_filters, kernel_size[0], kernel_size[1])) model.add(Activation('relu')) model.add(MaxPooling2D(pool_size=(nb_pool, nb_pool))) model.add(Dropout(0.25)) model.add(Flatten()) model.add(Dense(128)) model.add(Activation('relu')) model.add(Dropout(0.5)) model.add(Dense(nb_classes)) model.add(Activation('softmax')) model.compile(loss='categorical_crossentropy', optimizer='adadelta', metrics=['accuracy']) checkpointer = ModelCheckpoint(filepath="./weights_Eye.hdf5", verbose=1, save_best_only=True) model.fit(X_train, Y_train, batch_size=batch_size, nb_epoch=nb_epoch, verbose=1, validation_data=(X_test, Y_test), callbacks=[checkpointer]) score = model.evaluate(X_test, Y_test, verbose=0) print('Test score:', score[0]) print('Test accuracy:', score[1]) model_json = model.to_json() with open("model_Eye_30.json", "w") as json_file: json_file.write(model_json) # serialize weights to HDF5 model.save_weights("model_Eye_30.h5") print("Saved model to disk")
