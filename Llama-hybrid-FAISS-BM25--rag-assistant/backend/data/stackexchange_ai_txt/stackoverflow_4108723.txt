[site]: stackoverflow
[post_id]: 4108723
[parent_id]: 4108574
[tags]: 
Arrays of unknown size are not valid as C++ data members. They are valid in C99, and your compiler may be mixing C99 support with C++. What you can do in C++ is 1) give it a size, 2) use a vector or another container, or 3) ditch both automatic (local variable) and normal dynamic storage in order to control allocation explicitly. The third is particularly cumbersome in C++, especially with non-POD, but possible; example: struct A { int const size; char data[1]; ~A() { // if data was of non-POD type, we'd destruct data[1] to data[size-1] here } static auto_ptr create(int size) { // because new is used, auto_ptr's use of delete is fine // consider another smart pointer type that allows specifying a deleter A *p = ::operator new(sizeof(A) + (size - 1) * sizeof(char)); try { // not necessary in our case, but is if A's ctor can throw new(p) A(size); } catch (...) { ::operator delete(p); throw; } return auto_ptr (p); } private: A(int size) : size (size) { // if data was of non-POD type, we'd construct here, being very careful // of exception safety } A(A const &other); // be careful if you define these, A& operator=(A const &other); // but it likely makes sense to forbid them void* operator new(size_t size); // doesn't prevent all erroneous uses, void* operator new[](size_t size); // but this is a start }; Note you cannot trust sizeof(A) any where else in the code, and using an array of size 1 guarantees alignment (matters when the type isn't char).
