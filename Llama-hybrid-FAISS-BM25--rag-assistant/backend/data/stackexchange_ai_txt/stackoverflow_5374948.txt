[site]: stackoverflow
[post_id]: 5374948
[parent_id]: 5373883
[tags]: 
A brief overview of the approach: The "flow of control" in lazy programs is different than you're used to. Things won't be evaluated until they have to which is why your program is always a request behind with the output. In general, you can make something strict by using the "bang" operator ! and the BangPatterns pragma. If you use it in this case (by saying !text ) you will get the output of the headers once the request is finished. Unfortunately, hGetContents doesn't know when to stop waiting for more data before the print statement, because handle is not closed. If you additionally restructure the program to have the hClose handle before both the let statement, and print , then the program behaves like you want. In the other case, the print is not evaluated because the value of text is never "finalized" by the closing of handle . Since it's "lazy", print is then waiting on hds and lns , which are in turn waiting on text , which is waiting on hClose ... which is why you were getting the weird behaviour; hClose was not being evaluated until the socket was needed by the next request, which is why there was no output until then. Note that simply making text strict will still block the program forever, leaving it "waiting" for the file to close. Yet, if the file is closed when text is non-strict, it will always be empty, and cause an error. Using both together will get the desired effect. Your program with the suggested changes: Three changes were made: I added the {-# LANGUAGE BangPatterns #-} pragma, a single character ( ! ) in front of text , and moved hClose handle up a few lines. {-# LANGUAGE BangPatterns #-} import Network import System.IO import Network.HTTP.Headers acceptLoop :: Socket -> IO () acceptLoop s = do (handle, hostname, _) An alternate approach: To sidestep issues like this altogether, you can try using the hGetContents function from the System.IO.Strict module instead of System.IO . A final note: Rather than explicit recursion in acceptLoop , I find the following main to be more idiomatic: main = do s Doing this, you can remove the recursive call from acceptLoop . TomMD's solution uses forever from the Contol.Monad module, which is good too.
