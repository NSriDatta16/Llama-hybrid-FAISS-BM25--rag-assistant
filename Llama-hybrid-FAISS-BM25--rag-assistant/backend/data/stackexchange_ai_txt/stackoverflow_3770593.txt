[site]: stackoverflow
[post_id]: 3770593
[parent_id]: 3770457
[tags]: 
Imagine that you have a "large" (32 bytes) expanse of free memory: ---------------------------------- | | ---------------------------------- Now, allocate some of it (5 allocations): ---------------------------------- |aaaabbccccccddeeee | ---------------------------------- Now, free the first four allocations but not the fifth: ---------------------------------- | eeee | ---------------------------------- Now, try to allocate 16 bytes. Oops, I can't, even though there's nearly double that much free. On systems with virtual memory, fragmentation is less of a problem than you might think, because large allocations only need to be contiguous in virtual address space, not in physical address space. So in my example, if I had virtual memory with a page size of 2 bytes then I could make my 16 byte allocation with no problem. Physical memory would look like this: ---------------------------------- |ffffffffffffffeeeeff | ---------------------------------- whereas virtual memory (being much bigger) could look like this: ------------------------------------------------------... | eeeeffffffffffffffff ------------------------------------------------------... The classic symptom of memory fragmentation is that you try to allocate a large block and you can't, even though you appear to have enough memory free. Another possible consequence is the inability of the process to release memory back to the OS (because each of the large blocks it has allocated from the OS, for malloc etc. to sub-divide, has something left in it, even though most of each block is now unused). Tactics to prevent memory fragmentation in C++ work by allocating objects from different areas according to their size and/or their expected lifetime. So if you're going to create a lot of objects and destroy them all together later, allocate them from a memory pool. Any other allocations you do in between them won't be from the pool, hence won't be located in between them in memory, so memory will not be fragmented as a result. Or, if you're going to allocate a lot of objects of the same size then allocate them from the same pool. Then a stretch of free space in the pool can never be smaller than the size you're trying to allocate from that pool. Generally you don't need to worry about it much, unless your program is long-running and does a lot of allocation and freeing. It's when you have mixtures of short-lived and long-lived objects that you're most at risk, but even then malloc will do its best to help. Basically, ignore it until your program has allocation failures or unexpectedly causes the system to run low on memory (catch this in testing, for preference!). The standard libraries are no worse than anything else that allocates memory, and standard containers all have an Alloc template parameter which you could use to fine-tune their allocation strategy if absolutely necessary.
