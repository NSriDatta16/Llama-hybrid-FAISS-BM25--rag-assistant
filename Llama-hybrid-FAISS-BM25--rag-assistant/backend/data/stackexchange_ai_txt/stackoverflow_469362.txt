[site]: stackoverflow
[post_id]: 469362
[parent_id]: 469357
[tags]: 
JavaScript You can filter the input values of a text with the following setInputFilter function (supports Copy+Paste, Drag+Drop, keyboard shortcuts, context menu operations, non-typeable keys, the caret position, different keyboard layouts, validity error message, and all browsers since IE 9 ): // Restricts input for the given textbox to the given inputFilter function. function setInputFilter(textbox, inputFilter, errMsg) { [ "input", "keydown", "keyup", "mousedown", "mouseup", "select", "contextmenu", "drop", "focusout" ].forEach(function(event) { textbox.addEventListener(event, function(e) { if (inputFilter(this.value)) { // Accepted value. if ([ "keydown", "mousedown", "focusout" ].indexOf(e.type) >= 0){ this.classList.remove("input-error"); this.setCustomValidity(""); } this.oldValue = this.value; this.oldSelectionStart = this.selectionStart; this.oldSelectionEnd = this.selectionEnd; } else if (this.hasOwnProperty("oldValue")) { // Rejected value: restore the previous one. this.classList.add("input-error"); this.setCustomValidity(errMsg); this.reportValidity(); this.value = this.oldValue; this.setSelectionRange(this.oldSelectionStart, this.oldSelectionEnd); } else { // Rejected value: nothing to restore. this.value = ""; } }); }); } You can now use the setInputFilter function to install an input filter: setInputFilter(document.getElementById("myTextBox"), function(value) { return /^\d*\.?\d*$/.test(value); // Allow digits and '.' only, using a RegExp. }, "Only digits and '.' are allowed"); Apply your preferred style to the input-error class. Here’s a suggestion: .input-error{ outline: 1px solid red; } Note that you still must do server side validation ! Another caveat is that this will break the undo stack since it sets this.value directly. This means that Ctrl Z will not work to undo inputs after typing an invalid character. Demo See the JSFiddle demo for more input filter examples or run the Stack snippet below: // Restricts input for the given textbox to the given inputFilter. function setInputFilter(textbox, inputFilter, errMsg) { [ "input", "keydown", "keyup", "mousedown", "mouseup", "select", "contextmenu", "drop", "focusout" ].forEach(function(event) { textbox.addEventListener(event, function(e) { if (inputFilter(this.value)) { // Accepted value. if ([ "keydown", "mousedown", "focusout" ].indexOf(e.type) >= 0) { this.classList.remove("input-error"); this.setCustomValidity(""); } this.oldValue = this.value; this.oldSelectionStart = this.selectionStart; this.oldSelectionEnd = this.selectionEnd; } else if (this.hasOwnProperty("oldValue")) { // Rejected value: restore the previous one. this.classList.add("input-error"); this.setCustomValidity(errMsg); this.reportValidity(); this.value = this.oldValue; this.setSelectionRange(this.oldSelectionStart, this.oldSelectionEnd); } else { // Rejected value: nothing to restore. this.value = ""; } }); }); } // Install input filters. setInputFilter(document.getElementById("intTextBox"), function(value) { return /^-?\d*$/.test(value); }, "Must be an integer"); setInputFilter(document.getElementById("uintTextBox"), function(value) { return /^\d*$/.test(value); }, "Must be an unsigned integer"); setInputFilter(document.getElementById("intLimitTextBox"), function(value) { return /^\d*$/.test(value) && (value === "" || parseInt(value) .input-error { outline: 1px solid red; } JavaScript input filter showcase Supports Copy+Paste, Drag+Drop, keyboard shortcuts, context menu operations, non-typeable keys, the caret position, different keyboard layouts, and all browsers since IE 9 . There is also a jQuery version of this. Integer Integer &gt;= 0 Integer &gt;= 0 and &lt;= 500 Float (use . or , as decimal separator) Currency (at most two decimal places) A-Z only Hexadecimal TypeScript Here is a TypeScript version of this. function setInputFilter(textbox: Element, inputFilter: (value: string) => boolean, errMsg: string): void { ["input", "keydown", "keyup", "mousedown", "mouseup", "select", "contextmenu", "drop", "focusout" ].forEach(function(event) { textbox.addEventListener(event, function(this: (HTMLInputElement | HTMLTextAreaElement) & { oldValue: string; oldSelectionStart: number | null, oldSelectionEnd: number | null }) { if (inputFilter(this.value)) { this.oldValue = this.value; this.oldSelectionStart = this.selectionStart; this.oldSelectionEnd = this.selectionEnd; } else if (Object.prototype.hasOwnProperty.call(this, "oldValue")) { this.value = this.oldValue; if (this.oldSelectionStart !== null && this.oldSelectionEnd !== null) { this.setSelectionRange(this.oldSelectionStart, this.oldSelectionEnd); } } else { this.value = ""; } }); }); } jQuery There is also a jQuery version of this. See this answer . HTML5 HTML5 has a native solution with (see the specification and documentation ). The documentation has a working demo of this input type. Instead of reading the value property, read the valueAsNumber property of the input to get the typed value as a number rather than a string. Usage inside a is recommended because validation is made easier this way; for example, pressing Enter will automatically show an error message if the value is invalid. You can use the checkValidity method or the requestSubmit method on the entire form in order to explicitly check the validity. Note that you might need to use the required attribute in order to disallow an empty input. You can use the checkValidity method or the validity property on the input element itself in order to explicitly check the validity. You can use reportValidity to show an error message and use setCustomValidity to set your own message. This approach fundamentally has a different user experience: you are allowed to input invalid characters and the validation is performed separately . This has the benefit that the undo stack ( Ctrl Z ) won’t break. Note that server-side validation must be performed, regardless, no matter which approach you choose. But note that browser support varies: Most browsers will only validate the input when submitting the form, and not when typing. Most mobile browsers don’t support the step , min and max attributes. Chrome (version 71.0.3578.98) still allows the user to enter the characters e and E into the field. Also see the Q&A Why does the HTML input with type="number" allow the letter e to be entered in the field? . Firefox (version 64.0) and Edge (EdgeHTML version 17.17134) still allow the user to enter any text into the field. Demo document.querySelector("form").addEventListener("submit", (event) => { event.preventDefault(); console.log(`Submit! Number is ${event.target.elements.number.valueAsNumber}, integer is ${event.target.elements.integer.valueAsNumber}, form data is ${JSON.stringify(Object.fromEntries(new FormData(event.target).entries()))}.`); }) label { display: block; } Get a feel for the UX here: Enter any number: Enter any integer: Submit:
