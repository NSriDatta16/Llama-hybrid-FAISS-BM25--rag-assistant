[site]: stackoverflow
[post_id]: 495380
[parent_id]: 
[tags]: 
C#: How to make a form remember its Bounds and WindowState (Taking dual monitor setups into account)

I have made a class which a form can inherit from and it handles form Location, Size and State. And it works nicely. Except for one thing: When you maximize the application on a different screen than your main one, the location and size (before you maximized) gets stored correctly, but when it is maximized (according to its previous state) it is maximized on my main monitor. When I then restore it to normal state, it goes to the other screen where it was before. When I then maximize it again, it of course maximized on the correct screen. So my question is... how can I make a form, when it is maximized, remember what screen it was maximized on? And how do I restore that when the form opens again? Kind of complete solution to problem I accepted the answer which had a very good tip about how to if on screen. But that was just part of my problem, so here is my solution: On load First get stored Bounds and WindowState from whatever storage. Then set the Bounds . Make sure Bounds are visible either by Screen.AllScreens.Any(ø => ø.Bounds.IntersectsWith(Bounds)) or MdiParent.Controls.OfType ().First().ClientRectangle.IntersectsWith(Bounds) . If it doesn't, just do Location = new Point(); . Then set window state. On closing Store WindowState . If WindowState is FormWindowState.Normal , then store Bounds , otherwise store RestoreBounds . And thats it! =) Some example code So, as suggested by Oliver , here is some code. It needs to be fleshed out sort of, but this can be used as a start for whoever wants to: PersistentFormHandler Takes care of storing and fetching the data somewhere. public sealed class PersistentFormHandler { /// The form identifier in storage. public string Name { get; private set; } /// Gets and sets the window state. (int instead of enum so that it can be in a BI layer, and not require a reference to WinForms) public int WindowState { get; set; } /// Gets and sets the window bounds. (X, Y, Width and Height) public Rectangle WindowBounds { get; set; } /// Dictionary for other values. private readonly Dictionary otherValues; /// /// Instantiates new persistent form handler. /// /// The will be used as . /// Default state of the window. /// Default bounds of the window. public PersistentFormHandler(Type windowType, int defaultWindowState, Rectangle defaultWindowBounds) : this(windowType, null, defaultWindowState, defaultWindowBounds) { } /// /// Instantiates new persistent form handler. /// /// The will be used as base . /// Use this if you need to separate windows of same type. Will be appended to . /// Default state of the window. /// Default bounds of the window. public PersistentFormHandler(Type windowType, string id, int defaultWindowState, Rectangle defaultWindowBounds) { Name = string.IsNullOrEmpty(id) ? windowType.FullName : windowType.FullName + ":" + id; WindowState = defaultWindowState; WindowBounds = defaultWindowBounds; otherValues = new Dictionary (); } /// /// Looks for previously stored values in database. /// /// False if no previously stored values were found. public bool Load() { // See Note 1 } /// /// Stores all values in database /// public void Save() { // See Note 2 } /// /// Adds the given to the collection of values that will be /// stored in database on . /// /// Type of object. /// The key you want to use for this value. /// The value to store. public void Set (string key, T value) { // Create memory stream using (var s = new MemoryStream()) { // Serialize value into binary form var b = new BinaryFormatter(); b.Serialize(s, value); // Store in dictionary otherValues[key] = new Binary(s.ToArray()); } } /// /// Same as , but uses default( ) as fallback value. /// /// Type of object /// The key used on . /// The stored object, or the default( ) object if something went wrong. public T Get (string key) { return Get(key, default(T)); } /// /// Gets the value identified by the given . /// /// Type of object /// The key used on . /// Value to return if the given could not be found. /// In other words, if you haven't used yet. /// The stored object, or the object if something went wrong. public T Get (string key, T fallback) { // If we have a value with this key if (otherValues.ContainsKey(key)) { // Create memory stream and fill with binary version of value using (var s = new MemoryStream(otherValues[key].ToArray())) { try { // Deserialize, cast and return. var b = new BinaryFormatter(); return (T)b.Deserialize(s); } catch (InvalidCastException) { // T is not what it should have been // (Code changed perhaps?) } catch (SerializationException) { // Something went wrong during Deserialization } } } // Else return fallback return fallback; } } Note 1: In the load method you have to look for previously stored WindowState , WindowBounds and other values. We use SQL Server, and have a Window table with columns for Id , Name , MachineName (for Environment.MachineName ), UserId , WindowState , X , Y , Height , Width . So for every window, you would have one row with WindowState , X , Y , Height and Width for each user and machine. In addition we have a WindowValues table which just has a foreign key to WindowId , a Key column of type String and a Value column of type Binary . If there is stuff that is not found, I just leave things default and return false. Note 2: In the save method you then, of course do the reverse from what you do in the Load method. Creating rows for Window and WindowValues if they don't exist already for the current user and machine. PersistentFormBase This class uses the previous class and forms a handy base class for other forms. // Should have been abstract, but that makes the the designer crash at the moment... public class PersistentFormBase : Form { private PersistentFormHandler PersistenceHandler { get; set; } private bool handlerReady; protected PersistentFormBase() { // Prevents designer from crashing if (LicenseManager.UsageMode != LicenseUsageMode.Designtime) { Load += persistentFormLoad; FormClosing += persistentFormFormClosing; } } protected event EventHandler ValuesLoaded; protected event EventHandler StoringValues; protected void StoreValue (string key, T value) { if (!handlerReady) throw new InvalidOperationException(); PersistenceHandler.Set(key, value); } protected T GetValue (string key) { if (!handlerReady) throw new InvalidOperationException(); return PersistenceHandler.Get (key); } protected T GetValue (string key, T fallback) { if (!handlerReady) throw new InvalidOperationException(); return PersistenceHandler.Get(key, fallback); } private void persistentFormLoad(object sender, EventArgs e) { // Create PersistenceHandler and load values from it PersistenceHandler = new PersistentFormHandler(GetType(), (int) FormWindowState.Normal, Bounds); PersistenceHandler.Load(); handlerReady = true; // Set size and location Bounds = PersistenceHandler.WindowBounds; // Check if we have an MdiParent if(MdiParent == null) { // If we don't, make sure we are on screen if (!Screen.AllScreens.Any(ø => ø.Bounds.IntersectsWith(Bounds))) Location = new Point(); } else { // If we do, make sure we are visible within the MdiClient area var c = MdiParent.Controls.OfType ().FirstOrDefault(); if(c != null && !c.ClientRectangle.IntersectsWith(Bounds)) Location = new Point(); } // Set state WindowState = Enum.IsDefined(typeof (FormWindowState), PersistenceHandler.WindowState) ? (FormWindowState) PersistenceHandler.WindowState : FormWindowState.Normal; // Notify that values are loaded and ready for getting. var handler = ValuesLoaded; if (handler != null) handler(this, EventArgs.Empty); } private void persistentFormFormClosing(object sender, FormClosingEventArgs e) { // Set common things PersistenceHandler.WindowState = (int) WindowState; PersistenceHandler.WindowBounds = WindowState == FormWindowState.Normal ? Bounds : RestoreBounds; // Notify that values will be stored now, so time to store values. var handler = StoringValues; if (handler != null) handler(this, EventArgs.Empty); // Save values PersistenceHandler.Save(); } } And thats pretty much it. To use it, a form would just inherit from the PersistentFormBase. That would automatically take care of bounds and state. If anything else should be stored, like a splitter distance, you would listen for the ValuesLoaded and StoringValues events and in those use the GetValue and StoreValue methods. Hope this can help someone! Please let me know if it does. And also, please provide some feedback if there is anything you think could be done better or something. I would like to learn =)
