[site]: stackoverflow
[post_id]: 5417259
[parent_id]: 5416874
[tags]: 
Depends what you mean by "sufficient memory available". For a simple fragmentation "attack": Make a squillion small allocations until one fails[*]. Now, sort them in order of address[**]. Free 100 alternate allocations. Attempt to allocate 100*small bytes. Chances are the allocator will fail to find contiguous memory to satisfy that. If it has a small page size, and plenty of virtual address space compared with physical memory, then it might be able to rearrange things to do it - but that requires capabilities of the MMU on top of any anti-fragmentation strategy by the allocator. If by "sufficient available memory" you mean a large block of memory that formerly was a contiguous block, has been split up into several allocations all of which have since been freed, and now the allocator treats it as separate blocks and so fails to allocate large bytes then no, I don't think you can force an arbitrary block-box allocator to fail to coalesce blocks. Some allocator or other might do much more work than Windows appears to be doing in that other question, to guarantee that adjacent free blocks are always coalesced. [*] possible problem - over-committing memory allocators might not fail, you just get a segfault or your process is killed. On such systems you might need to track how much memory is available. [**] possible problem - in C and C++, operator isn't guaranteed to work. But on almost all systems it does, and in C++ there's std::less too.
