[site]: stackoverflow
[post_id]: 1286924
[parent_id]: 1286842
[tags]: 
The relevant documentation is at: http://qt-project.org/doc/qt-4.8/qxmlquery.html#running-xpath-expressions . The solution I came to was to use QXmlQuery to generate an XML file then parse it again using QDomDocument. RhythmboxTrackModel::RhythmboxTrackModel() { QXmlQuery query; QXmlQuery entries; QString res; QDomDocument rhythmdb; /* * Try and open the Rhythmbox DB. An API call which tells us where * the file is would be nice. */ QFile db(QDir::homePath() + "/.gnome2/rhythmbox/rhythmdb.xml"); if ( ! db.exists()) { db.setFileName(QDir::homePath() + "/.local/share/rhythmbox/rhythmdb.xml"); if ( ! db.exists()) return; } if (!db.open(QIODevice::ReadOnly | QIODevice::Text)) return; /* * Use QXmlQuery to execute and XPath query. Check the version to * make sure. */ query.setFocus(&db); query.setQuery("rhythmdb[@version='1.6']/entry[@type='song']"); if ( ! query.isValid()) return; query.evaluateTo(&res); db.close(); /* * Parse the result as an XML file. These shennanigans actually * reduce the load time from a minute to a matter of seconds. */ rhythmdb.setContent("" + res + ""); m_entryNodes = rhythmdb.elementsByTagName("entry"); for (int i = 0; i In case anyone is wondering, this is my code taken from a recent branch of the Mixxx project , specifically the features_looping branch. The things I dislike about this solution are: Parsing the XML twice Concatenating the result with a starting and ending tag.
