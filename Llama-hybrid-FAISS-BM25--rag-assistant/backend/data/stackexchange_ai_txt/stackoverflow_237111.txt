[site]: stackoverflow
[post_id]: 237111
[parent_id]: 236801
[tags]: 
If possible, as non-member and non-friend functions. As described by Herb Sutter and Scott Meyers, prefer non-friend non-member functions to member functions, to help increase encapsulation. In some cases, like C++ streams, you won't have the choice and must use non-member functions. But still, it does not mean you have to make these functions friends of your classes: These functions can still acess your class through your class accessors. If you succeed in writting those functions this way, then you won. About operator > prototypes I believe the examples you gave in your question are wrong. For example; ostream & operator I can't even start to think how this method could work in a stream. Here are the two ways to implement the > operators. Let's say you want to use a stream-like object of type T. And that you want to extract/insert from/into T the relevant data of your object of type Paragraph. Generic operator > function prototypes The first being as functions: // T > Paragraph T & operator >> (T & p_oInputStream, const Paragraph & p_oParagraph) { // do the extraction of p_oParagraph return p_oInputStream ; } Generic operator > method prototypes The second being as methods: // T > Paragraph T & T::operator >> (const Paragraph & p_oParagraph) { // do the extraction of p_oParagraph return *this ; } Note that to use this notation, you must extend T's class declaration. For STL objects, this is not possible (you are not supposed to modify them...). And what if T is a C++ stream? Here are the prototypes of the same > operators for C++ streams. For generic basic_istream and basic_ostream Note that is case of streams, as you can't modify the C++ stream, you must implement the functions. Which means something like: // OUTPUT std::basic_ostream & operator & p_oOutputStream, const Paragraph & p_oParagraph) { // do the insertion of p_oParagraph return p_oOutputStream ; } // INPUT >> Paragraph template std::basic_istream & operator >> (std::basic_istream & p_oInputStream, const CMyObject & p_oParagraph) { // do the extract of p_oParagraph return p_oInputStream ; } For char istream and ostream The following code will work only for char-based streams. // OUTPUT > A std::istream & operator >> (std::istream & p_oInputStream, const Paragraph & p_oParagraph) { // do the extract of p_oParagraph return p_oInputStream ; } Rhys Ulerich commented about the fact the char-based code is but a "specialization" of the generic code above it. Of course, Rhys is right: I don't recommend the use of the char-based example. It is only given here because it's simpler to read. As it is only viable if you only work with char-based streams, you should avoid it on platforms where wchar_t code is common (i.e. on Windows). Hope this will help.
