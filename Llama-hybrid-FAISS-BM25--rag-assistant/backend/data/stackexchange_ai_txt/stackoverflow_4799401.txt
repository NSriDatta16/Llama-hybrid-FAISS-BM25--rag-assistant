[site]: stackoverflow
[post_id]: 4799401
[parent_id]: 
[tags]: 
Python's super(), abstract base classes, and NotImplementedError

Abstract base classes can still be handy in Python. In writing an abstract base class where I want every subclass to have, say, a spam() method, I want to write something like this: class Abstract(object): def spam(self): raise NotImplementedError The challenge comes in also wanting to use super() , and to do it properly by including it in the entire chain of subclasses. In this case, it seems I have to wrap every super call like the following: class Useful(Abstract): def spam(self): try: super(Useful, self).spam() except NotImplementedError, e: pass print("It's okay.") That's okay for a simple subclass, but when writing a class that has many methods, the try-except thing gets a bit cumbersome, and a bit ugly. Is there a more elegant way of subclassing from abstract base classes? Am I just Doing It Wrong?
