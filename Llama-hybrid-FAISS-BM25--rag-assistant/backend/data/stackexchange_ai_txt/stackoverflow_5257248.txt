[site]: stackoverflow
[post_id]: 5257248
[parent_id]: 5257049
[tags]: 
The main issue is that the process doesn't reverse perfectly. std::ofstream ofs; // presumed open ofs > r1 >> r2 >> r3 >> r4 >> r5; // variables of same types as above You might think that will work but probably won't. There are no formal delimiters when writing to a text stream, you have to manually insert them to know when one token ends and another begins. Usually with regards to strings, it is assumed that they contain no newline characters or no tab characters, and then when reading back, these are often used as a delimiter. The most "perfect" way to write a string so you can read it back is to write its size then its content. Even then if you use iostream: os will not put any space between the size and the content, so if the content begins with a digit you are in trouble when reading it back later. os will work. With regards to reading big collections, your best bet with strings is to have tab-separated or line-separated and use std::getline in a loop. istream_iterator will simply not work if any of your strings have spaces. Your alternative is to first read in a header section with: - number of strings - size of each string. Then read in the data just from a big buffer, and by knowing how many you are about to read and their sizes, you can pre-allocate your buffers. Writing binary means writing raw bytes to the file. This is similar to the fwrite function in C, except you do not specify two sizes, just one size which is the number of bytes you will write. You need to address issues that: - Windows will insert an ASCII 13 character for you in front of every ASCII 10 character you write if you do not open the stream for binary. - If you are writing numbers byte-wise, beware of endian and size issues if they will be read back. The best way to address this is to put the endian-ness in the header section of your output and then write in native format. The assumption is that most of the time this will be the platform you use so it is more efficient. int x; os.write( &x, sizeof(int) ); The big plus-side of writing numbers this way is not only is it more efficient in time but there is also no need to insert any kind of delimiter so reading them back becomes relatively simple. The downside is that you will need a special interpreter to read the file back if there are any errors in it. Anyway, these are the issues. The elegant solution to all this is provided as part of the boost library with archive and serialize . You can write in text or binary mode and it will restore the way you stored it. It will even write pointers "deeply" for you.
