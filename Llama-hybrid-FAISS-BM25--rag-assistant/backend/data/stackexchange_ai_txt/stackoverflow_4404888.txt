[site]: stackoverflow
[post_id]: 4404888
[parent_id]: 4404675
[tags]: 
Thought experiment: Use three tableviews, but use the same datasource/delegate. Wire it up so whenever one view scrolls (i.e. through â€“scrollViewDidScroll: ), you also manually scroll the other views with -setContentOffset to the appropriate position. You should beware of possible circular calls though. I can't guarantee this will work, but this is as close as you can get that I can think of. You may also want to add extra rows above and below for particular views if you want the leftmost view to be able to scroll to the bottom, or the rightmost view to scroll to the top. Edit: For the most part, it's as basic as it seems. I just tried it out and wasn't too bad. There are some little quirks you will have to take care of though, including the circular calls, and the deceleration of scrollviews. For the circular calls I mentioned earlier, I managed my way around it by using the following code: -(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{ tableView1.delegate = nil; tableView2.delegate = nil; tableView3.delegate = nil; scrollView.delegate = self; } -(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { tableView1.delegate = self; tableView2.delegate = self; tableView3.delegate = self; } As for deceleration afterwards, it's not so much that the other views won't decelerate alongside them, but the views act a little wonky if you do touches on one of the other ones while they're decelerating. I didn't try it in this case to see if it'll work 100% for this, but you should try to code from here to stop the deceleration dead in its tracks when you start dragging it again.
