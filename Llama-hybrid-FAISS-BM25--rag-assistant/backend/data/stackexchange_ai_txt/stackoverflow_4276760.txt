[site]: stackoverflow
[post_id]: 4276760
[parent_id]: 4275952
[tags]: 
Okay, I will give it a shot. MVC is not hard, but you do have to alter your way of thinking a bit. In MVC you have the Models (your data layer[s]), the Views and the Controllers. Before we continue, I make the assumptions with my examples below that you are using LINQ to SQL for you data access layer (Model), and I have labeled it as dc . The Controllers fetch and format the data out of the Models and hand it off to the Views to display. So lets start with your first view which would be the view to create a TimeSegment. [HttpGet] public ActionResult CreateTimeSegment() { return View(new TimeSegmentView { Consultants = dc.Consultants.ToList(), Projects = dc.Projects.ToList(), Tasks = dc.Tasks.ToList() }); } This action will create a TimeSegmentView object and pass that to the View as its Model . Keep in mind that this action is decorated with [HttpGet] . TimeSegmentView` is a container class for the objects you need to pass to the view to create your UI and it looks like this: public class TimeSegmentView { public IList Consultants { get; set; } public IList Projects { get; set; } public IList Tasks { get; set; } public TimeSegment TimeSegment { get; set; } } NOTE: I'm not using the TimeSegment property yet, it's further down... In the view make sure you have it inherit from TimeSegmentView. Assuming that you're following the default MVC project structure and with me taking the liberty to add a Views folder into the Models folder your full reference would look like this: " %> Now you've typed the view to that object and you can now interact with its properties. So, you can build a form such as: Hours Date Consultant "> Project "> Task "> As you can see it created 3 select fields and just performed loops in each of them to build up their values based off of the model. Now, taking a submission of this form, we'll need to get the data and add it to our database with: [HttpPost] public RedirectToRouteResult CreateTimeSegment( [Bind(Prefix = "TimeSegment", Include = "Hours,Date,ConsultantID,ProjectID,TaskID")] TimeSegment TimeSegment) { dc.TimeSegments.InsertOnSubmit(TimeSegment); dc.SubmitChanges(); return RedirectToAction("EditTimeSegment", new { TimeSegmentID = TimeSegment.TimeSegmentID }); } Okay, first notice that I've named the action the same, but this one has an [HttpPost] decoration. I'm telling the action that I'm sending it a TimeSegment object and that I want it to bind the properties in the Include clause (this is mostly for security and validation). I then take the TimeSegment object I've passed in, add it to the data context, submit the changes and redirect. In this case I'm redirecting to another action to edit the object I just created passing in the new TimeSegmentID . You can redirect to what ever, this just felt appropriate to me... [HttpGet] public ActionResult EditTimeSegment( int TimeSegmentID) { return View(new TimeSegmentView { Consultants = dc.Consultants.ToList(), Projects = dc.Projects.ToList(), Tasks = dc.Tasks.ToList(), TimeSegment = dc.TimeSegments.Single(t => t.TimeSegmentID == TimeSegmentID) }); } In the edit action your doing the same thing as in the create action by building a new TimeSegmentView object and passing it to the view. The key difference here is that you're now populating the TimeSegment property. Your form would look something like this (shortened from above): " method="post"> Hours " /> And your receiving action on the controller would look like this: [HttpPost] public RedirectToRouteResult EditTimeSegment( int TimeSegmentID) { TimeSegment TS = dc.TimeSegments.Single(t => t.TimeSegmentID == TimeSegmentID); TryUpdateModel (TS, "TimeSegment", new string[5] { "Hours", "Date", "ConsultantID", "ProjectID", "TaskID" }); dc.SubmitChanges(); return RedirectToAction("EditTimeSegment", new { TimeSegmentID = TimeSegment.TimeSegmentID }); } Lastly, if you want to display a list of TimeSegments you can do something like this: [HttpGet] public ActionResult ListTimeSegments() { return View(new TimeSegmentsView { TimeSegments = dc.TimeSegments.ToList() }); } And TimeSegmentsView looks like this: public class TimeSegmentsView { public IList TimeSegments { get; set; } } And in the View you'd want to do this: I hope this is enough to give you a start. It's by no means complete, but its 5 AM and I haven't slept yet, so this will have to do for now (from me). Feel free to name your actions what you want, you don't have to stick to my naming conventions. I would suggest however that you change the naming of the properties of your tables. For example when your writing the expressions like in the table above you'll have to do TS.Project.ProjectName and that's redundant. You're already accessing the Project property of TS through their relationship so you know you're only going to work with a Project . This then makes ProjectName a pointless blob of text re-describing the object your working with. Instead just use Name , and turn your expression to TS.Project.Name . Anyway, just a suggestion, do what you like better. I'm passing out, so good night and happy Thanksgiving! UPDATE The process with collections is essentially the same as far as the controller side is conserned. It's the client side and the JavaScript that's more difficult to get going, so I'll assume that you have something established on that end. So, here's how the controller would work. You pass in an array of TimeSegment and the model binder is smart enough to figure it out through the Prefix of your form elements. " method="post"> Hours Hours And the controller: [HttpPost] public RedirectToRouteResult CreateTimeSegments( [Bind(Prefix = "TimeSegment", Include = "Hours,Date,ConsultantID,ProjectID,TaskID")] TimeSegment[] TimeSegments) { dc.TimeSegments.InsertAllOnSubmit(TimeSegments); dc.SubmitChanges(); return RedirectToAction("ListTimeSegments"); } And that's it. Of course you'll want to validate or do other stuff before sending to the database, but that's roughly all there is to it. UPDATE 2 I believe you can do an IList instead of TimeSegment[] without issues, but as far as if it's better, that's up for debate. The way I look at it the browser still sends a virtual array to the server so having the action receive an array feels natural, but its up to you what you want to use. So, a generic list action would look like this: [HttpPost] public RedirectToRouteResult CreateTimeSegments( [Bind(Prefix = "TimeSegment", Include = "Hours,Date,ConsultantID,ProjectID,TaskID")] IList TimeSegments) { dc.TimeSegments.InsertAllOnSubmit(TimeSegments); dc.SubmitChanges(); return RedirectToAction("ListTimeSegments"); } Keep in mind that I haven't used this (meaning the IList) before so I can't guarantee it will work, just speculating... UPDATE 3 About what you want to do with the Consultant , it sound a lot like what I do with Cookies. I have a BaseView class which is the type used by the Site.Master and then all other views extend from it. In the BaseView I have a Cookie property which is always populated by each controller action. I then use that property to get the id of the currently authorized user. So, in code it looks like this (using examples from one of my apps): public class BaseView { // Don't confuse with an HttpCookie, this is an object in my database... public Cookie Cookie { get; set;} } public class EmployeeView : BaseView { public Employee Employee { get; set; } } And with this, say I want to add a note to an employee, my form would look like this where I pass in a hidden field which is where your ConsultantID comes into play. " /> Hope this helps.
