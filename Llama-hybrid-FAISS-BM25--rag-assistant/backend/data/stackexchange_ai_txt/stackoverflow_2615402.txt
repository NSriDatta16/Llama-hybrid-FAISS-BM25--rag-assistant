[site]: stackoverflow
[post_id]: 2615402
[parent_id]: 2613935
[tags]: 
This seems to do it: $ for rev in $(git rev-list --branches); do git rev-list $rev \ | grep $(git rev-parse base) &>/dev/null \ && echo $rev; done \ | xargs -L 1 git rev-list -n 1 --oneline f16fd151b374b2aeec8b9247489c518a6347d001 merged in the latest from the base branch 564d795afb63eab4ffe758dbcd726ca8b790f9f6 spelling correction The last pipe section with xargs is just to show the commit messages for each of those commits. This lists the target commit in addition to its children, which is actually what I wanted. It's pretty durn slow though: it took over 3 seconds to run on a 40-commit repo. This is unsurprising since it's about as brute force as Andr√© the Giant. I guess a more elegant method would go through the rev-list for each ref and build a tree of the hashes of each commit linked to its children, then walk it starting at the target commit. But that's kind of complicated, so I was hoping that there was a git command for that :) I still need to figure out how to get this set of commits into filter-branch . I guess I can just grep the rev-list of $GIT_COMMIT from within my --tree-filter command.
