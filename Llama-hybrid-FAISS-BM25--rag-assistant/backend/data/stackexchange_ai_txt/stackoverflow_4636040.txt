[site]: stackoverflow
[post_id]: 4636040
[parent_id]: 4635945
[tags]: 
NOTE: The following answer is wrong , starting as it does from an flawed premise! Rather than redact the entire thing to save my blushes, I have left it intact so that the comments highlighting the error make sense, How can this possibly be supported safely ? Given (if this is what you have in mind, which I think it is): type TFoo = class end; PFoo = ^TFoo ; Then if we have: var a, b: TFoo ; p: PFoo ; a := TFoo .Create; b := TFoo .Create; Then both of the following would be permissible: p := @a; p := @b; At any given time p might dereference to any TFoo of T , but at any given time it can only ever reference a specific T . I cannot see any type-safe compile time mechanism for ensuring that code dereferences p correctly. One way to get around this issue (not a limitation of the compiler, but a limitation of trying to express something in a type safe way for which type safety simply cannot be expressed) would be to create type-specific derivatives of these types and use those. At the point at which you wish to dereference you are almost certainly going to know the type T anyway: type TFoo = class end; TFooString = TFoo ; PFooString = ^TFooString; var p: PFooString; a := TFoo ; b := TFoo ; p := @a; // Should not compile p := @b; // This is OK This is possible even in Delphi 2010. However, worryingly, in investigating this I find that: p := @a; // Should not compile DOES in fact compile. Which strikes me as wrong. VERY wrong. And could point to (yet) another flaw in the generics implementation in Delphi. Here be dragons...
