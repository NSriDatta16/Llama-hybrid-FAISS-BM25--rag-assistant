[site]: stackoverflow
[post_id]: 460896
[parent_id]: 460882
[tags]: 
It depends on where the DTOs are defined and how you want to test it. If you use DBML, then LINQ to SQL wants to generate the data objects in the data layer. While LINQ to SQL supports persistance ignorance, it doesn't go out of its way to make it easy. Entity Framework doesn't support it at all. This means that in the standard model, your data layer is defining all the domain entities, which is tricky if you want to test the user interface/business layers in true isolation from the data layer. A pragmatic approach might be to use the data object definitions from the data layer in unit tests, but not the data-context (i.e. hide the data-context behind the repository interface, but expose the entity types) - but this is muddying the waters a little, and means your UI, etc. need to strongly reference the data layer. But if you think of this as a "domain model layer which happens to also contain a repository implementation that we may or may not be using" you might justify it. Keeping completely separate domain entities makes unit testing and inversion of control (IoC) more "pure", but increases the amount of code you have (so double-edged).
