[site]: stackoverflow
[post_id]: 2285756
[parent_id]: 2285437
[tags]: 
[Edit from non-author: this is from 2010, and the process has been significantly simplified since May 2011. I'll add a post to this answer with my setup notes as of Feb 2012.] You'll need to put together a few pieces: Emacs, SLIME (which works perfectly well with Clojure -- see swank-clojure), swank-clojure (the Clojure implementation of SLIME's server counterpart), clojure-mode, Paredit and, of course, the Clojure jar for a start, then perhaps some extras among which Leiningen would perhaps be the most notable. Once you do set it all up, you'll have -- within Emacs -- all the workflow / editing features you mention in the question. Basic setup: The following are to great tutorials which describe how to set all of this up; there's more on the Web, but some of the others are quite outdated, whereas these two seem to be ok for now: in which are found tricks of the trade concerning clojure authorship post on Phil Hagelberg's blog; Phil maintains swank-clojure and clojure-mode, as well as a package called the Emacs Starter Kit which is something any newcomer to the Emacs world would be well-advised to have a look at. These instructions seem to have been brought up to date with recent changes to the infrastructure; in case of doubt, look for additional information on Clojure's Google group. Setting up Clojure, Incanter, Emacs, Slime, Swank, and Paredit post on the blog of the Incanter project. Incanter is a fascinating package providing an R-like DSL for statistical computations embedded right into Clojure. This post will be useful even if you don't plan on using -- or even installing -- Incanter. Putting it all to work: Once you set up all of this stuff, you could try and start using it right away, but I would strongly advise you to do the following: Have a look at SLIME's manual -- it's included in the sources and is actually very readable. Also, there's absolutely no reason why you should read the whole 50-page monster manual; just have a look around to see what features are available. Note: the autodoc feature of SLIME as found in the latest upstream sources is incompatible with swank-clojure -- this problem won't come up if you follow Phil Hagelberg's recommendation to use the ELPA version (see his aforementioned blog post for an explanation) or simply leave autodoc off (which is the default state of things). The latter option has some added appeal in that you can still use the latest SLIME with Common Lisp, in case you use that as well. Have a look at the docs for paredit. There are two ways to go about this: (1) look at the source -- there's a huge amount of comments at the top of the file which contain all the information you're likely to need; (2) type C-h m in Emacs while paredit-mode is active -- a buffer will pop up with information on the current major mode followed by information on all active minor modes (paredit is one of those). Update: I've just found this cool set of notes on Paredit by Phil Hagelberg... That's a link to a text file, I remember seeing a nice set of slides with this information somewhere, but can't seem to find it now. Anyway, it is a nice summary of how it works. Definitely take a look at it, I can't live without Paredit now and this file should make it very easy to start using it, I believe. :-) In fact, the C-h m combination will tell you about all keybindings active at the SLIME REPL, in clojure-mode (you'll want to remember C-c C-k for sending the current buffer off for compilation) and indeed in any Emacs buffer. As for loading the code from a file and then experimenting with it at the REPL: use the aforementioned C-c C-k combination to compile the current buffer, then use or require its namespace at the REPL. Next, experiment away. Final notes: Be prepared to have to tweak things for a while before it all clicks. There's a lot of tools involved and their interactions are mostly fairly smooth, but not to the point where it would be safe to assume you won't have to make some adjustments initially. Finally, here's a bit of code I keep in .emacs which you won't find elsewhere (although it's based on a cool function by Phil Hagelberg). I alternate between starting my swank instances with lein swank (one of the cooler features of Leiningen) and using the clojure-project function as found below to start the whole thing from within Emacs. I've done my best to make the latter produce an environment closely matching that provided by lein swank . Oh, and if you just want a REPL in Emacs for a quick and dirty experiment, then with the correct setup you should be able to use M-x slime directly. (setq clojure-project-extra-classpaths '( ; "deps/" "src/" "classes/" "test/" )) (setq clojure-project-jar-classpaths '( ; "deps/" "lib/" )) (defun find-clojure-project-jars (path) (apply #'append (mapcar (lambda (d) (loop for jar in (remove-if (lambda (f) (member f '("." ".."))) (directory-files d t)) collect jar into jars finally return jars)) (remove-if-not #'file-exists-p clojure-project-jar-classpaths)))) (defun find-clojure-jar (jars) (let ((candidates (remove-if-not (lambda (jar) (string-match-p "clojure\\([0-9.-]+\\(SNAPSHOT|MASTER\\)?\\)?\\.jar$" jar)) jars))) (if candidates (car candidates) (expand-file-name "~/.clojure/clojure.jar")))) (defun find-clojure-contrib-jar (jars) (let ((candidates (remove-if-not (lambda (jar) (string-match-p "clojure-contrib\\([0-9.-]+\\(SNAPSHOT|MASTER\\)?\\)?\\.jar$" jar)) jars))) (if candidates (car candidates) (expand-file-name "~/.clojure/clojure-contrib.jar")))) ;;; original due to Phil Hagelberg ;;; (see `Best practices for Slime with Clojure' thread on Clojure Google Group) (defun clojure-project (path) "Sets up classpaths for a clojure project and starts a new SLIME session. Kills existing SLIME session, if any." (interactive (list (ido-read-directory-name "Project root:" (locate-dominating-file default-directory "pom.xml")))) (when (get-buffer "*inferior-lisp*") (kill-buffer "*inferior-lisp*")) (cd path) ;; I'm not sure if I want to mkdir; doing that would be a problem ;; if I wanted to open e.g. clojure or clojure-contrib as a project ;; (both lack "deps/") ; (mapcar (lambda (d) (mkdir d t)) '("deps" "src" "classes" "test")) (let* ((jars (find-clojure-project-jars path)) (clojure-jar (find-clojure-jar jars)) (clojure-contrib-jar (find-clojure-contrib-jar jars))) (setq swank-clojure-binary nil ;; swank-clojure-jar-path (expand-file-name "~/.clojure/clojure.jar") swank-clojure-jar-path clojure-jar swank-clojure-extra-classpaths (cons clojure-contrib-jar (append (mapcar (lambda (d) (expand-file-name d path)) clojure-project-extra-classpaths) (find-clojure-project-jars path))) swank-clojure-extra-vm-args (list (format "-Dclojure.compile.path=%s" (expand-file-name "classes/" path))) slime-lisp-implementations (cons `(clojure ,(swank-clojure-cmd) :init swank-clojure-init) (remove-if #'(lambda (x) (eq (car x) 'clojure)) slime-lisp-implementations)))) (slime))
