[site]: stackoverflow
[post_id]: 1447599
[parent_id]: 1447474
[tags]: 
Handling Large Changes In my experience, these are relatively infrequent. When they do happen, updating the tests is a minor hassle. The trick is to pick the right granularity for the tests. If you test the public interface, updates will go quickly. If you test the private implementation code, changing from a SAX to a DOM parser will sax big time and you'll feel dom. ;-) Testing GUI Code In general I don't. I keep my UI layer as thin as possible. The idea is to test what might break. Testing Database Code When possible I prefer to place data-access code behind interfaces and mock that out when testing the business logic. As others have mentioned, at some point you may want to run integration tests against the DAL to insure that it works against a test database in a known state. You may want other integration tests of the entire system; having layers of different kinds of tests is a good thing. TDD is primarily about design, and does not eliminate the need for integration or acceptance tests. It's very possible to abuse mocks and stubs, writing tests that do nothing but test mock objects. It takes a lot of experience to write good tests; I'm still learning. My suggestion would be to keep practicing TDD, perhaps on smaller projects initially. Read as much as you can on it, talk to other practitioners, and use what works for you. Continuous Integration really helps with testing, as it insures that tests are run and makes broken tests visible. Highly recommended. EDIT: To be frank, I have trouble decoupling the data-access code in many cases and end up using test deck databases. Even integration tests like these have proved valuable, although they're slower and more fragile. As I said, I'm still learning.
