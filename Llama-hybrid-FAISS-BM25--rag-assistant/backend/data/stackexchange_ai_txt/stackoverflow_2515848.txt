[site]: stackoverflow
[post_id]: 2515848
[parent_id]: 2515829
[tags]: 
No, local variables don't have a default value 1 . They have to be definitely assigned before you read them. This reduces the chance of you using a variable you think you've given a sensible value to, when actually it's got some default value. This can't be done for instance or static variables because you don't know in what order methods will be called. See section 5.3 of the C# 3.0 spec for more details of definite assignment. Note that this has nothing to do with this being a reference type variable. This will fail to compile in the same way: int i; if (i == 0) // Nope, i isn't definitely assigned { } 1 As far as the language is concerned, anyway... clearly the storage location in memory has something in it, but it's irrelevant and implementation-specific. There is one way you can find out what that value is, by creating a method with an out parameter but then using IL to look at the value of that parameter within the method, without having given it another value. The CLR doesn't mind that at all. You can then call that method passing in a not-definitely-assigned variable, and lo and behold you can detect the value - which is likely to be the "all zeroes" value basically. I suspect that the CLI specification does enforce local variables having a default value - but I'd have to check. Unless you're doing evil things like the above, it shouldn't matter to you in C#.
