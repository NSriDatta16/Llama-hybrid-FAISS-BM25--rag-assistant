[site]: stackoverflow
[post_id]: 3695985
[parent_id]: 3695758
[tags]: 
In this project I need to create one huge array (hopefully I will be able to create one as big as ~7.13e+17, but this target is still up ahead.) That calls to create a dedicated structure, a la digital tree (or b-tree ) with key being the index, to avoid doing large allocations. Large allocations and especially reallocations might cause unnecessary memory fragmentation . If you split large array into smaller chunks, then not only array extension becomes easy, but also presentation of sparse array becomes possible. N.B. ~7.13e+17 is about 60 bit long. Do you even have hardware which can support that much RAM? It's not that I'm following industry closely, but I heard briefly about NUMA archs with 58 bit address bus - but nothing about 60+ bit archs. Each cell inside the array can contain one of the three values: 0, 1, 2.2. If cell might contain only 3 values (2.2 can be represented as 2) that makes it 2 bits of information. That means that you can pack into the uint32_t 16 values and into the uint64_t 32 values. You can try to find some existing digital tree implementation (or roll your own) and use as the key upper bits of index. Remaining bits of the original index would be an index into the tree leaf which would be an array with packed values. To exemplify using std::map in place of the trie, untested: enum { LS_BITS = 16, MS_BITS = 64-LS_BITS }; enum { VALUE_BITS = 2, VALUE_MASK = ((1 big_array_type; void big_array_set_value( big_array_type &b, uint64_t index, uint64_t value ) { leaf_node &n = b[index >> LS_BITS]; uint64_t li = index & ((1 > LS_BITS]; uint64_t li = index & ((1 > li) & VALUE_MASK; } This way one still wastes 0.5 bit of information since storage is 2 bits what allows to 4 values, yet only 3 are used. That can be also improved, but at much higher access performance cost.
