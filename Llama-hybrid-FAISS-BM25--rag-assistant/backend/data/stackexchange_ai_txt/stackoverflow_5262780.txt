[site]: stackoverflow
[post_id]: 5262780
[parent_id]: 5262693
[tags]: 
I suggest you give your factory implementation a method RegisterImplementation . So every new class is just a call to that method and you are not changing your factories code. UPDATE: What I mean is something like this: Create an interface that defines a calculation. According to your code, you already did this. For the sake of being complete, I am going to use the following interface in the rest of my answer: public interface ICalculation { void Initialize(string originalData); void DoWork(); } Your factory will look something like this: public class CalculationFactory { private readonly Dictionary > _calculations = new Dictionary >(); public void RegisterCalculation (string method) where T : ICalculation, new() { _calculations.Add(method, originalData => { var calculation = new T(); calculation.Initialize(originalData); return calculation; }); } public ICalculation CreateInstance(string method, string originalData) { return _calculations[method](originalData); } } This simple factory class is lacking error checking for the reason of simplicity. UPDATE 2: You would initialize it like this somewhere in your applications initialization routine: CalculationFactory _factory = new CalculationFactory(); public void RegisterCalculations() { _factory.RegisterCalculation ("Pivot"); _factory.RegisterCalculation ("GroupBy"); _factory.RegisterCalculation ("Standard deviation"); _factory.RegisterCalculation ("% phospho PRAS Protein"); _factory.RegisterCalculation ("AveragePPPperTreatment"); _factory.RegisterCalculation ("AvgPPPNControl"); _factory.RegisterCalculation ("PercentageInhibition"); }
