[site]: stackoverflow
[post_id]: 2291430
[parent_id]: 2291108
[tags]: 
I am not sure that any kind of standard thread locking or synchronization mechanisms will really work with so many threads. However, this might be a scenario where some basic messaging might be an ideal solution to the problem. Rather than using Thread.Join, which will block (and could be very difficult to manage with so many threads), you might try setting up one more thread that aggregates completion messages from your worker threads. When the aggregator has received all expected messages, it completes. You could then use a single WaitHandle between the aggregator and your main application thread to signal that all of your worker threads are done. public class WorkerAggregator { public WorkerAggregator(WaitHandle completionEvent) { m_completionEvent = completionEvent; m_workers = new Dictionary (); } private readonly WaitHandle m_completionEvent; private readonly Dictionary m_workers; public void StartWorker(Action worker) { var thread = new Thread(d => { worker(); notifyComplete(thread.ManagedThreadID); } ); lock (m_workers) { m_workers.Add(thread.ManagedThreadID, thread); } thread.Start(); } private void notifyComplete(int threadID) { bool done = false; lock (m_workers) { m_workers.Remove(threadID); done = m_workers.Count == 0; } if (done) m_completionEvent.Set(); } } Note, I have not tested the code above, so it might not be 100% correct. However I hope it illustrates the concept enough to be useful.
