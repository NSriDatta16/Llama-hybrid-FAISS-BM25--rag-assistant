[site]: datascience
[post_id]: 92725
[parent_id]: 12327
[tags]: 
When you have some historical data on good/bad matches (and "okay" features to describe these matches), you can try a Siamese Neural Network . This type of model is a "few shot" model, meaning that it is designed to work with a relatively small ammount of (training) data and potentially noisy features. Essentially you fit a model to pairs of (training) data ("matches"). The model will learn to interpret the available features so to calculate a Euclidean distance between pairs, e.g. $0 =$ "no distance" (perfect match) vs. $1 =$ "max. distance" (very poor match). The good thing is, that you can generate a lot of training data (by making pairs) even when there are few observations (the whole idea comes from image classification with few training images, works like a charm!). Once you have a trained model and you want to find a new match for a university applicant, you can simply make (hypothetical) pairs to be predicted by the model, e.g.: 1 Applicant A Alumni 1 2 Applicant A Alumni 2 3 Applicant A Alumni 3 When you feed these (hypothetical) matches to the network and make a prediction, you will get a vector of "distances" for the pairs, something like: 1 0.83 2 0.06 3 0.56 Provided that your training data are okay and that your model works well, you can immediately make a ranking of possible matches (lower distance would be better, i.e. $2 \succ 3 \succ 1$ in the example above). I'm a great fan of siamese networks. They can be a little complex, but when you get the model right, siamese networks are extremely powerful (and often more powerful than alternative models/approaches). I don't have sample code in R at hand. However, see this GitHub repo for a "toy version" of a siamese neural network with Keras/Tensorflow in Python. The model uses the "Iris data" (three classes). You should be able to use most of the code (data prep and model) off the shelf for your usecase. Maybe adjust some parts of the model, such as the hidden layers. Since Keras is also available for R, you could adapt the model to R. For the prediction part, just predict single pairs as described above (unlike averaging over classes like in the code sample). Note that the model in the sample code uses a custom lambda layer. So when you save the model, you need to save the weights only . When you load the model for prediction, just load the model in plain code and add (load) the weights. Lambda layers cannot be compiled properly by Keras' save/load command. So hardcoding the model and loading the weights only is required.
