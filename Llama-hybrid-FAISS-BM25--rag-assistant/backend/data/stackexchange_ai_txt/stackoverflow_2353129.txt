[site]: stackoverflow
[post_id]: 2353129
[parent_id]: 2352895
[tags]: 
I don't think you do - what I did to solve this problem was used a parallel region #pragma omp parallel shared(...) private(...) and allocated the array dynamically inside the parallel region. Try this: #include #include #include /* compile with gcc -o test2 -fopenmp test2.c */ int main(int argc, char** argv) { int i = 0; int size = 20; int* a = (int*) calloc(size, sizeof(int)); int* b = (int*) calloc(size, sizeof(int)); int* c; for ( i = 0; i That to me produced the same results as my earlier experiment program: #include #include #include /* compile with gcc -o test1 -fopenmp test1.c */ int main(int argc, char** argv) { int i = 0; int size = 20; int* a = (int*) calloc(size, sizeof(int)); int* b = (int*) calloc(size, sizeof(int)); for ( i = 0; i At a guess I'd say because OpenMP can't deduce the size of the array it can't be private - only compile-time arrays can be done this way. I get segfaults when I try to private a dynamically allocated array, presumably because of access violations. Allocating the array on each thread as if you'd written this using pthreads makes sense and solves the issue.
