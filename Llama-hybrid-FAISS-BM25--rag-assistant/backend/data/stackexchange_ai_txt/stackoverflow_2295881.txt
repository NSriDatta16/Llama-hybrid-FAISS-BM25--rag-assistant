[site]: stackoverflow
[post_id]: 2295881
[parent_id]: 2295606
[tags]: 
It's too late for me to decide how compliant this is, but it works for me: give the bitvector a custom allocator to alias the bits to your own buffer. Can someone weigh in with whether the rebound allocator inside the vector is required to be copy-constructed from the one passed in? Works on GCC 4.2.1. I seem to recall that the functionality is required for C++0x, and since it's not incompatible with anything in C++03 and is generally useful, support may already be widespread. Of course, it's implementation-defined whether bits are stored forwards or backwards or left- or right-justified inside whatever storage vector uses, so take great care. #include #include #include using namespace std; template struct my_alloc : allocator { template struct rebind { typedef my_alloc other; }; template my_alloc( my_alloc const &o ) { buf = o.buf; } my_alloc( void *b ) { buf = b; } // noncompliant with C++03: no default constructor T *allocate( size_t, const void *hint=0 ) { return static_cast ( buf ); } void deallocate( T*, size_t ) { } void *buf; }; int main() { unsigned long buf[ 2 ]; vector > blah( 128, false, my_alloc ( buf ) ); blah[3] = true; blah[100] = true; cerr
