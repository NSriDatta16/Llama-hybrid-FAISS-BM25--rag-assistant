[site]: stackoverflow
[post_id]: 2430574
[parent_id]: 2430557
[tags]: 
Since you want internal scrolling on the bottom div, I'm assuming you want the bottom div to be fluid vertically (rather--fluid to browser window size, not to content) as well as horizontally. (Being fluid horizontally really doesn't have much to do with a any solution to a vertical offset.) And since that's the case, your header has to be a set height. If the bottom div doesn't need to be fluid vertically, you can just set height to the desired number and declare overflow-y:scroll . For vertical fluidity, you'll need to use conflicting absolute positions , setting the bottom div to start just below where the top div ends and going down to the bottom of the page. Essentially: #bottomDiv { position: absolute; top: 100px; /* however tall your top div is */ left: 0; right: 0; bottom: 0; } Note the expression you'll have to use for IE6 (laid out in the article linked to, above). Update Why can't you modify .fullContainer ? If it's just that that's in another stylesheet, try anyway. The way CSS works, you can override anything that's come before it. So, if in your editable area you can add a fullContainer rule (which you should be able to, if you're editing the CSS file at all), you very likely could redefine that div to get rid of the width and height declarations ( width:auto and height:auto should do) and similarly reset or override other things (e.g., overflow:hidden if necessary). The other option is to try to make both your desired (new) top and bottom divs use position:fixed , but note that fixed positions are notoriously buggy on some browsers, and you might want to avoid it as fragile for laying out your whole site. Update 2 For IE6, you're using 100% height plus padding, which means it will be automatically too tall. In the article I point to , search for 'Creating the exception for IE5 and IE6' and use those expressions--if you can't put them in separate stylesheets, just use the star hack you're already using.
