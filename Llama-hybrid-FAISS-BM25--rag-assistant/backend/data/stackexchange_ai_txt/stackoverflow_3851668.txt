[site]: stackoverflow
[post_id]: 3851668
[parent_id]: 
[tags]: 
Position N circles of different radii inside a larger circle without overlapping

Given n circles with radii r1 ... rn, position them in such a way that no circles are overlapping and the bounding circle is of "small" radius. The program takes a list [r1, r2, ... rn] as input and outputs the centers of the circles. I ask for "small" because "minimum" radius converts it into a much more difficult problem (minimum version has already been proved to be NP hard/complete - see footnote near end of question). We don't need the minimum. If the shape made by the circles seems to be fairly circular, that is good enough. You can assume that Rmax/Rmin A low priority concern - the program should be able to handle 2000+ circles. As a start, even 100-200 circles should be fine. You might have guessed that the circles need not be packed together tightly or even touching each other. The aim is to come up with a visually pleasing arrangement of the given circles which can fit inside a larger circle and not leave too much empty space. (like the circles in a color blindness test picture ). You can use the Python code below as a starting point (you would need numpy and matplotlib for this code - "sudo apt-get install numpy matplotlib" on linux)... import pylab from matplotlib.patches import Circle from random import gauss, randint from colorsys import hsv_to_rgb def plotCircles(circles): # input is list of circles # each circle is a tuple of the form (x, y, r) ax = pylab.figure() bx = pylab.gca() rs = [x[2] for x in circles] maxr = max(rs) minr = min(rs) hue = lambda inc: pow(float(inc - minr)/(1.02*(maxr - minr)), 3) for circle in circles: circ = Circle((circle[0], circle[1]), circle[2]) color = hsv_to_rgb(hue(circle[2]), 1, 1) circ.set_color(color) circ.set_edgecolor(color) bx.add_patch(circ) pylab.axis('scaled') pylab.show() def positionCircles(rn): # You need rewrite this function # As of now, this is a dummy function # which positions the circles randomly maxr = int(max(rn)/2) numc = len(rn) scale = int(pow(numc, 0.5)) maxr = scale*maxr circles = [(randint(-maxr, maxr), randint(-maxr, maxr), r) for r in rn] return circles if __name__ == '__main__': minrad, maxrad = (3, 5) numCircles = 400 rn = [((maxrad-minrad)*gauss(0,1) + minrad) for x in range(numCircles)] circles = positionCircles(rn) plotCircles(circles) Added info : The circle packing algorithm commonly referred to in google search results is not applicable to this problem. The problem statement of the other "Circle packing algorithm" is thus : Given a complex K ( graphs in this context are called simplicial complexes, or complex in short) and appropriate boundary conditions, compute the radii of the corresponding circle packing for K.... It basically starts off from a graph stating which circles are touching each other (vertices of the graph denote circles, and the edges denote touch/tangential relation between circles). One has to find the circle radii and positions so as to satisfy the touching relationship denoted by the graph. The other problem does have an interesting observation (independent of this problem) : Circle Packing Theorem - Every circle packing has a corresponding planar graph (this is the easy/obvious part), and every planar graph has a corresponding circle packing (the not so obvious part). The graphs and packings are duals of each other and are unique. We do not have a planar graph or tangential relationship to start from in our problem. This paper - Robert J. Fowler, Mike Paterson, Steven L. Tanimoto: Optimal Packing and Covering in the Plane are NP-Complete - proves that the minimum version of this problem is NP-complete. However, the paper is not available online (at least not easily).
