[site]: stackoverflow
[post_id]: 5166075
[parent_id]: 5164645
[tags]: 
i'm guessing that it could happen because some threads(handlers) are suspending due to timeout while waiting on synchronized lock. But this is only my gues and it depends on application architecture(how did you organize queues, handlers, etc.) UPD: I have some sort of idea. Writing to CSV file is not thread safe and that's why you are using synchronization lock. And maybe that's why some threads are suspended while waiting. But we could solve it easily by creating WriteManager class. This class should have BlockingQueue instance so handlers will not invoke write method directly but they will put data to be written in the Queue (if queue is full they have to wait but if queue will be big enought they have not wait at all) and manager class will poll queue in infinite loop (of course it will be finite and controled by a flag ) and write data to CSV file. So when you have to start writing\managing process you just starting WriteManager and when no more writing is needed you just switch off the polling loop(actually loop shouldn't stop when you stop it manually but it should to poll all objects from queue and only than stop). UPD2: Does you invoke getStringsToWrite multiply times ? This is very basic example of what i mean but you could easily extended it or even fully rewrite. class someServiceClass { //singleton LinkedBlockingQueue csvWritingQueue = new LinkedBlockingQueue() def currentWriter = null def writerThread = null def getStringsToWrite(List someOtherList) { def stringsList = [] someOtherList.each { def someString = "someString" csvWritingQueue.put(someString) } } @Synchronized def writeRowsToFile(File file) { file.withWriterAppend {out-> while (!csvWritingQueue.isEmpty()) { out.writeLine csvWritingQueue.poll() } } } def write (File file) { if (writerThread == null) { currentWriter = new Runnable() { boolean isRun = true public void run() { while(isRun) { if(!csvWritingQueue.isEmpty()) { writeRowsToFile(file) } try { Thread.sleep(5 * 1000); }catch(e){ //e.printStackTrace() } } } } writerThread = new Thread(currentWriter) writerThread.start() } } def stop() { if (currentWriter != null) { currentWriter.isRun = false; try { writerThread.join(); }catch(e){ //e.printStackTrace() } } currentWriter = null; writerThread = null; } } } I hope it would help you. BackgroundThread plugin - has nice example of background worker.
