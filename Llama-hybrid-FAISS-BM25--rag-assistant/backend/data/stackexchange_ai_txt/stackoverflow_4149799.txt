[site]: stackoverflow
[post_id]: 4149799
[parent_id]: 4149338
[tags]: 
You seem to have solved your immediate problem, but your program is crawling with more subtle problems. I have taken the liberty of rewriting it for you. There is a reason for every change I made, even the ones that seem trivial. Please read it carefully and consider why I did what I did. I am happy to answer specific questions about the changes. /* factor.c - produce the prime factorization of a number. Uses the Sieve of Eratosthenes. */ #include #include #include #include static unsigned char * compute_sieve(unsigned long root) { unsigned char *sieve = malloc(root + 1); unsigned long i, j; /* all numbers are prime till proven otherwise */ memset(sieve, 1, root + 1); /* 0 and 1 are not prime */ sieve[0] = 0; sieve[1] = 0; for (i = 2; i 1) printf(" %lu", number); putchar('\n'); } free(sieve); free(factors); } static void usage(char **argv) { fprintf(stderr, "usage: %s NUMBER\n" "NUMBER must be a non-negative integer\n", argv[0]); } int main(int argc, char **argv) { unsigned long number; char *endptr; if (argc != 2) { usage(argv); return 1; } number = strtoul(argv[1], &endptr, 10); if (endptr == argv[1] || *endptr != '\0') { usage(argv); return 1; } factor(number); return 0; }
