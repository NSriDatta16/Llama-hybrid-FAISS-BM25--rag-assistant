[site]: stackoverflow
[post_id]: 2789530
[parent_id]: 2786899
[tags]: 
For any optimization, it's always best to test, test, test. I would try at least sorting networks and insertion sort. If I were betting, I'd put my money on insertion sort based on past experience. Do you know anything about the input data? Some algorithms will perform better with certain kinds of data. For example, insertion sort performs better on sorted or almost-sorted dat, so it will be the better choice if there's an above-average chance of almost-sorted data. The algorithm you posted is similar to an insertion sort, but it looks like you've minimized the number of swaps at the cost of more comparisons. Comparisons are far more expensive than swaps, though, because branches can cause the instruction pipeline to stall. Here's an insertion sort implementation: static __inline__ int sort6(int *d){ int i, j; for (i = 1; i = 1 && tmp Here's how I'd build a sorting network. First, use this site to generate a minimal set of SWAP macros for a network of the appropriate length. Wrapping that up in a function gives me: static __inline__ int sort6(int * d){ #define SWAP(x,y) if (d[y]
