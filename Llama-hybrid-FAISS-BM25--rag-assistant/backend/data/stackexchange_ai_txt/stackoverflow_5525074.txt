[site]: stackoverflow
[post_id]: 5525074
[parent_id]: 
[tags]: 
Collision detection for loop problem, only one array item tested?

[I apologise if this isn't really an in depth question, but I wanted to solve this once and for all] I was trying to get look into quadtrees, but already ran into trouble getting collision detection without any optimization working properly. Did a search and found a pretty neat example: http://wonderfl.net/c/kyLx (onenterframeC part mostly) Trying to imitate this, it won't work the same. Only some collisions are detected between particular objects. When the objects are not moving it seems to work alot better for some reason. I really can't figure out whats the problem, the code is essentially the same as the sample. I did not blindy copy pasted it, I understands whats happening except for this part: if (j J would never become bigger that I right? The line also completely removes any working collisions for me. Here is what I did: [view result here: http://martinowullems.com/collision.swf Main class package { import com.martino.objects.Square; import com.martino.world.TestWorld; import flash.display.MovieClip; import flash.events.Event; import net.hires.debug.Stats; /** * ... * @author Martino Wullems */ public class CollisionTest extends MovieClip { var world:TestWorld; public function CollisionTest() { addEventListener(Event.ADDED_TO_STAGE, onStage); } private function onStage(e:Event):void { removeEventListener(Event.ADDED_TO_STAGE, onStage); SetupWorld(); addChild(new Stats()); } private function SetupWorld():void { world = new TestWorld(); addChild(world); addObjects(50); } private function addObjects(amount:int):void { for (var i:int = 0; i TestWorld package com.martino.world { import com.martino.objects.Ball; import com.martino.objects.CollisionObject; import flash.display.MovieClip; import flash.events.Event; /** * ... * @author Martino Wullems */ public class TestWorld extends MovieClip { public var objects:Array; public function TestWorld() { initWorld(); } private function initWorld():void { objects = new Array(); addEventListener(Event.ENTER_FRAME, loopWorld); } private function loopWorld(e:Event):void { for (var i:int = 0; i objectB.x + objectB.width) { object.isHit = objectB.isHit = false; } else if (object.y + object.height objectB.y + objectB.height) { object.isHit = objectB.isHit = false; } else { object.isHit = objectB.isHit = true; }*/ object.debugDraw(); objectB.debugDraw(); } } private function MoveObject(object:CollisionObject):void { object.x += object.speedX; object.y += object.speedY; //////////////////// //check boundaries// //////////////////// if (object.x > stage.stageWidth) { object.speedX *= -1; }else if (object.x stage.stageHeight) { object.speedY *= -1; }else if (object.y CollisionObject package com.martino.objects { import flash.display.Sprite; import flash.events.MouseEvent; /** * ... * @author Martino Wullems */ public class CollisionObject extends Sprite { public var size:int; public var speedX:int = 0; public var speedY:int = 0; public var graphic:Sprite; var sleeping:Boolean = false; public var isHit:Boolean = false; public function CollisionObject() { addEventListener(MouseEvent.MOUSE_DOWN, grab); addEventListener(MouseEvent.MOUSE_UP, letGo); } private function grab(e:MouseEvent):void { startDrag(); speedX = 0; speedY = 0; } private function letGo(e:MouseEvent):void { stopDrag(); } public function Collision():void{ } ////////////////////// // setter and getter// ////////////////////// public function set isHit(value:Boolean):void { _isHit = value; graphic.visible = _isHit; hitGraphic.visible = !_isHit; } public function get isHit():Boolean { return _isHit; } } } Square package com.martino.objects { import flash.display.Sprite; /** * ... * @author Martino Wullems */ public class Square extends CollisionObject { public var hitGraphic:Sprite; public function Square(Size:int) { size = Size; drawSquare(); } private function drawSquare():void { graphic = new Sprite(); graphic.graphics.beginFill(0xFF0000); graphic.graphics.drawRect(0, 0, size, size); graphic.graphics.endFill(); addChild(graphic); hitGraphic = new Sprite(); hitGraphic.graphics.beginFill(0x0066FF); hitGraphic.graphics.drawRect(0, 0, size, size); hitGraphic.graphics.endFill(); addChild(hitGraphic); hitGraphic.visible = false; } override public function Collision():void { trace("I collided with a friend (inside joke)"); } public override function debugDraw():void { if (isHit) { graphic.visible = false; hitGraphic.visible = true; }else { graphic.visible = true; hitGraphic.visible = false; } } } } Any help would greatly be appreciated, want to get further on this ! EDIT: Changed some stuff, there is progress but stuff still is unclear to me ! Changed some things in TestWorld.as: package com.martino.world { import com.martino.objects.Ball; import com.martino.objects.CollisionObject; import flash.display.MovieClip; import flash.events.Event; /** * ... * @author Martino Wullems */ public class TestWorld extends MovieClip { public var objects:Array; public function TestWorld() { initWorld(); } private function initWorld():void { objects = new Array(); addEventListener(Event.ENTER_FRAME, loopWorld); } private function loopWorld(e:Event):void { var object:*; for (var i:int = 0; i stage.stageWidth) { object.vx *= -1; }else if (object.x stage.stageHeight) { object.vy *= -1; }else if (object.y Also added a setter and getter in collisionobject (so section before the edit). Not sure why I can't put the checkcollision inside the loop on the enter frame function? (when I do no collisions are shown). And placing "isHit = false" inside moveobjects to reset a check for a hit also seems pretty messy. I can't seem to find out when the objects aren't colliding to reset them I guess. Making an else statement on the hittest to check if there is no collision doesn't work, seems logical since there could be collisions with more than just 2 items in the hittestcheck. Any idea's ?
