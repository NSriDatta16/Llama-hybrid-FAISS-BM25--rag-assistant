[site]: stackoverflow
[post_id]: 551486
[parent_id]: 550106
[tags]: 
There's one more reason a simple assert(ptr != NULL) won't work before dereferencing a pointer won't work: Not every invalid pointer (even those that began life as NULL) is in fact equal to 0. First consider the case where you have a struct with several members: struct mystruct { int first; int second; int third; int fourth; }; If you have a pointer ptr to mystruct and you try to access ptr->second , the compiler is going to generate code that ads 4 (assuming 32-bit integers) to ptr and access that memory location. If ptr is 0, the actual memory location accessed will be 4. That's still invalid but wouldn't be caught by a simple assertion. (The compiler could reasonably be expected to check the address of ptr before adding 4, in which case the assertion would catch it.) Second, consider the case where you have an array of struct mystruct and you pass an arbitrary element to another function. If you try to access the second element of the array, it will begin at 16 bytes beyond the first pointer. There's no way the compiler could reasonably be expected to do what you want reliably in all cases, without catching legitimate pointer arithmetic. What you really want to do is use the operating system and hardware to catch invalid and unaligned memory access and kill your application, then figure out how to get the debugging information you need. The easiest way is simply to run inside a debugger. If you're using gcc on Linux, see how to generate a stacktace when my C++ app crashes . I assume there are similar ways to do the same thing with other compilers.
