[site]: stackoverflow
[post_id]: 5652444
[parent_id]: 5651761
[tags]: 
Other points to think about: 1. You are vulnerable to bruteforce A dictionary attack would crack your password. As the vast majority of users have an insecure password, it's only matter of time. Use captcha, or log invalid entries. Or add some delay when the password is incorrect. As Col. Shrapnel said, a rainbow table isn't a concern to you because they are used when someone have a bunch of hashes and want to crack them. Salt is used to gain some protection against a rainbow table, and this is not your case. 2. You are sending passwords in clear text If someone sniff your login (wifi, for example), you are doomed. There's some javascript libs which can encrypt anything using public keys. If you don't want to use SSL, encrypt the login/password, send to server, decrypt using the private key, and you are safer. 3. Consider using prepared statements on MySQL Using prepared statements helps against SQL injection, as it can safely run even with malicious input: $dbc = new mysqli("mysql_server_ip", "mysqluser", "mysqlpass", "dbname"); $statement = $db_connection->prepare("SELECT * FROM table WHERE thing='?'"); $statement->bind_param("i", $thing); $statement->execute(); 4. Don't relay on client-side validation On your login form, you relay on a javascript funcion preventing Enter-key to function. What if I disable Javascript? You could use a hidden field (e.g. ), use your function to prevent Enter-key, AND use an onSubmit() function to change FormIsValid to 1 before sending the form. In your server, verify FormIsValid. 5. You are vulnerable to session hijacking Your session are saved on a cookie, by default named PHPSESSID. If an attacker can get that cookie, it could send it to your server and steal your session. To prevent it, you can save the user IP address and user agent in the session, and compare the value received from the session on every request. If the values doesn't match, the user IP may have changed or the session may have been hijacked. 6. You can be vulnerable to session fixation As stated above, if someone convinces your admin to access some site, and this site sends a request to your site with a PHPSESSID on the request, your site would create the session, process the login/password, and state that the credentials are wrong. Not bad until now. Later, your admin logs into your portal, the session already exists, the login and password matches, and the session is UPDATED. The variable valid now is 1. As soon as the variable are updated, the attacker have full access to your portal, as he knows the PHPSESSID, your site doesn't prevent session hijacking, or session fixation. To avoid session fixation and hijacking, see #5.
