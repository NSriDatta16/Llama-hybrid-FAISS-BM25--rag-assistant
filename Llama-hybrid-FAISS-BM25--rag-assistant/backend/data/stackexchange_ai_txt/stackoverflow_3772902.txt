[site]: stackoverflow
[post_id]: 3772902
[parent_id]: 3772835
[tags]: 
You can get a signed NaN since the NaN-ness of the value and the sign of the value are controlled by different bits in IEEE754 (NaN is simply indicated by special exponent values, distinct from the sign bit). I'm at a loss as to what sort of operation would do it though. It's possible that one of the normal operations that produce NaN could be causing a negative variation (like +0/-0 or +Inf/-Inf ). But I would have thought that NaNs would print as nan regardless of sign. However, while the standard specifies in great detail how numbers are handled, it's strangely silent on how they're printed. The Wikipedia page for NaN lists these: nan NaN NaN% NAN NaNQ NaNS qNaN sNaN 1.#SNAN 1.#QNAN -1.#IND -NaN NaN12345 -sNaN12300 with some of those showing sign and the extra payload. Note that I'm talking about the IEEE standards here. The ISO C standards do indicate a limited number of forms but whether the sign and/or payload is printed is implementation-dependent. I can only assume that the later versions of the library have changed their behaviour. How to fix it within the compiler, I'm not sure. I'd just take the pragmatic approach and run your output file through something like sed 's/-nan/nan/g' . Hopefully that won't introduce other problems. And you should also keep an eye on the form that allows the payload to be printed as well, though I'd only worry about that when the tests start failing again. But I'd put a comment somewhere near that sed command indicating that it may happen at some time in the future. That way, at least the guy that follows you will understand why.
