[site]: stackoverflow
[post_id]: 5164932
[parent_id]: 5164538
[tags]: 
You could get better performance, normally, by increasing the buffer size. Right after building the ifstream , you can set its internal buffer using: char LocalBuffer[4096]; // buffer std::ifstream wordListFile("dictionary.txt"); wordListFile.rdbuf()->pubsetbuf(LocalBuffer, 4096); Note: rdbuf 's result is guaranteed no to be null if the construction of ifstream succeeded Depending on the memory available, your are strongly encouraged to grow the buffer if possible in order to limit interaction with the HDD and the number of system calls. I've performed some simple measurements using a little benchmark of my own, you can find the code below (and I am interested in critics): gcc 3.4.2 on SLES 10 (sp 3) C : 9.52725e+06 C++ : 1.11238e+07 difference: 1.59655e+06 Which gives a slowdown of a whooping 17% . This takes into account: automatic memory management (no buffer overflow) automatic resources management (no risk to forget to close the file) handling of locale So, we can argue that streams are slow... but please, don't throw your random piece of code and complains it's slow, optimization is hard work. Corresponding code, where benchmark is a little utility of my own which measure the time of a repeated execution (here launched for 50 iterations) using gettimeofday . #include #include #include #include #include #include "benchmark.h" struct CRead { CRead(char const* filename): _filename(filename) {} void operator()() { FILE* file = fopen(_filename, "r"); int count = 0; while ( fscanf(file,"%s", _buffer) == 1 ) { ++count; } fclose(file); } char const* _filename; char _buffer[1024]; }; struct CppRead { CppRead(char const* filename): _filename(filename), _buffer() {} enum { BufferSize = 16184 }; void operator()() { std::ifstream file(_filename); file.rdbuf()->pubsetbuf(_buffer, BufferSize); int count = 0; std::string s; while ( file >> s ) { ++count; } } char const* _filename; char _buffer[BufferSize]; }; int main(int argc, char* argv[]) { size_t iterations = 1; if (argc > 1) { iterations = atoi(argv[1]); } char const* filename = "largefile.txt"; CRead cread(filename); CppRead cppread(filename); double ctime = benchmark(cread, iterations); double cpptime = benchmark(cppread, iterations); std::cout
