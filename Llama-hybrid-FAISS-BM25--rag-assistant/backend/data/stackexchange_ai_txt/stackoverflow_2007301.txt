[site]: stackoverflow
[post_id]: 2007301
[parent_id]: 2005038
[tags]: 
Multiple template based scripts is (almost) never the right answer. Use data structures from a config file and control structures to get the behaviors you need. Instead of using a template to create code like: sub foo { my $thing = shift; return blarg( $thing ) * feemb( $thing ); } sub bar { my $thing = shift; return crag( $thing ) * forg( $thing ); } sub baz { my $thing = shift; return chomb( $thing ) * veezle( $thing ); } Do this: # Get this from a config file. YAML perhaps my $cfg = { foo => [ \&blarg, \&feemb ], bar => [ \&crag, \&forg ], baz => [ \&chomb, \&veezle ], }; sub calculate_product { my $cfg = shift; my $type = shift; my $thing = shift; my @subs_to_call = @{ $cfg->{$type} || [] }; my $result = {shift @subs_to_call}->($thing}; $result *= $_->($thing) for @subs_to_call; return $result; } # Call like so: my $foo_prod = calculate_product($cfg, 'foo', 15); You can bind config info to a subroutine (that is 'curry your functions') by generating closures with config info: # Get this from a config file. YAML perhaps my $cfg = { foo => [ \&blarg, \&feemb ], bar => [ \&crag, \&forg ], baz => [ \&chomb, \&veezle ], }; my %calculate_product; for my $product ( keys %$cfg ) { my @stored_subs_to_call = @{$cfg->{$product} || [] }; $calculate_product{$prod} = sub { my $thing = shift; my @subs_to_call = @stored_subs_to_call; my $result = {shift @subs_to_call}->($thing}; $result *= $_->($thing) for @subs_to_call; return $result; } } # Call generated code like so: my $foo_prod = $calculate_product{foo}->(15);
