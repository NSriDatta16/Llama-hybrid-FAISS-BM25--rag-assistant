[site]: stackoverflow
[post_id]: 2831044
[parent_id]: 2830941
[tags]: 
(Edited for brevity.) The compiler, CPU, and OS all can change the answer, here: CPU: instruction/data cache size, architecture, and behavior, especially any intelligent prefetch CPU: branch prediction and speculative execution behavior CPU: the penalty for a mispredicted branch compiler and CPU: the availability and relative cost of conditionally-executed instructions (helps with branch cases that only cover a few instructions) compiler or linker: optimizations that may transform your code and remove branches In short, as Blindy said in the comments: test it. =) If you're writing for a modern desktop OS or OSes, enlist the help of a profiling tool (valgrind, shark, codeanalyst, vtune, etc) -- it may give you details you never even knew you could look for, such as cache misses, branch mispredicts, etc. Even if you don't find a great answer, you'll learn something from applying the tool. I often find looking at the disassembly quite instructive, too (see some of the other answers in this thread). Some slightly more speculative notes: vtable tends to result in a load (this+0), offset, second load, and then branch on the contents of the register. You can see this in some of the other answers. Most CPUs that I'm familiar with are miserable at predicting branches from registers. the bool may be near other data you're using and as such may already be cached. The branch target is also likely to be fixed and therefore a lot more friendly for prediction and/or speculative execution. on some processors (rarer these days), it costs more to load a bool than an int. on an ARM processor I work with, we occasionally tuck the vtables in "tightly coupled memory" on the processor core. Decreases the indirect load time considerably -- it's as if the vtable is always in-cache or better. As you mentioned, the usual rule applies: do what fits requirements and is flexible/maintainable/readable first, then optimize. Further reading / other patterns to pursue: FastDelegate , which makes component based systems much easier to deal with Pitfalls of Object-Oriented Programming slides , which discuss how to get more out of CPU and CPU caches in general Both the "Data Oriented Design" and the "Component-Based Entity" paradigms are useful to keep in your brain for games, multimedia engines, and other things where you have a greater-than-average demand for performance and still want to keep your code somewhat organized. YMMV, of course. =)
