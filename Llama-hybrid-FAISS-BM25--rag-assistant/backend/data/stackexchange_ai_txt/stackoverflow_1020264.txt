[site]: stackoverflow
[post_id]: 1020264
[parent_id]: 1019928
[tags]: 
Code to demonstrate Ganesh's answer: {-# LANGUAGE FlexibleInstances, FunctionalDependencies, MultiParamTypeClasses, StandaloneDeriving, UndecidableInstances #-} import qualified Data.Map as Map import Data.Maybe (fromMaybe) class Mapping k m | m -> k where empty :: m v insert :: k -> v -> m v -> m v search :: k -> m v -> Maybe v delete :: k -> m v -> m v instance Ord k => Mapping k (Map.Map k) where empty = Map.empty search = Map.lookup insert = Map.insert delete = Map.delete data Trie m v = Trie { trValue :: Maybe v, trChildren :: m (Trie m v) } deriving instance (Show v, Show (m (Trie m v))) => Show (Trie m v) trieMod :: Mapping k m => Maybe v -> [k] -> Trie m v -> Trie m v trieMod val [] trie = trie { trValue = val } trieMod val (x:xs) trie = trie { trChildren = insert x newChild children } where children = trChildren trie newChild = trieMod val xs prevChild prevChild = fromMaybe empty . search x $ children instance Mapping k m => Mapping [k] (Trie m) where empty = Trie { trValue = Nothing, trChildren = empty } search [] trie = trValue trie search (x:xs) trie = search xs = Btw: Had functional dependencies not existed, we would probably need to compromise on an annoying interface and use function tables instead of type classes.
