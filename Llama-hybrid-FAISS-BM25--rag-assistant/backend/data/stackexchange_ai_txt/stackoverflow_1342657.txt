[site]: stackoverflow
[post_id]: 1342657
[parent_id]: 1342547
[tags]: 
As other responders have pointed out, you probably should consider why your design requires different logic for different types that can't be pulled up into an interface. However, assuming that there are good reasons for this, you only have a few options: Use reflection. This is generally slow and error prone code, that's also fragile when your implementation changes (i.e. methods are renamed, etc). Use an if/else if/else pattern to dispatch based on runtime checks of the type. This is pretty much your only other choice in pre-4.0 versions of C#. If you are using C# 4.0, you can use assign the object to a dynamic var , and at runtime dispatch to an overloaded method whose signature varies for each of the types supported (see example below). Here's a C# 4.0 dynamic dispatch example: void Foo() { dynamic preDisplay = cb.PreDisplay; DoSomethingWith( preDisplay ); // runtime dispatch using dynamic runtime (DLR) } void DoSomethingWith( RedPreDisplay r ) { ... } // code specific to RefPreDisplay void DoSomethingWith( GreenPreDisplay g ) { ... } // code specific to GreenPreDisplay void DoSomethingWIth( IPreDisplay o ) { ... } // catch-all
