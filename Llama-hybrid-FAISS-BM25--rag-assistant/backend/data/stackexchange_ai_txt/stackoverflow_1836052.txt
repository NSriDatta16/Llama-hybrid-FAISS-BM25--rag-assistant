[site]: stackoverflow
[post_id]: 1836052
[parent_id]: 1625608
[tags]: 
This is a sensible question, and I think there are definitional problems, such as "what is a DSL"? When a buzword becomes "hot" it becomes a marketing opportunity and gets divorced from underlying science, if there is any. Some years ago, I wrote a book (Building Better Applications, ISBN 0-442-01740-5, long out of print) where I tried to look into performance, not only of programs, but of programmers. I tried to look at it using information theory. I came up with a crude measure of maintainability, where a problem exists as a knowledge structure in somebody's head (no problem for an AI guy to say so), and its solution exists as a textual structure processed by a machine. What I look at is the relationship between these two structures. For example, if a change occurs in the mental problem description, how many source code changes are required to transfer that to the program text correctly? A simple way to measure that is to diff the code between before and after. Now, average that measure over the space of changes that are likely, and the lower the average is, the more maintainable is the source code. My thesis was that the more maintainable code is, by that measure, the more it comes to resemble the mental model of the domain, so it is reasonable to call it more "problem-oriented" or more "domain-specific". One characteristic I noticed of such code is that it tends to be more a statement of the problem, rather than a solution of the problem. The solution lies not in the language, but in the implementation of the language, the sub-structure. This is an echo, though not a direct agreement, with the concept of "declarative" vs. "imperative" language. So in trying to answer your question, I would say let's get away from what people might want "DSL" to mean and instead look at a definition that's at least moderately unambiguous. As part of developing that idea, I had stumbled on a number of techniques, one of which is Differential Execution , which seems to give good maintainability for coding UIs, and also reduces source code size by roughly an order of magnitude. My theory is that that's a successful example of what a DSL might be. I do not claim that maintainability can be achieved without the maintainer having to climb a learning curve. I think real maintainability comes at a price of programmers having to learn things that might not be easy to grasp, but once grasped have the desired value.
