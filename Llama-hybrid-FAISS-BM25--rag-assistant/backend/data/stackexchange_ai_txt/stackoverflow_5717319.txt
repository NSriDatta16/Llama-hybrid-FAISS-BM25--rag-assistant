[site]: stackoverflow
[post_id]: 5717319
[parent_id]: 
[tags]: 
GLSL normals with non-standard projection matrix

After a few days of getting my GLSL vertex shader to display the vertices correctly, I've now moved onto lighting! My understanding of openGL lighting/normals isn't great by any stretch of the imagination so bear with me. I'm unsure of what translations I need to apply to my normals to get them to display correctly. Here is the application code that sets up my lights: final float diffuseIntensity = 0.9f; final float ambientIntensity = 0.5f; final float position[] = { 0f, 0f, 25000f, 0f}; gl.glLightfv(GL.GL_LIGHT0, GL.GL_POSITION, position, 0); final float diffuse[] = { 0, diffuseIntensity, 0, 1f}; gl.glLightfv(GL.GL_LIGHT0, GL.GL_DIFFUSE, diffuse, 0); final float ambient[] = { ambientIntensity, ambientIntensity, ambientIntensity, 1f}; gl.glLightfv(GL.GL_LIGHT0, GL.GL_AMBIENT, ambient, 0); Pretty standard stuff so far. Now because of the requirements of the application, here is the (somewhat odd) vertex shader: void main() { // P is the camera matrix, model_X_matrices are the relative translation/rotation etc of the model currently being rendered. vec4 pos = gl_ProjectionMatrix * P * modelTranslationMatrix * modelRotationMatrix * modelScaleMatrix * gl_Vertex; gl_Position = pos; gl_TexCoord[0] = gl_MultiTexCoord0; gl_FrontColor = gl_Color; } It's my understanding that I need to transform the gl_Normal into world coordinates. For my shader, I believe this would be: vec4 normal = modelTranslationMatrix * modelRotationMatrix * modelScaleMatrix * vec4(gl_Normal); And then I would need to get the position of the light (which was already declared in the application code in world space). I think I would do this by: vec3 light_position = gl_LightSource[0].position.xyz; and then find the diffuse value of the light by find the dot product of the normal and the light position. Furthermore, I think in the fragment shader I just need to multiply the color by this diffuse value and it should all work. I'm just really not sure how to transform the normal coordinates correctly. Is my assumption correct or am I totally off the ball? EDIT: After reading that the normal matrix ( gl_NormalMatrix ) is just the 3x3 inverse of the gl_ModelView matrix, I'm guessing that a correct way to calculate the normal in world space is to multiply the gl_Normal by the inverse of modelTranslationMatrix * modelRotationMatrix * modelScaleMatrix ? Would I still need to multiply this by the P matrix or is that irrelevant for normal calculations?
