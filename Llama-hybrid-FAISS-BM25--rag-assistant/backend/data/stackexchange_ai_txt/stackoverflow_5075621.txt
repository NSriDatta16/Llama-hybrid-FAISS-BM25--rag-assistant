[site]: stackoverflow
[post_id]: 5075621
[parent_id]: 
[tags]: 
What is the difference between different orderings of the same monad transformers?

I am attempting to define an API to express a particular type of procedure in my program. newtype Procedure a = { runProcedure :: ? } There is state, consisting of a mapping of IDs to records: type ID = Int data Record = { ... } type ProcedureState = Map ID Record There are three basic operations: -- Declare the current procedure invalid and bail (similar to some definitions of fail for class Monad) abort :: Procedure () -- Get a record from the shared state; abort if the record does not exist. retrieve :: ID -> Procedure Record -- Store (or overwrite) a record in the shared state. store :: ID -> Record -> Procedure () I have a few goals with these operations: Procedures can make assumptions (unlike a raw Map.lookup call) about which records are available, and if any of their assumptions are wrong, the Procedure as a whole returns failure. A series of Procedures can be chained together using (from class Alternative) in order to fall back to Procedures that make different assumptions. (Similar to STM's orElse ) Given these goals, I believe I want some combination of the State and Maybe monads. -- Which to choose? type Procedure a = StateT ProcedureState Maybe a type Procedure a = MaybeT (State ProcedureState) a I can't figure out how the two orderings of Maybe and State will behave differently. Can anyone explain the difference in behavior between the two orderings? Also, if you see a problem with my original thinking (perhaps I am over-engineering), feel free to point it out. Conclusion: All three answers were helpful, but there was one common idea that helped me decide which ordering I wanted. By looking at the return type of runMaybeT / runStateT , it was easy to see which combination had the behavior I was looking for. (In my case, I want the return type Maybe (ProcedureState, a) ).
