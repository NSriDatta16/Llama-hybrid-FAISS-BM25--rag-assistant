[site]: datascience
[post_id]: 251
[parent_id]: 138
[tags]: 
Having done the rewriting game over and over myself (and still doing it), my immediate reaction was adaptability . While frameworks and libraries have a huge arsenal of (possibly intertwinable) routines for standard tasks, their framework property often (always?) disallows shortcuts. In fact, most frameworks have some sort of core infrastructure around which a core layer of basic functionality is implemented. More specific functionality makes use of the basic layer and is placed in a second layer around the core. Now by shortcuts I mean going straight from a second layer routine to another second layer routine without using the core. Typical example (from my domain) would be timestamps: You have a timestamped data source of some kind. Thus far the job is simply to read the data off the wire and pass it to the core so your other code can feast on it. Now your industry changes the default timestamp format for a very good reason (in my case they went from unix time to GPS time). Unless your framework is industry-specific it is very unlikely that they're willing to change the core representation of time, so you end up using a framework that almost does what you want. Every time you access your data you have to convert it to industry-time-format first, and every time you want it modified you have to convert it back to whatever the core deems appropriate. There is no way that you can hand over data straight from the source to a sink without double conversion. This is where your hand-crafted frameworks will shine, it's just a minor change and you're back modelling the real world whereas all other (non-industry-specific) frameworks will now have a performance disadvantage. Over time, the discrepancy between the real world and the model will add up. With an off-the-shelf framework you'd soon be facing questions like: How can I represent this in that or how do make routine X accept/produce Y . So far this wasn't about C/C++. But if, for some reason, you can't change the framework, i.e. you do have to put up with double conversion of data to go from one end to another, then you'd typically employ something that minimises the additional overhead. In my case, a TAI->UTC or UTC->TAI converter is best left to raw C (or an FPGA). There is no elegance possible, no profound smart data structure that makes the problem trivial. It's just a boring switch statement, and why not use a language whose compilers are good at optimising exactly that?
