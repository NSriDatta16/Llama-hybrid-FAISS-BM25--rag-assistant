[site]: stackoverflow
[post_id]: 1719919
[parent_id]: 1719527
[tags]: 
While I agree with AlexM, I did have some spare time and thought this would be interesting: # from django.whereever import cache class memoize(object): def __init__(self,prefix='mysite', timeout=300, keygenfunc=None): class memo_descriptor(object): def __init__(self,func): self.func = func def __get__(self,obj,klass=None): key = prefix + '___' + self.func.func_name + '___' + keygenfunc(obj) class memo(object): def __call__(s,*args,**kwargs): rv = cache.get(key) if rv is None: rv = self.func(obj,*args, **kwargs) cache.set(key, rv, timeout) return rv def invalidate(self): cache.set(key, None, 1) return memo() self.descriptor = memo_descriptor def __call__(self,func): return self.descriptor(func) Note I've changed the keygenfunc signature from (*args,**kwargs) to (instance) , as that is how you were using it in your example (and it's impossible to have an someBigCalculation.invalidate method clear the cache in the manner you wanted if you generate a key from the arguments to the method call rather than the object instance). class StorageUnit(models.Model): @memoize(timeout=60*180, keygenfunc=lambda x: str(x.id)) def someBigCalculation(self): return 'big calculation' There is a lot of stuff going on in that code, so whether it's actually making your life easier is something to consider.
