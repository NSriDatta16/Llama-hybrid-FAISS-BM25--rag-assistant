[site]: stackoverflow
[post_id]: 812565
[parent_id]: 809902
[tags]: 
I like the union answer, pretty neat. Typically I just bit shift to convert between little and big endian, although I think the union solution has fewer assignments and may be faster: //note UINT64_C_LITERAL is a macro that appends the correct prefix //for the literal on that platform inline void endianFlip(unsigned long long& Value) { Value= ((Value & UINT64_C_LITERAL(0x00000000000000FF)) > 8) | ((Value & UINT64_C_LITERAL(0x0000FF0000000000)) >> 24) | ((Value & UINT64_C_LITERAL(0x00FF000000000000)) >> 40) | ((Value & UINT64_C_LITERAL(0xFF00000000000000)) >> 56); } Then to detect if you even need to do your flip without macro magic, you can do a similiar thing as Pax, where when a short is assigned to 0x0001 it will be 0x0100 on the opposite endian system. So: unsigned long long numberToSystemEndian ( unsigned long long In, unsigned short SourceEndian ) { if (SourceEndian != 1) { //from an opposite endian system endianFlip(In); } return In; } So to use this, you'd need SourceEndian to be an indicator to communicate the endianness of the input number. This could be stored in the file (if this is a serialization problem), or communicated over the network (if it's a network serialization issue).
