[site]: stackoverflow
[post_id]: 4163704
[parent_id]: 4162900
[tags]: 
Do it with elegance: var myFunc = (function (foo, bar, baz) { // does whatever it is supposed to do }). withNamedArguments({foo:"default for foo", bar:"bar", baz:23 }); myFunc({foo:1}); // calls function(1, "bar", 23) myFunc({}); // calls function("default for foo", "bar", 23); myFunc({corrupt:1}); // calls function({corrupt:1}) myFunc([2,4], 1); //calls function([2,4], 1) Even this one works Array.prototype.slice = Array.prototype.slice.withNamedArguments({start:0, length:undefined}); [1,2,3].slice({length:2}) //returns [1,2] [1,2,3].slice(1,2) //returns [2,3] ... or here, parseInt() parseInt = parseInt.withNamedArguments({str:undefined, base:10}); parseInt({str:"010"}); //returns 10 Just enhance the Function object: Function.prototype.withNamedArguments = function( argumentList ) { var actualFunction = this; var idx=[]; var ids=[]; var argCount=0; // construct index and ids lookup table for ( var identifier in argumentList ){ idx[identifier] = argCount; ids[argCount] = identifier; argCount++; } return function( onlyArg ) { var actualParams=[]; var namedArguments=false; // determine call mode if ( arguments.length == 1 && onlyArg instanceof Object ) { namedArguments = true; // assume named arguments at the moment onlyArg = arguments[0]; for ( name in onlyArg ) if (name in argumentList ) { actualParams[idx[name]] = onlyArg[name]; } else { namedArguments = false; break; } } if ( namedArguments ) { // fill in default values for ( var i = 0; i
