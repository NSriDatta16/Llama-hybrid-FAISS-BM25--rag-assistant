[site]: stackoverflow
[post_id]: 5183255
[parent_id]: 5172380
[tags]: 
As requested, here is my solution. Here is the ImageResult class, copied and modified from John public class ImageResult : ActionResult { public ImageResult() { } public byte[] ImageData { get; set; } public MemoryStream ImageStream { get; set; } public string MimeType { get; set; } public HttpCacheability Cacheability { get; set; } public string ETag { get; set; } public DateTime? Expires { get; set; } public override void ExecuteResult(ControllerContext context) { if (this.ImageData == null && ImageStream == null) { throw new ArgumentNullException("ImageData or ImageStream"); } if (string.IsNullOrEmpty(this.MimeType)) { throw new ArgumentNullException("MimeType"); } context.HttpContext.Response.ContentType = this.MimeType; if (!string.IsNullOrEmpty(this.ETag)) { context.HttpContext.Response.Cache.SetETag(this.ETag); } if (this.Expires.HasValue) { context.HttpContext.Response.Cache.SetCacheability(this.Cacheability); context.HttpContext.Response.Cache.SetExpires(this.Expires.Value); } if (ImageStream != null) { ImageData = ImageStream.ToArray(); } context.HttpContext.Response.OutputStream.Write(this.ImageData, 0, this.ImageData.Length); } } Here is my action, modified for clarity public ActionResult Index(ItemImageRequest request) { var result = queueService.GetItemImage(request); if (result.TotalResults == 0) return new EmptyResult(); ItemImage image = result.FirstResult; //image.Image is type byte[] MemoryStream tiffStream = new MemoryStream(image.Image); MemoryStream pngStream = new MemoryStream(); System.Drawing.Bitmap.FromStream(tiffStream).Save(pngStream, System.Drawing.Imaging.ImageFormat.Png); return new ImageResult() { ImageStream = pngStream, MimeType = "image/png", Cacheability = HttpCacheability.NoCache }; } Thanks to John and Will for helping me out with this.
