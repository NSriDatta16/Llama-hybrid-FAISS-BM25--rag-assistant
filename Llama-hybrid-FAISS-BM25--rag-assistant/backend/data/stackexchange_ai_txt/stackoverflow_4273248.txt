[site]: stackoverflow
[post_id]: 4273248
[parent_id]: 4269787
[tags]: 
Ok, so your MemberListViewModel is for a listing page and your MemberEditViewModel is an editing page. What I would do, in my model, is expose the following classes: ListMembersTask EditMemberTask You inject these with all the repositories each one would need, and they expose the properties and methods needed by some abstract thing that's performing each task. For instance, ListMembersTask might have a method called CreateMember() that returns a new EditMemberTask initialized with an empty Member object. Your ViewModel then gets injected with the appropriate Task (so MemberListViewModel gets injected with ListMembersTask , etc.). Your MemberListViewModel would have a RelayCommand that called CreateMember() and took the returned EditMemberTask , injected it into a MemberEditViewModel and passed the new MemberEditViewModel to the presenter. If you follow that approach, then the Repositories are only responsible for persistence. A task wraps up the state of the business logic during a session, and a view-model just makes a task bindable. The next step I've been working on is to dispense with the Task-specific view-models, and I now hand a raw Task to the Presenter, and it inspects the object and builds a view-model hierarchy for the task out of elementary view-model elements (like EditTextViewModel , ChooseOneViewModel , DockingLayoutViewModel , etc.).
