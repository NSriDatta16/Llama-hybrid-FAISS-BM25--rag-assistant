[site]: stackoverflow
[post_id]: 232624
[parent_id]: 231438
[tags]: 
I see the point on utilization but this was my reasoning for trying this particular hashing scheme. Please ket me know if I missed something. To my knowledge, possible alternatives to hashtables to create a dynamic dictionary are (balanced) binary trees and skiplists. Just for discussion let's abstract from the key and value types and let's assume that we will access values through a void * . For a binary tree I would have: struct node { void *key; void *value; struct node *left; struct node *right; } So, assuming pointers have all the same size s , to store n items I will need 4 s bytes. Skiplists are almost the same as the average number of pointers in a node is 2. In an hashtable I would have: struct slot { void *key; void *value; } So, each item will only requre 2 s bytes to be stored. If the load factor is 50%, to store n items I will need the same 4 s bytes as trees. It doesn't seem too bad to me: the cuckoo hashtable will occupy more or less the same amount of memory as a binary tree but will give me O(1) access time rather than O(log n). Not counting the complexity of keeping the tree balanced and the additional info that could be required to store balancing information in the node. Other hashing schemes could achieve a better load factor (say 75% or 80%) with no guarantee on the worst case access time (that could even be O(n) ). By the way, d-ary cuckoo hashing and " cuckoo hashing with a stash " seem to be able to increase the load factor while still keeping constant access time. Cuckoo hashing seems a valuable technique to me and I thought it was already explored; that's the reason of my question.
