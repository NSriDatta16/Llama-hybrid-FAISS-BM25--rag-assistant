[site]: stackoverflow
[post_id]: 869788
[parent_id]: 869645
[tags]: 
Some barriers include: An existing code base which doesn't lend itself to unit testing. A problem domain that is hard to unit test meaningfully, such as GUI work or integrations with third party systems. A perception of integration problems over unit problems (in other words, if it doesn't work end to end it doesn't do anything, so what is the point of testing the unit). A mindset that wants to design ahead of time and have a clear system design rather than have tests drive design A political culture where design is done by a different person/group than development, and that design is not unit-test friendly. An inability to get over the fact that TDD is not about testing for conformance (arguments like "the one who writes the tests shouldn't be the one who codes it, they will be too lenient on themselves" and such variants). It isn't they way they have coded until now, so the shift is harder. Sometimes a certain test can be hard to set up, so the method will get abandoned because it "feels" slower. Design requirements that don't lend themselves to evolving design well or at all (think Nuclear Plant control software or other systems were actual lives depend on their functioning correctly). If everyone isn't running the test before checking in code, tests start to break often for wrong reasons (that is the intended behavior of the code changed, but the test didn't keep up, so the test is wrong, not the code) so they can be perceived as a drag.
