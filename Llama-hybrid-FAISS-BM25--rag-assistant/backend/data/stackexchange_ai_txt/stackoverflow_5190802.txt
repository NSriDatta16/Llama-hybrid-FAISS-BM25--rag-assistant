[site]: stackoverflow
[post_id]: 5190802
[parent_id]: 5190577
[tags]: 
Regarding 2): sqlite doesn't do any input validation as far as I know. Looking at the sqlite docs , I see this: SQLite does not have a storage class set aside for storing dates and/or times. Instead, the built-in Date And Time Functions of SQLite are capable of storing dates and times as TEXT, REAL, or INTEGER values: TEXT as ISO8601 strings ("YYYY-MM-DD HH:MM:SS.SSS"). ... So from my reading, Digikam is the one that's not playing by the (very soft) sqlite rules. (Probably because what you are describing was not in the authors' mind when they built their database). Depending on your workflow for this, there are a few options I can think of, none very satisfying: modify the Digicam code to output something like the TEXT format for Date that SQLite advertises in its docs. modify the Django code to parse that date format. create a view in your database, using one of the [date manipulation](http://www.sqlite.org/lang_datefunc.html) functions to convert that column, and have django use that view The first two are rather complex/hard to maintain, the third one seems doable without too much hassle. A last workaround, if you're not actually using the same database (but a copy) for both apps is to write a simple script to convert that column wholesale. Not "pretty", but should work.
