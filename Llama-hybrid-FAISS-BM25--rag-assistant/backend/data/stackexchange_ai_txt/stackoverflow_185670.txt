[site]: stackoverflow
[post_id]: 185670
[parent_id]: 185448
[tags]: 
Since you're talking about a web application, you need to be very careful with assuming anything with static classes or this type of pseudo-singleton because as David B said, they are only shared across that thread. Where you will get in trouble is if IIS is configured to use more than one worker process (configured with the ill-named "Web-Garden" mode, but also the # worker processes can be set in machine.config). Assuming the box has more than one processor, whoever is trying to tweak it's performance is bound to turn this on. A better pattern for this sort of thing is to use the HttpCache object. It is already thread-safe by nature, but what still catches most people is you object also needs to be thread-safe (since you're only going to probably create the instance and then read/write to a lot of its properties over time). Here's some skeleton code to give you an idea of what I'm talking about: public SomeClassType SomeProperty { get { if (HttpContext.Current.Cache["SomeKey"] == null) { HttpContext.Current.Cache.Add("SomeKey", new SomeClass(), null, System.Web.Caching.Cache.NoAbsoluteExpiration, TimeSpan.FromDays(1), CacheItemPriority.NotRemovable, null); } return (SomeClassType) HttpContext.Current.Cache["SomeKey"]; } } Now if you think you might need a web farm (multi-server) scale path, then the above won't work as the application cache isn't shared across machines.
