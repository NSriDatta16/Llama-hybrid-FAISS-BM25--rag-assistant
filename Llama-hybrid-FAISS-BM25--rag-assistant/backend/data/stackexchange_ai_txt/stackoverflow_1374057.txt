[site]: stackoverflow
[post_id]: 1374057
[parent_id]: 1373772
[tags]: 
A process that I've used in the past to solve a similar problem is to select all of the items with a single query an order based on country, then region, then subregion. You then loop through the query result and maintain variables pointing to the last id that you saw for country and region. If the next country/region id on the beverage doesn't match the last id, you save off the old list and start a new one. Here's some really rough/messy pythoncode to explain the idea: beverages = Beverage.objects.order_by('country', 'region', 'subregion') last_country = -1 menu = [] country_obj = None for beverage in beverages: if beverage.country_id != last_country: if country_obj is not None: if region_obj is not None: if subregion_obj is not None: region_obj['children'].append(subregion_obj) country_obj['children'].append(region_obj) menu.append(country_obj) country_obj = {'name': beverage.country.name, 'children': []} last_country = beverage.country_id last_region = -1 region_obj = None last_subregion = -1 subregion_obj = None if beverage.region is None: country_obj['children'].append(beverage) else: if beverage.region_id != last_region: if region_obj is not None: if subregion_obj is not None: region_obj['children'].append(subregion_obj) country_obj['children'].append(region_obj) region_obj = {'name': beverage.region.name, 'children': []} last_region = beverage.region_id last_subregion = -1 subregion_obj = None if beverage.subregion is None: region_obj['children'].append(beverage) else: if beverage.subregion_id != last_subregion: if subregion_obj is not None: region_obj['children'].append(subregion_obj) subregion_obj = {'name': beverage.subregion.name, 'children': []} last_subregion = beverage.subregion_id subregion_obj['children'].append(beverage) if beverage.subregion is not None: region_obj['children'].append(subregion_obj) if beverage.region is not None: country_obj['children'].append(region_obj) menu.append(country_obj) As you can probably tell, each of the levels has the same logic: check if the id has changed, if it has append the old x_obj and start a new one. The last five lines are to handle the last beverage, since you always save off the previous item during the current iteration (and there's no next iteration for the last item). This is really rough around the edges, but it's the process I've been using to only require one query. I edited to fix a few bugs I found when I finally got around to running it. It appears to work for my simple test cases.
