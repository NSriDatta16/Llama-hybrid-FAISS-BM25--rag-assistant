[site]: stackoverflow
[post_id]: 5238607
[parent_id]: 5236251
[tags]: 
Based on an article by Steve Sanderson I was able to find the elegant solution I was looking for: First of all, the model needs to be modified as follows: public class SimpleModel { public IEnumerable EmailAddresses { get; set; } } public class EmailAddress { [Required(ErrorMessage = "Email Address is required.")] [DataType(DataType.EmailAddress)] [DisplayName("Email Address")] public string Value { get; set; } } The controller method handling the GET method needs to prepopulate the model with as many entries as required: [HandleError] public class SimpleController : Controller { public ActionResult Simple() { SimpleModel model = new SimpleModel { EmailAddresses = new List { // as many as required new EmailAddress { Value = string.Empty }, new EmailAddress { Value = string.Empty }, new EmailAddress { Value = string.Empty } } }; return View(model); } [HttpPost] public ActionResult Simple(SimpleModel model) { if (ModelState.IsValid) { // handling code here } return View(model); } } The view also needs to change: ... and a new partial view needs to be created. Note that the view is strongly-type with the type of the collection item. x.Value)%> x.Value)%> x.Value)%> The BeginCollectionItem is a Helper method created by Sanderson: public static class HtmlPrefixScopeExtensions { private const string idsToReuseKey = "__htmlPrefixScopeExtensions_IdsToReuse_"; public static IDisposable BeginCollectionItem(this HtmlHelper html, string collectionName) { var idsToReuse = GetIdsToReuse(html.ViewContext.HttpContext, collectionName); string itemIndex = idsToReuse.Count > 0 ? idsToReuse.Dequeue() : Guid.NewGuid().ToString(); // autocomplete="off" is needed to work around a very annoying Chrome behaviour whereby it reuses old values after the user clicks "Back", which causes the xyz.index and xyz[...] values to get out of sync. html.ViewContext.Writer.WriteLine(string.Format(" ", collectionName, html.Encode(itemIndex))); return BeginHtmlFieldPrefixScope(html, string.Format("{0}[{1}]", collectionName, itemIndex)); } public static IDisposable BeginHtmlFieldPrefixScope(this HtmlHelper html, string htmlFieldPrefix) { return new HtmlFieldPrefixScope(html.ViewData.TemplateInfo, htmlFieldPrefix); } private static Queue GetIdsToReuse(HttpContextBase httpContext, string collectionName) { // We need to use the same sequence of IDs following a server-side validation failure, // otherwise the framework won't render the validation error messages next to each item. string key = idsToReuseKey + collectionName; var queue = (Queue )httpContext.Items[key]; if (queue == null) { httpContext.Items[key] = queue = new Queue (); var previouslyUsedIds = httpContext.Request[collectionName + ".index"]; if (!string.IsNullOrEmpty(previouslyUsedIds)) foreach (string previouslyUsedId in previouslyUsedIds.Split(',')) queue.Enqueue(previouslyUsedId); } return queue; } private class HtmlFieldPrefixScope : IDisposable { private readonly TemplateInfo templateInfo; private readonly string previousHtmlFieldPrefix; public HtmlFieldPrefixScope(TemplateInfo templateInfo, string htmlFieldPrefix) { this.templateInfo = templateInfo; previousHtmlFieldPrefix = templateInfo.HtmlFieldPrefix; templateInfo.HtmlFieldPrefix = htmlFieldPrefix; } public void Dispose() { templateInfo.HtmlFieldPrefix = previousHtmlFieldPrefix; } } } ... and that's it... when you post the form the model will be automatically populated and passed to the controller action handling the POST method. Note that with this solution all the attributes including the validation work as expected.
