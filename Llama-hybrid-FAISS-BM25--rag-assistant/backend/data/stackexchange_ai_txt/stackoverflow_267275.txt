[site]: stackoverflow
[post_id]: 267275
[parent_id]: 
[tags]: 
glDrawPixels/glCopyPixels to get a magnified view producing severely clamped image

Despite an earlier question ( asked here ), our project is constrained to using glDrawPixels, so we have to do some hackery. One of the feature requirements is to be able to have a magnified view show up on a clicked region of an image; so, looking at an image, I want to click the mouse, and have a 200% image window show up where the mouse is. As I drag my cursor, the window should follow the cursor. The context is set up like: The Big Red Book has code that looks like this: Gl.glShadeModel(Gl.GL_FLAT); Gl.glClearColor(0.1f, 0.1f, 0.1f, 0.0f); Gl.glPixelStorei(Gl.GL_UNPACK_ALIGNMENT, 2); Gl.glPolygonMode(Gl.GL_FRONT_AND_BACK, Gl.GL_LINE); Gl.glDisable(Gl.GL_SCISSOR_TEST); Gl.glDisable(Gl.GL_ALPHA_TEST); Gl.glDisable(Gl.GL_STENCIL_TEST); Gl.glDisable(Gl.GL_DEPTH_TEST); Gl.glDisable(Gl.GL_BLEND); Gl.glDisable(Gl.GL_DITHER); Gl.glDisable(Gl.GL_LOGIC_OP); Gl.glDisable(Gl.GL_LIGHTING); Gl.glDisable(Gl.GL_FOG); Gl.glDisable(Gl.GL_TEXTURE_1D); Gl.glDisable(Gl.GL_TEXTURE_2D); Gl.glPixelTransferi(Gl.GL_MAP_COLOR, Gl.GL_TRUE); Gl.glPixelTransferf(Gl.GL_RED_SCALE, 1.0f); Gl.glPixelTransferi(Gl.GL_RED_BIAS, 0); Gl.glPixelTransferf(Gl.GL_GREEN_SCALE, 1.0f); Gl.glPixelTransferi(Gl.GL_GREEN_BIAS, 0); Gl.glPixelTransferf(Gl.GL_BLUE_SCALE, 1.0f); Gl.glPixelTransferi(Gl.GL_BLUE_BIAS, 0); Gl.glPixelTransferi(Gl.GL_ALPHA_SCALE, 1); Gl.glPixelTransferi(Gl.GL_ALPHA_BIAS, 0); And then the call to make the smaller-but-zoomed image looks like int width = (int)((this.Width * 0.2)/2.0); Gl.glReadBuffer(Gl.GL_FRONT_AND_BACK); Gl.glRasterPos2i(0, 0); Gl.glBitmap(0, 0, 0, 0, mStartX - (width*2), mStartY, null); Gl.glPixelZoom(2.0f, 2.0f); Gl.glCopyPixels(mStartX - width, mStartY, width, width, Gl.GL_COLOR); where mStartY and mStartX are the points where the click happened. Problem is, the window that shows up is really mangling the lookup tables, and really clamping the image down to essentially a black-and-white binary image (ie, no shades of grey). The data is a black-and-white unsigned short array, and is set with this code: float step = (65535.0f / (float)(max - min)); mColorTable = new ushort[65536]; int i; for (i = 0; i max) mColorTable[i] = 65535; else mColorTable[i] = (ushort)((float)(i - min) * step); } .... //some irrelevant code Gl.glPixelMapusv(Gl.GL_PIXEL_MAP_R_TO_R, 65536, mColorTable); Gl.glPixelMapusv(Gl.GL_PIXEL_MAP_G_TO_G, 65536, mColorTable); Gl.glPixelMapusv(Gl.GL_PIXEL_MAP_B_TO_B, 65536, mColorTable); Now, according to this documentation , I should use GL_PIXEL_MAP_I_TO_I and set INDEX_SCALE and INDEX_BIAS to zero, but doing that does not change the result, that the image is severely clamped. And by 'severely clamped' I mean it's either black or white, with very few shades of grey, but the original non-magnified image looks like what's expected. So, how do I avoid the clamping of the magnified view? Should I make a second control that follows the cursor and gets filled in with data from the first control? That approach seems like it would take the array copies outside of the graphics card and into C#, which would almost by definition be slower, and so make the control nonresponsive. Oh, I'm using C# and the Tao framework, if that matters.
