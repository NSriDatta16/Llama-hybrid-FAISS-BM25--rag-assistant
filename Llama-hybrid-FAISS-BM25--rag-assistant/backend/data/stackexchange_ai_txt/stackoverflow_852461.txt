[site]: stackoverflow
[post_id]: 852461
[parent_id]: 852072
[tags]: 
You could always use valgrind instead of rolling your own implementation. If you don't care about the amount of memory you allocate you could use an even simpler implementation: (I did this really quickly so there could be errors and I realize that it is not the most efficient implementation. The pAllocedStorage should be given an initial size and increase by some factor for a resize etc. but you get the idea.) EDIT: I missed that this was for ARM, to my knowledge valgrind is not available on ARM so that might not be an option. static size_t indexAllocedStorage = 0; static size_t *pAllocedStorage = NULL; static unsigned int free_calls = 0; static unsigned long long int total_mem_alloced = 0; void * my_malloc(size_t size){ size_t *temp; void *p = malloc(size); if(p == NULL){ fprintf(stderr,"my_malloc malloc failed, %s", strerror(errno)); exit(EXIT_FAILURE); } total_mem_alloced += size; temp = (size_t *)realloc(pAllocedStorage, (indexAllocedStorage+1) * sizeof(size_t)); if(temp == NULL){ fprintf(stderr,"my_malloc realloc failed, %s", strerror(errno)); exit(EXIT_FAILURE); } pAllocedStorage = temp; pAllocedStorage[indexAllocedStorage++] = (size_t)p; return p; } void my_free(void *p){ size_t i; int found = 0; for(i = 0; i
