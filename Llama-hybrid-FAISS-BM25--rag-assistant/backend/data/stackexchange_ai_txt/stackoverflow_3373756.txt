[site]: stackoverflow
[post_id]: 3373756
[parent_id]: 3372659
[tags]: 
I'd take following steps: get all columns together in a matrix (this is needed for proper filtering) now apply a filter (need to google for it a bit) to sharpen edges and corners create some structure to hold data for next steps (this can have many different solutions, choose your favorite and/or optimal) scan vertically (column by column) and for each segment of consequent 'ones' found in a column (segment means you have found it's start end end y coordinates) do: check that this segment overlaps some segment in the previous column if it does not, consider this a new rect. Create a rect object and assign it's handle to the segment. for the new rect, update it's metrics (this operation takes just the segment's coordinates - x , ymin , ymax , and will be discussed later) if it does, assume this is the same rect, take the rect's handle, assign this handle to the current segment then get the rect by it's handle and update it's metrics That's pretty it. After this you will have a pool of rect objects each having four coordinates of its corners. Do some primitive math to approximate rect's width and height. So where is the magic ? Well, it all happens in the update rect metrics routine. For each rect we have 13 metrics: min X => ymin1, ymax1 max X => ymin2, ymax2 min Y => xmin1, xmax1 max Y => xmin2, xmax2 average vertical segment length First of all we have to determine if this rect is properly aligned within our scan grid. To do this we compare values average vertical segment length and max Y - min Y . If they are the same (i'd choose a threshold around 97%, and then tune it for the best results), then we assume the following coordinates for our rect: (min X, max Y) (min X, min Y) (max X, max Y) (max X, min Y). In other case out rect is rotated and in this case we take it's coordinates as follows: (min X, (ymin1+ymax1)/2) ((xmin1+xmax1)/2, min Y) (max X, (ymin2+ymax2)/2) ((xmin2+xmax2)/2, max Y)
