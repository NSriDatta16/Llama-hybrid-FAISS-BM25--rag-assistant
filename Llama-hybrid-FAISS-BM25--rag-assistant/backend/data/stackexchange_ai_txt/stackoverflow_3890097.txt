[site]: stackoverflow
[post_id]: 3890097
[parent_id]: 3890047
[tags]: 
The C++ standard says that typeid returns an object of type type_info, OR AN IMPLEMENTATION-DEFINED subclass thereof. So... I guess this is pretty much the answer. So I don't see why you reject your points 1 and 2. Paragraph 5.2.8 Clause 1 of the current C++ standard reads: The result of a typeid expression is an lvalue of static type const std::type_info (18.5.1) and dynamic type const std::type_info or const name where name is an implementation-defined class derived from std::type_info which preserves the behavior described in 18.5.1.61) The lifetime of the object referred to by the lvalue extends to the end of the program. Whether or not the destructor is called for the type_info object at the end of the program is unspecified. Which in turn means that one could write the following code is legal and fine: const type_info& x = typeid(expr); which may require that type_info be polymorphic
