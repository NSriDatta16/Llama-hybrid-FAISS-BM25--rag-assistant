[site]: stackoverflow
[post_id]: 4336994
[parent_id]: 4336583
[tags]: 
I suggest you to take a look to WPF classes to do this job (GDI+ are deprecated in a web context). The way (I don't know if is THE BEST way, but I've already done this and works pretty fine) is something similar to: // Load the original image BitmapImage image = new BitmapImage(); image.BeginInit(); image.CacheOption = BitmapCacheOption.OnLoad; image.UriSource = new Uri(physical_imagepath); image.EndInit(); // Create a final render image RenderTargetBitmap final = new RenderTargetBitmap(yourNeededWidth, yourNeededHeight, yourDpiDefault, yourDpiDefault, PixelFormats.Default); DrawingVisual dv = new DrawingVisual(); using (DrawingContext dc = dv.RenderOpen()) { Rect rectImage = new Rect(0, 0, (double)image.PixelWidth, (double)image.PixelHeight); dc.DrawImage(image, rectImage); // Load the bitmap of the watermark BitmapImage watermark = new BitmapImage(); watermark.BeginInit(); watermark.CacheOption = BitmapCacheOption.OnLoad; watermark.UriSource = new Uri(physical_logopath); watermark.EndInit(); // Defines the watermark box Rect rectWatermark = new Rect(0, 0, (double)watermark.PixelWidth, (double)watermark.PixelHeight); /* use rectWatermark.X and rectWatermark.Y to move your watermark box around on the final image */ dc.DrawImage(watermark, rectWatermark); } final.Render(dv); // And then serve the final Bitmap to the client Of course all written as HttpHandler. The code above is not tested. (little ads: I've published a CodeCanyon Item that do a similar job).
