[site]: stackoverflow
[post_id]: 5015469
[parent_id]: 5013571
[tags]: 
Solutions already proposed use a parser : too long a regex : I like it but needs to know regexes the module ast: interesting but needs to know it too . I treated the problem thinking to do it in the simplest manner understandable to a beginner. Moreover, my solution shows that Python built-in capabilities are enough to do the job. . First, I present your code corrected, WhiteDawn, in order that you will be able to see the very basic points which you must understand they can be simplified using the characteristics of Python. For example, seq being a sequence, seq[len(seq)-1] is its last element, but seq[-1] is the last element too. By the way, there is an error in you code: I think it's line[1][end] = line[1][end][:len(line[1][end])-1] # not: line[1][end] = line[1][end][:len(line[1][end])-2] otherwise there is a error during execution Also note the great function enumerate() And you must study the slicing of list: if li = [45, 12, 78, 96] then li[2:3] = [2, 5, 8] transforms li to li = [45, 12, 2, 5, 8, 96] y = "4:(1,2;4),(2,6;3),(3,7;15),(4,8;1),(5,6;1),(6,7;1),(5,9;9),(6,10;2),(7,11;1),(8,12;23),(9,10;5),(9,13;7),(10,14;6),(11,15;3),(12,16;3),(13,14;4),(15,16;7)" def partitionData(line): finalDic = dict() #partition the data around the formating print 'line==',line line = line.split(":") print '\ninstruction : line = line.split(":")' print 'line==',line print 'len of line==',len(line),' (2 strings)' print '---------------------' line[1] = line[1].split("),(") print '\ninstruction : line[1] = line[1].split("),(")' print 'line[1]==',line[1] #clean up data some more line[1][0] = line[1][0][1:] print 'instruction : line[1][0] = line[1][0][1:]' line[1][-1] = line[1][-1][0:-1] print 'instruction : line[1][-1] = line[1][-1][0:-1]' print 'line[1]==',line[1] print '---------------------' #simplify data and organize into a list for i,x in enumerate(line[1]): line[1][i] = x.split(",") line[1][i][1:] = line[1][i][1].split(";") print 'loop to clean the data in line[1]' print 'line[1]==',line[1] print '---------------------' #convert everything to integer to simplify algorithm print 'convert everything to integer to simplify algorithm' for i,x in enumerate(line[1]): line[1][i] = map(int,x) line[0] = int(line[0]) print 'line==',line print '---------------------' newData = dict() for a,b,c in line[1]: newData[(a,b)] = c line[1] = newData print 'line==',line print '---------------------' for i in line[1]: print 'i==',i,' (min(i),max(i))==',(min(i),max(i)) if not ((min(i),max(i)) in finalDic): finalDic[(min(i),max(i))] = line[1][i] else: print "There is a edge referenced twice!" exit() line[1] = finalDic print '\nline==',line return line print partitionData(y) . Secondly, my solution: y = "4:(1,2;4),(2,6;3),(3,7;15),(4,8;1),(5,6;1),(6,7;1),(5,9;9),(6,10;2),(7,11;1),(8,12;23),(9,10;5),(9,13;7),(10,14;6),(11,15;3),(12,16;3),(13,14;4),(15,16;7)" # line[1]== {(1, 2): 4, (5, 9): 9, (2, 6): 3, (6, 7): 1, (4, 8): 1, (5, 6): 1, (6, 10): 2, (9, 10): 5, (13, 14): 4, (11, 15): 3, (10, 14): 6, (9, 13): 7, (12, 16): 3, (7, 11): 1, (3, 7): 15, (8, 12): 23, (15, 16): 7} def partitionData(line): finalDic = dict() #partition the data around the formating print '\nline==',line line = line.split(":") print '\ninstruction:\n line = line.split(":")' print 'result:\n line==',line print '\n----------------------------------------------------' print '\nline[1]==',line[1] line[1] = line[1][1:-1].replace(";",",") print '\ninstruction:\n line[1] = line[1][1:-1].replace(";",",")' print 'result:\n line[1]==',line[1] line[1] = [ x.split(",") for x in line[1].split("),(") ] print '\ninstruction:\n line[1] = [ x.split(",") for x in line[1].split("),(") ]' print 'result:\n line[1]==',line[1] line = [int(line[0]),dict( ((int(a),int(b)),int(c)) for (a,b,c) in line[1] ) ] print '\ninstruction:\n line = [int(line[0],dict( ((int(a),int(b)),int(c)) for (a,b,c) in line[1] ) ]' print 'result:\n line[1]==',line[1] for i in line[1]: if not ((min(i),max(i)) in finalDic): finalDic[(min(i),max(i))] = line[1][i] else: print "There is a edge referenced twice!" exit() line[1] = finalDic print '\nline[1]==',line[1] return line print partitionData(y) I let the end with FinalDict untouched because I don't understand what does this snippet. If i is a couple of integers, (min(i),max(i)) is nothing else than the couple itself
