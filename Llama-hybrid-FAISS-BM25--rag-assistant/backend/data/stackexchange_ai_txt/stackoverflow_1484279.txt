[site]: stackoverflow
[post_id]: 1484279
[parent_id]: 
[tags]: 
How should I refactor a long chain of try-and-catch-wrapped speculative casting operations

I have some C# code that walks XML schemata using the Xml.Schema classes from the .NET framework. The various simple type restrictions are abstracted in the framework as a whole bunch of classes derived from Xml.Schema.XmlSchemaFacet. Unless there is something I've missed, the only way to know which of the derived facet types a given facet is, is to speculatively cast it to one of them, catching the resultant InvalidCastOperation in case of failure. Doing this leaves me with a really ugly function like this: private void NavigateFacet(XmlSchemaFacet facet) { try { handler.Length((XmlSchemaLengthFacet)facet); } catch(InvalidCastException) { try { handler.MinLength((XmlSchemaMinLengthFacet)facet); } catch(InvalidCastException) { try { handler.MaxLength((XmlSchemaMaxLengthFacet)facet); } catch(InvalidCastException) { ... } } } } I assume there must be more elegant ways to do this; either using some property I've missed from the .NET framework, or with some clever piece of OO trickery. Can anyone enlighten me?
