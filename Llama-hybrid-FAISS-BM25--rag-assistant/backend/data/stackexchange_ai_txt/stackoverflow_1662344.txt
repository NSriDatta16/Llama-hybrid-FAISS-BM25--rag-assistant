[site]: stackoverflow
[post_id]: 1662344
[parent_id]: 1639312
[tags]: 
I found a way to at least estimate the size of an object before sending it to LocalConnection by constructing a temporary SharedObject with the data. Since the SharedObject isn't ever written to the disk it seems to work even when local storage isn't allowed. Here's the function I'm going to use to determine the size: public static function getObjectSize(o:Object):Number { var so:SharedObject = SharedObject.getLocal("__getObjectSizeHelper"); so.data.o = o; var size:Number = so.getSize(); so.clear(); return size; } The messages I'm sending that are too big are arrays of complex objects. I'm going to assume no individual object will be too big (not 100% guaranteed, but most likely no user will put in enough data to make it big enough, and ignoring this case for now makes things much simpler). Given this assumption, I'll check the array before sending. If it's too big I'll split it in half and try those two arrays. I'll continue recursively splitting in half until I get to a set of arrays that are all small enough (Most likely I'll never need more than 1 split, but if I do then only 2 or 3). Then each part of the array can be sent individually and recombined on the other end of the communication channel. Here's the code I created to split an array into multiple arrays that are all small enough to send: public static function isTooBigForLC(o:Object):Boolean { return getObjectSize(o) > 35000; } public static function splitArrayForLC(a:Array):Array { if (!isTooBigForLC(a)) { return [a]; } if (a.length I'm modifying my send code to call this on the potentially-too-big Array before it's sent, and then send each of the "split" arrays separately. Then in my receive code I'm recombining them and raising a single event with the combined data. I'm keeping this updated for now (with documentation) here: http://gist.github.com/224258
