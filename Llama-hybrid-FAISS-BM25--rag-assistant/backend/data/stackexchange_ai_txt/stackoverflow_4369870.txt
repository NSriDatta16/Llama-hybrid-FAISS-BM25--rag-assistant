[site]: stackoverflow
[post_id]: 4369870
[parent_id]: 4369063
[tags]: 
this.gCurrentMouseX = evt.x; You don't want to use .x . It doesn't exist on a standard DOM MouseEvent object (which is why Firefox doesn't have it) and even in IE, it's usually not what you want. It's relative to the nearest positioned ancestor, where the meaning of ‘positioned’ may vary. It's generally better to get page-relative co-ordinates. Unfortunately, the pageX property that gives you this is also not a standard Event property, so although it is supported by IE9, Firefox, WebKit etc, you can't guarantee it's there. You can instead use clientX , which is standard, but is relative to the viewport, so to correct it in case the viewport has scrolled, you have to add the scrollLeft of the documentElement (unless you're in IE Quirks Mode, in which case it's the body instead... don't be in Quirks Mode!). (The other standard positioning property on MouseEvent is screenX , but that's largely useless except for positioning popups. There are also the non-standard properties offsetX and layerX which are even more useless.) if (window.event) { Better to test for the standard first ( evt not being undefined ), and only fall back to window.event for IE event . // Update mouse coords this.gUpdateMousePos = function(evt) { if (evt===undefined) evt= window.event; if ('pageX' in evt) { this.gCurrentMouseX = evt.pageX; this.gCurrentMouseY = evt.pageY; } else { this.gCurrentMouseX = evt.clientX+document.documentElement.scrollLeft; this.gCurrentMouseY = evt.clientY+document.documentElement.scrollTop; } } This gives you page-relative co-ordinates. If you want to calculate position relative to a particular element you then have to subtract the page-relative co-ordinates of that element, typically using an offsetLeft / offsetParent loop. Though there are lots more potential browser problems there too. Sigh. Frameworks can help here. Although to be honest most of them still trip up on some of the uglier corner cases. (It would be jolly nice if some helpful organisation would specify MouseEvent pageX / pageY as being standard, and add element/view pageLeft / pageTop properties to match... I can dream...)
