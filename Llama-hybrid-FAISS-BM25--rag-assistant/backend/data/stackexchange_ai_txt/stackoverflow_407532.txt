[site]: stackoverflow
[post_id]: 407532
[parent_id]: 406760
[tags]: 
Opinion: Data driven design puts the cart before the horse. It should be eliminated from our thinking forthwith. The vast majority of software isn't about the data, it's about the business problem we're trying to solve for our customers. It's about a problem domain , which involves objects, rules, flows, cases, and relationships. When we start our design with the data, and model the rest of the system after the data and the relationships between the data (tables, foreign keys, and x-to-x relationships), we constrain the entire application to how the data is stored in and retrieved from the database. Further, we expose the database architecture to the software. The database schema is an implementation detail. We should be free to change it without having to significantly alter the design of our software at all. The business layer should never have to know how the tables are set up, or if it's pulling from a view or a table, or getting the table from dynamic SQL or a stored procedure. And that type of code should never appear in the presentation layer. Software is about solving business problems. We deal with users, cars, accounts, balances, averages, summaries, transfers, animals, messsages, packages, carts, orders, and all sorts of other real tangible objects, and the actions we can perform on them. We need to save , load , update , find , and delete those items as needed. Sometimes, we have to do those things in special ways. But there's no real compelling reason that we should take the work that should be done in the database and move it away from the data and put it in the source code, potentially on a separate machine (introducing network traffic and degrading performance). Doing so means turning our backs on the decades of work that has already been done to improve the performance of stored procedures and functions built into databases. The argument that stored procedures introduce "yet another API" to be manged is specious: of course it does; that API is a facade that shields you from the database schema, including the intricate details of primary and foreign keys, transactions, cursors, and so on, and it prevents you from having to splice SQL together in your source code. Put the horse back in front of the cart. Think about the problem domain, and design the solution around it. Then, derive the data from the problem domain.
