[site]: stackoverflow
[post_id]: 741707
[parent_id]: 741687
[tags]: 
First of all, you can improve this by just causing an early function-return: def conflicts?(other) conflicts = 0 recurrences.each do |my_rec| other.recurrences.each do |other_rec| start, finish = other_rec.first, other_rec.last return true if my_rec.include?(start) || my_rec.include?(finish) end end false end This will however not improve the average performance of your algorithm but will only cause one comparision if there is a conflict. The only option you got is to detect "simple" collisions early. So like Store the type of recurrence (weekly, daily, monthly) into the recurrence object. If both are daily recurrences, find the first day where the might be a potential conflict. Example: daily, a: January-July, b: May-October should only check May,1st for a time-conflict. If there doesn't happen one, you do not need to check for any other conflicts. Do the same for different constellations (week-week, day-week, day-year). Avoid to write day-week and week-day - week_day(x,y) is the same as day_week(y,x) . If you don't find a matching method, you will have to use the method given above as a fallback. As you can see the latter is much more work - AND the worst-case execution time might be the same (since it uses the original algorithm as a fallback). Worst-case might be caused by an "irregular" reccurence ("each day one hour later") for example.
