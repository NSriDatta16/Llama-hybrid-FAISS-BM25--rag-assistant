[site]: stackoverflow
[post_id]: 1214903
[parent_id]: 1214513
[tags]: 
Here's a basic and relatively fast solution, keep reading below for some commentary: private static string GetCase(string path) { DirectoryInfo dir = new DirectoryInfo(path); if (dir.Exists) { string[] folders = dir.FullName.Split(Path.DirectorySeparatorChar); dir = dir.Root; foreach (var f in folders.Skip(1)) { dir = dir.GetDirectories(f).First(); } return dir.FullName; } else { return path; } } The basic idea is that getting subdirectories from a DirectoryInfo object will get you the correct case, so we just need to split the directory name and walk from the root to the target directory, getting the proper case at each step. My initial answer relied on getting the casing for every folder on the drive, and it worked but was slow. I came up with a slight improvement that stored the results, but it was still too slow for everyday usage. You can see the edit history for this comment if you need to do this for every thing on the drive, and even then there are probably ways to speed up that code. It was "here's how you might do it" and not "here's a great way to do it." Bertu, in his answer, came up with the idea of splitting the path into its components and getting the casing piece by piece, which results in a huge speed increase since you're no longer checking everything as in my original answer. Bertu also generalized his solution to do files as well as directories. In my tests, the code posted above (which uses Bertu's "split the path and do it by pieces" idea but approaches it iteratively instead of recursively) runs in about half the time of Bertu's code. I'm not sure if that's because his method also handles files, because his use of recursion introduces extra overhead, or because he ends up calling Path.GetFileName(path) and Path.GetDirectoryName(path) in each iteration. Depending on your exact needs, some combination of his answer and mine will likely solve your problem as well as is possible in C#. On that note, I should mention that there are some limitations to .Net filename handling, and since doing this in .Net requires making a lot of DirectoryInfo objects, you might want to consider unmanaged code if this is your bottleneck.
