[site]: stackoverflow
[post_id]: 382666
[parent_id]: 382624
[tags]: 
@measured decorates the some_func() function, using a function or class named measured . The @ is the decorator syntax, measured is the decorator function name. Decorators can be a bit hard to understand, but they are basically used to either wrap code around a function, or inject code into one. For example the measured function (used as a decorator) is probably implemented like this... import time def measured(orig_function): # When you decorate a function, the decorator func is called # with the original function as the first argument. # You return a new, modified function. This returned function # is what the to-be-decorated function becomes. print "INFO: This from the decorator function" print "INFO: I am about to decorate %s" % (orig_function) # This is what some_func will become: def newfunc(*args, **kwargs): print "INFO: This is the decorated function being called" start = time.time() # Execute the old function, passing arguments orig_func_return = orig_function(*args, **kwargs) end = time.time() print "Function took %s seconds to execute" % (end - start) return orig_func_return # return the output of the original function # Return the modified function, which.. return newfunc @measured def some_func(arg1): print "This is my original function! Argument was %s" % arg1 # We call the now decorated function.. some_func(123) #.. and we should get (minus the INFO messages): This is my original function! Argument was 123 # Function took 7.86781311035e-06 to execute The decorator syntax is just a shorter and neater way of doing the following: def some_func(): print "This is my original function!" some_func = measured(some_func) There are some decorators included with Python, for example staticmethod - but measured is not one of them: >>> type(measured) Traceback (most recent call last): File " ", line 1, in NameError: name 'measured' is not defined Check the projects import statements to see where the function or class is coming from. If it uses from blah import * you'll need to check all of those files (which is why import * is discouraged), or you could just do something like grep -R def measured *
