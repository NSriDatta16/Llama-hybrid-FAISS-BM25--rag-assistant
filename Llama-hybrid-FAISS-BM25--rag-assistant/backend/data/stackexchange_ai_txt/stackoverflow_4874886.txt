[site]: stackoverflow
[post_id]: 4874886
[parent_id]: 4872989
[tags]: 
This is exactly the approach I use and I've never had any problems with it. In my design, anything that comes out of the data access layer is abstracted as an interface (I refer to them as data transport contracts). In my domain model I then have static methods to create business entities from those data transport objects.. interface IFooData { int FooId { get; set; } } public class FooEntity { static public FooEntity FromDataTransport(IFooData data) { return new FooEntity(data.FooId, ...); } } It comes in quite handy where your domain model entities gather their data from multiple data contracts: public class CompositeEntity { static public CompositeEntity FromDataTransport(IFooData fooData, IBarData barData) { ... } } In contrast to your design, I don't provide factories to create concrete implementations of the data transport contracts, but rather provide delegates to write the values and let the repository worry about creating the concrete objects public class FooDataRepository { public IFooData Insert(Action insertSequence) { var record = new ConcreteFoo(); insertSequence.Invoke(record as IFooData); this.DataContext.Foos.InsertOnSubmit(record); // Assuming LinqSql in this case.. return record as IFooData; } } usage: IFooData newFoo = FooRepository.Insert(f => { f.Name = "New Foo"; }); Although a factory implementation is an equally elegant solution in my opinion. To answer your question, In my experience of a very similar approach I've never come up against any major problems, and I think you're on the right track here :)
