[site]: stackoverflow
[post_id]: 1241117
[parent_id]: 1240833
[tags]: 
Ok, here's one possible approach. The rough strategy here is this Accounts (i.e., access credentials) are separate from profiles (entity-specific data) Accounts identify the type of profile Profiles link back to their account with a foreign key. Other related tables (comments, for example) would use account.account_id as their foreign key. Queries could then determine which profile table to use when selecting additional information. Here's a quick ERD I knocked up with the wonderful MySQL Workbench tool. erd http://www.shackpics.com/files/sample_erd_co3zt3y5la0l81g4m530.png And here's the CREATE script generated by the tool for this model SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0; SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0; SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL'; CREATE SCHEMA IF NOT EXISTS `mydb` DEFAULT CHARACTER SET latin1 COLLATE latin1_swedish_ci ; USE `mydb`; -- ----------------------------------------------------- -- Table `mydb`.`account` -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `account` ( `account_id` INT UNSIGNED NOT NULL AUTO_INCREMENT , `login` VARCHAR(45) NULL , `password` VARCHAR(45) NULL , `account_type` TINYINT UNSIGNED NULL , PRIMARY KEY (`account_id`) ) ENGINE = InnoDB; -- ----------------------------------------------------- -- Table `mydb`.`organization_profile` -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `organization_profile` ( `organization_profile_id` INT UNSIGNED NOT NULL AUTO_INCREMENT , `account_id` INT UNSIGNED NOT NULL , `organization_name` VARCHAR(45) NULL , PRIMARY KEY (`organization_profile_id`) , INDEX `fk_organization_profile_account` (`account_id` ASC) , CONSTRAINT `fk_organization_profile_account` FOREIGN KEY (`account_id` ) REFERENCES `account` (`account_id` ) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE = InnoDB; -- ----------------------------------------------------- -- Table `mydb`.`user_profile` -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `user_profile` ( `user_profile_id` INT UNSIGNED NOT NULL AUTO_INCREMENT , `account_id` INT UNSIGNED NULL , `first_name` VARCHAR(45) NULL , `last_name` VARCHAR(45) NULL , PRIMARY KEY (`user_profile_id`) , INDEX `fk_user_profile_account1` (`account_id` ASC) , CONSTRAINT `fk_user_profile_account1` FOREIGN KEY (`account_id` ) REFERENCES `account` (`account_id` ) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE = InnoDB; -- ----------------------------------------------------- -- Table `mydb`.`xref_user_profile_has_organization_profile` -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `xref_user_profile_has_organization_profile` ( `user_profile_id` INT UNSIGNED NOT NULL , `organization_profile_id` INT UNSIGNED NOT NULL , PRIMARY KEY (`user_profile_id`, `organization_profile_id`) , INDEX `fk_xref_user_profile_has_organization_profile_user_profile1` (`user_profile_id` ASC) , INDEX `fk_xref_user_profile_has_organization_profile_organization_pro1` (`organization_profile_id` ASC) , CONSTRAINT `fk_xref_user_profile_has_organization_profile_user_profile1` FOREIGN KEY (`user_profile_id` ) REFERENCES `user_profile` (`user_profile_id` ) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `fk_xref_user_profile_has_organization_profile_organization_pro1` FOREIGN KEY (`organization_profile_id` ) REFERENCES `organization_profile` (`organization_profile_id` ) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE = InnoDB; SET SQL_MODE=@OLD_SQL_MODE; SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS; SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS; Note: I do not advocate storing plain-text passwords. This is only a sample model to describe relationships, not cover the specifics of secure access-credential storage. The basic strategy here is that you would arbitrarily "give" each profile table an "account_type" number. For example, organizations would be 1 , and users would be 2 .
