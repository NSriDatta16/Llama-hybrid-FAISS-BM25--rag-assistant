[site]: stackoverflow
[post_id]: 2869289
[parent_id]: 2869082
[tags]: 
I think this is bad practice for two reasons. It is not clear to the caller that other operations above and beyond what is minimally required for initialization are taking place. It leads to awkward coding scenarios if this operation throws exception. Regarding the first point...there is an implicit assumption that constructors only perform enough work to construct an object in a defined and consistent state. Placing extra work in them can lead to confusion if the work is long running or IO bound. Remember, the constructor cannot convey any meaning through its name like methods. One alternative is to create a static factory method with a meaningful name that returns a new instance. Regarding the second point...if the constructor contains an operation that throws exceptions unpredictably (contrasted with exceptions thrown because of parameter validation for example) then your exception handling code gets awkward. Consider the following example in C#. Notice how the good design has a more elegant feel to it. Nevermind, the fact that the clearly named method is at least an order of magnitude more readable. public class BadDesign : IDisposable { public BadDesign() { PerformIOBoundOperation(); } private void PerformIOBoundOperation() { } } public class GoodDesign : IDisposable { public GoodDesign() { } public void PerformIOBoundOperation() { } } public static void Main() { BadDesign bad = null; try { bad = new BadDesign(); } catch { // 'bad' is left as null reference. There is nothing more we can do. } finally { if (bad != null) { bad.Dispose(); } } GoodDesign good = new GoodDesign(); try { good.PerformIOBoundOperation(); } catch { // Do something to 'good' to recover from the error. } finally { good.Dispose(); } }
