[site]: stackoverflow
[post_id]: 1058364
[parent_id]: 859535
[tags]: 
Don't read directly into struct from a file! The packing might be different, you have to fiddle with pragma pack or similar compiler specific constructs. Too unreliable. A lot of programmers get away with this since their code isn't compiled in wide number of architectures and systems, but that doesn't mean it's OK thing to do! A good alternative approach is to read the header, whatever, into a buffer and parse from three to avoid the I/O overhead in atomic operations like reading a unsigned 32 bit integer! char buffer[32]; char* temp = buffer; f.read(buffer, 32); RECORD rec; rec.foo = parse_uint32(temp); temp += 4; rec.bar = parse_uint32(temp); temp += 4; memcpy(&rec.fooword, temp, 11); temp += 11; memcpy(%red.barword, temp, 11); temp += 11; rec.baz = parse_uint16(temp); temp += 2; The declaration of parse_uint32 would look like this: uint32 parse_uint32(char* buffer) { uint32 x; // ... return x; } This is a very simple abstraction, it doesn't cost any extra in practise to update the pointer as well: uint32 parse_uint32(char*& buffer) { uint32 x; // ... buffer += 4; return x; } The later form allows cleaner code for parsing the buffer; the pointer is automatically updated when you parse from the input. Likewise, memcpy could have a helper, something like: void parse_copy(void* dest, char*& buffer, size_t size) { memcpy(dest, buffer, size); buffer += size; } The beauty of this kind of arrangement is that you can have namespace "little_endian" and "big_endian", then you can do this in your code: using little_endian; // do your parsing for little_endian input stream here.. Easy to switch endianess for the same code, though, rarely needed feature.. file-formats usually have a fixed endianess anyway. DO NOT abstract this into class with virtual methods; would just add overhead, but feel free to if so inclined: little_endian_reader reader(data, size); uint32 x = reader.read_uint32(); uint32 y = reader.read_uint32(); The reader object would obviously just be a thin wrapper around pointer. The size parameter would be for error checking, if any. Not really mandatory for the interface per-se. Notice how the choise of endianess here was done at COMPILATION TIME (since we create little_endian_reader object), so we invoke the virtual method overhead for no particularly good reason, so I wouldn't go with this approach. ;-) At this stage there is no real reason to keep the "fileformat struct" around as-is, you can organize the data to your liking and not necessarily read it into any specific struct at all; after all, it's just data. When you read files like images, you don't really need the header around.. you should have your image container which is same for all file types, so the code to read a specific format should just read the file, interpret and reformat the data & store the payload. =) I mean, does this look complicated? uint32 xsize = buffer.read (); uint32 ysize = buffer.read (); float aspect = buffer.read (); The code can look that nice, and be a really low-overhead! If the endianess is same for file and architecture the code is compiled for, the innerloop can look like this: uint32 value = *reinterpret_cast )(ptr); ptr += 4; return value; That might be illegal on some architectures, so that optimization might be a Bad Idea, and use slower, but more robust approach: uint32 value = ptr[0] | (static_cast (ptr[1]) On a x86 that can compile into bswap or mov, which is reasonably low-overhead if the method is inlined; the compiler would insert "move" node into the intermediate code, nothing else, which is fairly efficient. If alignment is a problem the full read-shift-or sequence might get generated, outch, but still not too shabby. Compare-branch could allow the optimization, if test the address LSB's and see if can use the fast or slow version of the parsing. But this would mean penalty for the test in every read. Might not be worth the effort. Oh, right, we are reading HEADERS and stuff, I don't think that is a bottleneck in too many applications. If some codec is doing some really TIGHT innerloop, again, reading into a temporary buffer and decoding from there is well-adviced. Same principle.. no one reads byte-at-time from file when processing a large volume of data. Well, actually, I seen that kind of code very often and the usual reply to "why you do it" is that the file systems do block reads and that the bytes come from memory anyway, true, but they go through a deep call stack which is high-overhead for getting a few bytes! Still, write the parser code once and use zillion times -> epic win. Reading directly into struct from a file: DON'T DO IT FOLKS!
