[site]: stackoverflow
[post_id]: 5212423
[parent_id]: 5212356
[tags]: 
What's happening here is that the structure is being padded with an extra byte so that the union can be correctly aligned. The 01 following the FE is padding, the actual union starts at the next byte. That's because the alignment requirement for a union is affected by the alignment requirements of its parts. Since Length2 has a requirement to be aligned on a two-byte boundary, a padding byte is inserted before it to ensure this happens. If the stream you read in was FE FF 01 40 12 00 30 ... , you would still get the same values. As an aside, I think "Shouldnâ€™t Length2 be 0101 and value be 48?" should actually have read 64 (0x40) rather than 48 (0x30) . I assume that was a typo on your part. If you need the structure to not have padding, there's no standard way to do it but your compiler should provide a way. For example, you could use something like attributes in gcc : typedef struct { unsigned char Type; union { unsigned char Length; unsigned __int16 Length2; } char Value[0]; } __attribute__ ((aligned(1),packed)) TLV_TUPLE; Other environments may provide a #pragma pack or something similar to acheive the same end.
