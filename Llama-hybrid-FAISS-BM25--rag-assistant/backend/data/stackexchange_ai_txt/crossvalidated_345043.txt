[site]: crossvalidated
[post_id]: 345043
[parent_id]: 344746
[tags]: 
Huh... I made my post as a guest on SO because I am still on a suspension, but then the question got migrated here! So, if I understand you correctly, there's not really any similarity between the smooth s(x1, x2) and the random effect s(x1, x2, fac, bs = "re"), correct? Correct. The function name "s" does not mean "smooth function" when s() is used to construct a random effect. Broadly speaking, s() is just a model term constructor routine that constructs a design matrix and a penalty matrix. What I was envisioning was something smoothing in 2 dimensions like the former, but with some deviations from the average by factor level. You can get separate smooths per factor level using s(x1, x2, by=fac), but that completely separates the data for each factor level, rather than doing some partial pooling. s(x1, x2, by = fac) gives you something pretty close to what you want, except that as you said, data from different factor levels are treated independently. Technically, "close" means that s(x1, x2, by = fac) gives you the correct design matrix but not the correct penalty matrix. In this regard, you are probably aiming at te(x1, x2, fac, d = c(2, 1), bs = c("tp", "re")) . I have never seen such model term before, but its construction is definitely possible in mgcv : library(mgcv) x1 You can check that this smooth term has 2 smoothing parameters as expected, one for the s(x1, x2, bs = 'tp') margin, the other for the s(f, bs = 're') margin. Specification of k turns out subtle. You need to explicitly pass nlevels(f) to the random effect margin. For example, if you want a rank-10 thin-plate regression spline, ## my example factor `f` has 5 levels smooth_spec At first I was thinking that perhaps we can simply pass NA to the random effect margin, but it turns out not! smooth_spec This might implies that there is a tiny bug... will have a check when available.
