[site]: crossvalidated
[post_id]: 591007
[parent_id]: 590947
[tags]: 
A quick and--usually--easy way to verify an estimator is to apply it to simulated data. I will describe this approach in a way that generalizes to any estimator in any situation. Begin by coding your estimator. Here is an R implementation. Its input is a sample in an array x . It outputs the estimated parameter $\hat p(x).$ estimator You will need to generate random datasets. This function creates independent random Binomial $(m,p)$ variables truncated to exceed the value of $k:$ rbinom.trunc The simplest check is whether, on average, (1) the estimator's value is close to the parameter value for a range of parameter values and (2) that it gets closer as the sample size increases. That needs a double loop , implemented below using the outer function in R , which takes care of running the following simulate function for a specified sample size n and parameter value p : simulate The third argument n.sim is the number of samples to generate. These are placed into a matrix, one sample per column, and the estimator is applied to each column to produce its estimate $\hat p.$ simulate returns the mean of all these estimates. (For a more detailed study, portray the entire set of estimates graphically with a histogram, probability plot, frequency plot, or whatever.) Here is an example of its use, where the values of $n,$ $p,$ and $\hat p$ are collected into a data frame for visualization: n When I ran it, the output indicates the estimator is biased low for tiny values of $n,$ but once $n \ge 5$ or so, it is accurate. This doesn't mean it's a good estimator (we wouldn't expect the MLE to be a great one for small samples), but clearly it works. This is a gussied-up version of the ggplot2 visualization of X created by ggplot(X, aes(p, Estimate, color = n)) + geom_point() . You can also make a usable, not-quite-so-pretty plot with the base plot command, as in with(X, plot(p, Estimate)) . Apart from the lines that specify the range of sample sizes n , the range of parameter values p , and the simulation size n.sim , this solution requires five lines of code for the five basic steps to estimate -- generate -- simulate -- organize -- summarize the results. Carrying out this kind of check often is so quick and easy (the computation time is negligible) that it's always worth doing when you care about your answer.
