[site]: crossvalidated
[post_id]: 539193
[parent_id]: 539159
[tags]: 
You don't need a neural network for such a problem. Yes, date formats can varry , but they are standardized patterns. The kind of patterns can be easily matched using regular expressions , here you can find one example . It's easier, faster, and simpler to debug. With a neural network, you have no control over what it considers as a date, it will be something similar to what it saw in the training data, but with no guarantees. A neural network is an overkill in here. If the dates contain irregularities, you can additionally use fuzzy matching . If you insist on using a neural network (e.g. for educational purposes), to create valid date strings, you can just write a small script with several for loops iteration over years, months, days, and formats to create all the possible patterns. from datetime import datetime dates = [] # just an example, there are many more formats you may care about # you may also want to use camel case, lowercase and uppercase patterns formats = [r'%Y-%m-%d', r'%y-%m-%d', r'%Y/%m/%d', r'%d-%m-%Y', r'%d %b %Y', r'%d %B %Y'] for year in range(1900, 2022): for month in range(1, 13): for day in range(1, 31): for fmt in formats: try: date = datetime(year, month, day).strftime(fmt) dates.append(date) except ValueError: # nonexistent date pass Depending on what exactly you want your model to do (classify, extract, translate to common format) you could either mix them with false examples of letter and number patterns (phone numbers, P.O. box numbers, etc) and words that are not dates, inject them into text, or create translation pairs. Notice that for either searching valid examples or labeling them, you need first to do the homework and create the rules using regular expressions. If you want to generate the dates, you need to come up with a generator script that knows the rules. So in the end, first you need a working solution not based on a neural network. It would also serve as a baseline (if you label or generate the patterns yourself, the baseline will have perfect accuracy). The rule-based solution should be able to match nearly all the possible patterns, except for some strange typos. If you would like a fool-proof algorithm, you can have a two-step procedure: Use the rule-based algorithm (regexes) to match the simple cases. Extract the ambiguous maybe-dates using some very broad rules like \d{1,4}[^\d]{4,20}\d{1,4} and pass them to a neural network trained on a dataset with dates in strange formats and typos (you need to find them and label by hand first). This would be fast since most of the work would be done by regexes rather than a neural network and have a guaranteed good base performance since in the worst case you are making mistakes on ambiguous examples.
