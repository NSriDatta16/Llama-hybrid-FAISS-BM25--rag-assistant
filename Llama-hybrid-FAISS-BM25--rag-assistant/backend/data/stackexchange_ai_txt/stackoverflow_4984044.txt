[site]: stackoverflow
[post_id]: 4984044
[parent_id]: 4983915
[tags]: 
Short answer: No, time() is not a good salt. Long answer: copied from my answer to Salt Generation and open source software What is a salt? A salt is a random set of bytes of a fixed length that is added to the input of a hash algorithm. Why is salting (or seeding) a hash useful? Adding a random salt to a hash ensures that the same password will produce many different hashes. The salt is usually stored in the database, together with the result of the hash function. Salting a hash is good for a number of reasons: Salting greatly increases the difficulty/cost of precomputated attacks (including rainbow tables ) Salting makes sure that the same password does not result in the same hash. This makes sure you cannot determine if two users have the same password. And, even more important , you cannot determine if the same person uses the same password across different systems. Salting increases the complexity of passwords, thereby greatly decreasing the effectiveness of both Dictionary- and Birthday attacks . (This is only true if the salt is stored separate from the hash). Proper salting greatly increases the storage need for precomputation attacks, up to the point where they are no longer practical. (8 character case-sensitive alpha-numeric passwords with 16 bit salt, hashed to a 128 bit value, would take up just under 200 exabytes without rainbow reduction). There is no need for the salt to be secret. A salt is not a secret key, instead a salt 'works' by making the hash function specific to each instance. With salted hash, there is not one hash function, but one for every possible salt value. This prevent the attacker from attacking N hashed passwords for less than N times the cost of attacking one password. This is the point of the salt. A "secret salt" is not a salt, it is called a "key", and it means that you are no longer computing a hash, but a Message Authentication Code (MAC). Computing MAC is tricky business (much trickier than simply slapping together a key and a value into a hash function) and it is a very different subject altogether. The salt must be random for every instance in which it is used. This ensures that an attacker has to attack every salted hash separately. If you rely on your salt (or salting algorithm) being secret, you enter the realms of Security Through Obscurity (won't work). Most probably, you do not get additional security from the salt secrecy; you just get the warm fuzzy feeling of security. So instead of making your system more secure, it just distracts you from reality. So, why does the salt have to be random? Technically, the salt should be unique . The point of the salt is to be distinct for each hashed password. This is meant worldwide . Since there is no central organization which distributes unique salts on demand, we have to rely on the next best thing, which is random selection with an unpredictable random generator, preferably within a salt space large enough to make collisions improbable (two instances using the same salt value). It is tempting to try to derive a salt from some data which is "presumably unique", such as the user ID, but such schemes often fail due to some nasty details: If you use for example the user ID , some bad guys, attacking distinct systems, may just pool their resources and create precomputed tables for user IDs 1 to 50. A user ID is unique system-wide but not worldwide . The same applies to the username : there is one "root" per Unix system, but there are many roots in the world. A rainbow table for "root" would be worth the effort, since it could be applied to millions of systems. Worse yet, there are also many "bob" out there, and many do not have sysadmin training: their passwords could be quite weak. Uniqueness is also temporal. Sometimes, users change their password. For each new password , a new salt must be selected. Otherwise, an attacker obtained the hash of the old password and the hash of the new could try to attack both simultaneously. Using a random salt obtained from a cryptographically secure, unpredictable PRNG may be some kind of overkill, but at least it provably protects you against all those hazards. It's not about preventing the attacker from knowing what an individual salt is, it's about not giving them the big, fat target that will be used on a substantial number of potential targets. Random selection makes the targets as thin as is practical. In conclusion: Use a random, evenly distributed, high entropy salt. Use a new salt whenever you create a new password or change a password. Store the salt along with the hashed password. Favor big salts (at least 10 bytes, preferably 16 or more). A salt does not turn a bad password into a good password. It just makes sure that the attacker will at least pay the dictionary attack price for each bad password he breaks. Usefull sources: stackoverflow.com: Non-random salt for password hashes Bruce Schneier: Practical Cryptography (book) Matasano Security: Enough with the Rainbow Tables usenix.org: Unix crypt used salt since 1976 owasp.org : Why add salt openwall.com : Salts Disclaimer: I'm not a security expert. (Although this answer was reviewed by Thomas Pornin ) If any of the security professionals out there find something wrong, please do comment or edit this wiki answer. As for what seems to be a good source for your random salt Also read: What is the most secure seed for random number generation? In the absence of dedicated, hardware based, random generators, the best way of obtaining random data is to ask the operating system (on Linux, this is called /dev/random or /dev/urandom [both have advantages and problems, choose your poison]; on Windows, call CryptGenRandom() ) If for some reason you do not have access to the above mentioned sources of random, in PHP you could use the following function: From the source of phpass v0.3
