[site]: stackoverflow
[post_id]: 5036087
[parent_id]: 5031640
[tags]: 
Okay, I'll bite... James has a good answer, so I'm going to try a different tact and give a more down-to-earth viewpoint. Broadly speaking, a class is something that can be instantiated . singleton objects (scala) traits (Scala) and interfaces (Scala) are also commonly considered to be classes. This makes sense, as singletons are still instantiated (via compiler-generated code) and an interface can be instantiated as part of a subclass. Which brings us to the second point. classes are the primary unit of design in most object-oriented languages (though not the prototype-based ones like javascript). Polymorphism and subclassing are both defined in terms of classes. classes also provide a namespace and visibility controls. types are a very different beast, every possible value that the system can express will have one or more types, and these can sometimes be equated to classes, for example: (Int) => String // both the type and class are Function1[Int,String] "hello world" // class and type are String You also get some interesting differences between Scala and Java: 7 // both the class and type are Int in Scala // in Java there's no class and the type is Integer.TYPE println("hello world") // the return type is Unit, of class Unit // Java has void as a type, but no corresponding class error("oops") // the type and class are both "Nothing" and the really fun types that aren't classes at all. For example, this.type always refers to the unique type of this . It's unique to a single instance and isn't even compatible with other instances of the same class. There are also abstract types and type parameters. For example: type A // 'A' is an undetermined abstract type // to be made concrete in a subclass class Seq[T] { ... } // T is a type, but not a class Seq is interesting as it's a class, but not a type. More accurately, it's a "type constructor"; something that will construct a valid type when supplied with the necessary type parameter. Another term for type constructors is "higher kinded types", I personally don't like this term, as "type constructor" encourages me to think in terms of supplying types like any other form of argument - a mental model that has served me well for Scala. "higher-kinded" rightly implies that Seq has a "kind", which is * => * , this notation states that Seq will take a single type and yield a single type (this is similar to curried notation for describing functions). By way of comparison, the kind of Map is * => * => * because it takes two type parameters.
