[site]: stackoverflow
[post_id]: 4266856
[parent_id]: 3726561
[tags]: 
Sure, it is possible. And easy. For example, lets say you want to test the following method, which calls static methods on a Database class (a static persistence facade) and instantiates SimpleEmail (from Apache Commons Email) directly: public void doBusinessOperationXyz(EntityX data) throws EmailException { List items = Database.find("select x from EntityX x where x.xyz=?", data.getXyz()); BigDecimal total = ...compute/obtain the value... data.setTotal(total); Database.persist(data); Email email = new SimpleEmail(); email.setSubject("Notification about processing of ..."); email.addTo(data.getCustomerEmail()); email.setMsg("...some notification message..."); email.send(); } This method can be tested in isolation from the Database and Email dependencies with the following unit test, using JMockit : @Test public void doBusinessOperationXyz() throws Exception { final EntityX data = new EntityX(5, "abc", "5453-1"); final List items = new ArrayList(); items.add(new EntityX(1, "AX5", "someone@somewhere.com")); new Expectations() { @Mocked final Database unused = null; @NonStrict SimpleEmail email; { Database.find(withSubstring("select"), (Object[]) any ); result = items; Database.persist(data); email.send(); times = 1; } }; new MyBusinessService().doBusinessOperationXyz(data); } Normally, it would be necessary to inject mock objects for the Database and Email dependencies, forcing a more complex solution. By mocking/stubbing static methods and constructors, we can keep a simple, natural, and elegant design instead.
