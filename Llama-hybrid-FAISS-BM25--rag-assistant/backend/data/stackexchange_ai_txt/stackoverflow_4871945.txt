[site]: stackoverflow
[post_id]: 4871945
[parent_id]: 3969190
[tags]: 
I'd like to provide one answer myself, although the answers of Hans Passant and others are describing the tradeoffs already pretty well. After recently fiddling with DLL base addresses in our application, I will here give my conclusion: I think that, unless you can prove otherwise, providing DLLs with a non-default Base Address is an exercise in futility. This includes rebasing my DLLs. For the DLLs I control , given the average application, each DLL will be loaded into memory only once anyway, so the load on the paging file should be minimal. (But see the comment of Michal Burr in another answer about Terminal Server environment.) If DLLs are provided with a fixed base address (without rebasing) it will actually increase address space fragmentation, as sooner or later these addresses won't match anymore. In our app we had given all DLLs a fixed base address (for other legacy reasons, and not because of address space fragmentation) without using rebase.exe and this significantly increased address space fragmentation for us because you really can't get this right manually. Rebasing (via rebase.exe) is not cheap . It is another step in the build process that has to be maintained and checked, so it has to have some benefit. A large application will always have some DLLs loaded where the base address does not match, because of some hook DLLs (AV) and because you don't rebase 3rd party DLLs (or at least I wouldn't). If you're using a RAM disk for the paging file , you might actually be better of if loaded DLLs get paged out :-) So to sum up, I think that rebasing isn't worth the trouble except for special cases like the system DLLs. I'd like to add a historical piece that I found on Old New Thing: How did Windows 95 rebase DLLs? -- When a DLL needed to be rebased, Windows 95 would merely make a note of the DLL's new base address, but wouldn't do much else. The real work happened when the pages of the DLL ultimately got swapped in. The raw page was swapped off the disk, then the fix-ups were applied on the fly to the raw page, thereby relocating it. The fixed-up page was then mapped into the process's address space and the program was allowed to continue. Looking at how this process is done ( read the whole thing ), I personally suspect that part of the "rebasing is evil" stance dates back to the olden days of Win9x and low memory conditions. Look, now there's a non-historical piece on Old New Thing : How important is it nowadays to ensure that all my DLLs have non-conflicting base addresses? Back in the day, one of the things you were exhorted to do was rebase your DLLs so that they all had nonoverlapping address ranges, thereby avoiding the cost of runtime relocation. Is this still important nowadays? ... In the presence of ASLR, rebasing your DLLs has no effect because ASLR is going to ignore your base address anyway and relocate the DLL into a location of its pseudo-random choosing. ... Conclusion: It doesn't hurt to rebase, just in case, but understand that the payoff will be extremely rare . Build your DLL with /DYNAMICBASE enabled (and with /HIGHENTROPYVA for good measure) and let ASLR do the work of ensuring that no base address collision occurs. That will cover pretty much all of the real-world scenarios. If you happen to fall into one of the very rare cases where ASLR is not available, then your program will still work. It just may run a little slower due to the relocation penalty. ... ASLR actually does a better job of avoiding collisions than manual rebasing, since ASLR can view the system as a whole, whereas manual rebasing requires you to know all the DLLs that are loaded into your process, and coordinating base addresses across multiple vendors is generally not possible.
