[site]: stackoverflow
[post_id]: 4226159
[parent_id]: 4222503
[tags]: 
I would recommend looking at grouping sets, rather than using unioning data together. Grouping sets (along with CUBE and ROLLUP ) are ways of aggregating data at multiple levels, which is what you seem to be doing. Using grouping sets will get the data you are looking for. In order to sort the data, you need to add additional columns to the order by clause. The grouping_id() function I have used returns a number (0 or 1) depending on whether it is a 'superaggregate' row or not for the given expression. These 'superaggregate' rows are the additional rows that relate to totals and subtotals. I am sorting on the data and on whether the column is a superaggregate or not. Think you should be able to do something like: SELECT COLUMN1 AS LASTNAME, COLUMN2 AS FIRSTNAME, case when grouping_id(column3, substr(column3,3,3)) = 3 then 'Total' when grouping_id(column3, substr(column3,3,3)) = 2 then substr(column3,3,3) ||' Total' else column3 end as location, SUM(COLUMN4) AS ACTIVITYNM1, SUM(COLUMN5) AS ACTIVITYNM2, SUM(COLUMN6) AS ACTIVITYNM3, SUM(COLUMN7) AS ACTIVITYNM4, SUM(COLUMN8) AS ACTIVITYNM5, SUM(COLUMN9) AS REG_HRS, SUM(COLUMN10) AS OT_HRS, SUM(COLUMN11) AS TOTAL_HRS, SUM(COLUMN12) AS PRODUCTIVITY_PERCENTAGE FROM TABLE(ACTY_COLUMN(V_STARTDATE,V_ENDDATE)) GROUP BY grouping sets ((), (substr(column3,3,3)), (COLUMN1,COLUMN2,COLUMN3, substr(column3,3,3))) order by grouping_id(substr(column3,3,3)), substr(column3,3,3) desc, grouping_id(column3, substr(column3,3,3)), column3 desc Will hopefully run quicker and do what you want. I might have made the order by clause more complicated than necessary but it should do what you need.
