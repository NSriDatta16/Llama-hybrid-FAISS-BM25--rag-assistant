[site]: stackoverflow
[post_id]: 2054119
[parent_id]: 2051938
[tags]: 
This is considerably uglier than I had initially imagined. I do have a partial solution, but I'm not sure it's worth the effort. The default pattern match treats whitespace as tokens, and I've not found any clean way to get around it. So I've done the opposite: decorate the input string with whitespace. This example has just a single level of indentation; you could imagine recursing the whitespace-addition to match your favorite indentation style. Here's the example (need to compile and run; the 2.7 REPL at least doesn't seem to like multi-line XML in case statements). object Test { import scala.xml._ def whiten(xml: Node,w:String): Node = { val bits = Node.unapplySeq(xml) val white = new Text(w) val ab = new scala.collection.mutable.ArrayBuffer[Node]() ab += white; bits.get._3.foreach {b => ab += b ; ab += white } new Elem( xml.prefix, xml.label, xml.attributes, xml.scope, ab: _* ); } val xml = 123 Works def main(args:Array[String]) { whiten(xml,""" """ // You must match the multiline whitespace to your case indentation! ) match { case 123 {x} => println(x) case _ => println("Fails") } } } Rather inelegant, but it does (marginally) achieve what you want.
