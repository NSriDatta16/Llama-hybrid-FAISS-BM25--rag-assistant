[site]: stackoverflow
[post_id]: 738411
[parent_id]: 738204
[tags]: 
on the pure virtual method called error: You should create a different question as it is in fact different than the other. The answer to this question is on the very last paragraph of my previous answer to your initial question: Do not call virtual functions from constructors or destructors class Base { public: Base() { f(); } virtual void f() = 0; }; class Derived : public Base { public: virtual void f() {} }; int main() { Derived d; // crashes with pure virtual method called } The problem in the code above is that the compiler will allow you to instantiate an object of type Derived (as it is not abstract: all virtual methods are implemented). The construction of a class starts with the construction of all the bases, in this case Base. The compiler will generate the virtual method table for type Base, where the entry for f() is 0 (not implemented in base). The compiler will execute the code in the constructor then. After the Base part has completely been constructed, construction of the Derived element part starts. The compiler will change the virtual table so that the entry for f() points to Derived::f() . If you try calling the method f() while still constructing Base, the entry in the virtual method table is still null and the application crashes.
