[site]: stackoverflow
[post_id]: 1696208
[parent_id]: 1690786
[tags]: 
The NDK is basically an implementation of the Java Native Interface for Android. It gives you GCC 4.2.1 (the full set of tools as far as I can tell) with target arm-eabi . Whether the resulting code would run on an iPhone or other devices I don't know; I've never coded for the iPhone. Here is what file has to say about something I built with the NDK so perhaps you can compare: libpuzzles.so: ELF 32-bit LSB shared object, ARM, version 1 (SYSV), dynamically linked, not stripped ( strip is included; I just haven't run it here.) Here is gcc -v or g++ -v (they're identical): Using built-in specs. Target: arm-eabi Configured with: /opt/digit/android/git/android-ndk/out/arm-eabi-4.2.1/toolchain/src/gcc-4.2.1/configure --prefix=/opt/digit/android/git/android-ndk/build/prebuilt/linux-x86/arm-eabi-4.2.1 --target=arm-eabi --host=x86 _ 64-unknown-linux-gnu --build=x86 _ 64-unknown-linux-gnu --enable-languages=c,c++ --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --with-abi=aapcs --disable-nls --prefix=/opt/digit/android/git/android-ndk/build/prebuilt/linux-x86/arm-eabi-4.2.1 --with-sysroot=/opt/digit/android/git/android-ndk/build/platforms/cupcake/arch-arm --program-transform-name=s,^,arm-eabi-, Thread model: single gcc version 4.2.1 Assuming the code will run, managing this at the API level is a separate and interesting issue. Android will only let you call native code via the JNI API. I'm not familiar with the iPhone approach, but I know it's not Java so I'd guess it's more like standard dynamic linking or dlopen() ? What I mean is, you would have to either make your JNI functions (e.g. Java_com_example_Foo_YourMethod(JNI_Env*, jobject, ...) cope with being called from something that isn't a JVM (have your iPhone code fake a JNI_Env for example?) or, much less horribly, start by providing a native API suitable for iPhone and then include a JNI wrapper, which non-JNI platforms can safely ignore, which I gather is a common approach for this sort of thing. Hope that helps.
