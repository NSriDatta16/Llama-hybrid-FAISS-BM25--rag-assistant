[site]: stackoverflow
[post_id]: 4220894
[parent_id]: 4220815
[tags]: 
Best practice: [foo release]; // ensures that memory is released foo = nil; // ensures that there is no dangling pointer to released memory Other notes: When you assign to a property declared to retain, // in your .h @property (retain) MyObject *foo; // in your .m self.foo = bar; // bar is retained; whatever foo previously pointed at is released it will release what it was previously pointing at and retain the new object being assigned. So, you can use: self.foo = nil; and it will release whatever foo was pointing at. However, if your property was not declared to have retain storage semantics, this will not implicitly release whatever foo was pointing at. Also, as Ryan pointed out, a property can be overridden to have side effects. For this reason, it is best to follow the pattern of always using: [foo release]; To ensure that you don't have a dangling pointer to released memory, you can follow this up with: foo = nil; If you are not using properties with retain semantics, you need to release whatever was stored in the variable: [foo release]; EDIT: Also see the following answer to another question that explains this: iPhone - dealloc - Release vs. nil
