[site]: datascience
[post_id]: 87271
[parent_id]: 44535
[tags]: 
The arguments for input shape for MNIST are in the wrong order. It should be input_shape=(28, 28, 1) Additionally, sometimes it makes sense to not write code in functions until the code is working. It is more difficult to debug code in functions. I have create a working version of your code. It displays a progress bar so you should be able to see how long the code estimates it will take to finish. import numpy as np from tensorflow import keras from tensorflow.keras import Sequential from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense # Model / data parameters num_classes = 10 input_shape = (28, 28, 1) # the data, split between train and test sets (X_train, y_train), (X_test, y_test) = keras.datasets.mnist.load_data() # Scale images to the [0, 1] range X_train = X_train.astype("float32") / 255 X_test = X_test.astype("float32") / 255 # Make sure images have shape (28, 28, 1) X_train = np.expand_dims(X_train, -1) X_test = np.expand_dims(X_test, -1) print("x_train shape:", X_train.shape) print(X_train.shape[0], "train samples") print(X_test.shape[0], "test samples") # convert class vectors to binary class matrices y_train = keras.utils.to_categorical(y_train, num_classes) y_test = keras.utils.to_categorical(y_test, num_classes) def baseline_model(): "Define a simple CNN model" # create model model = Sequential() model.add(Conv2D(30, (5, 5), input_shape=(28, 28, 1), activation='relu')) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Conv2D(15, (3, 3), activation='relu')) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Dropout(0.2)) model.add(Flatten()) model.add(Dense(128, activation='relu')) model.add(Dense(50, activation='relu')) model.add(Dense(num_classes, activation='softmax')) # Compile model model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy']) return model # Build the model model = baseline_model() # Fit the model model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=500, batch_size=200) # Final evaluation of the model scores = model.evaluate(X_test, y_test, verbose=0)
