[site]: stackoverflow
[post_id]: 5060947
[parent_id]: 5060517
[tags]: 
Are you using the cache api? It sounds like it. This post , which pointed me to these slides helped me create a nice generational caching system which let me create the hierarchy I wanted. In short, you store a generation key (such as group ) in your cache and incorporate the value stored into your key creation function so that you can invalidate a whole set of keys at once. With this basic concept you could create highly complex hierarchies or just a simple group system. For example: class Cache(object): def generate_cache_key(self, key, group=None): """ Generate a cache key relating them via an outside source (group) Generates key such as 'group-1:KEY-your-key-here' Note: consider this pseudo code and definitely incomplete code. """ key_fragments = [('key', key)] if group: key_fragments.append((group, cache.get(group, '1'))) combined_key = ":".join(['%s-%s' % (name, value) for name, value in key_fragments) hashed_key = md5(combined_key).hexdigest() return hashed_key def increment_group(self, group): """ Invalidate an entire group """ cache.incr(group) def set(self, key, value, group=None): key = self.generate_cache_key(key, group) cache.set(key, value) def get(self, key, group=None): key = self.generate_cache_key(key, group) return cache.get(key) # example >>> cache = Cache() >>> cache.set('key', 'value', 'somehow_related') >>> cache.set('key2', 'value2', 'somehow_related') >>> cache.increment_group('somehow_related') >>> cache.get('key') # both invalidated >>> cache.get('key2') # both invalidated
