[site]: stackoverflow
[post_id]: 3830910
[parent_id]: 3827549
[tags]: 
I think it was Hugh Darwen who coined the terms 'distributed key' and 'distributed foreign keys', where a single referenced key value exists in exactly one of multiple referencing relvars (tables); this would require a related concept of 'multple assignment' in order to atomically insert to both the referenced and referencing relvars. While this could in theory be achieved in SQL-92 using deferrable schema-level ASSERTION s (or perhaps CHECK constraints that support subqueries), it's rather a clunky process, is procedural (rather than set-based) and there isn't a SQL product that has ever support this functionality (or ever will, I susepct). The best we can do with available SQL products is to use a compound key (entity_ID, entity_type) with a CHECK constraint on the entity_type in referencing tables to ensure there is no more than one referencing key value (note this is not the same as 'exactly one referencing key value') e.g. CREATE TABLE LegalPersons ( person_ID INTEGER IDENTITY NOT NULL UNIQUE, person_type VARCHAR(14) NOT NULL CHECK (person_type IN ('Company', 'Natural Person')), UNIQUE (person_type, person_ID) ); CREATE TABLE Companies ( person_ID INTEGER NOT NULL UNIQUE, person_type VARCHAR(14) NOT NULL CHECK (person_type = 'Company'), FOREIGN KEY (person_type, person_ID) REFERENCES LegalPersons (person_type, person_ID), companies_house_registered_number VARCHAR(8) NOT NULL UNIQUE -- other company columns and constraints here ); CREATE TABLE NaturalPersons ( person_ID INTEGER NOT NULL UNIQUE, person_type VARCHAR(14) NOT NULL CHECK (person_type = 'Natural Person'), FOREIGN KEY (person_type, person_ID) REFERENCES LegalPersons (person_type, person_ID) -- natural person columns and constraints here ); This superclass-subclass pattern is very common in SQL. Ideally, a table name should reflect the nature of the set as a whole. You many need to think beyond a compound of other sets' names; perhaps ask a expert in the particular field of business e.g. an accountant may use the term 'payroll' rather than 'EmployeesSalaries'. Another ideal is for a column's name to remain the same throughout the schema but with a subclassing approach you often need to qualify them (and this bothers me!) e.g. CREATE TABLE CompanyAgents ( company_person_ID INTEGER NOT NULL UNIQUE, company_person_type VARCHAR(14) NOT NULL CHECK (company_person_type = 'Company'), FOREIGN KEY (company_person_type, company_person_ID) REFERENCES LegalPersons (person_type, person_ID), agent_person_ID INTEGER NOT NULL, agent_person_type VARCHAR(14) NOT NULL, FOREIGN KEY (agent_person_type, agent_person_ID) REFERENCES LegalPersons (person_type, person_ID), CHECK (company_person_ID <> agent_person_ID) ); Note I would have used a single column key for agent_person_ID e.g. agent_person_ID INTEGER NOT NULL REFERENCES LegalPersons (person_ID) because there is no restriction on entity type. In principle I feel better about retaining the two-column compound key for all references throughout the schema and I find in practice as often as not I need to now the entity type anyhow so this SQL DDL is saving a JOIN in SQL DML :)
