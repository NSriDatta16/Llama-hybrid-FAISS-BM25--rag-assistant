[site]: stackoverflow
[post_id]: 2781889
[parent_id]: 2781816
[tags]: 
Computer memory is organized into "words", a sequence of bytes of a given size (often a 2-power). Memory is usually read and written in these units which are often compatible with the size of the registers and the CPU's native support for arithmetic operators. This is typically the source of the "bit rating" of a machine (e.g., a 32 bit CPU, a 64 bit CPU, the old 8-bit video game consoles). Of course, you often need a different size from the native word size. Machine instructions and smart coding allows you to break these words into smaller units by applying various bit-level logical operators, or to combine them into larger units by "combining" multiple words. For instance, if you have a 32 bit word, you could AND a word against a pattern like 0xff0000ff to get the first and last byte in that word, or 0x0000ffff to get just the contents of the second 16-bit int. In the case of bools, it is common to use memory as a bitmap. You can essentially place X "bools" in an X-bit word and access a specific bit by ANDing or ORing against a "mask" that refers to that bool. E.g., 1 for the first bit, 2 for the second bit, 4 for the fourth bit, etc. In most machines, it is inadvisable to split a smaller data type across two words (this is called alighment). When you work with a higher level language like C or C++, you usually don't have to worry about all this memory organization stuff. If you allocate an int, a short, and a double, the compiler will generate the appropriate machine code. You only do this directly when you want to smartly organize things in dynamically allocated memory, for example when manually implementing a bitmap. When working with larger units than the native word size, the compiler will again handle most things for you. For instance, on a 32-bit machine you can easily handle 32-bit int operations, but to run the same code on an 8-bit machine or a 16-bit machine the compiler would generate code to do the smaller operations and combine them to get the results. This is partially why it is generally considered advisable to run a 64-bit OS on a 64-bit machine, since otherwise you might be performing multiple instructions and read/writes to simulate 64-bit on a 32-bit OS rather than a single instruction or memory access.
