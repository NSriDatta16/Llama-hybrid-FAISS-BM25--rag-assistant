[site]: stackoverflow
[post_id]: 3465788
[parent_id]: 3465226
[tags]: 
Expanding on Calvin1602's answer: ftransform supposes matrices, which you do not use. gl_Vertex ought to be fine here, considering the final result is supposed to be the [-1:1]^3 cube, and his data is in that interval. Now, it should be gl_VertexAttrib[0] if you really want to go all GL3.1, but gl_Vertex and gl_VertexAttrib[0] alias (see below). As for the enable. You use vertex attrib 0, so you need: glEnableVertexAttribArray(0) An advice on figuring stuff out in general: don't clear to black, it makes life more difficult to figure out if something black is drawn or if nothing is drawn (use glClearColor to change that). On the pedantic side, your glShaderSource calls look suspicious, as you cast pointers around. I'd clean it up with glShaderSource(fs, 1, fragment_shader_code, NULL); The reason why it currently work with &fragment_shader_code is interesting , but here, I don't see why you don't simplify. == edit to add == Gah, not sure what I was thinking with gl_VertexAttrib. It's been a while I did not look at this, and I just made my own feature... The standard way to provide non-built-in attributes is actually non-trivial until GL4.1. // glsl attribute vec4 myinput; gl_Position = myinput; // C-code, rely on linker for location glLinkProgram(prog); GLint location = glGetAttribLocation(prog, "myinput"); glEnableVertexAttribArray(location, ...) // alternative C-code, specify location glBindAttribLocation(prog, 0, "myinput"); glLinkProgram(prog); glEnableVertexAttribArray(0, ...) GL4.1 finally supports specifying the location directly in the shader. // glsl 4.10 layout (location=0) in vec4 myinput;
