[site]: stackoverflow
[post_id]: 991717
[parent_id]: 966930
[tags]: 
this is how I used ViewModel with ComboBoxes, the DataContext is the ViewModel, not the underlying entity (List ). ViewModel (Person is a Simple class with Name and Age): public class PeopleViewModel : INotifyPropertyChanged { private List _peopleList; private Person _selectedPerson; public PeopleViewModel() { // initialize with sample data _peopleList = getPeopleList(); } // gets sample data private List getPeopleList() { var result = new List (); for (int i = 0; i PeopleList { get { return _peopleList; } } public Person SelectedPerson { get { return _selectedPerson; } set { if (_selectedPerson == value) return; _selectedPerson = value; // required so that View know about changes OnPropertyChanged("SelectedPerson"); } } private void OnPropertyChanged(string propertyName) { if (PropertyChanged != null) PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); } // WPF will listen on this event for changes public event PropertyChangedEventHandler PropertyChanged; } XAML for ComboBox: And in code behind I can do: public Window2() { InitializeComponent(); vm = new PeopleViewModel(); // we are listening on changes of ViewModel, not ComboBox vm.PropertyChanged += new PropertyChangedEventHandler(vm_PropertyChanged); this.DataContext = vm; } void vm_PropertyChanged(object sender, PropertyChangedEventArgs e) { if (e.PropertyName == "SelectedPerson") { MessageBox.Show(vm.SelectedPerson.Age.ToString()); } } // button1_Click should be probably replaced by Command private void button1_Click(object sender, RoutedEventArgs e) { // sample showing that GUI is updated when ViewModel changes vm.SelectedPerson = vm.PeopleList[2]; } Hope this helps, I'm quite new to WPF, I'd like to hear any feedback if this is the right way to use MVVM, I think it's quite elegant since you only deal with the ViewModel and Model in code, and the View can be replaced.
