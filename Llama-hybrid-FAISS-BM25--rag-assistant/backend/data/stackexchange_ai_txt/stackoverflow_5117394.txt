[site]: stackoverflow
[post_id]: 5117394
[parent_id]: 5117338
[tags]: 
Build the application as a Win32 application (not a console application), and examine the parameters to decide whether or not to use the console window. The following code is based on this . To use a console; create a class called CConsoleAttacher. Use it as follows, basically if there are arguments then open a console which will connect to the CMD window if you started from that. Obviously with Win32 applications when you launch the main windows it detaches from the console so this needs to be handled early on before creating app windows (which is what you want to do anyway...) CConsoleAttacher ca; if (ca.hasArguments()) { ca.ConnectToConsole(); } printf ("Test output \n"); Create a class called CConsoleAttacher. CConsoleAttacher.cpp #include "StdAfx.h" #include #include #include #include #include #include #include "ConsoleAttacher.h" #ifndef _USE_OLD_IOSTREAMS using namespace std; #endif static const WORD MAX_CONSOLE_LINES = 500; CConsoleAttacher::CConsoleAttacher(void) { argv = CommandLineToArgvW(GetCommandLineW(), &argc); } CConsoleAttacher::~CConsoleAttacher(void) { LocalFree(argv); } int CConsoleAttacher::getArgumentCount(void) { return argc; } CString CConsoleAttacher::getArgument(int id) { CString arg ; if (id 1; } void CConsoleAttacher::ConnectToConsole(void) { int hConHandle; HANDLE lStdHandle; CONSOLE_SCREEN_BUFFER_INFO coninfo; FILE *fp; // allocate a console for this app if (!AttachConsole(ATTACH_PARENT_PROCESS)) { if (!AllocConsole()) return; } // set the screen buffer to be big enough to let us scroll text GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE),&coninfo); coninfo.dwSize.Y = MAX_CONSOLE_LINES; SetConsoleScreenBufferSize(GetStdHandle(STD_OUTPUT_HANDLE),coninfo.dwSize); // redirect unbuffered STDOUT to the console lStdHandle = GetStdHandle(STD_OUTPUT_HANDLE); hConHandle = _open_osfhandle((intptr_t)lStdHandle, _O_TEXT); fp = _fdopen( hConHandle, "w" ); *stdout = *fp; setvbuf( stdout, NULL, _IONBF, 0 ); // redirect unbuffered STDIN to the console lStdHandle = GetStdHandle(STD_INPUT_HANDLE); hConHandle = _open_osfhandle((intptr_t)lStdHandle, _O_TEXT); fp = _fdopen( hConHandle, "r" ); *stdin = *fp; setvbuf( stdin, NULL, _IONBF, 0 ); // redirect unbuffered STDERR to the console lStdHandle = GetStdHandle(STD_ERROR_HANDLE); hConHandle = _open_osfhandle((intptr_t)lStdHandle, _O_TEXT); fp = _fdopen( hConHandle, "w" ); *stderr = *fp; setvbuf( stderr, NULL, _IONBF, 0 ); // make cout, wcout, cin, wcin, wcerr, cerr, wclog and clog // point to console as well ios::sync_with_stdio(); } CConsoleAttacher.h #pragma once class CConsoleAttacher { private: int argc; wchar_t** argv; public: CConsoleAttacher(void); ~CConsoleAttacher(void); int getArgumentCount(void); CString CConsoleAttacher::getArgument(int id); void ConnectToConsole(void); bool hasArguments(void); };
