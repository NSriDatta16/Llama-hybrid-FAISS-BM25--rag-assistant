[site]: crossvalidated
[post_id]: 194816
[parent_id]: 59895
[tags]: 
This implementation of the Python package rpy2 worked for me: import numpy as np from rpy2.robjects.packages import importr import rpy2.robjects as robjects r = robjects.r #allows access to r object with r. bcp = importr('bcp') #import bayesian change point package in python values = bcp.bcp( r.c( r.rnorm(50) , r.rnorm(50,5,1), r.rnorm(50) ) ) #use bcp function on vector posterior_means = np.array(values[5]).flatten() posterior_probability = np.array(values[7]).flatten() Then, you can plot the posterior means and posterior probability against the original vector. See the bcp function example in R for more detailed information about this example. Also, hard indexing values with a number (i.e. values[5]) is not ideal, but I was having a hard time using the rx and rx2 extractor. So if anyone can enlighten me on a less hacky method of extraction, I'd love to know!
