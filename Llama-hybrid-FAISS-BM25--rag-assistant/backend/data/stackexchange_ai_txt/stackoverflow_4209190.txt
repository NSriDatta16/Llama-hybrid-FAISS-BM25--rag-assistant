[site]: stackoverflow
[post_id]: 4209190
[parent_id]: 4188744
[tags]: 
Right - that makes perfect sense - this is indeed what your code does. What you need to add is the initial value where you started your drag as a relative rotation -- or track your last rotation. A very elaborate way is shown below - but this should help get the point across. @interface UntitledViewController : UIViewController { CGPoint firstLoc; UILabel * fred; double angle; } @property (assign) CGPoint firstLoc; @property (retain) UILabel * fred; @implementation UntitledViewController @synthesize fred,firstLoc; - (void)viewDidLoad { [super viewDidLoad]; self.fred = [[UILabel alloc] initWithFrame:CGRectMake(100,100,100,100)]; fred.text = @"Fred!"; fred.textAlignment = UITextAlignmentCenter; [self.view addSubview:fred]; angle = 0; // we aint have rotated just yet... }; // make sure we get them drag events. - (BOOL)isFirstResponder { return YES; } -(void)handleObject:(NSSet *)touches withEvent:(UIEvent *)event isLast:(BOOL)lst { UITouch *touch =[[[event allTouches] allObjects] lastObject]; CGPoint curLoc = [touch locationInView:self.view]; float fromAngle = atan2( firstLoc.y-fred.center.y, firstLoc.x-fred.center.x ); float toAngle = atan2( curLoc.y-fred.center.y, curLoc.x-fred.center.x ); // So the angle to rotate to is relative to our current angle and the // angle through which our finger moved (to-from) float newAngle = angle + (toAngle - fromAngle); CGAffineTransform cgaRotate = CGAffineTransformMakeRotation(newAngle); fred.transform = cgaRotate; // we only 'save' the current angle when we're done with the drag. // if (lst) angle = newAngle; } -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { UITouch *touch =[[[event allTouches] allObjects] lastObject]; // capture where we started - so we can later work out the // rotation relative to this point. // firstLoc = [touch locationInView:self.view]; }; -(void) touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { [self handleObject:touches withEvent:event isLast:NO]; }; -(void) touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { [self handleObject:touches withEvent:event isLast:YES]; } Obviously you can do this a lot more elegant - and above misses a bit of 0 .. 2xPI capping you need.
