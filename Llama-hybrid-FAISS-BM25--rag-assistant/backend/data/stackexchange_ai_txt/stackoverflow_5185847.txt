[site]: stackoverflow
[post_id]: 5185847
[parent_id]: 5174768
[tags]: 
A simple case of SQL injection works like this (in pseudocode): name = form_params["name"] year = 2011 sql = "INSERT INTO Students (name, year) " + "VALUES ('" + name + "', " + year + ");" database_handle.query(sql) year is supplied by you, the programmer, so it's not tainted, and can be embedded in the query in any way you find suitable; in this case — as an unquoted number. But name is supplied by the user and so can be anything. Along comes Bobby Tables and inputs this value: name = "Robert'); DROP TABLE Students; -- " And the query becomes INSERT INTO Students (name, year) VALUES ('Robert'); DROP TABLE Students; -- ', 2011); That substitution turned your one query into two. The first one gives an error because of the mismatched row count, but that doesn't matter, because the database is able to unambiguously find and run the second query. The attacker can work around the error by fiddling with the input anyway. The -- is a comment so that the rest of the input is ignored. Note how data suddenly became code — a typical sign of a security problem. What the suggested replacement does is this: name = form_params["name"].regex_replace("'", "\\\\'") How this works is confusing, hence my earlier comment. The string literal "\\\\'" represents the string \\' . The regex_replace function interprets that as the string \' . The database then sees ... VALUES ('Robert\'); DROP TABLE Students; -- ', 2011); and interprets that correctly as a quite unusual name. Among other problems this approach is very fragile. If the strings you use in your language don't substitute \\ as \ , if your string substitution function doesn't interpret \\ as \ (if it's not a regex function or it uses $1 instead of \1 for backreferences) you could end up with an even number of slashes like ... VALUES ('Robert\\'); DROP TABLE Students; -- ', 2011); and no SQL injection will be prevented. The solution is not to check what the language and library does with all possible input you can think of, or to anticipate what it might do in a future version, but rather to use the facilities provided by the database. These usually come in two flavours: database-aware escaping, which does exactly the right escaping of any data because the client library matches the server and it knows what the character encoding of the database you are querying is: sql = "... '" + database_handle.escape(name) + "' ..." out-of-band data submission (usually with prepared statments), so the data isn't even in the same string as the code: sql = "... VALUES (:n, :y);" database_handle.query(sql, n = name, y = year)
