[site]: stackoverflow
[post_id]: 730521
[parent_id]: 
[tags]: 
Really force file sync/flush in Java

How can data written to a file really be flushed/synced with the block device by Java. I tried this code with NIO: FileOutputStream s = new FileOutputStream(filename) Channel c = s.getChannel() while(xyz) c.write(buffer) c.force(true) s.getFD().sync() c.close() I supposed that c.force(true) togehter with s.getFD().sync() should be sufficient because the doc for force states Forces any updates to this channel's file to be written to the storage device that contains it. If this channel's file resides on a local storage device then when this method returns it is guaranteed that all changes made to the file since this channel was created, or since this method was last invoked, will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash. The documentation to sync states: Force all system buffers to synchronize with the underlying device. This method returns after all modified data and attributes of this FileDescriptor have been written to the relevant device(s). In particular, if this FileDescriptor refers to a physical storage medium, such as a file in a file system, sync will not return until all in-memory modified copies of buffers associated with this FileDesecriptor have been written to the physical medium. sync is meant to be used by code that requires physical storage (such as a file) to be in a known state. These two calls should be sufficient. Is it? I guess they aren't. Background: I do a small performance comparison (2 GB, sequential write) using C/Java and the Java version is twice as fast as the C version and probably faster than the hardware (120 MB/s on a single HD). I also tried to execute the command line tool sync with Runtime.getRuntime().exec("sync") but that hasn't changed the behavior. The C code resulting in 70 MB/s is (using the low level APIs (open,write,close) doesn't change much): FILE* fp = fopen(filename, "w"); while(xyz) { fwrite(buffer, 1, BLOCK_SIZE, fp); } fflush(fp); fclose(fp); sync(); Without the final call to sync; I got unrealistical values (over 1 GB aka main memory performance). Why is there such a big difference between C and Java? There are two possiblities: I doesn't sync the data correctly in Java or the C code is suboptimal for some reason. Update: I have done strace runs with "strace -cfT cmd". Here are the results: C (Low-Level API): MB/s 67.389782 % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 87.21 0.200012 200012 1 fdatasync 11.05 0.025345 1 32772 write 1.74 0.004000 4000 1 sync C (High-Level API): MB/s 61.796458 % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 73.19 0.144009 144009 1 sync 26.81 0.052739 1 65539 write Java (1.6 SUN JRE, java.io API): MB/s 128.6755466197537 % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 80.07 105.387609 3215 32776 write 2.58 3.390060 3201 1059 read 0.62 0.815251 815251 1 fsync Java (1.6 SUN JRE, java.nio API): MB/s 127.45830221558376 5.52 0.980061 490031 2 fsync 1.60 0.284752 9 32774 write 0.00 0.000000 0 80 close The time values seem to be system time only and are therefore pretty meaningless. Update 2: I switched to another server, rebooted, and I use a fresh formatted ext3. Now I get only 4% differences between Java and C. I simply don't know what went wrong. Sometimes things are strange. I should have tried the measurement with another system before writing this question. Sorry. Update 3: To summarize the answers: Use c.force(true) followed by s.getFD().sync() for Java NIO and s.flush() and s.getFD().sync() for Java's stream API. For the High-Level API in C don't forget to sync. A fflush submitted the data to the OS, but doesn't bring your data to the block device. Use strace to analyze the syscalls done by a command Cross check your results before posting a question. Update 4: Please note the following follow-up question .
