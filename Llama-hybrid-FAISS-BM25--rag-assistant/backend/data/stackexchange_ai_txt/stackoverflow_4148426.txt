[site]: stackoverflow
[post_id]: 4148426
[parent_id]: 4148341
[tags]: 
return(theVector); This already moves implicitly due to a special language rule, because theVector is a local object. See section 12.8 paragraphs 34 and 35: When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object , even if the copy/move constructor and/or destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies): â€” in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object with the same cv-unqualified type as the function return type , the copy/move operation can be omitted by constructing the automatic object directly into the function's return value [...] When the criteria for elision of a copy operation are met and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue . Note that you must return a std::vector ( by value ), not a std::vector && ( by reference ). But why the parenthesis? return is not a function: return theVector;
