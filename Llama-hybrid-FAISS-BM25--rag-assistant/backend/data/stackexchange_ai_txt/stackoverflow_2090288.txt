[site]: stackoverflow
[post_id]: 2090288
[parent_id]: 
[tags]: 
Are there any optimisations for retrieving of return value in Delphi?

I'm trying to find an elegant way to access the fields of some objects in some other part of my program through the use of a record that stores a byte and accesses fields of another record through the use of functions with the same name as the record's fields. TAilmentP = Record // actually a number but acts like a pointer private Ordinal: Byte; public function Name: String; inline; function Description: String; inline; class operator Implicit (const Number: Byte): TAilmentP; inline; End; TSkill = Class Name: String; Power: Word; Ailment: TAilmentP; End; class operator TAilmentP.Implicit (const Number: Byte): TAilmentP; begin Result.Ordinal := Number; ShowMessage (IntToStr (Integer (@Result))); // for release builds end; function StrToAilment (const S: String): TAilmentP; // inside same unit var i: Byte; begin for i := 0 to Length (Ailments) - 1 do if Ailments [i].Name = S then begin ShowMessage (IntToStr (Integer (@Result))); // for release builds Result := i; // uses the Implicit operator Exit; end; raise Exception.Create ('"' + S + '" is not a valid Ailment"'); end; Now, I was trying to make my life easier by overloading the conversion operator so that when I try to assign a byte to a TAilmentP object, it assigns that to the Ordinal field. However, as I've checked, it seems that this attempt is actually costly in terms of performance since any call to the implicit "operator" will create a new TAilmentP object for the return value, do its business, and then return the value and make a byte-wise copy back into the object that called it, as the addresses differ. My code calls this method quite a lot, to be honest, and it seems like this is slower than just assigning my value directly to the Ordinal field of my object. Is there any way to make my program actually assign the value directly to my field through the use of ANY method/function? Even inlining doesn't seem to work. Is there a way to return a reference to a (record) variable, rather than an object itself? Finally (and sorry for being off topic a bit), why is operator overloading done through static functions? Wouldn't making them instance methods make it faster since you can access object fields without dereferencing them? This would really come in handy here and other parts of my code. [EDIT] This is the assembler code for the Implicit operator with all optimizations on and no debugging features (not even "Debug Information" for breakpoints). add al, [eax] /* function entry */ push ecx mov [esp], al /* copies Byte parameter to memory */ mov eax, [esp] /* copies stored Byte back to register; function exit */ pop edx ret What's even funnier is that the next function has a mov eax, eax instruction at start-up. Now that looks really useful. :P Oh yeah, and my Implicit operator didn't get inlined either. I'm pretty much convinced [esp] is the Result variable, as it has a different address than what I'm assigning to. With optimizations off, [esp] is replaced with [ebp-$01] (what I assigning to) and [ebp-$02] (the Byte parameter), one more instruction is added to move [ebp-$02] into AL (which then puts it in [ebp-$01]) and the redundant mov instruction is still there with [epb-$02]. Am I doing something wrong, or does Delphi not have return-value optimizations?
