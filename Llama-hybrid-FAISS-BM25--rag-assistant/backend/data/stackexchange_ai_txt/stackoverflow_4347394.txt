[site]: stackoverflow
[post_id]: 4347394
[parent_id]: 4344987
[tags]: 
As YOUR ARGUMENT IS VALID suggested, you're state, at that point of your code, is not a dict. Answering to your comments, now. The state of your gen_server is set up in the init function, where you return: {ok, State}. Every time your gen_server receive a message, an handle_call or an handle_cast are called (depending if the call is synchronous or asynchronous). Inside these functions, the State that you set up during the init phase can be updated and transformed into ANYTHING. You can't rely on the assumption that the "type" of your initial state is the same during the whole execution of your server. In other words, if you do something like: init(_Args) -> {ok, dict:new()}. handle_call(_Request, _From, State) -> {ok, completely_new_state}. you've just "converted" your state from a dict into an atom and that (the atom) is what you will get in subsequent calls. For this kind of errors, the Erlang tracing tool dbg is quite helpful, allowing you to see how functions are called and which results are returned. Have a look to this short tutorial to learn how to use it: http://aloiroberto.wordpress.com/2009/02/23/tracing-erlang-functions/ UPDATE: What you should do: init(_Args) -> {ok, dict:new()}. handle_call(_Request, _From, State) -> NewState = edit_dict(State), {ok, NewState}. Where the edit_dict function is a function which takes a dict and returns an updated dict.
