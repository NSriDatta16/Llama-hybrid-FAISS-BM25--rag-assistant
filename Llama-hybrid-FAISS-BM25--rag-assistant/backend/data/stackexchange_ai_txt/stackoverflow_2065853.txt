[site]: stackoverflow
[post_id]: 2065853
[parent_id]: 2065763
[tags]: 
$context/../@attname does not make too much sense. You can't go "up" here, as this would bring you "outside of" $context . If the node-set contains something like this (a single node) then: $context/@attname If it is like this (a list of nodes): then: $context[1]/@attname All of this does not work if the variable contains a result tree fragment (RTF). In this case, you need to employ an extension function called node-set() . Most XSLT processors provide this function. EDIT: Your variable holds a union of the current node and a naked attribute node from its parent: The result of a union will always be in document order, so even though you selected the attribute after the context node in the XPath, in the resulting node set it will come before - the parent of the context node is before the context node in document order. You need $context[1] to grab the attribute node, and $context[2] to grab the other node. I must say that this is some strange and probably unnecessary complicated use of variables. I'm sure there is a way to do this in a less painful fashion. For example you could do and then use $context/../@res in the called template. That would be a lot more straight-forward than what you are trying now. Also, if the you show here is part of an , you can drop that param entirely. When a template is called (instead of applied), then the context node does not change, passing it in is redundant.
