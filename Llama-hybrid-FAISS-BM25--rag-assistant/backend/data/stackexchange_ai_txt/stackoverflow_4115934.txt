[site]: stackoverflow
[post_id]: 4115934
[parent_id]: 4103773
[tags]: 
I've thought of another—slightly unusual, but very effective—way to do this that doesn't require decorator functions or classes. Instead it just uses a mutable keyword argument, which ought to work in most versions of Python. Most of the time these are something to be avoided since normally you wouldn't want a default argument value to change from call-to-call—but that ability can be leveraged in this case and used as a cheap storage mechanism. Here's how that would work: def my_function1(_has_run=[]): if _has_run: return print("my_function1 doing stuff") _has_run.append(1) def my_function2(_has_run=[]): if _has_run: return print("my_function2 doing some other stuff") _has_run.append(1) for i in range(10): my_function1() my_function2() print('----') my_function1(_has_run=[]) # Force it to run. Output: my_function1 doing stuff my_function2 doing some other stuff ---- my_function1 doing stuff This could be simplified a little further by doing what @gnibbler suggested in his answer and using an iterator (which were introduced in Python 2.2): from itertools import count def my_function3(_count=count()): if next(_count): return print("my_function3 doing something") for i in range(10): my_function3() print('----') my_function3(_count=count()) # Force it to run. Output: my_function3 doing something ---- my_function3 doing something
