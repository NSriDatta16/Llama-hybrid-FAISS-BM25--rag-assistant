[site]: stackoverflow
[post_id]: 4768073
[parent_id]: 4765525
[tags]: 
This is a FAQ that pops up on the MEF forum every now and then. (I'm sure that there are several better threads that include an answer, but I'm unable to find one immediately). MEF does not support inspecting the part type of a lazy import (without instantiating that part) out of the box. This is probably because of two elements in its design philosophy: MEF encourages loose coupling. You should specify and use imports based on their contract. Relying on the actual class type of an import would prevent you from changing the composition in the future. MEF allows for lazy loading of types. Suppose there would be a Lazy.PartType property which you can use to inspect he actual type of the part. This would force the part type and the containing assembly to be loaded. Then you decide based on the PartType that you don't want to instantiate that particular part, and the assembly load was for nothing. (As far as I can tell, currently MEF does not yet exploit the second design feature out of the box. AssemblyCatalog will inspect all types immediately when AssemblyCatalog.Parts is called anyway. But there is a sample in the MEF sources that shows how to cache information about assemblies to delay or avoid assembly loads.) So instead of relying on the exact type of the part, you should add some metadata that you can use to do the selection of an import.
