[site]: stackoverflow
[post_id]: 3727433
[parent_id]: 
[tags]: 
Activator.CreateInstance: Dynamic Instantiation of Classes

I am designing a loosely-coupled structure. I want to call classes from different assemblies/namespaces via a code which is represented by a String . My design is, each of client's business rules is on different assemblies and not dependent on each other (ONE client is to ONE DLL ratio) so that when I made an update on business rules of 1 client, it would not affect the others. My attention now is on using Factory Design and using Activator.CreateInstance() Method. This is the project setup (2+n DLL's) namespace Foundation; // where the interfaces/abstract resides namespace Factory; // has dependency on Foundation assembly namespace Client1; // client1's DLL, no dependency namespace Client2; // client2's DLL, no dependency The UI // only referenced to the Foundation and Factory not the Clients The actual code namespace Foundation { public interface IBusinessRules { string GetBusinessRule(); } } namespace Client1 //DLL for client 1 { public class BusinessRules : Foundation.IBusinessRules { public string GetBusinessRule() { return "Client1 Business Rule"; } } } namespace Client2 //DLL for client 2 { public class BusinessRules : Foundation.IBusinessRules { public string GetBusinessRule() { return "Client2 Business Rule"; } } } namespace Factory { public static class Invoker where T: Foundation.IBusinessRules { public static T FetchInstance(string clientCode) { return (T)Activator.CreateInstance(Type.GetType(clientCode)); } } } //sample implementation that generates unhandled Exception using Factory; using Foundation; static void Main(string[] args) { //the parameter is maintained in the database IBusinessRules objClient1 = Invoker .FetchInstance("Client1"); //should call Client1.BusinessRules method Console.WriteLine(objClient.GetBusinessRule()); Console.Read(); objClient = Invoker .FetchInstance("Client2"); //should call Client2.BusinessRules method Console.WriteLine(objClient.GetBusinessRule()); Console.Read(); } Any idea why my sample doesn't work? And any suggestion to improve the design? Thanks in advance. How about using Expression.Lambda anyone?
