[site]: stackoverflow
[post_id]: 4711419
[parent_id]: 4683468
[tags]: 
As others said, there is no builtin placeholder for the assemblyname and a couple of ways to achieve it anyhow. Another one is to register your own handler/converter with the Log4Net framework. Basically, you do the same that the log4net.Util.PatternString class does internally (and you might check the relevant source code for a more complete "example" than the fragements given below). Example: Then the code: using log4net.Core; public sealed class MyExpressionHandler : IOptionHandler { private string m_str; public MyExpressionHandler(string str) { m_str = str; } public void ActivateOptions() { } public string Format() { return m_str.Replace("[ASSEMBLYNAME]", /* ... whatever ... */); } } Then provide a matching "Converter Class". internal class MyExpressionHandlerConverter : IConvertTo, IConvertFrom { public bool CanConvertTo(Type targetType) { return (typeof(string).IsAssignableFrom(targetType)); } public object ConvertTo(object source, Type targetType) { MyExpression patternString = source as MyExpression; if (patternString != null && CanConvertTo(targetType)) { return patternString.Format(); } throw ConversionNotSupportedException.Create(targetType, source); } public bool CanConvertFrom(System.Type sourceType) { return (sourceType == typeof(string)); } public object ConvertFrom(object source) { string str = source as string; if (str != null) { return new MyExpression(str); } throw ConversionNotSupportedException.Create(typeof(MyExpression), source); } } And finally make your converter known to the Log4Net framework: ConverterRegistry.AddConverter(typeof(MyExpression), typeof(MyExpressionConverter));
