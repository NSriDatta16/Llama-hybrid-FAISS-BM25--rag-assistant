[site]: stackoverflow
[post_id]: 3972553
[parent_id]: 3971868
[tags]: 
Here's a pretty naive implementation that you could fix up for your own needs. I purposely kept it pretty verbose. It's based on the five-number-summary often used to figure these things out. function get_median($arr) { sort($arr); $c = count($arr) - 1; if ($c%2) { $b = round($c/2); $a = $b-1; return ($arr[$b] + $arr[$a]) / 2 ; } else { return $arr[($c/2)]; } } function get_five_number_summary($arr) { sort($arr); $c = count($arr) - 1; $fns = array(); if ($c%2) { $b = round($c/2); $a = $b-1; $lower_quartile = array_slice($arr, 1, $a-1); $upper_quartile = array_slice($arr, $b+1, count($lower_quartile)); $fns = array($arr[0], get_median($lower_quartile), get_median($arr), get_median($upper_quartile), $arr[$c-1]); return $fns; } else { $b = round($c/2); $a = $b-1; $lower_quartile = array_slice($arr, 1, $a); $upper_quartile = array_slice($arr, $b+1, count($lower_quartile)); $fns = array($arr[0], get_median($lower_quartile), get_median($arr), get_median($upper_quartile), $arr[$c-1]); return $fns; } } function find_outliers($arr) { $fns = get_five_number_summary($arr); $interquartile_range = $fns[3] - $fns[1]; $low = $fns[1] - $interquartile_range; $high = $fns[3] + $interquartile_range; foreach ($arr as $v) { if ($v > $high || $v "; } } //$numbers = array( 19,20,21,21,22,30,60 ); // 60 is an outlier $numbers = array( 1,230,239,331,340,800); // 1 is an outlier, 800 is an outlier find_outliers($numbers); Note that this method, albeit much simpler to implement than standard deviation, will not find the two 60 outliers in your example, but it works pretty well. Use the code for whatever, hopefully it's useful! To see how the algorithm works and how I implemented it, go to: http://www.mathwords.com/o/outlier.htm This, of course, doesn't calculate the final average, but it's kind of trivial after you run find_outliers() :P
