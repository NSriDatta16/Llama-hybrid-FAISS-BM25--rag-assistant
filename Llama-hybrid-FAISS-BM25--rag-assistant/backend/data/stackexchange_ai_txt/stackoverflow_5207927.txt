[site]: stackoverflow
[post_id]: 5207927
[parent_id]: 5207332
[tags]: 
As you pointed out, the type if it exist is known by the compiler, otherwise it wouldn't exist. However, it is not always readily or even accessible to the programmer in C++03. N1607 mention the following in its conclusion: In C++2003, it is not possible to express the return type of a function template in all cases . Furthermore, expressions involving calls to function templates commonly have very complicated types, which are practically impossible to write by hand The question is how do we access this type as a programmer. This is not always a trivial process, often impracticable. It is increasingly complex when you have an expression for which you desire to know the result type. You would have to break it into pieces in order to figure the result types. It is not possible to simplify this process using templates (not without evaluating the expression anyhow). Breaking the expression will be error-prone, tedious and a nightmare to maintain. Think of this code: x.g()[b.a(e)]->f(); With C++98/TR1, it is often infeasible to name types that depend on template parameters. Traits offers us so much information, but eventually decltype is a much cleaner solution to many problems. A lot of the information available to you when meta programming is only available because libraries, such as boost or loki, use several tricks hidden in the dark corners of the C++98 language. Of course this is irrelevant to your question but I believe that it is worthy to mention that C++98 compilers already have mechanics to know these types. This is exactly what sizeof offers, except that it returns you a size. decltype reuse some of this functionality and solves these problems with greater elegance. As for a different (academic) example: struct Foo { struct { int x; } bar; }; template void f(const T& t) { // C++03, How can I name the type of T::bar ? // C++0x // decltype(t.bar) cpy; // Do stuff with our local cpy } int main() { f(Foo()); }
