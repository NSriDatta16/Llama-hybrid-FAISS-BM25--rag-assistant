[site]: stackoverflow
[post_id]: 1128272
[parent_id]: 
[tags]: 
Can someone recommend a better alternative to InternetOpenUrl(..)?

Environment: Win32 for Windows Mobile using C/C++ (VS2008) I need a clean and reliable method of updating some GPS coordinates (or other data) to a web server using http. Currently I've been using the following piece of code: wsprintf (threadParam.wszLocInfo, L"%s/LOGGPS/?U=%s&LAT=%.07f&LNG=%.07f&V=%s", ...); HANDLE hHTTPthread = CreateThread ( NULL, // No security attributes in Windows CE. 0, // Initial thread stack size, in bytes (Must be 0 under Windows CE) (LPTHREAD_START_ROUTINE) HTTPthread, // Thread procedure/function. &threadParam, // The argument for the new thread 0, // Creation flags NULL ); // Returned ID value (ignored). // Wait for the worker thread to complete. (with timeout) if (WaitForSingleObject (hHTTPthread, g_progSettings.dInetTimeout) == WAIT_TIMEOUT) { if (g_hHttpOpen) InternetCloseHandle (g_hHttpOpen); // terminate session. // Wait until the worker thread exits WaitForSingleObject (hHTTPthread, INFINITE); CloseHandle (hHTTPthread); g_txtbox.print (L"Worker thread has exited.\r\n"); return 0; } /////////////////// WorkerFunction ////////////////////// DWORD WINAPI HTTPthread (IN LPVOID vThreadParam) { // Get pointer to thread parameters. THREADPARAM *pThreadParam = (THREADPARAM*)vThreadParam; // Initialize an application's use of the Win32 Internet functions. g_hHttpOpen = InternetOpen (APP_CLASSNAME, // Application ID INTERNET_OPEN_TYPE_DIRECT, // No proxy server access NULL, // No name for proxy server NULL, // No bypass addresses 0); // No flags - Typical if (g_hHttpOpen == NULL) return 1; // failure // Set timeout. Whether they work or not, every bit might help. InternetSetOption (g_hHttpOpen, INTERNET_OPTION_CONNECT_TIMEOUT, &g_progSettings.dInetTimeout, sizeof(DWORD)); InternetSetOption (g_hHttpOpen, INTERNET_OPTION_RECEIVE_TIMEOUT, &g_progSettings.dInetTimeout, sizeof(DWORD)); InternetSetOption (g_hHttpOpen, INTERNET_OPTION_SEND_TIMEOUT, &g_progSettings.dInetTimeout, sizeof(DWORD)); InternetSetOption (g_hHttpOpen, INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT, &g_progSettings.dInetTimeout, sizeof(DWORD)); InternetSetOption (g_hHttpOpen, INTERNET_OPTION_CONTROL_SEND_TIMEOUT, &g_progSettings.dInetTimeout, sizeof(DWORD)); InternetSetOption (g_hHttpOpen, INTERNET_OPTION_DATA_RECEIVE_TIMEOUT, &g_progSettings.dInetTimeout, sizeof(DWORD)); InternetSetOption (g_hHttpOpen, INTERNET_OPTION_DATA_SEND_TIMEOUT, &g_progSettings.dInetTimeout, sizeof(DWORD)); g_hHttpUrl = InternetOpenUrl (g_hHttpOpen, pThreadParam->wszLocInfo, NULL, 0, INTERNET_FLAG_RELOAD | INTERNET_FLAG_PRAGMA_NOCACHE | INTERNET_FLAG_NO_CACHE_WRITE, 0); if (g_hHttpUrl == NULL) { InternetCloseHandle (g_hHttpOpen); return 2; // failure } // clean-up. InternetCloseHandle (g_hHttpOpen); InternetCloseHandle (g_hHttpUrl); return 0; // success } Now while this works (mostly), we all know that the timeouts are flaky and this brute force technique isn't very reliable and responsive at all times. The InternetOpenUrl(..) function makes things easy, but it's half-baked and not very flexible. So I'm looking for an alternative to perform the same thing. With reliable timeouts . How are you guys handling such updates to web servers? Thanks.
