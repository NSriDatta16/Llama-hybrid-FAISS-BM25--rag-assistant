[site]: stackoverflow
[post_id]: 4537877
[parent_id]: 4537586
[tags]: 
Specific notes to your question: Don't mix sort and search. First, a linear search is O(N), whereas sort_and_search is O(N log N) at best, i.e. a linear search would be faster . Binary search is a good choice of algoreithm only if you search many times over already-sorted data. Second, you noticed yourself that the caller needs control over the sort algorithm. Why not let the caller do that: quicksort(data,size); size_t result = binary_search(data,size); Generalization: Ways to use your example: (1) Functor parameter , as demonstrated by Naveen That makes sort_and_search a template, which may not be appropriate for some uses. it is a simle, common pattern, though. The advantage of this solution is the additional optimization possibilities when binary_search makes many short calls to the functor (which it doesn't in this case). The downside is the amount of code generated if sort_and_search itself has a large body. (2) function pointer as demonstrated by roe Even though this looks "C-ish", it's a simple, straigtforward solution. Downside: you can't parametrize the sort function (e.g. by specifying how to pick a pivot in the binary sort). (3) polymorphism Basically you: define an abstract base class, struct ISort { virtual void Sort(void * data, size_t size) = 0; virtual ~ISortData() {} } inherit concrete implementations from it: struct BinarySort : public ISort { ... } struct MergeSort : public ISort { ... } struct HeapSort : public ISort { ... } and provide the sort as a parameter to sort_and_search : size_t sort_and_search(void * data, size_t size, ISort & sort); Advantage/Disadvantage: Binding usually happens at runtime. This strongly isolates the sort and the search implementation (they could reside in differen binaries). However, the call overhead is significantly larger than in case More notes: the (void * data, size_t size) interface This interface doesn't provide type safety. It works, but the compiler can't tell you when you are passing invalid parameters. STL applies three generalizations here: Make the element type a template parameter: template size_t sas(T * values, size_t count) this provides type checking, and supports overloaded comparison operators for type T. Use iterators instead of arrays: They mess up the syntax, but it allows the algorithm to work on containers without consecutive storage. Also, you ca treat the container as a single entity, not a pointer and a count that the caller have to match. Optional comparison functor: An optional argument that contains functor for the comparison. This allows to use different sorting conditions on the same type T.
