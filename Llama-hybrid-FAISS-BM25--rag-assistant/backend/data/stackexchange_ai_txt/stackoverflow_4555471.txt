[site]: stackoverflow
[post_id]: 4555471
[parent_id]: 4555409
[tags]: 
The documentation of the current MySQL does not mention this constraint. It actually gives the impression that VARCHAR is stored in the row itself, as the sum of the length of all VARCHARs together in a row cannot be more than 65k bytes. It also mentions that storage is length+data, which is different from what you describe. I did find a mention of a splitted storage in MySQL compression internals : Tables created in previous versions of InnoDB use the “Antelope” file format, which supports only ROW_FORMAT=REDUNDANT and ROW_FORMAT=COMPACT. In these formats, InnoDB stores the first 768 bytes of BLOB, VARCHAR and TEXT columns in the clustered index record along with the primary key. The 768-byte prefix is followed by a 20-byte pointer to the overflow pages that contain the rest of the column value. To me this suggests that each column is considered individually when determining whether that column needs an overflow. This seems to contrast with newer versions of MySQL which seem to store VARCHAR quite differently. A VARCHAR in a newer version has a max length of 65k bytes, which seems to be stored in the record iself (no overflow), which results in the constraint that all columns together may not be longer than 65k byte. a CHAR is very different. It's maximum length is 255, and it is stored in the row itself. So no CHAR(500) :) The length of a CHAR column is fixed to the length that you declare when you create the table. The length can be any value from 0 to 255. When CHAR values are stored, they are right-padded with spaces to the specified length. When CHAR values are retrieved, trailing spaces are removed unless the PAD_CHAR_TO_FULL_LENGTH SQL mode is enabled.
