[site]: stackoverflow
[post_id]: 5116285
[parent_id]: 5115850
[tags]: 
The problem If you examine the token stream after tokenizing your source, you'll see that the following tokens are fed to the parser: LINEUP_OPEN :: [Lineup] NEWLINE :: \n LINE_CONTENT :: [Floor:Main Floor] NEWLINE :: \n LINE_CONTENT :: Test1 NEWLINE :: \n LINE_CONTENT :: Test2 NEWLINE :: \n LINE_CONTENT :: [Floor:Classics Floor] NEWLINE :: \n LINE_CONTENT :: Test3 NEWLINE :: \n LINE_CONTENT :: Test4 NEWLINE :: \n LINE_CONTENT :: Test5 NEWLINE :: \n LINE_CONTENT :: Test6 NEWLINE :: \n LINEUP_CLOSE :: [/Lineup] As you can see, there is never a FLOOR_OPEN created but LINE_CONTENT tokens instead. Here's how you can manually debug your token stream: String source = "[Lineup]\n" + "[Floor:Main Floor]\n" + "Test1\n" + "Test2\n" + "[Floor:Classics Floor]\n" + "Test3\n" + "Test4\n" + "Test5\n" + "Test6\n" + "[/Lineup]"; ANTLRStringStream in = new ANTLRStringStream(source); CalendarEventsJavaLexer lexer = new CalendarEventsJavaLexer(in); CommonTokenStream tokens = new CommonTokenStream(lexer); CalendarEventsJavaParser parser = new CalendarEventsJavaParser(tokens); for(Object o : tokens.getTokens()) { CommonToken t = (CommonToken)o; System.out.println(parser.tokenNames[t.getType()] + " :: " + t.getText().replace("\n", "\\n")); } The solution Changing: FLOOR_OPEN : '[Floor:'; to FLOOR_OPEN : '[Floor:' ~']'* ']'; ( FLOOR_CLOSE can then be removed) and changing: NONBREAKING : ~('\r' | '\n'); to: NONBREAKING : ~('\r' | '\n' | '[' | ']'); will result in the following parse tree: Comments Note that the lexer rules NONBREAKING and LINE_CONTENT are very similar, you probably don't want NONBREAKING to ever appear in the token stream. It's be better if you make NONBREAKING a fragment-rule. Fragment rules are only used by other lexer rules and will therefor never be used to create a "real" token: fragment NONBREAKING : ~('\r' | '\n' | '[' | ']'); LINE_CONTENT : NONBREAKING+;
