[site]: stackoverflow
[post_id]: 3643158
[parent_id]: 3643131
[tags]: 
Where did you get the idea that "string comparison has to be performed"? In order to determine if two type_info objects designate the same type, you need to compare these type_info objects directly, as in typeid(obj) == typeid(Test) . In fact, you cannot do the same things by comparing the strings returned by type_info::name() member simply because the language makes no guarantees about these strings at all. More specifically, it makes no guarantees about the uniqueness of these strings for each given type. They all can return "Hello World!" for all types. Or they can return an empty string for all types. Usually the implementations behave nicer than that, but in any case the name() member is there for some potential debugging/informational purposes. You cannot meaningfully rely on type_info::name() in the actual functionality of your code. Also, the language standard says that type_info objects are lvalue objects with static storage duration. I'd expect these type_info object to maintain their "address identity" for each specific type (although I'm not sure the standard actually guarantees that). I.e. I'd expect that &typeid(type) == &typeid(type) is always true (i.e. every time you invoke typeid for the same type, you get the same lvalue as the result). If so, you can compare the addresses of type_info objects instead of comparing them using the == operator. You can also use the addresses to build some more complicated data structure for type matching, like an associative array. You can't use switch/case with it though. (And again, I'm not sure my assumption about stable address identity of type_info is valid). In fact it is not. As Johannes Schaub noted in the comments, the correct way to put type_info s into an ordered container is to use the type_info::before() to establish ordering. Of course, in your specific case using a manually implemented integer identifier for the class (if you really really need to go that way) might be much more efficient. It also allows you a greater flexibility to implement your intent better. For example, typeid(Test) == typeid(const Test) will evaluate to false , which might not be what you want. However, hijacking the conversion operator to such a basic type as int for that purpose is definitely not a good idea. If you really need it, make it a named method and return something named, not a "magic constant".
