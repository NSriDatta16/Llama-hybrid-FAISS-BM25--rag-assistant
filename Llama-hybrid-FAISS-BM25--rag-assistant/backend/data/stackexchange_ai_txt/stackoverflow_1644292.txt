[site]: stackoverflow
[post_id]: 1644292
[parent_id]: 1641957
[tags]: 
If an expression of array type (such as the array name) appears in a larger expression and it isn't the operand of either the & or sizeof operators, then the type of the array expression is converted from "N-element array of T" to "pointer to T", and the value of the expression is the address of the first element in the array. In short, the array name is not a pointer, but in most contexts it is treated as though it were a pointer. Edit Answering the question in the comment: If I use sizeof, do i count the size of only the elements of the array? Then the array “head” also takes up space with the information about length and a pointer (and this means that it takes more space, than a normal pointer would)? When you create an array, the only space that's allocated is the space for the elements themselves; no storage is materialized for a separate pointer or any metadata. Given char a[10]; what you get in memory is +---+ a: | | a[0] +---+ | | a[1] +---+ | | a[2] +---+ ... +---+ | | a[9] +---+ The expression a refers to the entire array, but there's no object a separate from the array elements themselves. Thus, sizeof a gives you the size (in bytes) of the entire array. The expression &a gives you the address of the array, which is the same as the address of the first element . The difference between &a and &a[0] is the type of the result 1 - char (*)[10] in the first case and char * in the second. Where things get weird is when you want to access individual elements - the expression a[i] is defined as the result of *(a + i) - given an address value a , offset i elements ( not bytes ) from that address and dereference the result. The problem is that a isn't a pointer or an address - it's the entire array object. Thus, the rule in C that whenever the compiler sees an expression of array type (such as a , which has type char [10] ) and that expression isn't the operand of the sizeof or unary & operators, the type of that expression is converted ("decays") to a pointer type ( char * ), and the value of the expression is the address of the first element of the array. Therefore, the expression a has the same type and value as the expression &a[0] (and by extension, the expression *a has the same type and value as the expression a[0] ). C was derived from an earlier language called B, and in B a was a separate pointer object from the array elements a[0] , a[1] , etc. Ritchie wanted to keep B's array semantics, but he didn't want to mess with storing the separate pointer object. So he got rid of it. Instead, the compiler will convert array expressions to pointer expressions during translation as necessary. Remember that I said arrays don't store any metadata about their size. As soon as that array expression "decays" to a pointer, all you have is a pointer to a single element. That element may be the first of a sequence of elements, or it may be a single object. There's no way to know based on the pointer itself. When you pass an array expression to a function, all the function receives is a pointer to the first element - it has no idea how big the array is (this is why the gets function was such a menace and was eventually removed from the library). For the function to know how many elements the array has, you must either use a sentinel value (such as the 0 terminator in C strings) or you must pass the number of elements as a separate parameter. Which *may* affect how the address value is interpreted - depends on the machine.
