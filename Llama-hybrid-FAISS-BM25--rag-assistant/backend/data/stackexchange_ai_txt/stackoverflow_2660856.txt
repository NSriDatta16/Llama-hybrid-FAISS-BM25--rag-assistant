[site]: stackoverflow
[post_id]: 2660856
[parent_id]: 2660802
[tags]: 
I think you want to change your idea about what to store. A user gives you a pointer to some memory that she allocated, so she should expect to deallocate it. You don't need to memcpy or free the value, you just need to keep track of the pointer. Pushing in the queue should transfer ownership to the queue, and popping from the queue should transfer ownership back to the user. So all you need to do is copy around the 'val' pointer. Also, to clean up the queue storage when finished, you probably want a queueDestroy(Queue* q) function. Edit: Notice, you don't need QueueItem and you can store an array of QueueValues. Also, I realize you explicitly said that memory management was the job of the library, but that's when you run into problems (like the one you're running into). The library should take care of its own memory management (the queue). But the alloc & dealloc of the items should be the user's job. Another option is to provide a queueFront(Queue *q) which passes back the value, but then it gets deallocated by queuePop(Queue *q). I prefer your current approach though :) Requiring the user to define a max size for the queue is kinda restricting. If you want this to be generic++,modular++ then you should use a predefined constant, then grow on queuePush(), if it's full. Alternatively you can use a linked list implementation (but contiguous memory is generally much much faster).
