[site]: stackoverflow
[post_id]: 5663110
[parent_id]: 5663073
[tags]: 
The standard write function accepts a pointer to what you want to write out; you're passing it a char (which is being promoted to an int ). The minimal fix would be to change this: write (socket, bmpheader[i], 1); to write (socket, &bmpheader[i], 1); ...but there are better ways. You can just let write write out all 54 bytes itself: write (socket, bmpheader, 54); Or if you really want to do it a char at a time, you could use a pointer: int i; char *p; for (i = 0, p = bmpheader; i In either case, you want to avoid that magic number 54 and take it from the data. Since sizeof(char) is always one byte in standard C , you can use sizeof without doing the ugly sizeof(array) / sizeof(array[0]) thing: int i; char *p; for (i = 0, p = bmpheader; i ...but I'm sure there's a more elegant solution than that. You can also use putchar (fairly lightweight) instead of printf (fairly heavyweight): int i; char* p; for (i = 0, p = bmpheader; i And I used to do things like this with pointer arithmetic, no idea whether they're bad practice in the modern world: char* p; char* endp; for (p = bmpheader, p = bmpheader + sizeof(bmpheader); p
