[site]: stackoverflow
[post_id]: 4438968
[parent_id]: 4437489
[tags]: 
C supprots three types of function argument forms: Known fixed arguments: this is when you declare function with arguments: foo(int x, double y) . Unknown fixed arguments: this is when you declare it with empty parentheses: foo() (not be confused with foo(void) : it is the first form without arguments), or not declare it at all. Variable arguments: this is when you declare it with ellipsis: foo(int x, ...) . When you see standard function working then function definition (which is in form 1 or 3) is compatible with form 2 (using same calling convention). Many old std. library functions are so (as desugned to be), because they are there form early versions of C, where was no function declarations and they all was in form 2. Other function may be unintentionally be compatible with form 2, if they have arguments as declared in argument promotion rules for this form. But some may not be so. But form 2 need programmer to pass arguments of same types everywhere, because compiler not able to check arguments with prototype and have to determine calling convention osing actual passed arguments. For example, on MC68000 machine first two integer arguments for fixed arg functions (for both forms 1 and 2) will be passed in registers D0 and D1 , first two pointers in A0 and A1 , all others passed through stack. So, for example function fwrite(const void * ptr, size_t size, size_t count, FILE * stream); will get arguments as: ptr in A0 , size in D0 , count in D1 and stream in A1 (and return a result in D0 ). When you included stdio.h it will be so whatever you pass to it. When you do not include stdio.h another thing happens. As you call fwrite with fwrite(data, sizeof(*data), 5, myfile) compiler looks on argruments and see that function is called as fwrite(*, int, int, *) . So what it do? It pass first pointer in A0 , first int in D0 , second int in D1 and second pointer in A1 , so it what we need. But when you try to call it as fwrite(data, sizeof(*data), 5.0, myfile) , with count is of double type, compiler will try to pass count through stack, as it is not integer. But function require is in D1 . Shit happens: D1 contain some garbage and not count , so further behaviour is unpredictable. But than you use prototype defined in stdio.h all will be ok: compiler automatically convert this argument to int and pass it as needed. It is not abstract example as double in arument may be just result of computation involving floating point numbers and you may just miss this assuming result is int. Another example is variable argument function (form 3) like printf(char *fmt, ...) . For it calling convention require last named argument ( fmt here) to be passed through stack regardess of its type. So, then you call printf("%d", 10) it will put pointer to "%d" and number 10 on stack and call function as need. But when you do not include stdio.h comiler will not know that printf is vararg function and will suppose that printf("%d", 10) is calling to function with fixed arguments of type pointer and int. So MC68000 will place pointer to A0 and int to D0 instead of stack and result is again unpredictable. There may be luck that arguments was previously on stack and occasionally read there and you get correct result... this time... but another time is will fail. Another luck is that compiler takes care if not declared function may be vararg (and somehow makes call compatible with both forms). Or all arguments in all forms are just passed through stack on your machine, so fixed, unknown and vararg forms are just called identically. So: do not do this even you feel lucky and it works. Unknown fixed argument form is there just for compatibility with old code and is strictly discouraged to use. Also note: C++ will not allow this at all, as it require function to be declared with known arguments.
