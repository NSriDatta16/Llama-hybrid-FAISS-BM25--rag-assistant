[site]: stackoverflow
[post_id]: 1788765
[parent_id]: 1788696
[tags]: 
You are wrong when you say that the output of this code considered as a C program is 6 . Considered as a C program, this is undefined . You just happened to get 6 with your compiler, but you could just as well have gotten 24, segmentation fault, or a compile-time error. See the C99 standard , 6.5.2: Between the previous and next sequence point an object shall have its stored value modiÔ¨Åed at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored.71) --x-x-- is explicitly forbidden by this paragraph. EDIT: Aaron Digulla writes in the comments: Is it really undefined? Did you notice that I linked to the C99 standard and indicated the paragraph that says this is undefined? gcc -Wall (GCC 4.1.2) doesn't complain about this and I doubt that any compiler would reject this code. The standard describes some behaviors as "undefined" precisely because not all ways for a C program to be nonsense can be detected reliably at compile-time. If you think that "no warning" should mean everything's fine, you should switch to another language than C. Many modern languages are better defined. I use OCaml when I have a choice, but there are countless other well-defined languages. There is a reason why it returns 6 and you should be able to explain it. I did not notice your explanation of why this expression evaluated to 6. I hope you don't spend too much time writing it, because for me it returns 0. Macbook:~ pascalcuoq$ cat t.c #include int main(int argc, char **argv) { int y; printf("argc:%d\n", argc); y = --argc - argc--; printf("y:%d\n", y); return 0; } Macbook:~ pascalcuoq$ gcc t.c Macbook:~ pascalcuoq$ ./a.out 1 2 3 4 5 6 7 8 9 argc:10 y:0 This is the time at which you argue that there is a bug in my compiler (since it doesn't return the same thing as yours). Macbook:~ pascalcuoq$ gcc -v Using built-in specs. Target: i686-apple-darwin9 Configured with: /var/tmp/gcc/gcc-5490~1/src/configure --disable-checking -enable-werror --prefix=/usr --mandir=/share/man --enable-languages=c,objc,c++,obj-c++ --program-transform-name=/^[cg][^.-]*$/s/$/-4.0/ --with-gxx-include-dir=/include/c++/4.0.0 --with-slibdir=/usr/lib --build=i686-apple-darwin9 --with-arch=apple --with-tune=generic --host=i686-apple-darwin9 --target=i686-apple-darwin9 Thread model: posix gcc version 4.0.1 (Apple Inc. build 5490) Aaron also writes: As an engineer, you should still be able to explain why it returns one result or the other. Exactly! I gave the simplest explanation why one might get 6: the result is explicitly specified in C99 as undefined behavior, and it was in earlier standards too. and: Lastly, please show a compiler which warns about this construct. To the best of my knowledge, no compiler warns about *(&x - 1) where x is defined by int x; . Are you claiming that this construct is valid C and that a good engineer should be able to predict the result because no compiler warns about it? This construct is undefined, just like the one being discussed. Lastly, if you absolutely need warnings to believe there is a problem, consider using a verification tool such as Frama-C . It needs to make some assumptions that are not in the standard to capture some existing practices, but it correctly warns about --x-x-- and most other undefined C behaviors.
