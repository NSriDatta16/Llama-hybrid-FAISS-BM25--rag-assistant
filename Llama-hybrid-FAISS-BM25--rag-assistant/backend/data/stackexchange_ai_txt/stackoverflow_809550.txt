[site]: stackoverflow
[post_id]: 809550
[parent_id]: 
[tags]: 
C# Compiler : cannot access static method in a non-static context

I have the code below : public class Anything { public int Data { get; set;} } public class MyGenericBase { public void InstanceMethod(T data) { // do some job } public static void StaticMethod(T data) { // do some job } // others members... } public sealed class UsefulController : MyGenericBase { public void ProxyToStaticMethod() { StaticMethod(null); } // others non derived members... } public class Container { public UsefulController B { get; set; } } public class Demo { public static void Test() { var c = new Container(); c.B.InstanceMethod(null); // Works as expected. c.B.StaticMethod(null); // Doesn't work. // Static method call on object rather than type. // How to get the static method on the base type ? c.B.ProxyToStaticMethod(); // Works as expected. } } The compiler is very angry... I understand the error message but I don't know how to solve this. I was trying to get a type rather than an object to make my static method call, but I don't find the way to do it correctly. Moreover this results in something not elegant at all. Basically, the GenericBase is a class from a framework with a lot of static methods and some instance methods. The controller is typing this class and extending it. The container is a group of logical related controllers. Interesting thing : a Java version of this code compiles correctly, but with a warning. The execution is correct, too. Does it exist a design pattern to solve this ? Thanks for your inputs ! I found a way to get rid of this problem, thanks to your answers. It seems to work, but I can not tell if there are side effects right know. public class GenericBase : MyGenericBase { // Create instance calls here for every base static method. } public sealed class UsefulController : GenericBase { // others non derived members... }
