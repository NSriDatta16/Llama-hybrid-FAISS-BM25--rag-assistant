[site]: stackoverflow
[post_id]: 5206299
[parent_id]: 5204906
[tags]: 
Oh, well, for those having a similar problem, it looks like maybe I found the answer. I was expecting python to automatically scan the symbols compiled into the shared library FragIdx.so, instead it looks like this information must be provided explicitly as a .pxd file (which becomes a C header file after Cython is run). There are basically two steps involved in the process: Creation of a definition ( .pxd ) file for the superclass; Importing of the the superclass definition via cimport (as opposed to import ) in the subclass module. So, to make it more general. Suppose that you have defined your cdef-ed type A in module pkg1.mod1 . Then you cdef a type B in pkg2.mod2 that subclasses A . Your directory structure would look something like this: pkg1/ mod1.pyx mod1.pxd pkg2/ mod2.pyx mod2.pxd In pkg1/mod1.pxd you would have, say: cdef class A: cdef int a cdef int b And in pkg1/mod1.pyx you would provide the methods of your class. In pkg2/mod2.pxd , you would have: from pkg1.mod1 cimport A #note "cimport"!! cdef class B(A): cdef ... # your attributes here And again, in pkg2/mod2.pyx you would have to cimport the A symbol again: from pkg1.mod1 cimport A #note "cimport"!! cdef class B(A): ... # your methods here Interestingly enough, if you just want to use A in your python code, as opposed to using it to define a subtype, the definitions file mod1.pxd is not needed. This is related to the fact that when creating an extension type you need the definitions to be available for the C compiler, whereas you don't have this problem when running python code, but since it is not very intuitive maybe it's important to point it out. This information is actually available in the Cython docs , though maybe it could be a little bit more explicit. Hope this information can save some to someone.
