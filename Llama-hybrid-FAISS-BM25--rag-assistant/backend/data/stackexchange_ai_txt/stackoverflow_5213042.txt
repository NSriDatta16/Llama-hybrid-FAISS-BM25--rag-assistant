[site]: stackoverflow
[post_id]: 5213042
[parent_id]: 5207985
[tags]: 
First, I'd like to counter your assumption that each entity needs its own repository. Per, Eric Evans "Domain Driven Design" Repositories give access to selected aggregate roots. Repositories are prohibited from the interior of an aggregate. Given your example, a dog has a set of tricks that it has learned. When you want to add a new trick to the dog, you'd do something like this: var dog = dogRepository.Get(dogId); dog.Tricks.Add(newTrick); dogRepository.SaveOrUpdate(dog); When I need a new Application Services method that uses a combination of repositories that I don't have yet, I'm not sure what you mean by this. But I think if you stick to using repositories for aggregate roots, you're not going to run into such messy code. The other alternative seems to be to only let the Application Services layer play with the Repositories, but then you get a lot of boilerplate code added to the Application Services to do very simple things. Controllers orchestrate. Think of controllers as a part of the UI, they move you from page to page. I will admit that for simple things, it seems simpler to just inject a repository into the controller, but when your project grows the separation will help a lot, especially if you end up having another application hook into your Tasks layer. Keep repositories out of controllers. e.g. Do you have lots of classes that just do one task each? Or do you clump related tasks together along entity lines? How do you deal with tasks that need a lot of repositories? Does needing a lot of repositories for a task mean its time to go back to the drawing board? Again, I think this goes back to defining aggregate roots. Having 4-5 repositories in a task isn't that big of a deal. I usually organize my tasks by what the application is trying to do, with the idea that if the UI changes to, say, an external JSON request, you just need to call the right task. Hope this answers your question. Feel free to post this on the Sharp mailing list, you might get a better response there. Edit based on comments: Check out Who Can Help Me (https://github.com/sharparchitecture/Who-Can-Help-Me) for an example of how to use the ApplicationServices/Tasks layer. They have a fairly small domain model so each entity has its own task. I think you're confusing terminology a bit, or perhaps I'm being unclear. The idea behind an ApplicationServices layer is to further abstract the UI from the domain layer. Repositories are domain layer entities, and knowledge of them should not be in the controller. If you end up swapping out ORM or even moving to a document-based storage system, you'll see why this abstraction makes it really convenient, you just need to make sure your ApplicationServices contracts are working and don't have to muck about in the controllers. But, don't confuse the need for ApplicationServices as a way of future proofing. It simply allows for further decoupling between your layers and decoupling is nearly always a good thing. Again, for a project you're working on solo, all this might seem a bit of overkill. When you're working with other developers, all this abstraction is really, really nice. You can have a team working on upstream domain issues, and a team working on the presentation layer, and have a nice separation of concerns.
