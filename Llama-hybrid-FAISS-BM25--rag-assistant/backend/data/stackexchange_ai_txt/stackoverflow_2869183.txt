[site]: stackoverflow
[post_id]: 2869183
[parent_id]: 
[tags]: 
Segmentation fault in std function std::_Rb_tree_rebalance_for_erase ()

(Note to any future readers: The error, unsurprisingly, is in my code and not std::_Rb_tree_rebalance_for_erase () ) I'm somewhat new to programming and am unsure how to deal with a segmentation fault that appears to be coming from a std function. I hope I'm doing something stupid (i.e., misusing a container), because I have no idea how to fix it. The precise error is Program received signal EXC_BAD_ACCESS, Could not access memory. Reason: KERN_INVALID_ADDRESS at address: 0x000000000000000c 0x00007fff8062b144 in std::_Rb_tree_rebalance_for_erase () (gdb) backtrace #0 0x00007fff8062b144 in std::_Rb_tree_rebalance_for_erase () #1 0x000000010000e593 in Simulation::runEpidSim (this=0x7fff5fbfcb20) at stl_tree.h:1263 #2 0x0000000100016078 in main () at main.cpp:43 The function that exits successfully just before the segmentation fault updates the contents of two containers. One is a boost::unordered_multimap called carriage ; it contains one or more struct Infection objects. The other container is of type std::multiset > EventPQ called ce . void Host::recover( int s, double recoverTime, EventPQ & ce ) { // Clearing all serotypes in carriage // and their associated recovery events in ce // and then updating susceptibility to each serotype double oldRecTime; int z; for ( InfectionMap::iterator itr = carriage.begin(); itr != carriage.end(); itr++ ) { z = itr->first; oldRecTime = (itr->second).recT; EventPQ::iterator epqItr = ce.find( Event(oldRecTime) ); assert( epqItr != ce.end() ); ce.erase( epqItr ); immune[ z ]++; } carriage.clear(); calcSusc(); // a function that edits an array cout The last cout line appears immediately before the seg fault. My idea so far is that the rebalancing is being attempted on ce immediately after this function, but I am unsure why the rebalancing would be failing. Update I've confirmed the seg fault goes away (though the program then immediately crashes for other reasons) when I remove ce.erase( epqItr ); . I am able to remove events successfully in another place in the code; the code I use there to erase items in ce is identical to what's here. Backtracing without optimization (thanks, bdk) reveals much more information: Program received signal EXC_BAD_ACCESS, Could not access memory. Reason: KERN_INVALID_ADDRESS at address: 0x000000000000000c 0x00007fff8062b144 in std::_Rb_tree_rebalance_for_erase () (gdb) backtrace #0 0x00007fff8062b144 in std::_Rb_tree_rebalance_for_erase () #1 0x00000001000053d2 in std::_Rb_tree, std::less, > std::allocator >::erase (this=0x7fff5fbfdfe8, __position={_M_node = 0x10107cb50}) at > stl_tree.h:1263 #2 0x0000000100005417 in std::multiset, std::allocator >::erase (this=0x7fff5fbfdfe8, __position={_M_node = 0x10107cb50}) at stl_multiset.h:346 #3 0x000000010000ba71 in Simulation::runEpidSim (this=0x7fff5fbfcb40) at Simulation.cpp:426 #4 0x000000010001fb31 in main () at main.cpp:43 Unless Xcode is reading line numbers wrong, the only stl_tree.h in my hard drive is blank on line 1263. A few people asked to see the function that calls recover. It's a bit complicated: struct updateRecovery{ updateRecovery( int s, double t, EventPQ & ce ) : s_(s), t_(t), ce_(ce) {} void operator() (boost::shared_ptr ptr ) { ptr->recover( s_, t_, ce_ ); } private: int s_; double t_; EventPQ & ce_; }; // allHosts is a boost::multiindex container of boost::shared_ptr // currentEvents is the EventPQ container // it is an iterator to a specific member of allHosts allHosts.modify( it, updateRecovery( s, t, currentEvents ) ); cout The last cout prints. The code worked before without this particular version of the recovery function. Noah Roberts correctly pointed out that the problem is at Simulation.cpp, line 426. Jump below for embarrassing solution.
