[site]: stackoverflow
[post_id]: 304672
[parent_id]: 125532
[tags]: 
You said you were interested in why, so: In real mode, a segment is a 64K "window" to physical memory and these windows are spaced 16 bytes apart. In protected mode, a segment is a window to either physical or virtual memory, whose size and location is determined by the OS, and it has many other properties, including what privilege level a process must have to access it. From here on, everything I say refers to protected mode. There is a table in memory called the global descriptor table (GDT), which is where the information about these window sizes and locations and other properties are kept. There may also be local descriptor tables on a per-process basis, and they work in a similar way, so I'll just focus on the GDT. The value you load into a segment register is known as a segment selector . It is an index into the GDT or LDT, with a bit of extra security information. Naturally if a program tries to load a descriptor which is outside the bounds of the GDT, an exception occurs. Also if the process does not have enough privilege to access the segment, or something else is invalid, an exception occurs. When an exception occurs, the kernel handles it. This sort of exception would probably be classed as a segmentation fault. So the OS kills your program. There's one final caveat: in the x86 instruction set, you can't load immediate values into segment registers. You must use an intermediate register or a memory operand or POP into the segment register. MOV DS, 160 ;INVALID - won't assemble MOV AX, 160 ;VALID - assembles, but will probably result in an MOV DS, AX ;exception, and thus the death of your program I think it should be pointed out that the architecture allows for heaps of segments. But AFAIK, when it comes to the mainstream x86 operating systems, segment registers serve only a few purposes: Security mechanisms, such as keeping user space processes from harming each other or the OS Dealing with multiple/multi-core processors Thread-local storage: as an optimization, some operating systems (including Linux and Windows) use segment registers for thread-local storage (TLS). Since threads share the same address space, it is hard for a thread to "know" where its TLS region is without using a system call or wasting a register... but since segment registers are practically useless, there's no harm in "wasting" them for the sake of fast TLS. Note that when setting this up, an OS might skip the segment registers and write directly to descriptor cache registers, which are "hidden" registers used to cache the GDT/LDT lookups triggered by references to the segment registers, in which case if you try to read from the segment registers you won't see it. Apart from a segment per thread for TLS, really only a handful of segments (times the number of processors) are used, and only by the OS. Application programs can completely ignore the segment registers. This is due to OS design, not to any technical limitations. There may be embedded operating systems that require user-space programs to work with the segment registers, though I don't know of any.
