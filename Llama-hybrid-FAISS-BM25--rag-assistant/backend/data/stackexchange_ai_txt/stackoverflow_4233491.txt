[site]: stackoverflow
[post_id]: 4233491
[parent_id]: 4233300
[tags]: 
You want to create a templated version of your objects but have those objects take different parameter types based on the templated parameter? That's not a very easy thing to integrate into a library but there are a few ways of going about it. Take a look at unary_function for inspiration. There they are using templated traits to carry around the type parameters without having to work any sort of magic: template struct unary_function { typedef Arg argument_type; typedef Result result_type; }; 'unary_function' does not contain any functionality other than declaring typedefs. These typedefs, however, allow you to express in code and at compile time named equivalents between code segments. They leverage the way template parameters are checked. What this means is that you can have objects that work on this: template struct Foo{ typedef typename T::argument_type argument_type; Foo(T _myFunc) : m_Func(_myFunc) void myWrappedFunction(argument_type _argument){ m_Func( _argument ); } }; which contains within it the value type of the arguments without having to specify them in advance. So if you have pixel_type or something similar for each of your image objects then simply stating typename T::pixel_type will call forward the type parameter you need.
