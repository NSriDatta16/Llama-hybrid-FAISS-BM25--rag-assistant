[site]: stackoverflow
[post_id]: 966966
[parent_id]: 966032
[tags]: 
Textbook Answer: Operator overloading is not part of the Common Language Specification, meaning compiler writers are free to ignore or only partially support it if they feel like. As a library writer, you are responsible for providing alternate means for people to work with the class. Pragmatic Answer: Because it is a stupid thing to do in the first place. The op_GreaterThan method was explicitly created to make comparisons. That it, you aren't supposed to do 'interesting' things with it like concatinating two terms. The CLR only lets you abuse it because it needs to support legacy languages like C++. By the way, there is an overload specifically for joining two things together. It is called op_Concatenate. You really should consider using it instead of op_GreaterThan. EDIT Almost Good Answer: In F# the concatination operator I mentioned is ^. I call this the almost-good answer because I'm not so sure that C# supports it. I think it is only allowed in VB and F#. EDIT #2 It seems F# isn't honoring the ^ overload after all. EDIT #3 WTF is going on here? F# doesn't honor the > operator at all. Sure you can overload it, and it will emit the op_GreaterThan method correctly, but it ignores it. It doesn't even try to use op_GreaterThan, instead it looks for the System.IComparable interface. Even worse, this is a runtime check. Even though it can statically determine that class Foo doesn't implement IComparable, it still goes ahead and compiles the code anyways.
