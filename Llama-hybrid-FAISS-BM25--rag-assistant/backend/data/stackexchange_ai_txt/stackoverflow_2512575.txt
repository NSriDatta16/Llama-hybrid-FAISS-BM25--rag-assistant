[site]: stackoverflow
[post_id]: 2512575
[parent_id]: 2495256
[tags]: 
You didn't specify much about how you wanted to plot pixels, so I'm gonna start out by assuming it's really on the complexity order of "buffer[somepixel] = MAKECOLOR(255, 0, 0);". My suggestion would be that instead of reading back (which might be very expensive or quite cheap depending on memory architecture), modifying, and writing/uploading the backbuffer; Instead, plot your pixels to a texture, and let the GPU handle the composition of the GPU accelerated sprites and the CPU plotted pixels. In the basic case, that would be something like: Create a 4-channel texture the size of your backbuffer. If your target system supports it, specify LOCKABLE and DYNAMIC usage flags. (If it doesn't, or if the driver prefers non-lockable textures, you'll have to go through an extra system texture for step 2 below. And upload it using UpdateTexture / CopyRects instead) Each frame, lock the texture, plot your pixels, unlock the texture. Make sure to write coverage information to the alpha channel of the pixel, so that the GPU has some data that can control the composition. E.g. if you wanted to plot solid red, write (255, 0, 0, 255) for that pixel. Make sure you clear the pixels you don't actually want to plot. Set up the GPU to compose your plotted data on top of your sprites. by rendering a full-screen quad textured with your plotted texture (and using point sampling). For the simplest opaque composition case, enable AlphaTestEnable, set AlphaRef to 128, and AlphaFunc to GREATER, and disable ZEnable. This will render the plotted pixels on top of the sprites, while leaving the rest of the sprite pixels untouched. If you're using a depth buffer, and you wanted to get fancy about gaining some extra performance, you could render the plotted texture before your sprites, with both ZEnable and ZWriteEnabled enabled. (Make sure you render the full-screen quad at the near plane then) This will fill in a depth buffer mask where your opaque pixels are, which will occlude those pixels when you later render the sprites. Obviously, you're not really constrained to just overwriting solid pixels either. You could use alpha blending with a combination of creative blend modes and alpha values to create other kinds of compositions and overlays.
