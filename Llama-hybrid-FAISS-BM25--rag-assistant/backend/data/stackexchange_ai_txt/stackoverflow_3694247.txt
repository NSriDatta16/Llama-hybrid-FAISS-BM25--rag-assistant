[site]: stackoverflow
[post_id]: 3694247
[parent_id]: 3691943
[tags]: 
Let me try to clarify what is possible, not possible and planned with examples. The quote from the manual basically means you could have the following custom implementation type: use Doctrine\Common\Collections\Collection; // MyCollection is the "implementation type" class MyCollection implements Collection { // ... interface implementation // This is not on the Collection interface public function myCustomMethod() { ... } } Now you could use it as follows: class MyEntity { private $items; public function __construct() { $this->items = new MyCollection; } // ... accessors/mutators ... } $e = new MyEntity; $e->getItems()->add(new Item); $e->getItems()->add(new Item); $e->getItems()->myCustomMethod(); // calling method on implementation type // $em instanceof EntityManager $em->persist($e); // from now on $e->getItems() may only be used through the interface type In other words, as long as an entity is NEW (not MANAGED, DETACHED or REMOVED) you are free to use the concrete implementation type of collections, even if its not pretty. If it is not NEW, you must access only the interface type (and ideally type-hint on it). That means the implementation type does not really matter. When a persistent MyEntity instance is retrieved from the database, it will not use a MyCollection (constructors are not invoked by Doctrine, ever, since Doctrine only reconstitutes already existing/persistent objects, it never creates "new" ones). And since such an entity is MANAGED, access must happen through the interface type anyways. Now to what is planned. The more beautiful way to have custom collections is to also have a custom interface type, say IMyCollection and MyCollection as the implementation type. Then, to make it work perfectly with the Doctrine 2 persistence services you would need to implement a custom PersistentCollection implementation, say, MyPersistentCollection which looks like this: class MyPersistentCollection implements IMyCollection { // ... } Then you would tell Doctrine in the mapping to use the MyPersistentCollection wrapper for that collection (remember, a PersistentCollection wraps a collection implementation type, implementing the same interface, so that it can do all the persistence work before/after delegating to the underlying collection implementation type). So a custom collection implementation would consist of 3 parts: Interface type Implementation type (implements interface type) Persistent wrapper type (implements interface type) This will not only make it possible to write custom collections that work seemlessly with the Doctrine 2 ORM but also to write only a custom persistent wrapper type, for example to optimise the lazy-loading/initialization behavior of a particular collection to specific application needs. It is not yet possible to do this but it will be. This is the only really elegant and fully functional way to write and use completely custom collections that integrate flawlessly in the transparent persistence scheme provided by Doctrine 2.
