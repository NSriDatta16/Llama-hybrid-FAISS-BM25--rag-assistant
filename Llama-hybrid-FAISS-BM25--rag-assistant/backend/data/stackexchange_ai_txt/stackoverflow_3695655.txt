[site]: stackoverflow
[post_id]: 3695655
[parent_id]: 3695147
[tags]: 
I think there is a huge misunderstanding in the question itself. There is not relationship between stack or heap allocated objects on the one hand and pass by value or reference or pointer on the other. Stack vs Heap allocation Always prefer stack when possible, the object's lifetime is then managed for you which is much easier to deal with. It might not be possible in a couple of situations though: Virtual construction (think of a Factory) Shared Ownership (though you should always try to avoid it) And I might miss some, but in this case you should use SBRM (Scope Bound Resources Management) to leverage the stack lifetime management abilities, for example by using smart pointers. Pass by: value, reference, pointer First of all, there is a difference of semantics : value, const reference: the passed object will not be modified by the method reference: the passed object might be modified by the method pointer/const pointer: same as reference (for the behavior), but might be null Note that some languages (the functional kind like Haskell) do not offer reference/pointer by default. The values are immutable once created. Apart from some work-arounds for dealing with the exterior environment, they are not that restricted by this use and it somehow makes debugging easier. Your friend should learn that there is absolutely nothing wrong with pass-by-reference or pass-by-pointer: for example thing of swap , it cannot be implemented with pass-by-value. Finally, Polymorphism does not allow pass-by-value semantics. Now, let's speak about performances. It's usually well accepted that built-ins should be passed by value (to avoid an indirection) and user-defined big classes should be passed by reference/pointer (to avoid copying). big in fact generally means that the Copy Constructor is not trivial. There is however an open question regarding small user-defined classes. Some articles published recently suggest that in some case pass-by-value might allow better optimization from the compiler, for example, in this case: Object foo(Object d) { d.bar(); return d; } int main(int argc, char* argv[]) { Object o; o = foo(o); return 0; } Here a smart compiler is able to determine that o can be modified in place without any copying! (It is necessary that the function definition be visible I think, I don't know if Link-Time Optimization would figure it out) Therefore, there is only one possibility to the performance issue, like always: measure .
