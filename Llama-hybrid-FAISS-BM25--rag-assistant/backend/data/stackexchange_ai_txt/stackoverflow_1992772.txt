[site]: stackoverflow
[post_id]: 1992772
[parent_id]: 1991710
[tags]: 
In your first example, the RedirectToProvider() method calls the ASP.NET Response.Redirect() method. This method, as implemented by ASP.NET itself, throws an exception ( ThreadAbortException specifically). That's why you never get to throw new Exception("Should never get here"); line. Note however that that although it is never reached, throw must still appear because it allows C# to know that no return statement is necessary for the method to be verifiable and safe code. The FormsAuthentication.RedirectFromLoginPage method also ultimately calls Response.Redirect , which means it also throws an exception. But because you don't have a throw statement beneath it, C# requires that you return something instead. When you're in a method with a return type, C# demands you return or throw at every possible exit point. In ASP.NET web forms, Response.Redirect was your only option (well, not really but it seemed like it). But ASP.NET MVC offers a RedirectAction that allows you to issue a browser redirect without ever throwing an exception. And DotNetOpenAuth (the successor to DotNetOpenId) offers a way to leverage this feature. As shown here you can redirect to the provider by returning the result of IAuthenticationRequest.RedirectingResponse.AsActionResult() from your controller's action to initiate login instead of calling IAuthenticationRequest.RedirectToProvider() . Also, you can log the user into your site without using FormsAuthentication.RedirectFromLoginPage by calling FormsAuthentication.SetAuthCookie and then return Redirect(...) within your controller's action to send the user onto his destination.
