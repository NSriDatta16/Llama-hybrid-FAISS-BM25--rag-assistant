[site]: stackoverflow
[post_id]: 4199717
[parent_id]: 3652412
[tags]: 
I answered your last question on this subject, and ran into the same problem with Carbon's HIToolbox catching exceptions thrown by IBActions. First, undo everything I mentioned in my previous answer . It doesn't work with IBActions for some reason. My hunch is that HIToolbox lives lower on the exception-handling-chain, and gets any IBAction/GUI exceptions before NSApplication has the opportunity to. Any custom exception-handling function you can register with NSSetUncaughtExceptionHandler() lives (I believe) at the top of the chain. You're on the right track with NSExceptionHandling: Add the ExceptionHandling.framework to your Xcode Project #import "ExceptionHandlerDelegate.h" into your AppDelegate.m (or a custom Singleton exception class) Inside AppDelegate.m : // Very first message sent to class + (void)initialize { NSExceptionHandler *exceptionHandler = [NSExceptionHandler defaultExceptionHandler]; unsigned int handlingMask = NSLogAndHandleEveryExceptionMask; [exceptionHandler setExceptionHandlingMask:handlingMask]; [exceptionHandler setDelegate:self]; // ... } #pragma mark - #pragma mark NSExceptionHandler Delegate Methods // Called 1st: Should NSExceptionHandler log the exception? - (BOOL)exceptionHandler:(NSExceptionHandler *)sender shouldLogException:(NSException *)exception mask:(unsigned int)aMask { // ...log NSException if desired... return NO; // Changes to YES if NSExceptionHandler should handle logging } // Called 2nd: Should NSExceptionHandler handle the exception? - (BOOL)exceptionHandler:(NSExceptionHandler *)sender shouldHandleException:(NSException *)exception mask:(unsigned int)aMask { // ...crash your app here (e.g. [NSApp terminate:self]; ) // ...or handle the NSException and return YES/NO accordingly return NO; // If app crashed, never gets returned - should crash before that } The NSLogAndHandleEveryExceptionMask flag tells NSExceptionHandler to capture every exception it can (for your app only, I believe), regardless of where on the exception chain it exists. This means that @catch/@try/@finally blocks won't work, because the NSHandleOtherExceptionMask flag tells NSExceptionHandler to capture "everything below it" on the exception-handler chain. You can remove that flag, but then HIToolKit will probably get any IBAction exceptions again, since it appears to be lower on said chain. Apple's docs have info about the flags: NSExceptionHandler docs So when an NSException is raised (anywhere in your app AFAIK), and NSLogAndHandleEveryExceptionMask is set, these are called in the delegate in-order: -exceptionHandler:shouldLogException:mask: is called first. -exceptionHandler:shouldHandleException:mask: is called second. Just put your "crash code" inside the second delegate method and you should be OK. Helpful article: Understanding Exceptions and Handlers in Cocoa The reason I think you were having trouble getting NSExceptionHandler's delegate to work is because it's NOT compatible with a custom method set with NSSetUncaughtExceptionHandler() , which was part of the answer in my previous question. Per Apple : The NSExceptionHandler class provides facilities for monitoring and debugging exceptional conditions in Objective-C programs. It works by installing a special uncaught exception handler via the NSSetUncaughtExceptionHandler function. Consequently, to use the services of NSExceptionHandler, you must not install your own custom uncaught exception handler. It also probably doesn't work well when you override NSApplication's -reportException: method. Lastly, there doesn't appear to be a need to use @catch/@try/@finally (also part of my previous answer). Configuring NSExceptionHandler inside +initialize appears to "kick in" immediately, unlike overriding NSApplication's -reportException: method.
