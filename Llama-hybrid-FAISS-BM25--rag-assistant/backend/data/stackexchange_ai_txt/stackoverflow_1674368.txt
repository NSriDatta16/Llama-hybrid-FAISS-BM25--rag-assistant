[site]: stackoverflow
[post_id]: 1674368
[parent_id]: 1674150
[tags]: 
There's no "NULL definiton problem" in this case. There's a problem with how you are trying to use NULL in your code. NULL cannot be portably passed to variadic functions in C/C++ by itself. You have to explicitly cast it before passing, i.e. in your case you have to pass (const char*) NULL as the terminator of the argument list. Your question is tagged as C++. In any case, regardless of size, in C++ NULL will always be defined as an integer constant. It is illegal in C++ to define NULL as a pointer. Since your function expects a pointer ( const char * ), no definition of NULL will ever work for it in C++ code. For cleaner code you can define your own constant, like const char* const STR_TERM = NULL; and use it in the calls to your function. But you will never be able to meaningfully use just NULL for that purpose. Whenever a plain NULL is passed as a variadic argument, it is a blatant portability bug that has to be fixed. Added: your update claims that "C++ standard promises NULL of 8 byte size" (on a 64-bit platform I presume). This just doesn't make any sense. C++ standard does not promise anything like that about NULL . NULL is intended to be used as an rvalue. It has no specific size and there's no valid use of NULL where its actual size might even remotely matter. Quoting from ISO/IEC 14882:1998, section 18.1 'Types', paragraph 4: The macro NULL is an implementation defined C++ null pointer constant in this International Standard (4.10). 180) 180) Possible definitions include 0 and 0L, but not (void*)0.
