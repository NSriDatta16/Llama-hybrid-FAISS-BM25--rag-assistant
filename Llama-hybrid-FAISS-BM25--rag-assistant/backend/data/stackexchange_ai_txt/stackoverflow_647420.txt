[site]: stackoverflow
[post_id]: 647420
[parent_id]: 647287
[tags]: 
I've had to overcome similar problems. Here's my solution (modified to fit your own example). We create a wrapper around Stream (a superclass of NetworkStream , which is a superclass of TcpClient or whatever). It monitors reads. When some data is read, it is buffered. When we receive a length indicator (4 bytes) we check if we have a full message (4 bytes + message body length). When we do, we raise a MessageReceived event with the message body, and remove the message from the buffer. This technique automatically handles fragmented messages and multiple-messages-per-packet situations. public class MessageStream : IMessageStream, IDisposable { public MessageStream(Stream stream) { if(stream == null) throw new ArgumentNullException("stream", "Stream must not be null"); if(!stream.CanWrite || !stream.CanRead) throw new ArgumentException("Stream must be readable and writable", "stream"); this.Stream = stream; this.readBuffer = new byte[512]; messageBuffer = new List (); stream.BeginRead(readBuffer, 0, readBuffer.Length, new AsyncCallback(ReadCallback), null); } // These belong to the ReadCallback thread only. private byte[] readBuffer; private List messageBuffer; private void ReadCallback(IAsyncResult result) { int bytesRead = Stream.EndRead(result); messageBuffer.AddRange(readBuffer.Take(bytesRead)); if(messageBuffer.Count >= 4) { int length = BitConverter.ToInt32(messageBuffer.Take(4).ToArray(), 0); // 4 bytes per int32 // Keep buffering until we get a full message. if(messageBuffer.Count >= length + 4) { messageBuffer.Skip(4); OnMessageReceived(new MessageEventArgs(messageBuffer.Take(length))); messageBuffer.Skip(length); } } // FIXME below is kinda hacky (I don't know the proper way of doing things...) // Don't bother reading again. We don't have stream access. if(disposed) return; try { Stream.BeginRead(readBuffer, 0, readBuffer.Length, new AsyncCallback(ReadCallback), null); } catch(ObjectDisposedException) { // DO NOTHING // Ends read loop. } } public Stream Stream { get; private set; } public event EventHandler MessageReceived; protected virtual void OnMessageReceived(MessageEventArgs e) { var messageReceived = MessageReceived; if(messageReceived != null) messageReceived(this, e); } public virtual void SendMessage(Message message) { // Have fun ... } // Dispose stuff here }
