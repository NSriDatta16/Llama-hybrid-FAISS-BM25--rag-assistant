[site]: stackoverflow
[post_id]: 3042488
[parent_id]: 3039960
[tags]: 
As the docs state, a boost::asio::ip::basic_endpoint is an object that: describes an endpoint for a version-independent IP socket. In this case, "endpoint" usually refers to an IP address and port. Depending on the OS and the protocol you're using, the "native" representation of the endpoint (the one used by the OS for the lower-level sockets API) may be different, so basic_endpoint serves as a wrapper for the native endpoint type. To address your question as to what size() and resize() actually do, the answer I think is "not much," other than to serve as a portable way to get the size of the underlying endpoint representation. On UNIX-like systems (sorry, I've no details for Windows :o), the underlying endpoint type is usually struct sockaddr_in for IPv4 and struct sockaddr_in6 for IPv6 (defined in netinet/in.h ). So size() would return the sizeof one of those structures, depending on how the basic_endpoint was constructed. For more info on the sockaddr family of structs, see here: http://www.retran.com/beej/sockaddr_inman.html In fact, the code for size() is surprisingly simple if you look at it (~line 180 in boost/asio/ip/basic_endpoint.hpp ). It merely calls sizeof on a typedef representing the underlying native endpoint type for the protocol of the instance. Interestingly, the resize() method seems to do pretty much nothing , other than throw an exception if the requested size is greater than the size of the underlying sockaddr_storage struct ( sockaddr_storage is a struct that contains enough storage space for either sockaddr_in or sockaddr_in6 ). It possibly exists for future use in Asio or to adapt to future protocols, since basic_endpoint is a templated class. I'm not really sure... As for why you'd want to use these methods of an endpoint object in day-to-day Asio programming, I can't really think of a reason.
