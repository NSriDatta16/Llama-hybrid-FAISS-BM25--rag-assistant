[site]: stackoverflow
[post_id]: 4574953
[parent_id]: 779379
[tags]: 
One reason to do that is to defer the execution of code to a separate, subsequent event loop. When responding to a browser event of some kind (mouse click, for example), sometimes it's necessary to perform operations only after the current event is processed. The setTimeout() facility is the simplest way to do it. edit now that it's 2015 I should note that there's also requestAnimationFrame() , which isn't exactly the same but it's sufficiently close to setTimeout(fn, 0) that it's worth mentioning. edit again now that it's 2024 I should note that there are things you can do with the Promise API, such as: Promise.resolve().then(function() { // your code here }); or, fancier: queueMicrotask(function() { // your code here }); That's not always appropriate, but it is sometimes. Personally I think that designing around subtle differences in the way timers interact is a pretty fragile thing to do. You might have to in some weird situations, but I'd say pick one you like and stick to it.
