[site]: stackoverflow
[post_id]: 1493179
[parent_id]: 1438535
[tags]: 
I would use the following approach: Create an executable that prints the current date to stdout (CMake lacks this functionality) Add a target that is always considered out of date Let the target invoke another CMake script Let the invoked CMake script generate a header file Example code for this: --- CMakeLists.txt --- PROJECT(Foo) ADD_EXECUTABLE(RetreiveDateTime ${CMAKE_CURRENT_SOURCE_DIR}/datetime.cpp) ADD_CUSTOM_TARGET(GenerateFooHeader COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_SOURCE_DIR}/Generate.cmake WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR} DEPENDS RetreiveDateTime) ADD_EXECUTABLE(Foo "test.cpp" "${CMAKE_CURRENT_BINARY_DIR}/generated.h") ADD_DEPENDENCIES(Foo GenerateFooHeader) --- Generate.cmake --- EXECUTE_PROCESS(COMMAND ${CMAKE_BINARY_DIR}/RetreiveDateTime OUTPUT_VARIABLE DATETIMESTRING) MESSAGE(STATUS "DATETIME=\"${DATETIMESTRING}\"") CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/generated.h.in ${CMAKE_CURRENT_BINARY_DIR}/generated.h @ONLY) --- generate.h.in --- #pragma once #define DATETIMESTRING "@DATETIMESTRING@" --- datetime.cpp --- #include #include #include int main(int, char*[]) { time_t now; time(&now); tm * timeinfo = localtime(&now); char * asstring = asctime(timeinfo); asstring[strlen(asstring) - 1] = '\0'; // Remove trailing \n std::cout --- test.cpp --- #include "generated.h" #include int main(int, char*[]) { std::cout This results in an header "generated.h" that is regenerated on every build. If you do not need DATETIME this example could be substantially simplified as CMake lacks this feature and a program must be built to simulate the functionality. I would however think more than twice before doing this. Remember that the header-file will be regenerated every time make is run, making your target invalid at all times. You will never have a binary that is considered up-to-date.
