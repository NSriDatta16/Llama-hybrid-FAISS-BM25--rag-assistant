[site]: stackoverflow
[post_id]: 1515366
[parent_id]: 1515068
[tags]: 
As groundhog points out, the IORegistry is indeed the go-to source for all things device-related. The IOKit docs are very detailed and helpful; you should start with IOKit Fundamentals , then hit Accessing Hardware from Applications , then finally check out Device File Access Guide for Storage Devices if you want to get at information the BSD way. In this case, you can make the Disk Arbitration framework do some of the heavy lifting of querying the IO registry and registering for notifications. This saves a lot of code, but to do everything you want to do, you'll eventually need to use IOKit functions with the underlying IOMedia object (see DADiskCopyIOMedia() ). You could readily write a Cocoa wrapper around the IOMedia objects that represent the disks in the IO registry, then use object controllers to bind properties to your UI. Here's an example of registering for disk appearance notifications through the Disk Arbitration framework to get you started: // gcc -Wall -framework Foundation -framework DiskArbitration disk_arbiter.m -o disk_arbiter /* @file disk_arbiter.m * @author Jeremy W. Sherman * @date 2009-10-03 * * Demonstrates registering for disk appeared notifications from * the DiskArbitration framework. * * Note that disk appeared notifications are delivered for all * already-appeared disks at the time of registration, and then * trickle in as the events actually happen thereafter. */ #import #import #import sig_atomic_t sShouldExit = 0; static void RegisterInterruptHandler(void); static void HandleInterrupt(int); static void OnDiskAppeared(DADiskRef disk, void *__attribute__((__unused__))); int main(void) { CFStringRef const kDARunLoopMode = kCFRunLoopDefaultMode; RegisterInterruptHandler(); // Set up session. DASessionRef session = DASessionCreate(kCFAllocatorDefault); DARegisterDiskAppearedCallback(session, NULL/*all disks*/, OnDiskAppeared, (void *)NULL); DASessionScheduleWithRunLoop(session, CFRunLoopGetCurrent(), kDARunLoopMode); // Run event loop. printf("Starting...\n(Press Ctrl-C to exit.)\n\n"); const Boolean kAndReturnAfterHandlingSource = TRUE; const CFTimeInterval kForOneSecond = 1.0; while (!sShouldExit) (void)CFRunLoopRunInMode(kCFRunLoopDefaultMode, kForOneSecond, kAndReturnAfterHandlingSource); // Tear down and exit. printf("\nExiting...\n"); DASessionUnscheduleFromRunLoop(session, CFRunLoopGetCurrent(), kDARunLoopMode); CFRelease(session); exit(EXIT_SUCCESS); return EXIT_SUCCESS; } static void RegisterInterruptHandler(void) { struct sigaction sigact; sigact.sa_handler = HandleInterrupt; (void)sigaction(SIGINT, &sigact, NULL/*discard previous handler*/); } static void HandleInterrupt(int __attribute__((__unused__)) signo) { sShouldExit = 1; RegisterInterruptHandler(); } static void OnDiskAppeared(DADiskRef disk, void *__attribute__((__unused__)) ctx) { printf("Lo, a disk appears!\n"); CFShow(disk); } And here's output from a sample run: $ ./disk_arbiter Starting... (Press Ctrl-C to exit.) Lo, a disk appears! {id = /dev/disk3} Lo, a disk appears! {id = /dev/disk2s1} Lo, a disk appears! {id = /dev/disk2s2} Lo, a disk appears! {id = /dev/disk2} Lo, a disk appears! {id = /dev/disk1} Lo, a disk appears! {id = /dev/disk1s1} Lo, a disk appears! {id = /dev/disk0} Lo, a disk appears! {id = /dev/disk0s1} Lo, a disk appears! {id = /dev/disk0s2} ^C Exiting...
