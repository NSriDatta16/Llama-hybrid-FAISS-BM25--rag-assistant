[site]: stackoverflow
[post_id]: 3515322
[parent_id]: 3513930
[tags]: 
It seems to me that you could get rid of most of the vertex grepping by keeping track of end nodes when you add them to the graph, and as you process your node list. if( @dependencies ) { for my $dependency (@dependencies) { unless ($g->has_vertex($dependency)) { $g->add_vertex($dependency); } $g->add_edge($component, $dependency); } } else { push @end_components, $component; } Then when you process your data set, start one thread of execution (however you implement your parallelism) for each end node. When a thread completes, any parent nodes without other successors are added to the end node list. Keep processing the end node list until both the graph and the node list are empty . sub run_in_parallel { my $g = shift->copy; my $end_vertices = shift; my @queue; while( $g->vertices ) { print "running ", join(", ", @queue), " in parallel\n"; for my $compenent (@queue) { # When process finished. $g->delete_vertex($component); push @queue, grep { $g->is_successorless_vertex($_) } $g->predecessors($v); } # Add some error check for non-empty graph + empty queue + no processes waiting to finish. } } This change adds a bit of record keeping, and is a tad more fragile than your initial submission. Consider encapsulating these behaviors in an object that either contains or inherits from Graph . The biggest performance benefit will be with large, deep dependency graphs. Minimal improvement will be seen with small graphs (where the cost of grepping is tiny compared to the cost of managing processes), or where the graphs are very shallow. This code is thoroughly untested.
