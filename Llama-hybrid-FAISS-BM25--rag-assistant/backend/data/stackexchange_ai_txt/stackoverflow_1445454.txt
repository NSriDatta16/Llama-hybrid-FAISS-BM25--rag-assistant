[site]: stackoverflow
[post_id]: 1445454
[parent_id]: 1445274
[tags]: 
This is covered in positively confusing detail in section 5.16 of the standard. The important part is in paragraph 3. "If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (clause 4) to the type 'reference to T2', subject to the constraint that in the conversion the reference must bind directly (8.5.3) to E1." In the expression, the only lvalue is item , so the question is whether 0 (an int) can be implicitly converted to type Foo . In this case, there is no implicit conversion of any other type to a Foo , since the only available conversion function is marked explicit . Therefore, that doesn't work, and we follow with "if E2 is an rvalue, or if the conversion above cannot be done:" (skipping the part about if they both have class type) "Otherwise (i.e., if E1 or E2 has a nonclass type, or if they both have class types but the underlying classes are not either the same or one a base class of the other): E1 can be converted to match E1 if E1 can be implicitly converted to the type that expression E2 would have if E2 were converted to an rvalue (or the type it has, if E2 is an rvalue)." Therefore, we see that 0 is an rvalue, of type int . We can convert a Foo , since we can implicitly convert a Foo to a double and thence to an int . Then: "Using this process, it is determined whether the second operand can be converted to match the third operand, and whether the third operand can be converted to match the second operand. If both can be converted, oor one can be converted but the conversion is ambiguous, the program is ill-formed. If neither can be converted, the operands are left unchanged and further checking is performed as described below. If exactly one conversion is possible, that conversion is applied to the chosen operand and the converted operand is used in the place of the original operand for the remainder of this section." Since we can convert a Foo to an int , we convert the Foo to an int for the remainder of the determination. We've now got two int s as expression types, and at least one is an rvalue. I can go on with paragraph 5 and 6, but I think it's pretty obvious that the expression has type int . I think the takeaways are: Your compiler is functioning according to the standard. The rules on the type of a conditional expression are too complicated to be easily learned. Don't push the envelope, because you'll make a mistake sometime. (Besides, this is exactly the sort of place where a compiler might fail to implement the standard precisely.) Try to specify types so that both the second and third expression are of the same type. In any case, try to avoid expressions that are not of the desired type.
