[site]: stackoverflow
[post_id]: 1791401
[parent_id]: 1788267
[tags]: 
Looking at your sample code, your Chart class is tightly coupled to the ChartCalculation class (it's instantiating a new instance of it). If the Chart class uses the ChartCalculation through an interface (IChartCalculation in my sample code) you can remove this coupling. The concrete implementation of IChartCalculation used by the Chart class could be passed to the Chart class by it's constructor ( dependency injection ), perhaps by a factory class . An alternative might be to use an IOC framework (though often this may introduce more complexity than necessary). In this way the Chart class can use different concrete implementations of IChartCalculation and both can vary independently as long as they are coded to/implement the interface. class ChartProgram () { int lastItems []; void main () { lastItems = getLast10ItemsSold(); Chart myChart = new Chart(lastItems, new ChartCalculations()); } class Chart { int[] lastItems; IChartCalculation chartCalculations; public Chart(int[] lastItems, IChartCalculations cc) { this.lastItems = lastItems; chartCalculations = cc; int average = cc.GetAverage(lastItems); } } interface IChartCalculation { int GetAverage(int[] lastItems); } class ChartCalculation : IChartCalculation { public int GetAverage(int[] lastItems) { // do stuff here } }
