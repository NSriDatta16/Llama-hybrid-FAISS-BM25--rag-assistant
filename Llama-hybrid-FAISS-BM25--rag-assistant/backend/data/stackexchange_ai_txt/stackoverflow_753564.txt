[site]: stackoverflow
[post_id]: 753564
[parent_id]: 
[tags]: 
Templated namespaces and typedefs are illeagal -- workarounds?

I have a templated function fct that uses some complex data structure based on the template parameter. It also calls some helper functions (templated on the same type) that are in a separate helpers namespace and use the same complex data structure. Now it gets really ugly because we cannot make one typedef for the complex type that all functions can access: namespace helpers { template void h1(const std::vector > > >& bar){ // ... } } template void fct(const std::vector > > >& bar){ // ... helpers::h1(bar); } Now I want to make it prettier, by using one typedef that all functions can use. A templated typedef would be nice, but it's not allowed: template typedef std::vector > > > Bar; Another solution would be, I think, to wrap all these functions in a templated namespace , but that's not allowed in C++ either (I heard it will be in `C++0x' ...). We have of course templated classes, but note that I don't really want the user to have to construct an object and call member functions on it. So the workaround I ended up using was to use a templated class where all member functions are static : template class All { typedef std::vector > > > Bar; static void fct(const Bar& bar){ // ... h1(bar); } private: static void h1(const Bar& bar){ // ... } }; My question is: It's probably a bit funny if large parts of my code are organized like that? After all it's a bit unusual to have many classes with just static member functions? Are there other solutions/workaround that make the "templated typedef" / "templated namespace" possible?
