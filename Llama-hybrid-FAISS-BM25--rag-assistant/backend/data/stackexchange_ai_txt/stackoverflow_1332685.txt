[site]: stackoverflow
[post_id]: 1332685
[parent_id]: 
[tags]: 
Draw using mouse drag event in JOGL.

Well Guess I could need some help here. I'm new to JOGL, and I am trying to draw on the 3d canvas perhaps just anything, but the point is to use mouse drag events. Any idea how am I be able to do that? I try something as below but it did not worked out. And also in the below codes, I do not understand why the display() method is being invoked event before it was being called. Thanks alot in advance.. package Testing.Drawing; import java.awt.event.*; import java.awt.*; import javax.swing.JFrame; import javax.media.opengl.*; import javax.media.opengl.glu.*; import com.sun.j3d.utils.applet.MainFrame; import com.sun.j3d.utils.universe.*; public class TestDraw2 extends JFrame implements GLEventListener, KeyListener,MouseListener, MouseMotionListener { private GLCapabilities caps; private GLCanvas canvas; private float rotAngle = 0f; private boolean rotate = false; public TestDraw2() { super("TestDraw2"); caps = new GLCapabilities(); canvas = new GLCanvas(caps); canvas.addGLEventListener(this); canvas.addKeyListener(this); // canvas.addMouseListener(this); //canvas.addMouseMotionListener(this); setVisible(true); //this.getContentPane().add(canvas); } public void run() { setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(512, 512); setLocationRelativeTo(null); this.getContentPane().add(canvas); canvas.requestFocusInWindow(); } float mouse_x = 0.0f; float mouse_y = 0.0f; public static void main(String[] args) { new TestDraw2().run(); } final double PI = Math.PI; final double PI_2 = PI / 2; final double sin(double i) { return Math.sin(i); } final double cos(double i) { return Math.cos(i); } public void init(GLAutoDrawable drawable) { GL gl = drawable.getGL(); drawable.addKeyListener(this); drawable.addMouseListener(this); drawable.addMouseMotionListener(this); // float values[] = new float[2]; gl.glGetFloatv(GL.GL_LINE_WIDTH_GRANULARITY, values, 0); System.out.println("GL.GL_LINE_WIDTH_GRANULARITY value is " + values[0]); gl.glGetFloatv(GL.GL_LINE_WIDTH_RANGE, values, 0); System.out.println("GL.GL_LINE_WIDTH_RANGE values are " + values[0] + ", " + values[1]); gl.glEnable(GL.GL_LINE_SMOOTH); gl.glEnable(GL.GL_BLEND); gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA); gl.glHint(GL.GL_LINE_SMOOTH_HINT, GL.GL_DONT_CARE); gl.glLineWidth(1.5f); gl.glClearColor(0.0f, 0.0f, 0.0f, 0.0f); } public void display(GLAutoDrawable drawable) { //draw(drawable); /*GL gl = drawable.getGL(); gl.glClear(GL.GL_COLOR_BUFFER_BIT); gl.glColor3f(0.0f, 1.0f, 0.0f); gl.glPushMatrix(); gl.glRotatef(-rotAngle, 0.0f, 0.0f, 0.1f); gl.glBegin(GL.GL_LINES); gl.glVertex2f(-0.5f, 0.5f); gl.glVertex2f(0.5f, -0.5f); gl.glEnd(); gl.glPopMatrix(); gl.glColor3f(0.0f, 0.0f, 1.0f); gl.glPushMatrix(); gl.glRotatef(rotAngle, 0.0f, 0.0f, 0.1f); gl.glBegin(GL.GL_LINES); gl.glVertex2f(0.5f, 0.5f); gl.glVertex2f(-0.5f, -0.5f); gl.glEnd(); gl.glPopMatrix(); gl.glFlush(); if (rotate) rotAngle += 1f; if (rotAngle >= 360f) rotAngle = 0f;*/ GL gl = drawable.getGL(); //gl.glClear(GL.GL_COLOR_BUFFER_BIT); gl.glColor3f(0.0f, 1.0f, 0.0f); gl.glPushMatrix(); //gl.glRotatef(-rotAngle, 0.0f, 0.0f, 0.1f) gl.glTranslatef(mouse_x, mouse_y,0.1f); // gl.glRasterPos2f(mouse_x, mouse_y); //gl.glDrawPixels(gl.GL_CURRENT_RASTER_POSITION); gl.glBegin(GL.GL_POINTS); System.out.println("start values of x,y are: "+mouse_x+", "+mouse_y); gl.glVertex2f(mouse_x, mouse_y); //gl.glVertex2f(0.5f, -0.5f); gl.glEnd(); gl.glPopMatrix(); gl.glFlush(); } public void draw(){ canvas.display(); } public void reshape(GLAutoDrawable drawable, int x, int y, int w, int h) { GL gl = drawable.getGL(); GLU glu = new GLU(); gl.glViewport(0, 0, w, h); gl.glMatrixMode(GL.GL_PROJECTION); gl.glLoadIdentity(); if (w PI) { camera_yaw -= 2.0 * PI; } else if (camera_yaw PI_2) { camera_pitch = PI_2; } else if (camera_pitch PI) { scene_yaw -= 2.0 * PI; } else if (scene_yaw PI) { scene_pitch -= 2.0 * PI; } else if (scene_pitch
