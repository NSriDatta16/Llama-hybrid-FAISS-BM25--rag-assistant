[site]: stackoverflow
[post_id]: 1810436
[parent_id]: 1810043
[tags]: 
You tried to apply multi-texturing ? It does not show in your code. You do need to use it. One texture unit for the shadow texture, one for your diffuse map. If you tried, you should show the code with multi-texturing. Multi-texturing is handled through glActiveTexture (and for fixed function that you seem to be using, glClientActiveTexture to handle the texture coordinates specifications). Some pieces of advice: it's easier to understand exactly what you're doing if you use shaders. you want to map the depth texture to the texture unit 1: the setup of the texture unit for shadow mapping needs to be preceded by a glActiveTexture(GL_TEXTURE1) -- the BindTexture, the TexGen, and the texturing related Enable/Disable. Of course, you need to switch back to the texture unit 0 for the rest. you don't want any texturing when you draw to the depth map. It is faster to draw directly to the texture with the framebuffer_object extension, than to copy to it Hope this helps. Edit: Since you've changed quite a bit your question, let me add some pieces of advice and answers to your comments: A single texture unit will always fetch from a single texture object. You use glActiveTexture followed by glBindTexture to specify which texture will be fetched from on that texture unit. Note that to get any texturing on that unit, you still need to call glEnable(GL_TEXTURE_2D) for that unit. What to apply first... Well, this is where using shaders simplifies quite a lot the discussion. In general, the order of application completely depends on what fragment math you want to end up with. Let's put the following nomenclature: T_0 the result of the first texture fetch, T_1 the result of the second texture fetch. C_f The input color that OpenGL computed and rasterized for this fragment (You're using the fixed function lighting, that's what I'm talking about) C_o The final color of the fragment T_s the result of the shadow texture fetch, T_d the result of the diffuse texture fetch. The result you'll get, with 2 texture units enabled, is something like C_o = TexEnv1(TexEnv0(C_f,T_0), T_1) The result you want is likely C_o = C_f * T_s * T_d What does that tell us ? to implement the multiplications, you want modulate as your TexEnv for both texture unit 0 and texture unit 1 the order does not matter in this case (this is because the multiplication -aka modulation- is commutative) what I showed is pretty much shader code. A lot easier to read than TexEnv settings. Now to get back to your problem... At this point, I hope you understand what OpenGL state you should have come draw time. However, trying to know exactly what state you actually have from reading your code is a perilous exercise at best. If you are serious about using OpenGL, I recommend either of the following: use an OpenGL debugger. There are a number of tools out there that will show the exact state at a specific draw call. build your own debugging state tracking dump the OpenGL state of interest at the time of the draw. OpenGL provides getter methods for every bit of its state (or almost, I won't go into the dirtiest details here), You want to do that only for debugging purposes, Getters are not guaranteed to be efficient at all).
