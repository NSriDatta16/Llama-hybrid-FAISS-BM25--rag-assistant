[site]: stackoverflow
[post_id]: 5083525
[parent_id]: 5083367
[tags]: 
This seems like you have decided on the way you want to do the task and have created more complicated issues along the way. You started out fine by suggesting that you would create an interface that all of your objects would implement. But grouping them all in one static class is where things start to fall apart. A better organization would be to let each measurement class implement its calculate method. This way, when you are dealing with Foos, you don't have to go to one big class that has code that relates to Foos, Bars, Bizzes and Bazzes. You said you could have at least 100 classes, this will make your static class hard to work with in the first place. It is likely that you may not need that many implementations of calculate. You will be able to achieve this by building up a inheritance hierarchy which will further sub-divide and organize your code. public interface Measurable { T calculate(); } public class Foo implements Measurable { private int a; private int b; @Override Integer calculate() { return a + b; } } public class Foo implements Measurable { private double a; private double b; @Override Integer calculate() { return a / b; } } You have more information about what you are actually looking for, but that is a basic template that should provide a good example and show how you can make things flexible.
