[site]: stackoverflow
[post_id]: 3589652
[parent_id]: 3585728
[tags]: 
I know you've already accepted an answer, but you've got some serious problems with your code. Put your object definitions in files ending in .pm not .pl use modules instead of do ing libraries. Indirect object notation can lead to bugs, it is best to avoid using it. I took the liberty of rewriting your code with the small changes needed to fix the issues. First in MyTest.pm : package MyTest; # Changed name to avoid name conflicts. use strict; # Always use warnings; sub new { my $class = shift; # Removed parens on $class, they put the assignment of shift's # result into list context (which had no effect on the result, # but it is also unnecessary). my %defaults = ( attr => 'asdfa' ); my %args = %defaults, @_; # Assigns arguments and default values to %args, actual named # args will override keys in defaults where they match; my $self = {}; bless $self, $class; while( my ($attr, $value) = each %args ) { $self->$attr($value); # Initialize each attribute in named arg hash. } return $self; } sub attr { my $self = shift; if( @_ ) { $self->{_attr} = shift; } return $self->{attr} } sub log { my $self = shift; # Get invocant print "Accessed via class: ", $self->attr, "\n"; } process.pl #!/usr/bin/perl use strict; use warnings; use diagnostics; use MyTest; my $test = MyTest->new(); # Direct call of object constructor $test->log; print "Accessed via main: $test->{_attr}\n"; # Violating encapsulation # is generally a bad idea. If you are doing heavy OOP, consider learning to use Moose . Moose is a powerful, ultra-modern object system for Perl that adds powerful capabilities and reduces boilerplate code. If you want to learn "classical" Perl OOP, the tutorials in the perldoc ( perlboot , perltoot , perlobj , perlbot and perltooc ) are pretty good. If you want to get really deep into it, Damian Conway's Object Oriented Perl is a fantastic book.
