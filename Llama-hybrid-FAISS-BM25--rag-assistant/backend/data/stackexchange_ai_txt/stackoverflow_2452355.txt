[site]: stackoverflow
[post_id]: 2452355
[parent_id]: 2452336
[tags]: 
The XOR swap algorithm only makes sense when you have two pointers to mutable objects. a and b are two references to immutable ints. EDIT (moving from comments as requested, and expanding): Python integers are immutable. So every time you "modify" one using XOR, new storage will be allocated (or reused, e.g. for interning). This is fundamentally different from (e.g. C), where swap changes the value without allocating new memory. Put another way, XOR swap does not create new objects in either the C99 sense ("region of data storage in the execution environment, the contents of which can represent values") or the Python sense. As noted here , a true XOR swap can "exchange the values of the variables a and b without using extra space for a temporary variable." Or empirically: >>> x = 3 >>> y = 5 >>> print "x: ", x, ", id(x): ", id(x), "y: ", y, ", id(y): ", id(y) x: 3 , id(x): 137452872 y: 5 , id(y): 137452848 >>> x ^= y >>> print "x: ", x, ", id(x): ", id(x), "y: ", y, ", id(y): ", id(y) x: 6 , id(x): 137452836 y: 5 , id(y): 137452848 >>> y ^= x >>> print "x: ", x, ", id(x): ", id(x), "y: ", y, ", id(y): ", id(y) x: 6 , id(x): 137452836 y: 3 , id(y): 137452872 >>> x ^= y >>> print "x: ", x, ", id(x): ", id(x), "y: ", y, ", id(y): ", id(y) x: 5 , id(x): 137452848 y: 3 , id(y): 137452872 In this case, we see that the interpreter (2.6.4) seems to be interning the integers , so x ends up with the memory address y originally had. But the main point is that the swap requires at least one allocation (137452836), and x and y don't retain the same memory address throughout. In C: int x = 3; int y = 5; printf("x: %d, &x: %p, y: %d, &y: %p\n", x, &x, y, &y); x ^= y; printf("x: %d, &x: %p, y: %d, &y: %p\n", x, &x, y, &y); y ^= x; printf("x: %d, &x: %p, y: %d, &y: %p\n", x, &x, y, &y); x ^= y; printf("x: %d, &x: %p, y: %d, &y: %p\n", x, &x, y, &y); gives: x: 3, &x: 0xbfd433ec, y: 5, &y: 0xbfd433e8 x: 6, &x: 0xbfd433ec, y: 5, &y: 0xbfd433e8 x: 6, &x: 0xbfd433ec, y: 3, &y: 0xbfd433e8 x: 5, &x: 0xbfd433ec, y: 3, &y: 0xbfd433e8 This is a real XOR swap, so x and y always maintain the same memory locations and there is no temporary.
