[site]: datascience
[post_id]: 22689
[parent_id]: 22679
[tags]: 
This can be done with packages from the dplyr which is part of the tidyverse made by Hadley Wickham. The stringr package (also made by Hadley) is really helpfull in working with vectors of strings. Another package purrr is helpfull for applying functions t lists. First, lets import the libraries and create data: library(tidyverse) library(stringr) df = tibble( medium = c("organic", "(none) > referral > referral > (none) > (none) > referral", "(none)", "organic > referral > referral", "referral > referral > referral > referral", "organic > referral > referral > (none) > referral"), conversion = c("0", "0,0,0,0,0,0", "0", "0,1,0", "0,0,1,0", "0,1,0,1,0") ) You probably have the data as strings while a list represention would be much easier to work with. The following code converts the strings to lists by splitting on ">" or "," (resp. for medium and conversion). Also read upon the %>% which is really handy for working with data frames. After converting the strings to lists the conversion column can be made boolean by mapping the == operator on each row. df % mutate(medium = str_split(medium, ">"), conversion = str_split(conversion, ","), conversion = map(conversion, `==`, "1")) Removing the items after the first conversion is now a matter of simple indexing. A little magic is done with dplyr::lag and cumsum to get a boolean list that indicates all the steps before and during conversion. Then map is used to get (using the [ operator) all the mediums by boolean indexing with no_conversion_yet . df % mutate(no_conversion_yet = map(conversion, function(x) dplyr::lag(cumsum(x) % mutate(medium = map(no_conversion_yet, medium, `[`)) Filtering the rows that do not have a conversion is now easy. Simple remove all the rows that do not have any TRUE value in the conversion column. df % mutate(any_conversion = map_lgl(conversion, any)) %>% filter(any_conversion) Voila, life made easy by the superb packages of Hadley Wickham! (Also check his paper .)
