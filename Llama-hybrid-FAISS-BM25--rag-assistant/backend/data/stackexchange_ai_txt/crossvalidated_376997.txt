[site]: crossvalidated
[post_id]: 376997
[parent_id]: 376464
[tags]: 
I got the solution by adding a cropping layer in the end. The full code is as below: from keras.layers import Input, Dense, Conv2D, MaxPooling2D, UpSampling2D from keras.models import Model # from keras import backend as K input_img = Input(shape=(91, 91, 1)) # adapt this if using `channels_first` image data format x = Conv2D(16, (3, 3), activation='relu', padding='same')(input_img) x = MaxPooling2D((2, 2), padding='same')(x) x = Conv2D(8, (3, 3), activation='relu', padding='same')(x) x = MaxPooling2D((2, 2), padding='same')(x) x = Conv2D(8, (3, 3), activation='relu', padding='same')(x) encoded = MaxPooling2D((2, 2), padding='same')(x) # at this point the representation is (4, 4, 8) i.e. 128-dimensional x = Conv2D(8, (3, 3), activation='relu', padding='same')(encoded) x = UpSampling2D((2, 2))(x) x = Conv2D(8, (3, 3), activation='relu', padding='same')(x) x = UpSampling2D((2, 2))(x) x = Conv2D(16, (3, 3), activation='relu')(x) x = UpSampling2D((2, 2))(x) x = Conv2D(1, (3, 3), activation='sigmoid', padding='same')(x) decoded = Cropping2D(cropping=((1, 0), (1, 0)), data_format=None)(x) # this is the added step autoencoder = Model(input_img, decoded) autoencoder.compile(optimizer='adadelta', loss='binary_crossentropy')
