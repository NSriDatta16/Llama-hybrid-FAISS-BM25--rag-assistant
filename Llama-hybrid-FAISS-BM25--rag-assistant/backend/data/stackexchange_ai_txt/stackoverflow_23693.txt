[site]: stackoverflow
[post_id]: 23693
[parent_id]: 23277
[tags]: 
Basically the two styles, are like Yin and Yang. One is organized, while the other chaotic. There are situations when Functional programming is the obvious choice, and other situations were Procedural programming is the better choice. This is why there are at least two languages that have recently come out with a new version, that embraces both programming styles. ( Perl 6 and D 2 ) Procedural: The output of a routine does not always have a direct correlation with the input. Everything is done in a specific order. Execution of a routine may have side effects. Tends to emphasize implementing solutions in a linear fashion. Perl 6 sub factorial ( UInt:D $n is copy ) returns UInt { # modify "outside" state state $call-count++; # in this case it is rather pointless as # it can't even be accessed from outside my $result = 1; loop ( ; $n > 0 ; $n-- ){ $result *= $n; } return $result; } D 2 int factorial( int n ){ int result = 1; for( ; n > 0 ; n-- ){ result *= n; } return result; } Functional: Often recursive. Always returns the same output for a given input. Order of evaluation is usually undefined. Must be stateless. i.e. No operation can have side effects. Good fit for parallel execution Tends to emphasize a divide and conquer approach. May have the feature of Lazy Evaluation. Haskell ( copied from Wikipedia ); fac :: Integer -> Integer fac 0 = 1 fac n | n > 0 = n * fac (n-1) or in one line: fac n = if n > 0 then n * fac (n-1) else 1 Perl 6 proto sub factorial ( UInt:D $n ) returns UInt {*} multi sub factorial ( 0 ) { 1 } multi sub factorial ( $n ) { $n * samewith $n-1 } # { $n * factorial $n-1 } D 2 pure int factorial( invariant int n ){ if( n Side note: Factorial is actually a common example to show how easy it is to create new operators in Perl 6 the same way you would create a subroutine. This feature is so ingrained into Perl 6 that most operators in the Rakudo implementation are defined this way. It also allows you to add your own multi candidates to existing operators. sub postfix: ( UInt:D $n --> UInt ) is tighter(&infix: ) { [*] 2 .. $n } say 5!; # 120␤ This example also shows range creation ( 2..$n ) and the list reduction meta-operator ( [ OPERATOR ] LIST ) combined with the numeric infix multiplication operator. ( * ) It also shows that you can put --> UInt in the signature instead of returns UInt after it. ( You can get away with starting the range with 2 as the multiply "operator" will return 1 when called without any arguments )
