[site]: stackoverflow
[post_id]: 4897207
[parent_id]: 
[tags]: 
How drop GEF editors figures in the outside world?

After long investigations and reading this question I still didn't get a "good" solution for my problem. I have a Gef editor and I want to let the users drag and drop figures (== model objects) form this editor to an other custom view available in my perspective. Adding a DragSource with my own drag transfer on my GEF editor figure canvas allows that. But as a side effect, and I don't want this side effect, this disable the possibility to move the figures INSIDE the editor using drag and drop. After investigations I found this post on eclipse forums , but the solution is not acceptable for me. Thus I investigated deeper and came to the following pure SWT snippet that shows that MouseMove events (the ones used by gef to support dragging INSIDE the editor) are no more fired once a drag source has been added: import org.eclipse.swt.dnd.DND; import org.eclipse.swt.dnd.DragSource; import org.eclipse.swt.dnd.DragSourceEvent; import org.eclipse.swt.dnd.DragSourceListener; import org.eclipse.swt.dnd.FileTransfer; import org.eclipse.swt.dnd.Transfer; import org.eclipse.swt.events.MouseEvent; import org.eclipse.swt.events.MouseListener; import org.eclipse.swt.events.MouseMoveListener; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; public class SwtTest { public static void main(String[] args) { final Display display = new Display(); final Shell shell = new Shell(display); shell.addMouseListener(new MouseListener() { public void mouseUp(MouseEvent e) { System.out.println("mouseUp"); } public void mouseDown(MouseEvent e) { System.out.println("mouseDown"); } public void mouseDoubleClick(MouseEvent e) { System.out.println("mouseDoubleClick"); } }); shell.addMouseMoveListener(new MouseMoveListener() { @Override public void mouseMove(MouseEvent e) { System.out.println("Mouse move"); } }); DragSourceListener dragListener = new DragSourceListener() { public void dragFinished(DragSourceEvent event) { System.out.println("dragFinished"); } public void dragSetData(DragSourceEvent event) { System.out.println("dragSetData"); } public void dragStart(DragSourceEvent event) { System.out.println("dragStart"); } }; DragSource dragSource = new DragSource(shell, DND.DROP_COPY | DND.DROP_MOVE); dragSource.addDragListener(dragListener); dragSource.setTransfer(new Transfer[] { FileTransfer.getInstance() }); shell.pack(); shell.open(); while (!shell.isDisposed()) { if (!display.readAndDispatch()) display.sleep(); } display.dispose(); } } I guess this is the normal behavior fro man SWT point of view. Do you confirm ? Moreover, I am really looking for a solution to this issue other that the one proposed on Eclipse forum consisting in activating my DragSource only if a given condition is met such as Shift is pressed (this is done in a DragSourceListener.dragStart method by setting event.doit to false) Any help, suggestions and comments are welcome. Thanks in advance, Manu
