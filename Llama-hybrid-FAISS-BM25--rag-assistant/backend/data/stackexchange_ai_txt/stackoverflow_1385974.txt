[site]: stackoverflow
[post_id]: 1385974
[parent_id]: 1385624
[tags]: 
First, I would recommend very strongly that you try to talk your customer out of this requirement. Masked text boxes in general are a royal pain in the butt, both for the programmer and for the end user. In my opinion, if you must format user input, it is far better to format whatever they have entered after the control loses focus than to attempt to format their input while they are still typing it. With either approach, the easiest way to do this is to create your own user control (unless you want to use a third-party control, which I wouldn't advise for this purpose for a bunch of reasons) that inherits from TextBox (instead of inheriting from UserControl). If you wish to format the text after the user has finished entering input and has moved on to another control, you can add an EventHandler to your control's LostFocus event and format their input there. If, however, you wish to format as they're typing, you have a couple of grisly choices. First, you can handle the control's KeyPress or KeyDown events, and intercept-and-cancel non-numeric characters, or else format the overall Text property at this time. This is a common approach which often fails in unexpected ways, since it ends up not dealing with text that is copy-and-pasted into the control (which happens quite often in data-entry applications). An alternative approach is to handle the TextChanged event, which will respond to both keyboard input and pasted-in text, and re-format the text on the fly. Since you're often changing the text as they type, your code needs to pay attention to the SelectionStart property (among others), so that you don't unexpectedly change the caret's position as the user is typing. Also, when you change your control's text property while formatting it, this change will itself produce another TextChanged event, so you need to be careful that you don't get stuck in an endless loop. To reiterate my main point, you will be much happier formatting in the LostFocus event, and so will your end users. Once you've written your control, you can just do a global replace in your code, substituting "MyMaskedTextBox" for "TextBox" (case-sensitivity is recommended here). Update: Here is some simple parsing/formatting code you can use in your TextBox's LostFocus event: double d; TextBox tb = (TextBox)sender; if (double.TryParse(tb.Text, out d)) { tb.Text = d.ToString("#,###,###,###.0000"); tb.BackColor = SystemColors.Window; } else { tb.BackColor = Color.Red; } This code will format the user's input as a number in the way that you require if the text entered can be parsed as a double. If the input is not a valid double, the text is left as is and the BackColor is changed to red. This is a good way of indicating invalid input to the user (as opposed to popping up a MessageBox).
