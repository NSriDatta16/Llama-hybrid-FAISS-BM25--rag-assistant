[site]: stackoverflow
[post_id]: 5154103
[parent_id]: 5153775
[tags]: 
Whenever i see those if else if statements i think this must be done easier. In some cases the switch statement can help, but as this question already stated, it is not possible to switch on Type. So another workaround i commonly use is some kind of Dictionary . Where something depends on what i'd like to do. The maybe best matching construct for your case would something like Dictionary > which could be used in your case something like this: Dictionary > _FunctorsForType; private void InitializeFunctorsForType() { _FunctorsForType = new Dictionary >(); // Add a normal function _FunctorsForType.Add(typeof(ArgumentException), (Func )ForArgumentException); // Add as lambda _FunctorsForType.Add(typeof(InvalidCastException), (ex) => { // ToDo: Whatever you like return ex.Message; }); } private string ForArgumentException(Exception ex) { var argumentException = ex as ArgumentException; if (argumentException == null) { throw new ArgumentException("Exception must be of type " + typeof(ArgumentException).Name); } // ToDo: Whatever you like return ex.Message; } private void Usage(Type type) { Func func; if (!_FunctorsForType.TryGetValue(type, out func)) { throw new ArgumentOutOfRangeException("Exception type " + type.Name + " is not supported."); } var message = func(new NullReferenceException()); // ToDo: Whatever you have to do with your message } So with this construction you don't have to put all your intelligence into a big if-else statement. Instead you can put them in separate functions (maybe in different classes) to get a better organization of how to handle each type you like to support.
