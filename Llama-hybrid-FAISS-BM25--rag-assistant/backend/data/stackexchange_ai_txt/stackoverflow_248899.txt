[site]: stackoverflow
[post_id]: 248899
[parent_id]: 248031
[tags]: 
the head of the list. ( item1 Element: student1 Next ------------> ( item2 ) Element: student2 Next ------------> ( item3 ) Element: student3 Next: null ) the tail of the list. First of all, for you to be able to write the StudentList class, you need to write the client code first. Client code is the code that uses your student list. Also, don't just write one thing at a time and throw it away. Instead write a whole bunch of [test] cases that exercise the different ways you need to interact with the StudentList. Write exceptional cases too. But don't be tempted to write a swiss-army knife of a class that does everything just because it can. Write the minimal amount of code that gets the job done. How you need to use the class will heavily dictate how the class is constructed. This is the essence of TDD or Test Driven Design. Your biggest problem that I can see is you have no idea how you want to use the class. So lets do that first. // create a list of students and print them back out. StudentList list = new StudentList(); list.Add( new Student("Bob", 1234, 2, 'A') ); list.Add( new Student("Mary", 2345, 4, 'C') ); foreach( Student student in list) { Console.WriteLine(student.Name); } I add the students to the list, and then I print them out. I have no need for my client code to see inside the StudentList. Therefore StudentList hides how it implements the linked list. Let's write the basics of the StudentList. public class StudentList { private ListNode _firstElement; // always need to keep track of the head. private class ListNode { public Student Element { get; set; } public ListNode Next { get; set; } } public void Add(Student student) { /* TODO */ } } StudentList is pretty basic. Internally it keeps track of the first or head nodes. Keeping track of the first node is obviously always required. You also might wonder why ListNode is declared inside of StudentList. What happens is the ListNode class is only accessible to the StudentList class. This is done because StudentList doesn't want to give out the details to it's internal implementation because it is controlling all access to the list. StudentList never reveals how the list is implemented. Implementation hiding is an important OO concept. If we did allow client code to directly manipulate the list, there'd be no point having StudentList is the first place. Let's go ahead and implement the Add() operation. public void Add(Student student) { if (student == null) throw new ArgumentNullException("student"); // create the new element ListNode insert = new ListNode() { Element = student }; if( _firstElement == null ) { _firstElement = insert; return; } ListNode current = _firstElement; while (current.Next != null) { current = current.Next; } current.Next = insert; } The Add operation has to find the last item in the list and then puts the new ListNode at the end. Not terribly efficient though. It's currently O(N) and Adding will get slower as the list gets longer. Lets optimize this a little for inserts and rewrite the Add method. To make Add faster all we need to do is have StudentList keep track of the last element in the list. private ListNode _lastElement; // keep track of the last element: Adding is O(1) instead of O(n) public void Add(Student student) { if( student == null ) throw new ArgumentNullException("student"); // create the new element ListNode insert = new ListNode() { Element = student }; if (_firstElement == null) { _firstElement = insert; _lastElement = insert; return; } // fix up Next reference ListNode last = _lastElement; last.Next = insert; _lastElement = insert; } Now, when we add, we don't iterate. We just need to keep track of the head and tail references. Next up: the foreach loop. StudentList is a collection, and being a collection we want to enumerate over it and use C#'s foreach . The C# compiler can't iterate magically. In order to use the foreach loop We need to provide the compiler with an enumerator to use even if the code we write doesn't explicitly appear to use the enumerator. First though, lets re-visit how we iterate over a linked list. // don't add this to StudentList void IterateOverList( ListNode current ) { while (current != null) { current = current.Next; } } Okay. so let's hook into C#'s foreach loop and return an enumerator. To do that we alter StudentList to implement IEnumerable. This is getting a little bit advanced, but you should be able to figure out what's going on. // StudentList now implements IEnumerable public class StudentList : IEnumerable { // previous code omitted #region IEnumerable Members public IEnumerator GetEnumerator() { ListNode current = _firstElement; while (current != null) { yield return current.Element; current = current.Next; } } #endregion #region IEnumerable Members IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } #endregion } You should be able to spot the linked list iteration in there. Don't get thrown by the yield keyword. All yield is doing is returning the current student back to the foreach loop. The enumarator stops returning students when it gets to the end of the linked list. And that's it! The code works the way we want it to. * This is by no means the only way to implement the list. I've opted to put the list logic in the StudentList and keep ListNode very basic. But the code does only what my very first unit test needs and nothing more. There are more optimizations you could make, and there are other ways of constructing the list. Going forward: What you need to do is first create [unit] tests for what your code needs to do, then add the implementation you require. * fyi I also rewrote the Student class. Bad naming and strange casing from a C# persepctive, not to mention the code you provided doesn't compile. I prefer the _ as a leader to private member variables. Some people don't like that, however you're new to this so I'll leave them in because they're easy to spot. public class Student { private string _name; private int _id; private int _mark; private char _letterGrade; private Student() // hide default Constructor { } public Student(string name, int id, int mark, char letterGrade) // Constructor { if( string.IsNullOrEmpty(name) ) throw new ArgumentNullException("name"); if( id check parameters pay attention to the different casing of properties, classes, and variables. hide the default constructor. Why do I want to create students without real data? provide some read-only properties. This class is immutable as written (i.e. once you create a student, you can't change it).
