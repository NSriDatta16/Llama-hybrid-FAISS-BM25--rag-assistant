[site]: stackoverflow
[post_id]: 2494010
[parent_id]: 2456155
[tags]: 
One solution requires the following items: BezierLineCustomizer to make the lines curved. RunningAverageIncrementer to calculate a running average based on a variable. iReport variable that uses the RunningAverageIncremeter . BezierLineCustomizer Class public class BezierLineCustomizer implements JRChartCustomizer { public BezierLineCustomizer() { } public void customize( JFreeChart jFreeChart, JRChart jrChart ) { XYPlot xyPlot = ( XYPlot )jFreeChart.getPlot(); XYSplineRenderer splineRenderer = new XYSplineRenderer(); // Make the spline line thick and orange. // splineRenderer.setSeriesShapesVisible( 0, false ); splineRenderer.setSeriesShapesVisible( 1, false ); splineRenderer.setSeriesLinesVisible( 1, false ); splineRenderer.setSeriesStroke( 0, new BasicStroke( 4.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND, 1.0f, null, 0.0f ) ); splineRenderer.setSeriesPaint( 0, new Color( 255, 140, 0 ) ); splineRenderer.setSeriesVisibleInLegend( 1, Boolean.FALSE ); // Duplicate the data into a new dataset to control its line independently. // xyPlot.setDataset( 1, xyPlot.getDataset(0) ); XYItemRenderer defaultRenderer = new XYLineAndShapeRenderer(); defaultRenderer.setSeriesVisible( 0, Boolean.FALSE ); defaultRenderer.setSeriesVisibleInLegend( 0, Boolean.FALSE ); xyPlot.setRenderer( 1, defaultRenderer ); xyPlot.setRenderer( 0, splineRenderer ); } } RunningAverageIncrementer Class public class RunningAverageIncrementer implements JRIncrementer { /** Default number of tallies. */ private static final int DEFAULT_TALLIES = 128; /** Number of tallies within the sliding window. */ private static final int DEFAULT_SLIDING_WINDOW_SIZE = 30; /** Stores a sliding window of values. */ private List values = new ArrayList ( DEFAULT_TALLIES ); /** * Instantiated by the RunningAverageIncrementerFactory class. */ public RunningAverageIncrementer() { } /** * Calculates the average of previously known values. * @return The average of the list of values returned by getValues(). */ private double calculateAverage() { double result = 0.0; List values = getValues(); for( Double d: getValues() ) { result += d.doubleValue(); } return result / values.size(); } /** * Called each time a new value to be averaged is received. * @param value The new value to include for the average. */ private void recordValue( Double value ) { List values = getValues(); // Throw out // if( values.size() > getSlidingWindowSize() ) { values.remove( 0 ); } this.values.add( value ); } private List getValues() { return values; } private int getIterations() { return getValues().size(); } /** * Returns the newly incremented value, which is calculated by averaging * the previous value from the previous call to this method. * * @param jrFillVariable Unused. * @param tally New data point to average. * @param abstractValueProvider Unused. * @return The newly incremented value. */ public Object increment( JRFillVariable jrFillVariable, Object tally, AbstractValueProvider abstractValueProvider ) { double value = ((Number)tally).doubleValue(); recordValue( value ); double previousAverage = calculateAverage(); double newAverage = ( ( value - previousAverage ) / ( getIterations() + 1 ) ) + previousAverage; return new BigDecimal( newAverage ); } protected int getSlidingWindowSize() { return DEFAULT_SLIDING_WINDOW_SIZE; } } iReport Variable Create a variable that uses the RunningAverageIncrementerFactory class (exercise left to the reader). Set its variable expression to the plotted value. Set its initial value expression to zero. Spline Set the Customizer Class property of the TimeSeries chart to use the BezierLineCustomizer class. Result After these modifications, the running average is clearly visible:
