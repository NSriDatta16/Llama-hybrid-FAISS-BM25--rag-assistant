[site]: stackoverflow
[post_id]: 4093777
[parent_id]: 4092353
[tags]: 
The short answer AFAIK is no, that there is no other way to get at the navigation controller you are after. The medium answer is that you could override your table view controller's navigationController property to make it writable: @interface myTableViewController : UITableViewController { UINavigationController *navigationController; } @property (nonatomic, retain) UINavigationController *navigationController; That would allow you to set it to the pushed VC's navigation controller when you add its view as a subview. It will also still work as promised when you push it onto a navigation controller stack normally. The long answer is that Apple discourages what you are doing. From "About Custom View Controllers" in the View Controller Programming Guide : Note: If you want to divide a single screen into multiple areas and manage each one separately, use generic controller objects (custom objects descending from NSObject) instead of view controller objects to manage each subsection of the screen. Then use a single view controller object to manage the generic controller objects. The view controller coordinates the overall screen interactions but forwards messages as needed to the generic controller objects it manages. I have run into the problem you are describing and ended up taking an approach first suggested by Matt Gallagher on Cocoa with Love : Create a separate controller class that inherits from NSObject (instead of UIViewController) and implements UITableViewDelegate and UITableViewDataSource to manage the table view. He has sample code with his post that is extremely useful if you decide to go down this road. When I did this it largely amounted to simply changing the inheritance declaration in my custom UITableViewController subclass.
