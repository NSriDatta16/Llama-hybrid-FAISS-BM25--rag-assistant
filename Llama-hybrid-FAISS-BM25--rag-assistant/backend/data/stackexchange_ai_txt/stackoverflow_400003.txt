[site]: stackoverflow
[post_id]: 400003
[parent_id]: 399648
[tags]: 
You can implement your own storage of the delgates, and check for uniqueness when adding them to the event. See EventOwner2 class below for an example. I don't know how this is doing performance wise, but than again, that is not always an issue. using System; using System.Collections.Generic; namespace EventExperiment { class Program { static void Main(string[] args) { IEventOwner e=new EventOwner2(); Subscriber s=new Subscriber(e); e.RaiseSome(); Console.ReadKey(); } } /// /// A consumer class, subscribing twice to the event in it's constructor. /// public class Subscriber { public Subscriber(IEventOwner eventOwner) { eventOwner.SomeEvent += eventOwner_SomeEvent; eventOwner.SomeEvent += eventOwner_SomeEvent; } void eventOwner_SomeEvent(object sender, EventArgs e) { Console.WriteLine(DateTimeOffset.Now); } } /// /// This interface is not essensial to this point. it is just added for conveniance. /// public interface IEventOwner { event EventHandler SomeEvent; void RaiseSome(); } /// /// A traditional event. This is raised for each subscription. /// public class EventOwner1 : IEventOwner { public event EventHandler SomeEvent = delegate { }; public void RaiseSome() { SomeEvent(this,new EventArgs()); } } /// /// A custom event. This is raised only once for each subscriber. /// public class EventOwner2 : IEventOwner { private readonly List > handlers=new List >(); public event EventHandler SomeEvent { add { lock (handlers) if (handlers!=null&&!handlers.Contains(value)) { handlers.Add(value); } } remove { handlers.Remove(value); } } public void RaiseSome() { EventArgs args=new EventArgs(); lock(handlers) foreach (EventHandler handler in handlers) { handler(this,args); } } } }
