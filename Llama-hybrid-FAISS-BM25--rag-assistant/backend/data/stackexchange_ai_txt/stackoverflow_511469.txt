[site]: stackoverflow
[post_id]: 511469
[parent_id]: 510788
[tags]: 
If the interface in your question is a COM interface, the approach given by Quassnoi might not be sufficient. You have to pay attention to the threading-model of the COM object in use. If the secondary thread will join a separate COM apartment from the one that your COM object was created in, and if that object is not apartment-agile , you'll need to marshal that interface pointer so that the secondary thread gets a proxy, and not a direct pointer to the object. A COM object is normally made apartment-agile by using a special implementation of IMarshal. The simplest approach is to aggregate the Free Threaded Marshaler. Some useful links... CoMarshalInterThreadInterfaceInStream GlobalInterfaceTable (GIT) CoCreateFreeThreadedMarshaler Update: About the Free-threaded Marshaler... It's clear from comments on this topic that some people would recommend that you never touch the FTM. While "Effective COM" is an excellent book, I think some of its recommendations are open to interpretation. Item 33 says "Beware the FTM"; it does not say "Never use the FTM". Very wisely it advises caution particularly when your apartment-agile object holds references to other objects, because they might not be apartment-agile. So really the advice is: think carefully when building apartment-agile objects, whether or not they use the FTM to achieve their agility. If you're sure you can build an apartment-agile object, I see no reason why you wouldn't use the FTM to achieve that.
