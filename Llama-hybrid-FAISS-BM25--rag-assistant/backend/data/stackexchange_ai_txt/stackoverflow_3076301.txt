[site]: stackoverflow
[post_id]: 3076301
[parent_id]: 3076277
[tags]: 
The following is a leak: static void memeat(void) { static char *foo = NULL; foo = malloc(1024); return; } Valgrind output: ==16167== LEAK SUMMARY: ==16167== definitely lost: 4,096 bytes in 4 blocks ==16167== indirectly lost: 0 bytes in 0 blocks ==16167== possibly lost: 0 bytes in 0 blocks ==16167== still reachable: 1,024 bytes in 1 blocks ==16167== suppressed: 0 bytes in 0 blocks ==16167== Rerun with --leak-check=full to see details of leaked memory Note, still reachable (1024 bytes) is the result of the last time memeat() was entered. The static pointer still held a valid reference to the last block memeat() allocated when the program exited. Just not the previous blocks. The following is NOT a leak: static void memeat(void) { static char *foo = NULL; foo = realloc(foo, 1024); return; } Valgrind output: ==16244== LEAK SUMMARY: ==16244== definitely lost: 0 bytes in 0 blocks ==16244== indirectly lost: 0 bytes in 0 blocks ==16244== possibly lost: 0 bytes in 0 blocks ==16244== still reachable: 1,024 bytes in 1 blocks ==16244== suppressed: 0 bytes in 0 blocks ==16244== Rerun with --leak-check=full to see details of leaked memory Here, the address foo pointed to has been freed, and foo now points to the newly allocated address, and will continue to do so the next time memeat() is entered. Explanation: The static storage type says that the pointer foo will point to the same address as initialized each time the function is entered. However, if you change that address each time the function is entered via malloc() or calloc() , you've lost the reference to the blocks from the previous allocation. Hence, a leak, since either is going to return a new address. 'Still Reachable' in valgrind means that that all allocated heap blocks still have a valid pointer to access / manipulate / free them upon exit. This is similar to allocating memory in main() and not freeing it, just relying on the OS to reclaim memory. In short, yes - you have a leak. However, you can fix it rather easily. Just note that you are indeed relying on your OS to reclaim the memory unless you add another argument to your function that just tells ToHexString to call free on the static pointer, which you could use when exiting. Similar to this: (full test program) #include static void memeat(unsigned int dofree) { static char *foo = NULL; if (dofree == 1 && foo != NULL) { free(foo); return; } foo = realloc(foo, 1024); return; } int main(void) { unsigned int i; for (i = 0; i Valgrind output: ==16285== HEAP SUMMARY: ==16285== in use at exit: 0 bytes in 0 blocks ==16285== total heap usage: 6 allocs, 6 frees, 6,144 bytes allocated ==16285== ==16285== All heap blocks were freed -- no leaks are possible Note on the final output : Yes, 6144 bytes were actually allocated according to what malloc() returned while the program ran, but that just means the static pointer was freed, then reallocated according to the number of times memeat() was entered. The actual heap use of the program at any given time was actually just 2*1024, 1k to allocate the new pointer while the old one still existed waiting to be copied to the new one. Again, it should not be too hard to adjust your code, but it isn't clear to me why you are using static storage to begin with.
