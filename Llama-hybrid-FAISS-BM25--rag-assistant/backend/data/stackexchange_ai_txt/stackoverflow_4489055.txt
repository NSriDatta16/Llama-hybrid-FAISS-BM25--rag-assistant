[site]: stackoverflow
[post_id]: 4489055
[parent_id]: 4477400
[tags]: 
Code analysis engines generally require quite a lot of sophistication above and beyond just building ASTs. To do any serious code analysis, you need to know the meaning of identifiers in code and where/how they are defined ("symbol tables"), and you often need to know how information travels around the program (control and data flow analysis). You need machinery to support all of these, and then you need to tie that machinery to your proprietary language. I think of climbing Everest as an analogy. Getting ASTs is like getting to the 10,000 foot base camp. Any clod can do that by just walking up the hill using basic technology (hiking boots). Climbing the last 17,000 feet requires a whole different kind of technology, commitment, and plan, and most folks, having walked up the first 10,000 feet, are simply unprepared for the rest of the trip. (I have some experience here, check my bio). These are all pretty detailed topics and your absence of CS background is going to make the road for you likely pretty rough. (We all start somewhere, however, so this is really a matter of ambition). The Dragon book is an excellent resource that will help you understand what all this machinery does and why you need it; many other fine compiler books exist and will generally serve just as well. But you need to be prepared to do some serious reading. One way to get up the curve is to use a tool in which much of this machinery has been already thought out and implemented for you, by a bunch of computer scientists experienced at building such tools. Then your problem is considerably reduced: you only need to learn how to use what they provided, rather than trying to figure out what you need (most folks never get past the AST stage) and implement all the necessary support machinery. ANTLR (already mentioned, done by a pretty good CS professor) is sort of one, in that it provides parsing capabilities, enables you to define how ASTs are built, and how to climb over the resulting ASTs procedurally. But it doesn't provide much else you need for your task. Our DMS Software Reengineering Toolkit provides all the facilities I mentioned in the first paragraph, and then some. One of the first differences you will notice working with DMS is that you only need to provide it grammar; it will builds ASTs without any further help from you. You can get a flavor of what working with DMS is like, at this example of DMS applied to high school algebra and calculus . In particular, it shows how using just a simple grammar for algebra/calculus can be easily defined, and then "programs" in that language can be manipulated. This application is one that "transforms" code rather than analyzes it, but the basics are the same. A "real" DMS application that analyzed your proprietary langauge will be considerably more complex.
