[site]: stackoverflow
[post_id]: 4416204
[parent_id]: 4216139
[tags]: 
Do not try to implement drag and drop by reparenting the underlying python object. This won't work if the drag comes from outside your process; nor will it work for a copy operation (your node objects probably cannot exist in multiple places in the tree). Think of a drag and drop "move" as three operations: serialize the data to some byte string deserialize into a new index (or new indexes) (optional: if "move" rather than "copy") remove the old index(es) mineData() and dropMimeData() are the serialize and deserialize operations that you provide. Python provides some easy ways to implement them -- check the documentation for the pickle module. If you're lucky, pickle.dumps() and pickle.loads() will work out-of-the-box for you. Edit: I couldn't figure out how to paste code in comments, so here's the solution my comment refers to. This is safe, in the sense that it will fail by throwing a KeyError instead of causing crashes if you happen to break your rules. # drag: store off the data in a safe place, and serialize a cooky # that the drop target can use to retrieve the data. self.__tmp_storage_dct = { self.__tmp_storage_cooky: stuff } m.setData(self.rowlistptr_mime_type, QByteArray(pickle.dumps(self.__tmp_storage_cooky))) self.__tmp_storage_cooky += 1 # drop: if mime.hasFormat(self.rowlistptr_mime_type): print "got tmpstorage" cooky = pickle.loads(mime.data(self.rowlistptr_mime_type).data()) nodes = self.__tmp_storage_dct.pop(cooky)
