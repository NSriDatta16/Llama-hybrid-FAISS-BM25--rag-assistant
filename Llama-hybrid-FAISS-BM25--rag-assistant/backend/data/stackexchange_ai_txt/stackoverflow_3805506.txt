[site]: stackoverflow
[post_id]: 3805506
[parent_id]: 3805159
[tags]: 
While this problem appears simple on the surface, it's actually more complicated than it looks. However, by recognizing that visiting every position in a multidimensional (or even jagged) array is a Cartesian product operation on the set of indexes of the array - we can simplify the solution ... and ultimately write a more elegant solution. We're going to leverage Eric Lippert's LINQ Cartesian Product implementation to do the heavy lifting. You can read more about how that works on his blog if you like. While this implementation is specific to visiting the cells of a multidimensional array - it should be relatively easy to see how to extend it to visit a jagged array as well. public static class EnumerableExt { // Eric Lippert's Cartesian Product operator... public static IEnumerable > CartesianProduct ( this IEnumerable > sequences) { IEnumerable > emptyProduct = new[] { Enumerable.Empty () }; return sequences.Aggregate( emptyProduct, (accumulator, sequence) => from accseq in accumulator from item in sequence select accseq.Concat(new[] { item })); } } class MDFill { public static void Main() { // create an arbitrary multidimensional array Array mdArray = new int[2,3,4,5]; // create a sequences of sequences representing all of the possible // index positions of each dimension within the MD-array var dimensionBounds = Enumerable.Range(0, mdArray.Rank) .Select(x => Enumerable.Range(mdArray.GetLowerBound(x), mdArray.GetUpperBound(x) - mdArray.GetLowerBound(x)+1)); // use the cartesian product to visit every permutation of indexes // in the MD array and set each position to a specific value... int someValue = 100; foreach( var indexSet in dimensionBounds.CartesianProduct() ) { mdArray.SetValue( someValue, indexSet.ToArray() ); } } } It's now trivial to factor this code out into a reusable method that can be used for either jagged or multidimensional arrays ... or any data structure that can be viewed as a rectangular array.
