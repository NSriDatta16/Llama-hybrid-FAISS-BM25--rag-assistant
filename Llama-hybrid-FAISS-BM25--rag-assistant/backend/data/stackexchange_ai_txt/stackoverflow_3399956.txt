[site]: stackoverflow
[post_id]: 3399956
[parent_id]: 
[tags]: 
Pattern Matching, F# vs Erlang

In Erlang, you are encouraged not to match patterns that you do not actually handle. For example: case (anint rem 10) of 1 -> {ok, 10} 9 -> {ok, 25} end; is a style that is encouraged, with other possible results resulting in a badmatch result. This is consistant with the "let it crash" philosophy in Erlang. On the other hand, F# would issue an "incomplete pattern matching" in the equivalent F# code, like here . The question: why wouldn't F# remove the warning, effectively by augmenting every pattern matching with a statement equivalent to |_ -> failwith "badmatch" and use the "let it crash" philosophy? Edit : Two interesting answers so far: either to avoid bugs that are likely when not handling all cases of an algebraic datatype; or because of the .Net platform. One way to find out which is to check OCaml. So, what is the default behaviour in OCaml? Edit : To remove misunderstanding by .Net people who have no background in Erlang. The point of the Erlang philosophy is not to produce bad code that always crashes. Let it crash means let some other process fix the error . Instead of writing the function so that it can handle all possible cases, let the caller (for example) handle the bad cases which are thrown automatically. For those with Java background, it is like the difference between having a language with checked exceptions which must declare everything it will possibly return with every possible exception, and having a language in which functions may raise exceptions that are not explicitly declared.
