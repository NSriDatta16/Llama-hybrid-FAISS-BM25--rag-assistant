[site]: stackoverflow
[post_id]: 1755582
[parent_id]: 1729705
[tags]: 
OK I think i know the problem: the ei.lib uses TLS (Thread Local Storage). In the file ei_pthreads.c of the ei interface source code there is this snippet: #ifdef __WIN32__ #ifdef USE_DECLSPEC_THREAD /* Define (and initialize) the variable __erl_errno */ volatile __declspec(thread) int __erl_errno = 0; #else static volatile DWORD errno_tls_index = TLS_OUT_OF_INDEXES; static LONG volatile tls_init_mutex = 0; #endif #endif If USE_DECLSPEC_THREAD is not defined then, lower in the source file, TLS Api is used instead. Now, from msdn i found that: On Windows operating systems before Windows Vista, __declspec( thread ) has some limitations. If a DLL declares any nonlocal data or object as __declspec( thread ) , it can cause a protection fault if dynamically loaded. After the DLL is loaded with LoadLibrary, it causes system failure whenever the code references the nonlocal __declspec( thread ) data. Because the global variable space for a thread is allocated at run time, the size of this space is based on a calculation of the requirements of the application plus the requirements of all the DLLs that are statically linked. When you use LoadLibrary, you cannot extend this space to allow for the thread local variables declared with __declspec( thread ) . Use the TLS APIs, such as TlsAlloc, in your DLL to allocate TLS if the DLL might be loaded with LoadLibrary. So , since I use the erl interface libs provided with the precompiled binary distribution of erlang for windows, I wonder if they defined USE_DECLSPEC_THREAD when compiling those binaries. If not then I am in dead end and I will try something else to do my job with. If they did define it then I must install cygwin and recompile the sources without defining it. (Yikes...). FINAL UPDATE: Indeed this was the problem. I had to install cygwin and compile the erl_interface code again without defining USE_DECLSPEC_TRHEAD . Also there is another little catch when recompiling, a tiny change is needed so that definition of _WIN32_WINNT happens before inclusion of winbase.h because after the omission of USE_DECLSPEC_THREAD the code uses SwitchToThread which is defined in winbase.h only if _WIN32_WINNT is defined and with a value greater than 0x400.
