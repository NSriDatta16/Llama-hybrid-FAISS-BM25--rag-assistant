[site]: stackoverflow
[post_id]: 2787439
[parent_id]: 2786306
[tags]: 
Here's my shot at rewriting your function (see comments below): (defn generate-function ([] (generate-function 2 4 0.5 0.6 ())) ([pc maxdepth fp pp function-list] (if (and (pos? maxdepth) ( And some examples of use from my REPL... user> (generate-function) ({:const 63} {:op # } {:const 77} {:param \w} {:op # } {:const 3} {:param \v} {:const 1} {:const 8} {:op # } {:op # }) user> (generate-function) ({:const 27} {:param \y} {:param \v} {:op # } {:op # } {:op # } {:op # } {:const 61}) A couple of things to keep in mind, in pretty random order: I used recur in the above to avoid consuming stack in the recursive self-calls. However, you have this dotimes statement which makes me wonder if you might be interested in constructing a bunch of function-list s in parallel with one generate-function call. If so, tail-recursion with recur might not be an option with simplistic code like this, so you could either settle for the regular self-calls (but do consider the possibility of hitting the recursion limit; if you're positive that you'll only generate smallish functions and this won't be a problem, go ahead with the self-calls) or investigate continuation-passing style and rewrite your function in that style. The (do (dec pc) ...) thing in your code does nothing to the value of pc in the next recursive call, or indeed to its current value. Local variables (or locals, as they are most often called in the community) in Clojure are immutable; this includes function parameters. If you want to pass along a decremented pc to some function, you'll have to do just that, like you did with maxdepth in an earlier branch of your code. I renamed your function to generate-function , because camel case in function names is quite unusual in Clojure land. Also, I renamed the parameter which you called function to function-list (so maybe I should have used a name like generate-function-list for the function... hm), because that's what it is for now. Note that there's no point to keeping a separate opcount Var around; Clojure's persistent lists (as created by the list function) carry their count around, so (count some-list) is a constant-time operation (and very fast). Also, it would be idiomatic to use vectors for operations and parameters (and you can switch to vectors without changing anything in the rest of the code!). E.g. [\u \v \w \x \y \z] . In Clojure 1.2, you'll be able to use (rand-nth coll) for (nth coll (rand-int (count coll))) . If you want to generate actual Clojure functions from trees of items representing ops, params and constants, you'll want to use eval . That's discouraged in most scenarios, but not for evolutionary programming and similar stuff where it's the only way to go. Personally, I'd use a different format of the op/param/constant maps: something like {:category foo, :content bar} where foo is :op , :param or :const and bar is something appropriate in connection to any given foo .
