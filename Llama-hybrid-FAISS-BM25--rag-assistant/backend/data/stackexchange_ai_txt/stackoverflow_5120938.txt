[site]: stackoverflow
[post_id]: 5120938
[parent_id]: 
[tags]: 
iPhone using geocoder to create a string so it can be fed into Google Maps

So here's my last query. I've got all my components I need, however, I need the phone to create a string from the geocoder so it can be fed into Google maps. This string is passed to a server, then grabbed from that database into another iPhone by different users. I have the database get/post side finished, but I need the geocoding to work so it can produce an address string. Here's my code: I've used Mark/LaMarche's mapkit tutorial as my foundation. My question is: Can I use the geocoder WITHOUT having to use MapKit? And would that save me more code than what is written below? Thank you! - (IBAction)findMe { CLLocationManager *lm = [[CLLocationManager alloc] init]; lm.delegate = self; lm.desiredAccuracy = kCLLocationAccuracyBest; [lm startUpdatingLocation]; progressBar.hidden = NO; progressBar.progress = 0.0; progressLabel.text = NSLocalizedString(@"Determining Current Location", @"Determining Current Location"); button.hidden = YES; } - (void)openCallout:(id )annotation { progressBar.progress = 1.0; progressLabel.text = NSLocalizedString(@"Showing Annotation",@"Showing Annotation"); [mapView selectAnnotation:annotation animated:YES]; } #pragma mark - - (void)viewDidLoad { mapView.mapType = MKMapTypeStandard; // mapView.mapType = MKMapTypeSatellite; // mapView.mapType = MKMapTypeHybrid; } - (void)viewDidUnload { self.mapView = nil; self.progressBar = nil; self.progressLabel = nil; self.button = nil; } - (void)dealloc { [mapView release]; [progressBar release]; [progressLabel release]; [button release]; [address release]; [super dealloc]; } #pragma mark - #pragma mark CLLocationManagerDelegate Methods - (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation { if ([newLocation.timestamp timeIntervalSince1970] ) annotation { static NSString *placemarkIdentifier = @"Map Location Identifier"; if ([annotation isKindOfClass:[MapLocation class]]) { MKPinAnnotationView *annotationView = (MKPinAnnotationView *)[theMapView dequeueReusableAnnotationViewWithIdentifier:placemarkIdentifier]; if (annotationView == nil) { annotationView = [[MKPinAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:placemarkIdentifier]; } else annotationView.annotation = annotation; annotationView.enabled = YES; annotationView.animatesDrop = YES; annotationView.pinColor = MKPinAnnotationColorPurple; annotationView.canShowCallout = YES; [self performSelector:@selector(openCallout:) withObject:annotation afterDelay:0.5]; progressBar.progress = 0.75; progressLabel.text = NSLocalizedString(@"Creating Annotation",@"Creating Annotation"); return annotationView; } return nil; } - (void)mapViewDidFailLoadingMap:(MKMapView *)theMapView withError:(NSError *)error { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:NSLocalizedString(@"Error loading map", @"Error loading map") message:[error localizedDescription] delegate:nil cancelButtonTitle:NSLocalizedString(@"Okay", @"Okay") otherButtonTitles:nil]; [alert show]; [alert release]; }
