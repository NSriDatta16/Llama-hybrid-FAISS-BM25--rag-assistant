[site]: stackoverflow
[post_id]: 2650820
[parent_id]: 2650810
[tags]: 
The line: cond = (char *)malloc(sizeof(char)); allocates exactly one char for storage, into which you are then copying more than one - strcpy needs to put, at a bare minimum, the null terminator but, in your case, also the results of your strtok as well. The reason it may work on a different system is that some implementations of malloc will allocate at a certain resolution (e.g., a multiple of 16 bytes) no matter what actual value you ask for, so you may have some free space there at the end of your buffer. But what you're attempting is still very much undefined behaviour. The fact that the undefined behaviour may be to work sometimes in no way abrogates your responsibility to avoid such behaviour. Allocate enough space for storing the results of your strtok and you should be okay. The safest way to do this is to dynamically allocate the space so that it's at least as big as the string you're passing to strtok . That way there can be no possibility of overflow (other than weird edge cases where other threads may modify the data behind your back but, if that were the case, strtok would be a very bad choice anyway). Something like (if instr is your original input string): cond = (char*)malloc(strlen(instr)+1); This guarantees that any token extracted from instr will fit within cond . As an aside, sizeof(char) is always 1 by definition, so you don't need to multiply by it.
