[site]: stackoverflow
[post_id]: 1531254
[parent_id]: 1531206
[tags]: 
For a representation which affords exact comparison is not possible to do better than an optimal compression of a sequence of bits which represent the configuration. If you require MxN boolean values to be uniquely encoded in an integer, you require 2 M*N values. Whether that's feasible using your platform's fixed precision integers depends on the size of M and N; if not you'll have to use a bit string or a big integer. Because the original data is any integer value rather than just 1 or 0, a naive bitstring ID of a naive matrix will give a compression of 8 * sizeof ( matrix::cell_type ) . A bitstring optimised for sparse values could be better. Good implementations of sparse bitstrings compress the data, so this will reduce the storage space of the representation, and allow fast exact comparison, which are the requirements. If the patterns are guaranteed sparse to a certain level, there are optimisations you can do compressing the information, but you need to give more information. For example, are you using a sparse matrix representation ( banded, diagonal, row compressed etc ), and have access to the internals of the sparse matrix storage then that will naturally and efficiently map to a compressed bitstring. Looking at your other post, it seems that the matrix is being used as the grid for a game rather than as a matrix. In that case it's probably best to use a run length compression on the bitstring, as this yields another useful property - the encoded bitstring representation of the matrices whose configurations are translations of each other will only differ in the first value of the encoding.
