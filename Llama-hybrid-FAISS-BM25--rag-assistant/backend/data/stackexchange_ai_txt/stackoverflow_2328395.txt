[site]: stackoverflow
[post_id]: 2328395
[parent_id]: 2328339
[tags]: 
Edit: I don't have any expertise in this area and my math skills are pretty average. But I have the opinion that the solution to this problem is more complex and interesting than many answers here suggest, since I tried to do something similar recently and didn't find a solution. Color Difference The perception of color is of course subjective, but there is significant agreement between humans. For example, we can all agree that red, green and blue are very different colors, and even colorblind people agree that black and white are very different. RGB The most common representation of color in computer systems is the vector (r, g, b) which suggests a simple distance function like Lets set the range for r , g and b to [0, 1] and see how this works: Red (1, 0, 0) and red (1, 0, 0) has the distance of 0 , which should be obvious Red (1, 0, 0) and yellow (1, 1, 0) has the distance of 1 , which is smaller than the distance of Red (1, 0, 0) and blue (0, 0, 1) which is sqrt(2) , which is plausible So far, so good. The problem however is that blue and red have the same distance 1 from black (0, 0, 0) , but when looking at the image this doesn't seem to hold true: Also yellow (1, 1, 0) and magenta (1, 0, 1) both have have the same distance 1 from white (1, 1, 1) , which doesn't seem to make sense either: HSL and HSV I think it is safe to assume that analogue metrics for the HSL and HSV color schemes have the same problems. These color schemes aren't designed for comparing color. CIEDE2000 Luckily, there are scientists already trying to find a good way to compare colors. They came up with some elaborate methods, the latest one being CIEDE2000 (the full formula described in the article is huge ) This metric takes human perception into consideration, like the fact that we seem to be unable to discern shades of blue very well. So I'd say we use this as our color difference function. The Color Picking Algorithm Naive solution Some answers suggested the following algorithm colors = [] for n in range(n): success=False while not success: new_color = random_color() for color in colors: if distance(color, new_color)>far_enough: colors.append(new_color) success = True break This algorithm has some problems: The spacing of the colors isn't optimal. If we imagine the colors to be like numbers on a line, three numbers would be optimally spaced like this: |a-----b-----c| Packing an additional one number in there without moving a, b, and c is clearly worse than realigning all the colors. The algorithm isn't guaranteed to terminate . What if there is no color that is far enough form the existing colors in the list? The loop will continue forever Proper solution Well.. I don't have one.
