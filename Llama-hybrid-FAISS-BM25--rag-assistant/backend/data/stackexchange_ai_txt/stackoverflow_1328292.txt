[site]: stackoverflow
[post_id]: 1328292
[parent_id]: 1326539
[tags]: 
The purpose of the bytes pragma is to replace the length function (and several other string related functions) in the current scope. So every call to length in your program is a call to the length that bytes provides. This is more in line with what you were trying to do: #!/usr/bin/perl use strict; use warnings; sub bytes($) { use bytes; return length shift; } my $ascii = "foo"; #really UTF-8, but everything is in the ASCII range my $utf8 = "\x{24d5}\x{24de}\x{24de}"; print "[$ascii] characters: ", length $ascii, "\n", "[$ascii] bytes : ", bytes $ascii, "\n", "[$utf8] characters: ", length $utf8, "\n", "[$utf8] bytes : ", bytes $utf8, "\n"; Another subtle flaw in your reasoning is that there is such a thing as Unicode bytes. Unicode is an enumeration of characters. It says, for instance, that the U+24d5 is &#x24d5 (CIRCLED LATIN SMALL LETTER F); What Unicode does not specify how many bytes a character takes up. That is left to the encodings. UTF-8 says it takes up 3 bytes, UTF-16 says it takes up 2 bytes, UTF-32 says it takes 4 bytes, etc. Here is comparison of Unicode encodings . Perl uses UTF-8 for its strings by default. UTF-8 has the benefit of being identical in every way to ASCII for the first 127 characters.
