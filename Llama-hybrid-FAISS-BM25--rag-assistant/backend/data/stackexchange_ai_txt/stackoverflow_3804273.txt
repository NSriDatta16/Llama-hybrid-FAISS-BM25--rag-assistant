[site]: stackoverflow
[post_id]: 3804273
[parent_id]: 3801565
[tags]: 
__unaligned isn't a magic bullet that you should simply start throwing around when you get a misalignment exception. First you have to determine where in the code that exception occurred and then look at why. Are you accessing a pointer that is misaligned? Something like taking a byte array or buffer of some sort and then trying to accedd WORD data from an odd boundary or DWORD data from an address not divisible by 4? BYTE buffer[256]; .... DWORD d = *(DWORD*)buffer[3]; Or maybe you have a structure that you have strange packing on? #pragma pack(push, 1) struct { BYTE b; DWORD d; } s; #pragma pack(pop) The key is that you must make aligned accesses. x86 allows you to make unaligned accesses only because it catches the exception for you then does a second, unaligned read. Here's a quick tutorial , though bear in mind this is for x86, so it shows the CPU "fixing" the misalignment for you. ARM is not so forgiving. You must rearrange or reassembly the data yourself on ARM. You likely have to do a memcpy to an aligned address and use the data from there, but without knowing anything about your code, it's impossible to give much more insight.
