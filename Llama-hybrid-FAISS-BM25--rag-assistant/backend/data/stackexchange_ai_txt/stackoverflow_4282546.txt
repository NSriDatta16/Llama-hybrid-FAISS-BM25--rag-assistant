[site]: stackoverflow
[post_id]: 4282546
[parent_id]: 4282404
[tags]: 
The problem I see (and there could very well be others) is that in pEventCallback 's type, the template parameter should be a class type but is actually a pointer type. One fix (without limiting what types the callback wraps) is to use the base type: struct EventHook { char *name; EventHookMode mode; TBaseCallback* pCallback; }; If there's more to TEventCallback 's API, and it needs to be accessible through an EventHook , you should move the code in TEventCallback that deals with an object and its method into a separate subclass. // Example EventCallback that takes other args class EventCallback : public TBaseCallback { public: EventCallback(); EventCallback(const EventArgs& evtArgs); // EventCallback specific methods ... virtual EventArgs& args(); virtual const EventArgs& args() const; } /* TReturn allows for calling methods with a non-void return. Return value is ignored. */ template class TMethodCallback : public EventCallback { private: typedef TReturn (TClass::*TMeth)(IGameEvent*); TMeth funcPtr; // pointer to member function TClass* thisPtr; // pointer to object public: // constructor - takes pointer to an object and pointer to a member and stores them in two private variables TMethodCallback(TClass* _thisPtr, TMeth _funcPtr) { thisPtr = _thisPtr; funcPtr=_funcPtr; }; // override operator "()" virtual void operator()(IGameEvent *pEvent) { (*thisPtr.*funcPtr)(pEvent); }; // execute member function // override function "Call" virtual void Call(IGameEvent *pEvent) { (*thisPtr.*funcPtr)(pEvent); }; // execute member function }; Off-Topic You might as well make the default implementation of TBaseCallback::Call call TBaseCallback::operator() . void TBaseCallback::Call(IGameEvent *pEvent) { this->operator()(pEvent); };
