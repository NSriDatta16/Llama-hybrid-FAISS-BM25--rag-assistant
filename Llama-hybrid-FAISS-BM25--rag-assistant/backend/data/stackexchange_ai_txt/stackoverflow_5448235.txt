[site]: stackoverflow
[post_id]: 5448235
[parent_id]: 5447633
[tags]: 
It seems the answer is simpler than I thought. In your classloader, add to the classpath (jar not required) this folder: /META-INF/services/ In it, create a file named javax.xml.transform.TransformerFactory Edit it and set this as it's content to: com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl Thats it! Why does it work? see this class used by Java for loading the Xalan implementation. Notice that it seems de-facto a parent-last (or child-first) loader for that specific "META-INF" entry (the oposite of how regular Java class loaders work, e.g. parent-first / child-last) but feel free to correct me if I'm wrong Snippet from javax.xml.datatype.FactoryFinder /* * Try to find provider using Jar Service Provider Mechanism * * @return instance of provider class if found or null */ private static Object findJarServiceProvider(String factoryId) throws ConfigurationError { String serviceId = "META-INF/services/" + factoryId; InputStream is = null; // First try the Context ClassLoader ClassLoader cl = ss.getContextClassLoader(); if (cl != null) { is = ss.getResourceAsStream(cl, serviceId); // If no provider found then try the current ClassLoader if (is == null) { cl = FactoryFinder.class.getClassLoader(); is = ss.getResourceAsStream(cl, serviceId); } } else { // No Context ClassLoader, try the current // ClassLoader cl = FactoryFinder.class.getClassLoader(); is = ss.getResourceAsStream(cl, serviceId); } if (is == null) { // No provider found return null; } ...
