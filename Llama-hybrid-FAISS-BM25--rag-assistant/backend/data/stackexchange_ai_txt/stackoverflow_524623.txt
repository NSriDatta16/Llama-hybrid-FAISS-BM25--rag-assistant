[site]: stackoverflow
[post_id]: 524623
[parent_id]: 524591
[tags]: 
To be honest I am not certain but from what I have read, it really depends on the iterators. In the case of iterators from file streams it probably has no built in method to measure the length of the file between the begin and the end interator. If this is correct it will operate by something similar to doubling it's internal storage size every time it runs out of space. In this case for n characters in the file there will be Log[n,2] memory allocations, and memory deletions, and n*Log[n,2] individual character copies, on top of just copying the characters into the string. As Greg pointed out though, you might as well test it. As he said try it for a variety of file sizes for both techniques. Additionally you can use the following to get some quantitative timings. #include #include ... clock_t time1=0, time2=0, delta; float seconds; time1=clock(); //Put code to be timed here time2=clock(); delta= time2-time1; seconds =(((float)delta)/((float)CLOCKS_PER_SEC)); std::cout this should do the trick for the timing.
