[site]: stackoverflow
[post_id]: 2621837
[parent_id]: 2621610
[tags]: 
The most troubling feature new developers to DVCS need to realize is about the publication process : you can import (fetch/pull) whatever remote repo you need you can publish (push) to any (bare) repo you want From that, you can respect a few rules to make your questions easier: only rebase a branch if it hasn't been pushed (not pushed since the last rebase) only push to a bare repo (mandatory since Git1.7) follow Linus's advices on rebase and merges Now: Workflows / branching models : each workflow is there to support a release management process , and that is tailored for each project. What I can add to the workflow you mention is: each developer should not create a feature branch, only a "current dev" branch, because the truth is: the developer often doesn't know what exactly his/her branch will produce: one feature, several (because it ended up being too complex a feature), none (because not ready in time for release), another feature (because the original one had "morphed"),... Only an "integrator" should established official feature branches on a "central" repo, which can then be fetched by developers to rebase/merge the part of their work that fits that feature. Merging vs rebasing (tangled vs sequential history) : I like my answer you mention (" Workflow description for git usage for in-house development ") I am looking for a natural workflow : for fixes, it can help associating each fix with a ticket from a bug tracking, which helps the developer remember where (i.e. on which branch, i.e. a dedicated branch "for fixes") he/she should commit such modifications. Then hooks can help protect a central repo against pushes from non-validated bug-fixes or from branches from which one shouldn't push. (no specific solution here, all this need to be adapted to your environment) How to avoid creating merge conflicts (due to cherry-pick)? As stated by Jakub NarÄ™bski in his answer , cherry-picking should be reserved for rare situations where it is required. If your setup involves a lot of cherry-picking (i.e. "it is not rare"), then something is off. Would applying the same commit in revert (how to do this?) git revert should take care of that, but that is not ideal. How to decompose into topical branches? As long as a branch as not yet been pushed everywhere, a developer should reorganize its history of commits (once he/she finally see the development takes a more definitive and stable shape) into: several branches if needed (one by clear identified feature) a coherent set of commits within one branch (see Trimming Git Checkins ) Proper procedures like code review and graduating ? Integration branches (in a dedicated integration) repo can help the developer to: rebase his/her development on top of that remote integration branch (pull --rebase) solve locally push the development to that repo check with the integrator that doesn't result in a mess ;)
