[site]: stackoverflow
[post_id]: 728065
[parent_id]: 
[tags]: 
How do I persist an object between threads without using httpcontext.items?

I've got an object that handles in memory caching for my data access layer (DAL) and I need to persist it between threads. From what I've read the preferred method is to use httpcontext.item with code like so: Shared Property DALList() As Dictionary(Of String, DAL) Get If Not Web.HttpContext.Current.Items.Contains("_DALList") Then Web.HttpContext.Current.Items.Add("_DALList", New Dictionary(Of String, DAL)) End If Return Web.HttpContext.Current.Items("_DALList") End Get Set(ByVal value As Dictionary(Of String, DAL)) If Not Web.HttpContext.Current.Items.Contains("_DALList") Then Web.HttpContext.Current.Items.Add("_DALList", value) Else Web.HttpContext.Current.Items("_DALList") = value End If End Set End Property Two questions: Is this trying to serialize the object and if so how do I get it to leave the object intact and just reference it in memory instead of serializing it? I need to keep the object intact as it handles DB connections and caching under the covers. [EDIT] When I run this I get an error that causes the page to hang. There are two items in the event log. Faulting application w3wp.exe, version 7.0.6001.18000, time stamp 0x47919ed8, faulting module kernel32.dll, version 6.0.6001.18000, time stamp 0x4791ada5, exception code 0xe053534f, fault offset 0x000000000002649d, process id 0x%9, application start time 0x%10. and The state server has closed an expired TCP/IP connection. The IP address of the client is 127.0.0.1. The expired Read operation began at 04/07/2009 20:44:29. I then rehashed the code to put the items into a dictionary object against the session ID and I get those smae errors. If I use static variables it works fine but then I have my original problem which is that the users would be accessing other users data (clearly that's not an option). The rehashed version is as follows: (this works for the first method but not for this one) Shared _CurrentScope As New Dictionary(Of String, DALScope) Public Shared Property CurrentScope() As DALScope Get If Not _CurrentScope.ContainsKey(Web.HttpContext.Current.Session.SessionID & "_CurrentScope") Then _CurrentScope.Add(Web.HttpContext.Current.Session.SessionID & "_CurrentScope", New DALScope) End If Return _CurrentScope(Web.HttpContext.Current.Session.SessionID & "_CurrentScope") End Get Set(ByVal value As DALScope) If Not _CurrentScope.ContainsKey(Web.HttpContext.Current.Session.SessionID & "_Currentscope") Then _CurrentScope.Add(Web.HttpContext.Current.Session.SessionID & "_Currentscope", value) Else _CurrentScope(Web.HttpContext.Current.Session.SessionID & "_Currentscope") = value End If End Set End Property [EDIT] Good point onthe locking in the case where ther is more than one webrequest under tha same session. I ended up using the httpcontext.item approach and found that I'm issues were related to the property being a byval instead of byref. I have altered my code to include methods that deal wiht hte objects by ref and now this works.
