[site]: stackoverflow
[post_id]: 3559786
[parent_id]: 1517848
[tags]: 
Another approach that might be profitable, would be to build an array of 256 elements, which encodes the actions that you need to take in incrementing the count array. Here is a sample for a 4 element table, which does 2 bits instead of 8 bits. int bitToSubscript[4][3] = { {0}, // No Bits set {1,0}, // Bit 0 set {1,1}, // Bit 1 set {2,0,1} // Bit 0 and bit 1 set. } The algorithm then degenerates to: pick the 2 right hand bits off of the number. Use that as a small integer to index into the bitToSubscriptArray. In that array, pull off the first integer. That is the number of elements in the count array, that you need to increment. Based on that count, Iterate through the remainder of the row, incrementing count, based on the subscript you pull out of the bitToSubscript array. Once that loop is done, shift your original number two bits to the right.... Rinse Repeat as needed. Now there is one issue I ignored, in that description. The actual subscripts are relative. You need to keep track of where you are in the count array. Every time you loop, you add two to an offset. To That offset, you add the relative subscript from the bitToSubscript array. It should be possible to scale up to the size you want, based on this small example. I would think that another program could be used, to generate the source code for the bitToSubscript array, so that it can be simply hard coded in your program. There are other variation on this scheme, but I would expect it to run faster on average than anything that does it one bit at a time. Good Hunting. Evil.
