[site]: stackoverflow
[post_id]: 1931403
[parent_id]: 1931359
[tags]: 
Well, suppose you added three numbers and divided by three, and then added two numbers and divided by two. Can you get the average from these? x = (a + b + c) / 3 y = (d + e) / 2 z = (f + g) / 2 And you want r = (a + b + c + d + e + f + g) / 7 That is equal to r = (3 * (a + b + c) / 3 + 2 * (d + e) / 2 + 2 * (f + g) / 2) / 7 r = (3 * x + 2 * y + 2 * z) / 7 Both lines above overflow, of course, but since division is distributive, we do r = (3.0 / 7.0) * x + (2.0 / 7.0) * y + (2.0 / 7.0) * z Which guarantees that you won't overflow, as I'm multiplying x, y and z by fractions less than one. This is the fundamental point here. Neither I'm dividing all numbers beforehand by the total count, nor am I ever exceeding the overflow. So... if you you keep adding to an accumulator, keep track of how many numbers you have added, and always test if the next number will cause an overflow, you can then get partial averages, and compute the final average. And no, if you don't know the values beforehand, it doesn't change anything (provided that you can count them as you sum them). Here is a Scala function that does it. It's not idiomatic Scala, so that it can be more easily understood: def avg(input: List[Double]): Double = { var partialAverages: List[(Double, Int)] = Nil var inputLength = 0 var currentSum = 0.0 var currentCount = 0 var numbers = input while (numbers.nonEmpty) { val number = numbers.head val rest = numbers.tail if (number > 0 && currentSum > 0 && Double.MaxValue - currentSum number) { partialAverages = (currentSum / currentCount, currentCount) :: partialAverages currentSum = 0 currentCount = 0 } currentSum += number currentCount += 1 inputLength += 1 numbers = rest } partialAverages = (currentSum / currentCount, currentCount) :: partialAverages var result = 0.0 while (partialAverages.nonEmpty) { val ((partialSum, partialCount) :: rest) = partialAverages result += partialSum * (partialCount.toDouble / inputLength) partialAverages = rest } result } EDIT: Won't multiplying with 2, and 3, get me back into the range of "not supporter by the data type?" No. If you were diving by 7 at the end, absolutely. But here you are dividing at each step of the sum. Even in your real case the weights ( 2/7 and 3/7 ) would be in the range of manageble numbers (e.g. 1/10 ~ 1/10000 ) which wouldn't make a big difference compared to your weight (i.e. 1 ). PS: I wonder why I'm working on this answer instead of writing mine where I can earn my rep :-)
