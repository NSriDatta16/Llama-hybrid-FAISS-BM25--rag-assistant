[site]: stackoverflow
[post_id]: 2620509
[parent_id]: 2619800
[tags]: 
There are plenty wrong with the design of this assignment. Use enum The test code contains this snippets: MySimpleIt(erator?).PRIME_NUMBERS MySimpleIt(erator?).ODD_NUMBERS MySimpleIt(erator?).EVEN_NUMBERS In one place the type is MySimpleIt , in another it's MySimpleIterator . Either way, the name suggests using an interface to define a bunch of constants. THIS IS NOT A PROPER USE OF an interface !!! It would be a much better design to use an enum instead: enum SequenceType { PRIME_NUMBERS, ODD_NUMBERS, EVEN_NUMBERS; } See: Effective Java 2nd Edition Item 30: Use enums instead of int constants. Consider multiple implementations of the interface instead of a monolith with setType It looks like your sequencer should be able to switch sequence type on a whim. This will result in that class being a huge blob that must know how to generate every type of sequences. It may work okay just for the 3 types given here, but it's definitely a poor design if you later want to add more types of sequences. Consider just having different implementations of the same interface for the different types of sequences. You may want to define an AbstractIntegerSequencer that defines the basic functionality (resetting bounds, answering hasNext() , iterator() , etc), that delegates to an abstract protected int generateNext() for subclasses to @Override . This way, the specifics of the type of sequence to generate is nicely encapsulated to each subclass. You can still keep enum SequenceType for a static factory method that instantiates these different subclasses, one for each sequence type, but those sequences themselves probably shouldn't be able to switch type on a whim. Use generics Instead of making your type implements Iterator , you should make it implements Iterator . From JLS 4.8 Raw Types (emphasis theirs): The use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types . See also Effective Java 2nd Edition Item 32: Don't use raw type in new code. Don't confuse Iterator with Iterable . Let's say you have something like this: IntegerSequencer seq = new PrimeSequencer(0, 10); for (int i : seq) { System.out.println(i); } // prints "2", "3", "5", 7" for (int i : seq) { System.out.println(i); } // what should it print??? If you make seq implements Iterable , Iterator and @Override Iterator iterator() to return this; , then the second loop wouldn't print anything, since seq is its own iterator() , and at that point there is no more hasNext() for seq . A proper implementation of Iterable should be able to generate as many independent Iterator as necessary for the user, and such implementation would again print prime numbers between 0 and 10 in the above code. Further readings on stackoverflow Iterator performance contract (and use on non-collections) This question asked about PrimeGenerator implements Iterator (among other things) Why is Javaâ€™s Iterator not an Iterable? What is the Iterable interface used for? Why can't I iterate over an iterator?
