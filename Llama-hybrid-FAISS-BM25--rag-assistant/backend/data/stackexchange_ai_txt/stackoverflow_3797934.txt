[site]: stackoverflow
[post_id]: 3797934
[parent_id]: 3797447
[tags]: 
The idiom is not qt-specific. I'd plead for the variant of the second possibility you have already proposed. However, you don't need to register a signal/slot pair for the answer, just pass a callback which will be processed by the producer, but possibly on consumer's thread. For example: // this answer might arrive on Consumer's thread... void Producer::ProcessAnswer(bool pShouldStop) { // mShouldStopProcessing is shared among threads if (mShouldStopProcessing) return; if (pShouldStop) { // double checking pattern... if (!mShouldStopProcessing) { Lock lock; if (!mShouldStopProcessing) { // this notifies producer to stop processing mShouldStopProcessing = true; } } } } void Producer::ProcessData() { for (DataContainer::iterator tCurrent = mData.begin(); tCurrent != mData.end(); ++tCurrent) { if (mShouldStopProcessing) break; else { // emit signal here: OnDataProcessing (*tCurrent, std::bind(std::mem_fn(&Producer::ProcessAnswer), this)); } } } On Consumer's side you'd need: void ProcessData(Data& pData, std::function pCallback) { // process data here... bool tResult = //...; pCallback(tResult); }
