[site]: stackoverflow
[post_id]: 569813
[parent_id]: 569775
[tags]: 
scoped_ptr is the simplest. When it goes out of scope, it is destroyed. The following code is illegal (scoped_ptrs are non-copyable) but will illustrate a point: std::vector > tPtrVec; { scoped_ptr tPtr(new T()); tPtrVec.push_back(tPtr); // raw T* is freed } tPtrVec[0]->DoSomething(); // accessing freed memory shared_ptr is reference counted. Every time a copy or assignment occurs, the reference count is incremented. Every time an instance's destructor is fired, the reference count for the raw T* is decremented. Once it is 0, the pointer is freed. std::vector > tPtrVec; { shared_ptr tPtr(new T()); // This copy to tPtrVec.push_back and ultimately to the vector storage // causes the reference count to go from 1->2 tPtrVec.push_back(tPtr); // num references to T goes from 2->1 on the destruction of tPtr } tPtrVec[0]->DoSomething(); // raw T* still exists, so this is safe weak_ptr is a weak-reference to a shared pointer that requires you to check to see if the pointed-to shared_ptr is still around std::vector > tPtrVec; { shared_ptr tPtr(new T()); tPtrVec.push_back(tPtr); // num references to T goes from 1->0 } shared_ptr tPtrAccessed = tPtrVec[0].lock(); if (tPtrAccessed[0].get() == 0) { cout DoSomething(); // raw } intrusive_ptr is typically used when there is a 3rd party smart ptr you must use. It will call a free function to add and decrement the reference count.See the link to boost documentation for more info.
