[site]: crossvalidated
[post_id]: 560123
[parent_id]: 400394
[tags]: 
Normally, inverting the likelihood ratio test statistic or Rao's score test statistic is a nice technique to keep the parameter within its parameter space. However, since we have a sample size of 1 and the exact distribution of these test statistics is unknown in this case, these methods will fail miserably. It's times like these when the frequentist approach should give way to the Bayesian approach. The Bayesian approach will develop a credible interval, not a confidence interval, but it is guaranteed to be within its parameter space. Since we have a sample size of 1, I recommend using a uniform prior for $\rho$ , namely $\rho \sim Uni(-1,1)$ . Hence the posterior density of $\rho$ will be equivalent to the likelihood, up to a multiplicative constant. That is, \begin{eqnarray*} p(\rho | \boldsymbol{x} ) = \frac{1}{C} \exp\left(-\frac{1}{2} \left[\log |\boldsymbol{\Sigma}| + \boldsymbol{x}^{\prime} \boldsymbol{\Sigma}^{-1} \boldsymbol{x}\right]\right), \end{eqnarray*} where the constant $C$ is given by $C = \int_{-1}^1 p(\rho | \boldsymbol{x} ) \mbox{d} \rho$ . This may be found by numerical integration. In order to construct a two-sided $100(1-\alpha)\%$ credible interval, we can use a univariate root solver to find the values of $\rho_l$ and $\rho_u$ such that $\alpha/2 =\int_{-1}^{\rho_l} p(\rho | \boldsymbol{x} ) \mbox{d} \rho$ and $\alpha/2 =\int_{\rho_u}^{1} p(\rho | \boldsymbol{x} ) \mbox{d} \rho$ . The $100(1-\alpha)\%$ credible interval is then $(\rho_l, \rho_u)$ . Here is some R code to accomplish this. library(MASS) p = .5 Sigma = matrix(c(1,p,p^2,p,1,p,p^2,p,1),3,3) x = mvrnorm(1,rep(0,3),Sigma) prop.post = function(p,x){ sigma = matrix(c(1,p,p^2,p,1,p,p^2,p,1),3,3) h=exp(-.5*(as.numeric(determinant(sigma, logarithm = TRUE) $mod) + as.numeric(t(x)%*%solve(sigma)%*%x))) return(h) } v.prop.post = Vectorize(prop.post,vectorize.args="p") con = integrate(prop.post,-1,1,x=x)$ value true.post = function(p,x,con){ sigma = matrix(c(1,p,p^2,p,1,p,p^2,p,1),3,3) h=exp(-.5*(as.numeric(determinant(sigma, logarithm = TRUE)$mod) + as.numeric(t(x)%*%solve(sigma)%*%x))) return(h/con) } v.true.post = Vectorize(true.post,vectorize.args="p") a = .05 ci.l = function(x2,x,con,a){ return(integrate(v.true.post,-1,x2,x=x,con=con) $value - a/2) } ci.u = function(x2,x,con,a){ return(integrate(v.true.post,x2,1,x=x,con=con)$value - a/2) } v1=uniroot(ci.l,c(-.9999,.9999),x=x,con=con,a=a)$ root v2=uniroot(ci.u,c(-.9999,.9999),x=x,con=con,a=a)$root s = seq(-.99,.99,length=1000) y = v.true.post(s,x,con) plot(y~s,type="l") abline(v=v1,lty=2) abline(v=v2,lty=2)
