[site]: stackoverflow
[post_id]: 1953189
[parent_id]: 1953080
[tags]: 
First we need a way to compare the query string with a given entry. Let's assume a function using regexes: matches(query,trialstr) . An O(n) algorithm would be to simply run through every list item (your dictionary would be represented as a list in the program), comparing each to your query string. With a bit of pre-calculation, you could improve on this for large numbers of queries by building an additional list of words for each letter, so your dictionary might look like: wordsbyletter = { 'a' : ['aardvark', 'abacus', ... ], 'b' : ['bat', 'bar', ...], .... } However, this would be of limited use, particularly if your query string starts with an unknown character. So we can do even better by noting where in a given word a particular letter lies, generating: wordsmap = { 'a':{ 0:['aardvark', 'abacus'], 1:['bat','bar'] 2:['abacus']}, 'b':{ 0:['bat','bar'], 1:['abacus']}, .... } As you can see, without using indices, you will end up hugely increasing the amount of required storage space - specifically a dictionary of n words and average length m will require nm 2 of storage. However, you could very quickly now do your look up to get all the words from each set that can match. The final optimisation (which you could use off the bat on the naive approach) is to also separate all the words of the same length into separate stores, since you always know how long the word is. This version would be O( kx ) where k is the number of known letters in the query word, and x = x ( n ) is the time to look up a single item in a dictionary of length n in your implementation (usually log( n ). So with a final dictionary like: allmap = { 3 : { 'a' : { 1 : ['ant','all'], 2 : ['bar','pat'] } 'b' : { 1 : ['bar','boy'], ... } 4 : { 'a' : { 1 : ['ante'], .... Then our algorithm is just: possiblewords = set() firsttime = True wordlen = len(query) for idx,letter in enumerate(query): if(letter is not '?'): matchesthisletter = set(allmap[wordlen][letter][idx]) if firsttime: possiblewords = matchesthisletter else: possiblewords &= matchesthisletter At the end, the set possiblewords will contain all the matching letters.
