[site]: stackoverflow
[post_id]: 3232263
[parent_id]: 3212475
[tags]: 
The call-site fragment you give doesn't make sense. You have lua_pushstring(L,"function"); if(!lua_pcall(L,1,0,0)) { ... Which doesn't show retrieval of the function named "function", but rather a call to whatever was on top of the stack with its first argument given as the string "function" . Did you perhaps mean lua_getglobal(L,"function"); if(!lua_pcall(L,0,0,0)) { ... // succcess } else { // examine the error from the call for useful information fprintf(stderr, "lua_pcall: %s\n", lua_tostring(L,1)); } Edit: The error string returned from lua_pcall() is likely to be informative. For even more information, put a suitable error function on the stack as well, and pass its index as the 4th argument to lua_pcall . A good choice is debug.traceback . void callback(lua_State *L, const char *fname) { int status lua_getglobal(L,"debug"); // put debug.traceback on the stack lua_getfield(L,-1,"traceback"); lua_remove(L,-2); lua_getglobal(L,fname); // put function on the stack status = lua_pcall(L,0,0,-2) if (!status) // call it with no parameters and no return values { // succcess } else { // examine the error from the call for useful information fprintf(stderr, "lua_pcall returned %d: %s\n", status, lua_tostring(L,1)); lua_pop(L,1); // remove error message from the stack } lua_pop(L,1); // remove debug.traceback from the stack } Edit2: After your clarification, it still doesn't make sense. Your code has the following fragments: lua_register(state,"function",function); //dozens of them ... and later lua_getglobal(L,"require"); lua_pushstring(L,"function"); if(!lua_pcall(L,1,0,0)) { ... The first fragment creates a globals whose values are each C function. You would call those functions with get_global() and lua_pcall() as described in the first part of my answer. The second fragment is retrieving the global named require and calling it with the string "function" as its only argument. The equivalent expressed in Lua is require"function" , and it would be looking for a module named "function" in the usual way . Even when calling require() , it is a good idea to catch and report the error message. In this case, it is likely to tell you that there is no module named "function" in any of a long list of itemized places that require looked. But nothing you've written actually invokes the function itself. But there is a larger concern here. It isn't entirely clear why you need more than one Lua state in the first place, especially in a single-threaded program. Is it possible that [coroutines][2] are a better fit? With multiple states, you must remember that each state is extremely isolated from all the others. The only way to move values from one state to another is through using the C API to retrieve values from one state and push them to the other. Coroutines give some of the advantages of separate states, while sharing a common set of globals.
