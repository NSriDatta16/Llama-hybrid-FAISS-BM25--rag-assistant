[site]: stackoverflow
[post_id]: 3821288
[parent_id]: 3821261
[tags]: 
Is it a good idea to check for NULL before calling delete for any object? No! int *p = NULL; delete p ; //no effect The Standard says [Section 5.3.5/2] If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section. In either alternative, if the value of the operand of delete is the null pointer the operation has no effect . Furthermore in Section 18.4.1.1/13 void operator delete(void* ptr) throw(); void operator delete(void* ptr, const std::nothrow_t&) throw(); Default behavior: — For a null value of ptr, do nothing . — Any other value of ptr shall be a value returned earlier by a call to the default operator new, which was not invalidated by an intervening call to operator delete(void*) (17.4.3.7). For such a non-null value of ptr, reclaims storage allocated by the earlier call to the default operator new. EDIT : James Kanze here says that It's still the responisiblity of operator delete (or delete[]) to check; the standard doesn't guarantee that it won't be given a null pointer; the standard requires that it be a no-op if given a null pointer. Or that the implementation is allowed to call it. According to the latest draft, "The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect." I'm not quite sure what the implications of that "is one supplied in the standard library" are meant to be---taken literally, since his function is not one provided by the standard library, the sentence wouldn't seem to apply. But somehow, that doesn't make sense.
