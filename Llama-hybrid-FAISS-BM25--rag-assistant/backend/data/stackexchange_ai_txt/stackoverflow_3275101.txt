[site]: stackoverflow
[post_id]: 3275101
[parent_id]: 3270917
[tags]: 
There is no guarantee that any of the two are statically initialized before any runtime code is executed. For the first, it's easy to make it happen, though class One{ public: int adad1; int adad2; }; // initialized statically, if a and b are constant-expressions One one = { a, b }; As another guy says, constexpr in C++0x allows constructors to be executed statically. In your case that would work for the first case, but not for the second. You will have to live that for the second, no guarantee is made by the Standard. But the Standard still allows an implementation to optimize it to be done at static initialization phase. See 3.6.2/2 An implementation is permitted to perform the initialization of an object of namespace scope with static storage duration as a static initialization even if such initialization is not required to be done statically, provided that the dynamic version of the initialization does not change the value of any other object of namespace scope with static storage duration prior to its initialization, and the static version of the initialization produces the same value in the initialized object as would be produced by the dynamic initialization if all objects not required to be initialized statically were initialized dynamically. If the array given is suitable, your constructor may not violate those rules. The Standard shows an example, which i explained in more detail here . For completion, the example code is shown below inline double fd() { return 1.0; } extern double d1; double d2 = d1; // unspecified: // may be statically initialized to 0.0 or // dynamically initialized to 1.0 double d1 = fd(); // may be initialized statically to 1.0 As you see, putting things to be initialized earlier can even go with changed initial values if there exist a certain relation between variables.
