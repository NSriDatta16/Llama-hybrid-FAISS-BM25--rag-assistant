[site]: stackoverflow
[post_id]: 4541470
[parent_id]: 281818
[tags]: 
Given the attention this question / answer receives, and the valuable feedback from GManNickG , I have cleaned up the code a little bit. Two versions are given: one with C++11 features and another one with only C++98 features. In file type.hpp #ifndef TYPE_HPP #define TYPE_HPP #include #include std::string demangle(const char* name); template std::string type(const T& t) { return demangle(typeid(t).name()); } #endif In file type.cpp (requires C++11) #include "type.hpp" #ifdef __GNUG__ #include #include #include std::string demangle(const char* name) { int status = -4; // some arbitrary value to eliminate the compiler warning // enable c++11 by passing the flag -std=c++11 to g++ std::unique_ptr res { abi::__cxa_demangle(name, NULL, NULL, &status), std::free }; return (status==0) ? res.get() : name ; } #else // does nothing if not g++ std::string demangle(const char* name) { return name; } #endif Usage: #include #include "type.hpp" struct Base { virtual ~Base() {} }; struct Derived : public Base { }; int main() { Base* ptr_base = new Derived(); // Please use smart pointers in YOUR code! std::cout It prints: Type of ptr_base: Base* Type of pointee: Derived Tested with g++ 4.7.2, g++ 4.9.0 20140302 (experimental), clang++ 3.4 (trunk 184647), clang 3.5 (trunk 202594) on Linux 64 bit and g++ 4.7.2 (Mingw32, Win32 XP SP2). If you cannot use C++11 features, here is how it can be done in C++98, the file type.cpp is now: #include "type.hpp" #ifdef __GNUG__ #include #include #include struct handle { char* p; handle(char* ptr) : p(ptr) { } ~handle() { std::free(p); } }; std::string demangle(const char* name) { int status = -4; // some arbitrary value to eliminate the compiler warning handle result( abi::__cxa_demangle(name, NULL, NULL, &status) ); return (status==0) ? result.p : name ; } #else // does nothing if not g++ std::string demangle(const char* name) { return name; } #endif (Update from Sep 8, 2013) The accepted answer (as of Sep 7, 2013) , when the call to abi::__cxa_demangle() is successful, returns a pointer to a local, stack allocated array ... ouch! Also note that if you provide a buffer, abi::__cxa_demangle() assumes it to be allocated on the heap. Allocating the buffer on the stack is a bug (from the gnu doc): "If output_buffer is not long enough, it is expanded using realloc ." Calling realloc() on a pointer to the stack ... ouch! (See also Igor Skochinsky 's kind comment.) You can easily verify both of these bugs: just reduce the buffer size in the accepted answer (as of Sep 7, 2013) from 1024 to something smaller, for example 16, and give it something with a name not longer than 15 (so realloc() is not called). Still, depending on your system and the compiler optimizations, the output will be: garbage / nothing / program crash. To verify the second bug: set the buffer size to 1 and call it with something whose name is longer than 1 character. When you run it, the program almost assuredly crashes as it attempts to call realloc() with a pointer to the stack. (The old answer from Dec 27, 2010) Important changes made to KeithB's code : the buffer has to be either allocated by malloc or specified as NULL. Do NOT allocate it on the stack. It's wise to check that status as well. I failed to find HAVE_CXA_DEMANGLE . I check __GNUG__ although that does not guarantee that the code will even compile. Anyone has a better idea? #include const string demangle(const char* name) { int status = -4; char* res = abi::__cxa_demangle(name, NULL, NULL, &status); const char* const demangled_name = (status==0)?res:name; string ret_val(demangled_name); free(res); return ret_val; }
