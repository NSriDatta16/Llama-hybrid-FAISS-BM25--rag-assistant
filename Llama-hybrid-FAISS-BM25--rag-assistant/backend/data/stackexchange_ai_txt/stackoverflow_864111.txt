[site]: stackoverflow
[post_id]: 864111
[parent_id]: 863866
[tags]: 
The general issue has to do with a contract policy. The notion of a (public set) property is that when it is called, other actions may be taken in addition to the semantic notion of changing state. For example, calling a setter may fire events, trigger a peripheral device and so on. Your coworker is saying that by not using the property, you're side-stepping the contract and no events will be fired. So here's you should do from your coworker's point of view: this.Prop = CalculateSomeValue(); if (this.Prop kPropMax * 2) { this.Prop = kPropMax * 2; } this.Prop = this.Prop / 2; Now, this is a contrived case, but I've just hit a possible heavyweight property up to three times in the get and up to three times in the set, and one of those might be illegal (setting to kHighLimit / 2). I can work around this by using a local and calling the set precisely once at the end. I'd rather just mess with the field, though. I think a better approach is to take it pragmatically: use the property inside your class if and only if you want to invoke all the side-effects of a set or a get, otherwise obey the spirit of the property instead. -- clarification -- By obey the spirit of the property, let's say that my set property looks like this: bool PropValueOutOfRange(int val) { return val kPropMax; } public int Prop { set { if (PropValueOutOfRange(value)) throw new ArgumentOutOfRangeException("value"); if (PropValueConflictsWithInternalState(value)) throw new ArgumentException("value"); _prop = value; NotifyPeriperalOfPropChange(_prop); FirePropChangedEvent(/* whatever args might be needed */); } } In this I've factored out a lot of the grungy details, but that lets me reuse them. So now I feel confident in touching the private field _prop because I have the same infrastructure for making sure that I keep it in range and to notify the peripheral and fire the event. This lets me write this code: _prop = CalculateSomeValue(); if (_prop kPropMax * 2) _prop = kPropMax; _prop /= 2; NotifyPeripheralOfPropChange(); FirePropChangedEvent(); I'm using the same tools as those used to build the property so I'm working within the spirit of the property. I maintain correct range (but don't throw - I know better, I'm the implementer), hit the peripheral and fire events, and I do it thoughtfully, readably, and efficiently - not indiscriminately.
