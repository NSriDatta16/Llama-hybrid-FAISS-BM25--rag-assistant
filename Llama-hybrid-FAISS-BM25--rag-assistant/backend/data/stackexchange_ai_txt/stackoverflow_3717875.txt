[site]: stackoverflow
[post_id]: 3717875
[parent_id]: 3717215
[tags]: 
Alternative DOM Approach Alternatively, instead of doing a brute force traversal of the XML document you could use the XPath capabilities in the JDK to find the "B" element with value "13" and then remove it from its parent: import java.io.File; import javax.xml.parsers.*; import javax.xml.transform.*; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import javax.xml.xpath.*; import org.w3c.dom.*; public class Demo { public static void main(String[] args) throws Exception { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); Document document = dbf.newDocumentBuilder().parse(new File("input.xml")); XPathFactory xpf = XPathFactory.newInstance(); XPath xpath = xpf.newXPath(); XPathExpression expression = xpath.compile("//A/B[C/E/text()=13]"); Node b13Node = (Node) expression.evaluate(document, XPathConstants.NODE); b13Node.getParentNode().removeChild(b13Node); TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); t.transform(new DOMSource(document), new StreamResult(System.out)); } } The advantage of using an XPath it's easier to maintain, if the structure changes it's just a one line change to your code. Also if the depth of your document grows the XPath based solution stays the same number of lines. Non-DOM Approach If you don't want to materialize your XML as a DOM. You could use a Transformer and a stylesheet to remove a node: http://download.oracle.com/javase/6/docs/api/javax/xml/transform/Transformer.html
