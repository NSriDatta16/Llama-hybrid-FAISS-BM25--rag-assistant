[site]: stackoverflow
[post_id]: 3372093
[parent_id]: 3371268
[tags]: 
Dynamic-typed languages (Python, Ruby, etc) have seen have some of the largest and best test suites I have ever seen. I have more experience with Python, so I shall concentrate on it, but almost every attribute of Python and Ruby are equivalent with respect to its testability, and the propensity of open source projects using it to include test suites. There are many concrete examples of real world projects that are large, and are used by a lot of people, and have large large suites of tests, are practical examples of good results in testing software, and the ones I am most familiar with are written in Python. However, perhaps the SQLite people (C/C++) deserve some credit for building one of the most thorough test-suites in the whole open source world, too. Python test suites are (like all python application code) generally shorter, easier to write, and easier to read than any other language I have used. And yet, while I do not think C/C++ in particular is a very easy language to write tests in, and that it was more likely the passion and technical skill of the developers on the SQLite project, and the need to be able to trust their work, that lead to writing a large, thorough, effective test-suite in C++, and nothing to do with the C++ language itself. So, Python helps you out by making writing your apps easier, giving you time to write tests, that's all. But where C++ lacks in features to help you write tests, and takes you longer to build the same thing in C++, still some developers supply the skill and dedication and make it happen anyways, at whatever cost of time and effort. While certain features in a language make formal assurances of code-coverage in popular compiled and dynamic languages, very limited in scope, I believe the right path is to fix your formalisms, not change your language. The problem is not that the real world fails to meet my formal requirements for testing, but that the limits of the achievable in the real world need to be addressed by changing the way we build our formal definition of how tested the code is (code coverage, for example). In other words, the leaky abstractions in our testing formalisms are the thing failing us, not the real existing technology (C/C++). Testing is definitely an OPTIONAL part of the process, like everything in Python, very little is actually forced upon you. However, I would argue, that any language that found a way to FORCE you to write tests rather than ENCOURAGING such good behavior is in fact, an example of trying to legislate coding practices, that is bound to backfire. I do not frankly understand how a language can be designed in a way that forces you to test, without turning the language into a completely useless academic trivet. Like many others, I find the usability of a language to do real work at a real job much more important than ivory tower notions of formalism, and provable correctness. On the other hand, I find that the best way to free up a developer to write a lot of tests, and be able to test their code effectively, is to remove the accidental complexity from development. I believe that Python, and Delphi, which are the two languages I am most proficient in, do more to ease this burden than other languages widely used in commercial and open-source development do. Because of the extra time I didn't have to spend finding out how many pages of mumble-mumble it would take to write my main application code, I now find I have a half-day to test for correctness, scalability, and and even do some cross-platform testing. Ask not what you can do for your formalisms, but what your formalisms can do to come back down to earth.
