[site]: stackoverflow
[post_id]: 2710627
[parent_id]: 2710545
[tags]: 
1) It's best to keep your tests small and focused. That way, when a test fails, it's clear why the test failed. This usually results in a single assertion per test, but not always. However, instead of hand-coding a test for each individual "invalid scenario", you might want to take a look at JUnit 4.4 Theories (see the JUnit 4.4 release notes and this blog post ), or the JUnit Parameterized test runner. Parametrized tests and Theories are perfect for "calculation" methods like this one. In addition, to keep things organized, I might make two test classes, one for "good" inputs, and one for "bad" inputs. 2) You only need to include the test cases that you think are most likely to expose any bugs in your code, not all possible combinations of all inputs (that would be impossible as WizardOfOdds points out in his comments). The three sets that you proposed are good ones, but I probably wouldn't test more than those three. Using theories or parametrized tests, however, would allow you to add even more scenarios. 3) There are many benefits to writing unit tests, not just the one you mention. Some other benefits include: Confidence in your code - You have a high decree of certainty that your code is correct. Confidence to Refactor - you can refactor your code and know that if you break something, your tests will tell you. Regressions - You will know right away if a change in one part of the system breaks this particular method unintentionally. Completeness - The tests forced you to think about the possible inputs your method can receive, and how the method should respond. 5) It sounds like you did a good job with coming up with possible test scenarios. I think you got all the important ones.
