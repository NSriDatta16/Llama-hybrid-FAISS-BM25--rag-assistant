[site]: stackoverflow
[post_id]: 3664172
[parent_id]: 3663489
[tags]: 
As mentioned by he_the_great, templates are the best solution in most cases. (That's waht std::function is doing anyhow.) If you can't/don't want to use templates, look in std.functional. You'll find a function called toDelegate() , which uses some sneaky magic to turn a function pointer into a delegate. You can then do this: import std.functional; struct Impl1 { int doConversion(float x) { return cast(int) x; } } int impl2(float x) { return cast(int) x; } void fun(int delegate(float) dg) {} void main() { Impl1 impl1; fun(&impl1.doConversion); fun(toDelegate(&impl2)); } You could also write something equivalent to C++'s std::function , which would likely be trivial. In fact, I'll do it right here. Note, though that this doesn't correctly handle ref or out parameters or returns right now due to compiler bugs. import std.traits; interface Function(ReturnType, Args...) { ReturnType opCall(Args); } class FunctionImpl(C) : Function!(ReturnType!C, ParameterTypeTuple!C) { C callable; this(C callable) { this.callable = callable; } ReturnType!C opCall(ParameterTypeTuple!C args) { return callable(args); } } /**Convenience function for creating a Function object w/o explicitly specifying types */ FunctionImpl!C functionObject(C)(C callable) { return new typeof(return)(callable); } // Test function. uint inc(uint num) { return num + 1; } // Test it out. void main() { auto myFun = functionObject(&inc); assert(myFun(1) == 2); }
