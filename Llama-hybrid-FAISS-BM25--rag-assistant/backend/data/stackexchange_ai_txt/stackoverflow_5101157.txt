[site]: stackoverflow
[post_id]: 5101157
[parent_id]: 5058088
[tags]: 
You are choosing very complicated approach. Provide more details first: Does it really really necessary to extend original object prototype (aka how many times you change object prototype in run time)? How many different object are you going to create? By saying different I mean: created from the same object type, but with different public methods. How many object types are you planing to lock? How often are you planing to update your code? Are you using any kind of minifier/compiler? Response to comment 1 : If you are lock all objects then it is a matter of time when you deal performance problems (especially with IE). To date you have 2-3 object types you want to lock. Wouldn't it be easier to prepare these 2-3 objects in Delegation pattern ? Remember that you have to pay the price for flexibility; Try using Closure compiler in advanced mode. When you leverage this tool you gonna learn how to obfuscate object properties and leave public interface. Plus every code change and recompile results in new hidden variable/function names so good luck trying to guess witch one is setA or getA function. And the last but no least. Try to keep your public interface as neat and small as possible. This means: wrap up all your code with anonymous function and disclose as few objects/methods/properties as you can. A little bit more about Closure compiler obfuscation works. Compile renames all object properties to: aa, ab, ac, etc.; You disclose public methods/properties: a.prototype.getA = a.prototype.aa; (Internally you use a.prototype.aa method. This means that public method can be replaced with any value - this has no effect to your code); And finally You disclose object: window['foo'] = new a; The following method is used by Google (GMaps, GMail and etc.).
