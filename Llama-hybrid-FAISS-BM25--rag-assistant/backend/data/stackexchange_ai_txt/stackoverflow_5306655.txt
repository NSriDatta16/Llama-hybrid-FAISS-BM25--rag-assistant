[site]: stackoverflow
[post_id]: 5306655
[parent_id]: 
[tags]: 
Using view models in ASP.NET MVC 3

I'm relatively new to view models and I'm running into a few problems with using them. Here's one situation where I'm wondering what the best practice is... I'm putting all the information a view needs into the view model. Here's an example -- please forgive any errors, this is coded off the top of my head. public ActionResult Edit(int id) { var project = ProjectService.GetProject(id); if (project == null) // Something about not found, possibly a redirect to 404. var model = new ProjectEdit(); model.MapFrom(project); // Extension method using AutoMapper. return View(model); } If the screen only allows editing of one or two fields, when the view model comes back it's missing quite a bit of data (as it should be). [HttpPost] public ActionResult Edit(int id, ProjectEdit model) { var project = ProjectService.GetProject(id); if (project == null) // Something about not found, possibly a redirect to 404. try { if (!ModelState.IsValid) return View(model) // Won't work, view model is incomplete. model.MapTo(project); // Extension method using AutoMapper. ProjectService.UpdateProject(project); // Add a message for the user to temp data. return RedirectToAction("details", new { project.Id }); } catch (Exception exception) { // Add a message for the user to temp data. return View(model) // Won't work, view model is incomplete. } } My temporary solution is to recreate the view model from scratch, repopulate it from the domain model, reapply the form data to it, then proceed as normal. But this makes the view model parameter somewhat pointless. [HttpPost] public ActionResult Edit(int id, ProjectEdit model) { var project = ProjectService.GetProject(id); if (project == null) // Something about not found, possibly a redirect to 404. // Recreate the view model from scratch. model = new ProjectEdit(); model.MapFrom(project); // Extension method using AutoMapper. try { TryUpdateModel(model); // Reapply the form data. if (!ModelState.IsValid) return View(model) // View model is complete this time. model.MapTo(project); // Extension method using AutoMapper. ProjectService.UpdateProject(project); // Add a message for the user to temp data. return RedirectToAction("details", new { project.Id }); } catch (Exception exception) { // Add a message for the user to temp data. return View(model) // View model is complete this time. } } Is there a more elegant way? EDIT Both answers are correct so I would award them both if I could. The nod goes to MJ however since after trial and error I find his solution to be the leanest. I'm still able to use the helpers too, Jimmy. If I add what I need to be displayed to the view bag (or view data), like so... ViewBag.Project= project; I can then do the following... @Html.LabelFor(model => ((Project)ViewData["Project"]).Name) @Html.DisplayFor(model => ((Project)ViewData["Project"]).Name) A bit of a hack, and it requires the domain model to be decorated with System.ComponentModel.DisplayNameAttribute in some cases, but I already do that. I'd love to call... @Html.LabelFor(model => ViewBag.Project.Name) But dynamic causes a problem in expressions.
