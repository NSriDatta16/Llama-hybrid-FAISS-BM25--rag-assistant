[site]: stackoverflow
[post_id]: 4021458
[parent_id]: 4020897
[tags]: 
It is described very well in the C# Language Specification, chapter 7.9.6 "Reference type equality operators": The predefined reference type equality operators are: bool operator ==(object x, object y); bool operator !=(object x, object y); The operators return the result of comparing the two references for equality or non-equality. Since the predefined reference type equality operators accept operands of type object, they apply to all types that do not declare applicable operator == and operator != members. Conversely, any applicable user-defined equality operators effectively hide the predefined reference type equality operators. The predefined reference type equality operators require one of the following: • Both operands are reference-type values or the literal null. Furthermore, a standard implicit conversion (§6.3.1) exists from the type of either operand to the type of the other operand. • One operand is a value of type T where T is a type-parameter and the other operand is the literal null. Furthermore T does not have the value type constraint. Unless one of these conditions are true, a compile-time error occurs. Notable implications of these rules are: • It is a compile-time error to use the predefined reference type equality operators to compare two references that are known to be different at compile-time. For example, if the compile-time types of the operands are two class types A and B, and if neither A nor B derives from the other, then it would be impossible for the two operands to reference the same object. Thus, the operation is considered a compile-time error. The last paragraph is why you get the error.
