[site]: stackoverflow
[post_id]: 4626821
[parent_id]: 4626300
[tags]: 
There isn't any existing class that I'm aware of, but you can leverage the existing classes to help out with almost all of the difficult operations. The trick is to turn your data into a stream of Ints (or Bytes if there wouldn't be enough memory). You then can use all the handy collections methods (e.g. take ) and only are left with the problem of turning bits into memory. But that's easy if you pack the bits in MSB order. object BitExample { def bitInt(ii: Iterator[Int]): Int = (0 /: ii)((i,b) => (i 0) || (index+1 > shift) & 0x1 } } } And then you do things like import BitExample._ val compressed = new ArrayBits( Array[Byte](14,29,126) ).toStream val headless = compressed.dropWhile(_ == 0) val (test,rest) = headless.splitAt(3) if (bitInt(test) > 4) println(bitInt(rest.take(6))) (You can decide whether you want to use the iterator directly or as a stream, list, or whatever.)
