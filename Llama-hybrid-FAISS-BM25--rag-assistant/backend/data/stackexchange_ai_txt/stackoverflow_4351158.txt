[site]: stackoverflow
[post_id]: 4351158
[parent_id]: 4350951
[tags]: 
The Task Parallel Library might be exactly what you're looking for. I imagine your node-based drag-and-drop editor to look like this: Every node is essentially a Task . A Task can be anything -- read a file from disk, download some data from the web, or compute anything. When a Task has finished, it can ContinueWith one or more other Tasks, passing the result of the old Task to the new Tasks. A Task can also consist of waiting for multiple Tasks to finish. WhenAll these Tasks have finished, this Task can continue with another Task, passing the result of all Tasks to the new task. The TPL will schedule all these Tasks on a Thread Pool, so Threads can be reused and each Task doesn't need to have its own Thread. The TPL will find the optimal number of Threads for the system it is running on. The Visual Studio Async CTP adds native language support for asynchronous operations to C#, which makes working with Tasks really easy and fun. With the TPL it is just a matter of creating Tasks and composing them according to the node layout. Complete program code for the above example: var t1 = Task.Factory.StartNew (() => 42); var t2a = t1.ContinueWith (t => t.Result + 1); var t2b = t1.ContinueWith (t => t.Result + 1); var t3a = t2a.ContinueWith (t => t.Result * 2); var t3b = t2b.ContinueWith (t => t.Result * 3); var t4 = TaskEx.WhenAll (t3a, t3b) .ContinueWith (t => t.Result[0] + t.Result[1]); t4.ContinueWith(t => { Console.WriteLine(t.Result); }); Console.ReadKey();
