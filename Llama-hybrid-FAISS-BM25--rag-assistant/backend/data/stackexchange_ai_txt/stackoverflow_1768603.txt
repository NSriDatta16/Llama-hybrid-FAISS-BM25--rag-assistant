[site]: stackoverflow
[post_id]: 1768603
[parent_id]: 1768578
[tags]: 
You need to wrap them because when a function is used as an event handler, the this keyword refers to the DOM element that triggered the event, and if you don't wrap it, you don't have access to the instance members of your Dragger object, like this.isMouseDown . For example: Let's say you have a button: And you have the following object: var obj = { value: 'I am an object member', method: function () { alert(this.value); } } If you call: obj.method(); You will see an alert with the text contained in the value member of the obj object ( 'I am an object member' ). If you use the obj.method function as an event handler: document.getElementById('buttonId').onclick = obj.method; When the user clicks the button, it will alert 'Click me' . Why? Because when the click event is fired, obj.method will be executed with the this keyword pointing to the DOM element, and it will alert 'Click me' because the button contains a value member. You can check the above snippets running here . For context enforcement, I always keep close a bind function: // The .bind method from Prototype.js if (!Function.prototype.bind) { Function.prototype.bind = function(){ var fn = this, args = Array.prototype.slice.call(arguments), object = args.shift(); return function(){ return fn.apply(object, args.concat(Array.prototype.slice.call(arguments))); }; }; } It allows you to wrap any function, enforcing the context. As the first argument, it receives the object that will be used as this , and the rest of optional arguments, are the ones the wrapped functionenter code here will be called with. In the button example we could use it as : document.getElementById('buttonId').onclick = obj.method.bind(obj); It's really helpful in a lot of situations and it will be introduced as part of ECMAScript 5.
