[site]: stackoverflow
[post_id]: 292906
[parent_id]: 292363
[tags]: 
Initialization As a rule of thumb, try to initialize variables when they are declared. If the value of a variable is intended never to change, make that explicit with use of the final keyword. This helps you reason about the correctness of your code, and while I'm not aware of compiler or JVM optimizations that recognize the final keyword, they would certainly be possible. Of course, there are exceptions to this rule. For example, a variable may by be assigned in an if–else or a switch. In a case like that, a "blank" declaration (one with no initialization) is preferable to an initialization that is guaranteed to be overwritten before the dummy value is read. /* DON'T DO THIS! */ Color color = null; switch(colorCode) { case RED: color = new Color("crimson"); break; case GREEN: color = new Color("lime"); break; case BLUE: color = new Color("azure"); break; } color.fill(widget); Now you have a NullPointerException if an unrecognized color code is presented. It would be better not to assign the meaningless null . The compiler would produce an error at the color.fill() call, because it would detect that you might not have initialized color . In order to answer your question in this case, I'd have to see the code in question. If the solution initialized it inside the run() method, it must have been used either as temporary storage, or as a way to "return" the results of the task. If the collection is used as temporary storage, and isn't accessible outside of the method, it should be declared as a local variable, not an instance variable, and most likely, should be initialized where it's declared in the method. Concurrency Issues For a beginning programming course, your instructor probably wasn't trying to confront you with the complexities of concurrent programming—although if that's the case, I'm not sure why you were using a Thread . But, with current trends in CPU design, anyone who is learning to program needs to have a firm grasp on concurrency. I'll try to delve a little deeper here. Returning results from a thread's run method is a bit tricky. This method is the Runnable interface, and there's nothing stopping multiple threads from executing the run method of a single instance. The resulting concurrency issues are part of the motivation behind the Callable interface introduced in Java 5. It's much like Runnable , but can return a result in a thread-safe manner, and throw an Exception if the task can't be executed. It's a bit of a digression, but if you are curious, consider the following example: class Oops extends Thread { /* Note that thread implements "Runnable" */ private int counter = 0; private Collection state = ...; public void run() { state.add(counter); counter++; } public static void main(String... argv) throws Exception { Oops oops = new Oops(); oops.start(); Thread t2 = new Thread(oops); /* Now pass the same Runnable to a new Thread. */ t2.start(); /* Execute the "run" method of the same instance again. */ ... } } By the end of the the main method you pretty much have no idea what the "state" of the Collection is. Two threads are working on it concurrently, and we haven't specified whether the collection is safe for concurrent use. If we initialize it inside the thread, at least we can say that eventually, state will contain one element, but we can't say whether it's 0 or 1.
