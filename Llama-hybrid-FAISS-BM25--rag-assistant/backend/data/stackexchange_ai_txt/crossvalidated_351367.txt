[site]: crossvalidated
[post_id]: 351367
[parent_id]: 351329
[tags]: 
The algorithm to use depends on (a) the capabilities of your software platform; (b) how many such random draws you need; (c) how large the number of digits $n$ is; and (d) how large the number of possible results $\binom{n}{k}$ (where $k$ is the number of ones) is. Most statistical work is done with 32 or 64 signed integer and/or double-precision IEEE floating point numbers, so I will assume that of (a). Here is a set of solutions illustrated with working R code. To be specific, they all draw uniformly, independently, and randomly from the set $\mathcal{B}(n,k)$ of integers which, when represented in binary, have up to $n$ digits of which exactly $k$ are ones. You need a single random integer. Take a sample $i_1, i_2, \ldots, i_k$ without replacement from the set of places $0,1,\ldots, n-1$ and return $2^{i_1} + 2^{i_2} + \cdots + 2^{i_k}.$ rchoose This algorithm has $O(n)$ time and storage requirements. You need a large number $N$ of random integers where $n$ and $k$ are small. "Small" means both (1) your system accurately represents all integers through $2^{n}-1$ and (2) you have enough speed and RAM to compute and store all the elements of $\mathcal{B}(n,k).$ The solution is to generate an array representing all elements of $\mathcal{B}(n,k)$ and then (rapidly) draw randomly from this array: rchoose.many This algorithm requires $O(n \binom{n}{k})$ time to initialize plus $O(N)$ additional time to run. Its storage requirements are $O(n \binom{n}{k})$ (but could be reduced to $O(\binom{n}{k})$ by accumulating the values in a loop during initialization). You need a large number of random integers where $n$ and $k$ are not small. You're still limited by the need to represent $n$-digit binary integers in your system. About the best you can do is to loop $N$ times over the single-draw solution (1): rchoose.many.large This takes $O(Nn)$ time and $O(n)$ storage. Comparing the asymptotic requirements provides a criterion for selecting the appropriate solution in any situation. Examples These timings (on one modest workstation) provide some indication of the possibilities. system.time(x Here's a histogram of one largish sample (of a million draws) showing the distribution for $n=10,k=4.$ The bins have to be wider than $1$, for otherwise the counts will be either $0$ or close to a constant (because the distribution is uniform on $\mathcal{B}(10,4)$). I chose a width of $4:$ library(ggplot2) ggplot(data.frame(x=rchoose.many(1e6, 10, 4)), aes(x)) + geom_histogram(binwidth=4)
