[site]: stackoverflow
[post_id]: 5567481
[parent_id]: 5555551
[tags]: 
Well, ok, then I'll just let everybody know what I did in the hopes that someone else will find it useful. I decided to go with regular rails models with the external database configured in database.yml: # MySQL. Versions 4.1 and 5.0 are recommended. # # Install the MySQL driver: # gem install mysql # On Mac OS X: # sudo gem install mysql -- --with-mysql-dir=/usr/local/mysql # On Mac OS X Leopard: # sudo env ARCHFLAGS="-arch i386" gem install mysql -- --with-mysql- config=/usr/local/mysql/bin/mysql_config # This sets the ARCHFLAGS environment variable to your native architecture # On Windows: # gem install mysql # Choose the win32 build. # Install MySQL and put its /bin directory on your path. # # And be sure to use new-style password hashing: # http://dev.mysql.com/doc/refman/5.0/en/old-client.html development: adapter: mysql encoding: utf8 reconnect: false database: myapp_development pool: 5 username: db_user password: db_pass socket: /private/tmp/mysql.sock # Warning: The database defined as "test" will be erased and # re-generated from your development database when you run "rake". # Do not set this db to the same as development or production. test: adapter: mysql encoding: utf8 reconnect: false database: myapp_test pool: 5 username: db_user password: db_pass socket: /private/tmp/mysql.sock production: adapter: mysql encoding: utf8 reconnect: false database: my_app_production pool: 5 username: db_user password: db_pass socket: /private/tmp/mysql.sock ## This is the external DB ## external_app: adapter: mysql encoding: utf8 reconnect: false database: external_db pool: 5 username: db_user password: db_pass socket: /private/tmp/mysql.sock Then create the models with the standard rails generator: rails g model external_app_name/model_name --no-migrations As the models are in an existing, non-rails db I don't want migrations, do what you want here. This creates a basic empty model in app/models/external_app_name/model_name.rb which I then modify thusly: class ExernalApp::ModelName From there you can continue development as though it was a normal rails model (which, of course, it is ; ). This method will also create whatever tests and other junk that your normal generator creates so you can just move forward. Presumably you could also do this with a scaffold, etc if there was some good reason (wasn't for me, just need models). NOTE: This also creates a module in app/models/external_app.rb that looks like: module ExternalApp def self.table_name_prefix 'external_app_' end end Initially I set prefix to '' but doesn't seem to have any impact as created. I know none of this is rocket science or even very far up the ladder of computer science, but it's an organizational/process thing that I think will keep life as easy and 'rails way' as possible during this part of the project. Hope this helps!
