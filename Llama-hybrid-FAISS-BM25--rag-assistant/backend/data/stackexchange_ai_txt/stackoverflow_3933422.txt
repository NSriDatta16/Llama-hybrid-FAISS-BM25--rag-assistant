[site]: stackoverflow
[post_id]: 3933422
[parent_id]: 3933108
[tags]: 
Ok, took a look at the Google sample you showed and found this at the bottom of the class /* * Progress Helper class * * The DownloadServiceListerner interface defined in the JNLP API is * a subset of the DownloadProgressWindow interface used by elsewhere. * * this class is used to create a Helper object that implements both. */ private class ProgressHelper extends CustomProgress { private DownloadServiceListener _dsp = null; public ProgressHelper() { _dsp = null; } public ProgressHelper(DownloadServiceListener dsp) { setAppThreadGroup(Thread.currentThread().getThreadGroup()); setListener(dsp); _dsp = dsp; if (_dsp instanceof DefaultProgressHelper) { ((DefaultProgressHelper) _dsp).initialize(); } // for bug #4432604: _dsp.progress(null, null, 0, 0, -1); } public void done() { if (_dsp instanceof DefaultProgressHelper) { ((DefaultProgressHelper) _dsp).done(); } else { // make sure callbacks to DownloadServiceListener have // been called before returning (for TCK test) flush(); } } } And what is interesting is that it looks like it sets the current thread's ThreadGroup as the application thread group. So this leads me to believe that by doing this the actual download is kept closer to the application (not sure what the correct terminology would be) such that the RuntimeException throw in the class in the cancel check really does affect it. Otherwise, my hunch is that in your application the download actually takes place in another thread and is "unaffected" by the Exception thrown by your application, hence, allowing it to complete.
