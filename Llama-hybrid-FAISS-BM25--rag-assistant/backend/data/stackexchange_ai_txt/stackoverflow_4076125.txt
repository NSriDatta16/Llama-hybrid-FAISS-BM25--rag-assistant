[site]: stackoverflow
[post_id]: 4076125
[parent_id]: 4075947
[tags]: 
I think the most elegant solution is this one. Yes, of course I'm biased. I'm human :-) def countLeft (node,ind): if node == null: return 0 return ind + countLeft (node->left, 1) + countLeft (node->right, 0) total = countLeft (root, 0) By passing down the indicator for left nodes, it simplifies what has to be passed up. The following diagram shows each sum being passed up - you start at the bottom and each null passes up 0. Each node on the left passes up 1 plus whatever came from both branches below. Each node on the right passes up 0 plus whatever came from both branches below. The root adds nothing since it is neither a left nor right node (it's treated the same as right). 4 ^ | +---+ | 3 | __________+---+__________ /2 2\ +---+ +---+ | 5 | | 2 | +---+ +---+ /1 /2 0\ +---+ +---+ +---+ | 1 | | 4 | | 6 | +---+ +---+ +---+ /0 0\ /1 0\ /0 0\ +---+ | 7 | +---+ /0 0\ You can see the operation from this complete program: #include typedef struct sNode { int val; struct sNode *left, *right; } tNode; #define setNode(N,V,L,R) N.val = V; N.left = L; N.right = R int countLeft (tNode *node, int ind) { if (node == NULL) return 0; int x = ind + countLeft (node->left, 1) + countLeft (node->right, 0); printf ("Node %d passing up %d\n", node->val, x); return x; } int main (void) { tNode n3, n5, n1, n2, n4, n6, n7; setNode (n3, 3, &n5, &n2); setNode (n5, 5, &n1, NULL); setNode (n1, 1, NULL, NULL); setNode (n2, 2, &n4, &n6); setNode (n4, 4, &n7, NULL); setNode (n7, 7, NULL, NULL); setNode (n6, 6, NULL, NULL); printf ("countLeft is %d\n", countLeft (&n3, 0)); return 0; } which outputs the debugging lines: Node 1 passing up 1 Node 5 passing up 2 Node 7 passing up 1 Node 4 passing up 2 Node 6 passing up 0 Node 2 passing up 2 Node 3 passing up 4 countLeft is 4 The non-debugging version of the countLeft function is as simple as the pseudo-code at the start of this answer: int countLeft (tNode *node, int ind) { if (node == NULL) return 0; return ind + countLeft (node->left, 1) + countLeft (node->right, 0); }
