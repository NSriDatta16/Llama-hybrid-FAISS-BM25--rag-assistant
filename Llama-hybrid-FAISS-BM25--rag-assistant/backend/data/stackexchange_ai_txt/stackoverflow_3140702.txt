[site]: stackoverflow
[post_id]: 3140702
[parent_id]: 3140517
[tags]: 
In my experience option 2 is much easier to work with has minimal overhead. Realloc does not guarantee it will increase the size of existing memory. And in practice it almost never does. If you use it you will need to go back and remap all of the old objects. That would require that you remember where every object allocated was... That can be a ton over overhead. But it's hard to qualify "most efficient" without knowing exactly what metrics you use. This is the memory manager I always use. It works for the entire application not just one object. allocs: for every allocation determine the size of the object allocated. 1 look at a link list of frees for objects of that size to see if anything has been freed if so take the first free 2 look for in a look up table and if not found 2.1 allocate an array of N objects of the size being allocated. 3 return the next free object of the desired size. 3.1 if the array is full add a new page. N objects can be programmer tunned. If you know you have a million 16 byte objects you might want that N to be slightly higher. for objects over some size X, do not keep an array simply allocate a new object. frees: determine the size of the object, add it to the link list of frees. if the size of the object allocated is less than the size of a pointer the link list does not need to incur any memory overhead. simply use the already allocated memory to store the nodes. The problem with this method is memory is never returned to the operating system until the application has exited or the programmer decides to defragment the memory. defragmenting is another post. it can be done.
