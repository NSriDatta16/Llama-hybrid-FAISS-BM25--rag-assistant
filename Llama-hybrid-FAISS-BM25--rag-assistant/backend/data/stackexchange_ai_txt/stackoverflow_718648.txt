[site]: stackoverflow
[post_id]: 718648
[parent_id]: 133675
[tags]: 
I'm way late to the party here, but for future searchers I've used the following algorithm for a personal app I wrote. First of all, the region to reduce is selected by the user and passed to the red eye reducing method as a center Point and radius. The method loops through each pixel within the radius and does the following calculation: //Value of red divided by average of blue and green: Pixel pixel = image.getPixel(x,y); float redIntensity = ((float)pixel.R / ((pixel.G + pixel.B) / 2)); if (redIntensity > 1.5f) // 1.5 because it gives the best results { // reduce red to the average of blue and green bm.SetPixel(i, j, Color.FromArgb((pixel.G + pixel.B) / 2, pixel.G, pixel.B)); } I really like the results of this because they keep the color intensity, which means the light reflection of the eye is not reduced. (This means eyes keep their "alive" look.)
