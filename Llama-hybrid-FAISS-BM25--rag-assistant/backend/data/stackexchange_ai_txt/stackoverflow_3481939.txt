[site]: stackoverflow
[post_id]: 3481939
[parent_id]: 
[tags]: 
Lightweight file verification with PKI

I am trying to extend the legacy code of an online game to provide a reasonable assurance that the resource files associated with the game are the latest version, and not tampered with. I'd like to do this without DRM, without going into kernel mode, and without hardware assistance. What I ultimately settle on should ideally be about as secure as user-space gets. If they can get around these mechanisms then I'd say they've earned the right to be naughty -- for a while at least, then we ban them. :) The obvious thing to do is take a cryptographic hash of each of the files, and compare the hash output to pre-computed hashes. But care must be taken to assure that the user can not easily tamper with the pre-computed hashes that are used for comparison against the currently-computed hashes. Here are the measures I had in mind, at an architectural level: Use OS facilities to lock all the resource files for writing when the process is started, so no other processes can overwrite the files after the fact. Calculate the MD5 sums of each resource file. Connect to an https server, requiring verification against a particular signed certificate stored in the client executable. Download a file over https containing the "correct" hashes, storing it in RAM (not to disk). Compare the computed hashes to the ones received over https. Exit if the hashes don't match. This is more secure than storing the hashes client-side, because as long as they are stored client-side, it is usually possible for someone to modify them. Using this scheme, the attacker would have to figure out how to modify the executable in a way that changes the embedded public certificate so that it actually contains the attacker's certificate, which verifies against the attacker's https web server containing the poisoned hashes that match the attacker's tampered resource files. This is certainly feasible, but it's much more difficult than it would be if the program were using pre-computed keys stored on the client, right? The executable is native code, so it may be possible to wrap it in a packer that makes it even more difficult to edit the binary and replace the public key. Now, granted that I just described two paragraphs ago how to potentially attack the scheme I devised: is there any way other than what I described to attack this scheme? My second question is, what is a free (as in freeware OR freedom) library that can be called from Win32 C++ (Visual Studio 2010 compiler) to accomplish these tasks? Can they be done with built-in Windows APIs or is a third party solution required? So in summary, the questions: 1. Is the scheme I suggested robust enough to baffle most script kiddies; and 2. What dependencies or libraries would I use to implement it? Since this is just a game and not a matter of national security or even monetary risk (the game is 100% freeware with no in-game economy), the solution I implement should be pretty good, but it doesn't have to be industrial-strength. Feel free to answer one or both parts of my question as you see fit, and do correct me if you think I'm asking the wrong questions to begin with. Thanks!
