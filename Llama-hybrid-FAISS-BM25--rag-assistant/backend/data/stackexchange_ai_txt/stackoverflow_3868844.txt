[site]: stackoverflow
[post_id]: 3868844
[parent_id]: 3868827
[tags]: 
No. In C, you can only get a pointer to a storage area (which means a variable, an array element, or another pointer; they call those "l-values"), not to any expression. You cannot get a pointer to an expressions that has no defined storage area (like an addition, or the result of a function call). It should be noted however that C++ messes these rules with references, but for the sake of clarity, I'll leave it out. Pointers aren't magical: in the end, they're just integers. Therefore, when you get the pointer of a pointer, it's just like you were getting the pointer of an integer. It has no more repercussions. For instance, if you get the pointer to a in your code, you're just copying this address in another variable. Nothing keeps you from changing said variable: int a; int* p = &a; p = NULL; And doing this, you a will remain unaltered. All you can change about a is its value. Its address is immutable. Anything else would imply that &a = NULL (or any other pointer value) would work, which doesn't.
