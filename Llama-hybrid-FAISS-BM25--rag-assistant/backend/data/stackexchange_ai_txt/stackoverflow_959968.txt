[site]: stackoverflow
[post_id]: 959968
[parent_id]: 959951
[tags]: 
When you define and initialize a pointer to char like this: char * word = "hello"; you are actually telling the compiler to put the fixed string "hello" into a fixed piece of storage somewhere and then create the word pointer variable to point at it. Although you change change the word variable to point at something else and if it did point at some mutable storage you could change what it points to via * and [] operators, you are not allowed to change the fixed string "hello" through it. C++ allows assigning a fixed string to a pointer to non-const char purely for backwards compatibility. It is much better to only assign these strings to pointers to const char . e.g. const char * word = "hello"; This way you prevent causing illegal run time behaviour through compile time type checks. Edit: In your example there is essentially no externally visible difference between having the local variable declared static and not. This affects the life time of the pointer variable in each function. It does not affect the lifetime of the fixed strings that the pointer variables point at. As the functions return the value of the pointer variable (in C++ returns are always by value), it doesn't particularly matter whether the pointer variable in the function is destroyed at the end of the function or not. The strings themselves will always live beyond the scope of the function as string literals have static storage duration.
