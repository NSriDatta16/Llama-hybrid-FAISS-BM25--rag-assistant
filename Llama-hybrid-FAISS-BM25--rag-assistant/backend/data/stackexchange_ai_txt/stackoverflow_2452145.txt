[site]: stackoverflow
[post_id]: 2452145
[parent_id]: 2452132
[tags]: 
If bar is marked const as above, then the person reading the code, knowing what was passed in, knows at all time exactly what bar contains. There's no need to look at any code beforehand to see if bar got changed at any point along the way. This makes reasoning about the code simpler and thus reduces the opportunity for bugs to creep in. I vote "good practice" myself. Of course I'm also pretty much a convert to functional languages these days so.... Addressing the comment below, consider this source file: // test.c++ bool testSomething() { return true; } int test1(int a) { if (testSomething()) { a += 5; } return a; } int test2(const int a) { if (testSomething()) { a += 5; } return a; } In test1 there is no way for me to know what the value being returned will be without reading the (potentially sizable and/or convoluted) body of the function and without tracking down the (potentially distant, sizable, convoluted and/or source-unavailable ) body of the function testSomething . Further, the alteration of a may be the result of a horrific typo. That same typo in test2 results in this at compile-time: $ g++ test.c++ test.c++: In function ‘int test2(int)’: test.c++:21: error: assignment of read-only parameter ‘a’ If it was a typo, it's been caught for me. If it isn't a typo, the following is a better choice of coding, IMO: int test2(const int a) { int b = a; if (testSomething()) { b += 5; } return b; } Even a half-baked optimizer will generate identical code as in the test1 case, but you're signalling that care and attention will have to be paid. Writing code for readability involves a whole lot more than just picking snazzy names.
