[site]: crossvalidated
[post_id]: 593251
[parent_id]: 593201
[tags]: 
What you propose won't quite do what you want to accomplish. When you use bootstrapping to validate a model-building process, you need to repeat all the steps of the process within each bootstrap sample. That includes identifying the penalty factor. Frank Harrell, the author of the rms package , explains that in Chapter 5 of his book and his course notes . For example: the modeling strategy must be completely specified and then bootstrapped to get consistent estimates of variances and other sampling properties. As I understand your code, you would be finding the penalty factor only for the full sample, then use the same penalty factor for each of the bootstrap samples with the validate() and calibrate() functions. That doesn't validate the entire process. I don't think that the rms package provides built-in functions for including penalty-factor identification within bootstrap validation, but it's not too hard to write some simple code that can do that. As what you are doing seems to be equivalent to a ridge logistic regression, you might find some efficiency by using the glmnet package with its cv.glmnet() function to identify the optimal ridge penalty factor for the full data set and for each bootstrap sample, as illustrated in Section 6.5.2 of An Introduction to Statistical Learning . Use a "binomial" family argument for logistic regression, and a type.measure of "mse" or "deviance" to have a strictly proper scoring rule for penalty selection. That can be automated to return a model for each bootstrap sample at the sample's own optimal penalty factor and to test the model prediction against the full original data set. Then apply the steps in Section 5.3.5 of the Harrell references to validate and calibrate the entire model-building process. You also might gain some efficiency by removing genes with low overall variance in expression among all samples (blinded to disease status) before proceeding with the ridge regression, and by adapting your code to the R boot() package to take advantage of parallelization.
