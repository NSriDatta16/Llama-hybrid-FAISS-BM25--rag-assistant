[site]: crossvalidated
[post_id]: 623689
[parent_id]: 
[tags]: 
Representing Nested Models as an SKLearn Pipeline

Goal: Represent nested models with SKLearn's Pipeline / ColumnTransformer / FeatureUnion setup. Specific issue: I cannot figure out how to use the prediction from one model as a factor of a secondary model. Example of what I don't know how to do: Let $W_1, W_2, X_1, X_2$ be features. Let $Y$ represent the target variable. Assume $W_i$ and $X_i$ are already preprocessed and well behaved. Use Ridge to regress $Y$ on $W_1$ , $W_2$ . Let $\hat{Y}_W$ be the output from this step Use Ridge to regress $Y$ on $X_1$ , $X_2$ . Let $\hat{Y}_X$ be the output from this step Use XGBRegressor to regress $Y$ on $\hat{Y}_W$ , $\hat{Y}_X$ Example of what I know how to do: In the below example instead of using Ridge I use PCA as an intermediate step. I believe this works because PCA implements .fit and .transform . However, Ridge , or other estimator classes implement .fit and .predict (i.e. they do not implement .transform ). Use PCA on $W_1$ , $W_2$ and retrieve a single principle component factor. Let $\hat{PCA1}_W$ be the output from this step Use PCA on $X_1$ , $X_2$ and retrieve a single principle component factor. Let $\hat{PCA1}_X$ be the output from this step Use Linear Regression to regress $Y$ on $\hat{PCA1}_W$ , $\hat{PCA1}_X$ import pandas as pd from sklearn.decomposition import PCA from sklearn.pipeline import Pipeline from sklearn.compose import ColumnTransformer from sklearn.linear_model import LinearRegression from sklearn.model_selection import cross_val_score w1 = [x for x in range(10)] w2 = [x ** 2 for x in range(10)] x1 = [-x for x in range(10)] x2 = [2*x for x in range(10)] y = [x + 2 for x in range(10)] df = pd.DataFrame({'w1': w1, 'w2': w2, 'x1': x1, 'x2': x2, 'y': y}) pca_transformer = ColumnTransformer( [ ("pca_w", PCA(n_components=1), ['w1', 'w2']), ("pca_x", PCA(n_components=1), ['x1', 'x2']), ] ) pipeline = Pipeline( [ ("pca_transformer", pca_transformer), ("model", LinearRegression()) ] ) cross_val_score(estimator=pipeline, X=df, y=df['y'], scoring='neg_mean_squared_error', cv=10).mean() ```
