[site]: crossvalidated
[post_id]: 225197
[parent_id]: 225175
[tags]: 
Such values are for databases. Most databases long ago, and many today, allocated a fixed number of digits for integer-valued data. A number like -999 is the smallest that can be stored in four characters, -9999 in five characters, and so on. (It should go without saying that--by definition--a numeric field cannot store alphanumeric characters such as "NA". Some numeric code has to be used to represent missing or invalid data.) Why use the most negative number that can be stored to signify a missing value? Because if you mistakenly treat it as a valid number, you want the results to be dramatically incorrect. The further your codes for missing values get from being realistic, the safer you are, because hugely wrong input usually screws up the output. (Robust statistical methods are notable exceptions!) How could such a mistake happen? This occurs all the time when data are exchanged between systems. A system that assumes -9999 represents a missing value will blithely output that value when you write the data out in most formats, such as CSV. The system that reads that CSV file might not "know" (or not be "told") to treat such values as missing. Another reason is that good statistical data and computing platforms recognize many different kinds of missing values: NaNs, truly missing values, overflows, underflows, non-responses, etc, etc. By devoting the most negative possible values (such as -9999, -9998, -9997, etc) to these, you make it easy to query out all missing values from any table or array. Yet another is that such values usually show up in graphical displays as extreme outliers. Of all the values you could choose to stand out in a graphic, the most negative possible one stands the greatest chance of being far from your data. There are useful implications and generalizations: A good value to use for missing data in floating-point fields is the most negative valid number, equal approximately to $-10^{308}$ for double-precision floats. (Imagine the effect that would have on any average!) On the same principle, many old programs, which used single-precision floats, used somewhat arbitrary large numbers such as 1E+30 for missing values. Adopt a standard rule of this type to make it easy to invent NoData codes in new circumstances (when you are designing your own database software). Design your software and systems to fail dramatically if they fail at all. The worst bugs are those that are intermittent, random, or tiny, because they can go undetected and be difficult to hunt down.
