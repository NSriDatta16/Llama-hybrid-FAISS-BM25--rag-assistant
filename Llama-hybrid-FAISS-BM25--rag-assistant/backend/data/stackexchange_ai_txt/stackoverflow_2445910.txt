[site]: stackoverflow
[post_id]: 2445910
[parent_id]: 
[tags]: 
Filtering directly and indirectly connected things from list

if you have a function "test a b" which returns true if a and b are connected directly and if you have a given unordered list of things, what would be an elegant and fast solution to filter all connected things from given list? Example: let test a b = let diff = a - b in diff == 0 ;; let lst = [4;1;7;3;8;9;2;0] ;; filter_connected 2 lst ;; -> [4;1;3;2;0] Any hints? Hmmm, I will try to refine my question... there exists an unsorted list of things, pE. "let lst = [a;b;c;d;e;f;g;h];;" with type val a' list there exists also a function which decide if two things are directly connectable or in other words, if the two things are direct neighbours: val test : a' -> a' -> bool what I need is a function which has three arguments, the first one is a specific thing, the second one the unsorted list of things as suggested above, the last one is the test-function described above: val filter_connected : a' -> a' list -> (a' -> a' -> bool) -> a' list if a b are direct neigbours and b c are direct neighbours then [a;b;c] are connected. The suggested "List.filter () lst" does not help here, because it only filters the directed neighbours. In the example above with a b and b c as direct neighbours in case of test-function, and all others not, the "filter_connected" call will be: "filter_connected b lst (test);;" and would return: [a;b;c] Hope it will be more clean...
