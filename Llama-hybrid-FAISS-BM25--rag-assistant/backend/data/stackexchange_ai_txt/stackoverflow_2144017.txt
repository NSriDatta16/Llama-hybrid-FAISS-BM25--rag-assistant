[site]: stackoverflow
[post_id]: 2144017
[parent_id]: 
[tags]: 
Truncated Core Data NSData objects

I am saving arrays of doubles in an NSData* object that is persisted as a binary property in a Core Data (SQLite) data model. I am doing this to store sampled data for graphing in an iPhone app. Sometimes when there are more than 300 doubles in the binary object not all the doubles are getting saved to disk. When I quit and relaunch my app there may be as few as 25 data points that have persisted or as many as 300. Using NSSQLitePragmasOption with synchronous = FULL and this may be making a difference. It is hard to tell, as bug is intermittent. Given the warnings about performance problems as a result of using synchronous = FULL, I am seeking advice and pointers. Thanks. [[ Edit: here is code. ]] The (as yet unrealized) intent of -addToCache: is to add each new datum to the cache but only flush (fault?) Data object periodically. From Data.m @dynamic dataSet; // NSData * attribute of Data entity - (void) addDatum:(double_t)datum { DLog(@"-[Data addDatum:%f]", datum); [self addToCache:datum]; } - (void) addToCache:(double_t)datum { if (cache == nil) { cache = [NSMutableData dataWithData:[self dataSet]]; [cache retain]; } [cache appendBytes:&datum length:sizeof(double_t)]; DLog(@"-[Data addToCache:%f] ... [cache length] = %d; cache = %p", datum, [cache length], cache); [self flushCache]; } - (void) wrapup { DLog(@"-[Data wrapup]"); [self flushCache]; [cache release]; cache = nil; DLog(@"[self isFault] = %@", [self isFault] ? @"YES" : @"NO"); // [self isFault] is always NO. } - (void) flushCache { DLog(@"flushing cache to store"); [self setDataSet:cache]; DLog(@"-[Data flushCache:] [[self dataSet] length] = %d", [[self dataSet] length]); } - (double*) bytes { return (double*)[[self dataSet] bytes]; } - (NSInteger) count { return [[self dataSet] length]/sizeof(double); } - (void) dump { ALog(@"Dump Data"); NSInteger numDataPoints = [self count]; double *data = (double*)[self bytes]; ALog(@"numDataPoints = %d", numDataPoints); for (int i = 0; i
