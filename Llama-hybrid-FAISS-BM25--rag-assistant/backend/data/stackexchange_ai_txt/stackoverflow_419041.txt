[site]: stackoverflow
[post_id]: 419041
[parent_id]: 419022
[tags]: 
and that both ways would require the use of free(). No, only the first needs the use of a free. The second is allocated on the stack. That makes it incredibly fast to allocate. Look here: void doit() { /* ... */ /* SP += 10 * sizeof(int) */ int a[10]; /* ... (using a) */ } /* SP -= 10 */ When you create it, the compiler at compile time knows its size and will allocate the right size at the stack for it. The stack is a large chunk of continuous memory located somewhere. Putting something at the stack will just increment (or decrement depending on your platform) the stackpointer. Going out of scope will do the reverse, and your array is freed. That will happen automatically. Therefor variables created that way have automatic storage duration. Using malloc is different. It will order some arbitrary large memory chunk (from a place called freestore ). The runtime will have to lookup a reasonably large block of memory. The size can be determined at runtime, so the compiler generally cannot optimize it at compile time. Because the pointer can go out of scope, or be copied around, there is no inherent coupling between the memory allocated, and the pointer to which the memory address is assigned, so the memory is still allocated even if you have left the function long ago. You have to call free passing it the address you got from malloc manually if the time has come to do so. Some "recent" form of C, called C99, allows you to give arrays an runtime size. I.e you are allowed to do: void doit(int n) { int a[n]; // allocate n * sizeof(int) size on the stack */ } But that feature should better be avoided if you don't have a reason to use it. One reason is that it's not failsafe: If no memory is available anymore, anything can happen. Another is that C99 is not very portable among compilers.
