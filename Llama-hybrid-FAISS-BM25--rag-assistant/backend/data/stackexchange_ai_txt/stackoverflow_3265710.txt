[site]: stackoverflow
[post_id]: 3265710
[parent_id]: 3265637
[tags]: 
Personally, I see nothing wrong with accessing the private member within the class. In fact that's what I typically do (unless there's logic within the property getter/setter that I always want to leverage). It just makes sense to me: the code within the class constitutes that class's implementation; why hide an implementation from itself? Here's an example of what I mean. Suppose I have some member, m_denominator , and I want it never to be zero: private int m_denominator = 1; public int Denominator { get { return m_denominator; } set { if (value == 0) throw new ArgumentException("Denominator must not be zero."); m_denominator = value; } } I might say to myself: "OK, everywhere I set this value within this class, I should use Denominator to make sure I'm not setting it to zero." But I'm completely in control of what I'm setting Denominator to -- I'm inside the class! In this scenario, the point of the logic in the Denominator property is to protect the class from invalid values set by client code. There's no excuse for setting your internal state to some invalid value within the implementation of a class itself. Of course this is not an absolute rule. There are surely times when using the property for its logic within a class may be a sensible choice as a protective measure; really, I'm just arguing that it's not wrong to access private members from within a class.
