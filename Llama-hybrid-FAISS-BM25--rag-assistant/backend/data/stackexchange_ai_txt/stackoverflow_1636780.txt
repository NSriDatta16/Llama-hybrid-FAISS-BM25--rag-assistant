[site]: stackoverflow
[post_id]: 1636780
[parent_id]: 1636760
[tags]: 
There are many problems with your code. First of all, you should not use malloc and friends if you are programming in C++. char *g = (char*) malloc (sizeof(char) * 2); g = "ab"; Ooops. You just lost the 2 bytes of memory returned by the malloc call because now g points to the possibly read only location where "ab" is stored. g = (char*) realloc (g, sizeof(char) * 200); realloc can only be called on a pointer returned by an earlier malloc . Even if you had passed a valid pointer to realloc , realloc may return NULL if the re-allocation fails. In that case, the memory previously allocated remains allocated but you would overwrite the only variable pointing to that memory making it impossible to free the earlier allocation. See Having dynamically allocated an array, can I change its size? in the C FAQ list. Also, note that "ab" requires three bytes of storage, not two. Finally, sizeof(char) is always and everywhere 1, so there is no need to use sizeof(char) in your malloc calls. A correct C version of your program would look like this: #include #include #include int main (void) { char *tmp; char *g = malloc(3); if ( !g ) { return EXIT_FAILURE; } strcpy(g, "ab"); tmp = realloc (g, 200); if ( !tmp ) { return EXIT_FAILURE; } g = tmp; strcpy (g, "cdefg"); puts(g); return 0; } In the C++ version, you would use string rather than plan old C style character arrays. See my answer to another question for an example of how to reallocate a buffer to read complete lines for the second part of your question. However, note that code is also C and I am sure there are better ways of doing what you want in C++. I just do not know enough of the C++ standard library to give you a correct solution in C++.
