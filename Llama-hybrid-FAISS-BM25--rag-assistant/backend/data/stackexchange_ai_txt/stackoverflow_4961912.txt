[site]: stackoverflow
[post_id]: 4961912
[parent_id]: 4961342
[tags]: 
From the C language standard (draft n1256 ): 6.3.2.1 Lvalues, arrays, and function designators ... 3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type ’’ is converted to an expression with type ‘‘pointer to type ’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined. Memorize that paragraph, since one of the biggest sources of heartburn in C programming is how C treats array expressions. When you call doStuff(afm1); , the expression afm1 is implicitly converted from type "9-element array of int " to "pointer to int ", and the expression's value is the same as &afm1[0] . So what doStuff receives is a pointer value, not an array. In the context of a function parameter declaration, T a[] and T a[N] are both interpreted as T *a : 6.7.5.3 Function declarators (including prototypes) ... 7 A declaration of a parameter as ‘‘array of type ’’ shall be adjusted to ‘‘qualified pointer to type ’’, where the type qualifiers (if any) are those specified within the [ and ] of the array type derivation. If the keyword static also appears within the [ and ] of the array type derivation, then for each call to the function, the value of the corresponding actual argument shall provide access to the first element of an array with at least as many elements as specified by the size expression. Since doStuff receives a pointer value and not an array, the sizeof trick doesn't work. In general, you have to explicitly tell a function how large of an array you're passing to it; you can't determine that from the pointer value itself. So, when you call doStuff from main , you'll need to do something like doStuff(afm1, sizeof afm1/sizeof *afm1); ... int doStuff(int *afm, size_t afmsize) { ... }
