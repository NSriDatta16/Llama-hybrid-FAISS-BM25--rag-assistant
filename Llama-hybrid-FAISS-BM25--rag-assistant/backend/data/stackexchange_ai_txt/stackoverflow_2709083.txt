[site]: stackoverflow
[post_id]: 2709083
[parent_id]: 
[tags]: 
Boost's "cstdint" Usage

Boost's C99 stdint implementation is awfully handy. One thing bugs me, though. They dump all of their typedefs into the boost namespace . This leaves me with three choices when using this facility: Use " using namespace boost " Use " using boost::[u] _t " Explicitly refer to the target type with the boost:: prefix; e.g., boost::uint32_t foo = 0; Option № 1 kind of defeats the point of namespaces. Even if used within local scope (e.g., within a function), things like function arguments still have to be prefixed like option № 3. Option № 2 is better, but there are a bunch of these types, so it can get noisy. Option № 3 adds an extreme level of noise; the boost:: prefix is often ≥ to the length of the type in question. My question is: What would be the most elegant way to bring all of these types into the global namespace? Should I just write a wrapper around boost/cstdint.hpp that utilizes option № 2 and be done with it? Also, wrapping the header like so didn't work on VC++ 10 (problems with standard library headers): namespace Foo { #include namespace boost_alias = boost; } using namespace Foo::boost_alias; EDIT: I guess another option is to use the preprocessor to make it work on VC 10? Taking the snippet above: #ifndef FOO_HPP_INCLUDED #define FOO_HPP_INCLUDED #if _MSC_VER >= 1600 /*VC++ 10*/ || defined USE_NATIVE_STDINT_HEADER #include #else namespace cstdint_wrapper { #include namespace boost_alias = boost; } using namespace cstdint_wrapper::boost_alias; #endif #endif Less work, I guess?
