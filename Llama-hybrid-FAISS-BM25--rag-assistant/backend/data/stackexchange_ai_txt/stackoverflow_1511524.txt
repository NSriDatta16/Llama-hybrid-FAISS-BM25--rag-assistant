[site]: stackoverflow
[post_id]: 1511524
[parent_id]: 1510041
[tags]: 
we can inherit our non-XAML UserControls from each other I don't understand. What about MVVM precludes inheritance? we use as much code-behind as we want which expedites development Code-behind is fine as long as it's code that is concerned with the view. ie. not business logic that you want to test. Separation of concerns and all. You can still do MVVM whilst doing everything in code - even your view. MVVM is not about zero code behind. It's about separating concerns and the benefits you derive from that. If you have no need to design your views in Blend, then by all means you can manifest much or all of the view as code. Heck, even if you do need to do work in Blend, there's a certain amount of your view that could still be manifested as code. You just need to evaluate the trade-offs and make conscious and informed decisions. attaching the infragistic controls directly to our model class coming from the web service cleared up dozens of little binding problems we were having with binding Infragistics to ObservableCollections The Infragistics controls are extremely poor. There, I said it. If it's an option, don't use them. If it is not an option (and I've been in this position too), you can normally work around many issues with attached behaviors and other techniques. It's a hassle, yes, but don't blame MVVM - blame Infragistics for producing a control set that is so at odds with the WPF platform. even in straight WPF, the lack of ObservableCollections make problems like not being able to create a simple Menu go away I don't understand this point at all. ObservableCollections are part of WPF, not MVVM. And having read your question (again - I replied to it not long after you submitted it) I'd say this is just your misunderstanding of how WPF works - nothing to do with MVVM at all. we are replacing the EventAggregator one-by-one with direct events using UserControls and code behind, which cleared up all kinds of problems with events Right tool for the right job. If you're able to use direct events, then you can do so whether you're using MVVM or not. MVVM does not in any way require the use of the event aggregator pattern, so again your point is unclear. The event aggregator pattern can be used to ensure that different components can collaborate at runtime without having any compile-time dependencies. By using standard CLR events, you're creating strong dependencies between your components. Should you ever want to use them in isolation, you're gonna have one heck of a time. In summary, this doesn't much of a case against MVVM, but more a lack of understanding. I think you're swimming upstream and I'd advise you to take a closer look at MVVM. It's not a silver bullet or one-size-fits-all pattern, but it can sure help create a fantastic basis for your WPF/SL applications when used correctly.
