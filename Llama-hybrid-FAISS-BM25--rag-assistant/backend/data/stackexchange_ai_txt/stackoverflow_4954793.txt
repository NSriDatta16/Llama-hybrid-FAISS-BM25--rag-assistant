[site]: stackoverflow
[post_id]: 4954793
[parent_id]: 4949807
[tags]: 
Binding converter is always executed on UI thread. So you could start other thread in Convert method but eventually (as you need feedback from this thread) you have to wait until it completes, thereby you're blocking your app. In order to solve this problem, for example, you could use Binding.IsAsync property : public class ListItemViewData { private readonly Uri _uri; private readonly Sex _sex; ListItemViewData(Uri uri, Sex sex) { this._uri = uri; this._sex = sex; } public BitmapSource Image { get { // Do synchronous WebRequest } } } Usage in xaml (inside DataTemplate of listbox item): EDITED I've dived into BitmapImage class and have found out that it has pretty ctor with Uri parameter, that works asynchronously. So you shouldn't execute WebRequest by yourself. Do just like this: public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { var uri = (Uri)value; return new BitmapImage(uri) { CacheOption = BitmapCacheOption.None }; } EDITED 2 Your view data class. public class ListItemViewData : INotifyPropertyChanged { public ListItemViewData(Uri uri) { this._uri = uri; } private readonly Uri _uri; public Uri Uri { get { return this._uri; } } private BitmapSource _source = null; public BitmapSource Image { get { return this._source; } set { this._source = value; this.OnPropertyChanged("Image"); } } public event PropertyChangedEventHandler PropertyChanged; private void OnPropertyChanged(string p) { var pc = this.PropertyChanged; if (pc!=null) { pc(this, new PropertyChangedEventArgs(p)); } } } Helper, that executes images downloading: public static class WebHelper { public static Stream DownloadImage(Uri uri, string savePath) { var request = WebRequest.Create(uri); var response = request.GetResponse(); using (var stream = response.GetResponseStream()) { Byte[] buffer = new Byte[response.ContentLength]; int offset = 0, actuallyRead = 0; do { actuallyRead = stream.Read(buffer, offset, buffer.Length - offset); offset += actuallyRead; } while (actuallyRead > 0); File.WriteAllBytes(savePath, buffer); return new MemoryStream(buffer); } } } When you are filling model - you should start separate thread, which will download files and set up images source. this._listItems.Add(new ListItemViewData(new Uri(@"http://lifeboat.com/images/blue.ocean.jpg"))); //... var sc = SynchronizationContext.Current; new Thread(() => { foreach (var item in this._listItems) { var path = "c:\\folder\\"+item.Uri.Segments.Last(); var stream = WebHelper.DownloadImage(item.Uri, path); sc.Send(p => { BitmapImage bi = new BitmapImage(); bi.BeginInit(); bi.StreamSource = (Stream)p; bi.EndInit(); item.Image = bi; }, stream); } }).Start();
