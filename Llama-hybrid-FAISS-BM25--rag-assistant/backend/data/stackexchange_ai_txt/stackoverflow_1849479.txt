[site]: stackoverflow
[post_id]: 1849479
[parent_id]: 1849243
[tags]: 
Final Answer: Add an extra argument to the decorator indicating what is being decorated There may be something more elegant, but this works. from django.core.cache import cache from django.db.models.query import QuerySet try: from cPickle import dumps except: from pickle import dumps from hashlib import sha1 cache_miss = object() class CantPickleAQuerySet(Exception): pass def cache_function(cache_timeout, func_type='generic'): def wrapper(fn): def decorator(*args, **kwargs): try: cache_indentifiers = "%s%s%s%s" % ( fn.__module__, fn.__name__, dumps(args), dumps(kwargs) ) except Exception, e: print "Error: %s\nFailed to generate cache key: %s%s" % (e, fn.__module__, fn.__name__) return fn(*args, **kwargs) cache_key = sha1(cache_indentifiers).hexdigest() value = cache.get(cache_key, cache_miss) if value is cache_miss: value = fn(*args, **kwargs) if isinstance(value, QuerySet): raise CantPickleAQuerySet("You can't cache a queryset. But you CAN cache a list! just convert your Queryset (the value you were returning) to a list like so `return list(queryset)`") try: cache.set(cache_key, value, cache_timeout) except Exception, e: print "Error: %s\nFailed to cache: %s\nvalue: %s" % (e, cache_indentifiers, value) return value no_arg2 = object() def filter_decorator(arg1, arg2=no_arg2): if arg2 is no_arg2: return decorator(arg1) else: return decorator(arg1, arg2) if func_type == 'generic': return decorator elif func_type == 'filter': return filter_decorator return wrapper
