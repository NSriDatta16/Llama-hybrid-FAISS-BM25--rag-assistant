[site]: stackoverflow
[post_id]: 3505496
[parent_id]: 3504524
[tags]: 
My first problem was how to update the managed entity from the database with the unmanaged object coming from the client. Since the data sent to the client deliberately omits database keys, this was a bit tedious as it came down to explicitly "merging" elements from the unmanaged object into the Hibernate object. This isn't my question, but if anyone knows of an elegant way to do this, I'd be very interested to hear about it. Either you should include the id to the resource the client is sending or use PUT (e.g. PUT /object/{objectId} ). Then you don't need to merge but just "replace". I prefer to always return and expect complete resources. It avoid the yucky merging. My second problem, and the object of this post, occurs when I press the "save and close" button around the same time as the auto-save operation I mentioned earlier is going on. More often than not, I get an optimistic locking exception. This is because the second update operation is being handled in a separate thread while the first is still being processed. As you mentioned you can do this on client-side by JavaScript. You can introduce a 'dirty' flag and both the auto-save or the save-close button only transmit a request to server when the flag 'dirty' is set. The 'dirty' flag is toggled, when the user changed something. I would not let the server serialize requests, it complicates things. [...] However, I'm concerned that forcing this limitation on the client may be deviating from the spirit of ReST. Is it reasonable to expect a given client to have no more than one outstanding "update" (PUT) request to a particular resource at any point in time in a ReSTful application? Some of the spirit of REST is to decouple stuff and client can well decide when to do CRUD operations. BTW: There is a great frontend java-script framework which goes very well with REST apis: extJS . It worked well for us for internal applications (I wouldn't do a public website with extJS because of the extJS-style look&feel).
