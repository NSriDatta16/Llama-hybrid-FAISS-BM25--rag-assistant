[site]: stackoverflow
[post_id]: 2303528
[parent_id]: 2303490
[tags]: 
In theory, there's nothing preventing a linker from handling this -- basically do a topological sort among the dependencies to come up with an initialization order. Existing linkers don't do it though, and C++ mostly depends on existing linkers... Edit: From the viewpoint of the standard, the solution to this problem is utterly trivial: one sentence to require that all objects with static storage duration are initialized prior to main() beginning execution. Unfortunately, about all that would accomplish is raising another area in which virtually nobody conforms with the standard, or (worse) even has a plan to do so. For it to mean anything, the implementers on the committee have to agree that it's sufficiently important that they're going to implement it. You're right that it's easy to look around and see that people have problems with this. At the same time, I don't know of a single vendor who seems to consider it a real problem. None of them seems to have worked on it yet. None of them has it scheduled for a future release. As far as I can see, it hasn't even made it onto anybody's "it would be nice if we could someday" list. That brings us back to what I originally said: even though it may look like a serious problem to us as users, it apparently doesn't look that way to most implementers. I can see a number of reasons that might be so. First, of course, is that C++ isn't a key item in anybody's corporate agenda. Microsoft pushes .NET. Sun/Oracle and IBM push Java. Others have their own agendas, but none of them is trying to get you to use C++. It looks to me like most of them consider it a necessary evil, not something to which they really want to devote any effort at all. That being the case, working on completely re-designing the guts of their linker to handle this particular problem would probably only even be open to consideration if they got a lot of complaints about it. That as two problems. First of all, C++ starts out as a fairly small community, so it would take a huge percentage of them before implementers really noticed anything they said. Second, only a fairly small percentage of C++ programmers really run into problems with this anyway. About the only reason they'd bother or care would be if it became an issue for their own, internal development. Unfortunately, most have little reason to care about portability.
