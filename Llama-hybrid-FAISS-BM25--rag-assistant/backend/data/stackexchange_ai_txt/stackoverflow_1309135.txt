[site]: stackoverflow
[post_id]: 1309135
[parent_id]: 1308039
[tags]: 
The following program works by directly calculating the coordinates of a number. The method NumberToPoint() performs the following mapping. 0 => (x0 , y0 ) 1 => (x0 + 1, y0 ) 2 => (x0 + 1, y0 - 1) 3 => (x0 , y0 - 1) 4 => (x0 - 1, y0 - 1) 5 => (x0 - 1, y0 ) 6 => ... The rest is a very simple prime number test and a small console application. In order to save an image I would consider two solutions. If you can create a buffer for the whole image, you can just use the program below to fill the buffer. If the buffer would be to large, I would create a method PointToNumber() and invert the calculation - the method takes two coordinates and returns the number at this point. With this method you can iterate from top to bottom and left to right and calculate the number at this point, check if it is prime, and output the pixel as you go without a buffer. But for both solutions the image size should be be known before you start, because adding pixels at the top and left is quite expensive (but of cause possible). Questions Any good ideas for converting the coefficient lookup in NumberToPoint() into rock solid math without using modulo, integer division, and sign a thousand times? Any good ideas to shorten or speed up the prime number test? Code using System; using System.Drawing; using System.Linq; using System.Threading; namespace UlamsSpiral { public static class Program { public static void Main() { Int32 width = 60; Int32 height = 60; Console.SetWindowSize(Math.Min(width, 120), Math.Min(height, 60)); Console.SetBufferSize(width, height); Console.CursorVisible = false; Int32 limit = (Int32)Math.Pow(Math.Min(width, height) - 2, 2); for (Int32 n = 1; n n % m != 0); } } }
