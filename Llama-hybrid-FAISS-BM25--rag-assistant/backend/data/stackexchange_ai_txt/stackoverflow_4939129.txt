[site]: stackoverflow
[post_id]: 4939129
[parent_id]: 4936261
[tags]: 
Don't retain a scheduled NSTimer if you've set its target to self Don't set self as the target of a repeating timer unless you are absolutely sure to know all the consequences (...otherwise the runtime drowns a kitten in leaked timers, targets and userInfos — or so goes the saying.) Please read and re-read "Overview" in the NSTimer Class Reference and pay special attention to the last paragraph. In a nutshell: If you schedule an NSTimer, it becomes associated to the current run-loop which retains it. Furthermore, the timer retains its target . NSTimer instances are not reusable : "Once invalidated, timer objects cannot be reused" . So there is no point in retaining a scheduled timer in the first place. If you need to hang on to it (e.g. in order to cancel it) use a non-owning (aka weak) reference to it. Update: For a thorough explanation, see my answer to your other question (it now has graphs — albeit as links only — and stuff). Please consider the rest of this post (as well as many of my comments) as obsolete. Your property becomes @property (nonatomic, assign) NSTimer *walkTimer; BTW: -(void)cancelTimer { [self setWalkTimer:nil]; // great, now [self walkTimer] returns nil so [[self walkTimer] invalidate]; // here, you are calling [nil invalidate] } And since messaging nil is absolutely fine in Objective C, your crash miraculously vanishes...while your timer will happily continue to fire. Edit I've forgot to mention: A timer wants a selector that takes one argument, which will be the timer that fired... Or is that just a typo?
