[site]: stackoverflow
[post_id]: 5623259
[parent_id]: 5623172
[tags]: 
The problem is that my (@ctc_rec,$i) = ((),0); doesn't do what you think it does. It means the same as my @ctc_rec = (0); my $i; strict is doing what it's meant to and catching your mistake. Try writing: my @ctc_rec; my $i = 0; instead. That should get rid of the error. In this case, there's another way to get rid of the error, and simplify your code considerably at the same time: use selectall_arrayref . sub get_expected_contacts { return $db1->selectall_arrayref( "SELECT DISTINCT field1, field2, field3 FROM table WHERE field4 = ? AND field5 = ? AND field6 = 'E'", undef, @_ ); } If you really were intentionally doing something that was prohibited by strict (but knew what you were doing), you can disable strict locally: use strict; # this code is strict { no strict; # some code that is not strict here } # strict is back in effect now But you should never do that until you understand exactly what strict is complaining about, and why it's ok to do that in this instance. It's also better to disable only the part of strict that you have to. For instance, you can say no strict 'refs'; to allow symbolic references without disabling the other things strict does. (Note: The same technique works with the warnings pragma, which you should also be using.)
