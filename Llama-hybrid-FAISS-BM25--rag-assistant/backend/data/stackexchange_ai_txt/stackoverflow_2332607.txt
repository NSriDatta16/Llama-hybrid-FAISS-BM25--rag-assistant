[site]: stackoverflow
[post_id]: 2332607
[parent_id]: 2332553
[tags]: 
If you are writing recursive functions that keep stack-local references to large data that is not needed in sub-recursive calls, then this is a type of space leak, but it is very unusual to have this be a problem in practice. More generally, if you have something like Main() { var s = ReadInAGiganticString(); // say 10 Megs long Server(s.Substring(0,5)); // but I only care about first 5 chars } Server(s) { while(true) { ... } // but 10M is on stack forever } then this is a kind of stack-space-leak, but again, it is unlikely in practice. The fix is easy: Main() { var s = ReadInAGiganticString(); var t = s.Substring(0,5); s = null; // the fix Server(t); } Server(s) { while(true) { ... } } In general, if you ever have a giant variable on the stack right before a call that will last 'a long time' and the variable is no longer used, you can null it out to ensure it can be GC'd before going into the 'long' call. (It is possible that an optimizer may do this for you based on reachability analysis.) Note that the above answer is for references to heap-allocated objects that are rooted on the stack. If, on the other hand, you have stack-allocated memory (e.g. a gigantic struct or stackalloc thingie), then the fix is not as easy, but this is even rarer in practice (who ever creates giant structs?).
