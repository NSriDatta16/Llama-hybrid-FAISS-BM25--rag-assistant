[site]: stackoverflow
[post_id]: 3768729
[parent_id]: 3766074
[tags]: 
A compiler vendor who wants to write a conforming compiler is bound to what the Standard has to say, but not to your reasoning. The Standard says that an array subscript out of range is undefined behaviour, without any exception , so the compiler is allowed to blow up. To cite my comment from our last discussion ( Does C99 guarantee that arrays are contiguous? ) "Your original question was for a[0][6] , with the declaration char a[5][5] . This is UB, no matter what. It is valid to use char *p = &a[3][4]; and access p[0] to p[5] . Taking the address &p[6] is still valid, but accessing p[6] is outside of the object, thus UB. Accessing a[0][6] is outside of the object a[0] , which has type array[5] of chars. The type of the result is irrelevant, it is important how you reach it." EDIT: There are enough cases of undefined behaviour where you have to scan through the whole Standard, collect the facts and combine them to finally get to the conclusion of undefined behaviour. This one is explicit , and you even cite the sentence from the Standard in your question. It is explicit and leaves no space for any workarounds. I'm just wondering how much more explicitness in reasoning do you expect from us to become convinced that it really is UB? EDIT 2: After digging through the Standard and collecting information, here is another relevant citation: 6.3.2.1 - 3: Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue . If the array object has register storage class, the behavior is undefined. So I think this is valid: unsigned char *p = a[1]; unsigned char c = p[7]; // Strict aliasing not applied for char types This is UB: unsigned char c = a[1][7]; Because a[1] is not an lvalue at this point, but evaluated further, violating J.2 with an array subscript out of range. What really happens should depend on how the compiler actually implements the array indexing in multidimensional arrays. So you may be right that it doesn't make any difference on every known implementation. But that's a valid undefined behaviour, too. ;)
