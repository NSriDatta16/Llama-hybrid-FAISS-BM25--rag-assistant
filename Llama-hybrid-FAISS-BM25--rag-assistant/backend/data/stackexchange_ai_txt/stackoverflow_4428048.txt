[site]: stackoverflow
[post_id]: 4428048
[parent_id]: 
[tags]: 
What could cause malloc to initialise memory?

I am writing code to use a library called SCIP (solves optimisation problems). The library itself can be compiled in two ways: create a set of .a files, then the binary, OR create a set of shared objects. In both cases, SCIP is compiled with it's own, rather large, Makefile. I have two implementations, one which compiles with the .a files (I'll call this program 1), the other links with the shared objects (I'll call this program 2). Program 1 is compiled using a SCIP-provided makefile, whereas program 2 is compiled using my own, much simpler makefile. The behaviour I'm encountering occurs in the SCIP code, not in code that I wrote. The code extract is as follows: void* BMSallocMemory_call(size_t size) { void* ptr; size = MAX(size, 1); ptr = malloc(size); // This is where I call gdb print statements. if( ptr == NULL ) { printf("ERROR - unable to allocate memory for a SCIP*.\n"); } return ptr; } void SCIPcreate(SCIP** A) { *A = (SCIP*)BMSallocMemory_call(sizeof(**(A))) . . . } If I debug this code in gdb, and step through BMSallocMemory_call() in order to see what's happening, and view the contents of *((SCIP*)(ptr)) , I get the following output: Program 1 gdb output: 289 size = MAX(size, 1); (gdb) step 284 { (gdb) 289 size = MAX(size, 1); (gdb) 290 ptr = malloc(size); (gdb) print ptr $1 = (gdb) step 292 if( ptr == NULL ) (gdb) print ptr $2 = (gdb) step 290 ptr = malloc(size); (gdb) print ptr $3 = (void *) 0x8338448 (gdb) print *((SCIP*)(ptr)) $4 = {mem = 0x0, set = 0x0, interrupt = 0x0, dialoghdlr = 0x0, totaltime = 0x0, stat = 0x0, origprob = 0x0, eventfilter = 0x0, eventqueue = 0x0, branchcand = 0x0, lp = 0x0, nlp = 0x0, relaxation = 0x0, primal = 0x0, tree = 0x0, conflict = 0x0, cliquetable = 0x0, transprob = 0x0, pricestore = 0x0, sepastore = 0x0, cutpool = 0x0} Program 2 gdb output: 289 size = MAX(size, 1); (gdb) step 290 ptr = malloc(size); (gdb) print ptr $1 = (void *) 0xb7fe450c (gdb) print *((SCIP*)(ptr)) $2 = {mem = 0x1, set = 0x8232360, interrupt = 0x1, dialoghdlr = 0xb7faa6f8, totaltime = 0x0, stat = 0xb7fe45a0, origprob = 0xb7fe4480, eventfilter = 0xfffffffd, eventqueue = 0x1, branchcand = 0x826e6a0, lp = 0x8229c20, nlp = 0xb7fdde80, relaxation = 0x822a0d0, primal = 0xb7f77d20, tree = 0xb7fd0f20, conflict = 0xfffffffd, cliquetable = 0x1, transprob = 0x8232360, pricestore = 0x1, sepastore = 0x822e0b8, cutpool = 0x0} The only reason I can think of is that in either program 1's or SCIP's makefile, there is some sort of option that forces malloc to initialise memory it allocates. I simply must learn why the structure is initialised in the compiled implementation, and is not in the shared object implementation.
