[site]: stackoverflow
[post_id]: 4320873
[parent_id]: 4320610
[tags]: 
This code has much more serious issues than you can fix by adding a const or a typecast somewhere. The result of this code will ultimately be a crash somewhere down the line, because you're passing a pointer to a temporary. Once you finish with line of code that calls addElement , the pointer will be left dangling, and trying to use the object it points to will either result in nonsense (if you're reading the object) or stack corrpution (if you're writing to the object). The best way to redefine your code would be to change this to bool Set::addElement(Multinumber newElement) //pass the Multinumber by value and call addElement as follows: result.addElement(*setArray[i] + *rhs.setArray[j]); Note that I eliminated all of the extra parentheses because * has lower precedence than [] , so the parentheses around setArray[i] and setArray[i] were redundant. I think the code is more readable this way. Well really, if I can guess what's going on here, setArray is the internal storage of the Set class, so it's type will need to be redefined from Multinumber** to Multinumber* , in which case the call really should be result.addElement(setArray[i] + rhs.setArray[j]); EDIT Ugggh. None of the above will actually allow you to keep your polymorphism. You need to call new Rational somewhere, and the only reasonable place that I can think of is: result.addElement( new Rational(*setArray[i] + *rhs.setArray[j]) ); This will work without having to redefine Set::addElement . A better solution would be to redesign the whole thing so that it doesn't depend on polymorphism for numeric classes (because numeric classes really shouldn't be wrapped in pointers in most normal use).
