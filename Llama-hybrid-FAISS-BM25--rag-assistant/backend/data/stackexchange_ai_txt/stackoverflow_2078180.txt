[site]: stackoverflow
[post_id]: 2078180
[parent_id]: 2075497
[tags]: 
There are a couple of problems with your program. What you are doing is equivalent of: char data[SIZE]; char *p; /* get some useful value in data */ p = data; In the context of the last line , data refers to a pointer that points to the first element of the array data (i.e., the line is equivalent to p = &data[0]; ). So, what you just did was to assign to the pointer p the value of the address of the first character in data . Later, when you change the contents of data , the pointer to the first element of data is still the same ( data still exists at the same memory location). So, all your pointers refer to the same storage, and you keep overwriting what's in the storage. But then why does your program work when you provide literal strings? Because each literal string in C is guaranteed to exist throughout the life of the program and has a unique address. (There is a minor exception: if you use a literal string more than once in your program, it may or may not refer to the same memory.) So, you should dynamically allocate memory for firstName , lastName , and phoneNumber members of your nodes, and remember to free them when you are done with it. void addEntry(char *fn, char *ln, char *pn) { struct bookNode *tempNode, *iterator; tempNode = malloc(sizeof *tempNode); tempNode->firstName = malloc(strlen(fn) + 1); /* +1 for terminating 0 */ tempNode->lastName = malloc(strlen(ln) + 1); tempNode->phoneNumber = malloc(strlen(pn) + 1); /* Omitted check for malloc failures for brevity */ strcpy(tempNode->firstName, fn); strcpy(tempNode->lastName, ln); strcpy(tempNode->phoneNumber, pn); /* Now continue with what you were doing */ } Then, you will need a corresponding freeEntry function to free up the space. Another way to do this would be to declare your struct differently: #define MAX 20 struct bookNode { char firstName[MAX]; char lastName[MAX]; char phoneNumber[MAX]; struct bookNode *next; } *head; Then, your addEntry function doesn't need the malloc() calls for firstName , lastName , and phoneNumber , but you still need to copy data using strcpy() . (To know the reason, please refer to the link above.) Your corresponding freeEntry() function also wouldn't need to free those members. Now, for the rest of your program. Your way of finding a terminating newline works, but you can simplify it by using strchr() standard C function. The call in your case would look like: char *nl; if ((nl = strchr(first, '\n')) != NULL) { *nl = '\0'; } Finally, when you fix all the above, you will find that you are getting the last record twice in your phone book. In C, feof() doesn't tell you if you are at the end of file now: it tells you that the last attempt to read from the file failed because you were at end of the file.
