[site]: stackoverflow
[post_id]: 4352950
[parent_id]: 3359816
[tags]: 
All of these answers are very good. I love the simplicity of Mr. Meacham's GenericHandlerRouteHandler class. It is a great idea to eliminate an unnecessary reference to a virtual path if you know the specific HttpHandler class. The GenericHandlerRoute class is not needed, however. The existing Route class which derives from RouteBase already handles all of the complexity of route matching, parameters, etc., so we can just use it along with GenericHandlerRouteHandler . Below is a combined version with a real-life usage example that includes route parameters. First are the route handlers. There are two included, here -- both with the same class name, but one that is generic and uses type information to create an instance of the specific HttpHandler as in Mr. Meacham's usage, and one that uses a virtual path and BuildManager to create an instance of the appropriate HttpHandler as in shellscape's usage. The good news is that .NET allows both to live side by side just fine, so we can just use whichever we want and can switch between them as we wish. using System.Web; using System.Web.Compilation; using System.Web.Routing; public class HttpHandlerRouteHandler : IRouteHandler where T : IHttpHandler, new() { public HttpHandlerRouteHandler() { } public IHttpHandler GetHttpHandler(RequestContext requestContext) { return new T(); } } public class HttpHandlerRouteHandler : IRouteHandler { private string _VirtualPath; public HttpHandlerRouteHandler(string virtualPath) { this._VirtualPath = virtualPath; } public IHttpHandler GetHttpHandler(RequestContext requestContext) { return (IHttpHandler) BuildManager.CreateInstanceFromVirtualPath(this._VirtualPath, typeof(IHttpHandler)); } } Let's assume that we created an HttpHandler that streams documents to users from a resource outside our virtual folder, maybe even from a database, and that we want to fool the user's browser into believing that we are directly serving a specific file rather than simply providing a download (i.e., allow the browser's plug-ins to handle the file rather than forcing the user to save the file). The HttpHandler may expect a document id with which to locate the document to provide, and may expect a file name to provide to the browser -- one that may differ from the file name used on the server. The following shows the registration of the route used to accomplish this with a DocumentHandler HttpHandler : routes.Add("Document", new Route("document/{documentId}/{*fileName}", new HttpHandlerRouteHandler ())); I used {*fileName} rather than just {fileName} to allow the fileName parameter to act as an optional catch-all parameter. To create a URL for a file served by this HttpHandler , we can add the following static method to a class where such a method would be appropriate, such as in the HttpHandler class, itself: public static string GetFileUrl(int documentId, string fileName) { string mimeType = null; try { mimeType = MimeMap.GetMimeType(Path.GetExtension(fileName)); } catch { } RouteValueDictionary documentRouteParameters = new RouteValueDictionary { { "documentId", documentId.ToString(CultureInfo.InvariantCulture) } , { "fileName", DocumentHandler.IsPassThruMimeType(mimeType) ? fileName : string.Empty } }; return RouteTable.Routes.GetVirtualPath(null, "Document", documentRouteParameters).VirtualPath; } I omitted the definitions of MimeMap and and IsPassThruMimeType to keep this example simple. But these are intended to determine whether or not specific file types should provide their file names directly in the URL, or rather in a Content-Disposition HTTP header. Some file extensions could be blocked by IIS or URL Scan, or could cause code to execute that might cause problems for users -- especially if the source of the file is another user who is malicious. You could replace this logic with some other filtering logic, or omit such logic entirely if you are not exposed to this type of risk. Since in this particular example the file name may be omitted from the URL, then, obviously, we must retrieve the file name from somewhere. In this particular example, the file name can be retrieved by performing a look-up using document id, and including a file name in the URL is intended solely to improve the user's experience. So, the DocumentHandler HttpHandler can determine if a file name was provided in the URL, and if it was not, then it can simply add a Content-Disposition HTTP header to the response. Staying on topic , the important part of the above code block is the usage of RouteTable.Routes.GetVirtualPath() and the routing parameters to generate a URL from the Route object that we created during the route registration process. Here's a watered-down version of the DocumentHandler HttpHandler class (much omitted for the sake of clarity). You can see that this class uses route parameters to retrieve the document id and the file name when it can; otherwise, it will attempt to retrieve the document id from a query string parameter (i.e., assuming that routing was not used). public void ProcessRequest(HttpContext context) { try { context.Response.Clear(); // Get the requested document ID from routing data, if routed. Otherwise, use the query string. bool isRouted = false; int? documentId = null; string fileName = null; RequestContext requestContext = context.Request.RequestContext; if (requestContext != null && requestContext.RouteData != null) { documentId = Utility.ParseInt32(requestContext.RouteData.Values["documentId"] as string); fileName = Utility.Trim(requestContext.RouteData.Values["fileName"] as string); isRouted = documentId.HasValue; } // Try the query string if no documentId obtained from route parameters. if (!isRouted) { documentId = Utility.ParseInt32(context.Request.QueryString["id"]); fileName = null; } if (!documentId.HasValue) { // Bad request // Response logic for bad request omitted for sake of simplicity return; } DocumentDetails documentInfo = ... // Details of loading this information omitted if (context.Response.IsClientConnected) { string fileExtension = string.Empty; try { fileExtension = Path.GetExtension(fileName ?? documentInfo.FileName); } // Use file name provided in URL, if provided, to get the extension. catch { } // Transmit the file to the client. FileInfo file = new FileInfo(documentInfo.StoragePath); using (FileStream fileStream = file.OpenRead()) { // If the file size exceeds the threshold specified in the system settings, then we will send the file to the client in chunks. bool mustChunk = fileStream.Length > Math.Max(SystemSettings.Default.MaxBufferedDownloadSize * 1024, DocumentHandler.SecondaryBufferSize); // WARNING! Do not ever set the following property to false! // Doing so causes each chunk sent by IIS to be of the same size, // even if a chunk you are writing, such as the final chunk, may // be shorter than the rest, causing extra bytes to be written to // the stream. context.Response.BufferOutput = true; context.Response.ContentType = MimeMap.GetMimeType(fileExtension); context.Response.AddHeader("Content-Length", fileStream.Length.ToString(CultureInfo.InvariantCulture)); if ( !isRouted || string.IsNullOrWhiteSpace(fileName) || string.IsNullOrWhiteSpace(fileExtension)) { // If routed and a file name was provided in the route, then the URL will appear to point directly to a file, and no file name header is needed; otherwise, add the header. context.Response.AddHeader("Content-Disposition", string.Format("attachment; filename={0}", HttpUtility.UrlEncode(documentInfo.FileName))); } int bufferSize = DocumentHandler.SecondaryBufferSize; byte[] buffer = new byte[bufferSize]; int bytesRead = 0; while ((bytesRead = fileStream.Read(buffer, 0, bufferSize)) > 0 && context.Response.IsClientConnected) { context.Response.OutputStream.Write(buffer, 0, bytesRead); if (mustChunk) { context.Response.Flush(); } } } } } catch (Exception e) { // Error handling omitted from this example. } } This example uses some additional custom classes, such as a Utility class to simplify some trivial tasks. But hopefully you can weed through that. The only really important part in this class with regard to the current topic, of course, is the retrieval of the route parameters from context.Request.RequestContext.RouteData . But I've seen several posts elsewhere asking how to stream large files using an HttpHandler without chewing up server memory, so it seemed like a good idea to combine examples.
