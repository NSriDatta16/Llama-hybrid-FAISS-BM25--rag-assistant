[site]: stackoverflow
[post_id]: 881419
[parent_id]: 881363
[tags]: 
OK - to restate what I think you are asking for, you want to parse a file, and look for assigments of the form foo= { .... } and within the block, you want to move the comments to the end of the line. There are a number of ways to do this, the most elegant is usually related to what else you are doing in the loop. The one that springs to mind is just to remember the fact that the last line contained an '=' and use that fact when matching for '{' at the start of a line. Using one of my favourite perl constructs, the range operator in scalar context. So this would give... my $last_line_an_assignment = 0; while ( ) { if (($last_line_an_assignment && m!^\s*{!) .. m!^\s*}!) { s!(/\*.*?\*/)\s*(.*)$!$2 $1!; } print $_; $last_line_an_assignment = m!=!; } __DATA__ /* comment other */ (unsigned int a); other_assignment= /* not a table */ 12; array_table= { /* comment 1*/ (unsigned int a); /* comment 2*/ (unsigned int b); /* comment 3*/ (unsigned int c); /* comment 4*/ (unsigned int d); } /* comment other */ (unsigned int a); You can either print the data to another file, or you can update the files in place, using the '-i' option to perl local (@ARGV) = ($filename); local ($^I) = '.bak'; while (<>) { # make changes to line AND call print } This causes perl to make a backup of $filename (with extention '.bak'), and then all print calls in the loop will overwrite the contents if the file - for more information see the '-i' option in the "perlrun" manual page.
