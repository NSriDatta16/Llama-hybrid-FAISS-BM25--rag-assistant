[site]: stackoverflow
[post_id]: 2852234
[parent_id]: 2851991
[tags]: 
The problem is not related to initialization order, but rather to template instantiation. Templated code is instantiated on demand, that is, the compiler will not instantiate any templated code that is not used in your program. In particular, in your case the static class member FactoryBase<>::factory_helper_ is not being instantiated and thus it does not exist in the final binary, it does not register itself... (you can check this with 'nm' from the gnu toolchain, that will show the list of symbols present in your executable) Try changing the FactoryBase constructor to this: template class FactoryBase { //... FactoryBase(){ factory_helper_; } //... }; This will force the compiler into actually instantiating the static member in the binary and you should be set. There is no need to create an empty method and calling it. EDIT : As an answer to the comment, towards the end of paragraph ยง14.7.1[temp.inst]/1 in the current standard: Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; in particular, the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.
