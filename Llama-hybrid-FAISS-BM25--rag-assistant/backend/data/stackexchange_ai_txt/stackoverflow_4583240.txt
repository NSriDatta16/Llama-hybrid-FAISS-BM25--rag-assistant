[site]: stackoverflow
[post_id]: 4583240
[parent_id]: 4583125
[tags]: 
Yes, it's problematic. You simply have no guarantee that the memory is properly aligned. While various tricks exist to get storage with proper alignment, you're best off using Boost's or C++0x's aligned_storage , which hide these tricks from you. Then you just need: // C++0x typedef std::aligned_storage ::type storage_type; // Boost typedef boost::aligned_storage ::value>::type storage_type; storage_type storage; // properly aligned new (&storage) my_class(); // okay Note that in C++0x, using attributes, you can just do this: char storage [[align(my_class)]] [sizeof(my_class)];
