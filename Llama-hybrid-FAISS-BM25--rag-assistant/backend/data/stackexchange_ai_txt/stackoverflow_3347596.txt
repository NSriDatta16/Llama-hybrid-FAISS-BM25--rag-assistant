[site]: stackoverflow
[post_id]: 3347596
[parent_id]: 3346516
[tags]: 
You don't "make a method" at run time. That would amount to compiling new code. The methods that you assign to various event properties need to already exist. Furthermore, you can't "add events." The object you're deserializing already has events. You defined them when you wrote the class declaration in your Delphi code. You can't add new event properties to a class after it's been compiled. It appears that what you're really saying is that you have a standalone procedure that you happen to have named Method1 , and you want to pass it as a TNotifyEvent parameter when you call SetUpMethods . That's the wrong way to go. That Method1 procedure isn't a method, despite its name, so you mustn't use it where a method is required. Change that declaration so it belongs to a class , and then it will be a method. If you don't want to have to instantiate the class that the method belongs to, that's fine â€” you can declare it as a class method instead: class procedure TSomeClass.Method1(Sender: TNotifyEvent); I encourage you to change the declaration of AddMethod so that the last parameter is of type TMethod . Then you're sure to have both the code and data portions of the method pointer. Right now, you're assigning the data portion based on the object whose event property you're assigning, but as I mentioned in my comment, it's rare for that relationship to exist, especially now that the method belongs to an entirely unrelated class ( TSomeClass in my example). The value of the TMethod.Data field becomes the Self value when the method gets called. It's your responsibility to ensure that the value you store in that field is of a compatible type for the class the code belongs to.
