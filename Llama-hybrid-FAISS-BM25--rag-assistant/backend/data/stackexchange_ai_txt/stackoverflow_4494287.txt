[site]: stackoverflow
[post_id]: 4494287
[parent_id]: 4494251
[tags]: 
There are a few ways to do this. If you have only a couple objects that another class needs to utilize, use dependency injection; Pass each object as an argument into a class's constructor and store those objects as a class property. If only a single method needs the object, pass the object as an argument of the method. I discourage this approach though, because I feel it hinders expandability/code-cleanliness in the long run. If you have many objects that are needed in several classes, I recommend a registry that you inject into a class's constructor. The registry is a singleton (it holds a single instance of each object you need to share). In the class that needs to utilize a shared object, you might call $this->registry->get('Some_Shared_Object')->doSomething() . Dependency Injection (at the constructor) class Foo { protected $dependency1; protected $dependency2; protected $dependency3; public function __construct($dependency1, $dependency2, $dependency3) { $this->dependency1 = $dependency1; $this->dependency2 = $dependency2; $this->dependency3 = $dependency3; } public function foo() { $this->dependency1->doSomething(); } } $foo = new Foo($dependency1, $dependency2, $dependency3); $foo->foo(); Dependency Injection (at the method, not recommended) class Foo { public function foo($dependency1) { $dependency1->doSomething(); } } $foo = new Foo(); $foo->foo($dependency1); Dependency Injection using a Registry class Registry { var $data = array(); function __get($key) { return $this->get($key); } function __set($key, $value) { $this->set($key, $value); } /** * Retrieve a resource from the registry. * * @param string * @return mixed|null */ function get($key) { return isset($this->data[$key]) ? $this->data[$key] : NULL; } /** * Store a resource in the registry. * * @param string * @param mixed */ function set($key, &$value) { $this->data[$key] = $value; } /** * Check if a resource exists in the registry. * * @param string * @return boolean */ function has($key) { return isset($this->data[$key]); } } class Foo { protected $registry; public function __construct($registry) { $this->registry = $registry; } public function foo() { $this->registry->dependency1->doSomething(); } } $dependency1 = new Dependency1(); $registry = new Registry(); $registry->set('dependency1', $dependency1); $foo = new Foo($registry); $foo->foo();
