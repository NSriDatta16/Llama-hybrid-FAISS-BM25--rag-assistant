[site]: stackoverflow
[post_id]: 1275413
[parent_id]: 
[tags]: 
Tracking PHP Object property changes

I'm trying to track all changes made to a PHP variable. The variable can be an object or array. For example it looks something like: $object = array('a', 'b'); This object is then persisted to storage using an object-cache. When php script runs again. So when the script runs the second time, or another script runs and modifies that object, I want those modifications to be tracked, either as they are being done, or in one go after the script executes. eg: $object[] = 'c'; I would like to know that 'c' was added to the object. Now the actually code looks something like this: $storage = new Storage(); $storage->object = array('a', 'b'); second load: $storage = new Storage(); var_dump($storage->object); // array('a', 'b') $storage->object[] = 'c'; What I want to know is that 'c' was pushed into $storage->object so in the class "Storage" I can set that value to persistent storage. I have tried a few methods, that work, but have downsides. 1) Wrap all objects in a class "Storable" which tracks changes to the object The class "Storable" just saves the actual data object as a property, and then provides __get() and __set() methods to access it. When a member/property of the object is modified or added, the "Storable" class notes this. When a a property is accessed __get() on the Storable class returns the property, wrapped in another Storable class so that changes on that are tracked also, recursively for each new level. The problem is that the objects are no longer native data types, and thus you cannot run array functions on arrays. eg: $storage = new Storage(); var_dump($storage->object); // array('a', 'b') array_push($storage->object, 'c'); // fails So instead we'd have to implement these array functions as methods of Storable. eg: $storage = new Storage(); var_dump($storage->object); // array('a', 'b') $storage->object->push('c'); This is all good, but I'd like to know if its possible to somehow use native functions, to reduce the overhead on the library I'm developing, while tracking changes so any changes can be added to persistent storage. 2) Forget about tracking changes, and just update whole object structures This is the simplest method of keeping the objects in the program synchronized with the objects actually stored in the object-cache (which can be on a different machine). However, it means whole structures, like an array with 1000 indexes, have to be sent though a socket to the object-cache when a single index changes. 3) Keep a mirror of the object locally I've also tried cloning the object, and keeping a clone object untouched. Then when all processing is done by the PHP script, compare the clone to the modified object recursively, and submitting changed properties back to the object-cache. This however requires that the whole object be downloaded in order to use it. It also requires that the object take up twice as much memory, since it is cloned. I know this is pretty vague, but there is a quite a bit of code involved. If anyone wants to see the code I can post it, or put it up on an open SVN repo. The project is open source but I haven't set up a public repository yet.
