[site]: stackoverflow
[post_id]: 2541140
[parent_id]: 2540984
[tags]: 
It's hard to answer this definitively since the Java Language Specification doesn't state why a JVM implementation might want to do this (it only specifies that it can, in this section ), but I found a pretty interesting history of spurious wake-ups on Wikipedia . The actual article in about POSIX threads but I don't think it's too far of a stretch to assume that threading in Java was somewhat influenced by the behavior of POSIX threads: Spurious wakeups may sound strange, but on some multiprocessor systems, making condition wakeup completely predictable might substantially slow all condition variable operations. The race conditions that cause spurious wakeups should be considered rare. This quote is from David R. Butenhof, who then goes on to say: Though there were indeed some members of the working group who argued that it was theoretically possible to imagine that there might be such an implementation, that wasn't really the reason. (And they were never able to prove it.) POSIX threads were the result of a lot of tension between pragmatic hard realtime programmers and largely academic researchers. Spurious wakeups are the mechanism of an academic computer scientist clique to make sure that everyone had to write clean code that checked and verified predicates! "But the (perhaps) largely spurious (or at least arcanely philosophical) 'efficiency' argument went over better with the realtime people, and the real reason was usually relegated to second place in the rationale. "I've thought many times about how you might construct a correct and practical implementation that would really have spurious wakeups. I've never managed to construct an example. Doesn't mean there isn't one, though, and it makes a good story.
