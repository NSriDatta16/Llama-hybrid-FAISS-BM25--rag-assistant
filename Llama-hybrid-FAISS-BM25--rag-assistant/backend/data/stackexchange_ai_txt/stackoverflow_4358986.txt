[site]: stackoverflow
[post_id]: 4358986
[parent_id]: 4351074
[tags]: 
Apologies if I answer my own question, but I'd like to contribute with my own solution to the problem for future reference. I am keeping state across lexer function calls with the LexBuffer .BufferLocalStore property, which is simply a writeable IDictionary instance. Note: long brackets are used both by long string and multiline comments. This is often an overlooked part of the Lua grammar. let beginlongbracket = '[' ('=')* '[' let endlongbracket = ']' ('=')* ']' rule tokenize = parse | beginlongbracket { longstring (longBracketLevel(lexeme lexbuf)) lexbuf } (* ... *) and longstring level = parse | endlongbracket { if longBracketLevel(lexeme lexbuf) = level then LUASTRING(endLongString(lexbuf)) else longstring level lexbuf } | _ { toLongString lexbuf (lexeme lexbuf); longstring level lexbuf } | eof { failwith "Unexpected end of file in string." } Here are the functions I use to simplify storing data into the BufferLocalStore: let longBracketLevel (str : string) = str.Count(fun c -> c = '=') let createLongStringStorage (lexbuf : LexBuffer ) = let sb = new StringBuilder(1000) lexbuf.BufferLocalStore.["longstring"] ) (c : string) = let hasString, sb = lexbuf.BufferLocalStore.TryGetValue("longstring") let storage = if hasString then (sb :?> StringBuilder) else (createLongStringStorage lexbuf) storage.Append(c.[0]) |> ignore let endLongString (lexbuf : LexBuffer ) : string = let hasString, sb = lexbuf.BufferLocalStore.TryGetValue("longstring") let ret = if not hasString then "" else (sb :?> StringBuilder).ToString() lexbuf.BufferLocalStore.Remove("longstring") |> ignore ret Perhaps it's not very functional, but it seems to be getting the job done. use the tokenize rule until the beginning of a long bracket is found switch to the longstring rule and loop until a closing long bracket of the same level is found store every lexeme that does not match a closing long bracket of the same level into a StringBuilder, which is in turn stored into the LexBuffer BufferLocalStore. once the longstring is over, clear the BufferLocalStore. Edit: You can find the project at http://ironlua.codeplex.com . Lexing and parsing should be okay. I am planning on using the DLR. Comments and constructive criticism welcome.
