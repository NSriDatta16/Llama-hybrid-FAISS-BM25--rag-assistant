[site]: stackoverflow
[post_id]: 3850754
[parent_id]: 3110154
[tags]: 
There's no way I could offer a better answer than what's already here. But I can offer a concrete example of some multithreaded code that we actually had at my work that was disastrous. One of my coworkers, like you, was very enthusiastic about threads when he first learned about them. So there started to be code like this throughout the program: Thread t = new Thread(LongRunningMethod); t.Start(GetThreadParameters()); Basically, he was creating threads all over the place. So eventually another coworker discovered this and told the developer responsible: don't do that! Creating threads is expensive, you should use the thread pool, etc. etc. So a lot of places in the code that originally looked like the above snippet started getting rewritten as: ThreadPool.QueueUserWorkItem(LongRunningMethod, GetThreadParameters()); Big improvement, right? Everything's sane again? Well, except that there was a particular call in that LongRunningMethod that could potentially block -- for a long time . Suddenly every now and then we started seeing it happen that something our software should have reacted to right away... it just didn't. In fact, it might not have reacted for several seconds (clarification: I work for a trading firm, so this was a complete catastrophe). What had ended up happening was that the thread pool was actually filling up with long-blocking calls, leading to other code that was supposed to happen very quickly getting queued up and not running until significantly later than it should have. The moral of this story is not, of course, that the first approach of creating your own threads is the right thing to do (it isn't). It's really just that using threads is tough, and error-prone, and that, as others have already said, you should be very careful when you use them. In our particular situation, many mistakes were made: Creating new threads in the first place was wrong because it was far more costly than the developer realized. Queuing all background work on the thread pool was wrong because it treated all background tasks indiscriminately and did not account for the possibility of asynchronous calls actually being blocked. Having a long-blocking method by itself was the result of some careless and very lazy use of the lock keyword. Insufficient attention was given to ensuring that the code that was being run on background threads was thread-safe (it wasn't). Insufficient thought was given to the question of whether making a lot of the affected code multithreaded was even worth doing to begin with . In plenty of cases, the answer was no: multithreading just introduced complexity and bugs, made the code less comprehensible, and (here's the kicker): hurt performance. I'm happy to say that today , we're still alive and our code is in a much healthier state than it once was. And we do use multithreading in plenty of places where we've decided it's appropriate and have measured performance gains (such as reduced latency between receiving a market data tick and having an outgoing quote confirmed by the exchange). But we learned some pretty important lessons the hard way. Chances are, if you ever work on a large, highly multithreaded system, you will too.
