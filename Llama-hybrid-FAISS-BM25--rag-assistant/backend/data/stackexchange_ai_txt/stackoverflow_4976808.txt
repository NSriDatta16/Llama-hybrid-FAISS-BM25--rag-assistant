[site]: stackoverflow
[post_id]: 4976808
[parent_id]: 938521
[tags]: 
I realize this is an old thread, but I've just run across this as well. There are a few problems with the code above: It's not IPv6 savvy. At a minimum, it should detect and discard IPv6 addresses if the rest of your app can only handle v4 addresses, but ideally you should be prepared to pass both address families upstream. The port assignment will generate incorrect values for Intel processors. You need to use htons to fix that. As Andrew noted above, the iteration should use the enhanced for loop. (EDIT: Added this) As noted on another related thread, the use of inet_ntoa is discouraged in favor of inet_ntop . Putting all of this together, you get: char addressBuffer[INET6_ADDRSTRLEN]; for (NSData *data in self.addresses) { memset(addressBuffer, 0, INET6_ADDRSTRLEN); typedef union { struct sockaddr sa; struct sockaddr_in ipv4; struct sockaddr_in6 ipv6; } ip_socket_address; ip_socket_address *socketAddress = (ip_socket_address *)[data bytes]; if (socketAddress && (socketAddress->sa.sa_family == AF_INET || socketAddress->sa.sa_family == AF_INET6)) { const char *addressStr = inet_ntop( socketAddress->sa.sa_family, (socketAddress->sa.sa_family == AF_INET ? (void *)&(socketAddress->ipv4.sin_addr) : (void *)&(socketAddress->ipv6.sin6_addr)), addressBuffer, sizeof(addressBuffer)); int port = ntohs(socketAddress->sa.sa_family == AF_INET ? socketAddress->ipv4.sin_port : socketAddress->ipv6.sin6_port); if (addressStr && port) { NSLog(@"Found service at %s:%d", addressStr, port); } } }
