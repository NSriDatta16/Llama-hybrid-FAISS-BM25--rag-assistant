[site]: stackoverflow
[post_id]: 3836830
[parent_id]: 3836177
[tags]: 
Yeah, I ran into this problem too. What you need to do is keep a rotation matrix around that "accumulates" the current state of rotation, and use it in addition to the rotation matrix that comes from the current dragging operation. Say you have two matrices, lastRotMx and currRotMx. Make them members of CubeDrawingArea if you like. You haven't shown us this, but I assume that m_lastTrackPoint is initialized whenever the mouse button goes down for dragging. When that happens, copy currRotMx into lastRotMx. Then in on_motion_notify_event() , after you calculate m_rotAxis and m_angle, create a new rotation matrix draggingRotMx based on m_rotAxis and m_angle; then multiply lastRotMx by draggingRotMx and put the result in currRotMx. Finally, in redraw() , instead of glRotated(m_angle, m_rotAxis.x, m_rotAxis.y, m_rotAxis.z); rotate by currRotMx. Update: Or instead of all that... I haven't tested this, but I think it would work: Make cur_pos a class member so it stays around, but it's initialized to zero, as is m_lastTrackPoint. Then, whenever a new drag motion is started, before you initialize m_lastTrackPoint, let _3V dpos = cur_pos - m_lastTrackPoint (pseudocode). Finally, when you do initialize m_lastTrackPoint based on the mouse event coords, subtract dpos from it. That way, your cur_pos will already be offset from m_lastTrackPoint by an amount based on the accumulation of offsets from past arcball drags. Probably error would accumulate as well, but it should be gradual enough so as not to be noticeable. But I'd want to test it to be sure... composed rotations are tricky enough that I don't trust them without seeing them. P.S. your username is demotivating. Suggest picking another one. P.P.S. For those who come later searching for answers to this question, the keywords to search on are " arcball rotation ". An definitive article is Ken Shoemake's section in Graphical Gems IV . See also this arcball tutorial for JOGL .
