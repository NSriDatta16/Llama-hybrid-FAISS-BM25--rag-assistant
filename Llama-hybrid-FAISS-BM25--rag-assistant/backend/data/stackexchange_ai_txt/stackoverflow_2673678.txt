[site]: stackoverflow
[post_id]: 2673678
[parent_id]: 
[tags]: 
What transaction manager should I use for JBDC template When using JPA ?

I am using standard JPA transaction manager for my JPA transactions. However, now I want to add some JDBC entities which will share the same 'datasource'. How can I make the JDBC operations transactional with spring transaction? Do I need to switch to JTA transaction managers? Is it possible to use both JPA & JDBC transactional service with same datasource? Even better, is it possible to mix these two transactions? UPDATE: @Espen : I have a dao extended from SimpleJdbcDaoSupport which uses getSimpleJDBCTemplate.update to insert a database row. When a RuntimeException is thrown from the service code, the transaction never rolls back when using JPATransactionManager. It does rollback when using DatasourceTransactionManager. I tried to debug the JPATransactionManager and seems that it never performs rollback on underlying JDBCConnection(I guess due to the fact that the datasource is not necessarily has to be JDBC for JPA). My configuration setup are exactly like you explained here. Here are my test codes: --> --> AND HERE IS THE DAO: @Transactional public class CallRecordingScheduledProgramTriggerDAOJDBCImpl extends SimpleJdbcDaoSupport implements CallRecordingScheduledProgramTriggerDAO{ private static final Log log = LogFactory.getLog(CallRecordingScheduledProgramTriggerDAOJDBCImpl.class); @SuppressWarnings("unchecked") public CallRecordingScheduledProgramTrigger save( CallRecordingScheduledProgramTrigger entity) { log.debug("save -> entity: " + entity); String sql = null; Map args = new HashMap(); String agentIdsString = getAgentIdsString(entity.getAgentIds()); String insertSQL = "insert into call_recording_scheduled_program_trigger" + " ( queue_id, queue_id_string, agent_ids_string, caller_names, caller_numbers, trigger_id, note, callcenter_id, creator_id_string, creator_id) " + " values(:queueId, :queueIdString, :agentIdsString, :callerNames, :callerNumbers, :triggerId, :note, :callcenterId , :creatorIdString, :creatorId )"; args.put("queueId", entity.getQueueId()); args.put("agentIdsString",agentIdsString); args.put("callerNames", entity.getCallerNames()); args.put("queueIdString", entity.getQueueIdString()); args.put("callerNumbers", entity.getCallerNumbers()); args.put("triggerId", entity.getTriggerId()); args.put("note", entity.getNote()); args.put("callcenterId", entity.getCallcenterId()); args.put("creatorId", entity.getCreatorId()); args.put("creatorIdString", entity.getCreatorIdString()); sql = insertSQL; getSimpleJdbcTemplate().update(sql, args); System.out.println("saved: ----------" + entity); return entity; } } Here is the client code that calls the dao and throws exception (spring service) @Transactional(propagation=Propagation.REQUIRED) public void jdbcTransactionTest() { System.out.println("entity: " ); CallRecordingScheduledProgramTrigger entity = new CallRecordingScheduledProgramTrigger(); entity.setCallcenterId(10L); entity.setCreatorId(22L); entity.setCreatorIdString("sajid"); entity.setNote(System.currentTimeMillis() + ""); entity.setQueueId(22); entity.setQueueIdString("dddd"); String triggerId = "id: " + System.currentTimeMillis(); entity.setTriggerId(triggerId); callRecordingScheduledProgramTriggerDAO.save(entity); System.out.println("entity saved with id: " + triggerId ); throw new RuntimeException(); } NOTE: the code works as expected when using DatasourceTransactionManager UPDATE - 2: Ok I have found the root cause of the problem. Thanks to Espen. My entity manager configuration was like this(copied from spring pet-clinic app): Then I changed it to like this: Now everything seems to be working! Can anyone explain the difference between these two approach ?
