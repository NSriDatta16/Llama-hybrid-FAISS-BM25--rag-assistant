[site]: stackoverflow
[post_id]: 1512991
[parent_id]: 1512972
[tags]: 
It depends on what you want to optimize for. Speed I suggest using -O2 -NDEBUG -ftree-vectorize , and if your code is designed to specifically run on x86 or x86_64, add -msse2 . This will give you a broad idea on how it will perform with GIMPLE. Size I believe you should use -Os -fno-rtti -fno-exceptions -fomit-frame-pointer . This will minimize the size of the executable to a degree (assuming C++). In both cases, algorithm's speed is not compiler dependent, but a compiler can drastically change the way the code behaves if it can "prove" it can. GCC detects 'common' code such as hand-coded min() and max() and turns them into one SSE instruction (on x86/x86_64 and when -msse is set) or using cmov when i686 is available (SSE has higher priority). GCC will also take liberty in reordering loops, unrolling and inlining functions if it wants to, and even remove useless code. As for your latest edit: You can see that in -O0 std::vector is outperformed with twice faster pointers. While in -O2 they are almost the same. That's because std::vector still has code that throws exceptions and may use rtti. Try comparing with -O2 -NDEBUG -ftree-vectorize -fno-rtti -fno-exceptions -fomit-frame-pointer , and you'll see that std::vector will be slightly better than your code. GCC knows what 'built-in' types are and how to exploit them in real world use and will gladly do so - just like it knows what memset() and memcpy() does and how to optimize accordingly when copy size is known.
