[site]: stackoverflow
[post_id]: 4595727
[parent_id]: 4595675
[tags]: 
There's actually some functions called IsBadReadPtr() , IsBadWritePtr() , IsBadStringPtr() , and IsBadCodePtr() that might do the job, but do not use it ever . I mention this only so that you are aware that these options are not to be pursued. You're much better off making sure you set all your pointers to NULL or 0 when it points to nothing and check against that. For example: // Set ptr to zero right after deleting the pointee. delete ptr; // It's okay to call delete on zero pointers, but it // certainly doesn't hurt to check. Note: This might be a performance issue on some compilers ( see the section "Code Size" on this page ) so it might actually be worth it to do a self-test against zero first. ptr = 0; // Set ptr to zero right after freeing the pointee. if(ptr != 0) { free(ptr); // According to Matteo Italia (see comments) // it's also okay to pass a zero pointer, but // again it doesn't hurt. ptr = 0; } // Initialize to zero right away if this won't take on a value for now. void* ptr = 0; Even better is to use some variant of RAII and never have to deal with pointers directly: class Resource { public: // You can also use a factory pattern and make this constructor // private. Resource() : ptr(0) { ptr = malloc(42); // Or new[] or AcquiteArray() or something // Fill ptr buffer with some valid values } // Allow users to work directly with the resource, if applicable void* GetPtr() const { return ptr; } ~Resource() { if(ptr != 0) { free(ptr); // Or delete[] or ReleaseArray() or something // Assignment not actually necessary in this case since // the destructor is always the last thing that is called // on an object before it dies. ptr = 0; } } private: void* ptr; }; Or use the standard containers if applicable (which is really an application of RAII): std::vector arrayOfChars;
