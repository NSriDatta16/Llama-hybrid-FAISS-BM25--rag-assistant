[site]: datascience
[post_id]: 100102
[parent_id]: 99459
[tags]: 
You may consider this problem as Graph and chart its WeightedAdjacencyMatrix . I am using Wolfram Language but the same steps apply to your choice of language. I'll create some example data from a recent survey of top 10 popular DBMS . dbs = {{"Oracle", 1271}, {"MySQL", 1228}, {"Microsoft SQL Server", 991}, {"PostgreSQL", 569}, {"MongoDB", 488}, {"IBM Db2", 167}, {"Redis", 165}, {"Elasticsearch", 155}, {"SQLite", 131}, {"Microsoft Access", 115}}; wd = WeightedData[Sequence @@ Transpose[dbs]]; BarChart[ wd["Weights"] , ChartLabels -> {None, wd["InputData"]} , BarOrigin -> Left , PlotTheme -> "Detailed" ] Then generate 200 pairs of from-to moves using the survey's EmpiricalDistribution inside of WeightedData . SeedRandom[123]; moves = RandomChoice[wd, {200, 2}]; Collect the Counts of the pairs. counts = Counts[moves]; Short@counts 2,{Elasticsearch,SQLite}->1, >,{Microsoft SQL Server,Redis}->1,{IBM Db2,MongoDB}->1|> Create indices for the DBMS names. With[{n = wd["InputData"]} , vertex = Thread[n -> Range@Length@n] ]; Short@vertex {Oracle->1,MySQL->2,Microsoft SQL Server->3, >,Elasticsearch->8,SQLite->9,Microsoft Access->10} Create a SparseArray adjacency matrix from counts using the vertex for indices. adjMatrix = SparseArray[Normal@counts /. vertex, ConstantArray[Length@vertex, 2]]; adjMatrix // MatrixForm MatrixPlot the matrix. ticks = List @@@ Reverse[vertex, {2}]; MatrixPlot[ SparseArray[Normal@counts /. vertex] , FrameTicks -> { ticks , MapAt[Rotate[#, Ï€/2] &, ticks, {All, -1}] } , PlotLegends -> Automatic , Mesh -> All , MeshStyle -> LightGray ] The graph can also be charted from counts with Thickness and Opacity a function of the EdgeWeight . edgeStyle = Thread[ (Rule @@@ Keys[counts] /. vertex ) -> Apply[ Directive[Opacity@#, Thickness@#2] & , Transpose[{ Rescale[#, MinMax@#, {.25, 1}] , Rescale[#, MinMax@#, {.002, .005}] } &@Values[counts] ] , {1} ] ]; graph = Graph[ Rule @@@ Keys[counts] /. vertex , VertexLabels -> Reverse[vertex, {2}] , EdgeWeight -> Values[counts] , EdgeStyle -> edgeStyle , GraphLayout -> "CircularEmbedding" ] Hope this helps.
