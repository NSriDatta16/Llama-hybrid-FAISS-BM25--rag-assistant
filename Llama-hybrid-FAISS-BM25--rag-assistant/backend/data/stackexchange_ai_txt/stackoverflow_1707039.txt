[site]: stackoverflow
[post_id]: 1707039
[parent_id]: 1706675
[tags]: 
I think there is some confusion with the word "static". We have a keyword static that does different things in different contexts and we use the word "static" to name one of three classes of "storage durations". In some contexts static does not control the storage duration of objects but only "linkage" which is probably the main reason for the confusion. Storage durations A storage duration is a property of an object. The memory of an object with static storage duration is allocated once and once only. Initialization depends on the kind of object and where it is defined. Once it is initialized, it generally stays alive until the execution of main ends. Objects you declare and define at global/namespace scope always have a static storage duration. Objects with automatic storage duration can only be defined inside a block in functions. Such an object is created when execution reaches the definition. This can happen multiple times (recursion) which creates multiple objects. When execution leaves the block the objects are automatically destroyed. Dynamically allocated objects have a dynamic storage duration . In this case the user controls the life-time of the objects via new, new[], delete, delete[] etc. Linkage Internal vs external linkage is about visibility of names across translation units. If you declare something with external linkage you introduce a name that can be used in other translation units as well to refer to the same entity as long as those other TUs contain the proper declaration (usually contained in a header file). If you define something with internal linkage you can't access it from another translation unit by name . You can even define multiple entities with the same name (one per TU) as long as you have no more than one with external linkage. The keyword "static" The effect of static depends on the context: If you declare or define an object at global/namespace scope it is always an object with "static storage duration". The use of the keyword static at global/namespace scope doesn't affect the storage duration at all. Instead, it affects linkage. It declares the entity -- which might be a function as well -- to have internal linkage. So, the storage class specifier has been "misused" to do something completely different: enforce internal linkage. It's sort of the opposite of extern in this context. In C++ you can achieve the same effect with an anonymous namespace. You are encouraged to prefer anonymous namespaces over static to "minimize confusion". static at class scope can be used to declare objects with static storage duration in the scope of the class. There's only one such variable and not one for each object. static at function scope can be used to declare objects with static storage duration that is lazily initialized If you say "static variable" it's not clear what you mean exactly. Do you refer to the "static storage duration" or "internal linkage"? If you want to share a "global" variable across translation units you have to declare it in a header file as an entity with external linkage and define it in exactly one translation unit. Note that the keyword static is not used: // myheader.hpp extern int k; // declaring an int variable with external linkage // foo.cpp #include "myheader.hpp" int k; // defining an int variable with external linkage // bar.cpp #include "myheader.hpp" int main() { return k; }
