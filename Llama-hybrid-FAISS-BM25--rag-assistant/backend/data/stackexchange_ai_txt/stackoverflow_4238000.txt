[site]: stackoverflow
[post_id]: 4238000
[parent_id]: 4237896
[tags]: 
You can't assign memory to an array. An array has a fixed size, for the whole of its lifespan. An array can never be null. An array is not a pointer. malloc returns the address to a memory block that is reserved for the program. You can't "assign" that (being the memory block) to an array, but you can store the address of this memory block in a pointer: luckily, array subscription is defined through pointers - so you can "use pointers like arrays", e.g. int *ptr = malloc(5 * sizeof *ptr); ptr[2] = 5; // access the third element "of ptr" free(ptr); // always free at the end When you declare an array without a size (i.e. array[] ), it simply means the size of the array is determined from the initializer list. That is int array[] = {1, 2, 3, 4, 5}; // is equal to int array[5] = {1, 2, 3, 4, 5}; Trying to declare an array without a size and without an initializer is an error. The code pthread_t tid[MAX_OPS]; declares an array named tid of type pthread_t and of size MAX_OPS . If the array has automatic storage (i.e. declaration is inside a function and not static, not global), then each of the arrays elements has indeterminate value (and it would cause undefined behavior trying to read such value). Luckily, all that the function call does is that it takes the address of the first element of the array as the first parameter, and probably initializes it (the element) inside the function. The difference of calloc and malloc is that the memory block that calloc returns is initialized to zero. That is; int *ptr = calloc(5, sizeof *ptr); // is somewhat equal to int *ptr = malloc(5 * sizeof *ptr); memset(ptr, 0, 5 * sizeof *ptr); The difference between int *ptr = malloc(5 * sizeof *ptr); // and int array[5]; is that array has automatic storage, (is stored on stack), and is "released" after it goes out of scope. ptr , however, (is stored on heap), is dynamically allocated and must be free d by the programmer.
