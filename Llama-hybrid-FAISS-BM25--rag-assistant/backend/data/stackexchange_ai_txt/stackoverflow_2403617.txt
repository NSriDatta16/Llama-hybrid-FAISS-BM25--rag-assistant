[site]: stackoverflow
[post_id]: 2403617
[parent_id]: 2403589
[tags]: 
Many frameworks avoid the use of direct constructors for complex objects, preferring instead more elegant factories. A pattern is generated by 'compiling' a regular expression, so you make a static call to the 'compile' method. It initializes everything that is necessary. A matcher is specific to a pattern, and therefore generated by the pattern object rather than directly by the user. If the matcher had a constructor that took a pattern, the matcher's constructor might have had to access non-public fields of the pattern object. Another potential advantage of this approach (compared to direct construction) is that it is in principle possible to provide different matching engines transparently to the user by instantiating different subtypes of Pattern and Matcher behind the scenes. For example, suppose that you had different matcher implementations for regular expressions that match a fixed-length string (e.g., no wildcards), and for regular expressions that contain an asterisk or a plus, and that there was a performance difference. That being said, it doesn't seem like this actually takes place since the Matcher is defined as a final class, though it is likely that the internals are closely bounded to the pattern.
