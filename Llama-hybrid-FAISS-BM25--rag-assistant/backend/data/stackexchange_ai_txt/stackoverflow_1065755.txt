[site]: stackoverflow
[post_id]: 1065755
[parent_id]: 
[tags]: 
Strange behavior: Hash's keys cancel dynamic method definition

Let's say I want some instance of String behave differently from other, "normal" instances - for example cancel the effect of the "upcase" method. I do the following: class String def foo def self.upcase self end self end end It seems to work fine, and the way I need it: puts "bar".upcase #=> "BAR" puts "bar".foo.upcase #=> "bar" However, as soon as I use the tricked instance of the String as a key for a Hash, the behavior starts looking weird to me: puts ({"bar".foo => "code"}).keys.first.upcase #=> "BAR", not "bar"! ... which is as if the foo method is ignored, and the original instance of String is used as the key. Anyone can see what's going on here? Thanks a bunch!
