[site]: crossvalidated
[post_id]: 144906
[parent_id]: 
[tags]: 
Does the kernel trick really map 2d data to 3d data?

I want to learn something about kernel trick in svm, so I'm using this code: m=25; rA=unifrnd(0,1,1,m); rB=unifrnd(1,2,1,m); r=[rA rB]; theta=unifrnd(0,2*pi,1,2*m); x(1,:)=r.*cos(theta); x(2,:)=r.*sin(theta); y(1:m)=1; y(m+1:2*m)=-1; TrainInputs=x'; TrainTargets=y'; n=numel(TrainTargets); %% Design SVM C=10; svmstruct=svmtrain(TrainInputs,TrainTargets,... 'kernel_function','rbf',... 'rbf_sigma',.3,... 'showplot',true); I've study something about how the kernel trick maps 2d data to 3d data, for example as shown in this animation . But when I use my code, the svm separated my data to 2 regions, which I think are correct. Here's my result: But I can't understand: how can the RBF kernel map my 2d data to 3d in this example, and what is the rule of RBF? My data is still 2d? ....it is not clear for me, can you help me please to understand this?
