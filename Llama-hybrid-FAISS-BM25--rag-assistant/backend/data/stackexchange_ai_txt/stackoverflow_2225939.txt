[site]: stackoverflow
[post_id]: 2225939
[parent_id]: 2224492
[tags]: 
If you have n (n > 2) lists, it is not true that you need to carry out (n-1) comparisons on every merging step. However, the implementation becomes more complex. Suppose you have three lists, list[0..2] , and assume for simplicity you are merging them and they are all still non-empty (i.e. you have not run to the end of any of the lists). Assume furthermore for simplicity that all elements are distinct, i.e. when you compare two elements they are never the same. You have then six possible "states" in which you can be, which correspond to the six permutations of the three lists in an increasing order of the first elements on the lists, i.e. if list[0] = [5, 7, 11, 15] list[1] = [3, 4, 20, 21] list[2] = [9, 10, 12, 19] then the corresponding permutation of the lists is [1, 0, 2], i.e. list[1] has the least front element and list[2] has the greatest front element. When you now pop the next element (4) from list[1] you know already that list[0].front list[2].front based on the state [1, 0, 2] where you were. So now you need to perform either 1 or 2 comparisons: if (list[1].front move to state [1, 0, 2], next to pop is list[1] else if (list[1].front move to state[0, 1, 2], next to pop is list[0] else --> move state[0, 2, 1], next to pop is list[0] Assuming some kind of uniformity, the probability that the comparison (A) returns true, i.e. that the next element on the list from which you removed the previous element is less than the least element on the other two lists, is 1/3, so you have on the average (1/3 x 1 + 2/3 x 2) = 5/3 comparisons instead of 2 (which would be n-1). This is obviously worse by 2/3 comparisons per insert the normal mergesort which only needs 1 comparison per popped element. We can get a better result by considering also partially ordered states. There are three distinct comparisons which can be made (list[0] -- list[1], list[1] -- list[2] and list[0] -- list[2]). If we allow for the known results ( ) to be augmented with "don't know" (?), there are the following possible states: 0/1 1/2 0/2 and then all the variants regarding permutations and swapping at different places in the matrix. Now if were in a ( Now in a ( For completeness, here the algorithm (fragment shown): state_1_lt_2: /* known list[1].front This sums up to an expected number of comparisons per insert of 1/3 x 1 + 4/9 x (4/2) + 2/9 x (3/2) = 6/18 + 16/18 + 6/18 = 30/18 = 1 5/9.
