[site]: stackoverflow
[post_id]: 2368749
[parent_id]: 2368574
[tags]: 
If you want to maintain a codebase that works with Python 2 and 3, you wouldn't try to make code that will run in both, which will be awkward and ugly and bugprone, you would write in Python 2 and use 2to3 to convert. (You can also write in Python 3 and use 3to2 to convert, but I believe that tool is less mature.) 2to3 is not perfect, but making Python 2 code that can be converted by it makes tons more sense than making Python 2 code that will run in a Python 3 interpretter. Edit: This was common wisdom in 2010, but turned out not to be the case. The thing to do is write a polyglot. 2to3 did not end up being all that useful Another option is Cython , a Python-like language that can be used to create C extension modules. Cython modules can be used with Python 2 and 3. When you support multiple versions of Python, it is generally better to directly check for the capability you want rather than to check a version number. Checking version numbers directly is fragile and indirect. For example, if I wanted code that would work with Python pre-2.5, I would say: try: any except NameError: def any(iterable): for item in iterable: if item: return True return False (note that this is prettymuch the only reason to catch NameError ). Similarly, library availability would be checked by catching ImportError . Edit: There is a tons of tooling for abstracting this away by now. If you want a script to remember what version it is from, like you say, don't bother trying to support multiple versions at all. Put the proper version number binary in the shebang line and run the script based on that.
