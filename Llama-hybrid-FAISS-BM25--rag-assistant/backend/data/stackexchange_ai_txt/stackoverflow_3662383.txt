[site]: stackoverflow
[post_id]: 3662383
[parent_id]: 2596452
[tags]: 
I was able to answer my own question using the following code (see below), but my solution was very specific to the application. For instance, this will probably only look good and/or work for a TextView sized to approx. 1/2 the screen (with also a 40px top margin and 20px side margins... no bottom margin). The using this approach though, you can create your own similar implementation. The static method basically just looks at the number of characters and determines a scaling factor to apply to the TextView's text size, and then incrementally increases the text size until the overall height (an estimated height -- using the width of the text, the text height, and the width of the TextView) is just below that of the TextView. The parameters necessary to determine the scaling factor (i.e. the if/else if statements) were set by guess-and-check. You'll likely have to play around with the numbers to make it work for your particular application. This isn't the most elegant solution, though it was easy to code and it works for me. Does anyone have a better approach? public static void autoScaleTextViewTextToHeight(final TextView tv, String s) { float currentWidth=tv.getPaint().measureText(s); int scalingFactor = 0; final int characters = s.length(); //scale based on # of characters in the string if(characters =5 && characters =10 && characters =15 && characters =20 && characters =25 && characters =30 && characters =35 && characters =40 && characters =45 && characters =50 && characters =55 && characters =60 && characters =65 && characters =70 && characters =75) { scalingFactor = 5; } //System.out.println(((int)Math.ceil(currentWidth)/tv.getWidth()+scalingFactor)); //the +scalingFactor is important... increase this if nec. later while((((int)Math.ceil(currentWidth)/tv.getWidth()+scalingFactor)*tv.getTextSize()) Thanks.
