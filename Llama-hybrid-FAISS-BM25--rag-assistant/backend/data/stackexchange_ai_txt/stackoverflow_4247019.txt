[site]: stackoverflow
[post_id]: 4247019
[parent_id]: 4244481
[tags]: 
Since nothing else does the trick, I 'tricked' it like this: Add MessageHeader on the client side: using (OperationContextScope scope = new OperationContextScope(cli.InnerChannel)) { OperationContext.Current.OutgoingMessageHeaders.Add(MessageHeader.CreateHeader("MyHeader", Guid.NewGuid().ToString(), "")); string ret = cli.GetData(1); } In the "Name" property of the header I have the name of the header I want to pass, and I'm using the Namespace as the value-holder (since I can't seem to get to that 'value' of the header - it's not exposed as property?!). I do this on client side each time I create a service instance. On service I read the header like: var head = OperationContext.Current.IncomingMessageHeaders.FirstOrDefault(h => h.Name == "MyHeader"); string channelId = head.Namespace; It's definitely a hack, but I'm out of time to create something more elegant, and this allows me to maintain 'channel id' the way I can control it... it's an ugly solution and I don't like it, so whenever someone finds something better I'd appreciate it... edit : I tried using Outgoing/IncomingMessageProperties but that doesn't seem to work - it's nowhere to be found on server side... I'm probably missing something...
