[site]: stackoverflow
[post_id]: 3762713
[parent_id]: 3760113
[tags]: 
What I want to stress the most in this answer, is my disagreement with this bit of another answer: It's difficult (as you've noticed) to apply a pattern for the first time and understand what the benefits might be You have to see a clear benefit the pattern will give before applying it. If that's not the case, don't use it, adding patterns to your code that don't give clear benefits will very likely fall in an anti-pattern scenario . That's why i'd like people to tell me in which CONCRETE context you would use a GoF pattern, and also why you wouldn't use any of the other patterns that could have fit to the given problem (but probably in a less elegant way). First, don't limit yourself to what you read there. The best aspects of the patterns is to enable you to acquire design options to several different scenarios. Naturally there are scenarios that can be done in more than one way. Struggling choosing between 2 patterns in a very specific scenario? check them again, see what they said about the scenario and the benefits. If you find yourself overwhelmed with the amount of patterns, give most of them a rest. Don't introduce all the patterns into your skills at once. Pick a related handful of those, and learn well when to apply them (read them again, search/ask for comparisons in SO/blog posts. Always pay attention of how good the patterns you have applied respond to changes and how its the complexity of the code around them. Ask yourself the question on how those characteristics would be different with any of the other alternative patterns. Finally, understand that you are best following an evolving code approach. Do your best in keeping your code clean, but don't obsess on finding a solution that won't ever have to change. Even with the patterns at hand, you will be taking some assumptions, that can impact which pattern you chose. Changes might not be in line with those assumptions, is a fact or life. Read these 2 ebooks , can help you greatly on focusing how you design/develop/improve code.
