[site]: stackoverflow
[post_id]: 1539358
[parent_id]: 797442
[tags]: 
As you found out , xmlgen generates XML from a list structure. What I did find disappointing with the ``xmlgen` package that the format it supports is not quite the inverse of Emacs' xml parser . I did add this to my copy of xmlgen: ;; this creates a routine to be the inverse of what xml-parse does ;;;###autoload (defun xml-gen (form &optional in-elm level) "Convert a sexp to xml: '(p :class \"big\")) => \" \"" (let ((level (or level 0))) (cond ((numberp form) (number-to-string form)) ((stringp form) form) ((listp form) (destructuring-bind (xml attrs) (xml-gen-extract-plist form) (let ((el (car xml))) (unless (symbolp el) (error "Element must be a symbol (got '%S')." el)) (setq el (symbol-name el)) (concat " (length xml) 1) (concat ">" (mapconcat (lambda (s) (xml-gen s el (1+ level))) (cdr xml) "") " ") "/>")))))))) (defun xml-gen-attr-to-string (plist) (reduce 'concat (mapcar (lambda (p) (concat " " (symbol-name (car p)) "=\"" (cdr p) "\"")) plist))) (defun xml-gen-extract-plist (list) (list (cons (car list) (let ((kids (xml-node-children list))) (if (= 1 (length kids)) kids (remove-if-not 'listp kids)))) (xml-node-attributes list))) Note: the interface for this is xml-gen (not xmlgen which is the original parsing). With this interface, the following holds: (string-equal (xml-gen (car (xml-parse-region ))) ) and (equal (car (xml-parse-region (insert (xml-gen )))) ) The new xml-gen does not strive to preserve the whitespace around that the xml-parse-region routine generates.
