[site]: stackoverflow
[post_id]: 3001310
[parent_id]: 2998632
[tags]: 
Since the size is known before hand and you will need to convert the whole array to a 1D array (for OpenGL) why not create a class for it? I have created a template-based implementation of a 3D array which I hope will be useful to you. Usage: typedef Array3D DoubleArray333; DoubleArray333 array; Double val = 0.0; for (size_t i = 0; i The Array3D header file: #pragma once #include #include #include #include /** * \brief A 3D array of variable type and size. * \author Vite Falcon * \date 08/06/2010 **/ template class Array3D { private: T* m_array; /** * \brief Validate the index range of different dimensions. * \remarks Vite Falcon, 08/06/2010. * \author Vite Falcon * \date 08/06/2010 * \exception std::out_of_range Thrown when one of the indices is out-of-range. * \param x The width index. * \param y The height index. * \param z The depth index. **/ inline void validateRange(size_t x, size_t y, size_t z) { if (x >= SizeX || y >= SizeY || z >= SizeZ) { std::stringstream ss; ss = ArraySize) { std::stringstream ss; ss MyType; /** * \brief Default constructor. * \author Vite Falcon * \date 08/06/2010 **/ Array3D(void) :m_array(new T[ArraySize]) { } /** * \brief Copy constructor. * \author Vite Falcon * \date 08/06/2010 * \param other The other. **/ Array3D(const MyType& other) :m_array(new T[ArraySize]) { memcpy_s(m_array, sizeof(T)*ArraySize, other.m_array, sizeof(T)*ArraySize); } /** * \brief Destructor. * \author Vite Falcon * \date 08/06/2010 **/ ~Array3D(void) { delete[] m_array; m_array = 0; } /** * \brief Gets the value at a particular array index. * \author Vite Falcon * \date 08/06/2010 * \param array_index Zero-based index of the array. * \return The value at the given index. **/ inline T& at(size_t array_index) { return (*this)[array_index]; } /** * \brief Gets the value at a particular array index (const version) * \author Vite Falcon * \date 08/06/2010 * \param array_index Zero-based index of the array. * \return The value at the given index. **/ inline const T& at(size_t array_index) const { return (*this)[array_index]; } /** * \brief Gets the value in the array from the given 3D indices. * \author Vite Falcon * \date 08/06/2010 * \param x The width index. * \param y The height index. * \param z The depth index. * \return The value at the given indices. **/ inline T& at(size_t x, size_t y, size_t z) { return (*this)(x, y, z); } /** * \brief Gets the value in the array from the given 3D indices (const version). * \author Vite Falcon * \date 08/06/2010 * \param x The width index. * \param y The height index. * \param z The depth index. * \return The value at the given indices. **/ inline const T& at(size_t x, size_t y, size_t z) const { return (*this)(x, y, z); } /** * \brief The '()' operator to access the values as a 3D array. * \author Vite Falcon * \date 08/06/2010 * \return The value at the given indices. * * \param x The width index. * \param y The height index. * \param z The depth index. **/ inline T& operator ()(size_t x, size_t y, size_t z) { validateRange(x, y, z); return m_array[x*SizeY*SizeZ + y*SizeZ + z]; } /** * \brief The '()' operator to access the values as a 3D array (const version). * \author Vite Falcon * \date 08/06/2010 * \return The value at the given indices. * * \param x The width index. * \param y The height index. * \param z The depth index. **/ inline const T& operator()(size_t x, size_t y, size_t z) const { validateRange(x, y, z); return m_array[x*SizeY*SizeZ + y*SizeZ + z]; } /** * \brief The '[]' operator to access the values as a 1D array. * \author Vite Falcon * \date 08/06/2010 * \param array_index Zero-based index of the array. * \return Value at the given index. **/ inline T& operator[](size_t array_index) { validateIndex(array_index); return m_array[array_index]; } /** * \brief The '[]' operator to access the values as a 1D array. * \author Vite Falcon * \date 08/06/2010 * \param array_index Zero-based index of the array. * \return Value at the given index. **/ inline const T& operator[](size_t array_index) const { validateIndex(array_index); return m_array[array_index]; } /** * \brief Fills the array with the given value. * \author Vite Falcon * \date 08/06/2010 * \param val The value to fill the array. **/ void fill(const T& val) { for (size_t i = 0; i const size_t Array3D ::SizeX = x; template const size_t Array3D ::SizeY = y; template const size_t Array3D ::SizeZ = z; template const size_t Array3D ::ArraySize = x*y*z; You can also get the pointer to the array as a 1D by using the function: double* double_array = array.getArray(); EDIT: Changed the usage to show it with double rather than int.
