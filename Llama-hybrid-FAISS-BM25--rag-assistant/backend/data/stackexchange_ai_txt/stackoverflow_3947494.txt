[site]: stackoverflow
[post_id]: 3947494
[parent_id]: 
[tags]: 
Keep relative positions over MultiScaleImage

I implemented the following Silverlight app after seeing this instructions , here's my code: public partial class MainPage : UserControl { private Point lastMousePos = new Point(); private double zoom = 1; private Point lastMouseLogicaPos = new Point(); private Point lastMouseViewPort = new Point(); private bool duringDrag = false; private bool duringOpen = false; private List dots = new List (); private bool addDot = false; public MainPage() { InitializeComponent(); this.MouseMove += delegate(object sender, MouseEventArgs e) { this.lastMousePos = e.GetPosition(this.ZoomImage); }; ZoomImage.MouseWheel += new MouseWheelEventHandler(ZoomImage_MouseWheel); this.ZoomImage.UseSprings = false; } private void ZoomImage_MouseWheel(object sender, MouseWheelEventArgs e) { double newzoom = zoom; if (e.Delta > 0) { newzoom /= 1.3; } else { newzoom *= 1.3; } Point logicalPoint = this.ZoomImage.ElementToLogicalPoint(this.lastMousePos); this.ZoomImage.ZoomAboutLogicalPoint(zoom / newzoom, logicalPoint.X, logicalPoint.Y); zoom = newzoom; e.Handled = true; } private void ZoomImage_MouseLeftButtonDown(object sender, System.Windows.Input.MouseButtonEventArgs e) { lastMouseLogicaPos = e.GetPosition(LayoutRoot); lastMouseViewPort = this.ZoomImage.ViewportOrigin; foreach (var dot in this.dots) { dot.LastMouseLogicPos = e.GetPosition(LayoutRoot); } if (!this.addDot) { duringDrag = true; } } private void ZoomImage_MouseLeftButtonUp(object sender, System.Windows.Input.MouseButtonEventArgs e) { if (this.addDot) { Dot dot = new Dot(this.lastMouseLogicaPos.X, this.lastMouseLogicaPos.Y) { Name = "Dot" + (this.dots.Count + 1).ToString() }; this.dots.Add(dot); this.DotCanvas.Children.Add(dot); } else { duringDrag = false; } } private void ZoomImage_MouseMove(object sender, System.Windows.Input.MouseEventArgs e) { if (duringDrag) { double zoomFactor = 1 / this.ZoomImage.ViewportWidth; Point newPoint = lastMouseViewPort; Point thisMouseLogicalPos = e.GetPosition(LayoutRoot); newPoint.X += (lastMouseLogicaPos.X - thisMouseLogicalPos.X) / (this.ZoomImage.ActualWidth * zoomFactor); newPoint.Y += (lastMouseLogicaPos.Y - thisMouseLogicalPos.Y) / (this.ZoomImage.ActualWidth * zoomFactor); this.ZoomImage.ViewportOrigin = newPoint; foreach (var dot in this.dots) { Point dotLogicPoint = this.ZoomImage.ElementToLogicalPoint(new Point(dot.X, dot.Y)); thisMouseLogicalPos = e.GetPosition(LayoutRoot); dotLogicPoint.X -= (dot.LastMouseLogicPos.X - thisMouseLogicalPos.X) / ((1 / 1.8) * this.ZoomImage.ViewportWidth); dotLogicPoint.Y -= (dot.LastMouseLogicPos.Y - thisMouseLogicalPos.Y) / (this.ZoomImage.ActualWidth * this.ZoomImage.ViewportWidth); dot.X = (this.ZoomImage.LogicalToElementPoint(locLogicPoint).X); dot.Y = (this.ZoomImage.LogicalToElementPoint(locLogicPoint).Y); } } } private void ZoomImage_ImageOpenSucceeded(object sender, System.Windows.RoutedEventArgs e) { duringOpen = true; } private void ZoomImage_MotionFinished(object sender, System.Windows.RoutedEventArgs e) { if (duringOpen) { duringOpen = false; } } private void Button_Click(object sender, System.Windows.RoutedEventArgs e) { this.addDot = !this.addDot; if (this.addDot) { this.btnAddDot.Content = "Click on Image"; } else { this.btnAddDot.Content = "Add Dot"; } } } With this I can zoom and pan on a MultiScaleImage and add my custom Dot object to the DotCanvas canvas. Here's the XAML: Now, the problem is that, since the Dots are placed in a canvas that's over the MultiScateImage (ZoomImage object) when I pan and zoom the Dots will stay in their respective place over the canvas. This code has some missed tries trying to keep the Dots on place while the image is panning and zooming. Here's an image of the app, the blue dots around are my custom Dot object: The main question is, how can I keep the Dots in their relative place over the image while the user zooms and pans.
