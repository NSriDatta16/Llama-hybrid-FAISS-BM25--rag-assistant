[site]: stackoverflow
[post_id]: 3674967
[parent_id]: 3674466
[tags]: 
Using function pointers for this is very unlikely to give you speed optimizations. Firstly, you'd be adding 100 pointers to the functions. Second, the functions now have to be called through memory indirection, which is slower than a direct call. Third, your compiler will have a harder time doing function inlining. The specifics of just how performance is affected will depend on compiler and target platform, but for x86 you really don't want to go the function pointer route unless the functions take a fair amount of identical parameters. And if you want to really optimize, for readability as well as speed, you need to refactor . EDIT If we assume 32bit x86 and a normal compiler, and all functions taking no arguments, doing 100 sequential calls will take up 500 bytes at the call site, since call is encoded as E8 + four byte eip-relative destination offset. Converting to function pointers, you'll end up with a pointer table taking 400 bytes (it's possible that this could be encoded smaller, but since we aren't told where funcNNN are defined nor compiler, I'll assume 100 standard 32bit pointers). In addition to that, you need code to iterate through the pointer array and call the functions; this code depends on your compiler, the Visual C++ 2010 generated code is 16 bytes. So you've saved a mere 84 bytes, at the cost of execution speed. Without knowing more about the functions called, it's a bit hard commenting much further.
