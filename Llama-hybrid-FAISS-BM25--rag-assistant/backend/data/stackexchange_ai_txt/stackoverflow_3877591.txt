[site]: stackoverflow
[post_id]: 3877591
[parent_id]: 3875615
[tags]: 
I realize now (thanks to those that answered) that using a custom IComparer like this below removes the need to use swap. This solution guarantees the order and will still work correctly when one of the 5 possible values is missing. class CustomOrder : IComparer { static readonly Dictionary dictionary = new Dictionary () { {"Excellent", 1}, {"Very Good", 2}, {"Average", 3}, {"Bad", 4}, {"Very Bad", 5} }; public int Compare(Series x, Series y) { return dictionary[x.Name].CompareTo(dictionary[y.Name]); } } public partial class _Default : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { Series[] sortedSeries = chart.Series.ToArray(); Array.Sort(sortedSeries, new CustomOrder()); } } Old solution using swap (for reference) I don't like it, but this seems to work. Anyone have any better ideas? int count = collection.Count; // don't need to swap if there is only one element if (count > 1) { // have to run once for each letter sortCollection(count); sortCollection(count); sortCollection(count); sortCollection(count); } private void sortCollection(int count) { if (collection.Contains(collection['c'])) { // take care of last element collection.Swap(count - 1, collection.IndexOf(collection['c'])); } if (collection.Contains(collection['a']) && collection.Contains(collection['b'])) { // take care of middle elements if(collection[1] != collection['b']) collection.Swap(collection['a'], collection['b']); } if (collection.Contains(collection['d'])) { // take care of first element if(collection[0] != collection['d']) collection.Swap(0, collection.IndexOf(collection['d'])); } }
