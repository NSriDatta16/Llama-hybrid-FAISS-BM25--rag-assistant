[site]: stackoverflow
[post_id]: 3773678
[parent_id]: 3772664
[tags]: 
Okay, let's get ready to get your hands dirty :) I'll be using std::mismatch and std::transform First of all, some types: typedef std::map input_map; typedef input_map::const_reference const_reference; typedef input_map::const_iterator const_iterator; typedef std::pair const_pair; typedef std::map > result_map; Then predicates bool less(const_reference lhs, const_reference rhs) { return lhs.first Now main: result_map func(input_map const& m1, input_map const& m2) { if (m1.empty() || m2.empty()) { return result_map(); } // mismatch unfortunately only checks one range // god do I hate those algorithms sometimes... if (*(--m1.end()) I find this solution quite elegant... notwithstanding the awkard setup part since we need to ensure that the first range ends up quicker than the second because of mismatch ... Notice that the advance is really stupid, we could loop specifically here until we had *next.first.key == *next.second.key but it would complicate the loop. I really don't find this better than a handcrafted loop though... consider: result_map func2(input_map const& lhs, input_map const& rhs) { result_map result; for (const_iterator lit = lhs.begin(), lend = lhs.end(), rit = rhs.begin(), rend = rhs.end(); lit != lend && rit != rend;) { if (lit->first first) { ++lit; } else if (rit->first first) { ++rit; } else { result[lit->first] = std::make_pair(lit->second, rit->second); ++lit, ++rit; } } return result; } It's much more compact, probably more efficient... sometimes the functions you're looking are not general enough to be in the STL :)
