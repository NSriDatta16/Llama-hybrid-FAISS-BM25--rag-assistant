[site]: stackoverflow
[post_id]: 629763
[parent_id]: 619497
[tags]: 
Long story short: vsnprintf corrupted my heap under HP-UX 11.11. vsnprintf was introduced in C99 (ISO/IEC 9899:1999) and "is equivalent to snprintf, with the variable argument list" (ยง7.19.6.12.2), snprintf (ยง7.19.6.5.2): "If n is zero, nothing is written". Well, HP UX 11.11 doesn't comply with this specification. When 2nd arg == 0, arguments are written at the end of the 1st arg.. which, of course, corrupts the heap (I allocate no space when maxsize==0, given that nothing should be written). HP manual pages are unclear ("It is the user's responsibility to ensure that enough storage is available."), nothing is said regarding the case of maxsize==0 . Nice trap.. at the very least, the WARNINGS section of the man page should warn std-compliant users.. It's an egg/chicken pb: vnsprintf is variadic, so for the "user's responsibility" to ensure that enough storage is available" the "user's responsibility" must first know how much space is needed. And the best way to do that is to call vnsprintf with 2nd arg == 0: it should then return the amount of space required and sprintfs nothing.. well, except HP's ! One solution to use vnsprintf under this std violation to determine needed space: malloc 1 byte more to your buffer (1st arg) and call vnsprintf(buf+buf.length,1,..). This only puts a \0 in the new byte you allocated. Silly, but effective. If you're under wchar conditions, malloc(sizeof..). Anyway, workaround is trivial : never call v/snprintf under HP-UX with maxsize==0! I now have a happy stable program! Thanks to all contributers. Heap corruption through vsnprintf under HP-UX B11.11 This program prints "@@" under Linux/Cygwin/.. It prints "@fooo@" under HP-UX B11.11: #include #include const int S=2; void f (const char *fmt, ...) { va_list ap; int actualLen=0; char buf[S]; bzero(buf, S); va_start(ap, fmt); actualLen = vsnprintf(buf, 0, fmt, ap); va_end(ap); printf("@%s@\n", buf); } int main () { f("%s", "fooo"); return 0; }
