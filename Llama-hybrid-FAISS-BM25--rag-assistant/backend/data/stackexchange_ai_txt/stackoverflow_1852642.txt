[site]: stackoverflow
[post_id]: 1852642
[parent_id]: 1852580
[tags]: 
I'm not a nhibernate guru, but answer seems simple. When nhibernate loads an object, it expects it not to change in db as long as it's in nhibernate session cache. As you mentioned - you got multi thread app. This is what happens=> 1st thread loads an entity 2nd thread loads an entity 1st thread changes entity 2nd thread changes entity and => finds out that loaded entity has changed by something else and being afraid that it has screwed up changes 1st thread made - throws an exception to let programmer be aware about that. You are missing locking mechanism. Can't tell much about how to apply that properly and elegantly. Maybe Transaction would help. We had similar problems when we used nhibernate and raw ado.net concurrently (luckily - just for querying - at least for production code). All we had to do - force updating db on insert/update so we could actually query something through full-text search for some specific entities. Had StaleStateException in integration tests when we used raw ado.net to reset db. NHibernate session was alive through bunch of tests, but every test tried to cleanup db without awareness of NHibernate.
