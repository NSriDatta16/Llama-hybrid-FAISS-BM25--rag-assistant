[site]: stackoverflow
[post_id]: 1422302
[parent_id]: 1422246
[tags]: 
You cannot make NVARCHAR(MAX) a part of a key in a plain B-Tree index (you can still use it as an included column in an index). Otherwise, the storage will be the same as long as the data in the column does not exceed the row size threshold. Since you're probably not going to index this field anyway, it's a good idea to create it as NVARCHAR(MAX) . Even if you still want to index it (say, to do prefix searches using LIKE ), you can create a computed NVARCHAR(450) column, create an index on that column, and add it to your queries for coarse filtering. See this entry in my blog for more details: Indexing VARCHAR(MAX) If you are going to do exact searches for the small columns only, create a computed column, index it and query like this: ALTER TABLE History ADD HistoryDetailsIndex AS SUBSTRING(HistoryDetails, 1, 50) CREATE INDEX ix_mytable_typeid_details ON History (HistoryTypeId, HistoryDetailsIndex) INCLUDE (HistoryDetails) SELECT COUNT(*) FROM History WHERE HistoryTypeId = 123 AND HistoryDetailsIndex LIKE 'string_prefix_up_to_50_characters%' AND HistoryDetails = 'string_prefix_up_to_50_characters_plus_everything_after_it' This will include only only the first 50 characters from your HistoryDetails into the index key (which will be searched in a LIKE condition), and everything into the included column. If you are absolutely sure you will never search for a string that is more than 50 characters long, you can omit the included column and just use this: SELECT COUNT(*) FROM History WHERE HistoryTypeId = 123 AND HistoryDetailsIndex = 'string_prefix_up_to_50_characters' This will make the index shorter. However, this will fail if you provide a string more than 50 characters long, so use it if you are absolutely sure you will never search for long strings.
