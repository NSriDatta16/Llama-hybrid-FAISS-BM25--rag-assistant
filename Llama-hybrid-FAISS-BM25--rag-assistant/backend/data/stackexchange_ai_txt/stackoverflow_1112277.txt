[site]: stackoverflow
[post_id]: 1112277
[parent_id]: 1112182
[tags]: 
I have been using the following utility function that I wrote a long time ago: /** * @classDescription This class contains different utility functions */ function Utils() {} /** * This method returns a delegate function closure that will call * targetMethod on targetObject with specified arguments and with * arguments specified by the caller of this delegate * * @param {Object} targetObj - the object to call the method on * @param {Object} targetMethod - the method to call on the object * @param {Object} [arg1] - optional argument 1 * @param {Object} [arg2] - optional argument 2 * @param {Object} [arg3] - optional argument 3 */ Utils.createDelegate = function( targetObj, targetMethod, arg1, arg2, arg3 ) { // Create an array containing the arguments var initArgs = new Array(); // Skip the first two arguments as they are the target object and method for( var i = 2; i So, in your example, I would replace function Field1_Changed(el) { Field_Changed(el, delegate(Agent().Field1_Changed, $j(el).val()), true); } With something along the lines function Field1_Changed(el) { Field_Changed(el, Utils.createDelegate(Agent(), Agent().Field1_Changed, $j(el).val()), true); } Then, inside of Agent().FieldX_Changed I would manually call getApplicationState() (and encapsulate that logic into a generic method to process field changes that all of the Agent().FieldX_Changed methods would internally call).
