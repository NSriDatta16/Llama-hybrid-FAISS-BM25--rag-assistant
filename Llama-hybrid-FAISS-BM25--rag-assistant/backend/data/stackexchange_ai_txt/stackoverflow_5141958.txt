[site]: stackoverflow
[post_id]: 5141958
[parent_id]: 5141163
[tags]: 
You have two possibilities: Use a normal controller and because the AJAX call is already async you probably wouldn't need more: public class TablesController : Controller { [HttpPost] public ActionResult ReturnTables(string s) { using (var client = new WebClient()) { string result = client.DownloadString("http://example.com"); // Assuming the remote address returns a JSON object // if not parse the response and return Json return Content(result, "application/json"); } } } Use an async controller and IOCP (I/O Completion Ports): public class TablesController : AsyncController { [HttpPost] public void ReturnTablesAsync(string s) { AsyncManager.OutstandingOperations.Increment(); var client = new WebClient(); client.DownloadStringCompleted += (sender, e) => { try { AsyncManager.Parameters["result"] = e.Result; } finally { AsyncManager.OutstandingOperations.Decrement(); } }; client.DownloadStringAsync(new Uri("http://www.example.com")); } public ActionResult ReturnTablesCompleted(string result) { // Assuming the remote address returns a JSON object // if not parse the response and return Json return Content(result, "application/json"); } } In both cases you would consume those actions the same way: // Not sure exactly what was the purpose of the "s" query string // parameter as I am not using it in the action var data = { s: 'some data' }; $.post(' ', data, function(result) { // Do something with the result }); The difference between those two approaches is that the async version would use I/O Completion Ports and wouldn't block any worker threads during the retrieval of the remote resource.
