[site]: stackoverflow
[post_id]: 5549074
[parent_id]: 5549021
[tags]: 
I suggest you test it. It is a fairly expensive operation if you need to do this many, many times but can be less expensive than Double.toString() or Integer.toString() if you used those to create the data in the first place. I also suggest you only use double unless you know using a float could never ever cause a rounding issue. ;) It is about as expensive as creating objects, like String or adding an entry to a HashMap. Unless you plan to avoid do this as well, I wouldn't worry about it. EDIT: Similar to @Stackers' benchmark I would run the test longer and use nanoTime() int runs = 10000000; String val = "" + Math.PI; long start = System.nanoTime(); for (int i = 0; i prints Average Float.parseFloat() time was 474 ns. Average Double.parseDouble() time was 431 ns. BTW: I have function which reads doubles from a direct ByteBuffer which takes 80 ns. It is faster because it doesn't need a String and it doesn't create any objects. However, it is by no means trivial to do this and you have to design your core system to avoid any object creation. ;)
