[site]: stackoverflow
[post_id]: 4337295
[parent_id]: 4336888
[tags]: 
You need to know what the encoding is of that parameter in the query-string. Ruby 1.9 includes support for strings tagged with their encodings. In Ruby 1.9, you could: params[:q].encoding # Rails 3 on 1.9 generally presents strings in UTF-8 params[:q].encode('utf-8') # ask Ruby to re-encode it to UTF-8 Then you need to convert the parameter from that encoding into UTF-8 before doing string-interpolation ( #{...} syntax). Or you need to pass the parameter as a SQL parameter, not using string-interpolation. Of course, this brings up the security consideration that, unless you know how to properly encode text for usage in SQL, you should never do string-interpolation to build SQL string fragments. Because SQL-fragments with parameters are quick and easy to do in Rails, you should use them. # Rails 2 Artist.all(:conditions => ['name like ?', "%#{params[:q]}%"]) Artist.all(:conditions => ['name like :q', { :q=> "%#{params[:q]}%" }]) # Rails 3 Artist.where('name like ?', "%#{params[:q]}") Artist.where('name like :q', :q => "%#{params[:q]}") SQL injection is the security problem that occurs when you do string-interpolation and encode strings in a way that builds correct SQL fragments for some input strings, but not for others. In languages/frameworks where parameters are more difficult to work with, it would be acceptable to do string-interpolation or string-building (if it remains easy to do string-interpolation or string-building), so long as you research exhaustively how you are required to encode the interpolated strings to build correct SQL fragments, regardless of the input string. Because SQL injection is so easy to avoid with Rails via ordered or named parameters (see the four samples above), you should not have any problems ensuring that your SQL fragments are all safe.
