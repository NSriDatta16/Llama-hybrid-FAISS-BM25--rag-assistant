[site]: stackoverflow
[post_id]: 2969574
[parent_id]: 2969140
[tags]: 
I really like this question. I don't know a whole lot, but I do have a few things (assisted by the Wikipedia article , which has some neat tables and such itself): I think that sum types/union types ( e.g. data Either a b = Left a | Right b ) are equivalent to inclusive disjunction. And, though I'm not very well acquainted with Curry-Howard, I think this demonstrates it. Consider the following function: andImpliesOr :: (a,b) -> Either a b andImpliesOr (a,_) = Left a If I understand things correctly, the type says that ( a ∧ b ) → ( a ★ b ) and the definition says that this is true, where ★ is either inclusive or exclusive or, whichever Either represents. You have Either representing exclusive or, ⊕; however, ( a ∧ b ) ↛ ( a ⊕ b ). For instance, ⊤ ∧ ⊤ ≡ ⊤, but ⊤ ⊕ ⊥ ≡ ⊥, and ⊤ ↛ ⊥. In other words, if both a and b are true, then the hypothesis is true but the conclusion is false, and so this implication must be false. However, clearly, ( a ∧ b ) → ( a ∨ b ), since if both a and b are true, then at least one is true. Thus, if discriminated unions are some form of disjunction, they must be the inclusive variety. I think this holds as a proof, but feel more than free to disabuse me of this notion. Similarly, your definitions for tautology and absurdity as the identity function and non-terminating functions, respectively, are a bit off. The true formula is represented by the unit type , which is the type which has only one element ( data ⊤ = ⊤ ; often spelled () and/or Unit in functional programming languages). This makes sense: since that type is guaranteed to be inhabited, and since there's only one possible inhabitant, it must be true. The identity function just represents the particular tautology that a → a . Your comment about non-terminating functions is, depending on what precisely you meant, more off. Curry-Howard functions on the type system, but non-termination is not encoded there. According to Wikipedia , dealing with non-termination is an issue, as adding it produces inconsistent logics ( e.g. , I can define wrong :: a -> b by wrong x = wrong x , and thus “prove” that a → b for any a and b ). If this is what you meant by “absurdity”, then you're exactly correct. If instead you meant the false statement, then what you want instead is any uninhabited type, e.g. something defined by data ⊥ —that is, a data type without any way to construct it. This ensures that it has no values at all, and so it must be uninhabited, which is equivalent to false. I think you could probably also use a -> b , since if we forbid non-terminating functions, then this is also uninhabited, but I'm not 100% sure. Wikipedia says that axioms are encoded in two different ways, depending on how you interpret Curry-Howard: either in the combinators or in the variables. I think the combinator view means that the primitive functions we are given encode the things we can say by default (similar to the way that modus ponens is an axiom because function application is primitive). And I think that the variable view may actually mean the same thing—combinators, after all, are just global variables which are particular functions. As for primitive types: if I'm thinking about this correctly, then I think that primitive types are the entities—the primitive objects that we're trying to prove things about. According to my logic and semantics class, the fact that ( a ∧ b ) → c ≡ a → ( b → c ) (and also that b → ( a → c )) is called the exportation equivalence law, at least in natural deduction proofs. I didn't notice at the time that it was just currying—I wish I had, because that's cool! While we now have a way to represent inclusive disjunction, we don't have a way to represent the exclusive variety. We should be able to use the definition of exclusive disjunction to represent it: a ⊕ b ≡ ( a ∨ b ) ∧ ¬( a ∧ b ). I don't know how to write negation, but I do know that ¬ p ≡ p → ⊥, and both implication and falsehood are easy. We should thus able to represent exclusive disjunction by: data ⊥ data Xor a b = Xor (Either a b) ((a,b) -> ⊥) This defines ⊥ to be the empty type with no values, which corresponds to falsity; Xor is then defined to contain both ( and ) Either an a or a b ( or ) and a function ( implication ) from (a,b) ( and ) to the bottom type ( false ). However, I have no idea what this means . ( Edit 1: Now I do, see the next paragraph!) Since there are no values of type (a,b) -> ⊥ (are there?), I can't fathom what this would mean in a program. Does anyone know a better way to think about either this definition or another one? ( Edit 1: Yes, camccann .) Edit 1: Thanks to camccann's answer (more particularly, the comments he left on it to help me out), I think I see what's going on here. To construct a value of type Xor a b , you need to provide two things. First, a witness to the existence of an element of either a or b as the first argument; that is, a Left a or a Right b . And second, a proof that there are not elements of both types a and b —in other words, a proof that (a,b) is uninhabited—as the second argument. Since you'll only be able to write a function from (a,b) -> ⊥ if (a,b) is uninhabited, what does it mean for that to be the case? That would mean that some part of an object of type (a,b) could not be constructed; in other words, that at least one, and possibly both, of a and b are uninhabited as well! In this case, if we're thinking about pattern matching, you couldn't possibly pattern-match on such a tuple: supposing that b is uninhabited, what would we write that could match the second part of that tuple? Thus, we cannot pattern match against it, which may help you see why this makes it uninhabited. Now, the only way to have a total function which takes no arguments (as this one must, since (a,b) is uninhabited) is for the result to be of an uninhabited type too—if we're thinking about this from a pattern-matching perspective, this means that even though the function has no cases, there's no possible body it could have either, and so everything's OK. A lot of this is me thinking aloud/proving (hopefully) things on the fly, but I hope it's useful. I really recommend the Wikipedia article ; I haven't read through it in any sort of detail, but its tables are a really nice summary, and it's very thorough.
