[site]: stackoverflow
[post_id]: 3491076
[parent_id]: 3490228
[tags]: 
Actually, I answered with another (somewhat humorous) answer which used a absolutely huge array for a table lookup but, thinking back on it, it's not that bad an idea, provided you limit the table size. The following functions trade off space for time. As with all optimisations, you should profile them yourself in the target environment. First the (elegant) recursive version: unsigned int getSum (unsigned int val) { static const unsigned char lookup[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, // 0- 9 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, // 10- 19 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, // 20- 29 : 18, 19, 20, 21, 22, 23, 24, 25, 26, 27 // 990-999 }; return (val == 0) ? 0 : getSum (val / 1000) + lookup[val%1000]; } It basically separates the number into three-digit groupings with fixed lookups for each possibility. This can easily handle a 64-bit unsigned value with a recursion depth of seven stack frames. For those who don't even trust that small amount of recursion (and you should, since normal programs go that deep and more even without recursion), you could try the iterative solution: unsigned int getSum (unsigned int val) { static const unsigned char lookup[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, // 0- 9 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, // 10- 19 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, // 20- 29 : 18, 19, 20, 21, 22, 23, 24, 25, 26, 27 // 990-999 }; unsigned int tot = 0; while (val != 0) { tot += lookup[val%1000]; val /= 1000; } return tot; } These are probably three times faster than the one-digit-at-a-time solution, at the cost of a thousand bytes of data. If you're not adverse to using 10K or 100K, you could increase the speed to four or five times but you may want to write a program to generate the static array statement above :-) As with all optimisation options, measure, don't guess! I prefer the more elegant recursive solution myself but I'm also one of those types who prefer cryptic crosswords. Read into that what you will.
