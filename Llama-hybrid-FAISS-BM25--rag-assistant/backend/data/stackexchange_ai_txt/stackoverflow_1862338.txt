[site]: stackoverflow
[post_id]: 1862338
[parent_id]: 1862304
[tags]: 
The app delegate is a reasonable place to put it. Another option would be to create a custom singleton factory class that has a class method that returns your location manager delegate and implement the delegate methods there. That would keep your app delegate class cleaner. Here's a skeleton singleton class implemention based off of Peter Hosey's "Singletons in Cocoa: Doing them wrong" . This may be overkill, but it's a start. Add your delegate methods at the end. static MyCLLocationManagerDelegate *sharedInstance = nil; + (void)initialize { if (sharedInstance == nil) sharedInstance = [[self alloc] init]; } + (id)sharedMyCLLocationManagerDelegate { //Already set by +initialize. return sharedInstance; } + (id)allocWithZone:(NSZone*)zone { //Usually already set by +initialize. @synchronized(self) { if (sharedInstance) { //The caller expects to receive a new object, so implicitly retain it //to balance out the eventual release message. return [sharedInstance retain]; } else { //When not already set, +initialize is our caller. //It's creating the shared instance, let this go through. return [super allocWithZone:zone]; } } } - (id)init { //If sharedInstance is nil, +initialize is our caller, so initialze the instance. //If it is not nil, simply return the instance without re-initializing it. if (sharedInstance == nil) { if ((self = [super init])) { //Initialize the instance here. } } return self; } - (id)copyWithZone:(NSZone*)zone { return self; } - (id)retain { return self; } - (unsigned)retainCount { return UINT_MAX; // denotes an object that cannot be released } - (void)release { // do nothing } - (id)autorelease { return self; } #pragma mark - #pragma mark CLLLocationManagerDelegateMethods go here...
