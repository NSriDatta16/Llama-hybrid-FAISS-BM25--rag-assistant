[site]: stackoverflow
[post_id]: 4265544
[parent_id]: 
[tags]: 
Subqueries and MySQL Cache for 18M+ row table

As this is my first post it seems I can only post 1 link so I have listed the sites I'm referring to at the bottom. In a nutshell my goal is to make the database return the results faster, I have tried to include as much relevant information as I could think of to help frame the questions at the bottom of the post. Machine Info 8 processors model name : Intel(R) Xeon(R) CPU E5440 @ 2.83GHz cache size : 6144 KB cpu cores : 4 top - 17:11:48 up 35 days, 22:22, 10 users, load average: 1.35, 4.89, 7.80 Tasks: 329 total, 1 running, 328 sleeping, 0 stopped, 0 zombie Cpu(s): 0.0%us, 0.0%sy, 0.0%ni, 87.4%id, 12.5%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 8173980k total, 5374348k used, 2799632k free, 30148k buffers Swap: 16777208k total, 6385312k used, 10391896k free, 2615836k cached However we are looking at moving the mysql installation to a different machine in the cluster that has 256 GB of ram Table Info My MySQL Table looks like CREATE TABLE ClusterMatches ( id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, cluster_index INT, matches LONGTEXT, tfidf FLOAT, INDEX(cluster_index) ); It has approximately 18M rows, there are 1M unique cluster_index's and 6K unique matches. The sql query I am generating in PHP looks like. SQL query $sql_query="SELECT `matches`,sum(`tfidf`) FROM (SELECT * FROM Test2_ClusterMatches WHERE `cluster_index` in (".$clusters.")) AS result GROUP BY `matches` ORDER BY sum(`tfidf`) DESC LIMIT 0, 10;"; where $cluster contains a string of approximately 3,000 comma separated cluster_index's. This query makes use of approximately 50,000 rows and takes approximately 15s to run, when the same query is run again it takes approximately 1s to run. Usage The content of the table can be assumed to be static. Low number of concurrent users The query above is currently the only query that will be run on the table Subquery Based on this post [stackoverflow: Cache/Re-Use a Subquery in MySQL][1] and the improvement in query time I believe my subquery can be indexed. mysql> EXPLAIN EXTENDED SELECT `matches`,sum(`tfidf`) FROM (SELECT * FROM ClusterMatches WHERE `cluster_index` in (1,2,...,3000) AS result GROUP BY `matches` ORDER BY sum(`tfidf`) ASC LIMIT 0, 10; +----+-------------+----------------------+-------+---------------+---------------+---------+------+-------+---------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+----------------------+-------+---------------+---------------+---------+------+-------+---------------------------------+ | 1 | PRIMARY | derived2 | ALL | NULL | NULL | NULL | NULL | 48528 | Using temporary; Using filesort | | 2 | DERIVED | ClusterMatches | range | cluster_index | cluster_index | 5 | NULL | 53689 | Using where | +----+-------------+----------------------+-------+---------------+---------------+---------+------+-------+---------------------------------+ According to this older article [Optimizing MySQL: Queries and Indexes][2] in Extra info - the bad ones to see here are "using temporary" and "using filesort" MySQL Configuration Info Query cache is available, but effectively turned off as the size is currently set to zero mysqladmin variables; +---------------------------------+----------------------+ | Variable_name | Value | +---------------------------------+----------------------+ | bdb_cache_size | 8384512 | | binlog_cache_size | 32768 | | expire_logs_days | 0 | | have_query_cache | YES | | flush | OFF | | flush_time | 0 | | innodb_additional_mem_pool_size | 1048576 | | innodb_autoextend_increment | 8 | | innodb_buffer_pool_awe_mem_mb | 0 | | innodb_buffer_pool_size | 8388608 | | join_buffer_size | 131072 | | key_buffer_size | 8384512 | | key_cache_age_threshold | 300 | | key_cache_block_size | 1024 | | key_cache_division_limit | 100 | | max_binlog_cache_size | 18446744073709547520 | | sort_buffer_size | 2097144 | | table_cache | 64 | | thread_cache_size | 0 | | query_cache_limit | 1048576 | | query_cache_min_res_unit | 4096 | | query_cache_size | 0 | | query_cache_type | ON | | query_cache_wlock_invalidate | OFF | | read_rnd_buffer_size | 262144 | +---------------------------------+----------------------+ Based on this article on [Mysql Database Performance turning][3] I believe that the values I need to tweak are table_cache key_buffer sort_buffer read_buffer_size record_rnd_buffer (for GROUP BY and ORDER BY terms) Areas Identified for improvement - MySQL Query tweaks Changing the datatype for matches to an index that is an int pointing to another table [MySQL will indeed use a dynamic row format if it contains variable length fields like TEXT or BLOB, which, in this case, means sorting needs to be done on disk. The solution is not to eschew these datatypes, but rather to split off such fields into an associated table.][4] Indexing the new match_index feild so that the GROUP BY matches occurs faster, based on the statement ["You should probably create indices for any field on which you are selecting, grouping, ordering, or joining."][5] Tools To tweak perform I plan to use [Explain][6] making reference to [the output format][7] [ab - Apache HTTP server benchmarking tool][8] [Profiling][9] with [log data][10] Future Database Size The goal is to build a system that can have 1M unique cluster_index values 1M unique match values, approx 3,000,000,000 table rows with a response time to the query of around 0.5s (we can add more ram as necessary and distribute the database across the cluster) Questions I think we want to keep the entire recordset in ram so that the query doesnt touch the disk, if we keep the entire database in the MySQL cache does that eliminate the need for memcachedb? Is trying to keep the entire database in MySQL cache a bad strategy as its not designed to be persistent? Would something like memcachedb or redis be a better approach, if so why? Is the temporary table "result" that is created by the query automatically destroyed when the query finishes? Should we switch from Innodb to MyISAM [as its good for read heavy data where as InnoDB is good for write heavy][11] ? my cache doesnt appear to be on as its zero in my [Query Cache Configuration][12], why does the query currently occur faster the second time I run it? can i restructure my query to eliminate "using temporary" and "using filesort" occuring, should i be using a join instead of a subquery? how do you view the size of the MySQL [Data Cache][13]? what sort of sizes for the values table_cache, key_buffer, sort_buffer, read_buffer_size, record_rnd_buffer would you suggest as a starting point? Links 1: stackoverflow.com/questions/658937/cache-re-use-a-subquery-in-mysql 2: databasejournal.com/features/mysql/article.php/10897_1382791_4/Optimizing-MySQL-Queries-and-Indexes.htm 3: debianhelp.co.uk/mysqlperformance.htm 4: 20bits.com/articles/10-tips-for-optimizing-mysql-queries-that-dont-suck/ 5: 20bits.com/articles/10-tips-for-optimizing-mysql-queries-that-dont-suck/ 6: dev.mysql.com/doc/refman/5.0/en/explain.html 7: dev.mysql.com/doc/refman/5.0/en/explain-output.html 8: httpd.apache.org/docs/2.2/programs/ab.html 9: mtop.sourceforge.net/ 10: dev.mysql.com/doc/refman/5.0/en/slow-query-log.html 11: 20bits.com/articles/10-tips-for-optimizing-mysql-queries-that-dont-suck/ 12: dev.mysql.com/doc/refman/5.0/en/query-cache-configuration.html 13: dev.mysql.com/tech-resources/articles/mysql-query-cache.html
