[site]: stackoverflow
[post_id]: 5610192
[parent_id]: 5609892
[tags]: 
Update: I've seemingly solved this issue. I had a breakpoint where the client read the server response tcpClient.GetStream().Read(buffer, 0, buffer.Length); and noted that fewer bytes were read from the "problem" server. After a quick google I found this article http://social.msdn.microsoft.com/Forums/en-US/ncl/thread/759f3f2f-347b-4bd8-aa05-fb7f681c3426 in which Dave Murray suggests: There are a couple ways to handle this more elegantly. If you're not planning on reusing the connection for anything else, the easiest is what nobugz suggests. When the server is done sending data, have it Close() it's end of the connection. When the client has read all data sent before the Close, Read will start returning 0, at which point you know the server isn't planning on sending anything else. So i updated my code from a single read to: var buffer = new byte[32768]; var totalBytesRead = 0; var bytesRead = tcpClient.GetStream().Read(buffer, 0, buffer.Length); do { totalBytesRead += bytesRead; bytesRead = tcpClient.GetStream().Read(buffer, totalBytesRead, bytesRead); } while (bytesRead > 0); and updated my server code to close the connection as per the post. And according to the comment from @leppie i can probably remove my Base64 wrapped properties...
