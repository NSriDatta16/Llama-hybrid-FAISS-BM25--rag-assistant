[site]: stackoverflow
[post_id]: 4729943
[parent_id]: 4729847
[tags]: 
1) Make a public property, that returns the counter value. Name it "Counter" 2) Implement INotifyPropertyChanged and call PropertyChanged(new PropertyChangedEventArgs("Counter")) for every change of the counter-value 3) Change your markup as follows: This is only one possiblity of many. This link leads you to an overview of DataBinding. I could imagine that this document will clarify the above steps. Update As you wished in your comment, here an example, I assume you are in the main-window. I have changed some things against the above sequence: I have set the DataContext in the constructor. Therefore it is no more necessary to use a relative source for the Binding. Both ways are possible (and both are not very elegant, but to learn WPF-Databinding, they are appropriate). Maybe you try both, the only difference is the binding-declaration and the constructor code. public partial class MainWindow : Window , INotifyPropertyChanged{ public event PropertyChangedEventHandler PropertyChanged; int m_counter; public MainWindow() { InitializeComponent(); DataContext=this; } public int Counter { get { return m_counter; } set { if (m_counter != value) { m_counter = value; OnPropertyChanged(new PropertyChangedEventArgs("Counter")); } } } protected virtual void OnPropertyChanged(PropertyChangedEventArgs e) { if (null != PropertyChanged) { PropertyChanged(this,e); } } private void ClickNextButton(object sender, System.Windows.RoutedEventArgs e){ Counter += 1; if (Counter == 1) { } if (Counter == 2) { } } Continue with class declaration... And the XAML:
