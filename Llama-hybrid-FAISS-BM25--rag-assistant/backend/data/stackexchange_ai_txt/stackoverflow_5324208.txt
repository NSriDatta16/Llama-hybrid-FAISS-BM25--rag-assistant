[site]: stackoverflow
[post_id]: 5324208
[parent_id]: 5315868
[tags]: 
It should be a matter of mapping the length of your drag area to the length of the timeline: stage.addEventListener(MouseEvent.MOUSE_MOVE, updateAnimation); function updateAnimation(event:MouseEvent):void { animation.gotoAndStop(Math.floor(mouseX/stage.stageWidth * animation.totalFrames)); } Here's a commented version: stage.addEventListener(MouseEvent.MOUSE_MOVE, updateAnimation); function updateAnimation(event:MouseEvent):void { //take the ratio between the mouse position and stage width -> //a number from 0.0 to 1.0 var mouseRatio:Number = mouseX/stage.stageWidth; //'scale'/multiply that number to fit the animation frames -> from a maximum of 1.0 to animation's total frames //also, we 'round down' because we need an integer for the frame number, not a fractional number var frame:int = Math.floor(mouseRatio * animation.totalFrames); animation.gotoAndStop(frame); } Also, not that MOUSE_MOVE gets triggered several frames per second. You could update on ENTER_FRAME and since you mentioned dragging, you could also have a variable to keep track if the mouse is pressed or released: var mousePressed:Boolean; stage.addEventListener(MouseEvent.MOUSE_DOWN, togglePressed); stage.addEventListener(MouseEvent.MOUSE_UP, togglePressed); stage.addEventListener(Event.ENTER_FRAME, update); function togglePressed(event:MouseEvent):void { mousePressed = event.type == MouseEvent.MOUSE_DOWN; } function update(event:Event):void { if(mousePressed) animation.gotoAndStop(Math.floor(mouseX/stage.stageWidth * animation.totalFrames)); } HTH
