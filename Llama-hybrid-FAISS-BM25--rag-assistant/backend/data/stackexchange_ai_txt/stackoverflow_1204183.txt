[site]: stackoverflow
[post_id]: 1204183
[parent_id]: 1199646
[tags]: 
Implementing an interface as demonstrated simply and plainly by dfa is clean and elegant (and "officially" supported way). This what the interface concept is meant for. In C#, we could use delegates for programmers who like to use functon pointers in c, but DFA's technique is the way to use. You could have an array too Command[] commands = { new CommandA(), new CommandB(), new CommandC(), ... } Then you could execute a command by index commands[7].exec(); Plagiarising from DFA's, but having an abstract base class instead of an interface. Notice the cmdKey which would be used later. By experience, I realise that frequently an equipment commmand has subcommands too. abstract public class Command() { abstract public byte exec(String subCmd); public String cmdKey; public String subCmd; } Construct your commands thus, public class CommandA extends Command { public CommandA(String subCmd) { this.cmdKey = "A"; this.subCmd = subCmd; } public byte exec() { sendWhatever(...); byte status = receiveWhatever(...); return status; } } You could then extend generic HashMap or HashTable by providing a key-value pair sucking function: public class CommandHash extends HashMap ( public CommandHash (Command[] commands) { this.commandSucker(Command[] commands); } public commandSucker(Command[] commands) { for(Command cmd : commands) { this.put(cmd.cmdKey, cmd); } } } Then construct your command store: CommandHash commands = new CommandHash( { new CommandA("asdf"), new CommandA("qwerty"), new CommandB(null), new CommandC("hello dolly"), ... }); Now you could send controls objectively commands.get("A").exec(); commands.get(condition).exec();
