[site]: stackoverflow
[post_id]: 1795807
[parent_id]: 1795370
[tags]: 
If rm -rf is slow, perhaps you are using a "sync" option or similar, which is writing to the disk too often. On Linux ext3 with normal options, rm -rf is very quick. One option for fast removal which would work on Linux and presumably also on various Unixen is to use a loop device, something like: hole temp.img $[5*1024*1024*1024] # create a 5Gb "hole" file mkfs.ext3 temp.img mkdir -p mnt-temp sudo mount temp.img mnt-temp -o loop The "hole" program is one I wrote myself to create a large empty file using a "hole" rather than allocated blocks on the disk, which is much faster and doesn't use any disk space until you really need it. http://sam.nipl.net/coding/c-examples/hole.c I just noticed that GNU coreutils contains a similar program "truncate", so if you have that you can use this to create the image: truncate --size=$[5*1024*1024*1024] temp.img Now you can use the mounted image under mnt-temp for temporary storage, for your build. When you are done with it, do this to remove it: sudo umount mnt-temp rm test.img rmdir mnt-temp I think you will find that removing a single large file is much quicker than removing lots of little files! If you don't care to compile my "hole.c" program, you can use dd, but this is much slower: dd if=/dev/zero of=temp.img bs=1024 count=$[5*1024*1024] # create a 5Gb allocated file
