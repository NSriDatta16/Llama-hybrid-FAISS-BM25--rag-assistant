[site]: stackoverflow
[post_id]: 2357622
[parent_id]: 2356117
[tags]: 
My understanding is that self.results = anArray; is the same as [self setResults:anArray]; just because results is a property in this case. The way setResults: is implemented is set by the @property (in this case it will retain the new value). So this means anArray will have a retain count of 1. After setting self.results, anArray will have a retain count of 2. This is why you want to release the previously used anArray. That said, I don't understand why setResults: crashes when you're setting it. (Maybe it just crashes only when you try to use self.results, instead of setting it?) I'm just a beginner myself, if something is wrong I strongly encourage everyone who reads this to let me know what is wrong or correct. Still learning this myself. The way Apple would do this: In the .h file @property (nonatomic, retain) NSArray *results In the .m file @synthesize results; - (id)init { NSArray *anArray = [[NSArray alloc] init]; // retainCount = 1 self.results = anArray; // retainCount = 2 [anArray release]; // retainCount = 1, only one "left" is in self.results } - (void)dealloc { [results release]; }
