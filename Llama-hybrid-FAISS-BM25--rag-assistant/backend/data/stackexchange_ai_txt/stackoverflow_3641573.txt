[site]: stackoverflow
[post_id]: 3641573
[parent_id]: 
[tags]: 
Of which things should I take care if I'm using unboxed type (like Int#) in Haskell / GHC?

I'm trying to write a small script which parses and executes Brainfuck code, to understand the GHC options of optimization, I'm trying to optimize the code in order to be a bit faster and to understand what's going on there. On of the parts is the internal represantation of BF-code, I use a special datatype for this. Here's the sourcecode, included the two functions which are doing the conversions: data BFinstruction = AdjustValue Int | MovePointer Int | GetChar | PutChar | Loop BFcode deriving (Eq) type BFcode = [BFinstruction] unsafeCompileBrainfuck :: String -> BFcode unsafeCompileBrainfuck = fst . parse [] where -- arguments: input string, built code; output: output code, rest of input parse :: BFcode -> String -> (BFcode,String) parse c ('+':s) = parse (AdjustValue 1 :c) s parse c ('-':s) = parse (AdjustValue (-1):c) s parse c ('>':s) = parse (MovePointer 1 :c) s parse c (' BFcode simplifyBrainfuck ((AdjustValue x):(AdjustValue y):zs) = if x + y /= 0 then simplifyBrainfuck (AdjustValue (x + y):zs) else simplifyBrainfuck zs simplifyBrainfuck ((MovePointer x):(MovePointer y):zs) = if x + y /= 0 then simplifyBrainfuck (MovePointer (x + y):zs) else simplifyBrainfuck zs simplifyBrainfuck (x :zs) = x: simplifyBrainfuck zs simplifyBrainfuck [] = [] The idea is, that the code will be read from some input (string), preparsed and simplified by the above code and then executed by some other functions. (It is assumed, that the input is valid). In order to optimize this example, I tried to unbox the Int params of the MovePointer and AdjustValue constructors by doing domething like this: data BFinstruction -- BangPatterns = AdjustValue {-# UNPACK #-} !Int | MovePointer {-# UNPACK #-} !Int | GetChar | PutChar | Loop BFcode deriving (Eq) This will turn the boxed Int type into an unboxed, raw Int# type, which is an implementation detail of GHc. As I read, this option is only good in a few cases, so I want to ask, of which things I have to pay attention if I want to perform this kind of optimization. My goal is to allow the execution of BF-code using the benefits of Haskell - laziness (I want to archieve, that the code may only be kept as needed in memory) and easiness.
