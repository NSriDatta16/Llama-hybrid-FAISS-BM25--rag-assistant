[site]: stackoverflow
[post_id]: 3596611
[parent_id]: 3595935
[tags]: 
I agree with the principle that NHibernate should not be abstracted completely but I have found that the querying interface of NHibernate can be hidden away without too much hassle and that can happen by using Query objects. Each query object should leverage the power the NHibernate provides (ISession, ICriteria, IQuery, etc) and can be executed by the implementation of the IRepository. Having Query objects instead of methods in your repositories offers better testability and it would not require any references to NHibernate in your test classes. Here is how the whole thing could look like: public interface IRepository { ISession Session { get; } TResult Query (IQuery query); } public class Repository : IRepository { public ISession Session { get { return /* Call the session factory to return an ISession */; } } public TResult Query (IQuery query) { return query.Execute(Session)); } } public interface IQuery { TResult Execute(QueryContext context); } public abstract class Query : IQuery { public abstract TResult Execute(ISession session); } public class GetPeopleByName: IQuery { private readonly string _name; public GetPeopleByName(string name) { _name = name; } public override IList Execute(ISeesion session) { var query = context.Session.CreateCriteria(typeof(Person)) .Add(Restrictions.Eq("Name", _name)); return query.List (); } } Then you can use the above like: IRepository repository = /* Get somehow the implementation */ IList people = repository.Execute(new GetPeopleByName("Anna"));
