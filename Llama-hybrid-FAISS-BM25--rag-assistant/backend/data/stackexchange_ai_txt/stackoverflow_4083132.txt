[site]: stackoverflow
[post_id]: 4083132
[parent_id]: 4081992
[tags]: 
I respectfully submit that if you're updating your primary key field, it's not a primary key. For a column to be a primary key the following three statements must be true: It must never be NULL. It must be UNIQUE. It must never change. The first two are commonly enforced by the database server, but most do not enforce the third one, and it's the third one that appears to be violated in your design. In my experience, this is something that you really don't want to do. Just because the database will allow you to do it does not mean it's a good idea. Here there be dragons. OK, you've been warned. As far as HOW to do what you're trying to do - I suggest that you scrap the ON UPDATE CASCADE option on the foreign key constraint and instead create an ON UPDATE trigger on the parent table. If you set it to fire after the update both the OLD and NEW values will be available and your code can test to see precisely which fields changed and take appropriate action. You may also need to set the foreign key to fire on COMMIT instead of a verb time - otherwise the short period of time that the constraint will be violated will cause the update to fail off, even though it would be corrected by the time a COMMIT was issued. (I'm not as familiar with SQL Server as I am with other databases (e.g. Oracle) and I'm not 100% positive you can defer constraint execution until COMMIT time under SQL Server. You may need to do a little digging). Share and enjoy.
