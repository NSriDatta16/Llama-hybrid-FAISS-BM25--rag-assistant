[site]: stackoverflow
[post_id]: 2010090
[parent_id]: 2009605
[tags]: 
As Drew says, this doesn't sound befitting of signals and slots. And as dribeas says, a workaround is a protocol with a bool& found parameter that starts out false, with every slot checking at the start and returns if its true. If any slot sets the value to true, then processing of the other calls will happen very quickly. But just to cover all the bases (even the inadvisable ones), I'll mention that since boost::signals are all run on the same thread as the caller you could throw a custom exception from within the signal, then catch it at the call site. For better or worse, people occasionally resort to this when they feel they have no other option...like during visitor algorithms in the boost graph library: How do I stop the breadth-first search using Boost Graph Library when using a custom visitor? And now that I've mentioned it, don't do it that way. :) UPDATE: Didn't know it but you found that boost has a mechanism for handling this elegantly with combiners that take iterators and not result values: "The input iterators passed to the combiner transform dereference operations into slot calls. Combiners therefore have the option to invoke only some slots until some particular criterion is met." If you're sure you're sticking with boost then you've answered your own question because that does what you want. Though do note that other signal/slot systems (like Qt's) won't have a parallel to this...
