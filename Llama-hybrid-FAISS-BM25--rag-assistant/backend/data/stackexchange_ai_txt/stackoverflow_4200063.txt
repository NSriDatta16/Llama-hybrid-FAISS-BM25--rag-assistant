[site]: stackoverflow
[post_id]: 4200063
[parent_id]: 4199353
[tags]: 
I supplied the answer, contingent on the idea that the format was fixed-length. If this doesn't work then, for sanity's sake we need to make another assumption. This one goes along the lines that the first two captures are alright, but that the third can't be used because it depends on fixed-length format. No-space-in-Filename Assumption So the new assumption is the following sequence: a '[' character followed by any number of non- '[' characters followed by a closing ']' character followed by whitespace followed by a file specified by non-whitespace characters Then this should work: my ( $vmid, $name, $file ) = m/^ ( \d+ ) \s+ ( \S+ ) \s+ ( [[] [^\]]+ [\]] \s+ \S+) /x ; 'Nix Filenames But the reason I didn't suggest this at first is that *NIX files can contain spaces, and the columns looked contained by the fixed-width assumption. So I tried to avoid some unknown complexity with a simple pragmatic assumption about the data. And that is a single space in the file name differentiated by multiple spaces in the output. I'll show that below, but if the data uses spaces in the file names and spaces to separate columns AND allows spaces in the Guest OS, Version or Annotation fields. Then you're not going to get what you want by a regex. Single-space only Assumption Here's the single-space assumption: m/^ ( \d+ ) \s+ ( \S+ ) \s+ ( \[ [^\]]+ \] \s+ \S+ (?: [ ] \S+ )* ) /x Ye-argh!! OR Brute force method The more difficult case can be covered by the following (more) special-case code: my ( $vmid, $name, $file_haystack ) = m/^ ( \d+ ) \s+ ( \S+ ) \s+ (.*\S) \s* $/x ; my @file_parts = split ' ', $file_haystack; my $file_name = shift @file_parts; while ( @file_parts and !-d $file_name ) { $file_name .= ' ' . shift @file_parts; } However , that assumes the file exists on the system that you're reading the output from. If that is not the case, you might make the dot-vmx assumption: m/^ ( \d+ ) \s+ ( \S+ ) \s+ ( \[ [^\]]+ \] \s+ .* [.]vmx ) \s /x This all might be moot OR You're closer to the data than I am Of course this might all be moot because, perhaps you can pass a command to your script to make the columns unambiguous, say, like in a CVS format. Or perhaps if it prints a path with spaces in it, it will print double quotes around it. OR perhaps you can make it display spaces in the path name with escapes preceding them. Double-quote asssumption: m/^ ( \d+ ) \s+ ( \S+ ) \s+ ( \[ [^\]]+ \] \s+ (?:" [^"]+ " | \S+ ))/x Excaped space assumption: m/^ ( \d+ ) \s+ ( \S+ ) \s+ ( \[ [^\]]+ \] \s+ (?: [^\s\\]+ | (\\\\)*\\. )/x If the reporting program has not put rules around the output--or if your internal process has not put rules around it's lack of rules, then foolproof assumptions cannot be made.
