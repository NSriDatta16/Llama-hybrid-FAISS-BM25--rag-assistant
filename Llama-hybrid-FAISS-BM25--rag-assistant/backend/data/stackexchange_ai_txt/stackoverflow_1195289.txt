[site]: stackoverflow
[post_id]: 1195289
[parent_id]: 1195230
[tags]: 
1) I use TestDriven.Net, and I like it so a +1 from me for that 2) Code coverage is useful, when thought about in the right frame of mind: High code coverage does not necessarily mean high quality unit tests, but... High quality unit tests does mean high code coverage I've only used NCover, so can't recommend alternatives. Regarding mocking - once you grasp what it is about and what it really means for you, you will see the benefits it has to offer. Namely, it means you're not dependent on the integration of the code you're testing with an outside dependency, and also helps to keep text execution time down (e.g. mocking your data access layer prevents costly interaction with the DB). That is an important factor in my opinion as if tests take a long time to run, people can start to not bother running them if it means they have to wait too long! I use NUnit, which has support for mocks built-in. Tie a TDD approach into a continuous integration environment (e.g. CruiseControl.NET ), and you have a very powerful and productive setup. When starting out in TDD/unit testing, I'd always recommend writing tests for code written from "now" onwards and not focussing too much on writing tests for legacy/existing code. That is a lot harder to do in general and a lot more expensive time-wise, particularly if the code is old/not fresh in anyone's mind! Update: To explain my last point a bit further, in response to Robert's comment... When you are trying to get up and running with TDD/unit testing, and gain momentum with the whole team, you want that to be as positive and productive as possible. Writing tests for old code that isn't being changed during this initial period is expensive compared to new code because the code is not fresh, the exact intricacies of it more than likely have to be worked out again and not necessarily by the original programmer. Plus the fact that you may well find it difficult to justify to the business, the time needed to spend revisiting old code to write tests for them, instead of working on new functionality/fixing real bugs/issues. It can become a negative experience-a developer who is tasked writing the tests for old code he knows/remembers little about will find it more difficult to do and thus their first experience is not a positive one. You do need to be careful too in this situation as you may end up with weak tests which gives you false confidence. In my experience, it's absolutely critical that everyone gets off to a positive start with this, else confidence/motivation in it fades and the end result is much worse. I'm not actually saying you should not add tests for legacy code - I do myself when I work in or around older code that doesn't have any tests in order to bit-by-bit, improve the test coverage and quality. The difference is, I'm already onboard with the process, a "believer". It's the early stages of it, that are key...hence my point about not focussing too much on the legacy code at the start.
