[site]: stackoverflow
[post_id]: 2167055
[parent_id]: 2166335
[tags]: 
Suppose the length of the original sequence is L and the number of subsequences is N . You may simplify the expression for standard deviation to get sqrt(E[X^2] - E[X]^2) , where E denotes expectation/average and X denotes your random variable -- in your case, the sum of the subsequences. (A similar formula applies for the "sample standard deviation".) Note that E[X] does not depend on how you split your sequence, because it will always be the total sum divided by N . Thus, we just want to minimize E[X^2] or equivalently, the sum of X^2 (they differ by a factor of N by the definition of average). At this point, we can see that this problem can be solved with dynamic programming. Let f(i,j) , for i from 0 to M and j from 1 to N , be the minimal sum of squares of sums of subsequences from the split of the first i elements of your sequence into j subsequences. Then we see that f(i,j) may be computed in terms of all the f(i',j') with i' and j . More specifically, if your sequence is a[k] indexed from 0 to M-1 : f(i,1) = sum( a[k] for 0 Having minimized f(N,L) , you can use standard dynamic programming techniques to recover the splits. In particular, you can store the l that minimizes f(i,j) . The runtime of this solution is O(L^2 N) because you compute O(L N) different values of f and the minimum is over O(L) different values of l . Here's a straightforward implementation in Perl: #!/usr/bin/perl use strict; use warnings; local $\ = $/; print join ", ", map {"@$_"} best( 2, qw(1 1 1 1 1 1 10 1) ); # prints "1 1 1 1 1 1, 10 1" print join ", ", map {"@$_"} best( 3, qw(4 1 1 1 1 6) ); # prints "4, 1 1 1 1, 6" sub best { my( $N, @a ) = @_; my( @f, @g, $i, $j, $k, $sum ); # DP base case $sum = 0; $f[0][1] = $g[0][1] = 0; for $i ( 1 .. @a ) { $sum += $a[$i-1]; $f[$i][1] = $sum * $sum; $g[$i][1] = 0; } # DP recurrence for $j ( 2 .. $N ) { $f[0][$j] = $g[0][$j] = 0; for $i ( 1 .. @a ) { $sum = 0; $f[$i][$j] = $f[$i][$j-1]; $g[$i][$j] = $i; for $k ( reverse 0 .. $i-1 ) { $sum += $a[$k]; if( $f[$i][$j] > $f[$k][$j-1] + $sum * $sum ) { $f[$i][$j] = $f[$k][$j-1] + $sum * $sum; $g[$i][$j] = $k; } } } } # Extract best expansion my( @result ); $i = @a; $j = $N; while( $j ) { $k = $g[$i][$j]; unshift @result, [@a[$k .. $i-1]]; $i = $k; $j--; } return @result; }
