[site]: stackoverflow
[post_id]: 5695726
[parent_id]: 
[tags]: 
Java based Neural Network --- how to implement backpropagation

I am building a test neural network and it is definitely not working. My main problem is backpropagation. From my research, I know that it is easy to use the sigmoid function. Therefore, I update each weight by (1-Output)(Output)(target-Output) but the problem with this is what if my Output is 1 but my target is not? If it is one at some point then the weight update will always be 0...For now I am just trying to get the darn thing to add the inputs from 2 input neurons, so the optimal weights should just be 1 as the output neuron simply adds its inputs. I'm sure I have messed this up in lots of places but here is my code: public class Main { public static void main(String[] args) { Double[] inputs = {1.0, 2.0}; ArrayList answers = new ArrayList (); answers.add(3.0); net myNeuralNet = new net(2, 1, answers); for(int i=0; i inputLayer; private ArrayList outputLayer; private ArrayList answers; public net(Integer numInput, Integer numOut, ArrayList answers){ inputLayer = new ArrayList (); outputLayer = new ArrayList (); this.answers = answers; for(int i=0; i randomWeights = createRandomWeights(numInput); inputLayer.add(new neuron(outputLayer, randomWeights, -100.00, true)); } for(int i=0; i getOutputs(){ return outputLayer; } public void backpropagation(){ for(int i=0; i iOutBack = iOut.getBackConn(); Double iSigDeriv = (1-iOut.getOutput())*iOut.getOutput(); Double iError = (answers.get(i) - iOut.getOutput()); System.out.println("Answer: "+answers.get(i) + " iOut: "+iOut.getOutput()+" Error: "+iError+" Sigmoid: "+iSigDeriv); for(int j=0; j createRandomWeights(Integer size){ ArrayList iWeight = new ArrayList (); for(int i=0; i connections; private ArrayList backconns; private ArrayList weights; private Double threshold; private Double input; private Boolean isOutput = false; private Boolean isInput = false; private Double totalSignal; private Integer numCalled; private Double myOutput; public neuron(ArrayList conns, ArrayList weights, Double threshold){ this.connections = conns; this.weights = weights; this.threshold = threshold; this.totalSignal = 0.00; this.numCalled = 0; this.backconns = new ArrayList (); this.input = 0.00; } public neuron(ArrayList conns, ArrayList weights, Double threshold, Boolean isin){ this.connections = conns; this.weights = weights; this.threshold = threshold; this.totalSignal = 0.00; this.numCalled = 0; this.backconns = new ArrayList (); this.input = 0.00; this.isInput = isin; } public neuron(Boolean tf){ this.connections = new ArrayList (); this.weights = new ArrayList (); this.threshold = 0.00; this.totalSignal = 0.00; this.numCalled = 0; this.isOutput = tf; this.backconns = new ArrayList (); this.input = 0.00; } public void setInput(Double input){ this.input = input; } public void setOut(Boolean tf){ this.isOutput = tf; } public void resetNumCalled(){ numCalled = 0; } public void setBackConn(ArrayList backs){ this.backconns = backs; } public Double getOutput(){ return myOutput; } public Double getInput(){ return totalSignal; } public Double getRealInput(){ return input; } public ArrayList getWeights(){ return weights; } public ArrayList getBackConn(){ return backconns; } public Double getWeight(Integer i){ return weights.get(i); } public void setWeight(Integer i, Double d){ weights.set(i, d); } public void setOutput(Double d){ myOutput = d; } public void activation(Double myInput){ numCalled++; totalSignal += myInput; if(numCalled==backconns.size() && isOutput){ System.out.println("Total Sig: "+totalSignal); setInput(totalSignal); setOutput(totalSignal); } } public void activation(){ Double activationValue = 1 / (1 + Math.exp(input)); setInput(activationValue); fire(); } public void fire(){ for(int i=0; i OK so that is a lot of code so allow me to explain. The net is simple for now, just an input layer and an output layer --- I want to add a hidden layer later but I'm taking baby steps for now. Each layer is an arraylist of neurons. Input neurons are loaded with inputs, a 1 and a 2 in this example. These neurons fire, which calculates the sigmoid of the inputs and outputs that to the output neurons, which adds them and stores the value. Then the net backpropagates by taking the (answer-output) (output) (1-output)(output of the specific input neuron) and updates the weights accordingly. A lot of times, it cycles through and I get infinity, which seems to correlate with negative weights or sigmoid. When that doesn't happen it converges to 1 and since (1-output of 1) is 0, my weights stop updating. The numCalled and totalSignal values are just so the algorithm waits for all neuron inputs before continuing. I know I'm doing this an odd way, but the neuron class has an arraylist of neurons called connections to hold the neurons that it is forward connected to. Another arraylist called backconns holds the backward connections. I should be updating the correct weights as well since I am getting all back connections between neurons i and j but of all neurons j (the layer above i) I am only pulling weight i. I apologize for the messiness --- I've been trying lots of things for hours upon hours now and still cannot figure it out. Any help is greatly appreciated!
