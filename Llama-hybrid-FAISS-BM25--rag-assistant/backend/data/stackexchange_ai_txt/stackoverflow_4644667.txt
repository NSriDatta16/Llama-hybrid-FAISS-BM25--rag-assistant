[site]: stackoverflow
[post_id]: 4644667
[parent_id]: 4644511
[tags]: 
First, Lambert is correct. EXEs run in their own process. The reason why EXEs can't load into another process is because they are not compiled for relative addressing and can not be easily have its code remapped to another address. Developers launch other EXE programs with the Win32 system call, "CreateProcess". But I don't think that was your question... I think you want to know how to manually load code from a binary into running process (and have it run on a dedicated thread). Most developers just call LoadLibrary/GetProcessAddress to map a DLL into the process space and CreateThread to launch a thread. So I think what you are basically asking, "how do I implement the core component of the kernel and OS known as the loader?" Or put another way, "how do I implement CreateProcess and LoadLibrary myself?" The OS loader does more than just parse binary files into memory and set the instruction pointer to the first line of code. It also loads other dependent DLLs. Because the process may already have allocated other code to run at the target address that the DLL was compiled to, it may also have to do fixup the addresses of the DLL to load it at another address. I'm likely missing many other steps including virtual memory allocation for the binary code itself. I do recommend looking at the Richter book for its sections on processes, threads, and DLLs. He discusses a bit of this and some details on parsing the PE format of DLLs. Studying the Linux kernel implementation of how it loads .SO files into a process space may also be a worthwhile study.
