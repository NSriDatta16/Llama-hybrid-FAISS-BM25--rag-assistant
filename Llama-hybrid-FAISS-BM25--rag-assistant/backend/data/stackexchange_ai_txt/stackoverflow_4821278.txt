[site]: stackoverflow
[post_id]: 4821278
[parent_id]: 4820659
[tags]: 
Floating point numbers don't overflow in this kind of situation, they only lose precision. So there are no advantages of a running average over a running total here. The consequence is the same whether the running total or the denominator grows. To maintain precision in a running total, keep subtotals instead of a single total. Just keep adding to a subtotal until adding one more would cause overflow. Then move on to the next subtotal. Since they are all the same order of magnitude (in base 2), optimal precision may be achieved by converting to floating point and using a pairwise accumulation into one final total. // first = errors, second = counter typedef pair , uint32_t > running_subtotals; void accumulate_error( uint32_t error, running_subtotals &acc ) { ( numeric_limits ::max() - error acc( total.first.begin(), total.first.end() ); while ( acc.size() != 1 ) { if ( acc.size() % 2 ) acc.push_back( 0 ); for ( size_t index = 0; index
