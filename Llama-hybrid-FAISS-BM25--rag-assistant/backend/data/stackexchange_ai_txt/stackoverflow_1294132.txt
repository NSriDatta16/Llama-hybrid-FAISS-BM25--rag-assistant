[site]: stackoverflow
[post_id]: 1294132
[parent_id]: 1266902
[tags]: 
SkippyFire's solution seems more elegant than mine, but I figured that I will show you how I solved the problem. The following solution shows what I did to build a collection that can be bound to a tree view, and you can determine which items have been selected. It does not implement any Bindable Lists or anything though. However, it is not clear from your post whether this is what you want. This is an example of my XML file: Then I have a class that represents each item. It contains a Name, a List of child nodes (1 level down), a reference to its parent, and a string that logs the attribute of the element. public class Items { public string Name { get; set; } public List SubCategories { get; set; } public string IsLeaf { get; set; } public string Parent { get; set; } } From there, I populate a list of Items as follows: List categories = new List (); XDocument categoriesXML = XDocument.Load("TreeviewControls.xml"); categories = this.GetCategories(categoriesXML.Element("controls")); This calls the GetCategories() method private List GetCategories(XElement element) { return (from category in element.Elements("control") select new Items() { Parent = element.Attribute("name").Value, Name = category.Attribute("name").Value, SubCategories = this.GetCategories(category), IsLeaf = category.Attribute("attribute").Value }).ToList(); } After the categories variable has been populated, I just assign the list as the treeview's ItemSource. controltree.ItemsSource = categories; And from there, if the choice changes in the tree, I check if the choice is a leaf node, and if so, I raise an event. private void Selection_Changed(object sender, RoutedEventArgs e) { Items x = controltree.SelectedItem as Items; if (x.IsLeaf.Equals("leaf")) _parent.RaiseChange(x.Parent+","+x.Name); } This solution works for any depth in the tree as well.
