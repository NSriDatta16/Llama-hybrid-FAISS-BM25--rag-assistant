[site]: stackoverflow
[post_id]: 3259825
[parent_id]: 
[tags]: 
Trouble with lazy convolution fn in Clojure

I am writing some signal processing software, and I am starting off by writing out a discrete convolution function . This works fine for the first ten thousand or so list of values, but as they get larger (say, 100k), I begin to get StackOverflow errors, of course. Unfortunately, I am having a lot of trouble converting the imperative convolution algorithm I have to a recursive & lazy version that is actually fast enough to use (having at least a modicum of elegance would be nice as well). I am also not 100% sure I have this function completely right, yet â€“ please let me know if I'm missing something/doing something wrong. I think it's correct. (defn convolve " Convolves xs with is. This is a discrete convolution. 'xs :: list of numbers 'is :: list of numbers " [xs is] (loop [xs xs finalacc () acc ()] (if (empty? xs) (concat finalacc acc) (recur (rest xs) (if (empty? acc) () (concat finalacc [(first acc)])) (if (empty? acc) (map #(* (first xs) %) is) (vec-add (map #(* (first xs) %) is) (rest acc))))))) I'd be much obliged for any sort of help: I'm still getting my bearings in Clojure, and making this elegant and lazy and/or recursive would be wonderful. I'm a little surprised how difficult it is to express an algorithm which is quite easy to express in an imperative language in a Lisp. But perhaps I'm doing it wrong! EDIT: Just to show how easy it is to express in an imperative language, and to give people the algorithm that works nicely and is easy to read, here is the Python version. Aside from being shorter, more concise and far easier to reason about, it executes orders of magnitude faster than the Clojure code: even my imperative Clojure code using Java arrays. from itertools import repeat def convolve(ns, ms): y = [i for i in repeat(0, len(ns)+len(ms)-1)] for n in range(len(ns)): for m in range(len(ms)): y[n+m] = y[n+m] + ns[n]*ms[m] return y Here, on the other hand, is the imperative Clojure code. It also drops the last, non fully-immersed, values from the convolution. So aside from being slow and ugly, it's not 100% functional. Nor functional. (defn imp-convolve-1 [xs is] (let [ys (into-array Double (repeat (dec (+ (count xs) (count is))) 0.0)) xs (vec xs) is (vec is)] (map #(first %) (for [i (range (count xs))] (for [j (range (count is))] (aset ys (+ i j) (+ (* (nth xs i) (nth is j)) (nth ys (+ i j))))))))) This is so disheartening. Please, someone show me I've just missed something obvious. EDIT 3: Here's another version I thought up yesterday, showing how I'd like to be able express it (though other solutions are quite elegant; I'm just putting another one out there!) (defn convolve-2 [xs is] (reduce #(vec-add %1 (pad-l %2 (inc (count %1)))) (for [x xs] (for [i is] (* x i))))) It uses this utility function vec-add : (defn vec-add ([xs] (vec-add xs [])) ([xs ys] (let [lxs (count xs) lys (count ys) xs (pad-r xs lys) ys (pad-r ys lxs)] (vec (map #(+ %1 %2) xs ys)))) ([xs ys & more] (vec (reduce vec-add (vec-add xs ys) more)))) (vec (reduce vec-add (vec-add xs ys) more))))
