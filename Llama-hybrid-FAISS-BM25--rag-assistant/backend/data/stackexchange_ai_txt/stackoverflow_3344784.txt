[site]: stackoverflow
[post_id]: 3344784
[parent_id]: 3344399
[tags]: 
Basically, this cannot be done using C#, as has been said by several posts in this thread. It has been argued that this is not proper OO, but I beg to disagree. For ease of reference, if you have it handy, check page 464+ of OOSC . The term to be used here is Invariant inheritance . The example given is a Rectangle (always four sides), inheriting from Polygon (any amount of sides larger then 2). The rule is simple, quote: The invariant property of a class is the boolean and of the assertions appearing in it invariant clause and of the invariant properties of its parents, if any. Bertrand Meyer uses Design By Contract. To a lesser extend this is available to C# as well. With .NET 4.0, it has become available through Spec# . About the argument that this is not proper OO : the argument is correct (preventing inheritance down the chain defies the contract), but without preventing inheritance, but adding restrictions on the values by using invariant clauses, the OO paradigm is saved and the inheritance chain remains intact. Something like this: abstract class Animal { public abstract Legs { get; } } class Dog : Animal { public Dog { } [InvariantMaximum(4), InvariantMinimum(4)] public override Legs { get { return 4; } } } class Labrador : Dog { public override Legs { get { return 5; } } // compiler error } class Chihuahua: Dog { public override Legs { get { return 4; } } // OK } Edit (solution with sealed, a follow-up on this ) As requested in one of the threads, here's a little example that works with sealing off the further inheriting of a member (something many here considered a breach of OO, while the language designers clearly understood that it isn't): public abstract class Animal { public abstract int Legs {get;} } public class Dog : Animal { public sealed override int Legs {get { return 4; } } } public class Labrador : Dog { public override int Legs { get; } // compiler error }
