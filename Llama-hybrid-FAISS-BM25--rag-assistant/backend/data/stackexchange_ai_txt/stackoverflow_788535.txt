[site]: stackoverflow
[post_id]: 788535
[parent_id]: 
[tags]: 
Eric Lippert's challenge "comma-quibbling", best answer?

I wanted to bring this challenge to the attention of the stackoverflow community. The original problem and answers are here . BTW, if you did not follow it before, you should try to read Eric's blog, it is pure wisdom. Summary: Write a function that takes a non-null IEnumerable and returns a string with the following characteristics: If the sequence is empty the resulting string is "{}". If the sequence is a single item "ABC" then the resulting string is "{ABC}". If the sequence is the two item sequence "ABC", "DEF" then the resulting string is "{ABC and DEF}". If the sequence has more than two items, say, "ABC", "DEF", "G", "H" then the resulting string is "{ABC, DEF, G and H}". (Note: no Oxford comma!) As you can see even our very own Jon Skeet (yes, it is well known that he can be in two places at the same time ) has posted a solution but his (IMHO) is not the most elegant although probably you can not beat its performance. What do you think? There are pretty good options there. I really like one of the solutions that involves the select and aggregate methods (from Fernando Nicolet). Linq is very powerful and dedicating some time to challenges like this make you learn a lot. I twisted it a bit so it is a bit more performant and clear (by using Count and avoiding Reverse): public static string CommaQuibbling(IEnumerable items) { int last = items.Count() - 1; Func getSeparator = (i) => i == 0 ? string.Empty : (i == last ? " and " : ", "); string answer = string.Empty; return "{" + items.Select((s, i) => new { Index = i, Value = s }) .Aggregate(answer, (s, a) => s + getSeparator(a.Index) + a.Value) + "}"; }
