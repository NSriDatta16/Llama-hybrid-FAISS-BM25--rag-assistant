[site]: stackoverflow
[post_id]: 5570462
[parent_id]: 5504194
[tags]: 
I ended up going with a Server / Client setup, which is easier to manage. This way, there is only one Server PeerID, as opposed to a Server PeerID for every connection. I wasn't able to find many good examples, so I've included the basic GameKit Server / Client code here. // if the device in an ipad, treat it as a host / server if ([[[UIDevice currentDevice] model] isEqualToString:@"iPad"]) { isHost = YES; } else { isHost = NO; } // monitor if this device is connected to another device isConnected = NO; } #pragma mark GameKit Methods // Called when a change in the connection state is detected - (void)session:(GKSession *)session peer:(NSString *)peerID didChangeState:(GKPeerConnectionState)state { NSLog(@"Session:Peer:%@ Did Change State", peerID); Globals *globals = [Globals shareData]; switch (state) { case GKPeerStateConnected: NSLog(@"GKPeerStateConnected"); [globals.localSession setDataReceiveHandler:self withContext:nil]; // if this device is not the host and is not connected yet... if (!isHost && !isConnected) { // update variables, save the Server PeerId and the local Session so we can use them later isConnected = YES; serverSession = peerID]; localSession = session; } break; case GKPeerStateDisconnected: NSLog(@"GKPeerStateDisconnected"); break; case GKPeerStateAvailable: NSLog(@"GKPeerStateAvailable"); if (!isHost) { NSLog(@"Attempting to Connect..."); // the server is available, try to connect to it [session connectToPeer:peerID withTimeout:20]; } break; case GKPeerStateConnecting: NSLog(@"GKPeerStateConnecting"); break; case GKPeerStateUnavailable: NSLog(@"GKPeerStateUnavailable"); break; } } // Called if this device receives a request for a connection // This should only happen on the Server device -(void)session:(GKSession *)session didReceiveConnectionRequestFromPeer:(NSString *)peerID { NSLog(@"Received Connection Request From %@", peerID); // Accept the connection request from the peer [session acceptConnectionFromPeer:peerID error:nil]; } - (void)receiveData:(NSData *)data fromPeer:(NSString *)peer inSession:(GKSession *)session context:(void *)context { NSLog(@"Received Data"); } -(void)session:(GKSession *)session didFailWithError:(NSError *)error { NSLog(@"Session Failed: %@", error); } // Connected to a UIButton -(IBAction)sendData { NSLog(@"Sending Data ..."); } // Connected to a UIButton -(IBAction)beginConnection { Globals *globals = [Globals shareData]; // Set this up as a server if (isHost) { GKSession *session = [[GKSession alloc] initWithSessionID:@"" displayName:@"Server" sessionMode:GKSessionModeServer]; session.delegate = self; session.available = YES; NSLog(@"Setting Server Session Peer:%@", session.peerID); globals.localSession = session; } // or set it up as a client else { GKSession *session = [[GKSession alloc] initWithSessionID:@"" displayName:nil sessionMode:GKSessionModeClient]; session.delegate = self; session.available = YES; NSLog(@"Setting CLIENT Session Peer:%@", session.peerID); globals.localSession = session; } } ... Dealloc, etc... @end
