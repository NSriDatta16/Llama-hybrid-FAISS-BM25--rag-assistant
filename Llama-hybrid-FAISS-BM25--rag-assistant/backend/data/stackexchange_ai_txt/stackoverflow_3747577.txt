[site]: stackoverflow
[post_id]: 3747577
[parent_id]: 3719748
[tags]: 
If you don't mind a WPF approach, here is something to try. The following is a simple rescale method that accepts image streams and produces a byte[] containing the resulting JPEG data. Since you do not want to actually draw the images with GDI+, I thought this was suitable for you despite being WPF-based. (The only requirement is to reference WindowsBase and PresentationCore in your project.) Advantages include faster encoding (by 200-300% on my machine) and better parallel speedup, although I also see some unwanted serialization in the WPF rendering path. Let me know how this works for you. I'm sure it could be optimized further if necessary. The code: byte[] ResizeImage(Stream source) { BitmapFrame frame = BitmapFrame.Create(source, BitmapCreateOptions.IgnoreColorProfile, BitmapCacheOption.None); var newWidth = frame.PixelWidth >> 1; var newHeight = frame.PixelHeight >> 1; var rect = new Rect(new System.Windows.Size(newWidth, newHeight)); var drawingVisual = new DrawingVisual(); using (var drawingContext = drawingVisual.RenderOpen()) drawingContext.DrawImage(frame, rect); var resizedImage = new RenderTargetBitmap(newWidth, newHeight, 96.0, 96.0, PixelFormats.Default); resizedImage.Render(drawingVisual); frame = BitmapFrame.Create(resizedImage); using (var ms = new MemoryStream()) { var encoder = new JpegBitmapEncoder(); encoder.Frames.Add(frame); encoder.Save(ms); return ms.ToArray(); } }
