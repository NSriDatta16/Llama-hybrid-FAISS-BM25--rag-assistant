[site]: stackoverflow
[post_id]: 3057051
[parent_id]: 3055924
[tags]: 
Amardeep is right, system() on POSIX type systems runs the command through /bin/sh . I doubt you actually have a legitimate need to invoke these programs you speak of through a Bourne shell. A good reason would be if you needed them to have the default set of environment variables, but since /etc/profile is probably also unavailable so early in the boot process, I don't see how that can be the case here. Instead, use the standard fork()/exec() pattern: int system_alternative(const char* pgm, char *const argv[]) { pid_t pid = fork(); if (pid > 0) { // We're the parent, so wait for child to finish int status; waitpid(pid, &status, 0); return status; } else if (pid == 0) { // We're the child, so run the specified program. Our exit status will // be that of the child program unless the execv() syscall fails. return execv(pgm, argv); } else { // Something horrible happened, like system out of memory return -1; } } If you need to read stdout from the called process or send data to its stdin, you'll need to do some standard handle redirection via pipe() or dup2() in there. You can learn all about this sort of thing in any good Unix programming book. I recommend Advanced Programming in the UNIX Environment by W. Richard Stevens. The second edition coauthored by Rago adds material to cover platforms that appeared since Stevens wrote the first edition, like Linux and OS X, but basics like this haven't changed since the original edition.
