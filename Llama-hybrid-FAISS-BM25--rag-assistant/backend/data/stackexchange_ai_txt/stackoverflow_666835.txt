[site]: stackoverflow
[post_id]: 666835
[parent_id]: 666799
[tags]: 
I wasn't aware this is possible - I'd guess that the CLR needs to extract the embedded native DLL somewhere (Windows needs to have a file for the DLL to load it - it cannot load an image from raw memory), and wherever it's trying to do that the process does not have permission. Something like Process Monitor from SysInternals might give you a clue if the pronblem is that creating the DLL file is failing... Update: Ah... now that I've been able to read Suzanne Cook's article (the page didn't come up for me before), note that she is not talking about embedding the native DLL as a resource inside the managed DLL, but rather as a linked resource - the native DLL still needs to be its own file in the file system. See http://msdn.microsoft.com/en-us/library/xawyf94k.aspx , where it says: The resource file is not added to the output file. This differs from the /resource option which does embed a resource file in the output file. What this seems to do is add metadata to the assembly that causes the native DLL to logically be part of the assembly (even though it's physically a separate file). So things like putting the managed assembly into the GAC will automatically include the native DLL, etc.
