[site]: stackoverflow
[post_id]: 4329830
[parent_id]: 4329777
[tags]: 
C++ uses the limits defined in the C standard (C++: 18.3.2 (c.limits), C: 5.2.4.2.1): LONG_MIN -2147483647 // -(2^31 - 1) LONG_MAX +2147483647 // 2^31 - 1 So you are guaranteed that a long is at least 32 bits. And if you want to follow the long circuitous route to whether LONG_MIN / LONG_MAX are representable by a long , you have to look at 18.3.1.2 (numeric.limits.members) in the C++ standard: static constexpr T min() throw(); // Equivalent to CHAR_MIN, SHRT_MIN, FLT_MIN, DBL_MIN, etc. static constexpr T max() throw(); // Equivalent to CHAR_MAX, SHRT_MAX, FLT_MAX, DBL_MAX, etc. I moved the footnotes into the comment, so it's not exactly what appears in the standard. But it basically implies that std::numeric_limits ::min()==LONG_MIN==(long)LONG_MIN and std::numeric_limits ::max()==LONG_MAX==(long)LONG_MAX . So, even though the C++ standard does not specify the bitwise representation of (signed) negative numbers, it has to either be twos-complement and require 32-bits of storage in total, or it has an explicit sign bit which means that it has 32-bits of storage also.
