[site]: stackoverflow
[post_id]: 5671079
[parent_id]: 2800369
[tags]: 
As no one has provided a satisfactory answer, the correct answer seems to be "for no good reason". polygenelubricants provided a good overview of bad things happening with the java array covariance, which is a terrible feature by itself. Consider the following code fragment: String[] strings = new String[1]; Object[] objects = strings; objects[0] = 0; This obviously wrong code compiles without resorting to any "super" construct, so array covariance should not be used as an argument. Now, here I have a perfectly valid example of code requiring super in the named type parameter: class Nullable { private A value; // Does not compile!! public B withDefault(B defaultValue) { return value == null ? defaultValue : value; } } Potentially supporting some nice usage: Nullable intOrNull = ...; Integer i = intOrNull.withDefault(8); Number n = intOrNull.withDefault(3.5); Object o = intOrNull.withDefault("What's so bad about a String here?"); The latter code fragment does not compile if I remove the B altogether, so B is indeed needed. Note that the feature I'm trying to implement is easily obtained if I invert the order of type parameter declarations, thus changing the super constraint to extends . However, this is only possible if I rewrite the method as a static one: // This one actually works and I use it. public static B withDefault(Nullable nullable, B defaultValue) { ... } The point is that this Java language restriction is indeed restricting some otherwise possible useful features and may require ugly workarounds. I wonder what would happen if we needed withDefault to be virtual. Now, to correlate with what polygenelubricants said, we use B here not to restrict the type of object passed as defaultValue (see the String used in the example), but rather to restrict the caller expectations about the object we return. As a simple rule, you use extends with the types you demand and super with the types you provide.
