[site]: stackoverflow
[post_id]: 2415231
[parent_id]: 2414093
[tags]: 
Alright, so I've looked at this for most of the night now (surprise!) and I've debugged it down to a line in vendor/rails/actionpack/lib/action_controller/caching/actions.rb ...on line 127 starts a method as follows: def cache_layout? @options[:layout] == false end My line: caches_action :index, :expires_in => 6.hours, :cache_path => Proc.new {|controller| controller.send(:generate_cache_path) }, :layout => false This, to me, would indicate that we don't want to cache the layout, only the action. But by checking @options[:layout] == false, then when layout is set to false, the method itself will return true, saying that you should cache the layout. That seems like a bug to me. For now, I've just changed my layout line to :layout => true, and it seems to work, but that's obviously counter-intuitive. For reference, the cache_layout? method gets called here: def after(controller) return if controller.rendered_action_cache || !caching_allowed(controller) action_content = cache_layout? ? content_for_layout(controller) : controller.response.body controller.write_fragment(controller.action_cache_path.path, action_content, @options[:store_options]) end It also forces :layout => true into the render call for whatever action.call you're going to run from the controller, which is honestly not what I want to have happen if I have to set it to :layout => true just to get cache_layout? to return false. Just what I've come up with so far.
