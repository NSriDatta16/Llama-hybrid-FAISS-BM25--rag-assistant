[site]: stackoverflow
[post_id]: 871128
[parent_id]: 870715
[tags]: 
A few things. (1) Jon is of course correct; the issue is that nesting iterators like this gives you a call stack of iterator logic. If you are iterating a deep recursively defined data structure, this can blow the stack, and there are easy ways to turn what ought to be a linear algorithm into a quadratic algorithm. See Wes's article for more details. (2) We could build a new kind of iterator logic into the language that did not have the performance problem. I would love to implement this but it is not a high enough priority right now. If you're interested in the technical details of how to do so, read this paper . (3) There are many corner cases; the ones already alluded to (deferred execution of bounds checks and deferred execution of finally blocks) are the two most common. Unfortunately, in many versions of C# there are bugs in the code generator that exacerbate the latter problem. Suppose you have try { try { ... yield ... } finally { X() } } finally { Y() } -- there are weird situations you can get into where the code we generate accidentally calls Y() before X() on the cleanup path, which is clearly wrong. We've fixed those for the service pack, but if you find others, please let me know. (4) There are also some extant extremely obscure bugs involving the exact behaviour of the iterator when doing crazy things like a yield break out of a finally which then branches to an outer finally which does a second, redundant yield break. Again, if you happen to find bizarre-behaving iterators, feel free to bring them to my attention.
