[site]: stackoverflow
[post_id]: 450178
[parent_id]: 424927
[tags]: 
Never thought I'd see myself being quoted in a question. I pondered this question myself for some time, and made a rather pragmatic decision for my code base: In my code base, the ViewModel is getting called when actions happen, and I wanted it to stay this way. Additionally I do not want the ViewModel to control the views. What did I do? I added a controller for navigation: public interface INavigation { void NewContent(ViewModel viewmodel); void NewWindow(ViewModel viewmodel); } This controller does contain two actions: NewContent() does show new content in the current window, NewWindow() creates a new Window, populates it with the content and shows it. Of course my viewmodels have no clue which view to show. But they do know which viewmodel they want to show, so according to your example when DeleteCommand is executed, it would call the navigation service function NewWindow(new ValidateCustomerDeletedViewModel()) to show a window stating 'the customer has been deleted' (overkill for this simple messagebox, but it would be easy to have a special navigator function for simple messageboxes). How does the viewmodel get the navigation service? My viewmodel class has a property for the navigation controller: public class ViewModel { public INavigation Navigator { get; set; } [...] } When a viewmodel is attached to a window (or whatever displays the view), the window will set the Navigator property, so the viewmodel can call it. How does the navigator create the view to the viewmodel? You could have a simple list which view to create for which viewmodel, in my case I can use simple reflection since the names are matching: public static FrameworkElement CreateView(ViewModel viewmodel) { Type vmt = viewmodel.GetType(); // big bad dirty hack to get the name of the view, but it works *cough* Type vt = Type.GetType(vmt.AssemblyQualifiedName.Replace("ViewModel, ", "View, ")); return (FrameworkElement)Activator.CreateInstance(vt, viewmodel); } Of course the view needs a constructor accepting the viewmodel as parameter: public partial class ValidateCustomerDeletedView : UserControl { public ValidateCustomerDeletedView(ValidateCustomerDeletedViewModel dac) { InitializeComponent(); this.DataContext = dac; } } How does my window look like? Simple: my main window does implement the INavigation interface, and shows a start page on creation. See for yourself: public partial class MainWindow : Window, INavigation { public MainWindow() { InitializeComponent(); NewContent(new StartPageViewModel()); } public MainWindow(ViewModel newcontrol) { InitializeComponent(); NewContent(newcontrol); } #region INavigation Member public void NewContent(ViewModel newviewmodel) { newviewmodel.Navigator = this; FrameworkElement ui = App.CreateView(newviewmodel); this.Content = ui; this.DataContext = ui.DataContext; } public void NewWindow(ViewModel viewModel) { MainWindow newwindow = new MainWindow(viewModel); newwindow.Show(); } #endregion } (This does work equally well with a NavigationWindow and wrapping the view into a Page) Of course this is testable, since the navigation controller can be mocked easily. I'm not really sure if this is a perfect solution, but it works nicely for me right now. Any ideas and comments are welcome!
