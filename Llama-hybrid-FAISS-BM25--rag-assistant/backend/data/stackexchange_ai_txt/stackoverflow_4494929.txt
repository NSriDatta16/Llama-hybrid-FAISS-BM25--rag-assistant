[site]: stackoverflow
[post_id]: 4494929
[parent_id]: 
[tags]: 
Entity Framework: reload all child entities from query based on child entity attributes

Is there a way to elegantly load all child entities of an EF entity if the entity instance was loaded as the result of a query on child entity attributes? Here is a simple example of what I'm asking: First, some simple data tables: CREATE TABLE Invoices ( InvoiceID int IDENTITY(1000,1) NOT NULL, Customer nvarchar(50) NOT NULL, InvoiceDate datetime NOT NULL, CONSTRAINT PK_Invoices PRIMARY KEY (InvoiceID) ) CREATE TABLE InvoiceItems ( InvoiceItemID int IDENTITY(1,10) NOT NULL, InvoiceFK int NOT NULL, PurchasedItem varchar(24) NULL, Quantity decimal(10,2) NULL, ItemPrice money NULL, CONSTRAINT PK_InvoiceItems PRIMARY KEY (InvoiceItemID), CONSTRAINT FK_InvoiceItems_Invoice FOREIGN KEY (InvoiceFK) REFERENCES Invoices (InvoiceID) ) Now, what we want is to query the Invoice table based on a matching invoice item, but to then show all items for each selected invoice regardless of whether it matches the criteria: var qryOrders = from ordr in ctx.InvoiceItems .Include("Invoice") where ordr.PurchasedItem == "Buggy Whips" select ordr; foreach (var ordrItm in qryOrders) { Console.WriteLine("Order " + ordrItm.Invoice.InvoiceID + " contains buggy whips"); Console.WriteLine("Full contents of order:"); foreach (var itm in ordrItm.Invoice.InvoiceItems) { //this will only show the buggy whip item Console.WriteLine(itm.PurchasedItem); } } What I want is to show all order items in each order that contains "Buggy Whips", including items that are not buggy whips. If I were writing this in SQL, I would use a WHERE InvoiceID IN () clause with a subquery. My question is: can the Entity Framework make this happen in an elegant way? I've come up with some hacks that work, but nothing that feels right.
