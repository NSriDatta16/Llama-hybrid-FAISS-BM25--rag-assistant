[site]: stackoverflow
[post_id]: 2633642
[parent_id]: 2628118
[tags]: 
Here's a divide and conquer algorithm. AVERAGE case complexity is very good and I'd say it's something like O(n log MaxCoords) . Worst case could be quadratic though, however I think such a test would be pretty difficult to create. To make it even harder, make the order of the recursive function calls random. Maybe what @Larry suggested can get this to O(n log n) on average. I can't figure out a sweep line solution, but for the tests I've tried this is very fast. Basically, use a recursive function the works on the blue rectangle. First check if the blue rectangle is completely covered by one of the other rectangles. If yes, we're done. If not, split it into 4 quadrants, and recursively call the function on those quadrants. All 4 recursive calls must return true. I'm including some C# code that draws the rectangles. You can change it to work with larger values as well, but do remove the drawing procedures in that case, as those will take forever. I've tests it with a million rectangles and a square of side one billion generated such that it isn't covered, and the provided answer ( false ) took about a second on a quadcore. I've tested this on random data mostly, but it seems correct. If it turns out it isn't I'll just delete this, but maybe it'll get you on the right path. public partial class Form1 : Form { public Form1() { InitializeComponent(); } List Rects = new List (); private const int maxRects = 20; private void InitRects() { Random rand = new Random(); for (int i = 0; i
