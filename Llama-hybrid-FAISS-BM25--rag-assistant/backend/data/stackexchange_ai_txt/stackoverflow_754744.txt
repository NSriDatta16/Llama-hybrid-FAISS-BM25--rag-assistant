[site]: stackoverflow
[post_id]: 754744
[parent_id]: 754502
[tags]: 
One Possible Solution I found a workable solution, and ended up keeping the single button approach for now. I'll post my workaround here, but if anyone has a more elegant answer to my original question, don't hestitate to post it. My small epiphany After experimenting some more, it seems the issue of the button not getting repositioned properly on scrolling only happens when using the mouse wheel to scroll through the ListBox . Scrolling the "normal" way doesn't seem to reproduce the behavior, but as I couldn't be 100% sure, I included a fix for normal scrolling in my workaround as well. My ugly hack of a workaround Since I knew the mouse wheel (and scrolling in general) seemed to be at the heart of the issue, I decided to just invalidate my ListBox whenever the ListBox is scrolled or whenever the mouse wheel is moved. This does produce some unsightly flicker, which I would like to get rid of, but I can live with the results for now. I added the following methods to my derived EventListBox class: protected override void WndProc(ref Message m) { const int WM_VSCROLL = 277; if (m.Msg == WM_VSCROLL) { this.Invalidate(); } base.WndProc(ref m); } protected override void OnMouseWheel(MouseEventArgs e) { this.Invalidate(); base.OnMouseWheel(e); } I was a little surprised that ListBox doesn't inherit from ScrollableControl and there wasn't anything like an OnScroll method that I could override, so I did the scroll checking by overriding the WndProc method. The mouse wheel detection was simpler, since there was already an method available to override. Like I said, this is less than ideal as invalidating the listbox each time the list is scrolled causes flicker, and I suspect performance would degrade significantly when the listbox contains a lot of items. I won't accept this answer yet, as I'm curious to see if someone has a better solution.
