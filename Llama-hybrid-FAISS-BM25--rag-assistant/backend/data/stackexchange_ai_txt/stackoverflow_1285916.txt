[site]: stackoverflow
[post_id]: 1285916
[parent_id]: 1285468
[tags]: 
I think the actual timings are kind of interesting: Alex' answer: python -m timeit -s "l = range(1,1000,2) + range(1,1000,3); import collections" "d = collections.defaultdict(int)" "for x in l: d[x] += 1" "l[:] = [x for x in l if d[x] == 1]" 1000 loops, best of 3: 370 usec per loop Mine: python -m timeit -s "l = range(1,1000,2) + range(1,1000,3)" "once = set()" "more = set()" "for x in l:" " if x not in more:" " if x in once:" " more.add(x)" " once.remove( x )" " else:" " once.add( x )" 1000 loops, best of 3: 275 usec per loop sepp2k's O(n**2) version, to demonstrate why compexity matters ;-) python -m timeit -s "l = range(1,1000,2) + range(1,1000,3)" "[x for x in l if l.count(x)==1]" 100 loops, best of 3: 16 msec per loop Roberto's + sorted: python -m timeit -s "l = range(1,1000,2) + range(1,1000,3); import itertools" "[elem[0] for elem in itertools.groupby(sorted(l)) if elem[1].next()== 0]" 1000 loops, best of 3: 316 usec per loop mhawke's: python -m timeit -s "l = range(1,1000,2) + range(1,1000,3)" "d = {}" "for i in l: d[i] = d.has_key(i)" "[k for k in d.keys() if not d[k]]" 1000 loops, best of 3: 251 usec per loop I like the last, clever and fast ;-)
