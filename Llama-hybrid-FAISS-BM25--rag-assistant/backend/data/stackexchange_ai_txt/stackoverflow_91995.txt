[site]: stackoverflow
[post_id]: 91995
[parent_id]: 91127
[tags]: 
I use the TreeNode.Tag property to store small "controller" objects that makes up the logic. E.g.: class TreeNodeController { Entity data; virtual bool IsReadOnly { get; } virtual bool CanDrop(TreeNodeController source, DragDropEffects effect); virtual bool CanDrop(DataInfoObject info, DragDropEffects effect); virtual bool CanRename(); } class ParentNodeController : TreeNodeController { override bool IsReadOnly { get { return data.IsReadOnly; } } override bool CanDrop(TreeNodeController source, DragDropEffect effect) { return !IsReadOnly && !data.IsChildOf(source.data) && effect == DragDropEffect.Move; } virtual bool CanDrop(DataInfoObject info, DragDropEffects effect) { return info.DragDataCollection != null; } override bool CanRename() { return !data.IsReadOnly && data.HasName; } } class LeafNodeController : TreeNodeController { override bool CanDrop(TreeNodeController source, DragDropEffect effect) { return false; } } Then my CanDrop would be something like: bool CanDrop(DragDropEventArgs args) { Point point = tree.PointToClient(new Point(e.X, e.Y)); TreeNode target = tree.GetNodeAt(point); TreeNodeController targetController = target.Tag as TreeNodeController; DataInfoObject info = args.GetData(typeof(DataInfoObject)) as DataInfoObject; TreeNodeController sourceController = args.GetData(typeof(TreeNodeController)) as TreeNodeController; if (info != null) return targetController.CanDrop(info, e.Effect); if (sourceController != null) return targetController.CanDrop(sourceController, e.Effect); return false; } Now for each class of objects that I add to the tree I can specialize the behaviour by choosing which TreeNodeController to put in the Tag object.
