[site]: stackoverflow
[post_id]: 3837719
[parent_id]: 3793582
[tags]: 
Making folderList field public is the worst case. Exposing implementation details through public fields or through poorly designed public property (there are no differences for collections between public fields and public property with getter and setter). With public fields you can't promote a field to be a property when you want to add validation, change notification, put it into an interface or change your collection type from one type to another. BTW, Jeffrey Richter in annotation to Framework Design Guideline mentioned that "Personally, I always make my fields private. I don't even expose fields as internal , because doing so would give me no protection from code in my own assembly" I think the best way to add explicit interface that expose strict abstraction to MyClass clients. For example, you may add two separate methods to retrieving folders and to adding new folder to this storage: class MyClass { //You should return IList public IList MyList {get {return myList;} } //Or even IEnumerable , because you should return //as minimal interface as your clients needs public IEnumerable MyList {get {return myList;} } //You may expose this functionality through internal //method, or through protected internal method, //but you should avoid direct access to your implementation //even for descendants or another classes in your assembly public void AddElement(string s) {myList.Add(s);} private List myList; }
