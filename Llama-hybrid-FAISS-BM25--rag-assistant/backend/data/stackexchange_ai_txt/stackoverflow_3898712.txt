[site]: stackoverflow
[post_id]: 3898712
[parent_id]: 3895840
[tags]: 
The issue of xvalue safety can be worked around somewhat by providing an alternative for use inside expressions. The issues are completely different, now we don't want an xvalue result and can use a function: template T &var_or_dummy( bool modify, T &var, T &&dummy = T() ) { if ( modify ) return var; else return dummy = var; } maybe_get_result( arg, var_or_dummy( want_it, var ) ); Now the type has to be default-constructible, and the dummy is always constructed. The copy is conditionally evaluated. I don't think I'd really want to deal with code that did too much of this. Boost Optional can help a bit; it only requires CopyConstructible T: template T &var_or_dummy( bool modify, T &var, boost::optional &&dummy = boost::optional () ) { if ( modify ) return var; else return dummy = var; } Optional is useful, but it has some overlap with C++0x unions. It's not too hard to reimplement. template struct optional_union { bool valid; union storage { T obj; // union of one non-POD member simply reserves storage storage() {} // uh, what could the constructor/destructor possibly do?? ~storage() {} } s; optional_union() : valid( false ) {} optional_union &operator=( T const &in ) { new( &s.obj ) T( in ); // precondition: ! valid valid = true; return *this; } ~optional_union() { if ( valid ) s.obj.~T(); } }; template T &var_or_dummy( bool modify, T &var, optional_union &&dummy = optional_union () ) { if ( modify ) return var; else return ( dummy = var ).s.obj; } The optional_union class is only sufficient for this applicationâ€¦ obviously it could be expanded a lot.
