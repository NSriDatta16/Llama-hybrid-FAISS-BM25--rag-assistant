[site]: stackoverflow
[post_id]: 1426767
[parent_id]: 
[tags]: 
Do unidirectional associations lead to non-required foreign key fields through NHibernate

Update Added mappings below Question summary I have a database with many required foreign key fields and a code base with many unidirectional associations. I want to use NHibernate, but as far as I can tell, I either have to make the foreign key fields in the database NULLable (not a realistic option) or change the associations to bidirectional (not ideal either). Any other options that I've missed? Backgrounds I've joined a project that uses NHibernate to map tables 1:1 to so-called "technical" objects. After data retrieval, the objects are mapped to the actual domain model (AutoMapper style,implemented differently). I know that this is an unnecessary step and I want to propose removing it to the team. However, I'm running into an issue. The domain model contains many unidirectional associations: the Case object has a list of Persons associated with the case, but the Persons do not hold a reference to the Case object. In the underlying database scheme, the Person table has a required foreign key field that references the case Id. The data model: [ERD] PERSON CASE Id* Ids are generated by the DB Id* The domain model looks like this: public class Person : DomainEntity { // DomainEntity implements Id. Non-essential members left out } public class Case : DomainEntity { public virtual IList Persons { get; set; } } Calling session.Save() on a Case leads to a database error (CaseId required when inserting into Person), because NHibernate starts with inserting the Person entries, followed by the Case entry and finishes by updating the CaseId column in the Person entries. If the CaseId column in the database is altered to non-required (allow NULLs), everything works as it should... however, that change is not an option at the moment (the database model is shared by several apps for at least another year). The only way I have found to get NHibernate to execute the database actions correctly is by changing the association to bidirectional, i.e., by changing Person to public class Person : DomainEntity { public virtual Case Case { get; set; } } This would involve significant changes to the existing codebase however, so I would prefer alternatives, if they exist. I've played around with component mappings, but that is a bad fit since most associations in our model are not actual (UML) compositions. Are there any other options that I've missed? TIA! EDIT The (Fluent) mapping for Case looks like this: public class CaseMapping : ClassMap { public CaseMapping() { Not.LazyLoad(); Id(c => c.Id).GeneratedBy.Identity(); Map(x => x.Code).Not.Nullable().Length(20); Map(x => x.Name).Not.Nullable().Length(100); HasMany (x => x.Persons) .AsBag() .KeyColumn("CaseId") .ForeignKeyConstraintName("FK_Person_Case") .Cascade.AllDeleteOrphan(); } } If I use SessionSource.BuildSchema for a test database, this generates a Person table with a nullable CaseId column. I have not found a way for this to work with a non-nullable CaseId field without bidirectional associations. The executed (pseudo) SQL statements: INSERT INTO Case ... select @@identity INSERT INTO Person /* (all columns except CaseId) */ select @@identity UPDATE Person SET CaseId = ? WHERE Id = ?;@p0 = 2, @p1 = 1
