[site]: stackoverflow
[post_id]: 4403408
[parent_id]: 4235721
[tags]: 
I'm assuming you're using the lock-free single-producer single-consumer queue from the Dr Dobbs article - or something similar - so I'll use the terminology from there. In that case, your suggested answer in the paragraph that starts "AFAICT" is good, but I think it can be optimised slightly: In the consumer - as you say, when the consumer has exhausted the queue and is considering sleeping (and only then), it locks the mutex, checks the queue again, and then either releases the mutex and carries on working, if there was a new item in the queue or blocks on the condition variable (releasing the mutex when it awakes to find a non-empty queue, naturally). In the producer: First take a copy of last , call it saved_last Add the item new_item as usual, then take a copy of the divider pointer, call it saved_divider . If the value of saved_divider is equal to new_item , the object you just inserted, then your object has already been consumed, and your work is done. Otherwise, if the value of saved_divider is not equal to saved_last , then you don't need to wake up the consumer. This is because: At a time strictly after you added your new object, you know that divider had not yet reached either new_item or saved_last Since you started the insertion, last has only had those two values The consumer only ever stops when divider is equal to last Therefore the consumer must still be awake and will reach your new item before sleeping. Otherwise lock the mutex, signal the condvar then release the mutex. (Obtaining the mutex here ensures you don't signal the condar in the time between the consumer noticing the queue is empty, and actually blocking on the condvar.) This ensures that, in the case where the consumer tends to remain busy, you avoid locking the mutex when you know the consumer is still awake (and not about to sleep). It also minimises the time when the mutex is held, to further reduce the possibility for contention. The above explanation is quite wordy (because I wanted to include the explanation of why it works, rather than just what the algorithm is), but the code resulting from it should be quite simple. Of course whether it's actually worth doing will depend on a lot of things, and I'd encourage you to measure if performance is critical for you. Good implementations of the mutex/condvar primitives internally use atomic operations for most cases, so they generally only make a kernel call (the most expensive bit!) if there's a need to - i.e. if there's a need to block, or there are definitely some threads waiting - so the time saved by not calling the mutex functions may only amount to the overhead of the library calls.
