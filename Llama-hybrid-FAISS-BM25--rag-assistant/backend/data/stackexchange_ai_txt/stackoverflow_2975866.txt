[site]: stackoverflow
[post_id]: 2975866
[parent_id]: 2934126
[tags]: 
Of course. The ".ascii" directive is none but a .byte directive focused on the storage of ASCII text .ascii "PP" is like .byte 80,80 You can use .space to make room for your ASCII string, and then use the buffer in the convertion from integer to ASCII, if you mean this by "sw into .ascii directive" of in integer. The following code converts the "binary number" into a ASCII string using itoa and prints it (just for testing) with print_string. The function uses a buffer and returns the pointer to the first ASCII digit usable for printing. This could be used as a first helper function for a sprintf-like function implementation. .data buffer: .space 32 .text # the main supposes env. like spim or MARS main: li $a0, 1234 # a number jal itoa move $a0, $v0 li $v0, 4 # print_string syscall li $v0, 10 syscall # exit itoa: la $t0, buffer+30 # pointer to almost-end of buffer sb $0, 1($t0) # null-terminated str li $t1, '0' sb $t1, ($t0) # init. with ascii 0 li $t3, 10 # preload 10 slt $t2, $a0, $0 # keep the sign beq $a0, $0, iend # end if 0 bgtz $a0, loop neg $a0, $a0 # absolute value (unsigned) loop: div $a0, $t3 # a /= 10 mflo $a0 mfhi $t4 # get remainder add $t4, $t4, $t1 # convert to ASCII digit sb $t4, ($t0) # store it subu $t0, $t0, 1 # dec. buf ptr bne $a0, $0, loop # if not zero, loop addiu $t0, $t0, 1 # adjust buf ptr iend: beq $t2, $0, nolz # was After you have $v0 in the main, lb R, ($v0) picks "1", lb R, 1($v0) picks second digit (2) and so on; remember the string is null-terminated, so if you pick 0 (numeric), you have to stop
