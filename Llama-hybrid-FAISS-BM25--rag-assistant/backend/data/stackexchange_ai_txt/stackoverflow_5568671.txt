[site]: stackoverflow
[post_id]: 5568671
[parent_id]: 5567754
[tags]: 
As far as I know there are no good ways to solve this problem except for the following trick with native SQL query (exact SQL syntax depends on your DBMS): List result = s.createSQLQuery( "select {m.*}, {k.*} " + "from (select limit :firstResult :maxResults * from Mother m) m " + "left join Kitten k on k.motherId = m.id" ) .addEntity("m", Mother.class) .addJoin("k", "m.kittens") .setParameter("firstResult", ...) .setParameter("maxResults", ...) .setResultTransformer(MyDistrictRootEntityResultTransformer.INSTANCE) .list(); ... // Unfortunately built-in DistrictRootEntityResultTransformer cannot be used // here, since it assumes that root entity is the last in the tuple, whereas // with addEntity()/addJoin() it's the first in the tuple public class MyDistrictRootEntityResultTransformer implements ResultTransformer { public static final MyDistrictRootEntityResultTransformer INSTANCE = new MyDistrictRootEntityResultTransformer(); public Object transformTuple(Object[] tuple, String[] aliases) { return tuple[0]; } public List transformList(List collection) { return DistinctResultTransformer.INSTANCE.transformList(collection); } }
