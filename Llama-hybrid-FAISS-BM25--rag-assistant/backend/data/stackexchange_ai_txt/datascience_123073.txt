[site]: datascience
[post_id]: 123073
[parent_id]: 
[tags]: 
Perform k-means clustering over multiple columns using python but without library sklearn.kmeans

I'm on a project with the topic "clustering" using the KMeans method. so I have a data set with 10 columns and 1000 rows divided into 5 clusters (in this case there are 5 robot movements). I'm still new to this topic, so any help is greatly appreciated. I have tried to write a program in Python, but it doesn't use kmeans library. i am getting the centroid result, but not sure if the result is correct or not. and I also don't know how to do it if there is new data that will be predicted to enter which cluster this is the process of reading data from csv and then converting it into an array # Read data csv and convert to data mind = pd.read_csv(r'C:\Users\asus\Documents\AIOMotion_9samples.csv', header=None) mind.columns = ['Delta','Theta','Low Alpha','High Alpha','Low Beta','High Beta','Low Gamma','Mid Gamma','Attention','Meditation','Motion'] mind_list = mind.to_numpy().tolist() # Spread into each movement mind_array = [[],[],[],[],[]] for i in mind_list : if i[len(i)-1] == "Move Forward": i.pop() mind_array[0].append(i) elif i[len(i)-1] == "Move Backward": i.pop() mind_array[1].append(i) elif i[len(i)-1] == "Move right": i.pop() mind_array[2].append(i) elif i[len(i)-1] == "Move left": i.pop() mind_array[3].append(i) elif i[len(i)-1] == "Stop": i.pop() mind_array[4].append(i) Y = np.array(list(zip(mind_array[0],mind_array[1],mind_array[2],mind_array[3],mind_array[4]))) print('data:', Y) then I look for the median as the initial centroid # Find Median centroid = [[],[],[],[],[]] for G in range(0, len(mind_array)): if G == 0: # param0 = min( P for P in mind_array[0],key=itemgetter(1)) for S in range(0, len(mind_array[0][0])): param0 = median(P[S] for P in mind_array[0]) #minim = [min(abcdefghij) for abcdefghij in zip(*mind_array)] centroid[0].append(param0) last thing i was looking for a new centroid # To store the value of centroids when it updates D_old = np.zeros(D.shape) print('\nD-old: ', D_old ) # Cluster Lables(0, 1, 2) clusters = np.zeros(len(Y)) print('\ncluster: ', clusters) # Error func. - Distance between new centroids and old centroids error = dist(D, D_old, None) print('\nerror: ', error, '\n') # Loop will run till the error becomes zero while error != 0: # Assigning each value to its closest cluster for i in range(len(Y)): distances = dist(Y[i], D) my_cluster = np.argmin(distances) clusters[i] = my_cluster # Storing the old centroid values C_old = deepcopy(C) # Finding the new centroids by taking the average value for i in range(5): points = [Y[j] for j in range(len(Y)) if clusters[j] == i] D[i] = np.mean(points, axis=None) print('new centroid-',i,':', np.round(D[i])) error = dist(C, C_old, None) print('\nerror:', error) this is the result that i got so I don't know how to group 'Y' data and new data to be inputted later to enter which cluster. i'm so sorry with my bad post, this is the first time to me.
