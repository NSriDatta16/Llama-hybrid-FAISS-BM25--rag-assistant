[site]: stackoverflow
[post_id]: 3811402
[parent_id]: 
[tags]: 
Bestpractices: StructureMap and ASP.NET MVC 2 - Setter Injection/Contructur Injection in an abstract base Controller

public abstract class ConventionController : Controller { public const int PageSize = 5; public IMappingService MappingService { get; set;} } How do I set up StructureMap to get the Instance of IMappingService? Edit: With the help of Joshua Flanagan I now have the following code: EmployeeController public class EmployeeController : ConventionController { private readonly ITeamEmployeeRepository _teamEmployeeRepository; public EmployeeController(ITeamEmployeeRepository teamEmployeeRepository) { _teamEmployeeRepository = teamEmployeeRepository; } public ActionResult Index(int page = 1) { // The IMappingService dependency is hidden in the AutoMappedHybridView method that is a part of the ConventionController, easy use in the controller return AutoMappedHybridView (_teamEmployeeRepository.GetPagedEmployees(page, PageSize)); // With constructor injection I had to write this ... // return new HybridViewResult (_mappingService, _teamEmployeeRepository.GetPagedEmployees(page, PageSize)); } } ConventionController public abstract class ConventionController : Controller { public const int PageSize = 5; // This property is inject via StructureMap public IMappingService MappingService { get; private set; } public HybridViewResult AutoMappedHybridView (PagedList pagedList, string viewNameForAjaxRequest) { return new HybridViewResult (MappingService, pagedList, viewNameForAjaxRequest); } public HybridViewResult AutoMappedHybridView (PagedList pagedList) { return new HybridViewResult (MappingService, pagedList); } public HybridViewResult AutoMappedHybridView (TSourceElement sourceElement) { return new HybridViewResult (MappingService, sourceElement); } public HybridViewResult AutoMappedHybridView (TSourceElement sourceElement, string viewNameForAjaxRequest) { return new HybridViewResult (MappingService, sourceElement, viewNameForAjaxRequest); } } HybridViewResult public class HybridViewResult : BaseHybridViewResult { public HybridViewResult(IMappingService mappingService, PagedList pagedList) { ViewModel = mappingService.MapToViewModelPagedList (pagedList); } public HybridViewResult(IMappingService mappingService, PagedList pagedList, string viewNameForAjaxRequest) { ViewNameForAjaxRequest = viewNameForAjaxRequest; ViewModel = mappingService.MapToViewModelPagedList (pagedList); } public HybridViewResult(IMappingService mappingService, TSourceElement model) { ViewModel = mappingService.Map (model); } public HybridViewResult(IMappingService mappingService, TSourceElement model, string viewNameForAjaxRequest) { ViewNameForAjaxRequest = viewNameForAjaxRequest; ViewModel = mappingService.Map (model); } } As you can see the HybridViewResult needs the IMappingService dependency. If I would use a constructur in the ConventionController I would "pollute" my EmployeeController (imho). If EmployeeController would directly need the IMapping dependency I would use the constructor for injecting. But this would not be necessary, because there is already the IMapping property of the ConventionController. So as Darin Dimitrov said, this would violate the DI principle. How do I refactor my code? Do I really have to use constructor injection? Edit 2 How could I order StructureMap to create an instance of the HybridViewResult? If this would be possible the controllers would not need to know about a IMapping dependency. Is it at all possible to get an generic object (not boxed) from StructureMap?
