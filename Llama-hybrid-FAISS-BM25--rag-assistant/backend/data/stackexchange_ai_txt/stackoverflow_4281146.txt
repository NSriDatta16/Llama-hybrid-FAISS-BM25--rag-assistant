[site]: stackoverflow
[post_id]: 4281146
[parent_id]: 
[tags]: 
C++ Memory Access Violation While Setting a Object Property

Having trouble getting one portion of my code to work. Building a rudimentary linked list to learn pointers. I think I have most of it down, but any attempts to use a function I created (push_back) throws memory access errors on setting a value for a pointer. Not exactly sure what's wrong, because it works fine to use push_front, which work almost exactly the same. Any ideas? =/ CODE: driver.cpp #include #include #include "linklist.h" #include "node.h" using namespace std; // printList function // Purpose: Prints each node in a list // Returns: None. // Pre-Conditions: List must have member nodes. // Post-Conditions: None. void printList(linklist); int main() { linklist grocery; grocery.push_front(new node("milk", "1 gallon")); grocery.push_front(new node("bread","2 loaves")); grocery.push_front(new node("eggs","1 dozen")); grocery.push_front(new node("bacon","1 package")); cout getDescription() getQuantity() getDescription() getNextNode(); } } node.h #pragma once #include using namespace std; class node { public: // Default Constructor // Values, "none", "none", NULL. node(); // Parameterized Constructor // nextNode initialized NULL and must be explicitly set. node(string descriptionInput, string quantityInput); // getDescription function // Purpose: Returns node description. // Returns: string // Pre-Conditions: None. // Post-Conditions: None. string getDescription(); // setDescription function // Purpose: Sets node description // Returns: Void // Pre-Conditions: None // Post-Conditions: None void setDescription(string); // getQuantity function // Purpose: Returns node quantity. // Returns: string // Pre-Conditions: None. // Post-Conditions: None. string getQuantity(); // setQuantity function // Purpose: Sets node quantity // Returns: Void // Pre-Conditions: None // Post-Conditions: None void setQuantity(string); // getNextNode function // Purpose: Returns pointer to next node in list sequence. // Returns: node pointer // Pre-Conditions: None. // Post-Conditions: None. // Note: Not set during initialization. Must be explicitly done. node* getNextNode(); // setNextNode function // Purpose: Sets pointer to next node in list sequence. // Returns: None. // Pre-Conditions: None. // Post-Conditions: None. // Note: Not set during initialization. Must be explicitly done. void setNextNode(node*); private: string description; string quantity; node* nextNode; }; node.cpp #include "node.h" node::node() :description("none"), quantity("none"), nextNode(NULL) {} node::node(string descriptionInput, string quantityInput) :description(descriptionInput), quantity(quantityInput), nextNode(NULL) {} string node::getDescription() { return description; } void node::setDescription(string descriptionInput) { description = descriptionInput; } string node::getQuantity() { return quantity; } void node::setQuantity(string quantityInput) { quantity = quantityInput; } node* node::getNextNode() { return nextNode; } void node::setNextNode(node* input) { nextNode = input; } linklist.h #pragma once #include "node.h" class linklist { public: // Constructor // Builds an empty list linklist(); // push_front function // Purpose: Takes node pointer. Places that node at beginning of list. // Returns: None // Pre-Conditions: None // Post-Conditions: None void push_front(node*); // pop_front function // Purpose: Removes first node from list. // Returns: Node pointer. NODE IS NOT DESTROYED. // Pre-Conditions: List must have a node to remove. // Post-Conditions: Node is not destroyed. node* pop_front(); // getFirst function // Purpose: Returns node pointer to first node in list // Returns: node pointer // Pre-Conditions: List must have a node added. // Post-Conditions: None. node* getFirst(); // push_back function // Purpose: Takes node pointer. Places that node at end of list. // Returns: None // Pre-Conditions: None // Post-Conditions: None void push_back(node*); // pop_back function // Purpose: Removes last node from list. // Returns: Node pointer. NODE IS NOT DESTROYED. // Pre-Conditions: List must have a node to remove. // Post-Conditions: Node is not destroyed. node* pop_back(); // getNodeCount function // Purpose: Returns nodeCount // Returns: int // Pre-Conditions: None. // Post-Conditions: None. int getNodeCount(); private: node* firstNode; node* lastNode; int nodeCount; }; linklist.cpp #include "linklist.h" linklist::linklist() :firstNode(NULL), lastNode(NULL), nodeCount(0) {} void linklist::push_front(node* input) { node* temp = getFirst(); input->setNextNode(temp); firstNode = input; nodeCount++; } node* linklist::pop_front() { node* temp = getFirst(); firstNode = temp->getNextNode(); nodeCount--; return temp; } node* linklist::getFirst() { return firstNode; } void linklist::push_back(node* input) { node* temp = lastNode; temp->setNextNode(input); lastNode = temp; nodeCount++; } node* linklist::pop_back() { node* oldLast = lastNode; node* temp = firstNode; // find second to last node, remove it's pointer for (int i = 0; i getNextNode(); } temp->setNextNode(NULL); lastNode = temp; nodeCount--; return oldLast; } int linklist::getNodeCount() { return nodeCount; }
