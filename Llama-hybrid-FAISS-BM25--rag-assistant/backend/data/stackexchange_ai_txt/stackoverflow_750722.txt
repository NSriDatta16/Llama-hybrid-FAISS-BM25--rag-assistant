[site]: stackoverflow
[post_id]: 750722
[parent_id]: 746082
[tags]: 
Not interested in VB? :) I couldn't resist. I've solved this differently than many of the solutions presented here. My times are: Loading the dictionary and word prefixes into a hashtable: .5 to 1 seconds. Finding the words: averaging under 10 milliseconds. EDIT: Dictionary load times on the web host server are running about 1 to 1.5 seconds longer than my home computer. I don't know how badly the times will deteriorate with a load on the server. I wrote my solution as a web page in .Net. myvrad.com/boggle I'm using the dictionary referenced in the original question. Letters are not reused in a word. Only words 3 characters or longer are found. I'm using a hashtable of all unique word prefixes and words instead of a trie. I didn't know about trie's so I learned something there. The idea of creating a list of prefixes of words in addition to the complete words is what finally got my times down to a respectable number. Read the code comments for additional details. Here's the code: Imports System.Collections.Generic Imports System.IO Partial Class boggle_Default 'Bob Archer, 4/15/2009 'To avoid using a 2 dimensional array in VB I'm not using typical X,Y 'coordinate iteration to find paths. ' 'I have locked the code into a 4 by 4 grid laid out like so: ' abcd ' efgh ' ijkl ' mnop ' 'To find paths the code starts with a letter from a to p then 'explores the paths available around it. If a neighboring letter 'already exists in the path then we don't go there. ' 'Neighboring letters (grid points) are hard coded into 'a Generic.Dictionary below. 'Paths is a list of only valid Paths found. 'If a word prefix or word is not found the path is not 'added and extending that path is terminated. Dim Paths As New Generic.List(Of String) 'NeighborsOf. The keys are the letters a to p. 'The value is a string of letters representing neighboring letters. 'The string of neighboring letters is split and iterated later. Dim NeigborsOf As New Generic.Dictionary(Of String, String) 'BoggleLetters. The keys are mapped to the lettered grid of a to p. 'The values are what the user inputs on the page. Dim BoggleLetters As New Generic.Dictionary(Of String, String) 'Used to store last postition of path. This will be a letter 'from a to p. Dim LastPositionOfPath As String = "" 'I found a HashTable was by far faster than a Generic.Dictionary ' - about 10 times faster. This stores prefixes of words and words. 'I determined 792773 was the number of words and unique prefixes that 'will be generated from the dictionary file. This is a max number and 'the final hashtable will not have that many. Dim HashTableOfPrefixesAndWords As New Hashtable(792773) 'Stores words that are found. Dim FoundWords As New Generic.List(Of String) 'Just to validate what the user enters in the grid. Dim ErrorFoundWithSubmittedLetters As Boolean = False Public Sub BuildAndTestPathsAndFindWords(ByVal ThisPath As String) 'Word is the word correlating to the ThisPath parameter. 'This path would be a series of letters from a to p. Dim Word As String = "" 'The path is iterated through and a word based on the actual 'letters in the Boggle grid is assembled. For i As Integer = 0 To ThisPath.Length - 1 Word += Me.BoggleLetters(ThisPath.Substring(i, 1)) Next 'If my hashtable of word prefixes and words doesn't contain this Word 'Then this isn't a word and any further extension of ThisPath will not 'yield any words either. So exit sub to terminate exploring this path. If Not HashTableOfPrefixesAndWords.ContainsKey(Word) Then Exit Sub 'The value of my hashtable is a boolean representing if the key if a word (true) or 'just a prefix (false). If true and at least 3 letters long then yay! word found. If HashTableOfPrefixesAndWords(Word) AndAlso Word.Length > 2 Then Me.FoundWords.Add(Word) 'If my List of Paths doesn't contain ThisPath then add it. 'Remember only valid paths will make it this far. Paths not found 'in the HashTableOfPrefixesAndWords cause this sub to exit above. If Not Paths.Contains(ThisPath) Then Paths.Add(ThisPath) 'Examine the last letter of ThisPath. We are looking to extend the path 'to our neighboring letters if any are still available. LastPositionOfPath = ThisPath.Substring(ThisPath.Length - 1, 1) 'Loop through my list of neighboring letters (representing grid points). For Each Neighbor As String In Me.NeigborsOf(LastPositionOfPath).ToCharArray() 'If I find a neighboring grid point that I haven't already used 'in ThisPath then extend ThisPath and feed the new path into 'this recursive function. (see recursive.) If Not ThisPath.Contains(Neighbor) Then Me.BuildAndTestPathsAndFindWords(ThisPath & Neighbor) Next End Sub Protected Sub ButtonBoggle_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles ButtonBoggle.Click 'User has entered the 16 letters and clicked the go button. 'Set up my Generic.Dictionary of grid points, I'm using letters a to p - 'not an x,y grid system. The values are neighboring points. NeigborsOf.Add("a", "bfe") NeigborsOf.Add("b", "cgfea") NeigborsOf.Add("c", "dhgfb") NeigborsOf.Add("d", "hgc") NeigborsOf.Add("e", "abfji") NeigborsOf.Add("f", "abcgkjie") NeigborsOf.Add("g", "bcdhlkjf") NeigborsOf.Add("h", "cdlkg") NeigborsOf.Add("i", "efjnm") NeigborsOf.Add("j", "efgkonmi") NeigborsOf.Add("k", "fghlponj") NeigborsOf.Add("l", "ghpok") NeigborsOf.Add("m", "ijn") NeigborsOf.Add("n", "ijkom") NeigborsOf.Add("o", "jklpn") NeigborsOf.Add("p", "klo") 'Retrieve letters the user entered. BoggleLetters.Add("a", Me.TextBox1.Text.ToLower.Trim()) BoggleLetters.Add("b", Me.TextBox2.Text.ToLower.Trim()) BoggleLetters.Add("c", Me.TextBox3.Text.ToLower.Trim()) BoggleLetters.Add("d", Me.TextBox4.Text.ToLower.Trim()) BoggleLetters.Add("e", Me.TextBox5.Text.ToLower.Trim()) BoggleLetters.Add("f", Me.TextBox6.Text.ToLower.Trim()) BoggleLetters.Add("g", Me.TextBox7.Text.ToLower.Trim()) BoggleLetters.Add("h", Me.TextBox8.Text.ToLower.Trim()) BoggleLetters.Add("i", Me.TextBox9.Text.ToLower.Trim()) BoggleLetters.Add("j", Me.TextBox10.Text.ToLower.Trim()) BoggleLetters.Add("k", Me.TextBox11.Text.ToLower.Trim()) BoggleLetters.Add("l", Me.TextBox12.Text.ToLower.Trim()) BoggleLetters.Add("m", Me.TextBox13.Text.ToLower.Trim()) BoggleLetters.Add("n", Me.TextBox14.Text.ToLower.Trim()) BoggleLetters.Add("o", Me.TextBox15.Text.ToLower.Trim()) BoggleLetters.Add("p", Me.TextBox16.Text.ToLower.Trim()) 'Validate user entered something with a length of 1 for all 16 textboxes. For Each S As String In BoggleLetters.Keys If BoggleLetters(S).Length <> 1 Then ErrorFoundWithSubmittedLetters = True Exit For End If Next 'If input is not valid then... If ErrorFoundWithSubmittedLetters Then 'Present error message. Else 'Else assume we have 16 letters to work with and start finding words. Dim SB As New StringBuilder Dim Time As String = String.Format("{0}:{1}:{2}:{3}", Date.Now.Hour.ToString(), Date.Now.Minute.ToString(), Date.Now.Second.ToString(), Date.Now.Millisecond.ToString()) Dim NumOfLetters As Integer = 0 Dim Word As String = "" Dim TempWord As String = "" Dim Letter As String = "" Dim fr As StreamReader = Nothing fr = New System.IO.StreamReader(HttpContext.Current.Request.MapPath("~/boggle/dic.txt")) 'First fill my hashtable with word prefixes and words. 'HashTable(PrefixOrWordString, BooleanTrueIfWordFalseIfPrefix) While fr.Peek <> -1 Word = fr.ReadLine.Trim() TempWord = "" For i As Integer = 0 To Word.Length - 1 Letter = Word.Substring(i, 1) 'This optimization helped quite a bit. Words in the dictionary that begin 'with letters that the user did not enter in the grid shouldn't go in my hashtable. ' 'I realize most of the solutions went with a Trie. I'd never heard of that before, 'which is one of the neat things about SO, seeing how others approach challenges 'and learning some best practices. ' 'However, I didn't code a Trie in my solution. I just have a hashtable with 'all words in the dicitonary file and all possible prefixes for those words. 'A Trie might be faster but I'm not coding it now. I'm getting good times with this. If i = 0 AndAlso Not BoggleLetters.ContainsValue(Letter) Then Continue While TempWord += Letter If Not HashTableOfPrefixesAndWords.ContainsKey(TempWord) Then HashTableOfPrefixesAndWords.Add(TempWord, TempWord = Word) End If Next End While SB.Append("Number of Word Prefixes and Words in Hashtable: " & HashTableOfPrefixesAndWords.Count.ToString()) SB.Append(" ") SB.Append("Loading Dictionary: " & Time & " - " & String.Format("{0}:{1}:{2}:{3}", Date.Now.Hour.ToString(), Date.Now.Minute.ToString(), Date.Now.Second.ToString(), Date.Now.Millisecond.ToString())) SB.Append(" ") Time = String.Format("{0}:{1}:{2}:{3}", Date.Now.Hour.ToString(), Date.Now.Minute.ToString(), Date.Now.Second.ToString(), Date.Now.Millisecond.ToString()) 'This starts a path at each point on the grid an builds a path until 'the string of letters correlating to the path is not found in the hashtable 'of word prefixes and words. Me.BuildAndTestPathsAndFindWords("a") Me.BuildAndTestPathsAndFindWords("b") Me.BuildAndTestPathsAndFindWords("c") Me.BuildAndTestPathsAndFindWords("d") Me.BuildAndTestPathsAndFindWords("e") Me.BuildAndTestPathsAndFindWords("f") Me.BuildAndTestPathsAndFindWords("g") Me.BuildAndTestPathsAndFindWords("h") Me.BuildAndTestPathsAndFindWords("i") Me.BuildAndTestPathsAndFindWords("j") Me.BuildAndTestPathsAndFindWords("k") Me.BuildAndTestPathsAndFindWords("l") Me.BuildAndTestPathsAndFindWords("m") Me.BuildAndTestPathsAndFindWords("n") Me.BuildAndTestPathsAndFindWords("o") Me.BuildAndTestPathsAndFindWords("p") SB.Append("Finding Words: " & Time & " - " & String.Format("{0}:{1}:{2}:{3}", Date.Now.Hour.ToString(), Date.Now.Minute.ToString(), Date.Now.Second.ToString(), Date.Now.Millisecond.ToString())) SB.Append(" ") SB.Append("Num of words found: " & FoundWords.Count.ToString()) SB.Append(" ") SB.Append(" ") FoundWords.Sort() SB.Append(String.Join(" ", FoundWords.ToArray())) 'Output results. Me.LiteralBoggleResults.Text = SB.ToString() Me.PanelBoggleResults.Visible = True End If End Sub End Class
