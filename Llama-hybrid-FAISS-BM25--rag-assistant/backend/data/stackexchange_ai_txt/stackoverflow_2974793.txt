[site]: stackoverflow
[post_id]: 2974793
[parent_id]: 2974187
[tags]: 
I adressed porting from VC6 to VC9 in this post . I ported a million-line monolithic app from VC6 to VC9 last year, and it proved to be extraordinarily difficult. VC6 was notorious for being not very Standards-compliant even when it came out, and as the Standard evolved in the following years, VC6's compliance just became worse. Microsoft took the opportunity to fix this problem in VC7 to a large degree, but in doing so broke a lot of code that compiled in VC6. In some cases the code broke because the code itself was poor, and VC7 was a much better compiler that did not allow many liberties that VC6 did. But in many cases "good code" (from VC6's point of view) became illegal code because of the increased conformance. A very simple example: for( int i = 0, cont = 1; cont; ++i ) { // count something up } cout This code is perfectly fine as far as VC6 is concerned, but according to the Standard i falls out of scope at the end of the for block. There are many, many other examples of things like this that changed from VC6 to VC7 (and from VC7 to VC8 etc). You should review these changes carefully before you proceed: Breaking Changes VC 2005 - 2008 (VC 2005 -> VC 2008) Breaking Changes in the Visual C++ 2005 Compiler (VC 2003 -> VC 2005) Breaking Changes in Visual C++ .NET 2003 (VC6 -> VC 2003) We had many compelling reasons to move to VC9 beyond just better compliance. One was the ability to compile 64-bit apps, and so we eventually decided to port the entire app. But you may have alternatives. If the compiler is creating a roadblock for you in just one portion of the code, you might consider porting just that portion, and creating a layer compiled in VC9 that bridges the gap between VB 8.0 and your VC6 application. This could be little more than a marshalling proxy, that does nothing more than move data between your main application and the 3rd-party component.
