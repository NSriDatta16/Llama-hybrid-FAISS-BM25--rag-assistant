[site]: stackoverflow
[post_id]: 4411677
[parent_id]: 4410469
[tags]: 
You could do this with an immense amount of reflection, in a somewhat fragile way, by using the (undocumented) copy$default$1 methods, and matching types off of the copy method, and having both implement a trait that included def a: List[String] and def a_=(a0: List[String]) . But it's a bad idea; the support isn't fully there (e.g. if you mixed it into a non-case-class it would fail at runtime), it's slow, and it saves only a small amount of typing. If you have a case where it would save a huge amount of typing, I would encourage you to use code generation instead (i.e. Scala code that writes Scala code) with an extra pass for compilation.
