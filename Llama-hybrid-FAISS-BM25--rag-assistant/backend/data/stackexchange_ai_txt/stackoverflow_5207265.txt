[site]: stackoverflow
[post_id]: 5207265
[parent_id]: 5207181
[tags]: 
C++ started as "C with classes", and it was just a precompiler that transformed the class & co. syntactic sugar into C code (C was chosen because it was quite widespread, C compiler were available for many platforms); this was one of the reasons it was (is) C-compatible. Another (and maybe more important) one was to remain compatible with the existing C codebase (libraries, syscall, ...), which has been a significant advantage for its widespread usage. However, during its evolution and standardization, C++ evolved in something quite different. All the new features that were packed in it (notably advanced OOP capabilities, exceptions, templates) and the evolution of its standard library (especially the inclusion in it of the STL) encouraged new programming styles, that differ significantly from the old "C with classes" style; many common C idioms became obsolete, and had better replacements in C++ (see e.g. std::string vs C-style strings, std::vector vs "normal" heap-allocated arrays). Still, it wasn't a good idea to remove the "older" features, since (1) C compatibility is still important in many cases, (2) the "old" stuff is the foundation for the C++ data structures ( std::vector internally uses raw pointers and plain heap arrays) and (3) the background philosophy of C++ is to let the programmer choose. Since in general the "native" C++ alternatives are better than (usually safer/easier to use/more difficult to misuse, and in general as fast as) the corresponding C idioms, it's usually told to C++ newbies to forget about C and start directly from C++, to avoid picking "C bad habits". In particular, many C habits (=> e.g. raw pointers) become dangerous when exceptions are used, so it's better that a new programmer starts from the beginning with the idea that his code can be interrupted at any place, and make it exception safe from the beginning wrapping its resources in RAII classes.
