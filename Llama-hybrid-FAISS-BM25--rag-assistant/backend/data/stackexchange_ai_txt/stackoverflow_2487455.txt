[site]: stackoverflow
[post_id]: 2487455
[parent_id]: 2485219
[tags]: 
To begin with, you should check out Boost.Function , since it is about wrapping functions automatically, it will give you ideas I think ;) Second, your syntax is a bit awkward. You can perfectly use functions signatures as part as the template parameters, which nicely deals with the problem of variadic templates since it allows you to pass an arbitrary number of types ;) Callback callback; Would indicate that your callback will take a pointer to a function with a signature similar to your add : int add(int, int) . I actually prefer this syntax since it makes it clearer what we are passing on. Before we start though I have a question: what do you want to do about the return type ? 1. References Then there are things like the Boost.Fusion library which could help you a lot (basically, tuples). Also, check out Boost.FunctionTypes which offers facilities to analyze a function signature. 2. On the road again // It is nice to have a base class // Generally callbacks do not return anything though... struct CallbackBase { virtual ~CallbackBase(); virtual void execute() const = 0; }; namespace func_ = boost::function_types; template ::type, mpl_::size_t >::type > class Streamer { public: typedef Streamer ::type > next_type; typedef typename mpl_::size ::type size_type; typedef typename mpl_::minus ::type index_type; typedef typename mpl_::at ::type arg_type; Streamer(Parameters& p): mParameters(p) {} next_type operator (mParameters) = arg; return next_type(mParameters); } private: Parameters& mParameters; }; template struct Streamer { Streamer(Parameters&) {} }; template class Callback: public CallbackBase { public: typedef typename func_::result_type ::type result_type; typedef typename func_::parameters_type ::type parameters_type; typedef typename func_::function_pointer ::type >::type function_pointer; Callback(function_pointer f): mFunction(f) {} virtual void execute() const { mReturn = Invoke ::Do(f,mParameters); } Streamer operator ::type arg) { boost::fusion::at_c (mParameters) = arg; return Streamer (mParameters); } private: function_pointer f; result_type mResult; parameters_type mParameters; }; Well, that's how far I went. I haven't dealt with the actual invocation which require unpacking the tuple to pass the arguments to the function. So far usage would be: int add(int,int); void pass(const CallbackBase& b); int main(int argc, char* argv[]) { Callback c(&add); c I strongly encourage you to delve into Boost.Fusion if you wish to pursue your studies in this domain, as pure template metaprogramming is often fruitless if you can't bring the result into the runtime world :)
