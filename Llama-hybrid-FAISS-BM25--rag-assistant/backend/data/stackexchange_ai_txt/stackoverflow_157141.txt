[site]: stackoverflow
[post_id]: 157141
[parent_id]: 157039
[tags]: 
Having to iterate over the list multiple times isn't elegant IMHO. I'd probably create a function that allows doing: twos, threes = countmatching(xrange(1,10), lambda a: a % 2 == 0, lambda a: a % 3 == 0) A starting point would be something like this: def countmatching(iterable, *predicates): v = [0] * len(predicates) for e in iterable: for i,p in enumerate(predicates): if p(e): v[i] += 1 return tuple(v) Btw, "itertools recipes" has a recipe for doing much like your alt4. def quantify(seq, pred=None): "Count how many times the predicate is true in the sequence" return sum(imap(pred, seq))
