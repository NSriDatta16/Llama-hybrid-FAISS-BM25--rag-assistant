[site]: stackoverflow
[post_id]: 2157214
[parent_id]: 2156598
[tags]: 
It's difficult to give you specific advice because different code bases require different strategies. I refactor a module with 500-line subroutines differently than one with small subroutines and a lot of repeated code. If I need to change the interface too, there are different strategies for that. Get everything into source control. You need to keep the original and intermediate versions. If you don't already have a test suite, write one. Get the test coverage as high as you can. This test suite is the baseline for preserving the same behavior in the future versions, bugs and all. You're probably going to encounter a program that depends on a bug in the original module. Start hacking away. At each step, check that the rest still passes the original tests and that the published interface still results in the same behavior. I think your actual question, though, is "How to I export to the original module that loaded Dumb?". You can provide your own import routine that uses Exporter's import_to_level method. You can import to higher levels than the immediate one that loaded you. The Dumb::Database import can thus load its exports into the namespace that loaded Dumb even though it's Dumb that loads Dumb::Database .
