[site]: stackoverflow
[post_id]: 3376245
[parent_id]: 3374622
[tags]: 
You can do something like this: Func Euler = total=> new List () {3,5} .Select(m => ((int) (total-1) / m) * m * (((int) (total-1) / m) + 1) / 2) .Aggregate( (T, m) => T+=m); You still have the double counting problem. I'll think about this a little more. Edit: Here is a working (if slightly inelegant) solution in LINQ: var li = new List () { 3, 5 }; Func Summation = (total, m) => ((int) (total-1) / m) * m * (((int) (total-1) / m) + 1) / 2; Func Euler = total=> li .Select(m => Summation(total, m)) .Aggregate((T, m) => T+=m) - Summation(total, li.Aggregate((T, m) => T*=m)); Can any of you guys improve on this? Explanation: Remember the summation formula for a linear progression is n(n+1)/2. In the first case where you have multiples of 3,5
