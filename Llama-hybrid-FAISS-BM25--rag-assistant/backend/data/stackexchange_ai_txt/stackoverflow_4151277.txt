[site]: stackoverflow
[post_id]: 4151277
[parent_id]: 
[tags]: 
deallocation of pointers

I have a list pointer in type of A (called ListA) container a vector of pointers B. (Each A object is a container class that has a private attribute: std *B ). Then, I declare a pointer (called C having the same type as A), make a for-loop through ListA to get all pointers B and put them in C. When I quit my program, I deallocate ListA first, ListA in turn deallocates their own vector of pointers B. Then I deallocate pointer C, but the program crashes. I have debugged this a bit and know that pointer C at the time of deallocation points to nothing, so it doesn't know what to deallocate. Am I doing wrong? Or what is the solution for my problems? Sorry, I'll put my code below //Class A #pragma once #include "MyContainer.h" class B; class A { public: A(); ~A(); MyContainer *pListOfB; } A::A() { pListOfB = new MyContainer ; } A::~A() { if(pListOfB) { delete pListOfB; pListOfB = NULL; } } //Class C #pragma once #include "MyContainer.h" class B; class C { public: C(); ~C(); MyContainer *pListOfB; void getListOfB(MyContainer *pListOfA); } C::C() { pListOfB = new MyContainer ; } C::~C() { if(pListOfB) { delete pListOfB; pListOfB = NULL; } } void C::getListOfB(MyContainer *pListOfA) { for(pListOfA->isBegin(); !pListOfA->isEnd();) { A *pA = pListOfA->getNext(); for(pA->isBegin(); !pA->isEnd();) { B* pB = pA->*pListOfB->getNext(); pListOfB->add(pB); } } } //Class MyContainer #pragma once #include template class MyContainer { public: MyContainer(void); ~MyContainer(void); T* getNext(); void removeAll(); void add(T* t); void isBegin(); bool isEnd(); private: std::vector items; typename std::vector ::iterator it; }; template MyContainer ::~MyContainer() { removeAll(); } template void MyContainer ::add(T *t) { items.push_back(t); } template void MyContainer ::removeAll() { while(!isEmpty()) { std::vector ::iterator tempIt =items.begin(); T* t = (*tempIt); items.erase(tempIt); delete t; t=NULL; } } template T* MyContainer ::getNext() { if(isEnd() || isEmpty()) return NULL; return (T*)(*(it++)); } template void MyContainer ::isBegin() { it = items.begin(); } template bool MyContainer ::isEnd() { return it==items.end(); } I do the following action: 1. Initial a list A object : MyContainer *pListOfA; 2. Insert B data to each A object in pListOfA 3. Initial C object 4. Call C object operation getListOfB to get B data from pListOfA. 5. Quit program Program first dealloc pListOfA, each A then dealloc their own pListOfB. After that program dealloc C object in turn dealloc pListOfB attribute of C. But pListOfB point to nothing because pListOfA deallocs every data. So my program crash. I fix by rem the line delete pListOfB in the dtor of class C but I got a warning memory leak at that line. That's all my problem. Please show me the right way. Thanks in advance.
