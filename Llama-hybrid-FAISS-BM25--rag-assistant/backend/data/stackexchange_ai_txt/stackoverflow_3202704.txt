[site]: stackoverflow
[post_id]: 3202704
[parent_id]: 3202376
[tags]: 
Use multiprocessing instead of threading . Its has lots of advantage and one of advantage is to handling global storage for all process. This module use global dictionary which is initiated by manager. Here is sample example taken from PyMOTW The Manager is responsible for coordinating shared information state between all of its users. By creating the list through the manager, the list is updated in all processes when anyone modifies it. In addition to lists, dictionaries are also supported. import multiprocessing def worker(d, key, value): d[key] = value if __name__ == '__main__': mgr = multiprocessing.Manager() d = mgr.dict() jobs = [ multiprocessing.Process(target=worker, args=(d, i, i*2)) for i in range(10) ] for j in jobs: j.start() for j in jobs: j.join() print 'Results:', d $ python multiprocessing_manager_dict.py Results: {0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 10, 6: 12, 7: 14, 8: 16, 9: 18} Namespaces In addition to dictionaries and lists, a Manager can create a shared Namespace. Any named value added to the Namespace is visible across all of the clients. import multiprocessing def producer(ns, event): ns.value = 'This is the value' event.set() def consumer(ns, event): try: value = ns.value except Exception, err: print 'Before event, consumer got:', str(err) event.wait() print 'After event, consumer got:', ns.value if __name__ == '__main__': mgr = multiprocessing.Manager() namespace = mgr.Namespace() event = multiprocessing.Event() p = multiprocessing.Process(target=producer, args=(namespace, event)) c = multiprocessing.Process(target=consumer, args=(namespace, event)) c.start() p.start() c.join() p.join() $ python multiprocessing_namespaces.py Before event, consumer got: 'Namespace' object has no attribute 'value' After event, consumer got: This is the value
