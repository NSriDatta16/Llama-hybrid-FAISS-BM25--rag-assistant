[site]: stackoverflow
[post_id]: 3743678
[parent_id]: 3743628
[tags]: 
in Directory_block.c cache_set* newSet = malloc(sizeof(cache_set) + sizeof(directory_block)*numberOfBlocks); newSet is a pointer with space for: 1 cache_set: ok numberOfBlocks directory_blocks: huh? This is wrong: cache_sets do not have directory_blocks in them; they have pointers to directory_blocks typedef struct{ int setNumber; directory_block* blocks[]; }cache_set; I'd pay great attention to your type structure. Do you really need an array of pointers to directory_blocks inside cache_sets? If you do, the typedef is ok; if you don't, it's (probably) the code that's ok ... but, anyway, ... the structure and the malloc don't match. Edit use the flexible array member Suppose we have a struct with a flexible array member struct Example { int value; double fam[]; /* fam is the flexible array, of doubles */ }; and now we want to use a variable of type struct Example with space for 100 doubles: struct Example *example; example = malloc(sizeof *example + 100 * sizeof *example->fam); if (example) { /* use example, eg: */ example->fam[42] = 3.14159265; /* and remember to free the allocated object when done */ free(example); }
