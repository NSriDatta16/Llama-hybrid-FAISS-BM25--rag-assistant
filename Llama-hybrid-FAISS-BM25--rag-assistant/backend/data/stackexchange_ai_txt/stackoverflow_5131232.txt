[site]: stackoverflow
[post_id]: 5131232
[parent_id]: 5122864
[tags]: 
Here are few choices, pick one. Let's name our enumerable e: var e = new[] { "1", "5", "Transition Good->Bad", "3", "2", "Transition Bad->Good", "7", "Transition Good->Bad", "9", "12" }; If you have enumerable and the on/off signal is mixed in, then using .Scan() is most evident. It is basically a functional version of a foreach loop with a mutable flag: var goods = e .Scan(Tuple.Create("", 1), (x, y) => Tuple.Create(y, y.StartsWith("Transition") ? y.EndsWith("Good") ? 1 : -1 : x.Item2)) .Where(x => !x.Item1.StartsWith("Transition") && x.Item2 > 0) .Select(x => x.Item1); If you have enumerable and don't mind writing your own extension function specifically for this case, using yield return is probably most elegant: public static IEnumerable SplitByMarkers ( this IEnumerable source, Func fMarker) { var isOn = true; foreach (var value in source) { var m = fMarker(value); if (m == 0) if (isOn) yield return value; else continue; else isOn = m > 0; } } var goods = e.SplitByMarkers(x => x.StartsWith("Transition") ? x.EndsWith("Good") ? 1 : -1 : 0); If you have observable, and especially if the markers exist as a separate observable, the best option to create AndOn extension based on .CombineLatest: public static IObservable AndOn ( this IObservable source, IObservable onOff) { return source .CombineLatest(onOff, (v, on) => new { v, on }) .Where(x => x.on) .Select(x => x.v); } You can use AndOn with the above enumerable like this: var o = e.ToObservable().Publish(); var onOff = o .Where(x => x.StartsWith("Transition")) .Select(x => x.EndsWith("Good")) .StartWith(true); var goods = o .AndOn(onOff) .Where(x => !x.StartsWith("Transition")); using (goods.Subscribe(Console.WriteLine)) using (o.Connect()) { Console.ReadKey(); } And finally, RX geek way, using the Join operator available in the Dec 2010 drop of RX: var o = e.ToObservable().Publish(); var gb = o.Where(x => x == "Transition Good->Bad"); var bg = o.Where(x => x == "Transition Bad->Good").Publish(""); var goods = from s in o join g in bg on Observable.Empty () equals gb where !s.StartsWith("Transition") select s; using (goods.Subscribe(Console.WriteLine)) using (bg.Connect()) using (o.Connect()) { Console.ReadKey(); }
