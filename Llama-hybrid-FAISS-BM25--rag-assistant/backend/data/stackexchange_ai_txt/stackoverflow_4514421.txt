[site]: stackoverflow
[post_id]: 4514421
[parent_id]: 4513672
[tags]: 
"\001" aka "\x01" is an ASCII control code. It is not however one of the permitted XML characters. The only ASCII control codes which qualify are "\t", "\n" and "\r". Examples: >>> import xml.etree.cElementTree as ET # Raw newline works >>> t = ET.fromstring(" \n ") >>> t.text '\n' # Hex escaping of a newline works >>> t = ET.fromstring(" &#xa; ") >>> t.text '\n' # Hex escaping of "\x01" doesn't work; it's not a valid XML character >>> t = ET.fromstring(" &#x1; ") Traceback (most recent call last): File " ", line 1, in File " ", line 106, in XML cElementTree.ParseError: reference to invalid character number: line 1, column 3 If you want to include invalid XML characters somehow in an XML document, they must be hidden from the XML parser by an extra level of escaping. The mechanism needs to be documented, published, and understood by readers of your document. For example, in Microsoft Excel 2007+ XLSX files, Unicode code points which are not valid XML characters are smuggled past the parser by representing them as _xhhhh_ where hhhh is the hex representation of the codepoint. In your example this would be the 7 bytes _x0001_ . Note that it is necessary to escape any _ characters in the text that would otherwise be falsely interpreted as introducing an _xhhhh_ sequence. This is ugly, painful, inefficient, etc. You may wish to consider other methods. Is use of XML necessary? Would a CSV file (shock, horror!) do a better job in your application? Edit Some notes on the OP's encoding proposal: A. Although \r is a valid XML 1.0 input character, it is subject to mandatory immediate transmogrification , so you should escape it as well. B. This scheme assumes/hopes that the hhhh cannot be confused with any other markup. C. I take back what I said above about the Microsoft escaping scheme. It is relatively beautiful, painfree, and efficient. To complete the picture of your scheme for your gentle readers, you should show the code that is required to unescape the nasty bits and glue the pieces back together. Bear in mind that the MS scheme requires somebody to write one escaping function and one unescaping function, whereas your scheme requires different treatment for each tool (SAX, DOM, ElementTree). D. At the detailed level, the code is a little bit whiffy: if (len(g1) > 0): should be if g1: if (not foo == None): has a record THREE deviations from the commonly accepted idiom: (1) the parentheses (2) not x == y instead of x != y (3) != None instead of is not None Don't use list (and names of other built-in objects) as a name for your own variable. Edit 2 You want to split up a string using a regex. Why not use re.split ? splitInvalidXML2 = re.compile( ur'([^\x09\x0A\x0D\x20-\x7E\x85\xA0-\xFF\u0100-\uD7FF\uE000-\uFDCF\uFDE0-\uFFFD])' ).split def submitCharacters2(x, string): badchar = True for fragment in splitInvalidXML2(string): badchar = not badchar if badchar: x.startElement("u", attr0) x.characters('%04X' % ord(fragment)) x.endElement("u") elif fragment: x.characters(fragment)
