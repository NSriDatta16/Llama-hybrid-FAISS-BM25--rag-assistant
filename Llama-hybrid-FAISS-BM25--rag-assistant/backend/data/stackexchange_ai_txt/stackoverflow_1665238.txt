[site]: stackoverflow
[post_id]: 1665238
[parent_id]: 1665147
[tags]: 
cocoadev provides some more detail on how best to implement your own NSWindow subclass, complete with a description of most of the common pitfalls. The gist of it is to create a subclass of NSWindow , and set its styleMask to NSBorderlessWindowMask in the init method: - (id) initWithContentRect: (NSRect) contentRect styleMask: (unsigned int) aStyle backing: (NSBackingStoreType) bufferingType defer: (BOOL) flag { if ((self = [super initWithContentRect: contentRect styleMask: NSBorderlessWindowMask backing: bufferingType defer: flag]) == nil) { return nil; } [super setMovableByWindowBackground:YES]; [super setLevel:NSNormalWindowLevel]; [super setHasShadow:YES]; // etc. return self; } Note that you should probably return YES for canbecomeKeyWindow in order to make your window behave like a normal window. - (BOOL) canBecomeKeyWindow { return YES; } You can then create a custom NSView subclass, fill the entire window with an instance of said class, and then perform all of the appropriate window drawing from within that custom view. The whole thing can get a bit painful. You will have to re-implement most of the normal window behaviours such as resizing by dragging the bottom right corner.
