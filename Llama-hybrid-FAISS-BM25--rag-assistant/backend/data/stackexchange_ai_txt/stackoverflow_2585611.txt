[site]: stackoverflow
[post_id]: 2585611
[parent_id]: 2585068
[tags]: 
I'd actually approach this a completely different way, remove the empty slots, sort the list, then add the empty ones to the end of the list static void Main(string[] args) { List ints = new List { "3", "1", "", "5", "", "2" }; CustomIntSort(ints, (x, y) => int.Parse(x) - int.Parse(y)); // Ascending ints.ForEach(i => Console.WriteLine("[{0}]", i)); CustomIntSort(ints, (x, y) => int.Parse(y) - int.Parse(x)); // Descending ints.ForEach(i => Console.WriteLine("[{0}]", i)); } private static void CustomIntSort(List ints, Comparison Comparer) { int emptySlots = CountAndRemove(ints); ints.Sort(Comparer); for (int i = 0; i ints) { int emptySlots = 0; int i = 0; while (i This question caught my attention recently, this comparer will do it either class CustomComparer : IComparer { private bool isAscending; public CustomComparer(bool isAscending = true) { this.isAscending = isAscending; } public int Compare(string x, string y) { long ix = CustomParser(x) * (isAscending ? 1 : -1); long iy = CustomParser(y) * (isAscending ? 1 : -1); return ix.CompareTo(iy) ; } private long CustomParser(string s) { if (string.IsNullOrEmpty(s)) return isAscending ? int.MaxValue : int.MinValue; else return int.Parse(s); } }
