[site]: stackoverflow
[post_id]: 5739323
[parent_id]: 5738664
[tags]: 
Something like this (I assumed you want to instantiate the storage only once for all subscribers): public class Repository { public Repository() { _lazyStorage = new Lazy (StorageFactory); } private readonly Lazy _lazyStorage; private Dictionary NodeCache { get; set; } private Func StorageFactory { get; set; } public IObservable Fetch(IObservable ids) { return Observable .CreateWithDisposable (observer => ids.Subscribe(x => { INode node; if (NodeCache.TryGetValue(x, out node)) observer.OnNext(node); else { node = _lazyStorage.Value.Fetch(x); NodeCache[x] = node; observer.OnNext(node); } }, observer.OnError, observer.OnCompleted)); } } EDIT: Hmm, this order preservation while IStorage.Fetch asynchronous is interesting - waiting for IStorage.Fetch should block all future values... Thinking... I think I got it... Maybe... If you need order preservation, you need a queue. In RX world, queue is .Concat. Would the below work for you? public class Repository { public Repository() { _lazyStorage = new Lazy (StorageFactory); } private readonly Lazy _lazyStorage; private Dictionary NodeCache { get; set; } private Func StorageFactory { get; set; } private IObservable Fetcher(Guid id) { return Observable.Defer(() => { INode node; return NodeCache.TryGetValue(id, out node) ? Observable.Return(node) : _lazyStorage.Value.Fetch(id).Do(x => NodeCache[id] = x); }); } public IObservable Fetch(IObservable ids) { return ids.Select(Fetcher).Concat(); } }
