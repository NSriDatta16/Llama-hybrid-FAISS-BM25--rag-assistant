[site]: stackoverflow
[post_id]: 5528998
[parent_id]: 
[tags]: 
OpenMP threads appear to execute serially

I have an application which should essentially evaluate the reverse polish notation of a mathematical expression in parallel may times. My problem is i'm not seeing any gain in performance when using OpenMP. (Im using VS2008, the /openmp compiler option is set.) My main loop looks like this: int nMaxThreads = std::min(omp_get_max_threads(), s_MaxNumOpenMPThreads); int nThreadID; omp_set_num_threads(nMaxThreads); #pragma omp parallel for schedule(static) private(nThreadID) for (i=0; i The printfs are there solely for debugging purposes to see if any parallel action is taking place (which should mix them up inbetween the 4 threads). From the debug output i can see that indeed multiple threads are beeing spawned. Each thread is getting a certain chunk of the loop but the threads do not appear to execute in parallel. Thread 0 is calculating its chunk of the loop, then thread 1 calculates its chunk and so on. No parallel execution whatsoever. The Execution time is exactly as if openmp was'nt even active. EvalRPNInParallel is a member function that does the RPN calculation. I do not use any locks, mutexes omp barriers inside this function. double Foo::EvalRPNInParallel(int nOffset, int nThreadID) const { double *Stack = &m_vStackBuffer[nThreadID * (m_vStackBuffer.size() / 4); for (const SToken *pTok = m_pRPN; ; ++pTok) { switch (pTok->Cmd) { case cmADD: --sidx; Stack[sidx] += Stack[1+sidx]; continue; case cmSUB: --sidx; Stack[sidx] -= Stack[1+sidx]; continue; case cmMUL: --sidx; Stack[sidx] *= Stack[1+sidx]; continue; case cmVAR: Stack[++sidx] = *(pTok->Val.ptr + nOffset); continue; // ... // ... // ... case cmEND: return Stack[m_nFinalResultIdx]; } } } The strange thing is, if i'm deliberately slowing down EvalRPNInParallel with an unnecessary for loop i'm indeed seeing parallel execution of EvalRPNInParallel as i would expect it. Does anyone have an idea why i'm not seeing any gain from using OpenMP her? [update] I also tried the following openMP constructs neither one did show any parallel exection: int nIterationsPerThread = nBulkSize/nMaxThreads; #pragma omp parallel for private(nThreadID, j, k) shared(nMaxThreads, nIterationsPerThread) ordered for (i=0; i using sections: #pragma omp parallel shared(nBulkSize) private(nThreadID, i) { #pragma omp sections nowait { #pragma omp section for (i=0; i
