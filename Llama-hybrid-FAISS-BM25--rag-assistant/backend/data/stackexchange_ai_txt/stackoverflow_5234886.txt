[site]: stackoverflow
[post_id]: 5234886
[parent_id]: 5221936
[tags]: 
Solved it, although I'm sure this isn't optimal. Firstly, as Chris Becke suggested, you shouldn't respond to the WM_PAINT message and should only update using the 'UpdateLayeredWindow'. One of the problems I had was that gave UpdateLayeredWindow some bad coordinates, specifically I'd swapped the source and destination around (doh!) Here's the code for calling UpdateLayeredWindow from a GDI+ surface. It's not optimal but it works. void TOPLEVEL_FLOATING_WINDOW::update_layered_window() { BLENDFUNCTION blend_func = { 0 }; //build the blend function object... I guess microsoft doesn't/didn't like constructors blend_func.AlphaFormat = AC_SRC_OVER; blend_func.BlendFlags = 0; blend_func.SourceConstantAlpha = 255; blend_func.AlphaFormat = AC_SRC_ALPHA; POINT_2i pt = m_screen_pos; VECTOR_2i dim = m_bounds.dimensions(); POINT_2i pt_src (0,0) ; Gdiplus::Color bg(0,0,0,0); m_gdip_offscreen_bm->GetHBITMAP(bg, &m_offscreen_bm); //get the Hbitmap from my GDI+ bitmap - I think this is allocating a whole new bitmap off the heap. Yuck, very inefficient! HDC splash_dc = CreateCompatibleDC(m_display_dc); //create a temporary HDC HGDIOBJ oldobj = SelectObject(splash_dc , m_offscreen_bm); //'select' the bitmap. UpdateLayeredWindow(m_hwnd,m_display_dc, (POINT*)&pt, (SIZE*)&dim, splash_dc , (POINT*)&pt_src, 0 ,&blend_func,ULW_ALPHA); //this call works and updates our splash screens hidden buffer SelectObject(splash_dc, oldobj); //some tidy up code DeleteObject(m_offscreen_bm); //free the bitmap. Memory fragmentation HO! DeleteDC(splash_dc); //Delete the DC } And here's what I think should work but does not. I'll hand out some points to anybody who can tell me why not! I imagine this is because HDCs are not born equal and the UpdateLayeredWindow function can only accept HDCs created by a certain source in a certain way. It would be nice if the rules for this were more obvious. void TOPLEVEL_FLOATING_WINDOW::update_layered_window_in_an_ideal_world() { m_refresh_needed = false; BLENDFUNCTION blend_func = { 0 }; blend_func.AlphaFormat = AC_SRC_OVER; blend_func.BlendFlags = 0; blend_func.SourceConstantAlpha = 255; blend_func.AlphaFormat = AC_SRC_ALPHA; POINT_2i pt = m_screen_pos; VECTOR_2i dim = m_bounds.dimensions(); POINT_2i pt_src (0,0) ; HDC gdi_HDC = m_screen_gdi_dc->GetHDC(); //I have a GDI+ 'Graphics' object whose back buffer is the image I want to composite on to the desktop UpdateLayeredWindow(m_hwnd,m_display_dc, (POINT*)&pt, (SIZE*)&dim, gdi_HDC , (POINT*)&pt_src, 0 ,&blend_func,ULW_ALPHA); m_screen_gdi_dc->ReleaseHDC(gdi_HDC); //be nice and release the gdi_HDC } The only other alternative is to ignore GDI+ and render everything using my own raster library, which is quite happy to render to any offscreen buffer. However, that's kind of overkill for this project.
