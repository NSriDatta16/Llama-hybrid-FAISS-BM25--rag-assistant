[site]: stackoverflow
[post_id]: 3247065
[parent_id]: 
[tags]: 
Problems designing Bejeweled game

I am trying to do the design of a Bejeweled game. I have basically 3 classes. The Game class, which is what is going to be used by the player, a Board class, that represents the board, and a SwitchController class that is responsible for checking if the wanted switch on the board is valid, making the switch, counting the number of possible switches available (so I can know when the game is over, etc). My current design is something like the following: Game: isGameOver() isSwitchValid(coord1, coord2) makeSwitch(coord1, coord2) getPieceAt(coord) getBoardLength() IBoard: getPieceAt(coord) setPieceAt(coord, piece) getLength() My idea would then to have a ISwitchController : ISwitchController: isSwitchValid(coord1, coord2) makeSwitch(coord1, coord2) getAllValidSwitches() Here is a little diagram of how the classes are to be organized: I would have 2 different concrete classes of IBoard available for use (and for each one of them, I'd have to have an ISwitchController implementation). The problem: My program is to have 2 IBoard implementations: The first, ArrayBoard , will have all the pieces of the board stored in a 2D Array. There is nothing special about it. I will define an ArrayBoardSwitchController for managing this class. The second, ListBoard , will have for each color of pieces, a List/Set with all the coordinates of the pieces of that color. I will define a ListBoardSwitchController for managing this class. The main issue here is that the implementation of SwitchController will be totally different on ArrayBoard and on ListBoard . For example, while for implementing getAllValidSwitches() ArrayBoardSwitchController only needs the getPieceAt() method, that would not be a good idea to do with ListBoardSwitchController (in that class I use internally lists because it's easier to check if the move is valid that way). From what I can see, there are 2 different possible solutions: I could either merge together the ISwitchController and IBoard interfaces. That way I'd only have two classes, Game and Board (while basically Game would just be a controller for the Board, as it would be the Board that had all the game logic). It wouldn't be that nice because the classes wouldn't be as cohese as they could be if I had 3 distinct classes. Let the interfaces as they are and put all the methods I need to work with public in the concrete classes. For example, if I need a getYellowPiecesList() method, I'd put it public on ListBoard so ListBoardSwitchController could use it. ListBoardSwitchController would only know about it because it knows it only works against ListBoards . What's your opinion on the matter? The focus here is not so much on how to design the Bejeweled game, but how to solve this problem, that is recurrent when you try to implement algorithms: on one hand you want to have a clear and good OOP design, and in the other sometimes that gets in the way of having a sound and effective algorithm implementation.
