[site]: stackoverflow
[post_id]: 3873077
[parent_id]: 3872816
[tags]: 
data structure for containing a value and measurement unit tuple (e.g. 7.0 millimeters) Sounds like it has value semantics. The framework provides a mechanism for creating types with value semantics, namely struct . Use that. Almost everything you say in the next paragraph in your question, both pro and con value-types is a matter of optimising based on how it will interact with for the implementation details of the runtime. Since there are both pros and cons in this regard, there's no clear efficiency winner. Since you can't find the clear efficiency winner without actually trying it, any attempt to optimise in this regard will clearly be premature. As much as I'm sick to death of that quote about premature optimisation being bandied about the moment somebody tries to make something faster or smaller, it does apply here. One thing though that isn't about optimisation: I don't like the idea of overloading == and != if my tuple is a class, since the convention is that == and != is ReferenceEquals for reference types Not true at all. The default is that == and != deal with reference equality, but that's as much because the it's the only meaningful default without more knowledge of the semantics of the class. == and != should be overloaded when it fits a classes semantics to do so, ReferenceEquals should be used when reference equality is the only thing one cares about. If == and != is overloaded, someone will write if (myValue == null) and get a nasty runtime exception when myValue one day turn out to be null. Only if the == overload has a newbie mistake. The normal approach would be: public static bool operator == (MyType x, MyType y) { if(ReferenceEquals(x, null)) return ReferenceEquls(y, null); if(ReferenceEquals(y, null)) return false; return x.Equals(y); } And of course, the Equals overload should also check of the parameter being null and return false if it is, for people calling it directly. There isn't even a significant performance impact on calling this over the default == behaviour when one or both values are null, so what's the concern? Yet another aspect is that there is no clear way in C# (unlike in e.g. C++) to distinguish reference and value types in code usages, yet the semantics are very different. Not really. The default semantics as far as equality goes are pretty different, but since you are describing something as intending to have value semantics, that leans toward having it as a value type, rather than as a class type. Beyond that, the semantics available are much the same. The mechanisms can differ as far as boxing, reference sharing and so-on go, but that's back to optimisation again. Can == / != overloading in a class be justified in any circumstances? I would rather ask, can not overloading == and != be justified when that's the sensible thing to do for the class? As for what I as a programmer would assume about "UnitValue", I'd probably assume it was a struct, since it sounds like it should be. But actually, I wouldn't even assume that, as I mostly won't care until I do something with it where it's important, which given that it also sounds like it should be immutable, is a reduced set (the semantic differences between mutable reference types and mutable structs are greater in practice, but this one is a no-brainer immutable).
