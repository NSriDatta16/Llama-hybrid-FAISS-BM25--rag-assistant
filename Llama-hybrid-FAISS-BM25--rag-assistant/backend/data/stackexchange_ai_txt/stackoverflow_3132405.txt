[site]: stackoverflow
[post_id]: 3132405
[parent_id]: 3132381
[tags]: 
The solution isn't to make SomeClass non-generic - it's to avoid using the raw type. For example, this works fine: import java.util.*; class SomeClass { Map someMethod() { return null; } } public class Test { public static void main(String[] args) { SomeClass a = new SomeClass (); String value = a.someMethod().get("foo"); } } Admittedly it's slightly odd that the method effectively has type erasure applied if you use the raw type - but you should basically avoid doing that to start with. I can't currently find any explanation for the behaviour of the raw type in the JLS, but section 4.8 does include this warning: The use of raw types is allowed only as a concession to compatibility of legacy code. The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.
