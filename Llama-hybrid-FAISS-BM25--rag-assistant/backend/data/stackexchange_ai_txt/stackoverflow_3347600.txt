[site]: stackoverflow
[post_id]: 3347600
[parent_id]: 3341498
[tags]: 
There's lots of optimizations that you can do that involve introducing target specific code. I'll stick mostly with generic stuff, though. First, if you are going to loop with index limits then you should usually try to loop downward. Change: for (i = 0; i to for (i = iLen-1; i This can take advantage of the fact that many common processors essentially do a comparison with 0 for the results of any math operation, so you don't have to do an explicit comparison. This only works, though, if going backwards through the loop has the same results and if the index is signed (though you can sneak around that). Alternately you could try limiting by pointer math. This might eliminate the need for an explicit index (counter) variable, which could speed things up, especially if registers are in short supply. for (p = rgiFilter; p This also gets rid of the odd updating at the end of your inner loop. The updating at the end of the loop could confuse the compiler and make it produce worse code. You may also find that the loop unrolling that you did do may produce worse or equally as good results as if you had only two statements in the body of the inner loop. The compiler is likely able to make good decisions about how this loop should be rolled/unrolled. Or you might just want to make sure that the loop is unrolled twice since rgiFilter is an array of 16 bit values and see if the compiler can take advantage of accessing it just twice to accomplish two reads and two writes -- doing one 32 bit load and one 32 bit store. for (p = rgiFilter; p If your compiler and/or target processor supports it you can also try issuing prefetch instructions. For instance gcc has: __builtin_prefetch (const void * addr) __builtin_prefetch (const void * addr, int rw) __builtin_prefetch (const void * addr, int rw, int locality) These can be used to tell the compiler that if the target has prefetch instructions it should use them to try to go ahead and get addr into the cache. Optimally these should be issued once per cache line step per array you're working on. The rw argument is to tell the compiler if you want to read or write to address. Locality has to do with if the data needs to stay in cache after you access it. The compiler just tries to do the best it can figure out how to to generate the right instructions for this, but if it can't do what you ask for on a certain target it just does nothing and it doesn't hurt anything. Also, since the __builtin_ functions are special the normal rules about variable number of arguments don't really apply -- this is a hint to the compiler, not a call to a function. You should also look into any vector operations your target supports as well as any generic or platform specific functions, builtins, or pragmas that your compiler supports for doing vector operations.
