[site]: stackoverflow
[post_id]: 1278483
[parent_id]: 
[tags]: 
Protocol Buffers with Extensions

I'm perhaps overlooking something, but I'm attempting to wrestle protocol buffers into an easy method for providing extensions later. That seems a bit unclear so I'll jump directly into the problem. I am writing an assembly to support various tasks, one of which includes describing structured data. Perfect time to use protocol buffers. The primary class to use protocol buffers is called StateDefinition. Here's the .proto file I came up with for it: package Kannon.State; message StateDefinition { enum StateTypes { GRAPHICS = 0; AUDIO = 1; MIND = 2; PHYSICS = 3; NETWORK = 4; GENERIC = 5; } repeated StateTypes requiredStates = 1; optional GraphicsStateDef Graphics = 2; optional AudioStateDef Audio = 3; (etc) } message GraphicsStateDef { extensions 100 to max; } message AudioStateDef { extensions 100 to max; } (etc) My goal was to allow those _StateDef messages to be extended later with what the fields it would need. However, this extension would happen independent of the library I'm currently writing. Kagents.dll -> Handles StateDefinition parsing and such. Something Referencing Kagents.dll -> Has a protobuff file with "extend GraphicsStateDef" to define the state needed. I was hoping that defining the "extend GraphicsStateDef" would generate code that would allow me to use properties to access these fields, and avoid the cumbersome "Extendible.AppendValue()" and GetValue() syntax. One solution I devised, which seems hackish, is to define a class in the referencing DLL with extension methods, like so: public static class GraphicsExt { enum Fields { someValue = 1, someOtherValue = 2 } public static Int32 someValue(this State.GraphicsStateDef def) { return Extensible.GetValue(def, Fields.someValue); } public static void someValue(this State.graphicsStateDef def, Int32 value) { Extensible.AppendValue(def, fields.someValue, value); } } If anyone can think of a better way, I would be much obliged. =) Also, I'm not sure how lucid my description of the problem came out, so if there's any clarification or further information I can provide, please let me know. =) EDIT: So, After thinking a lot about this and realized I'm approaching the problem wrong. StateReference is supposed to store a list of different GameState's. As well, it stores a StateDefinition, which should describe the state of this state reference. Currently, I'm trying to deserialize the state buffers into different classes (GraphicsStateDef), when I really should be deserializing into the state objects themselves. Therefore, I need to rethink the design such that StateDefinition becomes a container for the stream and extracts only enough information for the "repeated StateTypes requiredStates=1" field. Then, in the referencing assembly, the rest of the stream can be deserialized into the respective states. Does anyone have reccomendations for how to approach this? A few ideas are formulating, but nothing concrete, and I'd love the input of others.
