[site]: stackoverflow
[post_id]: 3302958
[parent_id]: 3302705
[tags]: 
Select is your friend and List<>() has a constructor that takes an IEnumerable that you can leverage. XDocument employeeXML = XDocument.Parse(e.Result); employeeList = (from employee in employeeXML.Descendants(ns + "Employee") select new Employee(employee.Element(ns + "EmployeeName").Value, employee.Element(ns + "EmployeeTitle").Value, employee.Element(ns + "EmployeeImage").Element(ns + "include").Attribute("externalPath").Value, employee.Element(ns + "EmployeeSigImage").Element(ns + "include").Attribute("externalPath").Value, employee.Element(ns + "EmployeeVideo").Value, New List (employee.Descendants("EmployeeStoryHeaderParagraph").Select(e => e.Element("EmployeeHeader").Value)), New List (employee.Descendants("EmployeeStoryHeaderParagraph").Select(e => e.Descendants("EmployeeParagraphs").Select(ep => ep.Element("EmployeeParagraph").Value).ToArray())) )).ToList(); You could probably optimize that if you played with your constructor for Employee, though. Allow the constructor to pass in an IEnumerable for both the headers and the content and then parse within the class itself. That way you can "simplify" the LINQ to: employeeList = (from employee in employeeXML.Descendants(ns + "Employee") select new Employee(employee.Element(ns + "EmployeeName").Value, employee.Element(ns + "EmployeeTitle").Value, employee.Element(ns + "EmployeeImage").Element(ns + "include").Attribute("externalPath").Value, employee.Element(ns + "EmployeeSigImage").Element(ns + "include").Attribute("externalPath").Value, employee.Element(ns + "EmployeeVideo").Value, employee.Descendants("EmployeeStoryHeaderParagraph") )).ToList();
