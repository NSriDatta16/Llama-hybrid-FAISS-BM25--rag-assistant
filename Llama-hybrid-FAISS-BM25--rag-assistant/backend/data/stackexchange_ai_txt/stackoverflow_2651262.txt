[site]: stackoverflow
[post_id]: 2651262
[parent_id]: 394947
[tags]: 
From: http://www.semanticoverflow.com/questions/453/how-to-implement-semantic-data-versioning/748#748 I personally quite like the pragmatic approach which Freebase has adopted. Browse and edit views for humans: http ://www.freebase.com/view/guid/9202a8c04000641f80000000041ecebd http ://www.freebase.com/edit/topic/guid/9202a8c04000641f80000000041ecebd The data model exposed here: http ://www.freebase.com/tools/explore/guid/9202a8c04000641f80000000041ecebd Stricly speaking, it's not RDF (it's probably a superset of it), but part of it can be exposed as RDF: http ://rdf.freebase.com/rdf/guid.9202a8c04000641f80000000041ecebd Since it's a community driven website, not only they need to track who said what, when... but they are probably keeping the history as well (never delete anything): http ://www.freebase.com/history/view/guid/9202a8c04000641f80000000041ecebd To conclude, the way I would tackle your problem is very similar and pragmatic. AFAIK, you will not find a solution which works out-of-the-box. But, you could use a "tuple" store (3 or 4 aren't enough to keep history at the finest granularity (i.e. triples|quads)). I would use TDB code as a library (since it gives you B+Trees and a lot of useful things you need) and I would use a data model which allows me to: count quads, assign an ownership to a quad, a timestamp and previous/next quad(s) if available: [ id | g | s | p | o | user | timestamp | prev | next ] Where: id - long (unique identifier, same (g,s,p,o) will have different id... a lot of space, but you can count quads... and when you have a community driven website (like this one) counting things it's important. g - URI (or blank node?|absent (i.e. default graph)) s - URI|blank node p - URI o - URI|blank node|literal user - URI timestamp - when the quad was created prev - id of the previous quad (if present) next - id of the next quad (if present) Then, you need to think about which indexes you need and this would depend on the way you want to expose and access your data. You do not need to expose all your internal structures/indexes to external users/people/applications. And, when (and if), RDF vocabularies or ontologies for representing versioning, etc. will emerge, you are able to quickly expose your data using them (if you want to). Be warned, this is not common practice and it you look at it with your "semantic web glasses" it's probably wrong, bad, etc. But, I am sharing the idea, since I believe it's not harmful, it allows to provide a solution to your question (it will be slower and use more space than a quad store), part of it can be exposed to the semantic web as RDF / LinkedData. My 2 (heretic) cents.
