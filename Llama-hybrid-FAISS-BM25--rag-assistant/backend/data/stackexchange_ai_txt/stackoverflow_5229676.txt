[site]: stackoverflow
[post_id]: 5229676
[parent_id]: 
[tags]: 
C# LINQ to rank time series values on a daily basis => partition by date, then rank by value (largest to smallest)

I have a set of about 2000 separate time-series in the form of SortedList . Each series corresponds to the daily liquidity for a given security. I would like to created a daily ranking of these values. Were I to do this with for loops, I would do the following: Create a new empty time-series [date, (int)rank] for each security to hold its rank on a given day. This can be in the form of a SortedList . Created a list of all the unique dates (not every securities' time-series has a value for every date.) For each unique date, loop through each of the securities' daily liquidity time-series to determine if it had a value for that date. If it did, add the securities name, and value to the daily ranking array [SecName, liquidity Value]. Sort the array from largest to smallest (rank 1 = largest value). For each security (secName) in the array, add the date and the securities' rank to its time-series (created in step 1). Simply, this is a daily ranking of liquidity from largest to smallest. I can get linq to pull the data from the objects and group by date, but the rest is beyond my linq skills. Any linq masters care to give this a shot? A simplified version of the object structure is outlined below. Note: I have intentionally created one date (2011,01,18) where the values (30) are the same. In this case, a sub-ranking by symbol name is acceptable. So they would be ranked... 1st 6753 JT, 2nd 6754 JT. 6752 JT does not have a value for that date, so it would not be included. using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace Ranking_Query { class Program { static void Main(string[] args) { // created an instance of the datasource and add 3 securities to it Datasource ds = new Datasource() { Name = "test" }; ds.securities.Add("6752 JT", new Security() { timeSeries = new Dictionary >() { { "liquidity", new SortedList () { {new DateTime(2011,01,15),30}, {new DateTime(2011,01,16),20}, {new DateTime(2011,01,17),10} } } } }); ds.securities.Add("6753 JT", new Security() { timeSeries = new Dictionary >() { { "liquidity", new SortedList () { {new DateTime(2011,01,15),20}, {new DateTime(2011,01,16),30}, {new DateTime(2011,01,17),20}, {new DateTime(2011,01,18),30} } } } }); ds.securities.Add("6754 JT", new Security() { timeSeries = new Dictionary >() { { "liquidity", new SortedList () { {new DateTime(2011,01,16),10}, {new DateTime(2011,01,17),30}, {new DateTime(2011,01,18),30} } } } }); } class Datasource { public string Name { get; set; } public Dictionary securities = new Dictionary (); } class Security { public string symbol { get; set; } public Dictionary > timeSeries; } } } The output using a foreach loop like this... foreach (var sec in rankingsBySymbol) { Console.WriteLine(sec.Key); foreach (var secRank in sec) { Console.WriteLine(" {0} value {1} rank {2}",secRank.Date, secRank.Value, secRank.Rank); } } Should be as follows... 6752 JT 1/15/2011 12:00:00 AM value 30 rank 1 1/16/2011 12:00:00 AM value 20 rank 2 1/17/2011 12:00:00 AM value 10 rank 3 6753 JT 1/15/2011 12:00:00 AM value 20 rank 2 1/16/2011 12:00:00 AM value 30 rank 1 1/17/2011 12:00:00 AM value 20 rank 2 1/18/2011 12:00:00 AM value 30 rank 1 6754 JT 1/16/2011 12:00:00 AM value 10 rank 3 1/17/2011 12:00:00 AM value 30 rank 1 1/18/2011 12:00:00 AM value 30 rank 2 Note: The final output does not need to include the initial value used to calculate the ranking, just the date and rank. I have included it because it make it easier to understand the initial question.
