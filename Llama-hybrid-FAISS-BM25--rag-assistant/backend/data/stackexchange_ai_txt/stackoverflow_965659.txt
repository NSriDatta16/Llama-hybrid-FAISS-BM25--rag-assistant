[site]: stackoverflow
[post_id]: 965659
[parent_id]: 880090
[tags]: 
Taking a fresh look here, previous answers to question made various assumptions about the application. Concurrency within an application is something that needs to be thought about upfront and is something for which there isn't really a one-size-fits-all answer. Things to consider when making the choice for your application: LINQ to SQL / Entity Framework are very configurable because there isn't a one-size-fits-all. You aren't going to see the effect of concurrency until you have a certain load on your app (i.e. you, alone, at your own machine might never see it) How often does your application allow 2 (or more) users to edit the same entity? How do you want to handle the situation of when two edits overlap? Is your app serializing the data back and forth across another layer (e.g. Ajax)? If so then how do you know if the edited entity was modified between the read/update? Timestamp? Version field? Do you care if edits overlap? Pay special attention to FK relationships. Data integrity is where you can get bitten by last one wins. Different solutions have very different performance implications! You won't notice as you're developing but your app may fall over when 25 people use it simultaneously. Watch for lots of copying back and forth and for many SQL reads: Don't call SQL in a loop (watch for this when you pass in a list of entities) Don't use reflection for this when you already have concurrency checking via LINQ Minimize the copying back and forth of fields (may be necessary when crossing N-Tier boundaries). Don't make a separate query to look up the old entity, (only use it if you have it lying around already) let LINQ do this as it is more optimized for doing it in SQL. Here are some good links for deeper reading to decide your specific needs: Optimistic Concurrency Overview (LINQ to SQL, MSDN) Anti-Pattern: Mishandled Concurrency (June 2009, MSDN Magazine) My recommended solution: public virtual void Update(T entity) { var DB = ...; DB.GetTable ().Attach(entity, true); try { // commit to database DB.SubmitChanges(ConflictMode.ContinueOnConflict); } catch (ChangeConflictException e) { Console.WriteLine(e.Message); foreach (ObjectChangeConflict occ in DB.ChangeConflicts) { occ.Resolve(REFRESH_MODE); } } } Where REFRESH_MODE specifies one of the following: RefreshMode.KeepChanges RefreshMode.KeepCurrentValues RefreshMode.OverwriteCurrentValues You will also need to make some considerations about your model: Probably goes without saying but you will need to let LINQ know which field is your primary key to update the entities. You don't have to pass this in as another param (as in your original method) because LINQ already knows this is the PK. You get to ( rather than "have to" ) decide which fields are actually checked. For instance a foreign key field is very important to have concurrency checking, whereas the description field probably deserves a last-one-wins. You control that via the UpdateCheck attribute. The default is UpdateCheck.Always . From MSDN: Only members mapped as Always or WhenChanged participate in optimistic concurrency checks. No check is performed for members marked Never . For more information, see UpdateCheck . To enable optimistic concurrency, you need to specify a field to use as the concurrency token (e.g. timestamp or version) and this field always has to be present when serializing back and forth. Mark this column with IsVersion=true . If you don't want concurrency checking then you must mark all as UpdateCheck.Never.
