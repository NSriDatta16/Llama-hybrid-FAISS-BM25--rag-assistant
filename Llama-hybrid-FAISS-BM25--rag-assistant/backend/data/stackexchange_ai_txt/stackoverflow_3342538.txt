[site]: stackoverflow
[post_id]: 3342538
[parent_id]: 3342213
[tags]: 
There are quite a number of languages that were explicitly designed to fit all of that niche: BitC Cyclone Forth Mesa CPL BCPL (simplified version of CPL, implementation language of MULTICS) B (Ken Thompsons first try at a systems programming language, based loosely on BCPL, precursor to C) Ada Go D C++ Modula-2 (specifically designed for the Lilith personal computer as a successor to Pascal for systems programming, also used by IBM as the implementation language for the original OS/400) Oberon (specifically designed as a simpler successor to Modula-2) Component Pascal (object-oriented successor to Oberon, despite the name it is not a direct successor to Pascal) Modula-3 (despite the name not a successor to Modula-2 but an independent development) Sing# (the implementation language of Microsoft Research's Singularity Research OS) Limbo (language for the Inferno operating system (successor to Plan 9 (successor to Unix))) Ooc Erlang (maybe not for operating systems, but embedded realtime systems, especially in the telco industry (phone switches etc.), also lately (somewhat surprising to Erlang's inventors, actually) web servers, databsase systems, etc.) Interestingly, there are also a number of languages that were not specifically designed to fill that niche, but that have been very successfully used in that niche: Smalltalk (several Smalltalk OSs, embedded systems, microcontrollers, realtime systems, most famous: the Tektronix TDS500 series of digital oscilloscopes) Lisp (several Lisp OSs, embedded systems, microcontrollers, some NASA spacecraft) Java (several Java OSs (JNode, NewOS), embedded systems, microcontrollers, smartcards) C# (several OSs (Cosmos, SharpOS), Mono is used in High-Performance Computing) Haskell (the House OS, the seL4 verified microkernel) Pascal (MacOS) There's also a lot of languages that have not yet been used in that niche, but that certainly could be. (Mostly that is because those language communities themselves have been so indoctrinated by the "you can only write operating systems in C" bullshit that they actually believe their own language to be unusable.) Ruby Python ECMAScript (which is actually used for writing high-performance webservers lately) [Note that for each one of the three categories I listed there are literally thousands more languages that fit in there.] In fact, one sometimes gets the feeling that languages which are not specifically designed for, say, operating system programming are actually better for that kind of thing. Compare, for example, the level of innovation, the stability, number of security holes, performance in something like a Smalltalk OS from the 1970s and Windows or OSX from 2010. Personally, I believe that this is based on some deep-seated myths in the systems programming community. They believe that systems programming in a language with, say, strong typing, type safety, memory safety, pointer safety, automatic storage management is impossible and that the only way to get performance or realtime guarantees is to forego powerful abstraction facilities. However, it turns out that when you try to design a programming language for humans instead of machines, then humans can actually understand the programs they wrote, find security holes, fix bugs and locate and fix performance bottlenecks much better in a 1 line monad comprehension than in a 100 line for loop. For example SqueakNOS, which is a variant of the Squeak Smalltalk system that runs without an OS (in other words: it is the OS) has pretty much all of the features that you would expect from a modern OS (graphical user interface, ...) plus some that you don't (embedded scripting language that can modify every single piece of the OS at runtime) and weighs in at just 300k SLOC and boots in less than 5 seconds while e.g. Windows weighs in at 50 million SLOC.
