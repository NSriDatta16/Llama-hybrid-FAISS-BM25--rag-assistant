[site]: stackoverflow
[post_id]: 2981164
[parent_id]: 2980037
[tags]: 
I guess some of it depends on how basic or advanced the book/audience is. When you go from single-threaded to multi-threaded programming for the first time, you typically fall off a huge cliff (and many never recover, see e.g. all the muddled questions about Control.Invoke). Anyway, to add some thoughts that are less about the programming itself, and more about the other related tasks in the software process: Measuring : deciding what metric you are aiming to improve, measuring it correctly (it is so easy to accidentally measure the wrong thing), using the right tools, differentiating signal versus noise, interpreting the results and understanding why they are as they are. Testing : how to write tests that tolerate unimportant non-determinism/interleavings, but still pin down correct program behavior. Debugging : tools, strategies, when "hard to debug" implies feedback to improve your code/design and better partition mutable state, etc. Physical versus logical thread affinity : understanding the GUI thread, understanding how e.g. an F# MailboxProcessor/agent can encapsulate mutable state and run on multiple threads but always with only a single logical thread (one program counter). Patterns (and when they apply): fork-join, map-reduce, producer-consumer, ... I expect that there will be a large audience for e.g. "help, I've got a single-threaded app with 12% CPU utilization, and I want to learn just enough to make it go 4x faster without much work" and a smaller audience for e.g. "my app is scaling sub-linearly as we add cores because there seems to be contention here, is there a better approach to use?", and so a bit of the challenge may be serving each of those audiences.
