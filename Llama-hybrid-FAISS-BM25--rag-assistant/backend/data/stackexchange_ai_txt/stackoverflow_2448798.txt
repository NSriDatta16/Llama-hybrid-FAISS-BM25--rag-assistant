[site]: stackoverflow
[post_id]: 2448798
[parent_id]: 1140448
[tags]: 
There are several reasons why JPA-oriented frameworks (Hibernate, for instance) do not fit into idiomatic Scala applications elegantly: there are no nested annotations as states the Scala 2.8 Preview -- that means you cannot use annotations as mapping metadata for complex applications (even the simplest ones often use @JoinTable -> @JoinColumn ); inconsistencies between Scala and Java collections make developers convert collections; there are also cases when it is impossible to map Scala collections to associations without implementing complex interfaces of the underlying framework (Hibernate's PersistentCollections , for example); some very common features, such as domain model validation, require JavaBeans conventions on persistent classes -- these stuff is not quite "Scala way" of doing things; of course, the interop problems (like Raw Types or proxies) introduce a whole new level of issues that cannot be walked around easily. There are more reasons, I'm sure. That's why we have started the Circumflex ORM project . This pure-Scala ORM tries it's best to eliminate the nightmares of classic Java ORMs. Specifically, you define your entities in pretty much way you would do this with classic DDL statements: class User extends Record[User] { val name = "name".TEXT.NOT_NULL val admin = "admin".BOOLEAN.NOT_NULL.DEFAULT('false') } object User extends Table[User] { def byName(n: String): Seq[User] = criteria.add(this.name LIKE n).list } // example with foreign keys: class Account extends Record[Account] { val accountNumber = "acc_number".BIGINT.NOT_NULL val user = "user_id".REFERENCES(User).ON_DELETE(CASCADE) val amount = "amount".NUMERIC(10,2).NOT_NULL } object Account extends Table[Account] As you can see, these declarations are a bit more verbose, than classic JPA POJOs. But in fact there are several concepts that are assembled together: the precise DDL for generating schema (you can easily add indexes, foreign keys and other stuff in the same DSL-like fashion); all queries can be assembled inside that "table object" instead of being scattered around in DAO; the queries themselves are very flexible, you can store query objects, predicates, projections, subqueries and relation aliases in variables so you can reuse them, and even make batch update operations from existing queries (insert-select for example); transparent navigation between associations (one-to-one, many-to-one, one-to-many and many-to-many-through-intermediate-relation) can be achieved either by lazy or by eager fetching strategies; in both cases the associations are established on top of the foreign keys of underlying relations; validation is the part of framework; there is also a Maven2 plugin that allows generating schema and importing initial data from handy XML formatted files. The only things Circumflex ORM lacks are: multi-column primary keys (although it is possible to create multi-column foreign keys backed by multi-column unique constraints, but it is only for data integrity); full-fledged documentation (although we are actively working on it); success stories of ten-billion-dollar production systems that have Circumflex ORM as it's core technology. P.S. I hope this post will not be considered an advertisement. It isn't so, really -- I was trying to be as objective as possible.
