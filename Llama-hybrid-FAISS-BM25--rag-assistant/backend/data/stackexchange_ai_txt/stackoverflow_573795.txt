[site]: stackoverflow
[post_id]: 573795
[parent_id]: 
[tags]: 
Help me with Rigid Body Physics/Transformations

I want to instance a slider constraint, that allows a body to slide between point A and point B. To instance the constraint, I assign the two bodies to constrain, in this case, one dynamic body constrained to the static world, think sliding door. The third and fourth parameters are transformations, reference Frame A and reference Frame B . To create and manipulate Transformations, the library supports Quaternions, Matrices and Euler angles. The default slider constraint slides the body along the x-axis. My question is: How do I set up the two transformations, so that Body B slides along an axis given by its own origin and an additional point in space? Naively I tried: frameA.setOrigin(origin_of_point); //since the world itself has origin (0,0,0) frameA.setRotation(Quaternion(directionToB, 0 rotation)); frameB.setOrigin(0,0,0); //axis goes through origin of object frameB.setRotation(Quaternion(directionToPoint,0)) However, Quaternions don't seem to work as I expected. My mathematical knowledge of them is not good, so if someone could fill me in on why this doesn't work, I'd be grateful. What happens is that the body slides along an axis orthogonal to the direction. When I vary the rotational part in the Quaternion constructor, the body is rotated around that sliding direction. Edit: The framework is bullet physics. The two transformations are how the slider joint is attached at each body in respect to each body's local coordinate system. Edit2 I could also set the transformations' rotational parts through a orthogonal basis, but then I'd have to reliably construct a orthogonal basis from a single vector. I hoped quaternions would prevent this. Edit3 I'm having some limited success with the following procedure: btTransform trafoA, trafoB; trafoA.setIdentity(); trafoB.setIdentity(); vec3 bodyorigin(entA->getTrafo().col_t); vec3 thisorigin(trafo.col_t); vec3 dir=bodyorigin-thisorigin; dir.Normalize(); mat4x4 dg=dgGrammSchmidt(dir); mat4x4 dg2=dgGrammSchmidt(-dir); btMatrix3x3 m( dg.col_x.x, dg.col_y.x, dg.col_z.x, dg.col_x.y, dg.col_y.y, dg.col_z.y, dg.col_x.z, dg.col_y.z, dg.col_z.z); btMatrix3x3 m2( dg2.col_x.x, dg2.col_y.x, dg2.col_z.x, dg2.col_x.y, dg2.col_y.y, dg2.col_z.y, dg2.col_x.z, dg2.col_y.z, dg2.col_z.z); trafoA.setBasis(m); trafoB.setBasis(m2); trafoA.setOrigin(btVector3(trafo.col_t.x,trafo.col_t.y,trafo.col_t.z)); btSliderConstraint* sc=new btSliderConstraint(*game.worldBody, *entA->getBody(), trafoA, trafoB, true); However, the GramSchmidt always flips some axes of the trafoB matrix and the door appears upside down or right to left. I was hoping for a more elegant way to solve this. Edit4 I found a solution, but I'm not sure whether this will cause a singularity in the constraint solver if the top vector aligns with the sliding direction: btTransform rbat = rba->getCenterOfMassTransform(); btVector3 up(rbat.getBasis()[0][0], rbat.getBasis()[1][0], rbat.getBasis()[2][0]); btVector3 direction = (rbb->getWorldTransform().getOrigin() - btVector3(trafo.col_t.x, trafo.col_t.y, trafo.col_t.z)).normalize(); btScalar angle = acos(up.dot(direction)); btVector3 axis = up.cross(direction); trafoA.setRotation(btQuaternion(axis, angle)); trafoB.setRotation(btQuaternion(axis, angle)); trafoA.setOrigin(btVector3(trafo.col_t.x,trafo.col_t.y,trafo.col_t.z));
