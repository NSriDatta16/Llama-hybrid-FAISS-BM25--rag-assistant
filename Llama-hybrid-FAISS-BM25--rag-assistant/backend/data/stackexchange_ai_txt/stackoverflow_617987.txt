[site]: stackoverflow
[post_id]: 617987
[parent_id]: 617943
[tags]: 
I would also wrap a vector: // wraps a vector. provides convenience conversion constructors // and assign functions. struct bytebuf { explicit bytebuf(size_t size):c(size) { } template bytebuf(char const(&v)[size]) { assign(v); } template void assign(char const(&v)[size]) { c.assign(v, v+size); } // provide access to wrapped vector std::vector & buf() { return c; } private: std::vector c; }; int main() { bytebuf b("data"); process(&b.buf()[0], b.buf().size()); // process 5 byte std::string str(&b.buf()[0]); std::cout There is no need to add many more functions to it, i think. You can always get the vector using buf() and operate on it directly. Since a vectors' storage is contiguous, you can use it like a C array, but it is still resizable: c.buf().resize(42) The template conversion constructor and assign function allows you to initialize or assign from a C array directly. If you like, you can add more constructors that can initialize from a set of two iterators or a pointer and a length. But i would try keeping the amount of added functionality low, so it keeps being a tight, transparent vector wrapping struct.
