[site]: stackoverflow
[post_id]: 237134
[parent_id]: 237027
[tags]: 
Others have addressed the slicing problem. You then ask Ok, let me say, I know I need to do something to determine the base type, but is there something more elegant than doing an enum lookup to determine the kind of inherited object? Querying and switching on the type of the object is a poor design which misses the point of the OO approach. Instead of string ofxSndObj::createFilter(ofxBaseSndObj& obj) { string str = obj.getType(); if(str.compare("ofxSOBuzz") == 0) { // do ofxSOBuzz - specific thing } else if(str.compare("some other derived class") == 0) { // do stuff for other derived classes } // etc... } make the interesting behaviour the virtual function: class ofxBaseSndObj { public: // get rid of getType() virtual void HelpCreateFilter() = 0; }; string ofxSndObj::createFilter(ofxBaseSndObj& obj) { // Let the derived class do it's own specialized work. // This function doesn't need to know what it is. obj.HelpCreateFilter(); // rest of filter creation } Why is this better than the original version? Because ofxSndObj::createFilter does not need modifying if future derived classes of ofxBaseSndObj are added to the system. Your version needs extending for each new derived class. If this is unclear, try to post a little more code - I can't tell from your code or class names what these functions are supposed to do.
