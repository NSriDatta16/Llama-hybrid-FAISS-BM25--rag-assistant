[site]: stackoverflow
[post_id]: 5210494
[parent_id]: 5172510
[tags]: 
I have spent the past 7 months developing a large real-world heavily-concurrent server in F#. I cannot give you precise details but this is the largest consultancy contract my company has ever landed. I am looking for some thoughts from someone who has used F# to solve large, real world, problems. Is F# a good tool for this? Yes. I have no problem developing final commercial products in F# (I did it here and here ) but our clients are often most impressed with rapid prototyping using F#. For example, I recently found an internal company document that quoted 3 man months to implement a feature in C++ that had taken me 4 hours with F#! What are the pitfalls? There are some quirks in the language but the only major problems I have encountered (that blocked my work for weeks) were bugs in .NET and poor support for Infiniband drivers on Windows, neither of which had anything specifically to do with F#. I had some minor issues with bugs in the F# libraries (e.g. TryScan is broken) but they were easy to work around once I had figured out what the problem was. The F# team have always been extremely good at providing support and accepting suggestions. Also, note that I am one of the few people who pioneered this technology in industry so I expect you will hit fewer problems than I did and will solve them more quickly because we already solved them for you! We are dealing with lots of interacting messages and a lot of changing state, although that will likely live in a DB cloud of some kind. Functional programming seems to shine in dealing with massive parallelism and distributed computing, but seems to discourage changing any kind of state. That is a common misconception. In reality, almost all functional programming languages (e.g. Lisp, Scheme, Clojure, Scala, Standard ML, OCaml, F#, Erlang) are impure and rely upon uncontrolled side effects. Haskell is the only surviving purely functional language and it is completely irrelevant. In practice, the productivity benefits of F# have more to do with type inference, pattern matching and variant types (from the ML family of languages) and other features like asynchronous workflows, mailbox processors, sequence expressions, interoperability and so on. Is F# going to stick around? It concerns me that it is so new and I don’t want to tie myself to a dying platform (J# anyone?)… We have been using F# for 4 years and it continues to go from strength to strength. I think it is very unlikely to die anytime soon, not least because Microsoft are making such good use of F# internally. For example, the F# share of UK job market just tripled in only four months . Are there any large, real world solutions (preferably servers) that are using F#? Yes, many. Microsoft continue to use it in Bing AdCenter and Halo 3 and other companies like E-ON, Grange and Credit Suisse seem to have build substantial systems with it. I suspect there are dozens more using it in secret as our client does. Does F# work well with large teams of engineers? I am sure the answer to this is a simple yes, but I am still very unfamiliar with the language/tools. If you mean large teams of F# programmers then I don't know: I have only ever worked in teams of up to 4 people using these kinds of languages. If you mean how does the introduction of F# into part of a large team work, I can use my client as a case study. They had no F# 2 years ago. Today, the top two most productive teams are both using F# and they are solving problems that were believed to be unsolvable before the introduction of F# at the company. The number of people using F# regularly has increased gradually from one person two years ago to around two dozen people today. They have stopped hiring C++ developers and started requiring F# as basic knowledge for new employees. There are inevitable political issues though. My productivity has raised eyebrows across the company and management have started to question why I am so much more cost effective, putting a lot of pressure on the teams using mainstream languages (C++ and C#). Consequently, we are now coming under fire and losing buy-in within the company because we're making others look bad. I was instructed on Friday to slow down in order to avoid making too many people look bad! So I have now been assigned to multiple projects and am repeating this "success" there. ;-)
