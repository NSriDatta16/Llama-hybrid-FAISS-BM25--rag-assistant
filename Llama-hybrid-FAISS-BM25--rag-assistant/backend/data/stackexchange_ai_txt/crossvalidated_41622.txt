[site]: crossvalidated
[post_id]: 41622
[parent_id]: 
[tags]: 
How is a prediction interval generated for many input observations?

I am aware that the "prediction interval", as defined in most textbooks on linear models, is focused on the uncertainty in the model being fit and is used to estimate an output prediction range for exact inputs. However, as is normally the case, what about situations where the input isn't exact? How do you calculate a "prediction interval" that accounts for both the uncertainty in the model and the uncertainty in the input data? For example, Assume the model is: y = a0 + (a1 * x1) + (a2 * x2) Where y , x1 , and x2 are time series vectors. I only have one observation of the y time series with its associated x1 and x2 time series. That data is used to fit the model. However, I also have 1000 additional observations for x1 and x2 . I can easily calculate individual "prediction intervals", using the model and each x1 x2 pair, however I want to estimate a "prediction interval" that allows for all x1 and x2 observations. To be more specific, I generated the example below. The questionable code is below the #====== comment line. Basically, I used lm(..) to fit the y vector to its associated x1 and x2 vectors. Next, I used predict.lm(...interval="prediction", level=alpha) to generate its typical fit , lwr , and upr vectors for each additional x1 x2 pair (see Graph 1, fit is the solid line, upr and lwr are the dashed lines for two observations). I then collected these vectors for all x1 x2 pairs and used alpha to extract the upper and lower tails of all of the lwr and upr vectors (see Graph 2). Is this scheme valid? Does the alpha that was used in predict.lm(... level=alpha) apply directly to counting-up/sorting the results to generate a "prediction interval" that allows for all x1 x2 pairs? Can a 5% range from a competing model (for example an ARIMA model) be compared to this 5% "prediction interval"? I'm fairly sure that the following scheme isn't right, but so far, I haven't figured out what I need to fix. set.seed(1) numpoi
