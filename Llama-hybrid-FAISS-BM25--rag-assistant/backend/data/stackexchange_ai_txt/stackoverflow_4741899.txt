[site]: stackoverflow
[post_id]: 4741899
[parent_id]: 4740059
[tags]: 
You can't do that, unfortunately. What you will get immediately is an exception saying a control can have only one logical parent. Although what you can do is to do double-delegation. Your panel delegates measure/arrange to another panel, and in return it provides it with 'ghosts' which will act as a children to it and delegate their own measure/arrange to your panel's children. Here's the code: using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Windows.Controls; using System.Windows; public class DelegatePanel : Panel { private sealed class DelegateChild : FrameworkElement { readonly Func measure; readonly Func arrange; public DelegateChild(Func measure, Func arrange) { this.measure = measure; this.arrange = arrange; } protected override Size MeasureOverride(Size availableSize) { return measure(availableSize); } protected override Size ArrangeOverride(Size finalSize) { return arrange(finalSize); } } readonly Dictionary delegateByChild = new Dictionary (); public Panel LayoutPanel { get { return (Panel)GetValue(LayoutPanelProperty); } set { SetValue(LayoutPanelProperty, value); } } public static readonly DependencyProperty LayoutPanelProperty = DependencyProperty.Register("LayoutPanel", typeof(Panel), typeof(DelegatePanel), new PropertyMetadata(null)); protected override Size MeasureOverride(Size availableSize) { if(this.LayoutPanel==null) return base.MeasureOverride(availableSize); this.delegateByChild.Clear(); this.LayoutPanel.Children.Clear(); foreach (UIElement _child in this.Children) { var child = _child; var delegateChild = new DelegateChild( availableChildSize => { child.Measure(availableChildSize); return child.DesiredSize; }, finalChildSize => { return finalChildSize; }); delegateByChild[child] = delegateChild; this.LayoutPanel.Children.Add(delegateChild); } this.LayoutPanel.Measure(availableSize); return this.LayoutPanel.DesiredSize; } protected override Size ArrangeOverride(Size finalSize) { if(this.LayoutPanel==null) return base.ArrangeOverride(finalSize); this.LayoutPanel.Arrange(new Rect(finalSize)); foreach (var kv in delegateByChild) { var child = kv.Key; var delegateChild = kv.Value; var position = delegateChild.TranslatePoint(default(Point), this.LayoutPanel); Rect finalChildBounds = new Rect( position, delegateChild.RenderSize); child.Arrange(finalChildBounds); } return this.LayoutPanel.RenderSize; } } Disclaimer: this doesn't implement VirtualizingPanel. So whilst it does work inside ItemsControl and the gang -- it won't perform quick enough for large collections.
