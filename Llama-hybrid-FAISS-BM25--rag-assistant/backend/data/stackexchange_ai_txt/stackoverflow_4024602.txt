[site]: stackoverflow
[post_id]: 4024602
[parent_id]: 4024350
[tags]: 
I don't think frompyfunc can do this, though I could be wrong. Regarding np.vectorize A. M. Archibald wrote : In fact, anything that goes through python code for the "combine two scalars" will be slow. The slowness of looping in python is not because python's looping constructs are slow, it's because executing python code is slow. So vectorize is kind of a cheat - it doesn't actually run fast, but it is convenient. So np.frompyfunc (and np.vectorize ) are just syntactic sugar -- they don't make Python functions run any faster. After realizing that, my interest in frompyfunc flagged (to near zero). There is nothing unreadable about a Python loop, so either use one explicitly, or rewrite the function to truly leverage numpy (by writing truly vectorized equations). import numpy as np def beta_ml_fraction(beta): a = beta[:,0] b = beta[:,1] return a / (a + b) arr=np.array([(2,3)],dtype=np.float) print(beta_ml_fraction(arr)) # [ 0.4] arr=np.array([(2,3),(3,3)],dtype=np.float) print(beta_ml_fraction(arr)) # [ 0.4 0.5]
