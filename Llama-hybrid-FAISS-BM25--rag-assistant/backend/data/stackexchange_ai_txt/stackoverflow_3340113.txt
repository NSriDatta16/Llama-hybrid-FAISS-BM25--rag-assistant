[site]: stackoverflow
[post_id]: 3340113
[parent_id]: 3339492
[tags]: 
Just some thoughts: At first sight, this sounds impossible: a fully sorted array would have O(n 2 ) valid sub-blocks. So, you would need to count more than one valid sub-block at a time. Checking the validity of a sub-block is O(n) . Checking whether a sub-block is fully sorted is O(n) as well. A fully sorted sub-block contains nÂ·(n - 1)/2 valid sub-blocks, which you can count without further breaking this sub-block up. Now, the entire array is obviously always valid. For a divide-and-conquer approach, you would need to break this up. There are two conceivable breaking points: the location of the highest element, and that of the lowest element. If you break the array into two at one of these points, including the extremum in the part that contains the second-to-extreme element, there cannot be a valid sub-block crossing this break-point. By always choosing the extremum that produces a more even split, this should work quite well (average O(n log n) ) for "random" arrays. However, I can see problems when your input is something like (1 5 2 6 3 7 4 8) , which seems to produce O(n 2 ) behaviour. (1 4 7 2 5 8 3 6 9) would be similar (I hope you see the pattern). I currently see no trick to catch this kind of worse case, but it seems that it requires other splitting techniques.
