[site]: stackoverflow
[post_id]: 190256
[parent_id]: 190232
[tags]: 
Indeed, if your compiler does not act intelligently, it may try inserting copies of your inline d function recursively, creating infinitely-large code. Most modern compilers will recognize this, however. They can either: Not inline the function at all Inline it up to a certain depth, and if it hasn't terminated by then, call the separate instance of your function using the standard function calling convention. This can take care of many common cases in a high-performance manner, while leaving a fallback for the rare case with a large call depth. This also means that you keep both inlined and separate versions of that function's code around. For case 2, many compilers have #pragma s you can set to specify the maximum depth to which this should be done. In gcc , you can also pass this in from the command-line with --max-inline-insns-recursive (see more info here ).
