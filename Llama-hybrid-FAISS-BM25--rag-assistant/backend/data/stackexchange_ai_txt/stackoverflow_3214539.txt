[site]: stackoverflow
[post_id]: 3214539
[parent_id]: 3214282
[tags]: 
I'll start with the assumption that the datasets can fit in memory. If not, then you will need something fancier. I refer below to a "set", where I am thinking of something like a C++ std::set. I don't know the Java equivalent, but any storage scheme that permits rapid lookup (tree, hash table, whatever). Comparing three lists: L0, L1 and L2. Read L0, placing each element in a set: S0. Read L1, placing items that match an element of S0 into a new set: S1, and discarding others. Discard S0. Read L2, keeping items that match an element of S1 and discarding others. Update Just realised that the question was for "n" lists, not three. However the extension should be obvious. (I hope) Update 2 Some untested C++ code to illustrate the algorithm #include #include #include #include typedef std::vector strlist_t; strlist_t GetMatches(std::vector vLists) { assert(vLists.size() > 1); std::set s0, s1; std::set *pOld = &s1; std::set *pNew = &s0; // unconditionally load first list as "new" s0.insert(vLists[0].begin(), vLists[0].end()); for (size_t i=1; i clear(); // only keep new elements if they are matched in old list for (size_t j=0; j end() != pOld->find(vLists[i][j])) { // found match pNew->insert(vLists[i][j]); } } } return strlist_t(pNew->begin(), pNew->end()); }
