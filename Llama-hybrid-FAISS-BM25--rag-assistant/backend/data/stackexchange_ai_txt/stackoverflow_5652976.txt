[site]: stackoverflow
[post_id]: 5652976
[parent_id]: 
[tags]: 
Slicing params hash for specific values

Summary Given a Hash, what is the most efficient way to create a subset Hash based on a list of keys to use? h1 = { a:1, b:2, c:3 } # Given a hash... p foo( h1, :a, :c, :d ) # ...create a method that... #=> { :a=>1, :c=>3, :d=>nil } # ...returns specified keys... #=> { :a=>1, :c=>3 } # ...or perhaps only keys that exist Details The Sequel database toolkit allows one to create or update a model instance by passing in a Hash: foo = Product.create( hash_of_column_values ) foo.update( another_hash ) The Sinatra web framework makes available a Hash named params that includes form variables, querystring parameters and also route matches. If I create a form holding only fields named the same as the database columns and post it to this route, everything works very conveniently: post "/create_product" do new_product = Product.create params redirect "/product/#{new_product.id}" end However, this is both fragile and dangerous. It's dangerous because a malicious hacker could post a form with columns not intended to be changed and have them updated. It's fragile because using the same form with this route will not work: post "/update_product/:foo" do |prod_id| if product = Product[prod_id] product.update(params) #=> end end So, for robustness and security I want to be able to write this: post "/update_product/:foo" do |prod_id| if product = Product[prod_id] # Only update two specific fields product.update(params.slice(:name,:description)) # The above assumes a Hash (or Sinatra params) monkeypatch # I will also accept standalone helper methods that perform the same end end ...instead of the more verbose and non-DRY option: post "/update_product/:foo" do |prod_id| if product = Product[prod_id] # Only update two specific fields product.update({ name:params[:name], description:params[:description] }) end end Update: Benchmarks Here are the results of benchmarking the (current) implementations: user system total real sawa2 0.250000 0.000000 0.250000 ( 0.269027) phrogz2 0.280000 0.000000 0.280000 ( 0.275027) sawa1 0.297000 0.000000 0.297000 ( 0.293029) phrogz3 0.296000 0.000000 0.296000 ( 0.307031) phrogz1 0.328000 0.000000 0.328000 ( 0.319032) activesupport 0.639000 0.000000 0.639000 ( 0.657066) mladen 1.716000 0.000000 1.716000 ( 1.725172) The second answer by @sawa is the fastest of all, a hair in front of my tap -based implementation (based on his first answer). Choosing to add the check for has_key? adds very little time, and is still more than twice as fast as ActiveSupport. Here is the benchmark code: h1 = Hash[ ('a'..'z').zip(1..26) ] keys = %w[a z c d g A x] n = 60000 require 'benchmark' Benchmark.bmbm do |x| %w[ sawa2 phrogz2 sawa1 phrogz3 phrogz1 activesupport mladen ].each do |m| x.report(m){ n.times{ h1.send(m,*keys) } } end end
