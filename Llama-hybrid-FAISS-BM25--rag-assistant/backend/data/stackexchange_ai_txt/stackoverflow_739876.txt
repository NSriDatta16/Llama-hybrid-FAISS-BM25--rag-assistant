[site]: stackoverflow
[post_id]: 739876
[parent_id]: 739394
[tags]: 
There are a couple things you can do to find sexiness here :-) Django does not have any OOTB way to inject the properties of the through table into your Contact instance. A M2M table with extra data is a SQL concept, so Django wouldn't try to fight the relations, nor guess what should happen in the event of namespace collision, etc... . In fact, I'd go so far as to say that you probably do not want to inject arbitrary model properties onto your Contact object... if you find yourself needing to do that, then it's probably a sign you should revise your model definition. Instead, Django provides convenient ways to access the relation seamlessly, both in queries and for data retrieval, all the while preserving the integrity of the entities. In this case, you'll find that your Contact object offers a contactphonenumbers_set property that you can use to access the through data: >>> c = Contact.objects.get(id=1) >>> c.contactphonenumbers_set.all() # Would produce a list of ContactPhoneNumbers objects for that contact This means, in your case, to iterate of all contact phone numbers (for example) you would: for contact in Contact.objects.all(): for phone in contact.contactphonenumbers_set.all(): print phone.number.number, phone.number.type, phone.ext If you really, really, really want to do the injection for some reason, you'll see you can do that using the 3-line code sample immediately above: just change the print statements into assignment statements. On a separate note, just for future reference, you could have written your inject function without SQL statements. In Django, the through table is itself a model, so you can query it directly: def inject(self, contacts): contact_phone_numbers = ContactPhoneNumbers.objects.\ filter(contact__in=contacts) # And then do the result construction... # - use contact_phone_number.number.phone to get the phone and ext # - use contact_phone_number.contact to get the contact instance
