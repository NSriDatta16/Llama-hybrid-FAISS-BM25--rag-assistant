[site]: stackoverflow
[post_id]: 3513605
[parent_id]: 3513456
[tags]: 
You have defined struct S in the global namespace in two different ways, which breaks the One Definition Rule. In particular, there are two different definitions of ::S::Value() , and it's undefined which will actually end up being called. You should use nameless namespaces to make sure a distinctly named version of struct S is defined in each translation unit: namespace { struct S {int Value() {return 1;}} s1; } int GetValue1() {return s1.Value();} There's a lot more to the One Definition Rule than the first paragraph which you quote. The last paragraph basically says that some things, including class definitions, can appear more than once in a program, as long as they are all identical. Your code breaks this last condition. Or, in the (abridged) words of the Standard: There can be more than one definition of a class type ... in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then each definition of D shall consist of the same sequence of tokens.
