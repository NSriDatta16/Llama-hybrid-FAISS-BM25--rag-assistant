[site]: stackoverflow
[post_id]: 2666578
[parent_id]: 
[tags]: 
Function-Local Static Const variable Initialization semantics

The questions are in bold, for those that cannot be bothered reading a question in depth. This is a followup to this question. It is to do with the initialization semantics of static variables in functions. Static variables should be initialized once, and their internal state might be altered later - as I ( currently ) do in the linked question. However, the code in question does not require the feature to change the state of the variable later. Let me clarrify my position, since I don't require the string object's internal state to change. The code is for a trait class for meta programming, and as such would would benifit from a const char * const ptr -- thus Ideally a local cost static const variable is needed. My educated guess is that in this case the string in question will be optimally placed in memory by the link-loader, and that the code is more secure and maps to the intended semantics. This leads to the semantics of such a variable "The C++ Programming language Third Edition -- Stroustrup" does not have anything (that I could find) to say about this matter. All that is said is that the variable is initialized once when the flow of control of the thread first reaches the code. This leads me to ponder if the following code would be sensible, and if not what are the intended semantics ?. #include const char * const GetString(const char * x_in) { static const char * const x = x_in; return x; } int main() { const char * const temp = GetString("yahoo"); std::cout The following compiles on GCC and prints "yahoo" twice. Which is what I want -- However it might not be standards compliant (which is why I post this question). It might be more elegant to have two functions, "SetString" and "String" where the latter forwards to the first. If it is standards compliant does someone know of a templates implementation in boost (or elsewhere) ? edit: 11-may-2010 I am using the following macro to generate the above mentioned getter/setters in my classes that encode compile time information. #define MACRO_STATIC_SETTING_PTR(name, type) \ static const type const set_##name (const type const name##_in) { \ static const type const name = name##_in; \ return name; \ } \ static const type const name() { \ return set_##name(NULL); \ } #define MACRO_STATIC_SETTING(name, type) \ static const type set_##name (const type name##_in) { \ static const type name = name##_in; \ return name; \ } \ static const type name() { \ return set_##name(NULL); \ } These macros are placed inside a class declaration. For example: template class ConfigInstance{ public: MACRO_STATIC_SETTING_PTR(sqllite3_filename, char *) }; Hopefully this will be useful to others.
