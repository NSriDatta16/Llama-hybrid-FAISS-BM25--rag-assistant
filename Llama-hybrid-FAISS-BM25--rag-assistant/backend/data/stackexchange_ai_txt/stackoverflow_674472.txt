[site]: stackoverflow
[post_id]: 674472
[parent_id]: 673908
[tags]: 
I'm not sure if you can do this without the host plugin knowing something about loading the fragment's extra implementation code. For example: MyInterface o = null; try { Class c = getClass().getClassLoader().loadClass("my.fragment.Activator"); o = (MyInterface) c.newInstance(); } catch (ClassNotFoundException e) { } if (o != null) { o.start(); } where MyInterface is an interface defined in the host plugin, and implemented by your fragment. Another way might be to have the fragment provide an extension point identifying the extended class, but that is probably more than is needed.
