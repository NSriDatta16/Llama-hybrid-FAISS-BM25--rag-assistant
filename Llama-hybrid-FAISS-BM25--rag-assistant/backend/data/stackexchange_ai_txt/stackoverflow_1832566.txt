[site]: stackoverflow
[post_id]: 1832566
[parent_id]: 1832446
[tags]: 
According to equations in this article you can count the cross-correlation coefficient in this way: % Assuming: m and n are your signals organized as row vectors r = cov([m;n]) / (std(m)*std(n)); if you want to compute the coefficient only for some part of the signals, just use: r = cov([m(1:100);n(1:100)]) / (std(m(1:100))*std(n(1:100))); Have you also tried the corrcoef function? Edit Ok, I have checked the corrcoef function and it seems to be working properly, take a look: >> x = 100*randn(1000,1); >> y=34*randn(1000,1); >> corrcoef(x,y) ans = 1.0000 -0.0543 -0.0543 1.0000 So the correlation coefficient is equal -0.0543 - small similarity (as expected). To check that, let's compute the coefficient for identical signals: >> y=x; >> corrcoef(x,y) ans = 1 1 1 1 As expected, it's equal 1. Edit . As you can see, the result of corrcoef is a matrix of all possible correlation coefficients between these two signals: x y x 1.0000 -0.0543 y -0.0543 1.0000 So for cross-correlation you need to select one of the elements outside the main diagonal (there are located self-correlation coefficients, in this case always equal 1). There is no difference if you would select ans(2,1) or ans(1,2) - there is no difference, if you compute the correlation of x and y, or correlation of y and x. So the final code should look similar to this: R = corrcoef(x,y); % Correlation matrix r = R(2,1); % this is your Cross-Correlation coefficient
