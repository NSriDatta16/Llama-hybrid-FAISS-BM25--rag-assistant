[site]: stackoverflow
[post_id]: 1973774
[parent_id]: 1968702
[tags]: 
Against my better judgment I will try to help you again. The issue is not how to find a blank line. The issue is not which regex to use. The fundamental issue is understanding how to analyze a problem and turn that analysis into code. In this case the problem is "How do I parse this format?" I've written a parser for you. I have also taken the time to write a detailed description of the process I used to write it. WARNING: The parser is not carefully tested for all cases. It does not have enough error handling built in. For those features, you can request a rate card or write them yourself. Here's the data sample you provided (I'm not sure which of your several questions I pulled this from): constant fixup GemEstabCommDelay = vid = 6 name = "ESTABLISHCOMMUNICATIONSTIMEOUT" units = "s" min = max = default = constant fixup private GemConstantFileName = vid = 4 name = "" units = "" constant fixup private GemAlarmFileName = vid = 0 name = "" units = "" Before you can write a parser for a data file, you need to have a description the structure of the file. If you are using a standard format (say XML) you can read the existing specification. If you are using some home-grown format, you get to write it yourself. So, based on the sample data, we can see that: data is broken into blocks. each block starts with the word constant in column 0. each block ends with a blank line. a block consists of a start line, and zero or more additional lines. The start line consists of the keyword constant followed by one or more whitespace delimited words, an '=' sign and an <> quoted data value. The last keyword appears to be the name of the constant. Call it constant_name The <> -quoted data appears to be a combined type/value specifier. earlier keywords appear to specify additional metadata about the constant. Let's call those options . The additional lines specify additional key value pairs. Let's call them attributes. Attributes may have a single value or they may have a type/value specifier. One or more attributes may appear in a single line. Okay, so now we have a rough spec. What do we do with it? How is the format structured? Consider the logical units of organization from largest to smallest. These will determine the structure and flow of our code. A FILE is made of BLOCKS. BLOCKS are made of LINES. So our parser should decompose a file into blocks, and then handle the blocks. Now we rough out a parser in comments: # Parse a constant spec file. # Until file is done: # Read in a whole block # Parse the block and return key/value pairs for a hash. # Store a ref to the hash in a big hash of all blocks, keyed by constant_name. # Return ref to big hash with all block data Now we start to fill in some code: # Parse a constant spec file. sub parse_constant_spec { my $fh = shift; my %spec; # Until file is done: # Read in a whole block while( my $block = read_block($fh) ) { # Parse the and return key/value pairs for a hash. my %constant = parse_block( $block ); # Store a ref to the hash in a big hash of all blocks, keyed by constant_name. $spec{ $constant{name} } = \%constant; } # Return ref to big hash with all block data return \%spec; } But it won't work. The parse_block and read_block subs haven't been written yet. At this stage that's OK. The point is to rough in features in small, understandable chunks. Every once in a while, to keep things readable you need to gloss over the details drop in a subroutine--otherwise you wind up with monstrous 1000 line subs that are impossible to debug. Now we know we need to write a couple of subs to finish up, et viola: #!/usr/bin/perl use strict; use warnings; use Data::Dumper; my $fh = \*DATA; print Dumper parse_constant_spec( $fh ); # Parse a constant spec file. # Pass in a handle to process. # As long as it acts like a file handle, it will work. sub parse_constant_spec { my $fh = shift; my %spec; # Until file is done: # Read in a whole block while( my $block = read_block($fh) ) { # Parse the and return key/value pairs for a hash. my %constant = parse_block( $block ); # Store a ref to the hash in a big hash of all blocks, keyed by constant_name. $spec{ $constant{const_name} } = \%constant; } # Return ref to big hash with all block data return \%spec; } # Read a constant definition block from a file handle. # void return when there is no data left in the file. # Otherwise return an array ref containing lines to in the block. sub read_block { my $fh = shift; my @lines; my $block_started = 0; while( my $line = ) { $block_started++ if $line =~ /^constant/; if( $block_started ) { last if $line =~ /^\s*$/; push @lines, $line; } } return \@lines if @lines; return; } sub parse_block { my $block = shift; my ($start_line, @attribs) = @$block; my %constant; # Break down first line: # First separate assignment from option list. my ($start_head, $start_tail) = split /=/, $start_line; # work on option list my @options = split /\s+/, $start_head; # Recover constant_name from options: $constant{const_name} = pop @options; $constant{options} = \@options; # Now we parse the value/type specifier @constant{'type', 'value' } = parse_type_value_specifier( $start_tail ); # Parse attribute lines. # since we've already got multiple per line, get them all at once. chomp @attribs; my $attribs = join ' ', @attribs; # we have one long line of mixed key = "value" or key = @attribs = $attribs =~ /\s*(\w+\s+=\s+".*?"|\w+\s+=\s+ )\s*/g; for my $attrib ( @attribs ) { warn "$attrib\n"; my ($name, $value) = split /\s*=\s*/, $attrib; if( $value =~ /^"/ ) { $value =~ s/^"|"\s*$//g; } elsif( $value =~ /^ /; return $type, $value; } __DATA__ constant fixup GemEstabCommDelay = vid = 6 name = "ESTABLISHCOMMUNICATIONSTIMEOUT" units = "s" min = max = default = constant fixup private GemConstantFileName = vid = 4 name = "" units = "" constant fixup private GemAlarmFileName = vid = 0 name = "" units = "" The above code is far from perfect. IMO, parse_block is too long and ought to be broken into smaller subs. Also, there isn't nearly enough validation and enforcement of well-formed input. Variable names and descriptions could be clearer, but I don't really understand the semantics of your data format. Better names would more closely match the semantics of the data format. Despite these issues, it does parse your format and produce a big handy data structure that can be stuffed into whatever output format you want. If you use this format in many places, I recommend putting the parsing code into a module. See perldoc perlmod for more info. Now, please stop using global variables and ignoring good advice. Please start reading the perldoc, read Learning Perl and Perl Best Practices, use strict, use warnings. While I am throwing reading lists around go read Global Variables are Bad and then wander around the wiki to read and learn. I learned more about writing software by reading c2 than I did in school. If you have questions about how this code works, why it is laid out as it is, what other choices could have been made, speak up and ask. I am willing to help a willing student. Your English is good, but it is clear you are not a native speaker. I may have used too many complex sentences. If you need parts of this written in simple sentences, I can try to help. I understand that working in a foreign language is very difficult.
