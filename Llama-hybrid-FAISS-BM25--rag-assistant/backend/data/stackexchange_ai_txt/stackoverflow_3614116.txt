[site]: stackoverflow
[post_id]: 3614116
[parent_id]: 
[tags]: 
UIScrollView touch events during animation not firing with animateWithDuration: but work fine with UIView beginAnimations:

I have a UIScrollView subclass that I am programmatically scrolling using UIView animations. I'd like the user to be able to tap or zoom into the UIImageView content of the Scroll View while the animation is taking place. This has worked fine while using a formulation akin to this: - (void) scrollSmoothlyatPixelsPerSecond:(float)thePixelsPerSecond { // distance in pixels / speed in pixels per second float animationDuration = _scrollView.contentSize.width / thePixelsPerSecond; [UIView beginAnimations:@"scrollAnimation" context:nil]; [UIView setAnimationCurve: UIViewAnimationCurveLinear]; [UIView setAnimationDuration:animationDuration]; _scrollView.contentOffset = CGPointMake(_scrollView.contentSize.width, 0); [UIView commitAnimations]; } Now, since iOS 4.0, UIView beginAnimations: is discouraged. So I tried to update my code using a block and UIView animateWithDuration: The scrolling works identically to the above. The key and maddening difference is that during animation, the UIScrollView and other views no-longer respond to event handling methods: - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; Nor does : -(UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView; get called when trying to zoom. Edit for clarity : No UIView present responds to touch events. This isn't limited to just the UIScrollView. The UIScrollView's peer a UIToolbar does not respond to touch events, nor do other buttons that are subviews of a peer to the UIScrollView. It appears that the entire parent UIView is frozen out of user interaction while the animation is going on . Again, after the animation completes, all of the above UIViews are again responsive. These all do get called in the UIView beginAnimations: formulation regardless of animation state. My animateWithDuration: code is slightly different - but the differences are not material. As soon as the animation completes, the above touch events are again called... here's my animate code: - (void) scrollSmoothlyToSyncPoint:(SyncPoint *) theSyncPoint andContinue:(BOOL)theContinueFlag{ float animationDuration = theSyncPoint.time - [player currentTime]; [UIView animateWithDuration:animationDuration delay:0 options:UIViewAnimationOptionCurveLinear animations:^{ [_scrollView setContentOffset:theSyncPoint.contentOffset]; } completion:^(BOOL finished){ if (theContinueFlag) { SyncPoint *aSyncPoint = [self nextSyncPoint]; if (aSyncPoint) { [self scrollSmoothlyToSyncPoint:aSyncPoint andContinue:YES]; } } }]; } The only event handler that fires during the above animation block is: - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event; So, question: Should I - ignore Apple's discouraged label and continue to use the beginAnimation formulation? Should I - reimplement zooming and my other touch-based events using hitTest? Is there some knowledge of the difference in implementation between animation blocks that can help me confront this problem? Is there something obvious that I'm missing? I am a new developer to Apple, and so I don't know how seriously to take their discouraged tag. But if this API will be deprecated then disappear, I'd rather move in a lasting direction. thanks so much for your attention.
