[site]: stackoverflow
[post_id]: 1775951
[parent_id]: 1775486
[tags]: 
You could play games with lazy initialization: package Node; use Moose; has parent => ( is => 'ro', isa => 'Node', lazy => 1, init_arg => undef, builder => '_build_parent', ); has _parent => ( is => 'ro', init_arg => 'parent', ); has child => ( is => 'ro', isa => 'Node', lazy => 1, init_arg => undef, builder => '_build_child', ); has _child => ( is => 'ro', init_arg => 'child', predicate => undef, ); has name => is => 'ro', isa => 'Str'; Generate the builders and predicates on the fly: BEGIN { for (qw/ parent child /) { no strict 'refs'; my $squirreled = "_" . $_; *{"_build" . $squirreled} = sub { my($self) = @_; my $proto = $self->$squirreled; ref $proto eq "REF" ? $$proto : $proto; }; *{"has" . $squirreled} = sub { my($self) = @_; defined $self->$squirreled; }; } } This allows my $a = Node->new(parent => \my $b, name => "A"); $b = Node->new(child => $a, name => "B"); for ($a, $b) { print $_->name, ":\n"; if ($_->has_parent) { print " - parent: ", $_->parent->name, "\n"; } elsif ($_->has_child) { print " - child: ", $_->child->name, "\n"; } } Its output is A: - parent: B B: - child: A The code could be more elegant with η-conversion‎ , but Moose won't pass parameters to builder methods.
