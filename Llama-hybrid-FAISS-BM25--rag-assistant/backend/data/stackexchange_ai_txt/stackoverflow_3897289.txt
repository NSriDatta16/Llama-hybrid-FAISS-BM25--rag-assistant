[site]: stackoverflow
[post_id]: 3897289
[parent_id]: 
[tags]: 
Simple C# code freezes itself and all 32-bit applications (incl. VS2008) but only if run under a debugger with a breakpoint set

Background: As part of a small winforms app I'm developing I have a login screen. Besides the standard username/password fields it also has a third field - "Location" which is a dropdown containing possible geographical locations where a user can log on. The list of possible locations depends on the "distributor" to which the user belongs. Think of it as a user group, it's nothing more than that in reality. To provide user friendliness I change the contents of the dropdown whenever a valid username is entered. Also the username textbox has autocomplete. Though this does offer some information disclosure, in this case it is not an issue. The problem: When I type the first letter of my username in the textbox, autocomplete immediately completes it. The dropdown contents should also change. This happens fine if I run the program without debugger, but if the program is under debugger, everything freezes - both my app and Visual Studio. The autocomplete dropdown appears, but is empty. CPU usage is 0%. Only when I kill my app does Visual Studio unfreeze. What is weirder, moving one line of code fixes the problem, although semantically everything is the same. Thus, this code works: private void txtUser_TextChanged(object sender, EventArgs e) { string EnteredUserName = this.txtUser.Text.Trim(); var Found = this._NoLocations; foreach ( var usr in this._AllUsers ) if (string.Compare(usr.FullName, EnteredUserName, StringComparison.CurrentCultureIgnoreCase) == 0) { Found = new List (this._AllLocations.Where((a, b) => a.Distributor == usr.Distributor)); break; } this.bndLocation.DataSource = Found; } But this doesn't: private void txtUser_TextChanged(object sender, EventArgs e) { string EnteredUserName = this.txtUser.Text.Trim(); var Found = null; foreach ( var usr in this._AllUsers ) if (string.Compare(usr.FullName, EnteredUserName, StringComparison.CurrentCultureIgnoreCase) == 0) { Found = new List (this._AllLocations.Where((a, b) => a.Distributor == usr.Distributor)); this.bndLocation.DataSource = Found; break; } if ( Found == null ) this.bndLocation.DataSource = this._NoLocations; } I can also set breakpoints in this method and it will show that the method completes just fine, but the freeze happens afterwards. What gives? Oh, almost forgot - I'm using Visual Studio 2008 and Telerik RadControls Q3 2009. This didn't happen with windows standard controls, it only appeared after migration. Still, very weird. Update 1: OK, so the second code fragment only works sometimes . But here's something weirder: it's not only VS2008 that freezes. My browser (Opera) and Windows Live! Messenger also became unresponsive. Thankfully the Task Manager and the Taskbar work just fine. This is getting more and more confusing... Update 2: The variables _AllUsers , _AllLocations and _NoLocations are simple generic List s. The User and Location classes are simple objects with simple properties. Although I am using NHibernate, so they might be automagically subclassed to something. bndLocation is the standard .NET BindingSource to which the Locations dropdown is bound. Update 3: Wow, apparently all 32-bit processes are frozen . Or at least those with a UI. I'm able to start new apps, and they manage to initialize and show up, but then they freeze. For the record, I'm running Windows 7 x64. Update 4: Here's the catch for Update 1: the code works if there are no breakpoints set in code. If there is a breakpoint set anywhere, it will freeze. The breakpoint doesn't have to be hit, it just has to be set. If I set the breakpoint after starting the program, all will be fine. Update 5: As per request, here's the stack trace for the event: ServiceTracker.exe!ServiceTracker.Forms.Login.txtUser_TextChanged(object sender = {Telerik.WinControls.UI.RadTextBox}, System.EventArgs e = {System.EventArgs}) Line 85 C# System.Windows.Forms.dll!System.Windows.Forms.Control.OnTextChanged(System.EventArgs e) + 0x68 bytes Telerik.WinControls.UI.dll!Telerik.WinControls.UI.RadTextBoxBase.textBoxItem_TextChanged(object sender = {Telerik.WinControls.UI.RadTextBoxItem}, System.EventArgs e = {System.EventArgs}) + 0x47 bytes [Native to Managed Transition] [Managed to Native Transition] Telerik.WinControls.dll!Telerik.WinControls.RadItem.OnTextChanged(System.EventArgs e = {System.EventArgs}) + 0x80 bytes Telerik.WinControls.dll!Telerik.WinControls.RadItem.OnPropertyChanged(Telerik.WinControls.RadPropertyChangedEventArgs e = {Telerik.WinControls.RadPropertyChangedEventArgs}) + 0xeb bytes Telerik.WinControls.dll!Telerik.WinControls.RadHostItem.OnPropertyChanged(Telerik.WinControls.RadPropertyChangedEventArgs e = {Telerik.WinControls.RadPropertyChangedEventArgs}) + 0x5a bytes Telerik.WinControls.UI.dll!Telerik.WinControls.UI.RadTextBoxItem.OnPropertyChanged(Telerik.WinControls.RadPropertyChangedEventArgs e = {Telerik.WinControls.RadPropertyChangedEventArgs}) + 0x36c bytes Telerik.WinControls.dll!Telerik.WinControls.RadObject.RaisePropertyNotifications(Telerik.WinControls.RadPropertyValue propVal = {Telerik.WinControls.RadPropertyValue}, object oldValue = "", object newValue = "v") + 0x2f7 bytes Telerik.WinControls.dll!Telerik.WinControls.RadObject.SetValueCore(Telerik.WinControls.RadPropertyValue propVal = {Telerik.WinControls.RadPropertyValue}, object propModifier = null, object newValue = "v", Telerik.WinControls.ValueSource source = Local) + 0x5bb bytes Telerik.WinControls.dll!Telerik.WinControls.RadElement.SetValueCore(Telerik.WinControls.RadPropertyValue propVal = {Telerik.WinControls.RadPropertyValue}, object propModifier = null, object newValue = "v", Telerik.WinControls.ValueSource source = Local) + 0xa2 bytes Telerik.WinControls.dll!Telerik.WinControls.RadObject.SetValue(Telerik.WinControls.RadProperty property = {Telerik.WinControls.RadProperty}, object value = "v") + 0x9b bytes Telerik.WinControls.UI.dll!Telerik.WinControls.UI.RadTextBoxItem.TextBoxControl_TextChanged(object sender = {Text = "v"}, System.EventArgs e = {System.EventArgs}) + 0x168 bytes System.Windows.Forms.dll!System.Windows.Forms.Control.OnTextChanged(System.EventArgs e) + 0x68 bytes System.Windows.Forms.dll!System.Windows.Forms.TextBoxBase.WmReflectCommand(ref System.Windows.Forms.Message m) + 0xd2 bytes Telerik.WinControls.UI.dll!Telerik.WinControls.UI.HostedTextBoxBase.WndProc(ref System.Windows.Forms.Message message = {msg=0x2111 (WM_REFLECT + WM_COMMAND) hwnd=0xf0478 wparam=0x3000478 lparam=0xf0478 result=0x0}) + 0x5ac bytes System.Windows.Forms.dll!System.Windows.Forms.Control.ControlNativeWindow.WndProc(ref System.Windows.Forms.Message m) + 0x46 bytes System.Windows.Forms.dll!System.Windows.Forms.NativeWindow.DebuggableCallback(System.IntPtr hWnd, int msg = 8465, System.IntPtr wparam, System.IntPtr lparam) + 0xad bytes [Native to Managed Transition] [Managed to Native Transition] System.Windows.Forms.dll!System.Windows.Forms.Control.SendMessage(int msg, System.IntPtr wparam, System.IntPtr lparam) + 0x6c bytes System.Windows.Forms.dll!System.Windows.Forms.Control.ReflectMessageInternal(System.IntPtr hWnd, ref System.Windows.Forms.Message m) + 0x46 bytes System.Windows.Forms.dll!System.Windows.Forms.Control.WmCommand(ref System.Windows.Forms.Message m) + 0x44 bytes System.Windows.Forms.dll!System.Windows.Forms.Control.WndProc(ref System.Windows.Forms.Message m) + 0x1fd bytes Telerik.WinControls.dll!Telerik.WinControls.RadControl.WndProc(ref System.Windows.Forms.Message m = {msg=0x111 (WM_COMMAND) hwnd=0xc046e wparam=0x3000478 lparam=0xf0478 result=0x0}) + 0x1ab bytes Telerik.WinControls.UI.dll!Telerik.WinControls.UI.RadTextBoxBase.WndProc(ref System.Windows.Forms.Message m = {msg=0x111 (WM_COMMAND) hwnd=0xc046e wparam=0x3000478 lparam=0xf0478 result=0x0}) + 0x7a bytes System.Windows.Forms.dll!System.Windows.Forms.Control.ControlNativeWindow.WndProc(ref System.Windows.Forms.Message m) + 0x46 bytes System.Windows.Forms.dll!System.Windows.Forms.NativeWindow.DebuggableCallback(System.IntPtr hWnd, int msg = 273, System.IntPtr wparam, System.IntPtr lparam) + 0xad bytes [Native to Managed Transition] [Managed to Native Transition] System.Windows.Forms.dll!System.Windows.Forms.NativeWindow.DefWndProc(ref System.Windows.Forms.Message m) + 0x9f bytes System.Windows.Forms.dll!System.Windows.Forms.Control.WndProc(ref System.Windows.Forms.Message m) + 0x9e6 bytes Telerik.WinControls.UI.dll!Telerik.WinControls.UI.HostedTextBoxBase.WndProc(ref System.Windows.Forms.Message message = {msg=0x102 (WM_CHAR) hwnd=0xf0478 wparam=0x76 lparam=0x2f0001 result=0x0}) + 0x5ac bytes System.Windows.Forms.dll!System.Windows.Forms.Control.ControlNativeWindow.WndProc(ref System.Windows.Forms.Message m) + 0x46 bytes System.Windows.Forms.dll!System.Windows.Forms.NativeWindow.DebuggableCallback(System.IntPtr hWnd, int msg = 258, System.IntPtr wparam, System.IntPtr lparam) + 0xad bytes [Native to Managed Transition] [Managed to Native Transition] System.Windows.Forms.dll!System.Windows.Forms.Application.ComponentManager.System.Windows.Forms.UnsafeNativeMethods.IMsoComponentManager.FPushMessageLoop(int dwComponentID, int reason, int pvLoopData) + 0x5c3 bytes System.Windows.Forms.dll!System.Windows.Forms.Application.ThreadContext.RunMessageLoopInner(int reason = 4, System.Windows.Forms.ApplicationContext context = {System.Windows.Forms.Application.ModalApplicationContext}) + 0x578 bytes System.Windows.Forms.dll!System.Windows.Forms.Application.ThreadContext.RunMessageLoop(int reason, System.Windows.Forms.ApplicationContext context) + 0x65 bytes System.Windows.Forms.dll!System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window owner) + 0x763 bytes ServiceTracker.exe!ServiceTracker.Forms.Login.Authentificate(out ServiceTracker.Business.User user = null, out ServiceTracker.Business.Location location = null) Line 30 + 0x12 bytes C# ServiceTracker.exe!ServiceTracker.Framework.Program.Main() Line 79 + 0x19 bytes C# [Native to Managed Transition] [Managed to Native Transition] Microsoft.VisualStudio.HostingProcess.Utilities.dll!Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly() + 0x47 bytes mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state) + 0x9b bytes mscorlib.dll!System.Threading.ThreadHelper.ThreadStart() + 0x4d bytes Update 6: So, I've come as far as to strongly suspect that there is a combination of a deadlock and a race condition somewhere between my app and other 32-bit apps. Which is strange, because even under a debugger the process is 64-bit. Anyways, here are the several possible scenarios that reproduce the problem: The method changes the dropdown contents and there is a breakpoint ANYWHERE in my code. However if the breakpoint is OUTSIDE the if statement in the above method, everything works. Possibly that is because the breakpoint gets hit twice in a row - first when I enter the first letter; second when the autocomplete has provided the rest of the username. If the method doesn't change the dropdown contents, but there is a breakpoint inside the if statement, everything freezes as well. If the method contains just a Thread.Sleep(1000); , there is a freeze for exactly 1 second; Otherwise no freeze. So it smells like the event handler (or rather some method up the stack) takes a lock on some global resource which all other 32-bit processes need. Since VS2008 is a 32-bit process, it has to wait. But since there is a brekpoint, my app isn't running either, hence the deadlock. Also, changing the dropdown contents tries to take the same lock, and thus there is a deadlock within my app. If however there is a pause beforehand (when the breakpoint gets hit twice), the race condition doesn't happen and everything works again. But... I cannot imagine what this global resource could be.
