[site]: stackoverflow
[post_id]: 5337918
[parent_id]: 5332934
[tags]: 
Problems on algorithms often come with problem on data-structures. Let's make a few observations, first: paragraphs can be treated independently editing at a given index only invalidates the current word and those that follow it is unnecessary to copy the whole words when their index would suffice for retrieving them and only their length matter for the computation Paragraph I would begin by introducing the notion of paragraph, which are determined by user-introduced line-breaks. When an edition takes place, you need to locate which is the concerned paragraph, which requires a look-up structure. The "ideal" structure here would be a Fenwick Tree, for a small text box however this seems overkill. We'll just have each paragraph store the number of displayed lines that make up its representation and you'll count from the beginning. Note that an access to the last displayed line is an access to the last paragraph. The paragraphs are thus stored as a contiguous sequence, in C++ terms, well probably take the hit of an indirection (ie storing pointers) to save moving them around when a paragraph in the middle is removed. Each paragraph will store: its content, the simplest being a single std::string to represent it. its display, in editable form (which we need to determine still) Each paragraph will cache its display, this paragraph cache will be invalidated whenever an edit is made. The actual rendering will be made for only a couple of paragraphs at a time (and better, a couple of displayed lines): those which are visible. Displayed Line A paragraph may be to displayed with at least one line, but there is no maximum. We need to store the "display" in editable form, that is a form suitable for edition. A single chunk of characters with \n thrown in is not suitable. Changes imply moving lots of characters around, and users are supposed to be changing the text, so we need better. Using lengths, instead of characters, we may actually only store a mere 4 bytes (if the string takes more than 3GB... I don't guarantee much about this algorithm). My first idea was to use the character index, however in case of edition all subsequent indexes are changed, and the propagation is error prone. Lengths are offsets, so we have an index relative to the position of the previous word. It does pose the issue of what a word (or token) is. Notably, do you collapse multiple spaces ? How do you handle them ? Here I'll assume that words are separated from one another by a single whitespace. For "fast" retrieval, I'll store the length of the whole displayed line as well. This allows quickly skipping the first displayed lines when an edit is made at character 503 of the paragraph. A displayed line will thus be composed of: a total length (inferior to the maximum displayed length of the box, once computation ended) a sequence of words (tokens) length This sequence should be editable efficiently at both ends (since for wrapping we'll push/pop words at both ends depending on whether an edit added or removed words). It's not so important if in the middle we're not that efficient, because only one line at a time is edited in the middle. In C++, either a vector or deque should be fine. While in theory a list would be "perfect", in practice its poor memory locality and high memory overhead will offset its asymptotic guarantees. A line is composed of few words, so the asymptotic behavior does not matter and high constants do. Rendering For the rendering, pick up a buffer of already sufficient length (a std::string with a call to reserve will do). Normally, you'd clear and rewrite the buffer each time, so no memory allocation occurs. You need not display what cannot be seen, but do need to know how many lines there are, to pick up the correct paragraph. Once you get the paragraph: set offset to 0 for each line hidden, increment offset by its length (+ 1 for the space after it) a word is accessed as a substring of _content , you can use the insert method on buffer : buffer.insert(buffer.end(), _content[offset], _content[offset+length]) The difficulty is in maintaining offset , but that's what makes the algorithm efficient. Structures struct LineDisplay: private boost::noncopyable { Paragraph& _paragraph; uint32_t _length; std::vector _words; // copying around can be done with memmove }; struct Paragraph: { std::string _content; boost::ptr_vector _lines; }; With this structure, implementation should be straightforward, and should not slow down as much when the content grows.
