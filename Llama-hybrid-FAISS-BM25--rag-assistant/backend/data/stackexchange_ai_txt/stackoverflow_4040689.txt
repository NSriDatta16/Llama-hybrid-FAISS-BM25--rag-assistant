[site]: stackoverflow
[post_id]: 4040689
[parent_id]: 3998546
[tags]: 
1. the example: Just to make sure that (or check if) the session does not commit the changes, it is enough to call expunge_all on the session object. This will most probably prove that the changes are not actually committed: .... print '\nAfter:' get_session().expunge_all() list_users() 2. mysql: As you already mentioned, the sqlite example might not reflect what you actually see when using mysql . As documented in sqlalchemy - MySQL - Storage Engines , the most likely reason for your problem is the usage of non-transactional storage engines (like MyISAM ), which results in an autocommit mode of execution. 3. session scope: Although having one global session sounds like a quest for a problem , using new session for every tiny little request is also not a great idea. You should think of a session as a transaction/ unit-of-work . I find the usage of the contextual sessions the best of two worlds, where you do not have to pass the session object in the hierarchy of method calls, and at the same time you are given a pretty good safety in the multi-threaded environment. I do use the local session once in a while where I know I do not want to interact with the currently running transaction (session).
