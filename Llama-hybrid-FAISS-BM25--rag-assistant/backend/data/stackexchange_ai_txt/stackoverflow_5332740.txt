[site]: stackoverflow
[post_id]: 5332740
[parent_id]: 5225058
[tags]: 
I have had the same problem that you are describing and I have tried both of the options you specify without being entirely happy about either of them. The reason we both have this issue is at least partly because the shared-library-between-consumer-and-provider-of-a-web-service -solution is in violation of accepted patterns and practices for web service design . On the consumer side, it should be sufficient to know the interface published in the WSDL. Still, if you are prepared to accept a tight coupling between your web service provider and web service consumer and you know for certain that your current client will never be replaced by a different client (which might not be capable of referencing the shared library), then I understand why the proposed solution seems like a neat way to structure your app. IMPORTANT NOTE: Can we really honestly answer yes to both of these questions? Probably not. To recap: The issue appears when you have classes (e.g. a strongly typed dataset) defined in some sort of shared library (used on both client and server). Some of your shared classes are used in the interface defined by your web service. When the web reference is added there are proxy classes defined (for your shared classes) within the web reference namespace. Due to the different namespaces the proxy class and its actual counterpart in the shared library are incompatible. Here are four solutions that can be tried if you want to go ahead with the shared library setup: Don't. Use the proxy class on the client side. This is how it is intendend to be done. It works fine unless you simultaneously want to leverage aspects of the shared library that are not exposed by the web service WSDL. Implement or use a provided copy/duplication feature of the class (e.g. you could try to Merge() one strongly typed dataset into another). A Cast is obviosuly not possible, and the copy option is usually not a very good solution either since it tends to have undesirable side-effects. E.g. When you Merge a dataset into another, all the rows in the target dataset will be labeled as 'changed'. This could be resurrected with AcceptChanges(), but what if a couple of the received rows were actually changed. Serialize everything - except for elementary data types - into strings (and back again on the consumer side). Loss of type safety is one important weakness of this approach. Remove the explicit declaration of the shared class in Reference.cs and strip the namespace from the shared class wherever it is mentioned within Reference.cs. This is probably the best option. You get what you really wanted. The shared class is returned by the web service. The only irritating drawback with this solution is that your modifications to the reference.cs file is lost whenever you update your web reference. Trust me: It can be seriously annoying. Here is a link to a similar discussion :
