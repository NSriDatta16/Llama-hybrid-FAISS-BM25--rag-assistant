[site]: stackoverflow
[post_id]: 1110092
[parent_id]: 1109847
[tags]: 
int *a is a variable the size of a pointer, just like int b would an automatic int variable. If this declaration is in a function, that variable is automatic and stored on the [ stack ]( http://en.wikipedia.org/wiki/Stack_(data_structure)#Hardware_stacks) at runtime (a simple stack decrement allocates memory for it). If the declaration is global, then 'a' is simply mapped in executable's .DATA area. Any more & signs appended can 'create storage', because of the temporary variables you're using to hold'em ;) : b = &a; //the address in the executable's .DATA or on the stack (if `a` auto) c = &b; //the address of `b` on the stack, independent of `a` or `&a` d = &c; //the address of `c` on the stack, independent of `a` or `&a` z = &(&a); //error: invalid lvalue in unary '&' The last line complains about the fact that & requires the operand to be a lvalue . That is, something assignable - like b and c above. (&a) as is a result of an expression which is not stored anywhere, therefore is not a lvalue .
