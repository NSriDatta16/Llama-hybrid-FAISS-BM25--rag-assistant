[site]: stackoverflow
[post_id]: 1887941
[parent_id]: 1603798
[tags]: 
Don't trap all the exception, parametrize the one you want: using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace ProvaException { class Program { static void Main(string[] args) { int a = doWithException (divide, 0, typeof(DivideByZeroException), x => 300); Console.WriteLine(a); Console.ReadKey(); } public static int divide(int b) { return 10 / b; } public static T doWithException (Func a, T param1, Type exType, Func handFunction) { try { return a(param1); } catch(Exception ex) { if(exType.Equals(ex.GetType())) { return handFunction(ex); } else throw ex; } } } } Not very C# like, but it can be useful in same case (when you want to abstract handling exception). You have to write a different type signature for every type of function, because C# doesn't support currying. Veeeeeeeeery boring. :D It's not a very elegant solution, but it gives you an hint on how things works in functional languages. It's very fun to learn.
