[site]: stackoverflow
[post_id]: 4090444
[parent_id]: 4089975
[tags]: 
EDIT: one-pass map accumulator - result2 contains the info you need: #include #include #include typedef map Values; struct averageMap { averageMap() : lowerCount(0), lowerSum(0), upperSum(0) {} averageMap operator()(const averageMap& input, const Values::value_type& current) { if (current.first > boundary) { upperSum += current.second; } else { lowerSum += current.second; ++lowerCount; } return *this; } static size_t boundary; size_t lowerCount; unsigned int lowerSum; unsigned int upperSum; }; size_t averageMap::boundary(0); struct averageRange { averageRange() : count(0), sum(0) {} averageRange operator()(const averageRange& input, const Values::value_type& current) { sum += current.second; ++count; return *this; } size_t count; unsigned int sum; }; int main() { Values values; values[1] = 10; values[3] = 28; values[290] = 78; values[1110] = 110; averageMap::boundary = 100; averageMap result = accumulate(values.begin(), values.end(), averageMap(boundary), averageMap(boundary)); averageRange result2 = accumulate(values.lower_bound(2), values.upper_bound(300), averageRange(), averageRange()); return 0; }; OLD VERSION: This works for me. Using accumulate on range retrieved from map::upper_bound was problematic because many STL operations require final iterators to be reachable from first in range. There is a bit of a cheat here - assuming the map values are >= 0. #include #include #include #include using namespace std; typedef map Values; int main() { Values values; values[1] = 10; values[3] = 28; values[290] = 78; values[1110] = 110; size_t boundary(100); Values::iterator iter = values.upper_bound(boundary); vector lowerRange(values.size(), -1); transform(values.begin(), iter, lowerRange.begin(), [](std::pair p) -> int { return p.second; }); vector ::iterator invalid(find(lowerRange.begin(), lowerRange.end(), -1)); size_t lowerCount(distance(lowerRange.begin(), invalid)); lowerRange.resize(lowerCount); vector upperRange(values.size() - lowerCount); transform(iter, values.end(), upperRange.begin(), [](std::pair p) -> int { return p.second; }); size_t lowerAverage = accumulate(lowerRange.begin(), lowerRange.end(), 0) / lowerRange.size(); size_t upperAverage = accumulate(upperRange.begin(), upperRange.end(), 0) / upperRange.size(); return 0; };
