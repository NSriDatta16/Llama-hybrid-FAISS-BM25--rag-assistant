[site]: crossvalidated
[post_id]: 466755
[parent_id]: 466557
[tags]: 
Given the intended application, you might be interested in creating realistic modifications of the series of data. Overview This is easier to do than you might think. (See the three-line function decorrelate in the code below.) The idea is to generate the "noise" series realistically, according to any model you like. (You can even use actual data, such as a series for another stock or a portion of the series for the same stock at a different time.) The desired amount of correlation reduction determines what multiple of the noise series you need to add in order to achieve the intended reduction in correlation. Analysis To be explicit, let's suppose you have paired series $(x_t,y_t)$ and can produce a third series $\epsilon_t$ to use for the noise. Let the correlation coefficient of $(x_t,y_t)$ be $\rho$ and suppose you wish to obtain a new series $(y^*_t)$ (with the same average value as $(y_t)$ ) whose correlation with $(x_t)$ is $\kappa\rho.$ I assume $|\kappa|\lt 1:$ that is, you intend to reduce the correlation. As a technical preliminary, intended to ensure you will be able to obtain an answer, we need first to "decorrelate" the noise from the original series. This is readily done with ordinary least squares regression: fit the model $E[\epsilon] = \beta_0 + \beta_x x + \beta_y y$ to the data and replace the series $(\epsilon_t)$ with the residuals of that model, found by subtracting its fitted values from the original values. Let $(e_t)$ be the residual series. (If you're truly unlucky, this series could be entirely zero: that would mean the "noise" was originally a linear combination of $(x_t)$ and $(y_t).$ In such a case you will have to come up with a different noise series and try again.) As a bonus, including the constant term $\beta_0$ in the model guarantees the average value of $(e_t)$ is zero, so that adding the noise does not change the overall level of the data. The new series will be obtained by adding some positive multiple $\lambda$ of the noise to either $(y_t)$ (when $\kappa \ge 0$ ) or to $(-y_t)$ (when $\kappa \lt 0,$ which means you want to reverse the direction of correlation). That is, the solution will be $$(y_t^*) = (\operatorname{sgn}(\kappa) y_t + \lambda e_t).$$ The value of $\lambda$ is found by comparing the correlation coefficients. The requirement (when $\kappa \gt 0$ ) is $$\operatorname{Cor}(x_t, y_t^*) = \frac{\operatorname{Cov}(x_t, y_t + \lambda e_t)}{\sqrt{\operatorname{Var}(x_t) \operatorname{Var}(y_t+\lambda e_t)}} = \kappa \rho .$$ Writing $\sigma^2$ for the variance of $(x_t),$ $\tau^2$ for the variance of $(y_t),$ and $\psi^2$ for the variance of $(e_t),$ this equation becomes $$\frac{\rho\sigma\tau}{\sigma \sqrt{\tau^2+\lambda^2\psi^2}} = \kappa \rho.$$ If $\rho=0$ there's nothing to do, and when $\rho\ne 0$ this conveniently simplifies (when squared) to $$\frac{1}{1+\lambda^2\psi^2/\tau^2} = \kappa^2,$$ with the unique solution $$\lambda = \frac{\tau}{\psi}\sqrt{\frac{1}{\kappa^2}-1}.$$ It's easy to verify this works for negative $\kappa$ as well. To implement this in R , I offer the decorrelate function at the beginning of the code below. At line 2, it performs the decorrelation step using lm and residuals . It invisibly divides by $\psi$ using the scale function (also on line 2), but otherwise directly reflects the foregoing formula (line 3). For convenience, if you have no definite noise series $(\epsilon_t)$ to supply, it will create one randomly (out of Normal white noise, line 1). Examples First, here is the solution using the default white noise. In this scatterplot matrix, the original series $(x_t)$ is at the top upper left plotted against time. It exhibits noticeable positive serial correlation: it's not jagged and random, but smoothly undulating. Beneath it are $(y_t)$ (also serially correlated) and then--this is the first solution, down in the lower left corner--the noisy version of $(y_t).$ (The rest of the matrix displays correlations among the series as scatterplots. The colors consistently show the times.) The original correlation of $\rho=0.95$ has been reduced to precisely $\kappa \rho = 0.60.$ However, there's a problem: qualitatively, the noisy series doesn't look much like $(y_t).$ It's too jagged. We solve this by using a noise series that has (approximately) the same serial correlation as $(y_t).$ Here's what the second solution looks like: Look at the lower left corner. Once again, the correlation of this modified series $(y_t^*)$ with $(x_t)$ is precisely $\kappa \rho=0.60.$ If that seems like an improvement, then this method is probably what you want to use. Code Here is the R code that generated the data and the figures. You can modify its parameters to experiment. When you have real data, you only need the code starting at "Reduce their correlation" (as well as the decorrelate function, of course). The mysterious part (in the middle) is the generation of a series $(x_t,y_t)$ with specified correlation. This is carried out by applying the algorithm to the series $(x_t,x_t),$ for which the correlation is $1,$ and reducing that correlation by an amount $\rho.$ I am pleased with this trick :-). # Multiply the absolute correlation between `x` and `y` by a factor `kappa` # by adding noise to `y`. Returns the noisy `y`. # decorrelate
