[site]: stackoverflow
[post_id]: 3048650
[parent_id]: 
[tags]: 
How can I send multiple types of objects across Protobuf?

I'm implementing a client-server application, and am looking into various ways to serialize and transmit data. I began working with Xml Serializers, which worked rather well, but generate data slowly, and make large objects, especially when they need to be sent over the net. So I started looking into Protobuf, and protobuf-net. My problem lies in the fact that protobuf doesn't sent type information with it. With Xml Serializers, I was able to build a wrapper which would send and receive any various (serializable) object over the same stream, since object serialized into Xml contain the type name of the object. ObjectSocket socket = new ObjectSocket(); socket.AddTypeHandler(typeof(string)); // Tells the socket the types socket.AddTypeHandler(typeof(int)); // of objects we will want socket.AddTypeHandler(typeof(bool)); // to send and receive. socket.AddTypeHandler(typeof(Person)); // When it gets data, it looks for socket.AddTypeHandler(typeof(Address)); // these types in the Xml, then uses // the appropriate serializer. socket.Connect(_host, _port); socket.Send(new Person() { ... }); socket.Send(new Address() { ... }); ... Object o = socket.Read(); Type oType = o.GetType(); if (oType == typeof(Person)) HandlePerson(o as Person); else if (oType == typeof(Address)) HandleAddress(o as Address); ... I've considered a few solutions to this, including creating a master "state" type class, which is the only type of object sent over my socket. This moves away from the functionality I've worked out with Xml Serializers, though, so I'd like to avoid that direction. The second option would be to wrap protobuf objects in some type of wrapper, which defines the type of object. (This wrapper would also include information such as packet ID, and destination.) It seems silly to use protobuf-net to serialize an object, then stick that stream between Xml tags, but I've considered it. Is there an easy way to get this functionality out of protobuf or protobuf-net? I've come up with a third solution, and posted it below, but if you have a better one, please post it too! Information on field bounds bug (using System.String ): Hashing: protected static int ComputeTypeField(Type type) // System.String { byte[] data = ASCIIEncoding.ASCII.GetBytes(type.FullName); MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); return Math.Abs(BitConverter.ToInt32(md5.ComputeHash(data), 0)); } Serialization: using (MemoryStream stream = new MemoryStream()) { Serializer.NonGeneric.SerializeWithLengthPrefix (stream, o, PrefixStyle.Base128, field); // field = 600542181 byte[] data = stream.ToArray(); _pipe.Write(data, 0, data.Length); } Deserializaion: using (MemoryStream stream = new MemoryStream(_buffer.Peek())) { lock (_mapLock) { success = Serializer.NonGeneric.TryDeserializeWithLengthPrefix (stream, PrefixStyle.Base128, field => _mappings[field], out o); } if (success) _buffer.Clear((int)stream.Position); else { int len; if (Serializer.TryReadLengthPrefix(stream, PrefixStyle.Base128, out len)) _buffer.Clear(len); } } field => _mappings[field] throws a KeyNotFoundException while looking for 63671269 . If I replace ToInt32 with ToInt16 in the hash function, the field value is set to 29723 and it works. It also works if I explicitly define System.String 's field to 1 . Explicitly defining the field to 600542181 has the same effect as using the hash function to define it. The value of the string being serialized does not change the outcome.
