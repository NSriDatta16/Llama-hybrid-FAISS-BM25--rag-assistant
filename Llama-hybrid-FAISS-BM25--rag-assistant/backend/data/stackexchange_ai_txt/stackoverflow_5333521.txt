[site]: stackoverflow
[post_id]: 5333521
[parent_id]: 5332934
[tags]: 
General change to the algorithm - work out if you need the scroll bar as cheap as you can, ie. count the number of \n in the text and if it's greater then the vheight turn on the scroll, check lengths so on. prepare the text into appropriate lines for the control now that you know you need a scroll bar or not. This allows you to remove/reduce the test if(!isVscroll && isVScrollNeeded()) as is run on almost every character - isVScroll is probably not cheep, the example code doesn't seem to pass knowledge of lines to the function so can't see how it tells if it is needed. Assuming textRows is a vector - textrows.back() += is kind of expensive, looking up the back not so much as += on string not being efficient for strings. I'd change to using a ostrstream for gathering the row and push it in when it is done. getFont().getWidth() are likely to be expensive - is the font changing? how greatly does the width differ between smallest and largest, shortcuts for fixed width fonts. Use native methods where possible to get the size of a word since you don't want to break them - GetTextExtentPoint32 Often the will be sufficient space to allow for the VScroll when you change between. Restarting from the beginning with measuring could cost you up to twice the time. Store the width of the line with each line so you can skip over the ones that still fit. Or don't build the line strings directly, keep the words seperate with the size. How accurate does it realy need to be? Apply some pragmatism... Just assume VScroll will be needed, mostly wrapping won't change much even if it isn't (1 letter words at the end/start of a line) try and work more with words than with letters - checking remaining space for each letter can waste time. assume each letter in the string is the longest letter, letters x longest
