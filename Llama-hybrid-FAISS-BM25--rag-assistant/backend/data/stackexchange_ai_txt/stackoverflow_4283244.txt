[site]: stackoverflow
[post_id]: 4283244
[parent_id]: 
[tags]: 
JSF 2 : Is this a good approach to handle Business exceptions?

Following my previous question in Creating FacesMessage in action method outside JSF conversion/validation mechanism? , i'm trying to handle the exceptions thrown from the business layer outside my managed beans. The strategy is to search and convert business exceptions to faces messages in the a PhaseListener,. It is working as i expected, but im just wondering if im just reinventing the wheel, or doing it right with the wrong way ? Here's my code sample snippet : public class BusinessExceptionHandler implements PhaseListener { @Override public void afterPhase(PhaseEvent phaseEvent) { ExceptionHandler exceptionHandler = phaseEvent.getFacesContext().getExceptionHandler(); // just debugging the handled exception, nothing here /* for (ExceptionQueuedEvent event : exceptionHandler.getHandledExceptionQueuedEvents()) { ExceptionQueuedEventContext context = (ExceptionQueuedEventContext) event.getSource(); System.out.println("handled exception : " + context.getException()); }*/ for (Iterator it = exceptionHandler.getUnhandledExceptionQueuedEvents().iterator(); it.hasNext();) { ExceptionQueuedEvent event = it.next(); ExceptionQueuedEventContext eventContext = (ExceptionQueuedEventContext) event.getSource(); Throwable e = eventContext.getException(); System.out.println("unhandled exception : " + e); // get the root cause exception while (e.getCause() != null) { e = e.getCause(); } System.out.println("cause exception : " + e + ", cause exception is BE : " + (e instanceof BusinessException)); // handle BE if (e instanceof BusinessException) { BusinessException be = (BusinessException) e; System.out.println("processing BE " + be); FacesMessage message = Messages.getMessage( "com.corejsf.errors", be.getMessage(), be.getParamValues() ); FacesContext context = FacesContext.getCurrentInstance(); context.addMessage(null, message); it.remove(); // remove the exception // works fine without this block, if BE is thrown, always return to the original page /* NavigationHandler navigationHandler = context.getApplication().getNavigationHandler(); System.out.println("navigating to " + context.getViewRoot().getViewId()); navigationHandler.handleNavigation(context, context.getViewRoot().getViewId(), null); */ } } } @Override public void beforePhase(PhaseEvent phaseEvent) { } @Override public PhaseId getPhaseId() { return PhaseId.INVOKE_APPLICATION; } } Thank you ! Regards, Albert Kam
