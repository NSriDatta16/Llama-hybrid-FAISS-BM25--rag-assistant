[site]: stackoverflow
[post_id]: 1114114
[parent_id]: 1072790
[tags]: 
You need to have the opengl projection and modelview matrices. Multiply them to gain the modelview projection matrix. Invert this matrix to get a matrix that transforms clip space coordinates into world coordinates. Transform your touch point so it corresponds to clip coordinates: the center of the screen should be zero, while the edges should be +1/-1 for X and Y respectively. construct two points, one at (0,0,0) and one at (touch_x,touch_y,-1) and transform both by the inverse modelview projection matrix. Do the inverse of a perspective divide. You should get two points describing a line from the center of the camera into "the far distance" (the farplane). Do picking based on simplified bounding boxes of your models. You should be able to find ray/box intersection algorithms aplenty on the web. Another solution is to paint each of the models in a slightly different color into an offscreen buffer and reading the color at the touch point from there, telling you which brich was touched. Here's source for a cursor I wrote for a little project using bullet physics: float x=((float)mpos.x/screensize.x)*2.0f -1.0f; float y=((float)mpos.y/screensize.y)*-2.0f +1.0f; p2=renderer->camera.unProject(vec4(x,y,1.0f,1)); p2/=p2.w; vec4 pos=activecam.GetView().col_t; p1=pos+(((vec3)p2 - (vec3)pos) / 2048.0f * 0.1f); p1.w=1.0f; btCollisionWorld::ClosestRayResultCallback rayCallback(btVector3(p1.x,p1.y,p1.z),btVector3(p2.x,p2.y,p2.z)); game.dynamicsWorld->rayTest(btVector3(p1.x,p1.y,p1.z),btVector3(p2.x,p2.y,p2.z), rayCallback); if (rayCallback.hasHit()) { btRigidBody* body = btRigidBody::upcast(rayCallback.m_collisionObject); if(body==game.worldBody) { renderer->setHighlight(0); } else if (body) { Entity* ent=(Entity*)body->getUserPointer(); if(ent) { renderer->setHighlight(dynamic_cast (ent)); //cerr getName()
