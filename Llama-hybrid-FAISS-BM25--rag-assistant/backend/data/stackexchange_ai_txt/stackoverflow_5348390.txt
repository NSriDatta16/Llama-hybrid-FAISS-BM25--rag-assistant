[site]: stackoverflow
[post_id]: 5348390
[parent_id]: 5347875
[tags]: 
Looking at DragMove() code using reflector, i've come to this solution: we can write or own DragMove(IntPtr hWnd) , which does not perform button state check, but we must explicitly release mouse capture in MouseDown event handler. public static class Utility { [System.Runtime.InteropServices.DllImport("user32.dll")] private static extern IntPtr SendMessage(IntPtr h, int msg, IntPtr lp, IntPtr wp); public static void DragMove(IntPtr hwnd) { const int WM_SYSCOMMAND = 0x112; const int WM_LBUTTONUP = 0x202; SendMessage(hwnd, WM_SYSCOMMAND, (IntPtr)0xf012, IntPtr.Zero); SendMessage(hwnd, WM_LBUTTONUP, IntPtr.Zero, IntPtr.Zero); } } and change your MouseDown handler just a bit: void form_MouseDown( object sender, MouseEventArgs e ) { if( e.Button == MouseButtons.Left ) { // it is necessary to release mouse capture, so that // WPF window will be able to capture mouse input ((Control)sender).Capture = false; // use helper to acquire window handle var helper = new System.Windows.Interop.WindowInteropHelper( your_window_reference_goes_here); Utility.DragMove(helper.Handle); } } I didn't test it with ActiveX controls, but it works with simple WinForms control, hosted in WindowsFormsControlHost at least on Win7 Ultimate x64.
