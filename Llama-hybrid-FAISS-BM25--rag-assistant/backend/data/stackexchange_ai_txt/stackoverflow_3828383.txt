[site]: stackoverflow
[post_id]: 3828383
[parent_id]: 3828115
[tags]: 
A couple of examples: Regular expressions support grouping. E.g. in Ruby: /my (group)/.match("my group")[1] will output "group". storing something in a group requires an external storage, which a finite automaton does not have. Many languages, e.g. C#, support captures, i.e. that each match will be captured on a stack - for example the pattern (? .)* could perform multiple captures of "." in the same group. Grouping are used for backreferencing as pointed out by the user NullUserException above. Backreferencing requires one or more external stacks with the power of a push-down-automaton (you have to be able to push something on a stack and peek or pop it afterwards. Some engines have the possibility of seperately pushing and popping external stacks and checking whether the stack is empty. In .NET, actually (? test) pushes a stack, while (? ) pops a stack. Some engines like the .NET engine have a balanced grouping concept - where an external stack can be both pushed and popped at the same time. Balanced grouping syntax is (? ) which pops the LASTGROUP and pushes the capture since the LASTGROUP index on the FIRSTGROUP stack. This can actually be used to match infinitely nested constructions which is definitely beyond the power of a finite automaton. Probably other good examples exist :-) If you are further interessted in some of the implementation details of external stacks in combination with Regex's and balanced grouping and thus higher order automata than finite automata, I once wrote two short articles on this (http://www.codeproject.com/KB/recipes/Nested_RegEx_explained.aspx and http://www.codeproject.com/KB/recipes/RegEx_Balanced_Grouping.aspx ). Anyway - finitieness or not - I blieve that the power that this extra stuff brings to the regular languages is great :-) Br. Morten
