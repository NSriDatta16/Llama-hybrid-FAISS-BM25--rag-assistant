[site]: stackoverflow
[post_id]: 3781503
[parent_id]: 1610028
[tags]: 
Unfortunately, I never did end up going this route. Instead, I adapted the CFileDialog to achieve what I wanted, in an XP..Windows 7 compatible way. The crux of the solution is to obtain the IShellBrowser* instance from the common dialog control: // return the IShellBrowser for the common dialog // NOTE: we force CComPtr to create a new AddRef'd copy (since the one that this gives us is synthesized, and hasn't had an AddRef on our behalf) CComPtr GetShellBrowser() const { return (IShellBrowser*)::SendMessage(GetCommonDialogHwnd(), CDM_GETISHELLBROWSER, 0, 0); } In order to do fancier stuff (like figure out what really is selected - what is its true identity regardless of whether the user has hidden file extensions or not) - I use the resulting IShellBrowser*. For example: ////////////////////////////////////////////////////////////////////////// // Get display name of item in file open dialog. Flags tell how. // SHGDN_FORPARSING gets the full path name even when user has // checked `Hide extensions for known file types` in Explorer. // CString CMFCToolboxAdvancedFileDialog::GetDisplayNameOfItem(int nItem) const { // get the item ID of the given item from the list control LPITEMIDLIST pidlAbsolute = GetItemIDListOf(nItem); // no PIDL = no display name if (!pidlAbsolute) return ""; // get the display name of our item from the folder IShellFolder interface CString path = GetDisplayNameOf(pidlAbsolute); // deallocate the PIDL ILFree(pidlAbsolute); // return the pathname return path; } Which calls: // return the ITEMIDLIST for the item at the specified index in the list view (caller is responsible for freeing) LPITEMIDLIST CMFCToolboxAdvancedFileDialog::GetItemIDListOf(UINT nItem) const { // This can only succeed if there is an IShellView currently (which implies there is a list control) CListCtrl * pListCtrl = GetListCtrl(); if (!pListCtrl) return NULL; // Use undocumented method (the pidl is stored in the item data) // NOTE: Much thanks to Paul DiLascia for this technique (worked up until Vista) // http://www.dilascia.com/index.htm if (LPCITEMIDLIST pidlChild = (LPCITEMIDLIST)pListCtrl->GetItemData(nItem)) { // get PIDL of current folder from the common dialog LRESULT len = ::SendMessage(GetCommonDialogHwnd(), CDM_GETFOLDERIDLIST, 0, NULL); if (!len) return NULL; LPCITEMIDLIST pidlFolder = (LPCITEMIDLIST)CoTaskMemAlloc(len); ::SendMessage(GetCommonDialogHwnd(), CDM_GETFOLDERIDLIST, len, (LPARAM)(void*)pidlFolder); // return the absolute ITEMIDLIST return ILCombine(pidlFolder, pidlChild); } // Use another undocumented feature: WM_GETISHELLBROWSER CComPtr pShellBrowser(GetShellBrowser()); if (!pShellBrowser) return NULL; // attempt to get access to the view CComPtr pShellView; if (FAILED(pShellBrowser->QueryActiveShellView(&pShellView))) return NULL; // attempt to get an IDataObject of all items in the view (in view-order) CComPtr pDataObj; if (FAILED(pShellView->GetItemObject(SVGIO_ALLVIEW|SVGIO_FLAG_VIEWORDER, IID_IDataObject, (void**)&pDataObj))) return NULL; // attempt to get the ITEMIDLIST from our clipboard data object const UINT cfFormat = RegisterClipboardFormat(CFSTR_SHELLIDLIST); FORMATETC fmtetc = { cfFormat, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }; ClipboardStorageMedium stgmed; if (FAILED(pDataObj->GetData(&fmtetc, &stgmed))) return NULL; // cast to the actual data requested CIDA * pida = (CIDA*)stgmed.hGlobal; // ensure we have that index ASSERT(pida->cidl > nItem); if (nItem >= pida->cidl) return NULL; // find the data for the item requested const ITEMIDLIST * pidlParent = GetPIDLFolder(pida); const ITEMIDLIST * pidlChild = GetPIDLItem(pida, nItem); // return the absolute PIDL return ILCombine(pidlParent, pidlChild); } Which calls: // NOTE: this is the only way I know to get the actual list control! CListCtrl * GetListCtrl() const { // return &GetListView()->GetListCtrl(); // we have to be a window to answer such a question ASSERT(IsWindow(GetCommonDialogHwnd())); HWND hwnd = ::GetDlgItem(GetCommonDialogHwnd(), IDC_FILE_LIST_VIEW); if (hwnd) return static_cast (CListCtrl::FromHandle(::GetWindow(hwnd, GW_CHILD))); return NULL; } Well, hopefully that gives you the idea, and you can go from here. G/L! ;)
