[site]: crossvalidated
[post_id]: 514058
[parent_id]: 514045
[tags]: 
There is a recursive algorithm that succeeds (outputs heads) with probability $1/\Phi$ . It takes advantage of the fact that the continued fraction representation of $\Phi$ has all ones. The algorithm follows: Procedure OnePhi(): Returns 1 with probability $1/\Phi.$ Do the following steps repeatedly, until the algorithm returns a number: Set C = RandomBit() (the flip of a fair coin that shows 1 or 0 with equal probability). If C = 1, return 1 and stop. Set D = OnePhi(). If D = 1, return 0 and stop. The expected number of flips used by the algorithm, $\mathbb{E}[N]$ , is $2\Phi$ as shown below, taking note that all the flips are independent: Each iteration stops the algorithm with probability $p = \frac{1}{2} + (1-\frac{1}{2}) * (1/\Phi)$ (1/2 for step 2 and $1/\Phi$ for step 4). Thus, the expected number of iterations is $\mathbb{E}[T] = 1/p$ by a well-known rejection sampling argument, since the algorithm doesn't depend on iteration counts. Each iteration has $1 * \frac{1}{2} + (1 + \mathbb{E}[N]) * \frac{1}{2}$ coin flips on average, so the whole algorithm has $\mathbb{E}[N] = (1 * \frac{1}{2} + (1 + \mathbb{E}[N]) * \frac{1}{2}) * \mathbb{E}[T]$ coin flips on average. This equation has the solution $\mathbb{E}[N] = 1 + \sqrt{5} = 2\Phi$ . And on average, because the coin is fair, half of these flips ( $\Phi$ ) show 1 and half show 0. The following Python code shows this: import random def onephi(flips): # Flips stores counts on the number of times # the coin was flipped and the number of tails. # Flips is not essential to the algorithm and # can be omitted. done=-1 while done==-1: flips[0]+=1 if random.random()
