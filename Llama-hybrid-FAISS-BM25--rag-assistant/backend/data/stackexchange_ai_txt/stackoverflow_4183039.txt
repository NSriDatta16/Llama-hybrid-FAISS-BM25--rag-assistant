[site]: stackoverflow
[post_id]: 4183039
[parent_id]: 
[tags]: 
Django admin widget for custom-sorted relationship

I need some help at designing a model and widget for a custom-sorted M2M relationship. The typical application scenario would be books and authors. In particular, when the order of authors in a book does matter. The current version of my Publication model is: class Publication(models.Model): """ A scientific publication. """ class Meta: verbose_name = _('Publication') verbose_name_plural = _('Publications') ordering = ['year',] nickname = models.CharField( max_length=16, help_text=_( 'A mnemonic name that "idenfies" this publication.'\ ' E.g., concept_drift. (lowcase letters and dashes only)'), validators=[RegexValidator(regex=r'^[a-z]+(_[a-z]+)*$')]) title = models.CharField( _('Title'), max_length=1024) year = models.CharField( max_length=4, choices=YEARS, help_text=_('Year of publication'), db_index=True) month = models.PositiveSmallIntegerField( choices=MONTHS, db_index=True, null=True, blank=True) authors = models.ManyToManyField( Person, related_name='publications', blank=True, null=True) attachment = FileBrowseField( _('Attachment'), max_length=256, format='File', blank=True, null=True) notes = models.CharField( _('Notes'), max_length=512, help_text=_('Notes, e.g., about the conference or the journal.'), blank=True, null=True) bibtex = models.TextField( verbose_name=_('BibTeX Entry'), help_text=_('At this moment, the BibTeX is not parsed for content.'), blank=True, null=True) abstract = models.TextField( _('Abstract'), blank=True, null=True) fulltext = FileBrowseField( _('Fulltext'), max_length=256, format='Document', blank=True, null=True) date_updated = models.DateField( _('Last updated on'), auto_now=True, db_index=True) citation_key = models.SlugField( max_length=512, editable=False, db_index=True) @models.permalink def get_absolute_url(self): return ('academic_publishing_publication', (), { 'object_id': self.id }) def __unicode__(self): return u'%s %s' % ( self.title, self.year) and authors are of People class: class Person(models.Model): """ A person in a research lab. """ class Meta: verbose_name = _('Person') verbose_name_plural = _('People') ordering = [ 'rank', 'last_name', 'first_name', ] affiliation = models.ManyToManyField( Organization, blank=True, null=True, related_name='people') public = models.BooleanField( verbose_name=_('Public?'), help_text=_('Toggle visibility on public pages.'), default=False) current = models.BooleanField( help_text=_('Is he/she still in the group?'), default=True) rank = models.ForeignKey( Rank, verbose_name=_('Academic Rank'), related_name='people', blank=True, null=True) first_name = models.CharField( _('First Name'), max_length=64) mid_name = models.CharField( blank=True, null=True, max_length=64) last_name = models.CharField( _('Last Name'), max_length=64) e_mail = models.EmailField( _('E-mail'), blank=True, null=True) web_page = models.URLField( _('Web page'), blank=True, null=True) description = models.TextField( _('Description'), blank=True, null=True) picture = FileBrowseField( _('Profile picture'), max_length=200, format='Image', blank=True, null=True) @models.permalink def get_absolute_url(self): return ('academic_people_person_detail', (), {'object_id': self.pk}) def __unicode__(self): return u'%s' % self.name def _get_name(self): return u'%s %s' % (self.first_name, self.last_name) name = property(_get_name) I have two possibilities for storing the order of authors for each publication: 1. Explicit: make a AuthorForPublication model class AuthorForPublication(models.Model): author = ForeignKey(Person) order = SmallPositiveInteger() publication = ForeignKey(Publication) but then a question arise: is it feasible to make an easy to use admin widget into Publication? 2. Workaround: create an authors_order field in Publication that takes a list of pk s with a widget that lets the user re-order the authors. But this sounds a bit tricky. Other alternatives certainly exist and are suggestions are appreciated.
