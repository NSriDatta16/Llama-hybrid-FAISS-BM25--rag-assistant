[site]: stackoverflow
[post_id]: 2515714
[parent_id]: 2515611
[tags]: 
Very simple, your business entities should include a section to store Business Validation (that is business logic). This will then work whether you are designing a web based app, a client based app, a mobile app, etc. Very flexible. Suppose you have a business object (an entity) like a customer: public class Customer { public Customer(int customerId, string company, string city, string country) { CustomerId = customerId; Company = company; City = city; Country = country; } } You then realize that you want your business logic to state that you validate a customerID (in addition it is > 0), you require a company name (without one the customer is not valid), etc etc. These validations are your business logic layer. So you can change your customer class to inherit from say a BusinessObject layer, so your class becomes this: public class Customer : BusinessObject { /// /// Default constructor for customer class. /// Initializes automatic properties. /// public Customer() { // Default property values Orders = new List (); // Business rules AddRule(new ValidateId("CustomerId")); AddRule(new ValidateRequired("Company")); AddRule(new ValidateLength("Company", 1, 40)); } /// /// Overloaded constructor for the Customer class. /// /// Unique Identifier for the Customer. /// Name of the Customer. /// City where Customer is located. /// Country where Customer is located. public Customer(int customerId, string company, string city, string country) : this() { CustomerId = customerId; Company = company; City = city; Country = country; } //much more code like methods... } You do not want objects of BusinessObject type but what businessobject serves as is an abstract class that stores validation errors and business rules. A business rule is ultimately the rules you stated when you called AddRule: public abstract class BusinessObject { /// /// Default value for version number (used in LINQ's optimistic concurrency) /// protected static readonly string _versionDefault = "NotSet"; // List of business rules private IList _businessRules = new List (); // List of validation errors (following validation failure) private IList _validationErrors = new List (); /// /// Gets list of validations errors. /// public IList ValidationErrors { get { return _validationErrors; } } /// /// Adds a business rule to the business object. /// /// protected void AddRule(BusinessRule rule) { _businessRules.Add(rule); } /// /// Determines whether business rules are valid or not. /// Creates a list of validation errors when appropriate. /// /// public bool Validate() { bool isValid = true; _validationErrors.Clear(); foreach (BusinessRule rule in _businessRules) { if (!rule.Validate(this)) { isValid = false; _validationErrors.Add(rule.ErrorMessage); } } return isValid; } } Each business rule such as validateid, validaterequired, and validatelength need to be implemented: public class ValidateId : BusinessRule { public ValidateId(string propertyName) : base(propertyName) { ErrorMessage = propertyName + " is an invalid identifier"; } public ValidateId(string propertyName, string errorMessage) : base(propertyName) { ErrorMessage = errorMessage; } public override bool Validate(BusinessObject businessObject) { try { int id = int.Parse(GetPropertyValue(businessObject).ToString()); return id >= 0; } catch { return false; } } public class ValidateLength : BusinessRule { private int _min; private int _max; public ValidateLength(string propertyName, int min, int max) : base(propertyName) { _min = min; _max = max; ErrorMessage = propertyName + " must be between " + _min + " and " + _max + " characters long."; } public ValidateLength(string propertyName, string errorMessage, int min, int max) : this(propertyName, min, max) { ErrorMessage = errorMessage; } public override bool Validate(BusinessObject businessObject) { int length = GetPropertyValue(businessObject).ToString().Length; return length >= _min && length Those are just two samples of validatelength, and validateid, you can come up with validaterequired (check if the value exists). They both implement a business rule class: public abstract class BusinessRule { public string PropertyName { get; set; } public string ErrorMessage { get; set; } /// /// Constructor /// /// The property name to which rule applies. public BusinessRule(string propertyName) { PropertyName = propertyName; ErrorMessage = propertyName + " is not valid"; } /// /// Overloaded constructor /// /// The property name to which rule applies. /// The error message. public BusinessRule(string propertyName, string errorMessage) : this(propertyName) { ErrorMessage = errorMessage; } /// /// Validation method. To be implemented in derived classes. /// /// /// public abstract bool Validate(BusinessObject businessObject); /// /// Gets value for given business object's property using reflection. /// /// /// /// protected object GetPropertyValue(BusinessObject businessObject) { return businessObject.GetType().GetProperty(PropertyName).GetValue(businessObject, null); } } So your businessobject class just keeps a list of required business rules and the validation errors it catches. The business rule class simply stores the property name and an error message in case a rule is not correctly applied. It also contains an abstract validate() method which is defined for each validation class. It differs for each validation class because validating an id is different then validation a required field. The gang of four website has a lot of good help regarding this. Much of this code is taken from their models.
