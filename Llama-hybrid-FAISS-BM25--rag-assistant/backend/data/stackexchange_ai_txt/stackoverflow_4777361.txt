[site]: stackoverflow
[post_id]: 4777361
[parent_id]: 
[tags]: 
Observer and Decorator used together c++ *REVISED*

I have a program thats a coffee house that does beverage as a decorator / wrapper... I also have a observer and i am trying to tie that in with beverage. so, when the order is placed cellphone one is notified. I dont know how to do the update.. if i pass TheOrder class i get errors! beverage.h #ifndef _BEVERAGE_ #define _BEVERAGE_ #include "Starbuzz.h" namespace CoffeeHouse { namespace Decorator { //namespace Observer { //using namespace std; class Beverage { protected: std::string _description; protected: Beverage() : _description( "Unknown Beverage" ) { } public: virtual ~Beverage() = 0 { } public: virtual std::string getDescription() const { return _description; } public: virtual double cost() const = 0; }; } // namespace Observer } // namespace CoffeeHouse //} #endif one of the beverage concrete classes - i have 4 (espresso,houseblend,darkroast,decaf) #ifndef _DARK_ROAST_ #define _DARK_ROAST_ #include "Starbuzz.h" namespace CoffeeHouse { namespace Decorator { //namespace Observer { class DarkRoast : public Beverage { public: DarkRoast() { _description = "Dark Roast Coffee"; } public: double cost() const { return 0.99; } }; } // namespace Observer } #endif beverage decorator #ifndef _BEVERAGE_DECORATOR_ #define _BEVERAGE_DECORATOR_ #include "Starbuzz.h" namespace CoffeeHouse { namespace Decorator { class BeverageDecorator : public Beverage { private: BeverageDecorator( const BeverageDecorator& ); // Disable copy constructor private: void operator=( const BeverageDecorator& ); // Disable assignment operator protected: BeverageDecorator() { } public: virtual ~BeverageDecorator() = 0 { }; public: virtual std::string getDescription() const = 0; }; //} } // namespace Observer } // namespace CoffeeHouse #endif Here is the observer implementation.. Subject class #ifndef _SUBJECT_ #define _SUBJECT_ #include "Observer.h" #include namespace CoffeeHouse { namespace Observers { class Subject { protected: virtual ~Subject() = 0 { }; public: virtual void registerObserver( Observer* o ) = 0; public: virtual void removeObserver( Observer* o ) = 0; public: virtual void notifyObservers() = 0; }; } // namespace Observer } #endif here is the subject concrete class.. #ifndef _THE_ORDER_ #define _THE_ORDER_ #include "Beverage.h" #include #include #include "Order.h" #pragma once; using namespace CoffeeHouse::Decorator; namespace CoffeeHouse { namespace Observers { class TheOrder : public Subject { private: mutable std::list _observers; //private: mutable std::list _orders; //public: virtual ~Order() = 0 //public: ~TheOrder(); public: void NewOrder(Beverage* bev) { _orders.push_front(new Order(bev)); //_observers.push_front(new Order(bev)); } public: void registerObserver( Observer* o ) { assert( o ); _observers.push_back(o); } public: void removeObserver( Observer* o ) { assert( o ); _observers.remove(o); } public: void notifyObservers() { for( std::list ::iterator iterator = _observers.begin(); _observers.end() != iterator; ++iterator ) { Observer* observer = *iterator; observer->update(); } } }; //} } // namespace Observer } // namespace CoffeeHouse #endif here is cellphone1 which is the observer #ifndef _CELLPHONE1_ #define _CELLPHONE1_ #include using namespace std; namespace CoffeeHouse { namespace Observers { class CellPhone1: public Observer { public: std::string _number; CellPhone1(std::string number){ _number = number; } void update() { std::cout here is main() #include "Starbuzz.h" #include "Starbuzz2.h" #include "Subject.h" #include "TheOrder.h" #include "CellPhone2.h" #include "CellPhone3.h" #include "CellPhone1.h" using namespace CoffeeHouse::Decorator; using namespace CoffeeHouse::Observers; int main( int argc, char* argv[] ) { Beverage* beverage3 = new HouseBlend(); beverage3 = new Soy(beverage3); beverage3 = new Mocha(beverage3); beverage3 = new Whip(beverage3); std::cout getDescription() cost() registerObserver(obj); orders->notifyObservers(); Beverage* beverage6 = new DarkRoast(); orders->NewOrder(new Mocha(new Soy(new Whip((beverage6))))); return 0; } here is the order class #ifndef _ORDER_ #define _ORDER_ #include #include "Beverage.h" namespace CoffeeHouse { namespace Decorator { class Order { Beverage* _beverage; public: Order(Beverage* beverage) { _beverage = beverage; } }; } } #endif So, now i just need to do an update. what would i need to pass in update()? i would like to pass in the order in update so cellphone can display the order. If try to pass in The order class i have to include "theorder.h" and then i get a zillion errors.
