[site]: stackoverflow
[post_id]: 3703527
[parent_id]: 
[tags]: 
NHibernate: Querying with OR operator

I am looking for a way to build an OR operator into a query to look for a particular value in one field of a table as well as in another field of a joined table. This is pretty basic in SQL, but I can't for the world figure out how to do this in NHibernate. I have been searching the web, but the examples I find are pretty nebulous to me and I find them hard to apply to my particular implementation. I have an class called Party, with a string-field called reference, which is the main reference. New requirements demanded the option to also being able to add a lot of side-references to a party. So I had to add another class called PartyReference that has a many-to-one relationship to Party. Now with a given reference I have to look its value up in both this main reference field as well as among the side references. But as long as I cannot figure out to say to NHibernate that EITHER this field must correspond to the value OR one of the others, I cannot make it work. I have made a workaround that looks like this, but it is inelegant and stupid, as there has to be way to say "OR": public Party GetPartyOnAnyReference(string reference) { Party party; ISession session = Factory.OpenSession(); ITransaction tx = session.BeginTransaction(); try { //first search on main reference ICriteria criteria1 = session.CreateCriteria(typeof(Party)); criteria1.Add(Restrictions.Eq("Reference", reference)); IList parties1 = criteria1.List (); party = parties1.Count > 0 ? parties1[0] : null; //then try with side-references if (party == null) { ICriteria criteria2 = session.CreateCriteria(typeof(Party)); criteria2 .SetFetchMode("References", FetchMode.Eager) .CreateCriteria("References") .Add(Expression.Eq("Reference", reference)); IList parties2 = criteria2.List (); party = parties2.Count > 0 ? parties2[0] : null; } session.Close(); } catch (Exception e) { tx.Rollback(); session.Close(); if (e.GetType().ToString() == "NHibernate.ObjectNotFoundException") party = null; else throw; } return party; } I of course realize I can also solve this issue by simply removing the main reference from the Party class alltogether and treat it on par with the other references, as a PartyReference. But at some stage I will have to use an OR query with NHibernate anyway, so I might just as well solve it now with this particular case. Any ideas?
