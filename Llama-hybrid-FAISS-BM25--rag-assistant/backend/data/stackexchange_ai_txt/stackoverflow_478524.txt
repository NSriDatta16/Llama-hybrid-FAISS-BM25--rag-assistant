[site]: stackoverflow
[post_id]: 478524
[parent_id]: 478296
[tags]: 
Short answer is yes, you can change the discriminator value for the particular row(s) using native SQL . However, I don't think NHibernate is intended to work this way, since the discriminator is generally "invisible" to the Java layer, where its value is supposed to be set initially according to the class of the persisted object and never changed. I recommend looking into a cleaner approach. From the standpoint of the object model, you're trying to convert a superclass object into one of its subclass types while not changing the identity of its persisted instance, and that's where the conflict is (the converted object isn't really supposed to be the same thing). Two alternative approaches are: Create a new instance of TierOneCustomer based on the information in the original Customer object, then delete the original object. If you were relying on the Customer's Primary Key for retrieval, you'll need to take note of the new PK. or Change your approach so the object type (discriminator) doesn't need to change. Instead of relying on a subclass to distinguish TierOneCustomer from Customer, you can use a property that you can modify freely at any time, i.e. Customer.Tier = 1. Here are some related discussions on the Hibernate Forums that may be of interest: Can we update the discriminator column in Hibernate Table-per-Class Problem: Discriminator and Property Converting a persisted instance into a subclass
