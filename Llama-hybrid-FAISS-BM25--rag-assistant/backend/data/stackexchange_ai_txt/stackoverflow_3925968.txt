[site]: stackoverflow
[post_id]: 3925968
[parent_id]: 3920729
[tags]: 
The rule for C is as follows: 6.3.2.1 Lvalues, arrays, and function designators ... 3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined. The language for C++ is a little different: 4.2 Array-to-pointer conversion [conv.array] 1 An lvalue or rvalue of type “array of N T” or “array of unknown bound of T” can be converted to an rvalue of type “pointer to T”. The result is a pointer to the first element of the array. ... 8.3.4 Arrays [dcl.array] ... 7 A consistent rule is followed for multidimensional arrays. If E is an n-dimensional array of rank i × j × ... × k , then E appearing in an expression is converted to a pointer to an ( n −1)-dimensional array with rank j × ... × k . If the * operator, either explicitly or implicitly as a result of subscripting, is applied to this pointer, the result is the pointed-to ( n −1)-dimensional array, which itself is immediately converted into a pointer. So the following all hold true: Declaration Expression Type Decays to ----------- ---------- ---- --------- T a[N] a T [N] T * &a T (*)[N] *a T a[i] T T a[M][N] a T [M][N] T (*)[N] &a T (*)[M][N] *a T [N] T * a[i] T [N] T * &a[i] T (*)[N] *a[i] T a[i][j] T T a[M][N][O] a T [M][N][O] T (*)[M][N] &a T (*)[M][N][O] *a T [M][N] T (*)[N] a[i] T [M][N] T (*)[N] &a[i] T (*)[M][N] *a[i] T [N] T * a[i][j] T [N] T * &a[i][j] T (*)[N] *a[i][j] T a[i][j][k] T The pattern should be clear for higher-dimensional arrays. So let's analyze your dictionary: /* list of words and meanings */ char *dic[][40] = { "atlas", "A volume of maps.", "car", "A motorized vehicle.", "telephone", "A communication device.", "airplane", "A flying machine.", "", "" /* null terminate the list */ }; This isn't going to set up your dictionary the way you want; you've basically set this up as a 1-element array of 40 pointers to char. If you want an array of pairs of strings, then the declaration should look like this: char *dic[][2] = { {"atlas", "A volume of maps"}, {"car", "A motorized vehicle"}, {"telephone", "A communication device"}, {"airplane" , "A flying machine"}, {NULL, NULL} // empty strings and NULLs are different things. }; The type of dic is "5-element array of 2-element arrays of pointer to char", or char *[5][2] . Going by the rules above, the expression dic should decay to char *(*)[2] -- a pointer to a 2-element array of pointer to char. A function to search this dictionary would then look like this: char *definition(char *term, char *(*dictionary)[2]) // *NOT* char ***dictionary { while ((*dictionary)[0] != NULL && strcmp((*dictionary)[0], term) != 0) dictionary++; return (*dictionary)[1]; } and you would call it from your main function like char *def = definition(term, dic); Note that we have to use parentheses around the *dictionary expression in the function. The array subscript operator [] has higher precedence than the dereference operator * , and we don't want to subscript into dictionary directly, we want to subscript into the array that dictionary points to .
