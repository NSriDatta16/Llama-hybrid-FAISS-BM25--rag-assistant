[site]: stackoverflow
[post_id]: 1813543
[parent_id]: 1813483
[tags]: 
Edit: Equivalent, but more robust algorithm (and simpler): divide angles into 2 groups, [0-180) and [180-360) numerically average both groups average the 2 group averages with proper weighting if wraparound occurred, correct by 180Ëš This works because number averaging works "logically" if all the angles are in the same hemicircle. We then delay getting wraparound error until the very last step, where it is easily detected and corrected. I also threw in some code for handling opposite angle cases. If the averages are opposite we favor the hemisphere that had more angles in it, and in the case of equal angles in both hemispheres we return None because no average would make sense. The new code: def averageAngles2(angles): newAngles = [a % 360 for a in angles]; smallAngles = [] largeAngles = [] # split the angles into 2 groups: [0-180) and [180-360) for angle in newAngles: if angle smallAverage + 180: # average will hit wraparound, so will be off by 180 degrees return (average + 180) % 360 else: # opposite angles: return whichever has more weight if smallCount > largeCount: return smallAverage elif smallCount >>> averageAngles2([0, 0, 90]) 30.0 >>> averageAngles2([30, 350]) 10.0 >>> averageAngles2([0, 200]) 280.0 Here's a slightly naive algorithm: remove all oposite angles from the list take a pair of angles rotate them to the first and second quadrant and average them rotate average angle back by same amount for each remaining angle, average in same way, but with successively increasing weight to the composite angle some python code (step 1 not implemented) def averageAngles(angles): newAngles = [a % 360 for a in angles]; average = 0 weight = 0 for ang in newAngles: theta = 0 if 0
