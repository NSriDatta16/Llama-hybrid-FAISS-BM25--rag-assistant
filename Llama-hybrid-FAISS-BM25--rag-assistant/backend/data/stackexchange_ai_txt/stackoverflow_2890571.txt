[site]: stackoverflow
[post_id]: 2890571
[parent_id]: 2890438
[tags]: 
That C code you linked to would have been awfully helpful to include in the question ;-) Anyway, I went ahead and translated it into Python. Before you read it, let me say that I highly encourage you to try it yourself and only use my transcription as a guide. Translating algorithms from one programming language to another is generally great practice when you want to boost your skills in one or both languages. Even if you don't know C, as long as you're familiar enough with Python to write programs in it, you should be able to get the gist of the C code, since there are many similarities. Anyway, on to the code. import itertools, operator First, the pseudorandom number generator, which was identified in the presentation as a linear congruential generator . This type of PRNG is a general algorithm which can be "customized" by choosing specific values of a , c , and m (the variables mentioned in the Wikipedia article). Here is an implementation of a generic linear congruential generator: def prng(x, a, c, m): while True: x = (a * x + c) % m yield x (hopefully you could have come up with that on your own) Now for the actual function: def pass_to_key(passphrase): The first step in the process is to hash (or "map") the passphrase provided to a 32-bit number. The WEP algorithm does this by creating a set of 4 bytes (thus 4*8=32 bits) which are initialized to zero. bits = [0,0,0,0] It goes through the string and XORs each character with one of the bytes; specifically, character i is XOR'd into byte i % 4 . for i, c in enumerate(passphrase): bits[i & 3] ^= ord(c) These four bytes are then concatenated together, in order, to form a single 32-bit value. (Alternatively, I could have written the code to store them as a 32-bit number from the beginning) val = reduce(operator.__or__, (b This 32-bit value is used as the seed for a linear congruential generator with certain specific values which you can see in the code. How the original developer figured out these numbers, I have no idea. keys = [] The linear congruential generator can produce up to 32 bits of output at a time. (In C this is a limitation of the data type; in Python I had to artificially enforce it.) I need 20 bytes to generate 4 40-bit (5-byte) WEP keys, so I'll iterate the PRNG 20 times, for i, b in enumerate(itertools.islice(prng(val, 0x343fd, 0x269ec3, 1 and from each number, take only the 3rd byte from the right (bits 16-23): keys.append((b >> 16) & 0xff) Why the third? Well, the bits at the high end (4th from the right) tend not to change much, and those at the low end can be predictable for many values of the PRNG constants. Afterwards, all that's left is to print out the generated bytes in groups of 5. print ('%02x:%02x:%02x:%02x:%02x\n'*4) % tuple(keys)
