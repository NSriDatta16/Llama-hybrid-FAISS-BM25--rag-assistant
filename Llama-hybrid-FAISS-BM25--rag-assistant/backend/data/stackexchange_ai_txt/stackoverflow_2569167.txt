[site]: stackoverflow
[post_id]: 2569167
[parent_id]: 247800
[tags]: 
Hmmm, I think one elegant solution would be the following: //* AutogenCls.cs file //* Let say the file is auto-generated ==> it will be overridden each time when //* auto-generation will be triggered. //* //* Auto-generated class, let say via xsd.exe //* partial class AutogenCls { public AutogenCls(...) { } } //* AutogenCls_Cunstomization.cs file //* The file keeps customization code completely separated from //* auto-generated AutogenCls.cs file. //* partial class AutogenCls { //* The following line ensures execution at the construction time MyCustomization m_MyCustomizationInstance = new MyCustomization (); //* The following inner&private implementation class implements customization. class MyCustomization { MyCustomization () { //* IMPLEMENT HERE WHATEVER YOU WANT TO EXECUTE DURING CONSTRUCTION TIME } } } This approach has some drawbacks (as everything): It is not clear when exactly will be executed the constructor of the MyCustomization inner class during whole construction procedure of the AutogenCls class. If there will be necessary to implement IDiposable interface for the MyCustomization class to correctly handle disposing of unmanaged resources of the MyCustomization class, I don't know (yet) how to trigger the MyCustomization.Dispose() method without touching the AutogenCls.cs file ... (but as I told 'yet' :) But this approach offers great separation from auto-generated code - whole customization is separated in different src code file. enjoy :)
