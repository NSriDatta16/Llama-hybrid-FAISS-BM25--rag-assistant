[site]: stackoverflow
[post_id]: 2363613
[parent_id]: 2357024
[tags]: 
Yes, my question is very vague. My program is a graphical statistics app, it has to display Gantt chart, by means of TChart, describing the states, alarms or machined orders of one or more Tool Machine. On the supervisor PC a server (equipped with a TIdTcpServer and some DB components) is listening to my app on the LAN. The main-form client allows the final user to choice a range of dates (period) and the units (machines) to query the server. After that, the user press a button (there are 3 functionalities): a new form (and Datamodule) is created to display the results. The work of collecting data is completed by a thread because: 1) it can be a long job so it could freeze the GUI; 2) the user can launch more than one form to see various results. I have a basic Datamodule (with a TIdTcpClient with several function to collect the data), a basic form (never instantiated, with a lot of characteristics common to all data form, and the definition of the worker thread). unit dtmPDoxClientU; TdtmPDoxClient = class(TDataModule) IdTCPClient: TIdTCPClient; ... function GetData(...): boolean; ... end; unit frmChartBaseFormU; TfrmChartBaseForm = class(TForm) ... TheThread: TThreadClient; procedure WMThreadComm(var Message: TMessage); message WM_THREADCOMM; procedure ListenThreadEvents(var Message: TMessage); virtual; procedure ExecuteInThread(AThread: TThreadClient); virtual; end; TThreadClient = class(TThread) private public Task: integer; Module: TfrmChartBaseForm; procedure Execute; override; property Terminated; end; procedure TfrmChartBaseForm.FormCreate(Sender: TObject); ... TheThread := TThreadClient.Create(true); with TheThread do begin Module := self; FreeOnTerminate := true; end;//with end;//FormCreate procedure TfrmChartBaseForm.WMThreadComm(var Message: TMessage); begin ListenThreadEvents(Message); end;//WMThreadComm procedure TfrmChartBaseForm.ListenThreadEvents(var Message: TMessage); begin // do override in derived classes end;//ListenThreadEvents procedure TfrmChartBaseForm.ExecuteInThread(AThread: TThreadClient); begin // do override in derived classes end;//ExecuteInThread procedure TThreadClient.Execute; begin with Module do begin ExecuteInThread(self); end;//with end;//Execute Furthermore, using VFI, I also have two units: unit dtmPDoxClientDataOIU; TdtmPDoxClientDataOI = class(TdtmPDoxClient) cdsClient_IS: TClientDataSet; ... dsr_I: TDataSource; ... private public end; unit frmPDoxClientDataOIU; TfrmPDoxClientDataOI = class(TfrmChartBaseForm) ChartOI: TChart; ... procedure FormCreate(Sender: TObject); public { Public declarations } dtmPDoxClientDataOI: TdtmPDoxClientDataOI; procedure ListenThreadEvents(var Message: TMessage); override; procedure ExecuteInThread(AThread: TThreadClient); override; end; procedure TfrmPDoxClientDataOI.FormCreate(Sender: TObject); begin inherited; dtmPDoxClientDataOI := TdtmPDoxClientDataOI.Create(self); TheThread.Task := 1; TheThread.Resume; end;//FormCreate procedure TfrmPDoxClientDataOI.ListenThreadEvents(var Message: TMessage); begin if (Message.WParam = 1) then begin case Message.LParam of //GUI tasks, using ClientDataset already compiled and not re-used end;//case end;//if end;//ListenThreadEvents procedure TfrmPDoxClientDataOI.ExecuteInThread(AThread: TThreadClient); begin while not AThread.Terminated and (AThread.Task <> 0) do begin case AThread.Task of 1: begin if dtmPDoxClientDataOI.GetData(...) then if not AThread.Terminated then begin PostMessage(Handle,WM_THREADCOMM,1,1); AThread.Task := 2; end //if else AThread.Task := 0; end;//1 ... etc... end;//case end;//while end;//ExecuteInThread So, when the final user presses the button, a new form and its own datamodule and thread are created; the thread uses its own datamodule by means of ExecuteInThread function. When data are ready, a PostMessage is sent to the form, which updates the chart.
