[site]: stackoverflow
[post_id]: 519502
[parent_id]: 484511
[tags]: 
This is how you'd do it with the base class library in .net 3.5: The call to SetMinThreads is optional - see what happens with & without it. You should handle timeouts within your replacement to DoSomethingThatsSlow public class ThrottledParallelRunnerTest { public static void Main() { //since the process is just starting up, we need to boost this ThreadPool.SetMinThreads(10, 10); IEnumerable args = from i in Enumerable.Range(1, 100) select "task #" + i; ThrottledParallelRun(DoSomethingThatsSlow, args, 8); } public static void DoSomethingThatsSlow(string urlOrWhatever) { Console.Out.WriteLine("{1}: began {0}", urlOrWhatever, DateTime.Now.Ticks); Thread.Sleep(500); Console.Out.WriteLine("{1}: ended {0}", urlOrWhatever, DateTime.Now.Ticks); } private static void ThrottledParallelRun (Action action, IEnumerable args, int maxThreads) { //this thing looks after the throttling Semaphore semaphore = new Semaphore(maxThreads, maxThreads); //wrap the action in a try/finally that releases the semaphore Action releasingAction = a => { try { action(a); } finally { semaphore.Release(); } }; //store all the IAsyncResult - will help prevent method from returning before completion List results = new List (); foreach (T a in args) { semaphore.WaitOne(); results.Add(releasingAction.BeginInvoke(a, null, null)); } //now let's make sure everything's returned. Maybe collate exceptions here? foreach (IAsyncResult result in results) { releasingAction.EndInvoke(result); } } }
