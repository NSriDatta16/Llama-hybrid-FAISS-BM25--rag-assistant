[site]: stackoverflow
[post_id]: 661004
[parent_id]: 659915
[tags]: 
Steve, your proposed code has a bunch of problems with synchronization. (Antonio's does as well). To summarize: You need to cache an expensive object. You need to make sure that while one thread is doing the retrieval, another thread does not also attempt to retrieve the same object. That for n-threads all attempting to get the object only 1 object is ever retrieved and returned. That for threads requesting different objects that they do not contend with each other. pseudo code to make this happen (using a ConcurrentHashMap as the cache): ConcurrentMap > cache = new ConcurrentHashMap >; public Page getPage(Integer id) { Future myFuture = new Future (); cache.putIfAbsent(id, myFuture); Future actualFuture = cache.get(id); if ( actualFuture == myFuture ) { // I am the first w00t! Page page = getFromDataBase(id); myFuture.set(page); } return actualFuture.get(); } Note: java.util.concurrent.Future is an interface java.util.concurrent.Future does not actually have a set() but look at the existing classes that implement Future to understand how to implement your own Future (Or use FutureTask) Pushing the actual retrieval to a worker thread will almost certainly be a good idea.
