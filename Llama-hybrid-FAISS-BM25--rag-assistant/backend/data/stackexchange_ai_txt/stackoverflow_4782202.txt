[site]: stackoverflow
[post_id]: 4782202
[parent_id]: 
[tags]: 
Cocos2D crashes with a Zombie when I try to stop it in the middle of an animation

I'm trying to get Cocos2D on the iPhone to "clean itself up" before I switch back to a UIView-based view in my iPhone app, but it's overreleasing (or, I am overreleasing) something and crashing, and I can't make heads or tails of it. This is somewhat long, but I've tried to take care to organize it. My node hierarchy looks like this, and the parenthesis indicate "what's in" each node: CCScene (Menu) CCLayer (Character) CCLayer (Whole Animation) CCSprite, CCSpriteBatchNode (Parts of Animation, there can be many of each type) So, as the "Character" runs different animations, I remove the "animation" CCLayer from the "character" CCLayer, create a new "animation" CCLayer, and add it as a child. So far, that's caused no problems. Finally, there's a button on CCScene that "ends" the Cocos part of the app. I want to return to UIKit-land when I tap the "End" button. However, before I return back to UIView-land, I want to run one final animation on the Character, and when THAT is finished, terminate. To do that, I "register" a handler on the character CCLayer like this. I call the "final" animation, and then callback to the CCScene when the final animation is done (using KVO): - (void) doEndWithHandler:(id )handler { // Handler is the CCScene, "self.parent" could work but I want it loosely coupled self.endOfSessionHandler = handler; // Tell character to start final animation -- this creates a new CCLayer, // starts the animation, and assigns that CCLayer into self.animatedSequence [self changeCharacterActionTo:END_ANIMATION key:nil]]; // The "animation" CCLayer has a property called "moving" -- observe it [self.animatedSequence addObserver:self forKeyPath:@"moving" options:NSKeyValueObservingOptionNew context:NULL]; } And then my observing code, which is called back to when "moving" becomes NO (=animation finishes): - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if ([keyPath isEqualToString:@"moving"]) { BOOL movingStatus = [[change objectForKey:NSKeyValueChangeNewKey] boolValue]; if (movingStatus == NO) { // Stop observing [object removeObserver:self forKeyPath:@"moving"]; // Stop all animations on this level [self.animatedSequence stopAnimation]; [self removeChild:self.animatedSequence cleanup:YES]; [self removeFromParentAndCleanup:YES]; // Handler callback if (self.endOfSessionHandler && [self.endOfSessionHandler respondsToSelector:@selector(characterDidFinishSession)]) { [self.endOfSessionHandler characterDidFinishSession]; } } } // if key = moving } Now, you may say, Didn't know you that you can just add a callback using CCCallFunc as an action on your animation at the end, so you know when you're done moving? Yes, I do know that - but the point is that the CCScene "knows" when the end button is pressed -- not any one specific animation. The CCAction is already in motion when the end button is pressed, so I want to tell all sprites to STOP animating and destroy. My animation CCLayer has some special code to tell me when the sprite(s) has stopped moving. That code is working well-- I use a CCCallFunc callback on the end of every animation to tell my "animation" CCLayer class that it's done. Why it seems to be a problem, though, is that I get the KVO notification that "moving" has changed BEFORE the Cocos2D action stack trace has unwound. I'm pretty sure my problem is somewhere in there, because as soon as the KVO notification comes through, I try to stop everything (see the code above). Yet, not everything stops, because the Cocos2D framework crashes (overrelease) as it tries to "wrap up" the stack trace. Is it not possible to stop an animation from within a CCCallFunc callback that is an action animating the same sprite? For you true Cocos-heads out there, the exact line that is crashing is: if( currentTarget->currentActionSalvaged ) { // The currentAction told the node to remove it. To prevent the action from // accidentally deallocating itself before finishing its step, we retained // it. Now that step is done, it's safe to release it. [currentTarget->currentAction release]; .. which is on line 327 of CCActionManager.m .
