[site]: stackoverflow
[post_id]: 2383698
[parent_id]: 2377838
[tags]: 
A global 'flag' will not work, keep in mind that you have multiple waiters and multiple notifications, you don't want one 'waiter' to pick up all notifications. To reliable pick 'exactly one' task, use UPDATE with OUTPUT: UPDATE TOP(1) StatusTable SET Status = 1 OUTPUT DELETED.TaskId WHERE Status = 0; This is the recommended, reliable, way to dequeue rows from tables used as queues, see the Queues paragraph in OUTPUT Clause . But by now you should realize that 1) you are using tables as queues 2) you are receiving notifications from these queues and 3) you use Service Broker to deliver these notifications (via SqlDependency, which internally uses Service Broker ). So why not use just plain Service Broker? You need a queue and a service and have each instance starts a WAITFOR(RECEIVE...) on this queue (which is not polling). The job of interest ends its work with a SEND to your service, notifying that a job is complete. Exactly one of your instances will pick up this notification and carry on the post-processing (ie. deliver the web service call). This way you cut out all the 'fluf' around the notifications (SqlDependency, global flag, tables used as queues) and you go against the bare-bone infrastructure which would be used by SqlDependency anyway.
