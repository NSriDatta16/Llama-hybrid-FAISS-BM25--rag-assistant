[site]: datascience
[post_id]: 104019
[parent_id]: 103935
[tags]: 
I would try to use a genetic algorithm. A simple representation of the problem in terms of a genetic algorithm would go like this: A "gene" represents one of the parameters. An "individual" consists of assigning a value to each parameter. An "individual" represents a candidate solution, and it can be evaluated using the objective function. The goal is that at every iteration, a candidate solution is more likely to be selected if it performs well according to the objective function. The standard genetic algorithm works like this: Randomly pick a set of say 100 individuals (first generation) Calculate the "performance" of every individual Select say the top 10 individuals according to their performance, then produce the next generation of 100 individuals by cross-over among these top 10. A cross-over means picking two individuals A and B from the top 10 and producing a new individual with the value of every gene/instance taken from the same gene in either A or B (this choices between A or B is also made randomly for every gene). Optionally add some random mutations to the new individuals' genes. Iterate again from step 2. Keep iterating unless some stop condition is satisfied, for example the average performance over the last 5 generations doesn't increase anymore (or just stop based on manual inspection). There are probably some good genetic learning libraries around but I've never used any myself (the basic method is fairly simple to implement).
