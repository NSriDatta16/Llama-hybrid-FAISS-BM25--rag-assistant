[site]: stackoverflow
[post_id]: 4753901
[parent_id]: 
[tags]: 
Java - Problem with multiple, concurrent runtime.exec() InputStreams

I have no choice but to retrieve some external data by means of several Runtime.exec() calls to a VBScript. I truly hate this implementation, as I lose my cross-platform flexibility, but I may eventually develop similar *nix scripts to at least mitigate the problem. Before anyone asks, I cannot work around the need to call an external script to gather my data. I will live with the problems that causes. The exec() processes are run in a custom class that extends Runnable . It uses a BufferedReader to read in the data from getInputStream() . Edit : more code added as requested, but I don't see how the extra code is relevant :) I hope it helps, because it took a while to format! Oh, and go easy on my code style if it's ugly, but constructive criticism is encouraged... public class X extends JFrame implements Runnable { ... static final int THREADS_MAX = 4; ExecutorService exec; ... public static void main(String[] args) { ... SwingUtilities.invokeLater(new X("X")); } // End main(String[]) public X (String title) { ... exec = Executors.newFixedThreadPool(THREADS_MAX); ... // Create all needed instances of Y for (int i = 0; i If I execute the commands individually, I gather the data as I expect. However, if I execute the commands in the run() block of the class (meaning the calls are concurrent, as I am hoping for), it appears as if only one input stream is generated, which all BufferedReaders consume concurrently. To debug the issue, I output each consumed line on the console prefixed by which instance of my class was reading the input stream. I expect something like the following, understanding that they may be out of order from instance-to-instance, but the line order of a single instance would be intact: exec 0: Line1 exec 1: Line1 exec 2: Line1 exec 0: Line2 exec 1: Line2 exec 2: Line2 exec 0: Line3 exec 1: Line3 exec 2: Line3 ... What's strange is I get the expected number of instances of the very first line of the output ( Microsoft (R) Windows Script Host Version 5.7 ), but after this line, only one process continues to produce data in the input stream, and all readers randomly-consume this one stream, such as this example: exec 2: Microsoft (R) Windows Script Host Version 5.7 exec 0: Microsoft (R) Windows Script Host Version 5.7 exec 1: Microsoft (R) Windows Script Host Version 5.7 exec 0: line2 exec 1: line3 exec 2: line4 ... To make matters worse, the readers stall and readLine() never returns null. I read that this type of behavior might have something to do with the buffer size, but when I run only two concurrent threads, even with a short output, it still exhibits the same behavior. Nothing is captured in stdErr to indicate there is a problem. To see if this was a limitation of the script host, I created a batch file that START s multiple instances of the script concurrently. I should state this was run outside of Java, in a cmd shell, and launches several of its own shells. However, each concurrent instance fully returned the expected results and behaved well. Edit: As another troubleshooting idea, I decided to re-enable concurrency, but stagger my initialization method by inserting the following into my Y.run() block: try { Thread.sleep((int)(Math.random() * 1200)); } catch (InterruptedException e) { System.out.println("Can't sleep!"); } // End try initialize(monitor); into my code. I begin to see multiple outputs for the first few lines, but it quickly reverts to multiple consumers consuming the same producer, and as soon as the first completed stream closes, the rest of the consumers fire exceptions. The next consumer fires an IOException: Read error , and the rest fire IOException: Stream closed ! According to maaartinus, it IS possible to run multiple, concurrent InputStreams , so now the question becomes what is causing the undesired behavior? How can I independently grab their input streams? I don't want to have to write to a temporary file just to process the data back in, if I can avoid it.
