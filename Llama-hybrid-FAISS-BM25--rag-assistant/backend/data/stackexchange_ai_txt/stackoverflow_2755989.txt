[site]: stackoverflow
[post_id]: 2755989
[parent_id]: 2755708
[tags]: 
Actually after thinking about this again, your method is potentially less secure than "The normal flow". If you just send back HASH(HASH(user's original password)) , I can see scenarios where this can give an attacker leverage: Scenario 1: Jim registers on your site as jimjones@microsoft.com . Jim requests a password reset, but doesn't use it. The reset email is left sitting in his inbox for eternity. Jim changes his email address on your site. jimjones@gmicrosoft.com is compromised by Bob . Bob now runs a bruteforce attack via his distributed GPGPU farm and recovers Jim 's password. Scenario 2: Jim uses a the password jimjonesupinthisma! for his banking account. Jim registers on your site as jimjones@microsoft.com . jimjones@microsoft.com is not in any way associated with Jim s bank account. jimjones@gmicrosoft.com is compromised by Bob . Bob now requests a reset, he now has HASH(HASH(jim's password)) . Bob now runs a bruteforce attack via his distributed GPGPU farm and recovers Jim 's password, which he then uses to access Jim s bank account. Scenario 3: (Your site uses TLS, users register via TLS.) Jim registers on your site as jimjones@microsoft.com . Bob requests a password reset on Jim s account. Bob works for NSA at Room 641A . Bob uses his global internet sniffer and obtains HASH(HASH(jim's password)) as it's emailed in plaintext to jimjones@microsoft.com . Bob now runs a bruteforce attack via his distributed GPGPU farm and recovers Jim 's password. Variants of scenarios 1 and 2 happen all the time (depending on how strong the hash and password are), I'm not so sure about 3. The point is, your method leeks unnecessary information, which can indeed leverage an attacker against your user. I suggest you use randomly generated tokens that have nothing to do with the user's password.
