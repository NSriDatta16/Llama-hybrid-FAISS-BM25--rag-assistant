[site]: stackoverflow
[post_id]: 4170146
[parent_id]: 
[tags]: 
Simple storage class in C++ and strict aliasing

I have the following code for having a small class for storage. #include template class storage { private: struct destroy { T& m_t; destroy(T& t) : m_t(t) { } ~destroy() { m_t.~T(); } }; char m_c[sizeof(T)]; void* address() { return &m_c[0]; } public: void set(const T& t) { new (address()) T(t); } T get() { T& t = *static_cast (address()); destroy _d(t); return t; } }; template class choosable_storage { private: union { T* m_p; storage m_storage; }; bool m_direct; public: choosable_storage() : m_direct(false) { } void set_direct(const T& t) { m_direct = true; m_storage.set(t); } void set_indirect(T* const t) { m_p = t; } T get() { if (m_direct) return m_storage.get(); return *m_p; } }; int main(void) { storage s; // no problems s.set(42); std::cout c1; // strict aliasing warnings c1.set_indirect(&i); std::cout c2; c2.set_direct(i); std::cout gcc 4.4 warns that I break the strict aliasing rules in storage::get() when I return. AFAIK, I do not violate any rules. Do I actually violate strict aliasing or is gcc getting picky here? And is there a way of having it warning free without disabling strict aliasing? Thanks EDIT: On the other hand, the following implementation does not give any warnings: template class storage { private: struct destroy { T& m_t; destroy(T& t) : m_t(t) { } ~destroy() { m_t.~T(); } T const& operator()() const { return m_t; } }; char m_c[sizeof(T)]; public: void set(const T& t) { new(static_cast (m_c)) T(t); } T get(void) { return destroy(*static_cast (static_cast (m_c)))(); } }; EDIT: gcc 4.5 and up does not issue a warning - so apparently this was just a misinterpretation of the strict aliasing rules or a bug in gcc 4.4.x
