[site]: stackoverflow
[post_id]: 4835699
[parent_id]: 4834074
[tags]: 
Doing something like while(timer.isActive()) is not a good idea at all as it will cause your application to consume around 100% CPU time. It will also cause your application to never return to the event processing loop where the actual code for timer is executed, that's why it freezes. If you still want to use this approach, you should call QCoreApplication::processEvents() in the loop. It will temporarily pass control back to the event loop, so it will cause timer to time out. Instead of connecting timeout() to stopTimer(), you can just call timer.setSingleShot(true) before you start it, it will cause it to stop automatically after the first timeout. Note that you have a memory leak there as you create a new timer on each button push. Surely they are children of your form and will be destroyed, but only when the form is destroyed. If you want a more elegant approach, you can create a separate class for reading that file. In the constructor you'd open your file and stream which should be fields in this class. This class should also have a sort of readMore() slot which will read 2500 lines, then put a message and return. If it doesn't reach the end of the stream, then it would call QTimer::singleShot(10000, this, SLOT(readMore())), which will cause the event loop to call readMore() again in 10 seconds. The code would looks something like this (didn't check for errors): // myfilereader.h class Form; class MyFileReader: public QObject { Q_OBJECT public: MyFileReader(const QString &fileName); // this should be called after you create an instance of MyFileReader void startReading() {readMore();} private: QFile file; QTextStream stream; private slots: void readMore(); signals: void message(); // this should be connected to printMessage() in the Form void finished(); }; // myfilereader.cpp MyFileReader::MyFileReader(const QString &fileName): file(fileName), stream(&file), { // open the file, possibly throwing an exception // or setting some sort of "invalid" flag on failure } void MyFileReader::readMore() { QString line; int lineCount = 0; while(!(stream.atEnd()) { line = stream.readLine(); lineCount++; if(lineCount == 2500) { emit message(); break; } } if (stream.atEnd()) emit finished(); else QTimer::singleShot(10000, this, SLOT(readMore())); } This is a kind of more heavyweight approach, but this is the price of asynchronous event handling. You could also put all this stuff into the Form class, but I think using a separate class is better. As Daniel points out, if reading 2500 lines takes a long time, say 5 seconds, the message will be printed after 10 seconds after the reading has finished, that is, 15 seconds after it has started. If you want the message to be printed approximately each 10 seconds no matter how long reading takes, you should add a QTimer timer field to the class, connect it's timeout() signal to the readMore() slot in the MyFileReader constructor, then in the startReading() method call timer.start() before calling readMore(). Now, at the end of readMore() do this: if (stream.atEnd()) { timer.stop(); emit finished(); } You need a QTimer field in this case because you can't cancel a QTimer::singleShot() call, but you need to do it if you have reached the end of the stream, otherwise your readMore() will just keep on getting called again and again, even if there is nothing more to read. Note that even in this case, it is still possible for the message to appear less frequently than every 10 seconds in case if reading 2500 lines takes longer than these 10 seconds. If you want exactly 10 seconds, you should probably check the elapsed time in the loop instead, but I think that's an overkill, unless you expect reading to be very slow. Slightly off topic, but if you want an easy way to avoid memory leaks, you can also do this in the constructor: connect(this, SIGNAL(finished()), this, SLOT(deleteLater())); It will automatically mark your reader for deletion when you emit finished() , and, once that happens, the reader will be deleted as soon as the control goes back to the event loop. That is, after all slots connected to the finished() signal return. This approach allows you to just allocate a MyFileReader on the heap, then discard the pointer without worrying about memory leaks.
