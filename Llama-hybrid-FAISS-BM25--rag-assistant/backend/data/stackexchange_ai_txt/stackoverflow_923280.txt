[site]: stackoverflow
[post_id]: 923280
[parent_id]: 923135
[tags]: 
As you can see in the comments of that post, it is still controversially discussed, what is the best way. I tried it by subclassing too, but I ran in many problems, while using profiles work perfectly for me. class IRCUser(models.Model): user = models.ForeignKey(User, unique=True) name = models.CharField(max_length=100, blank= True, null = True ) friends = models.ManyToManyField("IRCUser", blank= True, null = True) dataRecieved= models.BooleanField(default=False) creating an IRCUser works like this: >>> IRCUser(user = User.objects.get(username='Kermit')).save() EDIT: Why are user_profiles elegant: Let's assume, we are writing a webapp, that will behave as a multi-protocol chat. The users can provide their accounts on ICQ, MSN, Jabber, FaceBook, Google Talk ..... We are free to create a custom user class by inheritance, that will hold all the additional informations. class CustomUser(User): irc_username = models.CharField(blank=True, null=True) irc_password = models.PasswordField(blank=True, null=True) msn_username = models.CharField(blank=True, null=True) msn_password = models.PasswordField(blank=True, null=True) fb_username = models.CharField(blank=True, null=True) fb_password = models.PasswordField(blank=True, null=True) gt_username = models.CharField(blank=True, null=True) gt_password = models.PasswordField(blank=True, null=True) .... .... this leads to data-rows with a lot of zero-values tricky what-if-then validation the impossibility, to have more the one account with the same service So now let's do it with user_profiles class IRCProfile(models.Model): user = models.ForeignKey(User, unique=True, related_name='ircprofile') username = models.CharField() password = models.PasswordField() class MSNProfile(models.Model): user = models.ForeignKey(User, unique=True, related_name='msnprofile') username = models.CharField() password = models.PasswordField() class FBProfile(models.Model): user = models.ForeignKey(User, unique=True, related_name='fbprofile') username = models.CharField() password = models.PasswordField() the result: User_profiles can be created when needed the db isn't flooded by zero-values n profiles of same type can be assigned to one user validation is easy this may lead to a more cryptic syntax in the templates, but we are free to have some shortcuts in our views/template_tags or to use {% with ... %} to flavour it as we want.
