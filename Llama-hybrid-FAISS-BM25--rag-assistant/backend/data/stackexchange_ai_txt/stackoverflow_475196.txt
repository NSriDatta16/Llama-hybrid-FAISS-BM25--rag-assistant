[site]: stackoverflow
[post_id]: 475196
[parent_id]: 474367
[tags]: 
My goal with disabling the ViewState on this drop down list is to minimize the size of the ViewState for the page. The problem I had with only doing the if(!Page.IsPostBack){...DataBind()...}, is that when you select an item for the first time, and the page reloads, my drop down list becomes empty. What I ended up doing was creating another Property on this control, LastIndex. When the OnSelectedIndexChanged event fires, I update the LastIndex value. In the Page_Load, I compare the Current and Last index values, if they're different, then fire a Index changed event. public int SelectedValue{ get { return this.DropDownList1.SelectedItem.Value; } } public int LastIndex{ get { return this.ViewState["lastIndex"] == null ? -1 : (int)this.ViewState["lastIndex"]; } set { this.ViewState["lastIndex"] = value; } } protected override void OnInit(EventArgs e){ base.OnInit(e); this.DropDownList1.DataTextField = "Text"; this.DropDownList1.DataValueField = "Value"; this.DropDownList1.DataSource = fillQueueDropDown(); this.DropDownList1.DataBind(); } protected void Page_Load(object sender, EventArgs e){ if (this.LastIndex != this.SelectedValue) this.OnSelectedQueueChanged(new EventArgs()); } private ListItemCollection fillQueueDropDown(){...} protected void DropDownList1_SelectedIndexChanged(object sender, EventArgs e){ OnSelectedQueueChanged(e); this.LastIndex = this.SelectedValue; } public event EventHandler queueNamesChangedEvent; public void OnSelectedQueueChanged(EventArgs e){ if (queueNamesChangedEvent != null) queueNamesChangedEvent(this, e); } You are right though. The data is re-loaded and re-bound in the OnInit phase. Then the ViewState is restored (and when the 0th index is restored), when we finally get to the Events phase, the control doesn't detect the change. Not sure this is the most elegant route, but it's working good so far. Then i found this in the msdn docs for IPostBackDataHandler: public virtual bool LoadPostData(string postDataKey, NameValueCollection postCollection) { String presentValue = Text; String postedValue = postCollection[postDataKey]; if (presentValue == null || !presentValue.Equals(postedValue)) { Text = postedValue; return true; } return false; } Since the present value is the same as the changed-to value, the event isn't fired.
