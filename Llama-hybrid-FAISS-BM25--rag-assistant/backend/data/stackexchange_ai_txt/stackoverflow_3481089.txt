[site]: stackoverflow
[post_id]: 3481089
[parent_id]: 
[tags]: 
Boost multi_index composite keys using MEM_FUN

Is there a way to use member functions in the specification of composite_key's in boost multi_index_container's? #include #include #include #include #include #include #include using namespace boost::multi_index; using namespace std; class Name { public: Name(const string &first, const string &middle, const string &last) : m_first(first) , m_middle(middle) , m_last(last) {} friend std::ostream& operator , BOOST_MULTI_INDEX_CONST_MEM_FUN( Name, const string &, first) >, ordered_non_unique , BOOST_MULTI_INDEX_CONST_MEM_FUN(Name, const string &, middle) >, ordered_non_unique , BOOST_MULTI_INDEX_CONST_MEM_FUN(Name, const string &, last) >, ordered_non_unique , BOOST_MULTI_INDEX_CONST_MEM_FUN(Name, const string &, last)>, member , BOOST_MULTI_INDEX_CONST_MEM_FUN( Name, const string &, first)> > > > > Name_set; typedef Name_set::index ::type Name_set_by_first; typedef Name_set::index ::type Name_set_by_middle; typedef Name_set::index ::type Name_set_by_last; void main() { Name_set names; names.insert(Name("robert", "shawn", "mitchell")); names.insert(Name("ravi", "john", "spaceman")); names.insert(Name("david", "abel", "mccoy")); names.insert(Name("steven", "xavier", "anser")); names.insert(Name("kris", "nomiddlename", "spigha")); names.insert(Name("jina", "wilson", "fabrice")); names.insert(Name("zebbo", "aniston", "michaels")); names.insert(Name("antonio", "magician", "esfandiari")); names.insert(Name("nora", "iris", "mitchell")); cout ().begin(); itf != names.get ().end(); ++itf) cout ().begin(); itm != names.get ().end(); ++itm) cout ().begin(); itl != names.get ().end(); ++itl) cout ().find("mitchell"); while (mitchells->last() == "mitchell") cout The code above represents what I would like to do, but the member<> template does not accept the BOOST_MULTI_INDEX_CONST_MEM_FUN macro the way ordered_non_unique<> does. Anyone come across this? Thanks!
