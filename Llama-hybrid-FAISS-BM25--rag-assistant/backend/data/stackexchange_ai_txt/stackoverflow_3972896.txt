[site]: stackoverflow
[post_id]: 3972896
[parent_id]: 3970352
[tags]: 
In a functional language, everything is dataflow. You can use functions as your module concept. To address each of your use-cases: A pluggagble module is a Clojure function that takes a single argument that is the state of your data vector. e.g. (def module-a some-function) To allow for easy extension by modules, I suggest using a Clojure map as your state, where one field is your array of floats. Composing modules is function composition. e.g. (def combined-module (compose module-a module-b) Auxiliary functions are accessor functions, extracting state from your data. e.g. If your data is a Clojure map with a :moving-average field, then the keyword :moving-average is your accessor function. State is not stored in modules. Boilerplate code is hidden in the implementation of your functions, which can be declared anywhere, possibly in another file and namespace.
