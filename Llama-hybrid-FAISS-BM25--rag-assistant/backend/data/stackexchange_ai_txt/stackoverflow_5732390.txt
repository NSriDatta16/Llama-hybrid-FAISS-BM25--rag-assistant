[site]: stackoverflow
[post_id]: 5732390
[parent_id]: 5731863
[tags]: 
Let's forget the math and try to solve this intuitively. First, if we want to map input numbers in the range [ 0 , x ] to output range [ 0 , y ], we just need to scale by an appropriate amount. 0 goes to 0, x goes to y , and a number t will go to (y/x)*t . So, let's reduce your problem to the above simpler problem. An input range of [ input_start , input_end ] has input_end - input_start + 1 numbers. So it's equivalent to a range of [ 0 , r ], where r = input_end - input_start . Similarly, the output range is equivalent to [ 0 , R ], where R = output_end - output_start . An input of input is equivalent to x = input - input_start . This, from the first paragraph will translate to y = (R/r)*x . Then, we can translate the y value back to the original output range by adding output_start : output = output_start + y . This gives us: output = output_start + ((output_end - output_start) / (input_end - input_start)) * (input - input_start) Or, another way: /* Note, "slope" below is a constant for given numbers, so if you are calculating a lot of output values, it makes sense to calculate it once. It also makes understanding the code easier */ slope = (output_end - output_start) / (input_end - input_start) output = output_start + slope * (input - input_start) Now, this being C, and division in C truncates, you should try to get a more accurate answer by calculating things in floating-point: double slope = 1.0 * (output_end - output_start) / (input_end - input_start) output = output_start + slope * (input - input_start) If wanted to be even more correct, you would do a rounding instead of truncation in the final step. You can do this by writing a simple round function: #include double round(double d) { return floor(d + 0.5); } Then: output = output_start + round(slope * (input - input_start))
