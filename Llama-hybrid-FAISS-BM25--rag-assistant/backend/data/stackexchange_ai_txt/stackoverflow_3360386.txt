[site]: stackoverflow
[post_id]: 3360386
[parent_id]: 
[tags]: 
About the fate of malloc()ed arrays of arrays

my first question on Stackoverflow. Let me start with a bit of code. It's a bit repetitive so I'm going to cut out the parts I repeat for different arrays (feel free to ask for the others). However, please ignore the code in preference to answering the Qs at the bottom. Firstly: thank you to answerers in advance. Secondly: the freeing of data. @implementation ES1Renderer GLfloat **helixVertices; GLushort **helixIndices; GLubyte **helixColors; - (void)freeEverything { if (helixVertices != NULL) { for (int i=0; i (I will get to the calling of this in a moment). Now for where I malloc() the arrays. - (void)askForVertexInformation { int nrows = self.helper.numberOfAtoms / 300; int mrows = [self.helper.bonds count] / 300; int alphaCarbonRows = [self.helper.alphaCarbons count] / 30; helixVertices = malloc(alphaCarbonRows * sizeof(GLfloat *) + 1); helixIndices = malloc(alphaCarbonRows * sizeof(GLfloat *) + 1); helixColors = malloc(alphaCarbonRows * sizeof(GLfloat *) + 1); for (int i=0; i Finally, the bit which calls everything (this is a separate class.) - (void)loadPDB:(NSString *)pdbToLoad { if (!self.loading) { [self performSelectorOnMainThread:@selector(stopAnimation) withObject:nil waitUntilDone:YES]; [self.renderer freeEverything]; [renderer release]; ES1Renderer *newRenderer = [[ES1Renderer alloc] init]; renderer = [newRenderer retain]; [self performSelectorOnMainThread:@selector(stopAnimation) withObject:nil waitUntilDone:YES]; // need to stop the new renderer animating too! [self.renderer setDelegate:self]; [self.renderer setupCamera]; self.renderer.pdb = nil; [renderer resizeFromLayer:(CAEAGLLayer*)self.layer]; [newRenderer release]; NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(setup:) object:pdbToLoad]; [self.queue addOperation:invocationOperation]; [invocationOperation release]; } } - (void)setup:(NSString *)pdbToLoad { self.loading = YES; [helper release]; [renderer.helper release]; PDBHelper *aHelper = [[PDBHelper alloc] initWithContentsOfFile:pdbToLoad]; helper = [aHelper retain]; renderer.helper = [aHelper retain]; [aHelper release]; if (!resized) { [self.helper resizeVertices:11]; resized = YES; } self.renderer.helper = self.helper; [self.helper setUpAtoms]; [self.helper setUpBonds]; if (self.helper.numberOfAtoms > 0) [self.renderer askForVertexInformation]; else { // LOG ME PLEASE. } [self performSelectorOnMainThread:@selector(removeProgressBar) withObject:nil waitUntilDone:YES]; [self performSelectorOnMainThread:@selector(startAnimation) withObject:nil waitUntilDone:YES]; self.renderer.pdb = pdbToLoad; self.loading = NO; } What I'm doing here is loading a molecule from a PDB file into memory and displaying it on an OpenGL view window. The second time I load a molecule (which will run loadPDB: above) I get the Giant Triangle Syndrome and Related Effects... I will see large triangles over my molecule. However, I am releasing and reallocating my PDBHelper and ES1Renderer every time I load a new molecule. Hence I was wondering: 1. whether the helixVertices, helixIndices and helixColors which I have declared as class-wide variables are actually re-used in this instance. Do they point to the same objects? 2. Should I be setting all my variables to NULL after freeing? I plan to do this anyway, to pick up any bugs by getting a segfault, but haven't got round to incorporating it. 3. Am I even right to malloc() a class variable? Is there a better way of achieving this? I have no other known way of giving this information to the renderer otherwise.
