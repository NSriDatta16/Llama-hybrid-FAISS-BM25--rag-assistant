[site]: crossvalidated
[post_id]: 32745
[parent_id]: 32735
[tags]: 
The residuals from gls will indeed have the same autocorrelation structure, but that does not mean the coefficient estimates and their standard errors have not been adjusted appropriately. (There's obviously no requirement that $\Omega$ be diagonal, either.) This is because the residuals are defined as $e = Y - X\hat{\beta}^{\text{GLS}}$. If the covariance matrix of $e$ was equal to $\sigma^2\text{I}$, there would be no need to use GLS! In short, you haven't done anything wrong, there's no need to adjust the residuals, and the routines are all working correctly. predict.gls does take the structure of the covariance matrix into account when forming standard errors of the prediction vector. However, it doesn't have the convenient "predict a few observations ahead" feature of predict.Arima , which takes into account the relevant residuals at the end of the data series and the structure of the residuals when generating predicted values. arima has the ability to incorporate a matrix of predictors in the estimation, and if you're interested in prediction a few steps ahead, it may be a better choice. EDIT: Prompted by a comment from Michael Chernick (+1), I'm adding an example comparing GLS with ARMAX (arima) results, showing that coefficient estimates, log likelihoods, etc. all come out the same, at least to four decimal places (a reasonable degree of accuracy given that two different algorithms are used): # Generating data eta summary(gls(y~x, correlation=corARMA(p=1), method='ML')) Generalized least squares fit by maximum likelihood Model: y ~ x Data: NULL AIC BIC logLik 2833.377 2853.008 -1412.688 Correlation Structure: AR(1) Formula: ~1 Parameter estimate(s): Phi 0.4229375 Coefficients: Value Std.Error t-value p-value (Intercept) -0.0375764 0.05448021 -0.68973 0.4905 x 0.9730496 0.03011741 32.30854 0.0000 Correlation: (Intr) x -0.022 Standardized residuals: Min Q1 Med Q3 Max -2.97562731 -0.65969048 0.01350339 0.70718362 3.32913451 Residual standard error: 1.096575 Degrees of freedom: 1000 total; 998 residual > > arima(y, order=c(1,0,0), xreg=x) Call: arima(x = y, order = c(1, 0, 0), xreg = x) Coefficients: ar1 intercept x 0.4229 -0.0376 0.9730 s.e. 0.0287 0.0544 0.0301 sigma^2 estimated as 0.9874: log likelihood = -1412.69, aic = 2833.38 EDIT: Prompted by a comment from anand (OP), here's a comparison of predictions from gls and arima with the same basic data structure as above and some extraneous output lines removed: df.est predict(model.gls, newdata=df.pred) [1] -0.3451556 -1.5085599 0.8999332 0.1125310 1.0966663 > predict(model.armax, n.ahead=5, newxreg=df.pred$x)$pred [1] -0.79666213 -1.70825775 0.81159072 0.07344052 1.07935410 As we can see, the predicted values are different, although they are converging as we move farther into the future. This is because gls doesn't treat the data as a time series and take the specific value of the residual at observation 995 into account when forming predictions, but arima does. The effect of the residual at obs. 995 decreases as the forecast horizon increases, leading to the convergence of predicted values. Consequently, for short-term predictions of time series data, arima will be better.
