[site]: stackoverflow
[post_id]: 3781158
[parent_id]: 3779358
[tags]: 
Binary access Following my comment about the poor performance of GetPixel for each pixel, I tried to write a snippet which finds if there are transparent pixels or not in an image (including PNG). Here it is. public static bool IsImageTransparent(string fullName) { using (Bitmap bitmap = Bitmap.FromFile(fullName) as Bitmap) { bool isTransparent; // Not sure if the following enumeration is correct. Maybe some formats do not actually allow transparency. PixelFormat[] formatsWithAlpha = new[] { PixelFormat.Indexed, PixelFormat.Gdi, PixelFormat.Alpha, PixelFormat.PAlpha, PixelFormat.Canonical, PixelFormat.Format1bppIndexed, PixelFormat.Format4bppIndexed, PixelFormat.Format8bppIndexed, PixelFormat.Format16bppArgb1555, PixelFormat.Format32bppArgb, PixelFormat.Format32bppPArgb, PixelFormat.Format64bppArgb, PixelFormat.Format64bppPArgb }; if (formatsWithAlpha.Contains(bitmap.PixelFormat)) { // There might be transparency. BitmapData binaryImage = bitmap.LockBits(new Rectangle(Point.Empty, bitmap.Size), ImageLockMode.ReadOnly, PixelFormat.Format64bppArgb); unsafe { byte* pointerToImageData = (byte*)binaryImage.Scan0; int numberOfPixels = bitmap.Width * bitmap.Height; isTransparent = false; // 8 bytes = 64 bits, since our image is 64bppArgb. for (int i = 0; i Pros: Binary access, much faster than GetPixel , Does not require additional libraries nor WPF, Works with any format supported by GDI+: BMP, GIF, JPEG, PNG, TIFF, Exif, WMF, and EMF. Cons: Requires unsafe , Is slower than reading PNG file directly. Palettes A less manual approach would be to use palettes. There might probably exist some .NET Framework or third party libraries which let you do that. I tried the following (using WPF): using (Stream imageStreamSource = new FileStream(fullName, FileMode.Open, FileAccess.Read, FileShare.Read)) { PngBitmapDecoder decoder = new PngBitmapDecoder(imageStreamSource, BitmapCreateOptions.PreservePixelFormat, BitmapCacheOption.Default); BitmapSource bitmapSource = decoder.Frames[0]; return bitmapSource.Palette.Colors.Any(c => c.A != 0); } but I does not work , since bitmapSource.Palette is null most of the time. Further, using palettes will heavily decrease performance, compared to the first snippet, since every color must be loaded into a list of colors before proceeding.
