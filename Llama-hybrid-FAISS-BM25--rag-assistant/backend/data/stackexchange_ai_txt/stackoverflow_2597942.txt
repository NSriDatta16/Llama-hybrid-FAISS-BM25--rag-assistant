[site]: stackoverflow
[post_id]: 2597942
[parent_id]: 1777901
[tags]: 
This problem isn't as easy as it seems, but after some thought, the algorithm to accomplish this isn't too bad. You'll notice the first and last element are already in place, so we don't need to worry about them. We will keep a left index variable which represents the first item in the first half of the array that needs changed. After that we set a right index variable to the first item in the 2nd half of the array that needs changed. Now all we do is swap the item at the right index down one-by-one until it reaches the left index item. Increment the left index by 2 and the right index by 1, and repeat until the indexes overlap or the left goes past the right index (the right index will always end on the last index of the array). We increment the left index by two every time because the item at left + 1 has already naturally fallen into place. Pseudocode Set left index to 1 Set right index to the middle (array length / 2) Swap the item at the right index with the item directly preceding it until it replaces the item at the left index Increment the left index by 2 Increment the right index by 1 Repeat 3 through 5 until the left index becomes greater than or equal to the right index Interleaving algorithm in C(#) protected void Interleave(int[] arr) { int left = 1; int right = arr.Length / 2; int temp; while (left left; i--) { temp = arr[i]; arr[i] = arr[i - 1]; arr[i - 1] = temp; } left += 2; right += 1; } } This algorithm uses O(1) storage (with the temp variable, which could be eliminated using the addition/subtraction swap technique) I'm not very good at runtime analysis, but I believe this is still O(n) even though we're performing many swaps. Perhaps someone can further explore its runtime analysis.
