[site]: stackoverflow
[post_id]: 4476029
[parent_id]: 4475592
[tags]: 
Part of what makes FastMM fast is that it will allocate a large block of memory and carve smaller uniformly sized pieces out of it. If any part of the block is in use, none of it can be released back to the OS. You're welcome to use a different memory manager. One approach would be to route all allocations directly to VirtualAlloc . Allocations will be rounded up to occupy an entire page at a time, so your program may suffer if you have lots of small allocations, but when you call VirtualFree , you can be confident that the memory definitely doesn't belong to your program anymore. Another option is to route everything to the OS heap. Use HeapAlloc . You can even enable the low-fragmentation heap for your program (on by default as of Windows Vista), which will make the OS employ a strategy similar to the one used by FastMM, but it will allow you to use some debugging and analysis tools from Microsoft to track your program's memory usage over time. Beware, though, that after you call HeapFree , some metrics might still show the memory as belonging to your program. Besides, the working set refers to the memory that's currently in physical RAM . That you observed the number go up does not mean that your program has allocated any more memory. It can simply mean that your program touched some memory that it had previously allocated, but which had not yet been put into RAM. During your loop, you touched that memory, and the OS has not decided to page it back out to disk yet.
