[site]: stackoverflow
[post_id]: 3979660
[parent_id]: 3979319
[tags]: 
I will address the 2nd part of you question first... If there is a conflict, the automated merge tools should force the programmer to decide how the merge happens. But the general assumption is that a conflict will involve two edits to the same set of lines. If somehow a conflict arises because of edits to lines that are not close to each other the automated merge will blithely choose both of the edits and a bug will appear. The general case of a merge tool always merging properly is very hard to solve, and really can't be with current technology. Here is an example of what I mean from C: int i; // Someone replaces this with 'short i' in one changeset stating // that a short is more efficient. // ... lots of code; // Someone else replaces all the 65000s with 100000s in another changeset, // saying that more precision is needed. for (i = 0; i No merge tool is going to catch this kind of conflict. The tool would have to actually compile the code to see that those two parts of the code have anything to do with eachother, and while that would likely be enough in this case, I can construct an example that would require the code to be run and the results examined to catch the conflict. This means that what you really ought to do is rigorously test your code after a merge, just like you should after any other change. The vast majority of merges will result in obvious conflicts that a developer will have to resolve (even though that resolution is often fairly obvious), or will merge cleanly. But the very few merges that don't fit either category can't easily be handled in an automated fashion. This can also be fixed by development practices that encourage locality. For example a coding standard that states "Variables should be declared near where they're used.". I'm guessing that .vcproj files are particularly prone to this problem since they are not well understood by developers and so if conflicts do appear they will not be sure what to do with them. My guess is that this happened and your developer simply did a revert back to the revision (s)he checked in. As for part 1... What to do in this case depends a lot on your development process. You can either strip the merge changeset out and redo it, though that won't work very well if lots of people have already pulled it, and it will work especially poorly if there are lots of changesets that have already been checked in that are based on the merge changeset. You can also check in a new change that fixes the problem with the merge. Those are basically your two options. The tone of your post seems to me to indicate that you may have some politics surrounding this issue in your organization, and people are blaming this error on the frequent merges of Mercurial. So I will point out that any change control system can have this problem. In the case of Subversion, for example, every time a developer does an update while they have outstanding changes in their working directory, they are doing a merge, and this kind of problem can arise with any merge.
