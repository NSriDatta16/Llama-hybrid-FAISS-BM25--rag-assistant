[site]: datascience
[post_id]: 28324
[parent_id]: 13011
[tags]: 
@Emre's response and @elias-strehle's implementation are correct. I have made a similar implementation using an elegant (imho) hashing function I borrowed from this tweet The class hashes each word to the product of all it's letters, in which each letter is mapped to a prime number. Products of prime numbers only collide when using the exact same numbers. It is quite fast (as requested), around 200k anagram lookups per second (on my machine) See here for a full example class Anagrammer: alphabet = {"a":2,"b":3,"c":5,"d":7,"e":11,"f":13,"g":17,"h":19,"i":23,"j":29,"k":31,"l":37,"m":41,"n":43,"o":47,"p":53,"q":59,"r":61,"s":67,"t":71,"u":73,"v":79,"w":83,"x":89,"y":97,"z":101} def __init__(self, corpus): self.index = {} self.createIndex(corpus) def createAnagramIndexNumber(self, word): index = 1 for x in list(word): index *= self.alphabet[x] return index def createIndex(self, corpus): for word in corpus: self.index.setdefault(self.createAnagramIndexNumber(word),set()) self.index[self.createAnagramIndexNumber(word)].add(word); def getAnagrams(self, word): return self.index[self.createAnagramIndex(word)]
