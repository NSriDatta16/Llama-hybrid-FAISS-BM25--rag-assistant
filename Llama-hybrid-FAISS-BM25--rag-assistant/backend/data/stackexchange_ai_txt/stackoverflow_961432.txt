[site]: stackoverflow
[post_id]: 961432
[parent_id]: 960955
[tags]: 
If it is very simple I would recommend that you create a subclass of UIView in code and create instances of this class (or you can use Interface Builder to create the custom UIView that is then archived into the NIB file and restored later on also using code). Using the code solution you could create instances of your custom UIView in your controller by calling something like: #import "MyCustomView.h" // let the superview decide how big it should be or set it as needed. CGRect sizeRect = CGRectMake(0,0,0,0); // create an instance of your view MyCustomView *view = [MyCustomView alloc] initWithFrame:sizeRect]; // set a custom delegate on the view or set callback methods using @selector()... [view setDelegate:self]; // self = view controller // add the view to the controller somewhere... (eg: update CGRect above as needed) [self addSubView:view]; // don't forget to release the view somewhere ;-) This example assumes that you create a delegate protocol that your View Controller can respond to or you can wire up events dynamically using @selector. If you don't want to create instances of the view in code you could add a "UIView" to your NIB file and set it's class type in the inspector window (command -> 4 -> class dropdown). If you want to do everything in interface builder you can create your custom UIView and use something like "- (NSArray *)loadNibNamed:(NSString *)name owner:(id)owner options:(NSDictionary *)options" (see NSBundle) to load the NIB file dynamically. This presents it's own challenges though it is also feasible. The most involved option would be to create your own xcode custom UI library / plugin so that your custom control / view could be dragged into each NIB file from the Library window like any other control shipped by Apple. Hope this clarifies or eliminates some options for re-using controls for you. Cheers-
