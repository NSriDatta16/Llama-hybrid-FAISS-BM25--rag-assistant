[site]: stackoverflow
[post_id]: 1582975
[parent_id]: 1582940
[tags]: 
This is a very common pattern, and it's fine for enums... but it can be implemented more simply. There's no need for a "reversible map" - the version which takes the month number in the constructor is better for going from Month to int . But going the other way isn't too hard either: public enum Month { JANUARY(1), FEBRUARY(2), MARCH(3), APRIL(4), MAY(5), JUNE(6), JULY(7), AUGUST(8), SEPTEMBER(9), OCTOBER(10), NOVEMBER(11), DECEMBER(12); private static final Map numberToMonthMap; private final int monthNum; static { numberToMonthMap = new HashMap (); for (Month month : EnumSet.allOf(Month.class)) { numberToMonthMap.put(month.getMonthNum(), month); } } private Month(int monthNum) { this.monthNum = monthNum; } public int getMonthNum() { return monthNum; } public static Month fromMonthNum(int value) { Month ret = numberToMonthMap.get(value); if (ret == null) { throw new IllegalArgumentException(); // Or just return null } return ret; } } In the specific case of numbers which you know will go from 1 to N, you could simply use an array - either taking Month.values()[value - 1] or caching the return value of Month.values() to prevent creating a new array on every call. (And as cletus says, getMonthNum could just return ordinal() + 1 .) However, it's worth being aware of the above pattern in the more general case where the values may be out of order, or sparsely distributed. It's important to note that the static initializer is executed after all the enum values are created. It would be nice to just write numberToMonthMap.put(monthNum, this); in the constructor and add a static variable initializer for numberToMonthMap , but that doesn't work - you'd get a NullReferenceException immediately, because you'd be trying to put the value into a map which didn't exist yet :(
