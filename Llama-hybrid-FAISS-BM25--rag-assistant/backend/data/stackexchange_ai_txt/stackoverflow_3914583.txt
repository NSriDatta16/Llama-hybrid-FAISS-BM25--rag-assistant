[site]: stackoverflow
[post_id]: 3914583
[parent_id]: 3914177
[tags]: 
I think your question is good - in fact, some of the earlier articles about the empty base class optimization talk about the "empty member optimization" and specifically say that a similar optimization could apply to members. Maybe, before there was a standard, some compilers did this. This is just idle speculation, I don't have much to back it up, but I had a look at some of these areas of the standard yesterday. C compatibility In this example: struct X{}; struct Y{}; struct Z { struct X x; struct Y y; int i; }; Z would be a POD under C++03 rules, but would not be layout-compatible with C if x and y were zero-sized subobjects. C layout compatibility is one of the reasons for the existence of PODs. This problem can't happen with base classes because C doesn't have base classes, and classes with base classes aren't PODs in C++03, so all bets are off :). Visitor has noted that C doesn't support empty structs, in fact. So this entire argument is wrong. I'd just assumed that it did - it seemed like a harmless generalization. Further, programs seem to assume things, like that y has a greater address than x , and stuff like that - this is guaranteed by the relational operators on pointers in 5.10/2. I don't really know if there's a compelling reason to allow this, or how many programs use it in practice. IMO, this is the strongest argument of all of these. Doesn't generalize well to arrays Continuing the above example, add this: struct Z1 { struct X x[1]; struct Y y[1]; int i; }; ...one might expect that sizeof(Z1) == sizeof(Z) , and that x and y also work as normal arrays do (i.e. that you can form a past-the-end pointer, and that pointer is different to any element's address). One of these expectations would be broken with zero-sized subobjects. Less compelling than the base case One of the main reasons for deriving from an empty base is because it's a policy or interface type class. These are often empty, and requiring them to take up space would impose an "abstraction penalty", i.e. make better organized code more bloated. This is something that Stroustrup doesn't want in C++ - he wants appropriate abstraction for minimal runtime cost. On the other hand, if you declare a member of a type, you don't inherit its functions, typedefs, etc; and you don't get the special pointer conversions from derived to base, so perhaps there's less reason to have a zero-sized member than a zero-sized base. A counterexample here is something like the Allocator policy class in STL containers - you don't necessarily want your containers to derive from it, but you want to "keep it around" without it taking up overhead. Empty base class case covers most uses ...you can use private inheritance instead of declaring a member if you're worried about the space overhead. It's not quite as direct, but you can more or less achieve the same thing. Obviously this doesn't work so well if you've got lots of empty members that you would like to take up zero space. It's another special case There are quite a few subtle things that don't work with this optimization. For example, you can't memcpy the bits of a zero-sized POD subobject into a char array, and then back, or between zero-sized subobjects. I've seen people implement operator= using memcpy (I don't know why...) which would break this sort of thing. Presumably it's less of a problem to break such things for base classes instead of members.
