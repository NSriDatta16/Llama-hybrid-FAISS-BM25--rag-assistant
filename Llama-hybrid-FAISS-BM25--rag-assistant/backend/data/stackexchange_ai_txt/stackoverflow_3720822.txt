[site]: stackoverflow
[post_id]: 3720822
[parent_id]: 3710612
[tags]: 
I've found a solution, seem like using select @var = some_value doesn't work well. See this: A SELECT statement that contains a variable assignment cannot be used to also perform typical result set retrieval operations. These are the fixed functions: usuarioExiste CREATE FUNCTION [dbo].[usuarioExiste] ( @usuario varchar(20) ) RETURNS int AS BEGIN declare @idUsuario int = 0; set @idUsuario = ( select idUsuario from usuarios where usuario = @usuario); if @idUsuario is null begin set @idUsuario = 0; end; return (@idUsuario); END; passwordCorrecto CREATE FUNCTION [dbo].[passwordCorrecto] ( @idUsuario int, @password varchar(20) ) RETURNS bit AS BEGIN declare @esCorrecto bit = 'false'; set @esCorrecto = ( select case when password = @password then 'true' else 'false' end from usuarios where usuarios.idUsuario = @idUsuario); return (@esCorrecto); END; and login CREATE FUNCTION [dbo].[login](@usuario varchar(20), @password varchar(20)) RETURNS @info TABLE (nombre varchar(70) not null, tipo varchar(30) not null) AS BEGIN DECLARE @idUsuario int = dbo.usuarioExistetest(@usuario); DECLARE @passCorrecto bit = dbo.passwordCorrectotest(@idUsuario, @password); INSERT @info SELECT usuarios.nombreUsuario, tiposUsuarios.tipoUsuario FROM usuarios LEFT JOIN tiposUsuarios ON usuarios.idTipoUsuario = tiposUsuarios.idTipoUsuario WHERE usuarios.idUsuario = @idUsuario and usuarios.estatus = 'ACTIVO' and @passCorrecto = 'true'; RETURN END;
