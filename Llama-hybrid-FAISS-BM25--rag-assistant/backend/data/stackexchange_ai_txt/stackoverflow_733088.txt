[site]: stackoverflow
[post_id]: 733088
[parent_id]: 732824
[tags]: 
I see a couple of things that stand out immediately: You are using a global filehandle and not closing it when done. You are using a two argument open (this isn't causing your issue, but it is best to avoid). Your altered regex does not do anything like you seem to think it does. For 1 and 2: # For loop around this: if ($error =~ /E03020039/) { print $error; open(my $mf, '>>', 'G:/perl/error.txt') or die "Unable to open error file - $!\n"; print $mf $error; $count ++; close $mf or die "Unable to close error file - $!\n"; } By using a lexical handle you prevent any other code from touching your handle without having passed explicitly. By closing the handle, you flush the handle's buffers. By checking for errors opening and closing the handle, you prevent uncaught errors leading to lost data. You may wish to move the open and close outside your for loop: my $count = 0; open( my $mh, '>>', 'errorlog.log' ) or die "oops $!\n"; for my $error ( ) { if ( $error =~ /E23323232323/ ) { print $mh $error; print $error; $count++; } } close $mh or die "oops $!\n"; Your code was reopening the same file into a global filehandle. This could easily be the cause of the problems you are seeing. It might not be. Does the correct information for error print to STDOUT? Regarding issue 3, $error =~ /E03020039/&&/characters\s\.\n/ is equivalent to: ($error =~ /E03020039/) && ($_ =~ /characters\s\.\n/) If you had warnings enabled you would (probably) have gotten the Use of uninitialized value in pattern match (m//) error message. It may have been surprising, but it would have been a clue that something was wrong. I believe you wanted something like: $error =~ /E03020039.*?characters\s.$/ But there is no reason to extend the match, since you are not capturing any part of the match. It will have no effect on the value in $error or what will be written to the file. Unless you have a specific reason not to, always start your perl programs with these two pragmas: use strict; use warnings; Even if you have a good reason not to use them, it is nearly always best to disable these pragmas only over a limited scope: use strict; use warnings; { no warnings 'uninitialized'; no strict 'vars'; print "$foo\n"; }
