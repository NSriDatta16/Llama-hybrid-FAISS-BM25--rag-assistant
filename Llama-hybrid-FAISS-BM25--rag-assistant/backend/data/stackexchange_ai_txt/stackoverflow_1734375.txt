[site]: stackoverflow
[post_id]: 1734375
[parent_id]: 1733667
[tags]: 
Here's some code to experiment with: using System; using System.Text; class Program { static void Main(string[] args) { StringBuilder sb = new StringBuilder(); try { //sb.Capacity = 690 * 1024 * 1024; while (true) sb.Append("asdf"); } catch (OutOfMemoryException) { Console.WriteLine("Died at: {0:N0} characters", sb.Capacity); Console.WriteLine("Memory used: {0:N0} bytes", GC.GetTotalMemory(false)); Console.ReadLine(); } } } Output on my machine (Win7 32-bit): Died at: 268,435,456 characters Memory used: 537,091,632 bytes A 32-bit operating system provides a process with close to 2 gigabytes of virtual memory. As you can see, the sample program dies well short of this, consuming only 25% of it. The problem is virtual memory address space fragmentation. The available 2 gigabytes needs to store both code and data. You can get an insight into how the VM is carved up with SysInternal's VMMap utility . There's something you can do about it with some insight in how StringBuilder works. It uses an internal array to store the string. This array is reallocated as needed to store the growing string, doubling the size each time. The Capacity property tells you the size of that array. This causes another kind of fragmentation, heap fragmentation. After the array is doubled in size, the old array can be collected but produces a "free block" that can't be merged back to become available for a large contiguous allocation. That's an implementation detail of the Large Object Heap and the Windows heap manager, Google "look-aside cache" to find out more about it. One workaround is to quickly gobble up virtual memory space before it can get fragmented. Remove the comment to see this at work. On my machine: Died at: 723,517,440 characters Memory used: 1,447,256,944 bytes I fine-tuned the Capacity value by experimentation, you may have to do the same to make it work on your machine. The difference is pretty dramatic, almost 3 times as much. Beware that this is very unlikely to reproduce well in a real program, timing is critical. Or on another machine for that matter, be sure to stay well below the cut-off point. Realistically, you are risking OOM once the buffer you use gets past 134 million characters.
