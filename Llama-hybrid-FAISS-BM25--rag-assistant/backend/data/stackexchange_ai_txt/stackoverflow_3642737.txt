[site]: stackoverflow
[post_id]: 3642737
[parent_id]: 
[tags]: 
Cleaning up bidirectional iterator code

I've modified James' flattening iterator to act as a bidirectional iterator if possible, but I don't think my changes are very elegant (particularly relying on a bool to see if the inner iterator has been set). However, I can't seem to come up with a nicer solution. Does anyone have any ideas? #include #include #include #include #include #include // An iterator that "flattens" a container of containers. For example, // a vector > containing { { 1, 2, 3 }, { 4, 5, 6 } } is iterated as // a single range, { 1, 2, 3, 4, 5, 6 }. template class flattening_iterator { public: typedef OuterIterator outer_iterator; typedef typename std::iterator_traits ::value_type::iterator inner_iterator; typedef typename std::iterator_traits ::iterator_category outer_category; typedef typename std::iterator_traits ::iterator_category inner_category; typedef typename std::common_type ::type common_category; typedef typename std::conditional ::value, std::bidirectional_iterator_tag, common_category>::type iterator_category; typedef typename std::iterator_traits ::value_type value_type; typedef typename std::iterator_traits ::difference_type difference_type; typedef typename std::iterator_traits ::pointer pointer; typedef typename std::iterator_traits ::reference reference; flattening_iterator() { } flattening_iterator(outer_iterator it, outer_iterator begin, outer_iterator end) : outer_it_(it), outer_begin_(begin), outer_end_(end), inner_it_assigned_(false) { if (outer_begin_ == outer_end_) { return; } if (outer_it_ == outer_end_) { return; } inner_it_ = outer_it_->begin(); inner_it_assigned_ = true; advance_past_empty_inner_containers(); } reference operator*() const { return *inner_it_; } pointer operator->() const { return &*inner_it_; } flattening_iterator& operator++() { ++inner_it_; if (inner_it_ == outer_it_->end()) advance_past_empty_inner_containers(); return *this; } flattening_iterator operator++(int) { flattening_iterator it(*this); ++*this; return it; } flattening_iterator& operator--() { if(!inner_it_assigned_) { if(outer_begin_ != outer_end_) { decrement_through_empty_inner_containers(); } return *this; } if(inner_it_ == outer_it_->begin()) { decrement_through_empty_inner_containers(); } else { --inner_it_; } return *this; } flattening_iterator operator--(int) { flattening_iterator it(*this); --*this; return it; } friend bool operator==(const flattening_iterator& a, const flattening_iterator& b) { if (a.outer_it_ != b.outer_it_) return false; if(a.outer_it_ != a.outer_end_ && b.outer_it_ != b.outer_end_ && a.inner_it_assigned_ == false && b.inner_it_assigned_ == false) return true; if (a.outer_it_ != a.outer_end_ && b.outer_it_ != b.outer_end_ && a.inner_it_ != b.inner_it_) return false; return true; } friend bool operator!=(const flattening_iterator& a, const flattening_iterator& b) { return !(a == b); } private: void advance_past_empty_inner_containers() { while (outer_it_ != outer_end_ && inner_it_ == outer_it_->end()) { ++outer_it_; if (outer_it_ != outer_end_) inner_it_ = outer_it_->begin(); } } void decrement_through_empty_inner_containers() { --outer_it_; while(outer_it_ != outer_begin_ && outer_it_->begin() == outer_it_->end()) { --outer_it_; } if(outer_it_->begin() != outer_it_->end()) { inner_it_ = --outer_it_->end(); inner_it_assigned_ = true; } } outer_iterator outer_it_; outer_iterator outer_begin_; outer_iterator outer_end_; inner_iterator inner_it_; bool inner_it_assigned_; }; template flattening_iterator flatten(Iterator start, Iterator first, Iterator last) { return flattening_iterator (start, first, last); } template std::reverse_iterator > flatten_reverse(Iterator start, Iterator first, Iterator last) { return std::reverse_iterator >(flatten(start, first, last)); } int main() { std::vector > v(3); int i(0); for (auto it(v.begin()); it != v.end(); ++it) { it->push_back(i++); it->push_back(i++); it->push_back(i++); it->push_back(i++); } v.insert(v.begin(), std::vector ()); v.insert(v.begin(), std::vector ()); v.insert(v.begin() + 4, std::vector ()); v.push_back(std::vector ()); v.push_back(std::vector ()); for (auto it(flatten(v.begin(), v.begin(), v.end())), end = flatten(v.end(), v.begin(), v.end()); it != end; ++it) { std::cout > v2; for (auto it(flatten(v2.end(), v2.begin(), v2.end())), end = flatten(v2.begin(), v2.begin(), v2.end()); it != end; --it) { std::cout
