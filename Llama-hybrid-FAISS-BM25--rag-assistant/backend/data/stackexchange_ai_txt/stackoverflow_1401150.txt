[site]: stackoverflow
[post_id]: 1401150
[parent_id]: 1400850
[tags]: 
Most of the time configuration can be done with just options that XML::Simple provides. Normally, it will automatically fold data down into as simple of a data structure as can be logically reproduced; it's great for data storage formats, but not as strong when it comes to matching a document format. Fortunately, even though it's "simple", it's incredibly powerful. To control the order of output of elements, you have a few options. You can use arrays, which guarentee order of data. However, it looks like you need a particular order of values for one tag. Key sorting is an automatic feature, too. As long as the keys you have are alphabetical, they will guaranteed sorted in that particular order. But many times, especially with very specific schemas, that won't do. Fortunately, XML::Simple still supports a way to customize it: you must use the OO interface, and override the sorted_keys method. Here's an example: use strict; use warnings; use XML::Simple; use Data::Dumper; package MyXMLSimple; # my XML::Simple subclass use base 'XML::Simple'; # Overriding the method here sub sorted_keys { my ($self, $name, $hashref) = @_; if ($name eq 'supertag') # only this tag I care about the order; { return ('tag1', 'tag3','tag4','tag10'); # so I specify exactly the right order. } return $self->SUPER::sorted_keys($name, $hashref); # for the rest, I don't care! } package main; # back to main code my $xmlParser = MyXMLSimple->new( # Create the parser, with options: KeepRoot => 1, # gives us our root element always. ForceContent => 1, # ensures that content stays special ); my $structure = { supertag => { tag1 => { content => 'value 1' }, tag10 => { content => 'value 2' }, tag3 => { content => 'value 3' }, tag4 => { content => 'value 4' }, }, }; my $xml = $xmlParser->XMLout($structure); print "The xml generated is:\n$xml\n"; print "The read in structure then is:\n" . $xmlParser->XMLin($xml) . "\n"; This will give us: The xml generated is: value 1 value 3 value 4 value 2 The read in structure then is: $VAR1 = { 'supertag' => { 'tag10' => { 'content' => 'value 2' }, 'tag3' => { 'content' => 'value 3' }, 'tag1' => { 'content' => 'value 1' }, 'tag4' => { 'content' => 'value 4' } } }; Check out the XML::Simple page on CPAN.
