[site]: stackoverflow
[post_id]: 1520325
[parent_id]: 1518072
[tags]: 
You could use the Unix command "tail +n" to remove the first n lines of output. That header looks like 10 lines, so this will strip it. $ matlab -nosplash -nodesktop -nodisplay -r test | tail +10 This is a little fragile, though, since warnings (like that "no window system") will get stripped, and the header size will vary depending on what warnings happen (and those warnings are useful diagnostics). Also, that warning might be on STDERR instead of STDOUT, so "tail +9" might be what you need. A more robust approach could be to modify the Matlab script to write to a separate file using fopen/fprintf/fclose. That way the header, warnings, errors, etc from Matlab will be separated from the formatted output you want. To get the "disp" output to go to that separate file handle, you can capture it using evalc. The outfile could be specified using an argument to test() in the -r message, and the $$ env variable (the bash process's PID) incorporated in the file name to prevent collisions in a multiprocess environment. function test(ppid) outfile = sprintf('outfile-%d.tmp', ppid); fh = fopen(outfile, 'w'); myvar = rand(3,4); str = evalc('disp(myvar)'); fprintf(fh, '%s', str); fclose(fh); To invoke it from bash, use this calling form. (May be minor syntax problems here; I don't have a Unix box to test on right now.) % matlab -nosplash -nodisplay -r "test($$)" -logfile matlab-log-$$.tmp Let's say your bash PID is 1234. Now you've got your output in outfile-1234.tmp and a Matlab log in matlab-log-1234.tmp. Stick them in /tmp if you don't want to be dependent on pwd. You could extend this to create multiple output files from a single matlab invocation, saving the startup costs if you need to compute multiple things.
