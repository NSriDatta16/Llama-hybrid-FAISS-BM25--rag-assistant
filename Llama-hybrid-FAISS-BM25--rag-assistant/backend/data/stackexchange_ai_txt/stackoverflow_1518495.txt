[site]: stackoverflow
[post_id]: 1518495
[parent_id]: 1344221
[tags]: 
After reviewing the other answers and considering CodeInChaos' comments, along with CodeInChaos still biased (although less) answer, I thought a final ultimate cut and paste solution was needed. So while updating my answer I decided to go all out. For an up to date version of this code, please visit the new Hg repository on Bitbucket: https://bitbucket.org/merarischroeder/secureswiftrandom . I recommend you copy and paste the code from: https://bitbucket.org/merarischroeder/secureswiftrandom/src/6c14b874f34a3f6576b0213379ecdf0ffc7496ea/Code/Alivate.SolidSwiftRandom/SolidSwiftRandom.cs?at=default&fileviewer=file-view-default (make sure you click the Raw button to make it easier to copy and make sure you have the latest version, I think this link goes to a specific version of the code, not the latest). Updated notes: Relating to some other answers - If you know the length of the output, you don't need a StringBuilder, and when using ToCharArray, this creates and fills the array (you don't need to create an empty array first) Relating to some other answers - You should use NextBytes, rather than getting one at a time for performance Technically you could pin the byte array for faster access.. it's usually worth it when your iterating more than 6-8 times over a byte array. (Not done here) Use of RNGCryptoServiceProvider for best randomness Use of caching of a 1MB buffer of random data - benchmarking shows cached single bytes access speed is ~1000x faster - taking 9ms over 1MB vs 989ms for uncached. Optimised rejection of bias zone within my new class. End solution to question: static char[] charSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".ToCharArray(); static int byteSize = 256; //Labelling convenience static int biasZone = byteSize - (byteSize % charSet.Length); public string GenerateRandomString(int Length) //Configurable output string length { byte[] rBytes = new byte[Length]; //Do as much before and after lock as possible char[] rName = new char[Length]; SecureFastRandom.GetNextBytesMax(rBytes, biasZone); for (var i = 0; i But you need my new (untested) class: /// /// My benchmarking showed that for RNGCryptoServiceProvider: /// 1. There is negligable benefit of sharing RNGCryptoServiceProvider object reference /// 2. Initial GetBytes takes 2ms, and an initial read of 1MB takes 3ms (starting to rise, but still negligable) /// 2. Cached is ~1000x faster for single byte at a time - taking 9ms over 1MB vs 989ms for uncached /// class SecureFastRandom { static byte[] byteCache = new byte[1000000]; //My benchmark showed that an initial read takes 2ms, and an initial read of this size takes 3ms (starting to raise) static int lastPosition = 0; static int remaining = 0; /// /// Static direct uncached access to the RNGCryptoServiceProvider GetBytes function /// /// public static void DirectGetBytes(byte[] buffer) { using (var r = new RNGCryptoServiceProvider()) { r.GetBytes(buffer); } } /// /// Main expected method to be called by user. Underlying random data is cached from RNGCryptoServiceProvider for best performance /// /// public static void GetBytes(byte[] buffer) { if (buffer.Length > byteCache.Length) { DirectGetBytes(buffer); return; } lock (byteCache) { if (buffer.Length > remaining) { DirectGetBytes(byteCache); lastPosition = 0; remaining = byteCache.Length; } Buffer.BlockCopy(byteCache, lastPosition, buffer, 0, buffer.Length); lastPosition += buffer.Length; remaining -= buffer.Length; } } /// /// Return a single byte from the cache of random data. /// /// public static byte GetByte() { lock (byteCache) { return UnsafeGetByte(); } } /// /// Shared with public GetByte and GetBytesWithMax, and not locked to reduce lock/unlocking in loops. Must be called within lock of byteCache. /// /// static byte UnsafeGetByte() { if (1 > remaining) { DirectGetBytes(byteCache); lastPosition = 0; remaining = byteCache.Length; } lastPosition++; remaining--; return byteCache[lastPosition - 1]; } /// /// Rejects bytes which are equal to or greater than max. This is useful for ensuring there is no bias when you are modulating with a non power of 2 number. /// /// /// public static void GetBytesWithMax(byte[] buffer, byte max) { if (buffer.Length > byteCache.Length / 2) //No point caching for larger sizes { DirectGetBytes(buffer); lock (byteCache) { UnsafeCheckBytesMax(buffer, max); } } else { lock (byteCache) { if (buffer.Length > remaining) //Recache if not enough remaining, discarding remaining - too much work to join two blocks DirectGetBytes(byteCache); Buffer.BlockCopy(byteCache, lastPosition, buffer, 0, buffer.Length); lastPosition += buffer.Length; remaining -= buffer.Length; UnsafeCheckBytesMax(buffer, max); } } } /// /// Checks buffer for bytes equal and above max. Must be called within lock of byteCache. /// /// /// static void UnsafeCheckBytesMax(byte[] buffer, byte max) { for (int i = 0; i = max) buffer[i] = UnsafeGetByte(); //Replace all bytes which are equal or above max } } } For history - my older solution for this answer, used Random object: private static char[] charSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".ToCharArray(); static rGen = new Random(); //Must share, because the clock seed only has Ticks (~10ms) resolution, yet lock has only 20-50ns delay. static int byteSize = 256; //Labelling convenience static int biasZone = byteSize - (byteSize % charSet.Length); static bool SlightlyMoreSecurityNeeded = true; //Configuration - needs to be true, if more security is desired and if charSet.Length is not divisible by 2^X. public string GenerateRandomString(int Length) //Configurable output string length { byte[] rBytes = new byte[Length]; //Do as much before and after lock as possible char[] rName = new char[Length]; lock (rGen) //~20-50ns { rGen.NextBytes(rBytes); for (int i = 0; i = biasZone) //Secure against 1/5 increased bias of index[0-7] values against others. Note: Must exclude where it == biasZone (that is >=), otherwise there's still a bias on index 0. rBytes[i] = rGen.NextByte(); rName[i] = charSet[rBytes[i] % charSet.Length]; } } return new string(rName); } Performance: SecureFastRandom - First single run = ~9-33ms . Imperceptible. Ongoing : 5ms (sometimes it goes up to 13ms) over 10,000 iterations, With a single average iteration= 1.5 microseconds. . Note: Requires generally 2, but occasionally up to 8 cache refreshes - depends on how many single bytes exceed the bias zone Random - First single run = ~0-1ms . Imperceptible. Ongoing : 5ms over 10,000 iterations. With a single average iteration= .5 microseconds. . About the same speed. Also check out: https://bitbucket.org/merarischroeder/number-range-with-no-bias/src https://stackoverflow.com/a/45118325/887092 These links are another approach. Buffering could be added to this new code base, but most important was exploring different approaches to removing bias, and benchmarking the speeds and pros/cons.
