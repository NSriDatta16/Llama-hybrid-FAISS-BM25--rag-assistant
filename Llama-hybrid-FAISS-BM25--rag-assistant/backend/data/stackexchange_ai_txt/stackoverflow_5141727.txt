[site]: stackoverflow
[post_id]: 5141727
[parent_id]: 5141402
[tags]: 
So you want to find the addresses of local variables without using the C operator designed specifically to find the address of a variable. Why? It's worth pointing out that, in any modern compiler/processor combination, the i and j in your example may not be on the stack if you don't use the & operator. Even if you do something with them so the compiler doesn't optimise them away, it may still choose to put them in registers. Edit: I've read your comment to datenwolf's answer and I think I know what you are being asked for. Here is a possible answer, but I must stress that I am making big assumptions about your compiler. In particular, all variables are stored on the stack variables aren't optimised away (turn off all optimisations in your compiler). storage space for automatic arrays is allocated directly on the stack the stack isn't cleaned between function calls If you have a function like this: int f() { int i = 1, j = 2; return 0; } You can inspect the order of i, j in memory with this function: void order() { int a[2]; if (a[0] == 1) { printf("i first\n"); } else { printf("j first\n"); } } int main() { f(); order(); return 0; } Never use anything like the above in real code. It relies on several pieces of officially undefined behaviour.
