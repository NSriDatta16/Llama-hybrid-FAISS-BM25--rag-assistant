[site]: stackoverflow
[post_id]: 460586
[parent_id]: 
[tags]: 
Simulating a 'local static' variable in python

Consider the following code: def CalcSomething(a): if CalcSomething._cache.has_key(a): return CalcSomething._cache[a] CalcSomething._cache[a] = ReallyCalc(a) return CalcSomething._cache[a] CalcSomething._cache = { } This is the easiest way I can think of for simulating a 'local static' variable in python. What bothers me is that CalcSomething._cache is mentioned outside the function's definition, but the alternative would be something like that: if not hasattr(CalcSomething, "_cache"): setattr(CalcSomething, "_cache", { } ) inside the function's definition, which is really cumbersome. Is there a more elegant way? [EDIT] Just to clarify, this question is not about local function caches, as the example above might suggest. Here is another short example where a 'static local' might be handy: def ParseString(s): return ParseString._parser.parse(s) # Create a Parser object once, which will be used for all parsings. # Assuming a Parser object is heave on resources, for the sake of this example. ParseString._parser = Parser()
