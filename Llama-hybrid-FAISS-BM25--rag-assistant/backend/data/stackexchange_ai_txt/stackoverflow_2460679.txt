[site]: stackoverflow
[post_id]: 2460679
[parent_id]: 2460451
[tags]: 
The way you're attempting to use delegates (constructing them with new , declaring a named delegate type) suggests that you're using C# 1. If you're actually using C# 3, it's much easier than that. Firstly, your delegate type: public delegate List GetAllNodesDelegate(int k); Already exists. It's just: Func > So you don't need to declare your own version of it. Secondly, you should think of a delegate as being like an interface with only one method in it, and you can "implement" it on the fly, without having to write a named class. Just write a lambda, or assign a method name directly. Func > getNodesFromInt; // just assign a compatible method directly getNodesFromInt = DoSomethingWithArgAndReturnList; // or bind extra arguments to an incompatible method: getNodesFromInt = arg => MakeList(arg, "anotherArgument"); // or write the whole thing specially: getNodesFromInt = arg => { var result = new List (); result.Add(new BaseNode()); return result; }; A lambda is of the form (arguments) => { body; } . The arguments are comma-separated. If there's only one, you can omit the parentheses. If it takes no parameters, put a pair of empty parentheses: () . If the body is only one statement long, you can omit the braces. If it's just a single expression, you can omit the braces and the return keyword. In the body, you can refer to practically any variables and methods from the enclosing scope (apart from ref / out parameters to the enclosing method). There's almost never any need to use new to create a delegate instance. And rarely a need to declare custom delegate types. Use Func for delegates that return a value and Action for delegates that return void . Whenever the thing you need to pass around is like an object with one method (whether an interface or a class), then use a delegate instead, and you'll be able to avoid a lot of mess. In particular, avoid defining interfaces with one method. It will just mean that instead of being able to write a lambda to implement that method, you'll have to declare a separate named class for each different implementation, with the pattern: class Impl : IOneMethod { // a bunch of fields public Impl(a bunch of parameters) { // assign all the parameters to their fields } public void TheOneMethod() { // make use of the fields } } A lambda effectively does all that for you, eliminating such mechanical patterns from your code. You just say: () => /* same code as in TheOneMethod */ It also has the advantage that you can update variables in the enclosing scope, because you can refer directly to them (instead of working with values copied into fields of a class). Sometimes this can be a disadvantage, if you don't want to modify the values.
