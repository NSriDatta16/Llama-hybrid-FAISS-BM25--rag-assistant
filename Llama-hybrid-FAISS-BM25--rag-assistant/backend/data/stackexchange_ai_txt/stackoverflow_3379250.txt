[site]: stackoverflow
[post_id]: 3379250
[parent_id]: 3378972
[tags]: 
At least at first glance, this seems to have a couple of problems. First: while ((line = strtok(buf, "\n\r"))) { To use strtok you normally pass the buffer on the first all, then make subsequent calls passing "NULL" for the first parameter until strtok returns a NULL (indicating that it's reached the end of the buffer). [Edit: upon further examination, it's apparent this isn't really a bug -- as pointed out by @Casablanca, he sets buf to NULL in the loop so the second and subsequent iterations actually do pass NULL for the first parameter -- so the current code is a bit hard to understand and (at least arguably) somewhat fragile, but not actually wrong.] Second, when you allocate your space, it looks like you're not allocating space for the terminating NUL: res[i] = (char*)malloc(sizeof(char) * strlen(line)); At least at first glance, it looks like this should be: res[i] = malloc(strlen(line)+1); [As an aside, sizeof(char)==1 and casting the return from malloc can mask the bug of failing to #include to get a proper prototype in scope.] Some of your other code isn't exactly wrong, but strikes me as less readable than ideal. For example: j = 0; while ((res[i][j] = tolower(line[j]))) { j++; } This appears to be a rather obfuscated way of writing: for (j=0; line[j] != '\0'; j++) res[i][j] = tolower((unsigned char)line[j]); Also note that when you call tolower , you generally need/want to cast the parameter to unsigned char (passing a negative value gives undefined behavior, and quite a few characters with accents, umlauts, etc., will normally show up as negative in the typical case that char is signed). You also seem to have a memory leak -- read_dict calls readfile , which allocates a buffer (with calloc -- why not malloc ?) and returns a pointer to that memory in a structure. read_dict receives the structure, but unless I've missed something, the struct goes out of scope without your ever freeing the memory it pointed to. Rather than try to find and fix the problem you've seen, my immediate reaction would be to start over. It seems to me that you've made the problem considerably more complex than it really is. If I were doing it, I'd probably start with a function to allocate space and read a line into the space, something on this order: // Warning: Untested code. #include #include #include char *readline(FILE *file) { char *buffer = NULL; size_t current_size = 1; char *temp; const int block_size = 256; do { if (NULL == (temp = realloc(buffer, current_size+block_size))) break; buffer = temp; buffer[current_size-1] = '\0'; if (fgets(buffer+current_size-1, block_size, file)==NULL) return strlen(buffer) > 0 ? buffer : NULL; current_size += block_size-1; } while (strchr(buffer, '\n') == NULL); strtok(buffer, "\n"); if (NULL != (temp = realloc(buffer, strlen(buffer)+1))) buffer =temp; return buffer; } Once that's working, reading all the lines in the file and converting them to upper-case comes out something like: // Warning: more untested code. while (res[i] = readline(file)) { size_t j; for (j=0; res[i][j]; j++) res[i][j] = toupper((unsigned char)res[i][j]); ++i; }
