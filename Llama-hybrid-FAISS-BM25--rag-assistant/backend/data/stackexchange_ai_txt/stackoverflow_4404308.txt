[site]: stackoverflow
[post_id]: 4404308
[parent_id]: 4365856
[tags]: 
I thought I post the main class #import "GLViewController.h" #import "ConstantsAndMacros.h" #import "OpenGLCommon.h" #import "WorldAppDelegate.h" #import "Tools.h" #import "glu.h" #define SPEED_MOVE 0.025 #define SPEED_TURN 0.05 #define MapSizeX 20 #define MapSizeZ 20 typedef struct { float x; float y; float z; } IMPoint3D; @interface GLViewController () - (void)updateData; - (BOOL)checkCollisionWithX:(float)x andWithZ:(float)z; - (void)loadTextures:(NSString *)textureName andWithIndex:(int)index; - (void)handleTouches; - (void)updateCoords; - (void)setupPlayer; - (void)addScene; - (void)loadTextureList; - (void)loadController; - (Boolean) checkCollission:(CGPoint)winPos object:(IMPoint3D) _object; - (CGPoint)getScreenCoorOfPoint:(IMPoint3D)_point3D; @end @implementation GLViewController @synthesize deviceID, players, label,collisionArray, baseURL; -(void)setupView:(GLView*)view { const GLfloat zNear = 0.1, zFar = 1000.0, fieldOfView = 120.0; GLfloat size = zNear * tanf(DEGREES_TO_RADIANS(fieldOfView) / 8.0); glEnable(GL_DEPTH_TEST); glMatrixMode(GL_PROJECTION); //Rotate the view glRotatef(-90,0,0,1); CGRect rect = self.view.bounds; glFrustumf(-size, size, -size / (rect.size.width / rect.size.height), size / (rect.size.width / rect.size.height), zNear, zFar); glViewport(0, 0, rect.size.width, rect.size.height); // Starting position eye[0] = -0; eye[1] = 3; eye[2] = -10; center[0] = 0; center[1] = 1.5; center[2] = 0; [self loadTextureList]; [self loadController]; [self loadTextureList ]; [self addScene]; [self setupPlayer]; [self updateCoords]; } // ... - (void)drawView:(UIView *)theView { // floor const GLfloat floorVertices[] = { -1, 0.0f, 1, 1, 0.0f, 1, 1, 0.0f, -1, -1, 0.0f, -1 }; const GLshort floorTextureCoords[] = { 0, 1, // top left 0, 0, // bottom left 1, 0, //bottom right 1, 1 //top right }; // Colour cube static const GLubyte cubeNumberOfIndices = 36; const GLubyte colourCubeFaceColors[] = { 0,255,0,255, 255,125,0,255, 255,0,0,255, 255,255,0,255, 0,0,255,255, 255,0,255,255 }; static const Vertex3D texturedVertices[]= { {-1.0, 1.0, 1.0}, // vertices[0] {1.0, 1.0, 1.0}, // vertices[1] {-1.0, -1.0, 1.0}, // vertices[2] {-1.0, -1.0, 1.0}, // vertices[3] {1.0, 1.0, 1.0}, // vertices[4] {1.0, -1.0, 1.0}, // vertices[5] {-1.0, 1.0, 1.0}, // vertices[6] {-1.0, 1.0, -1.0}, // vertices[7] {-1.0, -1.0, 1.0}, // vertices[8] {-1.0, -1.0, 1.0}, // vertices[9] {-1.0, 1.0, -1.0}, // vertices[10] {-1.0, -1.0, -1.0}, // vertices[11] {-1.0, 1.0, -1.0}, // vertices[12] {1.0, 1.0, -1.0}, // vertices[13] {-1.0, -1.0, -1.0}, // vertices[14] {-1.0, -1.0, -1.0}, // vertices[15] {1.0, 1.0, -1.0}, // vertices[16] {1.0, -1.0, -1.0}, {1.0, 1.0, 1.0}, {1.0, 1.0, -1.0}, {1.0, -1.0, 1.0}, {1.0, -1.0, 1.0}, {1.0, 1.0, -1.0}, {1.0, -1.0, -1.0}, {-1.0, 1.0, 1.0}, {-1.0, 1.0, -1.0}, {1.0, 1.0, 1.0}, {1.0, 1.0, 1.0}, {-1.0, 1.0, -1.0}, {1.0, 1.0, -1.0}, {-1.0, -1.0, 1.0}, {-1.0, -1.0, -1.0}, {1.0, -1.0, 1.0}, {1.0, -1.0, 1.0}, {-1.0, -1.0, -1.0}, {1.0, -1.0, -1.0}, }; static const GLubyte texturedCube[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, }; static const GLfloat texturedCubeCoord[] = { 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, }; glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glClearColor(0.0f, 0.0f, 0.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glColor4f(1.0, 1.0, 1.0, 1.0); glEnableClientState(GL_VERTEX_ARRAY); glEnableClientState(GL_TEXTURE_COORD_ARRAY); [self handleTouches]; //view : prebaked in to OPenGL Template gluLookAt(eye[0], eye[1], eye[2],center[0], center[1], center[2], 0.0, 1, 0.0); // draw the floor glPushMatrix(); //tell GL about our texture glMatrixMode(GL_TEXTURE); glScalef(20,20,1); glBindTexture(GL_TEXTURE_2D, 3); glMatrixMode(GL_MODELVIEW); glScalef(20,1,20); glTexCoordPointer(2, GL_SHORT, 0, floorTextureCoords); glVertexPointer(3, GL_FLOAT, 0, floorVertices); glDrawArrays(GL_TRIANGLE_FAN, 0, 4); glPopMatrix(); for (NSString *coords in self.collisionArray) { NSArray *coordsArray = [coords componentsSeparatedByString:@","]; float x = [[coordsArray objectAtIndex:0] floatValue] ; float z = [[coordsArray objectAtIndex:1] floatValue] ; float width = ([[coordsArray objectAtIndex:2] floatValue] /2) ; float length = ([[coordsArray objectAtIndex:3] floatValue] /2) ; glPushMatrix(); //tell GL about our texture glMatrixMode(GL_TEXTURE); glLoadIdentity(); if (width > length) { glScalef(width, 3, length); } else { glScalef(length, 3, width); } glBindTexture(GL_TEXTURE_2D, ([[coordsArray objectAtIndex:4] floatValue])); glMatrixMode(GL_MODELVIEW); glTranslatef(x, 3, z); glScalef(width, 3, length); glVertexPointer(3, GL_FLOAT, 0, texturedVertices); glTexCoordPointer(2, GL_FLOAT, 0, texturedCubeCoord); glDrawElements(GL_TRIANGLES,cubeNumberOfIndices , GL_UNSIGNED_BYTE, texturedCube); glPopMatrix(); } float x; float z; float playerRotation; for (NSDictionary *item in self.players) { x = [[item objectForKey:@"posX"] floatValue]; z = [[item objectForKey:@"posZ"] floatValue]; playerRotation = [[item objectForKey:@"rotation"] floatValue]; glPushMatrix(); glTranslatef(x, 1 , z); glRotatef(playerRotation, 0, 1, 0); //Reset textures glMatrixMode(GL_TEXTURE); glLoadIdentity(); glMatrixMode(GL_MODELVIEW); glVertexPointer(3, GL_FLOAT, 0, texturedVertices); glTexCoordPointer(2, GL_FLOAT, 0, texturedCubeCoord); glBindTexture(GL_TEXTURE_2D, 1); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, &texturedCube[0]); glBindTexture(GL_TEXTURE_2D, 4); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, &texturedCube[6]); int colorIndex = 0; glBindTexture(GL_TEXTURE_2D, 0); glColor4ub(colourCubeFaceColors[colorIndex], colourCubeFaceColors[colorIndex+1], colourCubeFaceColors[colorIndex+2], colourCubeFaceColors[colorIndex+3]); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, &texturedCube[12]); glPopMatrix(); } // GL teardown glDisableClientState(GL_TEXTURE_COORD_ARRAY); glDisableClientState(GL_VERTEX_ARRAY); } - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { CGPoint pos = [[touches anyObject] locationInView:self.view]; /* int i = 0; for (NSDictionary *item in self.players) { IMPoint3D playerPos; playerPos.x = [[item objectForKey:@"posX"] floatValue]; playerPos.z = [[item objectForKey:@"posZ"] floatValue]; playerPos.y = 1.0f; if([self checkCollission:pos object:playerPos]) { NSLog(@"FIRE I LOVE YOU MAN %i", i); } } */ for (NSDictionary *item in self.players) { int x; int z; x = [[item objectForKey:@"posX"] floatValue]; z = [[item objectForKey:@"posZ"] floatValue]; IMPoint3D playerPos; playerPos.x = x; playerPos.z = z; playerPos.y = 1; CGPoint screenPositionOfThisCube ; screenPositionOfThisCube = [self getScreenCoorOfPoint:playerPos]; #define TUNE 5 CGRect fingerSquish = CGRectMake( screenPositionOfThisCube.x - TUNE, screenPositionOfThisCube.y - TUNE, TUNE * 2, TUNE * 2); // now check that the POINT OF THE TOUCH // is inside the rect fingerSquish if ( CGRectContainsPoint( fingerSquish, pos ) ) { NSLog(@"WOOP"); // YOU HAVE FOUND THE TOUCHED CUBEY. // YOU ARE DONE. this item is the cube being touched. // make the cube change color or something to test it. } } //left if ( pos.x >= 35 && pos.x = 0 && pos.y = 35 && pos.x = 80 && pos.y = 80 && pos.x = 32 && pos.y = 0 && pos.x = 32 && pos.y MapSizeZ || eye[0] > MapSizeX || eye[2] MapSizeZ || eye[0] > MapSizeX || eye[2] x1 && x z1 && z
