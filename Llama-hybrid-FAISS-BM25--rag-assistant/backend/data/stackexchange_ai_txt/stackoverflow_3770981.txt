[site]: stackoverflow
[post_id]: 3770981
[parent_id]: 3770842
[tags]: 
why isn't that templated? Because standard containers are implemented to use the largest unsigned type that they reasonably can. If size_type is unsigned int in your implementation then that's for a reason, and whatever the reason is that prevented the implementers using a larger type, would still exist if you asked for something else[*]. Also, for your particular example, size types have to be unsigned, and you want to use a signed type, so that's another change that would be needed to support what you want to do. In practice, size_type for a standard container is (almost?) always size_t . So if you asked for a larger vector, you couldn't have one, because a vector is backed by contiguous storage. The vector would be unable to allocate an array bigger than size_t bytes. To use your Id as a vector index, you can either rely on implicit conversions, or you can explicitly convert (and, perhaps, explicitly bounds check) in order to make it absolutely clear what you are doing. You could also use asserts to ensure that Id is no bigger than size_type . Something like this, although a static assert would probably be better: assert(std::numeric_limits ::max() ::size_type>::max()); A map would be a good option if the Id values in use are sparse. If the only valid Ids are 1 and 400,000,000, then a vector would be rather wasteful of memory. If it makes you feel any more comfortable, remember that the literal 0 has type int , not vector ::size_type . Most people have no qualms about writing vec[0] : indeed it's used in the standard. [*] Even if that reason is just, "the implementers think that 4 billion elements is enough for anyone".
