[site]: stackoverflow
[post_id]: 206810
[parent_id]: 206438
[tags]: 
If you just want to store the string for a short period of time in memory, you can take a look at System.Security.SecureString . Taken from this answer : SecureString values are stored encrypted (obfuscated, rather), but most importantly, they are never swapped to disk and can be disposed of immediately when you're done with them. They're tricky to use because you can only build them one character at a time (to encourage you to build them by capturing keystrokes as the user types their password), and require three lines of code to recover and then wipe their plain text, but when used properly they can make a program more secure by avoiding the virtual-memory vulnerability. At the end of the example the SecureString is converted into a regular managed string, which makes it vulnerable again (be sure to use the try-catch-finally pattern to Zero the string after you're done with it). SecureString's use is in reducing the surface-area of attack by limiting the number of copies the Garbage Collector will make of the value, and reducing the likelihood of being written to the swap file. // Make a SecureString SecureString sPassphrase = new SecureString(); Console.WriteLine("Please enter your passphrase"); ConsoleKeyInfo input = Console.ReadKey(true); while (input.Key != ConsoleKey.Enter) { sPassphrase.AppendChar(input.KeyChar); Console.Write('*'); input = Console.ReadKey(true); } sPassphrase.MakeReadOnly(); // Recover plaintext from a SecureString // Marshal is in the System.Runtime.InteropServices namespace try { IntPtr ptrPassphrase = Marshal.SecureStringToBSTR(sPassphrase); string uPassphrase = Marshal.PtrToStringUni(ptrPassphrase); // ... use the string ... } catch { // error handling } finally { Marshal.ZeroFreeBSTR(ptrPassphrase); }
