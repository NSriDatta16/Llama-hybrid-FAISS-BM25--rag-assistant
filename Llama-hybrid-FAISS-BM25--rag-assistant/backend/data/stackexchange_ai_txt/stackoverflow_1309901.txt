[site]: stackoverflow
[post_id]: 1309901
[parent_id]: 1309863
[tags]: 
I'm not sure if this is exactly what you're looking for, but you can use Graphviz dot to model/graph relationships. Here's the updated content of the .dot file, more like your clarification: digraph G { compound = true // allow edges between clusters subgraph cluster_ab { rank = same; A -> B -> A } A -> C [ltail=cluster_ab] A -> D [ltail=cluster_ab] A -> E [ltail=cluster_ab] subgraph cluster_ef { rank = same; E -> F -> E } E -> G [ltail=cluster_ef] E -> H [ltail=cluster_ef] subgraph cluster_ei { E -> I -> E } I -> J [ltail=cluster_ei] I -> K [ltail=cluster_ei] } sample dot output http://img21.imageshack.us/img21/6177/64094067.png This one is a little different, because you can't create overlapping clusters (E->I and E->F). But I think it's more like the way you've clarified, even though it isn't terribly apparent that E and I are siblings -- I also had to make sure to link from I to J,K, otherwise there was a warning and it looked a bit uglier. There are plenty of libraries that interface with Graphviz/dot that would let you generate these kinds of graphs dynamically, rather than by hand as I did. Then if you've already got a library to store/retrieve directed graphs, you're pretty much there on storing hierarchical data. As to whether it's efficient , as you mentioned in your question... depends on how much data you're storing, of course. As @Kim points out in the comments, you can get a quite simplified graph by treating siblings as pairs, rather than individual nodes: digraph G { "A,B" -> C "A,B" -> D "A,B" -> E "E,F" -> G "E,F" -> H "E,I" -> J "E,I" -> K } It's an obvious and elegant solution that I completely overlooked, although it remains a little ambiguous about sibling relationships when overlap occurs (E again). simpler graph http://img35.imageshack.us/img35/8969/so2b.png
