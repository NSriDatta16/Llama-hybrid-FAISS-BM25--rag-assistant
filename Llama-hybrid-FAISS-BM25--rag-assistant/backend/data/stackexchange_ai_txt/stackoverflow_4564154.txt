[site]: stackoverflow
[post_id]: 4564154
[parent_id]: 
[tags]: 
ipad coredata error

happy holidays! so, Im grappling with coredata!, now I have info showing in a viewController in a table, but when I put the table in a second viewController called from the first, I get> entityForName: could not locate an NSManagedObjectModel for entity name 'Contacts'' even though the code was working as mentioned before(in just one view), what shall I do? thank you so much! The little test project is Here the project saves a contact (verified in a SQLite manager) but when taken to another view to check the contacts in a table it crashes, the part of the showing something of a db in a table inside the UIViewcontroller is working code also but in the main view not yet from this called xib, thanks here the code, (show.h, the view loaded from the main view..) #import @interface ShowViewController : UIViewController { NSFetchedResultsController *_fetchedResultsController; NSManagedObjectContext *_context; UITableView *tableView;} @property (nonatomic, retain) NSFetchedResultsController *fetchedResultsController; @property (nonatomic, retain) NSManagedObjectContext *context; @property (nonatomic, retain) IBOutlet UITableView *tableView; -(IBAction) btnStart:(id) sender; @end (show.m) #import "ShowViewController.h" #import "Contacts.h" @implementation ShowViewController @synthesize context = _context; @synthesize fetchedResultsController = _fetchedResultsController; @synthesize tableView; -(IBAction) btnStart:(id) sender{ initWithNibName:@"StartViewController" bundle:nil]; [UIView beginAnimations:@"flipping view" context:nil]; [UIView setAnimationDuration:1]; [UIView setAnimationCurve:UIViewAnimationCurveEaseIn]; [UIView setAnimationTransition: UIViewAnimationTransitionCurlUp forView:self.view.superview cache:YES]; [self.view removeFromSuperview]; [UIView commitAnimations]; } - (NSFetchedResultsController *)fetchedResultsController { if (_fetchedResultsController != nil) { return _fetchedResultsController; } NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init]; NSEntityDescription *entity = [NSEntityDescription entityForName:@"Contacts" inManagedObjectContext:_context]; [fetchRequest setEntity:entity]; //NSSortDescriptor *sort = [[NSSortDescriptor alloc] initWithKey:@"details.closeDate" ascending:NO]; //[fetchRequest setSortDescriptors:[NSArray arrayWithObject:sort]]; [fetchRequest setFetchBatchSize:20]; NSFetchedResultsController *theFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:_context sectionNameKeyPath:nil cacheName:@"Root"]; self.fetchedResultsController = theFetchedResultsController; _fetchedResultsController.delegate = self; [fetchRequest release]; [theFetchedResultsController release]; return _fetchedResultsController; } - (void)viewDidLoad { [super viewDidLoad]; /*array = [[NSMutableArray alloc] init]; [array addObject:@"Sports"]; [array addObject:@"Entertainment"]; [array addObject:@"Art"]; [array addObject:@"Technology"];*/ NSError *error; if (![[self fetchedResultsController] performFetch:&error]) { // Update to handle the error appropriately. NSLog(@"Unresolved error %@, %@", error, [error userInfo]); exit(-1); // Fail } } - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc that aren't in use. } - (void)viewDidUnload { self.fetchedResultsController = nil; [super viewDidUnload]; // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; } - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { id sectionInfo = [[_fetchedResultsController sections] objectAtIndex:section]; return [sectionInfo numberOfObjects]; //return [array count]; //return [[fetchedResultsController sections] count]; } - (void)configureCell:(UITableViewCell *)cell atIndexPath:(NSIndexPath *)indexPath { Contacts *info = [_fetchedResultsController objectAtIndexPath:indexPath]; cell.textLabel.text = info.name; //cell.detailTextLabel.text = [NSString stringWithFormat:@"%@, %@", info.city, info.state]; } //---insert individual row into the table view--- - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath { static NSString *CellIdentifier = @"Cell"; //---try to get a reusable cell--- UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; //---create new cell if no reusable cell is available--- if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease]; } [self configureCell:cell atIndexPath:indexPath]; return cell; } - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { [tableView deselectRowAtIndexPath:indexPath animated:YES]; } - (BOOL)shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation)interfaceOrientation { // Overriden to allow any orientation. return YES; } - (void)dealloc { self.fetchedResultsController = nil; self.context = nil; [super dealloc]; } #pragma mark NSFetchedResultsControllerDelegate methods - (void)controllerWillChangeContent:(NSFetchedResultsController *)controller { // The fetch controller is about to start sending change notifications, so prepare the table view for updates. [self.tableView beginUpdates]; } - (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType: (NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath { UITableView *tableView = self.tableView; switch(type) { case NSFetchedResultsChangeInsert: [tableView insertRowsAtIndexPaths:[NSArray arrayWithObject:newIndexPath] withRowAnimation:UITableViewRowAnimationFade]; break; case NSFetchedResultsChangeDelete: [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade]; break; case NSFetchedResultsChangeUpdate: [self configureCell:[tableView cellForRowAtIndexPath:indexPath] atIndexPath:indexPath]; break; case NSFetchedResultsChangeMove: [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade]; // Reloading the section inserts a new row and ensures that titles are updated appropriately. [tableView reloadSections:[NSIndexSet indexSetWithIndex:newIndexPath.section] withRowAnimation:UITableViewRowAnimationFade]; break; } } - (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id )sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType: (NSFetchedResultsChangeType)type { switch(type) { case NSFetchedResultsChangeInsert: [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; case NSFetchedResultsChangeDelete: [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; } } - (void)controllerDidChangeContent:(NSFetchedResultsController *)controller { // The fetch controller has sent all current change notifications, so tell the table view to process all updates. [self.tableView endUpdates]; } @end
