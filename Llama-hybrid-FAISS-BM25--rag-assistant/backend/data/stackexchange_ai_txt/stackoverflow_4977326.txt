[site]: stackoverflow
[post_id]: 4977326
[parent_id]: 4977306
[tags]: 
Have you tried a solution which uses synchronization, and found it doesn't perform well enough? You say you've determined that it's unacceptably slow - how slow was it, and do you already have a performance budget? Normally, obtaining an uncontested lock is extremely cheap, so I wouldn't expect it to be a problem. There may well be some clever lock-free solution - but it's likely to be significantly more complicated than just synchronizing whenever you need to access shared data. I understand that lock-free coding is all the rage, and scales beautifully when you can do it - but if you've got one thread interfering with another's data, it's very hard to do it safely. Just to be clear, I like using lock-free code when I can use high-level abstractions created by experts - things like the Parallel Extensions in .NET 4. I just don't like working with low-level abstractions like volatile variables if I can help it. Try locking, and benchmark it. Work out what performance is acceptable, and compare the performance of a simple solution with that goal. Of course, one option is redesigning... does the flushing have to happen actively in a different thread? Could the individual writer threads not just hand off the buffer to the flushing thread (and start a different buffer) periodically? That would make things a lot simpler. EDIT: Regarding your "flush signal" idea - I'd been thinking along similar lines. But you need to be careful about how you do it so that the signal can't get lost even if one thread takes a long time to process whatever it's doing. I suggest you make thread A publish a "flush counter"... and each thread keeps its own counter of when it last flushed. EDIT: Just realized this is Java, not C# - updated :) Use AtomicLong.incrementAndGet() to increment from thread A, and AtomicLong.get() to read from the other threads. Then in each thread, compare whether you're "up to date", and flush if necessary: private long lastFlush; // Last counter for our flush private Flusher flusher; // The single flusher used by all threads public void write(...) { long latestFlush = flusher.getCount(); // Will use AtomicLong.get() internally if (latestFlush > lastFlush) { flusher.Flush(data); // Do whatever else you need lastFlush = latestFlush; // Don't use flusher.getCount() here! } // Now do the normal write } Note that this assumes you only ever need to check for flushing in the Write method. Obviously that may not be the case, but hopefully you can adapt the idea.
