[site]: stackoverflow
[post_id]: 994412
[parent_id]: 994382
[tags]: 
System.IO.Stream uses the decorator pattern so it makes it pretty easy to create your own which wraps an underlying stream. This allows streams such as CryptoStream and GZipStream to wrap any other Stream instance and effectively "override" its Read/Write methods without deriving from the class you want to extend. Very flexible and popular design pattern described in the Gang of Four book. Now I'm not sure if the API you're working with requires a Stream or StreamReader. There is a significant distinction between the two. A StreamReader works at the text level and operations on characters/lines. A Stream works at the binary level and operates on bytes. In other words, the StreamReader is expected to be able to decode the bytes into text so that the consumer doesn't need to be concerned about the encoding. Use a Stream when encoding doesn't matter (such as when compressing or encyrpting) and use a StreamReader when working with text data. From what it sounds like, a StreamReader would make more sense here. If the API can accept a StreamReader, just derive your own from TextReader and override its ReadLine method so that the first call returns the line of text you need appended and subsequent calls just function as normal. The other option is to just use a StringWriter/StringReader and stuff it all into an in-memory string buffer, manipulate it, then pass it.
