[site]: stackoverflow
[post_id]: 2243646
[parent_id]: 
[tags]: 
Object Detection in openCV

I have a problem with my program written in Visual C++ using OpenCV: i have to capture frames from webcam and find all the various rectangle (it doesn't matter the color). I try to modify the samples in c, squares.c, but it doesn't work as well, because the program wait any key (different from 'q') to continue. This is the code. Someone can tell me where is the problem??? Thank you in advance. // // Object Detection of squares // Take images from webcam and find the square in them // // #include "stdafx.h" #include #include #include int thresh = 50; IplImage* img = 0; IplImage* img0 = 0; CvMemStorage* storage = 0; //const char* wndname = "Square Detection Demo with Webcam"; // helper function: // finds a cosine of angle between vectors // from pt0->pt1 and from pt0->pt2 double angle( CvPoint* pt1, CvPoint* pt2, CvPoint* pt0 ) { double dx1 = pt1->x - pt0->x; double dy1 = pt1->y - pt0->y; double dx2 = pt2->x - pt0->x; double dy2 = pt2->y - pt0->y; return (dx1*dx2 + dy1*dy2)/sqrt((dx1*dx1 + dy1*dy1)*(dx2*dx2 + dy2*dy2) + 1e-10); } // returns sequence of squares detected on the image. // the sequence is stored in the specified memory storage CvSeq* findSquares4( IplImage* img, CvMemStorage* storage ) { CvSeq* contours; int i, c, l, N = 11; CvSize sz = cvSize( img->width & -2, img->height & -2 ); IplImage* timg = cvCloneImage( img ); // make a copy of input image IplImage* gray = cvCreateImage( sz, 8, 1 ); IplImage* pyr = cvCreateImage( cvSize(sz.width/2, sz.height/2), 8, 3 ); IplImage* tgray; CvSeq* result; double s, t; // create empty sequence that will contain points - // 4 points per square (the square's vertices) CvSeq* squares = cvCreateSeq( 0, sizeof(CvSeq), sizeof(CvPoint), storage ); // select the maximum ROI in the image // with the width and height divisible by 2 cvSetImageROI( timg, cvRect( 0, 0, sz.width, sz.height )); // down-scale and upscale the image to filter out the noise cvPyrDown( timg, pyr, 7 ); cvPyrUp( pyr, timg, 7 ); tgray = cvCreateImage( sz, 8, 1 ); // find squares in every color plane of the image for( c = 0; c total == 4 && fabs(cvContourArea(result,CV_WHOLE_SEQ)) > 1000 && cvCheckContourConvexity(result) ) { s = 0; printf("ciclo for annidato fino a 5\t\n"); for( i = 0; i = 2 ) { t = fabs(angle( (CvPoint*)cvGetSeqElem( result, i ), (CvPoint*)cvGetSeqElem( result, i-2 ), (CvPoint*)cvGetSeqElem( result, i-1 ))); s = s > t ? s : t; } } // if cosines of all angles are small // (all angles are ~90 degree) then write quandrange // vertices to resultant sequence if( s h_next; } } } // release all the temporary images cvReleaseImage( &gray ); cvReleaseImage( &pyr ); cvReleaseImage( &tgray ); cvReleaseImage( &timg ); return squares; } // the function draws all the squares in the image void drawSquares( IplImage* img, CvSeq* squares ) { CvSeqReader reader; IplImage* cpy = cvCloneImage( img ); int i; // initialize reader of the sequence cvStartReadSeq( squares, &reader, 0 ); // read 4 sequence elements at a time (all vertices of a square) for( i = 0; i total; i += 4 ) { CvPoint pt[4], *rect = pt; int count = 4; // read 4 vertices CV_READ_SEQ_ELEM( pt[0], reader ); CV_READ_SEQ_ELEM( pt[1], reader ); CV_READ_SEQ_ELEM( pt[2], reader ); CV_READ_SEQ_ELEM( pt[3], reader ); // draw the square as a closed polyline cvPolyLine( cpy, &rect, &count, 1, 1, CV_RGB(0,255,0), 3, CV_AA, 0 ); } cvSaveImage("squares.jpg",cpy); //show the resultant image //cvShowImage( wndname, cpy ); cvReleaseImage( &cpy ); //return cpy; } int _tmain(int argc, _TCHAR* argv[]) { int key = 0; IplImage* frame =0; IplImage* squares=0; // create memory storage that will contain all the dynamic data storage = cvCreateMemStorage(0); CvCapture *camera = cvCreateCameraCapture(CV_CAP_ANY); /* Usa USB camera */ frame = cvQueryFrame(camera); frame = cvQueryFrame(camera); frame = cvQueryFrame(camera); while(key!='q'){ frame = cvQueryFrame(camera); frame = cvQueryFrame(camera); if(frame!=NULL){ printf("Got frame\t\n"); cvSaveImage("frame.jpg", frame); /*img0*/ img = cvLoadImage("frame.jpg"); //img = cvCloneImage( img0 ); cvNamedWindow( "img0", CV_WINDOW_AUTOSIZE); cvShowImage("img0",/*img0*/img); // find and draw the squares drawSquares( img, findSquares4( img, storage ) ); squares = cvLoadImage("squares.jpg"); // create window and a trackbar (slider) //with parent "image" and set callback //(the slider regulates upper threshold, //passed to Canny edge detector) cvNamedWindow( "main", CV_WINDOW_AUTOSIZE); cvShowImage("main", squares); /* wait for key. Also the function cvWaitKey takes care of event processing */ key = cvWaitKey(0); } } // release both images cvReleaseImage( &img ); cvReleaseImage( &img0 ); cvReleaseCapture(&camera); cvDestroyWindow("main"); cvDestroyWindow("img0"); // clear memory storage - reset free space position cvClearMemStorage( storage ); return 0; }
