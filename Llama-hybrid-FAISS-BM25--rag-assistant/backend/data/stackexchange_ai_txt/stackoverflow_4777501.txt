[site]: stackoverflow
[post_id]: 4777501
[parent_id]: 4777130
[tags]: 
If we take a look at your definition, exists :: (t -> Bool) -> [t] -> Bool exists f a []=error exists f a (x:xs) |if x∈f a =True |otherwise= x:f a xs We see that your type is exists :: (t -> Bool) -> [t] -> Bool So exists must take two parameters, one predicate function of type (t -> Bool) and one list of type [t] . It returns a Bool . This seem okay as per our intention of the specification. Let us look at the first line of your terms: exists f a [] = error This function suddenly takes three parameters. The f and the empty list constructor [] looks okay, but the a is not mentioned in the type specification. Hence, we prune it out: exists f [] = error Now, the error returned is not of boolean value. But the spec says it must be. Let us suppose we are asking exists ( . Then would a natural answer to the question be True or False ? Or paraphrased, is there any element x in [] satisfying the predicate f x ? On to the next line, exists f a (x:xs) |if x∈f a =True |otherwise= x:f a xs We learned that the a has to go by the type specification, so let us prune it. Since we have now grown a natural dislike for the a , why not prune it everywhere it occur. Also, since the if will produce a syntax error, lets rid ourselves of that too: exists f (x:xs) | x∈f = True | otherwise = x:f xs The x∈f does not make much sense, but f x does. The guard variant will be taken if f x returns true. Now, the True which is returned here sounds about right. It signifies that we have found an element in the list matching the predicate - and lo n' behold, x might be it! So we turn our attention to the final line. The otherwise means that the guard f x did not return True. As a consequence, the x is not satisfying the predicate, so we must search the rest of the list. The Right-hand-side x : f xs is peculiar. The : means that we will try to return a list, but the return type of the function is something of type Bool . The type checker won't like us if we try this. Furthermore, we have no reason to look at the x anymore since we just determined it does not satisfy the predicate. The key thing you are missing is that we need recursion at this point. We need to search the tail xs of the list somehow - and recursion means to invoke the exists function on the tail. Your general track is right, but ask again if something is unclear. One trick might be to go by the types for the recursion case: "What do i have to supply exists for it to return a Bool value?".
