[site]: stackoverflow
[post_id]: 4404170
[parent_id]: 
[tags]: 
Is this use of global static initialization okay for a "busybox" style application?

Still working on my closed/open source hybrid talked about earlier in this question . The application in question is actually a busybox like application -- there are several programs bundled into a single program, and the actual program run is chosen based upon the first command entered. This allows the sub-programs to share one copy of the CRT (I can't use the installable redist because I need to maintain single binary deployment), as well as several internals which are useful in several of the sub programs. Because some of the sub programs themselves cannot be released as a result of licensing restrictions, I'm considering using a startup like this. (Sorry for the amount of code :( ) ISubProgram.hpp #include struct ISubProgram { virtual std::wstring GetExecutive() const = 0; //Return sub program name virtual void OnStart(int argc, const char *argv[]) {}; virtual int Run(int argc, const char *argv[]) = 0; virtual ~ISubProgram() {} }; SubProgramList.hpp #include #include #include #include "ISubProgram.hpp" class SubProgramList; SubProgramList& GetSubProgramList(); class SubProgramList : boost::noncopyable { friend SubProgramList& GetSubProgramList(); SubProgramList() {} //Disallow direct creation. boost::ptr_map programs; public: void RegisterProgram(std::auto_ptr subProgramToRegister); ISubProgram * FindProgramFromExecutive(const std::wstring& executive); void CallOnStartMethods(int argc, char *argv[]); }; template struct RegisterSubProgram { RegisterSubProgram() { std::auto_ptr toAdd(new T); GetSubProgramList().RegisterProgram(toAdd); } } SubProgramList.cpp SubProgramList& GetSubProgramList() { static SubProgramList theList; return theList; } //Implementations of the class methods ExampleSubProgram.cpp #include "SubProgramList.hpp" struct ExampleSubProgram : public ISubProgram { virtual std::wstring GetExecutive() { return L"ExampleSubProgram"; } virtual int Run(int argc, const char *argv[]) { //Run this program :) } }; namespace { RegisterSubProgram registrar; } Main.cpp #include "SubProgramList.hpp" int main(int argc, char *argv[]) { SubProgramList& list = GetSubProgramList(); list.CallOnStartMethods(argc, argv); std::wstring subProgramName(/*.. Generate from argv[1] ...*/); FindProgramFromExecutive(subProgramName)->Run(argc, argv); } I think I'm clear of initialization order issues because the only global state is a local static rather than a global static. The main reason for this is that I can completely pull apart the closed source and open source bits of the program, which would make merging quick and efficient, and also removes the boilerplate of my current "Giant if/else subprogram selector" in main . Is this a reasonable use of on-start initialization (which is generally discouraged?) If not, what alternate implementation would you suggest?
