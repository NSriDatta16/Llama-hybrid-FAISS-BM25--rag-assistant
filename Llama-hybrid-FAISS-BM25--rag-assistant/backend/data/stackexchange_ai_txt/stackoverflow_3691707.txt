[site]: stackoverflow
[post_id]: 3691707
[parent_id]: 3691667
[tags]: 
The first thing I'd do is capture the transformation into a method somewhere (where "somewhere" is either an instance method on an appropriate object or a class method on a utility class). - (NSString *) transformString: (NSString *) aString { NSString *transformedString; transformedString = [aString stringByReplacingOccurrencesOfString:@"\n" withString:@" "]; transformedString = [transformedString stringByReplacingOccurrencesOfString:@"&" withString:@"and"]; transformedString = [transformedString stringByReplacingOccurrencesOfString:@"garçon" withString:@"garcon"]; transformedString = [transformedString stringByReplacingOccurrencesOfString:@"Garçon" withString:@"Garcon"]; transformedString = [transformedString stringByReplacingOccurrencesOfString:@"+" withString:@"and"]; transformedString = [transformedString stringByAddingPercentEscapesUsingEncoding:NSASCIIStringEncoding]; return transformedString; } Then: NSString *result = [myTransformer transformString: tVA.text]; A bit brutish, but it'll work. And by "brutish", I mean that it is going to be slow and will cause a bunch of interim strings to pile up in the autorelease pool. However, if this is something that you only do every now and then, don't worry about it -- while brutish, it is certainly quite straightforward. If, however, this shows up in performance analysis as a bottleneck, you could first move to using NSMutableString as it has methods for doing replacements in place. That, at least, will reduce memory thrash and will likely be a bit faster in that there is less copying of strings going on. If that is still too slow, then you will likely need to write yourself a fun little bit of parsing and processing code that walks through the original and copies it to new a new string while also doing any necessary transforms along the way. But, don't bother optimizing until you prove that it is a problem. And, of course, if it is a problem, you have just one method to optimize!
