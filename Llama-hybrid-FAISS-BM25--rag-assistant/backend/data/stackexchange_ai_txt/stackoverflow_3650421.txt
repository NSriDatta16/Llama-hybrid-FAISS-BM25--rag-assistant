[site]: stackoverflow
[post_id]: 3650421
[parent_id]: 3650256
[tags]: 
Basically you have the right answer already - well done you. :) Carat (^) in a set [^abc] will only match where it does not find a character in that set so it's application for matching orders of characters (i.e. strings) is limited and weak. Regex has numeric quantifiers {n} and {a,b} which allow you to match a defined number of repititions of a pattern, which would work for this specific pattern (because it's 'x' repeated) but it's not particularily expressive of the problem you're trying to solve (even for regex!) and is a bit brittle (it wouldn't be appropriate for negative match 'xyx' for example. An or pattern again would be verbose and rather unexpressive but it could be done as the fragment: (x|xx)[^x] // x OR xx followed by NOT x Obviously you can do this with an iterative algorithm but that's highly inefficient compared to a regex. Well done for thinking beyond the solution though.
