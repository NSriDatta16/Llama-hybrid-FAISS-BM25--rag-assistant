[site]: stackoverflow
[post_id]: 4666759
[parent_id]: 4666450
[tags]: 
One way might be: std::vector data = /* obtain bits somehow */ // Reserve an appropriate number of byte-sized buckets. std::vector bytes((int)std::ceil((float)data.size() / CHAR_BITS)); for(int byteIndex = 0; byteIndex Note that this assumes you don't care what the bit layout ends up being in memory, because it makes no adjustments for anything. But as long as you also serialize out the number of bits that were actually stored (to cover cases where you have a bit count that isn't a multiple of CHAR_BITS) you can deserialize exactly the same bitset or vector as you had originally like this. (I'm not happy with that bucket size computation but it's 1am and I'm having trouble thinking of something more elegant).
