[site]: stackoverflow
[post_id]: 835293
[parent_id]: 834383
[tags]: 
For me, one of the most important, will be: unique_ptr + std::move() ! Imagine: Smart pointer without any overhead: no reference counting operations no additional storage for reference counter variable Smart pointer that can be moved , ie. no destructor/constructor calls when moved What does this give you? Exception safe, cheap (pointers..) containers without any costs . The container will be able to just memcpy() unique_ptrs, so there will be no performance loss caused by wrapping regular pointer by smart pointer! So, once again: You can use pointers It will be safe (no memory leaks) It will cost you nothing You will be able to store them in containers, and they will be able to do "massive" moves (memcpy-like) with them cheaply. It will be exception safe :) Another point of view: Actually, when you move group of objects using copy(), there is constructor and destructor call for every object instance. When you copy 1000 objects of 1kb size, there will be at least one memcpy() and 2000 function calls. If you would want to avoid the thousands of calls, you would have to use pointers. But pointers are: dangerous, etc. Actual smart pointers will not help you, they solve other problems. There is no solution for now. You must pay for C++ RAII/pointer/valuevars design from time to time. But with C++0x, using unique_ptr will allow to do "massive" moves of objects (yes, practically objects, because pointer will be smart) without "massive" constructor/destructor calls, and without risk of using pointers! For me, this is really important. It's like relaxing the RAII concept (because of using pointers) without loosing RAII benefits. Another aspect: pointer wrapped in unique_ptr() will behave in many aspects similar to java reference object variable. The difference is that unique_ptr() will be able to exist in only one scope at a time.
