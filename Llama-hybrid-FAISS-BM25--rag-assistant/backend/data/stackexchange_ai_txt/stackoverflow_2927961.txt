[site]: stackoverflow
[post_id]: 2927961
[parent_id]: 2927250
[tags]: 
This really seems quite trivial, so I suppose we miss some requirements. Use Memoization to avoid computing the result more than once. This should be done in the framework. You could use some flowchart to determine how to make the information pass from one module to another... but the simplest way is to have each module directly calling those they depend upon. With memoization it does not cost much since if it's already been computed, you're fine. Since you need to be able to launch about any module, you need to give them IDs and register them somewhere with a way to look them up at runtime. There are two ways to do this. Exemplar: You get the unique exemplar of this kind of module and execute it. Factory: You create a module of the kind requested, execute it and throw it away. The downside of the Exemplar method is that if you execute the module twice, you'll not be starting from a clean state but from the state that the last (possibly failed) execution left it in. For memoization it might be seen as an advantage, but if it failed the result is not computed (urgh), so I would recommend against it. So how do you ... ? Let's begin with the factory. class Module; class Result; class Organizer { public: void AddModule(std::string id, const Module& module); void RemoveModule(const std::string& id); const Result* GetResult(const std::string& id) const; private: typedef std::map > ModulesType; typedef std::map > ResultsType; ModulesType mModules; mutable ResultsType mResults; // Memoization }; It's a very basic interface really. However, since we want a new instance of the module each time we invoke the Organizer (to avoid problem of reentrance), we need will need to work on our Module interface. class Module { public: typedef std::auto_ptr ResultPointer; virtual ~Module() {} // it's a base class virtual Module* Clone() const = 0; // traditional cloning concept virtual ResultPointer Execute(const Organizer& organizer) = 0; }; // class Module And now, it's easy: // Organizer implementation const Result* Organizer::GetResult(const std::string& id) { ResultsType::const_iterator res = mResults.find(id); // Memoized ? if (res != mResults.end()) return *(it->second); // Need to compute it // Look module up ModulesType::const_iterator mod = mModules.find(id); if (mod != mModules.end()) return 0; // Create a throw away clone std::auto_ptr module(it->second->Clone()); // Compute std::shared_ptr result(module->Execute(*this).release()); if (!result.get()) return 0; // Store result as part of the Memoization thingy mResults[id] = result; return result.get(); } And a simple Module/Result example: struct FooResult: Result { FooResult(int r): mResult(r) {} int mResult; }; struct FooModule: Module { virtual FooModule* Clone() const { return new FooModule(*this); } virtual ResultPointer Execute(const Organizer& organizer) { // check that the file has the correct format if(!organizer.GetResult("CheckModule")) return ResultPointer(); return ResultPointer(new FooResult(42)); } }; And from main: #include "project/organizer.h" #include "project/foo.h" #include "project/bar.h" int main(int argc, char* argv[]) { Organizer org; org.AddModule("FooModule", FooModule()); org.AddModule("BarModule", BarModule()); for (int i = 1; i print(); else std::cout
