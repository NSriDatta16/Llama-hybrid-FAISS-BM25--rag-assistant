[site]: stackoverflow
[post_id]: 1027868
[parent_id]: 
[tags]: 
How to convert from from java.util.Map to a Scala Map

A Java API returns a java.util.Map ;. I would like to put that into a Map[String,Boolean] So imagine we have: var scalaMap : Map[String,Boolean] = Map.empty val javaMap = new JavaClass().map() // Returns java.util.Map You can't do Map.empty ++ javaMap , because the ++ method does not know about Java maps. I tried: scalaMap = Map.empty ++ new collection.jcl.MapWrapper[String,Boolean] { override def underlying = javaMap } and: scalaMap = Map.empty ++ new collection.jcl.MapWrapper[java.lang.String,java.lang.Boolean] { override def underlying = javaMap } These both fail to compile, because of the generics - java.lang.String is not the same as a scala String. Is there a good way of doing this, short of copying the map manually? EDIT: Thanks, all good answers, I learned a lot from all of them. However, I made a mistake by posting a simpler problem here than the one I actually have. So, if you allow me, I'll generalise the question - What the API actually returns is java.util.Map > And I need to move this to Map[String, Map[SomeJavaEnum,String]] It probably does not seem like too much of a complication, but it adds an extra level of type erasure, and the only way I found of moving this to a Scala map was deep-copying it (using some of the techniques you suggested below). Anyone any hints? I kind of solved my problem by defining an implicit conversion for my exact types, so at least the ugliness is hidden in its own trait, but still feels a bit clumsy deep copying the lot.
