[site]: stackoverflow
[post_id]: 417653
[parent_id]: 416464
[tags]: 
Another reason for reconsidering the for construct entirely is that its scoping prevents access to the controlled variables after the loop has terminated. The value(s) of the variable(s) being mutated in the loop may useful for a variety of reasons (e.g. to distinguish success from failure in a search) which would otherwise require extra variables to preserve that information after scope exit. Here's a small example that searches a square array named a for a target value (assuming that SIZE is non-zero, otherwise no search is necessary!): int i = 0; int j = 0; while (i The subsequent code can use i to determine whether the desired value was located. Another advantage of the above is the flexibility. Suppose we're now informed that the values in rows of a are ascending, so the remainder of a row is irrelevant if a value larger than target is encountered. It's easy to know exactly what change to make, and where to make it. Because that new information allows us to abandon the current row, only the inner decision is affected, becoming: if (target I'm seeing more of the newer languages (especially functionally-oriented ones) abandoning the old "counting" loop construct; that's probably a good thing, as it encourages us to think about the meaning of the loop, rather than simply counting.
