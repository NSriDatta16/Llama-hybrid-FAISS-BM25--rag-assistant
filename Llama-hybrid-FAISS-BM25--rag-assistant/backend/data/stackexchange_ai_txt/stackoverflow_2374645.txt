[site]: stackoverflow
[post_id]: 2374645
[parent_id]: 
[tags]: 
Sending commands to stdin and sending end of transmit (Ctrl+D)

I want to run the following code. The application that I'm calling expects commands like User-Name=albert next line, another command and so on, until you are done. If you were to enter this manually from command line, you would type command, press enter, type command press enter. Right at the end AFTER PRESSING ENTER after the last command, you would press Ctrl + D to end it, that runs the program and comes back stating what happened. If you type a command wrong, the application says "expecting =" meaning that you sent a line that is not formatted right... So what I'm doing below is simulating typing this in manually, one command, new line, one command, new line etc, until the end, then I just append Ctrl+D after the last command. This doesn't work and the program says "expecting =" Any obvious issues? Thanks for your time. Albert // CREATE DISCONNECT FILE StringBuilder sb = new StringBuilder(); sb.AppendLine("User-Name=" + this.userName); sb.AppendLine("Acct-Session-Id=" + this.sessionID); sb.AppendLine("NAS-IP-Address=" + Setting.Item["EDGE.NASIP"]); sb.AppendLine("Framed-IP-Address=" + this.currentIP); sb.Append("/x4"); System.Diagnostics.ProcessStartInfo procStartInfo = new System.Diagnostics.ProcessStartInfo(); procStartInfo.WorkingDirectory = radclientPath.Substring(0, radclientPath.LastIndexOf("\\")); procStartInfo.FileName = radclientPath; procStartInfo.Arguments = @"-r 1 -d ..\etc\raddb -x 192.168.1.240:3799 disconnect password"; procStartInfo.RedirectStandardInput = true; procStartInfo.RedirectStandardError = true; procStartInfo.RedirectStandardOutput = true; procStartInfo.UseShellExecute = false; System.Diagnostics.Process proc = System.Diagnostics.Process.Start(procStartInfo); proc.StandardInput.Write(sb.ToString()); proc.WaitForExit(5000); if (proc.HasExited) { System.IO.File.WriteAllText(@"D:\temp.txt", proc.StandardOutput.ReadToEnd()); System.IO.File.WriteAllText(@"D:\temp2.txt", proc.StandardError.ReadToEnd()); string message = proc.StandardOutput.ReadToEnd() + "\n---\nErrors:\n---\n" + proc.StandardError.ReadToEnd(); return message; } System.IO.File.WriteAllText(@"D:\temp.txt", proc.StandardOutput.ReadToEnd()); System.IO.File.WriteAllText(@"D:\temp2.txt", proc.StandardError.ReadToEnd()); return ""; } I also tried it in single quotes and with a zero leading the number (\x04) and nothing either, so I tried writing what should be sent to the program to a text file. I then ran the program using the same command line params as below. Copied what was in the entire text file and pasted it into the command prompt, and that works fine. Not sure why it's not sent correctly to the stdin.. StringBuilder sb = new StringBuilder(); sb.AppendLine("User-Name=" + this.userName); sb.Append('\x04'); System.IO.File.WriteAllText(@"D:\input.txt", sb.ToString()); System.Diagnostics.ProcessStartInfo procStartInfo = new System.Diagnostics.ProcessStartInfo(); procStartInfo.WorkingDirectory = radclientPath.Substring(0, radclientPath.LastIndexOf("\\")); procStartInfo.FileName = radclientPath; procStartInfo.Arguments = @"-r 1 -d ..\etc\raddb -x 192.168.1.240:3799 disconnect password"; procStartInfo.RedirectStandardInput = true; procStartInfo.RedirectStandardError = true; procStartInfo.RedirectStandardOutput = true; procStartInfo.UseShellExecute = false; System.Diagnostics.Process proc = System.Diagnostics.Process.Start(procStartInfo); proc.StandardInput.Write(sb.ToString()); proc.WaitForExit(5000);
