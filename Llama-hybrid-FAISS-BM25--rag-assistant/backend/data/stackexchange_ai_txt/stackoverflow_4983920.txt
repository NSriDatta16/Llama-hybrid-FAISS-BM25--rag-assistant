[site]: stackoverflow
[post_id]: 4983920
[parent_id]: 
[tags]: 
Performant property access and possible dynamic compiling

I have a solution where i need to take different classes and access it's properties by name so if I have for instance the classes Horse and Cat , i need to be able to access them through a generic class, say Adapter, like HorseAdapter adapter = new HorseAdapter(); public SomeMethod() { Horse horse = new Horse(); DoStuff(horse, adapter); } public DoStuff(object obj, IAdapter adapter) { int speed = (int)adapter.GetValue(obj,"speed"); string name = adapter.GetValue(obj,"name") as string; adapter.SetValue(obj,"gender",true); } This is not difficult per se and there's a host of threads of stackoverflow on how to do it, you can use everything from reflection to dynamic. However in my case I need to optimize both performance and memory (don't ask why :) To get around the dynamic performance penalties my strategy is to build an adapter interface , say IAdapter , which implements object GetValue(object obj,string fieldName) SetValue(object obj,string fieldName,object value) So public class HorseAdapter : IAdapter { .. public override GetValue(object obj, string fieldName) { Horse horse = object as Horse, if (fieldName == "name") return horse.Name; else if (fieldName == "speed") return horse.Speed; } } Then each class that needs it implements that interface. The question is how to best solve a couple of things, first type conversion. It would perhaps be nice and more optimized to have GetInt, GetString etc etc but it seems you'll get alot of methods that you need to implement that way and the syntax isn't exactly beautiful so perhaps better to take the hit and cast the object instead using as A generic indexer would perhaps have been nice but alas c# doesn't support them. Another question is how much overhead the GetValue and SetValue will have, the classes that implements them needs to have a switch or if-else branch for different fieldnames. It shouldn't add that much of an overhead though I think if I use OrdinalIgnore case. Maybe there's a better solution but I can't think of one, a HashTable seems more expensive. ntepo To avoid the tediousness of manually creating the adapter classes I was thinking that a nice solution would be to generate the code for and compile them dynamically runtime(perhaps using CodeDom). What do you think, what's the most elegant solution for a problem like this with high performance? Benchmarks I tested four different approaches of a large number of objects and five different properties. "Normal" property access, "Adapter" property access, Getting property using reflection and lastly the Linq Expression method described in an answer below elapsed time normal properties:468 ms elapsed time reflection properties:4657 ms elapsed time adapter properties:551 ms elapsed time expression properties:1041 ms Seems like using an adapter is marginally slower then straight on properties, LINQ Expressions are about twice as slow and reflection is ten times as slow. Even if LINQ Expressions are twice as slow it's milliseconds we're talking about so it might be worth using to avoid having to setup adapters.
