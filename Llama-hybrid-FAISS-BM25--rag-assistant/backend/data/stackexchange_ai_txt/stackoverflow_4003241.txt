[site]: stackoverflow
[post_id]: 4003241
[parent_id]: 4003232
[tags]: 
Here is a C function that handles positive OR negative integer OR fractional values for BOTH OPERANDS #include float mod(float a, float N) {return a - N*floor(a/N);} //return in range [0, N) This is surely the most elegant solution from a mathematical standpoint. However, I'm not sure if it is robust in handling integers. Sometimes floating point errors creep in when converting int -> fp -> int. I am using this code for non-int s, and a separate function for int. NOTE: need to trap N = 0! Tester code: #include #include float mod(float a, float N) { float ret = a - N * floor (a / N); printf("%f.1 mod %f.1 = %f.1 \n", a, N, ret); return ret; } int main (char* argc, char** argv) { printf ("fmodf(-10.2, 2.0) = %f.1 == FAIL! \n\n", fmodf(-10.2, 2.0)); float x; x = mod(10.2f, 2.0f); x = mod(10.2f, -2.0f); x = mod(-10.2f, 2.0f); x = mod(-10.2f, -2.0f); return 0; } (Note: You can compile and run it straight out of CodePad: http://codepad.org/UOgEqAMA ) Output: fmodf(-10.2, 2.0) = -0.20 == FAIL! 10.2 mod 2.0 = 0.2 10.2 mod -2.0 = -1.8 -10.2 mod 2.0 = 1.8 -10.2 mod -2.0 = -0.2
