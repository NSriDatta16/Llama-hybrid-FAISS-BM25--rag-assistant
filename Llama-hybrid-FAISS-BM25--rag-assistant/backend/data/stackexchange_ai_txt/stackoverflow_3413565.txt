[site]: stackoverflow
[post_id]: 3413565
[parent_id]: 3412874
[tags]: 
http://www.cnn.com/...?eref=rss_world&utm_source=... That is not well-formed XML, and hence not RSS. You must escape all literal ampersand symbols to &amp; . (It's not valid in HTML either. When you put a & in an href="..." attribute you must also escape it to &amp; . The difference is browsers typically correct your mistake for you when they can; XML parsers won't.) document.rssform.rssurl.value Adding an ID on the and using document.getElementById is less ambiguous than the old-school form collection access. Either way, that's a rather roundabout way of getting a value into script. Why not lose the form and simple pass the RSS filename as an argument into getRSS() ? this.title; That doesn't do anything at all. None of the places you refer to a property like this have any effect; you are not creating members by doing this. var properties = new Array("title", "link", ... In general avoid the new Array constructor. The array literal syntax ( var properties= ['title', 'link, ...]; is easier to read and doesn't have the constructor's unexpected behaviour for a single argument. eval("this."+properties[i]+"=tmpElement.childNodes[0].nodeValue"); eval is evil. Never use it. You can use square-bracket notation to access a property with a dynamic name. a.b is the same as a['b'] , so: this[properties[i]]= tmpElement.childNodes[0].nodeValue; ... imgAttribs = new Array("url","title", ... You haven't declared var imgAttribs so that's an accidental global. Same with Item in RSS2Channel . (Why the capital letter?) eval("this."+imgAttribs[i]+"=imgElement.getAttribute("+imgAttribs[i]+")"); That won't work due to lack of quotes on the attribute name. You'll be getting getAttribute(url) , and there's no variable called url -> error. Again, use square bracket property access to set the attribute and not eval . eval("document.getElementById('chan_"+properties[i]+"').innerHTML = ''"); getElementById('chan_'+properties[i]) is fine, there is no point in doing that in an eval . xhr.setRequestHeader("Cache-Control", "no-cache"); xhr.setRequestHeader("Pragma", "no-cache"); Cache-Control and Pragma are typically HTTP response fields. They will not have the effect you expect in an HTTP request. If you want to ensure no caching occurs from the client side, use a ‘cachebuster’ method such as adding a random number or timestamp to the URL's query string. innerHTML = curProp Danger. Values you have fetched are arbitrary text strings and may contain HTML-special characters like and & . If you write such strings to an element's innerHTML , you are likely to get broken results, and if they include third-party content you have just given yourself a cross-site-scripting security hole. You can use textContent=... to set the content of an element without having to worry about HTML-escaping, however you then need to detect whether it's supported and fall back to IE's non-standard innerText property if it's not. A way that works on all browsers is to document.createTextNode(curProp) and append that text node to the element. innerHTML= imageTag+" alt='"+RSS.image.description+ ... You've got exactly the same problem with HTML-escaping here: if eg. the description contains , you're in trouble. You can write an HTML-encoder, eg.: function encodeHTML(s) { return s.replace(/&/g, '&amp;').replace(/ But really, creating HTML from bits of string totally sucks. Use DOM methods instead: var img= document.createElement('img'); img.src= RSS.image.url; img.title= RSS.image.description; img.width= RSS.image.width; img.height= RSS.image.height; document.getElementById('chan_image_link').appendChild(img);
