[site]: stackoverflow
[post_id]: 1365605
[parent_id]: 1364603
[tags]: 
Clearly the solution is to use the correct data type. Make counter an unsigned int. Then it can't be less than zero. Your compiler will obviously know this and be forced to choose the optimal solution. Or you could just measure it. You could also think about how it would be implemented...(here we go on a tangent)... less than zero: the sign bit would be set, so need to check 1 bit equal to zero : the whole value would be zero, so need to check all the bits Of course, computers are funny things, and it may take longer to check a single bit than the whole value (however many bytes it is on your platform). You could just measure it... And you could find out that one it more optimal than another (under the conditions you measured it). But your program will still run like a dog because you spent all your time optimising the wrong part of your code. The best solution is to use what many large software companies do - blame the hardware for not runnnig fast enough and encourage your customer to upgrade their equipment (which is clearly inferior since your product doesn't run fast enough).
