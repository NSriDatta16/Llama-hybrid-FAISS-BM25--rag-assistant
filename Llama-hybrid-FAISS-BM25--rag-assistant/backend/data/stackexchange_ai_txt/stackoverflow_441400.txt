[site]: stackoverflow
[post_id]: 441400
[parent_id]: 
[tags]: 
About Memory Management in Java and C++

Well, I've been given an assignment to basically figure out how memory allocation works for whatever language I'll be using. After some research, I have some questions and doubts which I'd like to get some insight in. For example: I read here that Java specifies exactly how the stack contents are organized. Looking at the JVM spec structure , it basically says the stack contains frames, and that the frames contain whatever is inside the class by properly allocating the variables and functions. Maybe I am missing something here, but I don't understand how this is any different than what C++ does. I ask because the first link says Java's specification of stack contents avoid compiler incompatibilities. Also, I have yet to find how the memory segments are exactly organized on top of each other. For example, I know the memory is divided into global variables, call stack, heap and code for C++, yet I don't know if the heap's address is higher than the stack's, or if that depends on the implementation. I also wonder whether a Java program has more than that, and how it would be laid out as well. I imagine there is a standard, since the JVM has to know where it all is to use it, though I suppose it could just have the pointers and leave the rest to the OS. I imagine too, that there must be at least a de facto standard. Another the thing I don't understand is the runtime constant pool. It's supposed to be "a per-class or per-interface runtime representation of the constant_pool table in a class file", but I don't think I understand what it does. It seems to have a tag to indicate what type the structure in question is? Then the name of the structure (given by the programmer or assigned by the underlying system?) Then it seems the rest of it varies with whatever the tag describes (a thread, an array, etc). If my interpretation of the runtime constant pool is right, then why are they necessary as well as stack frames? Is it because stack frames only take care of the stack segments, and the runtime constant pool must also have pointers for the heap allocated memory?
