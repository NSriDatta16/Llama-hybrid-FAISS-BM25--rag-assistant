[site]: stackoverflow
[post_id]: 1425915
[parent_id]: 1425681
[tags]: 
As a continuation of my original comment :) ... Currently your best bet is the third option, but if things get more complex you could go with the second, while adding facade methods to perform pre-specified sequences: Policy policy = new Policy(); policy.Status = Active; policyManager.InactivateAndUpdate(policy); //methods in PolicyManager public void Inactivate(Policy policy) { // possibly complex checks and validations might be put there in the future? ... policy.Status = Inactive; } public void InactivateAndUpdate(Policy policy) { Inactivate(policy); Update(policy); } The InactivateAndUpdate is a kind of facade method, which is just there to make the calling code a little neater, while still allowing the methods doing the actual work to be separate concerns (kind of breaks single responsibility for methods, but sometimes you just have to be pragmatic!). I deliberately name such methods in the style X and Y to make them stand out as doing two things. The InactivateAndUpdate method then frees you up to start implementing strategy patterns or splitting out the actual implementation methods as command objects for dynamic processing or whatever other architecture might become feasible in the future.
