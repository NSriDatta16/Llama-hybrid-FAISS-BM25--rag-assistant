[site]: stackoverflow
[post_id]: 4587428
[parent_id]: 4566532
[tags]: 
After further investigation, this appears to be a bug in the Lucene Highlighter code. As you can see here: public class TokenGroup { ... protected boolean isDistinct() { return offsetAtt.startOffset() >= endOffset; } ... The code attempts to determine if a group of tokens is distinct by checking to see if the start offset is greater than the previous end offset. The problem with this approach is illustrated by this issue. If you were to step through the tokens, you would see that they are as follows: 0-4: 'test', 'test' 5-6: '1', '1' 7-10: '500', '500' 5-10: '1500', '1,500' 11-15: 'this', 'this' From this you can see that the third token starts after the end of the second, but the fourth starts the same place as the second. The intended outcome would be to group tokens 2, 3, and 4, but per this implementation, token 3 is seen as separate from 2, so 2 shows up by itself, then 3 and 4 get grouped leaving this outcome: Expected: 'test 1,500 this' Observed: 'test 1 1,500 this' I'm not sure this can be accomplished without 2 passes, one to get all the indexes and a second to combine them. Also, I'm not sure what the implications would be outside of this specific case. Does anyone have any ideas here? EDIT Here is the final source code I came up with. It will group things correctly. It also appears to be MUCH simpler than the Lucene Highlighter implementation, but admittedly does not handle different levels of scoring as my application only needs a yes/no as to whether a fragment of text gets highlighted. Its also worth noting that I am using their QueryScorer to score the text fragments which does have the weakness of being Term oriented rather than Phrase oriented which means the search string "grammatical or spelling" would end up with highlighting that looks something like this " grammatical or spelling " as the or would most likely get dropped by your analyzer. Anyway, here is my source: public TextFragments getTextFragments( TokenStream tokenStream, String text, Scorer scorer ) throws IOException, InvalidTokenOffsetsException { OffsetAttribute offsetAtt = (OffsetAttribute) tokenStream.addAttribute( OffsetAttribute.class ); TermAttribute termAtt = (TermAttribute) tokenStream.addAttribute( TermAttribute.class ); TokenStream newStream = scorer.init( tokenStream ); if ( newStream != null ) { tokenStream = newStream; } TokenGroups tgs = new TokenGroups(); scorer.startFragment( null ); while ( tokenStream.incrementToken() ) { tgs.add( offsetAtt.startOffset(), offsetAtt.endOffset(), scorer.getTokenScore() ); if ( log.isTraceEnabled() ) { log.trace( new StringBuilder() .append( scorer.getTokenScore() ) .append( " " ) .append( offsetAtt.startOffset() ) .append( "-" ) .append( offsetAtt.endOffset() ) .append( ": '" ) .append( termAtt.term() ) .append( "', '" ) .append( text.substring( offsetAtt.startOffset(), offsetAtt.endOffset() ) ) .append( "'" ) .toString() ); } } return tgs.fragment( text ); } private class TokenGroup { private int startIndex; private int endIndex; private float score; public TokenGroup( int startIndex, int endIndex, float score ) { this.startIndex = startIndex; this.endIndex = endIndex; this.score = score; } } private class TokenGroups implements Iterable { private List tgs; public TokenGroups() { tgs = new ArrayList (); } public void add( int startIndex, int endIndex, float score ) { add( new TokenGroup( startIndex, endIndex, score ) ); } public void add( TokenGroup tg ) { for ( int i = tgs.size() - 1; i >= 0; i-- ) { if ( tg.startIndex fragment( String text ) { TextFragments fragments = new TextFragments (); int lastEndIndex = 0; for ( TokenGroup tg : this ) { if ( tg.startIndex > lastEndIndex ) { fragments.add( text.substring( lastEndIndex, tg.startIndex ), textModeNormal ); } fragments.add( text.substring( tg.startIndex, tg.endIndex ), tg.score > 0 ? textModeHighlighted : textModeNormal ); lastEndIndex = tg.endIndex; } if ( lastEndIndex iterator() { return tgs.iterator(); } }
