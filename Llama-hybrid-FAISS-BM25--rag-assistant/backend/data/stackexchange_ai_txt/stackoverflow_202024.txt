[site]: stackoverflow
[post_id]: 202024
[parent_id]: 201593
[tags]: 
The following ruby script attempts to parse the headers and builts the required sources alongside the original headers. #! /usr/bin/env ruby # Let's "parse" the headers # Note that using a regular expression is rather fragile # and may break on some inputs GLOBS = [ "toto/*.h", "tutu/*.h", "tutu/*.hxx" ] enums = {} GLOBS.each { |glob| Dir[glob].each { |header| enums[header] = File.open(header, 'rb') { |f| f.read }.scan(/enum\s+(\w+)\s+\{\s*([^}]+?)\s*\}/m).collect { |enum_name, enum_key_and_values| [ enum_name, enum_key_and_values.split(/\s*,\s*/).collect { |enum_key_and_value| enum_key_and_value.split(/\s*=\s*/).first } ] } } } # Now we build a .h and .cpp alongside the parsed headers # using the template engine provided with ruby require 'erb' template_h = ERB.new _to_string_h_ #define _to_string_h_ 1 #include " " char* enum_to_string( e); #endif EOS template_cpp = ERB.new _to_string.h" char* enum_to_string( e) { switch (e) { case : return " "; default: return "INVALID VALUE"; } } EOS enums.each { |header, enum_name_and_keys| enum_name_and_keys.each { |enum_name, enum_keys| File.open("#{File.dirname(header)}/#{enum_name}_to_string.h", 'wb') { |built_h| built_h.write(template_h.result(binding)) } File.open("#{File.dirname(header)}/#{enum_name}_to_string.cpp", 'wb') { |built_cpp| built_cpp.write(template_cpp.result(binding)) } } } Using regular expressions makes this "parser" quite fragile, it may not be able to handle your specific headers gracefully. Let's say you have a header toto/a.h, containing definitions for enums MyEnum and MyEnum2. The script will build: toto/MyEnum_to_string.h toto/MyEnum_to_string.cpp toto/MyEnum2_to_string.h toto/MyEnum2_to_string.cpp More robust solutions would be: Build all sources defining enums and their operations from another source. This means you'll define your enums in a XML/YML/whatever file which is much easier to parse than C/C++. Use a real compiler such as suggested by Avdi. Use preprocessor macros with or without templates.
