[site]: stackoverflow
[post_id]: 1369579
[parent_id]: 858035
[tags]: 
I know this has been repeated, but I will just post a code sample to see how unions do add to elegance and efficiency when reading network traffic: #pragma packed(1) struct header_t { uint16_t msg_id; uint16_t size; }; struct command_t { uint8_t cmd; }; struct position_t { uint32_t x; uint32_t y; uint32_t z; }; // ... Rest of the messages in an IDS struct message { header_t header; union { command_t command; position_t position; } body; }; #pragma packed(0) message read( int socket ) { message data; unsigned int readed = read( socket, &data, sizeof(header_t) ); // error checks... readed bytes smaller than header size and such readed = read( socket, &(data.body), data.header.size ); // error checks... } In the snippet above you can perform the message read in place, and you do not need to care about the concrete type of object received. If you did not use the union, you would be left with reading the header, extracting both the size and the type, instantiating an object of the appropriate type (either in a hierarchy or to include inside a variant type as boost::any/boost::variant), and performing the second read on the newly created space. We use this solution extensively to control simulators (some companies do not appreciate 'new' technologies like DDS or HLA and still depend on raw UDP/TCP data for their simulators). In the network layer we use unions that are transformed into internal data structures (network-to-host conversion, data scaling...) before feeding it into the application layers. As it was mentioned before, you must be careful with the padding at all times.
