[site]: stackoverflow
[post_id]: 235529
[parent_id]: 234333
[tags]: 
Unless you have a pretty old graphics-card, it's surprising that you don't have fragment-shader support. I'd suggest you try double-checking using this . Also, are you sure you want anything above the max value to be 0? Perhaps you meant 1? If you did mean 1 and not 0 then are quite long-winded ways to do what you're asking. The condensed answer is that you use multiple rendering-passes. First you render the image at normal intensity. Then you use subtractive blending (look up glBlendEquation) to subtract your minimum value. Then you use additive blending to multiply everything up by 1/(max-min) (which may need multiple passes). If you really want to do this, please post back the GL_VENDOR and GL_RENDERER for your graphics-card. Edit: Hmm. Intel 945G don't have ARB_fragment_shader , but it does have ARB_fragment_program which will also do the trick. Your fragment-code should look something like this (but it's been a while since I wrote any so it's probably bugged) !!ARBfp1.0 ATTRIB tex = fragment.texcoord[0] PARAM cbias = program.local[0] PARAM cscale = program.local[1] OUTPUT cout = result.color TEMP tmp TXP tmp, tex, texture[0], 2D SUB tmp, tmp, cbias MUL cout, tmp, cscale END You load this into OpenGL like so: GLuint prog; glEnable(GL_FRAGMENT_PROGRAM_ARB); glGenProgramsARB(1, &prog); glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, prog); glProgramStringARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB, strlen(src), src); glDisable(GL_FRAGMENT_PROGRAM_ARB); Then, before rendering your geometry, you do this: glEnable(GL_FRAGMENT_PROGRAM_ARB); glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, prog); colour4f cbias = cmin; colour4f cscale = 1.0f / (cmax-cmin); glProgramLocalParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 0, cbias.r, cbias.g, cbias.b, cbias.a); glProgramLocalParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 1, cscale.r, cscale.g, cscale.b, cscale.a); //Draw your textured geometry glDisable(GL_FRAGMENT_PROGRAM_ARB);
