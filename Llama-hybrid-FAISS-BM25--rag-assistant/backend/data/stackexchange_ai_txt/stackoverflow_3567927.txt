[site]: stackoverflow
[post_id]: 3567927
[parent_id]: 3565621
[tags]: 
Instead of using the JAXB RI (Metro), you could use the MOXy JAXB implementation (I'm the tech lead). It has some extensions that will make mapping this scenario fairly easy. jaxb.properties To use MOXy as your JAXB implementation you need to add a file named jaxb.properties in the same package as your model classes with the following entry: javax.xml.bind.context.factory=org.eclipse.persistence.jaxb.JAXBContextFactory Root import javax.xml.bind.annotation.*; @XmlRootElement(name="ROOT") @XmlAccessorType(XmlAccessType.FIELD) public class Root { @XmlElement(name="ELEM_A") private ElemA elemA; @XmlElement(name="ELEM_B") private ElemB elemB; } ElemA We can leverate @XmlTransformation. It is similar in concept to XmlAdapter, but easier to share among mappings. import java.util.Date; import javax.xml.bind.annotation.XmlAccessType; import javax.xml.bind.annotation.XmlAccessorType; import javax.xml.bind.annotation.XmlElement; import org.eclipse.persistence.oxm.annotations.XmlReadTransformer; import org.eclipse.persistence.oxm.annotations.XmlTransformation; import org.eclipse.persistence.oxm.annotations.XmlWriteTransformer; import org.eclipse.persistence.oxm.annotations.XmlWriteTransformers; @XmlAccessorType(XmlAccessType.FIELD) public class ElemA { @XmlTransformation @XmlReadTransformer(transformerClass=DateAttributeTransformer.class) @XmlWriteTransformers({ @XmlWriteTransformer(xpath="A_DATE/text()", transformerClass=DateFieldTransformer.class), @XmlWriteTransformer(xpath="A_TIME/text()", transformerClass=TimeFieldTransformer.class), }) public Date aDate; @XmlElement(name="STRING") private String string; } ElemB import java.util.Date; import javax.xml.bind.annotation.XmlAccessType; import javax.xml.bind.annotation.XmlAccessorType; import javax.xml.bind.annotation.XmlElement; import org.eclipse.persistence.oxm.annotations.XmlReadTransformer; import org.eclipse.persistence.oxm.annotations.XmlTransformation; import org.eclipse.persistence.oxm.annotations.XmlWriteTransformer; import org.eclipse.persistence.oxm.annotations.XmlWriteTransformers; @XmlAccessorType(XmlAccessType.FIELD) public class ElemB { @XmlTransformation @XmlReadTransformer(transformerClass=DateAttributeTransformer.class) @XmlWriteTransformers({ @XmlWriteTransformer(xpath="B_DATE/text()", transformerClass=DateFieldTransformer.class), @XmlWriteTransformer(xpath="B_TIME/text()", transformerClass=TimeFieldTransformer.class), }) private Date bDate; @XmlElement(name="NUM") private int num; @XmlTransformation @XmlReadTransformer(transformerClass=DateAttributeTransformer.class) @XmlWriteTransformers({ @XmlWriteTransformer(xpath="C_DATE/text()", transformerClass=DateFieldTransformer.class), @XmlWriteTransformer(xpath="C_TIME/text()", transformerClass=TimeFieldTransformer.class), }) private Date cDate; } DateAttributeTransformer The attribute transformer is responsible for unmarshalling the Date object. import java.text.ParseException; import java.text.SimpleDateFormat; import org.eclipse.persistence.internal.helper.DatabaseField; import org.eclipse.persistence.mappings.foundation.AbstractTransformationMapping; import org.eclipse.persistence.mappings.transformers.AttributeTransformer; import org.eclipse.persistence.sessions.Record; import org.eclipse.persistence.sessions.Session; public class DateAttributeTransformer implements AttributeTransformer { private AbstractTransformationMapping mapping; private SimpleDateFormat yyyyMMddHHmmss = new SimpleDateFormat("yyyyMMddHHmmss"); public void initialize(AbstractTransformationMapping mapping) { this.mapping = mapping; } public Object buildAttributeValue(Record record, Object instance, Session session) { try { String dateString = null; String timeString = null; for(DatabaseField field : mapping.getFields()) { if(field.getName().contains("DATE")) { dateString = (String) record.get(field); } else { timeString = (String) record.get(field); } } return yyyyMMddHHmmss.parseObject(dateString + timeString); } catch(ParseException e) { throw new RuntimeException(e); } } } DateFieldTransformer The field transformers are responsible for marshalling the Date object. import java.text.SimpleDateFormat; import java.util.Date; import org.eclipse.persistence.mappings.foundation.AbstractTransformationMapping; import org.eclipse.persistence.mappings.transformers.FieldTransformer; import org.eclipse.persistence.sessions.Session; public class DateFieldTransformer implements FieldTransformer { private AbstractTransformationMapping mapping; private SimpleDateFormat yyyyMMdd = new SimpleDateFormat("yyyyMMdd"); public void initialize(AbstractTransformationMapping mapping) { this.mapping = mapping; } public Object buildFieldValue(Object instance, String xPath, Session session) { Date date = (Date) mapping.getAttributeValueFromObject(instance); return yyyyMMdd.format(date); } } TimeFieldTransformer import java.text.SimpleDateFormat; import java.util.Date; import org.eclipse.persistence.mappings.foundation.AbstractTransformationMapping; import org.eclipse.persistence.mappings.transformers.FieldTransformer; import org.eclipse.persistence.sessions.Session; public class TimeFieldTransformer implements FieldTransformer { private AbstractTransformationMapping mapping; private SimpleDateFormat HHmmss = new SimpleDateFormat("HHmmss"); public void initialize(AbstractTransformationMapping mapping) { this.mapping = mapping; } public Object buildFieldValue(Object instance, String xPath, Session session) { Date date = (Date) mapping.getAttributeValueFromObject(instance); return HHmmss.format(date); } } Sample Program import java.io.File; import javax.xml.bind.JAXBContext; import javax.xml.bind.Marshaller; import javax.xml.bind.Unmarshaller; public class Demo { public static void main(String[] args) throws Exception { JAXBContext jc = JAXBContext.newInstance(Root.class); System.out.println(jc); Unmarshaller unmarshaller = jc.createUnmarshaller(); File xml = new File("src/forum41/input.xml"); Root root = (Root) unmarshaller.unmarshal(xml); Marshaller marshaller = jc.createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); marshaller.marshal(root, System.out); } } XML Document 20100825 141500 ABC 20100825 153000 123 20100825 154500 The code as shown above requires EclipseLink 2.2 currently under development. A nightly builds are available here: http://www.eclipse.org/eclipselink/downloads/nightly.php The current released version of EclipseLink 2.1 supports the above, but with a slightly different configuration. We can discuss the appropriate setup if you are interested in exploring this option.
