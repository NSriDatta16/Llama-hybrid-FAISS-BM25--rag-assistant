[site]: stackoverflow
[post_id]: 4535985
[parent_id]: 4483271
[tags]: 
The requirement is not uncommon, and can be supplied reasonably in SQL. But you have two issues blocking you. 1) You've entered an SQL tag, that means ISO/IEC/ANSI Standard SQL. The correct method to use is a cursor or cursor substitute (while loop, which does the same thing, but is faster). That avoids all these outer joins and handling massive result sets; then beating it into submission with GROUP BYs, etc. It also handles duplicates, mainly because it does it create them in the first place (via those five versions of the aliased table). And yes, it will keep getting worse, and when the database is reasonably populated it will be a performance hog. 2) Duplicates are not allowed in a Relational database, ie. in your source tables; you need to make the rows unique (and those keys/columns is not shown). No use trying to eliminate duplicates via code. If that is corrected, then all duplicates (real and created by the poor code) can be eliminated. This requirement can also be supplied more elegantly using Subqueries; except that here you need two levels of nesting, one to build teach Item column, and two to obtain rank or Position. And that (standard SQL construct) pre-supposes that you have a Relational database (no duplicate rows). High Eek factor if you are not used to SQL. Which is why most coders use a cursor or cursor substitute. But if you do not have SQL, its basic capabilities, (HSQL being some sub-standard implementation), then we are not using the same tool kit. The SQL code I can provide will not run for you, and we will keep going back and forth. (Maybe we should have a "psuedo-SQL" tag.) ID Column Prevents Duplicates ??? There is a myth that is prevalent in some parts of the industry, to that effect, due to books written by database beginners. As usual, myths have no scientific basis. Let's try a simple test. CREATE TABLE Person ( PersonId IDENTITY NOT NULL PRIMARY KEY, FirstName CHAR(30) NOT NULL, LastName CHAR(30) NOT NULL ) INSERT Person VALUES ("Fred", "Astaire") 1 row(s) affected INSERT Person VALUES ("Ginger", "Rogers") 1 row(s) affected INSERT Person VALUES ("Fred", "Astaire") 1 row(s) affected SELECT * FROM Person PersonId FirstName LastName ======== ============================== ============================== 1 Fred Astaire 2 Ginger Rogers 3 Fred Astaire 3 row(s) affected That's a pure, unarguable duplicate row. The simple fact is. the Id column provides a row number, but does nothing to prevent duplicate rows. For that you need an Unique Index on the columns that determine uniqueness, as identified in the data model, for every relational table in the database (by definition, if the rows are not unique, it is not a Relational table). Otherwise it is just a file storage system. CREATE UNIQUE NONCLUSTERED INDEX U_Name ON Person (LastName, FirstName) There is another form of data integrity (duplication) which I might identify while I am at it. INSERT Person VALUES ("Fred", "Astair") 1 row(s) affected INSERT Person VALUES ("Astaire", "Fred") 1 row(s) affected All are preventable in SQL.
