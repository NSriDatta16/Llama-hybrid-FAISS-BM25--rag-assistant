[site]: stackoverflow
[post_id]: 3486607
[parent_id]: 2799442
[tags]: 
There are a few things you can do to tighten up the codebase a bit, and I've done some homework on CF_DIBV5 that you may find helpful. First off, in __copyMenuItem_Click() , we have four complete copies of your image, which is much more than necessary. __pictureBox.Image Image imag = Image.FromStream(ms); new Bitmap(imag) Bitmap img = new Bitmap(new Bitmap(imag)); (the outer bitmap) Furthermore, your MemoryStream , imag , new Bitmap(imag) , and img do not get disposed, which could result in problems. Without changing the intent of the code (and probably without solving the handle issue), you could rewrite the method like this: private void __copyMenuItem_Click(object sender, EventArgs e) { var image = __pictureBox.Image; using (var g = __pictureBox.CreateGraphics()) using (var bmp = new Bitmap(image.Width, image.Height, PixelFormat.Format32bppArgb)) using (var bmpg = Graphics.FromImage(bmp)) { IntPtr hDC = g.GetHdc(); bmpg.DrawImage(image, 0, 0, image.Width, image.Height); SetClipboardData(bmp, hDC); g.ReleaseHdc(); } } The next thing that looked like it would require attention was the line: IntPtr hClipboard = SetClipboardData(CF_DIBV5, memBM); I am fairly certain that you must marshal out the BITMAPV5HEADER structure to pass bits to the clipboard when using CF_DIBV5. I've been wrong before, but I would verify that memBM actually contains the header. A good indicator is whether the first DWORD (UInt32) has the value 124 (the size of the header in bytes). My final remarks are more recommendation than a second pair of eyes. I found that photo applications like GIMP, Paint.NET, Fireworks, and PhotoScape appear to have poor or non-existant support for CF_DIBV5 (Format17) pasting. you might consider copying to the clipboard the PNG format, with an opaque bitmap as backup just in case the target application does not support PNG. I use an extension method to facilitate this: public static void CopyMultiFormatBitmapToClipboard(this Image image) { using (var opaque = image.CreateOpaqueBitmap(Color.White)) using (var stream = new MemoryStream()) { image.Save(stream, ImageFormat.Png); Clipboard.Clear(); var data = new DataObject(); data.SetData(DataFormats.Bitmap, true, opaque); data.SetData("PNG", true, stream); Clipboard.SetDataObject(data, true); } } With the extension method in hand, your __copyMenuItem_Click() method could be reduced to the following, and the SetClipboardData() method could be removed altogether: private void __copyMenuItem_Click(object sender, EventArgs e) { __pictureBox.Image.CopyMultiFormatBitmapToClipboard(); } Now, as we already discussed on another thread, PNG support may not cut it for you. I've tested this approach on a few applications; however, it will be up to you to determine whether this is sufficient transparency support for your requirements. GIMP: transparency supported Fireworks (3.0): transparency supported PhotoScape: white background Paint.NET: white background MS PowerPoint 2007: transparency supported MS Word 2007: white background MS Paint (Win7): white background Discussion of everything I looked into would be too lengthy for Stack Overflow. I have additional sample code and discussion available at my blog: http://www.notesoncode.com/articles/2010/08/16/HandlingTransparentImagesOnTheClipboardIsForSomeReasonHard.aspx Good luck!
