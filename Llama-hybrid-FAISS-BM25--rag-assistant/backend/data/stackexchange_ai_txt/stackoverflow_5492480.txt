[site]: stackoverflow
[post_id]: 5492480
[parent_id]: 5492402
[tags]: 
Every make rule works in the same way. If any of the dependencies (the values on the right hand side of the : ) are out of date, they're rebuilt, and then the recipe for the rule is run. In this case, the all target doesn't have a recipe, so make just checks the dependencies ( svm-train , svm-predict , and svm-scale ) and builds them if they're out of date. The lib target is similar - svm.o is built if it's out of date, and then the recipe $(CXX) -shared -dynamiclib svm.o -o libsvm.so.$(SHVER) is run. Since that's the line you asked about analyzing, the $(CXX) and $(SHVER) are make variables that will get filled in as they were defined earlier. In your case, $(CXX) is g++ and $(SHVER) is 2 . THe command that will get run is: g++ -shared -dynamiclib svm.o -o libsvm.so.2 At least assuming you haven't defined $(CXX) elsewhere - the ?= operator used to make that assignment only works if the variable hasn't already been defined. When you type make at the command line, you should see every command on the standard output as it is executed. You can use make -d or make -n for more debugging/logging information. The GNU make manual is extremely well written, and is IMHO one of the greatest programming resources available on the web.
