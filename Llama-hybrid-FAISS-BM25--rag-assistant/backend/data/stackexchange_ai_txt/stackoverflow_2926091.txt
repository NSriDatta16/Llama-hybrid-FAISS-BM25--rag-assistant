[site]: stackoverflow
[post_id]: 2926091
[parent_id]: 
[tags]: 
C++: Templates for static functions?

I have a static Utils class. I want certain methods to be templated, but not the entire class. How do I do this? This fails: #pragma once #include using std::string; class Utils { private: template static set findAll_if_rec(InputIterator begin, InputIterator end, Predicate pred, set result); public: static void PrintLine(const string& line, int tabLevel = 0); static string getTabs(int tabLevel); template static set Utils::findAll_if(InputIterator begin, InputIterator end, Predicate pred); }; Error: utils.h(10): error C2143: syntax error : missing ';' before ' What am I doing wrong? What is the correct syntax for this? Incidentally, I'd like to templatize the return value, too. So instead of: template static set findAll_if_rec(InputIterator begin, InputIterator end, Predicate pred, set result); I'd have: template static return_t findAll_if_rec(InputIterator begin, InputIterator end, Predicate pred, set result); How would I specify that: 1) return_t must be a set of some sort 2) InputIterator must be an iterator 3) InputIterator 's type must work with return_t 's type. Thanks. UPDATE: In response to people who say I should use a namespace intsead of a Java/C# style Utils class, is this more what you were looking for: Utils.h #pragma once #include #include using std::set; using std::string; namespace Utils { static void PrintLine(const string& line, int tabLevel = 0); static string getTabs(int tabLevel); template set Utils::findAll_if(set ::iterator begin, set ::iterator end, Predicate pred); }; Utils.cpp #include "Utils.h" #include #include using std::string; using std::cout; using std::endl; void Utils::PrintLine(const string& line, int tabLevel) { string tabs = getTabs(tabLevel); cout set Utils::findAll_if(set ::iterator begin, set ::iterator end, Predicate pred) { set result; return findAll_if_rec(begin, end, pred, result); } template set findAll_if_rec(set ::iterator begin, set ::iterator end, Predicate pred, set result) { InputIterator nextResultElem = find_if(begin, end, pred); if (nextResultElem == end) { return result; } result.add(*nextResultElem); return findAll_if_rec(++nextResultElem, end, pred, result); } This has many compiler errors. I don't think I'm using the result_t template argument correctly. Update 2 Based on Georg's comments: Utils.h #pragma once #include #include using std::set; using std::string; namespace Utils { void PrintLine(const string& line, int tabLevel = 0); string getTabs(int tabLevel); template set Utils::findAll_if(set ::iterator begin, set ::iterator end, Predicate pred); }; namespace detail { template set findAll_if_rec(set ::iterator begin, set ::iterator end, Predicate pred, set result); }; Utils.cpp #include "Utils.h" #include #include using std::string; using std::cout; using std::endl; void Utils::PrintLine(const string& line, int tabLevel) { string tabs = getTabs(tabLevel); cout Utils::findAll_if(set ::iterator begin, set ::iterator end, Predicate pred) { set result; return findAll_if_rec(begin, end, pred, result); } set detail::findAll_if_rec(set ::iterator begin, set ::iterator end, Predicate pred, set result) { InputIterator nextResultElem = find_if(begin, end, pred); if (nextResultElem == end) { return result; } result.add(*nextResultElem); return findAll_if_rec(++nextResultElem, end, pred, result); } Still not compiling. Help? Update 3: Getting closer... Utils.h: #pragma once #include #include using std::set; using std::string; namespace Utils { void PrintLine(const string& line, int tabLevel = 0); string getTabs(int tabLevel); template set Utils::findAll_if(set ::iterator begin, set ::iterator end, Predicate pred) { set result; return findAll_if_rec(begin, end, pred, result); } } namespace detail { template set findAll_if_rec(set ::iterator begin, set ::iterator end, Predicate pred, set result) { set ::iterator nextResultElem = find_if(begin, end, pred); if (nextResultElem == end) { return result; } result.add(*nextResultElem); return findAll_if_rec(++nextResultElem, end, pred, result); } } Utils.cpp: #include "Utils.h" #include #include using std::string; using std::cout; using std::endl; void Utils::PrintLine(const string& line, int tabLevel) { string tabs = getTabs(tabLevel); cout Still doesn't compile.
