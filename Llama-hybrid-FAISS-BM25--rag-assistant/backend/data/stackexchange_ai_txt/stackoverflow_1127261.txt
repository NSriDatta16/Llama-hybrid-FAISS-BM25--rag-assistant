[site]: stackoverflow
[post_id]: 1127261
[parent_id]: 1126651
[tags]: 
You don't exactly say how you want to combine IO and Maybe , but I assume you have many functions that return IO (Maybe a) that you want to combine easily. Basically you want to treat IO (Maybe a) as a separate type with it's own Monad instance: newtype IOMaybe a = IOM (IO (Maybe a)) -- "unpack" a value of the new type runIOMaybe :: IOMaybe a -> IO (Maybe a) runIOMaybe (IOM a) = a instance Monad IOMaybe where -- bind operator (IOM ioa) >>= f = IOM $ do a return Nothing Just v -> runIOMaybe (f v) -- return return a = IOM (return (Just a)) -- maybe also some convenience functions returnIO :: IO a -> IOMaybe a returnIO ioa = IOM $ do v IOMaybe a returnMaybe ma = IOM (return ma) With this you can use the do -Notation to combine functions that return IO (Maybe a) , IO a or Maybe a : f1 :: Int -> IO (Maybe Int) f1 0 = return Nothing f1 a = return (Just a) main = runIOMaybe $ do returnIO $ putStrLn "Hello" a Generally something that combines and modifies monads like this is called a monad transformer , and GHC comes with a package that includes monad transformers for common cases. If there is something in this monad transformer library that fits your scenario depends on how exactly you want to combine Maybe and IO.
