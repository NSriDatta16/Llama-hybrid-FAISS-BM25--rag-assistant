[site]: stackoverflow
[post_id]: 5741059
[parent_id]: 5704910
[tags]: 
This is basically a more extended version of Ben Voigt answer. As Ben Voigt said, the version without the conditional is O(n) , this should be straightforward. Now, the version with the conditional will execute the recursion inside the if statement a number of times equal to the number of divisors of n (= value of the divisor function for n = d(n) ). The lower limit inf d(n) = 2 , since for every prime, this will be true and there are infinitely many primes, so no matter how big you make n , you can always find one for which d(n) = 2 . This means that for primes, your function will recurse 0 times and it has complexity O(n) . The upper limit is more complicated (and I need coffee), so lets skip that for a moment and calculate the average complexity. The average complexity of d(n) = O(log n) , so, as stated by Ben Voigt, the original function will have an average complexity of O(n log n loglog n ...) . More in detail: you have the for loop, which is O(n) , in this for loop you will recurse an average of d(n) = O(log n) times. Now you enter the function again and recurse O(log (log n)) times, etc, etc. Also note the comments to your question by DarkDust & Jeff Forster. It will not function the way you want it too. Furthermore, checking if even numbers divide n is useless, since even numbers will never be primes (except for 2 of course). Due to the recursion, you will enter the inner if (the one with cout ) during recursive calls, so the output you get, will not be what you want (which I'm assuming is the distinct prime divisors of n). Another way to save time is by only testing up to floor(sqrt(n)) . If a number i divides n exactly, check if the quotient j = n / i is also a prime number. E.g. for n = 6 , you'd test up to floor(sqrt(6)) = 2 . Then you find that i = 2 is a divisor and you check j = 6 / 2 = 3 . You find that both i and j are prime divisors in this case.
