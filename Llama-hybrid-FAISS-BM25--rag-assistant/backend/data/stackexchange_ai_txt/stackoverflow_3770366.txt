[site]: stackoverflow
[post_id]: 3770366
[parent_id]: 3769989
[tags]: 
There are a thousand times better reasons to avoid Linq. Following quote from a discussion on Linq names a few of them: QUOTE1 "For instance this works: var a = new { x = 1, y = 2 }; a = new { x = 1, y = 3 }; But this does not work: var a = new { x = 1, y = 2 }; a = new { x = 1, y = 2147483649 }; It returns : Error 1 Cannot implicitly convert type 'AnonymousType#1' to 'AnonymousType#2' But this works: var a = new { x = 1, y = 2147483648 }; a = new { x = 1, y = 2147483649 }; When you compile: var a = new { x = 1, y = 2 }; The type of the x and y components is arbitrarily declared as a 32 bit signed integer, and it is one of the many integer types the platform has, without anything special. But there is more. For instance this works: double x = 1.0; x = 1; But this does not work: var a = new { x = 1.0, y = 0 }; a = new { x = 1, y = 0 }; The numeric conversion rules are not applicable to this kind of types. As you can see, elegance is in every detail." QUOTE2 "It appears, then, that 'AnonymousType#1' and 'AnonymousType#2' are not synonymous--they name distinct types. And as { x = 1, y = 2 } and { y = 2, x = 1 } are expressions of those two types, respectively, not only do they denote distinct values, but also values of distinct types. So, I was right to be paranoid. Now my paranoia extends even further and I have to ask what LinQ makes of the following comparison: new { x = 1, y = 2 } == new { x = 1, y = 2 } The result is false because this is a pointer comparison. But the result of: (new { x = 1, y = 2 }).Equals(new { x = 1, y = 2 }) Is true. And the result of: (new { x = 1, y = 2 }).Equals(new { y = 2, x = 1 }) and (new { x = 1, y = 2 }).Equals(new { a = 1, b = 2 }) Is false." QUOTE3 "updates are record oriented :-O This, I agree, is problematic, and derives from LINQ's sequence-oriented nature. This is a show stopper for me. If I have to use SQL for my updates anyway why to bother about LinQ? the optimization in LinQ to objects is unexistent. There is not any algebraic optimization nor automatic expression rewrite. Many people don't want to use LinQ to Objects because they lose a lot of performance. Queries are executed in the same way as you write them."
