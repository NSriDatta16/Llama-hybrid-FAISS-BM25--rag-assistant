[site]: stackoverflow
[post_id]: 4731624
[parent_id]: 4729224
[tags]: 
I hacked together a test of various functions here, and this is what I came up with: write_ushort: 7.81 s uShortToStr: 8.16 s convert: 6.71 s use_sprintf: 49.66 s (Write_ushort is my version, which I tried to write as clearly as possible, rather than micro-optimize, to format into a given character buffer; use_sprintf is the obvious sprintf(buf, "%d", x) and nothing else; the other two are taken from other answers here.) This is a pretty amazing difference between them, isn't it? Who would ever think to use sprintf faced with almost an order of magnitude difference? Oh, yeah, how many times did I iterate each tested function? // Taken directly from my hacked up test, but should be clear. // Compiled with gcc 4.4.3 and -O2. This test is interesting, but not authoritative. int main() { using namespace std; char buf[100]; #define G2(NAME,STMT) \ { \ clock_t begin = clock(); \ for (int count = 0; count Sprintf converted the entire possible range of unsigned shorts, then did the whole range again 2,999 more times at about 0.25 Âµs per conversion, on average, on my ~5 year old laptop. Sprintf is portable; is it also efficient enough for your requirements? My version: // Returns number of non-null bytes written, or would be written. // If ret is null, does not write anything; otherwise retlen is the length of // ret, and must include space for the number plus a terminating null. int write_ushort(unsigned short x, char *ret, int retlen) { assert(!ret || retlen >= 1); char s[uint_width_10 ::value]; // easy implementation agnosticism char *n = s; if (x == 0) { *n++ = '0'; } else while (x != 0) { *n++ = '0' + x % 10; x /= 10; } int const digits = n - s; if (ret) { // not needed by checking retlen and only writing to available space //assert(retlen >= digits + 1); while (--retlen && n != s) { *ret++ = *--n; } *ret = '\0'; } return digits; } Compile-time log TMP functions are nothing new, but including this complete example because it's what I used: template struct uint_width_10_nonzero { enum { value = uint_width_10_nonzero ::value + 1 }; }; template<> struct uint_width_10_nonzero { enum { value = 0 }; }; template struct uint_width_10 { enum { value = uint_width_10_nonzero ::value }; }; template<> struct uint_width_10 { enum { value = 1 }; };
