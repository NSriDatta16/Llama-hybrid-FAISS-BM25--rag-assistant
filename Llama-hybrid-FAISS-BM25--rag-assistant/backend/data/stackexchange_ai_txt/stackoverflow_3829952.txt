[site]: stackoverflow
[post_id]: 3829952
[parent_id]: 3829788
[tags]: 
If you want to get cleaner behaviour in this scenario you could replace use of a[0] with use a.at(0) , which will throw if the index is invalid. A pragmatic solution would be to init vector with n+1 entries and constrain access to 0..n-1 (as this code already does). void foo (int n) { std::vector scoped_array (n+1); char* pointer = &scoped_array[0]; file.read ( pointer , n ); for (int i = 0; i
