[site]: stackoverflow
[post_id]: 3032085
[parent_id]: 3031975
[tags]: 
This is a common idiom in languages where the types do not include range checks. An "out of bounds" value is used to indicate one of several conditions. Here, the return value indicates two things: 1) was the character found, and 2) where was it found. The use of -1 for not found and a non-negative index for found succinctly encodes both of these into one value, and the fact that not-found does not need to return an index. In a language with strict range checking, such as Ada or Pascal, the method might be implemented as (pseudo code) bool indexOf(c:char, position:out Positive); Positive is a subtype of int, but restricted to non-negative values. This separates the found/not-found flag from the position. The position is provided as an out parameter - essentialy another return value. It could also be an in-out parameter, to start the search from a given position. Use of -1 to indicate not-found would not be allowed here since it violates range checks on the Positive type. The alternatives in java are: throw an exception: this is not a good choice here, since not finding a character is not an exceptional condition. split the result into several methods, e.g. boolean indexOf(char c); int lastFoundIndex(); . This implies the object must hold on to state, which will not work in a concurrent program, unless the state is stored in thread-local storage, or synchronization is used - all considerable overheads. return the position and found flag separately: such as boolean indexOf(char c, Position pos) . Here, creating the position object may be seen as unnecessary overhead. create a multi-value return type such as class FindIndex { boolean found; int position; } FindIndex indexOf(char c); although it clearly separates the return values, it suffers object creation overhead. Some of that could be mitigated by passing the FindIndex as a parameter, e.g. FindIndex indexOf(char c, FindIndex start); Incidentally, multiple return values were going to be part of java (oak), but were axed prior to 1.0 to cut time to release. James Gosling says he wishes they had been included. It's still a wished-for feature . My take is that use of magic values are a practical way of encoding a multi-valued results (a flag and a value) in a single return value, without requiring excessive object creation overhead. However, if using magic values, it's much nicer to work with if they are consistent across related api calls. For example, // get everything after the first c int index = str.indexOf('c'); String afterC = str.substring(index); Java falls short here, since the use of -1 in the call to substring will cause an IndeOutOfBoundsException . Instead, it might have been more consistent for substring to return "" when invoked with -1, if negative values are considered to start at the end of the string. Critics of magic values for error conditions say that the return value can be ignored (or assumed to be positive). A consistent api that handles these magic values in a useful way would reduce the need to check for -1 and allow for cleaner code.
