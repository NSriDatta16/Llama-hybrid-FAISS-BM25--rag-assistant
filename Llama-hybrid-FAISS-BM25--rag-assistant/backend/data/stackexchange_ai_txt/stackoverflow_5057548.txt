[site]: stackoverflow
[post_id]: 5057548
[parent_id]: 5057398
[tags]: 
First, let's get rid of all those useless aliases. And pay attention to the comments that asked for table structures, indexes, and EXPLAIN output. SELECT DISTINCT node.nid AS nid , node_data_field_company_logo.field_company_logo_fid , node_data_field_company_logo.field_company_logo_list , node_data_field_company_logo.field_company_logo_data , node.type, node.vid , node_data_field_company_logo.field_job_details_title_value , RAND() AS _random FROM node LEFT JOIN term_node ON node.vid = term_node.vid LEFT JOIN term_data ON term_node.tid = term_data.tid LEFT JOIN content_type_profile_job_post ON node.vid = node_data_field_company_logo.vid WHERE (node.type in ('profile_job_post')) AND (node.status <> 0) AND ((term_data.name) = ('')) ORDER BY _random ASC Simple things: you'll usually benefit from an index on any column used in a JOIN clause or a WHERE clause. node.status node.type node.vid node_data_field_company_logo.vid term_data.name term_data.tid term_node.vid But it depends on the number of distinct values in each of those columns. For example, if node.status can have only two values, 0 and 1, then an index probably won't help with it. (That's one reason posting your table structures is important.) Simple things revisited: you're going to pay a heavy price for random order. Slightly more complex things: you might benefit from creating a view on the node table. The view should select only the columns and rows you actually need here. Then JOIN on that view instead of using the node table directly.
