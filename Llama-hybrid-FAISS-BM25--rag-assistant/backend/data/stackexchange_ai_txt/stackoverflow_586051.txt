[site]: stackoverflow
[post_id]: 586051
[parent_id]: 584544
[tags]: 
I agree with m-sharp that you're not going to avoid runtime polymorphism. If you value optimisation over elegance, try replacing say void invoke_trivial_on_all(const std::vector & v) { for (int i=0;i trivial_virtual_method(); } with something like void invoke_trivial_on_all(const std::vector & v) { for (int i=0;i tag==FooTag) static_cast (v[i])->Foo::trivial_virtual_method(); else if (v[i]->tag==BarTag) static_cast (v[i])->Bar::trivial_virtual_method(); else... } } it's not pretty, certainly not OOP (more a reversion to what you might do in good old 'C') but if the virtual methods are trivial enough you should get a function with no calls (subject to good enough compiler & optimisation options). A variant using dynamic_cast or typeid might be slightly more elegant/safe but beware that those features have their own overhead which is probably comparable to a virtual call anyway. Where you'll most likely see an improvement from the above is if some classes methods are no-ops, and it saved you from calling them, or if the functions contain common loop-invariant code and the optimiser manages to hoist it out of the loop.
