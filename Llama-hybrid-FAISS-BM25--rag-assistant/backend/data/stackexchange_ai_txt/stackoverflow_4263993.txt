[site]: stackoverflow
[post_id]: 4263993
[parent_id]: 4261916
[tags]: 
OK, you can do it if you are willing to store an extra void *. I reformatted your sample a bit so it was easier for me to work with. Look at this and see if it fits your needs. Also, note that I provided a few samples so you can add some templates to it that will help usability. They can be extended much more, but that should give you a good idea. There is also some output stuff to help you see what is going on. One more thing, I assume you know that you need to provide appropriate copy-ctor and assignment-operator but that is not the crux of this problem. My g++ version info: g++ --version g++ (SUSE Linux) 4.5.0 20100604 [gcc-4_5-branch revision 160292] #include #include class Duck { public: Duck(float s = 0.0f, bool q = false) : _speed(s), _quacking(q) { std::cout TypeEnum type_enum_for(); template TypeEnum type_enum_for () { return TYPE_DUCK; } template TypeEnum type_enum_for () { return TYPE_SOUP; } /** Tagged-union style variant class, can hold either one Duck or one Soup, but not both at once. */ class DuckOrSoup { public: DuckOrSoup() : _type(TYPE_UNSET), _data_ptr(_data) {/* empty*/} ~DuckOrSoup() {Unset();} void Unset() {ChangeType(TYPE_UNSET);} void SetValueDuck(const Duck & duck) { ChangeType(TYPE_DUCK); reinterpret_cast (_data_ptr)[0] = duck; } void SetValueSoup(const Soup & soup) { ChangeType(TYPE_SOUP); reinterpret_cast (_data_ptr)[0] = soup; } template void set(T const & t) { ChangeType(type_enum_for ()); reinterpret_cast (_data_ptr)[0] = t; } template T & get() { ChangeType(type_enum_for ()); return reinterpret_cast (_data_ptr)[0]; } template T const & get_const() { ChangeType(type_enum_for ()); return reinterpret_cast (_data_ptr)[0]; } private: void ChangeType(int newType); template struct _maxx {enum {sz = (S1>S2)?S1:S2};}; #define compile_time_max(a,b) (_maxx ::sz) enum {STORAGE_SIZE = compile_time_max(sizeof(Duck), sizeof(Soup))}; char _data[STORAGE_SIZE]; int _type; // a TYPE_* indicating what type of data we currently hold void * _data_ptr; }; void DuckOrSoup :: ChangeType(int newType) { if (newType != _type) { switch(_type) { case TYPE_DUCK: (reinterpret_cast (_data_ptr))->~Duck(); break; case TYPE_SOUP: (reinterpret_cast (_data_ptr))->~Soup(); break; } _type = newType; switch(_type) { case TYPE_DUCK: (void) new (_data) Duck(); break; case TYPE_SOUP: (void) new (_data) Soup(); break; } } } int main(int argc, char ** argv) { Duck sample_duck; sample_duck._speed = 23.23; Soup sample_soup; sample_soup._temperature = 98.6; std::cout ()._speed ()._temperature () = Duck(42.42); std::cout ()._speed () = Soup(0, 32); std::cout ()._temperature
