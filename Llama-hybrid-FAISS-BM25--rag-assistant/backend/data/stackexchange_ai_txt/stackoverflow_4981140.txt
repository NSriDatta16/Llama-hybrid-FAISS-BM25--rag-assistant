[site]: stackoverflow
[post_id]: 4981140
[parent_id]: 4981068
[tags]: 
I think that your problem is in this code: scanf("%9s", NameList[0]); The problem here is that scanf requires that the argument you provide as a location to store the result must be a pointer. If you provide something that isn't a pointer, scanf will treat it as though it is and essentially write memory to a random location, crashing the program. Fixing this requires two steps. First, you'll want to change your declaration of NameList so that it's no longer a char * . The reason is that a char * is a single string, whereas you want an array of strings. This would be defined as a char ** , a pointer to an array of char * s. This might look like this: char** NameList; Next, you'll need to allocate storage space for the strings. This is tricky and a bit subtle because you have to do two allocations. First, you need to allocate space for the array itself, which you could do like this: NameList = malloc (sizeof(char*) * NumItems); This allocates an array of pointers to characters, but it doesn't actually set up the pointers in those arrays to point to valid memory locations. To fix this, you'll want to then iterate across this array and set all of its elements to be pointers to buffers large enough to hold your strings - in this case, buffers of length 10: int i; for (i = 0; i Now, you can call scanf("%9s", NameList[0]); Because NameList[0] is a char * pointing to the buffer into which the characters should be written. One more comment on your code - rather than allocating an array of one element and then reallocating it to an array of two elements later on, consider just allocating all the space up-front. It's a bit clearer. Also, since you're now dealing with a buffer of char * s, each of which needs to be initialized to point to its own buffer, if you do incremental allocations you'll need to be sure to initialize all of the new char * s you allocate to point to a buffer somewhere. If you do this one step at a time there's a good chance you'll forget to set up the pointers and cause a crash, whereas if you do it up front there's no such risk. When it comes time to free the dynamically-allocated memory, you'll need to run the allocation process in reverse, first freeing the dynamically-allocated buffers for the strings, then freeing the top-level buffer. For example: for (i = 0; i This is necessary because free doesn't work recursively. You need to explicitly deallocate all the memory that you allocate. Note that you do not write the code like this: free (NameList); for (i = 0; i This will cause all sorts of Bad Things at runtime because if you free the top-level array first, then as you try iterating over its contents freeing the pointers, you'll be reading memory that you no longer own. Hope this helps!
