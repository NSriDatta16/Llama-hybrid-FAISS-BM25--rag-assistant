[site]: stackoverflow
[post_id]: 3536921
[parent_id]: 3536845
[tags]: 
The others have pointed you in the right direction, you aren't appropriately terminating your c strings. Declaring a char array of length 80 just points to a block of memory, it doesn't initialise the array in any way, this means that unless you /0 terminate the string you copy into it, you'll get all the crap lying around on the end up to the 80 characters. I've not written C++ in probably 15 years so the code below may not even work but hopefully it'll give you some ideas for a more elegant and maintainable solution. void iofunc::getName(string arg){ lineProcess(arg); //make sure to call this depending on what function u are using int name_count = 0; int wspace_count = 0; int arg_len = arg.length(); //int char_len = 0; string name_temp; // Let's assemble a c-str version if the inbound arg string char* cstr; cstr = new char [arg.size()+1]; strcpy (cstr, arg.c_str()); name_count = numberofNames(); //line process was called before so this will work, //make sure you call line process before using this function //for special, condition when there is no space in front of names if (special_condition == true){ glob_name = arg; } if (special_condition == false){ // Assuming there's at least 1 name, which we have to otherwise the original // code may never set glob_name, let's use the C String function strtok // to tokenise our newly created c string at each " ". // Grab the first name. name_temp = string(strtok(cstr, " ")); for (int i = 1; i
