[site]: stackoverflow
[post_id]: 1949138
[parent_id]: 1914996
[tags]: 
Not sure who has focus during a drag and drop. But an alternative solution to your problem would be to add a KeyEventDispatcher for your Stone class to the KeyboardFocusManager . From the JavaDoc: The KeyboardFocusManager is both a centralized location for client code to query for the focus owner and initiate focus changes, and an event dispatcher for all FocusEvents, WindowEvents related to focus, and KeyEvents+ . + my emphasis. Basically we use similar sort of code to intercept KeyEvents before they hit the Component that has focus. Just gave it a quick test for your particular drag and drop context and it seems to work alright (as long as your application has focus within the operating system). Essentially something along the lines of: Public Stone(...) { // ... KeyboardFocusManager fm = KeyboardFocusManager.getCurrentKeyboardFocusManager(); fm.addKeyEventDispatcher( new KeyEventDispatcher() { public boolean dispatchKeyEvent(KeyEvent e) { System.out.println("Key Press: " + e.getKeyChar()); return false; } } ); // ... } You will need to do a bit of leg-work on enabling and disabling when the user is no longer dragging and dropping as my test currently prints all the time. I also wonder if it is possible to use the KeyboardFocusManager to determine who actually ends up with focus during a drag and drop? Anyway, I hope this gives you a few new ideas to try.
