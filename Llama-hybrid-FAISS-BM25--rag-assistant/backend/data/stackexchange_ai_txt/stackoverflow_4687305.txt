[site]: stackoverflow
[post_id]: 4687305
[parent_id]: 4686011
[tags]: 
Reversing a single-linked list is sort of a classic question. It's answered here as well (and well answered), it does not requires recursion nor extra memory, besides a register (or 2) for reference keeping. However to the OP, I guess it's a school project/homework and some piece of advice, if you ever get to use single linked list for some real data storage, consider using a tail node as well. (as of now single linked lists are almost extinct, HashMap buckets comes to mind, though). Unless you have to check all the nodes for some condition during 'add', tail is quite an improvement. Below there is some code that features the reverse method and a tail node. package t1; public class SList { Node head = new Node(); Node tail = head; private static class Node{ Node link; int data; } void add(int i){ Node n = new Node(); n.data = i; tail = tail.link =n; } void reverse(){ tail = head; head = reverse(head); tail.link = null;//former head still links back, so clear it } private static Node reverse(Node head){ for (Node n=head.link, link; n!=null; n=link){//essentially replace head w/ the next and relink link = n.link; n.link = head; head = n; } return head; } void print(){ for (Node n=head; n!=null;n=n.link){ System.out.println(n.data); } } public static void main(String[] args) { SList l = new SList(); l.add(1);l.add(2);l.add(3);l.add(4); l.print(); System.out.println("=="); l.reverse(); l.print(); } }
