[site]: stackoverflow
[post_id]: 3252646
[parent_id]: 3252499
[tags]: 
Well, what your asking for is probably a VERY extensive list, as design patterns are use all over the .NET platform. Here are some examples I can think of off the top of my head: Adapter The adapter pattern, a common mechanism of bridging systems and platforms, is implemented in a variety of ways in the .NET framework. One of the most prevalent examples of this in .NET are Runtime Callable Wrappers, or RCW's. RCW's, generated with the tlbimp.exe program, provide adapters that let .NET managed code easily call into legacy COM code via a .NET API. Factory Method The factory method pattern is probably one of the most well-known patterns. It is implemented quite commonly throughout the .NET framework, particularly on primitive times, but also on many others. An excellent example of this pattern in the framework is the Convert class, which provides a host of methods to create common primitives from other common primitives. Additionally, another pervasive form of this pattern are the .Parse() and .TryParse() methods found on many primitive and basic types. Iterator The Iterator pattern is implemented via a couple interfaces and some language constructs, like foreach and the yeild keyword in C#. The IEnumerable interface and its generic counterpart are implemented by dozens of collections in the .NET framework, allowing easy, dynamic iteration of a very wide variety of data sets: IEnumerable IEnumerator foreach(var thing in someEnumerable) { // } The yeild keyword in C# allows the true form of an iterator to be realized, only incurring the cost of processing an iteration through a loop when that iteration is demanded: IEnumerable TokenizeMe(string complexString) { string[] tokens = complexString.Split(' '); foreach (string token in toekens) { yield return token; } } Builder The Builder pattern is implemented a few times in the .NET framework. A couple of note are the connection string builders. Connection strings can be a picky thing, and constructing them dynamically at runtime can sometimes be a pain. Connection String Builder classes demonstrate the builder pattern ideally: string connectionString = new SqlConnectionStringBuilder { DataSource = "localhost", InitialCatalog = "MyDatabase", IntegratedSecurity = true, Pooling = false }.ConnectionString; Other classes throughout the .NET framework, such as UriBuilder, also implement the builder pattern. Observer The observer pattern is a common pattern that allows one class to watch events of another. As of .NET 4, this pattern is supported in two ways: via language-integrated events (tightly coupled observers), and via the IObservable/IObserver interfaces (loosely coupled events). Classic language events make use of delegates , or strongly-typed function pointers, to track event callbacks in event properties. An event, when triggered, will execute each of the tracked callbacks in sequence. Events like this are used pervasively throughout the .NET framework. public class EventProvider { public event EventHandler SomeEvent; protected virtual void OnSomeEvent(EventArgs args) { if (SomeEvent != null) { SomeEvent(this, args); // Trigger event } } } public class EventConsumer { public EventConsumer(EventProvider provider) { provider.SomeEvent += someEventHandler; // Register as observer of event } private void someEventHandler(EventArgs args) { // handle event } } New with the .NET 4 framework are loosely coupled events. These are accomplished by implementing the IObservable and IObserver interfaces, which more directly support the original Observer design pattern. While not directly implemented by any .NET framework types that I am aware of, the core infrastructure for the pattern is an integral part of .NET 4. public class SomethingObservable: IObservable { private readonly List > m_observers; public IDisposable Subscribe(IObserver observer) { if (!m_observers.Contains(observer)) { m_observers.Add(observer); } var unsubscriber = new Unsubscriber(m_observers, observer) return unsubscriber; } private class Unsubscriber: IDisposable { public Unsubscriber(IList > observers, IObserver observer) { m_observers = observers; m_observer = observer; } private readonly IList > m_observers; private readonly IObserver m_observer; public void Dispose() { if (m_observer == null) return; if (m_observers.Contains(m_observer)) { m_observers.Remove(m_observer); } } } } Decorator The decorator pattern is a way of providing alternative representations, or forms, of behavior through a single base type. Quite often, a common set of functionality is required, but the actual implementation of that functionality needs to change. An excellent example of this in the .NET framework is the Stream class and its derivatives. All streams in .NET provide the same basic functionality, however each stream functions differently. Stream MemoryStream BufferedStream FileStream IsolatedStorageFileStream PipeStream AnonymousPipeClientStream AnonymousPipeServerStream NamedPipeClientStream NamedPipeServerStream CryptoStream GZipStream Many, many other design patterns are used within the .NET framework. Almost every aspect of .NET, from language to framework to fundamental runtime concepts, are based on common design patterns. Significant portions of the .NET framework, such as ASP.NET, are in and of themselves patterns. Take, for example, the ASP.NET MVC framework, which is an implementation of the web variant of MVC, or Model-View-Controller . The WPF and Silverlight UI frameworks directly support a pattern called MVVM, or Model-View-ViewModel . The ASP.NET pipeline itself is a collection of patterns, including intercepting filter , page controller , router , etc. Finally, one of the most commonly used patterns, composition , is used so extensively in the .NET framework that it is probably one of the most fundamental patterns of the entire framework.
