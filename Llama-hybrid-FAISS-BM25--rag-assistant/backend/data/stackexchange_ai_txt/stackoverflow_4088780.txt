[site]: stackoverflow
[post_id]: 4088780
[parent_id]: 4082212
[tags]: 
The performance difference between these two approaches should be negligible. Personally, I would suggest using a non-static approach due to the flexibility that it provides. If you find it helpful to have much of the parsing logic consolidated in one place, you could use a combination approach (demonstrated in my example below). Regarding performance, If you were repeatedly creating many new instances of your Parser class over a short period of time, you might notice a small performance impact, but then you would likely be able to refactor the code to avoid repeatedly creating instances of the Parser class. Also, while calling an instance method (especially a virtual method) is technically not as fast as calling a static method, again the performance difference should be very negligible. McWafflestix brings up a good point about state. However, given that your current implementation uses static methods, I assume that your Parser class does not need to maintain state between calls to the Read methods, and therefore you should be able to reuse the same Parser instance in order to parse multiple objects from a BinaryReader stream. Below is an example that illustrates the approach that I would probably take for this problem. Here are some features of this example: Using polymorphism to abstract details about where the parsing logic resides for a given type of object. Using a repository to store Parser instances so that they can be reused. Using reflection to identify the parsing logic for a given class or struct. Notice that I've kept the parsing logic in static methods within the ParseHelper class, and the Read instance methods on the MyObjectAParser and MyObjectBParser classes utilize those static methods on the ParseHelper class. This is just a design decision that you can make depending on what makes the most sense to you regarding how to organize your parsing logic. I'm guessing it would probably make sense to move some of the type-specific parsing logic into the individual Parser classes, but keep some of the general parsing logic in a ParseHelper class. // define a non-generic parser interface so that we can refer to all types of parsers public interface IParser { object Read(BinaryReader reader); } // define a generic parser interface so that we can specify a Read method specific to a particular type public interface IParser : IParser { new T Read(BinaryReader reader); } public abstract class Parser : IParser { public abstract T Read(BinaryReader reader); object IParser.Read(BinaryReader reader) { return this.Read(reader); } } // define a Parser attribute so that we can easily determine the correct parser for a given type [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = true)] public class ParserAttribute : Attribute { public Type ParserType { get; private set; } public ParserAttribute(Type parserType) { if (!typeof(IParser).IsAssignableFrom(parserType)) throw new ArgumentException(string.Format("The type [{0}] does not implement the IParser interface.", parserType.Name), "parserType"); this.ParserType = parserType; } public ParserAttribute(Type parserType, Type targetType) { // check that the type represented by parserType implements the IParser interface if (!typeof(IParser).IsAssignableFrom(parserType)) throw new ArgumentException(string.Format("The type [{0}] does not implement the IParser interface.", parserType.Name), "parserType"); // check that the type represented by parserType implements the IParser interface, where T is the type specified by targetType if (!typeof(IParser<>).MakeGenericType(targetType).IsAssignableFrom(parserType)) throw new ArgumentException(string.Format("The type [{0}] does not implement the IParser interface.", parserType.Name, targetType.Name), "parserType"); this.ParserType = parserType; } } // let's define a couple of example classes for parsing // the MyObjectA class corresponds to ParseObject1 in the original question [Parser(typeof(MyObjectAParser))] // the parser type for MyObjectA is MyObjectAParser class MyObjectA { // ... } // the MyObjectB class corresponds to ParseObject2 in the original question [Parser(typeof(MyObjectAParser))] // the parser type for MyObjectB is MyObjectBParser class MyObjectB { // ... } // a static class that contains helper functions to handle parsing logic static class ParseHelper { public static MyObjectA ReadObjectA(BinaryReader reader) { // throw new NotImplementedException(); } public static MyObjectB ReadObjectB(BinaryReader reader) { // throw new NotImplementedException(); } } // a parser class that parses objects of type MyObjectA from a BinaryReader class MyObjectAParser : Parser { public override MyObjectA Read(BinaryReader reader) { return ParseHelper.ReadObjectA(reader); } } // a parser class that parses objects of type MyObjectB from a BinaryReader class MyObjectBParser : Parser { public override MyObjectB Read(BinaryReader reader) { return ParseHelper.ReadObjectB(reader); } } // define a ParserRepository to encapsulate the logic for finding the correct parser for a given type public class ParserRepository { private Dictionary _Parsers = new Dictionary (); public IParser GetParser () { // attempt to look up the correct parser for type T from the dictionary Type targetType = typeof(T); IParser parser; if (!this._Parsers.TryGetValue(targetType, out parser)) { // no parser was found, so check the target type for a Parser attribute object[] attributes = targetType.GetCustomAttributes(typeof(ParserAttribute), true); if (attributes != null && attributes.Length > 0) { ParserAttribute parserAttribute = (ParserAttribute)attributes[0]; // create an instance of the identified parser parser = (IParser )Activator.CreateInstance(parserAttribute.ParserType); // and add it to the dictionary this._Parsers.Add(targetType, parser); } else { throw new InvalidOperationException(string.Format("Unable to find a parser for the type [{0}].", targetType.Name)); } } return (IParser )parser; } // this method can be used to set up parsers without the use of the Parser attribute public void RegisterParser (IParser parser) { this._Parsers[typeof(T)] = parser; } } Usage example: ParserRepository parserRepository = new ParserRepository(); // ... IParser parserForMyObjectA = parserRepository.GetParser (); IParser parserForMyObjectB = parserRepository.GetParser (); using (var fs = new FileStream(@"file.ext", FileMode.Open, FileAccess.Read, FileShare.Read)) { BinaryReader br = new BinaryReader(fs); MyObjectA objA = parserForMyObjectA.Read(br); MyObjectB objB = parserForMyObjectB.Read(br); // ... } // Notice that this code does not explicitly reference the MyObjectAParser or MyObjectBParser classes.
