[site]: stackoverflow
[post_id]: 1783702
[parent_id]: 603201
[tags]: 
Agreeing/expanding what has already been said, I don't think FastCGI will solve the problem. Apache Each request into Apache will use one worker thread until the request completes, which may be a long time for COMET requests. This article on Ajaxian mentions using COMET on Apache, and that it is difficult. The problem isn't specific to PHP, and applies to any back-end CGI module you may want to use on Apache. The suggested solution was to use the 'event' MPM module which changes the way requests are dispatched to worker threads. This MPM tries to fix the 'keep alive problem' in HTTP. After a client completes the first request, the client can keep the connection open, and send further requests using the same socket. This can save signifigant overhead in creating TCP connections. However, Apache traditionally keeps an entire child process/thread waiting for data from the client, which brings its own disadvantages. To solve this problem, this MPM uses a dedicated thread to handle both the Listening sockets, and all sockets that are in a Keep Alive state. Unfortunately, that doesn't work either, because it will only 'snooze' after a request is complete, waiting for a new request from the client. PHP Now, considering the other side of the problem, even if you resolve the issue with holding up one thread per comet request, you will still need one PHP thread per request - this is why FastCGI won't help. You need something like Continuations which allow the comet requests to be resumed when the event they are triggered by is observed. AFAIK, this isn't something that's possible in PHP. I've only seen it in Java - see the Apache Tomcat server . Edit: There's an article here about using a load balancer ( HAProxy ) to allow you to run both an apache server and a comet-enabled server (e.g. jetty, tomcat for Java) on port 80 of the same server.
