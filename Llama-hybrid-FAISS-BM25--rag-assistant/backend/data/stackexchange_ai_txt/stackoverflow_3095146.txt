[site]: stackoverflow
[post_id]: 3095146
[parent_id]: 
[tags]: 
What are the best Spring converter strategies in the case of a String to convert to a set of object?

I have the following (simplified) form in one of my view: Which is going to be bind to the following JavaBean: public class Entry { private String name; private List tags = new LinkedList (); // setters and getters omitted } because I want to take use all new fancy features of Spring 3, I'm using annotation-driven controller to receive the POST request: @Controller @RequestMapping("/entry") public class EntryController { @RequestMapping(method = RequestMethod.GET) public ModelAndView show() { ModelAndView mav = new ModelAndView("entry"); mav.addObject(new Entry()); return mav; } @RequestMapping(method = RequestMethod.POST) public String add(@ModelAttribute("entry") @Valid Entry entry, BindingResult result) { // check validation from Binding result // execute method on business beans: adding this entry to the system // return a view if correct } } As you can see, I need to convert my input text (which look like tag1, tag2, tag3 ) as a list of Tag, define like this: public class Tag { private String name; // setter and getter omitted } There is several strategies to do this with Spring 3.0: ( Sorry long post, questions are in bold ) The simplest Programming a new property tagsAsText to have a getter/setter as String: public class Entry { // ... public void setTagsAsText(String tags) { // convert the text as a list of tags } public String getTagsAsText() { // convert list of tags to a text } } This approach has two drawbacks: I include the conversion logic in my domain object, is it a problem ? Where can i access to the BindingResult in the case of error in the string ? Using BeanInfo I can also use a BeanInfo for my bean: public class EntryBeanInfo extends SimpleBeanInfo { public PropertyDescriptor[] getPropertyDescriptors() { try { @Override PropertyDescriptor tagsDescriptor = new PropertyDescriptor("tags", Entry.class) { @Override public PropertyEditor createPropertyEditor(Object bean) { return new EntryTagListEditor(Integer.class, true); }; }; // omitting others PropertyDescriptor for this object (for instance name) return new PropertyDescriptor[] { tagListDescriptor }; } catch (IntrospectionException ex) { throw new Error(ex.toString()); } } } And declare one converter public class EntryTagListEditor extends PropertyEditorSupport { public void setAsText(String text) { // convert the text to a list of Tag } public String getAsText() { // convert the list of Tag to a String } } This approach has also two drawbacks: I need to edit my BeanInfo every time I add / change my Entry class. or is there any way to have a simple way to define my BeanInfo (like "for this property, use this, else just do as usual" ) Where can i access to the BindingResult in the case of error in the string ? Using Converter Converter uses the generic mechanism of Java 5: final class StringToTagList implements Converter > { public List convert(String source) { // convert my source to a list of Tag } } This approach looks more elegant but still two drawbacks: It seems I redefine all default Converters if I configure this converter in the Property of ConversionServiceFactoryBean , is there any way to keep the default Converters ? (again) Where can i access to the BindingResult in the case of error in the string ?
