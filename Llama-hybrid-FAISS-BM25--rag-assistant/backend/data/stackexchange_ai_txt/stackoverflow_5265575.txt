[site]: stackoverflow
[post_id]: 5265575
[parent_id]: 5265417
[tags]: 
Here's my A-star path finder, it works and you're free to use it for learning and comparing your solution against it, rip me off if you like. But there are dependencies that are missing from this code and I'm using fixed-point arithmetic. This won't build without some changes. This code is relatively high level and should be easy enough to reverse engineer. public class AgentPathfinder { class SolutionComparer : IComparer { public int Compare(Solution x, Solution y) { return x.Cost.CompareTo(y.Cost); } } class Solution { public List Path { get; private set; } public FixedVector LastPosition { get { return Path[Path.Count - 1]; } } public Fixed32 Heuristic { get; set; } public Fixed32 Cost { get; set; } public Solution(FixedVector position, Fixed32 heuristic) { Path = new List (2) { position }; Heuristic = heuristic; Cost = Path.Count + heuristic; } public Solution(FixedVector position , Fixed32 heuristic , List path) { Path = new List (path) { position }; Heuristic = heuristic; Cost = Path.Count + heuristic; } } // TODO: replace with pathable terrain data public Map Map { get; set; } public FixedVector Position { get; set; } public FixedVector Destination { get; set; } public List Path { get; set; } public void Compute() { var visited = new bool[(int)Map.Size.Width, (int)Map.Size.Height]; var pq = new PriorityQueue (new SolutionComparer()); var bestFit = new Solution(new FixedVector((int)(Position.X + 0.5) , (int)(Position.Y + 0.5)) , (Destination - Position).Length ); pq.Enqueue(bestFit); while (pq.Count > 0) { var path = pq.Dequeue(); // optimal, thus far if (path.Heuristic
