[site]: stackoverflow
[post_id]: 1302215
[parent_id]: 
[tags]: 
C# locking and general threading design question

I have a threaded console application that is working fine, but it's architecture needs to be improved, and I'd like some feedback. Currently, the program loads up a list of data, and segments that data into partitions (one chunk for each thread). The program then initializes a new thread using the ThreadPool, and passes it ONE segment of the partitioned data on which to operate. Everything works nicely...except: Some of the threads fail...due to network problems, or unrecoverable exceptions. This is expected behavior and not a bug. I now need a way (if the thread fails) to recover that thread's segment of data and provide it to another working thread so that it doesn't become orphaned. I'm sure there are ways to do this, ie, sharing data between threads, etc, but I think there's a better approach. Instead of segmenting the data beforehand and passing it to each thread, I could share ONE static collection of this data between all threads. This is more elegant, but introduces newfound sync problems that the old approach didn't have to worry about. A.) What are your thoughts on this approach vs the old one? B.) If this approach is a good one, how do I go about locking access to the shared static collection. When the thread inits, I can lock the collection and pop-off a segment of the data just for that thread. The static collection would now be REDUCED by the amount popped off for that thread. Upon FAILURE of the thread, I could reallocate that segment of data to the shared collection by again locking it, and pushing the data back to the collection for other threads to attempt to process. For example: (untested pseudocode) void Process(object threadInfo) { lock(StaticCollection) { var segment = StaticCollection.Take(100); StaticCollection.Remove(StaticCollection.Where(item => segment.Contains(item))) } foreach(var seg in segment) { // do something } // reallocate the thread's data on failure if(unrecoverableErrorOccurred) { lock(StaticCollection) { StaticCollection.Add(segment); } } } Am I on the right track with this? It seems to me that one thread can remove items at the same time another thread is reallocating items...or does a lock on a STATIC collection mean that no other thread can access that collection at all. So, Thread A.) obtained a lock in the FIRST part of the method, would that block all other threads from executing the LAST part of the method until ThreadA was complete?
