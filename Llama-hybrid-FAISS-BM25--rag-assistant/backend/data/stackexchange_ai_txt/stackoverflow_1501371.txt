[site]: stackoverflow
[post_id]: 1501371
[parent_id]: 1501341
[tags]: 
References are nothing but restricted pointers. The only difference is that they must point to an existing variable. You can get around that in C++, but it is much harder to miss with: int& r = *(reinterpret_cast (0x0)); Of course this is undefined behavior! So, basically they are implemented as pointers. They differ in usage in many places, eg. references are derefernced automatically when they come as r-values or l-values: int x = 0; int& r = x; // 1) no need to take the address of x like &x r = r * x; // Manually: (*r) = (*r) * x They provide a safer alternative to raw-pointers. Also, they come with much more elegant syntax than raw-pointers. Just imagine that you don't have references when overloading class operators. In summary, they are restricted pointers, with a better/safer aliasing but with reduced functionality.
