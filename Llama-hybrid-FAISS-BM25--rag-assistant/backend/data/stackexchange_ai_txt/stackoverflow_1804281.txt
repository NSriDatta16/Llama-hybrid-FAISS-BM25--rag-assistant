[site]: stackoverflow
[post_id]: 1804281
[parent_id]: 1798366
[tags]: 
It is quite difficult to predict what concrete JAXP factory implementation will be loaded without actually creating an instance because the process for selecting an implementation. From the Official JAXP FAQ (Question 14): When an application wants to create a new JAXP DocumentBuilderFactory instance, it calls the staic method DocumentBuilderFactory.newInstance() . This causes a search for the name of a concrete subclass of DocumentBuilderFactory using the following order: The value of a system property like javax.xml.parsers.DocumentBuilderFactory if it exists and is accessible. The contents of the file $JAVA_HOME/jre/lib/jaxp.properties if it exists. The Jar Service Provider discovery mechanism specified in the Jar File Specification. A jar file can have a resource (i.e. an embedded file) such as META-INF/services/javax.xml.parsers.DocumentBuilderFactory containing the name of the concrete class to instantiate. The fallback platform default implementation. Adding to this complexity, each individual JAXP factory can have an independent implementation specified. It is common to use one parser implementation and another XSLT implementation, but the granularity of the selection mechanism above allows you to mix and match to an even greater degree. The following code will output information about the four main JAXP factories: private static void OutputJaxpImplementationInfo() { System.out.println(getJaxpImplementationInfo("DocumentBuilderFactory", DocumentBuilderFactory.newInstance().getClass())); System.out.println(getJaxpImplementationInfo("XPathFactory", XPathFactory.newInstance().getClass())); System.out.println(getJaxpImplementationInfo("TransformerFactory", TransformerFactory.newInstance().getClass())); System.out.println(getJaxpImplementationInfo("SAXParserFactory", SAXParserFactory.newInstance().getClass())); } private static String getJaxpImplementationInfo(String componentName, Class componentClass) { CodeSource source = componentClass.getProtectionDomain().getCodeSource(); return MessageFormat.format( "{0} implementation: {1} loaded from: {2}", componentName, componentClass.getName(), source == null ? "Java Runtime" : source.getLocation()); } The following sample output illustrates a mix-and-match of three different JAXP implementations (Built-in Xerces and external JARs for Xerces 2.8 and Xalan) working together: DocumentBuilderFactory implementation: org.apache.xerces.jaxp.DocumentBuilderFactoryImpl loaded from: file:/C:/Projects/Scratch/lib/xerces-2.8.0.jar XPathFactory implementation: com.sun.org.apache.xpath.internal.jaxp.XPathFactoryImpl loaded from: Java Runtime TransformerFactory implementation: org.apache.xalan.processor.TransformerFactoryImpl loaded from: file:/C:/Projects/Scratch/lib/xalan.jar SAXParserFactory implementation: org.apache.xerces.jaxp.SAXParserFactoryImpl loaded from: file:/C:/Projects/Scratch/lib/xerces-2.8.0.jar
