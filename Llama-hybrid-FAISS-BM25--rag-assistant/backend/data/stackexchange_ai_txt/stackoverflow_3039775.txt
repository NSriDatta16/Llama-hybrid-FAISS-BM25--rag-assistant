[site]: stackoverflow
[post_id]: 3039775
[parent_id]: 3038154
[tags]: 
I'm going to be a little bit presumptuous and disagree with everyone else. While it's technically true that anything possible in one language is possible in another (where "possible" means "computable"), they differ in what you can express naturally and easily . The computer might be doing the same thing in response to the code you write in C, but you are writing radically different code to make it do those things. As others have said, Objective-C provides a full runtime library written in C that will allow you to create Objective-C data structures and call C functions, but the code to do it will be very verbose, fairly roundabout and completely imperative. In Objective-C, the code is more declarative, more concise and far more readable. In general, trying to write Objective-C things in C will only make your code worse than it would be using either language idiomatically. For example, here is a simple program written in Objective-C: @interface NumberAdder : NSObject { int storedValue; } - (id)initWithStoredValue:(int)value; - (int)resultOfAddingStoredValue:(int)numberToAdd; @end @implementation NumberAdder - (int)resultOfAddingStoredValue:(int)numberToAdd { return numberToAdd + storedValue; } - (id)initWithStoredValue:(int)value { if (!(self = [super init])) return nil; storedValue = value; return self; } @end int main() { id adder = [[NumberAdder alloc] initWithStoredValue:4]; int result = [adder resultOfAddingStoredValue:3]; printf("It is %d\n", result); return 0; } And here is the same thing written in C with the Objective-C runtime (not tested, but should be roughly correct): int returnPlusStoredValueImp(id self, SEL _cmd, int arg) { int *storedValue = nil; object_getInstanceVariable(self, "storedValue", &storedValue) return arg + *storedValue; } id numberAdderInit(id self, SEL _cmd, int valueToStore) { objc_super superInfo = {self, objc_lookupClass("NSObject")}; self = objc_msgSendSuper(super_info, sel_getName("init")); if (!self) return nil; object_setInstanceVariable(self, "storedValue", &valueToStore); return self; } void createNumberAdderClass() __attribute(constructor)__ { Class NumberAdder = objc_allocateClassPair(objc_lookupClass("NSObject"), "NumberAdder", 0); if (!NumberAdder) return; class_addIvar(NumberAdder, "storedValue", sizeof(int), 4, "i"); // I'm actually not sure if the fourth argument is correct, so it's probably wrong, but just take that as a sign of how much this way of coding sucks objc_registerClassPair(NumberAdder); SEL nameOfPlusStoredValue = sel_registerName("resultOfAddingStoredValue:"); SEL nameOfInit = sel_registerName("initWithStoredValue:"); class_addMethod(NumberAdder, nameOfPlusStoredValue, returnPlusStoredValueImp, "i@:i"); class_addMethod(NumberAdder, nameOfInit, numberAdderInit, "@@:i"); } int main() { id adder = objc_msgSend(objc_lookupClass("NumberAdder"), sel_getName"alloc"); adder = objc_msgSend(adder, sel_getName("initWithStoredValue:"), 4); int result = (int)objc_msgSend(adder, sel_getName("resultOfAddingStoredValue:"), 3); printf("It is %d\n", result); return 0; }
