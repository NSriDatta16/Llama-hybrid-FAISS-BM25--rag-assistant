[site]: stackoverflow
[post_id]: 5413859
[parent_id]: 5413229
[tags]: 
I'm solving a related but not identical problem currently. My solution is to create a control list of the same length as the target csv lines, where each element in the control list is the name of a useMethod. In my case the useMethod is an editor widget; in your case, it would be a function that defines how the field is interpreted by your text-to-speech engine. For each line, you can then iterate over the fields, calling the appropriate processing widget. So for your example of "555-555-4321,Bob,Jill,3/30/2011", import csv def phoneNumber(number): ... def userName(name): ... def targetDate(datestring): ... control = [phoneNumber, userName, userName, targetDate] with open("csvFile", "r") as inFile: reader = csv.reader(inFile) for row in reader: for op, item in zip(control, row): op(item) I note that this only works if the csv file has constant interpretation per element, but if it has variant interpretation then a csv file is the wrong storage method. I also note that you'd need some other control object to generate the rest of the sentence; this is left as an exercise for the reader. :) This allows you to have a library of interpreter functions that can be assigned to fields in the csv file by simply changing the control string. A new control string would invoke a different order of field interpretations with no need to change the source code, and the new string could be entered on command line, stored in the first line of the csv file, or brought in some other way. edit: And noting your addendum on using a web interface to configure, that would be a straight-forward way to provide a new control list.
