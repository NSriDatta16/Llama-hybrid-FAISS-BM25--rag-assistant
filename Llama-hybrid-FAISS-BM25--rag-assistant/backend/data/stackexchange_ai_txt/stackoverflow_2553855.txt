[site]: stackoverflow
[post_id]: 2553855
[parent_id]: 2553293
[tags]: 
There is no specific limit on the number of artifacts (methods, constants, enumerations, etc) - say N - in an interface such that we can say if interface X has more than N artifacts, it is bloated . At least not without a context. In this case, the context is what is the interface supposed to provide? , or better yet, what are implementations of this interface supposed to do? What is the intended behavior or role of classes implementing the interface? I would strongly suggest you get familiar with certain metrics like cohesion and coupling (both in general and in specifics to OO.) In particular, I'd suggest you take a look at LCOM. Once you understand it, it will help you eyeball situations like the one you are encountering now. http://javaboutique.internet.com/tutorials/coupcoh/ One of the last things you want to do with an interface or class (or even package or module if you were doing procedural programming) is to turn them into bags of methods and functions where you throw everything but the kitchen sink. That leads to either poorly cohesion or tight coupling (or both.) One of the problems with interfaces is that we cannot easily compute or estimate their LCOM as one would with actual classes, which could guide you in deciding when to r-efactor. So for that you have to use a bit of intuition. Let's assume your interface is named A for the sake of argument. Then, Step 1: Consider grouping the interface methods by arguments: is there a subset of methods that operate on the same type of arguments? If so, are they significantly different from other method groups? interface A { void method1(); void method2(someArgType x); someOtherType y method3(); ... void doSomethingOn( someType t ); boolean isUnderSomeCondition( someType t ) someType replaceAndGetPrev( someType t, someFields ... ) } In such a case, consider splitting that group into its own interface, B . Step 2: Once you extract interface B, does it look like this? interface B { void doSomethingOn( someType t ); ... boolean isUnderSomeCondition( someType t ) ... someType replaceAndGetPrev( someType t, someFields ... ) } That is, it represents methods that do things on some type? If so, your interface is mimicking a procedural module operation on an ADT (in this case, someType ) - nothing wrong with if you are using a procedural or multi-paradigm language . Within reason and while being pragmatic, in OO, you minimize procedures that do things on other objects. You call methods in those objects to do things to themselves on your behalf. Or more precisely, you signal them to do something internally. In such a case, consider turning B into a class encapsulating the type (and, have it extend an interface with the same signature, but only if it makes sense, if you expect different implementations of artifacts encapsulating/managing elements of that type .) class Bclass { someType t; Bclass(){ t=new someType();} ... void doSomethingOn(); ... boolean isUnderSomeCondition() ... someType replaceAndGetPrev( someFields ... ) } Step 3: Determine the relationships between the interfaces and classes re-factored out from A. If B represent things that can only exist when A does (A is a context for B, for example a servlet request exists in a servlet context in Java EE lingo), then have B define a method that returns A (for example A B.getContext() or something like that.) If B represent things that are managed by A (A being a composite of things, including B), then have A define a method that returns B (B A.getBThingie()) If there is no such relationship between A and B, and they have nothing in common other than they were grouped together, then chances are that the original interface was poorly cohesive. If you cannot disentangle one from the other without breaking a significant amount of your design, then that's a sign that pieces of your system had poor boundaries and are tightly coupled. Hope it helps. ps. Also, I would also avoid trying to fit your interfaces and classes into traditional patterns UNLESS doing so serves an application/business specific purpose. I gotta throw that in there just in case. Too many people run amok with the GoF book trying to fit their classes into patterns rather than asking 'what problem am I solving with this?'
