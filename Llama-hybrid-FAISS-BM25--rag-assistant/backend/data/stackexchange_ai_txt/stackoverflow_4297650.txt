[site]: stackoverflow
[post_id]: 4297650
[parent_id]: 4297018
[tags]: 
If you want something fast, don't store your data in a TListView. Use a TStringList to store your list, then use a TListView in virtual mode. Reading from a TStringList.Items[] is many times faster than reading from a TListView.Items[] property. If you're sure that no void item exist in the list, uses this: procedure Extract(List, Dest: TStrings; Char1, Char2: char); var i,j: integer; V: cardinal; type PC = {$ifdef UNICODE}PCardinal{$else}PWord{$endif}; begin V := ord(Char1)+ord(Char2) shl (8*sizeof(char)); Dest.BeginUpdate; Dest.Clear; for i := 0 to List.Count-1 do begin if PC(pointer(List[i]))^=V then begin for j := i to List.Count-1 do begin Dest.Add(List[j]); if PC(pointer(List[j]))^<>V then break; // end the for j := loop end; break; // end the for i := loop end; Dest.EndUpdate; end; You can use binary search to get it even faster. But with the PWord() trick, on a 50000 items list, you won't notice it. Note that PC(pointer(List[i]))^=V is a faster version of copy(List[i],1,2)=Char1+Char2, because no temporary string is created during the comparison. But it works only if no List[i]='', i.e. no pointer(List[i])=nil. I've added a {$ifdef UNICODE} and sizeof(char) in order to have this code compile with all version of Delphi (before and after Delphi 2009).
