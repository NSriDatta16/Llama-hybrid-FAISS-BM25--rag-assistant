[site]: stackoverflow
[post_id]: 4071173
[parent_id]: 4067731
[tags]: 
Also there are some simple type-level programming techniques in Haskell. A canonical example follows: -- A family of types for the natural numbers data Zero data Succ n -- A family of vectors parameterized over the naturals (using GADTs extension) data Vector :: * -> * -> * where -- empty is a vector with length zero Empty :: Vector Zero a -- given a vector of length n and an a, produce a vector of length n+1 Cons :: a -> Vector n a -> Vector (Succ n) a -- A type-level adder for natural numbers (using TypeFamilies extension) type family Plus n m :: * type instance Plus Zero n = n type instance Plus (Succ m) n = Succ (Plus m n) -- Typesafe concatenation of vectors: concatV :: Vector n a -> Vector m a -> Vector (Plus n m) a concatV Empty ys = ys concatV (Cons x xs) ys = Cons x (concatV xs ys) Take a moment to take that in. I think it is pretty magical that it works. However, type-level programming in Haskell is in the feature-uncanny-valley -- just enough to draw attention to how much you can't do. Dependently-typed languages like Agda , Coq , and Epigram take this style to its limit and full power. Template Haskell is much more like the usual LISP-macro style of code generation. You write some code to write some code, then you say "ok insert that generated code here". Unlike the above technique, you can write any computably-specified code that way, but you don't get the very general typechecking as is seen in concatV above. So you have a few options to do what you want. I think metaprogramming is a really interesting space, and in some ways still quite young. Have fun exploring. :-)
