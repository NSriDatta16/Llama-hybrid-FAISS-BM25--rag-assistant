[site]: stackoverflow
[post_id]: 4248459
[parent_id]: 4248104
[tags]: 
There is a way, but you'll have to make use of some BufferedImage transformations. Once you create them, cache them or save them off to be easily reused later. Essentially, you want to start off with a black image (source color #000000) that only uses the alpha layer to turn off pixels (also providing smooth anti-aliasing). For example, in your source image, every pixel is black, but the alpha channel differs from pixel to pixel. First, read this article for some background information: http://www.javalobby.org/articles/ultimate-image/ Once you get done with that primer, you need to load your image into a BufferedImage: BufferedImage loadImg = ImageUtil.loadImage("C:/Images/myimg.png"); Next you need to create a new BufferedImage to make the transform into: public BufferedImage colorImage(BufferedImage loadImg, int red, int green, int blue) { BufferedImage img = new BufferedImage(loadImg.getWidth(), loadImg.getHeight(), BufferedImage.TRANSLUCENT); Graphics2D graphics = img.createGraphics(); Color newColor = new Color(red, green, blue, 0 /* alpha needs to be zero */); graphics.setXORMode(newColor); graphics.drawImage(loadImg, null, 0, 0); graphics.dispose(); return img; } Essentially, the setXORMode will XOR the color you provide with the color in the source image. If the source image is black, then whatever color you provide will be written as you specify it. With the new color using "0" for the alpha channel, the original alpha channel values will be respected. The end result is the composite you are looking for. Edit: You can load the initial BufferedImage in one of two ways. The easiest is to use Java's newer ImageIO API: http://download.oracle.com/javase/6/docs/api/javax/imageio/ImageIO.html to load the file directly to a BufferedImage. The call would look something like this: BufferedImage img = ImageIO.read(url); Alternatively, you can create a method to read the image using the ToolKit. public BufferedImage loadImage(String url) { ImageIcon icon = new ImageIcon(url); Image image = icon.getImage(); // Create empty BufferedImage, sized to Image BufferedImage buffImage = new BufferedImage( image.getWidth(null), image.getHeight(null), BufferedImage.TYPE_INT_ARGB); // Draw Image into BufferedImage Graphics g = buffImage.getGraphics(); g.drawImage(image, 0, 0, null); return buffImage; } Of course, if you pay attention, we have to do the exact same thing to read the image into a buffered image as we do to tint it. In short, if you changed the signature of the colorImage method to accept the Image object you only need to make a couple changes to the getWidth() and getHeight() methods to get it to work.
