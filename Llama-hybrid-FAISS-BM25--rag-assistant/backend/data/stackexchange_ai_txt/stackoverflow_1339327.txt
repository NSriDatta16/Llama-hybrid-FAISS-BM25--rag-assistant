[site]: stackoverflow
[post_id]: 1339327
[parent_id]: 1339270
[tags]: 
When sending a length field on a TCP stream, you need to decide two things: what length should the length have (1 byte, 2 bytes, 4 bytes, variable length) what endianness should I use I recommend to use 4 bytes length, and network byte order (i.e. big-endian). For network byte order, the macros htonl and ntohl will convert between host (native) byte order (little-endian, in your case), and network byte order. To send data, the fragment should look like this: size_t length = strlen(data); uint32_t nlength = htonl(length); send(sock, &nlength, 4, 0); send(sock, data, length, 0); On the receiving side, you extract first the length, then the data: uint32_t length, nlength; recv(sock, &nlength, 4, 0); length = ntohl(nlength); data = malloc(length+1); recv(sock, data, length, 0); data[length] = 0; What this code is missing is error handling: each of the send and receive calls may fail; the recvs may receive less data than expected. But this should give you an idea. Edit : To deal with the case that the recv returns too few data, run it in a loop, keeping a count of what you have read so far, e.g. int length_bytes = 0; while(length_bytes
