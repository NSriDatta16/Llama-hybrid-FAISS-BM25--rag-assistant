[site]: stackoverflow
[post_id]: 3546716
[parent_id]: 3517644
[tags]: 
For the general question, there isn't a very good answer except that's the way it works . Non garbage-collected Objective-C is an explicitly memory-managed language. This means it's up to you to take care of the object ownership semantics. There are conventions to help you do this, but ultimately you have to pay attention to who owns what. Now, you can argue that mere presence on the call stack is a kind of de facto ownership, and it would certainly be possible to design the language that way. However, in practice this would entail a lot of superfluous retaining and releasing that is unnecessary in all well-designed code and would only provide a specious safety buffer in a very few edge cases. It would probably also make a lot of genuine memory management bugs harder to find. You are, of course, entitled to disagree with that analysis, but neither you nor I have any say in the matter. In the specific case you describe, it seems to me the problem is that you haven't properly defined the ownership semantics when passing BOTTOM out from MIDDLE. There are two possibilities: MIDDLE returns a weak reference, which may subsequently go away. In this case it is up to TOP to retain before doing anything that might change the status of BOTTOM -- and calling release on MIDDLE surely falls into that category. MIDDLE confers temporary ownership on the caller, with the reference expected to remain good until the autorelease pool drains: return [[BOTTOM retain] autorelease]; In this case, it is safe to release MIDDLE afterwards. Both of these are valid approaches as Objective-C stands, and both will work. You just need to decide explicitly which you're using and act accordingly. Your bug arose from doing the first but expecting it to behave like the second.
