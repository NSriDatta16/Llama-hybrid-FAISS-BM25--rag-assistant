[site]: stackoverflow
[post_id]: 4433394
[parent_id]: 
[tags]: 
Android emulator crashes while using concurrency

This question is about using the Google Android SDK, in the Java programming language. My question could be boiled down to: Why is this code causing the android emulator to crash? I've been wrestling for a few days with concurrency related to setting up different threads for a game app. I have made many variations, but they have all failed. At this point, I just want to get a basic concurrent setup going. The worst part is that it is the emulator that crashes, so DDMS reports nothing; therefore I'm pretty clueless as to where the issue is. The following code shows an activity (class Main), that calls class SceneManager, which creates a thread to be used for game logic stuff. A 3rd class, StatusChannel, is (will be) used to communicate status information between the different threads (Eventually, there will also be a OpenGL rendering thread). The emulator crashes at different times. It may run for 20 seconds or for 5 minutes. The setContentView(R.layout.main) in the Activity class just the set basic layout that Eclipse creates. I've commented out the usage of Node (Created in the Activity class and accessed in SceneManager) I have installed sdk versions 1.5 through 2.3 -- The current app is targeted at 2.1 The issue has something to do with the SceneManager class. I'm specially suspicious of the run() method. Here are the 3 classes. Sorry for the code length. public class Main extends Activity { private SceneManager mSceneManager; private volatile Node mSceneGraph = new Node(); private volatile Status mStatusChannel = new Status(); /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { Log.d("-- Main", "onCreate()"); super.onCreate(savedInstanceState); setContentView(R.layout.main); // Holds the scene assets, such as the stage, // the agents, camera, etc. mSceneManager = new SceneManager(mSceneGraph, mStatusChannel); mSceneManager.onCreate(); } @Override protected void onResume() { Log.d("-- Main", "onResume()"); super.onResume(); mSceneManager.onResume(); } @Override protected void onPause() { Log.d("-- Main", "onPause()"); super.onPause(); mSceneManager.onPause(); } @Override protected void onDestroy() { Log.d("-- Main", "onDestroy()"); super.onDestroy(); mSceneManager.onDestroy(); } } public class SceneManager implements Runnable{ private Thread mThread; private volatile Status mStatusChannel; private volatile Node mSceneGraph; private volatile long mMillis = 0; private volatile PrepareVisitor mPrepareVisitor; private volatile int mStatus = Status.UNKNOWN_STATUS; SceneManager(Node sceneGraph, Status statusChannel) { mPrepareVisitor = new PrepareVisitor(); mStatusChannel = statusChannel; mSceneGraph = sceneGraph; mMillis = SystemClock.uptimeMillis(); mThread = new Thread(this); mThread.setName("LogicThread"); mStatusChannel.setSceneManagerStatus(Status.READY_STATUS); } public void onCreate() { Log.d("-- SceneManager", "onCreate()..."); // This will start the thread in a paused state. mThread.start(); } public void onResume() { Log.d("-- SceneManager", "onResume()..."); // Unpause the status manager, if it is currently paused. if (mStatusChannel.getSceneManagerStatus() == Status.PAUSED_STATUS) { mStatusChannel.setSceneManagerStatus(Status.READY_STATUS); } } public void onPause() { Log.d("-- SceneManager", "onPause()..."); if (mStatusChannel.getSceneManagerStatus() != Status.UNKNOWN_STATUS) { mStatusChannel.setSceneManagerStatus(Status.PAUSED_STATUS); } } public void onDestroy() { mStatusChannel.setSceneManagerStatus(Status.QUIT_STATUS); try { mThread.join(); } catch (InterruptedException e) { Log.d("-- SceneManager", "InterruptedException"); } } /** * This method should not be called by clients of this class. */ @Override public void run() { Log.d("-- SceneManager", "Called..."); // Main logic loop. outer: while (true) { // How much time has elapsed since last call. long timeDelta = SystemClock.uptimeMillis() - mMillis; switch (mStatus) { case Status.READY_STATUS: //mPrepareVisitor.go(mSceneGraph, timeDelta); break; case Status.PAUSED_STATUS: break; case Status.QUIT_STATUS: break outer; case Status.UNKNOWN_STATUS: int renderStatus = mStatusChannel.getRendererStatus(); if (renderStatus == Status.READY_STATUS) { mStatusChannel.setSceneManagerStatus(Status.READY_STATUS); } break; } mStatus = mStatusChannel.getSceneManagerStatus(); // Update the time. mMillis = SystemClock.uptimeMillis(); } } } public class Status { /* Generic Statuses */ public final static int UNKNOWN_STATUS = 0; public final static int READY_STATUS = 1; public final static int PAUSED_STATUS = 2; public final static int QUIT_STATUS = 3; /* Current statuses values */ private int mSceneManagerStatus = UNKNOWN_STATUS ; private int mRendererStatus = UNKNOWN_STATUS ; public synchronized int getSceneManagerStatus() { return mSceneManagerStatus; } public synchronized int getRendererStatus() { return mRendererStatus; } public synchronized void setSceneManagerStatus(int status) { mSceneManagerStatus = status; } public synchronized void setRendererStatus(int status) { mRendererStatus = status; } } -- EDIT -- This issue happens even with something as simple as this: public class ThreadActivity extends Activity { private Booboo mBooboo; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); mBooboo = new Booboo(); mBooboo.onCreate(); } } public class Booboo implements Runnable { private Thread mThread; Booboo() { mThread = new Thread(this, "SceneManagerThread"); } public void onCreate() { Log.d("Booboo", "Thread started"); mThread.start(); } @Override public void run() { while (true) {} } } I know the first reaction is to say that it's the while(true){}. Just remember that this is a contrived example to show the issue. In my own code, I do the lifecycle activity as described in the docs. The issue is that the emulator crashes after some time in an infinite loop like that, whether you have break conditions or not.
