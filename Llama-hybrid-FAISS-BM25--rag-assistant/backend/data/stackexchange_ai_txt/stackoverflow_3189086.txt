[site]: stackoverflow
[post_id]: 3189086
[parent_id]: 3188959
[tags]: 
You should definitely not pass the IEnumerator around. Apart from anything else, it could have some very bizarre effects in some cases. What would you expect to happen here, for example? using System; using System.Collections.Generic; class Test { static void ShowCurrentAndNext(IEnumerator iterator) { Console.WriteLine("ShowCurrentAndNext"); Console.WriteLine(iterator.Current); iterator.MoveNext(); // Let's assume it returns true Console.WriteLine(iterator.Current); } static void Main() { List list = new List { 1, 2, 3, 4, 5 }; using (var iterator = list.GetEnumerator()) { iterator.MoveNext(); // Get things going ShowCurrentAndNext(iterator); ShowCurrentAndNext(iterator); ShowCurrentAndNext(iterator); } } } A couple of changes to try: using (List .Enumerator iterator = list.GetEnumerator()) and using (IEnumerator iterator = list.GetEnumerator()) Try to predict the results in each case :) Now admittedly that's a particularly evil example, but it does demonstrate some corner cases associated with passing around mutable state. I would strongly encourage you to perform all your iteration in a "central" method which calls into appropriate other methods just with the current value.
