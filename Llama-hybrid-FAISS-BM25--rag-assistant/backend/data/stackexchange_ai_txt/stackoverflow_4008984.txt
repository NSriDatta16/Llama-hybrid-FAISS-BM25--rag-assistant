[site]: stackoverflow
[post_id]: 4008984
[parent_id]: 4008911
[tags]: 
which seems extremely inefficient for such a fundamental performance critical feature Just how often do you think delegates are attached to events (or combined at other times)? For example, in a Windows Forms app this is likely to happen pretty rarely - basically when setting up a form, for the most part... at which point there are far heavier things going on than what's in MulticastDelegate.CombineImpl . What does happen very often is that delegates are invoked ... for example, for every item in every projection or predicate (etc) in a LINQ query. That's the really performance critical bit, IMO. I'm also not convinced that this code is as inefficient as you think it is. It's taking the same approach as ArrayList in terms of creating a larger array than needed, to fill it as it's required. Would a linked list be more efficient? Possibly in some terms - but equally it would be less efficient in terms of locality and levels of indirection. (As each node would need to be a new object which itself contained a reference to the delegate, so navigating the list could end up bringing more pages into memory than an array of references would.) EDIT: Just as a quick microbenchmark (with all the usual caveats) here's some code to perform a given number of iterations of combining a given number of delegates: using System; using System.Diagnostics; class Test { const int Iterations = 10000000; const int Combinations = 3; static void Main() { // Make sure all paths are JITted Stopwatch sw = Stopwatch.StartNew(); sw.Stop(); Action tmp = null; for (int j = 0; j Some results on my machine, all with 10,000,000 iterations: 5 delegates: about 5.8 seconds 4 delegates: about 4.3 seconds 3 delegates: about 3.2 seconds 2 delegates: about 1.4 seconds 1 delegate: about 160ms (All tests run multiple times; the above are just samples which seemed reasonably representative. I haven't taken the average or anything.) Given the above results, I suspect that any paths even in combination-heavy WPF which only attach a single delegate will be blazingly fast. They'll slow down significantly going from 1-2, then gradually degrade (but with a lot less proportional difference than the 1-2 case).
