[site]: stackoverflow
[post_id]: 5648071
[parent_id]: 
[tags]: 
Numeric Stability with Summed Area Tables in Shadow Mapping

Im having issue with loss of precision in my SAVSM setup. when you see the light moving around the effect is very striking; there is a lot of noise with fragments going black and white all the time. This can be somewhat lessened by using the minvariance (thus ignoring anything below a certain threshold) but then we get even worse effects with incorrect falloff (see my other post). Im using GLSL 1.2 because I'm on a mac so I dont have access to the modf function in order to split the precision across two channels as described in GPU Gems 3 Chapter 8. Im using GL_RGBA32F_ARB textures with a Framebuffer object and ping ponging two textures to generate a summed area table which i use with the VSM algorithm. Moments / Depth Shader to create the basis for the tables varying vec4 v_position; varying float tDepth; float g_DistributeFactor = 1024.0; void main() { // Is this linear depth? I would say yes but one can't be utterly sure. // Could try a divide by the far plane? float depth = v_position.z / v_position.w ; depth = depth * 0.5 + 0.5; //Don't forget to move away from unit cube ([-1,1]) to [0,1] coordinate system vec2 moments = vec2(depth, depth * depth); // Adjusting moments (this is sort of bias per pixel) using derivative float dx = dFdx(depth); float dy = dFdy(depth); moments.y += 0.25 * (dx*dx+dy*dy); // Subtract 0.5 off now so we can get this into our summed area table calc //moments -= 0.5; // Split the moments into rg and ba for EVEN MORE PRECISION // float FactorInv = 1.0 / g_DistributeFactor; // gl_FragColor = vec4(floor(moments.x) * FactorInv, fract(moments.x ) * g_DistributeFactor, // floor(moments.y) * FactorInv, fract(moments.y) * g_DistributeFactor); gl_FragColor = vec4(moments,0.0,0.0); } The shadowmap shader varying vec4 v_position; varying float tDepth; float g_DistributeFactor = 1024.0; void main() { // Is this linear depth? I would say yes but one can't be utterly sure. // Could try a divide by the far plane? float depth = v_position.z / v_position.w ; depth = depth * 0.5 + 0.5; //Don't forget to move away from unit cube ([-1,1]) to [0,1] coordinate system vec2 moments = vec2(depth, depth * depth); // Adjusting moments (this is sort of bias per pixel) using derivative float dx = dFdx(depth); float dy = dFdy(depth); moments.y += 0.25 * (dx*dx+dy*dy); // Subtract 0.5 off now so we can get this into our summed area table calc //moments -= 0.5; // Split the moments into rg and ba for EVEN MORE PRECISION // float FactorInv = 1.0 / g_DistributeFactor; // gl_FragColor = vec4(floor(moments.x) * FactorInv, fract(moments.x ) * g_DistributeFactor, // floor(moments.y) * FactorInv, fract(moments.y) * g_DistributeFactor); gl_FragColor = vec4(moments,0.0,0.0); } The Summed tables do seem to be working. I know this because I have a function that converts back from the summed table to the original depth map and the two images do look pretty much the same. Im also using the -0.5 + 0.5 trick in order to get some more precision but it doesnt seem to be helping My question is this, given that im on a mac which has GLSL 1.2 only, how can I split the precision over two channels? If I could use these extra channels for space in the summed table then maybe that would work? Ive seen some stuff that uses modf but that isnt available to me. Also, people have suggested 32 bit integer buffers but I dont think I have support for these on my macbook pro.
