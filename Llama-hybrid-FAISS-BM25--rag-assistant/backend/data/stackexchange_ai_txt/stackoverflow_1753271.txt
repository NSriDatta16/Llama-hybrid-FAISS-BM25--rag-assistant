[site]: stackoverflow
[post_id]: 1753271
[parent_id]: 1752261
[tags]: 
I'm pretty sure it's a bug. If you collapse it down to a tiny example, e.g.: void boundFunction(int) { } typedef boost::signal0 LeakSignalType; LeakSignalType::slot_type aSlot = boost::bind(&::boundFunction, 1); LeakSignalType sig1, sig2; sig1.connect(aSlot); sig2.connect(aSlot); and trace the allocations, you'll find that one object (a boost::signals::detail::signal_base_impl::iterator ) allocated at line 75 of boost/lib/signals/src/signal_base.cpp is not freed up. // Allocate storage for an iterator that will hold the point of // insertion of the slot into the list. This is used to later remove // the slot when it is disconnected. std::auto_ptr saved_iter(new iterator); On the first connect , this iterator is attached to a fresh connection object, where signal_data is NULL: data->watch_bound_objects.get_connection()->signal_data = saved_iter.release(); On the second connect , however, the same connection object is reused, and the same line blindly overwrites the original pointer value. The second object is cleaned up, but the first is not. As verification, a breakpoint in signal_base_impl::slot_disconnected , the only place where signal_data is cleaned up, is only triggered once. I tracked this down in 1.39.0, but it looks like it's the same in 1.40.0. You could modify boost::signals::detail::signal_base_impl::connect_slot to clean up any previous iterator value it finds in the signal_data field of an existing connection, if you're comfortable making such a change and running a custom build of Boost. It might be better to just make sure you're only setting these up a fixed number of times and live with a few small memory leaks that you know won't grow over time. Update: I was going to submit this to the Boost bug tracker, but it's already there. This is a much smaller test case, however. https://svn.boost.org/trac/boost/ticket/738 Opened 3 years ago, not assigned to any milestone :-[
