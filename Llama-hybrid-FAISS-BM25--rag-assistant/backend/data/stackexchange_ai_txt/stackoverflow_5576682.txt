[site]: stackoverflow
[post_id]: 5576682
[parent_id]: 5576448
[tags]: 
Here are some quick answers based on memory. (You can always go spelunking through the compiler code for more detail.) 1) It allows targetting different frameworks, by not trying to implicitly use any mscorlib/FSharp.Core assemblies. So you use this when e.g. you explicitly reference the Silverlight mscorlib/FSharp.Core to target Silverlight. 2) Yes, nearly all of them, and I don't know what they all are. You might look at opt.fs. 3) Debugging - when using VS in "Debug" mode, --tailcalls- is passed to turn off tailcalls and preserve all stack frames to enable easier debugging. 4) FSharp can do inlining and other optimizations across assembly boundaries. This can be dangerous for published libraries because if A references B and A was compiled with crossoptimize and then deployed, and then someone changes/re-deploys B, it is possible A will "call" a method in the "old" B because that code from B was inlined into A and so A still has the "old B" code unless A is recompiled. This rarely matters in practice, but the 'typical' scenario if you have a number of dependent but independently-distributable F# libraries, you want to turn off crossoptimize to get rid of fragile dependencies. 5) That no longer exists.
