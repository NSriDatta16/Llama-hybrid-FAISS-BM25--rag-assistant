[site]: stackoverflow
[post_id]: 554611
[parent_id]: 552722
[tags]: 
I found buckminster brilliant, but terribly documented (I know, I know, I should contribute). I was looking for something to build RCP products. I won't talk too much more about that, but I will say what worked for me: The " webinar " showed me roughly what I could do, and I found myself going back to it a couple of times to start with. Try to get your project checked out into your workspace. This involves: installing buckminster on your Eclipse installation creating a small CQUERY file, which is 3 lines of XML telling buckminster what to check out. creating an RMAP file for your projects. I found this dogfood2.rmap very helpful. Thankfully, I am able to completely ignore CSPEC files, as they can be inferred from the existing metadata (i.e. from MANIFEST.MF , plugin.xml , .product files. I think it can work of the .project and .classpath files, but I don't _k_now). Similarly, I would ignore BOM files for now. Once I had materialized a workspace successfully, I could go on to try and replicate that headlessly. This article I found useful to create an installation for Buckminster suitable for deploying as part of our continuous integration. At this point, I had a long think about the relationships between the Eclipse projects used to build up the product. We settled on a tree (sic) with two major branches - the product branch and the test branch: cquery points to a build.feature build.feature points to a product and a test.product . product points to features foo.feature , foo.ui.feature , bar.feature , bar.ui.feature . Each of these features point to plugins or features. test.product points to foo.test.feature , foo.ui.test.feature , bar.test.feature , bar.ui.test.feature . Each of these features point to test fragments that can exercise the product plugins. By "point to", I mean the feature or cquery specifies it as a dependency. (I couldn't seem to get the Require-Bundle header in the manifest file to work, so put everything in the feature.xml ). I found playing on the command line very helpful at this stage. The resolve and build commands I found most helpful. I also found setting the output property useful here. Once I could build (i.e. compile) everything successfully, packaging it as a product was the next thing. Using the perform command for an action ( create.*.product ) specified in an inferred CSPEC file generated from a .product file was hardly intuitive, but it helped to have a known good product capable of being exported as a product from the IDE. The last thing I did was to find the setenv (I think) command, which helped set the Java version used to compile the code. There are a small number of properties you can set, but this one was the one I needed. Other links I also found latterly, that look helpful.
