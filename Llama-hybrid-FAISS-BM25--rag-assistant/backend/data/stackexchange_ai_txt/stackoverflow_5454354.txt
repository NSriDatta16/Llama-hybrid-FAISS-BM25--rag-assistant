[site]: stackoverflow
[post_id]: 5454354
[parent_id]: 
[tags]: 
TableView Crashing/Freezing Because Of Core Data Error

When the user clicks the + button in the navbar, a UIAlert with text prompt comes up. The user then enters a string into the prompt and it should result in a new UITableViewCell with the name as the string. For some reason the app is crashing when I get to the screen for this viewController. It think it is related to the following line in ViewDidLoad: NSEntityDescription *entity = [NSEntityDescription entityForName:@"Routine" inManagedObjectContext:managedObjectContext]; . The console says the following: Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '+entityForName: could not locate an NSManagedObjectModel for entity name 'Routine'' I think I need to use "name" instead of routine but that isn't working either. Here is my Core Data Model: Here is my code: #import "RoutineTableViewController.h" #import "AlertPrompt.h" #import "Routine.h" @implementation RoutineTableViewController @synthesize tableView; @synthesize eventsArray; @synthesize managedObjectContext; - (void)dealloc { [managedObjectContext release]; [eventsArray release]; [super dealloc]; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; } #pragma mark - View lifecycle - (void)viewDidLoad { UIBarButtonItem * addButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:self action:@selector(showPrompt)]; [self.navigationItem setLeftBarButtonItem:addButton]; [addButton release]; UIBarButtonItem *editButton = [[UIBarButtonItem alloc]initWithTitle:@"Edit" style:UIBarButtonItemStyleBordered target:self action:@selector(toggleEdit)]; self.navigationItem.rightBarButtonItem = editButton; [editButton release]; NSFetchRequest *request = [[NSFetchRequest alloc] init]; NSEntityDescription *entity = [NSEntityDescription entityForName:@"Routine" inManagedObjectContext:managedObjectContext]; [request setEntity:entity]; NSError *error = nil; NSMutableArray *mutableFetchResults = [[managedObjectContext executeFetchRequest:request error:&error] mutableCopy]; if (mutableFetchResults == nil) { // Handle the error. } [self setEventsArray:mutableFetchResults]; [mutableFetchResults release]; [request release]; [super viewDidLoad]; } -(void)toggleEdit { [self.tableView setEditing: !self.tableView.editing animated:YES]; if (self.tableView.editing) [self.navigationItem.rightBarButtonItem setTitle:@"Done"]; else [self.navigationItem.rightBarButtonItem setTitle:@"Edit"]; } -(void)showPrompt { AlertPrompt *prompt = [AlertPrompt alloc]; prompt = [prompt initWithTitle:@"Add Workout Day" message:@"\n \n Please enter title for workout day" delegate:self cancelButtonTitle:@"Cancel" okButtonTitle:@"Add"]; [prompt show]; [prompt release]; } - (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex { if (buttonIndex != [alertView cancelButtonIndex]) { NSString *entered = [(AlertPrompt *)alertView enteredText]; if(eventsArray && entered) { [eventsArray addObject:entered]; [tableView reloadData]; } } } -(void)addEvent { Routine *routine = (Routine *)[NSEntityDescription insertNewObjectForEntityForName:@"Routine" inManagedObjectContext:managedObjectContext]; NSError *error = nil; if (![managedObjectContext save:&error]) { // Handle the error. } [eventsArray insertObject:routine atIndex:0]; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:0]; [self.tableView insertRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade]; [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:0 inSection:0] atScrollPosition:UITableViewScrollPositionTop animated:YES]; } - (void)viewDidUnload { self.eventsArray = nil; [super viewDidUnload]; } #pragma mark - Table view data source - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return [eventsArray count]; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @"Cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { //cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease]; cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellEditingStyleDelete reuseIdentifier:CellIdentifier] autorelease]; } cell.textLabel.text = [self.eventsArray objectAtIndex:indexPath.row]; return cell; } // Override to support conditional editing of the table view. - (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath { // Return NO if you do not want the specified item to be editable. return YES; } -(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { // Delete the managed object at the given index path. NSManagedObject *eventToDelete = [eventsArray objectAtIndex:indexPath.row]; [managedObjectContext deleteObject:eventToDelete]; // Update the array and table view. [eventsArray removeObjectAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:YES]; // Commit the change. NSError *error = nil; if (![managedObjectContext save:&error]) { // Handle the error. } } } @end
