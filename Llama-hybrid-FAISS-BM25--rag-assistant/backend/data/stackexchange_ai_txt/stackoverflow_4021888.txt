[site]: stackoverflow
[post_id]: 4021888
[parent_id]: 4021856
[tags]: 
If you want to base the behavior on an interface, you could use a static initializer in that interface. public interface Foo{ static{ // do initializing here } } I'm not saying it's good practice, but it will definitely initialize the first time one of the implementing classes is loaded. Update: static blocks in interfaces are illegal. Use abstract classes instead! Reference: Initializers (Sun Java Tutorial) But if I understand you right, you want the initialization to happen once per implementing class. That will be tricky. You definitely can't do that with an interface based solution. You could do it with an abstract base class that has a dynamic initializer (or constructor), that checks whether the requested mapping already exists and adds it if it doesn't, but doing such things in constructors is quite a hack. I'd say you cleanest options are either to generate Code at build time (through annotation processing with apt or through bytecode analysis with a tool like asm) or to use an agent at class load time to dynamically create the mapping. Ah, more input. Very good. So clients use your library and provide mappings based on annotations. Then I'd say your library should provide an initializer method, where client code can register classes. Something like this: YourLibrary.getInstance().registerMappedClasses( CustomClass1.class, CustomClass2.class, CustomClass3.class, CustomClass4.class ) Or, even better, a package scanning mechanism (example code to implement this can be found at this question ): YourLibrary.getInstance().registerMappedClassesFromPackages( "com.mycompany.myclientcode.abc", "com.mycompany.myclientcode.def" ) Anyway, there is basically no way to avoid having your clients do that kind of work, because you can't control their build process nor their classloader for them (but you could of course provide guides for classloader or build configuration).
