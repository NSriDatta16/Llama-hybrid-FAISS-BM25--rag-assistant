[site]: stackoverflow
[post_id]: 2403768
[parent_id]: 2403458
[tags]: 
In Python you can accomplish this using meta classes, here's a small example. You can probably make it more elegantly but it is just to make the point import types class PrintMetaClass(type): def __init__(cls, name, bases, attrs): # for every member in the class override = {} for attr in attrs: member = attrs[attr] # if it's a function if type(member) == types.FunctionType: # we wrap it def wrapped(*args, **kwargs): print 'before any method' return member(*args, **kwargs) override[attr] = wrapped super(PrintMetaClass, cls).__init__(name, bases, attrs) for attr in override: setattr(cls, attr, override[attr]) class Foo: __metaclass__ = PrintMetaClass def do_something(self): print 2 class Bar(Foo): def do_something_else(self): print 3 In this example, the PrintMetaClass gets in the way of the creation of the Foo class and any of its subclasses redefining every method to be a wrapper of the original and printing a given message at the beginning. The Bar class receives this aspect-like behavior simply by inheriting from Foo which defines its __metaclass__ to be PrintMetaClass . Metaclasess in OOP: http://en.wikipedia.org/wiki/Metaclass Metaclasses in python: http://www.python.org/doc/essays/metaclasses/ http://www.ibm.com/developerworks/linux/library/l-pymeta.html
