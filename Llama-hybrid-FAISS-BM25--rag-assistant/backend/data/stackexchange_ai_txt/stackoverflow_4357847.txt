[site]: stackoverflow
[post_id]: 4357847
[parent_id]: 
[tags]: 
Dispose of WPF Window

I have a WPF Window that I show with Window.Show(). When I click X the form closes. But it is still in memory and the GC never comes and cleans it up. Also I do not have any refrences/handles to it. does any one know what could be causing it to stay in memory? Thanks! Update: I am using the following code to create the window: Public Sub OpenPageWindow(ByVal nick As String) Dim found As Boolean For Each pw As PageWindow In Application.Current.Windows.OfType(Of PageWindow)() If Not pw.Tag Is Nothing Then If pw.Tag.ToString() = nick Then If pw.IsVisible = False Then pw.Show() End If Exit Sub End If End If Next If found = False Then Dim p As New PageWindow With {.Name = "pw" & nick, .Tag = nick, _ .Title = "Chatting with " & nick, .ShowActivated = False} p.Show() End If End Sub and the following code-behind for the window itself: Public Class PageWindow Implements System.IDisposable Public UserPressedExit As Boolean Dim MainWin As MainWindow Private _IsBuddy As Boolean Private _IsBlocked As Boolean Private _IsOnline As Boolean Public Property FirstOpen As Boolean Public Property IsOnline As Boolean Get Return _IsOnline End Get Set(ByVal value As Boolean) If _IsOnline <> value Then _IsOnline = value End If End Set End Property Public Property IsBuddy As Boolean Get Return _IsBuddy End Get Set(ByVal value As Boolean) If _IsBuddy <> value Then _IsBuddy = value 'If value Then ' btnAddBuddy.IsEnabled = False ' iDeleteBuddy.IsEnabled = True 'Else ' btnAddBuddy.IsEnabled = True ' iDeleteBuddy.IsEnabled = False 'End If End If End Set End Property Private Sub Window_Loaded(ByVal sender As System.Object, ByVal e As System.Windows.RoutedEventArgs) Try MainWin = CType(Application.Current.Windows(0), MainWindow) Catch ex As Exception txtChat.AppendText("ERROR: " & ex.Message.ToString() & Environment.NewLine) End Try End Sub Private Sub Window_Closed(ByVal sender As System.Object, ByVal e As System.EventArgs) Me.Dispose() End Sub Private Sub txtTitle_PreviewMouseDown(ByVal sender As System.Object, ByVal e As System.Windows.Input.MouseButtonEventArgs) Me.DragMove() End Sub Private Sub pbMin_PreviewMouseUp(ByVal sender As System.Object, ByVal e As System.Windows.Input.MouseButtonEventArgs) WindowState = Windows.WindowState.Minimized End Sub Private Sub pbClose_PreviewMouseUp(ByVal sender As System.Object, ByVal e As System.Windows.Input.MouseButtonEventArgs) UserPressedExit = True txtChat.Clear() Me.Close() End Sub Private Sub txtSend_KeyUp(ByVal sender As System.Object, ByVal e As System.Windows.Input.KeyEventArgs) If e.Key = Key.Enter Then btnSend_Click(Nothing, Nothing) End If End Sub Private Sub btnSend_Click(ByVal sender As System.Object, ByVal e As System.Windows.RoutedEventArgs) If String.IsNullOrWhiteSpace(txtSend.Text) Then MessageBox.Show("Empty Message.") txtSend.Text = "" Else Send(txtSend.Text) txtSend.Text = "" End If End Sub Public Sub Page(ByVal message As String) If String.IsNullOrEmpty(message) = False Then If MainWin.Settings.ShowPageTimestamp Then txtChat.AppendText(Me.Tag.ToString() & " (" & Format(Date.Now, "HH:mm:ss") & "): " & message & Environment.NewLine) Else txtChat.AppendText(Me.Tag.ToString() & ": " & message & Environment.NewLine) End If If Me.IsFocused = False Then End If End If End Sub Private Sub Send(ByVal text As String) 'work on 389 event MainWin.Send("PAGE " + Me.Tag.ToString + " " + text) If MainWin.Settings.ShowPageTimestamp Then txtChat.AppendText(MainWin.Settings.Nick & ": " & text & Environment.NewLine) Else txtChat.AppendText(MainWin.Settings.Nick & " (" & Format(Date.Now, "HH:mm:ss") & "): " & text & Environment.NewLine) End If End Sub #Region "IDisposable Support" Private disposed As Boolean ' To detect redundant calls ' This code added by Visual Basic to correctly implement the disposable pattern. Public Sub Dispose() Implements IDisposable.Dispose ' Do not change this code. Put cleanup code in Dispose(ByVal disposing As Boolean) above. Dispose(True) GC.SuppressFinalize(Me) End Sub Protected Overridable Sub Dispose(ByVal disposing As Boolean) If Not Me.disposed Then If disposing Then 'dispose managed state (managed objects). RemoveHandler Me.Loaded, AddressOf Window_Loaded RemoveHandler txtTitle.PreviewMouseDown, AddressOf txtTitle_PreviewMouseDown RemoveHandler pbMin.PreviewMouseUp, AddressOf pbMin_PreviewMouseUp RemoveHandler pbClose.PreviewMouseUp, AddressOf pbClose_PreviewMouseUp RemoveHandler txtSend.KeyUp, AddressOf txtSend_KeyUp RemoveHandler btnSend.Click, AddressOf btnSend_Click RemoveHandler Me.Closed, AddressOf Window_Closed BindingOperations.ClearBinding(txtTitle, TextBlock.TextProperty) Me.Icon = Nothing ibBackground = Nothing 'iDeleteBuddy = Nothing 'btnAddBuddy = Nothing 'iBlockUser = Nothing pbMin = Nothing pbClose = Nothing MainWin = Nothing Me.Resources.Clear() GC.Collect() End If End If Me.disposed = True End Sub Protected Overrides Sub Finalize() ' Do not change this code. Put cleanup code in Dispose(ByVal disposing As Boolean) above. Dispose(False) MyBase.Finalize() End Sub #End Region End Class Then the following code for the XAML: --> Basically even if I create an empty WPF Window with a background image for the main grid and 2 eventhandlers Opening and Closed it still stays in memory, but when all the 'empty wpf' windows are closed the memory only decreases a little. just a little. Why arent simple windows disposed of entirely? I have even tried implementing the disposed functionality coded above.
