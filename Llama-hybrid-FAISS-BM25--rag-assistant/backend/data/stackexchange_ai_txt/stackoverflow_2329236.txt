[site]: stackoverflow
[post_id]: 2329236
[parent_id]: 2329171
[tags]: 
Here's just an outline of the idea: In a BST, the left subtree of node T contains only elements smaller than the value stored in T . If k is smaller than the number of elements in the left subtree, the k th smallest element must belong to the left subtree. Otherwise, if k is larger, then the k th smallest element is in the right subtree. We can augment the BST to have each node in it store the number of elements in its left subtree (assume that the left subtree of a given node includes that node). With this piece of information, it is simple to traverse the tree by repeatedly asking for the number of elements in the left subtree, to decide whether to do recurse into the left or right subtree. Now, suppose we are at node T: If k == num_elements(left subtree of T) , then the answer we're looking for is the value in node T . If k > num_elements(left subtree of T) , then obviously we can ignore the left subtree, because those elements will also be smaller than the k th smallest. So, we reduce the problem to finding the k - num_elements(left subtree of T) smallest element of the right subtree. If k , then the k th smallest is somewhere in the left subtree, so we reduce the problem to finding the k th smallest element in the left subtree. Complexity analysis: This takes O(depth of node) time, which is O(log n) in the worst case on a balanced BST, or O(log n) on average for a random BST. A BST requires O(n) storage, and it takes another O(n) to store the information about the number of elements. All BST operations take O(depth of node) time, and it takes O(depth of node) extra time to maintain the "number of elements" information for insertion, deletion or rotation of nodes. Therefore, storing information about the number of elements in the left subtree keeps the space and time complexity of a BST.
