[site]: stackoverflow
[post_id]: 5754982
[parent_id]: 5754590
[tags]: 
Populating a resource by calling a virtual function is possible by using inner classes. Here is an example #ifndef CLAZYSTATICRESOURCINITIALIZATIONASPECT_H #define CLAZYSTATICRESOURCINITIALIZATIONASPECT_H #include template class CLazyStaticResourceInitialization { public: /** * Destructor */ virtual ~CLazyStaticResourceInitialization() { } protected: /** * Internal class used for calling virtual function from constructor */ struct parent_virtual { /** * Virtual destructor */ virtual ~parent_virtual () { } /** * Virtual method implemented by parent class is necessary */ virtual void initializeOnce () const { } }; /** * Constructor that can call a virtual function of the parent * @param obj specifies the virtual function */ CLazyStaticResourceInitialization(const parent_virtual& obj ) { boost::mutex::scoped_lock scoped_lock(m_Mutex); //Initialize the resource only once if (isInitialized () == false) { obj.initializeOnce (); setInitialized (); } } /** * Returns if any instance of this class has been initialized or not * @return true if initialized, false otherwise */ bool isInitialized () const { return m_bInitialized;; } /** * Returns if any instance of this class has been initialized or not */ void setInitialized () { m_bInitialized = true; } protected: /** * The flag that indicates whether this class is initialized or not */ static volatile bool m_bInitialized; /** * The resource instance */ static R m_Resource; /** * The mutex to protect initialized flag */ static boost::mutex m_Mutex; }; //Assume that this class is not initialized in the beginning template volatile bool CLazyStaticResourceInitialization ::m_bInitialized = false; //Create a static instance of resource template R CLazyStaticResourceInitialization ::m_Resource; //Create a static instance of mutex template boost::mutex CLazyStaticResourceInitialization ::m_Mutex; #endif And here is how you can use it class CTestLazyInitialized : public CLazyStaticResourceInitialization > { public: CTestLazyInitialized(): CLazyStaticResourceInitialization >(lazyderived_virtual()) { } unsigned int size () { return this->m_Resource.size (); } protected: struct lazyderived_virtual : public CLazyStaticResourceInitialization >::parent_virtual { lazyderived_virtual () { } void initializeOnce () const { m_Resource.push_back (1); } }; }; Just pay attention to inner classes used in both base and derived classes. The mutex locking and template stuff can be ignored for your case.
