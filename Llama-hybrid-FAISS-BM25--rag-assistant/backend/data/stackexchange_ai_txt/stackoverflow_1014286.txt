[site]: stackoverflow
[post_id]: 1014286
[parent_id]: 978222
[tags]: 
OpenMP doesn't support these reduction operations. Consider Intel Threading Building Blocks' parallel_reduce algorithm, where you can implement arbitrary algorithm. Here an example. It uses summation of partial results. You may implement any function you want. #include #include #include #include /////////////////////////////////////////////////////////////////////////////// class PiCalculation { private: long num_steps; double step; public: // Pi partial value double pi; // Calculate partial value void operator () (const tbb::blocked_range &r) { double sum = 0.0; long end = r.end(); for (int i = r.begin(); i != end; i++) { double x = (i + 0.5) * step; sum += 4.0/(1.0 + x * x); } pi += sum * step; } // Combine results. Here you can implement any functions void join(PiCalculation &p) { pi += p.pi; } PiCalculation(PiCalculation &p, tbb::split) { pi = 0.0; num_steps = p.num_steps; step = p.step; } PiCalculation(long steps) { pi = 0.0; num_steps = steps; step = 1./(double)num_steps; } }; /////////////////////////////////////////////////////////////////////////////// int main() { tbb::task_scheduler_init init; const long steps = 100000000; PiCalculation pi(steps); tbb::parallel_reduce(tbb::blocked_range (0, steps, 1000000), pi); printf ("Pi is %3.20f\n", pi.pi); } Please check this link for additional reduction algorithms. http://cache-www.intel.com/cd/00/00/30/11/301132_301132.pdf#page=19 Please look through paragraph 3.3.1. There is an example on finding minimum value in an array.
