[site]: stackoverflow
[post_id]: 5368994
[parent_id]: 5368449
[tags]: 
The last two parameters are what seem to be passed to cv.Canny() , which implies that cv.Canny() is called from within cv.HoughCircles() . I'm not too sure about that. As for the sizes, it seems like the next two parameters (after 200, 100) default to 0 , which might mean that all sizes are detected. From the C++ example's source, I can also guess that you don't need to do a Canny edge detection: #include #include #include using namespace cv; int main(int argc, char** argv) { Mat img, gray; if( argc != 2 && !(img=imread(argv[1], 1)).data) return -1; cvtColor(img, gray, CV_BGR2GRAY); // smooth it, otherwise a lot of false circles may be detected GaussianBlur( gray, gray, Size(9, 9), 2, 2 ); vector circles; HoughCircles(gray, circles, CV_HOUGH_GRADIENT, 2, gray->rows/4, 200, 100 ); for( size_t i = 0; i You're trying to convert this C++ code into Python, I assume? for( size_t i = 0; i As far as I can tell, CvMat objects are iterable, just like a list: for circle in storage: radius = circle[2] center = (circle[0], circle[1]) cv.Circle(im, center, radius, (0, 0, 255), 3, 8, 0) I don't have any test images, so don't take my word that this works. Your complete code would might be: import cv def main(): im = cv.LoadImage('Proba.jpg') gray = cv.CreateImage(cv.GetSize(im), 8, 1) edges = cv.CreateImage(cv.GetSize(im), 8, 1) cv.CvtColor(im, gray, cv.CV_BGR2GRAY) #cv.Canny(gray, edges, 20, 55, 3) storage = cv.CreateMat(im.width, 1, cv.CV_32FC3) cv.HoughCircles(edges, storage, cv.CV_HOUGH_GRADIENT, 5, 25, 200, 10) for i in xrange(storage.width - 1): radius = storage[i, 2] center = (storage[i, 0], storage[i, 1]) print (radius, center) cv.Circle(im, center, radius, (0, 0, 255), 3, 8, 0) cv.NamedWindow('Circles') cv.ShowImage('Circles', im) cv.WaitKey(0) if __name__ == '__main__': main()
