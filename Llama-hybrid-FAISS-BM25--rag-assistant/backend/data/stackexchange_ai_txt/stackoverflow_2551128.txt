[site]: stackoverflow
[post_id]: 2551128
[parent_id]: 
[tags]: 
How can I implement a proper counter bean with EJB 3.0?

[EDIT] This question is "how do I do atomic changes to entity beans with EJB 3 and JPA 2.0". Should be simple, right? I tried to fix my code based on the answers I got so far. I'm using JBoss 6.0.0M2 with Hypersonic (just download it and call run.bat). My test case: Create 3 threads and call one of the testCounterMitLock*() 500 times in a loop. So a successful test should print "Anzahl eingetragene Zeilen: 1500" (3*500). I tried: CounterTestVersion ct = manager.find(CounterTestVersion.class, 1); manager.lock(ct, LockModeType.WRITE); int wert = ct.getWert(); Obviously doesn't work because a different thread can change the value in the database before the lock is applied. So I try to fix that: CounterTestVersion ct = manager.find(CounterTestVersion.class, 1); manager.lock(ct, LockModeType.WRITE); manager.refresh (ct); int wert = ct.getWert(); The refresh() should give me the current value and the implicit query should also make sure the object gets locked now. No such luck. Let's try with JPA 2.0: CounterTestVersion ct = manager.find(CounterTestVersion.class, 1, LockModeType.WRITE); int wert = ct.getWert(); That also doesn't work. Maybe the lock isn't enough? CounterTestVersion ct = manager.find(CounterTestVersion.class, 1, LockModeType.PESSIMISTIC_WRITE); int wert = ct.getWert(); Uhm ... doesn't work either! One last desperate attempt: CounterTestVersion ct = manager.find(CounterTestVersion.class, 1, LockModeType.PESSIMISTIC_WRITE); manager.flush(); manager.refresh (ct); int wert = ct.getWert(); Okay ... can anyone explain why nothing works? I'm out of ideas. [EDIT2] PS: To add insult to injury, this is the last output of the last running thread: commit/rollback: 441/62 (441+62 = 503)... Here is the complete code. First the bean: package server.kap15; import java.rmi.RemoteException; import javax.ejb.*; import javax.persistence.*; @Stateful public class CounterTestBean implements CounterTestRemote, SessionSynchronization { @PersistenceContext(unitName = "JavaEE") EntityManager manager; private int commit = 0; private int rollback = 0; public void initDatenbank() { manager.createNamedQuery("CounterTest.deleteAll").executeUpdate(); manager.createNamedQuery("TestTabelle.deleteAll").executeUpdate(); CounterTestVersion ct = new CounterTestVersion(); ct.setNr(1); ct.setVersion(1); ct.setWert(1); manager.persist(ct); } public boolean testCounterOhneLock() { try { CounterTest ct = manager.find(CounterTest.class, 1); int wert = ct.getWert(); ct.setWert(wert + 1); TestTabelle tt = new TestTabelle(); tt.setNr(wert); manager.persist(tt); manager.flush(); return true; } catch (Throwable t) { return false; } } public boolean testCounterMitLock() { try { CounterTestVersion ct = manager.find(CounterTestVersion.class, 1); manager.lock(ct, LockModeType.WRITE); int wert = ct.getWert(); ct.setWert(wert + 1); TestTabelle tt = new TestTabelle(); tt.setNr(wert); manager.persist(tt); manager.flush(); return true; } catch (Throwable t) { return false; } } public boolean testCounterMitLock2() { try { CounterTestVersion ct = manager.find(CounterTestVersion.class, 1); manager.lock(ct, LockModeType.WRITE); manager.refresh (ct); int wert = ct.getWert(); ct.setWert(wert + 1); TestTabelle tt = new TestTabelle(); tt.setNr(wert); manager.persist(tt); manager.flush(); return true; } catch (Throwable t) { return false; } } public boolean testCounterMitLock3() { try { CounterTestVersion ct = manager.find(CounterTestVersion.class, 1, LockModeType.WRITE); int wert = ct.getWert(); ct.setWert(wert + 1); TestTabelle tt = new TestTabelle(); tt.setNr(wert); manager.persist(tt); manager.flush(); return true; } catch (Throwable t) { return false; } } public boolean testCounterMitLock4() { try { CounterTestVersion ct = manager.find(CounterTestVersion.class, 1, LockModeType.PESSIMISTIC_WRITE); int wert = ct.getWert(); ct.setWert(wert + 1); TestTabelle tt = new TestTabelle(); tt.setNr(wert); manager.persist(tt); manager.flush(); return true; } catch (Throwable t) { return false; } } public boolean testCounterMitLock5() { try { CounterTestVersion ct = manager.find(CounterTestVersion.class, 1, LockModeType.PESSIMISTIC_WRITE); manager.flush(); manager.refresh (ct); int wert = ct.getWert(); ct.setWert(wert + 1); TestTabelle tt = new TestTabelle(); tt.setNr(wert); manager.persist(tt); manager.flush(); return true; } catch (Throwable t) { return false; } } public boolean testCounterMitVersion() { try { CounterTestVersion ctv = manager.find(CounterTestVersion.class, 1); int wert = ctv.getWert(); ctv.setWert(wert + 1); manager.flush(); TestTabelle tt = new TestTabelle(); tt.setNr(wert); manager.persist(tt); manager.flush(); return true; } catch (OptimisticLockException e) { System.out.println(">>> Versionskonflikt !"); return false; } catch (Throwable t) { System.out.println(t.getMessage()); return false; } } public long anzTestZeilen() { Query query = manager.createNamedQuery("TestTabelle.anzZeilen"); Long anzahl = (Long) query.getSingleResult(); return anzahl; } public void afterBegin() throws EJBException, RemoteException { } public void beforeCompletion() throws EJBException, RemoteException { } public void afterCompletion(boolean committed) throws EJBException, RemoteException { if (committed) commit++; else rollback++; System.out.println("commit/rollback: " + commit + "/" + rollback); } } The remote interface: package server.kap15; import javax.ejb.Remote; @Remote public interface CounterTestRemote { public void initDatenbank(); public boolean testCounterOhneLock(); public boolean testCounterMitLock(); public boolean testCounterMitLock2(); public boolean testCounterMitLock3(); public boolean testCounterMitLock4(); public boolean testCounterMitLock5(); public boolean testCounterMitVersion(); public long anzTestZeilen(); } The persistence.xml: java:DefaultDS The test client: package client.kap15; import java.util.Properties; import javax.naming.*; import javax.rmi.PortableRemoteObject; import server.kap15.CounterTestRemote; public class CounterTestMitLock extends Thread { CounterTestRemote ctr; public static void main(String[] args) { try { testMitLock(); testMitLock2(); testMitLock3(); testMitLock4(); testMitLock5(); } catch (Exception e) { e.printStackTrace (); } } static int N = 3; static CounterThread[] ct = new CounterThread[N]; private static void testMitLock () throws InterruptedException { System.out.println("--- Counter Test MIT Lock ----------------------"); System.out.println("Testinstanzen erzeugen..."); for (int i=0; i
