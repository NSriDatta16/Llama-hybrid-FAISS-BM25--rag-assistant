[site]: datascience
[post_id]: 69281
[parent_id]: 69140
[tags]: 
Simple RNN Cells follow this pattern: Given the following data: input data: X weights: wx recursive weights: wRec Initialize initial hidden state to 0 For each state, one by one: Update new hidden state as: (Input data * weights) + (Hidden state + recursive weights) In Python code: def compute_states(X, wx, wRec): """ Unfold the network and compute all state activations given the input X, input weights (wx), and recursive weights (wRec). Return the state activations in a matrix, the last column S[:,-1] contains the final activations. """ # Initialise a matrix that holds all states for all input sequences. # The initial state s_0 is set to 0, each of the others will depend from the previous. S = np.zeros((X.shape[0], X.shape[1]+1)) # Compute each state k from the previous state ( S[:,k] ) and current input ( X[:,k] ), # by use of the input weights (wx) and recursive weights (wRec). for k in range(0, X.shape[1]): S[:,k+1] = (X[:,k] * wx) + (S[:,k] * wRec) return S This is a slightly more clear version of the code I found here . Is this helpful for you?
