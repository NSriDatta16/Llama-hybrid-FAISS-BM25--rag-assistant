[site]: crossvalidated
[post_id]: 524937
[parent_id]: 
[tags]: 
Using a state space model to invert a moving average

Here is the problem :- We have an AR(1) process, $x[t]$ , ie, $(x[t] - \mu) = \phi(x[t-1]-\mu) + \epsilon_x[t] $ where $Var(\epsilon_x[t]) = \sigma_x^2$ and $Mean(\epsilon_x[t])=0$ ie. $x[t] = (\mu - \phi * \mu) + \phi x[t-1] + \epsilon_x[t] $ ie. $x[t] = \mu(1 - \phi) + \phi x[t-1] + \epsilon_x[t] $ For convenience I call $\mu(1-\phi)$ as $c$ . ie. $x[t] = c + \phi x[t-1] + \epsilon_x[t] $ We observe the 4 period moving average $y[t]$ of $x[t]$ with noise, ie. $ y[t] = 1/4*( x[t] + x[t-1] + x[t-2] + x[t-3] ) + \epsilon_y[t]$ where $Var(\epsilon_y[t]) = \sigma_y^2$ and $Mean(\epsilon_y[t])=0$ The problem is to go from $y[t]$ to $x[t]$ . Here is my attempt. I create the state space formulation of this problem. The measurement equation being :- $y[t] = .25 x[t] + .25 x[t-1] + .25 x[t-2] + .25 x[t-3] + \epsilon_y[t]$ The state vector here is $ \begin{bmatrix} x[t] \\ x[t-1] \\ x[t-2] \\ x[t-3] \\ 1 \\ \end{bmatrix} $ The state equation is :- $ \begin{bmatrix} x[t] \\ x[t-1] \\ x[t-2] \\ x[t-3] \\ 1 \end{bmatrix} = \begin{bmatrix} \phi && 0 && 0 && 0 && c = \mu * (1-\phi) \\ 0 && \phi && 0 && 0 && c = \mu * (1-\phi) \\ 0 && 0 && \phi && 0 && c = \mu * (1-\phi) \\ 0 && 0 && 0 && \phi && c = \mu * (1-\phi) \\ 0 && 0 && 0 && 0 && 1 \\ \end{bmatrix} \begin{bmatrix} x[t-1] \\ x[t-2] \\ x[t-3] \\ x[t-4] \\ 1 \\ \end{bmatrix} + \begin{bmatrix} \epsilon_x[t] \\ \epsilon_x[t-1] \\ \epsilon_x[t-2] \\ \epsilon_x[t-3] \\ 0 \end{bmatrix} $ The variance-covariance matrix of the error matrix above is :- $ \begin{bmatrix} \sigma_x^2 && 0 && 0 && 0 && 0 \\ 0 && \sigma_x^2 && 0 && 0 && 0 \\ 0 && 0 && \sigma_x^2 && 0 && 0 \\ 0 && 0 && 0 && \sigma_x^2 && 0 \\ 0 && 0 && 0 && 0 && 0 \end{bmatrix} $ In the language of dlm, I have computed GG and W. $ GG = \begin{bmatrix} \phi && 0 && 0 && 0 && c = \mu * (1-\phi) \\ 0 && \phi && 0 && 0 && c = \mu * (1-\phi) \\ 0 && 0 && \phi && 0 && c = \mu * (1-\phi) \\ 0 && 0 && 0 && \phi && c = \mu * (1-\phi) \\ 0 && 0 && 0 && 0 && 1 \end{bmatrix} $ $ W = \begin{bmatrix} \sigma_x^2 && 0 && 0 && 0 && 0 \\ 0 && \sigma_x^2 && 0 && 0 && 0 \\ 0 && 0 && \sigma_x^2 && 0 && 0 \\ 0 && 0 && 0 && \sigma_x^2 && 0 \\ 0 && 0 && 0 && 0 && 0 \end{bmatrix} $ Next I write the measurement equation in terms of the state vector at time t. $ y[t] = 1/4*( x[t] + x[t-1] + x[t-2] + x[t-3] ) + \epsilon_y[t]$ ie. $ y[t] = 1/4 * x[t] + 1/4 * x[t-1] + 1/4 * x[t-2] + 1/4 * x[t-3] + 0 * 1 + \epsilon_y[t]$ ie. $y[t] = \begin{bmatrix} .25 && .25 && .25 && .25 && 0 \end{bmatrix} * \begin{bmatrix} x[t] \\ x[t-1] \\ x[t-2] \\ x[t-3] \\ 1 \\ \end{bmatrix} + \epsilon_y[t] $ In terms of dlm, the $FF$ matrix is $ = \begin{bmatrix} .25 && .25 && .25 && .25 && 0 \end{bmatrix} $ and $V$ is $\begin{bmatrix} \sigma_y^2 \end{bmatrix} $ Here is the R program which implements the above library(dlm) library(zoo) # Simulating the data. set.seed(123) x $par[1])/(1+exp(fit1$ par[1]))^2 dg2 $par[2]) dg3 par[3]) dg4 $par[4]) dg hessian)%*%dg # print results coef; sqrt(diag(var)) coef + (2 * sqrt(diag(var))) coef - (2 * sqrt(diag(var))) Here is the output > coef; sqrt(diag(var)) [1] 0.6532458 4.4895771 0.6795316 6.0745278 [1] 0.04242776 0.66841183 0.12774506 0.10030250 > > coef + (2 * sqrt(diag(var))) [1] 0.7381013 5.8264007 0.9350217 6.2751328 > coef - (2 * sqrt(diag(var))) [1] 0.5683903 3.1527534 0.4240415 5.8739228 > The first parameter .3 is NOT between [.56,.73] The error variance in x = 4 is between [3.15,5.82 ] The error variance in y = 1 is not between [.42,.93 ] The mean of x = 6 IS between [5.8,6.2] This behavior is repeated on repeated sampling. In particular the $\phi$ is not covered in the 2 standard deviations of the coef[1]. Can some tell me where I am mistaken ? Theory or programming? I could have made a mistake but I do not see where I am wrong.
