[site]: stackoverflow
[post_id]: 1128761
[parent_id]: 1128444
[tags]: 
I think you should look into designing by contract . This way all components will be totally isolated from each other from the compile-time. But this will shift the work to maintaining the manually-written contracts instead of a compile-time-checked code interface. Basically, you'd have the same interface declaration on both side of the wire and then those are wired automatically by an agent which is either a custom implementation of Castle DynamicProxy and plus some Reflection stuff or an IoC container like Ninject which supports service locators. Basically, you write the "contract" on both Module1.dll and Module2.dll public interface IFooProvider { void Foo GetFoo(); } Then you need a service locator implementation which is a central piece of code that will help module register themselves and consumer finds the registered module. This is the normal work of a DI or IoC Container that I've mentioned. It'll look one way or another like this: public interface IServiceLocator { object LocateProvider (); void RegisterProvider (object implementation); } Basically, Module1, on load, should register itself with the ServiceLocator along withs the contract it is providing and then Module2, on load, would call the "LocateProvider" method supplying the contract it wants and gets the Module1 implementation. Something alongs: public class Module1Implementation : IProviderContract { void Foo GetFoo() { return new Foo(); } } public class Main { public void Main() { var locator = ServiceLocator.GetLocator(); locator.RegisterProvider (new Module1Implementation()); } } And in Module2.dll: public class Consumer { public IFooProvider FooProvider { get; set; } public Consumer() { var locator = ServiceLocator.GetLocator(); FooProvider = locator.LocateProvider (); // if Module1.dll is loaded, the locator should supply // Module1Implementation for you } } Then all "providers" module should reference the service locator DLL which should be 1 single extra DLL or it might have been built right into the core application itself. And on load, every module should register itself with the ServiceLocator along with the "contract" they are representing. Then, the last piece of the puzzle, is how you make contracts look-a-like which are defined in separate DLLs to appear as the same, which why I've mentioned Castle DynamicProxy and Reflection. How to do it is beyond this already long answer so I'll leave it to Google. :-) How will this helps? All dependencies between all DLLs but the service locator implementation are removed. So your deployment headache is down to: Make sure the service locator implementation is rock solid, since its the only thing that can't be easily changed. Make sure components that need to communicate with each other share the same "contract" Should the contract changes, use the Facade pattern to enable backward-compatibility. Whew! That was kinda long and buzzwords-filled but I hope it answers your question.
