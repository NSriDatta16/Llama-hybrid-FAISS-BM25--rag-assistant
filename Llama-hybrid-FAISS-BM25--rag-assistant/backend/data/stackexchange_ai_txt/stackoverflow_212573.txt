[site]: stackoverflow
[post_id]: 212573
[parent_id]: 209820
[tags]: 
Looking at your problem, I would modify the requirements a bit - 1) The most popular one should be shown most often. 2) Taglines should "age", so one that got a lot of votes (purchase) in the past, but none recently should be shown less often 3) Brand new taglines should be shown more often during their first days. If you agree on those, then a algorithm could be something like: START: x = random(1, 3); if x = 3 goto NEW else goto NORMAL NEW: TagVec = Taglines.filterYounger(5 days); // I'm taking a LOT of liberties with the pseudo code,,, x = random(1, TagVec.Length); return tagVec[x-1]; // 0 indexed vectors even in made up language, NORMAL: // Similar to EBGREEN above sum = 0; ForEach(TagLine in TagLines) { sum += TagLine.noOfPurhcases; } x = random(1, sum); ForEach(TagLine in TagLines) { x -= TagLine.noOfPurchase; if ( x > 0) return TagLine; // Find the TagLine that represent our random number } Now, as a setup I would give every new tagline 10 purchases, to avoid getting really big slanting for one single purchase. The aging process I would count a purchase older than a week as 0.8 purhcase per week of age. So 1 week old gives 0.8 points, 2 weeks give 0.8*0.8 = 0,64 and so forth... You would have to play around with the Initial purhcases parameter (10 in my example) and the aging speed (1 week here) and the aging factor (0.8 here) to find something that suits you.
