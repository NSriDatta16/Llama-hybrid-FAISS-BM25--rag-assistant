[site]: stackoverflow
[post_id]: 42662
[parent_id]: 42357
[tags]: 
What I don't understand is how the termination of the request as soon as a SQL Injection is detected in the URL not be part of a defense? (I'm not claiming this to be the entire solution - just part of the defense.) Every database has its own extensions to SQL. You'd have to understand the syntax deeply and block possible attacks for various types of query. Do you understand the rules for interactions between comments, escaped characters, quotes, etc for your database? Probably not. Looking for fixed strings is fragile. In your example, you block cast(0x , but what if the attacker uses CAST (0x ? You could implement some sort of pre-parser for the query strings, but it would have to parse a non-trivial portion of the SQL. SQL is notoriously difficult to parse. It muddies up the URL dispatch, view, and database layers. Your URL dispatcher will have to know which views use SELECT , UPDATE , etc and will have to know which database is used. It requires active updating of the URL scanner. Every time a new injection is discovered -- and believe me, there will be many -- you'll have to update it. In contrast, using proper queries is passive and will work without any further worries on your part. You'll have to be careful that the scanner never blocks legitimate URLs. Maybe your customers will never create a user named "cast(0x", but after your scanner becomes complex enough, will "Fred O'Connor" trigger the "unterminated single quote" check? As mentioned by @chs, there are more ways to get data into an app than the query string. Are you prepared to test every view that can be POST ed to? Every form submission and database field?
