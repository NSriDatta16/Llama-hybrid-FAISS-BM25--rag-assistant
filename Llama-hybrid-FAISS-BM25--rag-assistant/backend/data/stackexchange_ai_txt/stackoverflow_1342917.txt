[site]: stackoverflow
[post_id]: 1342917
[parent_id]: 1341818
[tags]: 
If you use PHP 5.3.0 and mysqlnd, you can use the new function mysqli_fetch_all() . This returns an array of associative arrays. If you use an earlier version of PHP, you could switch to using PDO, and use the function PDOStatement::fetchAll() . You ask in a comment what about a very large result set. It's true that an unbounded result set could cause the array to exceed your PHP memory limit and that would cause a fatal error and halt the script. But is this really a problem? How many products do you have? You could use LIMIT to make sure the query isn't unbounded. Re the other part of your questions regarding going back to a class, I'd suggest making an Iterator class: class DB implements IteratorAggregate { protected $_data = array(); public function getProductList() { // fetch all results from SQL query, stuff them into $this->_data return $this->getIterator(); } public function getIterator() { return new ArrayIterator($this->_data); } } Now you can use the class in a foreach loop: $db = new DB(); foreach ($db->getProductList() as $product) { // do something with each product } The IteratorAggregate interface means you can even do this: $db = new DB(); $db->getProductList(); // ...other steps... foreach ($db as $product) { // do something with each product } Of course you could only store one result set at a time with this method. If you used your DB class for any other queries in the meantime, it would complicate things. For this reason, most people don't try to write a single class to encapsulate all database operations. They write individual classes for each type of Domain Model they need to work with, decoupled from the database connection.
