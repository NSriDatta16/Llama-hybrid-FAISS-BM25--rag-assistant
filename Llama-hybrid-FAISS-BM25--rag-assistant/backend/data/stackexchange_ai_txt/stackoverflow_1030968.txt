[site]: stackoverflow
[post_id]: 1030968
[parent_id]: 1024640
[tags]: 
For these kind of problems I'm using an iterator that returns for each integer m the list of primes N ) that divide m. To implement such an iterator I'm using an array A of length R where R > sqrt( N ). At each point the array A contains list of primes that divide integers m .. m+R -1. I.e. A [ m % R ] contains primes dividing m . Each prime p is in exactly one list, i.e. in A [ m % R ] for the smallest integer in the range m .. m + R -1 that is divisible by p . When generating the next element of the iterator simply the list in A [ m % R ] is returned. Then the list of primes are removed from A [ m % R ] and each prime p is appended to A [( m + p ) % R]. With a list of primes N ) dividing m it is easy to find the factorization of m , since there is at most one prime larger than sqrt( N ). This method has complexity O( N log(log( N ))) under the assumption that all operations including list operations take O(1). The memory requirement is O(sqrt( N )). There is unfortunately, some constant overhead here, hence I was looking for a more elegant way to generate the values phi(n), but so for I've not been successful.
