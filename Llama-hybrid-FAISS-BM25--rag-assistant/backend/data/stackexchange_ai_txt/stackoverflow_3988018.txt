[site]: stackoverflow
[post_id]: 3988018
[parent_id]: 3987521
[tags]: 
If your container value is limited to a small number of types, you could achieve this using boost::variant as shown here: #include #include using namespace std; class text { }; class element { }; template class node { T cargo; static std::vector > children; node(const T& cargo) : cargo(cargo) { }; void add_child(const T& node) { children.push_back(boost::variant (node)); } }; I have taken the liberty of suggesting a couple of other mods - use const reference instead of pass-by-value on node constructor and add_child ; make the container children static as I don't think it makes sense for each node to have its own container. Locking would be required for multithreaded usage of add_child in this case. These comments apply whether you can use Boost or not in your final solution. You can perform operations on the vector elements using either get or static_visitor - the latter is preferable since you can make this generic - as shown here . An example of vector iteration analogous to what you would use for this solution: class times_two_generic : public boost::static_visitor<> { public: template void operator()( T & operand ) const { operand += operand; cout > vec; vec.push_back( 21 ); vec.push_back( "hello " ); times_two_generic visitor; std::for_each( vec.begin(), vec.end() , boost::apply_visitor(visitor) ); Output is: 42 hello hello
