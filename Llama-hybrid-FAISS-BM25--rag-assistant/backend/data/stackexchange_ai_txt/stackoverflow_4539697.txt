[site]: stackoverflow
[post_id]: 4539697
[parent_id]: 4539416
[tags]: 
Opening the PresentationFramework.dll within Reflector and looking at System.Windows.Controls.ItemsControl showed the following: public static readonly DependencyProperty ItemsSourceProperty = DependencyProperty.Register("ItemsSource", typeof(IEnumerable), typeof(ItemsControl), new FrameworkPropertyMetadata(null, new PropertyChangedCallback(ItemsControl.OnItemsSourceChanged))); private static void OnItemsSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { ItemsControl control = (ItemsControl) d; IEnumerable oldValue = (IEnumerable) e.OldValue; IEnumerable newValue = (IEnumerable) e.NewValue; ItemValueStorageField.ClearValue(d); if ((e.NewValue == null) && !BindingOperations.IsDataBound(d, ItemsSourceProperty)) { control.Items.ClearItemsSource(); } else { control.Items.SetItemsSource(newValue); } control.OnItemsSourceChanged(oldValue, newValue); } Not knowing what RefreshLayout does my hunch is that it has something to do with the way the ObservableCollection is being wrapped as the above code is oblivious to what the concrete collection type is and it would therefore be handled by the type being wrapped; in this case an ObservableCollection Try modifying your property as seen below to return the default view and adjust your ItemsSource property to be more akin to the above code from the framework and work backwards from there. private ObservableCollection eventItems; private ICollectionview eventsView; public System.ComponentModel.ICollectionView Events { get { if (eventsView == null) eventsView = CollectionViewSource.GetDefaultView(eventItems); return eventsView; } }
