[site]: stackoverflow
[post_id]: 3136639
[parent_id]: 2461762
[tags]: 
it has to do with memory fragmentation. Consider two strings, concatenated to one string. Each original must remain until the output is created. The output is longer than either input. Therefore, a new allocation must be made to store the result of such a concatenation. The original strings are freed but they are small blocks of memory. In a case of 'str1' . 'str2' . 'str3' . 'str4' you have several temps being created at each . -- and none of them fit in the space thats been freed up. The strings are likely not laid out in contiguous memory (that is, each string is, but the various strings are not laid end to end) due to other uses of the memory. So freeing the string creates a problem because the space can't be reused effectively. So you grow with each tmp you create. And you don't re-use anything, ever. Using the array based implode, you create only 1 output -- exactly the length you require. Performing only 1 additional allocation. So its much more memory efficient and it doesn't suffer from the concatenation fragmentation. Same is true of python. If you need to concatenate strings, more than 1 concatenation should always be array based: ''.join(['str1','str2','str3']) in python implode('', array('str1', 'str2', 'str3')) in PHP sprintf equivalents are also fine. The memory reported by memory_get_peak_usage is basically always the "last" bit of memory in the virtual map it had to use. So since its always growing, it reports rapid growth. As each allocation falls "at the end" of the currently used memory block.
