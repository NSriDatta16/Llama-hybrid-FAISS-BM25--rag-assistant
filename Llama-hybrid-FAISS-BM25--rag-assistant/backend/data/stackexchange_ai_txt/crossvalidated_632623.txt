[site]: crossvalidated
[post_id]: 632623
[parent_id]: 
[tags]: 
Riemannian alignment has no effect

I am trying to implement a Brain-Computer Interface system that should be able to differentiate between rest and movement trials. I am using motor-related cortical potentials for movement detection. The method I am using is cross-session transfer learning via Riemannian Alignment on EEG data as described in Transfer Learning for Brainâ€“Computer Interfaces: A Euclidean Space Data Alignment Approach by He and Wu. I am using the pyRiemann package, which implements most of the functionality. In short, the idea behind Riemannian alignment is that we convert our trials $X_i$ from time domain to the domain of covariance matrices: $$ \Sigma_i = X_iX^T_i$$ We find the Riemannian mean $ \overline R$ of the rest trials ( $I$ ): $$ \overline R = \arg \min\limits_{R} \sum\limits_{i \in I}{\delta^2(R, \Sigma_i)}$$ Then align all covariance matrices based on that mean: $$ \widetilde{\Sigma} = \overline R^{-1/2} \Sigma_i \overline R^{-1/2}$$ However, my Riemann-aligned data is only scaled and not actually aligned. Here's an MVCE on synthetic random data: import numpy as np from pyriemann.classification import MDM from pyriemann.estimation import ERPCovariances from pyriemann.utils import mean_riemann from scipy.linalg import fractional_matrix_power def generate_random_data(num_trials, num_channels, num_samples) -> np.array: return np.random.rand(num_trials, num_channels, num_samples) def get_data(): raw_mrcps = generate_random_data(100, 9, 1024) raw_rests = generate_random_data(100, 9, 1024) X = np.concatenate([raw_mrcps, raw_rests]) y = np.concatenate((np.full(raw_mrcps.shape[0], "MRCP"), np.full(raw_rests.shape[0], "Rest"))) return X, y def riemann_align_covariances(covariances: np.array, riemannian_mean: np.array): """ Aligns covariance matrices to the mean :param covariances: (n_trials, n_channels, n_channels) array :param riemannian_mean: (n_channels, n_channels) array :return: (n_trials, n_channels, n_channels) array of aligned covariance matrices """ sqrt_rm = fractional_matrix_power(riemannian_mean, -0.5) return np.matmul(np.matmul(sqrt_rm, covariances), sqrt_rm) def ra_fit(X, y): """ Performs Riemannian alignment on the train dataset :param X: (n_trials, n_channels, n_channels) array of trials :param y: (n_trials) array of labels :return: (covariance estimator, Riemannian mean, aligned covariances, covariances) """ # Use the ERP covariance estimator, as motor-related cortical potentials are ERP cov_estimator = ERPCovariances().fit(X, y) Xcov = cov_estimator.transform(X) riemannian_mean = mean_riemann(Xcov[y == "Rest"]) aligned_cov = riemann_align_covariances(Xcov, riemannian_mean) return cov_estimator, riemannian_mean, aligned_cov, Xcov def ra_predict(X_test, cov_estimator, riemannian_mean): """ Performs Riemannian alignment on the test dataset :param X_test: (n_trials, n_channels, n_channels) array of trials :param cov_estimator: Covariance estimator fitted on the train dataset :param riemannian_mean: Riemannian mean computed on the train dataset :return: (aligned covariances, covariances) """ # Estimate covariance matrices test_cov = cov_estimator.transform(X_test) # Use the Riemannian mean to align covariance matrices aligned_cov_test = riemann_align_covariances(test_cov, riemannian_mean) return aligned_cov_test, test_cov if __name__ == "__main__": np.random.seed(420) X_train, y_train = get_data() X_test, y_test = get_data() cov_estimator, riemannian_mean, aligned_cov_train, Xcov_train = ra_fit(X_train, y_train) aligned_cov_test, Xcov_test = ra_predict(X_test, cov_estimator, riemannian_mean) print(f"Aligned train min:{aligned_cov_train.min()}, max:{aligned_cov_train.max()}") print(f"Aligned test min:{aligned_cov_test.min()}, max:{aligned_cov_test.max()}") print(f"Raw train min:{Xcov_train.min()}, max:{Xcov_train.max()}") print(f"Raw test min:{Xcov_test.min()}, max:{Xcov_test.max()}") print("\n") mdm_aligned = MDM().fit(aligned_cov_train, y_train) print(f"Aligned, cross-session accuracy: {mdm_aligned.score(aligned_cov_test, y_test)}") print(f"Aligned, same-session accuracy: {mdm_aligned.score(aligned_cov_train, y_train)}") mdm_raw = MDM().fit(Xcov_train, y_train) print(f"Raw, cross-session accuracy: {mdm_raw.score(Xcov_test, y_test)}") print(f"Raw, same-session accuracy: {mdm_raw.score(Xcov_train, y_train)}") But the outputs suggests, that even though the covariance matrices have been adjusted (notice the change of min and max values between raw and aligned sets), it had zero effect on the relationships between the samples (the classification accuracy stays the same) Aligned train min:-0.0008464822809330225, max:0.007592227870226339 Aligned test min:-0.0007567616196139543, max:0.007511262549941491 Raw train min:-0.009972139397447007, max:0.09223166210280183 Raw test min:-0.00907206088657424, max:0.09081586929555409 Aligned, cross-session accuracy: 0.505 Aligned, same-session accuracy: 1.0 Raw, cross-session accuracy: 0.505 Raw, same-session accuracy: 1.0 This is supported by the plots of covariance matrices' embeddings, which show zero change between raw and aligned (the "Day1" synthetic data is a tad weird, having both classes already separated, but it still shows that there is no change between raw and aligned). Neverthless, my real data suffers from the same issue. Synthetic data covariance embeddings: EEG data covariance embeddings I would expect that the covariance matrices get manipulated by the alignment, such that it gets easier to find a boundary between the two classes - or at least that they get somewhat moved. Is my assumption wrong or am I doing something wrong here? The full copy-paste-and-run gist with plotting can be found here .
