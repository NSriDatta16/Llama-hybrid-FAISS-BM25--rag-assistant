[site]: stackoverflow
[post_id]: 1590322
[parent_id]: 1590148
[tags]: 
That's clearly not a good idea, really. These directories are a way to organize the code in logical groups. /web /include /web /stackoverflow /language-agnostic /algorithm /database /meta /bug /feature-request /src /local/ /include /local /my-favorites /src Now if I type #include "exception.h" What the heck am I trying to include ? Where's that file ? How can I see its content ? On the other hand if I type #include "local/my-favorites/exception.h" Then it's perfectly clear. (and I just have two includes -Iweb/include -Ilocal/include) And this way, I can have multiple files that have the exact same name and there would be no ambiguity, nifty when you wish to integrate two different 3rd party libraries which both have such a 'exception.h'. Also note that for clarity, the namespace nesting should reflect the directories organization. So that file: "web/include/web/meta/bug/exception.h" namespace web { namespace meta { namespace bug { struct exception: std::runtime_error {}; } } } // namespace bug, namespace meta, namespace web This way it's easy to think of what header you have to include when you want a class. Also note that, for example if you look at boost, they put headers for 'lazy' programmers, in each directory, which include the headers of all subdirectories file: "web/include/web/meta/bug.h" #include "web/meta/bug/file1.h" #include "web/meta/bug/file2.h" #include "web/meta/bug/file3.h" #include "web/meta/bug/file4.h" #include "web/meta/bug/file5.h" file: "web/include/web/meta.h" #include "web/meta/bug.h" #include "web/meta/feature-request.h" These includes might also 'pull' names into a more generic namespace with a using directive: namespace web { namespace meta { using ::web::meta::bug::bug; } } // namespace meta, namespace web To make it less painful for developers. So as you can see, the language already provide you with a very good way of organizing your code cleanly, if you go with the 'all includes' options, you'll just end up with an unmaintainable mess: #include "exception.h" #include "bug.h" #include "myString.h" #include "database_connect.h" #include "helper.h" // really love this one... #include "file.h" // not bad either eh ? I've had some of these at work... think 20 unqualified includes when you depend on 25+ components... now, do you think that it would be possible to remove a dependency on component X ? ;) EDIT : How to deal with 3rd party library ? Sometimes a 3rd party library does not live up to your expectations, whether it is: not self-sufficient headers (ie you need to include 3 files to use 1 object) warnings at compilation header organization problem you always have the opportunity to wrap them in headers of your own. For example, say I have: /include /file1.h /file2.h /detail /mustInclude.h /exception.h And anytime you wish to include a file, you have to include 'exception.h' BEFORE and 'mustInclude.h', and of course you have the problem that it is difficult to spot that the files included come from this 3rd party library and not your own (current) project. Well, just wrap: /include /3rdParty /file1.h (same name as the one you would like to include, it's easier) file: "/include/3rdParty/file1.h" #pragma push // ignore warnings caused #include "detail/exception.h" // necessary to include it before anything #include "file1.h" #include "detail/mustInclude.h" #pragma pop And then in your code: #include "3rdParty/file1.h" You have just isolated the problem, and all the difficulty now lies within your wrappers files. Note: I just realize that you may have the problem that the 3rd party headers reference each others without taking the 'relative path' into account, in this case, you can still avoid the 'multiple include' syndroms (even without edition), but that might be ill-fated. I suppose you don't have the opportunity not to use such crap :x ?
