[site]: stackoverflow
[post_id]: 5686551
[parent_id]: 
[tags]: 
Having trouble loading in multiple .bmp files for textures OpenGL C++

Having some trouble trying to get to .bmp files into an array so I can use them for textures. EDIT Display.h #pragma once #include "Ball.h" #include "Bitmap.h" class Display { private : static Bitmap m_HeightMap; static unsigned int textures; // static float TableX, TableY, TableZ; static float eyeZ, eyeY, eyeX; static float lightX, lightY, lightZ; static float Position[4]; static float translateZ, translateX; //static Timer m_Timer; public: static void Init(int argc, char ** argv); static void DisplayScene(); static void Resize(int w, int h); static void KeyboardInput(unsigned char pKey, int pX, int pY); static void Idle(); static void DrawLight(int pLightNumber, float * pPos); static void Table(float zStart, float xStart, float zEnd, float xEnd); static void BallCollisions(float pTimestep, Vector3f New_position, Vector3f New_velocity); }; void main(int argc, char ** argv) { Display::Init(argc, argv); } Display.cpp #include "Display.h" #include "Vector3f.h" #include "Ball.h" #include "Glut/glut.h" #include "GL/gl.h" #include "GL/glu.h" #include #include "Bitmap.h" static float TableWidth = 4; // Z axis normal = 4 float Display::eyeX = -7.5; //-7.5 float Display::eyeY = 3; //3 float Display::eyeZ = 5; //5 float Display::Position[4] = { 1.0f, 0.0f, -3.5, 1.0f }; float Display::translateZ = -3.5; float Display::translateX = 0.0; //Timer Display::m_Timer = Timer(); float Display::lightX = 5.0; //5 2.5 float Display::lightY = 5.0; float Display::lightZ = 2.5; float m_TableX = -5.0f; float m_TableZ = -2.5f; float m_TableWidth = 2.5f; float m_TableLength = 5.0f; float ballx = 0.7; float bally = 0.1; float ballz = -0.7; Ball Redball; float BALL_RED_START = 0; float RADIUS_OF_BALL = 0.3; float BALL_RED_END = 8; Ball Yellowball; float BALL_YELLOW_START = 0; float BALL_YELLOW_END = 8; Bitmap Display::m_HeightMap; unsigned int Display:: textures; GLuint textures[2]; void loadTexture(GLuint texture, const char* filename) { Bitmap image; Bitmap image[2]; image[0].loadBMP("myTexture.bmp"); image[1].loadBMP("myTexture2.bmp"); glBindTexture(GL_TEXTURE_2D, texture); glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE , GL_MODULATE); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image.width, image.height, GL_RGB, GL_UNSIGNED_BYTE, image.data); } void Display::Init(int argc, char ** argv) { glutInit(&argc, argv); // initializes glut // sets display mode. These parameter set RGB colour model // and double buffering. glutInitWindowSize(500,500); glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE); glutCreateWindow("Pool Version 1.0"); // Set glut callback functions glutDisplayFunc(Display::DisplayScene); glutIdleFunc(Display::Idle); glutReshapeFunc(Display::Resize); glutKeyboardFunc(Display::KeyboardInput); //m_Timer.getSeconds(); glEnable(GL_DEPTH_TEST); glPointSize(5); glEnable(GL_NORMALIZE); glEnable(GL_LIGHTING); glClearColor(0,0,0,1); glEnable(GL_COLOR_MATERIAL); float white[] = { 1.0f, 1.0f, 1.0f, 1.0f }; glLightfv(GL_LIGHT0, GL_DIFFUSE, white); glEnable(GL_LIGHT0); Redball.SetPos(Vector3f(0.0,0.3,0.0)); Ball Redball[8]; for(int i = BALL_RED_START; i } Bitmap.h I also have a class for my textures #ifndef _BITMAP_H #define _BITMAP_H #include #include #include using namespace std; const short BITMAP_MAGIC_NUMBER=19778; const int RGB_BYTE_SIZE=3; #pragma pack(push,bitmap_data,1) typedef struct tagRGBQuad { char rgbBlue; char rgbGreen; char rgbRed; char rgbReserved; } RGBQuad; typedef struct tagBitmapFileHeader { unsigned short bfType; unsigned int bfSize; unsigned short bfReserved1; unsigned short bfReserved2; unsigned int bfOffBits; } BitmapFileHeader; typedef struct tagBitmapInfoHeader { unsigned int biSize; int biWidth; int biHeight; unsigned short biPlanes; unsigned short biBitCount; unsigned int biCompression; unsigned int biSizeImage; int biXPelsPerMeter; int biYPelsPerMeter; unsigned int biClrUsed; unsigned int biClrImportant; } BitmapInfoHeader; #pragma pack(pop,bitmap_data) class Bitmap { public: //variables RGBQuad *colours; char *data; bool loaded; int width,height; unsigned short bpp; string error; //methods Bitmap(void); Bitmap(char *); ~Bitmap(); bool loadBMP(char *); private: //variables BitmapFileHeader bmfh; BitmapInfoHeader bmih; int byteWidth; //the width in bytes of the image int padWidth; //the width in bytes of the added image unsigned int dataSize; //size of the data in the file //methods void reset(void); bool convert24(char *); //convert to 24bit RGB bottom up data bool convert8(char *); //convert to 24bit RGB bottom up data }; #endif //_BITMAP_H Bitmap.cpp #include "Bitmap.h" //basic constructor Bitmap::Bitmap(){ reset(); } //constructor loads the bitmap when it is created Bitmap::Bitmap(char *file){ reset(); loadBMP(file); } //destructor Bitmap::~Bitmap(){ if(colours!=0) { delete[] colours; } if(data!=0) { delete[] data; } } //load a bitmap from a file and represent it correctly //in memory bool Bitmap::loadBMP(char *file) { FILE *in; //file stream for reading char *tempData; //temp storage for image data int numColours; //total available colours //bitmap is not loaded yet loaded=false; //make sure memory is not lost if(colours!=0) { delete[] colours; } if(data!=0) { delete[] data; } //open the file for reading in binary mode in=fopen(file,"rb"); //if the file does not exist return in error if(in==NULL) { error="File not found"; fclose(in); return false; } //read in the entire BITMAPFILEHEADER fread(&bmfh,sizeof(BitmapFileHeader),1,in); //check for the magic number that says this is a bitmap if(bmfh.bfType!=BITMAP_MAGIC_NUMBER) { error="File is not in DIB format"; fclose(in); return false; } //read in the entire BITMAPINFOHEADER fread(&bmih,sizeof(BitmapInfoHeader),1,in); //save the width, height and bits per pixel for external use width=bmih.biWidth; height=bmih.biHeight; bpp=bmih.biBitCount; //calculate the size of the image data with padding dataSize=(width*height*(unsigned int)(bmih.biBitCount/8.0)); //calculate the number of available colours numColours=1 0) { offset=padWidth-byteWidth; //count backwards so you start at the front of the image for(int i=0;i 0) { offset=padWidth-byteWidth; int j=0; //count backwards so you start at the front of the image for(int i=0;i All my errors are to do with this code in Display.cpp: Bitmap image[2]; image[0].loadBMP("myTexture.bmp"); image[1].loadBMP("myTexture2.bmp"); Errors: error C2040: image:'Bitmap [2]' differs in level of indirection of 'Bitmap' error C2088: '[' illegal for class (twice) error C2228: left of .BMP must have class/struct/union (twice) no operator "[]" matches these operands (twice)
