[site]: stackoverflow
[post_id]: 4900470
[parent_id]: 4900383
[tags]: 
There are two kinds of types in the C# type system "value types" and "reference types". Value types are copied by value; when you copy one, you get a wholly new object that has nothing to do with the original. Reference types are copied by reference; when you copy one, you are actually copying a reference to some storage location. You get two references that both refer to one object. Shorts are value types. If you want a short to be a reference type, then you could make a reference type wrapper: class ReferenceType where T : struct { public T Value { get; set } public ReferenceType(T value) { this.Value = value; } } var v1 = new ReferenceType (1); var v2 = new ReferenceType (2); var vs = new ReferenceType [2] { v1, v2 }; v1.Value = 1024; v2.Value = 512; Console.WriteLine(vs[0].Value); Console.WriteLine(vs[1].Value); And there you go. Now, that will give you reference access to the short because the short is actually stored in the field associated with the value property of the class. If you then say: v2 = new ReferenceType (3); Console.WriteLine(vs[1].Value); you won't get "3" -- v2 now refers to a different object than vs[1]. If what you really want to capture is a reference to a variable then what you want to use is a closure . class ReferenceToVariable { private Func getter; private Action setter; public ReferenceToVariable(Func getter, Action setter) { this.getter = getter; this.setter = setter; } public T Value { get { return getter(); } set { setter(value); } } } ... short v1 = 1; short v2 = 2; var vs = new [] { new ReferenceToVariable (()=>v1, x=>{v1=x;}), new ReferenceToVariable (()=>v2, x=>{v2=x;}) }; v1 = 123; vs[1].Value = 456; Console.WriteLine(vs[0].Value); // 123 Console.WriteLine(v2); // 456 Here we capture in the array objects which know how to get and set the current values of v1 and v2. Now, if what you want to do is make an alias to another variable directly , without this object in the way, then there is only one way to do that in C#: void M(ref short x) { x = 123; } ... short y = 1; M(ref y); Now "x" and "y" are two names for the same variable. However, the concept of "make an alias to another variable" only works in C# when the aliasing variable is a formal parameter of a method. There is no way to do it in general. Now, we could in theory do something like what you want. We could support "ref locals": UPDATE: The "theoretical" feature I discuss here was added to C# 7.0. short v1 = 1; ref short rv1 = ref v1; rv1 = 123; Console.WriteLine(v1); // 123 That is, rv1 becomes an alias for v1. C# does not support this, but the CLR does and therefore we could support it. However, the CLR does not support making arrays of "ref" element type, or fields that store refs. So in that sense, you couldn't do what you want. C# does support some special "hidden" features for passing around objects that act like references to variables but are lighter weight than the "two delegate" reference mentioned above. However, these special features are only for bizarre interop scenarios and I recommend against them. (And again, you can't make an array that stores typed references.) I don't think I'll talk about those features more in this answer; you really don't want to go there, believe me.
