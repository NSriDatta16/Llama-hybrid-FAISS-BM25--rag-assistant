[site]: stackoverflow
[post_id]: 4725715
[parent_id]: 4725512
[tags]: 
Consider this: Long transactions makes system less scalable. If you do UPDATE command, update locks last until commit/rollback, preventing other transaction to proceed. Second tables/database can be modified by concurent transactions, so you cannot rely on data in tables. Only way is to lock it => see no1. Serializable transaction in some data engines uses versions of data in your tables. So after first cmd is executed, transaction can see exact data available in cmd execution time. This might help you to show changes made by user, but you have no guarantee to save them back into storage. DataSets contains old/new version of data. But that is unfortunatelly out of your technology aim.
