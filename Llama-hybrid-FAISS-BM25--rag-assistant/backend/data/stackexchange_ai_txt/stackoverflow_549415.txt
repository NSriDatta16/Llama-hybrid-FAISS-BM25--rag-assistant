[site]: stackoverflow
[post_id]: 549415
[parent_id]: 549382
[tags]: 
Some of the questions to consider are: Is your application multi-threaded? Is the thread[s] which write[s] the messages the same as the UI thread which reads the messages and populates the list box? How many messages per second and being created? How many times per second do you want to update the list box? What's the maximum number of messages over time? Do you display them all in the list box, or do you discard older ones? Do you want log the messages into a file as well (e.g. for tech support purposes)? Is the listbox (the UI element) the only place where messages are stored? Is the listbox always displayed, or can the user hide/destroy it? How sophisticated are the end-users? Can you ask them to use other (better) tools to view your log file, or do you need to implement a (relatively unsophisticated) viewer into your own UI? Sorry to answer your question with questions, but these are questions which need answering before you can say "is this the best approach?". it's not a multithreaded application, is a freaking small application that I don't want to overload. If the application isn't multi-threaded, then the 'simplest thing that could possibly work' would be to not bother with a list or queue; and instead, let your other classes append messages directly into the UI listbox element (perhaps via a delegate), for example: class MyClass { Action log; MyClass(Action log) { this.log = log; } void Something() { //log a message log("Hello world!"); } } class MyForm { ListBox listBox = new ListBox(); MyClass myClass; MyForm() { //create a delegate which logs strings //by writing them to the ListBox Action log = delegate(string s) { listBox.Items.Add(s); }; //pass this logger to classes which need to use it myClass = new MyClass(log); //test it myClass.Something(); } } Here's similar code using a non-anonymous delegate, with some extra functionality as requested in one of your comments: class MyForm { ListBox listBox = new ListBox(); MyClass myClass; MyForm() { //pass the Log action to classes which need to use it myClass = new MyClass(Log); //test it myClass.Something(); } ///logs strings by writing them to the ListBox void Log(string s) { if (listBox.Items.Count == 300) listBox.Items.RemoveAt(0); listBox.Items.Add(s); } } I think I answer wrong the (6). I should be able to send messages even if the listbox has not been created yet... that's why I suggested a List or Queue In this case, you do need storage other than only the ListBox. Your suggestion would work. An alternative suggestion is: When you create your ListBox, populate it from the List (using the ListBox.Items.AddRange method) In the Log function, if the ListBox doesn't exist then write the message to the List, else if the ListBox does exist then write the message to the ListBox. Doing this might be (very slightly) simpler than defining, listening to, and firing an event.
