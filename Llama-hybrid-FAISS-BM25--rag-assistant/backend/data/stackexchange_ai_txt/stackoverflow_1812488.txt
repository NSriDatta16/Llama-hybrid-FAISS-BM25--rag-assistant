[site]: stackoverflow
[post_id]: 1812488
[parent_id]: 1806395
[tags]: 
I have done this by Party model. This way your abstraction is always Party: public abstract class Party { private IList _contacts = new List (); public int Id {get; set;} public abstract string DisplayName { get; } public IEnumerable Contacts { get { return _contacts; } } } public class Person { public string FirstName {get; set;} public string LastName {get; set;} public override string DisplayName { get { return FirstName + " " + LastName; } } } public class Organization { public string Name {get; set;} public override string DisplayName { get { return Name; } } } For mapping there are two possible strategies: One table per inheritance tree; one table per class. public class PartyMap : ClassMap { public PartyMap() { Id(x => x.Id).GeneratedBy.Native(); HasManyToMany(x => x.Contacts).Access.CamelCaseField(Prefix.Underscore); } } public class PersonMap : JoinedSubClassPart { public PersonMap() { Map(x => x.FirstName).Length(40); Map(x => x.LastName).Length(100); } } public class OrganizationMap : JoinedSubClassPart { public OrganizationMap() { Map(x => x.Name).Length(40); } } That should create 4 tables: Party, Person, Organization and Contact
