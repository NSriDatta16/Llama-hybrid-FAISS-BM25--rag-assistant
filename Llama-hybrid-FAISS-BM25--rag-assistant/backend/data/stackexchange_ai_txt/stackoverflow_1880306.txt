[site]: stackoverflow
[post_id]: 1880306
[parent_id]: 1880243
[tags]: 
In this related question several approaches are discussed: The recursive one, will probably be the easiest to implement, however in terms of scaling for depth and number of items, it is limited as it tends to exponentially take longer and risks overflowing your stack Another approach would be to use a stack which in terms of scaling has a much more linear growth Be sure to check out Eric Lippert's comment at the bottom of the page. Update, to give you an idea of what I mean: public static class Extensions { public static IList TransformTree (this IEnumerable collection, Func > entitySelector, Func > pocoSelector, Func transformer) { var transformedList = new List (); var stack = new Stack >(); var parents = new Dictionary , R>(); stack.Push(collection); while (stack.Count > 0) { IEnumerable items = stack.Pop(); R transformedParent; IList parentChildren = parents.TryGetValue(items, out transformedParent) ? pocoSelector(transformedParent) : transformedList; foreach (var item in items) { R transformedItem = transformer(item); parentChildren.Add(transformedItem); IEnumerable children = entitySelector(item); stack.Push(children); parents.Add(children, transformedItem); } } return transformedList; } } Call it like so: treeItems.TransformTree ( (item) => { return item.Children; }, (pocoItem) => { return pocoItem.Children; }, (item) => { return new TreeItemPoco(item); });
