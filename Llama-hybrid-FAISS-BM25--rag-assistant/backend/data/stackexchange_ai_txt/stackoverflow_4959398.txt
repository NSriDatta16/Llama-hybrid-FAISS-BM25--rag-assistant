[site]: stackoverflow
[post_id]: 4959398
[parent_id]: 4929188
[tags]: 
Looping through an array of bytes is pretty easy (I'm assuming you should stop when you encounter a negative number, but your situation might vary): mov esi, pointerToByteArray loop_start: mov al, [esi] cmp al, 80h jge loop_end ; Do your byte-checking code here inc esi jmp loop_start loop_end: When the loop ends, the total number of elements will be esi-pointerToByteArray . Part two you've already done, you didn't realize it. You use the cmp opcode just like: cmp al, threshold jge not_threshhold ; add to threshold counter not_threshold: Part three is pretty easy too, but will take some knowledge of bit twiddling. You should know that every even number will have the least significant bit clear (the 1's place) so if you remove the top 7 bits you'll either have 1 (for odd numbers) or 0 (for even): mov bl, al and bl, 1 jnz not_even ; add to even counter not_even: The easiest way to do part 4 is test each prime less than or equal to 127 (the maximum value of a positive byte): cmp al, 2 je is_prime cmp al, 3 je is_prime cmp al, 5 je is_prime cmp al, 7 je is_prime ; all the primes up to 127 jmp not_prime is_prime: ; add to prime counter not_prime: Please not that there are much better, more efficient, and elegant ways to check for primeness than that, but it should get the job done. Without knowing more information I can't tell you how to output the information you collect.
