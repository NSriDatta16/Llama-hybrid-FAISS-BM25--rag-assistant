[site]: stackoverflow
[post_id]: 350358
[parent_id]: 350318
[tags]: 
Use the SQL Profiler to work out what indexes to create, it is designed to work out that information for you and suggest improved execution profiles. Do you have foreign keys on k3, k4? Try turning k1, k2 into ints and making them foreign keys, it'll use a lot less storage for one, I'd have thought and I think it should be quicker (though I may be wrong there, I guess SQL Server caches these values). More to the point, it's easier if you ever need to update a value. You just change the name of the foreign key row- you don't then have to update 100 million primary keys, or whatever. One good tip to improve query speeds is to put in a sub-query that cuts down your recordset size to a more managable one. In: SELECT TOP(g) d1 FROM table WITH(NOLOCK) WHERE k1 = a WHERE k2 = b WHERE k3 = c WHERE k4 = d WHERE k5 = e WHERE k6 = f ORDER BY k7 Which, I presume should be SELECT TOP(g) d1 FROM table WITH(NOLOCK) WHERE k1 = a AND k2 = b AND k3 = c AND k4 = d AND k5 = e AND k6 = f ORDER BY k7 There is likely to be some set of data that immediately cuts the recordset down from, say 10 million rows, to 10,000. e.g. SELECT TOP(g) d1 FROM (SELECT * FROM table k1=a AND k2=a WITH(NOLOCK)) WHERE AND k3 = c AND k4 = d AND k5 = e AND k6 = f ORDER BY k7 This assumes that you can cut down the initial set of data massively by one or two of the WHERE arguments- which is almost certain. DBAs probably have more, better solutions!
