[site]: stackoverflow
[post_id]: 5584417
[parent_id]: 5423058
[tags]: 
Yan's statement is inaccurate. Using moveToThread is one way of achieving the proper behavior, but it not the only method. The alternative is to override the run method and create your objects that are to be owned by the thread there. Next you call exec(). The QThread can have signals, but make sure the connections are all Queued. Also all calls into the Thread object should be through slots that are also connected over a Queued connection. Alternatively function calls (which will run in the callers thread of execution) can trigger signals to objects that are owned by the thread (created in the run method), again the connections need to be Queued. One thing to note here, is that the constructor and destructor are running in the main thread of execution. Construction and cleanup need to be performed in run. Here is an example of what your run method should look like: void MythreadDerrivedClass::run() { constructObjectsOnThread(); exec(); destructObjectsOnThread(); m_waitForStopped.wakeAll(); } Here the constructObjectsOnThread will contain the code one would feel belongs in the constructor. The objects will be deallocated in destructObjectsOnThread. The actual class constructor will call the exit() method, causing the exec() to exit. Typically you will use a wait condition to sit in the destructor till the run has returned. MythreadDerivedClass::~MythreadDerivedClass() { QMutexLocker locker(&m_stopMutex); exit(); m_waitForStopped.wait(locker.mutex(), 1000); } So again, the constructor and destructor are running in the parent thread. The objects owned by the thread must be created in the run() method and destroyed before exiting run. The class destructor should only tell the thread to exit and use a QWaitCondition to wait for the thread to actually finish execution. Note when done this way the QThread derived class does have the Q_OBJECT macro in the header, and does contain signals and slots. Another option, if you are open to leveraging a KDE library, is KDE's Thread Weaver . It's a more complete task based multitasking implementation similar QtConcurrentRun in that it leverages a thread pool. It should be familiar for anyone from a Qt background. That said, if you are open to a c++11 method of doing the same thing, I would look at std::async . For one thing, you will no longer have any dependance on Qt, but the api also makes more clear what is going on. With MythreadDerivedClass class inheriting from QThread, the reader gets the impression that MythreadDerivedClass is a thread (since it has an inheritance relationship), and that all its functions run on a thread. However, only the run() method actually runs on a thread. std::async is easier to use correctly, and has fewer gotcha's. All our code is eventually maintained by someone else, and these sorta things matter in the long run. C++11 /w QT Example: class MyThreadManager { Q_OBJECT public: void sndProgress(int percent) void startThread(); void stopThread(); void cancel() { m_cancelled = true; } private: void workToDo(); std::atomic m_cancelled; future m_threadFuture; }; MyThreadedManger::startThread() { m_cancelled = false; std::async(std::launch::async, std::bind(&MyThreadedManger::workToDo, this)); } MyThreadedManger::stopThread() { m_cancelled = true; m_threadfuture.wait_for(std::chrono::seconds(3))); // Wait for 3s } MyThreadedManger::workToDo() { while(!m_cancelled) { ... // doWork QMetaInvoke::invokeMethod(this, SIGNAL(sndProgress(int)), Qt::QueuedConnection, percentDone); // send progress } } Basically, what I've got here isn't that different from how your code would look like with QThread, however, it is more clear that only workToDo() is running on the thread and that MyThreadManager is only managing the thread and not the thread itself. I'm also using MetaInvoke to send a queued signal for sending our progress updates with takes care of the progress reporting requirement. Using MetaInvoke is more explicit and always does the right thing (doesn't matter how you connect signals from your thread managers to other class's slots). You can see that the loop in my thread checks an atomic variable to see when the process is cancelled, so that handles the cancellation requirement.
