[site]: stackoverflow
[post_id]: 4989508
[parent_id]: 4989419
[tags]: 
In response to your questions- Most operating systems use virtual memory to have each program think it owns all of the address space. This means that usually the limit on the size of a program is the amount of physical memory in the system, minus a small amount of memory that's usually reserved for invalid (think NULL) pointers and the kernel. The maximum memory restriction is usually platform-dependent, but on 32-bit systems usually your programs can get nearly 4GB of memory and on a 64-bit system much more than that. Of course, you also have to take into account the size of your disk, which limits how much virtual memory you can have. In theory you could write a program so huge that you couldn't fit it into memory, but unless you're using an embedded device (where this really is a concern) I doubt this would ever happen. In most programming languages, including C and C++, the stack size is not fixed at compile-time and instead starts small and grows as the program runs. However, the way the stack grows usually makes this particularly cheap - to get more space, you just need to bump the stack pointer a bit. If this ever takes you into memory that currently isn't allocated for the program, the OS will usually allocate the memory for you by associating a page with the virtual address where the stack now lives, which is considerably faster than doing a heap allocation. The cost of doing this is usually negligible in the long run, so don't be discouraged from using stack memory. Interestingly, some older programming languages, namely the first incarnation or so of FORTRAN, did not have dynamic stack space, and so recursion wasn't possible. Virtually all modern languages have eliminated these restrictions. You are correct - when more heap space is needed, often the page table is adjusted to grow the heap space. Many memory allocators opt to put the majority of memory into anonymous memory-mapped files to avoid directly using heap space for this purpose, but the principle is essentially the same - the page table is updated to make room for the new memory. If you have two global variables in different files that get linked together, then both of the object files will contain symbolic links saying that they need to reference a variable with that name, and both of the object files will contain definitions saying that they provide a symbol of this name. When you try linking them together, the linker will notice that the same symbol name has been defined in two places and will report an error because it's unsure which one of them it should use as "the" instance of that global variable. To counteract this, at least in C, you can mark global variables static to give them internal linkage. This makes the symbol not globally exported, and so the generated object file can either resolve the references internally or mangle the name so that it doesn't conflict with other symbols from other files. C++ allows for this, along with the anonymous namespace feature, to achieve the same effect. Hope this helps! If anyone spots an errors or ambiguities here, let me know and I'd be glad to correct them.
