[site]: stackoverflow
[post_id]: 1099367
[parent_id]: 1099305
[tags]: 
There are probably two major differences: Ruby has elegant, anonymous closures. Rails uses them to good effect. Here's an example: class WeblogController @posts.to_xml } format.rss { render :action => "feed.rxml" } end end end Anonymous closures/lambdas make it easier to emulate new language features that would take blocks. In Python, closures exist, but they must be named in order to be used. So instead of being able to use closures to emulate new language features, you're forced to be explicit about the fact that you're using a closure. Ruby has cleaner, easier to use metaprogramming. This is used extensively in Rails, primarily because of how easy it is to use. To be specific, in Ruby, you can execute arbitrary code in the context of the class. The following snippets are equivalent: class Foo def self.make_hello_method class_eval do def hello puts "HELLO" end end end end class Bar In both cases, you can then do: Bar.new.hello which will print "HELLO". The class_eval method also takes a String, so it's possible to create methods on the fly, as a class is being created, that have differing semantics based on the parameters that are passed in. It is, in fact, possible to do this sort of metaprogramming in Python (and other languages, too), but Ruby has a leg up because metaprogramming isn't a special style of programming. It flows from the fact that in Ruby, everything is an object and all lines of code are directly executed. As a result, Class es are themselves objects, class bodies have a self pointing at the Class, and you can call methods on the class as you are creating one. This is to large degree responsible for the degree of declarativeness possible in Rails, and the ease by which we are able to implement new declarative features that look like keywords or new block language features.
