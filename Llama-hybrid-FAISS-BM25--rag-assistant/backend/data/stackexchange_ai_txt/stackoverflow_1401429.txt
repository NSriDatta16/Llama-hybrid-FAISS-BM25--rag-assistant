[site]: stackoverflow
[post_id]: 1401429
[parent_id]: 1401261
[tags]: 
Tentatively... Sorry I haven't time to test that the following works... EDIT (finishing after a long day at work...) Yes! That was about right. t'was only missing a * for the template match string, which should be "/*" not just "/" This tested ok with an XML file made by copying that from the OP's question (with necessary edits since the sample XML of the question is fragmentary). Attention, however! Using the *[local-name()='xyz'] trick to ignore namespaces should be kept for quick tests, read after the code snippet for a preferable way of handling these XML Namespaces. XPath and Namespaces The XPath data model treats an XML document as a tree of nodes, such as element, attribute, and text nodes, where the name of each node is a combination of its local name and its namespace name. Interestingly XPath deals with the default namespace in a way that is inconsistent, and that is why one doesn't notice all this xmlns issue until elements targeted by the XSL belong to fully qualified named elements in the input XML.... see this link for more details. When faced with XML input that has xmlns-specified elements, an XSL script writer must either ensure to fully qualify its target nodes' names (preferred approach) or use the local-name() trick shown above to instruct XPath to ignore the namespaces. To use xmlns-prefixed names, a short prefix can be defined as usually and it can then be used by the XSL logic, as follows. (actual xmlns may be wrong, as the sample xml file is incomplete)
