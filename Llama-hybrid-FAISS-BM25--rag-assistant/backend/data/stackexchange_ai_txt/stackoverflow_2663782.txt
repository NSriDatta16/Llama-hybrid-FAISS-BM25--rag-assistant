[site]: stackoverflow
[post_id]: 2663782
[parent_id]: 2663710
[tags]: 
While there's no such thing as a "fast order by rand()", there is a workaround for your specific task. For getting any single random row , you can do like this german blogger does: http://web.archive.org/web/20200211210404/http://www.roberthartung.de/mysql-order-by-rand-a-case-study-of-alternatives/ (I couldn't see a hotlink url. If anyone sees one, feel free to edit the link.) The text is in german, but the SQL code is a bit down the page and in big white boxes, so it's not hard to see. Basically what he does is make a procedure that does the job of getting a valid row. That generates a random number between 0 and max_id, try fetching a row, and if it doesn't exist, keep going until you hit one that does. He allows for fetching x number of random rows by storing them in a temp table, so you can probably rewrite the procedure to be a bit faster fetching only one row. The downside of this is that if you delete A LOT of rows, and there are huge gaps, the chances are big that it will miss tons of times, making it ineffective. Update: Different execution times SELECT * FROM table ORDER BY RAND() LIMIT 1; / 30-40 seconds / SELECT id FROM table ORDER BY RAND() LIMIT 1; / 0.25 seconds / SELECT id, username FROM table ORDER BY RAND() LIMIT 1; / 90 seconds / I was sort of expecting to see approximately the same time for all three queries since I am always sorting on a single column. But for some reason this didn't happen. Please let me know if you any ideas about this. It may have to do with indexing. id is indexed and quick to access, whereas adding username to the result, means it needs to read that from each row and put it in the memory table. With the * it also has to read everything into memory, but it doesn't need to jump around the data file, meaning there's no time lost seeking. This makes a difference only if there are variable length columns (varchar/text), which means it has to check the length, then skip that length, as opposed to just skipping a set length (or 0) between each row.
