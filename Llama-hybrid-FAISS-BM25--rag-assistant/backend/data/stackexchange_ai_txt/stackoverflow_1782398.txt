[site]: stackoverflow
[post_id]: 1782398
[parent_id]: 1782325
[tags]: 
In general, what I use to do is: Data layer: For data access, I create an Interface, for each object. Each interface lists all the public data access methods for the object in question. To hold the data, I create container types, for each object as well, which can be structs or simple classes only with data. I also rely on language data set, like lists, to hold my data, so I not linked to a particular database type. After that, I create a class that implements the data interfaces, this class has all SQL and access the database, so in case of change in the data storage technology, this is the only class that will be changed. Business layer: Does all the logic with data, how to validate, wich methods from the data interfaces should be called and in which order. This class receives and "send" data to the data storage or GUI, using containers (lists for example) where the data types are my containers mentioned above. GUI: Calls business logic methods and show / format data presentation. There's no logic here other than call the right methods of the business logic. Small code example of a container (C#) //Interface for Department class data access. DataStorage assembly namespace DataStorage { public interface IDepartmentDS { void Open(); //Open data conection void Close(); //Close data conection List List(); //Gets all departments (from data base) } } //This class holds all data regarded a department. There's no logic here. Repositories assembly namespace Repositories { public class Department { [Browsable(false)] public Department() { } [Browsable(false)] public Department(String Symbol, String Name) { this.Symbol = Symbol; this.DeptName = Name; } public Department(Department department) { this.Symbol = department.Symbol; this.DeptName = department.DeptName; } [Browsable(false)] public String Symbol { get; set; } public String DeptName { get; set; } } } //This class implements the data manipulation itself, accessing the real database. //However the data exchange outside this class is done via repositories classes and //Generics - Lists mainly public class DataStorage : IDepartmentDS { //Here I use to put generic functions to connect with the database, format stored //procedure parameters list etc. //Implementation of the List method declare in the Department Interface List IDepartmentDS.List() { String query = String.Format("SELECT * FROM {0}", DepartmentTable); int rows = 0; DataSet ds = ExecSqlCommand(query, out rows); //this method is private to this class if (ds == null) return null; List list = new List (); foreach (DataRow row in ds.Tables[0].Rows) { list.Add(new Repositories.Department((String)row[DepFN_Symbol], (String)row[DepFN_DepName])); //DepFN_Symbol and the others are just const variables representing the column index } return list; } } public class DepartmentLogic { public DepartmentLogic() { ..... } public List GetAllDepartments() { //Here I create an Instance of the DataStorage but using the Department interface //so I restrict the access to Department data methods only. It could be a good //idea here to use the factory pattern. IDepartmentDS department = (IDepartmentDS) new DataStorage(); department.Open(); List departments = department.List(); department.Close(); return departments; } } This Business logic example is, indeed, very simple, just shows how to retrieve data from Storage layer, but as long as you have access to data, you can manipulate it in the way you want. Just a comment here: maybe this solution should be re-thinked if implemented in a very busy server with thousands of requisitions because it can use lots of memory. For the business logic and also UI point of view, all data are communicated between modules using general purpose containers like Lists. The link point between all those modules are the containers classes so all the classes are more less well decoupled. UI makes requisitions to the Business logic classes, so it acts like a service provider. Doing in that way, changing the UI will not affect the classes below to it. The Business logic requests and send data to the Data storage classes using general purpose data, so changing the data base / storage technology should not affect it. That's the way I use to do and I'm trying to improve it ;)
