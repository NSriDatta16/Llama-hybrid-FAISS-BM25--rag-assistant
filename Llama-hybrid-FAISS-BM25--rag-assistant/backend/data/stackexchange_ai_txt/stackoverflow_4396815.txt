[site]: stackoverflow
[post_id]: 4396815
[parent_id]: 4395515
[tags]: 
There is really only one practical way to do this. Adding a static image control in the resource editor is a pain as the image needs to be resized to cover the entire dialog, making the dialog all but impossible to edit as all clicks will be on the image control. You can defer creation of the image control to WM_INITDIALOG, but the second mark against using a control is that window controls do not paint elegantly when overlapped. So, you need to do this manually, load the bitmap in WM_INITDIALOG, store the HBITMAP, and paint it on your WM_ERASEBKGND messages. If you additionally convert the HBITMAP to an HBRUSH, you can handle the WM_CTLCOLORSTATIC (and other WM_CTLCOLORxxx) messages and return the HBRUSH from the messages, this will paint the bitmap under any non-rectangular controls so, as per your "after" screenshot, the after text would be black text on a bitmap backdrop. Your final problem is, if the dialog is resizable it will flicker. There are some ways to try and fix this, none are 100% successful: Add the WS_EX_COMPOSITED style to your dialog. Added in Windows 2000, this style caused dialogs(any window actually) to render all the child windows to a backbuffer in one pass, and then render that onto the screen eliminating flicker. The Desktop Window Manager that implements Vista's Aero Glass effect however doesn't support it, so as of Windows 6.0 this feature was broken. Add the WS_CLIPCHILDREN style to the dialog box. Using this style makes it impossible to use controls like tabs, or group boxes, as they rely on unclipped painting rects to composite with other controls.
