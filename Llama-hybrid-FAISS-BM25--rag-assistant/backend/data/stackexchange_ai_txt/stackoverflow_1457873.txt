[site]: stackoverflow
[post_id]: 1457873
[parent_id]: 1457842
[tags]: 
This is bad, because the operator= can't rely on a set-up object anymore. You should do it the other way around, and can use the copy-swap idiom. In the case where you just have to copy over all elements, you can use the implicitly generated assignment operator. In other cases, you will have to do something in addition, mostly freeing and copying memory. This is where the copy-swap idiom is good for. Not only is it elegant, but it also provide so an assignment doesn't throw exceptions if it only swaps primitives. Let's a class pointing to a buffer that you need to copy: Fixture::Fixture():m_data(), m_size() { } Fixture::Fixture(const Fixture& f) { m_data = new item[f.size()]; m_size = f.size(); std::copy(f.data(), f.data() + f.size(), m_data); } Fixture::~Fixture() { delete[] m_data; } // note: the parameter is already the copy we would // need to create anyway. Fixture& Fixture::operator=(Fixture f) { this->swap(f); return *this; } // efficient swap - exchanging pointers. void Fixture::swap(Fixture &f) { using std::swap; swap(m_data, f.m_data); swap(m_size, f.m_size); } // keep this in Fixture's namespace. Code doing swap(a, b) // on two Fixtures will end up calling it. void swap(Fixture &a, Fixture &b) { a.swap(b); } That's how i write the assignment operator usually. Read Want speed? Pass by value about the unusual assignment operator signature (pass by value).
