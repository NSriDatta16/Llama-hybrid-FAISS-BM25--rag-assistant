[site]: stackoverflow
[post_id]: 4914912
[parent_id]: 
[tags]: 
MonoTouch -- SetNeedsDisplay doesn't refresh my custom UIView

Simple concept: I have a custom UIView which draws a path (series of lines). These lines are defined by the user via touches. After a touch, I want the Draw method to redraw the updated path/lines. Code: Here is my custom UIView called "Renderer": public partial class Renderer : MonoTouch.UIKit.UIView { enum eClickMode { BeginPoint, ControlPoint, EndPoint } eClickMode _ClickMode = eClickMode.BeginPoint; CGPath _Path = new CGPath(); PointF _ControlPoint, _EndPoint; UIImage _ImageRough; UIColor _Rough; public Renderer (IntPtr ptr) { _ImageRough = new UIImage("/Users/general/Desktop/deeprough.jpg"); _Rough = UIColor.FromPatternImage(_ImageRough); UIColor.Black.SetStroke(); // Set initial path to make sure something gets drawn _Path = new CGPath(); _Path.MoveToPoint(100, 100); _Path.AddQuadCurveToPoint(200, 200, 100, 300); } public override void Draw (RectangleF rect) { base.Draw (rect); CGContext gfx = UIGraphics.GetCurrentContext(); _Rough.SetFill(); gfx.SetLineWidth(0); gfx.AddPath(_Path); gfx.DrawPath(CGPathDrawingMode.FillStroke); } public override void TouchesEnded (NSSet touches, UIEvent evt) { base.TouchesEnded (touches, evt); UITouch touch = touches.ToArray ()[0]; PointF pt = touch.LocationInView(this); switch (_ClickMode) { case Renderer.eClickMode.BeginPoint: _Path.MoveToPoint(pt); _ClickMode = Renderer.eClickMode.ControlPoint; break; case eClickMode.ControlPoint: _ControlPoint = pt; _ClickMode = Renderer.eClickMode.EndPoint; break; case eClickMode.EndPoint: _EndPoint = pt; _Path.AddQuadCurveToPoint(_ControlPoint.X, _ControlPoint.Y, _EndPoint.X, _EndPoint.Y); _Path.MoveToPoint(_EndPoint); this.SetNeedsDisplay(); break; } } } Here is my MainWindow.Designer code: [MonoTouch.Foundation.Register("AppDelegate")] public partial class AppDelegate { private MonoTouch.UIKit.UIWindow __mt_window; private Renderer __mt_renderer; #pragma warning disable 0169 [MonoTouch.Foundation.Connect("window")] private MonoTouch.UIKit.UIWindow window { get { this.__mt_window = ((MonoTouch.UIKit.UIWindow)(this.GetNativeField("window"))); return this.__mt_window; } set { this.__mt_window = value; this.SetNativeField("window", value); } } [MonoTouch.Foundation.Connect("renderer")] private Renderer renderer { get { this.__mt_renderer = ((Renderer)(this.GetNativeField("renderer"))); return this.__mt_renderer; } set { this.__mt_renderer = value; this.SetNativeField("renderer", value); } } } // Base type probably should be MonoTouch.UIKit.UIView or subclass [MonoTouch.Foundation.Register("Renderer")] public partial class Renderer { } I know for sure that in the TouchesEnded method, this.SetNeedsDisplay() is getting hit. But the Draw method only gets called initially. I've seen other threads indicating a similar problem in Objective-C, but the solution seems to always be about threading. Well, I'm not threading (at least I'm not trying to anyway). This seems like a simple concept (and it is in .Net). Any help is GREATLY appreciated.
