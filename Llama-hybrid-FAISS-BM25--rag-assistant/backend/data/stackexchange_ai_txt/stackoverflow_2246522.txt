[site]: stackoverflow
[post_id]: 2246522
[parent_id]: 2238197
[tags]: 
Since I was able to use UncleBen's answers to create a comprehensive solution (as good as I think it gets at this point in C++), I wanted to share it, below: Feel free to use it, but I make no guarantees whatsoever about its worthiness for any use whatsoever, etc., etc., be an adult and take responsibility for your own damn actions, blah, blah: ////////////////////////////////////////////////////////////// // Raw Memory Initialization Helpers // // Provides: // Zero(x) where x is any type, and is completely overwritten by null bytes (0). // Initialized x; where T is any legacy type, and it is completely null'd before use. // // History: // // User UncleBen of stackoverflow.com and I tried to come up with // an improved, integrated approach to Initialized<> // http://stackoverflow.com/questions/2238197/how-do-i-specialize-a-templated-class-for-data-type-classification // // In the end, there are simply some limitations to using this // approach, which makes it... limited. // // For the time being, I have integrated them as best I can // However, it is best to simply use this feature // for legacy structs and not much else. // // So I recommend stacked based usage for legacy structs in particular: // Initialized bm; // // And perhaps some very limited use legacy arrays: // Initialized filename; // // But I would discourage their use for member variables: // Initialized m_cbLength; // ...as this can defeat template type deduction for such types // (its not a size_t, but an Initialized - different types!) // ////////////////////////////////////////////////////////////// #pragma once // boost #include #include // zero the memory space of a given PODS or native array template void Zero(T & object, int zero_value = 0) { // ensure that we aren't trying to overwrite a non-trivial class BOOST_STATIC_ASSERT((boost::is_POD ::value)); // make zeroing out a raw pointer illegal BOOST_STATIC_ASSERT(!(boost::is_pointer ::value)); ::memset(&object, zero_value, sizeof(object)); } // version for simple arrays template void Zero(T (&object)[N], int zero_value = 0) { // ensure that we aren't trying to overwrite a non-trivial class BOOST_STATIC_ASSERT((boost::is_POD ::value)); ::memset(&object, zero_value, sizeof(object)); } // version for dynamically allocated memory template void Zero(T * object, size_t size, int zero_value = 0) { // ensure that we aren't trying to overwrite a non-trivial class BOOST_STATIC_ASSERT((boost::is_POD ::value)); ::memset(object, zero_value, size); } ////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////////////// // Initialized for non-inheritable types // usage: Initialized i; template ::value> struct Initialized { // ensure that we aren't trying to overwrite a non-trivial class BOOST_STATIC_ASSERT((boost::is_scalar ::value)); // the data T m_value; // default valued construction Initialized() : m_value() { } // implicit valued construction (auto-conversion) template Initialized(const U & rhs) : m_value(rhs) { } // assignment template T & operator = (const U & rhs) { if ((void*)&m_value != (void*)&rhs) m_value = rhs; return *this; } // implicit conversion to the underlying type operator T & () { return m_value; } operator const T & () const { return m_value; } // zero method for this type void _zero() { m_value = T(); } }; ////////////////////////////////////////////////////////////////////////// // Initialized for inheritable types (e.g. structs) // usage: Initialized r; template struct Initialized : public T { // ensure that we aren't trying to overwrite a non-trivial class BOOST_STATIC_ASSERT((boost::is_POD ::value)); // default ctor Initialized() : T() { } // auto-conversion ctor template Initialized(const OtherType & value) : T(value) { } // auto-conversion assignment template Initialized & operator = (const OtherType & value) { *this = value; } // zero method for this type void _zero() { Zero((T&)(*this)); } }; ////////////////////////////////////////////////////////////////////////// // Initialized arrays of simple types // usage: Initialized szFilename; template struct Initialized { // ensure that we aren't trying to overwrite a non-trivial class BOOST_STATIC_ASSERT((boost::is_POD ::value)); // internal data T m_array[N]; // default ctor //Initialized() : m_array() { } // Generates a warning about new behavior. Its okay, but might as well not produce a warning. Initialized() { Zero(m_array); } // array access operator T * () { return m_array; } operator const T * () const { return m_array; } // NOTE: All of the following techniques leads to ambiguity. // Sadly, allowing the type to convert to ArrayType&, which IMO should // make it fully "the same as it was without this wrapper" instead causes // massive confusion for the compiler (it doesn't understand IA + offset, IA[offset], etc.) // So in the end, the only thing that truly gives the most bang for the buck is T * conversion. // This means that we cannot really use this for very well, but that's a fairly small loss // (there are lots of ways of handling character strings already) // // automatic conversions // operator ArrayType& () { return m_array; } // operator const ArrayType& () const { return m_array; } // // T * operator + (long offset) { return m_array + offset; } // const T * operator + (long offset) const { return m_array + offset; } // // T & operator [] (long offset) { return m_array[offset]; } // const T & operator [] (long offset) const { return m_array[offset]; } // metadata size_t GetCapacity() const { return N; } // zero method for this type void _zero() { Zero(m_array); } }; ////////////////////////////////////////////////////////////////////////// // Initialized for pointers to simple types // usage: Initialized p; // Please use a real smart pointer (such as std::auto_ptr or boost::shared_ptr) // instead of this template whenever possible. This is really a stop-gap for legacy // code, not a comprehensive solution. template struct Initialized { // the pointer T * m_pointer; // default valued construction Initialized() : m_pointer(NULL) { } // valued construction (auto-conversion) template Initialized(const U * rhs) : m_pointer(rhs) { } // assignment template T * & operator = (U * rhs) { if (m_pointer != rhs) m_pointer = rhs; return *this; } template T * & operator = (const U * rhs) { if (m_pointer != rhs) m_pointer = rhs; return *this; } // implicit conversion to underlying type operator T * & () { return m_pointer; } operator const T * & () const { return m_pointer; } // pointer semantics const T * operator -> () const { return m_pointer; } T * operator -> () { return m_pointer; } const T & operator * () const { return *m_pointer; } T & operator * () { return *m_pointer; } // allow null assignment private: class Dummy {}; public: // amazingly, this appears to work. The compiler finds that Initialized p = NULL to match the following definition T * & operator = (Dummy * value) { m_pointer = NULL; ASSERT(value == NULL); return *this; } // zero method for this type void _zero() { m_pointer = NULL; } }; ////////////////////////////////////////////////////////////////////////// // Uninitialized requires that you explicitly initialize it when you delcare it (or in the owner object's ctor) // it has no default ctor - so you *must* supply an initial value. template struct Uninitialized { // valued initialization Uninitialized(T initial_value) : m_value(initial_value) { } // valued initialization from convertible types template Uninitialized(const U & initial_value) : m_value(initial_value) { } // assignment template T & operator = (const U & rhs) { if (&m_value != &rhs) m_value = rhs; return *this; } // implicit conversion to underlying type operator T & () { return m_value; } operator const T & () const { return m_value; } // the data T m_value; }; ////////////////////////////////////////////////////////////////////////// // Zero() overload for Initialized<> ////////////////////////////////////////////////////////////////////////// // version for Initialized template void Zero(Initialized & object) { object._zero(); }
