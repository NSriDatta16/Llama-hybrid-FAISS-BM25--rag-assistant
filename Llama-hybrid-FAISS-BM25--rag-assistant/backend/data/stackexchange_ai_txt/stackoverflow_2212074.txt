[site]: stackoverflow
[post_id]: 2212074
[parent_id]: 2212049
[tags]: 
Assuming that you are in fact working with bitmaps, you'll likely find it easier to just let the library do this for you. The System.Drawing.Graphics class has a CompositingMode property that can be set to either SourceCopy (the default - overwrites the background colour) or SourceOver (blends with the background color). See MSDN: How to Use Compositing Mode to Control Alpha Blending for more detail. If you just want the raw math, alpha blending is pretty simple. For an alpha value a between 0.0 and 1.0, the result should be: (aOld * oldValue) + ((1 - aOld) * aNew * newValue) Where oldValue is the previous value before overlay, newValue is what you want to overlay with, and aOld and aNew are the old and new alpha values respectively. You obviously need to do this calculation for the R, G, and B values separately. See also: Alpha Compositing (wiki link) for a more thorough explanation. Update: I think it should be easy to figure out how to adapt this to the code in the OP, but I guess not everybody's a math person. I'm going to assume that the byte[] is a repeating sequence of A, R, G, B values (so Length would be a multiple of 4). If that's not the case, then you'll have to adapt this code to whatever storage format you're using. bytes[] result = new bytes[first.Length]; for(i = 0; i
