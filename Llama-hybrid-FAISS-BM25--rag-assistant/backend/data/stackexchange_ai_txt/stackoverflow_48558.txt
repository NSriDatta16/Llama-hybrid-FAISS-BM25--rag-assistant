[site]: stackoverflow
[post_id]: 48558
[parent_id]: 48475
[tags]: 
What I like to do is have a number of tables that represent the raw data, so in this case you'd have Items (ID pk, Name, ) Tags (ID pk, Name) TagItems (TagID fk, ItemID fk) This works fast for the write times, and keeps everything normalized, but you may also note that for each tag, you'll need to join tables twice for every further tag you want to AND, so it's got slow read. A solution to improve read is to create a caching table on command by setting up a stored procedure that essentially creates new table that represents the data in a flattened format... CachedTagItems(ID, Name, , tag1, tag2, ... tagN) Then you can consider how often the Tagged Item table needs to be kept up to date, if it's on every insert, then call the stored procedure in a cursor insert event. If it's an hourly task, then set up an hourly job to run it. Now to get really clever in data retrieval, you'll want to create a stored procedure to get data from the tags. Rather than using nested queries in a massive case statement, you want to pass in a single parameter containing a list of tags you want to select from the database, and return a record set of Items. This would be best in binary format, using bitwise operators. In binary format, it is easy to explain. Let's say there are four tags to be assigned to an item, in binary we could represent that 0000 If all four tags are assigned to an object, the object would look like this... 1111 If just the first two... 1100 Then it's just a case of finding the binary values with the 1s and zeros in the column you want. Using SQL Server's Bitwise operators, you can check that there is a 1 in the first of the columns using very simple queries. Check this link to find out more .
