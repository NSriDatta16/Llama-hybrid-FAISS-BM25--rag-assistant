[site]: stackoverflow
[post_id]: 2705286
[parent_id]: 2704996
[tags]: 
The main difference with a DVCS (Distributed Version Control) from a VCS, is that it is made (by the very nature of its distributed work) to do one thing, and one thing well: merge . So you the tasks you mention can be viewed from that angle. Branches will still be made, but not all of them will be visible by other developers. Lots of them won't actually leave your local repository. Being a DVCS has two main impact on merging: you commit as many times as you want. Those commits are not immediately visible to others (i.e. "they won't have to merge them immediately after the next update of their workspace") ~ the publication process is a passive one: your pushes can be ignored by other repos. ~ the "consuming" part is an active one: you can examine what has been pushed to you before merging that to your branch, and decide what you want to merge and from whom (and not just because you are all working on a "same branch"). it works well for any merge workflow (partial, criss-crossing, recursive, ...) The DAG (Directed Acyclic Graph) often used to record the history by those DVCS (at least Git and Mercurial) makes it easy to find what has already been merged and find the common ancestor. That is one important difference between SVN and its DVCS counterparts , but there are others as well . Now: Implement a feature As I detail in my CVCS (Central VCS) answer , the difficulty behind a "feature" branch is that many sub-features will end-up intertwined. This is where DVCS will shine as they will allow you to reorganize their local (as in "not pushed yet") history (changesets for Mercurial, SHA1 commits ofr Git), in order to facilitate partial merges, or sub-feature branches creations. Fixing bugs You can almost create a branch per bug-fix if you want. The idea is to make sure a bug-fix is identified by a simple linear set of commmits merged back in the development branch (or the maintenance branch if this is released). I prefer making sure to first rebase the bug-fix branch on top of the development branch (to make sure my fixes are still compliant with any work which may have been done in parallel on said main branch), before merging that dev branch with the bug-fix one (fast-forward merge: the main branch now reference all the fixes) Code Review The blame or annotation feature is still there to help assign the tasks during a code review, but this time, all the developers are not necessarily on one site (since it is a *Distributed *VCS), and not with the same identification scheme (not using the same LDAP for instance). A DVCS way to organize code review is to push new changes to a special code review repo, which will: reject those commits if they don't answer to the required quality criteria accept those (merge them with the code-review repo), and push them to a new repo (used for various testing for instance) Refactoring code (post code-review) They are done on the developer's local repo, in a branch (since it is so easy to merge it back) Incorporate patches Same process than last section. Releasing the newer version of your app (desktop, web, mobile, would you treat them differently?) The actual release process is simply initiated by a special identified (tag) version of your software. (the rest of the "release management process", that is the deployment and configuration part is detailed in the CVCS answer ) The question is, with a DVCS: "from which repository will that official version of your software come from?" You need to establish a "central" or rather "official" repository which will play the role of: repo for versions to be released repo for new repositories wanted to contribute So it can serve both for release purposes, but also for new development purposes.
