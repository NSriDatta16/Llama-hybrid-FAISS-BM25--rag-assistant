[site]: stackoverflow
[post_id]: 408424
[parent_id]: 408415
[tags]: 
This is called explicit interface implementation . In your example since you define the Dispose() method as "void IDisposable.Dispose()" you are explicitly implementing the IDisposable interface as well. This is normally done to avoid collisions. If Microsoft ever wanted to add another Dispose() method that did something else to RegistryKey they wouldn't be able to unless they used explicit implementation of that interface. This is done often with the generic IEnumerable interface. It requires you to also implement the non-generic interface IEnumerable. The only member in these two interfaces is GetEnumerator, with the generic one being more useful, so its usually implemented like this: public clas SomeClass : IEnumerable { public IEnumerator GetEnumerator () { ... } IEnumerator IEnumerable.GetEnumerator () { return GetEnumerator (); } } This way when you call an object of SomeClass's GetEnumator method, it calls the generic version, since the other one was implemented explicitly, allowing us to get the strong-typing generics allow. See pages 166-169 of Programming C# by Jesse Liberty (I've got the fourth edition).
