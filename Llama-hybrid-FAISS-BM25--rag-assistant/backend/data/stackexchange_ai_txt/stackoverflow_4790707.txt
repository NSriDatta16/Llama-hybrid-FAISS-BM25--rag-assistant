[site]: stackoverflow
[post_id]: 4790707
[parent_id]: 4789792
[tags]: 
Django has a built-in feature called Generic Foreign Keys that allow you to tie a single table to multiple models in this fashion. This is how you would create your models: from django.db import models from django.contrib.contenttypes.models import ContentType from django.contrib.contenttypes import generic class News(models.Model): title = models.CharField() ... class Film(models.Model): title = models.Charfield() ... class Calendar(models.Model): title = models.Charfield() ... class MetaInfo(models.Model): content_type = models.ForeignKey(ContentType) object_id = models.PositiveIntegerField() content_object = generic.GenericForeignKey() If you wish, you can be more explicit about the relationship between a model and MetaInfo by using GenericRelation . For example: class Film(models.Model): title = models.CharField() metainfo = generic.GenericRelation('MetaInfo') ... This allows you to access the related MetaInfo records directly from the Film model, as in f = Film.objects.get(pk=1) for mi in f.metainfo.all(): #mi is a matching MetaInfo record for Film record with pk=1 Just to elaborate a bit: In the MetaInfo model, content_type serves as the equivalent of your tbl column (although it points to a Django construct called a ContentType; Django constructs one for each model in the app/set of apps) and object_id corresponds to your fi key. You actually generally don't pay much attention to those fields. Instead, you get and set the content object, which is the corresponding record. For example, instead of storing or retrieving tlb='Film', fi=1, you'd get or set content_object which corresponds directly to the Film record matching pk=1. In essence, contenttype__name='Film', object_id=1 while content_object=Film.object.get(pk=1) This is all assuming that this database is for Django use only. If it's an existing database that you're trying to use within Django, there isn't a straightforward way to handle this that I'm aware of.
