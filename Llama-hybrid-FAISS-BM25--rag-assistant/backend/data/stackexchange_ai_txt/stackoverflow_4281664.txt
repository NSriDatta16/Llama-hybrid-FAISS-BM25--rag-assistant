[site]: stackoverflow
[post_id]: 4281664
[parent_id]: 4275504
[tags]: 
Per the C standard ( n1256 draft): 6.7.3 Type qualifiers ... 3 The properties associated with qualified types are meaningful only for expressions that are lvalues. 114) ... 5 If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined. If an attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type, the behavior is undefined. 115) ... 114) The implementation may place a const object that is not volatile in a read-only region of storage. Moreover, the implementation need not allocate storage for such an object if its address is never used. 115) This applies to those objects that behave as if they were defined with qualified types, even if they are never actually defined as objects in the program (such as an object at a memory-mapped input/output address). In short, a const -qualified object may be stored in a different area from non- const -qualified objects, but not necessarily. The const qualifier is an instruction to the compiler to reject code that attempts to modify that object directly; attempts to modify the object indirectly (as you do in the second code snippet) results in undefined behavior, meaning any result is possible.
