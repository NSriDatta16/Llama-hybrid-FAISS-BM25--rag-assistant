[site]: stackoverflow
[post_id]: 607696
[parent_id]: 570297
[tags]: 
Pass 2, about 30% better (on my machine) than my previous. The main saving came from unrolling the inner loop to amortize the overhead. Also included (commented out) is an aborted attempt to save time by exiting early (& set the pixel black) when you are stuck in the central cardioid. It works, but it's slower no matter how I jiggered it. I've got to run, but I'll leave a parting suggestion. There may be some optimization possible by run-length encoding the results (so instead of saving a bunch of bit-twiddled chars you'd save a list (number of white dots, number of black dots, number of white dots, etc.)). This would: Reduce the storage/GC overhead Allow some optimizations on the output generation (when the numbers were >> 8) Permit some orbit detection. No idea if it could be coded tight enough to fly, but that is where I would try next if I had more time. -- The Computer Language Shootout -- http://shootout.alioth.debian.org/ -- contributed by Mike Pall -- with optimizations by Markus J. Q. (MarkusQ) Roberts local width = tonumber(arg and arg[1]) or 100 local height, wscale = width, 2/width local m, limit2 = 50, 4.0 local write, char = io.write, string.char local h2 = math.floor(height/2) local hm = height - h2*2 local top_half = {} for y=0,h2+hm do local Ci = 2*y / height - 1 local line = {""} for xb=0,width-1,8 do local bits = 0 local xbb = xb+7 for x=xb,xbb limit2 then bits = bits + 1 break end -- if i == 1 then -- local ar,ai = 1-4*Zr,-4*Zi -- local a_r = math.sqrt(ar*ar+ai*ai) -- local k = math.sqrt(2)/2 -- local br,bi2 = math.sqrt(a_r+ar)*k,(a_r-ar)/2 -- if (br+1)*(br+1) + bi2
