[site]: stackoverflow
[post_id]: 5265647
[parent_id]: 3612337
[tags]: 
Tom, I believe that your question makes much sense in a particular context. Say that you want to store visitors of multiple types in a vector, but you can't because they are all of different types. You have a few choices: use variant again to store visitors, use boost.any, or use virtual functions. I think that virtual functions are an elegant solution here, but certainly not the only one. Here is how it goes. First, let's use some variant; bool , int , and float will do. typedef boost::variant variant_type; Then comes the base class, more or less as you had it. template struct Visitor : public boost::static_visitor<> { void operator()(T0 value) { Process(value); } void operator()(T1 value) { Process(value); } void operator()(T2 value) { Process(value); } virtual void Process(T0 val){ std::cout Next, we have two specific variants. template struct Visitor1 : public Visitor { void Process(T0 val){ std::cout template struct Visitor2 : public Visitor { void Process(T1 val){ std::cout Finally, we can make a single vector of different variants: int main() { variant_type data(1.0f); std::vector*> v; v.push_back(new Visitor1()); v.push_back(new Visitor2()); apply_visitor(*v[0],data); apply_visitor(*v[1],data); data = true; apply_visitor(*v[0],data); apply_visitor(*v[1],data); return 0; } And here is the output: I am Visitor1 at T2 I am Visitor2 at T2 I am Visitor1 at T0 I am Visitor at T0 If for some reason I needed to have different variants in one container, I would surely consider this solution. I would also think how much worse/better would it be to actually stick the visitors into another variant. The nice thing about using inheritance is that it is extensible post factum: you can always inherit from a class, but once a variant is set, you can't change it without actually touching the existing code.
