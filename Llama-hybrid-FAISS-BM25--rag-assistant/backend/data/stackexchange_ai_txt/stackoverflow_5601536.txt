[site]: stackoverflow
[post_id]: 5601536
[parent_id]: 5594970
[tags]: 
Cribbed from the MongoDB groups . It is somewhat specific to MongoDB, however, it is pretty generic. Most of these history implementations break down to two common strategies. Strategy 1: embed history In theory, you can embed the history of a document inside of the document itself. This can even be done atomically. > db.docs.save( { _id : 1, text : "Original Text" } ) > var doc = db.docs.findOne() > db.docs.update( {_id: doc._id}, { $set : { text : 'New Text' }, $push : { hist : doc.text } } ) > db.docs.find() { "_id" : 1, "hist" : [ "Original Text" ], "text" : "New Text" } Strategy 2: write history to separate collection > db.docs.save( { _id : 1, text : "Original Text" } ) > var doc = db.docs.findOne() > db.docs_hist.insert ( { orig_id : doc._id, ts : Math.round((new Date()).getTime() / 1000), data : doc } ) > db.docs.update( {_id:doc._id}, { $set : { text : 'New Text' } } ) Here you'll see that I do two writes. One to the master collection and one to the history collection. To get fast history lookup, just grab the original ID: > db.docs_hist.ensureIndex( { orig_id : 1, ts : 1 }) > db.docs_hist.find( { orig_id : 1 } ).sort( { ts : -1 } ) Both strategies can be enhanced by only displaying diffs You could hybridize by adding a link from history collection to original collection Whats the best way of saving a document with revisions in a key value store? It's hard to say there is a "best way". There are obviously some trade-offs being made here. Embedding: atomic changes on a single doc can result in large documents, may break the reasonable size limits probably have to enhance code to avoid returning full hist when not necessary Separate collection: easier to write queries not atomic, needs two operations ( do you have transactions? ) more storage space ( extra indexes on original docs )
