[site]: stackoverflow
[post_id]: 2048127
[parent_id]: 69711
[tags]: 
My experience is that sugaring every term intuitively seems unattractive, but is worth pursuing. An interest in persistent storage has led me by a circuitous route to consider the problems of mixing expression and atomic values. To support this, I decided to separate them completely in the type system; thus Int, Char etc. are the type constructors only for integer and character values. Expression types are formed with the polymorphic type constructor Exp; e.g. Exp Int refers to a value which reduces in one step to Int. The relevance of this to your question arises when we consider evaluation. At an underlying level, there are primitives which require atomic values: COND, addInt etc. Some people refer to this as forcing an expression, I prefer to see it simply as a cast between values of different types. The challenge is to see if this can be done without requiring explicit reduction directives. One solution is exactly as you suggest: i.e. to treat coercion as a form of overloading. Say we have an input script: foo x Then, after sugaring, this becomes: (coerce foo) (coerce x) Where, informally: coerce :: a -> b coerce x = REDUCE (cast x) if a and b are incompatible x otherwise Thus coerce is either identity or an application of cast where b is the return type for a given context. cast can now be treated as a type class method, e.g. class Cast a, b where {cast :: a -> b }; -- ¬:: is an operator, literally meaning: don’t cast --(!) is the reduction operator. Perform one stage of reduction. -- Reduce on demand instance Cast Exp c, c where { inline cast = ¬::(!)(\x::(Exp c) -> ¬::(!)x) }; The ¬:: annotations are used to suppress the coerce syntactic sugaring. The intention is that other instances of Cast can be introduced to extend the range of conversions, although I haven't explored this. As you say, overlapping instances seem necessary.
