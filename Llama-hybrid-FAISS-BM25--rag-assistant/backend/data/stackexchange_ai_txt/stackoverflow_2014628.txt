[site]: stackoverflow
[post_id]: 2014628
[parent_id]: 
[tags]: 
Use heap storage instead of stack (K&R 5.7)

I have a program that sorts input lines lexicographically, and I've come to this exercise in K&R: Rewrite readlines to store lines in an array supplied by main, rather than calling alloc to maintain storage. How much faster is the program? Here is the original program, using malloc to maintain storage for lines. #include #include #include #define MAXLINES 5000 char *lineptr[MAXLINES]; int readlines(char *lineptr[], int nlines); void writelines(char *lineptr[], int nlines); void qsort(char *lineptr[], int left, int right); char *alloc(int n); #define MAXSIZE 10000 int main(int argc, char *argv[]) { int nlines; if((nlines = readlines(lineptr, MAXLINES)) >= 0) { qsort(lineptr, 0, nlines-1); writelines(lineptr, nlines); getchar(); return 0; } else { printf("error: input too big to sort\n"); getchar(); return 1; } } #define MAXLEN 1000 int getline(char *, int); int readlines(char *lineptr[], int maxlines) { int len, nlines; char *p; char line[MAXLEN]; nlines = 0; while((len = getline(line, MAXLEN)) > 0) if(nlines >= maxlines || (p = alloc(len)) == NULL) return -1; else { line[len-1] = '\0'; strcpy(p, line); lineptr[nlines++] = p; } return nlines; } void writelines(char *lineptr[], int nlines) { while(nlines-- > 0) printf("%s\n", *lineptr++); } #define MAXALLOC 5000 char allocbuf[MAXALLOC]; char *allocp = allocbuf; char *alloc(int n) { if(allocbuf + MAXALLOC - allocp >= n) { allocp += n; return allocp - n; } else return 0; } int getline(char s[], int lim) { int c, i; for (i = 0; i = right) return; swap(v, left, (left+right)/2); last = left; for(i = left + 1; i I edited it this way: #include #include #include #define MAXLINES 5000 char *lineptr[MAXLINES]; int readlines(char *lineptr[], int nlines, char buf[]); void writelines(char *lineptr[], int nlines); void qsort(char *lineptr[], int left, int right); #define MAXSIZE 10000 int main(int argc, char *argv[]) { int nlines; char buf[MAXSIZE]; if((nlines = readlines(lineptr, MAXLINES, buf)) >= 0) { qsort(lineptr, 0, nlines-1); writelines(lineptr, nlines); getchar(); return 0; } else { printf("error: input too big to sort\n"); getchar(); return 1; } } #define MAXLEN 1000 int getline(char *, int); int readlines(char *lineptr[], int maxlines, char buf[]) { int len, nlines; char *p = buf; char line[MAXLEN]; nlines = 0; while((len = getline(line, MAXLEN)) > 0) if(nlines >= maxlines || MAXSIZE + buf - p 0) printf("%s\n", *lineptr++); } int getline(char s[], int lim) { int c, i; for (i = 0; i = right) return; swap(v, left, (left+right)/2); last = left; for(i = left + 1; i Is this what the author wanted, or did I do it wrong? Also, measuring time diffrence, is it correct to just start the clock at the begining of the main and then stop it after reading lines is over, and compare the time taken? #include #include #include #define MAXLINES 5000 char *lineptr[MAXLINES]; int readlines(char *lineptr[], int nlines); void writelines(char *lineptr[], int nlines); void qsort(char *lineptr[], int left, int right); char *alloc(int n); #define MAXSIZE 10000 int main(int argc, char *argv[]) { int nlines; if((nlines = readlines(lineptr, MAXLINES)) >= 0) { qsort(lineptr, 0, nlines-1); writelines(lineptr, nlines); getchar(); return 0; } else { printf("error: input too big to sort\n"); getchar(); return 1; } } #define MAXLEN 1000 int getline(char *, int); int readlines(char *lineptr[], int maxlines) { int len, nlines; char *p; char line[MAXLEN]; nlines = 0; while((len = getline(line, MAXLEN)) > 0) if(nlines >= maxlines || (p = alloc(len)) == NULL) return -1; else { line[len-1] = '\0'; strcpy(p, line); lineptr[nlines++] = p; } return nlines; } void writelines(char *lineptr[], int nlines) { while(nlines-- > 0) printf("%s\n", *lineptr++); } #define MAXALLOC 5000 char allocbuf[MAXALLOC]; char *allocp = allocbuf; char *alloc(int n) { if(allocbuf + MAXALLOC - allocp >= n) { allocp += n; return allocp - n; } else return 0; } int getline(char s[], int lim) { int c, i; for (i = 0; i = right) return; swap(v, left, (left+right)/2); last = left; for(i = left + 1; i This is the original code.
