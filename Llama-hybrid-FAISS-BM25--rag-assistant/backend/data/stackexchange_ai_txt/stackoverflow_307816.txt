[site]: stackoverflow
[post_id]: 307816
[parent_id]: 307796
[tags]: 
How about: for file in *.php3 do sed 's/\.php3/.php/g' $file > ${file%3} done The for/do/done loop deals with each .php3 file in turn, editing the file and replacing each string .php3 with .php , and copying the file from something.php3 to something.php. Added for amended question: for file in $(find . -type f -name '*.php3' -print) do sed 's/\.php3/.php/g' $file > ${file%3} done The ' -print ' can usually be omitted these days, but historically, a lot of machine time was wasted by people who forgot to add it because there was originally (pre-POSIX) no default action. This fragment is about the simplest modification of the original code to do the extended task, but isn't necessarily the best way to do it any more - it pre-generates the entire list of files before processing any. You could instead use: find . -type f -name '*.php3' -print | while read file do sed 's/\.php3/.php/g' $file > ${file%3} done However, both the amended versions can run into problems if file names or path names can contain blanks or newlines or other such characters. To avoid such issues, you have to work harder - using Perl or (GNU find + xargs) or some other techniques. If you're sane, you avoid such problems. If you've inherited a less than entirely sane setup, then you may have to delve deeper into the arcana of Unix file name handling.
