[site]: stackoverflow
[post_id]: 5283343
[parent_id]: 5281261
[tags]: 
If you think of each pixel as a vertex rather than a face, you can generate a simple triangular mesh. +--+--+ |\ |\ | | \| \| +--+--+ |\ |\ | | \| \| +--+--+ Each vertex has an x and y coordinate corresponding to the x and y of the pixel in the map. The z coordinate is based on the value in the map at that location. Triangles can be generated explicitly or implicitly by their position in the grid. What you need is the normal at each vertex . A vertex normal can be computed by taking an area-weighted average of the surface normals for each of the triangles that meet at that point. If you have a triangle with vertices v0 , v1 , v2 , then you can use a vector cross product (of two vectors that lie on two of the sides of the triangle) to compute a vector in the direction of the normal and scaled proportionally to the area of the triangle. Vector3 contribution = Cross(v1 - v0, v2 - v1); Each of your vertices that aren't on the edge will be shared by six triangles. You can loop through those triangles, summing up the contribution s, and then normalize the vector sum. Note: You have to compute the cross products in a consistent way to make sure the normals are all pointing in the same direction. Always pick two sides in the same order (clockwise or counterclockwise). If you mix some of them up, those contributions will be pointing in the opposite direction. For vertices on the edge, you end up with a shorter loop and a lot of special cases. It's probably easier to create a border around your grid of fake vertices and then compute the normals for the interior ones and discard the fake borders. for each interior vertex V { Vector3 sum(0.0, 0.0, 0.0); for each of the six triangles T that share V { const Vector3 side1 = T.v1 - T.v0; const Vector3 side2 = T.v2 - T.v1; const Vector3 contribution = Cross(side1, side2); sum += contribution; } sum.Normalize(); V.normal = sum; } If you need the normal at a particular point on a triangle (other than one of the vertices), you can interpolate by weighing the normals of the three vertices by the barycentric coordinates of your point. This is how graphics rasterizers treat the normal for shading. It allows a triangle mesh to appear like smooth, curved surface rather than a bunch of adjacent flat triangles. Tip: For your first test, use a perfectly flat grid and make sure all of the computed normals are pointing straight up.
