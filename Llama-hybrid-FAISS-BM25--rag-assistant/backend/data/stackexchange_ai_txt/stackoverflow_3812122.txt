[site]: stackoverflow
[post_id]: 3812122
[parent_id]: 3811298
[tags]: 
Set up your project to use the Windows Low Fragmentation Heap (LFH) using this API at the start of the program. This may fix your problem without more work on custom implementations. Sample code, taken directly from MSDN: #include #include #include #define HEAP_LFH 2 int __cdecl _tmain() { BOOL bResult; HANDLE hHeap; ULONG HeapInformation; // // Note: The HeapSetInformation function is available on Windows 2000 with SP4 // only if hotfix KB 816542 is installed. To run this example on Windows 2000, // use GetProcAddress to get a pointer to the function if available. // // // Enable heap terminate-on-corruption. // A correct application can continue to run even if this call fails, // so it is safe to ignore the return value and call the function as follows: // (void)HeapSetInformation(NULL, HeapEnableTerminationOnCorruption, NULL, 0); // If the application requires heap terminate-on-corruption to be enabled, // check the return value and exit on failure as shown in this example. // bResult = HeapSetInformation(NULL, HeapEnableTerminationOnCorruption, NULL, 0); if (bResult != FALSE) { _tprintf(TEXT("Heap terminate-on-corruption has been enabled.\n")); } else { _tprintf(TEXT("Failed to enable heap terminate-on-corruption with LastError %d.\n"), GetLastError()); return 1; } // // Create a new heap with default parameters. // hHeap = HeapCreate(0, 0, 0); if (hHeap == NULL) { _tprintf(TEXT("Failed to create a new heap with LastError %d.\n"), GetLastError()); return 1; } // // Enable the low-fragmenation heap (LFH). Starting with Windows Vista, // the LFH is enabled by default but this call does not cause an error. // HeapInformation = HEAP_LFH; bResult = HeapSetInformation(hHeap, HeapCompatibilityInformation, &HeapInformation, sizeof(HeapInformation)); if (bResult != FALSE) { _tprintf(TEXT("The low-fragmentation heap has been enabled.\n")); } else { _tprintf(TEXT("Failed to enable the low-fragmentation heap with LastError %d.\n"), GetLastError()); return 1; } return 0; }
