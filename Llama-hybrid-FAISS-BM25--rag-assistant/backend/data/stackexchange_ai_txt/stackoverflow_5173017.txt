[site]: stackoverflow
[post_id]: 5173017
[parent_id]: 5170633
[tags]: 
@RS Conley's answer is giving a very broad into to the subject, and I agree with most. The only thing I think differently is in the bottom line. MVVM is THE architecture for 95% of applications in WPF. Choosing any other architectures is means settling for something that is less than the best you can get. In RS Conley's situation Passive View might be the best way to go, but that is far from being the normal case. As a way to understand how MVVM is better, let's see what's he's losing when he's going the PassiveView approach. Maintainability In Passive View, the ViewModel knows about the IView, which means that SRP (Single Responsibility Principle) is not kept. The Controller in PassiveView interacts directly with both the Model and the View, and therefor is doing two completely different things! . Under MVVM, the ViewModel, which is the heart of the application only have one concern, which is to contain the state&logic of the application. The Maintainability of such code is really superior to PassiveView, MVP or MVC treamendously. It is true that PassiveView is better when it comes to Automated Tests Coverege, but IMHO, good maintainability of code is far more important. Testability helps u make sure you don't break your code, while Maintainability helps you not to build problematic code to begin with. When it comes to Maintainability, MVVM and PresentationModel are an evolotion of previous UI architectures, and that's because the SRP principle is kept very strictly. Write enough code in MVVM and you'll see what I mean. Blendability Another Feature where MVVM is really strong is Blendability. Since all of the application state is preserved within the ViewModel, it is easy to fake data for design time, which allows enourmous boost to productivity. This is impossible to create in PassiveView, MVP or MVC, because in all of those architectures the controller has to actively put data inside the view. In MVVM the data just "jumps" to the View and therefore can be mocked. Testability This is indeed a place where PassiveView is superior to MVVM. If 100% Unit Tests coverage of UI is crucial to you then it's a big deal. In most situations however, the coverage that MVVM allows you is more than enough, and you'll usually add another tier of testing using regular UI Testing (which you'd end up doing in PassiveView also btw). I think that Testability is the less important of the three features. Sorted by importance, it's Maintainability, Blendablilty, and Testability. Where is MVVM not the right choice? I've participated in ~ 15 WPF & Silverlight Projects the last year, all of which MVVM fit perfectly. I think that in places where the presentation logic is extremely big, such as in games, MVVM might not be the right choice. Other than games, I can't really think of an application category that wouldn't go best with MVVM, other than special situations like RS Conley mentioned.
