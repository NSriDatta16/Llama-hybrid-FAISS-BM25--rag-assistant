[site]: stackoverflow
[post_id]: 683556
[parent_id]: 683504
[tags]: 
Accidental assignment protection: Putting the lvalue on the right hand side is not needed in some newer languages like C#. In C# the following won't compile: if (variable = 0) So in C# there is no need to do: if (0 == variable) This practice is very common in C/C++ programs to avoid accidental assignments that were meant to be comparisons. Multiple return points: Disallowing multiple return points was enforced mainly because you don't want to forget to delete your variables. Instead if you just use RAII you don't need to worry about it. Disclaimer: There are still good reasons to minimize multiple return points, and sometimes it is useful to have only one. Header files In most modern languages, you do not separate your code into declaration and definition. C++ defines for multiple header file includes In C++ you used to often do: #ifdef _MYFILE_H_ #define _MYFILE_H_ //code here #endif This sometimes would lead to something like the following though: #ifdef _MYFILE_H_ #define _WRONGNAME_H_ //code here #endif A better way to do this if your compiler supports it: #pragma once C variable declarations With C you had to declare all variables at the top of your block of code. Even later versions of C didn't require this though, but people still do it. Hungarian notation: (Read, contains some unique info) Hungarian notation can still be good . But I don't mean that kind of hungarian notation. Before it was very important in C to have things like: int iX = 5; char szX[1024]; strcpy(szX, "5"); Because you could have completely type unsafe functions like: printf("%i", iX); Now if I would have called the string x, my program would have crashed. Of course the fix to this is to use only typesafe functions. So as long as you do that you don't need hungarian notation in this sense. But still it is a good idea as discussed by Joel in his sense.
