[site]: stackoverflow
[post_id]: 2641146
[parent_id]: 
[tags]: 
Handling file renames in Git

I'd read that when renaming files in Git , you should commit any changes, perform your rename and then stage your renamed file. Git will recognise the file from the contents, rather than seeing it as a new untracked file, and keep the change history. However, doing just this tonight I ended up reverting to git mv . > $ git status # On branch master # Changes to be committed: # (use "git reset HEAD ..." to unstage) # # modified: index.html # I renamed my stylesheet in Finder from iphone.css to mobile.css : > $ git status # On branch master # Changes to be committed: # (use "git reset HEAD ..." to unstage) # # modified: index.html # # Changed but not updated: # (use "git add/rm ..." to update what will be committed) # (use "git checkout -- ..." to discard changes in working directory) # # deleted: css/iphone.css # # Untracked files: # (use "git add ..." to include in what will be committed) # # css/mobile.css So Git now thinks I've deleted one CSS file, and added a new one. It is not what I want. Letâ€™s undo the rename and let Git do the work. > $ git reset HEAD . Unstaged changes after reset: M css/iphone.css M index.html I am back to where I began: > $ git status # On branch master # Changes to be committed: # (use "git reset HEAD ..." to unstage) # # modified: index.html # Let's use git mv instead: > $ git mv css/iphone.css css/mobile.css > $ git status # On branch master # Changes to be committed: # (use "git reset HEAD ..." to unstage) # # renamed: css/iphone.css -> css/mobile.css # # Changed but not updated: # (use "git add ..." to update what will be committed) # (use "git checkout -- ..." to discard changes in working directory) # # modified: index.html # It looks like we're good. So why didn't Git recognise the rename the first time around when I used Finder?
