[site]: stackoverflow
[post_id]: 3667925
[parent_id]: 3652911
[tags]: 
If you can't make it work the way you want it to directly, create a class to provide the type of behaviour you want. So, to use big arrays: using System; using System.Collections.Generic; using System.Text; using System.IO; namespace BigBuffer { class Storage { public Storage (string filename) { m_buffers = new SortedDictionary (); m_file = new FileStream (filename, FileMode.Open, FileAccess.Read, FileShare.Read); } public byte [] GetBuffer (long address) { int key = GetPageIndex (address); byte [] buffer; if (!m_buffers.TryGetValue (key, out buffer)) { System.Diagnostics.Trace.WriteLine ("Allocating a new array at " + key); buffer = new byte [1 0); } public int GetPageIndex (long address) { return (int) (address >> 24); } public int GetPageOffset (long address) { return (int) (address & ((1 m_buffers; } class BigStream : Stream { public BigStream (Storage source) { m_source = source; m_position = 0; } public override bool CanRead { get { return true; } } public override bool CanSeek { get { return true; } } public override bool CanTimeout { get { return false; } } public override bool CanWrite { get { return false; } } public override long Length { get { return m_source.Length; } } public override long Position { get { return m_position; } set { m_position = value; } } public override void Flush () { } public override long Seek (long offset, SeekOrigin origin) { switch (origin) { case SeekOrigin.Begin: m_position = offset; break; case SeekOrigin.Current: m_position += offset; break; case SeekOrigin.End: m_position = Length + offset; break; } return m_position; } public override void SetLength (long value) { } public override int Read (byte [] buffer, int offset, int count) { int bytes_read = (int) (m_position + count > Length ? Length - m_position : count); m_source.FillBuffer (buffer, offset, bytes_read, m_position); m_position += bytes_read; return bytes_read; } public override void Write(byte[] buffer, int offset, int count) { } Storage m_source; long m_position; } class IntBigArray { public IntBigArray (Storage storage) { m_storage = storage; m_current_page = -1; } public int this [long index] { get { int value = 0; index "); BigStream stream = new BigStream (storage); StreamReader reader = new StreamReader (stream); string line = reader.ReadLine (); IntBigArray array = new IntBigArray (storage); int value = array [0]; BinaryReader binary = new BinaryReader (stream); binary.BaseStream.Seek (0, SeekOrigin.Begin); int another_value = binary.ReadInt32 (); } } } I split the problem into three classes: Storage - where the actual data is stored, uses a paged system BigStream - a stream class that uses the Storage class for its data source IntBigArray - a wrapper around the Storage type that provides an int array interface The above can be improved significantly but it should give you ideas about how to solve your problems.
