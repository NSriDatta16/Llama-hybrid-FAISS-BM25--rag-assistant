[site]: stackoverflow
[post_id]: 1961149
[parent_id]: 1959272
[tags]: 
To programmatically inject the Spring Security functionality into existing beans, you may need to use a Spring Security applicaton context and register your beans there: @Test public void testSpringSecurity() throws Exception { InMemoryXmlApplicationContext ctx = initSpringAndSpringSecurity(); // Creates new instance IMyService secured = (IMyService) ctx.getAutowireCapableBeanFactory() .initializeBean(new MyService(), "myService"); assertTrue(AopUtils.isAopProxy(secured)); fakeSecurityContext("ROLE_USER"); secured.getCustomers(); // Works: @Secured("ROLE_USER") fakeSecurityContext("ROLE_FOO"); try { secured.getCustomers(); // Throws AccessDenied Exception fail("AccessDeniedException expected"); } catch (AccessDeniedException expected) { } } private InMemoryXmlApplicationContext initSpringAndSpringSecurity() { InMemoryXmlApplicationContext ctx = new InMemoryXmlApplicationContext( " " + " " + " " + " " + " " + " "); return ctx; } I used an in-memory application context, as the MethodDefinitionSourceAdvisor states in its documentation that auto-proxying is only enabled for ApplicationContext s. Thus, i belief that you need an app context for auto-proxying, if you don't use a separate ProxyFactoryBean for each service object. But since you're using the @Secured annotation, i suspect that this is the same as auto-proxying. The fakeSecurityContext() just set an Authentication object with the given role into the SecurityContextHolder for testing purposes. You can do it with Spring Core functionality on your own. Assume you've got a service which returns a List of Customers and the current user may only view Customers with up to a specific limit of revenue. The following test case will be our start: @Test public void testSecurity() throws Exception { ClassPathXmlApplicationContext appCtx = new ClassPathXmlApplicationContext( "spring.xml"); IMyService service = (IMyService) appCtx.getBean("secured", IMyService.class); assertEquals(1, service.getCustomers().size()); } This is the original service implementation: public class MyService implements IMyService { public List getCustomers() { return Arrays.asList(new Customer(100000), new Customer(5000)); } } Configure your service object in spring.xml and add the method interceptor: securityInterceptor The security interceptor implementation: public class MyServiceInterceptor implements MethodInterceptor { private int revenueLimit = 10000; public void setRevenueLimit(int revenueLimit) { this.revenueLimit = revenueLimit; } @SuppressWarnings("unchecked") public Object invoke(MethodInvocation mi) throws Throwable { List filtered = new ArrayList (); List result = (List ) mi.proceed(); for (Customer customer : result) { if (customer.isRevenueBelow(revenueLimit)) { filtered.add(customer); } } return filtered; } } The advantage of using such an approach is that you not only can check declaratively for roles of the current user, but also enforce corporate policies in a dynamic way, e.g. limit the returned Objects based on business values.
