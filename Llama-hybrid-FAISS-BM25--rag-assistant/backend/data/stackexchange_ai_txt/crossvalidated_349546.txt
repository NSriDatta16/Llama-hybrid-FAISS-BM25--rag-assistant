[site]: crossvalidated
[post_id]: 349546
[parent_id]: 198944
[tags]: 
Here are some popular data wrangling packages in R with examples. Data used for the examples: attach(iris) attach(mtcars) l [1] apply family of functions in R base Applying a user-defined function: enter code heremyFunc Adding a new column with the mean of each row: enter code heremtcars$newCol lapply: lapply returns a list of the same length as X, each element of which is the result of applying FUN to the corresponding element of X. lapply(l, mean) sapply: sapply is a user-friendly version of lapply by default returning a vector or matrix if appropriate. sapply(l, mean) vapply: vapply is similar to sapply, but has a pre-specified type of return value. vapply(l, mean, c(row1=0)) mapply: mapply is a multivariate version of sapply. mapply(sum, l$a, l2$c) rapply: rapply is a recursive version of lapply. rapply(l, log2, how = "list") #returns a list structure rapply(l, log2) #returns a vector tapply: Apply a function to each cell of a ragged array, that is to each (non-empty) group of values given by a unique combination of the levels of certain factors. #mean petal length by species tapply(iris$Petal.Length, Species, mean) [2] dplyr package: select: select keeps only the variables you mentio. select(mtcars, starts_with("dis")) filter: filter find rows/cases where conditions are true. filter(mtcars, disp>400) group_by: group_by() takes an existing tbl and converts it into a grouped tbl where operations are performed "by group". group_by(iris, Species) merge: merge two data frames by common columns or row names, or do other versions of database join operations. The following is inner join which select rows where the left side data frame has a match in the right side data frame. merge(df1, df2, by.x = "CustId", by.y = "CustId") [3] sqldf package: Using sqldf package, the inner join can be expressed in SQL-like statement as follows: sqldf("SELECT CustId, City, State FROM df1 JOIN df2 USING(CustId)") [4] tidyr package gather: gather takes multiple columns and collapses into key-value pairs, duplicating all other columns as needed. You use gather() when you notice that you have columns that are not variables. gather(mtcars) separate: Given either regular expression or a vector of character positions, separate() turns a single character column into multiple columns. separate(mtcars, col="mpg", into=c("a","b")) unite: Convenience function to paste together multiple columns into one. unite_(mtcars, col="MpgCyl", c("mpg","cyl"), sep="-") [5] stats package: aggregate: aggregate splits the data into subsets, computes summary statistics for each, and returns the result in a convenient form. aggregate(iris[, 1:4], by=list(Species), FUN="mean") [6] data.table package: data.table inherits from data.frame. It offers fast and memory efficient: file reader and writer, aggregations, updates, equi, non-equi, rolling, range and interval joins, in a short and flexible syntax, for faster development. Since a data.table is a data.frame, it is compatible with R functions and packages that accept only data.frames. There are three parts in the DT[i,j,by] command, and in the SQL terminology the i corresponds to WHERE, j to SELECT, and by to GROUP BY. dt[am==1, mean(mpg), by=.(am, cyl)]
