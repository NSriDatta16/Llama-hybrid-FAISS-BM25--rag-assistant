[site]: crossvalidated
[post_id]: 488634
[parent_id]: 488625
[tags]: 
I'll go ahead and plug something I have been messing around with I am calling LazyProphet . Definitely takes a lot of influence from fbprophet but it measures trend via binary segmented regressions then measures seasonality then exogenous factors then uses gradient boosting to create more splits of the trend and regularize/adjust the other coefficients. It boosts until the global cost function (controlled via the regularization parameter) stops decreasing. One nice thing it has over fbprophet (I think, pretty sure prophet doesnt have this) is trend dampening on your forecasted trend which can be controlled via a parameter. Also you have a few different estimators for trend such as a mean changepoint/ linear changepoint/ global polynomial ridge regression. There are some examples in the readme in the link! Like I said this was mostly me just messing around and adding stuff so it is quite messy code wise but is is pip installable and the class object is easy enough to work with. I do have a much cleaner implementation coming sometime soon with a lot more trend/seasonal estimators since the procedure itself is quite general and can work with an ARIMA or ETS or whatever measure of trend. As a quick example of something you are interested in (although this is a dumb example in regards to our variables, just using what is easy): import quandl import pandas as pd import matplotlib.pyplot as plt import LazyProphet as lp #Get bitcoin data data = quandl.get("BITSTAMP/USD") #let's get our X matrix with the new variables to use X = data.drop('Low', axis = 1) X_train = X.iloc[-930:-50,:] X_test = X.iloc[-50:,:] y = data['Low'] y_train = y[-930:-50,] y_test = y[-50:,] #create Lazy Prophet class boosted_model = lp.LazyProphet(freq = 365, estimator = 'mean', max_boosting_rounds = 200, approximate_splits = True, regularization = 1.2, verbose = 1, exogenous = X_train) #Fits on just the time series #returns a dictionary with the decomposition output = boosted_model.fit(y_train) forecast = boosted_model.extrapolate(len(y_test), X_test) plt.plot(np.append(output['yhat'].values, forecast), label = 'Predicted') plt.plot(np.append(y_train.values,y_test.values), label = 'Actual') plt.vlines(len(X_train), 0, 13000, linestyles='dashed', color = 'red') plt.legend() plt.show()
