[site]: stackoverflow
[post_id]: 3703658
[parent_id]: 
[tags]: 
Specifying one type for all arguments passed to variadic function or variadic template function w/out using array, vector, structs, etc?

This question is about guaranteeing all arguments are of the same type while exhibiting a reject-early behavior with a clean compiler error, not a template-gibberish error I'm creating a function (possibly member function, not that it matters... maybe it does?) that needs to accept an unknown number of arguments, but I want all of them to be the same type. I know I could pass in an array or vector, but I want to be able to accept the list of args directly without extra structure or even extra brackets. It doesn't look like variadic functions by themselves are typesafe, and I wasn't sure how to go about this w/ variadic template functions. Here's essentially what I'm aiming for (more than likely not correct code, and totally not for the purpose of getting lists of dragons, lol): //typedef for dragon_list_t up here somewhere. enum Maiden { Eunice , Beatrice , Una_Brow , Helga , Aida }; dragon_list_t make_dragon_list(Maiden...) { //here be dragons } OR template dragon_list_t make_dragon_list(Maidens...) { //here be dragons } USAGE dragon_list_t dragons_to_slay = make_dragon_list(Maiden.Eunice, Maiden.Helga, Maiden.Aida) ; Tried a few things similar to the above already, no dice. Suggestions? Obvious oversights I may have made? I know it may not be a huge deal to do this instead: dragon_list_t make_dragon_list(std::array maidens) { //here be dragons. } dragon_list_t dragons_to_slay = make_dragon_list({Maiden.Eunice, Maiden.Helga, Maiden.Aida}) ; but I'd much rather be able to do it the first way if possible.
