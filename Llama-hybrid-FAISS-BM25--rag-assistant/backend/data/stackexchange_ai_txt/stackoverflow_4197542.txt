[site]: stackoverflow
[post_id]: 4197542
[parent_id]: 
[tags]: 
Interrupt thread after specified time - problems

I am developing an application where every TimeMax_Sec seconds a complex function (optimisation) is run. The function can potentially enter in a loop or just to take too much time, and the time TimeMax_Sec is set by the user. Therefore, I'm trying to run the function in a separate thread. To execute constantly the function, I use the command ScheduledExecutorService.scheduleAtFixedRate . Before the new thread is started, I have to be sure that the existing thread is not active any more and has released all the resources used. For this, inside the thread, I compare the time elapsed from the start of the thread with TimeMax_Sec , and if the it is greater, the thread is interrupted. Now, I have two problems: the code to call the threads looks too much complex and redundant and I'm wondering if it is possible to make it more elegant and clear. The code is like this: public class Main { public static void main(String[] args) { Runnable threadShell = new Runnable() { public void run() { Thread thread_Object = new rtr.cicle_thread(... args ...); try { thread_Object.start(); Thread.currentThread().sleep( timeMax_Sec*1000 ); if ( thread_Object.isAlive() ) { config_Obj_Final.stopThread = true; System.out.println("Thread forced to stop") thread_Object.join(); } } catch (InterruptedException e) { flagException(); } } }; ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); executor.scheduleAtFixedRate(ThreadShell, 0, timeMax_Sec, TimeUnit.SECONDS); } } more important, but maybe linked to the previous, the thread doesn't stops in time, and I have the impression that the time seen by the thread is slower than the actual time. An example of the code of the function in the thread is: public class cicle_thread extends Thread{ private ... args_thread ...; public cicle_thread(... args ...){ args_thread = args; } public void run(){ Calendar threadStartTime = Calendar.getInstance(); Calendar threadCurrentTime = Calendar.getInstance(); long loopFrequencyMilliseconds = timeMax_Sec*1000; long threadLifeInMilliseconds = 0; threadCurrentTime = Calendar.getInstance(); threadLifeInMilliseconds = threadCurrentTime.getTimeInMillis()-threadStartTime.getTimeInMillis(); if(threadLifeInMilliseconds>loopFrequencyMilliseconds){ if(Thread.currentThread().isInterrupted()){ interrupt(); return; } } function_1(); threadCurrentTime = Calendar.getInstance(); threadLifeInMilliseconds = threadCurrentTime.getTimeInMillis()-threadStartTime.getTimeInMillis(); if(threadLifeInMilliseconds>loopFrequencyMilliseconds){ if(Thread.currentThread().isInterrupted()){ interrupt(); return; } } function_2(); ... threadCurrentTime = Calendar.getInstance(); threadLifeInMilliseconds = threadCurrentTime.getTimeInMillis()-threadStartTime.getTimeInMillis(); if(threadLifeInMilliseconds>loopFrequencyMilliseconds){ if(Thread.currentThread().isInterrupted()){ interrupt(); return; } } function_n(); } but printing the time elapsed ThreadLifeInMilliseconds and the current time I have this result: Thread_1_Start 17:12:20 Function_1 ThreadLifeInMilliseconds = 0 Function_2 ThreadLifeInMilliseconds = 31 Function_3 ThreadLifeInMilliseconds = 624 Function_4 ThreadLifeInMilliseconds = 1357 threads forced to stop Thread_2_Start 17:12:28 Function_1 ThreadLifeInMilliseconds = 0 Function_2 ThreadLifeInMilliseconds = 47 Function_3 ThreadLifeInMilliseconds = 624 Function_4 ThreadLifeInMilliseconds = 1263 threads forced to stop Thread_3_Start 17:12:35 Function_1 ThreadLifeInMilliseconds = 0 Function_2 ThreadLifeInMilliseconds = 16 Function_3 ThreadLifeInMilliseconds = 577 Function_4 ThreadLifeInMilliseconds = 1014 threads forced to stop in the first case for example, the second thread is started after 8 seconds, but ThreadLifeInMilliseconds at Function_4 is only 1357 milliseconds. Note that TimeMax_Sec was set to 3 seconds (3000 milliseconds), therefore when the intermediate thread wake up from its sleep, it find the child thread still alive and write "threads forced to stop". Any idea? Thanks pardon, it looks like that the formatting of the code doesn't work too well...
