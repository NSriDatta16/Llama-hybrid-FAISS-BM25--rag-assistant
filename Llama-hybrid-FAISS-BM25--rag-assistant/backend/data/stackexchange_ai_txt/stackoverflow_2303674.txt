[site]: stackoverflow
[post_id]: 2303674
[parent_id]: 2303555
[tags]: 
A few tips: The first GetValues allocates newPtr (which is not declared within the function, a global variable?) but then does nothing with it. There are two possible ways that your function could work with regards to memory storage: The function gets a pointer to valid memory for an array of size large enough. In that case the signature of the function ought to be float *GetValues(float *array, size_t arraySize) to more clearly state the nature of the arguments. You need not to allocate anything inside the function. The function should allocate the needed memory itself and let the caller free the memory some time later. In that case you MUST have some kind of hint in the name of the function that it allocates memory. Otherwise you are in for a disaster in terms of maintaining this code because it will be extremely easy to make mistakes in freeing memory. You will not need to pass an array pointer to the function, but if you do it needs to be a double pointer for it to be of any meaning (C and C++ passes arguments by value so it is not possible to change a pointer which is passed as an argument) float *GetValuesAndAllocateMemmory(size_t n) float *GetValuesAndAllocateMemmory(float **array_pp, size_t n) The loop in the second GetValues should be float *start_p = p; ... while (scanf("%f", &input) == 1) { *p++ = input; cout in order to be identical to the first GetValues. Here there is upper limit of number of float values is n but your code does not check this cout and will crash if more than n floats are entered. Never trust user input data , even when it comes from yourself. Always verify. Search for the term "input validation" for more information about this. cout
