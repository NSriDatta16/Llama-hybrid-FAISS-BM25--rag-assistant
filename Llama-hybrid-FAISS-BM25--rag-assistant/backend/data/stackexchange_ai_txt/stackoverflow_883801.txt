[site]: stackoverflow
[post_id]: 883801
[parent_id]: 883682
[tags]: 
The difference lies in the C++ grammar. A simple-declaration is formed like this: declaration-specifier-seq init-declarator-list Where declaration-specifier-seq is a sequence of declaration specifiers: simple-type-specifier: int, bool, unsigned, typedef-name, class-name ... class-specifiers: class X { ... } type-qualifier: const, volatile function-specifier: inline, virtual, ... storage-class-specifier: extern, static, ... typedef You get the idea. And init-declarator-list is a list of declarators with an optional initializer for each: a *a a[N] a() &a = someObj So a full simple-declaration could look like this, containing 3 declarators: int a, &b = a, c[3] = { 1, 2, 3 }; Class members have special rules to account for the different context in which they appear, but they are very similar. Now, you can do typedef int A[3]; A *a; Since the first uses the typedef specifier and then simple-type-specifier and then a declarator like "a[N]". The second declaration then uses the typedef-name "A" (simple-type-specifier) and then a declarator like "*a". However, you of course cannot do int[3] * a; Since "int[3]" is not a valid declaration-specifier-seq as shown above. And now, of course, a template is not just like a macro text substitution. A template type parameter of course is treated like any other type-name which is interpreted as just the type it names and can appear where a simple-type-specifier can appear. Some C# folks tend to say C++ templates are "just like macros", but of course they are not :)
