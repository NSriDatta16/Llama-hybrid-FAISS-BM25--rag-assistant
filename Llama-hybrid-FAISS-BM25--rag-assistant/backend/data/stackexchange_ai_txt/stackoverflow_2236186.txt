[site]: stackoverflow
[post_id]: 2236186
[parent_id]: 2235622
[tags]: 
I'm a bit confused about Javascript undefined & null. null generally behaves similarly to other scripting languages' concepts of the out-of-band ‘null’, ‘nil’ or ‘None’ objects. undefined , on the other hand, is a weird JavaScript quirk. It's a singleton object that represents out-of-band values, essentially a second similar-but-different null . It comes up: When you call a function with fewer arguments than the arguments list in the function statement lists, the unpassed arguments are set to undefined . You can test for that with eg.: function dosomething(arg1, arg2) { if (arg2===undefined) arg2= DEFAULT_VALUE_FOR_ARG2; ... } With this method you can't tell the difference between dosomething(1) and dosomething(1, undefined) ; arg2 will be the same value in both. If you need to tell the difference you can look at arguments.length , but doing optional arguments like that isn't generally very readable. When a function has no return value; , it returns undefined . There's generally no need to use such a return result. When you declare a variable by having a var a statement in a block, but haven't yet assigned a value to it, it is undefined . Again, you shouldn't really ever need to rely on that. The spooky typeof operator returns 'undefined' when its operand is a simple variable that does not exist, instead of throwing an error as would normally happen if you tried to refer to it. (You can also give it a simple variable wrapped in parentheses, but not a full expression involving a non-existant variable.) Not much use for that, either. This is the controversial one. When you access a property of an object which doesn't exist, you don't immediately get an error like in every other language. Instead you get an undefined object. (And then when you try to use that undefined object later on in the script it'll go wrong in a weird way that's much more difficult to track down than if JavaScript had just thrown an error straight away.) This is often used to check for the existence of properties: if (o.prop!==undefined) // or often as truthiness test, if (o.prop) ...do something... However, because you can assign undefined like any other value: o.prop= undefined; that doesn't actually detect whether the property is there reliably. Better to use the in operator, which wasn't in the original Netscape version of JavaScript, but is available everywhere now: if ('prop' in o) ... In summary, undefined is a JavaScript-specific mess, which confuses everyone. Apart from optional function arguments, where JS has no other more elegant mechanism, undefined should be avoided. It should never have been part of the language; null would have worked just fine for (2) and (3), and (4) is a misfeature that only exists because in the beginning JavaScript had no exceptions. what does if (!testvar) actually do? Does it test for undefined and null or just undefined? Such a ‘truthiness’ test checks against false , undefined , null , 0 , NaN and empty strings. But in this case, yes, it is really undefined it is concerned with. IMO, it should be more explicit about that and say if (testvar!==undefined) . once a variable is defined can I clear it back to undefined (therefore deleting the variable). You can certainly assign undefined to it, but that won't delete the variable. Only the delete object.property operator really removes things. delete is really meant for properties rather than variables as such. Browsers will let you get away with straight delete variable , but it's not a good idea and won't work in ECMAScript Fifth Edition's strict mode. If you want to free up a reference to something so it can be garbage-collected, it would be more usual to say variable= null . can I pass undefined as a parameter? Yes.
