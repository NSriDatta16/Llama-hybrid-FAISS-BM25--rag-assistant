[site]: stackoverflow
[post_id]: 4284976
[parent_id]: 4284760
[tags]: 
Don't test properties, methods, data etc. Instead, describe the behaviour you're looking for and provide some examples which show how you can use the class. You'll find that most of the behaviour in your codebase is valuable, so you can get high levels of coverage this way without looking paranoid. (If it isn't valuable, delete it!) For instance, you could have a validator which read: [Test] public void ShouldOnlyValidateAlphaNamesLessThan50Chars() { var validator = new Validator(); Assert.IsTrue(validator.validates("An Alpha Name")); Assert.IsFalse(validator.validates( "A Really Really Long Name that's 51 characters xx")); Assert.IsFalse(validator.validates("A name with 1234 numbers")); } This is enough to show the kind of behaviour that the validator should have. I would put enough examples in each test method to show the valuable nature of the code. Experiment with it. Some people prefer "One assertion per test" but it doesn't have to be that way if it works better for you differently. With respect to 3rd party libraries, I'd think about what they're doing for you that's valuable, then wrap them up in another class which you can mock out. Moq is my favourite .NET mocking framework of choice. For UI testing, especially for web pages, I'd look at Selenium.NET. However, this is used for testing the entire system - we don't normally unit-test UI elements. This is partly because it's hard and expensive, and partly because actually looking at them, using them and playing with them in context is the only way to check that they're behaving properly. QUnit is the framework I've seen used for Javascript testing, if you're using that in your pages and want to test that too.
