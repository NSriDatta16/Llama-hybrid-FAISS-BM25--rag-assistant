[site]: stackoverflow
[post_id]: 1553552
[parent_id]: 1529606
[tags]: 
As already mentioned, the active record associations create a metric buttload of convenience methods. Sure, you could write your own methods to fetch everything. But that is not the Rails Way. The Rails Way is the culmination of two mottos. DRY (Don't Repeat Yourself) and "Convention over Configuration". Essentially by naming things in a way that makes sense, some robust methods provided by the framework can abstract out all the common code. The code you place in your question is the perfect example of something that can be replaced by a single method call. Where these convenience methods really shine are the more complex situations. The kind of thing involving join models, conditions, validations, etc. To answer your question when you do something like @user.articles.find(:all, :conditions => ["created_at > ? ", tuesday]) , Rails prepares two SQL queries and then merges them into one. where as your version just returns the list of objects. Named scopes do the same thing, but usually don't cross model boundaries. You can validate it by checking the SQL queries in the development.log as you call these things in the console. So lets talk about Named Scopes for a moment because they give a great example of how rails handles the SQL, and I think they're a simpler way to demonstrate what's going on behind the scenes, as they don't need any model associations to show off. Named Scopes can be used to perform custom searches of a model. They can be chained together or even called through associations. You could easily create custom finders that return identical lists, but then you run into the same problems mentioned in the Question. class Article "user" named_scope :edited_scope, :conditions => {:edited => true} named_scope :recent_scope, lambda do { :conditions => ["updated_at > ? ", DateTime.now - 7.days]} def self.edited_method self.find(:all, :conditions => {:edited => true}) end def self.recent_method self.find(:all, :conditions => ["updated_at > ?", DateTime.now - 7 days]) end end Article.edited_scope => # Array of articles that have been flagged as edited. 1 SQL query. Article.edited_method => # Array of Articles that have been flagged as edited. 1 SQL query. Array.edited_scope == Array.edited_method => true # return identical lists. Article.recent_scope => # Array of articles that have been updated in the past 7 days. 1 SQL query. Article.recent_method => # Array of Articles that have been updated in the past 7 days. 1 SQL query. Array.recent_scope == Array.recent_method => true # return identical lists. Here's where things change: Article.edited_scope.recent_scope => # Array of articles that have both been edited and updated in the past 7 days. 1 SQL query. Article.edited_method.recent_method => # no method error recent_scope on Array # Can't even mix and match. Article.edited_scope.recent_method => # no method error Article.recent_method.edited_scope => # no method error # works even across associations. @user.articles.edited.comments => # Array of comments belonging to Articles that are flagged as edited and belong to @user. 1 SQL query. Essentially each named scope creates an SQL fragment. Rails will skillfully merge with every other SQL fragment in the chain to produce a single query returing exactly what you want. The methods added by the association methods work the same way. Which is why they seamlessly integrate with named_scopes. The reason for the mix & match didn't work is the same that the of_sector method defined in the question doeso't work. edited_methods returns an Array, where as edited_scope (as well as find and all other AR convenience methods called as part of a chain) pass their SQL fragment onward to the next thing in the chain. If it's the last in the chain it executes the query. Similarly, this won't work either. @edited = Article.edited_scope @edited.recent_scope You tried to use this code. Here's the proper way to do it: class User {:sector_id => sector_id}) end end end To achieve this functionality you want to do this: class Articles {:sector_id => sectors} } end end class User Then you can do things like this: @user.articles.of_sector(4) => # articles belonging to @user and sector of 4 @user.articles.of_sector(5,6) => # articles belonging to @user and either sector 4 or 5 @user.articles.of_sector([1,2,3,]) => # articles belonging to @user and either sector 1,2, or 3
