[site]: stackoverflow
[post_id]: 4215819
[parent_id]: 4214859
[tags]: 
Since Bert isn't fixing his answer, I'll post the correct one. Yes, you're right that the original code is broken, despite what most people here are saying. In your example 5 / \ 2 1 / 3 Calling hasPathSum(root, 7); will return true despite the fact that there is no root-to-leaf path that adds to 7. That's because when node 2 is reached, it recursively checks the right child (with sum 0), which then returns true because the right child is null . The fix is inspired by Bert's answer: // `if` statement should check children and `return` statement deduct node.data from sum boolean hasPathSum(Node node, int sum) { int subSum = sum - node.data; if(node.left==null && node.right==null) { return(subSum == 0); } else { // otherwise check both subtrees if ( node.left != null && hasPathSum(node.left, subSum) ) { return true; if ( node.right != null && hasPathSum(node.right, subSum) ) { return true; } return false; } } You can roll the else block into one long statement if you want (lots of ands and ors), but I find this cleaner.
