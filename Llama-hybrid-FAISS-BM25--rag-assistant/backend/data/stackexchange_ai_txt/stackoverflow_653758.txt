[site]: stackoverflow
[post_id]: 653758
[parent_id]: 652779
[tags]: 
We use lzz which splits out a single file into a separate header and translation unit. By default, it would normally put the template definitions into the header too, however, you can specify that you don't want this to happen. To show you how you might use it consider the following: // t.cc #include "b.h" #include "c.h" template class A { void foo () { C c; c.foo (); b.foo (); } B b; } Take the above file and copy it to 't.lzz' file. Place any #include directives into separate $hdr and $src blocks as necessary: // t.lzz $hdr #include "b.h" $end $src #include "c.h" $end template class A { void foo () { C c; c.foo (); b.foo (); } B b; } Now finally, run lzz over the file specifying that it places the template definitions into the source file. You can either do this using a $pragma in the source file, or you can use the command line option "-ts": This will result in the following files being generated: // t.h // #ifndef LZZ_t_h #define LZZ_t_h #include "b.h" #undef LZZ_INLINE #ifdef LZZ_ENABLE_INLINE #define LZZ_INLINE inline #else #define LZZ_INLINE #endif template class A { void foo (); B b; }; #undef LZZ_INLINE #endif And: // t.cpp // #include "t.h" #include "c.h" #define LZZ_INLINE inline template void A ::foo () { C c; c.foo (); b.foo (); } #undef LZZ_INLINE You can then run these through some grep/sed commands to remove the LZZ helper macros.
