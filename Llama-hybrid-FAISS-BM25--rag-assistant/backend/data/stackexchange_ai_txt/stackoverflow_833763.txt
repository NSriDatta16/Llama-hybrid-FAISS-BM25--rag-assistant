[site]: stackoverflow
[post_id]: 833763
[parent_id]: 831099
[tags]: 
Maybe bit offtopic, but I've struggled with this before (pre D2006, so no records) for some ORM framework. Assuming that the "class" stuff is set in stone: Tips and hints: the packing problem I worked around by having getters and setters for the fields, storing them in the array of byte of the class. Could even be bitpacked. If setters/getters are inlinable (then not an option for me, D6) it could be fairly cheap even. try to harvest heap allocation (both administrative overhead and slack space) overhead by initializing a block of memory yourself, setting the VMT and call the constructor on it. IIRC heap overhead was 8 bytes and the granularity of allocation of the old heapmgr was 8 byte, and with fastmm 16 byte. If you sort the classes according to size, you can use a bitmap as allocation structure If you are particularly evil, remember that a pointer has 2 or 3 bits slack. I used these bits as identity for an extremely much used type of allocation, saving the 4 byte the heap reserves to store size. Pay attention to your indexes. If you get a lot of objects (I had about 6 million), you have to be careful with your index types too. (no tstringlist please) Always keep the non obfuscated stuff under ifdef, for easier debugging testing (*) never use strings as key. Hash if necessarily. Normalizing structures is not only good for databases (*) I later recompiled the "clean" version under 64-bit FPC , and it worked after a few minor sizeof(pointer()) despite the uglinesses of point 1 an 2
