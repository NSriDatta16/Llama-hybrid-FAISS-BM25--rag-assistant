[site]: stackoverflow
[post_id]: 2462222
[parent_id]: 2426696
[tags]: 
Well, well it seems the answer to this was also in the book (modern compiler implementation in java). The book presents 4 answers: Some procedures don't call other procedures. If you draw the diagram of procedure calls, and assume that each procedure calls on average 1-2 other procedures, you come up with a tree, in which the "leafs" (the procedures that don't call others) outnumber the tree non-left nodes. So you win that way. Some compilers don't allocate a stack frame at all for these leaf nodes. Some optimizing compilers use "interprocedural register allocation" - which basically means they analyse all of your source code and make smart ways of storing arguments to procedures ahead of time, thus minimizing writing to stack. Some procedures are done with a variable before they call another function - in which case that register can be just overwritten. Some architectures use "register windows", so that each function invocation can allocate fresh set of registers without memory traffic.
