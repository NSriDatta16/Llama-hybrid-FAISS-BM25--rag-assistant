[site]: stackoverflow
[post_id]: 4456819
[parent_id]: 4456420
[tags]: 
The .NET version of Zip won't handle an arbitrary number of arrays the way Python's appears to do. You'll need to call Zip twice: Dim first As String() = { "a", "b", "c" } Dim second As Integer() = { 1, 2, 3 } Dim third As String() = { "x", "y", "z" } Dim query = first.Zip(second, Function(f, s) New With { .First = f, .Second = s }) _ .Zip(third, Function(o, t) New With { o.First, o.Second, .Third = t }) For Each item in query Console.WriteLine("{0}, {1}, {2}", item.First, item.Second, item.Third) Next Another option would be to use the overloaded Enumerable.Select method that includes the index. This approach relies on the types you're working with allowing access by index. I wouldn't recommend substituting index access with the ElementAt method for performance purposes. Also, this approach assumes all collections have the same length, otherwise it will throw an exception. It would work as follows: Dim query2 = first.Select(Function(f, i) New With { .First = f, .Second = second(i), .Third = third(i) }) EDIT: One thought is to leverage Python directly and call it from VB.NET. I'm not really sure how this would be handled, and there will be a learning curve to set it all up. Search for "call python from c#" or from "vb.net" for more on that topic. The challenge is you can't dynamically create an anonymous type. The closest approach I came up with is to use .NET 4.0's ExpandoObject . To use C#'s dynamic keyword in VB.NET you should be able to initialize an object without specifying the type, such as Dim o = 5 since it's really an object underneath. You'll probably need to set Option Infer On and Option Strict Off to achieve that. The following code expects arrays as input. Unfortunately mixing dynamic types and other IEnumerable s becomes challenging when attempting to access the Count . Jon Skeet has a relevant article about it here: Gotchas in dynamic typing . For that reason I stuck with arrays; it can be changed to List to use the Count property, but definitely not a mixture without a lot of work. VB.NET Dim first As String() = { "a", "b", "c" } Dim second As Integer() = { 1, 2, 3 } Dim third As String() = { "x", "y", "z" } Dim fourth As Boolean() = { true, false, true } Dim list As New List(Of Object) From { first, second, third, fourth } ' ensure the arrays all have the same length ' Dim isValidLength = list.All(Function(c) c.Length = list(0).Length) If isValidLength Dim result As New List(Of ExpandoObject)() For i As Integer = 0 To list(i).Length - 1 Dim temp As New ExpandoObject() For j As Integer = 0 To list.Count - 1 CType(temp, IDictionary(Of string, Object)).Add("Property" + j.ToString(), list(j)(i)) Next result.Add(temp) Next ' loop over as IDictionary ' For Each o As ExpandoObject In result For Each p in CType(o, IDictionary(Of string, Object)) Console.WriteLine("{0} : {1}", p.Key, p.Value) Next Console.WriteLine() Next ' or access via property ' For Each o As Object In result Console.WriteLine(o.Property0) Console.WriteLine(o.Property1) Console.WriteLine(o.Property2) Console.WriteLine(o.Property3) Console.WriteLine() Next End If C# equivalent (for anyone interested) string[] first = { "a", "b", "c" }; int[] second = { 1, 2, 3 }; string[] third = { "x", "y", "z" }; bool[] fourth = { true, false, true }; var list = new List { first, second, third, fourth }; bool isValidLength = list.All(l => l.Length == list[0].Length); if (isValidLength) { var result = new List (); for (int i = 0; i )temp).Add("Property" + j, list[j][i]); } result.Add(temp); } // loop over as IDictionary foreach (ExpandoObject o in result) { foreach (var p in (IDictionary )o) Console.WriteLine("{0} : {1}", p.Key, p.Value); Console.WriteLine(); } // or access property via dynamic foreach (dynamic o in result) { Console.WriteLine(o.Property0); Console.WriteLine(o.Property1); Console.WriteLine(o.Property2); Console.WriteLine(o.Property3); Console.WriteLine(); } }
