[site]: crossvalidated
[post_id]: 337639
[parent_id]: 337585
[tags]: 
Besides the obvious generation from a Gamma generator until the outcome is larger than a, as in your R code and the (inefficient) gene=rep(0,N) for (i in 1:N){ x=rgamma(1,b,c) while (x or the slightly improved gama=rgamma(N,b,c) gene=gama[gama>a] while (length(gene) a])} gene=gene[1:N] [which both may suffer from unacceptable running time when $a$ gets large enough], there exist optimised truncated Gamma generators, as an accept-reject algorithm in Philippe (1996) . If one is not concerned by a high precision, inverting the cdf as in Fa=pgamma(a,b,c) gene=qgamma(runif(N,Fa,1),b,c) or (when a is too large) Fa=pgamma(a,b,c,low=FALSE) gene=qgamma(1-runif(N,0,Fa),b,c) works as well. An illustration of the limitations of the "repeat until x>a" approach is provided by moving from a=200 to a=2000 > pgamma(2000,shape=10,scale=20,lower.tail=FALSE) [1] 1.125347e-31 since it would take an average of 10³¹ attempts to produce one acceptance.
