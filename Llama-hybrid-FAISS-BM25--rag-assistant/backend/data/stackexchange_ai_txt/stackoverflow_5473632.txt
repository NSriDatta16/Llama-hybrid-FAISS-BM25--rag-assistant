[site]: stackoverflow
[post_id]: 5473632
[parent_id]: 5473130
[tags]: 
kriegar's solution will work. There's also this one, which searches by Status id instead of text matching on description : destroyedStatus = Status.objects.get(description="destroyed") clients_destroyed_items = StorageItem.objects.filter(client=client, itemstatushistory__status=destroyedStatus) This assumes descriptions are unique, but you have no such constraint in your model. I have no idea which implementation is faster. EDIT: By the way, if you've got some crazy system where you have more than one Status with a description of "destroyed", and you wanted to query by Status id s instead of description , you would just do: destroyedStatusIDs = Status.objects.filter(description="destroyed").values_list("id", flat=True) clients_destroyed_items = StorageItem.objects.filter(client=client, itemstatushistory__status__in=destroyedStatusIDs) BTW, it's considered good practice to set related_name on your ForeignKey , OneToOneField , and ManyToManyField relationships, usually to plurals. So your history class becomes: class ItemStatusHistory(models.Model): date = models.DateTimeField(auto_now=True) contact = models.ForeignKey(Contact, related_name="history") item = models.ForeignKey(StorageItem, related_name="history") status = models.ForeignKey(Status, related_name="history") user = models.ForeignKey(User, related_name="history") which would change my first example to: destroyedStatus = Status.objects.get(description="destroyed") clients_destroyed_items = StorageItem.objects.filter(client=client, history__status=destroyedStatus) EDIT 2: Ah, so you only want to consider the current (i.e. latest) Status. This is where aggregation and F objects come in. Basically, the idea is to have the database create a "fake column" in the table which has the date of the latest (i.e. maximum date ) Status, then require the date to match as well as the status: from django.db.models import F, Max destroyedStatus = Status.objects.get(description="destroyed") clients_destroyed_items = StorageItem.objects.annotate( last_change_date=Max("itemstatushistory__date")).filter(client=client, itemstatushistory__status=destroyedStatus, itemstatushistory__date=F("last_change_date")) I haven't tested this, this is the first time I've tried this, and there may be a better way, so comments are welcome.
