[site]: stackoverflow
[post_id]: 912761
[parent_id]: 
[tags]: 
Ideas for designing a Secure, "Low Cost" method for confirming client-side game results

This is more a system design question/challenge, than a coding question. Basically, I'm thinking of throwing together a Bejeweled -esque game on Facebook using just HTML, CSS, and javascript. This is mostly out of a desire to learn all the little caveats of FBJS via a non-trivial project. So here's the deal. When developing for Facebook, actual API calls are very expensive; not only is there an additional POST to the Facebook servers, there's also the api call limit and throttling to worry about. In a nutshell, the fewer calls to Facebook the better. Combine this with the timing concerns of even this simple puzzle game, and there's good reason to aggressively minimize the number of callbacks in general. Not being a security expert, here's the design I've come up with: Embed a random seed in the game page. Use that seed to create the game board (As well as additional pieces as needed). Tweak the seed (xor, concatenate and hash, something like that) after each player move, based on time since last move. Edit: I should probably also include the actual move taken in mutating the seed. Upon game completion post back the following: game start time, each move taken and when, and the client side results. On the server, re-run the game with the given data, sanity checking the start time and move times, and then confirm that the results match. To mitigate denial of service, the game itself will be tweaked to have a win by turn X condition. To discourage the server being used as a "oracle" of sorts, a user posting back an invalid game will be banned for some constant time X (X being on the order of minutes). This design requires three Facebook call per game played: one to store the random seed before the game is played, one to fetch it after the game is finished, and one to update the player's score if the game is valid. What I'm trying to proof the system against is straight up score spoofing ( http://...?myscore=999999999 , or similar). I'd also like to mitigate "look ahead" attacks, wherein the user can tell what pieces are coming to the board next. Denial of service attacks on the hosting server (intentional or otherwise) should also be prevented. The actual question, can anyone see a flaw in this design? Equivalently, is there a simpler design that meets my criteria? Note: I am aware how unnecessary this probably is, but its an interesting question none the less. I'm going to try and throw some numbers up here to futher illustrate my reasoning, these are pretty rough but I hope helpful. Assuming a 10x10 game board, there are ~200 potential moves (swapping two adjacent pieces) most of which are invalid. Let's say there are on average 5 valid moves per "turn". If we constrain player actions to the frame of 50 to 30,000 milliseconds, there are 149,750 potential new hashes provided the "tweaking" algorithm doesn't discard bits; I feel confident in say there are at least 10,000 potential new hashes which must be calculated by an attacker assuming a cryptographically secure hash is used. If you throw a min-max algorithm at this, your decision tree explodes very quickly. Throw a game session expiration at this, say 30 minutes, and I believe the attack because equivalent in complexity to writing a little bot program to play for you which cannot reasonably be defended against.
