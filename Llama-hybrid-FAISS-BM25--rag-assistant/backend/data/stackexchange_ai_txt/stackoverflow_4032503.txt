[site]: stackoverflow
[post_id]: 4032503
[parent_id]: 4031249
[tags]: 
Does .dll get access to the entire memory available to the host process or just a portion of it? i.e is there a limitation when memory is allocated by a function inside the .dll? After a DLL has been loaded into the host process, there is no distinction whatsoever for code "living" in the DLL vs. code "living" in the original executable module. For the process being executed all memory ranges are the same, whether they come from a DLL or from the original executable. There are no differences as to what the code from the DLL can do vs. what the code compiled in the original exec module can do. That said, there are differences when using the heap - these are explained in the questions Space_C0wb0y provided the links for in the comments Will STL classes like string, vector (dynamically increasing storage) etc used by the dll, work without issue here? They will create issues (solvable ones, but still) if you use them in the interface of your DLL. The will not (or should only under very rare circumstances) create issues if you do not use them on the DLL interface level. I am sure there are a few more specific questions+answers around for this. Basically, if you use them at the interface level, the DLL and the EXE have to be compiled with "exactly" the same flags, i.e. the types need to be binary compatible. I.e. if the comiler flags (optimization, etc.) in your DLL differ from the ones in the EXE such that a std::string is layed out differently in memory in the EXE vs. the DLL, then passing a string object between the two will result in a crash or silent errors (or demons flying out of your nose). If you only use the STL types inside of functions or between functions internal to your DLL, then their compatibility with the EXE doesn't matter.
