[site]: stackoverflow
[post_id]: 2946799
[parent_id]: 2862978
[tags]: 
One way to solve this is to only use bindings for the first two column where it works. For the remaining columns you implement a NSTableViewDataSource that implements the custom logic needed. First create a new class that implements -tableView:objectValueForTableColumn:row: -tableView:setObjectValue:forTableColumn:row: (you only need the 2nd if the user is supposed to edit the other columns). Then add an IBOutlet NSArrayController *valuesController; instance variable to that class. Inside Interface Builder add a new object of that class (drag a blue "object" cube into the file's window from the library). Connect your array controller to your new data source. Then connect the data source with the table view to make it the table view's data source. Make sure the columns past the first two are not bound to anything. The -tableView:objectValueForTableColumn:row: method will get called for those columns as needed and you can look at the object as needed: - (id)tableView:(NSTableView *)aTableView objectValueForTableColumn:(NSTableColumn *)aTableColumn row:(NSInteger)rowIndex; { NSObject *myObject = [[valuesController arrangedObjects] objectAtIndex:rowIndex]; id columnIdentifier = [aTableColumn identifier]; if ([columnIdentifier isEqual:@"foo"]) { if ([myObject respondsToSelector:@selector(fooValue)]) { return [myObject fooValue]; } } return nil; } Note how I'm using the columns identifier to see which column is being requested. Set the columns identifier inside Interface Builder.
