[site]: stackoverflow
[post_id]: 5261769
[parent_id]: 5261174
[tags]: 
i would like to be able to have a reference to a variable inside a instance of a class, but i'd like the reference to become a class variable so I dont need to send it around inside of the class as parameter You will have to live with disappointment then. The CLR type system explicitly forbids storage of references to variables as members of classes. The CLR permits references to variables to be passed to methods as arguments corresponding to formal parameters or 'this' stored as locals returned as method return values but does not permit storage in arrays, fields, and so on. Basically, anything that goes "on the heap" can't hold onto a ref. C# exposes the first feature: refs to variables as method parameters. It does not expose the other two features (though I have written an experimental version of C# which does, and it works quite nicely.) Note that C# does not allow you to use refs in contexts which would require heap storage of the ref -- like a ref parameter being a closed-over outer variable of a lambda, for example. There are a few rare cases in which the compiler does allow what looks like long-term storage of the ref, and uses copy-in-copy-out semantics to emulate the ref, but probably best to not even go there. Why does the CLR have this restriction? The right way to think about it is that there are two kinds of storage: long term and short term, usually called "heap" and "stack". But the shape of the data structure is irrelevant; what is relevant is the length of the lifetime. A variable has a storage location; that's what a variable is. If you could keep a ref to a variable allocated from the short-term storage in a long-term storage then the long-term storage keeps a ref to something that is of shorter lifetime, and therefore might crash and die when it accesses the variable after its death. Obviously there are many ways to solve this problem. For example, the CLR team could have chosen to make it illegal to take a ref to short-term storage, and allow storage of refs in long-term storage. But that then means that you can't take refs to local variables or parameters, which you would like to put in short-term storage because their lives are so short. The way the CLR team actually chose was to disallow long-term storage of any ref. Like any design decision, it was the result of many tradeoffs against competing goals.
