[site]: stackoverflow
[post_id]: 4926034
[parent_id]: 4921046
[tags]: 
To cature the selected ListView item inside a button pressed event you can leverage the MVVM pattern. In my ListView, in the XAML, I bind the ItemsSource and SelectedItem to a ViewModel class. I also bind my button Command in the template to RunCommand in the ViewModel. The tricky part is getting the binding correct from the template to the active DataContext. Once you do this you can capture the SelectedCustomer inside the RunCommand that gets executed when the button gets pressed. I've included some of the code to help get you started. You can find implementations of ViewModelBase and DelegateCommand via Google. Here is the XAML: Here is the ViewModel: using System.Collections.ObjectModel; using System.Windows.Input; using ListViewScrollPosition.Commands; using ListViewScrollPosition.Models; namespace ListViewScrollPosition.ViewModels { public class MainViewModel : ViewModelBase { public ICommand RunCommand { get; private set; } public MainViewModel() { RunCommand = new DelegateCommand (OnRunCommand, CanRunCommand); _customers = Customer.GetSampleCustomerList(); _selectedCustomer = _customers[0]; } private ObservableCollection _customers = new ObservableCollection (); public ObservableCollection Customers { get { return _customers; } } private Customer _selectedCustomer; public Customer SelectedCustomer { get { return _selectedCustomer; } set { _selectedCustomer = value; OnPropertyChanged("SelectedCustomer"); } } private void OnRunCommand(object obj) { // use the SelectedCustomer object here... } private bool CanRunCommand(object obj) { return true; } } } Here is where I link in the ViewModel to the View: public partial class MainView : Window { public MainView() { InitializeComponent(); DataContext = new ViewModels.MainViewModel(); } }
