[site]: stackoverflow
[post_id]: 304059
[parent_id]: 294382
[tags]: 
The difference, in practice, is actually To read and write a 5MB file 24 times, my numbers taken using a Profiler. They were on average: char[] = 4139 ms CharBuffer = 4466 ms ByteBuffer = 938 (direct) ms Individual tests a couple times favored CharBuffer. I also tried replacing the File-based IO with In-Memory IO and the performance was similar. If you are trying to transfer from one native stream to another, then you are better off using a "direct" ByteBuffer. With less than 10% performance difference, in practice, I would favor the CharBuffer. It's syntax is clearer, there's less extraneous variables, and you can do more direct manipulation on it (i.e. anything that asks for a CharSequence). Benchmark is below... it is slightly wrong as the BufferedReader is allocated inside the test-method rather than outside... however, the example below allows you to isolate the IO time and eliminate factors like a string or byte stream resizing its internal memory buffer, etc. public static void main(String[] args) throws Exception { File f = getBytes(5000000); System.out.println(f.getAbsolutePath()); try { System.gc(); List impls = new java.util.ArrayList (); impls.add(new CharArrayImpl()); //impls.add(new CharArrayNoBuffImpl()); impls.add(new CharBufferImpl()); //impls.add(new CharBufferNoBuffImpl()); impls.add(new ByteBufferDirectImpl()); //impls.add(new CharBufferDirectImpl()); for (int i = 0; i = 0) { out.write(buff, 0, n); } } } public static class CharBufferImpl extends Main { CharBuffer buff = CharBuffer.allocate(BUFFER_SIZE); public void runTest(InputStream ins, OutputStream outs) throws IOException { Reader in = new BufferedReader(new InputStreamReader(ins)); Writer out = new BufferedWriter(new OutputStreamWriter(outs)); int n; while ((n = in.read(buff)) >= 0) { buff.flip(); out.append(buff); buff.clear(); } } } public static class ByteBufferDirectImpl extends Main { ByteBuffer buff = ByteBuffer.allocateDirect(BUFFER_SIZE * 2); public void runTest(InputStream ins, OutputStream outs) throws IOException { ReadableByteChannel in = Channels.newChannel(ins); WritableByteChannel out = Channels.newChannel(outs); int n; while ((n = in.read(buff)) >= 0) { buff.flip(); out.write(buff); buff.clear(); } } }
