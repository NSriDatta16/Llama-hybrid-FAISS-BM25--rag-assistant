[site]: stackoverflow
[post_id]: 3988467
[parent_id]: 2952732
[tags]: 
Task: You have a list people of objects of class Person that has fields name and age . Your task is to sort this list first by name , and then by age . Java 7: Collections.sort(people, new Comparator () { public int compare(Person a, Person b) { return a.getName().compare(b.getName()); } }); Collections.sort(people, new Comparator () { public int compare(Person a, Person b) { return Integer.valueOf(a.getAge()).compare(b.getAge()); } }); Scala: val sortedPeople = people.sortBy(p => (p.name, p.age)) Update Since I wrote this answer, there has been quite some progress. The lambdas (and method references)have finally landed in Java, and they are taking the Java world by storm. This is what the above code will look like with Java 8 (contributed by @fredoverflow): people.sort(Comparator.comparing(Person::getName).thenComparing(Person::getAge)); While this code is almost as short, it does not work quite as elegantly as the Scala one. In Scala solution, the Seq[A]#sortBy method accepts a function A => B where B is required to have an Ordering . Ordering is a type-class. Think best of both worlds: Like Comparable , it's implicit for the type in question, but like Comparator , it's extensible and can be added retrospectively to types that did not have it. Since Java lacks type-classes, it has to duplicate every such method, once for Comparable , then for Comparator . For example, see comparing and thenComparing here . The type-classes allow one to write rules such as "If A has ordering and B has ordering, then their tuple (A, B) also has ordering". In code, that is: implicit def pairOrdering[A : Ordering, B : Ordering]: Ordering[(A, B)] = // impl That is how the sortBy in our code can compare by name and then by age. Those semantics will be encoded with the above "rule". A Scala programmer would intuitively expect this to work this way. No special purpose methods like comparing had to be added to Ordering . Lambdas and method references are just a tip of an iceberg that is functional programming. :)
