[site]: stackoverflow
[post_id]: 3901624
[parent_id]: 3901124
[tags]: 
@Gabe's answer is correct, but needs to be shown clearly rather than hypothesized. CPython (and probably only CPython) does an in-place string append when it can. There are limitations on when it can do this. First, it can't do it for interned strings. That's why you'll never see this if you test with a = "testing"; a = a + "testing" , because assigning a string literal results in an interned string. You have to create the string dynamically, as this code does with str(12345) . (This isn't much of a limitation; once you do an append this way once, the result is an uninterned string, so if you append string literals in a loop this will only happen the first time.) Second, Python 2.x only does this for str , not unicode . Python 3.x does do this for Unicode strings. This is strange: it's a major performance difference--a difference in complexity . This discourages using Unicode strings in 2.x, when they should be encouraging it to help the transition to 3.x. And finally, there can be no other references to the string. >>> a = str(12345) >>> id(a) 3082418720 >>> a += str(67890) >>> id(a) 3082418720 This explains why the non-Unicode version is so much faster in your test than the Unicode version. The actual code for this is string_concatenate in Python/ceval.c , and works for both s1 = s1 + s2 and s1 += s2 . The function _PyString_Resize in Objects/stringobject.c also says explicitly: The following function breaks the notion that strings are immutable . See also http://bugs.python.org/issue980695 .
