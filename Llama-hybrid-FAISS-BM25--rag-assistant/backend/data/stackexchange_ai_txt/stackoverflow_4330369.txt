[site]: stackoverflow
[post_id]: 4330369
[parent_id]: 4330027
[tags]: 
There are 2 problems with this code. ::GetMessage() doesn't stop because you're using the hWnd parameter with something else than NULL . You need to fetch the thread messages to get ::GetMessage() to return 0 . Following on the logic in (1), you need to post the message using ::PostThreadMessage() to put it in the thread's message queue. All of this is rather well illustrated by the fact the ::PostQuitMessage(status) is a shorthand for ::PostThreadMessage(::GetCurrentThreadId(), WM_QUIT, status, 0); EDIT : It seems that people have been led into thinking that ::PostThreadMessage(...,WM_QUIT,...); doesn't work because it doesn't get the special treatement of setting the QS_QUIT flag that is set by ::PostQuitMessage() . If that was the case, then there would be no way to send WM_QUIT to another thread's message queue. Here is proof that it works anyways. In particular, pay attention to the constants Use_PostQuitMessage and GetMessage_UseWindowHandle . Feel free to change the values and play around with the code. It works just as advertised in my answer, except that I mistakenly used ::GetCurrentThread() rather than ::GetCurrentThreadId() before trying it out. #include #include #include namespace { // Doesn't matter if this is 'true' or 'false'. const bool Use_PostQuitMessage = false; // Setting this to 'true' prevents the application from closing. const bool GetMessage_UseWindowHandle = false; void post_quit_message () { if ( Use_PostQuitMessage ) { ::PostQuitMessage(0); } else { ::PostThreadMessageW(::GetCurrentThreadId(), WM_QUIT, 0, 0); } } ::BOOL get_message ( ::HWND window, ::MSG& message ) { if ( GetMessage_UseWindowHandle ) { return (::GetMessageW(&message, window, 0, 0)); } else { return (::GetMessageW(&message, 0, 0, 0)); } } ::ULONG __stdcall background ( void * ) { // Allocate window in background thread that is to be interrupted. ::HWND window = ::CreateWindowW(L"STATIC", 0, WS_OVERLAPPEDWINDOW, 0, 0, 512, 256, 0, 0, ::GetModuleHandleW(0), 0); if ( window == 0 ) { std::cerr 0) { // Handle 'CloseWindow()'. if ( message.message == WM_CLOSE ) { post_quit_message(); continue; } // Handling for 'ALT+F4'. if ((message.message == WM_SYSCOMMAND) && (message.wParam == SC_CLOSE)) { post_quit_message(); continue; } // Dispatch message to window procedure. ::TranslateMessage(&message); ::DispatchMessageW(&message); } // Check for error in 'GetMessage()'. if ( result == -1 ) { std::cout P.S. : To actually test the single-threaded use of ::PostThreadMessage(::GetCurrentThreadId(),...); invoke ::background(0); in main instead of launching the thread.
