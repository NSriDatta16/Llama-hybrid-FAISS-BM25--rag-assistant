[site]: stackoverflow
[post_id]: 1874688
[parent_id]: 1874493
[tags]: 
Taking these one at a time: I want to copy a class that contains an array. Okay, so for example: class Foo { int arr[20]; }; If it would be allocated with operator new then I should manualy copy this array within a copy constructor. Okay, now the confusion sets in. In the above example, the array is actually part of the object. sizeof(Foo) would give you 80 if int is 4 bytes. An alternative would be to have a pointer to an array, which is useful if the array needs to change size: class Bar { int *arr; }; In that case, sizeof(Bar) is the size of a pointer (usually 4 or 8 bytes), and copying the object copies the pointer. This is called a "shallow copy". If you wanted a "deep copy", i.e. a copy would duplicate the array's contents and not just the object, then you need a copy constructor. The third alternative is to use vector , as wheaties recommends: class Bob { std::vector arr; }; This internally works the same as the Bar case, and the vector can be resized, but the vector template takes care of the deep copy for you, so you don't need a copy constructor. I'd recommend the Foo case if you need a fixed-size array, where the size is known at compile time, and the Bob case otherwise. The Bar case is pretty much just reinventing the wheel. Is simple memcpy(...) safe here? Safe for Foo . Safe for Bar if you want a shallow copy. Unsafe for Bob . The moral of the story is that storing a variable in an object works just like storing it in a function block or global: if you specify an array ( [N] instead of * ), the size had better be determined at compile time, and you get the storage placed right there.
