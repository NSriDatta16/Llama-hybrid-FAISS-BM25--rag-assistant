[site]: stackoverflow
[post_id]: 4889489
[parent_id]: 4889351
[tags]: 
The answer to this depends entirely on what you're doing: If you're attempting to create a managed interface to your existing unmanaged library (in other words, write code in VB.NET or some other .NET language that calls code in an existing non-.NET .dll), then you're doing the right thing. I'll address that in a second If you're attempting to create a managed implementation of your existing unmanaged library (i.e. rewrite the existing .dll in .NET and get rid of the existing .dll entirely), then you should spend the time necessary to refactor the code into something object-oriented rather than trying to duplicate structures and such. In general structures (which are value types) should be used only if you have a particularly convincing reason to do so; otherwise, you should be using classes (reference types) and properly migrate the code from procedural into object-oriented. If you're creating a managed interface, you should know that the naming of structure members is ignored. It's the order and size of the elements that's important. However, that's not really your issue here, as you're just dealing with an impedance mismatch between the way C defines structures and the way VB.NET (and other .NET languages) do. Since the union keyword just allows you to break up a larger structure into logical blocks of variables without defining the substruct as a standalone data structure, some massaging is required to get it into .NET, which doesn't allow such things (again, structs are not the primary means of encapsulating information in reference-based object-oriented languages like VB.NET and C#). You'll have to take the substructure(s) and define them as structures on their own, then define a variable typed as the substructure as a regular member on the outer structure. (Incidentally, there's no need to use StructLayoutKind.Explicit if you're declaring the members in order; using Sequential will make it easier to read if they're already in the right order.) After that somewhat long-winded response, you're looking for something like this: _ Structure StructV5 Public PgSeq As PGPTR Public Usage As Short Public Version As Short End Structure _ Structure StructV6 Public RecSig As Short Public SeqNbr As Short Public Usage As Integer End Structure _ Structure FCRTOP Public V5 as StructV5 Public V6 as StructV6 Public PagSize as Short End Structure Your other option would be to keep your structure as-is (and add the member for PagSize , of course) and simply change the name of Usage within v6 . However, taking this approach (with explicit struct declaration) will give you more meaningful syntax.
