[site]: stackoverflow
[post_id]: 921569
[parent_id]: 920929
[tags]: 
Hmm, first, you seem to be rolling a lot of your own stuff. I'd look into Boost::MPL to replace, say Base selection template, and to inherit over a vector with inherit. Second, you are using "const static bool hasSpeed = true;" a lot; In my programing, I usually prefer a typedefed trait, similar to Boost::type_traits . You can use them to select functions to run at compile time. You could avoid doing that "EmptyBase". template struct has_size; template struct has_size > : public true_type { }; template struct has_size > : public false_type { }; // given a particle typedef SomeParticle_t has_size ::value Third, a lot of what you are doing here depends on what you want your end usage to be; do you want the particles to be separate, types that can't be converted to each other? If you go this route, pretty much every function will be a template, and you could use boost::enable_if to disable code that doesn't apply to a given particle. It will be potentially very fast (since a lot of work happens at compile time), but you'll have gigantic, hard to read error statements (not very accessible for someone new to templates). Another, non template route would be inheritance; you would define a set of virtual functions that a particle needs, and then break those out into classes you inherit from. It's not quite clear from your code what you expect to be able to do with the Particle. The errors would be easier to understand, but the code potentially slower (more work shifted to runtime, and would make your objects bigger) Here's a code sample to illustrate the differences: // Using templates template typename boost::enable_if , typename particle::speed_type >::type calculate_future_speed(const particle& t) { /* do your acceleration calculation */ } template typename boost::enable_if , boost::not_ >, typename particle::speed_type >::type calculate_future_speed(const particle& t) { /* no acceleration, so no calculation! just return the speed*/ } template typename boost::enable_if , typename particle::speed_type >::type calculate_future_speed(const particle& t) { return 0; /* Has no speed, and no acceleration */ }
