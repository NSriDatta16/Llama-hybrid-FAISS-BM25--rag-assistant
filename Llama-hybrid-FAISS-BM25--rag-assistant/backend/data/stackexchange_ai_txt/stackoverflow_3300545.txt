[site]: stackoverflow
[post_id]: 3300545
[parent_id]: 3289804
[tags]: 
Joel, this is possible thanks to Code Query through LINQ capabilities (CQLinq). Here is a CQLinq query that detect deep mutability for property getters. For each getters that provokes mutability, the code query shows the set of fields assigned. // Restrict the iteration only on property getters // that are changing states or that call a method that changes state let propertyGetters = Application.Methods.Where(m => m.IsPropertyGetter) let methodsThatChangeState = Application.Methods.Where(m => m.ChangesObjectState || m.ChangesTypeState) from m in propertyGetters.DepthOfIsUsingAny(methodsThatChangeState).DefinitionDomain .Union(propertyGetters.Intersect(methodsThatChangeState)) // Find all methods called directly or indirectly by the property getter let methodsCalledIndirectly = m.MethodsCalled.FillIterative( methods => methods.SelectMany(m1 => m1.MethodsCalled)) .DefinitionDomain .Union(m.ToEnumerable()) // Gather all field assigned that are not generated by the compiler let fieldsAssigned = methodsCalledIndirectly .SelectMany(m1 => m1.FieldsAssigned) .Where(f => !f.IsGeneratedByCompiler) where fieldsAssigned.Any() orderby fieldsAssigned.Count() descending select new { m, fieldsAssigned } This query is complex, mainly because I optimized it, to first keep only getters that themselves changing state, or that are calling directly or indirectly a method that is changing state (call to DepthOfIsUsingAny() ). Then, for each of this getter, we build the set of all methods called directly or indirectly (thanks to a call to FillIterative() ), and we gather all fields assigned by all this method. Concretely the query result looks like:
