[site]: stackoverflow
[post_id]: 4779186
[parent_id]: 4779095
[tags]: 
Thats simple, try to use custom marshaling (especially if you want to use char** pointers). I found that you are no getting "Memory ass dumb" string, because of some improper realization of doRequest(char*,char**), as well as assigning to the result is not properly handled; Firstly, if you are allocating memory in unmanaged process and passes it to managed process, you will need declare some mechanism to free unmanaged memory. Managed GC does not know anything about this memory, which will be lost overwize. Secondy, you need to allocate memory for the results, and pass them to the unmanaged process, because the original memory locations can be rewritten in any time. Lastly, you are getting only the first characted of the input just because you are not allocated memory for the results, effectively passing only a memory pointer to the memory location of the first output character, say &array[0] Here is the compete code (MS VC++/MS C#), which fixes all the issues: lib.cpp: #include "stdafx.h" #include "lib.h" using namespace std; int func1(char* input, char** output) { stringstream xmlInputStream, xmlOutputStream; xmlInputStream (xmlOutputString.c_str()); long length = sizeof(char) * xmlOutputString.length(); char* src = const_cast (xmlOutputString.c_str()); char* dst = (char*)malloc(length+1); memcpy_s(dst, length, src, length); dst[length]=0; // 0 byte always ends up given ANSI string *output = dst; //cout Program.cs: using System; using System.Runtime.InteropServices; namespace test { class Program { [DllImport("lib.dll", EntryPoint = "func1", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern unsafe int func1(char* input, char** data); [DllImport("lib.dll", EntryPoint = "func1_cleanup", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)] public static extern unsafe int func1_cleanup(char* data); static void Main(string[] args) { string input = "Hello, World!"; string output; int result = func1(input, out output); } private const int S_OK = 0; public static int func1(string input, out string output) { unsafe { output = null; int result = -1; fixed (char* parray1 = &input.ToCharArray()[0]) { // // if you allocating memory in a managed process, you can use this // //char[] array = new char[0xffffff]; //fixed(char* parray = &array[0]) { // // if you allocating memory in unmanaged process do not forget to cleanup the prevously allocated resources // char* array = (char*)0; char** parray2 = &array; result = func1(parray1, parray2); if (result == S_OK) { // // if your C++ code returns the ANSI string, you can skip this extraction code block (it can be useful in Unicode, UTF-8, UTF-7, UTF-32, all C# supported encodings) // //byte* self = (byte*)*((int*)parray2); //byte* ptr = self; //List bytes = new List (); //do //{ // bytes.Add(*ptr++); //} //while (*ptr != (byte)0); //output = Encoding.ASCII.GetString(bytes.ToArray()); output = Marshal.PtrToStringAnsi(new IntPtr(*parray2)); } func1_cleanup(array); } } return result; } } } }
