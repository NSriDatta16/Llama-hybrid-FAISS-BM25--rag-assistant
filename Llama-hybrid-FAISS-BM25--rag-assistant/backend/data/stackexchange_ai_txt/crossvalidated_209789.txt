[site]: crossvalidated
[post_id]: 209789
[parent_id]: 
[tags]: 
Estimate the paramters of the simplest multiplicative error model

I am trying to implement the simplest multiplicative error model possible, to understand how it works. MEMs are time series model (introduced by Robert Engle), where instead of the components being additive, they are multiplicative. I am working from this ( http://www.nber.org/papers/w12690.pdf ) paper. I am using the simplest model, specified by equations (1), (6) and (11). I have put together the following R code to simulate the time series. alpha = 0.2 beta = 0.5 mu0 = 100000 gam = 100000 wholeSize = 10000 eps = rgamma(wholeSize,2,2) mu= mu0 x = mu0*eps[1] for (t in 2:length(eps)){ mu[t] = gam + x[t-1]*alpha + beta*mu[t-1] x[t] = mu[t] * eps[t] } Going from the first equation (which is not numbered) in section 2.2, I have put together the following R code which successfully estimates the scale parameter used in the gamma distribution for equation (6). tailSize = 1000 train = tail(1:wholeSize, tailSize) x = x[train] mu = mu[train] logLik.x = function(phi){ -sum(phi * log(phi) - log(gamma(phi)) + (phi-1)*log(x) - phi*(log(mu)+x/mu)) } a = optimize(logLik.x, c(1, 8)) print(a$minimum) Apparently equation (17) tells me how to estimate the parameters from equation (11), but I can't see how. I have attempted it with the following code sum.w = function(w, a, b){ mu.t = w s = 0 for (t in 2:length(x)){ mu.t_1 = mu.t mu.t = w + a*x[t-1] + b*mu.t_1 s = s + (x[t] - mu.t)/(mu.t^2) } s } sum.a = function(w, a, b){ mu.t = w s = 0 for (t in 2:length(x)){ mu.t_1 = mu.t mu.t = w + a*x[t-1] + b*mu.t_1 s = s + x[t-1]*(x[t] - mu.t)/mu.t^2 } s } sum.b = function(w, a, b){ mu.t = w s = 0 for (t in 2:length(x)){ mu.t_1 = mu.t mu.t = w + a*x[t-1] + b*mu.t_1 s = s + mu.t_1*(x[t] - mu.t)/mu.t^2 } s } fn_ = function(pars){ w=pars[1] a=pars[2] b=pars[3] abs(sum.w(w,a,b)) + abs(sum.a(w,a,b)) + abs(sum.b(w,a,b)) } a = optim(c(10,0.1,0.1), fn_, method = "L-BFGS-B", lower=c(100,0.01, 0.01), upper=c(999999999999, 0.99, 0.99)) print(a$par) fn_(a$par) fn_(c(100000, 0.2, 0.5)) The above doesn't quite work. I am expecting the optimized results of w = 100000, alpha = 0.2 and beta = 0.5. Instead I get w= 109, alpha = 0.29 and beta = 0.74. Also, plugging in the results of the optimizer into fn_ does indeed give a lower value than the true parameters so the optimizer did it's job correctly. The problem must be with the objective function fn_. But I can't see where. Any advice? PS: there is no tag for multiplicative error models (MEM). How do I create one?
