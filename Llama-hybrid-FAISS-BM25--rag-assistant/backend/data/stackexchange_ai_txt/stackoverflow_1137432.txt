[site]: stackoverflow
[post_id]: 1137432
[parent_id]: 1125301
[tags]: 
I'm going to provide some balance against the unanimous "no". DISCLAIMER: Yes, threads are complicated and can cause a whole bunch of problems. Everyone else has pointed this out. From experience, a sequence of blocking reads/writes to a socket (which requires a separate thead) is much simpler than non-blocking ones. With blocking calls, you can tell the state of the connection just by looking at where you are in the function. With non-blocking calls, you need a bunch of variables to record the state of the connection, and check and modify them every time you interact with the connection. With blocking calls, you can just say "read the next X bytes" or "read until you find X" and it will actually do it (or fail). With non-blocking calls, you have to deal with fragmented data which usually requires keeping temporary buffers and filling them as necessary. You also end up checking if you've received enough data every time you receive little more. Plus you have to keep a list of open connections and handle unexpected closes for all of them. It doesn't get much simpler than this: void WorkerThreadMain(Connection connection) { Request request = ReadRequest(connection); if(!request) return; Reply reply = ProcessRequest(request); if(!connection.isOpen) return; SendReply(reply, connection); connection.close(); } I'd like to note that this "listener spawns off a worker thread per connection" pattern is how web servers are designed, and I assume it's how a lot of request/response soft of server applications are designed. So in conclusion, I have experienced the asynchronous socket spaghetti code you mentioned, and spawning off worker threads for every connection ended up being a good solution. Having said all this, throwing threads at a problem should usually be your last resort.
