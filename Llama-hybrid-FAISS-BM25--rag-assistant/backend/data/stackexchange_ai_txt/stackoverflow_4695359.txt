[site]: stackoverflow
[post_id]: 4695359
[parent_id]: 
[tags]: 
How to texture glDrawElements

I have no Idea how I would texture something drawn by using glDrawElements? From what I gather you need to use glTexCoordPointer? but I'm still really confused. I'll put the whole program here so you can see what I'm doing public class DrawWater { public Expr2 func; // The function that is being drawn. private String functionInput; private boolean version_1_5; // Check is OpenGL 1.5 is available; set in init(). public boolean dataIsValid; // Set to true whenever data needs to be recomputed. public double xMax = 5; public double yMax = 5; private int[] textures = new int[3]; // Storage For 3 Textures // This is checked in the display() method before drawing. /* Buffers to hold the points and normals for the surface. */ private FloatBuffer vBuf = BufferUtil.newFloatBuffer(201 * 201 * 3); private FloatBuffer nBuf = BufferUtil.newFloatBuffer(201 * 201 * 3); /* Buffers to hold the indices for drawing the surface and lines with glDrawElements*/ private IntBuffer surfaceIndexBuffer = BufferUtil.newIntBuffer(200 * 201 * 2); private IntBuffer xLineIndexBuffer = BufferUtil.newIntBuffer(21 * 201); private IntBuffer yLineIndexBuffer = BufferUtil.newIntBuffer(21 * 201); /* VBO ID numbers for holding the data when OpenGL version is 1.5 or higher */ private int vertexVBO, normalVBO; // VBO IDs for surface data. private int xLineVBO, yLineVBO, surfaceVBO; // VBO IDs for index data. public DrawWater() { } public void setup(GL gl, String equ) { this.functionInput = equ; this.func = new Expr2(equ); } public void draw(GL gl) { version_1_5 = gl.isExtensionAvailable("GL_VERSION_1_5"); if (gl.isExtensionAvailable("GL_VERSION_1_3")) { gl.glEnable(GL.GL_MULTISAMPLE); } makeElementBuffers(); // Generate lists of indices for glDrawElements. This data never changes. if (version_1_5) { // Generate VBOs for the data, and fill the ones that are for index data with // data from Java nio buffers. The VBOs for index data won't change again and // so use GL.GL_STATIC_DRAW. int[] ids = new int[5]; gl.glGenBuffers(5, ids, 0); this.vertexVBO = ids[0]; this.normalVBO = ids[1]; this.xLineVBO = ids[2]; this.yLineVBO = ids[3]; this.surfaceVBO = ids[4]; gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vertexVBO); gl.glVertexPointer(3, GL.GL_FLOAT, 0, 0); gl.glBindBuffer(GL.GL_ARRAY_BUFFER, normalVBO); gl.glNormalPointer(GL.GL_FLOAT, 0, 0); gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0); gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, surfaceVBO); gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, 4 * 2 * 200 * 201, surfaceIndexBuffer, GL.GL_STATIC_DRAW); gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, xLineVBO); gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, 4 * 21 * 201, xLineIndexBuffer, GL.GL_STATIC_DRAW); gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, yLineVBO); gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, 4 * 21 * 201, yLineIndexBuffer, GL.GL_STATIC_DRAW); gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, 0); } else { gl.glVertexPointer(3, GL.GL_FLOAT, 0, vBuf); gl.glNormalPointer(GL.GL_FLOAT, 0, nBuf); } this.dataIsValid = false; // Force recomputation of data with new graph definition. if (func != null) { gl.glMaterialfv(GL.GL_FRONT, GL.GL_AMBIENT_AND_DIFFUSE, new float[]{0.7f, 0.7f, 1}, 0); gl.glMaterialfv(GL.GL_BACK, GL.GL_AMBIENT_AND_DIFFUSE, new float[]{0.8f, 0.8f, 0.5f}, 0); if (!dataIsValid) { this.computeSurfaceData(); if (version_1_5) { // Set up VBOs for surface points and normals. Since these change // pretty regularly, use GL.GL_DYNAMIC_DRAW. gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vertexVBO); gl.glBufferData(GL.GL_ARRAY_BUFFER, 4 * 3 * 201 * 201, vBuf, GL.GL_DYNAMIC_DRAW); gl.glBindBuffer(GL.GL_ARRAY_BUFFER, normalVBO); gl.glBufferData(GL.GL_ARRAY_BUFFER, 4 * 3 * 201 * 201, nBuf, GL.GL_DYNAMIC_DRAW); gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0); } } gl.glEnableClientState(GL.GL_VERTEX_ARRAY); gl.glEnableClientState(GL.GL_NORMAL_ARRAY); this.drawSurface(gl); // Just draw the surface. gl.glPolygonOffset(1, 1); gl.glEnable(GL.GL_POLYGON_OFFSET_FILL); this.drawSurface(gl); gl.glDisable(GL.GL_POLYGON_OFFSET_FILL); gl.glDisable(GL.GL_LIGHTING); gl.glColor3f(0, 0, 0); gl.glDisableClientState(GL.GL_NORMAL_ARRAY); gl.glEnable(GL.GL_LIGHTING); } gl.glDisableClientState(GL.GL_VERTEX_ARRAY); gl.glDisableClientState(GL.GL_NORMAL_ARRAY); } private void makeElementBuffers() { for (int i = 0; i Any help or advise would help I'm just confused ? Ya this is the array buffer int[] ids = new int[5]; gl.glGenBuffers(5, ids, 0); this.vertexVBO = ids[0]; this.normalVBO = ids[1]; this.xLineVBO = ids[2]; this.yLineVBO = ids[3]; this.surfaceVBO = ids[4]; gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vertexVBO); gl.glVertexPointer(3, GL.GL_FLOAT, 0, 0); gl.glBindBuffer(GL.GL_ARRAY_BUFFER, normalVBO); gl.glNormalPointer(GL.GL_FLOAT, 0, 0); gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0); gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, surfaceVBO); gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, 4 * 2 * 200 * 201, surfaceIndexBuffer, GL.GL_STATIC_DRAW); gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, xLineVBO); gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, 4 * 21 * 201, xLineIndexBuffer, GL.GL_STATIC_DRAW); gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, yLineVBO); gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, 4 * 21 * 201, yLineIndexBuffer, GL.GL_STATIC_DRAW); I can add the whole program if you'd like to see?
