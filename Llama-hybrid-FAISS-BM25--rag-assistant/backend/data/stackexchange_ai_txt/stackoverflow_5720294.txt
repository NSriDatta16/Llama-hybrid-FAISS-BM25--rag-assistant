[site]: stackoverflow
[post_id]: 5720294
[parent_id]: 5718941
[tags]: 
The fundamental problem is one that you've already identified: you're trying to memoize a function that accepts mutable arguments. This problem is very closely related to the reason python dict s don't accept mutable built-ins as keys. It's also a problem that's very simple to fix. Write a function that only accepts immutable arguments, memoize that, and then create a wrapper function that extracts the immutable values from the mutable objects. So... class Car(object): [ ... ] @memoize def _calculate_aa(self, capacity, weight): return capacity / weight def average_acceleration(self): return self._calculate_aa(self.engine.capacity, self.chassis.weight) Your other option would be to use property setters to update the value of average_acceleration whenever relevant values of Engine and Chassis are changed. But I think that might actually be more cumbersome than the above. Note that for this to work, you have to use new-style classes (i.e. classes that inherit from object -- which you should really be doing anyway). class Engine(object): def __init__(self): self._weight = None self.updated = False @property def weight(self): return self._weight @weight.setter def weight(self, value): self._weight = value self.updated = True Then in Car.average_acceleration() check whether engine.updated , recalculate aa if so, and set engine.updated to False. Pretty clunky, seems to me.
