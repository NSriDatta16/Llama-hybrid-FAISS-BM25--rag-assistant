[site]: stackoverflow
[post_id]: 2785905
[parent_id]: 2785755
[tags]: 
This seemed to me an semi-elegant solution. New Solution: import re reg = re.compile('(\'|").*?\\1') pp = re.compile('.*?;') def splitter(string): #add a last semicolon string += ';' replaces = [] s = string i = 1 #replace the content of each quote for a code for quote in reg.finditer(string): out = string[quote.start():quote.end()] s = s.replace(out, '**' + str(i) + '**') replaces.append(out) i+=1 #split the string without quotes res = pp.findall(s) #add the quotes again #TODO this part could be faster. #(lineal instead of quadratic) i = 1 for replace in replaces: for x in range(len(res)): res[x] = res[x].replace('**' + str(i) + '**', replace) i+=1 return res Old solution: I choose to match if there was an opening quote and wait it to close, and the match an ending semicolon. each "part" you want to match needs to end in semicolon. so this match things like this : 'foobar;.sska'; "akjshd;asjkdhkj..,"; asdkjhakjhajsd.jhdf; Code: mm = re.compile('''((?P '|")?.*?(?(quote)\\2|);)''') res = mm.findall('''part 1;"this is ; part 2;";'this is ; part 3';part 4''') you may have to do some postprocessing to res, but it contains what you want.
