[site]: stackoverflow
[post_id]: 4640057
[parent_id]: 4629734
[tags]: 
I know you explicitly stated that you were interested in a purely functional sieve implementation so I held off presenting my sieve until now. But upon re-reading the paper you referenced, I see the incremental sieve algorithm presented there is essentially the same as my own, the only difference being implementation details of using purely functional techniques versus decidedly imperative techniques. So I think I at least half-qualify in satisfying your curiosity. Moreover, I would argue that using imperative techniques when significant performance gains can be realized but hidden away by functional interfaces is one of the most powerful techniques encouraged in F# programming, as opposed to the everything pure Haskell culture. I first published this implementation on my Project Euler for F#un blog but re-publish here with pre-requisite code substituted back in and structural typing removed. primes can calculate the first 100,000 primes in 0.248 seconds and the first 1,000,000 primes in 4.8 seconds on my computer (note that primes caches its results so you'll need to re-evaluate it each time you perform a benchmark). let inline infiniteRange start skip = seq { let n = ref start while true do yield n.contents n.contents = {mutable c:'a ; p:'a ; mutable m:'a ; s:'a} ///A cached, infinite sequence of primes let primes = let primeList = ResizeArray () primeList.Add({c=3 ; p=3 ; m=9 ; s=9}) //test whether n is composite, if not add it to the primeList and return false let isComposite n = let rec loop i = let sp = primeList.[i] while sp.m n then primeList.Add({c=n ; p=n ; m=n*n ; s=n*n}) false else loop (i+1) loop 0 seq { yield 2 ; yield 3 //yield the cached results for i in 1..primeList.Count-1 do yield primeList.[i].p yield! infiniteRange (primeList.[primeList.Count-1].p + 2) 2 |> Seq.filter (isComposite>>not) }
