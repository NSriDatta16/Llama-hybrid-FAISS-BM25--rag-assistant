[site]: crossvalidated
[post_id]: 447334
[parent_id]: 447326
[tags]: 
The treatment-contrast default in R, which uses one level of a categorical predictor as reference and describes other levels in comparison against that reference, is not your only choice. This UCLA IDRE web page goes into detail on 9 different ways to set up a design matrix for categorical variables. As you "would like to see the effect of each level of the factor (as compared to the mean)," deviation coding would be the way to go. In R, the contr.sum() function provides the design matrix for deviation coding. Note, however, that you might need to be careful in interpreting those values. The overall mean of your data points will necessarily depend on the relative numbers and mean values of each of the groups, and might not necessarily be representative of what's going on in the population. With contr.sum() for deviation coding, the reported intercept against which levels are compared is instead the mean among all levels unweighted by the number in each group, as noted in the UCLA IDRE web page. Then again, that might not be representative of what's going on in the population. With 5 levels of a categorical predictor you will still only get 5 parameter values returned, that intercept and coefficients for differences of 4 of the 5 levels from the intercept. A simple work-around if you want to get a corresponding value for the reference level (the last level, with contr.sum() ) is to change the reference level of the factor and repeat the analysis. You will lose the coefficient for the new reference level but will gain that for the former reference level while the others remain the same. Some find the approaches provided by the emmeans package useful in situations involving unbalanced designs, as it weights all cells in a design equally. It has extensive facilities for analysis and prediction with many types of models, and the package author frequently visits this site. As a comment from @rvl points out, that package provides a particularly simple solution to your problem. After you use the emmeans() function on your regression model object m , the contrast() function applied to the resulting emmGrid object provides what you are looking for as the default contrast, eff.emmc , comparing all levels against the average over all levels.
