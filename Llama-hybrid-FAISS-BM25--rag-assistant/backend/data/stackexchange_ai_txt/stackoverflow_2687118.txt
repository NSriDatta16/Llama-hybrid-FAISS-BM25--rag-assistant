[site]: stackoverflow
[post_id]: 2687118
[parent_id]: 2679080
[tags]: 
Thank you Greg for your answer it happens the way you describe it. However, I am not pleased with this situation because it means that I have to place if(this == nullptr) throw gcnew ArgumentException("this"); at the beginning of every method. Only this would guarantee that my method won't appear at the top of stack-trace as a faulty piece of code without argument validation. I have never come across (this == null) when I was writing in C#. Therefore, I decided to find out how is it different from C++/CLI. I created a sample application in C++/CLI: namespace ThisEqualsNull{ public ref class A { public: void SampleMethod() { System::Diagnostics::Debug::Assert(this != nullptr); } }; public ref class Program{ public: static void Main(array ^args) { A^ a = nullptr; a->SampleMethod(); } }; } And a small program in C# that uses the C++/CLI classes with the same Main method: class Program { static void Main(string[] args) { A a = null; a.SampleMethod(); } } Then I disassembled them with Red Gate's .NET Reflector: C++/CLI .method public hidebysig static void Main(string[] args) cil managed { .maxstack 1 .locals ( [0] class ThisEqualsNull.A a) L_0000: ldnull L_0001: stloc.0 L_0002: ldnull L_0003: stloc.0 L_0004: ldloc.0 L_0005: call instance void ThisEqualsNull.A::SampleMethod() L_000a: ret } C# .method private hidebysig static void Main(string[] args) cil managed { .entrypoint .maxstack 1 .locals init ( [0] class [ThisEqualsNull]ThisEqualsNull.A a) L_0000: nop L_0001: ldnull L_0002: stloc.0 L_0003: ldloc.0 L_0004: callvirt instance void [ThisEqualsNull]ThisEqualsNull.A::SampleMethod() L_0009: nop L_000a: ret } The important parts are: C++/CLI L_0005: call instance void ThisEqualsNull.A::SampleMethod() C# L_0004: callvirt instance void [ThisEqualsNull]ThisEqualsNull.A::SampleMethod() Where: call - Calls the method indicated by the passed method descriptor. callvirt - Calls a late-bound method on an object, pushing the return value onto the evaluation stack. And now the final conclusion: C# compiler in VS 2008 treats every method as if it was virtual, thus it it always safe to assume that (this != null). In C++/CLI every method is called as it should so it is necessary to pay attention to the non-virtual method calls.
