[site]: crossvalidated
[post_id]: 141454
[parent_id]: 141250
[tags]: 
In general Wide format is (often) easier for us to read. Long format is often easier for computers to read. In R, for instance, the ggplot2 and lattice packages in R both depend somewhat heavily on getting your data into the "right" long form, which can sometimes be a matter of trial and error if you aren't comfortable with the process. Unfortunately I've never used Tableau (despite having had the free version on my computer for months) so I can't specifically comment on what works best in that program. It helps to think of every data visualization as a kind of generalized scatterplot. Just about anything that can vary, be it color, shape, or position on the page, can (in principle) be converted into a new orthogonal axis. Unfortunately, we puny humans can only imagine three such axes at a time, so we resort to the other codings to represent variation. In most data viz systems that I know of, there is a tight correspondence between "dimensions on the graph" and "columns in the spreadsheet." So if you want a variable to vary along an axis (like time), that something should vary within a single column. If you want to make a new axis for each level of a variable , then you should make a new column for each level. Again, the only possible exception I can imagine is for a situation where you want to, say, plot multiple time series on the same chart . But it's not really an exception. In principle, there is a different y axis for each year . We can just draw them on top of each other because they're on the same scale. Your case You will probably want to generate a visualization that looks something like the chart I linked to. The most natural format, in my opinion, would be something like this: |date | my.usage| util.avg.usage| nbhd.avg.usage| low.temp| high.temp| avg.temp| |:-----------|--------:|--------------:|--------------:|--------:|---------:|--------:| |Feb 1, 2015 | 36| 40| 31| 34| 58| 46| |Feb 2, 2015 | 37| 53| 43| 24| 42| 33| Each column is a dimension or axis along which data can vary. A good rule of thumb here might be: If you can say what unit something is measured with, you can probably position it along an axis Here we have units of "time", "usage", and "temperature." There are seven axes/dimensions/variables/columns here. We are free to plot all of them (bad), or we can start condensing them. Condensing axes is good, because the ultimate goal of any visualization is to make comparisons, and having putting two "data axes" on the same "graphical axis" greatly facilitates comparisons between the "data axes." For instance, to make a time series comparison of your usage with neighborhood average and utility average usage, you would typically put time (in days) on the X axis and usage (presumably in kWh) on the Y axis. Then you would draw a separate time series for each of my.usage , util.avg.usage , and nbhd.avg.usage . This is how you would do things in Microsoft Excel, base R, or MATLAB. However R packages ggplot2 and lattice use a somewhat different paradigm. Instead of thinking of each usage (yours, neighborhood average, utility average) as a separate dimension, in this paradigm usage type itself is a dimension . This is a little hard to wrap your head around, because you can't give usage a unit and it doesn't vary along an axis because its ordering is arbitrary. At times this paradigm can be a little restrictive, but within these restrictions it has a lot of intuitive appeal. To use these packages, your data could instead end up looking like this: |date |location | usage|temp.type | temp| |:-----------|:--------------|-----:|:---------|----:| |Feb 1, 2015 |my.usage | 36|low.temp | 34| |Feb 2, 2015 |my.usage | 37|low.temp | 24| |Feb 1, 2015 |util.avg.usage | 40|low.temp | 34| |Feb 2, 2015 |util.avg.usage | 53|low.temp | 24| |Feb 1, 2015 |nbhd.avg.usage | 31|low.temp | 34| |Feb 2, 2015 |nbhd.avg.usage | 43|low.temp | 24| |Feb 1, 2015 |my.usage | 36|high.temp | 58| |Feb 2, 2015 |my.usage | 37|high.temp | 42| |Feb 1, 2015 |util.avg.usage | 40|high.temp | 58| |Feb 2, 2015 |util.avg.usage | 53|high.temp | 42| |Feb 1, 2015 |nbhd.avg.usage | 31|high.temp | 58| |Feb 2, 2015 |nbhd.avg.usage | 43|high.temp | 42| |Feb 1, 2015 |my.usage | 36|avg.temp | 46| |Feb 2, 2015 |my.usage | 37|avg.temp | 33| |Feb 1, 2015 |util.avg.usage | 40|avg.temp | 46| |Feb 2, 2015 |util.avg.usage | 53|avg.temp | 33| |Feb 1, 2015 |nbhd.avg.usage | 31|avg.temp | 46| |Feb 2, 2015 |nbhd.avg.usage | 43|avg.temp | 33| Different programs use different terms for the operation of converting between wide and long formats. Microsoft Excel and SciPy call this "pivoting." R calls it "reshaping." The R packages reshape and reshape2 call this "melting" ($wide \rightarrow long$) and "casting" ($long \rightarrow wide$). R package tidyr uses "gather" to mean "melt" and "spread" to mean "cast." Interestingly, the creator of reshape / reshape2 is also the creator of tidyr . And by the way, here is how I generated these tables in R: library(dplyr) library(tidyr) library(knitr) d % kable d %>% gather_("location", "usage", gather_cols = 2:4) %>% gather_("temp.type", "temp", 2:4) %>% kable
