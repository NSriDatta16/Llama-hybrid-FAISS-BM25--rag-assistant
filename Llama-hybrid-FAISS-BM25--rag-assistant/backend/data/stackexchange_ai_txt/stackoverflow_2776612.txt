[site]: stackoverflow
[post_id]: 2776612
[parent_id]: 2679698
[tags]: 
It may not work exactly like this under the hood, but here's the way I conceptualize it: When you summon an object from a DataContext, one of the things Linq does is track the changes to this object over time so it knows what to save back if you submit changes. If you lose this original data context, the Linq object summoned from it doesn't have the history of what has changed in it from the time it was summoned from the DB. For example: DbDataContext db = new DbDataContext(); User u = db.Users.Single( u => u.Id == HARD_CODED_GUID ); u.FirstName = "Foo"; db.SubmitChanges(); In this case since the User object was summoned from the data context, it was tracking all the changes to "u" and knows how to submit those changes to the DB. In your example, you had a User object that had been persisted somewhere (or passed from elsewhere and do not have it's original DataContext it was summoned from). In this case, you must attach it to the new data context. User u; // User object passed in from somewhere else DbDataContext db = new DbDataContext(); u.FirstName = "Foo"; DbDataContext.Users.Attach( u ); db.SubmitChanges(); Since the relationship between user and organization is just a GUID (OrganizationId) in your data model, you only have to attach the user object. I'm not sure about your scaffolding code, but maybe something like this: private const Guid DEFAULT_ORG = new Guid("3cbb9255-1083-4fc4-8449-27975cb478a5"); public void Save(User user) { if (!DataContext.Users.Contains(user)) { user.Id = Guid.NewGuid(); user.CreatedDate = DateTime.Now; user.Disabled = false; user.OrganizationId = DEFAULT_ORG; // make the foreign key connection just // via a GUID, not by assigning an // Organization object DataContext.Users.InsertOnSubmit(user); } else { DataContext.Users.Attach(user); } DataContext.SubmitChanges(); }
