[site]: stackoverflow
[post_id]: 3902788
[parent_id]: 3900870
[tags]: 
To do this with HTML::TreeBuilder , you would read the file, modify the tree, and write it out (to the same file, or a different file). This is fairly complex, because you're trying to convert part of a text node into a tag, and because you have comments that can't move. A common idiom with HTML-Tree is to use a recursive function that modifies the tree: use strict; use warnings; use 5.008; use File::Slurp 'read_file'; use HTML::TreeBuilder; sub replace_keyword { my $elt = shift; return if $elt->is_empty; $elt->normalize_content; # Make sure text is contiguous my $content = $elt->content_array_ref; for (my $i = 0; $i [$i]) { # It's a child element, process it recursively: replace_keyword($content->[$i]) unless $content->[$i]->tag eq 'a'; # Don't descend into } else { # It's text: if ($content->[$i] =~ /here/) { # your keyword or regexp here $elt->splice_content( $i, 1, # Replace this text element with... substr($content->[$i], 0, $-[0]), # the pre-match text # A hyperlink with the keyword itself: [ a => { href => 'http://example.com' }, substr($content->[$i], $-[0], $+[0] - $-[0]) ], substr($content->[$i], $+[0]) # the post-match text ); } # end if text contains keyword } # end else text } # end for $i in content index } # end replace_keyword my $content = read_file('foo.shtml'); # Wrap the SHTML fragment so the comments don't move: my $html = HTML::TreeBuilder->new; $html->store_comments(1); $html->parse(" $content "); my $body = $html->look_down(qw(_tag body)); replace_keyword($body); # Now strip the wrapper to get the SHTML fragment back: $content = $body->as_HTML; $content =~ s!^ \n?!!; $content =~ s! \s*\z!!; print STDOUT $content; # Replace STDOUT with a suitable filehandle The output from as_HTML will be syntactically correct HTML, but not necessarily nicely-formatted HTML for people to view the source of. You can use HTML::PrettyPrinter to write out the file if you want that.
