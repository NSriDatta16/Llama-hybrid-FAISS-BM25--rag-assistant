[site]: stackoverflow
[post_id]: 3867315
[parent_id]: 
[tags]: 
Unit Testing - Arranging objects that are inaccessible to the test project

I am writing a card game in an attempt to learn Silverlight. I have domain representation of the game which is exposed to Silverlight as a WCF service and the only public method on my Game object is "PlayCards". Which is a method that looks like this public void PlayCards(Guid playerId, List cards) When this method is invoked, the Game object is updated and transmitted to all the clients using a duplex binding There are lots of scenarios I need to unit test (doing it via the UI is becoming really tedious, especially as there are lots of scenarios that don't occur naturally that often). However, to do so would mean making various properties public that really don't need to be (except for my testing purposes) Here's some specifics: I have a game class that contains a list of players : public class Game { public List Players { get { return _players; } } ... The Player class has a Hand public class Player { public Hand Hand { get; internal set; } ... The Hand class has various parts public class Hand { public List FaceDownCards { get; internal set; } public List FaceUpCards { get; internal set; } public List InHandCards { get; internal set; } Now, in my unit tests I want to set up various scenarios where one player has certain cards, and the next player has certain cards. Then have the first player play some cards (via the public PlayCards method) and then Assert on the game state But of course, as Players is a read only property I can't do this. Likewise Hand (on Player) is inaccessible. Likewise the parts of the hand. Any ideas how I can set this up? I guess this might mean my design is wrong? thanks EDIT: Here's what some classes look like to give you an idea of some of the properties I want to Assert on after cards have been played I have changed the private setters to internal for the moment while I experiment with InternalsToVisible, but am interested what the pure TDD way of doing things would be public class Game { public List Players { get; internal set; } public Deck Deck { get; internal set; } public List PickUpPack { get; internal set; } public CardList ClearedCards { get; internal set; } public Player CurrentPlayer { get { return Players.SingleOrDefault(o => o.IsThisPlayersTurn); } } internal Direction Direction { get; set; } .. public class Player { public Guid Id { get; internal set; } public Game CurrentGame { get; internal set; } public Hand Hand { get; internal set; } public bool IsThisPlayersTurn { get; internal set; } public bool IsAbleToPlay { get; internal set; } public string Name { get; internal set; } ... public class Hand { public List FaceDownCards { get; internal set; } public List FaceUpCards { get; internal set; } public List InHandCards { get; internal set; } ...
