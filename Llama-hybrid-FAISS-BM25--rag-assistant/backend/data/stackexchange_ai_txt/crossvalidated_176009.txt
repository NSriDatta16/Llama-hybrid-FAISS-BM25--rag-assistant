[site]: crossvalidated
[post_id]: 176009
[parent_id]: 
[tags]: 
Robustness Weights in LOESS behaving strangely

I've been playing around with writing my own LOESS module in Python (2 reasons: first, I wanted the practice, and second, the implementation in statsmodels doesn't compute confidence intervals). The implementation is based primarily on the original LOESS paper (Cleveland, 1988, Journal of the American Statistical Association ) and on this presentation from Michigan State (linked in the code comments). All went well until I tried implementing the robustness weights (see slides 18-19 in the presentation). The completely mess-up the smoothing. As an example, I downloaded debt-to-GDP data from FRED to smooth. After the first iteration (before robustness weights are applied), it smoothes rather well: However, after just two additional iteration with the robustness weights, here's what starts to happen: Do you have any idea what might be going on? I suspect there is something wrong with the robustness weights vector, or with the way I multiply the weights, but I can't figure it out. Here's the code: import numpy as np import matplotlib.pyplot as plt class LoessPy: def __init__(self, X, Y, m = 0.3, p = 3, t = 10., iters=50): #where X and Y are numpy arrays self.X = X self.Y = Y self.m = m self.p = p self.t = t self.iter = iters self.mad = 0 self.cost = 0 self.n = len(X) self.window = np.int(np.floor(self.n*m)) self.weights = np.zeros((self.n, self.n)) self.Yhat = np.zeros_like(Y) self.res = np.zeros_like(Y) self.res_weights = np.ones_like(Y) self.betas = np.zeros_like(self.weights) def find_neighbors(self, x): diffs = np.empty((self.n, 2)) diffs[:,1] = np.abs(self.X - x) diffs[:,0] = range(self.n) d_sorted = diffs[diffs[:,1].argsort()] n_indices = d_sorted[range(self.window),0] return n_indices.astype(int), self.X[n_indices.tolist()] def weight_cubic(self, x0, x1, span): z = (x0-x1)/(span/2.) return (1-(abs(z)**3))**3 if abs(z) Thanks in advance!
