[site]: stackoverflow
[post_id]: 318343
[parent_id]: 318236
[tags]: 
This looks deceptively simple but has a few pitfalls. For example, many of the solutions posted in the previous answers assume that the quads are in base 10 - but a quad starting with a zero must be treated as a base 8 (octal) number, hence for example any quad part starting with zero and containing the digits 8 or 9 is not valid. I.e, the IP number 192.168.1.010 is not 192.168.1.10 but in reality is 192.168.1.8 , and the IP number 192.168.019.14 is not valid since the third quad contains the invalid base 8 digit 9. I emphatically encourage you to use the functions provided by the socket library included in your operating system or compiler environment. Edit: (Thought it was implicit, but) of course, you can also have hexadecimal quads, a la 192.168.1.0x0A for 192.168.1.10, and of course you can mix and match to your sadistic content happily using upper and lower case, a la 0xC0.0xa8.1.010 for 192.168.1.8. Try some examples using ping if you want to have fun. This works just fine cross-platform (tested a while back while swearing under Linux, NetBSD, and Win32.) Further edit in response to KaluSingh Gabbar's request: For example, you can specify 192.168.1.10 as 0xc0a8010a and it still represents a valid IP number, a la: [mihailim@home ~]$ ping 0xc0a8010a PING 0xc0a8010a (192.168.1.10) 56(84) bytes of data. ^C --- 0xc0a8010a ping statistics --- 3 packets transmitted, 0 received, 100% packet loss, time 2479ms
