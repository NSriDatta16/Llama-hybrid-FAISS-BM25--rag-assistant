[site]: stackoverflow
[post_id]: 1586891
[parent_id]: 1581256
[tags]: 
If You like "programming" in combinatory logic , then You can automatically "translate" some logic problems into another field: proving equality of combinatory logic terms. With a good functional programming practice, You can solve that, and afterwards, You can translate the answer back to a Hilbert style proof of Your original logic problem. The possibility of this translation in ensured by Curry-Howard correspondence . Unfortunately, the situation is so simple only for a subset of (propositional) logic: restricted using conditionals. Negation is a complication, I know nothing about that. Thus I cannot answer this concrete question: ¬ ( α ⊃ ¬ β ) ⊢ α But in cases where negation is not part of the question, the mentioned automatic translation (and back-translation) can be a help, provided that You have already practice in functional programming or combinatory logic. Of course, there are other helps, too, where we can remain inside the realm of logic: proving the problem in some more intuitive deductive system (e.g. natural deduction ) and afterwards using metatheorem s that provide a "compiler" possibility: translating the "high-level" proof of natural deduction to the "machine-code" of Hilbert-style deduction system. I mean, for example, the metalogical theorem called " deduction theorem ". As for theorem provers, as far as I know, the capabilities of some of them are extended so that they can harness interactive human assistance. E.g. Coq is such. Appendix Let us see an example. How to prove α ⊃ α ? Hilbert system Verum ex quolibet α , β is assumed as an axiom scheme, stating that sentence α ⊃ β ⊃ α is expected to be deducible, instantiated for any subsentences α , β Chain rule α , β , γ is assumed as an axiom scheme, stating that sentence ( α ⊃ β ⊃ γ ) ⊃ ( α ⊃ β ) ⊃ α ⊃ γ is expected to be deducible, instantiated for any subsentences α , β Modus ponens is assumed as a rule of inference: provided that α ⊃ β is deducible, and also α is deducible, then we expect to be justified to infer that also α ⊃ β is deducible. Let us prove theorem: α ⊃ α is deducible for any α proposition. Let us introduce the following notations and abbreviations, developing a "proof calculus": Proof calculus VEQ α , β : ⊢ α ⊃ β ⊃ α CR α , β , γ : ⊢ ( α ⊃ β ⊃ γ ) ⊃ ( α ⊃ β ) ⊃ α ⊃ γ MP : If ⊢ α ⊃ β and ⊢ α , then also ⊢ β A tree diagram notation: Axiom scheme — Verum ex quolibet: ━━━━━━━━━━━━━━━━━ [ VEQ α , β ] ⊢ α ⊃ β ⊃ α Axiom scheme — chain rule: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ [ CR α , β , γ ] ⊢ ( α ⊃ β ⊃ γ ) ⊃ ( α ⊃ β ) ⊃ α ⊃ γ Rule of inference — modus ponens: ⊢ α ⊃ β ⊢ α ━━━━━━━━━━━━━━━━━━━ [ MP ] ⊢ β Proof tree Let us see a tree diagram representation of the proof: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━ [ CR α , α ⊃ α , α ] ━━━━━━━━━━━━━━━ [ VEQ α , α ⊃ α ] ⊢ [ α ⊃( α ⊃ α )⊃ α ]⊃( α ⊃ α ⊃ α )⊃ α ⊃ α ⊢ α ⊃ ( α ⊃ α ) ⊃ α ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ [ MP ] ━━━━━━━━━━━ [ VEQ α , α ] ⊢ ( α ⊃ α ⊃ α ) ⊃ α ⊃ α ⊢ α ⊃ α ⊃ α ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ [ MP ] ⊢ α ⊃ α Proof formulae Let us see an even conciser (algebraic? calculus?) representation of the proof: ( CR α , α ⊃ α , α VEQ α , α ⊃ α ) VEQ α , α : ⊢ α ⊃ α so, we can represent the proof tree by a single formula: the forking of the tree (modus ponens) is rendered by simple concatenation (parentheses), and the leaves of the tree are rendered by the abbreviations of the corresponding axiom names. It is worth of keep record about the concrete instantiation, that' is typeset here with subindexical parameters. As it will be seen from the series of examples below, we can develop a proof calculus , where axioms are notated as sort of base combinators , and modus ponens is notated as a mere application of its "premise" subproofs: Example 1 VEQ α , β : ⊢ α ⊃ β ⊃ α meant as Verum ex quolibet axiom scheme instantiated with α , β provides a proof for the statement, that α ⊃ β ⊃ α is deducible. Example 2 VEQ α , α : ⊢ α ⊃ α ⊃ α Verum ex quolibet axiom scheme instantiated with α , α provides a proof for the statement, that α ⊃ α ⊃ α is deducible. Example 3 VEQ α , α ⊃ α : ⊢ α ⊃ ( α ⊃ α ) ⊃ α meant as Verum ex quolibet axiom scheme instantiated with α , α ⊃ α provides a proof for the statement, that α ⊃ ( α ⊃ α ) ⊃ α is deducible. Example 4 CR α , β , γ : ⊢ ( α ⊃ β ⊃ γ ) ⊃ ( α ⊃ β ) ⊃ α ⊃ γ meant as Chain rule axiom scheme instantiated with α , β , γ provides a proof for the statement, that ( α ⊃ β ⊃ γ ) ⊃ ( α ⊃ β ) ⊃ α ⊃ γ is deducible. Example 5 CR α , α ⊃ α , α : ⊢ [ α ⊃ ( α ⊃ α ) ⊃ α ] ⊃ ( α ⊃ α ⊃ α ) ⊃ α ⊃ α meant as Chain rule axiom scheme instantiated with α , α ⊃ α , α provides a proof for the statement, that [ α ⊃ ( α ⊃ α ) ⊃ α ] ⊃ ( α ⊃ α ⊃ α ) ⊃ α ⊃ α is deducible. Example 6 CR α , α ⊃ α , α VEQ α , α ⊃ α : ⊢ ( α ⊃ α ⊃ α ) ⊃ α ⊃ α meant as If we combine CR α , α ⊃ α , α and VEQ α , α ⊃ α together via modus ponens , then we get a proof that proves the following statement: ( α ⊃ α ⊃ α ) ⊃ α ⊃ α is deducible. Example 7 ( CR α , α ⊃ α , α VEQ α , α ⊃ α ) VEQ α , α : ⊢ α ⊃ α If we combine the compund proof ( CR α , α ⊃ α , α ) together with VEQ α , α ⊃ α (via modus ponens ), then we get an even more compund proof. This proves the following statement: α ⊃ α is deducible. Combinatory logic Although all this above has indeed provided a proof for the expected theorem, but it seems very unintuitive. It cannot be seen how people can "find out" the proof. Let us see another field, where similar problems are investigated. Untyped combinatory logic Combinatory logic can be regarded also as an extremely minimalistic functional programming language. Despite of its minimalism, it entirely Turing complete, but evenmore, one can write quite intuitive and complex programs even in this seemingly obfuscated language, in a modular and reusable way, with some practice gained from "normal" functional programming and some algebraic insights, . Adding typing rules Combinatory logic also has typed variants. Syntax is augmented with types, and evenmore, in addition to reduction rules, also typing rules are added. For base combinators: K α , β is selected as a basic combinator, inhabiting type α → β → α S α , β , γ is selected as a basic combinator, inhabiting type ( α → β → γ ) → ( α → β ) → α → γ . Typing rule of application: If X inhabits type α → β and Y inhabits type α , then X Y inhabits type β . Notations and abbreviations K α , β : α → β → α S α , β , γ : ( α → β → γ ) → ( α → β )* → α → γ . If X : α → β and Y : α , then X Y : β . Curry-Howard correspondence It can be seen that the "patterns" are isomorphic in the proof calculus and in this typed combinatory logic. The Verum ex quolibet axiom of the proof calculus corresponds to the K base combinator of combinatory logic The Chain rule axiom of the proof calculus corresponds to the S base combinator of combinatory logic The Modus ponens rule of inference in the proof calculus corresponds to the operation "application" in combinatory logic. The "conditional" connective ⊃ of logic corresponds to type constructor → of type theory (and typed combinatory logic) Functional programming But what is the gain? Why should we translate problems to combinatory logic? I, personally, find it sometimes useful, because functional programming is a thing which has a large literature and is applied in practical problems. People can get used to it, when forced to use it in erveryday programming tasks ans pracice. And some tricks and hints of functional programming practice can be exploited very well in combinatory logic reductions. And if a "transferred" practice develops in combinatory logic, then it can be harnessed also in finding proofs in Hilbert system. External links Links how types in functional programming (lambda calculus, combinatory logic) can be translated into logical proofs and theorems: Wadler, Philip (1989). Theorems for free! . Links (or books) how to learn methods and practice to program directly in combinatory logic: Madore, David (2003). The Unlambda Programming Language. Unlambda: Your Functional Programming Language Nightmares Come True . Curry, Haskell B. & Feys, Robert & Craig, William (1958). Combinatory Logic . Vol. I . Amsterdam: North-Holland Publishing Company. Tromp, John (1999). Binary Lambda Calculus and Combinatory Logic . Downloadable in PDF and Postscript from the author's John's Lambda Calculus and Combinatory Logic Playground .
