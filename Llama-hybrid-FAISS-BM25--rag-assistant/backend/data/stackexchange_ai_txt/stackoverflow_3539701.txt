[site]: stackoverflow
[post_id]: 3539701
[parent_id]: 3528524
[tags]: 
To start with, you should bench your application in a real environment using load testing tools, you can't really make valid conclusions from the behavior you observe in your IDE. On top of that don't forget that profiling actually alters performances. I. Logging (...) The problem with the slow logging was solved after switching from Netbeans 6.8 to Netbeans 6.9.1 That's the first proof you can't use trust the behavior inside your IDE. II. DB Operation: The first time i call the find Method of the following EJB it takes 2,4 s! Additional calls last only some ms. So why takes the first operation that long? Maybe because some GlassFish services are (lazy) loaded, maybe because the stateless session beans (SLSB) have to be instantiated, maybe because the EntityManagerFactory has to be created. What did the profiling say? Why do you see when activating app server logging? And what's the problem since subsequent calls are ok? III. Dependency Injection, JNDI Lookup: Is there a difference beetween DI like (@EJB ...) and InitialContext lookups concerncing performance? JNDI lookups are expensive and it was a de facto practice to use some caching in the good old service locator. I thus don't expect the performances to be worst when using DI (I actually expect the container to be good at it). And honestly, it has never been a concern for me. When you work on performance optimization, the typical workflow is 1) detect a slow operation 2) find the bottleneck 2) work on it 3) if the operation is still not fast enough, go back to 2). To my experience, the bottleneck is 90% of the time in the DAL. If your bottleneck is DI, you have no performance problem IMO. In other words, I think you're worrying too much and you're very close to "premature optimization". IV. Managed Beans - I use many Session Scoped Beans, because the ViewScope seems to be very buggy and Request Scoped is not always practically. Is there an alternative? - because these Beans are not slow but the server side memory is stressed during a whole session. And when a user logs out it takes some time! I don't see any question :) So I don't have anything to say. Update (answering a comment): Using a conversation scope might be indeed less expensive. But as always, measure. V. EJBs - I don't use MDB only Session Beans and Singleton Beans. Often they inject other Beans with the @EJB Annotation. One Singleton Bean use @Schedule Annotations to start repeatedly operations. A interesting thing i found is that since EJB 3.1 you can use the @Asynchronous Annotation to make Session Bean Method's asynchronous. What should i generally consider when implementing EJBs concerning performance? SLSBs (and MDBs) perform very well in general. But here are some points to keep in mind when using SLSBs: Prefer Local over Remote interfaces if your clients and EJBs are collocated to avoid the overhead of remote calls. Use Stateful Session Beans (SFSB) only if necessary (they are harder to use, managing state has a performance cost and they don't scale very well by nature). Avoid chaining EJBs too much (especially if they are remote), prefer coarse grained methods over multiple fine-grained methods invocation. Tune the SLSB pool (so that you have just enough beans to serve your concurrent clients, but not too much to avoid wasting resources). Use transactions appropriately (e.g. use NOT_SUPPORTED for read only methods). I would also suggest to not use something unless you really need the feature and there is a real problem to solve (e.g. @Asynchronous). Maybe someone could give me some general and/or specific tips to increase the performance of javaee applications, especially concerning the above issues. Thanks! Focus on your data access code, I'm pretty sure this represents 80% of the execution time of most business flows. And as I already hinted, are you sure that you actually have a performance problem? I'm not convinced. But if you really are, measure performances outside your IDE.
