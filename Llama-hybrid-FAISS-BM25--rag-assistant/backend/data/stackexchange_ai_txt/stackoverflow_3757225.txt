[site]: stackoverflow
[post_id]: 3757225
[parent_id]: 3757126
[tags]: 
Assuming I understand the question, in F# you can define expressions which depend on the availability of members with particular signatures. For instance let inline f x a = (^t : (member Method : ^a -> unit)(x,a)) This defines a function f which takes a value x of type ^t and a value a of type ^a where ^t has a method Method taking an ^a to unit ( void in C#), and which calls that method. Because this function is defined as inline , the definition is inlined at the point of use, which is the only reason that it can be given such a type. Thus, although you can pass f as a first class function, you can only do so when the types ^t and ^a are statically known so that the method call can be statically resolved and inserted in place (and this is why the type parameters have the funny ^ sigil instead of the normal ' sigil). Here's an example of passing f as a first-class function: type T() = member x.Method(i) = printfn "Method called with int: %i" i List.iter (f (new T())) [1; 2; 3] This runs the method Method against the three values in the list. Because f is inlined, this is basically equivalent to List.iter ((fun (x:T) a -> x.Method(a)) (new T())) [1; 2; 3] EDIT Given the context that seems to have led to this question ( C# - How can I “overload” a delegate? ), I appear not to have addressed your real question at all. Instead, what Gabe appears to be talking about is the ease with which one can define and use discriminated unions. So the question posed on that other thread might be answered like this using F#: type FunctionType = | NoArgument of (unit -> unit) | ArrayArgument of (obj[] -> unit) let doNothing (arr:obj[]) = () let doSomething () = printfn "'doSomething' was called" let mutable someFunction = ArrayArgument doNothing someFunction f() | ArrayArgument f -> f [| |] // pass in empty array At a low level, there's no CIL magic going on here; it's just that NoArgument and ArrayArgument are subclasses of FunctionType which are easy to construct and to deconstruct via pattern matching. The branches of the pattern matching expression are morally equivalent to a type test followed by property accesses, but the compiler makes sure that the cases have 100% coverage and don't overlap. You could encode the exact same operations in C# without any problem, but it would be much more verbose and the compiler wouldn't help you out with exhaustiveness checking, etc. Also, there is nothing here which is particular to functions; F# discriminated unions make it easy to define types which have a fixed number of named alternatives, each one of which can have data of whatever type you'd like.
