[site]: stackoverflow
[post_id]: 4067457
[parent_id]: 4067435
[tags]: 
I'm not entirely certain what you're asking but if it's how to get the string representation of the integer at offset 6, you can do it as a two-step: char str[enough_to_hold_datalen_and_then_some]; int val = atoi (input+6); sprintf (str, "%d", val); Alternatively, if you want to get a chunk of the string regardless of whether it's made up of digits: strcpy (str, input+6); // get the rest of the string strncpy (str, input+6, 4); str[4] = '\0'; // get up to four characters. If your problem is that input is a local variable to the function and, when you return its address, you get bogus data because it's gone out of scope, I'd use: return strdup (input+6); That will return a copy of the string on the heap (which is long-lived as opposed to the stack frame, which is not). Just remember that you need to free that memory when you're finished with it. And be certain that you actually have six characters in that buffer. If your C implementation doesn't have a strdup , use this one . Based on your update, it looks like you're after that last option. With your code: char *r_str; strcpy (r_str, input+6); return r_str; you are not actually allocating any storage to put the string copy (hence the crash). I would replace that whole bit with a simple: return strdup (input+6); as I suggested. Ha, ha, gotta love those Linux man page writers : If the destination string of a strcpy() is not large enough (that is, if the programmer was stupid/lazy, and failed to check the size before copying) then anything might happen. Overflowing fixed length strings is a favourite cracker technique.
