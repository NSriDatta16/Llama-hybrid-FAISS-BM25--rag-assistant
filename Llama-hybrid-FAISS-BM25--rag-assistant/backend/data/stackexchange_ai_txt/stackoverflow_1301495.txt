[site]: stackoverflow
[post_id]: 1301495
[parent_id]: 
[tags]: 
Is there a *clean* way to make a read-only dependency-property reflect the value of another property?

The code below is my current solution. A great example of what I am trying to mimic would be the FrameworkElement.ActualWidth property. You know how the ActualWidth property is calculated and reassigned, whenever the Width property changes, or whenever the control is redrawn, or whenever else? ------ From the developer's perspective, it just looks like data-binding hard-at-work. But ActualWidth is a read-only dependency-property. Does Microsoft really have to go through this gigantic trash-hole of code to make that work? Or is there a simpler way that utilizes the existing functionality of the data-binding system? public class foo : FrameworkElement { [ValueConversion(typeof(string), typeof(int))] public class fooConverter : IValueConverter { public object Convert( object value, Type targetType, object parameter, CultureInfo culture) { ... } public object ConvertBack( object value, Type targetType, object parameter, CultureInfo culture) { ... } } private static readonly fooConverter fooConv = new fooConverter(); private static readonly DependencyPropertyKey ReadOnlyIntPropertyKey = DependencyProperty.RegisterReadOnly( "ReadOnlyInt", typeof(int), typeof(foo), null); public int ReadOnlyInt { get { return (int)GetValue(ReadOnlyIntPropertyKey.DependencyProperty); } } public static readonly DependencyProperty ReadWriteStrProperty = DependencyProperty.Register( "ReadWriteStr", typeof(string), typeof(foo), new PropertyMetadata(ReadWriteStr_Changed)); public string ReadWriteStr { get { return (string)GetValue(ReadWriteStrProperty); } set { SetValue(ReadWriteStrProperty, value); } } private static void ReadWriteStr_Changed( DependencyObject d, DependencyPropertyChangedEventArgs e) { try { if (d is foo) { foo f = d as foo; f.SetValue( ReadOnlyIntPropertyKey, fooConv.Convert(f.ReadWriteStr, typeof(int), null, CultureInfo.CurrentCulture)); } } catch { } } }
