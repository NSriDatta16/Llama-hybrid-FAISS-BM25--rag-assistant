[site]: stackoverflow
[post_id]: 3773497
[parent_id]: 3773403
[tags]: 
You're better off using a library like MoreLinq , but if you really had to do this using "plain LINQ", you can use GroupBy : var sequence = new[] {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}; var result = sequence.Select((x, i) => new {Group = i/8, Value = x}) .GroupBy(item => item.Group, g => g.Value) .Select(g => g.Where(x => true)); // result is: { {1,2,3,4,5,6,7,8}, {9,10,11,12,13,14,15,16} } Basically, we use the version of Select() that provides an index for the value being consumed, we divide the index by 8 to identify which group each value belongs to. Then we group the sequence by this grouping key. The last Select just reduces the IGrouping<> down to an IEnumerable > (and isn't strictly necessary since IGrouping is an IEnumerable ). It's easy enough to turn this into a reusable method by factoring our the constant 8 in the example, and replacing it with a specified parameter. It's not necessarily the most elegant solution, and it is not longer a lazy, streaming solution ... but it does work. You could also write your own extension method using iterator blocks ( yield return ) which could give you better performance and use less memory than GroupBy . This is what the Batch() method of MoreLinq does IIRC.
