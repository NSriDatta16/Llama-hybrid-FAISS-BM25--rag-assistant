[site]: stackoverflow
[post_id]: 4354819
[parent_id]: 4354611
[tags]: 
To use their example, you might have a window class which can be scrolled and/or have its border painted in various ways (or not at all). If you were to use inheritance to cover all these features, you'd need one subclass for every feasible combination of features (no border no scrolling, border without scrolling, scrolling without border, border and scrolling etc.). This is an inflexible maintenance nightmare as you add more features because there's an explosion in the number of classes. The main point they're making here is that you can use either the strategy pattern or the decorator pattern to better solve this problem. You could have a Window class which encapsulates a scrolling strategy object and a border strategy object. Or you could take your Window object, wrap it inside a border decorator and wrap that inside a scrolling decorator. But you're completely right in your understanding; these are two different design patterns with different characteristics which lead to different applications. With Decorator, the Component has no knowledge of the agent which is adding functionality... and so you tend to end up building around an existing component class. With Strategy, it's the other way around since the Component is employing (and hence knows about) agents to perform various tasks - these agents generally don't know about their governing Components.
