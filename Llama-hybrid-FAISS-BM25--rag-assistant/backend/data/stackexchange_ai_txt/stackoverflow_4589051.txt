[site]: stackoverflow
[post_id]: 4589051
[parent_id]: 4580862
[tags]: 
Just a few suggestions, based on general info provided here, w/out knowing specifics on what your application actually does or will be doing. use sha1 of the file as a file name (if needed, store user-supplied file name in DB) the thing is that if you care about the data, you would have to store a checksum anyways. If you use sha1 (sha256,md5,other hash) it then will be easy validate file data -- read file, cacl hash, if it matches the name then the data is valid. Assuming that this is a webapp of some kind, hash-based file name can be used as etag when serving data. (check your .git directory for an example on this). This assumes that you cannot use user-supplied file name anyways, as user can send something like "<>?:().txt" use directory structure that makes sense from your app standpoint the main test here is that that it should be possible to identify a file just by looking at PATH\FILE alone, w/out doing metadata lookup in DB. If you store/access patterns are strictly time-based then STORE\DATE\HH\FILE would make sense, if you have files that are owned by users, then perhaps STORE\ \UID\FILE would make sense. use transactions for file/metadata operations i.e. start write file metadata trx, try writing a file to FS, on success commit trx, rollback on error. The utmost care should be taken to avoid a situation when you have file metadata in DB and no file in FS and vise-verso. use several root storage locations i.e. STORE01\ STORE02\ STORE\ - this can help in development (and later with scaling out). It is possible that several developers will be using one central DB and file storage that is local to their machine. Using STORE from the start will help to avoid a situation when metadata/file comb. will be valid in one instance of an app, and not valid in the other.. never store absolute PATHes in DB
