[site]: stackoverflow
[post_id]: 2572644
[parent_id]: 2357544
[tags]: 
I got this to work. Here's how. First create an NSValueTransformer like so: ArrayToDataTransformer.h @interface ArrayToDataTransformer : NSValueTransformer { } @end ArrayToDataTransformer.m import "ArrayToDataTransformer.h" @implementation ArrayToDataTransformer + (BOOL)allowsReverseTransformation { return YES; } + (Class)transformedValueClass { return [NSData class]; } - (id)transformedValue:(id)value { //Take an NSArray archive to NSData NSData *data = [NSKeyedArchiver archivedDataWithRootObject:value]; return data; } - (id)reverseTransformedValue:(id)value { //Take NSData unarchive to NSArray NSArray *array = (NSArray*)[NSKeyedUnarchiver unarchiveObjectWithData:value]; return array; } @end The above is your interface to NSManagedObject, now create one that use it, for example: Array.h #import @class Arrays; @interface Array : NSManagedObject { } @property (nonatomic, retain) id myArray; @property (nonatomic, retain) Arrays * arrayOfArrays; @end Array.m #import "Array.h" #import "Arrays.h" @implementation Array @dynamic myArray; @dynamic arrayOfArrays; @end In the xcdatamodel, Array needs myArray Attributes set as Optional (usually always checked), and Type is: Transformable, and Value Transformer Name: ArrayToDataTransformer Now you can use it; NSMutableArray* positionArray; positionArray = [[NSMutableArray alloc] arrayWithCapacity:[myArray count]]; for(NSArray *pos in myArray) { [positionArray addObject:[NSString stringWithFormat:@"%@",pos]]; } NSLog(@"ArrayCtrl : positionArray cnt = %d",[positionArray count]); //Now add the positionArray to CoreData using the setValue & myArray Key Array *array = (Array*)[NSEntityDescription insertNewObjectForEntityForName:@"Array" inManagedObjectContext:self.managedObjectContext]; [array setValue:positionArray forKey:@"myArray"]; [myArrays setMyArrays:array]; [self saveAction:array]; [positionArray release]; To retrieve the data from CoreData: using a one-to-one relationship, thus myArrays points to just one array element NSArray *positionArray = [myArrays.array valueForKey:@"myArray"]; If you are using a one-to-many, and things are named as above, you'll get back an NSSet. Core Data should store the Array as a Blob in the database, and a large Array can be written very quickly, say one with 3,500 objects takes less than a second. The performance is comparable to how UIImage is stored and retrieved using pretty much the same concepts. The retrieval I think is even faster. The alternative is to write each value of the Array individually into Core Data. For this you need to create the appropriate NSManageObject, but beware that you'll have to save 3,500 times for each array value, and for 3,500 items, this will take 20 to 30 seconds. Thus the above method is great for writing large arrays into CoreData in one shot, and retrieving them also in one shot. Spent a few hours on this one, was about to give up, and then I saw the light!
