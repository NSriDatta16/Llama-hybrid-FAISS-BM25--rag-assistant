[site]: stackoverflow
[post_id]: 3353576
[parent_id]: 3352714
[tags]: 
Timing this code isn't really possible. You'll only get realistic timing results if you run the Release version of the code. Which also kicks in the JIT optimizer. And it is smart enough to see that "pt" isn't actually used anywhere, it removes all code that assigns it . You'll end up with the exact same time and still not know anything. To force the JIT optimizer to actually emit the assignment code, you have to do something with "pt". Like: Console.WriteLine(pt) But now you'll be timing how long Console.WriteLine() takes instead of finding out anything about the efficiency of the assignment. What's worthy in this case however is to look at the machine code that's generated. Here's an annotated version of what my x86 JIT compiler generated in the Release build with the optimizer enabled: 00000008 xor eax,eax ; New Point 0000000a mov dword ptr [ebp-10h],eax ; pt.X = 0 0000000d mov dword ptr [ebp-0Ch],eax ; pt.Y = 0 [first fragment] 00000010 mov esi,1 ; i = 1 pt = New Point(i, i) 00000015 mov dword ptr [ebp-10h],esi ; pt.X = i 00000018 mov dword ptr [ebp-0Ch],esi ; pt.Y = i [elided] 00000036 add esi,1 ; i = i + 1 00000039 jo 0000007D ; overflow check 0000003b cmp esi,3E8h ; i The [elided] section is the Console.WriteLine() call. Look closely at the machine code instructions: It is the exact same code . The JIT compiler is cool that way. If you ask it to do the same job it generates the same code. The common advice is to code for clarity instead of efficiency. While such a statement isn't often verified, it is often accurate.
