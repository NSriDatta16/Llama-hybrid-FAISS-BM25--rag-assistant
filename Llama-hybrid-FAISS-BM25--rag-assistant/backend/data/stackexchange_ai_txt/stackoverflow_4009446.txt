[site]: stackoverflow
[post_id]: 4009446
[parent_id]: 3864155
[tags]: 
Unless you have good reasons to, you don't want to reinvent pseudo random generation. It is quite possible to get something wrong. I'd suggest starting with an array with A[i]=i then do this: for (i=0; i Edit This is in response to the comments below: How random do you want the sequence to be. Note that the inherent information in a randomly chosen permutation is log(n!) which is somewhere close to n/e bits. So you do need that many random bits to be generated. Now since you want these many random bits stored anywhere I think (more like a gut feeling than a mathematical proof) it would be hard to do a truly random permutation without that much storage). But if you just want a sequence that is not easy to reverse engineer you could just concatenate a number of 1:1 functions one after the other. Two things come to mind: - keep a counter i for the sequence that goes from 0 through N-1. do log_2(N/2) bit flips on i where bits to flip are chosen at random when when you are starting the sequence. generate a random permutation over log_2(N) bits at the beginning of sequence using the above method and then swap the bits in the result above. Find a random number r1 that is a relative prime to n at and another random number r2 between 0 and n-1. Your i-th number is = r2^r % n. Some combination of these should give you a hard to reverse engineer sequence. The key is that the more random bits you infuse the harder it is to reverse engineer. One thing that comes to mind is that if your range is 0..N-1, just find a large number P that is a relative prime to N and choose another random number
