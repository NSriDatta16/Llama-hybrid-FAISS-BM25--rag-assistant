[site]: stackoverflow
[post_id]: 2744914
[parent_id]: 2742583
[tags]: 
Instead of embedding the key in the assembly, put it in the app.config file (or another file delivered with the application) and prevent your application from running if the key is not present and valid. To protect it against modification by users, also add an RSA signature the config file. This code could be used to generate XML containing your key. public static void Main() { Console.WriteLine(GenerateKey()); } public static Byte[] Transform(Byte[] bytes, ICryptoTransform xform) { using (System.IO.MemoryStream stream = new System.IO.MemoryStream()) { using (CryptoStream cstream = new CryptoStream(stream, xform, CryptoStreamMode.Write)) { cstream.Write(bytes, 0, bytes.Length); cstream.Close(); stream.Close(); return stream.ToArray(); } } } public static string GenerateKey() { RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); // This is the private key and should never be shared. // Generate your own with RSA.Create().ToXmlString(true). String rsaPrivateKey = " uPCow37yEzlKQXgbqO9E3enSOXY1MCQB4TMbOZyk9eXmc7kuiCMhJRbrwild0LGO8KE3zci9ETBWVVSJEqUqwtZyfUjvWOLHrf5EmzribtSU2e2hlsNoB2Mu11M0SaGd3qZfYcs2gnEnljfvkDAbCyJhUlxmHeI+35w/nqSCjCk= AQAB 4SMSdNcOP0qAIoT2qzODgyl5yu9RubpIU3sSqky+85ZqJHXLUDjlgqAZvT71ROexJ4tMfMOgSWezHQwKWpz3sw== 0krr7cmorhWgwCDG8jmzLMo2jafAy6tQout+1hU0bBKAQaPTGGogPB3hTnFIr84kHcRalCksI6jk4Xx/hiw+sw== DtR9mb60zIx+xkdV7E8XYaNwx2JeUsqniwA3aYpmpasJ0N8FhoJI9ALRzzp/c4uDiuRNJIbKXyt6i/ZIFFH0qw== mGCxlBwLnhkN4ind/qbQriPYY8yqZuo8A9Ggln/G/IhrZyTOUWKU+Pqtx6lOghVdFjSxbapn0W8QalNMFGz7AQ== WDYfqefukDvMhPHqS8EBFJFpls/pB1gKsEmTwbJu9fBxN4fZfUFPuTnCIJsrEsnyRfeNTAUFYl3hhlRYZo5GiQ== qB8WvAmWFMW67EM8mdlReI7L7jK4bVf+YXOtJzVwfJ2PXtoUI+wTgH0Su0IRp9sR/0v/x9HZlluj0BR2O33snQCxYI8LIo5NoWhfhkVSv0QFQiDcG5Wnbizz7w2U6pcxEC2xfcoKG4yxFkAmHCIkgs/B9T86PUPSW4ZTXcwDmqU= "; rsa.FromXmlString(rsaPrivateKey); String signedData = " Insert your key here "; Byte[] licenseData = System.Text.Encoding.UTF8.GetBytes(signedData); Byte[] sigBytes = rsa.SignData(licenseData, new SHA1CryptoServiceProvider()); String sigText = System.Text.Encoding.UTF8.GetString(Transform(sigBytes, new ToBase64Transform())); System.Text.StringBuilder sb = new StringBuilder(); using (System.Xml.XmlWriter xw = System.Xml.XmlTextWriter.Create(sb)) { xw.WriteStartElement("License"); xw.WriteRaw(signedData); xw.WriteElementString("Signature", sigText); xw.WriteEndElement(); } return sb.ToString(); } Example output from this code: Insert your key here cgpmyqaDlHFetCZbm/zo14NEcBFZWaQpyHXViuDa3d99AQ5Dw5Ya8C9WCHbTiGfRvaP4nVGyI+ezAAKj287dhHi7l5fQAggUmh9xTfDZ0slRtvYD/wISCcHfYkEhofXUFQKFNItkM9PnOTExZvo75pYPORkvKBF2UpOIIFvEIU= Then you can use code like this to verify it. You never have to distribute the private key: public static Boolean CheckLicenseSignature(String licXml) { try { System.Xml.XmlDocument xd = new System.Xml.XmlDocument(); xd.LoadXml(licXml); String licSig = xd.SelectSingleNode("/License/Signature").InnerText; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); String rsaPublicKey = " uPCow37yEzlKQXgbqO9E3enSOXY1MCQB4TMbOZyk9eXmc7kuiCMhJRbrwild0LGO8KE3zci9ETBWVVSJEqUqwtZyfUjvWOLHrf5EmzribtSU2e2hlsNoB2Mu11M0SaGd3qZfYcs2gnEnljfvkDAbCyJhUlxmHeI+35w/nqSCjCk= AQAB "; rsa.FromXmlString(rsaPublicKey); Byte[] licenseData = System.Text.Encoding.UTF8.GetBytes(xd.SelectSingleNode("/License/SignedData").OuterXml); return rsa.VerifyData(licenseData, new SHA1CryptoServiceProvider(), Transform(System.Text.Encoding.UTF8.GetBytes(licSig), new FromBase64Transform())); } catch (System.Xml.XmlException ex) { return false; } catch (InvalidOperationException ex) { return false; } }
