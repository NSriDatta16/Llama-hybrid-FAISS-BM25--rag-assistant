[site]: stackoverflow
[post_id]: 4578380
[parent_id]: 4578291
[tags]: 
They use CreateWindowEx . A really simple WinAPI app that creates a window looks a little like this: #include // If you're using MSVC, this is the easiest HINSTANCE. Other compilers // get it from WinMain and pass in to constructor. extern "C" IMAGE_DOS_HEADER __ImageBase; HINSTANCE hInstance = (HINSTANCE)&__ImageBase; class Window { HWND hWnd; static LRESULT __stdcall WindowProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { if (Window* ptr = reinterpret_cast (GetWindowLongPtr(hWnd, GWLP_USERDATA))) return ptr->DoMessage(hWnd, message, wParam, lParam); else return DefWindowProc(hWnd, message, wParam, lParam); } LRESULT DoMessage(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) { switch(msg) { case WM_DESTROY: PostQuitMessage(0); return 0; } return DefWindowProc(hWnd, msg, wParam, lParam); } public: bool DoMessages() { MSG msg; while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) { // Translate the message and dispatch it to WindowProc() TranslateMessage(&msg); DispatchMessage(&msg); } if (msg.message == WM_QUIT) { return false; } return true; } Window() { WNDCLASSEX wc; // clear out the window class for use ZeroMemory(&wc, sizeof(WNDCLASSEX)); // fill in the struct with the needed information wc.cbSize = sizeof(WNDCLASSEX); wc.style = CS_HREDRAW | CS_VREDRAW; wc.lpfnWndProc = WindowProc; wc.hInstance = hInstance; wc.hCursor = LoadCursor(NULL, IDC_ARROW); wc.hbrBackground = (HBRUSH)COLOR_WINDOW; wc.lpszClassName = L"WindowClass1"; RegisterClassEx(&wc); // create the window and use the result as the handle hWnd = CreateWindowEx(NULL, L"WindowClass1", // name of the window class L"Wide::Development", // title of the window WS_OVERLAPPEDWINDOW, // window style. Always windowed for now. 0, // x-position of the window 0, // y-position of the window 1, // width of the window 1, // height of the window NULL, // we have no parent window, NULL NULL, // we aren't using menus, NULL hInstance, // application handle NULL); ShowWindow(hWnd, SW_MAXIMIZE); // Snap our window to the user's desktop res, minus taskbar etc. SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast (this)); SetWindowPos(hWnd, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED); // Make sure that our WindowLongPtr is updated. } }; int main() { Window window; while(window.DoMessages()) { // Do app updates, or sleep() if you're mostly waiting on user input Sleep(50); } // When DoMessages() returns false, the window was destroyed, so return. } You can look up the MSDN documentation for more information on what these functions do. Essentially, all it does is create a very simple maximized non-fullscreen window, register for input, and when the window is destroyed, quit the application. You'll notice that I actually forwarded the input to the Window object, so this most basic of all frameworks is object-orientated and you can play with inheritance here if you want, just don't forget that the WindowLongPtr functions use a void* and are not type safe. It's also worth mentioning that on some compilers like MSVC, if you #include , they expect for you to use the WinMain entry point, not main(). The game rendering and update code is typically miles more complex and difficult than the WinAPI, so I'd grab a book on DirectX9.0c or DirectX10.
