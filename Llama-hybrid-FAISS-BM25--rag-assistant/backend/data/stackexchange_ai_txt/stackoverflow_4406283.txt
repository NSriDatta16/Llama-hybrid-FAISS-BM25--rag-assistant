[site]: stackoverflow
[post_id]: 4406283
[parent_id]: 4406203
[tags]: 
A module in ruby can be used for 3 possible things 1. Namespacing This is pretty straight forward. module Foo class Bar end end f = Foo::Bar.new 2. Collection of functions Sometimes, you will have some functions that don't really fit in any class. In something like java, you would just put them as a bunch of static methods on a class. In ruby, you would put them on a module, since having them on a class implies the class is intended to be instanciated module FooHelper def self.bar puts 'hi' end end FooHelper.bar # => hi 3. Mixins This is the hardest to understand of all 3. Basically, it is rubys answer to multiple inheritance in C, or interfaces in java. Sometimes you have logic which belongs in several classes, but at the same time doesn't fit as a parent class. A mixin describes "mixing" a modules methods into a class. There is actually a lot more to this, but at an extremely high level, it would look like this module CanFoo def foo puts 'bar' end end class Baz include CanFoo end class Bar include CanFoo end baz.new.foo # => bar bar.new.foo # => bar mixins are a fairly advanced topic, and it takes a bit of time to understand when you would use one over a super class. IMO they are one of the coolest features of ruby though, and handles the multiple inheritance problem with a great deal more elegance then any other OO language I have looked at.
