[site]: stackoverflow
[post_id]: 2603608
[parent_id]: 2603135
[tags]: 
OperationContext.Current is only available on the thread that is actually executing the operation. If you want it to be available to a worker thread, then you need to actually pass a reference to the callback channel to that thread. So your operation might look something vaguely like: public class MyService : IMyService { public void Login() { var callback = OperationContext.Current.GetCallbackChannel (); ThreadPool.QueueUserWorkItem(s => { var status = VendorLibrary.PerformLogin(); callback.ReportLoginStatus(status); }); } } This is a straightforward way of doing it using the ThreadPool and anonymous method variable capturing. If you want to do it with a free-running thread, you'd have to use a ParameterizedThreadStart instead and pass the callback as the parameter. Update for specific example: Seems that what's going on here is that the IVendorService uses some event-driven model for callbacks. Since you're using InstanceContextMode.PerSession , you can actually just store the callback in a private field of the service class itself, then reference that field in your event handler. [ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)] public class VendorServer : IVendorServer { private IMyCallback callback; private IVendorService vendorService; public VendorServer() { callback = OperationContext.Current.GetCallbackChannel (); vendorService = new VendorService(); vendorService.AgentManager.AgentLoggedIn += AgentManager_AgentLoggedIn; } public void Login(string userName, string password, string stationId) { vendorService.Login(userName, password, stationId); } private void AgentManager_AgentLoggedIn(object sender, EventArgs e) { callback.ReportLoggedIn(...); } } If you decide to switch to a different instance mode later on then this won't work, because each client will have a different callback. As long as you keep it in session mode, this should be fine.
