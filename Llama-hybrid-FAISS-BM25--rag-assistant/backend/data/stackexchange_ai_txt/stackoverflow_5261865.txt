[site]: stackoverflow
[post_id]: 5261865
[parent_id]: 1896503
[tags]: 
I recommend to everybody not to use it or only in homeopathic doses. Unfortunately I have to work with it a lot for legacy reasons, and as was stated before it was developed for .NET 1.1 and was not upgraded since, has no support for generics, no support for delegates, cannot declare events etc. It was never very widespread and is currently not developed anymore (although sometimes Microsoft still fixes a bug I submit). But that's the minor issue: There are major problems in the compiler, valid code may crash it easily and then all you have is an exception thrown somewhere in the depth of jsc.exe with no hint which file is causing the crash let alone which line of code. Here's an example of what happens (I was casting a strongly typed array into an ICollection): ***INTERNAL COMPILER ERROR*** Microsoft.Vsa.VsaException: InternalCompilerError (0x80133021): System.NotSupportedException: Not supported in a non-reflected type. at System.Reflection.Emit.SymbolType.GetMember(String name, MemberTypes type, BindingFlags bindingAttr) at System.Type.GetMember(String name, BindingFlags bindingAttr) at Microsoft.JScript.Convert.GetToXXXXMethod(IReflect ir, Type desiredType, Boolean explicitOK) at Microsoft.JScript.Convert.EmittedCallToConversionMethod(AST ast, ILGenerator il, Type source_type, Type target_type) at Microsoft.JScript.Convert.Emit(AST ast, ILGenerator il, Type source_type, Type target_type, Boolean truncationPermitted) at Microsoft.JScript.Binding.TranslateToILCall(ILGenerator il, Type rtype, ASTList argList, Boolean construct, Boolean brackets) at Microsoft.JScript.Lookup.TranslateToILCall(ILGenerator il, Type rtype, ASTList argList, Boolean construct, Boolean brackets) at Microsoft.JScript.Call.TranslateToIL(ILGenerator il, Type rtype) at Microsoft.JScript.Binding.TranslateToILSet(ILGenerator il, AST rhvalue) at Microsoft.JScript.Lookup.TranslateToILSet(ILGenerator il, Boolean doBoth, AST rhvalue) at Microsoft.JScript.VariableDeclaration.TranslateToIL(ILGenerator il, Type rtype) at Microsoft.JScript.Block.TranslateToIL(ILGenerator il, Type rtype) at Microsoft.JScript.FunctionObject.TranslateToIL(CompilerGlobals compilerGlobals) at Microsoft.JScript.FunctionDeclaration.TranslateToILInitializer(ILGenerator il) at Microsoft.JScript.Block.TranslateToILInstanceInitializers(ILGenerator il) at Microsoft.JScript.Class.TranslateToCOMPlusClass() at Microsoft.JScript.Class.TranslateToIL(ILGenerator il, Type rtype) at Microsoft.JScript.Package.TranslateToIL(ILGenerator il, Type rtype) at Microsoft.JScript.Block.TranslateToIL(ILGenerator il, Type rtype) at Microsoft.JScript.ScriptBlock.TranslateToIL(ILGenerator il, Type rtype) at Microsoft.JScript.ScriptBlock.TranslateToILClass(CompilerGlobals compilerGlobals, Boolean pushScope) at Microsoft.JScript.VsaStaticCode.TranslateToIL() at Microsoft.JScript.Vsa.VsaEngine.DoCompile() at Microsoft.Vsa.BaseVsaEngine.Compile() Good luck if you have to find the problem with such a message. JScript.NET has some features that could be interesting for some projects, like prototyping (adding new properties and I think also methods to an existing instance of any object), has kind of Lamda-Functions already since .NET 1.1 (maybe 1.0) etc. But to reach this totally different behavior from what was possible with .NET 1.1 they had to wrap everything in runtime-helpers, JScript.NET has an own String class, that is converted into System.String to and fro whenever needed. Same with arrays, JScript has its own implementation and has to convert them whenever a framework function is called with an array as parameter etc. I experienced such funny things like that a request to the database was executed twice if I passed it directly as a parameter to a method ( DoSomething(myRequest.Execute()) , the result of the request was of type System.String[][] ) but the whole thing is working fine if I assign the result first to a variable and then pass it to the method, or if you try to sort an array with System.Array.Sort(..) it is simply ignored and so on. I have the feeling JScript.NET was a case study to proof that it's also possible to implement languages with a very different philosophy, and the Microsoft gave it up as they realized its approach was not well chosen, but they learned the lesson and did an excellent job with PowerShell which has a somewhat similar philosophy. But to cut a long story short: Don't use JScript.NET if you don't have to, use a modern language like C# or VB.NET instead, and if you need scripting functionality, I recommend using CSScript.
