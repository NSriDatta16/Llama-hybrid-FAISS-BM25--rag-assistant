[site]: stackoverflow
[post_id]: 5124608
[parent_id]: 
[tags]: 
Help me improve some more SSE2 code

I am looking for some help to improve this bilinear scaling sse2 code on core2 cpus On my Atom N270 and on an i7 this code is about 2x faster than the mmx code. But under core2 cpus it is only equal to the mmx code. Code follows void ConversionProcess::convert_SSE2(BBitmap *from, BBitmap *to) { uint32 fromBPR, toBPR, fromBPRDIV4, x, y, yr, xr; ULLint start = rdtsc(); ULLint stop; if (from && to) { uint32 width, height; width = from->Bounds().IntegerWidth() + 1; height = from->Bounds().IntegerHeight() + 1; uint32 toWidth, toHeight; toWidth = to->Bounds().IntegerWidth() + 1; toHeight = to->Bounds().IntegerHeight() + 1; fromBPR = from->BytesPerRow(); fromBPRDIV4 = fromBPR >> 2; toBPR = to->BytesPerRow(); uint32 x_ratio = ((width-1) Bits(); uint8* fromPtr1 = (uint8*)from->Bits(); uint8* fromPtr2 = (uint8*)from->Bits() + fromBPR; struct FilterInfo { uint16 one_minus_diff; // one minus diff uint16 diff; // diff value used to calculate the weights used to average the pixels uint16 one_minus_diff_rep; // one minus diff repeated uint16 diff_rep; // diff value used to calculate the weights used to average the pixels repeated }; FilterInfo *xWeights = (FilterInfo *)memalign(16, toWidth * 8); FilterInfo *yWeights = (FilterInfo *)memalign(16, toHeight * 8); uint32 *xIndexes = (uint32 *)memalign(16, (toWidth+2) * 4); // will overread by 2 index uint32 *yIndexes = (uint32 *)memalign(16, toHeight * 4); x = 0; for (uint32 j=0;j > 7; xWeights[j].diff = x - (xr > 7; yWeights[j].diff = y - (yr
