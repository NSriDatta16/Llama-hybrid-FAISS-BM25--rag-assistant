[site]: stackoverflow
[post_id]: 3791877
[parent_id]: 3786033
[tags]: 
Dynamic and lexical scoping have different behaviors when a piece of code is used in a different scope than the one it was defined in. In practice, there are two patterns that cover most troublesome cases: A function shadows a global variable, then calls another function that uses that global variable. (defvar x 3) (defun foo () x) (defun bar (x) (+ (foo) x)) (bar 0) ⇒ 0 This doesn't come up often in Emacs because local variables tend to have short names (often single-word) whereas global variables tend to have long names (often prefixed by packagename- ). Many standard functions have names that are tempting to use as local variables like list and point , but functions and variables live in separate name spaces are local functions are not used very often. A function is defined in one lexical context and used outside this lexical context because it's passed to a higher-order function. (let ((cl-y 10)) (mapcar* (lambda (elt) (* cl-y elt)) '(1 2 3))) ⇒ (10 20 30) (let ((cl-x 10)) (mapcar* (lambda (elt) (* cl-x elt)) '(1 2 3))) ⇑ (wrong-type-argument number-or-marker-p (1 2 3)) The error is due to the use of cl-x as a variable name in mapcar* (from the cl package). Note that the cl package uses cl- as a prefix even for its local variables in higher-order functions. This works reasonably well in practice, as long as you take care not to use the same variable as a global name and as a local name, and you don't need to write a recursive higher-order function. P.S. Emacs Lisp's age isn't the only reason why it's dynamically scoped. True, in those days, lisps tended towards dynamic scoping — Scheme and Common Lisp hadn't really taken on yet. But dynamic scoping is also an asset in a language targeted towards extending a system dynamically: it lets you hook into more places without any special effort. With great power comes great rope to hang yourself: you risk accidentally hooking into a place you didn't know about.
