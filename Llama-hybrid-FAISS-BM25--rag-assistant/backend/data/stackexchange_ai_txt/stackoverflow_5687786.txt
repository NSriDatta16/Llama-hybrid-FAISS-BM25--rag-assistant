[site]: stackoverflow
[post_id]: 5687786
[parent_id]: 5687682
[tags]: 
Ah, I see you have found a solution in C++ already using Dijkstra's algorithm: http://hashsamrat.blogspot.com/2010/10/surviving-monster-programming-problem.html However, you seem to be thinking about 'recursion' and other methods. The solution is separate than the implementation. Thus what you really want to do would be to use the same algorithm (Dijkstra's, which is just breadth-first search carefully done so you visit the shortest paths first), but in python rather than C++. You could just copy the C++ line-by-line, using python idioms to make the code cleaner and more elegant. But you'll still be using the same algorithm. (Alternatively, you could Google for the hundreds of ways people have implemented Dijkstra's in python. Or you could write it yourself; all you need is a priority queue (see wikipedia), and if time isn't an issue, you can write a poorly-performing priority queue in the form of a dictionary-of-lists.) edit: Thinking about it, if by "shortest set of choices" you just mean "fewest gunshots", you don't really need Dijkstra's at all; it's just breadth-first-search (which is equivalent to Dijkstra's when all edges have weight 1). In particular, the logic to generate a new node is as follows: def howManyHeadsLeft(currentHeads, damage, regen): newHeads = heads - damage if {this results in blowing off our own head} and newHeads>0: #modify depending on assumptions # we killed ourselves without taking monster down with us return {} # the empty set of possible search nodes else: newHeads += regen # we could just say return {newHeads} here, # but that would be terribly slow to keep on searching the same # state over and over again, so we use a cache to avoid doing that # this is called dynamic programming if {we have never seen newHeads before}: return {newHeads} else return {} def newSearchNodes(currentHeads): return howManyHeadsLeft(currentHeads, atypeDamage, atypeRegen) | howManyHeadsLeft(currentHeads, btypeDamage, btypeRegen) The 'goal' condition for the search is having just enough damage to kill the hydra without killing yourself (modify as appropriate depending on assumptions): heads==1+atypeDamage or heads==1+btypeDamage Of course it is also possible that no solution exists (regen > damage for both types of guns), in which case this algorithm might run forever, but could probably be modified to terminate.
