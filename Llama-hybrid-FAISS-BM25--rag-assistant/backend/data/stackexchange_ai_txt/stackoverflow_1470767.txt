[site]: stackoverflow
[post_id]: 1470767
[parent_id]: 1467200
[tags]: 
Alternate solution to the one presented by VonC would be to use "ours" merge strategy to join histories, but to take one version: $ git checkout -b tmp original-repo/master $ git merge -s ours master # take version from 'tmp', i.e. from 'original-repo/master' $ git checkout master $ git merge tmp # should be fast forward $ git branch -d tmp # 'tmp' branch is no longer needed What you do above is to do in short "theirs" merge. Caveat: this solution solves original problem only if there are no other commits on local branch since last merge (last update), that the ones which are to be replaced by version from original repository!!! So this solution allows to keep your version of solving the problem for the history, but is more limited in application. Below there is set of ASCII-art diagrams showing what is happening in the repository in each step: before first command: \*---\*---x---A after " git checkout -b tmp original-repo/master ": where both 'tmp' (local branch) and 'original-repo/master' (remote-tracking branch) point to the same commit. after " git merge -s ours master ": /-------------- original-repo/master v *---*---x---A----A' where commit A' is a merge commit, but has the same contents (the same tree) as commit A after " git checkout master && git merge tmp " (the merge should be fast-forward): /-------------- original-repo/master v *---*---x---A----A' Both 'master' and 'tmp' point to the same commit. after " git branch -d tmp ", and some reorganizing of the diagram \*---\*---x---A-----\ At the end: remote-tracking branch ' original-repo/master ' (i.e. ' refs/remotes/original-repo/master ') points to commit A, local branch ' master ' (i.e. ' refs/heads/master '), which is current branch, points to commit A'. Commit A' has: commit A as its first parent ( A'^1 == A ), commit b as second parent ( A'^2 == a ), and its contents (its tree) is the same as in commit A ( A'^{tree} == A^{tree} ).
