[site]: stackoverflow
[post_id]: 1786498
[parent_id]: 385506
[tags]: 
Here's the problem I see with the whole concept of avoiding premature optimization. There's a disconnect between saying it and doing it. I've done lots of performance tuning, squeezing large factors out of otherwise well-designed code, seemingly done without premature optimization. Here's an example. In almost every case, the reason for the suboptimal performance is what I call galloping generality , which is the use of abstract multi-layer classes and thorough object-oriented design, where simple concepts would be less elegant but entirely sufficient. And in the teaching material where these abstract design concepts are taught, such as notification-driven architecture, and information-hiding where simply setting a boolean property of an object can have an unbounded ripple effect of activities, what is the reason given? Efficiency . So, was that premature optimization or not?
