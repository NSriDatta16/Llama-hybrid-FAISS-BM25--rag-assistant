[site]: stackoverflow
[post_id]: 3835677
[parent_id]: 3781962
[tags]: 
This is my first post on stackoverflow, so I apologize in advance for missing any preliminary etiquette. Also, in the interest of full disclosure, Dave brought this problem to my attention. Here's an O(N^2logN) solution, mostly because of the the repeated sorting step in the for loop. Absolute values: Remove zero elements and sort by absolute value. Since you are allowed to place a negative sign in front of your final result, it does not matter whether your answer is negative or positive. Only the absolute values of all numbers in the set matter. Multiplication only for numbers > 1: We make the observation that for any set of positive integers greater than 1, (e.g. {2,3,4} ), the largest result comes from a multiplication. This can be shown by an enumerative technique or a contradiction argument over permitted operations + and -. e.g. (2+3)*4 = 2*4 + 3*4 . In other words, multiplication is the most "powerful" operation (except for the 1s). Addition of the 1s to the smallest non-1 numbers: For the 1s, since multiplication is a useless operation, we are better off adding. Here again we show a complete ordering on the result of an addition. For rhetoric sake, consider again the set {2,3,4} . We note that: 2*3*(4+1) . In other words, we get the most "mileage" from a 1 by adding it to the smallest existing non-1 element in the set. Given a sorted set, this can be done in O(N^2logN) . Here's what the pseudo-code looks like: S = input set of integers; S.absolute(); S.sort(); //delete all the 0 elements S.removeZeros(); //remove all 1 elements from the sorted list, and store them ones = S.removeOnes(); //now S contains only integers > 1, in ascending order S[0] ... S[end] for each 1 in ones: S[0] = S[0] + 1; S.sort(); end max_result = Product(S);
