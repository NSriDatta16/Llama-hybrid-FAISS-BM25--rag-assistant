[site]: stackoverflow
[post_id]: 4857291
[parent_id]: 4851542
[tags]: 
You can use deforestation on folds. In fact, map/map fusion is a special case of that. The trick is to replace list construction by a special build function: build :: (forall b. (a -> b -> b) -> b -> b) -> [a] build g = g (:) [] Now, using the standard definition of foldr foldr :: (a -> b -> b) -> b -> [a] -> b foldr c n [] = n foldr c n (x:xs) = c x (foldr c n xs) We have the following equivalence: foldr c n (build g) == g c n (Actually this is only true under certain, but common, circumstances. For details see "Correctness of short-cut fusion" ). If you write your list producing functions (including map ) using build and your consumers using foldr , then the above equality can remove most intermediate lists. Haskell's list comprehensions are translated into combinations of build and foldr . The downside of this approach is that it cannot handle left folds. Stream Fusion handles this just fine, though. It expresses list producers and transformers as streams (coinductive datatypes, kind of like iterators). The above paper is very readable, so I recommend taking a look. The "bananas" paper mentioned by gasche goes into more details about kinds of folds and their equivalences. Finally, there is Bird and Moor's "Algebra of Programming" , which mentions transformations such as combining two folds into one .
