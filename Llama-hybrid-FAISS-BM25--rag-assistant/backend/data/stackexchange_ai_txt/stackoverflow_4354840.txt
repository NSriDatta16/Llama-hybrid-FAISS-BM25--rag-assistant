[site]: stackoverflow
[post_id]: 4354840
[parent_id]: 4354620
[tags]: 
Edit : At first I thought you were daft: the first example surely wouldn't even compile. Only after trying it myself (and seeing that it does compile) did I realize what Doggett already pointed out : your class B example actually has no relationship to the IFoo interface; it's just a generic type whose type parameter happens to be called IFoo . Maybe you were aware of this, and you really were asking, "Why would I want to constrain a generic type parameter at all?" If that's the case then I think the other answers have addressed this to some extent. But it sounded like you were asking, "Why would I define my type like that , instead of like this (since they are practically the same)?" The answer to this is, quite simply: they are not the same. Now, here's another questionâ€”one you didn't ask, but the one I originally set out to answer ;) Why define a type like this: class A where T : IFoo { T GetFoo(); } ...instead of this? class A { IFoo GetFoo(); } Here's one reason that springs to my mind (because it resembles scenarios I've dealt with in the past): you are designing not one class, but a small hierarchy of classes, and IFoo is simply the "base line" interface all of your classes will require, while some may leverage specific implementations, or more derived interfaces. Here's a dumb example: class SortedListBase where TList : IList , new() { protected TList _list = new TList(); // Here's a method I can provide using any IList implementation. public T this[int index] { get { return _list[index]; } } // Here's one way I can ensure the list is always sorted. Better ways // might be available for certain IList implementations... public virtual void Add(T item) { IComparer comparer = Comparer .Default; for (int i = 0; i : SortedListBase > { // Here is a smarter implementation, dependent on List 's // BinarySearch method. Note that this implementation would not // be possible (or anyway, would be less direct) if SortedListBase's // _list member were simply defined as IList . public override void Add(T item) { int insertionIndex = _list.BinarySearch(item); if (insertionIndex
