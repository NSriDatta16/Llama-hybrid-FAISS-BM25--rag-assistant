[site]: stackoverflow
[post_id]: 5140912
[parent_id]: 5140520
[tags]: 
The difference between your two solutions should be marginal. Table solution might be cleaner depending on activity. However, do note that 'you are doing it wrong' (according to the theory). The RDBMS application design principle clearly states that you should not try to specify how your queries should be executed, but what data you want. The database will find optimal path to your solution (the RDBMS sits closest to the data and depending on your architecture might save network round trips, storage round trips and so on; scalability can be seriously crippled here and you might not be aware of it if you don't do decent stress testing; furthermore RDBMS knows about indexes and internal statistics that determine if scans or seeks will be more effective and it knows how to optimally execute joins). In practice, try to raise the question why different database for friendships? (is it really different db or different schema on the same db?). Furthermore, if you really want to go the way you do it (disabling the RDBMS to look for optimal execution plan), then the most important factors are: indexes (will affect the performance in orders of magnitude) usage patterns (indexes will improve performance of SELECTs, but too many indexes will slow down updates) application/client layer caching (can affect performance and scalability in orders of magnitude) EDIT: So, considering "Given a set of N friend IDs, get all the open sessions or the latest session for all these friends." here is a query that should be tested before introducing new structures Sessions (SessionID, User, Context, Start, End) SELECT * FROM Sessions s WHERE s.End IS NULL AND s.User IN (:friendsList) UNION ALL SELECT * FROM Sessions s WHERE s.User NOT IN (SELECT User FROM Sessions s2 WHERE s2.User IN (:friendsList) AND s2.End IS NULL) AND s.User IN (:friendsList) AND s.End IN (SELECT MAX(End) FROM Sessions s2 WHERE s2.User = s.User) There are more ways to write the above to try to help the optimizer, in particular if your DB supports CTE the above can be rewritten more efficiently. Notes: :friendsList - list of Users that are friends. Also, I am assuming open sessions have NULL as value of the End for open sessions. You might already be choosing some other approach (maybe you have a field denoting it; or there are two tables, one for open sessions, one for closed) The above query will benefit from certain indexes (principle is to first try to optimize with indexes, then with restructuring; first index I would try is composite index on User, End ) and on relatively small number of friends (assumed from the fact that it passed around as a string), this should perform decently already.
