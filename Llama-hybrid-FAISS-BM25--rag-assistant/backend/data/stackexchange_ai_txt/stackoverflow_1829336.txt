[site]: stackoverflow
[post_id]: 1829336
[parent_id]: 1829028
[tags]: 
The reason why (id) is used in method declarations is two fold: (1) The method may take or return any type. NSArray contains any random object and, thus, objectAtIndex: will return an object of any random type. Casting it to NSObject* or id would be incorrect for two reasons; first, an Array can contain non NSObject subclasses as long as they implement a certain small set of methods and, secondly, a specific return type would require casting. (2) Objective-C doesn't support covariant declarations. Consider: @interface NSArray:NSObject + (id) array; @end Now, you can call +array on both NSArray and NSMutableArray . The former returns an immutable array and the latter a mutable array. Because of Objective-C's lack of covariant declaration support, if the above were declared as returning (NSArray*) , clients of the subclasses method would have to cast to `(NSMutableArray*). Ugly, fragile, and error prone. Thus, using the generic type is, generally, the most straightforward solution. So... if you are declaring a method that returns an instance of a specific class, typecast explicitly. If you are declaring a method that will be overridden and that override may return a subclass and the fact that it returns a subclass will be exposed to clients, then use (id) . No need to file a bug -- there are several already. Note that ObjC now has limited co-variance support through the instancetype keyword. I.e. NSArray 's +array method could now be declared as: + (instancetype) array; And the compiler would treat [NSMutableArray array] as returning an NSMutableArray* while [NSArray array] would be considered as returning NSArray* .
