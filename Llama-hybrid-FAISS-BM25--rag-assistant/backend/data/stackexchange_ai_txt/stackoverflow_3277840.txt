[site]: stackoverflow
[post_id]: 3277840
[parent_id]: 
[tags]: 
Name clashes between field labels of different datatypes in Haskell

Coming to Haskell from a background in various OO languages, one thing that seems like a bit of a drawback to me is that function and field names aren't scoped to the types they're associated with, so it's easy to run into clashes if different datatypes have fields with the same name. If I have these three modules: module One where data Foo a = Foo { value :: a } ---- module Two where data Bar a = Bar { value :: a } ---- module Three where import One import Two foo = Foo { value = 42 } -- compile error here n = value foo -- and here the unqualified references to value in module Three are considered ambiguous even though only one of the two imported names makes sense in this context. (In an OO language, references to foo.value and bar.value would be unambiguous.) Of course I can disambiguate by writing Foo { One.value = 42 } , but that looks awkward. I can also name the fields differently, e.g. "fooValue" and "barValue", but the redundancy in Foo { fooValue = 42 } looks awkward as well. This is really a special case of the more general issue of functions in different modules that have the same name but operate on different, unrelated types. I seem to run into it more often with field names, though. For example, I have several datatypes, not related by a type class but often used together, that contain color values, so I'd like each one to have a field named "color". How do experienced Haskell developers name things, and organize them into modules, to avoid this type of situation?
