[site]: crossvalidated
[post_id]: 490127
[parent_id]: 67907
[tags]: 
This is very related with this question cumsum with shift of n I asked in SO. I also answered in SO the same question as this one but it has been closed so I include here the answer again because I think is more focus in the software implementation than from the mathematical understanding (even though I think they are equivalent mathematically). The question asked the same thing, how to reverse the moving average, a.k.a in pandas as rolling mean. The code sample of the question : import numpy as np import pandas as pd import matplotlib.pylab as plt np.random.seed(100) data = np.random.rand(200,3) df = pd.DataFrame(data) df.columns = ['a', 'b', 'y'] df['y_roll'] = df['y'].rolling(10).mean() df['y_roll_predicted'] = df['y_roll'].apply(lambda x: x + np.random.rand()/20) So, how to obtain df['y'] back from df['y_roll'] ? and apply the same method to df['y_roll_predicted'] With this function cumsum_shift(n) which you have to think of it as the inverse of the pandas/numpy method diff(periods = n) , you can reverse the moving average up to constant if you don't have the initial values. The definition of cumsum_shift(n) that generalizes the cumsum() which is this one with n = 1 (n is called shift in the code): def cumsum_shift(s, shift = 1, init_values = [0]): s_cumsum = pd.Series(np.zeros(len(s))) for i in range(shift): s_cumsum.iloc[i] = init_values[i] for i in range(shift,len(s)): s_cumsum.iloc[i] = s_cumsum.iloc[i-shift] + s.iloc[i] return s_cumsum Then assuming the size of the window is 10 win_size = 10 then if you multiply by 10 the diff 'ed of the rolling mean and then "cumsum shift it" with a shift of 10, you obtain the original serie up to the intial values. The code: win_size = 10 s_diffed = win_size * df['y_roll'].diff() df['y_unrolled'] = cumsum_shift(s=s_diffed, shift = win_size, init_values= df['y'].values[:win_size]) This code recovers exactly y from y_roll because you have the initial values. You can see it plotting it (in my case with plotly) that y and y_unrolled are exactly the same (just the red one). Now doing the same thing to y_roll_predicted to obtain y_predicted_unrolled . Code: win_size = 10 s_diffed = win_size * df['y_roll_predicted'].diff() df['y_predicted_unrolled'] = cumsum_shift(s=s_diffed, shift = win_size, init_values= df['y'].values[:win_size]) In this case the result are not exactly the same, notice how the initial values are from y and then y_roll_predicted incorporate noise to y_roll so the "unrolling" cannot recover exactly the original one. Here a plot zoomed in in a smaller range to see it better: Hope this can help somebody.
