[site]: stackoverflow
[post_id]: 3243085
[parent_id]: 3243035
[tags]: 
The definition would be a very simple one-liner, but without spoiling it, you should look into: a "rest" argument -- this (define (foo . xs) ...xs...) defines foo as a function that takes any number of arguments and they're available as a list which will be the value of xs . length returns the length of a list. apply takes a function and a list of values and applies the function to these values. When you get that, you can go for more: see the foldl function to avoid applying a list on a potentially very big list (this can matter in some implementations where the length of the argument list is limited, but it wouldn't make much difference in Racket). note that Racket has exact rationals, and you can use exact->inexact to make a more efficient floating-point version. And the spoilers are: (define (average . ns) (/ (apply + ns) (length ns))) Make it require one argument: (define (average n . ns) (/ (apply + n ns) (add1 (length ns)))) Use foldl : (define (average n . ns) (/ (foldl + 0 (cons n ns)) (add1 (length ns)))) Make it use floating point: (define (average n . ns) (/ (foldl + 0.0 (cons n ns)) (add1 (length ns))))
