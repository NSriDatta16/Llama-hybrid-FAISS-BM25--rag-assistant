[site]: stackoverflow
[post_id]: 5627715
[parent_id]: 
[tags]: 
2-dimensional glRotatef()

(iPhone) I'm trying to make it so that the user can rotate an object by dragging his finger on the screen. Dragging left or right should rotate around the Y-axis, and dragging up or down should rotate around the X-axis. Here's my original code: glRotatef( yAmt, 0, 1, 0 ); glRotatef( xAmt, 1, 0, 0 ); The rotation is all crazy and seems to go in random directions. I'm pretty sure it has to do with the second statement being dependent on the first statement, but I've tried to negate that with some fancy math and still couldn't get it right. Well I partially figured it out, but now I have a new problem (how to sum two rotations?). MY SOLUTION: Let's say you wanted to rotate the cube left 90 then down 90. You try this: glRotatef( 90, 0, 1, 0 ); glRotatef( 90, 1, 0, 0 ); It doesn't work. The second function behaves strangely because the first function has swapped the X and Z axes. So you try this: glRotatef( 90, 0, 1, 0 ); glRotatef( 90, 0, 0, 1 ); Now you have the desired result, but if you change the amount of Y rotation in the first function to 180 or 45 or whatever, it fails again. The desired rotation vector is dependent of the amount of Y rotation from the first function. Desired result is achieved with this: glRotatef( yAmt, 0, 1, 0 ); glRotatef( xAmnt, cos(yAmt), 0, sin(yAmt) ); Now what if you want to rotate up and down first and then left to right? This last solution fails because, first of all, the functions are in the wrong order, and second of all, the Y axis is also dependent on the X rotation. You have to account for this, AND you have to combine the two functions, resulting in: glRotatef( totalAmt, xFactor*cos(yAmt), yFactor*cos(xAmt), xFactor*sin(yAmt) + yFactor*sin(xAmt) ); Where xFactor and yFactor add up to desired rotation vector (1,0 for up and down, 0,1 for left and right, sqrt(.5), sqrt(.5) for diagonal rotation). MY PROBLEM: The problem comes in when the user finishes one rotation and starts a new one. You have to remember and "reinact" the previous rotation, otherwise you get an undesired "jump" back to 0 rotation. One new rotation is fine, I can implement touchesEnded to remember the parameters of glRotatef and then plug them in to a new rotation like this: glRotatef( amt_old, x_old, y_old, z_old ); glRotatef( totalAmt, xFactor*cos(yAmt), yFactor*cos(xAmt), xFactor*sin(yAmt) + yFactor*sin(xAmt) ); But on the second new rotation, I now have two rotations to "reinact". I can't figure out what values to assign to amt_old, x_old, y_old, and z_old. What it boils down to is...how do you sum two glRotatef rotations?
