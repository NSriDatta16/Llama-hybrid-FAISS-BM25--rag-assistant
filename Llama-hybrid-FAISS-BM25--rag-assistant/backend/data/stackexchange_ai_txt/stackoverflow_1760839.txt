[site]: stackoverflow
[post_id]: 1760839
[parent_id]: 1760812
[tags]: 
What you are trying to achieve is polymorphism , which is an OO concept. So while this would be quite easy to implement in C++ (or other OO languages), it's a bit more challenging in C. One way you could get around is it to create a generic "packet" structure such as this: typedef struct { void* messageHandler; int messageLength; int* messageData; } packet; Where the messageHandler member is a function pointer to a callback routine which can process the message type, and the messageLength and messageData members are fairly self-explanatory. The idea is that the method which you pass the packetStruct to would use the Tell, Don't Ask principle to invoke the specific message handler pointer to by messageHandler , passing in the messageLength and messageData without interpreting it. The dispatch function (pointed to by messageHandler ) would be message-specific and will be able to cast the messageData to the appropriate meaningful type, and then the meaningful fields can be extracted from it and processed, etc. Of course, this is all much easier and more elegant in C++ with inheritance, virtual methods and the like. Edit: In response to the comment: I'm a little unclear how "able to cast the messageData to the appropriate meaningful type, and then the meaningful fields can be extracted from it and processed, etc." would be accomplished. You would implement a handler for a specific message type, and set the messageHandler member to be a function pointer to this handler. For example: void messageAlphaHandler(int messageLength, int* messageData) { MessageAlpha* myMessage = (MessageAlpha*)messageData; // Can now use MessageAlpha members... int messageField = myMessage->field1; // etc... } You would define messageAlphaHandler() in such a way to allow any class to get a function pointer to it easily. You could do this on startup of the application so that the message handlers are registered from the beginning. Note that for this system to work, all message handlers would need to share the same function signature (i.e. return type and parameters). Or for that matter, how messageData would be created in the first place from my struct. How are you getting you packet data? Are you creating it manually, reading it off a socket? Either way, you need to encode it somewhere as a string of bytes. The int* member ( messageData ) is merely a pointer to the start of the encoded data. The messageLength member is the length of this encoded data. In your message handler callback, you don't want probably don't want to continue to manipulate the data as raw binary/hex data, but instead interpret the information in a meaningful fashion according to the message type. Casting it to a struct essentially maps the raw binary information on to a meaningful set of attributes matching to the protocol of the message you are processing.
