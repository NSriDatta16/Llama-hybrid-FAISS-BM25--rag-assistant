[site]: stackoverflow
[post_id]: 281211
[parent_id]: 281144
[tags]: 
Your models retrieve data, your presenter organizes data for the view, and the view controls binding your model to UI elements. For example, here's a model for a LogEvent: public class LogEvent{ public string Title {get;set;} public string Date {get;set;} public string Message {get;set;} // this is for example only; you would most likely bind directly against the host.GetAllLogs() result public static IEnumerable RetrieveAllLogs(ILogProvider host){ return from x in host.GetAllLogs() select new LogEvent(x.LogTitle, x.Date, x.Message); } Here's the controller that handles a user request to view all logs: [DependencyPropertyLolJk] protected ILogProvider MyLogProvider {get;set;} // set by DI [AcceptVerbs(HttpVerbs.Get)] public ActionResult Logs() { return View("Logs", LogEvent.GetAllLogs(MyLogProvider).OrderByDescending(x => x.Date)); } And here is the view and how it binds to the model: Date Title Message So you see, you have to write your html using inline code. This works well for simple UIs, but can be complex and a drudgery when it comes to more complex things, such as pagers and gridviews. When your UI gets complex, the easiest thing to do is to create extensions to the HtmlHelper class. Here are two examples that show how this can cut down the complexity of your UI: HtmlHelper GridView and Pager controls. I've created similar helper methods, and its pretty remarkable how you can mix html and inline code within lambdas. Now if the designer was only able to format this kind of mixed code/markup decently...
