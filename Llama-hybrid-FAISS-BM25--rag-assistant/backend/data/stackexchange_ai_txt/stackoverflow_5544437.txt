[site]: stackoverflow
[post_id]: 5544437
[parent_id]: 5543896
[tags]: 
I've taken the liberty of changing the order of your magic parameters under the assumption that base 10 is more common and optional: def magic(digits,base=10) raise "Max magic base of 36" unless base [1, 1, 1] #=> [1, 1, 2] #=> [1, 2, 1] #=> [1, 2, 2] #=> [2, 1, 1] #=> [2, 1, 2] #=> [2, 2, 1] #=> [2, 2, 2] magic(2,16){ |a,b| p [a,b] } #=> [1, 1] #=> [1, 2] #=> [1, 3] #=> ... #=> [16, 15] #=> [16, 16] Explanation : By translating the original problem from 1..10 to 0..9 and concatenating the digits we see that the output is just counting, with access to each digit. 0000 0001 0002 ... 0010 0011 0012 ... 9997 9998 9999 So that's what my code above does. It counts from 0 up to the maximum number (based on the number of digits and allowed values per digit), and for each number it: Converts the number into the appropriate 'base': i.to_s(base) # e.g. 9.to_s(8) => "11", 11.to_s(16) => "b" Uses String#% to pad the string to the correct number of characters: "%#{digits}s" % ... # e.g. "%4s" % "5" => " 5" Turns this single string into an array of single-character strings: str.scan(/./) # e.g. " 31".scan(/./) => [" ","3","1"] Note that in Ruby 1.9 this is better done with str.chars Converts each of these single-character strings back into a number: n.to_i(base) # e.g. "b".to_i(16) => 11, " ".to_i(3) => 0 Adds 1 to each of these numbers, since the desire was to start at 1 instead of 0 Splats this new array of numbers as arguments to the block, one number per block param: yield *parts
