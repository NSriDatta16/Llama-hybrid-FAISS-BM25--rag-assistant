[site]: stackoverflow
[post_id]: 5614075
[parent_id]: 5613996
[tags]: 
Instead of creating a new OpenHelper in each of your static methods, instantialize your DataHandlerDB with the current context and have the class hold a variable populated by getWritableDatabase . You are creating multiple cursor objects created by different SQLiteOpenHelper objects and Android doesn't like doing this. Check this out for additional info: http://www.ragtag.info/2011/feb/1/database-pitfalls/ Here's how it looks to me like you're doing things... public class DataHandlerDB{ public static SQLiteDatabase createDB(Context ctx) { OpenHelper helper = new OpenHelper(ctx); SQLiteDatabase db = helper.getWritableDatabase(); ... return db; } public static Cursor selectTopCalls(Context ctx) { OpenHelper helper = new OpenHelper(ctx); SQLiteDatabase db = helper.getWritableDatabase(); // error is here ... return c; } } This results in multiple concurrent SQLiteOpenHelper objects and multiple SQLiteDatabase objects and the locking situation you currently have. Instead of doing multiple Static calls, make a DataHandler class that you instantialize with the consistent context and then make normal calls (instead of static ones): public class DataHandlerDB{ OpenHelper _helper; SQLiteDatabse _db; public DataHandlerDB( Context ctx ){ _helper = new OpenHelper(ctx); _db = _helper.getWritableDatabase(); } public SQLiteDatabase createDB() { ... return db; } public Cursor selectTopCalls() { ... return c; } } public void setBasicContent() { ... DataHandlerDB handler = new DataHandlerDB( this ); Cursor c = handler.selectValues(); //.selectTopCalls()? ... } When you create this object, it will persist 1 OpenHelper and 1 SQLiteDatabase . This should alleviate the problems with SQLite wanting the database closed before it can access it. Don't forget to close the DB in the onDestroy method of your activity.
