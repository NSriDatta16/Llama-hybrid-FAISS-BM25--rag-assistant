[site]: stackoverflow
[post_id]: 2947734
[parent_id]: 2947550
[tags]: 
The problem that you are having is that while a float can store 6.25e+10, it only has a few significant digits of precision. This means that when you are building a large number by adding lots of small numbers together a bit at a time, you reach a point where the smaller number is smaller than the lowest precision digit in the larger number so adding it up has no effect. As to why you are not getting this behaviour in the non-intrinsic version, it is likely that result variable is being held in a register which uses a higher precision that the actual storage of a float so it is not being truncated to the precision of a float on every iteration of the loop. You would have to look at the generated assembler code to be sure.
