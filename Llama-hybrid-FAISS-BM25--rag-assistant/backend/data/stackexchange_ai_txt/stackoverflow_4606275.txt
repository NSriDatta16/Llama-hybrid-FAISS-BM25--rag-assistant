[site]: stackoverflow
[post_id]: 4606275
[parent_id]: 4595998
[tags]: 
If you think the problem is that you subclass the DefaultMutableTreeNode, try making your DataFlavor to be an array of Object, or even better, an ArrayList: DataFlavor.javaJVMLocalObjectMimeType + ";class=java.util.ArrayList" This way you can return your copies list along with your transferable. Maybe it will avoid the problem. here's a rough scetch of how to do this with lists: import javax.swing.*; import javax.swing.tree.*; import java.awt.*; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.Transferable; import java.awt.datatransfer.UnsupportedFlavorException; import java.io.IOException; import java.util.*; import java.util.List; /** * Author: Denis Tulskiy * Date: 1/5/11 */ public class Test extends JFrame { class NodeA extends DefaultMutableTreeNode { NodeA(Object userObject) { super(userObject); } } class NodeB extends DefaultMutableTreeNode { NodeB(Object userObject) { super(userObject); } } class NodeC extends DefaultMutableTreeNode { NodeC(Object userObject) { super(userObject); } } private static class MyTransferHandler extends TransferHandler { @Override public int getSourceActions(JComponent c) { return MOVE; } @Override protected Transferable createTransferable(JComponent c) { JTree tree = (JTree) c; ArrayList nodes = new ArrayList (); for (TreePath path : tree.getSelectionPaths()) { DefaultMutableTreeNode component = (DefaultMutableTreeNode) path.getLastPathComponent(); nodes.add(component); } return new NodesTransferable(nodes); } @Override public boolean canImport(TransferSupport support) { return support.isDataFlavorSupported(NodesTransferable.getDataFlavor()); } @Override public boolean importData(TransferSupport support) { if (!canImport(support)) { return false; } JTree tree = (JTree) support.getComponent(); List data = null; try { data = (List ) support.getTransferable().getTransferData(NodesTransferable.getDataFlavor()); } catch (UnsupportedFlavorException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } if (data != null) { Point dropPoint = support.getDropLocation().getDropPoint(); TreePath path = tree.getPathForLocation(dropPoint.x, dropPoint.y); DefaultMutableTreeNode parent = (DefaultMutableTreeNode) path.getLastPathComponent(); for (DefaultMutableTreeNode node : data) { node.removeFromParent(); parent.add(node); } DefaultTreeModel model = (DefaultTreeModel) tree.getModel(); model.reload(); } return true; } } static class NodesTransferable implements Transferable { private static DataFlavor dataFlavor; public static DataFlavor getDataFlavor() { if (dataFlavor == null) { try { dataFlavor = new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType + ";class=java.util.ArrayList"); } catch (ClassNotFoundException e) { e.printStackTrace(); } } return dataFlavor; } private java.util.List nodes; NodesTransferable(List nodes) { this.nodes = nodes; } @Override public DataFlavor[] getTransferDataFlavors() { return new DataFlavor[]{getDataFlavor()}; } @Override public boolean isDataFlavorSupported(DataFlavor flavor) { return flavor.match(dataFlavor); } @Override public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException { return nodes; } } public Test() { JTree tree = new JTree(); tree.setDragEnabled(true); tree.setDropMode(DropMode.ON_OR_INSERT); DefaultMutableTreeNode root = new DefaultMutableTreeNode("Root"); NodeA child = new NodeA("nodea"); root.add(child); child.add(new NodeB("nodeb")); child.add(new NodeC("nodec")); tree.setModel(new DefaultTreeModel(root)); tree.setTransferHandler(new MyTransferHandler()); setLayout(new BorderLayout()); add(tree, BorderLayout.CENTER); setSize(300, 400); setLocationRelativeTo(null); setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new Test().setVisible(true); } }
