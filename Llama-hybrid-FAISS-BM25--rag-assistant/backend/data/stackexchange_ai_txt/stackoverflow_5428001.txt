[site]: stackoverflow
[post_id]: 5428001
[parent_id]: 5424831
[tags]: 
I don't really know what I'm doing here, but this moves more controllably, at least. First, explicitly set the canvas size: self.canvas = Canvas(frame, bd=0, height=600, width=800, xscrollcommand=self.xscrollbar.set, yscrollcommand=self.yscrollbar.set) Then, in __init__() , add a couple of instance variables to keep track of the current position: self.pos_x = self.pos_y = 0.0 Then, replace the drag method with this: def drag(self, event): # Note canvas dimensions are used here self.pos_x += float(self._x-event.x) / 800.0 self.pos_y += float(self._y-event.y) / 600.0 if self.pos_x 1.0: self.pos_x = 1.0 if self.pos_y 1.0: self.pos_y = 1.0 self.canvas.xview("moveto", self.pos_x) self.canvas.yview("moveto", self.pos_y) self._x = event.x self._y = event.y I don't know why you have to cast those numbers to float, but it doesn't work if you don't. It's brittle; if you multiply the mouse movement by anything, even just 0.99 or 1.01, the movement gets really wonky; I suspect there's some kind of feedback going on between the mouse movement and the canvas movement. It doesn't play nicely with the scroll bars, either; I suppose we'd have to update pos_x and pos_y when they're moved. As I said, don't really know what I'm doing; I haven't done much GUI programming. Anyway, hope this helps.
