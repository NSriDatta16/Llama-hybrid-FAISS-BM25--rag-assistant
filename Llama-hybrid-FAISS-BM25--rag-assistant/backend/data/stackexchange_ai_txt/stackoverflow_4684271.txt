[site]: stackoverflow
[post_id]: 4684271
[parent_id]: 4684216
[tags]: 
You could try this? #define numberWithFloat(float f) \ [NSNumber numberWithFloat:f] #define floatFromNumber(NSNumber *n) \ [n floatValue] (see my original answer below) Here's the other thing with NSNumber, you don't have to retrieve what you set. For example NSNumber *myInt = [NSNumber numberWithInteger:100]; float myFloat = [myInt floatValue]; is perfectly valid. NSNumber's strength is that it allows you to "weak-type" your primitives, use compare: , use isEqualTo: , and stringValue for easy display. [EDIT] User @Dave DeLong says that sub-classing NSNumber is a Bad Idea without much work. Since it's a class cluster (meaning NSNumber is an abstract superclass of a lot of subclasses) you'll have to declare your own storage if you sub-class it. Not recommended, and thanks to Dave for pointing that out.
