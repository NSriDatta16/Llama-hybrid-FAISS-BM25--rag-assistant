[site]: stackoverflow
[post_id]: 2159769
[parent_id]: 2159725
[tags]: 
This declares an instance variable in your object: @interface myclass : UIImageView { int aVar; } Instance variables are private implementation details of your class. If you want other objects to be able to read or set the value of the instance variable (ivar), you can declare it as a property: @property int aVar; This means that the compiler expects to see setter and getter accessor methods for the property. When you use the @synthesize keyword, you are asking the compiler to automatically generate setter and getter accessor methods for you. So, in this case the compiler will generate code similar to this when it encounters the @synthesize keyword: - (int) aVar { return aVar; } - (void)setAVar:(int)someInt { aVar = someInt; } By default on the iPhone (and on the 32-bit runtime on the Mac), @synthesize requires an instance variable to be present in order to store the property's value. This ivar is usually named the same as the property, but doesn't have to be, for instance you could do this: @interface myclass : UIImageView { int aVar; } @property int someValue; @synthesize someValue = aVar; Neither @synthesize nor @property are actually required, you can create your own getter and setter methods, and as long as you create them using Key-Value Coding-compliant syntax, the property will still be usable. The requirement for an ivar to be present as well as the @property declaration is due to the fragile base class limitation of the 32-bit Objective-C runtime on both the Mac and iPhone. With the 64-bit runtime on the Mac you don't need an ivar, @synthesize generates one for you. Note that there are numerous keywords you can use with your @property declaration to control what sort of synthesized accessor code is created, such as readonly for a getter-only accessor, copy , atomic , nonatomic and so on. More information is in the Objective-C 2.0 Programming Language documentation.
