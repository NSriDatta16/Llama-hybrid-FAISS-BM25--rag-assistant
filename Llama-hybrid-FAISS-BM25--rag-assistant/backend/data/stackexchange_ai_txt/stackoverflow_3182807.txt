[site]: stackoverflow
[post_id]: 3182807
[parent_id]: 3182733
[tags]: 
You probably mean a doubly-linked list, with one of the pointers going forward and the other going backward. This allows you to get to the next and previous nodes for a given node without having to remember the last one or two nodes encountered (as in a singly-linked list). But the one thing I discovered which made the code even more elegant was to always have two dummy elements in the list at all times, the first and the last. This gets rid of the edge cases for insertion and deletion since you're always acting on a node in the middle of the list. For example, an empty list is created: first = new node last = new node first.next = last first.prev = null last.next = null last.prev = first // null last -> null Obviously, traversing the list is slightly modified (forward version shown only): curr = first.next while curr <> last: do something with curr curr = curr.next The insertions are much simpler since you don't have to concern yourself with whether you're inserting at the start or end of the list. To insert before the current point: if curr = first: raise error add = new node add.next = curr add.prev = curr.prev curr.prev.next = add curr.prev = add Deletions are also simpler, avoiding the edge cases: if curr = first or curr = last: raise error curr.prev.next = curr.next curr.next.prev = curr.prev delete curr All very much cleaner code and at the cost of only having to maintain two extra nodes per list, not a great burden in today's huge memory space environments. Caveat 1: If you're doing embedded programming where space still might matter, this may not be a viable solution (though some embedded environments are also pretty grunty these days). Caveat 2: If you're using a language that already provides linked list capabilities, it's probably better to do that rather than roll your own (other than for very specific circumstances).
