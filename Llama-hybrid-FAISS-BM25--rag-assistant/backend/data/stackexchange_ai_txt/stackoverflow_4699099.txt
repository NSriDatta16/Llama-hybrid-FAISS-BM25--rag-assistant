[site]: stackoverflow
[post_id]: 4699099
[parent_id]: 3326912
[tags]: 
If I'm correct, the only small drawback of this, is that you are forced to explicitly mention what kind of TLoot you are splitting. Arrow arrow1; /* some code initializing arrow1 */ Arrow arrow2 = arrow1.Split (10); Obviously, arrow1 being an Arrow , we couldn't have written anything else (like for example Arrow b = a.Split (10); which makes no sense), yet Arrow arrow2 = arrow1.Split(10); unfortunately wouldn't compile, since the return type of a generic method cannot be infered if it has no parameter of the same type. Here is the trick : make Split an extension method on Loot . :-) Its prototype becomes public static TLoot Split (this TLoot item, int quantityToTake) where TLoot : Loot and TLoot now takes place among the parameter at position 1 (even if introduced by the special keyword this : nevermind !). This first parameter disappears when calling, so that all occurs as if we had return type inference. You can now write Arrow arrow2 = arrow1.Split(10); . It is perfectly legal and the returned type is an authentic strongly typed Arrow (you could even write var arrow2 = arrow1.Split(10); and then examine arrow2 's type to be sure). I confess it seems more cool and elegant than really usefull in this context. But I'm fond of fluent interface (method chaining), and there, it really becomes a huge improvement. Compare these 2 declarations : /*Given an certain among of arrows found in the treasure chamber, each player in the team receives a fraction of it according to his age and experience, but always 10 arrows at least anyway. Ok, ok ! I had to search before finding such an example vaguely accurate in the context of arrows and potions ! lol*/ foreach(Player p in Team) p.Arrows = Treasure.Arrows.Split (10).Split (p.Age).Split (p.Experience*2); foreach(Player p in Team) p.Arrows = Treasure.Arrows.Split(10).Split(p.Age).Split(p.Experience*2); Ok, here again the benefit remains poor ( Treasure.Arrows.Split (10+p.Age+p.Experience*2) works as well and is shorter !) but there really are situations where making the return type implicit hugely improves the readibility.
