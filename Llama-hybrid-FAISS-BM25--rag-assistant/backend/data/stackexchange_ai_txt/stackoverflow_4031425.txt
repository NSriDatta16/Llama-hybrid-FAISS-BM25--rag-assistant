[site]: stackoverflow
[post_id]: 4031425
[parent_id]: 4030430
[tags]: 
This is possible and I previously tried two paths: Convert to Grayscale then apply pixel by pixel conversion to B&W. --Problem with this is I don't get good results with images with transparency. If you're not very strict, given an RGBA image, get the pixel RGB average and convert to B&W with a supplied threshold and retain its transparency. Technically this is still RGBA but more of Black, White and Transparency. e.g. UIImage *originalImage = [UIImage imageNamed:@"option_bluetooth.png"]; unsigned char *pixelBuffer = [self getPixelData:originalImage.CGImage]; size_t length = originalImage.size.width * originalImage.size.height * 4; CGFloat intensity; int bw; //50% threshold const CGFloat THRESHOLD = 0.5; for (int index = 0; index THRESHOLD) { bw = 255; } else { bw = 0; } pixelBuffer[index] = bw; pixelBuffer[index + 1] = bw; pixelBuffer[index + 2] = bw; } CGColorSpaceRef colorSpace=CGColorSpaceCreateDeviceRGB(); CGContextRef bitmapContext=CGBitmapContextCreate(pixelBuffer, originalImage.size.width, originalImage.size.height, 8, 4*originalImage.size.width, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrderDefault); CFRelease(colorSpace); free(pixelBuffer); CGImageRef cgImage=CGBitmapContextCreateImage(bitmapContext); CGContextRelease(bitmapContext); UIImage *bwImage = [UIImage imageWithCGImage:cgImage]; I get the pixel data by writing to an offscreen context (the new way of getting the raw data which Apple suggests does not work for me) e.g. CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); unsigned char *rawData = malloc(imageHeight * imageWidth * 4); CGContextRef offscreenContext = CGBitmapContextCreate(rawData, imageWidth, imageHeight, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrderDefault); CGColorSpaceRelease(colorSpace); CGContextDrawImage(offscreenContext, CGRectMake(0, 0, imageWidth, imageHeight), cgCropped); CGContextRelease(offscreenContext); Here's the code to get Pixel Data + (unsigned char *) getPixelData: (CGImageRef) cgCropped { size_t imageWidth = CGImageGetWidth(cgCropped); size_t imageHeight = CGImageGetHeight(cgCropped); size_t bitsPerComponent = 8; size_t bytesPerPixel = 4; size_t bytesPerRow = bytesPerPixel * imageWidth; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); unsigned char *rawData = malloc(imageHeight * imageWidth * 4); CGContextRef offscreenContext = CGBitmapContextCreate(rawData, imageWidth, imageHeight, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrderDefault); CGColorSpaceRelease(colorSpace); CGContextDrawImage(offscreenContext, CGRectMake(0, 0, imageWidth, imageHeight), cgCropped); CGContextRelease(offscreenContext); return rawData; }
