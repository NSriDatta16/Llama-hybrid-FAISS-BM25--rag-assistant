[site]: stackoverflow
[post_id]: 4692532
[parent_id]: 
[tags]: 
"Namespace prefix not defined" when it actually is defined

I'm having trouble deserializing XML with an "undefined" namespace prefix which really is defined. We've published an internal web service in C# which serves a variety of clients. A new client's IDE insists on declaring xsi:type for every element in its XML output, and they can't turn off this "feature". The XML message they produce goes like this, where "namespace" is the correct namespace. ABCDEF ABC123 DEF456 is basically an array of strings. The service method accepts as XmlNode, but XmlSerializer throws a "prefix 'ns1' not defined" error. (It is defined in a parent node, but apparently that is not good enough.) I have a similar problem using wsdl.exe to generate classes and deserialize the input for me. Using XmlNamespaceManager to specify prefixes doesn't seem right -- akin to magic numbers, and I can't predict which prefix a given consumer will declare anyway. Is there a way to handle this without stripping the attributes out (books.Attributes.RemoveAll)? That doesn't feel particularly elegant either. I've found that books.OuterXML does not contain any information for 'ns1' unless I hack the element inbound to use that prefix (), so I can see why it complains, but I don't yet understand why 'ns1' isn't recognized from its previous definition above. Many thanks for any help, or at least education, someone can provide. Edits: it works fine if I change to use the prefix, i.e. . This works whether I've defined xmlns or no. That may be consistent with this answer , but I still don't see how I would feasibly declare the prefix in the service code. @Chris, certainly. Hope I can strike a balance between "stingy with closed source" and "usable for those who would help". Here "books" is the XmlNode received in the service method parameter. (Not to get off topic, but will also humbly take suggestions to improve it in general; I'm still a novice.) XmlSerializer xmlSerializer = new XmlSerializer(typeof(booksType)); StringReader xmlDataReader = new StringReader(books.OuterXml); books = (booksType)xmlSerializer.Deserialize(xmlDataReader); The class is pretty much this: [Serializable()] [XmlRoot("books", Namespace = "namespace")] [XmlTypeAttribute(TypeName = "booksType", Namespace = "namespace")] public class booksType { [XmlElement(ElementName = "bookID")] public string[] bookIDs { get; set; } }
