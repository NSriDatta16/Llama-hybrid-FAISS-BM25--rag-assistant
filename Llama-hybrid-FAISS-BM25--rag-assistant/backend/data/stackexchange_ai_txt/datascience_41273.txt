[site]: datascience
[post_id]: 41273
[parent_id]: 9346
[tags]: 
Great question. This is a matter of complexity, and the approach you use will depend on how complex the problem is. Any problem we try to solve will have a degree of complexity associated with it, colloquially defined as "the number of things interacting, or things that need to be considered." In supervised and unsupervised learning we specify precisely the number of things to consider. For example, in multiple linear regression we tell the learning algorithm how many features to consider when fitting a model (the number of columns in your training set). The same situation holds for unsupervised learning; a well-defined training set with an explicit number of features are used (in this case without labels). What you are facing is a situation ill-suited for classification or regression, because you cannot specific precisely the number of "things to consider." As you say, your problem space is exceedingly large. Another way to think about this is in terms of the training set required to learn a model; how hard is it for you imagine what the training set looks like? In your case difficult. What exactly would the columns of my set contain? This is why applications like self-driving cars, Atari, and AlphaGo do not use classification or regression. It's impossible to know what the training set would even look like. You can try, but your model will fail to reliably make strong predictions (in this case moves). How many things wold you have to consider to build a model of road conditions? This is why a third type of machine learning, reinforcement learning, exists. Rather than use a pre-specified training set, it uses trial and error. By continually poking its environment it can learn a policy that works in the long term. So, for smaller problem spaces where we stand a chance of defining the training set we use supervised and unsupervised machine learning. For larger problem spaces where it's difficult to define the training set we use reinforcement learning. Of course you can also make interesting combinations of all the above approaches, but it still comes down to complexity.
