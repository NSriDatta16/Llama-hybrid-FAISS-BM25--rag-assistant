[site]: stackoverflow
[post_id]: 5736553
[parent_id]: 5736150
[tags]: 
You can test whether the method is being called via the Verify method. If the called method does not return anything then you dont need a Setup . I prefer this than the Setup or Expect/VerifyAll approach as it is more AAA. [Test] public void ShoudlCallMockMethod() { var mocked = new Mock (); var target = new ClassToTest(mocked.Object); target.DoStuff(); mocked.Verify(x => x.CallMyMethod(It.IsAny ()); } here it expects that a call to CallMyMethod with any argument. If you know the exact argument passed in and want to check that then do mocked.Verify(x => x.CallMyMethod("exactstring")); if you want more complex matching of what was passed in (useful for complex objects with many araguments) then have a look at another answer I did with using a matcher . You can also add Times.AtMostOnce() if you want to ensure it gets called only once [Edit] Based on your edits and comments you do not need to mock the args object but if you still want to verify that the parameters are set then you can verify on the Client.SendAsync method, provided that can be mocked (which I would suggest you should aim towards if you have not already done so). The link I provided about matchers should help with that. As for you question in your comment over the past few years there has been a shift from Record/Replay-Verify > Expect/Setup-Verify > [Setup]-Verify. It can be down to the mocking technology but mostly due to the introduction of lambda expressions in c#3.5 and then the move to AAA. What you really want is small readable tests that follow the AAA principle so having Expect/Setup-VerifyAll is really having the Assert in the Arrange phase (you have to look back to see what is being verified). So unless the mocked method needs to return something then you don't need the Setup, just verify that the method was called in the Assert phase.
