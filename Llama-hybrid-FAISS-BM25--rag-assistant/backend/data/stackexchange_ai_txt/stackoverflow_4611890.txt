[site]: stackoverflow
[post_id]: 4611890
[parent_id]: 
[tags]: 
Faster way to convert from a String to generic type T when T is a valuetype?

Does anyone know of a fast way in VB to go from a string to a generic type T constrained to a valuetype ( Of T as Structure ), when I know that T will always be some number type? This is too slow for my taste: Return DirectCast(Convert.ChangeType(myStr, GetType(T)), T) But it seems to be the only sane method of getting from a String --> T . I've tried using Reflector to see how Convert.ChangeType works, and while I can convert from the String to a given number type via a hacked-up version of that code, I have no idea how to jam that type back into T so it can be returned. I'll add that part of the speed penalty I'm seeing (in a timing loop) is because the return value is getting assigned to a Nullable(Of T) value. If I strongly-type my class for a specific number type (i.e., UInt16 ), then I can vastly increase the performance, but then the class would need to be duplicated for each numeric type that I use. It'd almost be nice if there was converter to/from T while working on it in a generic method/class. Maybe there is and I'm oblivious to its existence? Conclusion : Testing the three provided implementations below and my original DirectCast/ChangeType form, @peenut's approach of using a prepared delegate to fetch the Parse method from a basic type works. No error checking is done, however, so implementors need to remember to only use this with valuetypes that have a Parse method available. Or extend the below to do error checking. All runs were done on a 32bit system running Windows Server 2003 R2 with 4GB of RAM. Each "run" is 1,000,000 executions (ops) of the method to be tested, timed with StopWatch and reported back in milliseconds. Original DirectCast(Convert.ChangeType(myStr, GetType(T)), T) : 1000000 ops: 597ms Average of 1000000 ops over 10 runs: 472ms Average of 1000000 ops over 10 runs: 458ms Average of 1000000 ops over 10 runs: 453ms Average of 1000000 ops over 10 runs: 466ms Average of 1000000 ops over 10 runs: 462ms Using System.Reflection and calling InvokeMethod to get at the Parse method: 1000000 ops: 12213ms Average of 1000000 ops over 10 runs: 11468ms Average of 1000000 ops over 10 runs: 11509ms Average of 1000000 ops over 10 runs: 11524ms Average of 1000000 ops over 10 runs: 11509ms Average of 1000000 ops over 10 runs: 11490ms Konrad's approach to generate IL code to access the Parse method and store the call into a delegate: 1000000 ops: 352ms Average of 1000000 ops over 10 runs: 316ms Average of 1000000 ops over 10 runs: 315ms Average of 1000000 ops over 10 runs: 314ms Average of 1000000 ops over 10 runs: 314ms Average of 1000000 ops over 10 runs: 314ms peenut's approach of using a delegate to access the Parse method directly: 1000000 ops: 272ms Average of 1000000 ops over 10 runs: 272ms Average of 1000000 ops over 10 runs: 275ms Average of 1000000 ops over 10 runs: 274ms Average of 1000000 ops over 10 runs: 272ms Average of 1000000 ops over 10 runs: 273ms Comparatively, peenut's approach is almost 200ms faster when executed 1,000,000 times in a tight loop, so his approach wins out. Although, Konrad's wasn't far behind and is itself a fascinating study of things like ILGenerator. Props to all who contributed!
