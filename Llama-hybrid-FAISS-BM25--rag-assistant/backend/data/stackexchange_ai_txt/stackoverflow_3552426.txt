[site]: stackoverflow
[post_id]: 3552426
[parent_id]: 3551935
[tags]: 
Billy O'Neal started to head in the right direction, but didn't (IMO) quite get to the real target. Assuming your target is Windows, a much simpler way would be to use the Windows Symbol handler functions, particularly SymFromName , which will let you supply the symbol's name, and it will return (among other things) the address for that symbol. Of course, to do any of this you will have to run under an account that's allowed to do debugging. At least for global variables, however, you don't necessarily have to stop the target process to find symbols, addresses, etc. In fact, it works just fine for a process to use these on itself, if it so chooses (quite a few of my early experiments getting to know these functions did exactly that). Here's a bit of demo code I wrote years ago that gives at least a general idea (though it's old enough that it uses SymGetSymbolFromName , which is a couple of generations behind SymFromName ). Compile it with debugging information and stand back -- it produces quite a lot of output. #define UNICODE #define _UNICODE #define DBGHELP_TRANSLATE_TCHAR #include #include #include #include #include #pragma comment(lib, "dbghelp.lib") int y; int junk() { return 0; } struct XXX { int a; int b; } xxx; BOOL CALLBACK sym_handler(wchar_t const *name, ULONG_PTR address, ULONG size, void *) { if (name[0] != L'_') std::wcout
