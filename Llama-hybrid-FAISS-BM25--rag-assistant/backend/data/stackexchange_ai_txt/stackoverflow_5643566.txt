[site]: stackoverflow
[post_id]: 5643566
[parent_id]: 5643242
[tags]: 
I considered voting to close this a a duplicate, but the title is pretty good, and looking through other questions, I don't find a complete answer to a general question. These sorts of questions betray an absence of understanding of the basics of HTTP, so I wrote this long answer instead. I've glossed over a bit, but anyone who understands the following probably wouldn't need to ask a question like this one. Or if they did, they'd be able to ask a more specific question. First - If you're storing images or other files in the database, stop and reconsider your architecture. RDBMSes aren't really optimized to handle BLOBs. There are a number of (non-relational) databases that are specifically tuned to handle files. They are called filesystems , and they're really good at this. At least 95% of the time that I've found regular files stuck in a RDBMS, it's been pointless. So first off, consider not storing the file data in the database, use the filesystem, and store some small data in the database (paths if you must, often you can organize your filesystem so all you need is a unique id). So, you're sure you want to store your blob in the database? In that case , you need to understand how HTTP works. Without getting into too much detail, whenever some client requests a URL (makes an HTTP Request), the server responds with a HTTP Response. A HTTP response has two major parts: the headers, and the data. The two parts are separated by two consecutive newlines. Headers, on the wire, are simple plain-text key/value pairs that look like: Name: value and are separated by a newline. The data is basically a BLOB. It's just data. The way that data is interpreted is decided (by the client) based on the value of the Content-Type header that accompanies it. The Content-Type header specifies the Internet Media Type of the data contained in the data section. See it work There's nothing magic about this. For a regular HTML page, the whole response is human readable. Try the following: $ telnet google.com 80 # connect go google.com on port 80 You'll see something like: Trying 74.125.113.104... Connected to google.com. Escape character is '^]'. Now type: GET / (followed by return). You've just made a very simple HTTP request! And you've probably received a response. Look at the response. You'll see all the headers, followed by a blank line, followed by the HTML code of the google home page. So what? So now you know what web servers do. They take requests (like GET / ), and return responses (comprised of headers followed by a blank line (two consecutive newlines) followed by data). Now, it's time to realize that: Your web application is really just a customized web server All that code you write takes whatever the request is, and translates it into an HTTP response. So you're basically just making a specialized version of apache, or IIS, or nginx, or lighty, or whatever. Now, the default way that a web server usually handles requests is to look for a file in a directory (the document root), look at it to figure out which headers to send, and then send those headers, followed by the file contents. But, while your webserver does all that magically for files in the filesystem, it is completely ignorant of some BLOB in an RDBMS. So you have to do it yourself. If you know the contents of your BLOB are, say, a JPG image that should be named based on a "name" column in the same table, you might do something like: (If you wanted to hint that browser should download the file instead of display it, you might use an additional header like: header('Content-Disposition: attachment; filename="' . $row['name'].'"'); ) PHP is smart enough to provide the header() function, which sets headers, and makes sure they're sent first (and separated form the data). Once you're done setting headers, you just send your data. As long as your headers give the client enough information about how to handle the data payload, everything is hunkey-dorey. Hooray.
