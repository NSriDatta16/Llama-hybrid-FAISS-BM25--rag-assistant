[site]: stackoverflow
[post_id]: 5125366
[parent_id]: 5125286
[tags]: 
This is by design and to be expected. The short answer to your question is you should continue calling "read" until you get all the data you expect. That is: int total_bytes = 0; int expected = BUFSIZE; int bytes_read; char *buffer = malloc(BUFSIZE+1); // +1 for null at the end while (total_bytes From my experience, one of the biggest misconceptions (resulting in bugs) that you'll receive as much data as you ask for. I've seen shipping code in real products written with the expectation that sockets work this way (and no one certain as to why it doesn't work reliably). When the other side sends N bytes, you might get lucky and receive it all at once. But you should plan for receiving N bytes spread out across multiple recv calls. With the exception of a real network error, you'll eventually get all N bytes. Segmentation, fragmentation, TCP window size, MTU, and the socket layer's data chunking scheme are the reasons for all of this. When partial data is received, the TCP layer doesn't know about how much more is yet to come. It just passes what it has up to the app. It's up to the app to decide if it got enough. Likewise, "send" calls can get conglomerated into the same packet together. There may be ioctls and such that will make a socket block until all the expected data is received. But I don't know of any off hand. Also, don't use read and write for sockets. Use recv and send. Read this book . It will change your life with regards to sockets and TCP:
