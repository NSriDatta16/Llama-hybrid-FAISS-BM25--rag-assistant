[site]: crossvalidated
[post_id]: 637157
[parent_id]: 
[tags]: 
Compare failure rates across multiple systems

I work in pharmaceutical manufacturing and one part of a process is a filtration step that uses 'clusters' or 'sets' of single-use (disposable) filters in parallel - the product flows into a manifold and then is distributed evenly between these sets, which are installed in individual housings. Each of the (seven) sets must be tested individually prior to use (the housing is isolated and cannot be used if it fails) and we want to know if one housing / set is failing the test statistically more than the others. Each set has been tested for 273 batches and I get the following number of failures / failure rate and suspect that Set #5 is more likely than than the others to fail: Set # Set 1 Set 2 Set 3 Set 4 Set 5 Set 6 Set 7 Failures 5 1 3 4 9 2 1 Failure rate * 1.83 0.37 1.10 1.17 3.30 0.73 0.37 * Failures per 100 tests I had considered just looking at the mean & standard deviation failure count and checking for mean +/- 3SD, but as I only have seven sets, the standard deviation is too large (2.82) vs. the mean (3.57) Code in Python (with credit to @dipetkov for the 'R' original): import numpy as np x = np.array([5, 1, 3, 4, 9, 2, 1]) n = np.repeat(273, 7) failures = np.sum(x) successes = np.sum(n) - np.sum(x) n_rep = np.repeat(np.arange(1, 8), repeats=n) # Create array of tests outside of the function, for speed t_rep = np.concatenate((np.ones(failures), np.zeros(successes))) def one_permutation_under_null(): x_rep = np.random.choice(t_rep, size=len(n_rep)) rates = np.array([np.mean(x_rep[n_rep == i]) for i in range(1, 8)]) # * the highest failure probability # return np.max(rates) # * the difference between the highest and lowest failure probability # return np.max(rates) - np.min(rates) # * the difference between the highest probability and the average of the rest rates = np.sort(rates) return rates[6] - np.mean(rates[:5]) np.random.seed(1234) s_rep = np.array([one_permutation_under_null() for _ in range(10000)]) # result = np.mean(s_rep >= 9 / 273) # result = np.mean(s_rep >= 9 / 273 - 1 / 273) result = np.mean(s_rep >= 9 / 273 - (5 + 1 + 3 + 4 + 2 + 1) / (6 * 273)) print(f'Proportion of iterations with statistic equal to or more extreme than the observed result: {result}')
