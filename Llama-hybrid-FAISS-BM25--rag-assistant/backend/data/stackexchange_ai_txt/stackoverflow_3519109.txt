[site]: stackoverflow
[post_id]: 3519109
[parent_id]: 3519014
[tags]: 
IMO, you need to host old services for your previous clients at (preferably) old end points and have new services at new end points. You can take out old services when all your old clients migrate to newer version. Perhaps, you can use inheritance to reduce your efforts, for example [DataContract(OldNameSpace)] ClassA { ... } [DataContract(NewNameSpace)] ClassB : ClassA { } Similarly, create new service contract from inheriting from new one. Service implementation need not change expect it needs to implement new contract. Now you have to configure two end point - one for old contract and another for new contract. Edit: Put sample interfaces and implementation Let's say your old contract was something like public interface IOldContract { ClassA GetFoo(); void DoBar(ClassA a); } Now you can choose the new contract either as public interface INewContract { ClassB GetFoo(); void DoBar(ClassB b); ClassB GetMix(ClassB a); } or as public interface INewContract2 : IOldContract { ClassB GetFoo2(); void DoBar2(ClassB b); ClassB GetMix2(ClassB b); } I tend to go with later variation (as new contract remains compatible with old one). But in your case, you can choose former as you will be anyway exposing two endpoints. Now you need modify service implementation as follows: public class ServiceImplementation : INewContract2 { #region INewContract2 Members public ClassB GetFoo2() { // Your old implementation goes here } public void DoBar2(ClassB b) { DoBar(b); } public ClassB GetMix2(ClassB b) { return GetMixHelper(b); } #endregion #region IOldContract Members public ClassA GetFoo() { return GetFoo2(); } public void DoBar(ClassA a) { // You old implementation goes here } public ClassA GetMix(ClassA a) { return GetMixHelper(a); } #endregion private ClassB GetMixHelper(ClassA a) { // Your old implementation goes here } } I hope that you get the idea. Even here also you have multiple choices of code organization. You can have two skeleton service implementation classes - one for old contract and another for new contract. Both will delegate actually functionality to a helper class (which is your current implementation).
