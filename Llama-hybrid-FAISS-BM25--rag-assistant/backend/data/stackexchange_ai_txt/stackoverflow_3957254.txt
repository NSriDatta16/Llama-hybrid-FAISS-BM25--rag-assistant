[site]: stackoverflow
[post_id]: 3957254
[parent_id]: 3957168
[tags]: 
That's pretty much exactly how I've done it in the past. main: claim mutex for each desired thread: start child release mutex : child: claim mutex release mutex : Note that this doesn't actually guarantee that all the threads have started before the first one starts doing something, just that the main thread has created them. In order to do that, you can use something like the following method: main: claim mutex set unstarted to 0 for each desired thread: start child add 1 to unstarted release mutex : child: claim mutex subtract 1 from unstarted while unstarted > 0: release mutex yield // if necessary claim mutex release mutex : Whatever initialisation a thread has to do to be considered started will occur between the claim and the subtract . I see from further investigation that barriers are actually a more elegant way to do this. They weren't actually available in the pthread implementations I used which is why my code may seem a little verbose. However, I'll leave it as-is on the off-chance that someone uses pre-v6 pthreads or a different threading method (without barriers) and because, as the question asked, this is a different way of doing it.
