[site]: stackoverflow
[post_id]: 2278697
[parent_id]: 2277662
[tags]: 
Well, the whole things seems a bit odd, agreed. All of them are single instance and single threaded. That's definitely going to come back and cause massive performance headaches - guaranteed. I don't understand why anyone would want to write a singleton WCF service to begin with (except for a few edge cases, where it does make sense), and if you do have a singleton WCF service, to get any decent performance, it must be multi-threaded (which is tricky programming, and is why I almost always advise against it). All services have the same OperationContract: they expose a Register() and Send() method. That's rather odd, too. So anyone calling will first .Register(), and then call .Send() with different parameters several times?? Funny design, really.... The SOA assumption is that you design your services to be the model of a set of functionality you want to expose to the outside world, e.g. your CustomerService might have methods like GetCustomerByID , GetAllCustomersByCountry , etc. methods - depending on what you need. Having just a single Send() method with parameters which define what is being done seems a bit.... unusual and not very intuitive / clear. Is this idea of a graph topology with messages hopping over indirect links unusual? Not necessarily. It can make sense to expose just a single interface to the outside world, and then use some internal backend services to do the actual work. .NET 4 will actually introduce a RoutingService in WCF which makes these kind of scenarios easier. I don't think this is a big no-no. Is doing all communication back to a client via CallbackContracts unusual. Yes, unusual, fragile, messy - if you can ever do without it - go for it. If you have mostly simple calls, like GetCustomerByID - make those a standard Request/Response call - the client requests something (by supplying a Customer ID) and gets back a Customer object as a return value. Much much simpler! If you do have long-running service calls, that might take minutes or more to complete - then you might consider One-Way calls which just deposit a request into a queue, and that request gets handled later on. Typically, here, you can either deposit the answer into a response queue which the client then checks, or you can have two additional service methods which give you the status of a request (is it done yet?) and a second method to retrieve the result(s) of that request. Hope that helps to get you started !
