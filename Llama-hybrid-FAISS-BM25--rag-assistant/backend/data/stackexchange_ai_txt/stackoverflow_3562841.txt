[site]: stackoverflow
[post_id]: 3562841
[parent_id]: 3561936
[tags]: 
First question is, why do you need to store the sort in the database? If you are alway sorting in the key property, just use a sort descriptor whenever you need to access them in a sorted order. Second question, why are you writing your own sort routine? This design seems rather complicated. I understand the need for arbitratary storage of key value pairs, I designed a similar system in my book. However I am unclear as to the need for sorting those values nor the need for a custom sort routine such as this one. If you could explain the need behind the sorting I could probably suggest a better strategy. Also, I would highly recommend looking into the two methods -valueForUndefinedKey: and -setValue: forUndefinedKey: as a cleaner solution to your issue. That would allow you to write code like: [myObject valueForKey:@"anythingInTheWorld"]; [myObject setValue:someValue forKey:@"anythingInTheWorld"]; and follow proper Key-Value Coding rules. Update The -valueForUndefinedKey: design is only for use in code, it is not for use accessing the store. I am still a little unclear with your goals. Given the following model: Entity > Property In this design, Property has two attributes: Key Value From here you can access any property on Entity via -valueForUndefinedKey: because under the covers, Entity will go out and fetch the associated Property for that key. Thus you get dynamic values on your Entity . Now the question of sorting. With this design, you can sort directly on SQLite because you are really sorting on the Property entity. Although I am still unclear as to the final goal of the sorting. What value does it have? How will it be used? Update: Design reconsidered The last design I proposed was wrong. On deeper reflection, it is simpler than I proposed. Your goal can be accomplished with the original Entity > Property design. However there is a bit more work to be done in the -setValue: forKey: method. The logic is as follows: External code called -setValue: forKey: on an Entity . The -setValue: forKey: method attempts to retrieve the Property . If the Property exists then the value is updated. If the Property does not exist then a Property is created for each Entity with a default value set (assumed to be an empty string). The only performance hit is when a new key is introduced. Other than that it should work without any performance penalties.
