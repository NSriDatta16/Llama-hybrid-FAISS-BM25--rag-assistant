[site]: stackoverflow
[post_id]: 5497239
[parent_id]: 5497100
[tags]: 
Iterator-based solution An elegant solution would be to make Compute() accept iterators instead of pointers. The iterators you provide will have an adequate ++ operator (see boost::iterator for an easy way to build them) Compute(MyIterator x, MyIterator y, MyIterator z); There are normally very few changes to make to the function body, since *x , x[i] or ++x will be handled by MyIterator to point to the right memory location. Quick'n Dirty solution A less elegant but more straightforward solution is to hold your Data in the following struct typedef struct { std::vector x; std::vector y; std::vector z; }DataArray3D; When receiving the data fill your struct like void Receive(const Data3D& data, DataArray3D& array) { array.x.push_back(data.x); array.y.push_back(data.y); array.z.push_back(data.z); } and call Compute like this (Compute itself is unchanged) Compute(&array.x[0], &array.y[0], &array.z[0]);
