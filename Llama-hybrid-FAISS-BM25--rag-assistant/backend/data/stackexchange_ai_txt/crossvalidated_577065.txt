[site]: crossvalidated
[post_id]: 577065
[parent_id]: 
[tags]: 
time series for deep learning modelling

What is the best format to feed the input data, which are time series with fixed density over time, to a deep learning network to get minute to minute predictions? I have a dataset with nd days of entries each one with only 1 minute of interval so we have 1440 entries per each day. And I want to get nm number of minutes of prediction. To make the things harder i want to every minute update with data of oene minute more. I tryed this code but only get predictions for 7 minutes and i cant change that: df.reset_index(inplace=True) df = df[[datecname, "Close"]] plt.figure(figsize=(16,7)) plt.plot(df[datecname], df["Close"]) #Create Sequences of 15 days and predict the price on 16Th day # [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] -> [16] #Standardize our data df["Close"] = (df["Close"] - df["Close"].mean()) / df["Close"].std() #Train #Validation #Test - Never show this one to the model only to make predictions from sklearn.model_selection import train_test_split x_train, x_val = train_test_split(df["Close"], test_size=0.2, shuffle=False) x_val, x_test = train_test_split(x_val, test_size=0.4, shuffle=False) window_size = 15 batch_size = 32 shuffle_buffer = x_train.shape[0] def window_ds(series, window_size, batch_size, shuffle_buffer): ds= tf.data.Dataset.from_tensor_slices(series) ds = ds.window(window_size + 1, shift=1, drop_remainder=True) ds = ds.flat_map(lambda w: w.batch(window_size +1)) ds = ds.shuffle(shuffle_buffer).map(lambda w: (w[:-1], w[-1])) ds= ds.batch(batch_size).prefetch(1) return ds x_train_ds = window_ds(x_train, window_size,batch_size, shuffle_buffer) x_val_ds = window_ds(x_train, window_size,batch_size, x_val.shape[0]) #dataset de treino e de validaçao criado #criaçao da rede neural input_layer = tf.keras.layers.Input(shape=[window_size])#primeira camada (de input) l0 = tf.keras.layers.Dense(128, activation="relu")(input_layer)#primeira camada de DENSE l1 = tf.keras.layers.Dense(256, activation="relu")(l0)#segunda camada de DENSE output_l = tf.keras.layers.Dense(1)(l1)#camada de output model = tf.keras.models.Model(inputs=input_layer, outputs=output_l)#passar modelo para o tensorflow model.compile(optimizer="RMSprop", loss="mse", metrics="mse")#Aqui omodelo é3 compilado model.fit(x_train_ds, validation_data=x_val_ds, epochs=100)#Nesta linha o modelo é treinado x_test = x_test.to_numpy #célula de teste de modelo forecast = [] buys = {} sells = {} for i in range(0, len(x_test()) - window_size, window_size): f = model.predict(x_test[i:i+window_size][np.newaxis])[0][0] if f > x_test[window_size]: buys.update({i+window_size:x_test[i+window_size]}) elif f
