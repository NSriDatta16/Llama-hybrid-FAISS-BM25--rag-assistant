[site]: stackoverflow
[post_id]: 5095779
[parent_id]: 5095738
[tags]: 
private static bool isLastIntervalNewerThanDB(string muiMethod) { using (var db = new IntLMPDB()) { // Try to load a matching record. LastIntervalUpdated liRec = db.LastIntervalUpdateds.FirstOrDefault(rec => rec.method == muiMethod); // If it could not be loaded, exit because there's no way to determine if we should run. if (liRec == null) { throw new Exception(string.Format("Could NOT find LastIntervalUpdated record for muiMethod: {0}", muiMethod)); } // we have a valid interval record, so lets check that it has been updated since the last webPostTime. // put another way, there are three datetime values in the LastIntervalUpdated table. First is the // interval itself, second is the retrievalTime and third is the webPostTime. Whenever the MUI is // checked for a new interval if one is found then the code updates the retrievalTime to the current // instant in time. This tells us what the last interval this application found on its last run was. // The thrid value is the webPostTime, this time instant is only updated by this very method we're in // right here. We can use this logic: if the retrievalTime is greater than the webPostTime then there's // a newer interval that we haven't yet processed and inserted into the databse. So we should run the // method below and update ALL of the syncable values into the databse. Then we'll set the dbPostTime to // the current instance. As it goes, if this program then runs again before the interval is updated // then the dbPostTime will be greater than the retrieval time and we'll know to do nothig. Simple Right? :) // or check here includes a NULL check on dbPostTime because it's possible that dbPostTime is NULL, // in the example of the first time the system runs. It might have run a LastUpdate sync and not yet // done this method, so dbPostTime would be NULL. None of the other columns are allowed to be null. return liRec.dbPostTime_EST == null || liRec.retrievalTime_EST > liRec.dbPostTime_EST; } }
