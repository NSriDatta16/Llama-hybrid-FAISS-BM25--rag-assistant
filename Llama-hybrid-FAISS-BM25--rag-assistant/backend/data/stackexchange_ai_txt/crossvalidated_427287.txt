[site]: crossvalidated
[post_id]: 427287
[parent_id]: 
[tags]: 
Q-learning agent stucks in an infinite loop

I am simulating a mouse to find a cheese on an empty table. I randomly put a cheese on the table and let the mouse find the cheese without falling off the table. The problem is, in test part, agent goes into an infinite loop if i don't provide any epsilon values. If I provide an epsilon value, agent can fall off the table. The table is discrete but the cheese is random. So i need the mouse to learn the table first. Say the agent at 322. Agent finds the largest Q and moves to the left which is 321. This time, largest value is 322. And it keeps going... I couldn't find any problems. Is my approach wrong or missing something? Here's the code i have written: import numpy as np import random import matplotlib.pyplot as plt import pickle class Env: def __init__(self): self.grid_size = 10 # 10x10 matrix self.observation_size = self.grid_size * self.grid_size self.action_size = 4 # 0: left 1: right 2: up 3: down def reset(self): self.grid = [] self.holes = [] self.target = [] self.x = np.random.randint(0, self.grid_size) while True: self.y = np.random.randint(0, self.grid_size) if self.x != self.y: break self.state = (self.y * self.grid_size) + self.x while True: self.target_x = np.random.randint(0, self.grid_size) while True: self.target_y = np.random.randint(0, self.grid_size) if self.target_y != self.target_x: break self.target = (self.target_y * self.grid_size) + self.target_x if self.target != self.state: break return self.state def step(self, action): reward = 0 done = False # 0: left 1: right 2: up 3: down x = self.x y = self.y if action == 0: self.x = self.x - 1 elif action == 1: self.x = self.x + 1 elif action == 2: self.y = self.y + 1 elif action == 3: self.y = self.y - 1 self.state = (self.y * self.grid_size) + self.x if self.x = self.grid_size: if self.x = self.grid_size: if self.y
