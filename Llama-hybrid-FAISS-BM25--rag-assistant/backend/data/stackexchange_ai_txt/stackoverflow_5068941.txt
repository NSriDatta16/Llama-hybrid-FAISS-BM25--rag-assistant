[site]: stackoverflow
[post_id]: 5068941
[parent_id]: 5068892
[tags]: 
You can accomplish this a number of ways, but perhaps the easiest way would be to use a map Map model = new HashMap (); model.put("bean", bean); model.put("userdetails", userdetails); //and so on return new ModelAndView("welcomePage", "model", model); Then, in your page, you just have to add an extra level when you access it User's name is ${ model.userdetails.username } alternatively, you could also change your handler signature to be something like this public String handleRequest(Model model){ //arbitrary handling code model.addAttribute("bean", bean); model.addAttribute("userdetails", userdetails); //etc return "welcomePage"; } When you do it like this, you don't actually have to return the model because Spring holds on to the reference before you receive it and can then access it afterwards. I personally find this method a little better because it makes unit testing easier. All you have to do is check the string return value and use a Spring mock model (or your own mock object that implements the Model interface). Edit To address the comments: This source gives some examples and discusses some of the various supported method signatures. Specifically, check out section 15.3.2.3 for a discussion of the parameters that can be passed to handler methods. Basically, Spring uses the @RequestMapping annotations to determine which methods should be called based on a given request. Spring is then able to examine the method signature and generate the appropriate parameters before calling the method. In the case where you return a ModelAndView object, the Model is created when the constructor is called based on the parameters you provide. If you don't provide any model objects, then an empty model is created. However, when you specify that you should receive the model as a parameter to your handler method, Spring creates an instance of a Model object for you and passes it to your method. Spring holds on to a reference to that model and, when your method returns, passes that model along to the web view (for example a JSP parser). It really is effectively the same as returning a ModelAndView object except it makes unit testing a lot easier and frankly, IMO makes for a cleaner and more elegant implementation. Note: Keep in mind that a Model is really just a special Map object (hence why Spring supports using a Model or Map interchangeably in the method signatures). There are a few additional methods and it also supports implicit attribute naming. For instance, if you were to simply pass an object without giving it a name, the Model object will figure out what to name the object based on object type, etc. However, if you always provide a "key" for the object you add to the model, it behaves exactly the same as a Map .
