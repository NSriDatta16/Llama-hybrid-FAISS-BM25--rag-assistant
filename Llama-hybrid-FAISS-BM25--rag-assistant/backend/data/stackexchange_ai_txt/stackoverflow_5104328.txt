[site]: stackoverflow
[post_id]: 5104328
[parent_id]: 5103380
[tags]: 
The error that is causing your compile problems is that you are directly casting an expression to the type Either (IO ()) (String, [String]) when it is not an Either value. (The compiler is not outputting a very helpful error message.) To create an Either value [1], we use the data constructors Left and Right . Convention (from the library page) is that errors are a Left value, while correct values are a Right value. I did a quick rewrite of your arg checking function as checkArgs :: [String] -> Either String (String, [String]) checkArgs args = case args of [] -> Left "No arguments given. See --help for more info." _ -> let (params@(param:_),rest) = span (\(c:_) -> c=='-') args in if length params > 1 then Left ("No arguments given for " ++ param) else let (pArgs,_) = span (\(c:_) -> c/='-') rest in Right (param, pArgs) Note that the arg checking function does not interact with any external IO () library functions and so has a purely functional type. In general if your code does not have monadic elements ( IO () ), it can be clearer to write it in purely functional style. (When starting out in Haskell this is definitely something I would recommend rather than trying to get your head around monads/monad transformers/etc immediately.) When you are a little more comfortable with monads, you may want to check out Control.Monad.Error [2], which can wraps similar functionality as Either as a monad and would encapsulate some details like Left always being computation errors. [1] http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Either.html [2] http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Error.html
