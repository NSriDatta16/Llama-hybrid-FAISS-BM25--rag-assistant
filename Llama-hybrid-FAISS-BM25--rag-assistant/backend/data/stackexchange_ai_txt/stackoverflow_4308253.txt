[site]: stackoverflow
[post_id]: 4308253
[parent_id]: 2079988
[tags]: 
If you're just starting out with DirectShow programming, this might be a bit of a hill climb, but I hope it's of some help, or points you in the right direction. M$DN has a page describing how to select a capture device . It's a little thin on examples, so I've provided a simple implementation below. The theory is that you need to enumerate all devices in the CLSID_VideoInputDeviceCategory , and attempt to create a render graph for each valid item in the category. First I'll show you the code to iterate the names of the devices in the category. Below are 3 static functions you can use to iterate the devices in a category. Once you've added these functions to your project, you can list the devices in the Video Input Device category by calling the following function: ListDevicesInCategory(CLSID_VideoInputDeviceCategory); Okay, here are the three functions. ListDevicesInCategory() is where the work happens. It depends on other two functions, FindDeviceInCategory() and CountDevicesInCategory() #define RFAIL(x) { HRESULT hr = x; if(FAILED(hr)) {return hr;} } static HRESULT FindDeviceInCategory(IBaseFilter** pSrc, const IID& cls, wstring& wFilterName,int devNum) { CComPtr spDevEnum; CComPtr spEnum; int i; RFAIL( spDevEnum.CoCreateInstance(CLSID_SystemDeviceEnum) ); RFAIL( spDevEnum->CreateClassEnumerator(cls, &spEnum, 0) ); if(spEnum == 0) return E_FAIL; for(i = 0; i >= 0; i++) { CComPtr spiMoniker; if( spEnum->Next(1, &spiMoniker, 0) != S_OK ) return E_FAIL; if( devNum == i) { CComVariant varName; CComPtr spiPropBag; RFAIL(spiMoniker->BindToStorage(0, 0, IID_IPropertyBag,reinterpret_cast (&spiPropBag))); RFAIL(spiPropBag->Read(L"FriendlyName", &varName, 0)); RFAIL(spiMoniker->BindToObject(0, 0, IID_IBaseFilter, reinterpret_cast (pSrc))); wFilterName = V_BSTR(&varName); varName.Clear(); return S_OK; } } return E_FAIL; } static HRESULT CountDevicesInCategory( int *pCount, const IID& categoryClass ) { // pass in a category class like CLSID_VideoInputDeviceCategory, writes the count of the number of filters in that category // available on the local machine HRESULT hr = S_OK; CComPtr spIDevEnum; CComPtr spIEnum; CComPtr spIMoniker; hr = CoCreateInstance(CLSID_SystemDeviceEnum, 0, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, reinterpret_cast (&spIDevEnum)); if( ! SUCCEEDED(hr) || hr == S_FALSE ) { *pCount = 0; return hr; } hr = spIDevEnum->CreateClassEnumerator( categoryClass, &spIEnum, 0 ); if( ! SUCCEEDED(hr) || hr == S_FALSE ) { *pCount = 0; return hr; } if( spIEnum ) { while( spIEnum->Next(1, &spIMoniker, 0) == S_OK ) { (*pCount) ++; spIMoniker.Detach(); } } return S_OK; } static HRESULT ListDevicesInCategory( const GUID & cls ) { CComPtr spSource; wstring * psNextFilter = NULL; int nDeviceNum = 0; int nTotalNumDevices = 0; HRESULT hr = S_OK; bool bComplete = false; DeviceNames CaptureDeviceNames; if( FAILED(CountDevicesInCategory( &nTotalNumDevices, (IID)cls )) ) bComplete = TRUE; if( nTotalNumDevices == 0 ) bComplete = TRUE; while( ! bComplete ) { psNextFilter = new std::wstring; hr = FindDeviceInCategory( &spSource, (IID)cls, *psNextFilter, nDeviceNum++ ); if( SUCCEEDED(hr) && spSource ) { if ( *psNextFilter ) { wcout Once you've identified an item in a category that you're interested in, you can add it to a graph with the IGraphBuilder::AddFilter call. To add a filter to your graph, you'll first need to get an IBaseFilter* to that filter. I've got one more function for you to do this with. Define an IBaseFilter smart pointer: CComPtr spSource; Attach to the filter: m_spSource.Attach( GetFilter(CLSID_VideoInputDeviceCategory, CComBSTR(L"Osprey-450e Video Device 1A")) ); Here's that last function - GetFilter: static IBaseFilter * GetFilter( REFCLSID clsidDeviceClass, CComBSTR & sName ) { HRESULT hr; IBaseFilter * pRetFilter = NULL; ICreateDevEnum * pSysDevEnum = NULL; IEnumMoniker * pEnum = NULL; IMoniker * pMoniker = NULL; int nSameSrcCounter = 0; hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (void**)&pSysDevEnum); if( pSysDevEnum ) hr = pSysDevEnum->CreateClassEnumerator(clsidDeviceClass, &pEnum, 0); if (hr != S_OK) return NULL; USES_CONVERSION; while ( pEnum->Next(1, &pMoniker, NULL) == S_OK ) { IPropertyBag *pPropBag = NULL; VARIANT var; VariantInit(&var); pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag); hr = pPropBag->Read(L"FriendlyName", &var, 0); if (SUCCEEDED(hr)) { if(sName == OLE2T(var.bstrVal)) { hr = pMoniker->BindToObject(NULL, NULL, IID_IBaseFilter, (void**)&pRetFilter); if (FAILED(hr)) pRetFilter = NULL; VariantClear(&var); pPropBag->Release(); pMoniker->Release(); break; } } VariantClear(&var); pPropBag->Release(); pMoniker->Release(); } pSysDevEnum->Release(); pEnum->Release(); return pRetFilter; }
