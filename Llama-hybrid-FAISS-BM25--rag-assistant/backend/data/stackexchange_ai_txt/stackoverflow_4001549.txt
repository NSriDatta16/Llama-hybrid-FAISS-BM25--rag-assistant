[site]: stackoverflow
[post_id]: 4001549
[parent_id]: 271398
[tags]: 
And one more: public enum ParseFailBehavior { ReturnNull, ReturnDefault, ThrowException } public static T? ParseNullableEnum (this string theValue, ParseFailBehavior desiredBehavior = ParseFailBehavior.ReturnNull) where T:struct { T output; T? result = Enum.TryParse (theValue, out output) ? (T?)output : desiredBehavior == ParseFailBehavior.ReturnDefault ? (T?)default(T) : null; if(result == null && desiredBehavior == ParseFailBehavior.ThrowException) throw new ArgumentException("Parse Failed for value {0} of enum type {1}". FormatWith(theValue, typeof(T).Name)); } This version requires .NET 4.0; in 3.5 you have no TryParse and no optional parameters; you're stuck with Enum.Parse() which you have to try-catch. It's still totally doable in 3.5 (and much more useful as Enum.Parse() is oogly and your only other option): public static T? ParseNummableEnum (this string theValue) { return theValue.ParseNullableEnum (ParseFailBehavior.ReturnNull); } public static T? ParseNullableEnum (this string theValue, ParseFailBehavior desiredBehavior) where T:struct { try { return (T?) Enum.Parse(typeof (T), theValue); } catch (Exception) { if(desiredBehavior == ParseFailBehavior.ThrowException) throw; } return desiredBehavior == ParseFailBehavior.ReturnDefault ? (T?)default(T) : null; } Usage: //returns null if OptionOne isn't an enum constant var myEnum = "OptionOne".ParseNullableEnum (); //guarantees a return value IF the enum has a "zero" constant value (generally a good practice) var myEnum = "OptionTwo".ParseNullableEnum (ParseFailBehavior.ReturnDefault).Value
