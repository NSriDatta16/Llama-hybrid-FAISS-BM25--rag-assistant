[site]: stackoverflow
[post_id]: 2007782
[parent_id]: 1960786
[tags]: 
That's always going to be the case. PDF doesn't have circles in the primitives, only beziers. The PDF imaging model was built from the PostScript imaging model, which itself only provides circles using the arc/arcto primitives, which themselves are implemented in terms of beziers. Oddly enough, I had call to do this exact task in some test code I'm working on that generates PDF's. Here's how I did it: private void DrawEllipse(PdfGraphics g, double xrad, double yrad) { const double magic = 0.551784; double xmagic = xrad * magic; double ymagic = yrad * magic; g.MoveTo(-xrad, 0); g.CurveTo(-xrad, ymagic, -xmagic, yrad, 0, yrad); g.CurveTo(xmagic, yrad, xrad, ymagic, xrad, 0); g.CurveTo(xrad, -ymagic, xmagic, -yrad, 0, -yrad); g.CurveTo(-xmagic, -yrad, -xrad, -ymagic, -xrad, 0); } private void DrawCircle(PdfGraphics g, double radius) { DrawEllipse(g, radius, radius); } Assume that PdfGraphics is a class that spews out PDF commands, so g.MoveTo(x, y) will turn into "x y m" in the content stream. I took my math and my magic number from Don Lancaster's fabulous explanation (PDF, naturally). This assumes that the circle or ellipse will be drawn at the origin. To move it somewhere else, do a translation transform first or modify the code to subtract add in the desired origin. This code gives a worst case error of roughly 1/1250 (about .08 %) and average of 1/2500 (about .04%).
