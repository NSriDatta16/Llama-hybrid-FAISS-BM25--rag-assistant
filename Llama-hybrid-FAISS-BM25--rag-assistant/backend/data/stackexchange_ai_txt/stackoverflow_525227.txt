[site]: stackoverflow
[post_id]: 525227
[parent_id]: 
[tags]: 
Console menu updating OpenGL window

I am making an application that does some custom image processing. The program will be driven by a simple menu in the console. The user will input the filename of an image, and that image will be displayed using openGL in a window. When the user selects some processing to be done to the image, the processing is done, and the openGL window should redraw the image. My problem is that my image is never drawn to the window, instead the window is always black. I think it may have to do with the way I am organizing the threads in my program. The main execution thread handles the menu input/output and the image processing and makes calls to the Display method, while a second thread runs the openGL mainloop. Here is my main code: #include #include #include "ImageProcessor.h" #include "BitmapImage.h" using namespace std; DWORD WINAPI openglThread( LPVOID param ); void InitGL(); void Reshape( GLint newWidth, GLint newHeight ); void Display( void ); BitmapImage* b; ImageProcessor ip; int main( int argc, char *argv[] ) { DWORD threadID; b = new BitmapImage(); CreateThread( 0, 0, openglThread, NULL, 0, &threadID ); while( true ) { char choice; string path = "TestImages\\"; string filename; cout > filename; path += filename; b = new BitmapImage( path ); Display(); cout > choice; if( choice == '1' ) { ip.InvertColour( *b ); } else { ip.LineThinning( *b ); } Display(); } return 0; } void InitGL() { int argc = 1; char* argv[1]; argv[0] = new char[20]; strcpy( argv[0], "main" ); glutInit( &argc, argv ); glutInitDisplayMode( GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH); glutInitWindowPosition( 0, 0 ); glutInitWindowSize( 800, 600 ); glutCreateWindow( "ICIP Program - Character recognition using line thinning, Hilbert curve, and wavelet approximation" ); glutDisplayFunc( Display ); glutReshapeFunc( Reshape ); glClearColor(0.0,0.0,0.0,1.0); glEnable(GL_DEPTH_TEST); } void Reshape( GLint newWidth, GLint newHeight ) { /* Reset viewport and projection parameters */ glViewport( 0, 0, newWidth, newHeight ); } void Display( void ) { glClear (GL_COLOR_BUFFER_BIT); // Clear display window. b->Draw(); glutSwapBuffers(); } DWORD WINAPI openglThread( LPVOID param ) { InitGL(); glutMainLoop(); return 0; } Here is my draw method for BitmapImage: void BitmapImage::Draw() { cout Any ideas as to the problem? Edit: The problem was technically solved by starting a glutTimer from the openglThread which calls glutPostRedisplay() every 500ms. This is OK for now, but I would prefer a solution in which I only have to redisplay every time I make changes to the bitmap (to save on processing time) and one in which I don't have to run another thread (the timer is another thread im assuming). This is mainly because the main processing thread is going to be doing a lot of intensive work and I would like to dedicate most of the resources to this thread rather than anything else.
