[site]: stackoverflow
[post_id]: 1290674
[parent_id]: 1290623
[tags]: 
Here is a query that produces the log of all events in a given period, along with the current count of calls when the event occured. It uses several CTEs to build up the needed data in a logical sequence of steps: select calls started before start time, substract calls ended before start time, add call events between start and end time. This result set is then used to produce the timeline of events, along with a count of current calls at any event. The CTEs are used simply because I find them much more easier to read and understand than derived tables. declare @temp table ( EvId int not null , CallId uniqueidentifier not null , DateTime Datetime not null); declare @starttime datetime , @endtime datetime; select @starttime = '7/10/2008 1:33:14 PM'; select @endtime = '7/10/2008 1:43:14 PM'; -- These are all the calls -- that started before the start time with started_call as ( select * from call_log where DateTime This query produces a plan that does not scan the entire log table, given proper indexes exists in place. It gives correct results for any interval, tacking into account existing calls at the interval start time. In my testing on 1 mil log records it consistently produced events for 10 minutes intervals in 1.1s (628ms to produce the @temp table, 505ms to produce the timeline with current count) on a 1.5GB RAM single proc laptop. Performance on large tables can be improved if a restriction on the maximum duration of any call is introduced, because the search for existing calls at start time can then be bounded on the lower end (DatTime >= start time - max duration of a call). The use of an intermediate @temp table variable is no elegant, but is efficient. Here is a sample output: EvId CallId DateTime cnt 1 401D9E00-040C-4B0E-8864-C66B72CF47AA 2008-07-10 13:33:16.000 23 10 401D9E00-040C-4B0E-8864-C66B72CF47AA 2008-07-10 13:33:16.000 23 1 8BF7AF50-B32C-464A-AF01-FDB653F0517D 2008-07-10 13:33:18.000 22 10 8BF7AF50-B32C-464A-AF01-FDB653F0517D 2008-07-10 13:33:18.000 22 0 CB523E24-5CE2-4E36-9D6C-4AE7BCEB1F53 2008-07-10 13:33:19.000 21 1 4A54EEB6-A899-4167-9D5C-2CE1BC838FFB 2008-07-10 13:33:20.000 22 Here is how I created and loaded the test data. Note the clustered index and nonclustered index on the table, they are both critical. create table call_log (id int identity(1,1) not null , EvId int not null , CallId uniqueidentifier not null , DateTime Datetime not null); create clustered index cdx_call_log on call_log(EvId, DateTime); create nonclustered index idx_call_log_call_id on call_log(CallId); go set nocount on; declare @i int, @date datetime, @callId uniqueidentifier; select @i = 0, @date = '7/10/2008 12:33:14 PM'; begin transaction while @i
