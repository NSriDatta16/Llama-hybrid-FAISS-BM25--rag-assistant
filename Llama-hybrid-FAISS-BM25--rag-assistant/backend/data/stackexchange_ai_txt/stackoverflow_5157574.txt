[site]: stackoverflow
[post_id]: 5157574
[parent_id]: 
[tags]: 
Receiving mixed media over Java socket. Yours better?

I'm about to give a programming exercice in Java and I'd like my students to discover the intrinsics of HTTP themselves rather than having URLConnection doing all the job for them. In order to estimate the complexity, I came up with the following snippet, which parses the reply (imho, one of the hardest part of the job), which will return e.g. "HTTP/1.1 200 OK" , push things like "Server: makato" and "content-length: 1337" in the headers vector and leave the InputStream at the first byte of the content, so that a DataInputStream or a InputStreamReader can later be built on top of it safely. I'm curious to know if someone with more experience of the Java classes could suggest more elegant alternatives. One thing I'm not pleased with is that each individual is.read() will inevitably generate an additional system call (assuming that Socket.getInputStream() is used to feed is argument). public static String recvHttpHeaders(InputStream is, Vector headers) throws Exception { byte line[] = new byte[512]; String pending=null; String status=null; boolean complete=false, CR=false; int n=0; while (!complete) { int x = is.read(); switch(x) { case -1: throw new Exception("something went wrong"); case '\r': if (CR) throw new Exception("encoding mismatch CRCR"); CR=true; break; case '\n': // bare LF are accepted silently. String ln = new String(line,0,n,"ASCII"); if (pending!=null) ln = pending + ln; if (status==null) status = ln; else headers.add(ln); complete = ln.length()==0; pending = null; n=0; CR=false; break; default: if (CR) throw new Exception("encoding mismatch ?CR"); if (n>=512) { String part = new String(line, "ASCII"); if (pending!=null) pending += part; else pending = part; n=0; } line[n++]=(byte)x; break; } } return status; } edit : admittedly, one would love to use xxx.readline() here to avoid messing up with lines reconstruction. BufferedReader (or any other *Reader, actually) converts bytes into chars according to one charset. That means I'm no longer free to chose that charset for the content if I used that feature in the header parsing. I haven't found any byte-level classes that has readline ability built-in. performance solution : Thanks for pointing out BufferedInputStream. I made a few additional tests, and indeed, invoking as BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); String status = recvHttpHeaders(bis, headers); rawCopy(bis, output); indeed reduce the amount of system calls performed and still allow me to properly receive binary content unmodified.
