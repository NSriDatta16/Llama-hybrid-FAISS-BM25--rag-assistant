[site]: stackoverflow
[post_id]: 2813692
[parent_id]: 2813484
[tags]: 
The lowercase letters in the type declarations are type variables . This means that when there is an a this must be the same type. Bracketed (eg (a -> b) ) subexpressions tend to mean that the function accepts a function as one of its parametres. Rectangular brackets indicate a list of something. So map accepts these arguments: (a -> b) a function that accepts one argument [a] a list that the first argument function can act on and produces [b] a list as a result. We can decode (.) the same way: (a -> b) is a function that accepts a single argument (c -> a) is a function that produces the same typa as the argument to the first function c an argument of the same type that the second function uses However Haskell can do a neat thing and that is if you omit an argument it returns a function that has the remaining signature. So (.) is commonly used to chain functions. Let's say we have 2 functions ord :: Char -> Int which takes a character and returns it's integer representation and add32 :: Int -> Int that adds 32 to it's argument. When we write upcaseVal = add32 . ord the function upcaseVal now has the signature upcaseVal :: Char -> Int because the (.) function would have left it with c -> b and we substitue thes in the function definition. So foldr map would have to be like this: foldr 's first argument is a function that takes 2 arguments which map is. Since the functions output has to be of the same type as the second argument ( (a -> b -> b ) we see that in map a = b Thus the final type will be: (b -> b) -> [b] -> [b] -> b -> [b] -> b But I guess that doesn't have to bother you that much since the compiler deals with stuff like this most of the time.
