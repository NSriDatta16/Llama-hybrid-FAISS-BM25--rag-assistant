[site]: stackoverflow
[post_id]: 4638090
[parent_id]: 4637463
[tags]: 
When you create an index on a column or columns in MySQL table, the database is creating a data structure called a B-tree (assuming you use the default index setting), for which the key of each record is a concatenation of the values in the indexed columns. For example, let's say you have a table that is defined like: CREATE TABLE mytable ( id int unsigned auto_increment, column_a char(32) not null default '', column_b int unsigned not null default 0, column_c varchar(512), column_d varchar(512), PRIMARY KEY (id) ) ENGINE=MyISAM; Then let's give it some data: INSERT INTO mytable VALUES (1, 'hello', 2, null, null); INSERT INTO mytable VALUES (2, 'hello', 3, 'hi', 'there'); INSERT INTO mytable VALUES (3, 'how', 4, 'are', 'you?'); INSERT INTO mytable VALUES (4, 'foo', 5, '', 'bar'); Now suppose you decide to add a key to column_a and column_b like: ALTER TABLE mytable ADD KEY (column_a, column_b); The database is going to create the aforementioned B-tree, which will have four keys in it, one for each row: hello-2 hello-3 how-4 foo-5 When you perform a search that references the column_a column, or that references the column_a AND column_b columns, the database will be able to use this index to narrow the record set it has to examine. Let's say you have a query like: SELECT ... FROM mytable WHERE column_a = 'hello'; Even though the above query does not specify a value for the column_b column, it can still take advantage of our index by looking for all keys that begin with "hello". For the same reason, if you had a query like: SELECT ... FROM mytable WHERE column_b = '2'; This query would NOT be able to use our index, because it would have to parse the index keys themselves to try to determine which keys' second value matches '2', which is terribly inefficient. Now, let's address your original question of the maximum length. Suppose we try to create an index spanning all four non-PK columns in this table: ALTER TABLE mytable ADD KEY (column_a, column_b, column_c, column_d); You will get an error: ERROR 1071 (42000): Specified key was too long; max key length is 1000 bytes In this case our column lengths are 32, 10, 512, and 512, which in a single-byte-per-character situation is 1066, which is above the limit of 1000. Suppose that it DID work; you would be creating the following keys: hello-2- hello-3-hi-there how-4-are-you? foo-5--bar Now, suppose that you had values in column_c and column_d that were very long -- 512 characters each. Even in a basic single-byte character set, your keys would now be over 1000 bytes in length, which is what MySQL is complaining about. It gets even worse with multibyte character sets, where seemingly "small" columns can still push the keys over the limit. If you MUST use a large compound key, one solution is to use InnoDB tables rather than the default MyISAM tables, which support a larger key length (3500 bytes) -- you can do this by swapping ENGINE=InnoDB instead of ENGINE=MyISAM in the declaration above. However, generally speaking, if you are using long keys there is probably something wrong with your table design. Remember that single-column indexes often provide more utility than multi-column indexes. You want to use a multi-column index when you are going to often/always take advantage of it by specifying all of the necessary criteria in your queries. Also, as others have mentioned, do NOT index every column of a table, since each index is adding storage overhead to your database. You want to limit your indexes to the columns that are frequently used by queries, and if it seems like you need too many, you should probably think about breaking up your tables up into more logical components.
