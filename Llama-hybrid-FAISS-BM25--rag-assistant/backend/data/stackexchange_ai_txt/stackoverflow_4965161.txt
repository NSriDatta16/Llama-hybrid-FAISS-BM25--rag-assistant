[site]: stackoverflow
[post_id]: 4965161
[parent_id]: 4673475
[tags]: 
In general with the GWT.runAsync method you can create exclusive fragments or leftovers. In order to move a piece of code from the initial download to an exclusive fragment, not only you have to use the runAsync method but you also have to make sure that the code in the runAsync method is not referenced in sync parts of your application. Provided this condition is satisfied, your code can end up in an exclusive fragment (if the code is not used by other runAsync methods) or a leftover (if it is referenced in mulptiple runAsync method). //Class A is referenced only here! GWT.runAsync(new RunAsyncCallback() { @Override public void onSuccess() { a = new A(); } @Override public void onFailure(Throwable reason) { ... } }); .... //Class B is referenced in different points but always inside async calls! GWT.runAsync(new RunAsyncCallback() { @Override public void onSuccess() { b = new B(); } @Override public void onFailure(Throwable reason) { ... } }); .... GWT.runAsync(new RunAsyncCallback() { @Override public void onSuccess() { b = new B(); } @Override public void onFailure(Throwable reason) { .... } }); The code relative to class A will be in an exclusive fragment, class B will be in a leftover. In general, i suggest you use Compile Reports to understand what's going on in code splitting. Also: calling runAsync in onModuleLoad doesn't make much sense. 1MB? Are you sure? maybe post an example and I can try to understand what's going on
