[site]: stackoverflow
[post_id]: 4915194
[parent_id]: 4915176
[tags]: 
Your problem may be due to your mixing AWT and Swing (heavy weight and light weight) components in the same program, and this is something that shouldn't be done, unless you have definite need of this and know what you're doing. I doubt that you need a ChangeListener as JScrollPanes should be able to handle this sort of thing out of the box. Have you tried having your class extend JPanel or JComponent instead of Canvas? Also, when posting code, consider creating and posting an SSCCE , a small compilable runnable program that we can run, test, modify, and hopefully correct. If you create and post this type of code, you'll likely get a decent and complete solution quickly. edit: I created a test program to see what effect Canvas has on JScrollPanes, and it's as I thought -- the Canvas covers over the scroll bars, and everything else. To see for yourself compile and run this code and then resize the JFrame by clicking and dragging. The Canvas is blue and is in a JScrollPane on the left while the JPanel is red and is in a JScrollPane on the right. import java.awt.*; import javax.swing.*; @SuppressWarnings("serial") public class CanvasInScrollPane extends JPanel { private static final Dimension CANVAS_SIZE = new Dimension(300, 300); private static final Dimension APP_SIZE = new Dimension(500, 250); Canvas canvas = new Canvas(); JPanel panel = new JPanel(); public CanvasInScrollPane() { canvas.setPreferredSize(CANVAS_SIZE); canvas.setBackground(Color.blue); panel.setPreferredSize(CANVAS_SIZE); panel.setBackground(Color.red); setPreferredSize(APP_SIZE); setLayout(new GridLayout(1, 0, 5, 0)); add(new JScrollPane(canvas)); add(new JScrollPane(panel)); } private static void createAndShowUI() { JFrame frame = new JFrame("CanvasInScrollPane"); frame.getContentPane().add(new CanvasInScrollPane()); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.pack(); frame.setLocationRelativeTo(null); frame.setVisible(true); } public static void main(String[] args) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { createAndShowUI(); } }); } }
