[site]: stackoverflow
[post_id]: 4687759
[parent_id]: 4687607
[tags]: 
The top component will get the mouse click. How much the JLabel will cover will depend on its size and on the JPanel's layout manager. One way is to give the listener to the JLabel (as has also been mentioned above), but another way to do it is as I describe below, and while perhaps not the best way, it worked well for me: 1) A JLayeredPane holds everything and has a MouseAdapter that is added as a MouseListener and MouseMotionListener. 2) A JPanel, called "board", that uses GridLayout(8, 8) and is the exact size as the JLayeredPane is added to the layered pane's bottom layer, or to be precise, the JLayeredPane.DEFAULT_LAYER. 3) This JPanel holds 64 other small JPanel squares in the GridLayout (actually the squares extend from JPanel), and each uses GridBagLayout. 4) The chess pieces are JLabels and are held by the JPanel squares. 5) In the MouseAdapter mousePressed method, I get the Point, p, that the mouse is located at via e.getPoint (if e is the MouseEvent object passed to the method). I then find out which square holds this point by calling findComponentAt(p) on the board JPanel. I then check to see if this square holds a piece. If so, the piece is removed from the square and added directly to the JLayeredPane's JLayeredPane.DRAG_LAYER. 6) If a chess piece is held in the JLayeredPane's JLayeredPane.DRAG_LAYER the MouseAdapter's mouseDragged method will control the piece's location. 7) On mouseRelease, I again find out which square holds the mouse's location or Point by the same technique as above, using findComponentAt(p) and if it is a valid square, I remove the chess piece from the JLayeredPane's JLayeredPane.DRAG_LAYER and place it in the square. If it's off the board or not a valid square, I return the chess piece to the original location. Note that if the board JPanel doesn't completely fill the JLayeredPane, then its offset within the JLayeredPane must be used to correct the location Point, p before calling findComponentAt(p) since the MouseAdapter will return Points relative to the JLayeredPane not the board JPanel. For example: import java.awt.*; import java.awt.event.*; import java.awt.image.BufferedImage; import javax.swing.*; public class Chess2 { private static void createAndShowUI() { JFrame frame = new JFrame("Chess 2"); frame.getContentPane().add(new Chess2Gui().getMainComponent()); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.pack(); frame.setLocationRelativeTo(null); frame.setVisible(true); } public static void main(String[] args) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { createAndShowUI(); } }); } } class Chess2Gui { private static final int RANKS = 8; private static final int FILES = 8; private static final Color DARK_COLOR = new Color(0, 100, 0); private static final Color LIGHT_COLOR = new Color(200, 200, 200); private static final Color DARK_PIECE_COLOR = Color.black; private static final int SQR_WIDTH = 80; private static final int PIECE_WIDTH = 60; private static final Dimension SQR_SIZE = new Dimension(SQR_WIDTH, SQR_WIDTH); private JLayeredPane mainLayeredPane = new JLayeredPane(); private JPanel board = new JPanel(new GridLayout(RANKS, FILES)); private JPanelSquare[][] jPanelSquareGrid = new JPanelSquare[RANKS][FILES]; public Chess2Gui() { for (int rank = 0; rank
