[site]: stackoverflow
[post_id]: 1331497
[parent_id]: 1331487
[tags]: 
Basic Friendly names Use the Description attribute: * enum MyEnum { [Description("This is black")] Black, [Description("This is white")] White } And a handy extension method for enums: public static string GetDescription(this Enum value) { FieldInfo field = value.GetType().GetField(value.ToString()); object[] attribs = field.GetCustomAttributes(typeof(DescriptionAttribute), true); if(attribs.Length > 0) { return ((DescriptionAttribute)attribs[0]).Description; } return string.Empty; } Used like so: MyEnum val = MyEnum.Black; Console.WriteLine(val.GetDescription()); //writes "This is black" (Note this doesn't exactly work for bit flags...) For localization There is a well-established pattern in .NET for handling multiple languages per string value - use a resource file , and expand the extension method to read from the resource file: public static string GetDescription(this Enum value) { FieldInfo field = value.GetType().GetField(value.ToString()); object[] attribs = field.GetCustomAttributes(typeof(DescriptionAttribute), true)); if(attribs.Length > 0) { string message = ((DescriptionAttribute)attribs[0]).Description; return resourceMgr.GetString(message, CultureInfo.CurrentCulture); } return string.Empty; } Any time we can leverage existing BCL functionality to achieve what we want, that's definitely the first route to explore. This minimizes complexity and uses patterns already familiar to many other developers. Putting it all together To get this to bind to a DropDownList, we probably want to track the real enum values in our control and limit the translated, friendly name to visual sugar. We can do so by using an anonymous type and the DataField properties on the list: myDDL.DataSource = Enum.GetValues(typeof(MyEnum)).OfType ().Select( val => new { Description = val.GetDescription(), Value = val.ToString() }); myDDL.DataBind(); Let's break down that DataSource line: First we call Enum.GetValues(typeof(MyEnum)) , which gets us a loosely-typed Array of the values Next we call OfType () which converts the array to an IEnumerable Then we call Select() and provide a lambda that projects a new object with two fields, Description and Value. The DataTextField and DataValueField properties are evaluated reflectively at databind-time, so they will search for fields on DataItem with matching names. - Note in the main article, the author wrote their own DescriptionAttribute class which is unnecessary, as one already exists in .NET's standard libraries. -
