[site]: stackoverflow
[post_id]: 2339065
[parent_id]: 2339027
[tags]: 
First, remember the Rules of Optimization . But this is possible in C or C++ using bitfields: struct mystruct { unsigned int smallint1 : 3; /* 3 bits wide, values 0 -- 7 */ signed int smallint2 : 4; /* 4 bits wide, values -8 -- 7 */ unsigned int boolean : 1; /* 1 bit wide, values 0 -- 1 */ }; It's worth noting that while you gain by not requiring so much storage, you lose because it becomes more costly to access everything, since each read or write now has a bunch of bit twiddling mechanics associated with it. Given that storage is cheap, it's probably not worth it. Edit: You can also use vector to store 1-bit bools; but beware of it because it doesn't act like a normal vector ! In particular, it doesn't provide iterators. It's sufficiently different that it's fair to say a vector is not actually a vector . Scott Meyers wrote very clearly on this topic in 'Effective STL'.
