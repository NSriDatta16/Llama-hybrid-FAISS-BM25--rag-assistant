[site]: stackoverflow
[post_id]: 2201100
[parent_id]: 2158981
[tags]: 
Although I am still not sure about when your use case would make sense (see my comment on the question itself), I would like to contribute a working example that is in my opinion more readable than thread-local storage (whether static or instance). The example is using .NET 3.5: using System; using System.Collections.Generic; using System.Text; using System.Threading; using System.Linq; namespace SimulatedThreadLocal { public sealed class Notifier { public void Register(Func callback) { var id = Thread.CurrentThread.ManagedThreadId; lock (this._callbacks) { List > list; if (!this._callbacks.TryGetValue(id, out list)) { this._callbacks[id] = list = new List >(); } list.Add(callback); } } public void Execute() { var id = Thread.CurrentThread.ManagedThreadId; IEnumerable > threadCallbacks; string status; lock (this._callbacks) { status = string.Format("Notifier has callbacks from {0} threads, total {1} callbacks{2}Executing on thread {3}", this._callbacks.Count, this._callbacks.SelectMany(d => d.Value).Count(), Environment.NewLine, Thread.CurrentThread.ManagedThreadId); threadCallbacks = this._callbacks[id]; // we can use the original collection, as only this thread can add to it and we're not going to be adding right now } var b = new StringBuilder(); foreach (var callback in threadCallbacks) { b.AppendLine(callback()); } Console.ForegroundColor = ConsoleColor.DarkYellow; Console.WriteLine(status); Console.ForegroundColor = ConsoleColor.Green; Console.WriteLine(b.ToString()); } private readonly Dictionary >> _callbacks = new Dictionary >>(); } public static class Program { public static void Main(string[] args) { try { var notifier = new Notifier(); var syncMainThread = new ManualResetEvent(false); var syncWorkerThread = new ManualResetEvent(false); ThreadPool.QueueUserWorkItem(delegate // will create closure to see notifier and sync* events { notifier.Register(() => string.Format("Worker thread callback A (thread ID = {0})", Thread.CurrentThread.ManagedThreadId)); syncMainThread.Set(); syncWorkerThread.WaitOne(); // wait for main thread to execute notifications in its context syncWorkerThread.Reset(); notifier.Execute(); notifier.Register(() => string.Format("Worker thread callback B (thread ID = {0})", Thread.CurrentThread.ManagedThreadId)); syncMainThread.Set(); syncWorkerThread.WaitOne(); // wait for main thread to execute notifications in its context syncWorkerThread.Reset(); notifier.Execute(); syncMainThread.Set(); }); notifier.Register(() => string.Format("Main thread callback A (thread ID = {0})", Thread.CurrentThread.ManagedThreadId)); syncMainThread.WaitOne(); // wait for worker thread to add its notification syncMainThread.Reset(); notifier.Execute(); syncWorkerThread.Set(); syncMainThread.WaitOne(); // wait for worker thread to execute notifications in its context syncMainThread.Reset(); notifier.Register(() => string.Format("Main thread callback B (thread ID = {0})", Thread.CurrentThread.ManagedThreadId)); notifier.Execute(); syncWorkerThread.Set(); syncMainThread.WaitOne(); // wait for worker thread to execute notifications in its context syncMainThread.Reset(); } finally { Console.ResetColor(); } } } } When you compile and run the above program, you should get output like this: alt text http://img695.imageshack.us/img695/991/threadlocal.png Based on your use-case I assume this is what you're trying to achieve. The example first adds two callbacks from two different contexts, main and worker threads. Then the example runs notification first from main and then from worker threads. The callbacks that are executed are effectively filtered by current thread ID. Just to show things are working as expected, the example adds two more callbacks (for a total of 4) and again runs the notification from the context of main and worker threads. Note that Notifier class is a regular instance that can have state, multiple instances, etc (again, as per your question's use-case). No static or thread-static or thread-local is used by the example. I would appreciate if you could look at the code and let me know if I misunderstood what you're trying to achieve or if a technique like this would meet your needs.
