[site]: crossvalidated
[post_id]: 465235
[parent_id]: 464705
[tags]: 
There are many R packages that can fit ARIMA models to break-point data. I compiled an overview of some of them here: https://lindeloev.github.io/mcp/articles/packages.html . Fewer of these can do a model comparison. I created the mcp package for this (an several other) purposes, so you may want to check out the docs on model comparison in mcp . One advantage of Bayesian methods is that they inherently penalize more complex model due to their larger predictive space, whereas you have to do some tricks using frequentist methods. As of version 0.2, mcp only does AR(N) models - not MA(N) or ARIMA(N). From your description, your two models would be: # The two models model_break = list( y ~ 1 + x + ar(1), ~ 1 + x ) model_null = list(y ~ 1 + x + ar(1)) # Fit them library(mcp) fit_break = mcp(model_break, data) fit_null = mcp(model_null, data) # Compare them fit_break $loo = loo(fit_break) fit_null$ loo = loo(fit_null) loo::loo_compare(fit_break $loo, fit_null$ loo) Incorporating knowledge about the change point location If you know the break point exactly, you can fix the prior to a particular value, indicating 100% certainty in that value: prior_break = list(cp_1 = 211.5) fit_break = mcp(model_null, data, prior_break) # override default priors If you know it approximately (e.g., when the policy was changed but not when the effects occur), you could set a lower bound: prior = list(cp_1 = "dunif(211.5, MAXX)") # By default, mcp infers the changepoint with a weak prior. See model fits There are several views of the model fits: Use summary(fit) for a numerical summary of the parameter estimates. Use plot(fit) for a visualization of the whole model and it's fit to data. Use plot_pars(fit) to see posterior distributions for individual parameters. fit would then be either fit_break or fit_null from above. These functions have a lot of options so check out their docs.
