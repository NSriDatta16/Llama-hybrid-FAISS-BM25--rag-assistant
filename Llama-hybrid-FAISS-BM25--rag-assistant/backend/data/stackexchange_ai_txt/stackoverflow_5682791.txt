[site]: stackoverflow
[post_id]: 5682791
[parent_id]: 5680725
[tags]: 
Note I don't speak ruby, but I intend to do have done a ruby version later just for speed comparison :) If you just iterate all numbers from 0 to 117648 ( ruby ) and print them in base-7 notation, you'll at least have discarded any numbers containing 7,8,9. This includes the optimization suggestion by MrE, apart from lifting the problem to simple int arithmetic instead of char-sequence manipulations. All that remains, is to check for the presence of at least one 6. This would make the algorithm skip at most 6 items in a row, so I deem it less unimportant (the average number of skippable items on the total range is 40%). Simple benchmark to 6666666666 (Note that this means outputting 222,009,073 (222M) lines of 6-y numbers) Staying close to this idea, I wrote this quite highly optimized C code (I don't speak ruby) to demonstrate the idea. I ran it to 282475248 (congruent to 6666666666 (mod 7)) so it was more of a benchmark to measure: 0m26.5s #include static char buf[11]; char* const bufend = buf+10; char* genbase7(int n) { char* it = bufend; int has6 = 0; do { has6 |= 6 == (*--it = n%7); n/=7; } while(n); return has6? it : 0; } void asciify(char* rawdigits) { do { *rawdigits += '0'; } while (++rawdigits != bufend); } int main() { *bufend = 0; // init long i; for (i=6; i I also benchmarked another approach, which unsurprisingly ran in less than half the time because this version directly manipulates the results in ascii string form, ready for display this version shortcuts the has6 flag for deeper recursion levels this version also optimizes the 'twiddling' of the last digit when it is required to be '6' the code is simply shorter... Running time: 0m12.8s #include #include inline void recursive_permute2(char* const b, char* const m, char* const e, int has6) { if (m Benchmarks measured with: gcc -O4 t6.c -o t6 time ./t6 > /dev/null
