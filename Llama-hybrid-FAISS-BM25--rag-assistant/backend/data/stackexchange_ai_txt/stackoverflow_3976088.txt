[site]: stackoverflow
[post_id]: 3976088
[parent_id]: 3961678
[tags]: 
As it turns out, this is one of the dark corners of the ECMA specification for ECMAScript (hence JavaScript): Finally a value is assigned for use with the this keyword. If the value assigned refers to an object then property accessors prefixed with the this keyword reference properties of that object. If the value assigned (internally) is null then the this keyword will refer to the global object. (http://jibbering.com/faq/notes/closures/ ; thanks to @ Brian Flanagan for the link) Apparently, during execution of a function that is assigned to a variable (within another Function ) the context is lost, the scope is thus set to null and this will refer to the Window Object . I'm not quite sure whether this is something to expect from a Function initialized as a local variable. Typically I would expect a closure to have access to the scope it was created while that is still in memory, including it's predecessor in the scope chain. This behaviour is different from a function that is the property of a Function Object , where the context is not lost and this will correctly point to the owner of the member Function (which is the Function Object or a member depending on how many layers there are). The solution for this problem (while maintaining private Function members, i.e. members that are only accessible from within the Function 's scope) is wrapping the function inside another Function using Function.prototype.apply (or Function.prototype.call ) to set the context manually: function F() { this.field = "value" ; var self = this ; var init = function(value) { (function() { this.field = value ; }).apply(self,value) ; } ; this.method = function() { return this.field ; } ; init( arguments[0] ) ; } This is similar to Function.prototype.bind introduced in JavaScript 1.85 as well as the PrototypeJS library. Edit: Forgot parentheses around the enclosed function in init . This will result in a SyntaxError .
