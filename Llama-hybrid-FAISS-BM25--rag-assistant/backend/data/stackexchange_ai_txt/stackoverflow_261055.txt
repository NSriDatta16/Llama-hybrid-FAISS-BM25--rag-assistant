[site]: stackoverflow
[post_id]: 261055
[parent_id]: 260658
[tags]: 
As you've certainly discovered, copying to a target directory that already exists won't work: svn cp svn://my_project/vendor/1.1 svn://my_project/trunk because trunk already exists, so you'd end up with: svn://my_project/trunk/1.1 Using merge has the unfortunate property of not keeping history of the vendor 1.1 tag in subversion prior to 1.5 which introduced merge tracking. You may not care. In this case merge would be the correct solution: svn co svn://my_project/trunk trunk-wc svn merge svn://my_project/trunk svn://my_project/vendor/1.1 trunk-wc The best way to read this merge is: First determine the changes necessary to to make trunk identical to vendor/1.1 , then apply those changes to the given working copy (also of trunk, in this case). I should point out that this merge will effectively blow away anything that was in trunk previously. So, if you have local (non-vendor) modifications already on the trunk, you'll want to apply just the changes between 1.1 and the previous vendor drop: svn co svn://my_project/trunk trunk-wc svn merge svn://my_project/vendor/1.0 svn://my_prjoect/vendor/1.1 trunk-wc If trunk exists, but is empty you've got two choices: replace the trunk, or write a little shell loop: Replacing the trunk looks like this: svn rm svn://my_project/trunk svn cp svn://my_project/vendor/1.1 svn://my_project/trunk Leveraging the shell (bash): svn co svn://my_project/trunk trunk svn co svn://my_project/vendor/1.1 1.1 ( cd 1.1 for x in * ; do svn cp $x ../trunk done ) svn ci trunk
