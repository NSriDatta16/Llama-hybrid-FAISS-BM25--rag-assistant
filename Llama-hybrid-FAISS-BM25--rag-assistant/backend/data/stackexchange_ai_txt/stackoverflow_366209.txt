[site]: stackoverflow
[post_id]: 366209
[parent_id]: 351314
[tags]: 
For one thing, the code shown does not actually describe a trie. Rather, it appears to be a tree containing a pair of elements in each node ( T* and unsigned ). You can by discipline use a tree of tuples as a trie, but it's only by convention, not enforcement. This is part of why you're having such a hard time implementing operator++ . What you need to do is have each Trie contain a left-right disjoint ADT, rather than just the raw elements. It's a layer of abstraction which is more commonly found in functional languages (e.g. Scala's Either ). Unfortunately, C++'s type system isn't quite powerful enough to do something that elegant. However, there's nothing preventing you from doing this: template class Either { public: Either(L *l) : left(l), right(0) {} Either(R *r) : left(0), right(r) {} L *get_left() const { return left; } R *get_right() const { return right; } bool is_left() const { return left != 0; } bool is_right() const { return right != 0; } private: L *left; R *right; }; Then your Trie 's data members would be defined as follows: private: Either disjoint; vector *> children; // english pluralization Trie * parent; I'm playing fast and loose with your pointers, but you get the gist of what I'm saying. The important bit is that no given node can contain both an unsigned and a T* . Try this, and see if that helps. I think you'll find that being able to easily determine whether you are on a leaf or a branch will help you tremendously in your attempt to iterate.
