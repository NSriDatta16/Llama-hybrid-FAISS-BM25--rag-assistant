[site]: stackoverflow
[post_id]: 5665908
[parent_id]: 5665231
[tags]: 
I'd honestly go with a more generic version using iterators, such that you can "stream" the encoding. Consider the following implementation: #include namespace xml { // Helper for null-terminated ASCII strings (no end of string iterator). template OutIter copy_asciiz ( InIter begin, OutIter out ) { while ( *begin != '\0' ) { *out++ = *begin++; } return (out); } // XML escaping in it's general form. Note that 'out' is expected // to an "infinite" sequence. template OutIter escape ( InIter begin, InIter end, OutIter out ) { static const char bad[] = "&<>"; static const char* rep[] = {"&amp;", "&lt;", "&gt;"}; static const std::size_t n = sizeof(bad)/sizeof(bad[0]); for ( ; (begin != end); ++begin ) { // Find which replacement to use. const std::size_t i = std::distance(bad, std::find(bad, bad+n, *begin)); // No need for escaping. if ( i == n ) { *out++ = *begin; } // Escape the character. else { out = copy_asciiz(rep[i], out); } } return (out); } } Then, you can simplify the average case using a few overloads: #include #include namespace xml { // Get escaped version of "content". std::string escape ( const std::string& content ) { std::string result; result.reserve(content.size()); escape(content.begin(), content.end(), std::back_inserter(result)); return (result); } // Escape data on the fly, using "constant" memory. void escape ( std::istream& in, std::ostream& out ) { escape(std::istreambuf_iterator (in), std::istreambuf_iterator (), std::ostreambuf_iterator (out)); } } Finally, test the whole lot: #include int main ( int, char ** ) { std::cout bar & qux ")
