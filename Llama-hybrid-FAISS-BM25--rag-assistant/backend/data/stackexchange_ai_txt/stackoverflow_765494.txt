[site]: stackoverflow
[post_id]: 765494
[parent_id]: 765459
[tags]: 
Just for the record, zeroing the bits in an object won't affect whether the destructor gets called (unless the compiler has a special quirk that enables this behaviour). Just write some logging statements in your destructor to test this out. Structuring your program not to allocate anything is probably the way the system was designed. I've not worked with embedded systems before, however I have read some experienced embedded shops that discourage use of dynamic memory because the runtime environment has scarce amounts of it. However, if you must, you can still use placement new. If you don't have the header, here are the relevant lines directly from it on my version of GCC: // Default placement versions of operator new. inline void* operator new(std::size_t, void* __p) throw() { return __p; } inline void* operator new[](std::size_t, void* __p) throw() { return __p; } // Default placement versions of operator delete. inline void operator delete (void*, void*) throw() { } inline void operator delete[](void*, void*) throw() { } Stick that somewhere in a header file included by every source file that uses placement new/delete. Sample file that tests this: #include #include int main(int argc, char** argv) { typedef char const* cstr; char foobar[16]; cstr* str = new (&foobar) cstr(argc > 1 ? argv[1] : "Hello, world!"); std::puts(*str); str->~cstr(); } On my version of GCC, this does not use libstdc++ at all (if -fno-exceptions is used). Now, if you want to combine that with malloc (if your platform provides this), then you can do this: #include #include inline void* operator new (std::size_t n) {return std::malloc(n);} inline void* operator new[](std::size_t n) {return std::malloc(n);} inline void operator delete (void* p) {std::free(p);} inline void operator delete[](void* p) {std::free(p);} int main(int argc, char** argv) { typedef char const* cstr; cstr* str = new cstr(argc > 1 ? argv[1] : "Hello, world!"); std::puts(*str); delete str; } This allows you to use the standard new / delete that you're familiar with, without requiring use of libstdc++ . Good luck!
