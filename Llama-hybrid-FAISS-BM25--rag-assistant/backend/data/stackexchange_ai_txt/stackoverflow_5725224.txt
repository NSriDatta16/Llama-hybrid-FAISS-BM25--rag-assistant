[site]: stackoverflow
[post_id]: 5725224
[parent_id]: 5718821
[tags]: 
You appear to be making the cardinal mistake of thinking of Core Data as an object wrapper around a relational database. It isn't. ActiveRecord is an object wrapper around a relational database which is why it has to use techniques like polymorphic association. You can't cram Core Data into the relational wrapper paradigm and expect to get an elegant design. From what I can puzzle out of your data model, you don't actually need the reviewablId and reviewableType attributes to actually create the graph itself. Instead, you would replace them with entity inheritance and relationships. Start with a data model that looks like so. Review{ //... some review attributes place ReviewablePlace.reviews //... logically a review must always have a place that is reviewed } ReviewablePlace(abstract){ reviewableID:Number //... in case you have to fetch on this ID number later reviews >Review.place } Airport:Reviewable{ //... some airport specific attributes } Restaurant:Reviewable{ //... some restaurant specific attributes } This replaces the polymorphic association with object relationships and it differentiates between the two types of reviewable places by making two separate subentities. Since the Review entity has a relationship defined with the abstract Reviewable entity it can also form a relationship with any of the Reviewable subentities. You can fetch by reviewableID on the Reviewable entity and it will return the Airport or Restaurant object with that id and you can pop either into the place relationship of a new Review object. To process you JSON objects you would (in psuedocode): if Airport fetch on reviewableID if fetch returns existing Airport managed object break //don't want a duplicate so don't create an object else create new Airport managed object with reviewableID break if Restaurant fetch on reviewableID if fetch returns existing Restaurant managed object break //don't want a duplicate so don't create an object else create new Restaurant managed object with reviewableID break if Review fetch on reviewableID if fetch returns Reviewable object of either subclass create new Review object and assign fetched Reviewable object to the Review.place relationship break else create new Airport or Resturant object using the JSON provided reviewableID and reviewableType info create new Review object and assign the newly created Reviewable subclass object to the Review.place relationship break I think that will give you an integral object graph without having to jump through hoops. In any case, much of the checking that you are contemplating in the parent post can be replaced with the subentities and the proper relationships.
