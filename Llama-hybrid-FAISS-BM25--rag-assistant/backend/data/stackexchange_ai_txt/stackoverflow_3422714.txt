[site]: stackoverflow
[post_id]: 3422714
[parent_id]: 3422669
[tags]: 
You may want to read through here: http://ofps.oreilly.com/titles/9780596155957/AdvancedObjectOrientedProgramming.html#EqualityOfObjects but it appears that if you did: filesHere.sameElements(filesHere2) that it should be true. The javadoc for this is here: http://www.scala-lang.org/api/2.6.0/scala/IterableProxy.html#sameElements%28Iterable%5BB%5D%29 UPDATE: A couple of snippets from the first link that may be helpful: In Java, C++, and C# the == operator tests for reference, not value equality. In contrast, Ruby’s == operator tests for value equality. Whatever language you’re used to, make sure to remember that in Scala, == is testing for value equality. In reference to == not working as expected on Lists: While this may seem like an inconsistency, encouraging an explicit test of the equality of two mutable data structures is a conservative approach on the part of the language designers. In the long run, it should save you from unexpected results in your conditionals. UPDATE 2: Based on comments from Raphael I looked at the specification, and it was dated two days ago for the most recent update, and I see these at http://www.scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf : Method equals: (Any)Boolean is structural equality, where two instances are equal if they both belong to the case class in question and they have equal (with respect to equals) constructor arguments. class AnyRef extends Any { def equals(that: Any): Boolean = this eq that final def eq(that: AnyRef): Boolean = . . . // reference equality So, it appears that the definition hasn't changed in Scala 2.10.2, as the specification seems to be consistent. If the behavior is different, then if you write a unit test it should be sent as a bug for Scala.
