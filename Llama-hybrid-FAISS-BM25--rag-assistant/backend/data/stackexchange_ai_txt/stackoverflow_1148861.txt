[site]: stackoverflow
[post_id]: 1148861
[parent_id]: 1148778
[tags]: 
If you know which devices are out there you can use the Ping Class . This will allow you to at least fill up the ARP table. You can always execute ARP -a and parse the output if you have to. Here is also a link that shows how to pinvoke to call GetIpNetTable . I have included examples below of Ping Class and how to access the ARP table using the GetIpNetTable. This is an example for the Ping Class using System; using System.Net; using System.Net.NetworkInformation; using System.Text; namespace Examples.System.Net.NetworkInformation.PingTest { public class PingExample { // args[0] can be an IPaddress or host name. public static void Main (string[] args) { Ping pingSender = new Ping (); PingOptions options = new PingOptions (); // Use the default Ttl value which is 128, // but change the fragmentation behavior. options.DontFragment = true; // Create a buffer of 32 bytes of data to be transmitted. string data = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"; byte[] buffer = Encoding.ASCII.GetBytes (data); int timeout = 120; PingReply reply = pingSender.Send (args[0], timeout, buffer, options); if (reply.Status == IPStatus.Success) { Console.WriteLine ("Address: {0}", reply.Address.ToString ()); Console.WriteLine ("RoundTrip time: {0}", reply.RoundtripTime); Console.WriteLine ("Time to live: {0}", reply.Options.Ttl); Console.WriteLine ("Don't fragment: {0}", reply.Options.DontFragment); Console.WriteLine ("Buffer size: {0}", reply.Buffer.Length); } } } } This is an example of the GetIpNetTable. using System; using System.Runtime.InteropServices; using System.ComponentModel; using System.Net; namespace GetIpNetTable { class Program { // The max number of physical addresses. const int MAXLEN_PHYSADDR = 8; // Define the MIB_IPNETROW structure. [StructLayout(LayoutKind.Sequential)] struct MIB_IPNETROW { [MarshalAs(UnmanagedType.U4)] public int dwIndex; [MarshalAs(UnmanagedType.U4)] public int dwPhysAddrLen; [MarshalAs(UnmanagedType.U1)] public byte mac0; [MarshalAs(UnmanagedType.U1)] public byte mac1; [MarshalAs(UnmanagedType.U1)] public byte mac2; [MarshalAs(UnmanagedType.U1)] public byte mac3; [MarshalAs(UnmanagedType.U1)] public byte mac4; [MarshalAs(UnmanagedType.U1)] public byte mac5; [MarshalAs(UnmanagedType.U1)] public byte mac6; [MarshalAs(UnmanagedType.U1)] public byte mac7; [MarshalAs(UnmanagedType.U4)] public int dwAddr; [MarshalAs(UnmanagedType.U4)] public int dwType; } // Declare the GetIpNetTable function. [DllImport("IpHlpApi.dll")] [return: MarshalAs(UnmanagedType.U4)] static extern int GetIpNetTable( IntPtr pIpNetTable, [MarshalAs(UnmanagedType.U4)] ref int pdwSize, bool bOrder); [DllImport("IpHlpApi.dll", SetLastError = true, CharSet = CharSet.Auto)] internal static extern int FreeMibTable(IntPtr plpNetTable); // The insufficient buffer error. const int ERROR_INSUFFICIENT_BUFFER = 122; static void Main(string[] args) { // The number of bytes needed. int bytesNeeded = 0; // The result from the API call. int result = GetIpNetTable(IntPtr.Zero, ref bytesNeeded, false); // Call the function, expecting an insufficient buffer. if (result != ERROR_INSUFFICIENT_BUFFER) { // Throw an exception. throw new Win32Exception(result); } // Allocate the memory, do it in a try/finally block, to ensure // that it is released. IntPtr buffer = IntPtr.Zero; // Try/finally. try { // Allocate the memory. buffer = Marshal.AllocCoTaskMem(bytesNeeded); // Make the call again. If it did not succeed, then // raise an error. result = GetIpNetTable(buffer, ref bytesNeeded, false); // If the result is not 0 (no error), then throw an exception. if (result != 0) { // Throw an exception. throw new Win32Exception(result); } // Now we have the buffer, we have to marshal it. We can read // the first 4 bytes to get the length of the buffer. int entries = Marshal.ReadInt32(buffer); // Increment the memory pointer by the size of the int. IntPtr currentBuffer = new IntPtr(buffer.ToInt64() + Marshal.SizeOf(typeof(int))); // Allocate an array of entries. MIB_IPNETROW[] table = new MIB_IPNETROW[entries]; // Cycle through the entries. for (int index = 0; index
