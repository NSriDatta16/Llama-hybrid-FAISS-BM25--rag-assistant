[site]: stackoverflow
[post_id]: 1261619
[parent_id]: 1261598
[tags]: 
For a multidimensional array, probably the best option would be to use boost's multi_array library: typedef boost::multi_array array_type; array_type p(boost::extents[100][100][100]); // make an 100x100x100 array of floats p[1][2][3] = 4.2; This lets you completely abstract away the allocation and details of setting up the multidimensional array. Plus, because it uses linear storage, you get the efficiency benefits of linear storage with the ease of access of indirections. Failing that, you have three other major options. The most C++-y option without using external libraries would be to use a STL container: std::vector p; p.resize(100); As with multi_array , p will then automatically be freed when it goes out of scope. You can get the vector bounds with p.size() . However the vector will only handle one dimension for you, so you'll end up doing nested vectors (ick!). You can also use new directly: float ***p = new float**[100]; To deallocate: delete [] p; This has all the disadvantages of std::vector , plus it won't free it for you, and you can't get the size later. The above three methods will all throw an exception of type std::bad_alloc if they fail to allocate enough memory. Finally, for completeness, there's the C route, with calloc() : float ***p = (float ***)calloc(100, sizeof(*p)); To free: free((void*)p); This comes from C and is a bit uglier with all the casts. For C++ classes it will not call the constructors for you, either. Also, there's no checking that the sizeof in the argument is consistent with the cast. If calloc() fails to allocate memory it will return NULL; you'll need to check for this and handle it.
