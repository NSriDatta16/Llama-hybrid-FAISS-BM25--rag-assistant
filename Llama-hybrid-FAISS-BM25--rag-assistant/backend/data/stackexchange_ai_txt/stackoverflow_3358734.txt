[site]: stackoverflow
[post_id]: 3358734
[parent_id]: 3355408
[tags]: 
Interface Oriented Design describes this better than I ever could http://pragprog.com/titles/kpiod/interface-oriented-design . The author uses some excellent examples of interfaces versus inheritance for things like the taxonomy of the animal kingdom. It has some of the best arguments against excessive inheritance and judicious use of interfaces I have read to date. A bunch of websites with incompatible ways of bringing them up: Listing of Facebook.java : public class Facebook { public void showFacebook() { // ... } } Listing of YouTube.java : public class YouTube { public void showYouTube() { // ... } } Listing of StackOverflow.java : public class StackOverflow { public void showStackOverflow() { // ... } } A client manually handling the different methods the websites use to bring themselves up: Listing of ClientWithoutInterface.java : public class ClientWithoutInterface { public static void main(String... args) { String websiteRequested = args[0]; if ("facebook".equals(websiteRequested)) { new Facebook().showFacebook(); } else if ("youtube".equals(websiteRequested)) { new YouTube().showYouTube(); } else if ("stackoverflow".equals(websiteRequested)) { new StackOverflow().showStackOverflow(); } } } Introduce a Website interface to make the client's job easier: Listing of Website.java : public interface Website { void showWebsite(); } Listing of Facebook.java : public class Facebook implements Website { public void showWebsite() { // ... } } Listing of YouTube.java : public class YouTube implements Website { public void showWebsite() { // ... } } Listing of StackOverflow.java : public class StackOverflow implements Website { public void showWebsite() { // ... } } Listing of ClientWithInterface.java : public class ClientWithInterface { public static void main(String... args) { String websiteRequested = args[0]; Website website; if ("facebook".equals(websiteRequested)) { website = new Facebook(); } else if ("youtube".equals(websiteRequested)) { website = new YouTube(); } else if ("stackoverflow".equals(websiteRequested)) { website = new StackOverflow(); } website.showWebsite(); } } Whoop-de-doo, more code for nothing? Actually we can go a little further and have the client rope a couple of friends into helping it find and render a requested website: Listing of ClientWithALittleHelpFromFriends.java : public class ClientWithALittleHelpFromFriends { public static void main(String... args) { WebsiteFinder finder = new WebsiteFinder(); WebsiteRenderer renderer = new WebsiteRenderer(); renderer.render(finder.findWebsite(args[0])); } } Listing of WebsiteFinder.java : public class WebsiteFinder { public Website findWebsite(String websiteRequested) { if ("facebook".equals(websiteRequested)) { return new Facebook(); } else if ("youtube".equals(websiteRequested)) { return new YouTube(); } else if ("stackoverflow".equals(websiteRequested)) { return new StackOverflow(); } } } Listing of WebsiteRenderer.java : public class WebsiteRenderer { public void render(Website website) { website.showWebsite(); } } Looking back at ClientWithoutInterface , it is totally coupled to both specific lookup and rendering based. It would be very difficult to manage when you get to hundreds or thousands of sites. With the Website interface in place the WebsiteFinder could easily be converted to be backed on a Map, a database or even a web based lookup to satisfy increasing scale. Interfaces make it possible to separate a role from the component that achieves it. They make it possible to swap in alternative solutions to the same problem based on pretty much anything: Current load on machine Size of the data set (sorting algorithms can be picked) User requesting the action being performed
