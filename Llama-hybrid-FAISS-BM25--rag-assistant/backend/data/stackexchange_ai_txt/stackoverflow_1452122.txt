[site]: stackoverflow
[post_id]: 1452122
[parent_id]: 
[tags]: 
C# class design without using "Internal" or "Static"?

I have a bunch of data I want to instantiate in a class, and for each variable I want to ensure a specific set of methods are also defined. IE: [TypeA] VarA [TypeB] VarB [TypeC] VarC FA1() which is a function of VarA and VarB FA2() which is a function of VarA and VarC FB1() which is a function of VarB and VarA FB2() which is a function of VarB and VarC ... As there will be a large number of variables (and hence even more functions) I want to split my source code up into manageable chunks. So I am looking for an automatic way of ensuring that all of the functions for each variable are instantiated. I have come up with 3 possible methods to organize my code and I am not too happy with each of them and I am looking or advice as to which method is the better (or even if I have missed a completely different implementation method): 1. Partial Class partial class Base { } partial class Base { [TypeA] VarA; FA1 { .. }; // function of VarA and VarB FA2 { .. }; // function of VarA and VarC } partial class Base { [TypeB] VarB; FB1 { .. }; // function of VarB and VarA FB2 { .. }; // function of VarB and VarC } Pros: Simple Variables can only be accessed from within class Base. If there are two variables of the same type then the functions for each variable can implement its own function differently. Cons: Cannot automatically ensure that all functions are created for each variable Need to manually ensure that there are no name collisions between each function name. Note that the Cons may be solved by a code generator of some sort (maybe time to learn T4??) 2. Internal class class Base { internal [ClassA] ObjA = new [ClassA](); internal [ClassB] ObjB = new [ClassB](); } class [BaseClassA] { public [TypeA] VarA; public virtual F1 { .. }; public virtual F2 { .. }; } class [ClassA] : [BassClassA] { public override F1 { .. }; // function of VarA and ObjB.VarB public override F2 { .. }; // function of VarA and ObjC.VarC } ... Pros: Class hierarchy enforces that all functions are created and that variables are there to be accessed. Through use of virtual functions can create instance specific implementations of functions Cons: Use of Internal means that data is visible everywhere in the assembly. 3. Static data abstract class Data { static [TypeA] VarA; static [TypeB] VarB; ... } abstract class [BaseClassA] : Data { public virtual F1 { .. }; public virtual F2 { .. }; } class [ClassA] : [BassClassA] { public override F1 { .. }; // function of VarA and VarB public override F2 { .. }; // function of VarA and VarC } class Base { [ClassA] ObjA = new [ClassA](); [ClassB] ObjB = new [ClassB](); } Pros: System ensures that all routines are instantiated Data is not blasted all around the assembly Within each function you can directly reference the other variables as per the 'partial class' solution Cons: The use of static smells like I have just re-invented global data. What I want is to somehow cherry pick the best points of each method: The direct manner of accessing variables of the "Partial class" and "Static" methods The local data of the "Partial class" method The automatic enforcing of function implementation of the "Internal" and "Static" methods. And I want to avoid: The lack of enforcing function generation in the "Partial class" The global access of data in the "Internal" method The re-invention of global data in the "Static" method If I was going to have my druthers I'd say that what I want is to somehow apply an interface to an instance of a variable - like: [TypeA] VarA : IFunctions; [TypeB] VarB : IFunctions; And somehow have the compiler auto-generate the final function names from the interface names and the vaiable name. So can people suggest which of the 3 methods they would prefer to implement, or suggest any other methods that may suit.
