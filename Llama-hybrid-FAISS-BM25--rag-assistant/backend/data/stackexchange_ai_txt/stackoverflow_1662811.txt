[site]: stackoverflow
[post_id]: 1662811
[parent_id]: 1662772
[tags]: 
I think it is drawing your attention to the fact that a assign is being used, as opposed to retain or copy . Since an NSString is an object, in a reference-counted environment (ie without Garbage Collection) this can be potentially "dangerous" (unless it is intentional by design). However, the difference between assign , retain and copy are as follows: assign : In your setter method for the property, there is a simple assignment of your instance variable to the new value, eg: - (void)setString:(NSString*)newString { string = newString; } This can cause problems since Objective-C objects use reference counting, and therefore by not retaining the object, there is a chance that the string could be deallocated whilst you are still using it. retain : this retains the new value in your setter method. For example: - (void)setString:(NSString*)newString { [newString retain]; [string release]; string = newString; } This is safer, since you explicitly state that you want to maintain a reference of the object, and you must release it before it will be deallocated. copy : this makes a copy of the string in your setter method: - (void)setString:(NSString*)newString { if(string!=newString) { [string release]; string = [newString copy]; } } This is often used with strings, since making a copy of the original object ensures that it is not changed whilst you are using it.
