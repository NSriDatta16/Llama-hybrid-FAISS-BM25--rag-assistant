[site]: stackoverflow
[post_id]: 127214
[parent_id]: 125997
[tags]: 
Try the a modification of the command pattern: public abstract class ToolStripItemCommand { private bool enabled = true; private bool visible = true; private readonly List controls; protected ToolStripItemCommand() { controls = new List (); } public void RegisterControl(ToolStripItem item, string eventName) { item.Click += delegate { Execute(); }; controls.Add(item); } public bool Enabled { get { return enabled; } set { enabled = value; foreach (ToolStripItem item in controls) item.Enabled = value; } } public bool Visible { get { return visible; } set { visible = value; foreach (ToolStripItem item in controls) item.Visible = value; } } protected abstract void Execute(); } Your implementations of this command can be stateful in order to support your view's state. This also enables the ability to build "undo" into your form. Here's some toy code that consumes this: private ToolStripItemCommand fooCommand; private void wireUpCommands() { fooCommand = new HelloWorldCommand(); fooCommand.RegisterControl(fooToolStripMenuItem, "Click"); fooCommand.RegisterControl(fooToolStripButton, "Click"); } private void toggleEnabledClicked(object sender, EventArgs e) { fooCommand.Enabled = !fooCommand.Enabled; } private void toggleVisibleClicked(object sender, EventArgs e) { fooCommand.Visible = !fooCommand.Visible; } HelloWorldCommand: public class HelloWorldCommand : ToolStripItemCommand { #region Overrides of ControlCommand protected override void Execute() { MessageBox.Show("Hello World"); } #endregion } It's unfortunate that Control and ToolStripItem do not share a common interface since they both have "Enabled" and "Visible" properties. In order to support both types, you would have to composite a command for both, or use reflection. Both solutions infringe on the elegance afforded by simple inheritance.
