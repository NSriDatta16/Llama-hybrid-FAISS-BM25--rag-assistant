[site]: stackoverflow
[post_id]: 1064562
[parent_id]: 1061717
[tags]: 
Basically Spring is a framework for dependency-injection which is a pattern that allows building very decoupled systems. The problem For example, suppose you need to list the users of the system and thus declare an interface called UserLister : public interface UserLister { List getUsers(); } And maybe an implementation accessing a database to get all the users: public class UserListerDB implements UserLister { public List getUsers() { // DB access code here } } In your view you'll need to access an instance (just an example, remember): public class SomeView { private UserLister userLister; public void render() { List users = userLister.getUsers(); view.render(users); } } Note that the code above hasn't initialized the variable userLister . What should we do? If I explicitly instantiate the object like this: UserLister userLister = new UserListerDB(); ...I'd couple the view with my implementation of the class that access the DB. What if I want to switch from the DB implementation to another that gets the user list from a comma-separated file (remember, it's an example)? In that case, I would go to my code again and change the above line to: UserLister userLister = new UserListerCommaSeparatedFile(); This has no problem with a small program like this but... What happens in a program that has hundreds of views and a similar number of business classes? The maintenance becomes a nightmare! Spring (Dependency Injection) approach What Spring does is to wire the classes up by using an XML file or annotations, this way all the objects are instantiated and initialized by Spring and injected in the right places (Servlets, Web Frameworks, Business classes, DAOs, etc, etc, etc...). Going back to the example in Spring we just need to have a setter for the userLister field and have either an XML file like this: or more simply annotate the filed in our view class with @Inject : @Inject private UserLister userLister; This way when the view is created it magically will have a UserLister ready to work. List users = userLister.getUsers(); // This will actually work // without adding any line of code It is great! Isn't it? What if you want to use another implementation of your UserLister interface? Just change the XML. What if don't have a UserLister implementation ready? Program a temporal mock implementation of UserLister and ease the development of the view. What if I don't want to use Spring anymore? Just don't use it! Your application isn't coupled to it. Inversion of Control states: "The application controls the framework, not the framework controls the application". There are some other options for Dependency Injection around there, what in my opinion has made Spring so famous besides its simplicity, elegance and stability is that the guys of SpringSource have programmed many many POJOs that help to integrate Spring with many other common frameworks without being intrusive in your application. Also, Spring has several good subprojects like Spring MVC, Spring WebFlow, Spring Security and again a loooong list of etceteras. Anyway, I encourage you to read Martin Fowler's article about Dependency Injection and Inversion of Control because he does it better than me. After understanding the basics take a look at Spring Documentation , in my opinion, it is used to be the best Spring book ever.
