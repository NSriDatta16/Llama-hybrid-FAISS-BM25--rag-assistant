[site]: stackoverflow
[post_id]: 3135903
[parent_id]: 3135261
[tags]: 
First look at the problem. You want "everything in A not in B". That means you're going to have to visit "everything in A". You'll also have to visit everything in B to have knowledge of what is and is not in B. So that suggests there should be an O(n) + O(m) solution, or taking liberty to elide the difference between n and m, O(2n) . Let's consider the std::set_difference approach. Each sort is O(n log n) , and set_difference is O(n) . So the sort-sort-set_difference approach is O(n + 2n log n) . Let's call that O(4n) . Another approach would be to first place the elements of B in a set (or map). Iteration across B to create the set is O(n) plus insertion O(log n) of each element, followed by iteration across A O(n), with a lookup for each element of A (log n), gives a total: O(2n log n) . Let's call that O(3n) , which is slightly better. Finally, using an unordered_set (or unordered_map), and assuming we get average case of O(1) insertion and O(1) lookup, we have an approach that is O(2n) . A-ha! The real win here is that unordered_set (or map) is probably the most natural choice to represent your data in the first place, i.e., the proper design yields the optimized implementation. That doesn't always happen, but it's nice when it does!
