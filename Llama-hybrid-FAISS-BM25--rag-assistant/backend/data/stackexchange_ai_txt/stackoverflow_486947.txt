[site]: stackoverflow
[post_id]: 486947
[parent_id]: 
[tags]: 
Customizing IQueryable

I'm trying to customize entities of my application to make them have a property referencing the DataContext that loaded them. I think the best way is to somehow create a class that implements the IQueryable and set the entity datacontext property in its GetEnumerator method. My question is, how can I use the Provider and Expression used by Linq to SQL in my implementation of IQueryable so that I don't have to implement them myself? BTW: For my scenario, is there another way? Take a look at the following code: public partial class Product: IEntityBase { public Product() { _DataContext = new SampleDataContext(); } private long _Id; [Column(Storage="_Id", AutoSync=AutoSync.OnInsert, DbType="BigInt NOT NULL IDENTITY", IsPrimaryKey=true, IsDbGenerated=true)] public long Id { get{ return _Id; } set{ _Id = value; } } private string _Name; [Column(Storage="_Name", DbType="NVarChar(MAX) NOT NULL", CanBeNull=false public string Name { get{ return _Name; } set{ _Name = value; } } private SampleDataContext _DataContext; //This is the property extending the Product class and should be set when this class is being returned //by IQueryable .GetEnumerator() public SampleDataContext DataContext { get{ return _Name; } set{ _Name = value; } } public MyQueryable GetProducts() { MyQueryable result = from p in context.Products where {Some Conditions 1} select p; result.DataContext = _DataContext; return result; } public void SomeMethod() { //This query will not actually set the DataCotnext property. //And the generated sql query is something like: //SELECT * FROM Products WHERE {Some Conditions 1} AND {Some Conditions 2} var products = GetProducts().Where( {Some Conditions 2} ); //Now that the GetEnumerator() is called the DataContext property of the products //will be set. foreach( var item in products ) { item.Name = "Test Name"; item.DataContext.SubmitChanges(); } } } public MyQueryable : IQueryable where T: class, IEntityBase { // //Implementation of IQueryable which is my question // public IEnumerator GetEnumerator() { foreach( var item in Provider.GetEnumerator () ) { item.DataContext = this.DataContext; yield return item; } } public SampleDataContext DataContext{ get; set; } } public interface IEntityBase { SampleDataContext DataContext{ get; set; }; } UPDATE I found the answer myself. Here it is the sample code to show how I did that. public MyQueryable : IQueryable where T: class, IEntityBase where TContext: DataContext, new() { public MyQueryable (TContext context, IQueryable baseIQueryable) { if( baseIQueryable == null ) throw new ArgumentNullException("baseIQueryable"); this.Provider = baseIQueryable.Provider; this.Expression = baseIQueryable.Expression; this.DataContext = context; } public IEnumerator GetEnumerator() { var enumerator = Provider.Execute >(Expression); foreach( var item in enumerator ) { item.DataContext = this.DataContext ?? new TContext(); yield return item; } } IEnumerator IEnumerable.GetEnumerator() { var enumerator = Provider.Execute (Expression); foreach( var item in enumerator ) { ((IEntityBase )item).DataContext = this.DataContext; yield return item; } } // //Other implementations... // public SampleDataContext DataContext{ get; set; } } public partial class Product: IEntityBase { public MyQueryable GetProducts() { var result = from p in context.Products where {Some Conditions 1} select p; return new MyQueryable (this.DataContext, result); } }
