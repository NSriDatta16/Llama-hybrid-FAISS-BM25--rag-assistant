[site]: stackoverflow
[post_id]: 2451714
[parent_id]: 
[tags]: 
Access Violation When Accessing an STL Object Through A Pointer or Reference In A Different DLL or EXE

I experience the following problem while using legacy VC6. I just cann't switch to modern compiler, as I am working on a legacy code base. http://support.microsoft.com/kb/172396 Since there are no way to export map, my planned workaround is using static linking instead of dynamic linking. I was wondering whether you all had encountered the similar situation? What is your workaround for this? Another workaround is to create wrapper class around the stl map, to ensure creation and accessing stl map, are within the same DLL space. Note that, fun0, which uses wrapper class will just work fine. fun1 will crash. Here is the code example : // main.cpp. Compiled it as exe. #pragma warning (disable : 4786) #include #include template class __declspec(dllimport) map_wrapper { public: map_wrapper(); ~map_wrapper(); map_wrapper(const map_wrapper&); map_wrapper& operator=(const map_wrapper&); V& operator[](const K&); const V& operator[](const K&) const; const V& get(const K&) const; void put(const K&, const V&); int size() const; private: std::map *m; }; __declspec(dllimport) void fun0(map_wrapper & m); __declspec(dllimport) void fun1(std::map & m); int main () { map_wrapper m0; std::map m1; m0["hello"] = 888; m1["hello"] = 888; // Safe. The we create std::map and access map both in dll space. fun0(m0); // Crash! The we create std::map in exe space, and access map in dll space. fun1(m1); return 0; } // dll.cpp. Compiled it as dynamic dll. #pragma warning (disable : 4786) #include #include #include /* In map_wrapper.h */ template class __declspec(dllexport) map_wrapper { public: map_wrapper(); ~map_wrapper(); map_wrapper(const map_wrapper&); map_wrapper& operator=(const map_wrapper&); V& operator[](const K&); const V& operator[](const K&) const; const V& get(const K&) const; void put(const K&, const V&); int size() const; private: std::map *m; }; /* End */ /* In map_wrapper.cpp */ template map_wrapper ::map_wrapper() : m(new std::map ()) { } template map_wrapper ::~map_wrapper() { delete m; } template map_wrapper ::map_wrapper(const map_wrapper & map) : m(new std::map (*(map.m))) { } template map_wrapper & map_wrapper ::operator=(const map_wrapper & map) { std::map * tmp = this->m; this->m = new std::map (*(map.m)); delete tmp; return *this; } template V& map_wrapper ::operator[](const K& key) { return (*this->m)[key]; } template const V& map_wrapper ::operator[](const K& key) const { return (*this->m)[key]; } template const V& map_wrapper ::get(const K& key) const { return (*this->m)[key]; } template void map_wrapper ::put(const K& key, const V& value) { (*this->m)[key] = value; } template int map_wrapper ::size() const { return this->m->size(); } // See : http://www.parashift.com/c++-faq-lite/templates.html#faq-35.15 // [35.15] How can I avoid linker errors with my template classes? template class __declspec(dllexport) map_wrapper ; /* End */ __declspec(dllexport) void fun0(map_wrapper & m) { std::cout & m) { std::cout
