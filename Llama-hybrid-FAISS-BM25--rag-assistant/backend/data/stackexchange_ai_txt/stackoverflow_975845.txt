[site]: stackoverflow
[post_id]: 975845
[parent_id]: 961942
[tags]: 
VSE, The Visual Software Environment. This is a language that a prof of mine ( Dr. Henry Ledgard ) tried to sell us on back in undergrad/grad school. (I don't feel bad about giving his name because, as far as I can tell, he's still a big proponent and would welcome the chance to convince some folks it's the best thing since sliced bread). When describing it to people, my best analogy is that it's sort of a bastard child of FORTRAN and COBOL, with some extra bad thrown in. From the only really accessible folder I've found with this material (there's lots more in there that I'm not going to link specifically here): VSE Overview (pdf) Chapter 3: The VSE Language (pdf) (Not really an overview of the language at all) Appendix: On Strings and Characters (pdf) The Software Survivors (pdf) (Fevered ramblings attempting to justify this turd) VSE is built around what they call "The Separation Principle". The idea is that Data and Behavior must be completely segregated. Imagine C's requirement that all variables/data must be declared at the beginning of the function, except now move that declaration into a separate file that other functions can use as well. When other functions use it, they're using the same data, not a local copy of data with the same layout. Why do things this way? We learn that from The Software Survivors that Variable Scope Rules Are Hard. I'd include a quote but, like most fools, it takes these guys forever to say anything. Search that PDF for "Quagmire Of Scope" and you'll discover some true enlightenment. They go on to claim that this somehow makes it more suitable for multi-proc environments because it more closely models the underlying hardware implementation. Riiiight. Another choice theme that comes up frequently: INCREMENT DAY COUNT BY 7 (or DAY COUNT = DAY COUNT + 7) DECREMENT TOTAL LOSS BY GROUND_LOSS ADD 100.3 TO TOTAL LOSS(LINK_POINTER) SET AIRCRAFT STATE TO ON_THE_GROUND PERCENT BUSY = (TOTAL BUSY CALLS * 100)/TOTAL CALLS Although not earthshaking, the style of arithmetic reflects ordinary usage, i.e., anyone can read and understand it - without knowing a programming language. In fact, VisiSoft arithmetic is virtually identical to FORTRAN, including embedded complex arithmetic. This puts programmers concerned with their professional status and corresponding job security ill at ease. Ummm, not that concerned at all, really. One of the key selling points that Bill Cave uses to try to sell VSE is the democratization of programming so that business people don't need to indenture themselves to programmers who use crazy, arcane tools for the sole purpose of job security. He leverages this irrational fear to sell his tool. (And it works-- the federal gov't is his biggest customer). I counted 17 uses of the phrase "job security" in the document. Examples: ... and fit only for those desiring artificial job security . More false job security ? Is job security dependent upon ensuring the other guy can't figure out what was done? Is job security dependent upon complex code...? One of the strongest forces affecting the acceptance of new technology is the perception of one's job security . He uses this paranoia to drive wedge between the managers holding the purse strings and the technical people who have the knowledge to recognize VSE for the turd that it is. This is how he squeezes it into companies-- "Your technical people are only saying it sucks because they're afraid it will make them obsolete!" A few additional choice quotes from the overview documentation: Another consequence of this approach is that data is mapped into memory on a "What You See Is What You Get" basis , and maintained throughout. This allows users to move a complete structure as a string of characters into a template that descrives each individual field. Multiple templates can be redefined for a given storage area. Unlike C and other languages, substructures can be moved without the problems of misalignment due to word boundary alignment standards. Now, I don't know about you, but I know that a WYSIWYG approach to memory layout is at the top of my priority list when it comes to language choice! Basically, they ignore alignment issues because only old languages that were designed in the '60's and '70's care about word alignment. Or something like that. The reasoning is bogus. It made so little sense to me that I proceeded to forget it almost immediately. There are no user-defined types in VSE. This is a far-reaching decision that greatly simplifies the language. The gain from a practical point of view is also great. VSE allows the designer and programmer to organize a program along the same lines as a physical system being modeled. VSE allows structures to be built in an easy-to-read, logical attribute hierarchy. Awesome! User-defined types are lame. Why would I want something like an InputMessage object when I can have: LINKS_IN_USE INTEGER INPUT_MESSAGE 1 ORIGIN INTEGER 1 DESTINATION INTEGER 1 MESSAGE 2 MESSAGE_HEADER CHAR 10 2 MESSAGE_BODY CHAR 24 2 MESSAGE_TRAILER CHAR 10 1 ARRIVAL_TIME INTEGER 1 DURATION INTEGER 1 TYPE CHAR 5 OUTPUT_MESSAGE CHARACTER 50 You might look at that and think, "Oh, that's pretty nicely formatted, if a bit old-school." Old-school is right. Whitespace is significant-- very significant. And redundant! The 1 's must be in column 3. The 1 indicates that it's at the first level of the hierarchy. The Symbol name must be in column 5. You hierarchies are limited to a depth of 9. Well, ok, but is that so awful? Just wait: It is well known that for reading text, use of conventional upper/lower case is more readable. VSE uses all upper case (except for comments). Why? The literature in psychology is based on prose. Programs, simply, are not prose. Programs are more like math, accounting, tables. Program fonts (usually Courier) are almost universally fixed-pitch, and for good reason â€“ vertical alignment among related lines of code. Programs in upper case are nicely readable, and, after a time, much better in our opinion Nothing like enforcing your opinion at the language level! That's right, you cannot use any lower case in VSE unless it's in a comment. Just keep your CAPSLOCK on, it's gonna be stuck there for a while. VSE subprocedures are called processes. This code sample contains three processes: PROCESS_MUSIC EXECUTE INITIALIZE_THE_SCENE EXECUTE PROCESS_PANEL_WIDGET INITIALIZE_THE_SCENE SET TEST_BUTTON PANEL_BUTTON_STATUS TO ON MOVE ' ' TO TEST_INPUT PANEL_INPUT_TEXT DISPLAY PANEL PANEL_MUSIC PROCESS_PANEL_WIDGET ACCEPT PANEL PANEL_MUSIC *** CHECK FOR BUTTON CLICK IF RTG_PANEL_WIDGET_NAME IS EQUAL TO 'TEST_BUTTON' MOVE 'I LIKE THE BEATLES!' TO TEST_INPUT PANEL_INPUT_TEXT. DISPLAY PANEL PANEL_MUSIC All caps as expected. After all, that's easier to read. Note the whitespace. It's significant again. All process names must start in column 0. The initial level of instructions must start on column 4. Deeper levels must be indented exactly 3 spaces. This isn't a big deal, though, because you aren't allowed to do things like nest conditionals. You want a nested conditional? Well just make another process and call it. And note the delicious COBOL-esque syntax! You want loops? Easy: EXECUTE NEXT_CALL EXECUTE NEXT_CALL 5 TIMES EXECUTE NEXT_CALL TOTAL CALL TIMES EXECUTE NEXT_CALL UNTIL NO LINES ARE AVAILABLE EXECUTE NEXT_CALL UNTIL CALLS_ANSWERED ARE EQUAL TO CALLS_WAITING EXECUTE READ_MESSAGE UNTIL LEAD_CHARACTER IS A DELIMITER Ugh.
