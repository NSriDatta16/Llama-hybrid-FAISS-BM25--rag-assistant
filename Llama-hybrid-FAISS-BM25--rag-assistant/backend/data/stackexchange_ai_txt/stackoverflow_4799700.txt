[site]: stackoverflow
[post_id]: 4799700
[parent_id]: 4799654
[tags]: 
.Union will give you the distinct combination of various sequences. Note: if you are working with a custom type, you will need to provide overrides for GetHashCode/Equals inside the class or provide an IEqualityComparer for your type in an overload. For BCL types such as int or DateTime , you will be fine. Example: var sequence = Enumerable.Range(0,10).Union(Enumerable.Range(5,10)); // should result in sequence of 0 through 14, no repeats Edit What would be the elegant way to union all my ranges without chaining them all in one command. If you have a sequence of sequences, be it a collection of lists, perhaps a jagged array, you can use the SelectMany method along with Distinct . int[][] numberArrays = new int[3][]; numberArrays[0] = new int[] { 1, 2, 3, 4, 5 }; numberArrays[1] = new int[] { 3, 4, 5, 6, 7 }; numberArrays[2] = new int[] { 2, 4, 6, 8, 10 }; var allUniqueNumbers = numberArrays.SelectMany(i => i).Distinct(); Otherwise, you might consider creating your own extension method that could handle this. public static class MyExtensions { public static IEnumerable UnionMany (this IEnumerable sequence, params IEnumerable [] others) { return sequence.Union(others.SelectMany(i => i)); } } // var allUniques = numberArrays[0].UnionMany(numberArrays[1], numberArrays[2]);
