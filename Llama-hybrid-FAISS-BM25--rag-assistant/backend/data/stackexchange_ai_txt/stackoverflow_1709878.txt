[site]: stackoverflow
[post_id]: 1709878
[parent_id]: 
[tags]: 
Casting generic collection to concrete implementation in C# 2.0

Chosen Solution Thanks for the help everyone. I've decided to do the following. public static class PersonCollection { public static List GetNames(RecordCollection list) { List nameList = new List (list.Count); foreach (Person p in list) { nameList.Add(p.Name); } return nameList; } } I'm trying to cast a generic collection RecordCollection to a derived collection PersonCollection, but I get a cast exception: RecordCollection col = this.GetRecords (this.cbPeople); PersonCollection people = (PersonCollection)col; The reason I'm trying to do this is two-fold: The derived classes (eg, PersonCollection) can have instance methods (eg, GetLastNames) which shouldn't be in the base class. The method GetRecords is generic so I can get a collection of any Record objects. What is the best approach to solve this in C# 2.0 ? What is the most elegant approach to solving this? This is signature of GetRecords: public RecordCollection GetRecords (ComboBox cb) where T : Record, new() This is my base implementation: public abstract class Record : IComparable { public abstract int CompareTo(object other); } public class RecordCollection : ICollection where T : Record, new() { private readonly List list; public RecordCollection() { this.list = new List (); } // Remaining ICollection interface here } I have derived objects based on that base implementation as follows: public class Person : Record { public Person() { // This is intentionally empty } public string Name { get; set; } public override int CompareTo(object other) { Person real = other as Person; return this.Name.CompareTo(real.Name); } } public class PersonCollection : RecordCollection { }
