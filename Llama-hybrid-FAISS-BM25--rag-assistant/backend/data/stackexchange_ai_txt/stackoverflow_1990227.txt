[site]: stackoverflow
[post_id]: 1990227
[parent_id]: 1988484
[tags]: 
I would say that your issues go beyond just STL porting. Since the list, dict, and set data structures, which are bolted on to C++ via the STL, are native to core Python, then their usage is incorporated into common Python code idioms. If you want to give Google another shot, try looking for references for "Python for C++ Programmers". One of your hits will be this presentation by Alex Martelli . It's a little dated, from way back in ought-three, but there is a side-by-side comparison of some basic Python code that reads through a text file, and how it would look using STL. From there, I would recommend that you read up on these Python features: iterators generators list and generator comprehensions And these builtin functions: zip map Once you are familiar with these, then you will be able to construct your own translation/mapping between STL usage and Python builtin data structures. As others have said, if you are looking for a "plug-and-chug" formula to convert STL C++ code to Python, you will just end up with bad Python. Such a brute force approach will never result in the power, elegance, and brevity of a single-line list comprehension. (I had this very experience when introducing Python to one of our managers, who was familiar with Java and C++ iterators. When I showed him this code: numParams = 1000 paramRequests = [ ("EqptEmulator/ProcChamberI/Sensors", "ChamberIData%d"%(i%250)) for i in range(numParams) ] record.internalArray = [ParameterRequest(*pr) for pr in paramRequests] and I explained that these replaced this code (or something like it, this might be a mishmash of C++ and Java APIs, sorry): std::vector prs = new std::vector (); for (int i = 0; i One of your instincts from working with C++ will be a reluctance to create new lists from old, but rather to update or filter a list in place. We even see this on many forums from Python developers asking about how to modify a list while iterating over it. In Python, you are much better off building a new list from the old with a list comprehension. allItems = [... some list of items, perhaps from a database query ...] validItems = [it for it in allItems if it.isValid()] As opposed to: validItems = [] for it in allItems: if it.isValid(): validItems.add(it) or worse: # get list of indexes of items to be removed removeIndexes = [] for i in range(len(allItems)): if not allItems[i].isValid(): removeIndexes.add(i) # don't forget to remove items in descending order, or later indexes # will be invalidated by earlier removals sort(removeIndexes,reverse=True) # copy list validItems = allItems[:] # now remove the items from allItems for idx in removeIndexes: del validItems[i]
