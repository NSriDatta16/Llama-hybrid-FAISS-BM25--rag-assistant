[site]: stackoverflow
[post_id]: 4530131
[parent_id]: 4529868
[tags]: 
If I understand the question correctly, you've got an array containing an odd number of integer values, consisting of a number of integers that appear twice plus one integer that appears only once. For example, the array might look like this: [3, 41, 6, 6, 41] where 6 and 41 are both repeated and 3 is unique. It would be good to know if there are any other constraints. For example: Is the array sorted? (If so, this is a simple problem to solve in O(N) time with no requirement for temporary storage.) Can the unpaired integer be the same as an integer in a pair? e.g. is [1, 2, 2, 2, 1] a valid input, being a pair of 1s, a pair of 2s and an unpaired 2? Assuming the array isn't sorted, here's one solution, expressed in pseudocode, which runs in O(N) time and requires at most around half the storage space again of the original array. SEEN = [] for N in ARRAY: if N in SEEN: remove N from SEEN else: add N to SEEN if size of SEEN != 1: error - ARRAY doesn't contain exactly 1 un-paired value else: answer = SEEN[0] Here's a sample implementation using an NSMutableDictionary to store seen values, assuming that the source array is a plain C array. #import int main(int argc, char argv[]) { NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; int array[9] = {3, 4, 5, 6, 7, 6, 5, 4, 3}; NSMutableDictionary *d = [NSMutableDictionary dictionaryWithCapacity:16]; for (int i = 0; i And here it is running: $ gcc -lobjc -framework Foundation -std=c99 demo.m ; ./a.out 2010-12-25 11:23:21.426 a.out[17544:903] Unpaired number: 7
