[site]: stackoverflow
[post_id]: 1494812
[parent_id]: 
[tags]: 
Why can't I retrieve an item from a HashSet without enumeration?

I'm looking for insight into the heads of HashSet designers. As far as I am aware, my question applies to both Java and C# HashSets, making me think there must be some good reason for it, though I can't think of any myself. After I have inserted an item into a HashSet, why is it impossible to retrieve that item without enumeration, hardly an efficient operation? Especially since a HashSet is explicitly built in a way which supports efficient retrieval. It would often be useful to me to have Remove(x) and Contains(x) return the actual item that is being removed or contained. This is not necessarily the item I pass into the Remove(x) or Contains(x) function. Sure, I guess I could achieve the same effect through a HashMap but why waste all that space and effort when it should be perfectly possible to do this with a set? I can appreciate that there may be some design concerns that adding this functionality would allows uses of HashSet which are not consistent with their role or future role in the framework, but if this is so, what are these design concerns? Edit To answer some more questions, here are more details: I am using an immutable reference type with overridden hashcode, equals, etc to emulate a value type in C#. Let's say the type has members A, B, and C. Hashcode, equals, etc depend only on A and B. Given some A and B I want to be able to retrieve that equivalent item from a hashset and get it's C. I won't be able to use HashSet for this it appears, but I would at least like to know if there is any good reason for this. Pseudo code follows: public sealed class X{ object A; object B; object extra; public int HashCode(){ return A.hashCode() + B.hashCode(); } public bool Equals(X obj){ return obj.A == A && obj.B == B; } } hashset.insert(new X(1,2, extra1)); hashset.contains(new X(1,2)); //returns true, but I can't retrieve extra
