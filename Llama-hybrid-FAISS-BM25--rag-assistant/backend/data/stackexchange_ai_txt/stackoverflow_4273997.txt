[site]: stackoverflow
[post_id]: 4273997
[parent_id]: 2396415
[tags]: 
This is most likely used in singleton design pattern, wherein the constructor is defined as private so as to avoid being instantiated, the double colon (::) operator can access members that are declared static inside the class, so if there are static members, the pseudo variable $this cannot be used, hence the code used self instead, Singletons are good programming practices that will only allow 1 instance of an object like database connector handlers. From client code, accessing that instance would be done by creating a single access point, in this case he named it getInstance() , The getInstance in itself was the function that created the the object basically using the new keyword to create an object meaning the constructor method was also called. the line if(!isset(self::instance)) checks if an object has already been created, you could not understand this becuase the code is just a fragment, somewhere in the top, there should be static members like probably private static $_instance = NULL; in normal classes we would have accessed this member by simply $this->_instance = 'something'; but its declared static and so we could not use the $this code we use instead self::$_instance by checking if there is an object stored on this static class variable, the class can then decide to create or not to create a single instance, so if its not set, !isset, meaning no object exists on the static member $_instance, then it generates a new object, stored it in the static member $_instance by the command self::$_instance = new self(); and returned it to client code. The client code can then happily use the single instance of the object with its public methods, but in the client code, calling the single access point, that is, the getInstance() method is also tricky, it has to be called like this $thisObject = className::getInstance(); the reason, the function in itself is declared static.
