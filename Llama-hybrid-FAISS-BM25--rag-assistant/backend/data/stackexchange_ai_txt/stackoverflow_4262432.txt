[site]: stackoverflow
[post_id]: 4262432
[parent_id]: 4261916
[tags]: 
I still cannot understand the need or usage for this but g++ 4.4.3 with -O3 -Wall works with the following patch. If it works, can you share the use case, why you need this? class DuckOrSoup { public: DuckOrSoup() : _type(TYPE_UNSET) {_duck = NULL; _soup = NULL;/* empty*/} ~DuckOrSoup() {Unset();} void Unset() {ChangeType(TYPE_UNSET);} void SetValueDuck(const Duck & duck) {ChangeType(TYPE_DUCK); _duck = new (&_data[0])Duck (duck); } void SetValueSoup(const Soup & soup) { ChangeType(TYPE_SOUP); _soup = new (&_data[0])Soup (soup); } private: void ChangeType(int newType); template struct _maxx {enum {sz = (S1>S2)?S1:S2};}; #define compile_time_max(a,b) (_maxx ::sz) enum {STORAGE_SIZE = compile_time_max(sizeof(Duck), sizeof(Soup))}; char _data[STORAGE_SIZE]; int _type; // a TYPE_* indicating what type of data we currently hold Duck* _duck; Soup* _soup; }; void DuckOrSoup :: ChangeType(int newType) { if (newType != _type) { switch(_type) { case TYPE_DUCK: _duck->~Duck(); _duck = NULL; break; case TYPE_SOUP: _soup->~Soup(); _soup = NULL; break; } _type = newType; switch(_type) { case TYPE_DUCK: _duck = new (&_data[0]) Duck(); break; case TYPE_SOUP: _soup = new (&_data[0]) Soup(); break; } } }
