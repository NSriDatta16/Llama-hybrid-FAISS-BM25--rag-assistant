[site]: stackoverflow
[post_id]: 5331458
[parent_id]: 5330106
[tags]: 
Do you really need to keep track of all of the unsampled cases? Even if you had a 1-by-10 10 vector that stored a logical value of true or false indicating if that permutation had been sampled or not, that would still require about 10 GB of storage, and MATLAB is likely to either throw an "Out of Memory" error or bring your entire machine to a screeching halt if you try to create a variable of that size. An alternative to consider is storing a sparse vector of indicators for the permutations you've already sampled. Let's consider your smaller example: A = 1:8; B = 1:10; C = 1:25; nA = numel(A); nB = numel(B); nC = numel(C); beenSampled = sparse(1,nA*nB*nC); The 1-by-2000 sparse matrix beenSampled is empty to start (i.e. it contains all zeroes) and we will add a one at a given index for each sampled permutation. We can get a new sample permutation using the function RANDI to give us indices into A , B , and C for the new set of values: indexA = randi(nA); indexB = randi(nB); indexC = randi(nC); We can then convert these three indices into a single unique linear index into beenSampled using the function SUB2IND : index = sub2ind([nA nB nC],indexA,indexB,indexC); Now we can test the indexed element in beenSampled to see if it has a value of 1 (i.e. we sampled it already) or 0 (i.e. it is a new sample). If it has been sampled already, we repeat the process of finding a new set of indices above. Once we have a permutation we haven't sampled yet, we can process it: while beenSampled(index) indexA = randi(nA); indexB = randi(nB); indexC = randi(nC); index = sub2ind([nA nB nC],indexA,indexB,indexC); end beenSampled(index) = 1; newSample = [A(indexA) B(indexB) C(indexC)]; %# ...do your subsequent processing... The use of a sparse array will save you a lot of space if you're only going to end up sampling a small portion of all of the possible permutations. For smaller total numbers of permutations, like in the above example, I would probably just use a logical vector instead of a sparse vector.
