[site]: stackoverflow
[post_id]: 5717589
[parent_id]: 5716220
[tags]: 
You can search for a free PDF book "C++-GUI-Programming-with-Qt-4-1st-ed.zip" and read Chapter 18 about Multi-threading in Qt. Concurrent programming features supported by Qt includes (not limited to) the following: Mutex Read Write Lock Semaphore Wait Condition Thread Specific Storage However, be aware of the following trade-offs with Qt: Performance penalties vs native threading libraries. POSIX thread (pthreads) has been native to Linux since kernel 2.4 and may not substitute for in W32API in all situations. Inter-thread communication in Qt is implemented with SIGNAL and SLOT constructs. These are NOT part of the C++ language and are implemented as macros which requires proprietary code generators provided by Qt to be fully compiled. If you can live with the above limitations, just follow these recipes for using QThread: #include Derive your own class from QThread. You must implement a public function run() that returns void to contain instructions to be executed. Instantiate your own class and call start() to kick off a new thread. Sameple Code: #include class MyThread : public QThread { public: void run() { // do something } }; int main(int argc, char** argv) { MyThread t1, t2; t1.start(); // default implementation from QThread::start() is fine t2.start(); // another thread t1.wait(); // wait for thread to finish t2.wait(); return 0; }
