[site]: stackoverflow
[post_id]: 3704402
[parent_id]: 3694100
[tags]: 
If the values are correctly in range (0..1023), then your last conversion is unnecessarily wasteful on the divisions; the last line could be replaced with: temp[3] = 1023 / 1000; or even: temp[3] = 1023 >= 1000; Since division is repeated subtraction, but you have a very special case (not a general case) division to deal with, I'd be tempted to compare the timings for the following code with the division version. I note that you put the digits into the string in 'reverse order' - the least significant digit goes in temp[0] and the most in temp[4] . Also, there is no chance of null-terminating the string given the storage. This code uses a table of 8 bytes of static data - considerably less than many of the other solutions. void convert_to_ascii(int value, char *temp) { static const short subtractors[] = { 1000, 100, 10, 1 }; int i; for (i = 0; i = subtractors[i]) { n++; value -= subtractors[i]; } temp[3-i] = n + '0'; } } Performance testing - Intel x86_64 Core 2 Duo 3.06 GHz (MacOS X 10.6.4) This platform is probably not representative of your microcontroller, but the test shows that on this platform, the subtraction is considerably slower than the division. void convert_by_division(int value, char *temp) { temp[0] = (value % 10) + '0'; temp[1] = (value % 100) / 10 + '0'; temp[2] = (value % 1000) / 100 + '0'; temp[3] = (value % 10000) / 1000 + '0'; } void convert_by_subtraction(int value, char *temp) { static const short subtractors[] = { 1000, 100, 10, 1 }; int i; for (i = 0; i = subtractors[i]) { n++; value -= subtractors[i]; } temp[3-i] = n + '0'; } } #include #include #include static void time_convertor(const char *tag, void (*function)(void)) { int r; Clock ck; char buffer[32]; clk_init(&ck); clk_start(&ck); for (r = 0; r Compiling with GCC 4.5.1, and working in 32-bit, the average timings were (optimization ' -O '): 0.13 seconds using division 0.65 seconds using subtraction Compiling and working in 64-bit, the average timings were: 0.13 seconds using division 0.48 seconds using subtraction Clearly, on this machine, using subtraction is not a winning proposition. You would have to measure on your machine to make a decision. And removing the modulo 10000 operation will only skew results in favour of the division (it knocks about 0.02 seconds off the time with division when replaced with the comparison; that's a 15% saving and worth having).
