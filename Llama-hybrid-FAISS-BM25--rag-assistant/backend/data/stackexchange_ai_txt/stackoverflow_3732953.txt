[site]: stackoverflow
[post_id]: 3732953
[parent_id]: 3732939
[tags]: 
Using a lambda would be tricky - it will end up being a method in a different class, if it captures local variables. You could detect that, of course, but it wouldn't be compile-time safe. Likewise the signature part is interesting, in that if it's definitely an Action , the delegate has no parameters. You can't just make the parameter Delegate , or method group conversions won't work... although you could still call myFoo.AddCallBack(new Action (MyMethodName)); An alternative is to produce a bunch of overloads: public static void AddCallback(this Foo foo, Action action) public static void AddCallback (this Foo foo, Action action) public static void AddCallback (this Foo foo, Action action) It wouldn't be elegant, but you'd probably only need a few for practical reasons. If any methods returned values, you'd need similar ones for Func . There's the additional potential problem of passing a delegate with multiple actions... again, you could check this at compile-time. Finally, you might want to check that the Target of the delegate is the same as the foo parameter. With these problems out of the way, working out the signature is relatively straightforward. You use the Delegate.Method property, and from that you can get the name and parameter types. If the library requires "int" rather than "System.Int32" etc then you'll need a bit of faffing around that, but it shouldn't be too bad. (It does sound like a pretty odd API though.)
