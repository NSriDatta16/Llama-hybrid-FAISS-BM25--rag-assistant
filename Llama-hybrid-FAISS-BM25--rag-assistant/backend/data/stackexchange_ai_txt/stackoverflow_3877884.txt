[site]: stackoverflow
[post_id]: 3877884
[parent_id]: 3877862
[tags]: 
operate is initialised to NULL because it is a global variable, not because it is a function pointer. All objects with static storage duration (which includes global variables, file-level static variables and static variables in functions) are initialised to 0 or NULL if no initialiser is given. [EDIT in response to Jim Buck's comment:] In C++, this is guaranteed by clause 3.6.2/1 of the language standard, which begins: Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place. Zero-initialization and initialization with a constant expression are collectively called static initialization ; all other initialization is dynamic initialization . I expect the same behaviour is true of C, since C++ is designed to be compatible with it on most things, although I don't have the standard for it. [EDIT #2] As Jeff M points out in a comment, it's important to realise that variables of automatic storage duration (that is, "ordinary" local variables) are not automatically zero-initialised: unless an initialiser is given, or they are assigned values by a constructor, they will initially contain random garbage (whatever was already sitting in memory at that location). So it's a good habit to initialise all variables -- it can't hurt but can help.
