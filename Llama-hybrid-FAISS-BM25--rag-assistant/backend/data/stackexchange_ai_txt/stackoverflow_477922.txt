[site]: stackoverflow
[post_id]: 477922
[parent_id]: 477880
[tags]: 
For Unix: ::signal(SIGINT, sigintHandler); ::signal(SIGKILL, sigkillHandler); //etc Make those handlers push a quit event onto your eventqueue (or equivalent) and ignore the signal. Your app will then be able to quit gracefully. However, there's one signal (SIGKILL) which can't be ignored. To handle that, determine the most critical resources you really wanna release on a kill (i'm not convinced a temp dir is that important. just delete in on next start.), and in your handler, call a release function on your relevant singletons. To elaborate on singletons . ::signal cannot call bound functions, so your handler only has access to singletons/globals. If your design doesn't organize things with singletons (and it shouldn't), you can still often hack around that. For example if you have multiple MainWindows across the stack, then you can also have a global vector of pointers to all of them, which you can access from the handler if necessary. Note that for common kills (like with kill foo ) you get SIGQUIT rather than SIGKILL -- and SIGQUIT is nicely ignorable. SIGKILL is only for kill -9 foo (in which case the user might does not even want you doing cleanup). Yes, signals are hairy. edit - I was informed SIGKILL is not only unignorable, but also uncatchable . And indeed, there isn't much of anything sane you can do on SIGKILL. Deleting a temp dir? Why? That temp dir was there for a reason. Just pretend sigkill is a power outage and recover on next start -- unless you can do a specific hack as was commented by others about unlinking. That's what I get for talking out of my ass.
