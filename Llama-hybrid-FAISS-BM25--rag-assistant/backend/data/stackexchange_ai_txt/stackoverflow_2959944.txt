[site]: stackoverflow
[post_id]: 2959944
[parent_id]: 2959691
[tags]: 
DISCLAIMER: i would never write code this way IRL. Ok, here is the hack I was talking about. Just don't use it in any code that is going to be remotely important, as it's not guaranteed to always work, but you'll see the idea of how memory is organized after looking at it. I encourage compiling them to assembly with gcc -S and taking a look at that as well. root@brian:~# cat struct-hack.c #include struct hack { int a, b; }; int main() { struct hack myhack = { 0xDEAD, 0xBEEF }; FILE *out = fopen("./out", "w"); fwrite(&myhack, sizeof(struct hack), 1, out); fclose(out); return 0; } root@brian:~# cat struct-read.c #include #include // in bytes. #define STRUCT_ADDRESS_MODE int #define STRUCT_SIZE 8 int main() { /** THIS IS BAD CODE. DO NOT USE IN ANY REMOTELY SERIOUS PROGRAM. **/ // Open file FILE *in = fopen("./out", "r"); if(!in) exit(1); // We need a way of addressing the structure, an Int is convenient because we // know the structure contains a couple ints. STRUCT_ADDRESS_MODE *hacked_struct = malloc(STRUCT_SIZE); if(!hacked_struct) exit(1); fread(hacked_struct, STRUCT_SIZE, 1, in); printf ("%x, %x\n", hacked_struct[0], hacked_struct[1]); free(hacked_struct); fclose(in); return 0; } root@brian:~# ./struct-hack root@brian:~# hexdump -C out 00000000 ad de 00 00 ef be 00 00 |........| 00000008 root@brian:~# ./struct-read dead, beef
