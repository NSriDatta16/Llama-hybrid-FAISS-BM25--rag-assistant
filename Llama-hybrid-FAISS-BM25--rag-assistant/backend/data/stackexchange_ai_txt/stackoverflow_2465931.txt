[site]: stackoverflow
[post_id]: 2465931
[parent_id]: 2462719
[tags]: 
There are two schools of thought for working with SVN (and most other centralized VCS): Stable Trunk - The trunk is where all of your good stable code is. Only safe "single work-unit" changes are done to the trunk. All of your development is done in branches and then merged to the trunk. When it is release time, you tag from the trunk. Unstable Trunk - The trunk is your "bleeding edge". All the new stuff gets committed to the trunk. When your work starts to gel into a release, you make a branch where you can work on stabilizing and polishing everything. You'll end up with a branch for each release (branches/v1.0, branches/v1.1, etc). You tag from the release branch when it is ready. Notes about Model #1: People can work in branches without stomping on each other. You can divide the unstable development work up as you see fit, even one branch per developer. You can have hierarchical branches, with quality gates between them. Example: Joe commits unstable stuff to his private branch, when Joe is happy with his work, it gets merged to the team-level branch, which gets tested more formally, and then it is merged to the trunk with the fully-tested work from other teams. This means a lot of merging, in both directions. Stuff gets pushed up to the trunk. Trunk changes need to be propagated down to the branches. Prior to SVN's merge tracking features, this was really hard to do. Notes about Model #2: The development work is more collaborative. It discourages people from working for a too long in isolation, then dropping a bomb onto the codebase. There will be a lot of broken builds, unless you enforce some discipline with pre-commit testing. It encourages keeping the codebase modularized, so you don't have everyone fighting to change the same files in the trunk at the same time. This model makes it easier to manage updates to older and newer releases (e.g. you are releasing bugfixes for both v1.x and v2.x). For long-running changes, you probably need a branch to work on the feature anyway. I have seen both models work very well. It depends on how the team works and how the codebase is structured.
