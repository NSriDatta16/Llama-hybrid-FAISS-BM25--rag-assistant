[site]: datascience
[post_id]: 124044
[parent_id]: 124042
[tags]: 
I asked ChatGPT, and, to my surprise (due to previous experience), it solved my question correctly, as far as I can say at the moment, but I am open for comments. Apparently this works: class Autoencoder(Model): def __init__(self, latent_dim, shape): super(Autoencoder, self).__init__() self.latent_dim = latent_dim self.shape = shape self.ht = 2 self.buffer = tf.Variable(initial_value=tf.zeros(shape=(shape[0], shape[1] * self.ht), dtype=tf.float32)) self.encoder = tf.keras.Sequential([ layers.Flatten(), layers.Dense(int(shape[0] * shape[1] * 1.5), activation='swish'), layers.Dense(latent_dim, activation='swish'), ]) self.decoder = tf.keras.Sequential([ layers.Dense(int(shape[0] * shape[1] * 1.5), activation='swish'), layers.Dense(tf.math.reduce_prod(shape), activation='sigmoid'), layers.Reshape(shape) ]) def update_buffer(self, new_element): n = self.shape[1] self.buffer[:, n:].assign(self.buffer[:, :-n]) self.buffer[:, :n].assign(new_element) def call(self, x): decoded = [] for i in range(x.shape[0]): buffer_tensor = self.buffer xin = tf.expand_dims(tf.concat((x[i, :, :], buffer_tensor), axis=1), axis=0) encoded = self.encoder(xin) buffer_reshaped = tf.reshape(buffer_tensor, [1, self.buffer.shape[0] * self.buffer.shape[1]]) decin = tf.concat([encoded, buffer_reshaped], axis=1) y = self.decoder(decin) decoded.append(y) self.update_buffer(tf.squeeze(y)) out = tf.squeeze(tf.convert_to_tensor(decoded)) return out I tried something similar, but got the assignment in the update_buffer function wrong apparently!
