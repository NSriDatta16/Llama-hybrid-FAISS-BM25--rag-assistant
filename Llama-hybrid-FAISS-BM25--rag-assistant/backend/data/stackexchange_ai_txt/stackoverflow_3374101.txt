[site]: stackoverflow
[post_id]: 3374101
[parent_id]: 3373794
[tags]: 
The code you provided gives this error: Couldn't match expected type `Double' against inferred type `m Double' In the expression: get >>= \ s0 -> let (x, s1) = ... in put s1 >> return x In the definition of `getAverage': getAverage s c = get >>= \ s0 -> let ... in put s1 >> return x All this means is that the type resulting from the expression ("inferred") disagrees with the type signature ("expected"). In this case, getAverage operates in the State monad, so it's the type signature that's incorrect, as it can't evaluate to a non-monadic type. Your code has other problems besides that, however, and won't compile even after fixing that particular issue. First a few stylistic issues to make it more readable: getAverage has an unused parameter, which is supposedly a value in the State monad, which doesn't really make sense anyway. Using the do notation is usually clearer than using (>>=) and lambdas, especially for something like State . The indentation of the second line is confusing, since the in goes with the let that's inside the lambda. Making those changes we have this: getAverage s = do s0 ...which makes it easier to spot the next error: The second argument of media is a 2-tuple, and s1 is just a single number, but you're trying to use both for the state value. Probably what you wanted was to set the state to (x, s1) , but return only x . getAverage s = do s0 This compiles just fine, but still needs some tidying: media needs to update the entire state value, so rather than get ting and put ting, just use the modify function. The return value is the first part of the state value, so just fmap ing fst over get is more straightforward. So now we have something like this: media :: Double -> MyState -> MyState media s (a, n) = ((a * n + s) / (n + 1), n + 1) getAverage:: Double -> State MyState Double getAverage s = do modify (media s) fmap fst get We can also note that getAverage is kind of doing two different things, and split it into separate functions: updateAverage:: Double -> State MyState () updateAverage s = modify (media s) currentAverage :: State MyState Double currentAverage = fmap fst get getAverage:: Double -> State MyState Double getAverage s = updateAverage s >> currentAverage Edit : And since I forgot about the minor detail of actually getting the results back out of the monad, replacing updateAverage with getAverage in Travis Brown's getAverages function will let it work on my code above.
