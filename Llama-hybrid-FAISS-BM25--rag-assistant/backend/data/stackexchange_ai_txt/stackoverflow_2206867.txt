[site]: stackoverflow
[post_id]: 2206867
[parent_id]: 2206735
[tags]: 
[Edit: just noticed that although your title says "be inlined", your actual question says "making functions inline". The two effectively have nothing to do with one another, they just have confusingly similar names. In modern compilers, the primary effect of inline is the thing that originally in C99 was (I think) just a necessary detail to make inline work at all: to permit multiple definitions of a symbol with external linkage. That's because modern compilers don't pay a whole lot of attention to the programmer's opinion of whether a function should be inlined. They do pay some, though, so the confusion of concepts persists. I've answered the question in the title, which is the decision the compiler makes, not the question in the body, which is the decision the programmer makes.] Inlining is not necessarily an all-or-nothing deal. One strategy which compilers use to decide whether to inline, is to keep inlining function calls until the resulting code is "too big". "Big" is defined by some hopefully sensible heuristic. So consider the following recursive function (which deliberately is not simply tail-recursive): int triangle(int n) { if (n == 1) return 1; return n + triangle(n-1); } If it's called like this: int t100() { return triangle(100); } Then there's no particular reason in principle that the usual rules that the compiler uses for inlining shouldn't result in this: int t100() { // inline call to triangle(100) int result; if (100 == 1) { result = 1; } else { // inline call to triangle(99) int t99; if (100 - 1 == 1) { t99 = 1; } else { // inline call to triangle(98) int t98; if (100 - 1 - 1 == 1) { t98 = 1; } else { // oops, "too big", no more inlining t98 = triangle(100 - 1 - 1 - 1) + 98; } t99 = t98 + 99; } result = t99 + 100; } return result; } Obviously the optimiser will have a field day with that, so it's much "smaller" than it looks: int t100() { return triangle(97) + 297; } The code in triangle itself could be "unrolled" a few steps by a few levels of inlining, in exactly the same way, except that it doesn't have the benefits of constants: int triangle(int n) { if (n == 1) return 1; if (n == 2) return 3; if (n == 3) return 6; return triangle(n-3) + 3*n - 3; } I doubt whether compilers actually do this, though, I don't think I've ever noticed it [Edit: MSVC does if you tell it to, thanks peterchen]. There's an obvious potential benefit in saving call overhead, but as against that people don't really expect recursive functions to get inlined, and there's no particular guarantee that the usual inlining heuristics will perform well with recursive functions (where there are two different places, the call site and the recursive call, that might be inlined, with different benefits in each case). Furthermore, it's difficult at compile time to estimate how deep the recursion will go, and the inline heuristics might like to take account of the call depth to make decisions. So it may be that the compiler just doesn't bother. Functional language compilers are typically a lot more aggressive dealing with recursion than C or C++ compilers. The relevant trade-off there is that so many functions written in functional languages are recursive, that performance might be hopeless if the compiler couldn't optimise tail-recursion. So Lisp programmers typically rely on good optimisation of recursive functions, whereas C and C++ programmers typically don't.
