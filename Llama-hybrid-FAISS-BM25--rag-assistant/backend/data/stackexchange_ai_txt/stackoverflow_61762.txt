[site]: stackoverflow
[post_id]: 61762
[parent_id]: 61677
[tags]: 
This is how I did it just recently. Add an interface that implements IDispatch and a coclass for that interface to your IDL: [ object, uuid(6EDA5438-0915-4183-841D-D3F0AEDFA466), nonextensible, oleautomation, pointer_default(unique) ] interface IServerEvents : IDispatch { [id(1)] HRESULT OnServerEvent(); } //... [ uuid(FA8F24B3-1751-4D44-8258-D649B6529494), ] coclass ServerEvents { [default] interface IServerEvents; [default, source] dispinterface IServerEvents; }; This is the declaration of the CServerEvents class: class ATL_NO_VTABLE CServerEvents : public CComObjectRootEx , public CComCoClass , public IDispatchImpl , public IConnectionPointContainerImpl , public IConnectionPointImpl { public: CServerEvents() { } // ... BEGIN_COM_MAP(CServerEvents) COM_INTERFACE_ENTRY(IServerEvents) COM_INTERFACE_ENTRY(IDispatch) COM_INTERFACE_ENTRY(IConnectionPointContainer) END_COM_MAP() BEGIN_CONNECTION_POINT_MAP(CServerEvents) CONNECTION_POINT_ENTRY(__uuidof(IServerEvents)) END_CONNECTION_POINT_MAP() // .. // IServerEvents STDMETHOD(OnServerEvent)(); private: CRITICAL_SECTION m_csLock; }; The key here is the implementation of the IConnectionPointImpl and IConnectionPointContainerImpl interfaces and the connection point map. The definition of the OnServerEvent method looks like this: STDMETHODIMP CServerEvents::OnServerEvent() { ::EnterCriticalSection( &m_csLock ); IUnknown* pUnknown; for ( unsigned i = 0; ( pUnknown = m_vec.GetAt( i ) ) != NULL; ++i ) { CComPtr spDisp; pUnknown->QueryInterface( &spDisp ); if ( spDisp ) { spDisp.Invoke0( CComBSTR( L"OnServerEvent" ) ); } } ::LeaveCriticalSection( &m_csLock ); return S_OK; } You need to provide a way for your client to specify their handler for your events. You can do this with a dedicated method like "SetHandler" or something, but I prefer to make the handler an argument to the method that is called asynchronously. This way, the user only has to call one method: STDMETHOD(DoSomethingAsynchronous)( IServerEvents *pCallback ); Store the pointer to the IServerEvents, and then when you want to fire your event, just call the method: m_pCallback->OnServerEvent(); As for the VB code, the syntax for dealing with events is a little different than what you suggested: Private m_server As Server Private WithEvents m_serverEvents As ServerEvents Private Sub MainMethod() Set s = CreateObject("Server") Set m_serverEvents = New ServerEvents Call m_searchService.DoSomethingAsynchronous(m_serverEvents) End Sub Private Sub m_serverEvents_OnServerEvent() MsgBox "Event handled" End Sub I hope this helps.
