[site]: stackoverflow
[post_id]: 2807105
[parent_id]: 2807049
[tags]: 
The linked in C Run Time is a wrapper around your "main" function; it initializes everything that is needed before your C code can be run. It does not contain (m)any "functions", those are in the C standard library (which is dynamically linked). I think you misunderstand dynamic linking: it's done by the OS. So you tell the OS that your executable needs DLL a , b , c and d . The time you execute your executable, the OS will load the executable in a memory location, and reads in the executable what is necessary to run it. It will then grab those DLLs and paste them in the memory region of your executable, and then it tells your code that a is loaded at x , b is loaded at y , etc. so your code can call it's functions. Sometimes, compilers include (called statical linking) a library at compile-time: they do that, such that the OS doesn't have to load it at runtime, and thus loads faster. .lib files are DLL files without the "D", because they can be statically linked. It's also possible to dynamically link against library files; this makes your executable smaller, but makes load time of your executable slower. About the WinAPI: most calls to the C library are converted into (some) calls into the WinAPI; but only if they have to interact with the OS (I/O, etc.). The difference is that the C library is equal on most platforms, so it increases portability if you use the C library instead of the Windows API's directly. Update : You asked how to load a DLL if you completely dynamically link your executable? Well: you don't have to! The difference between the "load dll" and "call to load dll" is; the "load dll" is done by the OS when you launch the application. The OS will search your executable for a specific "import table". It's a table stating which DLLs it really needs, before it can execute (i.e. kernel32.dll or user32.dll on Windows). The OS will make the "call to load dll", even before your code runs. The "call to load dll" also exists in kernel32.dll for your code to be called: it's possible to load/unload DLLs while your code runs. This can be of a case, if you have a huge code-base and you want to free memory by unloading that one-time use library during your whole application lifetime (for instance, during startup). If you don't use the function anymore, you can unload the DLL. But it's also possible that you need some function, which you haven't loaded yet, to speed up loading. You can then load the DLL if you need the function yourself. This is quite advanced stuff, and most of the time, the OS will swap away the unused DLLs anyway ("removing" memory, literally: it moves the memory that isn't used much (like an unused DLL) to a place of mass storage, like the harddisk. If you need it, it automatically "swaps" it back!). So: you don't have to concern much about loading/unloading DLLs on Windows. If you have a good linker, and tell it to dynamically link against libraries, it will all work out just fine.
