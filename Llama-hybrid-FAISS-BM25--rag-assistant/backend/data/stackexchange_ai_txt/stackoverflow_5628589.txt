[site]: stackoverflow
[post_id]: 5628589
[parent_id]: 5628057
[tags]: 
You need to find some constraint for your system and work to keep that within some reasonable bounds. I've done a bunch of molecular collision simulations and in those systems the total energy is conserved, so every step I double check the total energy of the system and if it varies by some threshold, then I know that my time step was poorly chosen (too big or too small) and I pick a new time step and rerun it. That way I can keep track of what's happening to the system in real time. For this simulation, I don't know what conserved quantity you have, but if you have one, you can try to keep that constant. Remember, making your time step smaller doesn't always increase the accuracy, you need to optimize the step size with the amount of precision you have. I've had numerical simulations run for weeks of CPU time and conserved quantities were always within 1 part in 10^8, so it is possible, you just need to play around some. Also, as Tomalak said, maybe try to always reference your system to the start time rather than to the previous step. So rather than always moving your chromosomes keep the chromosomes at their start place and store with them a transformation matrix that gets you to the current location. When you compute your new rotation, just modify the transformation matrix. It may seem silly, but sometimes this works well because the errors average out to 0. For example, lets say I have a particle that sits at (x,y) and every step I calculate (dx, dy) and move the particle. The step-wise way would do this t0 (x0,y0) t1 (x0,y0) + (dx,dy) -> (x1, y1) t2 (x1,y1) + (dx,dy) -> (x2, y2) t3 (x2,y2) + (dx,dy) -> (x3, y3) t4 (x3,30) + (dx,dy) -> (x4, y4) ... If you always reference to t0, you could do this t0 (x0, y0) (0, 0) t1 (x0, y0) (0, 0) + (dx, dy) -> (x0, y0) (dx1, dy1) t2 (x0, y0) (dx1, dy1) + (dx, dy) -> (x0, y0) (dx2, dy2) t3 (x0, y0) (dx2, dy2) + (dx, dy) -> (x0, y0) (dx3, dy3) So at any time, tn, to get your real position you have to do (x0, y0) + (dxn, dyn) Now for simple translation like my example, you're probably not going to win very much. But for rotation, this can be a life saver. Just keep a matrix with the Euler angles associated with each chromosome and update that rather than the actual position of the chromosome. At least this way they won't float away.
