[site]: stackoverflow
[post_id]: 2299350
[parent_id]: 2298752
[tags]: 
what you can do is to use a self-organizing map (SOM) with the topology of fixed length, say N-bit, words, so that e.g. if N=8 then every cell in the SOM has exactly 8 neighbors (those where one bit has been flipped). Now if you have K [dictionary] words you can encode every [dictionary] word as a vector of real numbers between 0..1 so that the ith word has the ith element set to 1 and others to 0. You can then calculate the "distance" between two arbitrary vectors a1...aK and b1...bK by summing over i,j : ai * bj * distance(ai, bj) which gives you the distance metric for running the SOM algorithm. When the SOM has stabilized, [dictionary] words near to each other in your metric are near to each other in the topology of the map, from which you get the encoding trivially as [binary] words. Note that the map must have more cells than there are words, i.e. 2**N > K. This answer of course assumes background with self organizing maps. See http://en.wikipedia.org/wiki/Self-organizing_map
