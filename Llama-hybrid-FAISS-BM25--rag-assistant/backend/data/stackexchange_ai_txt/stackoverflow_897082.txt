[site]: stackoverflow
[post_id]: 897082
[parent_id]: 896786
[tags]: 
I have implemented a benchmark program to compare the effect of the different expression. I computed y using double precision and then compute y using single precision with different expressions. Here are the expression tested: inline double getYDbl( double x, double x0, double y0, double x1, double y1 ) { double const t = (x - x0)/(x1 - x0); return y0 + t*(y1 - y0); } inline float getYFlt1( float x, float x0, float y0, float x1, float y1 ) { double const t = (x - x0)/(x1 - x0); return y0 + t*(y1 - y0); } inline float getYFlt2( float x, float x0, float y0, float x1, float y1 ) { double const t = (x - x0)*(y1 - y0); return y0 + t/(x1 - x0); } inline float getYFlt3( float x, float x0, float y0, float x1, float y1 ) { double const t = (y1 - y0)/(x1 - x0); return y0 + t*(x - x0); } inline float getYFlt4( float x, float x0, float y0, float x1, float y1 ) { double const t = (x1 - x0)/(y1 - y0); return y0 + (x - x0)/t; } I computed the average and stdDev of the difference between the double precision result and single precision result. The result is that there is none on the average over 1000 and 10K random value sets. I used icc compiler with and without optimization as well as g++. Note that I had to use the isnan() function to filter out bogus values. I suspect these result from underflow in the difference or division. I don't know if the compilers rearrange the expression. Anyway, the conclusion from this test is that the above rearrangements of the expression have no effect on the computation precision. The error remains the same (on average).
