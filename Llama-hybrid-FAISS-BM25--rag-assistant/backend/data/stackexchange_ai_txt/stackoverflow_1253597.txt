[site]: stackoverflow
[post_id]: 1253597
[parent_id]: 1253388
[tags]: 
There is no memory fragmentation in Java; during the GC run, memory areas are compacted. Since you don't see a high CPU utilization, there is no GC running, either. So something else must be the cause of your problems. Here are a few ideas: If the database of your application is on a different server, there may be network problems If you run Windows and you have mapped network drives, one of the drives may lock up your computer (again network problems). The same is true for NFS drives on Unix. Check the system log for network errors. Is the computer swapping lots of data to disk? Since CPU util is low, the cause of the problem could be that the app was swapped to disk and the GC run forced it back into RAM. This will take a long time if your server hasn't enough real RAM to keep the whole Java app in RAM. Also, other processes can force the app out of RAM. Check the real memory utilization and your swap space usage. To understand the output of the GC log, this post might help. [EDIT] I still can't get my head around "low CPU" and "GC stalls". Those two usually contradict each other. If the GC is stalling, you must see 100% CPU usage. If the CPU is idle, then something else is blocking the GC. Do you have objects which overload finalize() ? If a finalize blocks, the GC can take forever.
