[site]: stackoverflow
[post_id]: 4044360
[parent_id]: 4044275
[tags]: 
If I define the following class class X {}; The compiler will define the following methods: X::X() {} // Default constructor. It takes zero arguments (hence default). X::~X() {} // Destructor X::X(X const& rhs) {}; // Copy constructor X& operator=(X const& rhs) {return *this;} // Assignment operator. // Since C++11 we also define move operations X::X(X&& rhs) {}; // Move Constructor X& operator=(X&& rhs) {return *this;} // Move Assignment Note: The default constructor is not built if ANY constructor is defined. The other methods are not built if the user defines an alternative. What is slightly more interesting is the default implementation when we have members and a base: class Y: public X { int a; // POD data int* b; // POD (that also happens to be a pointer) Z z; // A class }; // Note: There are two variants of the default constructor. // Both are used depending on context when the compiler defined version // of the default constructor is used. // // One does `default initialization` // One does `zero initialization` // Objects are zero initialized when // They are 'static storage duration' // **OR** You use the braces when using the default constructor Y::Y() // Zero initializer : X() // Zero initializer , a(0) , b(0) , z() // Zero initializer of Z called. {} // Objects are default initialized when // They are 'automatic storage duration' // **AND** don't use the braces when using the default constructor Y::Y() :X // Not legal syntax trying to portray default initialization of X (base class) //,a // POD: uninitialized. //,b // POD: uninitialized. ,z // Not legal syntax trying to portray default initialization of z (member) {} // // Note: It is actually hard to correctly zero initialize a 'automatic storage duration' // variable (because of the parsing problems it tends to end up a a function // declaration). Thus in a function context member variables can have indeterminate // values because of default initialization. Thus it is always good practice to // to initialize all members of your class during construction (preferably in the // initialization list). // // Note: This was defined this way so that the C++ is backward compatible with C. // And obeys the rule of don't do more than you need too (because we want the C++ // code to be as fast and efficient as possible. Y::Y(Y const& rhs) :X(rhs) // Copy construct the base ,a(rhs.a) // Copy construct each member using the copy constructor. ,b(rhs.b) // NOTE: The order is explicitly defined ,z(rhs.z) // as the order of declaration in the class. {} Y& operator=(Y const& rhs) { X::operator=(rhs); // Use base copy assignment operator a = rhs.a; // Use the copy assignment operator on each member. b = rhs.b; // NOTE: The order is explicitly defined z = rhs.z; // as the order of declaration in the class. return(*this); } Y::~Y() { Your Code first } // Not legal code. Trying to show what happens. : ~z() , ~b() // Does nothing for pointers. , ~a() // Does nothing for POD types , ~X() ; // Base class destructed last. // Move semantics: Y::Y(Y&& rhs) :X(std::move(rhs)) // Move construct the base ,a(std::move(rhs.a)) // Move construct each member using the copy constructor. ,b(std::move(rhs.b)) // NOTE: The order is explicitly defined ,z(std::move(rhs.z)) // as the order of declaration in the class. {} Y& operator=(Y&& rhs) { X::operator=(std::move(rhs)); // Use base move assignment operator a = std::move(rhs.a); // Use the move assignment operator on each member. b = std::move(rhs.b); // NOTE: The order is explicitly defined z = std::move(rhs.z); // as the order of declaration in the class. return(*this); }
