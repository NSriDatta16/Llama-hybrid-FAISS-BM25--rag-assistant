[site]: stackoverflow
[post_id]: 2031271
[parent_id]: 2030054
[tags]: 
In a view controller you can create an outlet for another controller. All you need to do is something like this in the same nib file in interface builder: MainController UIViewController ->UIview UIView ModalController UIViewController ->ModalControllerView UIView in MainController.h, create an outlet for the view controller: @property(nonatomic, retain) IBOutlet ModalController *ModalController (and of course you need the ivar and include also) In Interface Builder, connect ModalController mainController to the ModalController view using option drag or however you want. When the nib loads, you'll get modalController set to an instantiated ModalController, then methods in MainController can access modalController and do whatever they want to it. Then you just have to use presentModalView to present it. I think the more typical way to do this, though, is this: - (IBAction)showInfo { FlipsideViewController *controller = [[FlipsideViewController alloc] initWithNibName:@"FlipsideView" bundle:nil]; controller.delegate = self; controller.modalTransitionStyle = UIModalTransitionStyleFlipHorizontal; [self presentModalViewController:controller animated:YES]; [controller release]; } (That's directly from the Utility Application project template in Xcode.) In other words, create the modal controller and view in it's own nib file then load the nib file manually as needed. This is more memory efficient since it doesn't instantiate the object until it's actually needed. There's also no reason why you can't just do: modalController = [[ModalViewController alloc] initWithNibName:@"ModalView" bundle:nil]; in MainController's viewDidLoad or initWithCoder method or something, then proceed to configure it however you want.
