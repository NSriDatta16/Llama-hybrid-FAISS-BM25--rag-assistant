[site]: stackoverflow
[post_id]: 5095575
[parent_id]: 5090779
[tags]: 
The "right way" to do it in Haskell is to separate IO from, well, everything else. The direct translation of your code would be this: getncheck_guesslist :: IO [Int] getncheck_guesslist = do line [Int] check_guesslist line = let tmp = splitOneOf ",;" line in map read tmp Notice that getncheck_guesslist is simply an IO action. The function doesn't have input parameters , even though it does require (IO) input from getLine . Also notice that getncheck_guesslist is a simple modification of the getLine IO action. Isn't there a combinator that would let me push a function to act on the value inside a monad? Stop. Hoogle time! I have a function (a -> b) . I have a value of the input type, but it's stuck in a monad m a . I want to perform the function inside the monad, so the result will inevitably be stuck in the monad too m b . Putting that all together, we hoogle (a -> b) -> m a -> m b . Lo and behold, fmap is just what we were looking for. get_guesslist = check_guesslist `fmap` getLine -- or, taking it a step further get_guesslist = (map read . splitOneOf ",;") `fmap` getLine :: IO [Int] As a final note, whenever you code a method with the name like somethingAndSomethingElse , it's usually better coding style to write and invoke something and somethingElse as two separate methods. For the final versions, I just renamed it get_guesslist , since conceptually that's what it does. It gets the guesses as a list of Ints. As a final final note, I have left off at the point where barsoap started. ;) fmap is the same as .
