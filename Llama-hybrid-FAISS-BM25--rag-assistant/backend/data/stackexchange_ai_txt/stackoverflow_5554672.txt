[site]: stackoverflow
[post_id]: 5554672
[parent_id]: 5543474
[tags]: 
For anyone who stumbles upon this in the future, I'm posting a complete solution to my question here, thanks especially to Antal for showing me the major error in my table construction. Using ViewWillAppear to reload the table is a bad idea in general, because it causes the table, or portions of the table to load twice. The proper way to do this is using the Delegate method of the second view controller, which I've done here. I'm posting the relevant portions of the two view controllers. Both are setup as UViewControllers, not as UITableViewControllers. Both are modal views. I hope someone finds this useful. // // FirstViewController.h // #import #import "SecondViewController.h" @interface FirstViewController : UIViewController { UITableView *firstTableView; NSArray *myArray; } @property (nonatomic, retain) IBOutlet UITableView *firstTableView; @property (nonatomic, assign) NSArray *myArray; - (void) didSelectOptions:(NSInteger *)intOptionType; - (void) didCancelOptions; @end // // FirstViewController.m // #import "FirstViewController.h" #import "Constants.h" @implementation FirstViewController @synthesize firstTableView; @synthesize myArray; - (void) viewDidLoad { // Load the array that contains the option names, in this case, constants stored in Constants.h myArray = [[NSArray alloc] initWithObjects:kStoredRowName0, kStoredRowName1, kStoredRowName2, nil]; } // do everything else to deal with the first view . . . - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { // Use the indexPath.section as the identifier since objects in each section share unique construction, ie: switches, etc. NSString *identifier = [NSString stringWithFormat: @"%d", [indexPath indexAtPosition: 0]]; // In this example I'm storing the important integer value in NSUserDefaults as kStoredConstant NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; UITableViewCell *cell = [firstTableView dequeueReusableCellWithIdentifier:identifier]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle: UITableViewCellStyleDefault reuseIdentifier:identifier] autorelease]; switch (indexPath.section) { case 0: // OnOff Controls using UISwitch NSLog(@"Section 0"); // set up switches … break; case 1: // Segmented Controls using UISegmentedControl NSLog(@"Section 1"); // set up segmented controls … break; case 2: // Label that will be selected from SecondViewContoller NSLog(@"Section 2"); // set up label UILabel *myLabel = [[UILabel alloc] initWithFrame:CGRectMake(150.0, 15.0, 120.0, 17.0)]; myLabel.backgroundColor = [UIColor clearColor]; myLabel.font = [UIFont systemFontOfSize:14]; myLabel.textColor = [UIColor colorWithRed:0.25 green:0.0 blue:0.0 alpha:1.0]; myLabel.textAlignment = UITextAlignmentLeft; myLabel.tag = indexPath.section; myLabel.text = [myArray objectAtIndex:[userDefaults integerForKey:kStoredConstant]]; [cell addSubview:myLabel]; [myLabel release]; cell.textLabel.text = @"Choose A Value:"; cell.accessoryType = UITableViewCellAccessoryDetailDisclosureButton; break; } } else { switch (indexPath.section) { case 0: // OnOff Controls using UISwitch NSLog(@"Section 0"); break; case 1: // Segmented Controls using UISegmentedControl NSLog(@"Section 1"); break; case 2: // Label that will be selected from SecondViewContoller { NSLog(@"Section 2"); UILabel *myLabel = (UILabel *)[cell viewWithTag:indexPath.section]; myLabel.text = [myArray objectAtIndex:[userDefaults integerForKey:kStoredConstant]]; } break; } } // Format the cell label properties for all cells cell.textLabel.backgroundColor = [UIColor clearColor]; cell.textLabel.font = [UIFont systemFontOfSize:14]; cell.textLabel.textColor = [UIColor colorWithRed:0.25 green:0.0 blue:0.0 alpha:1.0]; cell.textLabel.highlightedTextColor = [UIColor colorWithRed:1.0 green:1.0 blue:0.9 alpha:1.0]; return cell; } - (void) tableView:(UITableView *)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath *)indexPath { // Un-highlight the selected cell [firstTableView deselectRowAtIndexPath:indexPath animated:YES]; switch (indexPath.section) { case 0: // Deal with changes in UISwitch Controls NSLog(@"Section 0"); break; case 1: // Deal with changes in Segmented Controls NSLog(@"Section 1"); break; case 2: // Launch the SecondViewContoller to select a value { SecondViewController *secondViewController = [[SecondViewController alloc] init]; secondViewController.modalTransitionStyle = UIModalTransitionStyleCrossDissolve; secondViewController.secondViewControllerDelegate = self; [self presentModalViewController:secondViewController animated:YES]; [secondViewController release]; } break; } } #pragma mark - #pragma mark SecondViewControllerDelegate - (void) didSelectOptions:(NSInteger *)intOptionType { // User selected a row in secondTableView on SecondViewController, store it in NSUserDefaults NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; [userDefaults setInteger:(int)intOptionType forKey:kStoredConstant]; [userDefaults synchronize]; // Reload only the row in firstTableView that has been changed, in this case, row 0 in section 2 [self.firstTableView reloadRowsAtIndexPaths:[NSArray arrayWithObject:[NSIndexPath indexPathForRow:0 inSection:2]]withRowAnimation:UITableViewRowAnimationNone]; [self dismissModalViewControllerAnimated:YES]; } - (void) didCancelOptions { // User didn't select a row, instead clicked a done or cancel button on SecondViewController [self dismissModalViewControllerAnimated:YES]; } // Make sure and release Array and Table // // SecondViewController.h // #import @protocol SecondViewControllerDelegate - (void) didCancelOptions; - (void) didSelectOptions:(NSInteger *)optionType; @end @interface SecondViewController : UIViewController { NSArray *myArray; UITableView *secondTableView; id secondViewControllerDelegate; } @property (nonatomic, retain) NSArray *myArray; @property (nonatomic, retain) IBOutlet UITableView *secondTableView; @property (nonatomic, assign) id secondViewControllerDelegate; - (IBAction) doneViewingOptions:(id)sender; // This is wired to a Cancel or a Done Button @end // // SecondViewController.m // #import "SecondViewController.h" #import "Constants.h" @implementation SecondViewController @synthesize secondViewControllerDelegate; @synthesize myArray; @synthesize secondTableView; - (void) viewDidLoad { // Load the array that contains the option names, in this case, constants stored in Constants.h myArray = [[NSArray alloc] initWithObjects:kStoredRowName0, kStoredRowName1, kStoredRowName2, nil]; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { // Build a default table. This one is simple so the following is the only important part: cell.textLabel.text = [myArray objectAtIndex:indexPath.row]; } - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { // Return the changed row value to the FirstViewController using secondViewControllerDelegate [self.secondViewControllerDelegate didSelectOptions:(NSInteger *)indexPath.row]; } - (IBAction) doneViewingOptions:(id)sender { // User didn't select a row, just clicked Done or Cancel button [self.secondViewControllerDelegate didCancelOptions]; } // Make sure and release Array and Table
