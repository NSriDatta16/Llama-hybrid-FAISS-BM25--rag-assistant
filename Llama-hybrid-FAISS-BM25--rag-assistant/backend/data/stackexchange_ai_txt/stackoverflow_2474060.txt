[site]: stackoverflow
[post_id]: 2474060
[parent_id]: 2473816
[tags]: 
Strings are immutable, so it will create a copy of the string. However if the substring matches the exact string of another string that was known at compile time , it will actually use the same memory as that substring. That's string interning. From MSDN : "The common language runtime automatically maintains a table, called the "intern pool", which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of String you add programmatically. The intern pool conserves string storage. If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of String that have identical values." The code sample is informative. You can prevent automatic interning using the [assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)] attribute to prevent automatic string interning. You would also have to use NGEN.exe to compile it to a native image, to prevent interning. Note that if you use a StringBuilder it avoids interning. It's only for strings that can be matched up with other strings known at compile time. This is a modified example of the MSDN article, notice that if I pass in part of "abcd" from the Console, it is still interned, even though that str3 is constructed at runtime. However StringBuilder avoids interning. // Sample for String.IsInterned(String) using System; using System.Text; using System.Runtime.CompilerServices; using System.Diagnostics; // In the .NET Framework 2.0 the following attribute declaration allows you to // avoid the use of the interning when you use NGEN.exe to compile an assembly // to the native image cache. //[assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)] class Sample { public static void Main() { // String str1 is known at compile time, and is automatically interned. String str1 = "abcd"; Console.WriteLine("Type cd and it will be ok, type anything else and Assert will fail."); string end = Console.ReadLine(); // Constructed, but still interned. string str3 = "ab" + end; // Constructed string, str2, is not explicitly or automatically interned. String str2 = new StringBuilder().Append("wx").Append("yz").ToString(); Console.WriteLine(); Test(1, str1); Test(2, str2); Test(3, str3); // Sanity checks. // Debug.Assert(Object.ReferenceEquals(str3, str1)); // Assertion fails, as expected. Debug.Assert(Object.ReferenceEquals(string.Intern(str3), string.Intern(str1))); // Passes Debug.Assert(Object.ReferenceEquals(string.Intern(str3), (str1))); // Passes Debug.Assert(Object.ReferenceEquals((str3), string.Intern(str1))); // Fails Console.ReadKey(); } public static void Test(int sequence, String str) { Console.Write("{0}) The string, '", sequence); String strInterned = String.IsInterned(str); if (strInterned == null) Console.WriteLine("{0}', is not interned.", str); else Console.WriteLine("{0}', is interned.", strInterned); } }
