[site]: stackoverflow
[post_id]: 4622828
[parent_id]: 4622410
[tags]: 
Method overloading is useless if your intent is solely parameter sequence, because IMHO, you're just encouraging boilerplate code (repeating identical code), and if the parameters are all of the same data type, you'll receive a compilation error because the method signatures are ambiguous. I do a lot of method overloading in APIs for convenience purposes when a parameter can exist as multiple data types: public class Client { public Status get(String request) { return get(new Request(request)); } public Status get(Request request) { // do stuff } } If you have a lot of parameters, and many of them are optional, I would suggest looking into the Builder pattern . The intent of the builder pattern is to create an immutable object constructed of optional parameters. For instance: public String get(String arg0, String arg1, String arg2) { // do stuff } public String get(String arg0, String arg1) { return method(arg0, arg1, null); } public String method(String arg0) { return method(arg0, null, null); } can probably be improved with a builder: class Request { final String arg0; final String arg1; final String arg2; private Request(Builder b) { this.arg0 = b.arg0; this.arg1 = b.arg1; this.arg2 = b.arg2; } // getter methods public static class Builder { String arg0, arg1, arg2; public Builder arg0(String arg) { this.arg0 = arg; return this; } public Builder arg1(String arg) { this.arg1 = arg; return this; } public Builder arg2(String arg) { this.arg2 = arg; return this; } public Request build() { return new Request(this); } } } class Client { public String get(Request request) { } } new Client().get(Request.Builder().arg0("arg0").arg1("arg1").arg2("arg2").build()); Another overload that I do a lot is when a method can accept parameters of varying data types: public String lookup(String variant) { return lookup(Integer.parseInt(variant)); } public String lookup(int ordinal) { // logic }
