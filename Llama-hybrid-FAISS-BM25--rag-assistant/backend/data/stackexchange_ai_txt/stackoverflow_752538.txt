[site]: stackoverflow
[post_id]: 752538
[parent_id]: 48094
[tags]: 
I don't know why this was answered so confusingly long. If you delete the array of pointers, you will free the memory used for an array of usually ints. a pointer to an object is an integer containing the adress. You deleted a bunch of adresses, but no objects. delete does not care about the content of a memory space, it calls a destructor(s) and marks the mem as free. It does not care that it just deleted a bunch of adresses of objects, it merely sees ints. That's why you have to cycle through the array first! and call delete on every element, then you can delete the storage of the array itself. Well, now my answer got somewhat long... .... strange... ;) Edit: Jason's answer is not wrong, it just fails to hit the spot. Neither the compiler nor anything else in c(++) cares about you deleting stuff that is elsewhere pointed to. You can just do it. Other program parts trying to use the deleted objects will segfault on you. But no one will hinder you. Neither will it be a problem to destroy an array of pointers to objects, when the objects are referenced elsewhere.
