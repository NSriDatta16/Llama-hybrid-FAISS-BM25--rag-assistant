[site]: stackoverflow
[post_id]: 4964971
[parent_id]: 4964687
[tags]: 
Updated So I couldn't help but play around a bit with this thing and see what other ways I could manipulate the document with as little code as possible. Suffice it to say that it can be shortened to work in an either/or scenario, but I like to make things with options for the user to play with. Having said that, here are some variations on the above and benefits/disappointments: Official Submission (473bytes) Minified (473bytes) 1 function t(e){var r=[],w;for(w=0;w 1?1:-1;}).join(''))+z[z.length-1];}return e;});} Un-minified version: (479bytes) 1 function t(e){ var r=[],w; for(w=0;w 1?1:-1; }).join(''))+x[x.length-1]; } return e; }); } No use of jQuery ("pure javascript") Add just above or wrap the code in an onload event. 1 re-placement of var declarations makes it shorter, see 479bytes vs 473 byes ) Additional Versions Basic ( demo ) // jQuery Garble // "Basic" version // // Requirements: // 1. Find all words 4+ letters long (exclude hyphens, punctuation or numbers from // the classification) // 2. The words being garbled must follow: // a. They can not remain the same as the previous state // b. The first and last character must remain in-tact // 3. The garbling must be random and produce a new result each iteration. // // Usage: // $(selector).garble(options); // (function($){ $.fn.extend({ garble: function(options){ // basic options var o = $.extend({ flagChanges: false, changeClass: 'modified' },options); // iterate over elements return this.each(function(i,e){ var txt = $(e).text(); // locate words with 4+ letters $(e).html(txt.replace(/\b[a-z]{4,}\b/ig,function(w){ var e = w; // make sure we get an altered word back while (e==w){ var x = w.split(''); e = x[0]+(x.slice(1,x.length-1).sort(function(y,z){ return (Math.random()*2)>1?1:-1; // randomize }).join(''))+x[x.length-1]; } return (o.flagChanges?' '+e+' ':e); })); }); } }); })(jQuery); Pros Very slim and trim Options that allow you to modify the modified word (wraps each change in a span with the default "modified" class, or a class of your choosing). Cons Won't work with nested elements (this means you have to select the lowest possible element in the DOM tree. So, if you're just going to be doing paragraphs with no hyperlinks or spans within, this is your winner) If elements that have children are used in the selector, their html formatting (such as a linkin a paragraph) will be stripped. Slim and Trim ( demo ) $(function(){ // on load $('*','body').contents().map(function(i,e){ // grab all elements, return e.nodeType !== 3 ? null : e; // then filter by textual elements }).each(function(i,e){ // amd iterate through them. e.data = e.data.replace(/\b[a-z]{4,}\b/ig, function(w) { // go through and find 4+ letters words if (w.length==4&&w.substring(1,2)==w.substring(2,3)) // (avoid infinite loops on words that return w; // can't be changed [e.g. look]) var e = w; // Store the original word for comparison, but while (e==w){ // keep scrambling until we have a new word. var x = w.split(''); // (do so by breaking out middle letters in to array, e = x[0] + (x.slice(1, x.length - 1).sort(function(a,b){ // then sort those middle letters return (Math.random() * 2) > 1 ? 1 : -1; // based on a random number) }).join('')) + x[x.length - 1]; // Now, rejoin it all back together } return e; // and finally return the modified result. }); }); }); Fully Featured ( demo ) // jQuery Garble // "Feature Rich" version // // Requirements: // 1. Find all words 4+ letters long (exclude hyphens, punctuation or numbers from // the classification) // 2. The words being garbled must follow: // a. They can not remain the same as the previous state // b. The first and last character must remain in-tact // 3. The garbling must be random and produce a new result each iteration. // // Usage: // $(selector).garble(options); // (function($) { $.fn.extend({ garble: function(options) { var o = $.extend({}, $.fn.garble.defaults, options); // takes in a string and performs the necessary manipulation(s) on it. Use regex // to only collect words greater than or equal to 4 characters long, and consider // punctuation not part of the word. var garbleStr = function(s,t){ return s.replace(/\b[a-z]{4,}\b/ig, function(w) { var e = o.algorithm(w); // if we're not performing a low-level parse and they want the changes styled, // return a span with either the detault class or their custom class if (t && !o.lowLevel && o.highLevel.flagChanges) return ' '+e+' '; // just return the new word return e; }); }; // Very high-level process. // Will only change the lowest node's text (so a paragraph // with links, only the links will be altered) var highLevel = function(i, e) { // we're not at the bottom element, keep going if ($(e).children().length>0){ return $(e).children().each(highLevel); } var t = $(e).text(); $(e).html(garbleStr(t,e.tagName!=='TEXTAREA')); }; // Low level process // Goes down to each individual element and changes it var lowLevel = function(i, e) { var d = e.data; e.data = garbleStr(d); }; // depending their selection, execute either or if (o.lowLevel){ return this.find('*').contents().map(function(i, e) { return (e.nodeType !== 3 ? null : e); }).each(lowLevel); }else{ return this.contents().each(highLevel); } }, }); // Defaults $.fn.garble.defaults = { // Perform low-level modification? (Modifies all words it finds, // not just the one farthests down the tree) lowLevel: false, // when lowLevel is set to false, these options are available: highLevel: { // wrap changes in a flagChanges: false, // the class being applied to the above changeClass: 'modified' }, // function used to garble the text. This will be passed each word // individually and should return the new word's value. algorithm: function(w) { // if w = "hello": // 1. Make an array out of the letters. // 2. keep the first and last in-tact, but use .slice() to extract the middle // 3. Perform the specified algorithm on the middle characters // 4. return result var e = w; while (e==w){ // secure it gets changed var x = w.split(''); e = x[0] + (x.slice(1, x.length - 1).sort(function(a,b){ return (Math.random() * 2) > 1 ? 1 : -1; }).join('')) + x[x.length - 1]; } return e; } }; })(jQuery); Pros Flexible. This will work in just about every scenario, albeit a quick-to process bottom-of-the-food-chain element or calling it on the entire --this can handle it. Very customizable: Can specify to perform low level (every element) changes, or highLevel (only elements with no children) Can specify if you want to show the changes, and what class to apply (changes are wrapped in a span with the specified class name) Can specify a function to use for scrambling (maybe you want to just reverse the words or use a better method) Cons Little more overhead, though it is still fast. Maybe too many options or just too bloated. I'm sure someone will find more cons
