[site]: crossvalidated
[post_id]: 183877
[parent_id]: 183854
[tags]: 
First of all let us state that you are trying to fit the model which is not that common. Since $y_t\in \mathbb{R}^n$ you can always estimate $n$ independent AR models. So your model implies that all these $n$ AR models must have the same coefficients. That is a powerful restriction and you need to be sure, that the process you are trying to model satisfies this restriction. Having said that, if you are sure that the restriction is feasible, the model is a linear model, so you can use OLS to fit it. Naturally R function ar is not suitable for this model, because as I said such model is not that common, so nobody thought that it is worth implementing. The model order can be chosen in the same way VAR model order is chosen, i.e. using information criteria. If you fit the model via OLS, you can use AIC and BIC with no problems. Just remember that you need to compare AIC and BIC for models which are fitted on the same sample . For VAR models this means dropping the first $k$ observations, where $k$ is the number of highest lag number you are trying to estimate. For elegant way of fitting (for my understanding of elegant), I recommend using dplyr and tidyr packages to manipulate your data and then fit using lm . Suppose your data is a matrix, where data for time periods are in columns: set.seed(100) Y Y[1:5, 1:2] 1 2 [1,] -0.50219235 0.08988614 [2,] 0.13153117 0.09627446 [3,] -0.07891709 -0.20163395 [4,] 0.88678481 0.73984050 [5,] 0.11697127 0.12337950 Your data is in a wide format and I suggest it to convert to long format: library(dplyr) library(tidyr) dY % data.frame(check.names = FALSE) %>% mutate(id = 1:10) %>% gather("time",Y,-id, convert = TRUE) > dY[1:10,] id time Y 1 1 1 -0.50219235 2 2 1 0.13153117 3 3 1 -0.07891709 4 4 1 0.88678481 5 5 1 0.11697127 6 6 1 0.31863009 7 7 1 -0.58179068 8 8 1 0.71453271 9 9 1 -0.82525943 10 10 1 -0.35986213 In this format you have two additional columns which record the time period and to which element of the vector the value corresponds to. Having such format it is easy to add lagged values of $y$: dY % group_by(id) %>% mutate(Y.l1 = lag(Y,1), Y.l2 = lag(Y, 2), Y.l3 = lag(Y,3)) To fit the model use lm : lm(Y~Y.l1,data= dY) Call: lm(formula = Y ~ Y.l1, data = dY) Coefficients: (Intercept) Y.l1 0.01749 -0.01624 To choose the order, you need to fit the model for all orders: ar1 % filter(time > 3)) ar2 % filter(time > 3)) ar3 % filter(time > 3)) Put them all in the list for easier manipulation: mods Check that the sample size is the same for all models, before calculating AIC/BIC: > mods %>% sapply(function(x)nrow(x$model)) [1] 970 970 970 Calculate AIC: > mods %>% sapply(AIC) [1] 2832.232 2832.308 2832.659 Calculate BIC: > mods %>% sapply(BIC) [1] 2846.864 2851.817 2857.045
