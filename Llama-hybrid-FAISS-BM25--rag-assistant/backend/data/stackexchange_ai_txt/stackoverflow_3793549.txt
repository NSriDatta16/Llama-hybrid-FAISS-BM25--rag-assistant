[site]: stackoverflow
[post_id]: 3793549
[parent_id]: 3793542
[tags]: 
Yes, that's how lock is designed to work. The lock keyword marks a statement block as a critical section by obtaining the mutual-exclusion lock for a given object, executing a statement, and then releasing the lock. Mutual-exclusion means that there can be at most one thread that holds the lock at any time. Locking on this is a bad idea and is discouraged. You should create a private object and lock on that instead. To solve your problem you could lock on two different objects. private object lockObject1 = new object(); private object lockObject2 = new object(); public void foo() { lock (lockObject1) { // ... } } public void bar() { lock (lockObject2) { // ... } } Alternatively you could reuse the same lock but move it inside the loop so that each loop has a chance to proceed: while (stopThreads == false) { foreach (var acc in myList) { lock (lockObject) { // process some stuff } } } However I would suggest that you spend some time to understand what is going on rather than reordering the lines of code until it appears to work on your machine. Writing correct multithreaded code is difficult. For stopping a thread I would recommend this article: Shutting Down Worker Threads Gracefully
