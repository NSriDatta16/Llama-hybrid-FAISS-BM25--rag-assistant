[site]: stackoverflow
[post_id]: 1998273
[parent_id]: 1998258
[tags]: 
My solutions relies on three things: First: it's possible to override the model's put() method. Second: users.get_current_user() still provides the correct user, and Third: ragendja.auth.google_models.User.get_djangouser_for_user() takes a google.appengine.api.users.user object and returns the corresponding Django User object - creating it first if it didn't already exist. Putting this all together, I have: class Request(db.Model): requestor = db.ReferenceProperty(User) def put(self): if not self.requestor: self.requestor = User.get_djangouser_for_user(users.get_current_user()) super(Request, self).put() This works nicely with the admin interface: the admin can assign any existing user (or use the supplied + sign to create a new user) - if they leave it blank, they'll be assigned as the requestor. Later when I add a view for users to manage their own requests, this value will be on the 'excluded' list, and the same method will add in their username every time they create a new request. I'm not sure if this is an optimal solution though; I'm new to Django, so maybe there's a better way to achieve this.
