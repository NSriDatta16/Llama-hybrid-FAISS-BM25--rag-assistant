[site]: datascience
[post_id]: 96985
[parent_id]: 96611
[tags]: 
Breaking down a number of questions, firstly I want to forecast 3 months into the future. You need at least 3+ months worth of data to do this task. That means, your "forecast horizon" needs to be a subset of your data set in which you can define how far ahead you want to be making predictions. See for example the image below: the Decoder should be taking the previous time-steps production levels as input (meaning dimension 1), as well as the previous hidden and cell state. I think you are mixing up attention pooling architecture with self-attention/transformer architecture concepts. In typical encoder/decoder rnn, the decoder needs to consume the hidden state output from each LSTM cell/timestep. Unless you are trying a more experimental output, the cell state as well as the input data should not be passed to the decoder. If you are using Luong/additive attention pooling, again only the hidden state is needed for its calculation. I am not sure your attention method is entirely correct. I paste below an example of hoe your decoder with additive attention should look like: class AttnDecoderRNN(nn.Module): """ Courtesy of https://pytorch.org/tutorials/intermediate/seq2seq_translation_tutorial.html """ def __init__(self, hidden_size, output_size, dropout_p=0.1, max_length=MAX_LENGTH): super(AttnDecoderRNN, self).__init__() self.hidden_size = hidden_size self.output_size = output_size self.dropout_p = dropout_p self.max_length = max_length self.attn = nn.Linear(self.hidden_size * 2, self.max_length) self.attn_combine = nn.Linear(self.hidden_size * 2, self.hidden_size) self.dropout = nn.Dropout(self.dropout_p) self.gru = nn.GRU(self.hidden_size, self.hidden_size) self.out = nn.Linear(self.hidden_size, self.output_size) def forward(self, input, hidden, encoder_outputs): # Here is the attention pooling calculation attn_weights = F.softmax( self.attn(torch.cat((embedded[0], hidden[0]), 1)), dim=1) attn_applied = torch.bmm(attn_weights.unsqueeze(0), encoder_outputs.unsqueeze(0)) output = torch.cat((embedded[0], attn_applied[0]), 1) output = self.attn_combine(output).unsqueeze(0) output = F.relu(output) output, hidden = self.gru(output, hidden) output = F.log_softmax(self.out(output[0]), dim=1) return output, hidden, attn_weights def initHidden(self): return torch.zeros(1, 1, self.hidden_size, device=device) Rightfully so, you claim that input and hidden state needs to be passed to the decoder and I presume you refer to a self-attention architecture. For this model, there are no decoder/decoder units but rather each input is abstracted into a query, key and value latent spaces, as in the following diagram: You can read more about the self-attention architecture here https://towardsdatascience.com/self-attention-5b95ea164f61 , before you decide how you want to proceed attacking your problem.
