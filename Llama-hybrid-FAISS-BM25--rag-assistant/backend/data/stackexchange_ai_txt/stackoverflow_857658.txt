[site]: stackoverflow
[post_id]: 857658
[parent_id]: 857593
[tags]: 
The code generation is somewhat confusing but can be done for simple cases: compiling: public static void Main(string[] args) { Console.WriteLine("", // ignore this argument "Should create array of ", typeof(int), " with specified size." "x"); } (adding "x" to force it to use a params overload) gives .method public hidebysig static void Main(string[] args) cil managed { .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() .maxstack 4 .locals init ( [0] object[] objArray) L_0000: ldstr "" L_0005: ldc.i4.4 L_0006: newarr object L_000b: stloc.0 L_000c: ldloc.0 L_000d: ldc.i4.0 L_000e: ldstr "Should create array of " L_0013: stelem.ref L_0014: ldloc.0 L_0015: ldc.i4.1 L_0016: ldtoken int32 L_001b: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle( valuetype [mscorlib]System.RuntimeTypeHandle) L_0020: stelem.ref L_0021: ldloc.0 L_0022: ldc.i4.2 L_0023: ldstr " with specified size." L_0028: stelem.ref L_0029: ldloc.0 L_002a: ldc.i4.3 L_002b: ldstr "x" L_0030: stelem.ref L_0031: ldloc.0 L_0032: call void [mscorlib]System.Console::WriteLine(string, object[]) L_0037: ret } So you have to do is parse the il to detect the arguments being pushed into the compiler generated array. a heristic that is fragile but might be sufficient it to say: find call to 'my method'. find nearest previous newarr object take all ldstr and ldtoken in between these and assume they are the arguments. This is rough but may be sufficient for your needs. An AOP style approach will get you what you want at runtime by simply instrumenting every call to dump the values but at sompile time the approach above is your only realistic option given only the IL. The code generated may be very different in Release builds, You will be unable to spot the auto generated array verses someone explicitly creating it themselves (which may be further away from the call site or even in a different method/constructor/class. Proviso I should note after your edit for why you want to do this that Attribute based annotations are a far better solution, I cannot see why you would want to do this in the method when you can attribute it directly...
