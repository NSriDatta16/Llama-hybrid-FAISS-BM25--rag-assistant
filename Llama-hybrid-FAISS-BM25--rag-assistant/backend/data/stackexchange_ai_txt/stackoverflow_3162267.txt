[site]: stackoverflow
[post_id]: 3162267
[parent_id]: 3153390
[tags]: 
Your alpha blend function is correct; another way to think of alpha blending is that it interpolates between two color values based on alpha, so it should be a value in [0, 1]. However, you shouldn't be passing the color components as char , which is signed by default. You should pass them either as unsigned char or as a wider integer type. What is happening is that instead of passing in 255 as you expect, you are passing in -1 . In other words, store your color components as unsigned char s to ensure you don't have signedness shenanigans (see EDIT2). EDIT: Note that if your alpha is in [0, 255], you should normalize it to [0, 1] to perform the alpha blending operation. EDIT2: Also, if you are storing your pixels as char instead of unsigned char , this would explain the odd clamping I saw: alpha_transparency(0.9, (char)255, (char)255) == alpha_transparency(0.9f, -1.0f, -1.0f) == -1.0f == 0xff (cast to char) alpha_transparency(0.9, (char)128, (char)255) == alpha_transparency(0.9f, -128.0f, -1.0f) == -13.7f == 0xf3 alpha_transparency(0.9, (char)127, (char)255) == alpha_transparency(0.9f, 127.0f, -1.0f) == -11.80f == 0x0b alpha_transparency(0.9, (char)0, (char)255) == alpha_transparency(0.9f, 0.0f, -1.0f) == -0.9f == 0x00
