[site]: stackoverflow
[post_id]: 3668316
[parent_id]: 3667650
[tags]: 
Yes, that shouldn't be a problem. There are very few native C++ constructs that cannot be translated to IL. Varargs used to be a problem but that was solved, I'm only aware of __fastcall as untranslatable. Won't be a problem, Boost won't use it. The only other problem I'm aware of is having a lot of global variables. They need to be embedded in a CLR class and a class cannot have more than 65535 fields. You'll get an exception when the CLR loader tries to load the assembly. You'd need some pretty, erm, special code to get close to that limitation. A secondary consideration is whether it actually makes sense to do so. The point of using native code in the first place is to take advantage of the time that the code optimizer can spend on optimizing it. You are throwing that away by getting the code translated to IL, the JIT optimizer doesn't have the same luxury. Leverage C++ Interop, it can translate from managed value types to native types without you having to write any glue code. Just turn off IL generation on the fly. Like this: #pragma managed(push, off) // Native code goes here //... #pragma managed(pop) // Managed code goes here
