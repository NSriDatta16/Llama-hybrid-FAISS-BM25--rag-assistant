[site]: stackoverflow
[post_id]: 446601
[parent_id]: 446502
[tags]: 
First, you are doing pretty well on keeping things separated. It pays back in the future, so don't give up. The database layout (or even database itself) is irrelevant to the essence of MVC. It happens to be relational database in most cases, however MVC does not require it explicitly (you can use XML storage or some grid/cloud as well). What is crucial to the MVC is to keep Model separated from the rest, which you did. Your View is also clearly separated from the rest. Similarly to M part of MVC, Views can not only present HTML, but any text-representable output (XML, XML+XSL, RSS, plain text, or even email messages), Views can be implemented in several ways: PHP includes like yours, templates (i.e. Smarty) or fully fledged objects serializable to text. I'm far from judging which strategy is the best, it's a matter of individual coding style and project requirements. Your controller is confusing (it is more Page Controller than Application Controller). It is probably due to the fact, that there's one hidden part in MVC architecture. It is called Front Controller or Dispatcher . It is up to Dispatcher to parse input, instantiate controller (as in Application Controller) and invoke requested method. If you want to keep going with your custom MVC implementation I suggest you using some common way of passing Controller class and method name in URL, i.e. index.php/Movies/list index.php/Movies/details/35 Then in new index.php you just parse $_SERVER['PATH_INFO'], instantiate class Movies and call its list method, i.e. $args = explode('/', ltrim($_SERVER['PATH_INFO'], '/')); $className = array_shift($args); $method = array_shift($args); require "$className.php"; call_user_func_array(array(new $className(), $method), $args); Then you just move the content of if-else block to two separate methods in Movies class. class Movies { // may extend generic Controller class if you wish public function list() { $movies = Movie::get_all(); include 'views/v_list.php'; } public function details($movieId) { $movie = new Movie($movieId); if ($movie->id > 0) { include 'views/v_movie.php'; } else { echo "Movie Not Found"; } } This way you can have multiple controllers, each with multiple actions. Final remarks. On database side it would be handy to use one of existing ORM frameworks. They will save you days of work and will probably perform better than hand-crafted db tier. I would also suggest handling instantiation of PDO instance as instantiating PDO in every Model object is not the cleanest way. Something like DBFactory::getConnection would do. You may consider returning HTML rather than echoing it out in controller. This gives you grat flexibility if you want to implement Intercepting Filters that would wrap controller, intercept its output and pre- or post-process it. It is super handy to have a filter that attaches HTML header and footer automatically. Creating custom framework is great fun and valuable educational experience, however I would suggest using one of existing frameworks for more serious tasks. All the best.
