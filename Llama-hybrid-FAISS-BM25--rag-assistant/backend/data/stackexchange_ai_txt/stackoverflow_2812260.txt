[site]: stackoverflow
[post_id]: 2812260
[parent_id]: 2809309
[tags]: 
After reading the above answers, I decided that Pete's answer with two versions of operator[] was the best way forward. To handle the morphing between types at run-time I created a new array template class that took four parameters as follows; template class CMorphArray { int GetSize() { return m_BaseData.GetSize(); } BOOL IsEmpty() { return m_BaseData.IsEmpty(); } // Accessing elements const TYPE& GetAt(int nIndex) const; TYPE& GetAt(int nIndex); void SetAt(int nIndex, ARG_TYPE newElement); const TYPE& ElementAt(int nIndex) const; TYPE& ElementAt(int nIndex); // Potentially growing the array int Add(ARG_TYPE newElement); // overloaded operator helpers const TYPE& operator[](int nIndex) const; TYPE& operator[](int nIndex); CBigArray m_BaseData; private: CBigArray m_RefCache; CBigArray m_RefIndex; CBigArray m_CacheIndex; virtual void Convert(BASE_TYPE,ARG_TYPE) = 0; virtual void Convert(TYPE,BASE_ARG_TYPE) = 0; void InitCache(); TYPE& GetCachedElement(int nIndex); }; The main data storage is in m_BaseData which is the data in its native format, which can vary in type as discussed. m_RefCache is secondary array to cache of elements in the expected format, and the GetCachedElement function uses the virtual Convert functions to translate the data as it is moved in and out of the cache. The cache needs to be at least as big as the number of simultaneous references that can be active at any one time, but in my case will probably benefit from being bigger as it reduces the number of conversions required. While Alsk's cursor implementation probably would have worked well, the solution given requires fewer object copies and temporary variables, and ought to afford slightly better performance which is important in this case. Apologies to all you STL fans for the older MFC look and feel; the rest of the project is MFC so it makes more sense in this case. The CBigArray was the result of a related stack overflow question that became the basis of my large array handling. I hope to finish the implementation today and test tomorrow. If it all goes belly up on me, I'll edit this post accoringly.
