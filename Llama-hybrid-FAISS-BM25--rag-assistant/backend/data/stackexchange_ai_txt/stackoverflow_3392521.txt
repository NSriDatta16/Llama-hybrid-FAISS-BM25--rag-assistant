[site]: stackoverflow
[post_id]: 3392521
[parent_id]: 
[tags]: 
What is your solution to the "Escape from Zurg" puzzle in C#?

found this puzzle HERE ... I made a brute force solution and I would like to know how you woul solve it... Buzz, Woody, Rex, and Hamm have to escape from Zurg(a) They merely have to cross one last bridge before they are free. However, the bridge is fragile and can hold at most two of them at the same time. Moreover, to cross the bridge a flashlight is needed to avoid traps and broken parts. The problem is that our friends have only one flashlight with one battery that lasts for only 60 minutes (this is not a typo: sixty). The toys need different times to cross the bridge (in either direction): TOY TIME Buzz 5 minutes Woody 10 minutes Rex 20 minutes Hamm 25 minutes Since there can be only two toys on the bridge at the same time, they cannot cross the bridge all at once. Since they need the flashlight to cross the bridge, whenever two have crossed the bridge, somebody has to go back and bring the flashlight to those toys on the other side that still have to cross the bridge. The problem now is: In which order can the four toys cross the bridge in time (that is, in 60 minutes) to be saved from Zurg? //(a) These are characters from the animation movie “Toy Story 2”. here is my solution: public Form1() { InitializeComponent(); List toys = new List (){ new toy { name = "buzz", time = 5 } , new toy { name = "woody", time = 10 } , new toy { name = "rex", time = 20 } , new toy { name = "ham", time = 25 } , }; var posibles = Combinaciones(toys, 4).ToList(); //all permutations List > solutions = new List >(); foreach (var pointA in posibles) { string order = ""; int flashlight = 60; List pointB = new List (); do { var fastestInA = pointA.Take(2).ToList(); flashlight -= fastestInA.Max(t => t.time); order += "go " + String.Join(",", fastestInA.Select(t => t.name)) + "\n"; fastestInA.ForEach(t => pointA.Remove(t)); pointB.AddRange(fastestInA); if (pointB.Count t.time); order += "return " + String.Join(",", fastestInB.Select(t => t.name).ToArray()) + "\n"; fastestInB.ForEach(t => pointB.Remove(t)); pointA.AddRange(fastestInB); } } while (pointB.Count != 4); solutions.Add(new Tuple (order, flashlight)); } var optimal = solutions.Where(s => s.Item2 == solutions.Max(t => t.Item2)).ToList(); optimal.ForEach(s => Console.Write("Order:\n" + s.Item1 + "TimeLeft:" + s.Item2 + "\n\n")); } public class toy { public int time { get; set; } public string name { get; set; } } // this is to do permutations public static List > Combinaciones(List list, int take) { List > combs = new List >(); foreach (var item in list) { var newlist = list.Where(i => !i.Equals(item)).ToList(); var returnlist = take > { new List () } : Combinaciones(newlist, take - 1); foreach (var l in returnlist) { l.Add(item); } combs.AddRange(returnlist); } return combs.ToList(); } }
