[site]: stackoverflow
[post_id]: 4779707
[parent_id]: 4763307
[tags]: 
"can I somehow create an objective-C object which - in it's constructor - takes a c++ function pointer as an argument which it calls later?" Yes, but its rather ugly. First, define a callback baseclass, and a templated version. This can go into a generic .h file that can be #includ ed from .cpp and .mm files. Also define a basic CThread class: // Thread.h #pragma once #include // for a cpp compatible definition of id class Callback{ public: virtual void operator()(void)=0; }; template class ClassCallback : public Callback { T* _classPtr; typedef void(T::*fncb)(void); fncb _cbProc; public: ClassCallback(T* classPtr,fncb cbProc):_classPtr(classPtr),_cbProc(cbProc){} virtual void operator()(void){ (_classPtr->*_cbProc)(); } }; class CThread { id _thread; public: void Start(Callback* cb); }; Next, put the implementation of CThread , and its obj-c buddy object, in a .mm file: // Thread.mm #import #import "Thread.h" @interface ThreadStarter:NSObject { Callback *theCallback; } -(void)Run; -(id)init:(Callback*)cb; @end @implementation ThreadStarter -(id)init:(Callback*)cb { theCallback = cb; return [super init]; } -(void)Run { theCallback(); } @end void CThread::Start(Callback* cb){ _thread = [[ThreadStarter alloc] init:cb]; [NSThread detachNewThreadSelector:@selector(Run) toTarget:_thread withObject:nil]; } }; And then, in your application's cpp file, you can: // MyClass.cpp (doesn't even have to be .mm) #include "Thread.h" class MyClass { CThread _myThread; void SomeArbMethod(){ } public: MyClass(){ _myThread.Start( new ClassCallback (this,&MyClass::SomeArbMethod)); } };
