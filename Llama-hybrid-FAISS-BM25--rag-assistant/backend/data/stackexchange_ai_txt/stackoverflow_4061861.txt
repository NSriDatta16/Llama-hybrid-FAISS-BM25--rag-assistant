[site]: stackoverflow
[post_id]: 4061861
[parent_id]: 4061818
[tags]: 
Edit: Now that you've provided more information, perhaps we can shed some light on this confusing behavior. You've violated the One Definition Rule . The results of doing this aren't really defined, but we can make some educated guesses based on your observed results. Template functions are always declared inline, as this is required for template parameter substitution. When the compiler encounters one of these functions, it has the choice of emitting it as inline code or creating a function body and calling it. If it creates a function body the linker becomes responsible for eliminating duplicate definitions in different translation units. The linker doesn't do much checking to see if the apparent duplicates are functionally equivalent, it just goes by the decorated name of the function, which depends on the types of the arguments; if the types all have the same names, they're assumed to be identical. It can make this assumption because of the One Definition Rule. This is how you can have a class definition that isn't included in your source affect the outcome of your code - the linker is substituting a bad copy of the code for a good one. If the compiler generates inline code you'll get the outcome you expect, if the linker gets involved you have a 50/50 chance of getting the wrong thing. And even if your code gets lucky, some other piece of code is now whacked. Original answer: It is possible for a vector to be bigger than the requested size, but size won't reflect that value; you can test for this using capacity . The excess storage will be part of the memory usage but the elements won't be initialized, and any attempt to access beyond the result of size will result in undefined behavior.
