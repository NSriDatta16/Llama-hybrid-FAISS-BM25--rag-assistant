[site]: stackoverflow
[post_id]: 1638875
[parent_id]: 1638288
[tags]: 
I have seen lots of solutions to this basic conundrum: polymorphism + variation in interfaces. One basic approach is to provide a way to query for extended interfaces - so you have something along the lines of COM programming under Windows: const unsigned IType_IShape = 1; class IShape { public: virtual ~IShape() {} // ensure all subclasses are destroyed polymorphically! virtual bool isa(unsigned type) const { return type == IType_IShape; } virtual void Draw() = 0; virtual void Erase() = 0; virtual void GetBounds(std::pair & bounds) const = 0; }; const unsigned IType_ISegmentedShape = 2; class ISegmentedShape : public IShape { public: virtual bool isa(unsigned type) const { return type == IType_ISegmentedShape || IShape::isa(type); } virtual void AddSegment(const Point & a, const Point & b) = 0; virtual unsigned GetSegmentCount() const = 0; }; class Line : public IShape { public: Line(std::pair extent) : extent(extent) { } virtual void Draw(); virtual void Erase(); virtual void GetBounds(std::pair & bounds); private: std::pair extent; }; class Polygon : public ISegmentedShape { public: virtual void Draw(); virtual void Erase(); virtual void GetBounds(std::pair & bounds); virtual void AddSegment(const Point & a, const Point & b); virtual unsigned GetSegmentCount() const { return vertices.size(); } private: std::vector vertices; }; Another option would be to make a single richer base interface class - which has all the interfaces you need, and then to simply define a default, no-op implementation for those in the base class, which returns false or throws to indicate that it isn't supported by the subclass in question (else the subclass would have provided a functional implementation for this member function). class Shape { public: struct Unsupported { Unsupported(const std::string & operation) : bad_op(operation) {} const std::string & AsString() const { return bad_op; } std::string bad_op; }; virtual ~Shape() {} // ensure all subclasses are destroyed polymorphically! virtual void Draw() = 0; virtual void Erase() = 0; virtual void GetBounds(std::pair & bounds) const = 0; virtual void AddSegment(const Point & a, const Point & b) { throw Unsupported("AddSegment"); } virtual unsigned GetSegmentCount() const { throw Unsupported("GetSegmentCount"); } }; I hope that this helps you to see some possibilities. Smalltalk had the wonderful attribute of being able to ask the meta-type-system whether a given instance supported a particular method - and it supported having a class-handler that could execute anytime a given instance was told to perform an operation it didn't support - along with what operation that was, so you could forward it as a proxy, or you could throw a different error, or simply quietly ignore that operation as a no-op). Objective-C supports all of those same modalities as Smalltalk! Very, very cool things can be accomplished by having access to the type-system at runtime. I assume that .NET can pull of some crazy cool stuff along those lines (though I doubt that its nearly as elegant as Smalltalk or Objective-C, from what I've seen). Anyway, ... good luck :)
