[site]: stackoverflow
[post_id]: 1409260
[parent_id]: 
[tags]: 
WPF data-binding with multiple dependencies?

I believe this code may require more effort to comprehend than average, so I'm using contextual code-comments to explain my predicament in an effort to make it a little easier to understand my question. public class MyControl : System.Windows.FrameworkElement { public double Property1 { get; set; } public double Property2 { get; set; } } ... ... static readonly MyPrimaryConverter PrimConv = new MyPrimaryConverter(); static readonly MySecondaryConverter SecConv = new MySecondaryConverter(); public Window1() { InitializeComponent(); System.Windows.Data.BindingExpressionBase BindExp1, BindExp2; System.Windows.Data.Binding MyBinding; MyBinding = new System.Windows.Data.Binding("Property1"); MyBinding.Source = ControlA; MyBinding.Mode = System.Windows.Data.BindingMode.OneWay; MyBinding.Converter = PrimConv; MyBinding.ConverterParameter = ControlB; BindExp1 = ControlA.SetBinding( System.Windows.UIElement.MinWidthProperty, MyBinding); //Binds correctly and shows "Status" as active MyBinding = new System.Windows.Data.Binding("Property2"); MyBinding.Source = ControlB; // ControlB.Property2 is the source value now MyBinding.Mode = System.Windows.Data.BindingMode.OneWay; MyBinding.Converter = SecConv; //Uses the secondary converter MyBinding.ConverterParameter = ControlA; //ControlA is the parameter now BindExp2 = ControlA.SetBinding( System.Windows.UIElement.MinWidthProperty, MyBinding); /* Also binds correctly and shows "Status" as active, but causes BindExp1 to show "Status" as "Detached" ****THIS IS THE PROBLEM I NEED HELP WITH**** How can I successfully bind ControlA.MinWidth to BOTH of the values that are used to calculate MinWidth? This is required so that MinWidth will be recalculated if EITHER value changes at any time Bonus points if you can show how to do it with only one converter class instead of two */ } ... [System.Windows.Data.ValueConversion(typeof(double), typeof(double))] public class MyPrimaryConverter : System.Windows.Data.IValueConverter { public object Convert( object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { if ((value is double) && (parameter is MyControl)) return ((double)value) * (parameter as MyControl).Property2; /* This converter ALWAYS returns: ControlA.Property1 * ControlB.Property2 value == ControlA.Property1 and parameter == ControlB, so we return value * parameter.Property2 */ return System.Windows.DependencyProperty.UnsetValue; } public object ConvertBack( object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { return System.Windows.DependencyProperty.UnsetValue; } } [System.Windows.Data.ValueConversion(typeof(double), typeof(double))] public class MySecondaryConverter : System.Windows.Data.IValueConverter { public object Convert( object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { if ((value is double) && (parameter is MyControl)) return ((double)value) * (parameter as MyControl).Property1; /* This converter also ALWAYS returns: ControlA.Property1 * ControlB.Property2 "value" and "parameter" are swapped: value == ControlB.Property2 and parameter == ControlA so we return value * parameter.Property1 instead of value * parameter.Property2 */ return System.Windows.DependencyProperty.UnsetValue; } public object ConvertBack( object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { return System.Windows.DependencyProperty.UnsetValue; } }
