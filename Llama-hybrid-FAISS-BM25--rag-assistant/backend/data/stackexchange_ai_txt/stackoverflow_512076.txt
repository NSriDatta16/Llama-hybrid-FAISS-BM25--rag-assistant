[site]: stackoverflow
[post_id]: 512076
[parent_id]: 512063
[tags]: 
All of this is copied directly from kdubois.net . Go upvote that website. /home — This is where all the directories and files containing information specific to one user reside. Each user of the system should be granted a directory within /home that matches the name of that user. Contained within each user’s profile is usually all the files you deal with on a regular basis, your documents, media, and settings are all best placed within your /home/$USERNAME directory. /etc — This is where the system typically stores system configuration files. The settings for networking, the graphical X server, as well as many other system functions reside in this folder. Take a peek inside. Your graphical X server keeps all its configuration within the X11/ directory. The file mtab stores cron settings. If you’re on a Debian system, the files to configure apt are withing the apt/ directory. There are tons of other system settings in this folder, so try to learn about them if you can. Be careful when messing with anything in the /etc directory! /boot — This folder contains what is needed to boot up the computer. Minimally it contains a bootloader like GRUB or LILO (the menu that pops up at boot and allows you to select the OS) and an image of the kernel. Oftentimes, initial ramdisks are also included here also. I’m more accustomed to GRUB, so I’ll go into a little depth of how a /boot directory using grub would work. Upon boot, the system looks into /boot/grub/menu.lst to try to determine how to boot up whaever system you want for this session. In menu.lst, there are specifications for what kernel boot image should be used, as well as what initial ramdisk should be used. GRUB then takes what its been told about the system and jump starts the kernel into booting. Unless you’re messing with boot options, you probably won’t deal with /boot too often, but its a critical part of a Linux system, which is always good to have knowledge about. /bin — This contains system wide, basic binary executables. Basic tools for things like decompressing files or navigating directories are contained here. For instance, ‘cd’ , ‘ls’, ‘ip’, ‘cat’ and other programs that are universal basic linux standards are contained here. /mnt and /media — Depending on what system you use, these two folders are where you will mount filesystems other than the / filesystem. Looking at Ubuntu ( the distro I usually blog from on my laptop), whenever you plug a USB memory stick, CD, or a new hard drive, it is mounted under /media directory. /dev — This contains all the device nodes of the system. Any hardware detected by the kernel is placed here as and entry. In modern Linux systems, this folder is managed largely by Udev, which helps with the automatic configuration and population of this directory. Forcibly removing anything in this directory is highly ill advised. :-D. This folder is pretty useful in telling if a driver you just compiled is working, and for seeing what your system sees as its hardware. For instance, hd1,hd2, etc. are PATA hard drives, sd1, sd2, etc. are SCSI drives, ram is the system ram, and video0 is usually some sort of TV tuner. Strictly speaking, every item in /dev is not a physical component of the system, but most are. Each device is treated like a file. This notion is familiar to veteran open source guys, but an odd concept to new converts from windows. This removes a huge level of abstraction and makes writing to your graphics card the same as writing your term paper. The kernel handles the actual steps necessary for making the device process the data like it should. Neat little tricks arise from this. For instance, I can cat /dev/video0 (my Hauppauge TV tuner) and record a TV show with a single command. (cat /dev/video0 > show.mpg). Respect the dev directory! :-D /lost+found — When an EXT filesystem has trouble, any files that are orphaned or in trouble are placed here. Hopefully you’ll never have to think about this folder. :-) /sbin — A concatenation of “system binaries” , this folder typically contains higher level system utilities, like ifconfig for network configuration. The boundary between what goes in /bin and /sbin have always been a little vague to me, but sbin utilities always seem like they perform more advanced functions, like dhclient for obtaining DHCP IP addresses, or mkfs for formatting a disk. /root — this is the superuser’s (the root user’s) home folder. Simple as that. /tmp — As you could guess, this folder holds temporary files. If Mozilla Firefox needs to cache your current download, it could store the partial file in /tmp until it finishes downloading and then copy it out of /tmp to your chosen download location. Good programs will clean up /tmp themselves when they’re done using it, but its contents are automatically deleted upon reboot, so don’t worry about this folder ballooning over time until its causing performance issues. /lib — This contains all the system libraries. Look inside and you’ll find a bunch of .so files. These are libraries needed by other programs to run. If you’re curious about this, type “ldd /bin/echo” (echo is a simple utility for outputting text). Your system will return what libraries echo is linked to, namely, ld-linux.so.2 and libc.so.6 and linux-gate.so.1. ldd works with any program. Modifying the names of your system libraries will break your system. Programs won’t know where to look when they need to access critical components located in libraries. Pretty much everything links against libc.so.6 and ld-linux.so.2, so renaming this is a sure way to bust your system. You won’t have to worry too heavily about system libraries, as package managers doing a good job about keeping everything in order. Compiling code, or helping to develop linux, however, you might run into problems here or there with libraries though, so watch out! /srv — A lot of times, this folder is used on web servers to contain information that can be accessed via the internet. /proc — This is a mission critical folder that you probably shouldn’t screw with. The kernel uses this to organize processes’s (running programs, more or less) information. /opt — Optional. A lot of times, system administrators will use this folder to install programs that you want to be easily deleted by hand. For instance, on my gnome based system here, I installed KDE’s libraries to /opt so that I can simply easily delete the entire folder. When compiling software, the default installation will scatter libraries, binaries and configuration files across the directory, so by telling the installer to put everything in /opt, you can still install the program, but you can leave it in a place that you can delete everything at once. /var — This folder contains important files that contain system state information. For instance, the error log for your graphical server is contained in this folder /usr — Probably my favorite folder in /. Normally, programs that are oriented more towards the user and less towards getting the system to operate are installed into /usr. GNOME or KDE are usually installed in this folder, and you will find many of the programs you fire up in daily usage (like Firefox, or Evolution, or Gedit) located here. Descend into /usr and you will find a bunch of folders much like you see in /. The reason for this is that the programs can be installed to a root-like set of folders (like the installer is expecting) without actually muddling up the / directory with a plethora of files. The system’s linker knows to look in both /lib and /usr/lib so any libraries installed into /usr/lib are found just as easily as those in /lib. Likewise, the binaries in /usr/bin are found as easily as /bin because the system knows to look in both paths. The /usr/local contains yet another root like directory! This is for the same reason as the root like folder in /usr, but is intended for the system administrator to install more permanent programs (usually ones he compiled personally) into. The reasons for doing all this might seem a bit vague or arbitrary but are actually incredibly useful if you get down to trying to organize a system or develop new software.
