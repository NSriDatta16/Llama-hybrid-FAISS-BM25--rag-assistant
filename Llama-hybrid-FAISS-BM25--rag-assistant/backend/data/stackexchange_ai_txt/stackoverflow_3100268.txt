[site]: stackoverflow
[post_id]: 3100268
[parent_id]: 3098696
[tags]: 
I wrote a program in C which demonstrate how to receive the information which you need #include #include // for GUID_DEVCLASS_CDROM etc #include #include // for MAX_DEVICE_ID_LEN, CM_Get_Parent and CM_Get_Device_ID #include #include #define ARRAY_SIZE(arr) (sizeof(arr)/sizeof(arr[0])) #pragma comment (lib, "setupapi.lib") // // Define the various device characteristics flags (defined in wdm.h) // #define FILE_REMOVABLE_MEDIA 0x00000001 #define FILE_READ_ONLY_DEVICE 0x00000002 #define FILE_FLOPPY_DISKETTE 0x00000004 #define FILE_WRITE_ONCE_MEDIA 0x00000008 #define FILE_REMOTE_DEVICE 0x00000010 #define FILE_DEVICE_IS_MOUNTED 0x00000020 #define FILE_VIRTUAL_VOLUME 0x00000040 #define FILE_AUTOGENERATED_DEVICE_NAME 0x00000080 #define FILE_DEVICE_SECURE_OPEN 0x00000100 #define FILE_CHARACTERISTIC_PNP_DEVICE 0x00000800 #define FILE_CHARACTERISTIC_TS_DEVICE 0x00001000 #define FILE_CHARACTERISTIC_WEBDAV_DEVICE 0x00002000 #pragma warning (disable: 4201) typedef struct _IO_STATUS_BLOCK { union { NTSTATUS Status; PVOID Pointer; } DUMMYUNIONNAME; ULONG_PTR Information; } IO_STATUS_BLOCK, *PIO_STATUS_BLOCK; #pragma warning (default: 4201) typedef enum _FSINFOCLASS { FileFsVolumeInformation = 1, FileFsLabelInformation, // 2 FileFsSizeInformation, // 3 FileFsDeviceInformation, // 4 FileFsAttributeInformation, // 5 FileFsControlInformation, // 6 FileFsFullSizeInformation, // 7 FileFsObjectIdInformation, // 8 FileFsDriverPathInformation, // 9 FileFsVolumeFlagsInformation,// 10 FileFsMaximumInformation } FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS; typedef struct _FILE_FS_DEVICE_INFORMATION { DEVICE_TYPE DeviceType; ULONG Characteristics; } FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION; typedef NTSTATUS (NTAPI *LPFN_NT_QUERY_VOLUME_INFORMATION_FILE) (HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FsInformation, ULONG Length, FS_INFORMATION_CLASS FsInformationClass); BOOL GetDriveTypeAndCharacteristics (HANDLE hDevice, DEVICE_TYPE *pDeviceType, ULONG *pCharacteristics) { HMODULE hNtDll; LPFN_NT_QUERY_VOLUME_INFORMATION_FILE lpfnNtQueryVolumeInformationFile; NTSTATUS ntStatus; IO_STATUS_BLOCK IoStatusBlock; FILE_FS_DEVICE_INFORMATION FileFsDeviceInfo; BOOL bSuccess = FALSE; hNtDll = GetModuleHandle (TEXT("ntdll.dll")); if (hNtDll == NULL) return FALSE; lpfnNtQueryVolumeInformationFile = (LPFN_NT_QUERY_VOLUME_INFORMATION_FILE)GetProcAddress (hNtDll, "NtQueryVolumeInformationFile"); if (lpfnNtQueryVolumeInformationFile == NULL) return FALSE; ntStatus = lpfnNtQueryVolumeInformationFile (hDevice, &IoStatusBlock, &FileFsDeviceInfo, sizeof(FileFsDeviceInfo), FileFsDeviceInformation); if (ntStatus == NO_ERROR) { bSuccess = TRUE; *pDeviceType = FileFsDeviceInfo.DeviceType; *pCharacteristics = FileFsDeviceInfo.Characteristics; } return bSuccess; } void FildVolumeName (LPCTSTR pszDeviceName) { TCHAR szVolumeName[MAX_PATH] = TEXT(""); TCHAR szDeviceName[MAX_PATH] = TEXT(""); HANDLE hFind = INVALID_HANDLE_VALUE; DWORD dwCharCount; BOOL bSuccess; hFind = FindFirstVolume (szVolumeName, ARRAYSIZE(szVolumeName)); if (hFind == INVALID_HANDLE_VALUE) return; while(TRUE) { // Skip the \\?\ prefix and remove the trailing backslash. size_t Index = lstrlen(szVolumeName) - 1; if (szVolumeName[0] != TEXT('\\') || szVolumeName[1] != TEXT('\\') || szVolumeName[2] != TEXT('?') || szVolumeName[3] != TEXT('\\') || szVolumeName[Index] != TEXT('\\')) return; // error // QueryDosDeviceW doesn't allow a trailing backslash, // so temporarily remove it. szVolumeName[Index] = TEXT('\0'); dwCharCount = QueryDosDevice (&szVolumeName[4], szDeviceName, ARRAYSIZE(szDeviceName)); szVolumeName[Index] = TEXT('\\'); if (dwCharCount == 0) return; // error if (lstrcmp (pszDeviceName, szDeviceName) == 0) { _tprintf (TEXT(" Volume Device Name: %s\n"), szVolumeName); return; } bSuccess = FindNextVolume (hFind, szVolumeName, ARRAYSIZE(szVolumeName)); if (!bSuccess) { DWORD dwErrorCode = GetLastError(); if (dwErrorCode == ERROR_NO_MORE_ITEMS) break; else break; // ERROR!!! } } } void DumpVidPidMi (LPCTSTR pszDeviceInstanceId) { TCHAR szDeviceInstanceId[MAX_DEVICE_ID_LEN]; const static LPCTSTR arPrefix[3] = {TEXT("VID_"), TEXT("PID_"), TEXT("MI_")}; LPTSTR pszToken, pszNextToken; int j; lstrcpy (szDeviceInstanceId, pszDeviceInstanceId); pszToken = _tcstok_s (szDeviceInstanceId , TEXT("\\#&"), &pszNextToken); while(pszToken != NULL) { for (j = 0; j cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA); ZeroMemory (&deviceInfoData, sizeof(deviceInfoData)); deviceInfoData.cbSize = sizeof(deviceInfoData); bSuccess = SetupDiGetDeviceInterfaceDetail (hIntDevInfo, &interfaceData, pInterfaceDetailData, dwRequiredSize, &dwRequiredSize, &deviceInfoData); if (!bSuccess) continue; hDev = CreateFile (pInterfaceDetailData->DevicePath, 0, // no access to the drive FILE_SHARE_READ | FILE_SHARE_WRITE, // share mode NULL, // default security attributes OPEN_EXISTING, // disposition 0, // file attributes NULL); // do not copy file attributes if (hDev != INVALID_HANDLE_VALUE) { STORAGE_DEVICE_NUMBER sdn; DWORD cbBytesReturned; bSuccess = DeviceIoControl (hDev, // device to be queried IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, // no input buffer (LPVOID)&sdn, sizeof(sdn), // output buffer &cbBytesReturned, // # bytes returned (LPOVERLAPPED) NULL); // synchronous I/O if (bSuccess) { if (sdn.DeviceType == DeviceType && sdn.DeviceNumber == DeviceNumber) { DEVINST dnDevInstParent, dnDevInstParentParent; CONFIGRET ret; // device found !!! TCHAR szBuffer[4096]; _tprintf (TEXT(" DevicePath: %s\n"), pInterfaceDetailData->DevicePath); bSuccess = SetupDiGetDeviceInstanceId (hIntDevInfo, &deviceInfoData, pszDeviceInstanceId, dwDeviceInstanceIdSize, &dwRequiredSize); if (dwRequiredSize > MAX_DEVICE_ID_LEN) continue; bSuccess = SetupDiGetDeviceRegistryProperty (hIntDevInfo, &deviceInfoData, SPDRP_REMOVAL_POLICY, &dwDataType, (PBYTE)pdwRemovalPolicy, sizeof(DWORD), &dwRequiredSize); // SPDRP_CHARACTERISTICS - Device characteristics // FILE_FLOPPY_DISKETTE, FILE_REMOVABLE_MEDIA, and FILE_WRITE_ONCE_MEDIA characteristics // FILE_READ_ONLY_DEVICE bSuccess = SetupDiGetDeviceRegistryProperty (hIntDevInfo, &deviceInfoData, SPDRP_CLASS, &dwDataType, (PBYTE)szBuffer, sizeof(szBuffer), &dwRequiredSize); if (bSuccess) _tprintf (TEXT(" Class: \"%s\"\n"), szBuffer); bSuccess = SetupDiGetDeviceRegistryProperty (hIntDevInfo, &deviceInfoData, SPDRP_HARDWAREID, &dwDataType, (PBYTE)szBuffer, sizeof(szBuffer), &dwRequiredSize); if (bSuccess) { LPCTSTR pszId; _tprintf (TEXT(" Hardware IDs:\n")); for (pszId=szBuffer; *pszId != TEXT('\0') && pszId + dwRequiredSize/sizeof(TCHAR) BusType); if (pszBusType) _tprintf (TEXT(" Bus Type: %s\n"), pszBusType); else _tprintf (TEXT(" Bus Type: Unknown (%d)\n"), psdp->BusType); if (psdp->VendorIdOffset) _tprintf (TEXT(" VendorId: \"%hs\"\n"), (LPCSTR)((PBYTE)psdp + psdp->VendorIdOffset)); if (psdp->ProductIdOffset) _tprintf (TEXT(" ProductId: \"%hs\"\n"), (LPCSTR)((PBYTE)psdp + psdp->ProductIdOffset)); if (psdp->ProductRevisionOffset) _tprintf (TEXT(" ProductRevision: \"%hs\"\n"), (LPCSTR)((PBYTE)psdp + psdp->ProductRevisionOffset)); if (psdp->RemovableMedia) bIsRemoveable = TRUE; } cbBytesReturned = 0; bSuccess = DeviceIoControl (hDevice, // device to be queried IOCTL_STORAGE_CHECK_VERIFY2, NULL, 0, // no input buffer NULL, 0, // no output buffer &cbBytesReturned, // # bytes returned (LPOVERLAPPED) NULL); // synchronous I/O if (bSuccess) _tprintf (TEXT(" the device media are accessible\n")); else if (GetLastError() == ERROR_NOT_READY) _tprintf (TEXT(" the device media are not accessible\n")); bSuccess = DeviceIoControl (hDevice, // device to be queried IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, // no input buffer (LPVOID)&sdn, sizeof(sdn), // output buffer &cbBytesReturned, // # bytes returned (LPOVERLAPPED) NULL); // synchronous I/O // GetLastError of ERROR_MORE_DATA indicates to the caller that the buffer was not large enough to accommodate the data requested if (!bSuccess) __leave; _tprintf (TEXT(" DeviceType: %d, DeviceNumber: %d, PartitionNumber: %d\n"), sdn.DeviceType, sdn.DeviceNumber, sdn.PartitionNumber); pGuidInferface = NULL; pGuidClass = NULL; if (sdn.DeviceType == FILE_DEVICE_CD_ROM || sdn.DeviceType == FILE_DEVICE_DVD) { pGuidInferface = (GUID*)&GUID_DEVINTERFACE_CDROM; pGuidClass = (GUID*)&GUID_DEVCLASS_CDROM; } else if (sdn.DeviceType == FILE_DEVICE_DISK) { DEVICE_TYPE DeviceType; ULONG ulCharacteristics; bSuccess = GetDriveTypeAndCharacteristics (hDevice, &DeviceType, &ulCharacteristics); if (bSuccess) { if ((ulCharacteristics & FILE_FLOPPY_DISKETTE) == FILE_FLOPPY_DISKETTE) { pGuidInferface = (GUID*)&GUID_DEVINTERFACE_FLOPPY; pGuidClass = (GUID*)&GUID_DEVCLASS_FLOPPYDISK; } else { pGuidInferface = (GUID*)&GUID_DEVINTERFACE_DISK; pGuidClass = (GUID*)&GUID_DEVCLASS_DISKDRIVE; } if ((ulCharacteristics & FILE_REMOVABLE_MEDIA) == FILE_REMOVABLE_MEDIA) bIsRemoveable = TRUE; } } // GUID_DEVCLASS_MEDIUM_CHANGER if (CloseHandle (hDevice)) hDevice = INVALID_HANDLE_VALUE; bSuccess = FindDiInfos (pGuidInferface, pGuidClass, pszEnumerator, sdn.DeviceType, sdn.DeviceNumber, ARRAY_SIZE(szDeviceInstanceId), // MAX_DEVICE_ID_LEN szDeviceInstanceId, &dwRemovalPolicy); if (bSuccess) { if (dwRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL || dwRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL) bIsRemoveable = TRUE; _tprintf (TEXT(" DeviceInstanceId: %s\n"), szDeviceInstanceId); if (bIsRemoveable) _tprintf (TEXT(" Drive %c: is removeable\n"), pszDriveRoot[0]); } } } __finally { if (pszLogicalDrives) pszLogicalDrives = (LPTSTR) LocalFree (pszLogicalDrives); if (hDevice != INVALID_HANDLE_VALUE) bSuccess = CloseHandle (hDevice); } return 0; } The program can be compiled without Windows DDK installed (only Windows SDK, which installed for example together with Visual Studio is required). The program produces output like following: .... Drive L: Dos Device Name: \Device\CdRom2 Volume Device Name: \\?\Volume{2c5f6a93-2b50-11df-aa6a-005056c00008}\ Volume Name: "SONYPICTUTIL" Bus Type: USB VendorId: "HL-DT-ST" ProductId: "DVDRAM GE20LU11 " ProductRevision: "CL01" the device media are accessible DeviceType: 2, DeviceNumber: 2, PartitionNumber: -1 DevicePath: \\?\usbstor#cdrom&ven_hl-dt-st&prod_dvdram_ge20lu11&rev_cl01#0010101640008b615&0#{53f56308-b6bf-11d0-94f2-00a0c91efb8b} Class: "CDROM" Hardware IDs: "USBSTOR\CdRomHL-DT-STDVDRAM_GE20LU11_CL01" "USBSTOR\CdRomHL-DT-STDVDRAM_GE20LU11_" "USBSTOR\CdRomHL-DT-ST" "USBSTOR\HL-DT-STDVDRAM_GE20LU11_C" "HL-DT-STDVDRAM_GE20LU11_C" "USBSTOR\GenCdRom" "GenCdRom" Friendly Name: "HL-DT-ST DVDRAM GE20LU11 USB Device" Physical Device Object Name: "\Device\00000096" Device Description: "CD-ROM Drive" Parent Device Instance ID: USB\VID_152E&PID_1640\0010101640008B615 vid: "152E" pid: "1640" Parent of Parent Device Instance ID: USB\ROOT_HUB20\4&29A1BD9B&0 DeviceInstanceId: USBSTOR\CDROM&VEN_HL-DT-ST&PROD_DVDRAM_GE20LU11&REV_CL01\0010101640008B615&0 Drive L: is removeable Drive N: Dos Device Name: \Device\HarddiskVolume8 Volume Device Name: \\?\Volume{ae08a3c8-71cf-11de-bc1d-005056c00008}\ Volume Name: "" Bus Type: USB VendorId: "SanDisk " ProductId: "Cruzer " ProductRevision: "8.01" the device media are accessible DeviceType: 7, DeviceNumber: 5, PartitionNumber: 1 DevicePath: \\?\usbstor#disk&ven_sandisk&prod_cruzer&rev_8.01#1740030578903736&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b} Class: "DiskDrive" Hardware IDs: "USBSTOR\DiskSanDisk_Cruzer__________8.01" "USBSTOR\DiskSanDisk_Cruzer__________" "USBSTOR\DiskSanDisk_" "USBSTOR\SanDisk_Cruzer__________8" "SanDisk_Cruzer__________8" "USBSTOR\GenDisk" "GenDisk" Friendly Name: "SanDisk Cruzer USB Device" Physical Device Object Name: "\Device\000000aa" Device Description: "Disk drive" Parent Device Instance ID: USB\VID_0781&PID_5406\1740030578903736 vid: "0781" pid: "5406" Parent of Parent Device Instance ID: USB\ROOT_HUB20\4&128079C2&0 DeviceInstanceId: USBSTOR\DISK&VEN_SANDISK&PROD_CRUZER&REV_8.01\1740030578903736&0 Drive N: is removeable Because we are interesting for only devices which are accessible through drive letters the program start with enumerating of all logical drives in the system with respect of GetLogicalDriveStrings function. For every drive we can use IOCTL_STORAGE_QUERY_PROPERTY to get information like VendorId , ProductId and ProductRevision . The usage of IOCTL_STORAGE_GET_DEVICE_NUMBER allow us to get the drive type (like CD/DVD or Disk/Floppy). Moreover two numbers: DeviceType and DeviceNumber are unique in the system and we can use these as the basis to fine the device instance (using SetupDi - functions) for the drive. Because Floppy and Disk devices has the same defice type FILE_DEVICE_DISK I demonstrate another function NtQueryVolumeInformationFile with FileFsDeviceInformation parameter to get so named Characteristics for the device. The characteristic is the best way to destinguisch floppy from other disks and choose the corresponding class and interface GUID for the device enumeration ( GUID_DEVINTERFACE_FLOPPY or GUID_DEVINTERFACE_DISK ). We get the DeviceType and DeviceNumber for all devices enumerated with respect of SetupDi API. In the way we find out which device has which drive letter. One more important thing is the hierarchy of devices: parent/child relationship. To demonstrate this I use CM_Get_Parent and CM_Get_Device_ID functions in the code example. So we can see which USB device has which storage divice as the child. I displayed some information about the found devices. You can combine API from the example with IOCTL_MOUNTMGR_QUERY_POINTS (see Using IOCTL_MOUNTMGR_QUERY_POINTS ) or FindFirstVolumeW , FindNextVolumeW and GetVolumePathNamesForVolumeNameW (see http://msdn.microsoft.com/en-us/library/cc542456(VS.85).aspx ) to receive more detailed information if needed. UPDATED : By the way the buffer returned by IOCTL_STORAGE_QUERY_PROPERTY has another fields like STORAGE_BUS_TYPE BusType ( BusTypeUsb , BusTypeFibre , BusTypeSd etc.) etc. You can also use IOCTL_STORAGE_QUERY_PROPERTY to ask another information like StorageDeviceUniqueIdProperty or StorageDeviceUniqueIdProperty etc. If you want to have more USB specific information, I recommend you http://www.emmet-gray.com/Articles/USB_SerialNumbers.htm which shows the usage of IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX , IOCTL_USB_GET_NODE_INFORMATION and IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION . UPDATED 2: I placed the extended version of program under http://www.ok-soft-gmbh.com/ForStackOverflow/EnumMassStorage.c because of restriction with the message size in stackoverflow.com. The test output looks like folowing http://www.ok-soft-gmbh.com/ForStackOverflow/EnumMassStorage.txt UPDATED 3: I found a bug and updated the code. Please use the latest version of the code and verify that your problem is solved.
