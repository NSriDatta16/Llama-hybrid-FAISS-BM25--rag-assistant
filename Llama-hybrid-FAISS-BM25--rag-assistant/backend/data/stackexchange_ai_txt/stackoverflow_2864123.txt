[site]: stackoverflow
[post_id]: 2864123
[parent_id]: 2864058
[tags]: 
You might want to take a look into the implementation of the std::vector specialization iterators, as they tackle the same problem. Note that with time, the specialization has been frown upon mainly because it does not comply with the container requirements (the iterators don't provide references to the actual contained type, but a proxy value), and that will also be a problem with your implementation. The other possible approach is using a regular container but having the stored type accept implement the assignment/conversions to and from the user expected types. If that is not possible with your current stored type, you can write a wrapper for it. A simplified wrapper (you will need to work on it to make it work): template class wrapper { public: typedef T store_type; typedef U value_type; wrapper() : stored() {} wrapper( value_type const & v ) : stored( convert (v) {} wrapper& operator=( value_type const & value ) { // or pass-by-value stored = convert (value); // or however you can convert them return *this; } operator value_type() const { // I don't quite like this, if possible use explicit conversions return convert (stored); } private: store_type stored; // maybe storage is handled externally and this can be pointer/ref. }; // For the simple test double int conversion static cast suffices template T convert( U in ) { return static_cast (in); } int main() { std::vector > v; v.push_back( 10 ); int x = v[0]; v[0] = 5; std::vector > v2; v.push_back( 10.5 ); double y = v2[0]; v2[0] = 11.3; }
