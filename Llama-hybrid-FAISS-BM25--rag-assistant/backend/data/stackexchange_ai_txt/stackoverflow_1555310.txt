[site]: stackoverflow
[post_id]: 1555310
[parent_id]: 1555057
[tags]: 
A generic List ( List ) should always be quicker than an ArrayList. Firstly, an ArrayList is not strongly-typed and accepts types of object , so if you're storing value types in the ArrayList , they are going to be boxed and unboxed every time they are added or accessed. A Generic List can be defined to accept only (say) int 's so therefore no boxing or unboxing needs to occur when adding/accessing elements of the list. If you're dealing with reference types, you're probably still better off with a Generic List over an ArrayList, since although there's no boxing/unboxing going on, your Generic List is type-safe, and there will be no implicit (or explicit) casts required when retrieving your strongly-typed object from the ArrayList's "collection" of object types. There may be some edge-cases where an ArrayList is faster performing than a Generic List, however, I (personally) have not yet come across one. Even the MSDN documentation states: Performance Considerations In deciding whether to use the List )>) or ArrayList class, both of which have similar functionality, remember that the List )>) class performs better in most cases and is type safe. If a reference type is used for type T of the List )>) class, the behavior of the two classes is identical. However, if a value type is used for type T, you need to consider implementation and boxing issues. If a value type is used for type T, the compiler generates an implementation of the List )>) class specifically for that value type. That means a list element of a List )>) object does not have to be boxed before the element can be used, and after about 500 list elements are created the memory saved not boxing list elements is greater than the memory used to generate the class implementation. Make certain the value type used for type T implements the IEquatable )>) generic interface. If not, methods such as Contains must call the Object..::.Equals(Object) method, which boxes the affected list element. If the value type implements the IComparable interface and you own the source code, also implement the IComparable )>) generic interface to prevent the BinarySearch and Sort methods from boxing list elements. If you do not own the source code, pass an IComparer )>) object to the BinarySearch and Sort methods Moreover, I particularly like the very last section of that paragraph, which states: It is to your advantage to use the type-specific implementation of the List )>) class instead of using the ArrayList class or writing a strongly typed wrapper collection yourself. The reason is your implementation must do what the .NET Framework does for you already, and the common language runtime can share Microsoft intermediate language code and metadata, which your implementation cannot. Touch√©! :)
