[site]: stackoverflow
[post_id]: 4608239
[parent_id]: 
[tags]: 
Using Pygeoip on Appengine - no module named mmap

I'm trying to do some IP-lookup on Python Google Appengine like this: import pygeoip gi = pygeoip.GeoIP('GeoIP.dat') Location = gi.country_code_by_addr(self.request.remote_addr) (pygeoip can be found here: http://code.google.com/p/pygeoip/ ) The above code executes fine locally but when I push it to the live server I get the following error: : No module named mmap Traceback (most recent call last): File "/base/data/home/apps/tomcritchlow1/geoip.347423765058502279/main.py", line 28, in import pygeoip File "/base/data/home/apps/tomcritchlow1/geoip.347423765058502279/pygeoip/__init__.py", line 34, in import mmap I'm using Python 2.5 locally so it should be the same as the live server I think? The Pygeoip page says the following: Supported Flags: STANDARD (do all reads from disk, slowest) MEMORY_CACHE MMAP_CACHE (map the whole file to memory, fastest) I'm not sure exactly what "supported flags" means - if mmap is the problem could I use Pygeoip using memory cache instead of mmap? How would I do that? Thanks! Tom PS - still a coding a n00b so please go easy :) EDIT : The solution outlined below works, first use this code: gi = pygeoip.GeoIP('GeoIP.dat', flags=pygeoip.const.MEMORY_CACHE) Then modify the init .py file within pygeoip like follows (warning! I've just commented out bits of code, not done anything fancy!!) """ Pure Python GeoIP API. The API is based off of U{MaxMind's C-based Python API }, but the code itself is based on the U{pure PHP5 API } by Jim Winstead and Hans Lellelid. It is mostly a drop-in replacement, except the C{new} and C{open} methods are gone. You should instantiate the L{GeoIP} class yourself: C{gi = GeoIP('/path/to/GeoIP.dat', pygeoip.MEMORY_CACHE)} @author: Jennifer Ennis @license: Copyright(C) 2004 MaxMind LLC This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program. If not, see . """ from __future__ import with_statement import os import math import socket #import mmap from const import * from util import ip2long class GeoIPError(Exception): pass class GeoIPMetaclass(type): def __new__(cls, *args, **kwargs): """ Singleton method to gets an instance without reparsing the db. Unique instances are instantiated based on the filename of the db. Flags are ignored for this, i.e. if you initialize one with STANDARD flag (default) and then try later to initialize with MEMORY_CACHE, it will still return the STANDARD one. """ if not hasattr(cls, '_instances'): cls._instances = {} if len(args) > 0: filename = args[0] elif 'filename' in kwargs: filename = kwargs['filename'] if not filename in cls._instances: cls._instances[filename] = type.__new__(cls, *args, **kwargs) return cls._instances[filename] GeoIPBase = GeoIPMetaclass('GeoIPBase', (object,), {}) class GeoIP(GeoIPBase): def __init__(self, filename, flags=0): """ Initialize the class. @param filename: path to a geoip database @type filename: str @param flags: flags that affect how the database is processed. Currently the only supported flags are STANDARD, MEMORY_CACHE, and MMAP_CACHE. @type flags: int """ self._filename = filename self._flags = flags #tom: #if self._flags & MMAP_CACHE: if '2' == '3': with open(filename, 'rb') as f: self._filehandle = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) else: self._filehandle = open(filename, 'rb') #tom: #if self._flags & MEMORY_CACHE: # self._memoryBuffer = self._filehandle.read() self._setup_segments() def _setup_segments(self): """ Parses the database file to determine what kind of database is being used and setup segment sizes and start points that will be used by the seek*() methods later. """ self._databaseType = COUNTRY_EDITION self._recordLength = STANDARD_RECORD_LENGTH filepos = self._filehandle.tell() self._filehandle.seek(-3, os.SEEK_END) for i in range(STRUCTURE_INFO_MAX_SIZE): delim = self._filehandle.read(3) if delim == (chr(255) * 3): self._databaseType = ord(self._filehandle.read(1)) if (self._databaseType >= 106): # backwards compatibility with databases from April 2003 and earlier self._databaseType -= 105 if self._databaseType == REGION_EDITION_REV0: self._databaseSegments = STATE_BEGIN_REV0 elif self._databaseType == REGION_EDITION_REV1: self._databaseSegments = STATE_BEGIN_REV1 elif self._databaseType in (CITY_EDITION_REV0, CITY_EDITION_REV1, ORG_EDITION, ISP_EDITION, ASNUM_EDITION): self._databaseSegments = 0 buf = self._filehandle.read(SEGMENT_RECORD_LENGTH) for j in range(SEGMENT_RECORD_LENGTH): self._databaseSegments += (ord(buf[j]) = self._databaseSegments: return x[1] offset = x[1] else: if x[0] >= self._databaseSegments: return x[0] offset = x[0] raise Exception('Error traversing database - perhaps it is corrupt?') def _get_org(self, ipnum): """ Seek and return organization (or ISP) name for converted IP addr. @param ipnum: Converted IP address @type ipnum: int @return: org/isp name @rtype: str """ seek_org = self._seek_country(ipnum) if seek_org == self._databaseSegments: return None record_pointer = seek_org + (2 * self._recordLength - 1) * self._databaseSegments self._filehandle.seek(record_pointer, os.SEEK_SET) org_buf = self._filehandle.read(MAX_ORG_RECORD_LENGTH) return org_buf[:org_buf.index(chr(0))] def _get_region(self, ipnum): """ Seek and return the region info (dict containing country_code and region_name). @param ipnum: converted IP address @type ipnum: int @return: dict containing country_code and region_name @rtype: dict """ country_code = '' region = '' if self._databaseType == REGION_EDITION_REV0: seek_country = self._seek_country(ipnum) seek_region = seek_country - STATE_BEGIN_REV0 if seek_region >= 1000: country_code = 'US' region = ''.join([chr((seek_region / 1000) / 26 + 65), chr((seek_region / 1000) % 26 + 65)]) else: country_code = COUNTRY_CODES[seek_region] region = '' elif self._databaseType == REGION_EDITION_REV1: seek_country = self._seek_country(ipnum) seek_region = seek_country - STATE_BEGIN_REV1 if seek_region 0: record['region_name'] = record_buf[record_buf_pos:record_buf_pos+str_length] record_buf_pos += str_length + 1 str_length = 0 # get city char = ord(record_buf[record_buf_pos+str_length]) while (char != 0): str_length += 1 char = ord(record_buf[record_buf_pos+str_length]) if str_length > 0: record['city'] = record_buf[record_buf_pos:record_buf_pos+str_length] record_buf_pos += str_length + 1 str_length = 0 # get the postal code char = ord(record_buf[record_buf_pos+str_length]) while (char != 0): str_length += 1 char = ord(record_buf[record_buf_pos+str_length]) if str_length > 0: record['postal_code'] = record_buf[record_buf_pos:record_buf_pos+str_length] else: record['postal_code'] = None record_buf_pos += str_length + 1 str_length = 0 latitude = 0 longitude = 0 for j in range(3): char = ord(record_buf[record_buf_pos]) record_buf_pos += 1 latitude += (char
