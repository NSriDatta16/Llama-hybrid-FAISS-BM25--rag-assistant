[site]: stackoverflow
[post_id]: 462725
[parent_id]: 462699
[tags]: 
I suggest writing your own extension method (edited to be generic with an IComparable constraint.) public static int MaxIndex (this IEnumerable sequence) where T : IComparable { int maxIndex = -1; T maxValue = default(T); // Immediately overwritten anyway int index = 0; foreach (T value in sequence) { if (value.CompareTo(maxValue) > 0 || maxIndex == -1) { maxIndex = index; maxValue = value; } index++; } return maxIndex; } Note that this returns -1 if the sequence is empty. A word on the characteristics: This works with a sequence which can only be enumerated once - this can sometimes be very important, and is generally a desirable feature IMO. The memory complexity is O(1) (as opposed to O(n) for sorting) The runtime complexity is O(n) (as opposed to O(n log n) for sorting) As for whether this "is LINQ" or not: if it had been included as one of the standard LINQ query operators, would you count it as LINQ? Does it feel particularly alien or unlike other LINQ operators? If MS were to include it in .NET 4.0 as a new operator, would it be LINQ? EDIT: If you're really, really hell-bent on using LINQ (rather than just getting an elegant solution) then here's one which is still O(n) and only evaluates the sequence once: int maxIndex = -1; int index=0; double maxValue = 0; int urgh = sequence.Select(value => { if (maxIndex == -1 || value > maxValue) { maxIndex = index; maxValue = value; } index++; return maxIndex; }).Last(); It's hideous, and I don't suggest you use it at all - but it will work.
