[site]: stackoverflow
[post_id]: 3573400
[parent_id]: 3523323
[tags]: 
Ruby 1.9: 709 chars R=gets.chop;s='';k=[];n=a=0 G={?(=>(A="(a-=1;s 1;")+"k (B="s B+(C="s D="s D,??=>D} R.each_char{|c|eval G[c]||A+D+F};eval B+C def P l,s;l.map{|a|a (K="a=k.pop;")+"k n=[a[0]]},a[1] K+(H="P a[1],s={Y=>n=[a[0]]};")+"k K+H+"k (I=K+"b=k.pop;")+"k [a[0],b[0]]},a[1]+b[1]]", ?\0=>I+"P b[1],a[0];k a=[]},[a]]"} e=k[0];P e[1],R; p $ (This will also works in Ruby 1.8 with 45 more chars by adding the alias below) Test with type testcase.txt | ruby regex.rb An implementation of Russ Cox's NFA parser in Ruby. A state is represented as a hash with a single key which holds an array of next states. Ungolfed: #needed to run on ruby 1.8 class String alias :each_char :each_byte end ## Infix to Postfix R=gets.chop p "regexp = #{R}" k=[] s='' #will hold postfix string n=a=0 #count braNches and Atoms postfix = R.each_char{|c| case c when ?( (a-=1;s 1 k 1 s s0=[state,state]] # Frag is [state, [s0,...]] Y=?| #choice indicator X={:true=>[R]} #matcstate def patch l,s #l is list of arrays, s is state. Put s in each array l.map{|a| a n=[a[0]]} k n=[a[0]]} patch(a[1],s) k n=[a[0]]} patch(a[1],s) k [a[0],b[0]]} k a=[]},[a]] end } e=k.pop patch(e[1],X) #Running the NFA E=[e[0]] #Evaluator p $
