[site]: crossvalidated
[post_id]: 7855
[parent_id]: 7850
[tags]: 
I did something similar recently. There are quite a few ways to aggregate data like this in R, but the ddply function from the package plyr is my security blanket, and I turn to it for things like this. I'm assuming that you have individual records for each person in your dataset, with age, sex, and marital status. There's no need to split up the data into multiple tables for this approach - if you have women in the original table, just leave them in and add sex as a grouping variable. require(plyr) results.by.age This splits the data.frame yourdata by unique combinations of the variables sex and age . Then, for each of those chunks (referred to as x ), it calculates the number of people who belong to that group ( n ), how many of them are married ( ever.married.n ), and what proportion of them are married ( ever.married.prop ). It will then return a data.frame called results.by.age with rows like sex age n ever.married.n ever.married.prop "Male" 25 264 167 0.633 This is perhaps not the most elegant or efficient way to do this, but this general pattern has been very helpful for me. One advantage of this is that you can easily and transparently collect whatever statistics you want from the subset, which can be helpful if you want to, say, add a regression line to the plot (weight by n ) or have both male and female proportions on the same plot and color the points by sex. Here's a revised version using the summarise() function from plyr - the effect is the same, but summarise() has a couple of key advantages: - It works within the environment of the current subset - so rather than typing x$marital.status , I can just type marital.status . - It lets me refer to other variables I've already created, which makes percentages, transformations and the like much easier - if I've already made num and denom , the proportion of num is just num / denom . results.by.age
