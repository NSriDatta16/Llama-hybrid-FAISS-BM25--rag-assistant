[site]: stackoverflow
[post_id]: 3173151
[parent_id]: 3170456
[tags]: 
After looking through the various ImageBrush related classes, especially that of BitmapImage I started to think that the StreamSource property was simply referencing the stream instead of making a local copy within the BitmapImage object. So, the using statement within my helper method was in effect releasing the stream and therefore making the StreamSource of the BitmapImage null. The canvas then fell back to a plain white (#FFFFFFFF) SolidColorBrush (Thanks James for reminding me of Snoop ). So, to fix this I instead created a private List to hold the references to the various image streams and then point my BitmapImages to those references. I implemented IDisposable to release the various MemoryStreams when the GC came along. Here is the abbreviated code: public class Media : IDisposable { private readonly List m_Screens = new List (); private readonly List m_BackingStreams = new List (); public BitmapImage MainScreen { get; private set; } public List Screens { get { return m_Screens; } } public Media() { LoadScreens(); } private void LoadScreens() { m_BackingStreams.Add(FromResourceBitmap(Properties.Resources.Screen_01)); m_BackingStreams.Add(FromResourceBitmap(Properties.Resources.Screen_02)); m_BackingStreams.Add(FromResourceBitmap(Properties.Resources.Screen_03)); m_BackingStreams.Add(FromResourceBitmap(Properties.Resources.Screen_04)); m_BackingStreams.Add(FromResourceBitmap(Properties.Resources.Screen_05)); foreach (var stream in m_BackingStreams) { m_Screens.Add(FromResourceStream(stream)); } } private BitmapImage FromResourceStream(Stream stream) { var result = new BitmapImage(); result.BeginInit(); result.StreamSource = stream; result.EndInit(); return result; } private MemoryStream FromResourceBitmap(Bitmap bitmap) { var stream = new MemoryStream(); bitmap.Save(stream, ImageFormat.Png); return stream; } public void Dispose() { if (m_BackingStreams.Count == 0 || m_BackingStreams == null) return; foreach (var stream in m_BackingStreams) { stream.Close(); stream.Flush(); } } And here is what it looked like when I actually set the background of my Canvas during runtime: MainMenuCanvas.Background = new ImageBrush(m_Media.Screens[0]); That fixed it, as inelegant as it may be. While researching I did come across this little bit of info in the BitmapImage.StreamSource documentation page on MSDN: Set the CacheOption property to BitmapCacheOption.OnLoad if you wish to close the stream after the BitmapImage is created. The default OnDemand cache option retains access to the stream until the bitmap is needed, and cleanup is handled by the garbage collector. ( http://bit.ly/bitmapimagestreamsource ) However, when I tried to use the original solution with the CacheOption enum set to BitmapCacheOption.OnLoad it resulted in the same problem. I may be missing something here, but the obvious isn't so obvious I guess. :)
