[site]: stackoverflow
[post_id]: 981177
[parent_id]: 980083
[tags]: 
Unlike Java, where a static variable is scoped for all instances of a class, static in C means that a variable is accessible only from within the file where it is declared. It allows you to do things like declare a static variable inside a function, which sets the value only the first time through, like this . One thing you haven't mentioned is the relationship between classes A, B, and C. If they are in an inheritance hierarchy, and you're expecting the static variable to be inherited as in Java, the method described by zpasternack will work. If the three classes are unrelated, and you just want to access the value declared in A, then extern is a more appropriate way to go. In this case, you want to declare the variable as extern in ClassA.h, then define it in Class.m. As long as ClassB and ClassC import ClassA.h, they will be able to link against the same extern definition. One fine point is that, instead of using extern by itself, it's more robust to use OBJC_EXPORT , which is defined in objc-api.h and handles compiling under C++ as well. Here's a code sample: // ClassA.h OBJC_EXPORT NSString* commonString; ... // ClassA.m NSString* commonString = @"OldValue"; // ClassB.m #import "ClassA.h" ... commonString = @"NewValue"; // Can be inside a function or method Of course, using externed variables in this way creates an infamous, much-maligned global variable , which is fragile in that anyone can read or write it, and access is uncontrolled. This is the simple approach, and answers your question about using static vs. extern . However, as a design principle, the encapsulation provided by wrapping the variable with class methods is much safer, albeit more complex. In object-oriented languages, when the effect you're trying to achieve is that of a class-static method, encapsulation is probably the right way to go.
