[site]: stackoverflow
[post_id]: 4625935
[parent_id]: 4622916
[tags]: 
Assumption 1: UserDataViewModel truely is a ViewModel The term "ViewModel" on the end of class name it implies that the purpose of that class is to support a specific view. You would not expect such a view model to make it difficult for the view to which it is attached to do its job. I would therefore suggest your "ViewModel" is messed up and needs redevelopment. Start with:- public class EntryItem { public string Name {get; set;} public CategoryItem Category {get; set;} } Your CategoryItem doesn't need an entires collection property and your UserDataView returns a flat collection of all EntryItem objects. Binding is easy. Assumption 2: UserDataViewModel isn't actually a ViewModel Its possible that what you've called a view model is in fact just a model of data arranged in manner matching its storage or general usage. This would account for why it doesn't match the actual view's requirements. I would introduce another assumption which on WP7 is likely be true (probably would be elsewhere). During display of the view the contents of the collections are not modified nor are the names of the items. Hence the Observable nature of these objects (whilst possibly being useful elsewhere) are not necessary for the view to work. If these assumptions are true then a value converter and an additional class can be used to present the items in more acceptable way:- public class EntryHolder { public EntryItem Entry {get; set;} public CategoryItem Category {get; set; } } public class CategoryToEntryItemExConverter { public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { UserDataViewModel model = value as UserDataViewModel; if (model != null) { return model.Data.SelectMany(c => c.Entries .Select(e => new EntryHolder() { Category = c, Entry = e}) ); } else { return null; } } public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { throw new NotImplementedException(); } } Now you would adjust your Xaml:- ...
