[site]: stackoverflow
[post_id]: 1719358
[parent_id]: 
[tags]: 
How can I manage a group of derived but otherwise Unrelated Classes

It seems the more I talk about this problem the better I understand it. I think my previous question didn't convey what I am trying to do correctly. My apologies for that. In my design I have GameObjects which are essentially an aggregation class, all functionality in a GameObject is implemented by adding various "Features" to it. A Feature is a Subclass of the Feature class that has it's own members and functions. All Features can receive Messages class Feature { public: virtual void takeMessage(Message& message) = 0; }; class VisualFeature : public Feature { public: void takeMessage(Message& message); private: RenderContext m_renderer; }; ... Additional Features ... FeatureServers are objects that are responsible for coordinating the various Features. GameObjects can subscribe to FeatureServers to receive messages from them, and Features can Subscribe to GameObjects to handle the messages it is interested in. So for example in this code: GameObject Square; VisualFeature* SquareSprite = new VisualFeature(); Square.subscribe(SquareSprite, "MESSAGE_RENDER"); Square.addFeature(SquareSprite); m_VisualFeatureServer.subscribe(Square, "MESSAGE_RENDER"); The VisualFeatureServer sends the message tied to "MESSAGE_RENDER" which may look something like this class Message { public: std::string getID() {return m_id;} bool isConsumed() {return m_consumed;} void consume() {m_consumed = true;} protected: bool isConsumed; std::string m_id; } class Message_Render : public Message { public: Message_Render() : m_id("MESSAGE_RENDER"), m_consumed(false) {} RenderTarget& getRenderTarget() {return m_target;} private: RenderTarget& m_target; }; When the VisualFeatureServer sends the Message_Render class to the Square GameObject it then forwards it to any FeatureComponents that are subscribed to receive that particular message. In this case the VisualFeature class receives the Message_Render message. Here is where my problem is, the VisualFeature class is going to receive a Message& that it can tell is a Message_Render by it's ID, I want to be able to treat it as a Message_Render rather then a Message like so: void VisualFeature::takeMessage(Message& message) { //Here's the problem, I need a pattern to handle this elegantly derivedMessage = convertMessageToDerivedType(message); this->handleDerivedMessageType(derivedMessage); } void VisualFeature::handleDerivedMessageType(Message_Render& message) { message.getRenderTarget().render(m_renderer); message.consume(); } Is there a way to elegantly deal with the takeMessage portion of this design?
