[site]: stackoverflow
[post_id]: 1770475
[parent_id]: 1770010
[tags]: 
Which types to use in order to accomplish this in Java? The short answer is a long . Now, more on how to measure... System.currentTimeMillis() The "traditional" way to do this is indeed to use System.currentTimeMillis() : long startTime = System.currentTimeMillis(); // ... do something ... long estimatedTime = System.currentTimeMillis() - startTime; o.a.c.l.t.StopWatch Note that Commons Lang has a StopWatch class that can be used to measure execution time in milliseconds. It has methods methods like split() , suspend() , resume() , etc that allow to take measure at different points of the execution and that you may find convenient. Have a look at it. System.nanoTime() You may prefer to use System.nanoTime() if you are looking for extremely precise measurements of elapsed time. From its javadoc: long startTime = System.nanoTime(); // ... the code being measured ... long estimatedTime = System.nanoTime() - startTime; Jamon Another option would be to use JAMon , a tool that gathers statistics (execution time, number of hit, average execution time, min, max, etc) for any code that comes between start() and stop() methods. Below, a very simple example: import com.jamonapi.*; ... Monitor mon=MonitorFactory.start("myFirstMonitor"); ...Code Being Timed... mon.stop(); Check out this article on www.javaperformancetunning.com for a nice introduction. Using AOP Finally, if you don't want to clutter your code with these measurement (or if you can't change existing code), then AOP would be a perfect weapon. I'm not going to discuss this very deeply but I wanted at least to mention it. Below, a very simple aspect using AspectJ and JAMon (here, the short name of the pointcut will be used for the JAMon monitor, hence the call to thisJoinPoint.toShortString() ): public aspect MonitorAspect { pointcut monitor() : execution(* *.ClassToMonitor.methodToMonitor(..)); Object arround() : monitor() { Monitor monitor = MonitorFactory.start(thisJoinPoint.toShortString()); Object returnedObject = proceed(); monitor.stop(); return returnedObject; } } The pointcut definition could be easily adapted to monitor any method based on the class name, the package name, the method name, or any combination of these. Measurement is really a perfect use case for AOP.
