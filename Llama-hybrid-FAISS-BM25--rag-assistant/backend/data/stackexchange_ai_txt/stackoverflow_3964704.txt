[site]: stackoverflow
[post_id]: 3964704
[parent_id]: 3963046
[tags]: 
If understand your question correctly, then you have 2 solutions to accomplish this: In both solution you'll see that I remove the Include method since Include does NOT allow you to filter the related data. 1. Filtered Projection (Returns Anonaymous Type) : Dim results = From p In RL.App.TComEntities.tblTelephoneNumbers _ Where p.companyId = m_CompanyID _ Select New With {.Handsets = p, _ .tblCalls = p.tblCalls.Where(Function(t) t.price > 100)} However, it might not be desirable in all situations as it gives a collection of anonymous type objects. 2. Two Tracked Queries (Returns EntityObjects): This one gives you a collection of your entityobject tblTelephoneNumbers: Dim m_handsets = (From p In RL.App.TComEntities.tblTelephoneNumbers _ Where p.companyId = m_CompanyID Select p).ToList() Dim m_tblCalls = (From t In RL.App.TComEntities.tblCalls _ Where t.price > 100 Select t).ToList(); ForEach(Dim t In m_tblCalls) m_handsets.Single(Function(h) h.ID = t.tblTelephoneNumberID).tblCalls.Add(t) End ForEach 3. Leveraging Attach Method (Returns EntityObjects) : The last and probably the best and most elegant solution is to use EntityCollection.Attach Method along with EntityCollection.CreateSourceQuery : foreach (var tel in m_handsets) { IQueryable sourceQuery = tel.tblCalls.CreateSourceQuery() .Where(c => c.price > 100); tel.tblCalls.Attach(sourceQuery); } Sorry for any VB syntax mistake, I wrote them all off the top of my head.
