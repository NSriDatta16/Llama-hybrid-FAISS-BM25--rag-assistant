[site]: stackoverflow
[post_id]: 1025137
[parent_id]: 1018407
[tags]: 
I find this solution particualarly elegant and a bit easier to follow. Solution 1 public static IEnumerable GetIndexedItems2 (this IEnumerable collection, IEnumerable indices) { int skipped = 0; foreach (int index in indices) { int offset = index - skipped; collection = collection.Skip(offset); skipped += offset; yield return collection.First(); } } This can be refactored farther to a real simple implementation: Solution 2 public static IEnumerable GetIndexedItems3 (this IEnumerable collection, IEnumerable indices) { foreach (int offset in indices.Distances()) { collection = collection.Skip(offset); yield return collection.First(); } } public static IEnumerable Distances(this IEnumerable numbers) { int offset = 0; foreach (var number in numbers) { yield return number - offset; offset = number; } } But we are not done Due to deferred execution LINQs Skip is way too slow. public static IEnumerable GetIndexedItems4 (this IEnumerable collection, IEnumerable indices) { var rest = collection.GetEnumerator(); foreach (int offset in indices.Distances()) { Skip(rest, offset); yield return rest.Current; } } static void Skip (IEnumerator enumerator, int skip) { while (skip > 0) { enumerator.MoveNext(); skip--; } return; } static IEnumerable Distances(this IEnumerable numbers) { int offset = 0; foreach (var number in numbers) { yield return number - offset; offset = number; } } Benchmarking, gives us similar performance to the solution by Eric. using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Diagnostics; namespace ConsoleApplication21 { static class LinqExtensions { public static IEnumerable GetIndexedItemsEric (this IEnumerable collection, IEnumerable indices) { int currentIndex = -1; using (var collectionEnum = collection.GetEnumerator()) { foreach (int index in indices) { while (collectionEnum.MoveNext()) { currentIndex += 1; if (currentIndex == index) { yield return collectionEnum.Current; break; } } } } } public static IEnumerable GetIndexedItemsSam (this IEnumerable collection, IEnumerable indices) { var rest = collection.GetEnumerator(); foreach (int offset in indices.Distances()) { Skip(rest, offset); yield return rest.Current; } } static void Skip (this IEnumerator enumerator, int skip) { while (skip > 0) { enumerator.MoveNext(); skip--; } return; } static IEnumerable Distances(this IEnumerable numbers) { int offset = 0; foreach (var number in numbers) { yield return number - offset; offset = number; } } } class Program { static void TimeAction(string description, int iterations, Action func) { var watch = new Stopwatch(); watch.Start(); for (int i = 0; i rand.Next(max - 1)).Distinct().OrderBy(_ => _).ToArray(); // warmup array.GetIndexedItemsEric(lookups).ToArray(); array.GetIndexedItemsSam(lookups).ToArray(); TimeAction("Eric's Solution", iterations, () => { array.GetIndexedItemsEric(lookups).ToArray(); }); TimeAction("Sam's Solution", iterations, () => { array.GetIndexedItemsEric(lookups).ToArray(); }); Console.ReadKey(); } } } Eric's Solution Time Elapsed 770 ms Sam's Solution Time Elapsed 768 ms
