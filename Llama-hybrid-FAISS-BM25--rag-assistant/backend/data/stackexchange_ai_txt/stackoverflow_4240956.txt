[site]: stackoverflow
[post_id]: 4240956
[parent_id]: 
[tags]: 
Python chat client-server modification goes horribly wrong

As an exercise, I looked for a simple Python chat client-server system to modify and toy with. The first major failing I found in the system was that it used a single tcp connection for the server and client to communicate. The second was that you could only have two people (one using the client, and the other using the server) communicate. Thirdly, consecutive posts were impossible. One person sent a message, then had to wait for the other person to send a single message before talking again. Very, very limiting. So I began threading it and experimenting with the sockets. Clients connect to the server once, give their IP addresses, create a listening thread, and then reconnect to the server's message receiver. All posts are sent to that receiver, which iterates through a list of connected clients and connects to each of them and sends the message (with the sender's name in the beginning; misc feature). (I know that opening a new connection so often like that is inefficient, but I wanted to keep with tcp connections until I had it working, and THEN go to UDP) However, weird crap began happening. Suffice it to say that I have nightmares of Error 91. Could anyone identify how to render this code operable within this structure and feature-set? (Python version 2.6 yey; ignore the infinite loop that is just a placeholder) SERVER CODE: from socket import * from time import time, ctime import Queue, threading IP = '' PORT = 5000 PORTPlus = 2 PORTRec = 1000 ADS = (IP, PORT) namelist = [] clientlist = [] class clientRec(threading.Thread): def __init__(self): threading.Thread.__init__(self) print "I'm this far:", (IP, (PORT + PORTRec)) self.receiver = socket(AF_INET, SOCK_STREAM) self.receiver.bind((IP, PORT + PORTRec)) self.sender = socket(AF_INET, SOCK_STREAM) def run(self): global clientlist, namelist self.receiver.listen(10) connected = True while connected: tcpcli, addr = receiver.accept() message = tcpcli.recv(1024) # Accept clien't IP for home-dialing for i in range(clientlist.__len__()): # For each connected client try: sender.connect(clientlist(i)) # connect sender.send(namelist[i] + message) # and deliver message with sender's name sender.close() except: del clientlist[i], namelist[i] print "ADS:", (IP, 5000) handle = clientRec() tcpsoc = socket(AF_INET, SOCK_STREAM) # Paperwork tcpsoc.bind(ADS) # Bind self to port tcpsoc.listen(5) # Listen on that port0 handle.start() # Start thread # Main while 1: print "Waiting for connection" tcpcli, addr = tcpsoc.accept() # Accept unknown client print "Connection received; handling..." namelist.append(tcpcli.recv(1024)) # Accept client's name client_IP = tcpcli.recv(1024) # Accept clien't IP for home-dialing client_port = int(tcpcli.recv(1024))# Accept clien't listening port port_assign = PORT + PORTRec tcpcli.send(str(port_assign)) # Tell the client that port tcpcli.close() # Close client connection clientlist.append((client_IP, client_port))# Add client to send-list print "Handled." tcpsoc.close() CLIENT CODE: #!/usr/bin/env python from socket import * import threading, cgi, os IP = '' PORT = 5000 PORTmy = 100 ADS = (IP, PORT) class iListen(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.receiver = socket(AF_INET, SOCK_STREAM)# Paperwork self.receiver.bind(('', PORT + PORTmy)) # Listen on that port self.receiver.listen(5) # Listen for posts def run(self): while listening: tcpcli, addr = receiver.accept() # Accept unknown client message = tcpcli.recv(1024) if message == "/q": listening = False tcpcli.close() # Initial CONNECT myname = raw_input("Tell me yer name partnah: ") tcpsoc = socket(AF_INET, SOCK_STREAM) tcpsoc.connect(ADS) # First Connect tcpsoc.send(myname) # Declare name tcpsoc.send(gethostbyname(gethostname()))# Give IP address tcpsoc.send(str(PORT + PORTmy)) # Give listening port ADS = (IP, int(tcpsoc.recv(1024))) # Get new connect details tcpsoc.close() # Close old connection listen = iListen() # Create listener thread listen.start() # Start listening # RECONNECT print ADS tcpsoc = socket(AF_INET, SOCK_STREAM) tcpsoc.connect(ADS) # reconnect to new port connected = True # Main Chat-loop while connected: mes = raw_input(">>>") tcpsoc.send(mes) if mes == "/q": tcpsoc.close() connected = False time.sleep(4) sys.exit()
