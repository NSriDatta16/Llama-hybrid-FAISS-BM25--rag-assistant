[site]: stackoverflow
[post_id]: 1217554
[parent_id]: 1216667
[tags]: 
This is a fairly typical range-finding problem, with the concatenation thrown in. Not sure if the following fits exactly, but it's a starting point. (Cursors are usually best avoided except in the small set of cases where they are faster than set-based solutions, so before the cursor haters get on me please note I use a cursor here on purpose because this smells to me like a cursor-friendly problem -- I typically avoid them.) So if I create data like this: CREATE TABLE [dbo].[sourceValues]( [Start] [int] NOT NULL, [End] [int] NOT NULL, [Item] [varchar](100) NOT NULL ) ON [PRIMARY] GO ALTER TABLE [dbo].[sourceValues] WITH CHECK ADD CONSTRAINT [End_after_Start] CHECK (([End]>[Start])) GO ALTER TABLE [dbo].[sourceValues] CHECK CONSTRAINT [End_after_Start] GO declare @i int; set @i = 0; declare @start int; declare @end int; declare @item varchar(100); while @i Then I can treat the problem like this: each "Start" AND each "End" value represents a change in the collection of current Items, either adding one or removing one, at a certain time. In the code below I alias that notion as "event," meaning an Add or Remove. Each start or end is like a time, so I use the term "tick." If I make a collection of all the events, ordered by event time (Start AND End), I can iterate through it while keeping a running tally in an in-memory table of all the Items that are in play. Each time the tick value changes, I take a snapshot of that tally: declare @tick int; declare @lastTick int; declare @event varchar(100); declare @item varchar(100); declare @concatList varchar(max); declare @currentItemsList table ( Item varchar(100) ); create table #result ( Start int, [End] int, Items varchar(max) ); declare eventsCursor CURSOR FAST_FORWARD for select tick, [event], item from ( select start as tick, 'Add' as [event], item from sourceValues as adds union all select [end] as tick, 'Remove' as [event], item from sourceValues as removes ) as [events] order by tick set @lastTick = 1 open eventsCursor fetch next from eventsCursor into @tick, @event, @item while @@FETCH_STATUS = 0 BEGIN if @tick != @lastTick begin set @concatList = '' select @concatList = @concatlist + case when len( @concatlist ) > 0 then '-' else '' end + Item from @currentItemsList insert into #result ( Start, [End], Items ) values ( @lastTick, @tick, @concatList ) end if @event = 'Add' insert into @currentItemsList ( Item ) values ( @item ); else if @event = 'Remove' delete top ( 1 ) from @currentItemsList where Item = @item; set @lastTick = @tick; fetch next from eventsCursor into @tick, @event, @item; END close eventsCursor deallocate eventsCursor select * from #result order by start drop table #result Using a cursor for this special case allows just one "pass" through the data, like a running totals problem. Itzik Ben-Gan has some great examples of this in his SQL 2005 books.
