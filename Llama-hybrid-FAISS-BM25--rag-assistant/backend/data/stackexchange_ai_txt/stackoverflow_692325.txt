[site]: stackoverflow
[post_id]: 692325
[parent_id]: 680011
[tags]: 
It looks like strager has identified the main problem: the loop conditions. Your alphabet is 0,1,2,3, so you should loop over that whole range. 0 is not a special case, as your code tries to treat it. The special case is to skip the iteration when the alphabet value equals the value in your key, which is what the continue suggested by strager accomplishes. Below is my version of your algorithm. It has some alternative ideas for loop structures, and it avoids copying the key by modifying it in place. Note that you can also change the size of the alphabet by changing the MIN_VALUE and MAX_VALUE constants. Here's the output for the "001" case: 101 111 121 131 102 103 100 201 211 221 231 202 203 200 301 311 321 331 302 303 300 011 012 013 010 021 022 023 020 031 032 033 030 002 003 000 And here's the code: #include #include #include #include using namespace std; const int MIN_VALUE = 0; const int MAX_VALUE = 3; int increment(int& ch) { if (ch == MAX_VALUE) ch = MIN_VALUE; else ++ch; return ch; } string stringKey(const vector & key) { ostringstream sout; for (int i = 0; i key; key.push_back(0); key.push_back(0); key.push_back(1); for (int outerKeyPos = 0; outerKeyPos
