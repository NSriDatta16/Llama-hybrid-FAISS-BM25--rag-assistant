[site]: stackoverflow
[post_id]: 1188773
[parent_id]: 1188751
[tags]: 
You basically have three approaches to this problem (one of which I'll eliminate immediately): One table per class (this is the one I'll eliminate); A record type with optional columns; and A record type with a child table depending on type that you join to. For simplicity I generally recommend (2). So once you have your table: CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, type VARCHAR(10), name VARCHAR(100) ); where type can be 'AGENT' or 'LEAD' (for example). Alternatively you can use one character type codes. You can then start to fill in the blanks with the object model: You have a User parent class; You have two child classes: Lead and Agent; Those children have a fixed type. and it should fall into place quite easily. As for how to load in one statement, I would use some kind of factory. Assuming these barebones classes: class User { private $name; private $type; protected __construct($query) { $this->type = $query['type']; $this->name = $query['name']; } ... } class Agent { private $agency; public __construct($query) { parent::constructor($query); $this->agency = $query['agency']; } ... } class Lead { public __consruct($query) { parent::constructor($query); } ... } a factory could look like this: public function loadUserById($id) { $id = mysql_real_escape_string($id); // just in case $sql = "SELECT * FROM user WHERE id = $id"; $query = mysql_query($sql); if (!query) { die("Error executing $sql - " . mysql_error()); } if ($query['type'] == 'AGENT') { return new Agent($query); } else if ($query['type'] == 'LEAD') { return new Lead($query); } else { die("Unknown user type '$query[type]'"); } } Alternatively, you could have the factory method be a static method on, say, the User class and/or use a lookup table for the types to classes. Perhaps polluting the classes with the query result resource like that is a questionable design in the strictest OO sense, but it's simple and it works.
