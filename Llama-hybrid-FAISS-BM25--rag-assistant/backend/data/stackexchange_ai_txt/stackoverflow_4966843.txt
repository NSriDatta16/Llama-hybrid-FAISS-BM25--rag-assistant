[site]: stackoverflow
[post_id]: 4966843
[parent_id]: 4958209
[tags]: 
The technical term for a block in code coverage is basic block . To crib directly from the Wikipedia entry : The code in a basic block has one entry point, meaning no code within it is the destination of a jump instruction anywhere in the program, and it has one exit point, meaning only the last instruction can cause the program to begin executing code in a different basic block. Under these circumstances, whenever the first instruction in a basic block is executed, the rest of the instructions are necessarily executed exactly once, in order. A basic block is important in code coverage because we can insert a probe at the beginning of the basic block. When this probe is hit, we know that all of the following instructions in that basic block will be executed (due to the properties of a basic block). Unfortunately, with compilers (and especially with optimizations), it's not always apparent how source code maps to basic blocks. The easiest way to tell is to look at the generated assembly. For example, let's look at your original main & testfunction : For main , I see the assembly below (interleaved with the original source). Similarly to what Peter does here , I have noted where the basic blocks start. int main() { 013B2D20 push ebp We see that main has three basic blocks: one initial block, and the other two because of the function calls. Looking at the code, this seems reasonable. testfunction is a little tougher. Just looking at the source, there appears to be three blocks: The entry to the function and logic test ( input > 0 ) The condition true branch ( return 1 ) The condition false branch ( return 0 ) However, because of the actual generated assembly, there are four blocks. I'm assuming you built your code with optimizations disabled. When I build with VS2010 in the Debug configuration (optimizations disabled), I see the following disassembly for testfunction : int testfunction(int input) { 013B2CF0 push ebp 0) { 013B2CF9 cmp dword ptr [input],0 013B2CFD jle testfunction+18h (013B2D08h) return 1; 013B2CFF mov eax,1 Here, we have four blocks: The entry to the function The condition true branch The condition false branch The shared function epilog (cleaning up the stack and returning) Had the compiler duplicated the function epilog in both the condition true and condition false branches, you would only see three blocks. Also, interestingly, the compiler inserted a spurious jmp instruction at 013B2D06 . Because it's unreachable code, it's not treated as a basic block. In general, all of this analysis is overkill since the overall code coverage metric will tell you what you need to know. This answer was just to highlight why the number of blocks isn't always obvious or what's expected.
