[site]: stackoverflow
[post_id]: 4210230
[parent_id]: 4208795
[tags]: 
I'm mostly throwing this out there because this question caught my interest, it was something I have no expertise in, and I'd like to generate discussion. I took the Point in Polygon pseudo-code and tried to make it fit your situation. It seemed you are only interested in determining if something is winding clockwise or counter-clockwise. Here is a simple test and a very simple (rough around the edges) C# implementation. [Test] public void Test_DetermineWindingDirection() { GraphicsPath path = new GraphicsPath(); // Set up points collection PointF[] pts = new[] {new PointF(10, 60), new PointF(50, 110), new PointF(90, 60)}; path.AddLines(pts); foreach(var point in path.PathPoints) { Console.WriteLine("X: {0}, Y: {1}",point.X, point.Y); } WindingDirection windingVal = DetermineWindingDirection(path.PathPoints); Console.WriteLine("Winding value: {0}", windingVal); Assert.AreEqual(WindingDirection.Clockwise, windingVal); path.Reverse(); foreach(var point in path.PathPoints) { Console.WriteLine("X: {0}, Y: {1}",point.X, point.Y); } windingVal = DetermineWindingDirection(path.PathPoints); Console.WriteLine("Winding value: {0}", windingVal); Assert.AreEqual(WindingDirection.CounterClockWise, windingVal); } public enum WindingDirection { Clockwise, CounterClockWise } public static WindingDirection DetermineWindingDirection(PointF[] polygon) { // find a point in the middle float middleX = polygon.Average(p => p.X); float middleY = polygon.Average(p => p.Y); var pointInPolygon = new PointF(middleX, middleY); Console.WriteLine("MiddlePoint = {0}", pointInPolygon); double w = 0; var points = polygon.Select(point => { var newPoint = new PointF(point.X - pointInPolygon.X, point.Y - pointInPolygon.Y); Console.WriteLine("New Point: {0}", newPoint); return newPoint; }).ToList(); for (int i = 0; i 0) if (Y 0)) { if (Yp1 > 0) w = w + .5; else w = w - .5; } else if ((Yp1 == 0) && (Xp1 > 0)) { if (Y 0 ? WindingDirection.ClockWise : WindingDirection.CounterClockwise; } The difference that I've put in that makes this a bit specific to your problem is that I've calculated the average values of X and Y from all points and use that as the "point in polygon" value. So, passing in just an array of points, it will find something in the middle of them. I've also made the assumption that the V i+1 should wrap around when it gets to the bounds of the points array so that if (i + 1 == points.Count) // use points[0] instead This hasn't been optimized, it's just something to potentially answers your question. And perhaps you've already come up with this yourself. Here's hoping for constructive criticism. :)
