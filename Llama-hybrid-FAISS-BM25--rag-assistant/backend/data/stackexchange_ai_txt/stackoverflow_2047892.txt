[site]: stackoverflow
[post_id]: 2047892
[parent_id]: 2046228
[tags]: 
NOTE With the release of version 3.2 of the CUDA Toolkit, NVIDIA now includes the rules file with the Toolkit as opposed to the SDK. Therefore I've split this answer into two halves, use the correct instructions for your version of the Toolkit. NOTE These instructions are valid for Visual Studio 2005 and 2008. For Visual Studio 2010 see this answer . CUDA TOOLKIT 3.2 and later I recommend using the NvCudaRuntimeApi.rules file (or NvCudaDriverApi.rules if using the driver API) provided by NVIDIA, this is released with the toolkit and supports the latest compiler flags in a friendly manner. Personally I would advise against using the VS wizard, but only because I really don't think you need it. The rules file (installed into the Program Files\Microsoft Visual Studio 9.0\VC\VCProjectDefaults directory) "teaches" Visual Studio how to compile and link any .cu files in your project into your application. Create a new project using the standard MS wizards (e.g. an empty console project) Implement your host (serial) code in .c or .cpp files Implement your wrappers and kernels in .cu files Add the NvCudaRuntimeApi.rules (right click on the project, Custom Build Rules , tick the relevant box), see note 1 Add the CUDA runtime library (right click on the project and choose Properties , then in Linker -> General add $(CUDA_PATH)\lib\$(PlatformName) to the Additional Library Directories and in Linker -> Input add cudart.lib to the Additional Dependencies ), see notes [2] and [3] Optionally add the CUDA include files to the search path, required if you include any CUDA files in your .cpp files (as opposed to .cu files) (right click on the project and choose Properties , then in C/C++ -> General add $(CUDA_PATH)\include to the Additional Include Directories ), see note [3] Then just build your project and the .cu files will be compiled to .obj and added to the link automatically Some other tips: Change the code generation to use statically loaded C runtime to match the CUDA runtime; right click on the project and choose Properties , then in C/C++ -> Code Generation change the Runtime Library to /MT (or /MTd for debug, in which case you will need to mirror this in Runtime API -> Host -> Runtime Library ), see note [4] Enable syntax highlighting using the usertype.dat file included with the SDK, see the readme.txt in \C\doc\syntax_highlighting\visual_studio_8 I'd also recommend enabling Intellisense support with the following registry entry (replace 9.0 with 8.0 for VS2005 instead of VS2008): [HKEY_CURRENT_USER\Software\Microsoft\VisualStudio\9.0\Languages\Language Services\C/C++] "NCB Default C/C++ Extensions"=".cpp;.cxx;.c;.cc;.h;.hh;.hxx;.hpp;.inl;.tlh;.tli;.cu;.cuh;.cl" Incidentally I would advocate avoiding cutil if possible, instead roll your own checking. Cutil is not supported by NVIDIA, it's just used to try to keep the examples in the SDK focussed on the actual program and algorithm design and avoid repeating the same things in every example (e.g. command line parsing). If you write your own then you will have much better control and will know what is happening. For example, the cutilSafeCall wrapper calls exit() if the function fails - a real application (as opposed to a sample) should probably handle the failure more elegantly! CUDA TOOLKIT 3.1 and earlier I would use the Cuda.rules file provided by NVIDIA with the SDK, this is released alongside the toolkit and supports the latest compiler flags in a friendly manner. Personally I would advise against using the VS wizard, but only because I really don't think you need it. The rules file (in the C\common directory of the SDK) "teaches" Visual Studio how to compile and link any .cu files in your project into your application. Create a new project using the standard MS wizards (e.g. an empty console project) Implement your host (serial) code in .c or .cpp files Implement your wrappers and kernels in .cu files Add the Cuda.rules (right click on the project, Custom Build Rules , browse for the rules file and ensure it is ticked) Add the CUDA runtime library (right click on the project and choose Properties , then in Linker -> General add $(CUDA_LIB_PATH) to the Additional Library Directories and in Linker -> Input add cudart.lib to the Additional Dependencies ), see note [2] below Optionally add the CUDA include files to the search path, required if you include any CUDA files in your .cpp files (as opposed to .cu files) (right click on the project and choose Properties , then in C/C++ -> General add $(CUDA_INC_PATH) to the Additional Include Directories ) Then just build your project and the .cu files will be compiled to .obj and added to the link automatically Some other tips: Change the code generation to use statically loaded C runtime to match the CUDA runtime, right click on the project and choose Properties , then in C/C++ -> Code Generation change the Runtime Library to /MT (or /MTd for debug, in which case you will need to mirror this in CUDA Build Rule -> Hybrid CUDA/C++ Options ), see note [4] Enable syntax highlighting using the usertype.dat file included with the SDK, see the readme.txt in \C\doc\syntax_highlighting\visual_studio_8 I'd also recommend enabling Intellisense support with the following registry entry (replace 9.0 with 8.0 for VS2005 instead of VS2008): [HKEY_CURRENT_USER\Software\Microsoft\VisualStudio\9.0\Languages\Language Services\C/C++] "NCB Default C/C++ Extensions"=".cpp;.cxx;.c;.cc;.h;.hh;.hxx;.hpp;.inl;.tlh;.tli;.cu;.cuh;.cl" Incidentally I would advocate avoiding cutil if possible, instead roll your own checking. Cutil is not supported by NVIDIA, it's just used to try to keep the examples in the SDK focussed on the actual program and algorithm design and avoid repeating the same things in every example (e.g. command line parsing). If you write your own then you will have much better control and will know what is happening. For example, the cutilSafeCall wrapper calls exit() if the function fails - a real application (as opposed to a sample) should probably handle the failure more elegantly! NOTE You can also use a Toolkit-version-specific rules fule e.g. NvCudaRuntimeApi.v3.2.rules . This means that instead of looking for the CUDA Toolkit in %CUDA_PATH% it will look in %CUDA_PATH_V3_2%, which in turn means that you can have multiple versions of the CUDA Toolkit installed on your system and different projects can target different versions. See also note [3]. The rules file cannot modify the C/C++ compilation and linker settings, since it is simply adding compilation settings for the CUDA code. Therefore you need to do this step manually. Remember to do it for all configurations! If you want to stabilise on a specific CUDA Toolkit version then you should replace CUDA_PATH with CUDA_PATH_V3_2. See also note 1 . Having mismatched version of the C runtime can cause a variety of problems; in particular if you have any errors regarding LIBCMT (e.g. LNK4098: defaultlib 'LIBCMT' conflicts with use of other libs ) or multiply defined symbols for standard library functions, then this should be your first suspect.
