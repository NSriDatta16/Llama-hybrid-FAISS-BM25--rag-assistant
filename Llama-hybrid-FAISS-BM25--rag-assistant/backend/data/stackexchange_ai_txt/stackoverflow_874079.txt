[site]: stackoverflow
[post_id]: 874079
[parent_id]: 
[tags]: 
Faster enumeration: Leveraging Array Enumeration

So, I have a class with an array inside. Currently, my strategy for enumerating over the class's items is to use the code, foreach (item x in classInstance.InsideArray) . I would much rather use foreach (item x in classInstance) and make the array private. My main concern is that I really need to avoid anything slow; the array gets hit a lot (and has a couple hundred items). It is vital that enumerating over this array is cheap. One thought was to just have the class implement IEnumerable , but InsideArray.getEnumerator() only gives me a non-generic enumerator. I also tried implementing the IEnumerable interface. This worked but was very slow, possibly due to boxing. Is there a way to make the class itself enumerable without a performance hit? Normal Code: //Class public class Foo { //Stuff public Item[,] InsideArray {get; private set;} } //Iteration. Shows up all over the place foreach (Item x in classInstance.InsideArray) { //doStuff } Adjusted, much slower code: //Class public class Foo : IEnumerable { //Stuff private Item[,] InsideArray; System.Collections.IEnumerator System.Collections.IEnumerable GetEnumerator() { return InsideArray.GetEnumerator(); } } //Iteration. Shows up all over the place foreach (Item x in classInstance) { //doStuff } Note: Adding an implementation for the nongeneric iterator is possible and faster than my slow solution, but it is still a bit worse than just using the array directly. I was hoping there was a way to somehow tell C#, "hey, when I ask you to iterate over this object iterate over it's array, just as fast," but apparently that is not quite possible...at least from the answers suggested thus far.
