[site]: stackoverflow
[post_id]: 4653400
[parent_id]: 4651844
[tags]: 
Oh wow, lifetime management using Unity in am MVC app. Where do I start? First of all, session singletons are not really possible as there is no ASP.NET system that will guarantee that the same instance will be used between requests in the same session. The session can mimic the same object persisted within the session by serializing and deserializing it between requests. Transient instances - i.e. simple registrations without lifetime management specification are sufficient 99% of the time. This implies that an instance of registered type will be created every time it is needed. It is very rarely that you need instances to live throughout the lifetime of the request. However when you need those, you really need those. A connection to a DB is a perfect candidate for this. Request singletons, on the other hand are much easier to create and manage. The most elegant solution is to use Unity's child container feature. A child container can be created at the beginning of the request, disposed at the end of the request (as an added bonus it will dispose all ContainerControlledLifetimeManager instances). When creating a child container, all registrations are still available from the parent container, so you need to register request specific stuff with the child container. Here is pseudo-code to get this working: private void Application_Start() { _parentContainer = new UnityContainer(); //creates a transient registration, available at any point in the app. _parentContainer.RegisterType (); ControllerBuilder.Current.SetControllerFactory(new ServiceLocatorControllerFactory()); } private void Application_BeginRequest() { var childContainer = _parentContainer.CreateChildContainer(); //registers a request "singleton" //This registration is a type registration, an instance of RequestInterfaceImpl //will be created when needed and then kept in the container for later use. childContainer.RegisterType (new ContainerControlledLifetimeManager()); //save the child container in the context, so we can use it later HttpContext.Items["childContainer"] = childContainer; } private void Application_EndRequest() { //dispose the child container ((IUnityContainer)HttpContext.Items["childContainer"]).Dispose(); } One other thing that needs to be done is to override the Controller Factory to use the child container to create controllers. Controller are the first point of entry into the application and they could simply take a dependency on other components in their constructor. public class UnityControllerFactory : DefaultControllerFactory { #region IControllerFactory Members public override IController CreateController(System.Web.Routing.RequestContext requestContext, string controllerName) { IController controller; controllerName = controllerName.ToLower(); var container = ((IUnityContainer)HttpContext.Items["childContainer"]) if(container.IsRegistered (controllerName)) controller = container.Resolve (controllerName); else controller = base.CreateController(requestContext, controllerName) ; return controller; } }
