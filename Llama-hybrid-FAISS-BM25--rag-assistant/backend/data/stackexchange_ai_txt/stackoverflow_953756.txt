[site]: stackoverflow
[post_id]: 953756
[parent_id]: 77632
[tags]: 
Not needing to typecast is one of the biggest advantages of Java generics , as it will perform type checking at compile-time. This will reduce the possibility of ClassCastException s which can be thrown at runtime, and can lead to more robust code. But I suspect that you're fully aware of that. Every time I look at Generics it gives me a headache. I find the best part of Java to be it's simplicity and minimal syntax and generics are not simple and add a significant amount of new syntax. At first, I didn't see the benefit of generics either. I started learning Java from the 1.4 syntax (even though Java 5 was out at the time) and when I encountered generics, I felt that it was more code to write, and I really didn't understand the benefits. Modern IDEs make writing code with generics easier. Most modern, decent IDEs are smart enough to assist with writing code with generics, especially with code completion. Here's an example of making an Map with a HashMap . The code I would have to type in is: Map m = new HashMap (); And indeed, that's a lot to type just to make a new HashMap . However, in reality, I only had to type this much before Eclipse knew what I needed: Map m = new Ha Ctrl + Space True, I did need to select HashMap from a list of candidates, but basically the IDE knew what to add, including the generic types. With the right tools, using generics isn't too bad. In addition, since the types are known, when retrieving elements from the generic collection, the IDE will act as if that object is already an object of its declared type -- there is no need to casting for the IDE to know what the object's type is. A key advantage of generics comes from the way it plays well with new Java 5 features. Here's an example of tossing integers in to a Set and calculating its total: Set set = new HashSet (); set.add(10); set.add(42); int total = 0; for (int i : set) { total += i; } In that piece of code, there are three new Java 5 features present: Generics Autoboxing and unboxing For-each loop First, generics and autoboxing of primitives allow the following lines: set.add(10); set.add(42); The integer 10 is autoboxed into an Integer with the value of 10 . (And same for 42 ). Then that Integer is tossed into the Set which is known to hold Integer s. Trying to throw in a String would cause a compile error. Next, for for-each loop takes all three of those: for (int i : set) { total += i; } First, the Set containing Integer s are used in a for-each loop. Each element is declared to be an int and that is allowed as the Integer is unboxed back to the primitive int . And the fact that this unboxing occurs is known because generics was used to specify that there were Integer s held in the Set . Generics can be the glue that brings together the new features introduced in Java 5, and it just makes coding simpler and safer. And most of the time IDEs are smart enough to help you with good suggestions, so generally, it won't a whole lot more typing. And frankly, as can be seen from the Set example, I feel that utilizing Java 5 features can make the code more concise and robust. Edit - An example without generics The following is an illustration of the above Set example without the use of generics. It is possible, but isn't exactly pleasant: Set set = new HashSet(); set.add(10); set.add(42); int total = 0; for (Object o : set) { total += (Integer)o; } (Note: The above code will generate unchecked conversion warning at compile-time.) When using non-generics collections, the types that are entered into the collection is objects of type Object . Therefore, in this example, a Object is what is being add ed into the set. set.add(10); set.add(42); In the above lines, autoboxing is in play -- the primitive int value 10 and 42 are being autoboxed into Integer objects, which are being added to the Set . However, keep in mind, the Integer objects are being handled as Object s, as there are no type information to help the compiler know what type the Set should expect. for (Object o : set) { This is the part that is crucial. The reason the for-each loop works is because the Set implements the Iterable interface, which returns an Iterator with type information, if present. ( Iterator , that is.) However, since there is no type information, the Set will return an Iterator which will return the values in the Set as Object s, and that is why the element being retrieved in the for-each loop must be of type Object . Now that the Object is retrieved from the Set , it needs to be cast to an Integer manually to perform the addition: total += (Integer)o; Here, a typecast is performed from an Object to an Integer . In this case, we know this will always work, but manual typecasting always makes me feel it is fragile code that could be damaged if a minor change is made else where. (I feel that every typecast is a ClassCastException waiting to happen, but I digress...) The Integer is now unboxed into an int and allowed to perform the addition into the int variable total . I hope I could illustrate that the new features of Java 5 is possible to use with non-generic code, but it just isn't as clean and straight-forward as writing code with generics. And, in my opinion, to take full advantage of the new features in Java 5, one should be looking into generics, if at the very least, allows for compile-time checks to prevent invalid typecasts to throw exceptions at runtime.
