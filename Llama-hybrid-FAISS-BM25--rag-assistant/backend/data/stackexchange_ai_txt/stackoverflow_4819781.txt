[site]: stackoverflow
[post_id]: 4819781
[parent_id]: 
[tags]: 
Wrapping an Unmanaged C++ Class Library with C++/CLI - Question 1 - Project/Code Organization

Note: This post represents Question #1 of my inquiry. The introduction block (all text until the numbers are reached) is repeated in both questions as it is background information that may be needed to answer the question. Introduction to Question I have an unmanaged C++ library that contains classes and functions that are common to and shared among several "higher level" libraries. I now have need to provide access to the common library to C#/.Net applications. To do this, I will have to wrap the common library with C++/CLI wrapper classes. The classes contained in the common library can be complex classes containing nested class definitions and member variables that are collections of other class objects. The collection variables are instances of typedefs of a custom list class for managing the collection. The common library also includes classes that represent the parsed structure of a custom script file syntax created using FLEX/BISON. The common library and the "higher level" libraries are all written in a fashion that allows for cross platform (Linux and GCC) compiling and usage. Any changes I make must still allow for this. The C++/CLI wrapper classes at first need only read capability. But as the project advances, I'll eventually need to be able to create and modify the objects as well. I know C++/CLI and have created several wrappers for other unmanaged C/C++ projects as well as providing abstracted functionality to this same common library. So I have the basics (and some advanced knowledge) already. I have two questions related to performing this task and since they could both spawn their own discussions and solutions, I'm splitting my questions into separate posts. I'll include the link to the other question in each post. Actual Questions How do I structure my files within the project? The namespace and class names between the unmanaged and C++/CLI projects will not conflict. As the unmanaged project uses the "C" prefix for class names while the C++/CLI does not. So unmanaged class CWidget will become just Widget . And they use different root namespace names. The issue comes when file names are concerned. As my default naming pattern would be to use Widget.h and Widget.cpp for both unmanaged and C++/CLI. The projects are currently setup where all files of the project are in the root of the project folder. Includes for header files are done as just the name of the header (e.g. #include "Widget.h" ). And to appropriately resolve includes for files of a different project, the path of the other project is added to the Additional Include Directories property of the using project. If I change my Additional Include Directories property to be the root of the solution ( ..\ ) and do my include for the unmanaged header as #include "Unmanaged\Widget.h , I have a new issue of resolving headers included in the unmanaged header. So using that option would require I change all include statements to prefix their project directory. I know other projects The most obvious/quickest solution to the issue of duplicate file names is to change the naming pattern for one of the libraries. So for the C++/CLI project, instead of using Widget.h and Widget.cpp to prefix or suffix m (managed) or w (wrapper). So the C++/CLI files would be mWidget.h , wWidget.h , WidgetM.h , or WidgetW.h . Then I could just repeat my existing pattern throughout and be good. But is there a better way to organize the files so that I could keep my pre-/suffix-less file names with minimal changes to existing code? Wrapping an Unmanaged C++ Class Library with C++/CLI - Question 2 - Collections
