[site]: stackoverflow
[post_id]: 5053017
[parent_id]: 5052521
[tags]: 
A functor is a an object that behaves like a function. This means you need to define a class that defines the operator() Example: class GameBoardMoveListSorter { bool operator()(std::pair const& left, std::pair const& right) const { return left.first Edit Based on Comment: Comments from others please: I though the new standard gave inner classes accesses to the enclosing classes private members. But having just re-read the standard that does not seem to be the wording I am seeing (the behavior of the compiler seems to allow accesses (though I know the conformance in this area has always been weak)). Section 9.7 Paragraph 4 Like a member function, a friend function (11.4) defined within a nested class is in the lexical scope of that class; it obeys the same rules for name binding as a static member function of that class (9.4), but it has no special access rights to members of an enclosing class . Based on the above section of the manual. The inner class must be a friend class to accesses the private members of the outer class. Note. Unlike java there is no implied parent relationship between inner and outer class. Thus the inner class must have an explicit reference to an outer class object to access its members. #include class Chess { private: int board[8][8]; class GameBoardMoveListSorter { GameBoardMoveListSorter(Chess& p) : parent(p) {} bool operator()(std::pair const& left, std::pair const& right) const { int val = parent.board[0][0] + parent.board[7][7]; return left.first + val > moveList(/*Generate Moves*/); moveList.sort(GameBoardMoveListSorter(*this)); // Do something with the move list. } };
