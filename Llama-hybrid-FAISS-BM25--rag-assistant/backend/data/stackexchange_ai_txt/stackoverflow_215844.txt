[site]: stackoverflow
[post_id]: 215844
[parent_id]: 95842
[tags]: 
On the topic of passing arbitrary lists/arrays into a SQL Server 2005 function or sproc, the least hokey way I know is to use an XML variable. If desired, that XML variable can be a strongly typed XML type that is associated w/ an XML Schema. Given a list passed into a procedure/function as XML, you can extract that list into a table variable or temp table via "shredding". "To shred" XML means to transform in the opposite direction--from XML to rowset(s). (The FOR XML clause causes a rowset to XML transformation.) In the user-defined table function CREATE FUNCTION [dbo].[udtShredXmlInputBondIdList] ( -- Add the parameters for the function here @xmlInputBondIdList xml ) RETURNS @tblResults TABLE ( -- Add the column definitions for the TABLE variable here BondId int ) AS BEGIN -- Should add a schema validation for @xmlInputIssuerIdList here --Place validation here -- Fill the table variable with the rows for your result set INSERT @tblResults SELECT nref.value('.', 'int') as BondId FROM @xmlInputBondIdList.nodes('//BondID') as R(nref) RETURN END if the @xmlInputBondIdList is an XML fragment of the expected structure like that immediately below and is invoked as follows DECLARE @xmlInputBondIdList xml SET @xmlInputBondIdList = ' 8681 8680 8684 ' SELECT * FROM [CorporateBond].[dbo].[udtShredXmlInputBondIdList] (@xmlInputBondIdList) the result will be the rowset BondId 8681 8680 8684 A couple other examples can be found at http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=678284&SiteID=1
