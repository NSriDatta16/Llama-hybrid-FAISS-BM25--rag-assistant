[site]: stackoverflow
[post_id]: 2112101
[parent_id]: 2111667
[tags]: 
Note that the form shown here wasn't accepted into the standard, as noted below. Compile time string processing is guessed to become possible through user-defined literals proposed in N2765 . As i already mentioned, i don't know of any compiler that currently implements it and without compiler support there can be only guess work. In §2.13.7.3 and 4 of the draft we have the following: Otherwise (S contains a literal operator template), L is treated as a call of the form operator "" X () where n is the source character sequence c1c2...ck. [Note: The sequence c1c2...ck can only contain characters from the basic source character set. —end note] Combine that with constexpr and we should have compile time string processing. update: i overlooked that i was reading the wrong paragraph, this form is allowed for user-defined-integer-literals and -floating-literals, but apparently not for -string-literals (§2.13.7.5). This part of the proposal seems to have not been accepted. That being said, with my limited glimpse at C++0x, it might look something like this (i most likely got something wrong): template struct hash { static const unsigned result = c + hash ::result; }; template struct hash { static const unsigned result = c; }; template constexpr unsigned operator "" _hash() { return hash ::result; } // update: probably wrong, because the above // form is not allowed for string-literals: const unsigned h = "abcd"_hash; If Jerrys approach works, then the following should work however: constexpr unsigned operator "" _hash(const char* s, size_t) { return const_hash(s); }
