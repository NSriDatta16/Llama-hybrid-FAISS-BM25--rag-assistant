[site]: stackoverflow
[post_id]: 2457549
[parent_id]: 2442840
[tags]: 
The syntax 5.2 is valid for any Fractional . Int is not an instance of Fractional , nor can or should it be. As what to do when converting an arbitrary Rational to an Int is underspecified. The conversion to a Double from an arbitrary fraction, however makes perfectly good sense (within the range of the type). Your expectation is driven by the presence of implicit coercions in many languages. However, those come with a cost. You have to manually ensure that the entire system of coercions is confluent. Haskell does not do this, choosing instead to let numeric literal syntax leverage the type system. To convert between them you need to use fromIntegral to make explicit the need for coercion, this avoids relying on confluence and allows programmers to define new numeric types. belowThreshold = filter (\x -> fromIntegral x This is analogous to using an explicit conversion in C++, like ((double)x . Although, this statement only works because of defaulting, because 5.2 could be used as a member of any Fractional , and the result of 'fromIntegral x' is any Num , a superclass of Fractional , so fromIntegral x is underspecified, it merely knows that it needs to compare two Fractional values of the same type and it chooses Double as a reasonable default, based on a 'default' statement. Also note that Int is not the only Integral type, so the above method works on any list of Integral values: belowThreshold :: Integral a => [a] -> [a]
