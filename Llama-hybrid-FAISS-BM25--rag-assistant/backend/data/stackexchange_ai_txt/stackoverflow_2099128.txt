[site]: stackoverflow
[post_id]: 2099128
[parent_id]: 2099120
[tags]: 
I think a better question is why should it? After all: MyObject foo; foo.DoBar(); Is hardly any more difficult. It's more readable too (though obviously that may be biased.) Even if you could construct-call, it would likely be tagged as a "bad thing" to do. Sort of how like multiple declarations on the same line are allowed, but often decrease readability. Such a construct adds rules and complexity to an already complex language, when an arguably preferable solution is already present. Do we really want to add costly sugar to a language just to save a few keystrokes? In response to: "I could see it being useful though when you want to construct an object and just call one function on it. " If you want to construct an object just to call a function, would it be possible to just make that function a free-function? After all, it's operating either on default data or data that was passed to the constructor anyway. The only thing missing would be the destructor. Not to mention the other option: struct MyObject { MyObject(bool pCallDoBar = true) { if (pCallDoBar) DoBar(); } void DoBar(void) { } }; MyObject foo; Or just: MyObject().DoBar(); // destructor called here, though I think you'd need a concrete example to really make a case.
