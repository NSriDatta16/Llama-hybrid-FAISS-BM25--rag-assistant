[site]: stackoverflow
[post_id]: 4211103
[parent_id]: 
[tags]: 
Scala for comprehension efficiency?

In the book "Programming In Scala", chapter 23, the author give an example like: case class Book(title: String, authors: String*) val books: List[Book] = // list of books, omitted here // ﬁnd all authors who have published at least two books for (b1 The author said, this will translated into: books flatMap (b1 => books filter (b2 => b1 != b2) flatMap (b2 => b1.authors flatMap (a1 => b2.authors filter (a2 => a1 == a2) map (a2 => a1)))) But if you look into the map and flatmap method definition( TraversableLike.scala ), you may find, they are defined as for loops: def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = { val b = bf(repr) b.sizeHint(this) for (x Traversable[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = { val b = bf(repr) for (x Well, I guess this for will continually be translated to foreach and then translated to while statement which is a construct not an expression, scala doesn't have a for construct, because it wants the for always yield something. So, what I want to discuss with you is that, why does Scala do this "For translation" ? The author's example used 4 generators, which will be translated into 4 level nested for loop in the end, I think it'll have really horrible performance when the books is large. Scala encourage people to use this kind of "Syntactic Sugar", you can always see codes that heavily make use of filter, map and flatmap, which seems programmers are forgetting what they really do is nesting one loop inside another, and what achieved is only to make codes looks a bit shorter. What's your idea?
