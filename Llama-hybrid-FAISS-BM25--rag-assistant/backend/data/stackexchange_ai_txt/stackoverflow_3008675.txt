[site]: stackoverflow
[post_id]: 3008675
[parent_id]: 3007141
[tags]: 
With the kickstart from everyone here I ended up doing this and it works. It is far from elegant, but it gets the job done /// /// adds an element to an xml tree and builds the tree up if it is needed /// /// root node /// root/childOne/innerParent/name /// element to add /// elements value static XElement BuildTree(XElement outerParent, string innerParentPath, string name, object value) { List s = innerParentPath.Split('/').ToList(); string str = ""; XElement prevInner = null; if (s.Count != 2)//use 2 since we know the root will always be there { var t = new List (s); t.RemoveRange(s.Count - 1, 1);//remove last element string[] sa = t.ToArray(); str = string.Join("/", sa); prevInner = BuildTree(outerParent, str, name, value);//call recursively till we get to root; } else { prevInner = outerParent; } XElement inner = prevInner.Element(s[s.Count - 1]); if (inner == null) { if (s[s.Count - 1] == name)//add actual element if we're at top lvl. { prevInner.Add(new XElement(name, value)); } else { inner = new XElement(s[s.Count - 1]); prevInner.Add(inner); } } return inner; }
