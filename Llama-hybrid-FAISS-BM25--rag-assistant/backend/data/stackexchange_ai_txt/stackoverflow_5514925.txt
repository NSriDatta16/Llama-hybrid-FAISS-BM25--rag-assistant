[site]: stackoverflow
[post_id]: 5514925
[parent_id]: 5507665
[tags]: 
The major reason for this is that most LL(k) parsers that are written in functional languages are just implemented using parser combinators, because the easiest path to generate a parser combinator library is recursive descent . Haskell's parsec , attoparsec , and polyparse and Scala's stock parser combinators all produce what are effectively LL(*) parsers. Both parsec and attoparsec require you to use an explicit try combinator to get backtracking, but this is only done for efficiency and the scala parser combinators can also deal with packrat parsing . Consider the following fragment from the announcement of Brent Yorgey's recent unbound package: parseAtom = parens parseTerm var ident lam brackets ident parseTerm it is pretty easy to see the original grammar. LR parsers require much more complicated preprocessing to generate the tables to execute efficiently, since the direct hand encoding of one using something like recursive ascent is pretty awful. By implementing your parser combinators as an EDSL rather than an external tool you enable greater use of advanced features of your programming language. You can make portions of the grammar higher order, build the lexer hack directly into the parser, etc. Typical LR parser generators can't do these things, or can only offer them in ad hoc ways in limited contexts because of the need to be able to emit the tables in the end.
