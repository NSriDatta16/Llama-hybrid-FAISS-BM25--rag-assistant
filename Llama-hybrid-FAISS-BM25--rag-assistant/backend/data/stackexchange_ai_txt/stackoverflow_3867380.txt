[site]: stackoverflow
[post_id]: 3867380
[parent_id]: 3867315
[tags]: 
It's not your design that's wrong, but your implementation might be. Try this, with the interfaces only having get ters on the property declarations: public class Game : IGame { public List Players { get { return _players; } } } public class Player : IPlayer { public IHand Hand { get; internal set; } } public class Hand : IHand { public List FaceDownCards { get; internal set; } public List FaceUpCards { get; internal set; } public List InHandCards { get; internal set; } } If you build your classes this way, you can mock up the hands you want to test, or build players with those hands programatically, to validate the logic at all the different levels. EDIT An example of a Mocked IPlayer (using Moq in this case) to inject a specific (poker) hand - //Mmmm...Full House List inHandCards = new List { ...Cards...}; //2 Kings? List faceDownCards = new List { ...Cards...}; List faceUpCards = new List { ...Cards...}; //3 4s? Mock hand = new Mock (); hand.SetupGet(h => FaceDownCards).Returns(faceDownCards); hand.SetupGet(h => FaceUpCards).Returns(faceUpCards); hand.SetupGet(h => InHandCards).Returns(inHandCards); Mock player = new Mock (); player.SetupGet(p => p.Hand).Returns(hand.Object); //Use player.Object in Game EDIT 2 I just realized why Jeff commented that he had misread the question, and realized that I'd only answered part of it. To expand on what you stated in the comments, it sounds like you have something like this: public class Game { public Player NextPlayer { get; private set; } public bool NextPlayerCanPlay { get; private set; } ... } Which is not a very testable class because your tests can't set anything. The best way I've found to get around this is to build a couple of interfaces IGame and ITestableGame which expose the properties differently: public interface IGame { IPlayer NextPlayer { get; } bool NextPlayerCanPlay { get; } } internal interface ITestableGame { IPlayer NextPlayer { get; set; } bool NextPlayerCanPlay { get; set; } } public class Game : IGame, ITestableGame { public IPlayer NextPlayer { get; set; } public bool NextPlayerCanPlay { get; set; } } Then, in your service, just send the clients an IGame object, and either make the ITestableGame interface internal and market it as InternalsVisibleTo(TestAssembly) , or just make it public and don't use it outside of your testing. EDIT 3 Based only on what you posted, it sounds like your control flow is set up something like this: public class Player { public void Play(List cardsToPlay) { hand.InHandCards.Remove(cardsToPlay); currentGame.PickUpPack.Add(cardsToPlay); hand.Add(currentGame.Deck.Draw(cardsToPlay.Count)); currentGame.SelectNextPlayer(); } } Is that fairly accurate?
