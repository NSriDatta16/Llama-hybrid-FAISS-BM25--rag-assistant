[site]: stackoverflow
[post_id]: 3034440
[parent_id]: 3034289
[tags]: 
If the head is publicly accessible, it'll need to be available as an array/list/collection so that consumers can deal with it. Another way of dealing with this may be to switch to a more behavioral design rather than a stateful design. In other words, instead of having code telling the dragon to nod, have the dragon respond to an event that would cause him to nod, if that makes sense. say("Dragon, would you like a yummy princess?"); if(dragon.Stomach.Contents.IsEmpty) { dragon.Nod(); } compared with: say("Dragon, would you like a yummy princess?"); dragon.offerFood(princess); // in dragon class void offerFood(Food yummyFood) { if(Stomach.Contents.Empty) { head.Nod(); // can be overridden by subclasses. } } In the second example, the consumer of the dragon class isn't asserting authority to make the dragon do things... all the consumer is doing is things (saying things, offering a princess) that he has the authority to do - the dragon gets to decide whether it wants to nod its head or not (which makes sense. I doubt that I'd be able to get a dragon to nod its head if it didn't want to!) I call this 'behavioral' because the interfaces focus on the interactions between the objects (the dragon and whatever is offering the yummy princess) rather than the state of the dragon (its heads).
