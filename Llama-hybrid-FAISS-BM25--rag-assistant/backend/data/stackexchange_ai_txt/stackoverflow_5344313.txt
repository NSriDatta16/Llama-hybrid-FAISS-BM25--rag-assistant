[site]: stackoverflow
[post_id]: 5344313
[parent_id]: 3854607
[tags]: 
I had a problem like this and began to implement the solution suggested by @Jamiec but I quickly realised that I needed a better solution because my model is much larger than that in the example cited here. I have one master table with three intermediate tables, each of which have one or more tertiary tables. And the three intermediates each had something like 50 columns. This would mean a lot of work to type all that up, particularly in the fetch part with the temporary memvars. I tried to find a way to FETCH directly into the temp table but it seems you cannot do that. What I did was add a column to the intermediate tables called OriginalId. Here is my code translated into the model used by the asker: DECLARE @newQuestionnaireId INT INSERT INTO Questionnaire (Id,Description) SELECT Id, Description FROM Questionnaire WHERE ID = @sourceQuestionnaireID SET @newquestionnaireId = SCOPE_IDENTITY() INSERT INTO Category(QuestionnaireId, description, originalId) SELECT @newquestionnaireId, description, id FROM Category WHERE questionnaireId = @sourceQuestionnaireId INSERT INTO Question SELECT Category.Id, Question.Field FROM Question join Category on Question.CategoryId = Category.OriginalId WHERE Category.QuestionnaireId = @newquestionnaireId In my model the id fields are all Identities so you do not supply them in the inserts. Another thing I discovered before I gave up on the CURSOR approach was this clever little trick to avoid having to type the FETCH statement twice by using an infinite WHILE loop with a BREAK:
