[site]: stackoverflow
[post_id]: 2395786
[parent_id]: 2395703
[tags]: 
i think you might want to do like this: ` struct PacketHeader { unsigned int senderId; unsigned int sequenceNum; }; class Packet { protected: PacketHeader header; std::vector data; public: char* serialize(int& packetSize); void deserialize(const char* data,int dataSize); } char* Packet::serialize(int& packetSize) { packetSize = this->data.size()+sizeof(PacketHeader); char* packetData = new char[packetSize]; PacketHeader* packetHeader = (PacketHeader*)packetData; packetHeader->senderId = htonl(this->header.senderId); packetHeader->sequenceNum = htonl(this->header.sequenceNum); char* packetBody = (packetData + sizeof(packetHeader)); for(size_t i=0 ; i data.size() ; i++) { packetBody[i] = this->data.at(i); } return packetData; } void deserialize(const char* data,int dataSize) { PacketHeader* packetHeader = (PacketHeader*)data; this->header.senderId = ntohl(packetHeader->senderId); this->header.sequenceNum = ntohl(packetHeader->sequenceNum); this->data.clear(); for(int i=sizeof(PacketHeader) ; i data.push_back(data[i]); } } ` those codes does not include bound checking and free allocated data, don't forget to delete the returned buffer from serialize() function, and also you can use memcpy instead of using loop to copy byte per byte into or from std::vector. most compiler sometime add padding inside a structure, this would cause an issue if you send those data intact without disable the padding, you can do this by using #pragma pack(1) if you are using visual studio disclaimer: i don't actually compile those codes, you might want to recheck it
