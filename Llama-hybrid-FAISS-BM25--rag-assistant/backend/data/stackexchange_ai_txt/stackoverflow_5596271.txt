[site]: stackoverflow
[post_id]: 5596271
[parent_id]: 
[tags]: 
Crockford-style prototypal pattern gotcha; looking for an elegant solution

I often use Crockford's prototypal pattern when writing JavaScript programs. I thought I understood all the "gotchas" involved, but I discovered one I didn't think about before. I'd like to know if anyone has a best practice for handling it. Here's a simple example: // Here's the parent object var MyObject = { registry: {}, flatAttribute: null, create: function () { var o, F = function () {}; F.prototype = this; o = new F(); return o; } }; // instance is an empty object that inherits // from MyObject var instance = MyObject.create(); // Attributes can be set on instance without modifying MyObject instance.flatAttribute = "This is going to be applied to the instance"; // registry doesn't exist on instance, but it exists on // instance.prototype. MyObject's registry attribute gets // dug up the prototype chain and altered. It's not possible // to tell that's happening just by examining this line. instance.registry.newAttribute = "This is going to be applied to the prototype"; // Inspecting the parent object // prints "null" console.log(MyObject.flatAttribute); // prints "This is going to be applied to the prototype" console.log(MyObject.registry.newAttribute); I want to feel safe that any changes that appear to be made to the instance don't propagate up the inheritance change. This is not the case when the attribute is an object and I'm setting a nested property. A solution is to re-initialize all object attributes on the instance. However, one of the stated advantages of using this pattern is removing re-initialization code from the constructor. I'm thinking about cloning all the object attributes of the parent and setting them on the instance within the create() function: { create: function () { var o, a, F = function () {}; F.prototype = this; o = new F(); for (a in this) { if (this.hasOwnProperty(a) && typeof this[a] === 'object') { // obviously deepclone would need to be implemented o[a] = deepclone(this[a]); } } return o; } }; Is there a better way?
