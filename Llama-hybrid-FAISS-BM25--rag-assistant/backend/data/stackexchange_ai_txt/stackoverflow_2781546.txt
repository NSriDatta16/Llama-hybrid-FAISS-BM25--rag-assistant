[site]: stackoverflow
[post_id]: 2781546
[parent_id]: 2781297
[tags]: 
If you just want to be able to receive multiple lines, rather than exiting after one, this is simple. You just need to place a loop around your read/write code, like so (quick and dirty): while( 1 ) { numread = read(rdfd, buf, MAX_BUF_SIZE); fprintf(stderr, "Full Duplex Server : Read From the pipe : %sn", buf); /* Convert to the string to upper case */ count = 0; while (count Of course, now you have an application which will never exit, and will start doing nothing as soon as it gets an EOF, etc. So, you can reorganize it to check for errors: numread = read(rdfd, buf, MAX_BUF_SIZE); while( numread > 0) { /* ... etc ... */ numread = read(rdfd,buf, MAX_BUF_SIZE); } if( numread == 0 ) { /* ... handle eof ... */ } if( numread From the man page, read returns 0 for EOF and -1 for an error (you have read the man page, right? http://linux.die.net/man/2/read ). So what this does is keeps on grabbing bytes from the read pipe until it reaches EOF or some error, in which case you (probably) print a message and exit. That said, you might just do a reopen when you get an EOF so you can get more input. Once you've modified your program to read continuously, entering multiple lines interactively is simple. Just execute: cat - > /tmp/np1 The '-' explicitly tells cat to read from stdin (this is the default, so you don't actually need the dash). So cat will pass everything you enter on to your pipe program. You can insert an EOF using Ctrl+D, which will cause cat to stop reading stdin. What happens to your pipe program depends on how you handle the EOF in your read loop. Now, if you want another program that does all the io, without cat, (so you end up with a stdio echo program), the pseudocode is going to look sort of like this: const int stdin_fd = 0; // known unix constant! int readpipe_fd = open the read pipe, as before int writepipe_fd = open the write pipe, as before read stdin into buffer while( stdin is reading correctly ) { write data from stdin to read pipe check write is successful read write pipe into buffer check read is successful write buffer to stdout (fprintf is fine) read stdin into buffer. } You can use the read system call to read stdin if you feel like it, but you can also just use stdio. Reading, writing, and opening your pipes should all be identical to your server program, except read/write is all reversed.
