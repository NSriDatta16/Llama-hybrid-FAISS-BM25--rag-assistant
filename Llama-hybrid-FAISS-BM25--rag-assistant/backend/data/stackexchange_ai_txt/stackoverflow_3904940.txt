[site]: stackoverflow
[post_id]: 3904940
[parent_id]: 809227
[tags]: 
yes the representation shown is very much correct as if we do it the other way round u will require an operator to reverse all the bits but in this case the logic is quite straightforward if we consider the size of the integers in the machine for instance in most machines an integer is 2 bytes = 16 bits maximum value it can hold is 2^16-1=65535 2^16=65536 0%65536=0 -1%65536=65535 which corressponds to 1111.............1 and all the bits are set to 1 (if we consider residue classes mod 65536) hence it is much straight forward. I guess no if u consider this notion it is perfectly dine for unsigned ints and it actually works out just check the following program fragment int main() { unsigned int a=2; cout } answer for b = 4294967295 whcih is -1%2^32 on 4 byte integers hence it is perfectly valid for unsigned integers in case of any discrepancies plzz report
