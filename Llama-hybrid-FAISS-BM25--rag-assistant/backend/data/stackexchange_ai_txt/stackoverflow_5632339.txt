[site]: stackoverflow
[post_id]: 5632339
[parent_id]: 5630137
[tags]: 
You should always use foreach if possible. foreach iterate over practically anything (even metadata, like compile-time data types); for can't. foreach (Type; TypeTuple!(int, long, short)) { pragma(msg, Type); } but you can't do that with a for loop. foreach can be used to perform actions at compile-time (extension of above); for example, if you have a piece of code that repeats 10 times, you can say: template Iota(size_t a, size_t b) //All integers in the range [a, b) { static if (a and this will occur at compile-time , with i treated as a constant . (This doesn't normally work with for .) foreach can be overloaded with opApply and also with range constructs, but for can't. This is very handy when iterating a tree structure (like all the folders in a file system), because it actually allows you to use entirely stack-based memory rather than allocating on the heap (because you can use recursion). foreach is preferred in most situations because it prevents the need for you to type your data explicitly, which is useful in preventing some bugs. For example, for (int i = 0; i is dangerous if n is greater than 2^32 - 1, but foreach (i; 0 .. n) { arr[i]++; } is not, because the compiler automatically chooses the correct type for iteration. This also improves readability.
