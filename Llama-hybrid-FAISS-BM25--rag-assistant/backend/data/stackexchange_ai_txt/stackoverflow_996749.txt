[site]: stackoverflow
[post_id]: 996749
[parent_id]: 996498
[tags]: 
There are several forms of operator new: void *operator new (size_t); void *operator new [] (size_t); void *operator new (size_t, void *); void *operator new [] (size_t, void *); void *operator new (size_t, /* parameters of your choosing! */); void *operator new [] (size_t, /* parameters of your choosing! */); All the above can exist at both global and class scope. For each operator new, there is an equivalent operator delete. You need to make sure you are adding logging to all versions of the operator, if that is the way you want to do it. Ideally, you would want the system to behave the same regardless of whether the memory logging is present or not. For example, the MS VC run time library allocates more memory in debug than in release because it prefixes the memory allocation with a bigger information block and adds guard blocks to the start and end of the allocation. The best solution is to keep all the memory logging information is a separate chunk or memory and use a map to track the memory. This can also be used to verify that the memory passed to delete is valid. new allocate memory add entry to logging table delete check address exists in logging table free memory However, you're writing embedded software where, usually, memory is a limited resource. It is usually preferable on these systems to avoid dynamic memory allocation for several reasons: You know how much memory there is so you know in advance how many objects you can allocate. Allocation should never return null as that is usually terminal with no easy way of getting back to a healthy system. Allocating and freeing memory leads to fragmentation. The number of objects you can allocate will decrease over time. You could write a memory compactor to move allocated objects around to free up bigger chunks of memory but that will affect performance. As in point 1, once you get a null, things get tricky. So, when doing embedded work, you usually know up front how much memory can be allocated to various objects and, knowing this, you can write more efficient memory managers for each object type that can take appropriate action when memory runs out - discarding old items, crashing, etc. EDIT If you want to know what called the memory allocation, the best thing to do is use a macro (I know, macros are generally bad): #define NEW new (__FILE__, __LINE__, __FUNCTION__) and define an operator new: void *operator new (size_t size, char *file, int line, char *function) { // log the allocation somewhere, no need to strcpy file or function, just save the // pointer values return malloc (size); } and use it like this: SomeObject *obj = NEW SomeObject (parameters); You compiler might not have the __FUNCTION__ preprocessor definition so you can safely omit it.
