[site]: stackoverflow
[post_id]: 2075264
[parent_id]: 2074099
[tags]: 
Generic Optimizations Here as some of my favorite optimizations. I have actually increased execution times and reduced program sizes by using these. Declare small functions as inline or macros Each call to a function (or method) incurs overhead, such as pushing variables onto the stack. Some functions may incur an overhead on return as well. An inefficient function or method has fewer statements in its content than the combined overhead. These are good candidates for inlining, whether it be as #define macros or inline functions. (Yes, I know inline is only a suggestion, but in this case I consider it as a reminder to the compiler.) Remove dead and redundant code If the code isn't used or does not contribute to the program's result, get rid of it. Simplify design of algorithms I once removed a lot of assembly code and execution time from a program by writing down the algebraic equation it was calculating and then simplified the algebraic expression. The implementation of the simplified algebraic expression took up less room and time than the original function. Loop Unrolling Each loop has an overhead of incrementing and termination checking. To get an estimate of the performance factor, count the number of instructions in the overhead (minimum 3: increment, check, goto start of loop) and divide by the number of statements inside the loop. The lower the number the better. Edit: provide an example of loop unrolling Before: unsigned int sum = 0; for (size_t i; i After unrolling: unsigned int sum = 0; size_t i = 0; **const size_t STATEMENTS_PER_LOOP = 8;** for (i = 0; i In this advantage, a secondary benefit is gained: more statements are executed before the processor has to reload the instruction cache. I've had amazing results when I unrolled a loop to 32 statements. This was one of the bottlenecks since the program had to calculate a checksum on a 2GB file. This optimization combined with block reading improved performance from 1 hour to 5 minutes. Loop unrolling provided excellent performance in assembly language too, my memcpy was a lot faster than the compiler's memcpy . -- T.M. Reduction of if statements Processors hate branches, or jumps, since it forces the processor to reload its queue of instructions. Boolean Arithmetic ( Edited: applied code format to code fragment, added example) Convert if statements into boolean assignments. Some processors can conditionally execute instructions without branching: bool status = true; status = status && /* first test */; status = status && /* second test */; The short circuiting of the Logical AND operator ( && ) prevents execution of the tests if the status is false . Example: struct Reader_Interface { virtual bool write(unsigned int value) = 0; }; struct Rectangle { unsigned int origin_x; unsigned int origin_y; unsigned int height; unsigned int width; bool write(Reader_Interface * p_reader) { bool status = false; if (p_reader) { status = p_reader->write(origin_x); status = status && p_reader->write(origin_y); status = status && p_reader->write(height); status = status && p_reader->write(width); } return status; }; Factor Variable Allocation outside of loops If a variable is created on the fly inside a loop, move the creation / allocation to before the loop. In most instances, the variable doesn't need to be allocated during each iteration. Factor constant expressions outside of loops If a calculation or variable value does not depend on the loop index, move it outside (before) the loop. I/O in blocks Read and write data in large chunks (blocks). The bigger the better. For example, reading one octect at a time is less efficient than reading 1024 octets with one read. Example: static const char Menu_Text[] = "\n" "1) Print\n" "2) Insert new customer\n" "3) Destroy\n" "4) Launch Nasal Demons\n" "Enter selection: "; static const size_t Menu_Text_Length = sizeof(Menu_Text) - sizeof('\0'); //... std::cout.write(Menu_Text, Menu_Text_Length); The efficiency of this technique can be visually demonstrated. :-) Don't use printf family for constant data Constant data can be output using a block write. Formatted write will waste time scanning the text for formatting characters or processing formatting commands. See above code example. Format to memory, then write Format to a char array using multiple sprintf , then use fwrite . This also allows the data layout to be broken up into "constant sections" and variable sections. Think of mail-merge . Declare constant text (string literals) as static const When variables are declared without the static , some compilers may allocate space on the stack and copy the data from ROM. These are two unnecessary operations. This can be fixed by using the static prefix. Lastly, Code like the compiler would Sometimes, the compiler can optimize several small statements better than one complicated version. Also, writing code to help the compiler optimize helps too. If I want the compiler to use special block transfer instructions, I will write code that looks like it should use the special instructions.
