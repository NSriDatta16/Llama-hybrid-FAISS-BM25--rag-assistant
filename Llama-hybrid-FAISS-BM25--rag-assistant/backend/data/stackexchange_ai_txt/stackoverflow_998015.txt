[site]: stackoverflow
[post_id]: 998015
[parent_id]: 766581
[tags]: 
Cocoa (a framework available both on Mac and iOS) implements several common collection types , including NSArray , NSDictionary , and NSSet , as well as their mutable variants. (Leopard also introduced NSPointerArray , NSHashMap , and NSHashTable , an array/dictionary/set with additional options (like using weak references) that make them a rather convenient to use in a garbage collected environment. However, these classes aren't currently available on iPhone, and would make little sense at the moment, since iOS doesn't support garbage collection.) These classes are extremely fast, and are suitable for general-purpose use in any Cocoa application. Beyond these provided structures, you have several choices: (1) create more complex structures using these as building blocks, (2) leverage existing third-party code, or (3) build your own data structures from scratch. One option is CHDataStructures.framework , an open-source Objective-C framework which I maintain. It implements several other common data structures, such as stack/queue/deque, linked lists, sorted sets, and more. These structures adopt NSCoding and NSCopying (plus NSFastEnumeration on 10.5+), so they work seamlessly with native Objective-C code. The project allows you to build a static library for use on iPhone as well. Since this framework is open source, you can even include only the relevant code directly in your project if needed. While you can use C++ and STL structures, I have found that mixing Objective-C and C++ tends to be much more confusing and lead to in vexing bugs, especially for novices. This isn't a bash against C++, just a "when in Rome" principle. When using C++, STL is of course the preferred approach. If you're already mixing in C++, you're probably comfortable enough with it that STL might be a good choice; even so, I find that using native Cocoa collections produces more self-evident, readable code.
