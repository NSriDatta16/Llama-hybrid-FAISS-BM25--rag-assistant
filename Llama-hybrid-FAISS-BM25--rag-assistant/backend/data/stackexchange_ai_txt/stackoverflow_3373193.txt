[site]: stackoverflow
[post_id]: 3373193
[parent_id]: 
[tags]: 
Why is vector deleting destructor being called as a result of a scalar delete?

I have some code that is crashing in a large system. However, the code essentially boils down to the following pseudo-code. I've removed much of the detail, as I have tried to boil this down to the bare bones; I don't think this misses anything crucial though. // in a DLL: #ifdef _DLL #define DLLEXP __declspec(dllexport) #else #define DLLEXP __declspec(dllimport) #endif class DLLEXP MyClass // base class; virtual { public: MyClass() {}; virtual ~MyClass() {}; some_method () = 0; // pure virtual // no member data }; class DLLEXP MyClassImp : public MyClass { public: MyClassImp( some_parameters ) { // some assignments... } virtual ~MyClassImp() {}; private: // some member data... }; and: // in the EXE: MyClassImp* myObj = new MyClassImp ( some_arguments ); // scalar new // ... and literally next (as part of my cutting-down)... delete myObj; // scalar delete Note that matching scalar new and scalar delete are being used. In a Debug build in Visual Studio (2008 Pro), in Microsoft's , the following assertion fails: _ASSERTE(_CrtIsValidHeapPointer(pUserData)); Near the top of the stack are the following items: mydll_d.dll!operator delete() mydll_d.dll!MyClassImp::`vector deleting destructor'() I think this ought to be mydll_d.dll!MyClassImp::`scalar deleting destructor'() That is, the program is behaving as if I'd written MyClassImp* myObj = new MyClassImp ( some_arguments ); delete[] newObj; // array delete The address in pUserData is that of myObj itself (as opposed to a member). The memory around that address looks like this: ... FD FD FD FD (address here) VV VV VV VV MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM FD FD FD FD AB AB AB AB AB AB AB AB EE FE EE FE ... where the four VV s are presumably the address of the virtual function table, the MM...MM is recognisable member data, and the other bytes are various special markers put in place by the debugger (e.g. the FD FD s are 'guard bytes' around the object's storage). Shortly before the assertion failure I do see the VV s change, and wonder if that is due to a switch to the base class's virtual function table. I'm aware of the problem of the wrong level in the class hierarchy undergoing destruction. That's not the problem here; my destructors are all virtual. I note Microsoft's page "BUG: Wrong Operator Delete Called for Exported Class" http://support.microsoft.com/kb/122675 but that seems to be regarding the wrong executable (with the wrong heap) attempting to take responsibility for destruction of the data. In my case, it's that the wrong 'flavour' of deleting destructor appears to be being applied: i.e. vector rather than scalar. I am in the process of trying to produce minimal cut-down code that still exhibits the problem. However, any hints or tips to help with how to investigate this problem further would be much appreciated. Perhaps the biggest clue here is the mydll_d.dll!operator delete() on the stack. Should I expect this to be myexe_d.exe!operator delete() , indicating that the DLLEXP s have been 'lost'? I suppose this could be an instance of a double-delete (but I don't think so). Is there a good reference I can read regarding what _CrtIsValidHeapPointer checks for?
