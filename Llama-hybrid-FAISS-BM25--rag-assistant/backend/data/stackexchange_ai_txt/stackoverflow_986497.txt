[site]: stackoverflow
[post_id]: 986497
[parent_id]: 
[tags]: 
Excel page breaks via VBA

As part of an overhaul of a report generator I saw what I believed to be inefficient code. This part of the code runs after the main report is generated to set the page breaks in logical positions. The criteria is this: Each Site starts on a new page. Group's aren't allowed to broken across pages. The code follows the above format: 2 loops doing those jobs. This is the original code (sorry for the length): Public Sub PageBreak(ByRef wstWorksheet As Excel.Worksheet, ByVal pctProgress As ProgressCtl.ProgressControl) Dim breaksMoved As Integer Dim p As HPageBreak Dim i As Integer 'Used as a control value breaksMoved = 1 ' Marks that no rows/columns are to be repeated on each page wstWorksheet.Activate wstWorksheet.PageSetup.PrintTitleRows = "" wstWorksheet.PageSetup.PrintTitleColumns = "" 'If this isn't performed beforehand, then the HPageBreaks object isn't available Range("A3").Select ActiveWindow.View = xlPageBreakPreview 'Defaults the print area to be the entire sheet wstWorksheet.DisplayPageBreaks = False wstWorksheet.PageSetup.PrintArea = "" Range("$B$4").Select ' add breaks after each site Do While ActiveCell.Row "Site ID" Then ActiveCell.Offset(1, 0).Activate wstWorksheet.HPageBreaks.Add ActiveCell End If pctProgress.ProgressText = "Set break point " & CStr(passes) & "." & CStr(i) Next Loop 'Reset the view to normal wstWorksheet.DisplayPageBreaks = True ActiveWindow.View = xlNormalView Range("A3").Select End Sub Seeing room for improvement I set about modifying this. As one of the new requirements the people wanting the report were manually removing pages prior to printing. So I added checkboxes on another page and copied the checked items across. To ease that I used named ranges. I used these named ranges to meet the first requirement: ' add breaks after each site For Each RangeName In ActiveWorkbook.Names If Mid(RangeName.Name, 1, 1) = "P" Then Range(RangeName).Activate ActiveCell.Offset(Range(RangeName).Rows.Count - 1, 0).Select ActiveCell.PageBreak = xlPageBreakManual End If Next RangeName All Ranges are prefixed with P_ (for parent). Using the lame Now() style of rough timing this is 1 second slower on my short 4 site report and the more challenging 15 site report. These have 606 and 1600 rows respectively. 1 second isn't so bad. Lets look at the next criteria. Each logical group is split by a blank row, so the easiest way is to find the next page break, step back until you find the next blank line and insert the new break. Rinse and repeat. So why does the original run through multiple times? We can improve that too (the boiler plate outside the loops is the same). Dim i As Long Dim oPageBreak As HPageBreak Do While i "Site ID" Then ActiveCell.Offset(1, 0).Activate shtDeliveryVariance.HPageBreaks.Add ActiveCell End If Loop One pass and more elegant too. But how much quicker is it? On the small test is takes 54 seconds compared to the original 45 seconds, and on the larger test my code is slower again at 153 to 130 seconds. And this is averaged over 3 runs too. So my questions are: Why is my newer code so much slower than the original despite mine looking faster and what can I do to speed up the slowness of the code ? Note : Screen.Updating, etc. is already off as is Calculation etc.
