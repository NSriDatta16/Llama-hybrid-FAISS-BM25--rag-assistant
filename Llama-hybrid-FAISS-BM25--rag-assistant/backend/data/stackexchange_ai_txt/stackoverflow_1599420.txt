[site]: stackoverflow
[post_id]: 1599420
[parent_id]: 1599363
[tags]: 
Answer to updated question: The reason you're having trouble doing this in an elegant way, is because you seem to be using a combination of return values and exceptions. You should consider manually raising an exception instead of using return values if the sitation is, well, exceptional. Assuming there is a good reason for the return values however, I'm thinking it might be clearer to go without a finally block altogether, and to include a return at the end of the try block and also in your catch block. That would save you from passing the exception message in a messy way. I can't really say what the best solution would be, since your code snippet does not show what Response would be if DoSomething() returns a non-zero value. Original answer: It depends a little on what you're trying to accomplish. Are exceptions actually being thrown in any of the methods? Otherwise there is no good reason to use a try-finally pattern. This would be equivalent (though maybe not advisable for readability): bool doneEverything = DoSomething() && DoSomething2() && DoSomething3(); DoSomethingElse(); If there are exceptions being thrown, and handled at a higher level, I'd recommend isolating this code in a separate method, so you can use a return statement*. void DoStuff() { try { if (!DoSomething()) return; if (!DoSomething2()) return; if (!DoSomething3()) return; } finally { DoSomethingElse(); } } To answer your question about when the finally code block is executed: it is always executed, unless the executing thread terminates prematurely. *: Some restructuring is recommended, because there is no equivalent of the Delphi Exit . The break statement comes closest, but it can only be used in loop constructs or switch blocks. To mimic Exit behavior, you would need goto and a label. We wouldn't want that, now would we? :)
