[site]: stackoverflow
[post_id]: 932748
[parent_id]: 932706
[tags]: 
If you want smooth animation, you'll need to make it time-based, and allow Windows to process messages in between movements. Set a timer , and respond to WM_TIMER notifications by moving the window a distance based on the elapsed time since your animation started. For natural-looking movement, don't use a linear function for determining the distance - instead, try something like Robert Harvey's suggested function. Pseudocode: // // animate as a function of time - could use something else, but time is nice. lengthInMS = 10*1000; // ten second animation length StartAnimation(desiredPos) { originalPos = GetWindowPos(); startTime = GetTickCount(); // omitted: hwnd, ID - you'll call SetTimer differently // based on whether or not you have a window of your own timerID = SetTimer(30, callback); } callback() { elapsed = GetTickCount()-startTime; if ( elapsed >= lengthInMS ) { // done - move to destination and stop animation timer. MoveWindow(desiredPos); KillTimer(timerID); } // convert elapsed time into a value between 0 and 1 pos = elapsed / lengthInMS; // use Harvey's function to provide smooth movement between original // and desired position newPos.x = originalPos.x*(1-SmoothMoveELX(pos)) + desiredPos.x*SmoothMoveELX(pos); newPos.y = originalPos.y*(1-SmoothMoveELX(pos)) + desiredPos.y*SmoothMoveELX(pos); MoveWindow(newPos); }
