[site]: stackoverflow
[post_id]: 3139941
[parent_id]: 3139077
[tags]: 
Do you have sources of the child program? Check how it reads its input (or post the source here). Does your child program work with cmd input redirection, e.g. if you do echo yes | childprogram.exe ? If not, chances are that the program uses low level console functions to do its input (maybe indirectly, e.g. via _getch() ). In this case you may have to use WriteConsoleInput to simulate input. Or, there may be a mistake in your redirection code. Post it here. EDIT A sample of using WriteConsoleInput: #include #include #include #include static const INPUT_RECORD SimulatedInput [] = { {KEY_EVENT, {TRUE, 1, 0, 0, {L'e'}, 0}}, {KEY_EVENT, {TRUE, 1, 0, 0, {L'c'}, 0}}, {KEY_EVENT, {TRUE, 1, 0, 0, {L'h'}, 0}}, {KEY_EVENT, {TRUE, 1, 0, 0, {L'o'}, 0}}, {KEY_EVENT, {TRUE, 1, 0, 0, {L' '}, 0}}, {KEY_EVENT, {TRUE, 1, 0, 0, {L'T'}, 0}}, {KEY_EVENT, {TRUE, 1, 0, 0, {L'E'}, 0}}, {KEY_EVENT, {TRUE, 1, 0, 0, {L'S'}, 0}}, {KEY_EVENT, {TRUE, 1, 0, 0, {L'T'}, 0}}, {KEY_EVENT, {TRUE, 1, VK_RETURN, 0, {L'\r'}, 0}}, }; int main( int, char*[] ) { printf("\n(type 'exit' to exit the subshell)\n"); // start a command interpreter asynchronously intptr_t process_handle = _spawnlp(_P_NOWAIT, "cmd", "/k", "prompt", "SUBSHELL: ", NULL); // get own console handle HANDLE con_input_handle = GetStdHandle(STD_INPUT_HANDLE); // send input to the console DWORD n_written; WriteConsoleInputW(con_input_handle, SimulatedInput, _countof(SimulatedInput), &n_written); // wait for child process to exit _cwait(NULL, process_handle, 0); return 0; } The sample above has to be compiled as a console program, because it uses GetStdHandle to obtain console input handle. When parent is a console app, child console app will share the console with parent. If parent is a GUI app and thus has no console, use AttachConsole function to attach to the child process console before calling GetStdHandle , then call FreeConsole when finished with it.
