[site]: stackoverflow
[post_id]: 4932691
[parent_id]: 4807341
[tags]: 
Disclaimer: I did not use SWI-Prolog in a commercial/production environment, I did not try the SWI/Java interface (although it was reported on the SWI-Prolog mailing list to work reasonably well), and I have no interest in the semantic web. That said, I did write a large and non-trivial project using SWI-Prolog, and it wasn't a toy application - I needed it to work in order to finish my research. Therefore I have some credentials for answering this question, even if not all of the required ones. In the context of a large project, it is best to treat Prolog as a domain-specific language for writing search routines - Not unlike SQL and storage. Prolog does one thing extremely well, and that it solving search problems. If your problem can be narrowed down to finding a valid assignment to a set of variables given a set of facts and rules, Prolog is your weapon-of-choice: You won't have to worry about anything else in your coding other than tweaking the queries and rules. It will also run reasonably fast, especially if you compile the predicates. Prolog is often slow not because it is inherently slow, but because it runs search routines over a large search space. Keeping that in mind, you can integrate it with Java in a similar manner you integrate SQL: Prolog takes care about solving the search. It stores the permanent data and the rules, and run the queries. The Java app takes care of anything else. Development environments are a bit of a soft-spot for Prolog. You won't get a fancy IDE - Simply because there are very few things to be fancy about. Prolog programs rarely have full compile-time information, so you won't get perfect auto-completion. I simply used Emacs, with the Prolog shell always open. For most things, the Prolog textual tracer/debugger will do the trick. SWI comes with its-own graphical debugger, but I haven't tried it. Prolog has several rarely-known advantages: A built-in parsing framework (DCG rules), a great macros system (term expansion), and meta-predicates (call, findall, etc.). If you know how to use them, these are real aces in your deck. To summarize: Does Prolog boosts or damages productivity? That depends on what currently blocks your productivity. If you waste too much time wondering how to implement knowledge representation and search routines in Java - Just use Prolog; It's not as if you implement your-own red-black trees instead of using SQL. If you're looking for soft-realtime performance and a spoiling IDE - Try something else.
