[site]: stackoverflow
[post_id]: 5573113
[parent_id]: 1288322
[tags]: 
I accomplished this by using a UITapGestureRecognizer: UIGestureRecognizer* cancelGesture; - (void) backgroundTouched:(id)sender { [self.view endEditing:YES]; } #pragma mark - UISearchBarDelegate -(void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar { cancelGesture = [UITapGestureRecognizer new]; [cancelGesture addTarget:self action:@selector(backgroundTouched:)]; [self.view addGestureRecognizer:cancelGesture]; } -(void)searchBarTextDidEndEditing:(UISearchBar *)searchBar { if (cancelGesture) { [self.view removeGestureRecognizer:cancelGesture]; [cancelGesture release]; cancelGesture = nil; } } The code is a bare, but you can see the intent. When the SearchBar starts editing, you attach a tap gesture recognizer to the view controller's view, and remove it when it stops editing. There are a couple caveats that you can work around: doing this will make it so if you click anything besides the keyboard or the search bar's text field, the recognizer traps the click -- so if you use the clear, cancel, scope or results button they won't respond correctly. In my particular scenario, I had a UITableView that was covering the exposed area of the view so I attached the gesture recognizer to it instead of the view controllers main view, isolating the area to which the gesture would respond.
