[site]: stackoverflow
[post_id]: 5682893
[parent_id]: 5682713
[tags]: 
I suspect that you're seeing an issue with memory fragmentation, rather than a memory leak, per se. Since you're not waiting for threads to exit, you've got as many as 200 threads all trying to allocate memory at the same time. Add to that the default memory allocation strategy for std::string , which doubles the current allocation each time it needs to grow, and you're probably chewing up your address space pretty quickly. One very simple thing you can do to help mitigate the problem is to preallocate the memory for the strings by using reserve() . In this case your strings are (31 * 100,000) + 1 bytes long, so you could modify calc() as follows: string TTT; // We know how big the string will get, so pre-alloc memory for it to avoid the // inefficiencies of the default allocation strategy as the string grows. TTT.reserve(3100001); for (int ii=0; ii This would allocate the memory for the strings once, in a single contiguous block, and avoid much of the fragmentation that you're suffering now. A quick test of this change under Valgrind shows that the original code does allocations of about 1.5 GB total over the lifetime of the process; but the modified version does allocations of about 620 MB total. Also worth noting that Valgrind did not reveal any memory leaks. It's always a good idea to try it out if you think you have a memory problem in your program: Valgrind home .
