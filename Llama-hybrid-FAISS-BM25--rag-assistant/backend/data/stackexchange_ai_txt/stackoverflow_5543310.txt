[site]: stackoverflow
[post_id]: 5543310
[parent_id]: 
[tags]: 
Java Motion Detection using webcam

I'm in a group that is trying to detect motion from people walking through a space and then for each separate person, to display a fish in an "aquarium". Right now we're using Processing and OpenCV to do facial detection and then for each face, we create a fish. The problem is that the system runs at a really low frame rate. We need to get the frame rate up by a large factor, which is why we're trying to figure out how to use motion detection. Our teacher suggested that we use threading in processing and check less often for people, but we're really confused by how to do the threading. Any suggestions about how we should handle this would be really really appreciated. Thank you. Here is the code: import hypermedia.video.*; // Imports the OpenCV library import java.awt.Rectangle; import ddf.minim.analysis.*; import ddf.minim.*; OpenCV opencv; // Creates a new OpenCV object Minim minim; AudioInput in; FFT fft; int w; PImage fade; PImage movementImg; // Creates a new PImage to hold the movement image ArrayList bubbles; // Creates an ArrayList to hold the Bubble objects PImage bubblePNG; // Creates a PImage that will hold the image of the bubble int randPos; PImage fishImg; PImage fishImg2; PImage fishImg3; PImage fishImg4; PImage fishImg5; PImage sharkImg; PImage clockImg; PImage backImg; int sharkX=480; int sharkY=height/2; int sharkMoves = 480; int sharkSpeed=40; int flagForShark=0; int flagForNotification=0; ArrayList psystems; int NotificationX = 10; int NotificationY = 10; //clock int cx, cy; float secondsRadius; float minutesRadius; float hoursRadius; float clockDiameter; void setup(){ size ( 640, 480 ); // Window size of 640 x 480 opencv = new OpenCV( this ); // Initialises the OpenCV library opencv.capture( 640, 480 ); // Sets the capture size to 640 x 480 opencv.cascade( OpenCV.CASCADE_FRONTALFACE_ALT ); //// load the FRONTALFACE description file movementImg = new PImage(640, 480 ); // Initialises the PImage that holds the movement image bubbles = new ArrayList(); // Initialises the ArrayList bubblePNG = loadImage("bubble.png"); // Load the bubble image into memory smooth(); fishImg = loadImage("purpleFish.png"); fishImg2 = loadImage("fish2.png"); fishImg3 = loadImage("fish3.png"); fishImg4 = loadImage("fish4.png"); fishImg5 = loadImage("fish5.png"); sharkImg = loadImage("shark.png"); clockImg = loadImage("clock.png"); backImg = loadImage("bg01.png"); fill(61,36,9); int radius = min(100, 100) / 2; secondsRadius = radius * 0.72; minutesRadius = radius * 0.60; hoursRadius = radius * 0.50; clockDiameter = radius * 1.8; cx = 50; cy = 50; //Sound stuff minim = new Minim(this); in = minim.getLineIn(Minim.STEREO, 512); fft = new FFT(in.bufferSize(),in.sampleRate()); fft.logAverages(60,7); } void youareloud(){ fft.forward(in.mix); for(int i=0; i 3){ randPos = 160*(int)random(0, 5); bubbles.add(new Bubble( randPos+(int)random(-10, 10), 480, (int)random(10,25), (int)random(10,25))); // Adds a new bubble to the array with a random x position } } for ( int i = 0; i 0 && y 0 ){ //If the current pixel is within the screen bondaries if (brightness(movementImg.pixels[x + (y * width)]) > 127){ //and if the brightness is above 127 (in this case, if it is white) movementAmount++; //Add 1 to the movementAmount variable. } } } } if (movementAmount > 5){ // If more than 5 pixels of movement are detected in the bubble area //poppedBubbles++; // Add 1 to the variable that holds the number of popped bubbles return 1; // Return 1 so that the bubble object is destroyed } else { // If less than 5 pixels of movement are detected, //bubbleY += 10; // increase the y position of the bubble so that it falls down bubbleY -= 10; // increase the y position of the bubble so that it falls down if (bubbleY 0){ sharkMoves-=sharkSpeed; } else { sharkMoves=480; flagForShark=0; } } if(flagForNotification==1){ image(sharkImg,NotificationX,NotificationY); } //Clock // Draw the clock background // fill(80); noStroke(); // ellipse(cx, cy, clockDiameter, clockDiameter); image(clockImg,5,5,clockDiameter,clockDiameter); // Angles for sin() and cos() start at 3 o'clock; // subtract HALF_PI to make them start at the top float s = map(second(), 0, 60, 0, TWO_PI) - HALF_PI; float m = map(minute() + norm(second(), 0, 60), 0, 60, 0, TWO_PI) - HALF_PI; float h = map(hour() + norm(minute(), 0, 60), 0, 24, 0, TWO_PI * 2) - HALF_PI; // Draw the hands of the clock stroke(61,36,9); strokeWeight(1); line(cx, cy, cx + cos(s) * secondsRadius, cy + sin(s) * secondsRadius); strokeWeight(2); line(cx, cy, cx + cos(m) * minutesRadius, cy + sin(m) * minutesRadius); strokeWeight(4); line(cx, cy, cx + cos(h) * hoursRadius, cy + sin(h) * hoursRadius); // Draw the minute ticks // strokeWeight(2); // beginShape(POINTS); // for (int a = 0; a
