[site]: stackoverflow
[post_id]: 2213750
[parent_id]: 2213664
[tags]: 
A concept is a set of requirements on a type. For example, you could have a concept called "RandomAccessible", which places the requirement on a type that it implements operator[](int) in O(1) time. As concepts were dropped from the upcoming C++ standard, they only exist intangibly in C++ as documentation. As an example, you could read SGI's description of the Container concept . When a type meets all the requirements of a concept, you call it a model of that concept. For example, std::vector is a model of the Container concept (or, equivalently, std::vector "models" Container). Finally, a policy is a unit of behaviour, which can be combined with other units of behaviour to build complex classes. For example, say you wanted to build two classes: a fixed-size array, and a dynamically-resizable array. Both these classes have a lot of shared functionality, but just differ in their storage mechanisms, and some of their functionality (e.g. you can't call push_back on a fixed-size array). template class array : public StoragePolicy { public: T& operator[](int i) { return data[i]; } }; template class fixed_storage { T data[N]; }; template class dynamic_storage { T* data; public: void push_back(const T& value) { // Code for dynamic array insertion } }; Usage would be as follows: int main() { array > fixed_array; array > dynamic_array; dynamic_array.push_back(1); fixed_array[9] = dynamic_array[0]; } Obviously this is a very crude and incomplete example, but I hope it illuminates the concept behind a policy. Note that in the example, we could say that fixed_storage and dynamic_storage are "models" of the StoragePolicy concept. Of course, we would need to formally define exactly what the StoragePolicy concepts requires of its models. In this case, it would simply be to define an indexable data member variable.
