[site]: stackoverflow
[post_id]: 4447240
[parent_id]: 4446364
[tags]: 
The first thing you should do in OOP is consider the classes of objects. Cocoa uses an MVC (Model, View, Controller) architecture, so classes should fit in one of these three categories. Cocoa already provides the NSTableView class which works quite well, so that leaves the model and controller. There are a number of different approaches to the model class you could take: You could write a function table class that holds x and y values in separate arrays You could write a function table class that has a single array of (x,y) pairs. In either this or the previous implementation, you could provide a public interface that supports both arrangements (i.e. they'd have methods that return a y given an x, and properties that are x, y, and (x,y) collections). Some implementation details would depend on how you're connecting the table view to the data (bindings, or the older NSTableViewDataSource protocol ). You could also use an array of x values, and create a value transformer . With this approach, the y-values exist in the table view and not the model. And so on The application requirements will determine which approach to take. I'll show you the value transformer approach, as it requires the least amount of code. For the controller, you could rely on NSArrayController (which works quite well with NSTableView), or create your own. For example, you could use an NSMutableArray as the model, and create a controller that maps the values from the array to other values. This controller could perform the mapping using blocks or some function classes that you define. As you see, there are quite a few options. I'm going to go with the option that requires the least coding: a value transformer, an NSArrayController for the controller and an NSMutableArray (stored in an object that also stores a value transformer) for the model. In the following, code should be stored in files following the standard convention: each interface and implementation is in a separate file with name equal to the class, and an extension of ".h" for interfaces and ".m" for implementation. I also won't bother with the common import statements, such as for Cocoa/Cocoa.h and each class implementation's own interface. First, the value transformer. Actually, there are two, an abstract superclass and a concrete subclass. This separation is so that you can easily add other function types later. The superclass, FunctionTransformer , is very simple. All that needs to be overridden from its base, NSValueTransformer , is the method that returns the class of transformed values, transformedValueClass : @interface FunctionTransformer : NSValueTransformer + (Class)transformedValueClass; @end @implementation Function + (Class)transformedValueClass { return [NSNumber class]; } @end The concrete subclass, LinearTransformer , needs to override the primary method of value transformers: transformedValue: . Since linear transforms are invertible, we'll also provide a reverseTransformedValue: . It will also need properties for the slope and intercept values. #import "FunctionTransformer.h" @interface LinearTransformer : FunctionTransformer { NSNumber *m_; NSNumber *b_; } @property (nonatomic,retain) NSNumber *slope; @property (nonatomic,retain) NSNumber *intercept; + (BOOL)allowsReverseTransformation; -(id)init; -(id)initWithSlope:(float)slope; -(id)initWithIntercept:(float)intercept; -(id)initWithSlope:(float)slope intercept:(float)intercept; -(void)dealloc; -(NSNumber*)transformedValue:(id)value; -(NSNumber*)reverseTransformedValue:(id)value; @end @implementation LinearTransformer @synthesize slope=m_, intercept=b_; +(BOOL)allowsReverseTransformation { return YES; } -(id)initWithSlope:(float)m intercept:(float)b { if ((self = [super init])) { m_ = [[NSNumber alloc] initWithFloat:m]; b_ = [[NSNumber alloc] initWithFloat:b]; } return self; } -(id)init { return [self initWithSlope:1.0 intercept:0.0]; } -(id)initWithSlope:(float)slope { return [self initWithSlope:slope intercept:0.0]; } -(id)initWithIntercept:(float)intercept { return [self initWithSlope:1.0 intercept:intercept]; } -(void)dealloc { [b release]; [m release]; [super dealloc]; } -(NSNumber*)transformedValue:(id)value { return [NSNumber numberWithFloat:([value floatValue] * [m floatValue] + [b floatValue])]; } -(NSNumber*)reverseTransformedValue:(id)value { return [NSNumber numberWithFloat:(([value floatValue] - [b floatValue]) / [m floatValue])]; } @end A specific LinearTransformer needs to be registered to be used so that you can set the slope and intercept. The application delegate could own this transformer (along with the x value collection), or you could write a custom controller. We're going to write a model class that bundles together the x values and the value transformer, named FunctionTable . Setting the function transformer requires a sub tasks: registering the transformer as a value transformer (using +setValueTransformer:forName: ). This means we'll need to provide our own setter ( setF: ) for the function transformer property ( f ). #import "FunctionTransformer.h" extern NSString* const kFunctionTransformer; @interface FunctionTable : NSObject { NSMutableArray *xs; FunctionTransformer *f; } @property (nonatomic,retain) IBOutlet NSMutableArray *xs; @property (nonatomic,retain) IBOutlet FunctionTransformer *f; @end // FunctionTable.m: #import "LinearTransformer.h" NSString* const kFunctionTransformer = @"Function Transformer"; @implementation FunctionTable @synthesize xs, f; -(id) init { if ((self = [super init])) { xs = [[NSMutableArray alloc] init]; self.f = [[LinearTransformer alloc] init]; [f release]; } return self; } -(void)dealloc { [f release]; [xs release]; [super dealloc]; } -(void)setF:(FunctionTransformer *)func { if (func != f) { [f release]; f = [func retain]; [NSValueTransformer setValueTransformer:f forName:kFunctionTransformer]; } } @end By default, FunctionTable uses a LinearTransformer . If you want to use a different one, simply set the FunctionTables 's f property. You could do this in Interface Builder (IB) by using bindings . Note that in this simplistic implementation, the value transformer is always registered under the name "Function Transformer", effectively limiting you to one FunctionTable . A more complex scheme would be to give every FunctionTable their own function transformer name which would be used when registering their own FunctionTransformer . To set everything up: Open the app's main window nib in IB. Instantiate an NSArrayController and a FunctionTable (and your custom app delegate, if any). To the main window, add: Buttons to add and remove elements, labels and NSTextFields for the slope and intercept, an NSTableView. Set the table headers to "x" and "y" (not necessary for app to work) Set up the connections : Have the add & remove buttons send to the NSArrayController's add: and remove: actions. Bind the NSTextFields values to the FunctionTables's f.slope and f.intercept key paths. Bind the values of both columns of the NSTableView to FunctionTables's xs . Set the value transformer for the second column to "Function Transformer" Bind the NSArrayController's content array to the FunctionTable's xs key. If you've got an app delegate, connect it to the File's Owner's delegate outlet. Now build and run. You can use the add and remove buttons to add and remove rows to/from the table. You can edit the "x" and "y" column in a row (the latter is thanks to reverseTransformedValue: ). You can sort by either the "x" or "y" columns. You can change the slope and intercept, though you won't notice the updates in the table unless you select the rows individually. Advanced Topics To fix the table view update problem, we need to propagate changes on one object's (a FunctionTransformer ) properties to changes on another's (a FunctionTable ) properties. We'll have the FunctionTable observe changes on its function transformer's properties and, when it FunctionTable receives a notice that any such property has changed, send a notice that the xs property has changed (which is a bit of an abuse, since xs hasn't actually changed). This is going to get a little magical, so bear with me. An object subscribes to changes on another object using the KVO method addObserver:forKeyPath:options:context: of the other object, and unsubscribes using removeObserver:forKeyPath: . These methods just need to be called, not written. Notifications are handled by a observeValueForKeyPath:ofObject:change:context: method of the observing object, so this method needs to be written. Finally, an object can send its own notifications by calling willChangeValueForKey: and didChangeValueForKey: . Other methods exist to send notifications that only part of a collection has changed, but we won't use them here. Our FunctionTable could handle the change subscription and unsubscription, but then it has to know which properties of the function transformer to observe, which means you couldn't change the type of the transformer. You could add methods to each concrete function transformer to subscribe and unsubscribe an observer: @implementation LinearTransformer ... -(void)addObserver:(NSObject *)observer options:(NSKeyValueObservingOptions)options context:(void *)context { [self addObserver:observer forKeyPath:@"slope" options:options context:context]; [self addObserver:observer forKeyPath:@"intercept" options:options context:context]; } -(void)removeObserver:(id)observer { [self removeObserver:observer forKeyPath:@"slope"]; [self removeObserver:observer forKeyPath:@"intercept"]; } @end However, this will require a fair bit of code repetition in each method and across each concrete function transformer. Using some magic ( reflection and closures , or as they're called in Objective-C, blocks ( [2] )), we can add the methods (named addObserver:options:context: and removeObserver: , as they are functionally similar to the KVO methods for subscribing & unsubscribing) to FunctionTransformer , or even to NSObject . Since observing all properties on an object isn't just limited to FunctionTransformer s, we'll add the methods to NSObject . For this to work, you'll need either OS X 10.6 or PLBlocks and OS X 10.5. Let's start from the top down, with the changes to FunctionTable . There's now new subtasks when setting the function transformer: unsubscribing from changes to the old transformer and subscribing to changes to the new one. The setF: method thus needs to be updated to make use of NSObject 's new methods, which will be defined in a header named "NSObject_Properties.h". Note we don't need to worry about the implementation of these methods yet. We can use them here, having faith that we will write suitable implementations later. FunctionTable also needs a new method to handle change notifications (the observeValueForKeyPath:ofObject:change:context: referred to earlier). #import "NSObject_Properties.h" @interface FunctionTable ... -(void)setF:(FunctionTransformer *)func { if (func != f) { [f removeObserver:self]; [f release]; f = [func retain]; [f addObserver:self options:NSKeyValueObservingOptionPrior context:NULL]; [NSValueTransformer setValueTransformer:f forName:kFunctionTransformer]; } } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (object == f) { if ([[change objectForKey:NSKeyValueChangeNotificationIsPriorKey] boolValue]) { [self willChangeValueForKey:@"xs"]; } else { [self didChangeValueForKey:@"xs"]; } } } Next, we write the new methods on NSObject . The methods to subscribe or unsubscribe from changes will loop over the object's properties, so we'll want a helper method, forEachProperty , to perform the loop. This helper method will take a block that it calls on each property. The subscription and unsubscription methods will simply call forEachProperty , passing a block that calls the standard KVO methods ( addObserver:forKeyPath:options:context: and removeObserver:forKeyPath: ) on each property to add or remove subscriptions. //NSObject_Properties.h #import #import @interface NSObject (Properties) typedef void (^PropertyBlock)(objc_property_t prop, NSString *name); -(void)forEachProperty:(PropertyBlock)block; -(void)addObserver:(id)observer options:(NSKeyValueObservingOptions)options context:(void *)context; -(void)removeObserver:(id)observer; @end // NSObject_Properties.m: ... @implementation NSObject (Properties) -(void)forEachProperty:(PropertyBlock)block { unsigned int propCount, i; objc_property_t * props = class_copyPropertyList([self class], &propCount); NSString *name; for (i=0; i
