[site]: stackoverflow
[post_id]: 3823661
[parent_id]: 
[tags]: 
Show failure for SQL 2005 Job that executes Powershell script through CMD prompt, IF PS script fails

I have a SQL 2005 instance that runs a job that uses a Powershell script to rename the current SQL TX Log backup file by appending "-PrevDay" to it, (subsequently deleting the backup already named "XXX-PrevDay.bak" if it exists), and then run a full backup of the DB and a TX Log backup, if the DB is not in Simple mode. SQL Server Agent Job kicks off the Powershell script through CMD in each job step and the powershell script kicks off the sql backup using "Invoke-SQLCmd" cmdlet. This works great, unless the backup fails, because the SQL job still shows as "Successful". This is because the SQL job that kicks off the Powershell script through the CMD prompt, only cares if the Powershell script runs...not if the commands IN the script actually succeed or fail. Is it possible, using error trapping in powershell (or any method really), to have the powershell script "fail" the cmd prompt action of running the script...so that the SQL Job reports a failure? Does this even make sense? LOL I would assume that if I was able to use SQL 2008, which allows for a SQL job step type of "Powershell Script" (instead of the step type having to be Operating System...that kicks off the PS script) this wouldn't be an issue...however...that's not an option. Right now, the job step runs the powershell script, through CMD using Parameters for DBName, Path, and Servername and looks like this: powershell.exe "C:\SQLBackupScriptsTest\SQLServerBackup.ps1" -DBName 'Angel_Food' -Path 'E:\SQLBackup1' -Server 'DEVSQLSRV' The actual Powershell script looks like this: Param($DBName,$Path,$Server) ## Add sql snapins...must have for Invoke-Sqlcmd with powershell 2.0 ## add-pssnapin sqlserverprovidersnapin100 add-pssnapin sqlservercmdletsnapin100 [reflection.assembly]::LoadWithPartialName("Microsoft.SqlServer.Smo") | out-null ## Set parameter for finding DB recovery model ## $Recovery = (Invoke-Sqlcmd -Query "SELECT recovery_model_desc FROM sys.databases WHERE name = '$DBName'" -Server $Server) ## Do full backup of DB ## (Invoke-Sqlcmd -Query "BACKUP DATABASE $DBName TO DISK = N'$Path\$DBName\$DBName.bak' WITH NOFORMAT, INIT, NAME = N'$DBNameTEST', SKIP, NOREWIND, NOUNLOAD, STATS = 10, CHECKSUM" -Server $Server -ConnectionTimeout 0 -QueryTimeout 65535) ############################################################################################################ ## Check recovery mode, if FULL, check for Log-PrevDay.bak. If exists then delete. If not exist, move on ## ## Then check for Current TX log backup. If exists, rename to Log-PreDay.bak. If not exist, move on ## ## Then perform TX Log backup ## ## If recovery mode NOT FULL, do nothing ## ############################################################################################################ IF ($Recovery.recovery_model_desc -eq 'FULL') #THEN# { ## Look to see if PrevDay TX log exists. If so, delete, if not, move on ## IF (Test-Path $Path\$DBName\$DBName-Log-PrevDay.bak) #THEN# {remove-item $Path\$DBName\$DBName-Log-PrevDay.bak -force} ELSE {} ## Look to see if current TX log exists, if so, rename to Prev Day TX Log, if not, move on ## IF (Test-Path $Path\$DBName\$DBName-Log.bak) #THEN# {rename-item $Path\$DBName\$DBName-Log.bak -newname $DBName-Log-PrevDay.bak -force} ELSE {} Invoke-Sqlcmd -Query "BACKUP LOG $DBName TO DISK = N'$Path\$DBName\$DBName-Log.bak' WITH NOFORMAT, INIT, NAME = N'$DBName LogTEST (Init)', SKIP, NOREWIND, NOUNLOAD, STATS = 10, CHECKSUM" -Server $Server -ConnectionTimeout 0 -QueryTimeout 65535} ELSE {}
