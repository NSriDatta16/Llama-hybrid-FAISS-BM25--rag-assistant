[site]: stackoverflow
[post_id]: 4259292
[parent_id]: 4259099
[tags]: 
I've recently implemented something similar to what you're describing. I began by creating an EventManager class that has a "Publish" and "Subscribe" method. When the system starts up, it scans all the loaded assemblies (libraries) for classes that implement the IEventListener interface: /// /// A class that intends to listen for specific events to be published by an /// event manager. /// /// public interface IEventListener { /// /// Subscribes to the event types that this listener wishes to listen for. /// /// void RegisterSubscriptions(EventManager eventManager); } ... and calls the RegisterSubscriptions method on each of them. (There is only one instance of the EventManager that gets used everywhere; I use dependency injection to bind it as a singleton instance.) RegisterSubscriptions will simply call the Subscribe method for each event type and handler that the given class is intended to handle. (I'm using .NET, so events and handlers are a little easier to work with, but you can do the same thing in Java using anonymous subclasses.) A typical event might be something like RoomEntered, and the arguments associated with this event would include the room ID and maybe some other properties about the room. The game engine publishes this event when the user enters a room, providing the appropriate event arguments for that room, and the EventManager class is then responsible for invoking each handler that has subscribed to that event type. One handler for this event might be "HandleEnterRoomWithMonsters", which checks to see whether the room has monsters, and performs an action accordingly. Does this make sense overall? Do you have any questions about this approach?
