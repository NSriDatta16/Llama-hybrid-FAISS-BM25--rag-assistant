[site]: stackoverflow
[post_id]: 896114
[parent_id]: 
[tags]: 
WPF Drag n drop doesn't fire CommanBinding.CanExecute

Yes, I know it sounds weird, but it doesn't, the question is why, and if there's a work around. It works with everything, even when you hit PrintScreen or Pause keys, CanExecute fires. So after doing a drag drop, in order to make it fire, you have to do "something" else, like a mouse click, focus, hit a key, anything. That'll make the event fire, and allow Execute to happen. Anyway, here's my code, I know it's long, but it'll help you help me. I found this bug in our large main project, so I simplified it to this little app to isolate the problem. XAML: Allow New Allow Save Allow Undo Allow Redo Drag this label... ...here to toggle AllowNew ...here to toggle AllowSave Clear list C#: using System; using System.Windows; using System.Windows.Controls; using System.Windows.Input; namespace DragNDropCommands { /// /// Interaction logic for Window1.xaml /// public partial class Window1 : Window { private CommandControl commandControl = new CommandControl(); private int canExecuteCount = 1; public Window1() { InitializeComponent(); } private void Window_Loaded(object sender, RoutedEventArgs e) { this.DataContext = commandControl; } private void NewCanExecute(object sender, CanExecuteRoutedEventArgs e) { if (this.commandControl == null || listViewLog == null) return; e.CanExecute = this.commandControl.AllowNew; listViewLog.Items.Add ( String.Format ( "{0} - NewCanExecute: {1} - commandControl.AllowNew: {2}", canExecuteCount++, e.CanExecute, commandControl.AllowNew ) ); } private void NewExecuted(object sender, ExecutedRoutedEventArgs e) { MessageBox.Show("New executed"); } private void SaveCanExecute(object sender, CanExecuteRoutedEventArgs e) { if (this.commandControl == null || listViewLog == null) return; e.CanExecute = this.commandControl.AllowSave; listViewLog.Items.Add ( String.Format ( "{0} - SaveCanExecute: {1} - commandControl.AllowSave: {2}", canExecuteCount++, e.CanExecute, commandControl.AllowSave ) ); } private void SaveExecuted(object sender, ExecutedRoutedEventArgs e) { MessageBox.Show("Save executed"); } private void UndoCanExecute(object sender, CanExecuteRoutedEventArgs e) { if (this.commandControl == null || listViewLog == null) return; e.CanExecute = this.commandControl.AllowUndo; listViewLog.Items.Add ( String.Format ( "{0} - UndoCanExecute: {1} - commandControl.AllowUndo: {2}", canExecuteCount++, e.CanExecute, commandControl.AllowUndo ) ); } private void UndoExecuted(object sender, ExecutedRoutedEventArgs e) { MessageBox.Show("Undo executed"); } private void RedoCanExecute(object sender, CanExecuteRoutedEventArgs e) { if (this.commandControl == null || listViewLog == null) return; e.CanExecute = this.commandControl.AllowRedo; listViewLog.Items.Add ( String.Format ( "{0} - RedoCanExecute: {1} - commandControl.AllowRedo: {2}", canExecuteCount++, e.CanExecute, commandControl.AllowRedo ) ); } private void RedoExecuted(object sender, ExecutedRoutedEventArgs e) { MessageBox.Show("Redo executed"); } private void Button_Click(object sender, RoutedEventArgs e) { listViewLog.Items.Clear(); } private void Label_MouseDown(object sender, MouseButtonEventArgs e) { Label label = (Label)sender; if(e.LeftButton == MouseButtonState.Pressed) DragDrop.DoDragDrop(label, label, DragDropEffects.Move); } private void labelDropNew_Drop(object sender, DragEventArgs e) { this.commandControl.AllowNew = !this.commandControl.AllowNew; } private void labelDropSave_Drop(object sender, DragEventArgs e) { this.commandControl.AllowSave = !this.commandControl.AllowSave; } } public class CommandControl : DependencyObject { public bool AllowNew { get { return (bool)GetValue(AllowNewProperty); } set { SetValue(AllowNewProperty, value); } } // Using a DependencyProperty as the backing store for AllowNew. This enables animation, styling, binding, etc... public static readonly DependencyProperty AllowNewProperty = DependencyProperty.Register("AllowNew", typeof(bool), typeof(CommandControl), new UIPropertyMetadata(false)); public bool AllowSave { get { return (bool)GetValue(AllowSaveProperty); } set { SetValue(AllowSaveProperty, value); } } // Using a DependencyProperty as the backing store for AllowSave. This enables animation, styling, binding, etc... public static readonly DependencyProperty AllowSaveProperty = DependencyProperty.Register("AllowSave", typeof(bool), typeof(CommandControl), new UIPropertyMetadata(false)); public bool AllowUndo { get { return (bool)GetValue(AllowUndoProperty); } set { SetValue(AllowUndoProperty, value); } } // Using a DependencyProperty as the backing store for AllowUndo. This enables animation, styling, binding, etc... public static readonly DependencyProperty AllowUndoProperty = DependencyProperty.Register("AllowUndo", typeof(bool), typeof(CommandControl), new UIPropertyMetadata(false)); public bool AllowRedo { get { return (bool)GetValue(AllowRedoProperty); } set { SetValue(AllowRedoProperty, value); } } // Using a DependencyProperty as the backing store for AllowRedo. This enables animation, styling, binding, etc... public static readonly DependencyProperty AllowRedoProperty = DependencyProperty.Register("AllowRedo", typeof(bool), typeof(CommandControl), new UIPropertyMetadata(false)); } } You should be able to just copy paste and do a few name changes (files, namespaces) to get it running. I'd really love your help since this has been driving me nuts, and now that I finally discover the reason for the bug, I don't know what to do about it. Any suggestion is really apreciatted. Thanks in advance.
