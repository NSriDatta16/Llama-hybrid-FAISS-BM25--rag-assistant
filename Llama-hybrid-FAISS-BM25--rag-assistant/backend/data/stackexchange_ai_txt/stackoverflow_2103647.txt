[site]: stackoverflow
[post_id]: 2103647
[parent_id]: 2103079
[tags]: 
Yes, sure. I've done this many times. The problems and solutions are the same whether mixed code is compiled and linked together, or when transmitting struct-formatted data between machines. In the bad old days, this frequently occurred when integrating MS C and almost anything else: Borland Turbo C. DEC VAX C, Greenhills C. The easy part is getting the number of bytes for various data types to agree. For example short on a 32-bit compiler on one side being the same as int on a 16-bit compiler at the other end. Since common source code to declare structures is usually a good thing, a number of to-the-point declarations are helpful: typedef signed long s32; typedef signed short s16; typedef signed char s8; typedef unsigned long u32; typedef unsigned short u16; typedef unsigned char u8; ... Microsoft C is the most annoying. Its default is to pad members to 16-bit alignment, and maybe more with 64-bit code. Other compilers on x86 don't pad members. struct { int count; char type; char code; char data [100]; } variable; It might seem like the offset of code should be the next byte after type , but there might be a padding byte inserted between. The fix is usually #ifdef _MSC_VER // if it's any Microsoft compiler #pragma pack(1) // byte align structure members--that is, no padding #endif There is also a compiler command line option to do the same.
