[site]: stackoverflow
[post_id]: 3194937
[parent_id]: 3193327
[tags]: 
I think that a good approach for you would be to use the solution shown in one of the XtraGrid's tutorials. Please take a look at the Demos\Components\XtraGrid\CS\GridTutorials\GridVirtualData folder. It contains the demo project showing how to effectively work with large data. In this sample, the grid works really fast with collection containing 100000 records. The grid rows are represented by indexes and real values are obtained using property descriptors. Thus, when the grid is loaded, it fetches only rows visible on the screen. When the grid is scrolled, additional data is accessed dynamically. Set the breakpoint in the getter of the object IList.this[int fIndex] property and you will see how smart the grid can be :). To unfreeze the GUI, it is possible to use the Application.DoEvents() method. I see that you are using the MemoEdit to log input messages. It contains the standard multiline TextBox inside and this control works really slow with large content :(. If I understand your task correctly, you've added the editor to allow the end-user copy input messages. If I were you, I would replace the MemoEdit by the XtraGrid. It allows you to copy data to clipboard from several selected records. We have slightly changed the demo project and here is the resulting code we have finally got: List list = new List (); for(int i = 0;i ... public class LogMessage { public LogMessage() { TimeStamp = DateTime.Now; Description = "Message at " + TimeStamp.Ticks.ToString(); } public DateTime TimeStamp; public string Description; } public abstract class LogMessagePropertyDescriptor : PropertyDescriptor { bool fIsReadOnly; public LogMessagePropertyDescriptor(string fPropertyName, bool fIsReadOnly) : base(fPropertyName, null) { this.fIsReadOnly = fIsReadOnly; } public override bool CanResetValue(object component) { return false; } public override bool IsReadOnly {get { return fIsReadOnly; } } public override Type ComponentType { get { return typeof(LogMessage); } } public override void ResetValue(object component) {} public override bool ShouldSerializeValue(object component) { return true; } } public class LogMessageTimeStampPropertyDescriptor: LogMessagePropertyDescriptor { public LogMessageTimeStampPropertyDescriptor(bool fIsReadOnly) : base("TimeStamp", fIsReadOnly) { } public override Type PropertyType {get {return typeof(DateTime); } } public override object GetValue(object component) { LogMessage message = (LogMessage)component; return message.TimeStamp; } public override void SetValue(object component, object val) { LogMessage message = (LogMessage)component; message.TimeStamp = (DateTime)val; } } public class LogMessageDescriptionPropertyDescriptor: LogMessagePropertyDescriptor { public LogMessageDescriptionPropertyDescriptor(bool fIsReadOnly) : base("Description", fIsReadOnly) { } public override Type PropertyType { get { return typeof(string); } } public override object GetValue(object component) { LogMessage message = (LogMessage)component; return message.Description; } public override void SetValue(object component, object val) { LogMessage message = (LogMessage)component; message.Description = (string)val; } } public class VirtualList : IList, ITypedList { PropertyDescriptorCollection fColumnCollection; List messages; public VirtualList(List messages) { this.messages = messages; CreateColumnCollection(); } public int RecordCount { get {return messages.Count; } } public int ColumnCount { get { return fColumnCollection.Count; } } protected virtual void CreateColumnCollection() { List pds = new List (); pds.Add(new LogMessageTimeStampPropertyDescriptor(true)); pds.Add(new LogMessageDescriptionPropertyDescriptor(false)); fColumnCollection = new PropertyDescriptorCollection(pds.ToArray()); } #region ITypedList Interface object IList.this[int fIndex] { get { return messages[fIndex]; } set { } } PropertyDescriptorCollection ITypedList.GetItemProperties(PropertyDescriptor[] descs) { return fColumnCollection; } string ITypedList.GetListName(PropertyDescriptor[] descs) { return ""; } #endregion #region IList Interface public virtual int Count { get { return RecordCount; } } public virtual bool IsSynchronized { get { return true; } } public virtual object SyncRoot { get { return true; } } public virtual bool IsReadOnly{ get { return false; } } public virtual bool IsFixedSize{ get { return true; } } public virtual IEnumerator GetEnumerator() { return null; } public virtual void CopyTo(System.Array array, int fIndex) {} public virtual int Add(object val) { throw new NotImplementedException(); } public virtual void Clear() { throw new NotImplementedException(); } public virtual bool Contains(object val) { throw new NotImplementedException(); } public virtual int IndexOf(object val) { throw new NotImplementedException(); } public virtual void Insert(int fIndex, object val) { throw new NotImplementedException(); } public virtual void Remove(object val) { throw new NotImplementedException(); } public virtual void RemoveAt(int fIndex) { throw new NotImplementedException(); } #endregion }
