[site]: stackoverflow
[post_id]: 4065018
[parent_id]: 4064763
[tags]: 
It does seem possible that this behavior could come from a situation in which there is no leak. Is there any chance that your heap is getting fragmented ? Say you make lots of allocations of size n . You free them all, which makes your C library insert those buffers into a free list. Some other code path then makes allocations smaller than n , so those blocks in the free list get chunked up into smaller units. Then the next iteration of the loop does another batch of allocations of size n , and the free list no longer contains contiguous memory at that size, and malloc has to ask the kernel for more memory. Eventually those "smaller-than- n " allocations get freed as would your " n -sized" ones, but if you run enough iterations where the fragmentation exists, I could see the process gradually increasing its memory footprint. One way to avoid this might be to allocate all your objects once, and not keep allocating/freeing them. Since you're using C++ this might necessitate placement new or something similar. Since you are using Windows, I might also mention that Win32 supports having multiple heaps in a process, so if your objects come from a different heap than other allocations you may avoid this.
