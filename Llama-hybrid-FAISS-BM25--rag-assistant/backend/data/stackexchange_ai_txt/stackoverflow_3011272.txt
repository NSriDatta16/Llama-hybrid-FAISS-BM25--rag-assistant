[site]: stackoverflow
[post_id]: 3011272
[parent_id]: 
[tags]: 
Would it be possible to have a UTF-8-like encoding limited to 3 bytes per character?

UTF-8 requires 4 bytes to represent characters outside the BMP. That's not bad ; it's no worse than UTF-16 or UTF-32. But it's not optimal (in terms of storage space). There are 13 bytes (C0-C1 and F5-FF) that are never used. And multi-byte sequences that are not used such as the ones corresponding to "overlong" encodings. If these had been available to encode characters, then more of them could have been represented by 2-byte or 3-byte sequences (of course, at the expense of making the implementation more complex). Would it be possible to represent all 1,114,112 Unicode code points by a UTF-8-like encoding with at most 3 bytes per character? If not, what is the maximum number of characters such an encoding could represent? By "UTF-8-like", I mean, at minimum: The bytes 0x00-0x7F are reserved for ASCII characters. Byte-oriented find / index functions work correctly. You can't find a false positive by starting in the middle of a character like you can in Shift-JIS. Update -- My first attempt to answer the question Suppose you have a UTF-8-style classification of leading/trailing bytes. Let: A = the number of single-byte characters B = the number of values used for leading bytes of 2-byte characters C = the number of values used for leading bytes of 3-byte characters T = 256 - (A + B + C) = the number of values used for trailing bytes Then the number of characters that can be supported is N = A + BT + CTÂ². Given A = 128, the optimum is at B = 0 and C = 43. This allows 310,803 characters, or about 28% of the Unicode code space. Is there a different approach that could encode more characters?
