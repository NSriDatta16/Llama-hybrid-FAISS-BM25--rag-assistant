[site]: stackoverflow
[post_id]: 3747511
[parent_id]: 3743518
[tags]: 
One of the design goals of git is speed. Consider storing objects in git as deltas rather than unique objects. If you store each unique blob by SHA1 hash, retrieving the content from that SHA1 hash requires only a fixed computation. If you start storing deltas, you will have to reconstruct the object and the computation will no longer be fixed and could increase without bound depending on the implementation. A good way to understand the design is to look at an actual repository (note: emails munged): $ git cat-file commit HEAD tree 21f9601e608cf62360fca43cd7f0bf05bb65bd23 parent 11507e17a7c823c379202ae344aa59fe5370a4fd author John Doe 1273816361 -0400 committer John Doe 1273816361 -0400 Important Work $ git ls-tree HEAD 100644 blob 2f6d9912344c299670551c9e9684a7cae800ec5d .gitignore ... 100644 blob a3ddeb9dd0541b80981f2f78bbc500579a13459a COPYING 040000 tree f1ac0acae2a4ab31c2a79b71f08ebd651136d706 contrib ... You can see from these two commands that a commit is just some metadata, one or more parents and a tree. A tree contains one or more blobs and trees. Knowing, that, you can start to consider the complexity of various repository operations. The tip of a branch is just a pointer to a commit hash. So, starting with that, listing history is just a matter of traversing the parents. Listing the contents of the tree, just means traversing the tree and all subtrees. Retrieving the file contents is as above. Of course, there is always a trade-off, and this model is quite space-inefficient, though it does provide automatic deduplication at the file-level since each unique file only needs to be stored once. This is mitigated effectively with the packfile . Delta storage (used in svn, etc) is more space-efficient without compression, but git ultimately stores more efficiently. To diff commits, you can see that you can start by comparing tree hashes, and then if they don't match, you traverse the tree and compare its blobs and trees, and so on. Since the model is designed around atomic commits, a file diff is more expensive, but not unreasonably so.
