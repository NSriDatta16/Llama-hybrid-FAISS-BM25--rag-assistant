[site]: stackoverflow
[post_id]: 500407
[parent_id]: 500057
[tags]: 
Basically, the statement quoted refers to the problem of resolving the location for insertion and deletion of data elements into and from the heap. In order to maintain "the shape property" of a binary heap, the lowest level of the heap must always be filled from left to right leaving no empty nodes. To maintain the average O(1) insertion and deletion times for the binary heap, you must be able to determine the location for the next insertion and the location of the last node on the lowest level to use for deletion of the root node, both in constant time. For a binary heap stored in an array (with its implicit, compacted data structure as explained in the Wikipedia entry), this is easy. Just insert the newest data member at the end of the array and then "bubble" it into position (following the heap rules). Or replace the root with the last element in the array "bubbling down" for deletions. For heaps in array storage, the number of elements in the heap is an implicit pointer to where the next data element is to be inserted and where to find the last element to use for deletion. For a binary heap stored in a tree structure, this information is not as obvious, but because it's a complete binary tree, it can be calculated. For example, in a complete binary tree with 4 elements, the point of insertion will always be the right child of the left child of the root node. The node to use for deletion will always be the left child of the left child of the root node. And for any given arbitrary tree size, the tree will always have a specific shape with well defined insertion and deletion points. Because the tree is a "complete binary tree" with a specific structure for any given size, it is very possible to calculate the location of insertion/deletion in O(1) time. However, the catch is that even when you know where it is structurally, you have no idea where the node will be in memory. So, you have to traverse the tree to get to the given node which is an O(log n) process making all inserts and deletions a minimum of O(log n), breaking the usually desired O(1) behavior. Any search ("depth-first", or some other) will be at least O(log n) as well because of the traversal issue noted and usually O(n) because of the random nature of the semi-sorted heap. The trick is to be able to both calculate and reference those insertion/deletion points in constant time either by augmenting the data structure ("threading" the tree, as mention in the Wikipedia article) or using additional pointers. The implementation which seems to me to be the easiest to understand, with low memory and extra coding overhead, is to just use a normal simple binary tree structure (using a pRoot and Node defined as [data, pParent, pLeftChild, pRightChild]) and add two additional pointers (pInsert and pLastNode). pInsert and pLastNode will both be updated during the insertion and deletion subroutines to keep them current when the data within the structure changes. This implementation gives O(1) access to both insertion point and last node of the structure and should allow preservation of overall O(1) behavior in both insertion and deletions. The cost of the implementation is two extra pointers and some minor extra code in the insertion/deletion subroutines (aka, minimal). EDIT : added pseudocode for an O(1) insert() Here is pseudo code for an insert subroutine which is O(1), on average: define Node = [T data, *pParent, *pLeft, *pRight] void insert(T data) { do_insertion( data ); // do insertion, update count of data items in tree # assume: pInsert points node location of the tree that where insertion just took place # (aka, either shuffle only data during the insertion or keep pInsert updated during the bubble process) int N = this->CountOfDataItems + 1; # note: CountOfDataItems will always be > 0 (and pRoot != null) after an insertion p = new Node( , null, null, null); // new empty node for the next insertion # update pInsert (three cases to handle) if ( int(log2(N)) == log2(N) ) {# #1 - N is an exact power of two # O(log2(N)) # tree is currently a full complete binary tree ("perfect") # ... must start a new lower level # traverse from pRoot down tree thru each pLeft until empty pLeft is found for insertion pInsert = pRoot; while (pInsert->pLeft != null) { pInsert = pInsert->pLeft; } # log2(N) iterations p->pParent = pInsert; pInsert->pLeft = p; } else if ( isEven(N) ) {# #2 - N is even (and NOT a power of 2) # O(1) p->pParent = pInsert->pParent; pInsert->pParent->pRight = p; } else {# #3 - N is odd # O(1) p->pParent = pInsert->pParent->pParent->pRight; pInsert->pParent->pParent->pRight->pLeft = p; } pInsert = p; // update pLastNode // ... [similar process] } So, insert(T) is O(1) on average: exactly O(1) in all cases except when the tree must be increased by one level when it is O(log N), which happens every log N insertions (assuming no deletions). The addition of another pointer (pLeftmostLeaf) could make insert() O(1) for all cases and avoids the possible pathologic case of alternating insertion & deletion in a full complete binary tree. (Adding pLeftmost is left as an exercise [it's fairly easy].)
