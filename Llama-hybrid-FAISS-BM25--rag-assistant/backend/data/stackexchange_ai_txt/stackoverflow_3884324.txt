[site]: stackoverflow
[post_id]: 3884324
[parent_id]: 3878096
[tags]: 
Memory Node.js' strengths come from its ability to keep a lot of connections open and idle. Where for instance Apache would need a connection limit (sometimes it's as low as 20 concurrent connections, depending on your server environment) because it allocates 2 MB of memory to each connection, Node.js doesn't need that. Apache also doesn't like keeping connections open because of this problem, and keeping connections open becomes a hassle. A node app is programmed as a single thread (though in the background it uses threads for various blocking operations, but not on a per-connection basis). If you've programmed in Erlang you may know how liberating it is to not having to care about what the other agents (or connections) are doing, while still being able to share data between the (virtual) instances without any extra effort. In theory Node can handle as many connections as the max number of file descriptors/sockets allowed on your system. In windows (using cygwin) this is about 65536, and on unix i bet more is possible, though unlimited in theory (with the server end on port 80, 65536 connections can be handled to each destination). In Apache this would cause a memory allocation problem long before hitting even 2000 users. In reality these are just numbers, and they are affected by a bunch of other things, such as how much data can your app actually handle passing through to a given subset (or even all) of the connections. The more realistic estimate is that it can handle 20-25.000 users with average activity without any significant lag. The only pure single-server setup i know that can handle this many concurrent users is an IRC server programmed in C, though there are probably a few web servers too (like nginx) that could deal with it. Performance Node uses Google's V8 JavaScript engine, meaning that it's fast and getting even faster every week. An advantage of Node is that it uses asynchronous I/O, so that when one user has to wait for a file to be read from disk or a database call, node puts that in the background (remember i said it uses threads in the background) and let's that wait, while in the main thread it moves on to the next task. This makes sure that it always keeps moving . Even if any given user may have a slight delay, the others aren't held up by it. socket.io This is the library to use for your communication. You can find out more on http://socket.io It also comes with a chat example that is so easy, you can't help feeling that it's awesome. Oh, and remember to try Node for yourself and make a decision based on that. It's not great for everything, but it's a good choice for a lot of things.
