[site]: stackoverflow
[post_id]: 3153760
[parent_id]: 3153483
[tags]: 
Ideally the data accessible to the controller should be passed as parameter to model methods. So I advise you to see if it is possible to rewrite your code. But here are two possible solutions to your problem. I prefer the later approach as it is generic. Approach 1: Declare a virtual attribute class CardSignup attr_accessor call_context def call_context @call_context || {} end end In your controller code: def create cs = CardSignup.new(...) cs.call_context = params if cs.save # success else # error end end In your CardSignup model: def credit_status_on_create Organization.find(self.organization_id).update_credits(call_context) end Update the Organization model. Note the change to your count logic. def update_credits @organization = Organization.find(call_context[:id]) credit_count = @organization.card_signups.count(:conditions => {:credit_status => true}) end Approach 2: Declare a thread local variable accessible to all models Your controller code: def create Thread.local[:call_context] = params cs = CardSignup.new(...) if cs.save # success else # error end end Update the Organization model. Note the change to your count logic. def update_credits @organization = Organization.find((Thread.local[:call_context] ||{})[:id]) credit_count = @organization.card_signups.count(:conditions => {:credit_status => true}) end
