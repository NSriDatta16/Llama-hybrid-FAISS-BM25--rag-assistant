[site]: stackoverflow
[post_id]: 1418829
[parent_id]: 
[tags]: 
Help Needed Creating a Binary Tree Given Truth Table

First, in order to provide full disclosure, I want to point out that this is related to homework in a Machine Learning class. This question is not the homework question and instead is something I need to figure out in order to complete the bigger problem of creating an ID3 Decision Tree Algorithm. I need to generate tree similar to the following when given a truth table let learnedTree = Node(0,"A0", Node(2,"A2", Leaf(0), Leaf(1)), Node(1,"A1", Node(2,"A2", Leaf(0), Leaf(1)), Leaf(0))) learnedTree is of type BinaryTree which I've defined as follows: type BinaryTree = | Leaf of int | Node of int * string * BinaryTree * BinaryTree ID3 algorithms take into account various equations to determine where to split the tree, and I've got all that figured out, I'm just having trouble creating the learned tree from my truth table. For example if I have the following table A1 | A2 | A3 | Class 1 0 0 1 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 1 1 0 1 0 1 1 0 And I decide to split on attribute A1 I would end up with the following: (A1 = 1) A1 (A1 = 0) A2 | A3 | Class A2 | A3 | Class 0 0 1 1 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 1 1 Then I would split the left side and split the right side, and continue the recursive pattern until the leaf nodes are pure and I end up with a tree similar to the following based on the splitting. let learnedTree = Node(0,"A0", Node(2,"A2", Leaf(0), Leaf(1)), Node(1,"A1", Node(2,"A2", Leaf(0), Leaf(1)), Leaf(0))) Here is what I've kind of "hacked" together thus far, but I think I might be way off: let rec createTree (listToSplit : list >) index = let leftSideSplit = listToSplit |> List.choose (fun x -> if x.Item(index) = 1. then Some(x) else None) let rightSideSplit = listToSplit |> List.choose (fun x -> if x.Item(index) = 0. then Some(x) else None) if leftSideSplit.Length > 0 then let pureCheck = isListPure leftSideSplit if pureCheck = 0 then printfn "%s" "Pure left node class 0" createTree leftSideSplit (index + 1) else if pureCheck = 1 then printfn "%s" "Pure left node class 1" createTree leftSideSplit (index + 1) else printfn "%s - %A" "Recursing Left" leftSideSplit createTree leftSideSplit (index + 1) else printfn "%s" "Pure left node class 0" Should I be using pattern matching instead? Any tips/ideas/help? Thanks a bunch!
