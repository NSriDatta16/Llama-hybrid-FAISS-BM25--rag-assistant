[site]: stackoverflow
[post_id]: 5599526
[parent_id]: 3953910
[tags]: 
UPDATE - I've written a more generic example (plus a link to a zip file containing the entire VS2008 project) as entry on my blog here. Sorry, I am so late to the game, but here is how I have integrated IronPython into a C++/cli app in Visual Studio 2008 - .net 3.5. (actually mixed mode app with C/C++) I write add-ons for a map making applicaiton written in Assembly. The API is exposed so that C/C++ add-ons can be written. I mix C/C++ with C++/cli. Some of the elements from this example are from the API (such as XPCALL and CmdEnd() - please just ignore them) /////////////////////////////////////////////////////////////////////// void XPCALL PythonCmd2(int Result, int Result1, int Result2) { if(Result==X_OK) { try { String^ filename = gcnew String(txtFileName); String^ path = Assembly::GetExecutingAssembly()->Location; ScriptEngine^ engine = Python::CreateEngine(); ScriptScope^ scope = engine->CreateScope(); ScriptSource^ source = engine->CreateScriptSourceFromFile(String::Concat(Path::GetDirectoryName(path), "\\scripts\\", filename + ".py")); scope->SetVariable("DrawingList", DynamicHelpers::GetPythonTypeFromType(AddIn::DrawingList::typeid)); scope->SetVariable("DrawingElement", DynamicHelpers::GetPythonTypeFromType(AddIn::DrawingElement::typeid)); scope->SetVariable("DrawingPath", DynamicHelpers::GetPythonTypeFromType(AddIn::DrawingPath::typeid)); scope->SetVariable("Node", DynamicHelpers::GetPythonTypeFromType(AddIn::Node::typeid)); source->Execute(scope); } catch(Exception ^e) { Console::WriteLine(e->ToString()); CmdEnd(); } } else { CmdEnd(); } } /////////////////////////////////////////////////////////////////////////////// As you can see, I expose to IronPython some objects (DrawingList, DrawingElement, DrawingPath & Node). These objects are C++/cli objects that I created to expose "things" to IronPython. When the C++/cli source->Execute(scope) line is called, the only python line to run is the DrawingList.RequestData. RequestData takes a delegate and a data type. When the C++/cli code is done, it calls the delegate pointing to the function "diamond" In the function diamond it retrieves the requested data with the call to DrawingList.RequestedValue() The call to DrawingList.AddElement(dp) adds the new element to the Applications visual Database. And lastly the call to DrawingList.EndCommand() tells the FastCAD engine to clean up and end the running of the plugin. import clr def diamond(Result1, Result2, Result3): if(Result1 == 0): dp = DrawingPath() dp.drawingStuff.EntityColor = 2 dp.drawingStuff.SecondEntityColor = 2 n = DrawingList.RequestedValue() dp.Nodes.Add(Node(n.X-50,n.Y+25)) dp.Nodes.Add(Node(n.X-25,n.Y+50)) dp.Nodes.Add(Node(n.X+25,n.Y+50)) dp.Nodes.Add(Node(n.X+50,n.Y+25)) dp.Nodes.Add(Node(n.X,n.Y-40)) DrawingList.AddElement(dp) DrawingList.EndCommand() DrawingList.RequestData(diamond, DrawingList.RequestType.PointType) I hope this is what you were looking for.
