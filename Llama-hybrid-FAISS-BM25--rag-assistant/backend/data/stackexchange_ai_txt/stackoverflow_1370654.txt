[site]: stackoverflow
[post_id]: 1370654
[parent_id]: 1369314
[tags]: 
You should look into whether or not UIScrollView's contentOffset property is animatable using UIView animation blocks. If it's not, then you could try using an NSTimer and in its function, either set the contentOffset or call [scrollView scrollRectToVisible:desiredContentFrame animated:YES]; where desiredContentFrame.origin.y is just a little bit lower than what you previously had it at (depending on the scroll speed you want). Then play around with the firing frequency of your timer and the desiredContentFrame.origin.y's delta to see what looks best and has the best performance. Here's a quick hack showing both ways: - (void)startAnimTimer { currentRect = CGRectMake(0, 0, 1, 1); [NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(doScroll) userInfo:nil repeats:YES]; } - (void)startAnimUIView { [UIView beginAnimations:@"scrollUIViewAnim" context:nil]; [UIView setAnimationDuration:20.0]; [UIView setAnimationCurve:UIViewAnimationCurveLinear]; CGPoint newContentOffset = CGPointMake(0, scrollView.contentSize.height); scrollView.contentOffset = newContentOffset; [UIView commitAnimations]; } - (void)loadView { [super loadView]; self.scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(5, 5, 200, 200)]; scrollView.contentSize = CGSizeMake(200, 1000); scrollView.backgroundColor = [UIColor magentaColor]; CGFloat y = 10; CGFloat yDelta = 21; for(int i = 0; i
