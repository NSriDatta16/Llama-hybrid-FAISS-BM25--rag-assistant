[site]: stackoverflow
[post_id]: 3561173
[parent_id]: 3561137
[tags]: 
Wow, two questions in one day that can be solved via Cartesian products. Amazing. You can use Eric Lippert's LINQ snippet to generate all combinations of the index values. This approach results in a streaming set of values, so they don't require storage in memory. This approach nicely separates the logic of generating the codes from maintaining state or performing computation with the code. Eric's code for all combinations: static IEnumerable > CartesianProduct (this IEnumerable > sequences) { IEnumerable > emptyProduct = new[] { Enumerable.Empty () }; return sequences.Aggregate( emptyProduct, (accumulator, sequence) => from accseq in accumulator from item in sequence select accseq.Concat(new[] {item})); } You can now write: public static IEnumerable AllCodes() { char[] characters = {a, b, c... z}; IEnumerable codeSets = new[] { characters, characters, characters }; foreach( var codeValues in codeSets.CartesianProduct() ) { yield return string.Format( "{0}{1}{2}", codeValues[0], codeValues[1], codeValues[2]); } } The code above generates a streaming sequence of all code strings from aaa to zzz . You can now use this elsewhere where you perform your processing: foreach( var code in AllCodes() ) { // use the code value somehow... }
