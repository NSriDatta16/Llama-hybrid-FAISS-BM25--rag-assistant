[site]: stackoverflow
[post_id]: 720275
[parent_id]: 720244
[tags]: 
Your Server constructor blocks, potentially indefinitely, in accept() . Two things about Swing programs: Never do any long task in the Swing event thread, and, Never do manipulate any Swing object outside the Swing event thread unless the method being used is explicitly documented as thread-safe. This means that if the server is being started from the Swing event thread -- that is, if it is being started in response to a button click or the like -- then yes you must spawn another thread for your Server object. Otherwise you guarantee that the Swing event thread will be blocked until your thread exits. You say that your application still stops responding even when you spawn another thread for your server? Ensure that you're calling Thread.start() and not run() , or you will accidentally still block yourself by running the "new Thread" actually in your own Thread. NOTES: I see that you do a Thread.sleep(0); in your run() loop. This is not guaranteed to do anything whatsoever. If you have a single CPU machine, this may be fairly be implemented as a no-op, allowing the same thread to keep running. You really want isConnected to be volatile -- otherwise there is no guarantee that changes to this variable will be seen by any thread other than the one where it is changed. You don't set isConnected to false, anywhere, so your run() will run until the JVM is stopped or until that Thread takes a RuntimeException. It is discouraged to start Threads in constructors. (See Java Concurrency In Practice .) You don't want to accept on your ServerSocket until you are in your Thread's run() method! Otherwise your constructor will block waiting for a connection and will not return control to the event thread! You have the following code in your constructor: your code is: thread = new Thread(this); thread.setDaemon(true); //thread.run(); When you had thread.run() not commented out, you were not starting a new Thread! To do that, you need to do thread.start() . Instead, you were running this new Thread (which will never stop, for reason #3 above) in the same thread that invoked the constructor. The way your code is written right now, all IOExceptions are logged, but otherwise swallowed. You probably want to set isConnected to false on any IOException , as well as in closeConnection() .
