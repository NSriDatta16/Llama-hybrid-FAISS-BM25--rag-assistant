[site]: stackoverflow
[post_id]: 332619
[parent_id]: 318590
[tags]: 
I don't really recommend this design as a pragmatic approach in your situation but as a possible solution for this kind of domain it is probably quite interesting. If you were to implement your differential solver as a collection of immutable classes which are created and then have some convenient arg-less 'compute()' method to call which computes the value associated with that class using the instances variables and stores and returns the answer. You would then be able to build a caching mechanism into each class so that you did not have to re-evaluate the answer if you had already computed it for the same arguments. I'm afraid that I don't know C++ syntax so I'll use Java instead. public class ValuePlusOne implements Computable { private int value; private int result; private Boolean hasRun; private static Map instanceMap = new HashMap(); // Creates an instance reusing an existing one if possible public static getInstance(int value) { ValuePlusOne instance = (ValuePlusOne)instanceMap.get(value); if (instance = null) { instance = new ValuePlusOne(value); instanceMap.put(value,instance); } return instance; } // Private constructor private ValuePlusOne(int value) { this.value = value; hasRun = false; } // Computes (if not already computed) and returns the answer public int compute() { if (!hasRun) { hasRun = true; result = value + 1; } return result; } } This means that you will be able to invisibly reuse any computations that you have done before. This will only give you a speed up if you are often redoing calculations with the same arguments and in the (approximately) continuous domain of differentials this may occur very infrequently. This approach also lends itself to parallelisation but requires modification for that to be safe. Unless that caching offered real benefits I would prefer to use the flat C-style procedural approach. Anyone will be able to read and understand your code easily with stateless data-in data-out methods.
