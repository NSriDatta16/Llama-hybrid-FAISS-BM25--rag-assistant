[site]: stackoverflow
[post_id]: 5163527
[parent_id]: 5163107
[tags]: 
The answer depends on what you are trying to test. The example sounds like something out of cucumber, but you used the term BDD. I associate BDD with bottom-up unit testing. If that is the case, lets assume you have an authentication class of some sort, and a user class. User class: public class User : IUser { public int ID { get; set; } public string Name { get; set; } public string Password { get; set; } } public interface IUser { int ID { get; } string Name { get; } string Password { get; } } Authenticator Class: public class Authenticator : IAuthenticator { public Authenticator() { //Initialize and acquire some authentication mechanism (db, service, file, etc..) } public bool IsLoggedIn(IUser user) { return true; } public bool LoginUser(IUser user) { //Do real login. return true; } public bool LogoutUser(IUser user) { //Do real logout. return true; } } public interface IAuthenticator { bool LoginUser(IUser user); bool LogoutUser(IUser user); } UserActions class for calling the authenticator, managing permissions, etc: public class UserActions { private readonly IAuthenticator _authenticator; private readonly IUser _user; //private Permissions Permissions; public UserActions(IUser user) : this(new Authenticator(), user) { } public UserActions(IAuthenticator authenticator, IUser user) { _authenticator = authenticator; _user = user; } public bool Login() { var result = _authenticator.LoginUser(_user); return result; } public void Logout() { _authenticator.LogoutUser(_user); } } With these classes, I would try to test the behavior (using NUnit and MOQ) of the UserActions class in regards to logging in and logging out. In this example, no work is done, but for the sake of example, imagine a fuller implementation: [TestFixture] public class Tester { [Test] public void CanLoginGoodUser() { IUser user = new User { ID = 1, Name = "Test1", Password = "good" }; var authenticator = new Mock (); authenticator.Setup(a => a.LoginUser(user)).Returns(true); var action = new UserActions(authenticator.Object, user); action.Login(); authenticator.Verify(a => a.LoginUser(It.Is (u => u == user)), Times.AtLeastOnce()); } [Test] public void WontLoginBadUser() { IUser user = new User { ID = 1, Name = "Test1", Password = "bad" }; var authenticator = new Mock (); authenticator.Setup(a => a.LoginUser(user)).Returns(false); var action = new UserActions(authenticator.Object, user); action.Login(); authenticator.Verify(a => a.LoginUser(It.Is (u => u == user)), Times.AtLeastOnce()); } } I don't actually login, or logout. What I do is leverage the interface to provide canned responses that show how the class behaves when it interacts with the classes that it consumes. In this case its the authenticator and user objects. Notice that I didn't mock the user class, because, at this point, there is no need. I'm sure other people will disagree with this approach, but this is what I currently do. It works well for me in the sense that it allows for bottom-up testing, solid code coverage, and separation concerns with my class design.
