[site]: stackoverflow
[post_id]: 3852403
[parent_id]: 3851642
[tags]: 
The problem is here: $(list).find("a:not(:Contains(" + filter + "))").parent().slideUp(); $(list).find("a:Contains(" + filter + ")").parent().slideDown(); Since you're rendering this: divInfo.innerHTML += ' '+friends[i].name +' '; There is no anchor wrapper, the text is directly in the so change the first two lines to look in those elements accordingly, like this: $(list).find("li:not(:Contains(" + filter + "))").slideUp(); $(list).find("li:Contains(" + filter + ")").slideDown(); You could also make that whole section a bit faster by running your Contains() code only once, making a big pact for long lists, like this: $(input).bind("change keyup", function () { var filter = $(this).val(); if(filter) { var matches = $(list).find("li:Contains(" + filter + ")").slideDown(); $(list).find("li").not(matches).slideUp(); } else { $(list).find("li").slideDown(); } }); And to resolve those potential (likely really) innerHTML issues, build your structure by using the DOM, like this: function getFriends(){ var theword = '/me/friends'; FB.api(theword, function(response) { var divInfo = $("#divInfo"), friends = response.data; divInfo.append(' Friends/h1>'); var list = $(' '); for (var i = 0; i ', { text: friends[i].name }).appendTo(list); } divInfo.append(list); }); } By doing it this way you're building your content all at once, the being a document fragment, then one insertion....this is also better for performance for 2 reasons. 1) You're currently adding invalid HTML with the .innerHTML calls...you should never have an unclosed element at any point, and 2) you're doing 2 DOM manipulations (1 for the header, 1 for the list) after the much faster document fragment creation, not repeated .innerHTML changes.
