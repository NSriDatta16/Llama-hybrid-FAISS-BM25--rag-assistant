[site]: stackoverflow
[post_id]: 3771784
[parent_id]: 
[tags]: 
Struct containing std::string being passed to lua

I have working C++ code using swig which creates a struct, passes it to lua (essentially by reference), and allows manipulation of the struct such that the changes made in the lua code remain once I've returned to the C++ function. This all works fine until I add a std::string to the struct, as shown here: struct stuff { int x; int y; std::string z; }; I'm unable to modify the std::string because it's apparently passed as a const reference. If I attempt to assign a value to this string in my lua function I get this error: Error in str (arg 2), expected 'std::string const &' got 'string' What is the proper way to address this problem? Do I have to write some custom C++ function to set z rather than using normal syntax like obj.z = "hi" ? Is there some way to allow this assignment using swig? The C++ code is #include #include extern "C" { #include "lua.h" #include "lualib.h" #include "lauxlib.h" } #include "example_wrap.hxx" extern int luaopen_example(lua_State* L); // declare the wrapped module int main() { char buff[256]; const char *cmdstr = "print(33)\n"; int error; lua_State *L = lua_open(); luaL_openlibs(L); luaopen_example(L); struct stuff b; b.x = 1; b.y = 2; SWIG_NewPointerObj(L, &b, SWIGTYPE_p_stuff, 0); lua_setglobal(L, "b"); while (fgets(buff, sizeof(buff), stdin) != NULL) { error = luaL_loadbuffer(L, buff, strlen(buff), "line") || lua_pcall(L, 0, 0, 0); if (error) { fprintf(stderr, "%s", lua_tostring(L, -1)); lua_pop(L, 1); /* pop error message from the stack */ } } printf("B.y now %d\n", b.y); printf("Str now %s\n", b.str.c_str()); luaL_dostring(L, cmdstr); lua_close(L); return 0; }
