[site]: stackoverflow
[post_id]: 755997
[parent_id]: 755044
[tags]: 
One thing you can do is stop type-casting interfaces . You don't need to do it to go from IDerived to IBase , and you don't need it to go from IBase to IUnknown , either. Any reference to an IDerived is an IBase already, so you can call IBase methods even without type-casting. If you do less type-casting, you let the compiler do more work for you and catch things that aren't sound. Your stated goal is to be able to check that the thing you're getting out of your list really is an IBase reference. Adding IBase as an implemented interface would allow you to achieve that goal easily. In that light, your "two major reasons" for not doing that don't hold any water. "I want to be able to compare references for equality": No problem. COM requires that if you call QueryInterface twice with the same GUID on the same object, you get the same interface pointer both times. If you have two arbitrary interface references, and you as -cast them both to IBase , then the results will have the same pointer value if and only if they are backed by the same object. Since you seem to want your list to only contain IBase values, and you don't have Delphi 2009 where a generic TInterfaceList would be helpful, you can discipline yourself to always explicitly add IBase values to the list, never values of any descendant type. Whenever you add an item to the list, use code like this: List.Add(Item as IBase); That way, any duplicates in the list are easy to detect, and your "hard casts" are assured to work. "It doesn't actually solve the problem": But it does, given the rule above. Assert(Supports(List[i], IBase)); When the object explicitly implements all its interfaces, you can check for things like that. And if you've added items to the list like I described above, it's safe to disable the assertion. Enabling the assertion lets you detect when someone has changed code elsewhere in your program to add an item to the list incorrectly. Running your unit tests frequently will let you detect the problem very soon after it's introduced, too. With the above points in mind, you can check that anything that was added to the list was added correctly with this code: var AssertionItem: IBase; Assert(Supports(List[i], IBase, AssertionItem) and (AssertionItem = List[i])); // I don't recall whether the compiler accepts comparing an IBase // value (AssertionItem) to an IUnknown value (List[i]). If the // compiler complains, then simply change the declaration to // IUnknown instead; the Supports function won't notice. If the assertion fails, then either you added something to the list that doesn't support IBase at all, or the specific interface reference you added for some object cannot serve as the IBase reference. If the assertion passes, then you know that List[i] will give you a valid IBase value. Note that the value added to the list doesn't need to be an IBase value explicitly. Given your type declarations above, this is safe: var A: IDerived; begin A := TImplementation.Create; List.Add(A); end; That's safe because the interfaces implemented by TImplementation form an inheritance tree that degenerates to a simple list. There are no branches where two interfaces don't inherit from each other but have a common ancestor. If there were two decendants of IBase , and TImplementation implemented them both, the above code wouldn't be valid because the IBase reference held in A wouldn't necessarily be the "canonical" IBase reference for that object. The assertion would detect that problem, and you'd need to add it with List.Add(A as IBase) instead. When you disable assertions, the cost of getting the types right is paid only while adding to the list, not while reading from the list. I named the variable AssertionItem to discourage you from using that variable elsewhere in the procedure; it's there only to support the assertion, and it won't have a valid value once assertions are disabled.
