[site]: stackoverflow
[post_id]: 5240304
[parent_id]: 5240267
[tags]: 
I believe this is all defined behavior that will continue to work on any implementation. Looking at the various documentation for valarray, it looks like it has to be legal in order for all the other things about ::std::valarray to hold true. The bare pointers to the elements should remain perfectly valid until the resize member function is called or the valarray is destroyed. The only real question is whether or not valarray is required to hold its elements contiguously or not. And I found the answer to that question in a post . I'll excerpt it here: Yes, valarray also uses contiguous storage. The specific wording from the standard is ($26.3.2.3/3): The expression &a[i+j] == &a[i] + j evaluates as true for all size_t i and size_t j such that i+j is less than the length of the non-constant array a. Of course, slices still won't be able to be used directly with the standard algorithms, though creating a slice iterator shouldn't be too hard. It'd be pretty easy to make a bidirectional one, but much harder (lots of tricky math you have to get exactly right) to create a random access iterator. The difference between two pointers becomes (as someone else said) ::std::ptrdiff_t . This will be a different type on different platforms. I use gcc under 64-bit Fedora 14, and the type is long for me. There is no overhead in this 'type conversion'. It isn't even a conversion really. The compiler just does the subtraction as if the two pointers were plain old numbers and the result is a plain old number of some type. The use of ::std::ptrdiff_t for the type is to ensure that the type of number used is big enough to hold the difference between any two pointers in the system.
