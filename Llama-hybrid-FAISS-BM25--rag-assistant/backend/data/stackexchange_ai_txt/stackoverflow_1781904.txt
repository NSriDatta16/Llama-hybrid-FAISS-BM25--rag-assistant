[site]: stackoverflow
[post_id]: 1781904
[parent_id]: 1779859
[tags]: 
Did you mean something like this? let myActions = [fun () -> printfn "You've woken up a dragon." fun () -> printfn "You hit the dragon for 0 points of damage." fun () -> printfn "The dragon belches." fun () -> printfn "You have died."] let actionBuilder actionList = let actions = ref actionList fun () -> match !actions with | [] -> () | h::t -> h(); actions := t Usage (F# interactive): > let doSomething = actionBuilder myActions;; val doSomething : (unit -> unit) > doSomething();; You've woken up a dragon. val it : unit = () > doSomething();; You hit the dragon for 0 points of damage. val it : unit = () > doSomething();; The dragon belches. val it : unit = () > doSomething();; You have died. val it : unit = () > doSomething();; val it : unit = () > **Edit: ** if you want to be able to add actions, maybe it's better to make an action dispenser that uses a Queue internally, since appending is O(N) with a list and O(1) with a Queue: type actionGenerator(myActions: (unit->unit) list) = let Q = new System.Collections.Generic.Queue (Seq.ofList myActions) member g.NextAction = fun () -> if Q.Count = 0 then () else Q.Dequeue()() member g.AddAction(action) = Q.Enqueue(action)
