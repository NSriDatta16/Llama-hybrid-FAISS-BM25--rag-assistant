[site]: stackoverflow
[post_id]: 852394
[parent_id]: 852334
[tags]: 
You need to use structs and or unions. You'll need to make sure your data is properly packed on both sides of the connection and you may want to translate to and from network byte order on each end if there is any chance that either side of the connection could be running with a different endianess. As an example: #pragma pack(push) /* push current alignment to stack */ #pragma pack(1) /* set alignment to 1 byte boundary */ typedef struct { unsigned int packetID; // identifies packet in one direction unsigned int data_length; char receipt_flag; // indicates to ack packet or keep sending packet till acked char data[]; // this is typically ascii string data w/ \n terminated fields but could also be binary } tPacketBuffer ; #pragma pack(pop) /* restore original alignment from stack */ and then when assigning: packetBuffer.packetID = htonl(123456); and then when receiving: packetBuffer.packetID = ntohl(packetBuffer.packetID); Here are some discussions of Endianness and Alignment and Structure Packing If you don't pack the structure it'll end up aligned to word boundaries and the internal layout of the structure and it's size will be incorrect.
