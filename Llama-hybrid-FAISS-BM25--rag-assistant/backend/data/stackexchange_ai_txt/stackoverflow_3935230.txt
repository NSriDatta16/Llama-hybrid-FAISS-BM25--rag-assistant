[site]: stackoverflow
[post_id]: 3935230
[parent_id]: 3934100
[tags]: 
Uhm, how about something along the lines of a binary search tree? To put comparison in pseudocode: position1 > position2 := (position1.x > position2.x) || ((position1.x == position2.x) && (position1.y > position2.y)) list1.x > list2.x := { for (i in 0...n) if (list1[i] > list2[i]) return true; else if (list1[i] > list2[i]) return false; return false; } where n of course is the length of the lists. I'm not much of a java-pro and I really don't know the standard library, but I suppose, you could just write the tree yourself. Implement a getID-method, that'll try to find this list or insert it otherwise and along with it a unique id, which you can obtain by simply incrementing a counter. That way, you get an ID (instead of a hash), that has no collisions, whatsoever. In worst case comparing 2 lists is O(n) , thus a find/insert is O(n) * O(log(m)) (supposing the tree is balanced) where m is the overall number of all lists. Determining an ID is thus more expensive than hashing, in worst case, but as said, the result is guaranteed to be unique. I can say little about average, since you give no numbers. Actually I am surprised you do not want to make a direct comparison, since I'd expect the probability for 2 positions to be equal is less than 1%, thus a list comparison is about O(1), since the probability that you need to compare 5 entries is really small. Also, it is not clear, whether the lists are mutable or not, since if they are immutable, the cost should be of little importance.
