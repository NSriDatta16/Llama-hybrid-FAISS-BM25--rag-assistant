[site]: stackoverflow
[post_id]: 4249030
[parent_id]: 
[tags]: 
Load javascript async, then check DOM loaded before executing callback

Problem: Load js files asynchronously, then check to see if the dom is loaded before the callback from loading the files is executed. edit: We do not use jQuery; we use Prototype. edit: added more comments to the code example. I am trying to load all of my js files asynchronously so as to keep them from blocking the rest of the page. But when the scripts load and the callback is called, I need to know if the DOM has been loaded or not, so I know how to structure the callback. See below: //load asynchronously (function(){ var e = document.createElement('script'); e.type = "text/javascript"; e.async = true; e.src = srcstr; // a little magic to make the callback happen if(navigator.userAgent.indexOf("Opera")){ e.text = "initPage();"; }else if(navigator.userAgent.indexOf("MSIE")){ e.onreadystatechange = initPage; }else{ e.innerHTML = "initPage();"; } // attach the file to the document document.getElementsByTagName('head')[0].appendChild(e); })(); initPageHelper = function(){ //requires DOM be loaded } initPage = function(){ if(domLoaded){ // if dom is already loaded, just call the function initPageHelper(); }else{ //if dom is not loaded, attach the function to be run when it does load document.observe("dom:loaded", initPageHelper); } } The callback gets called properly due to some magic behind the scenes that you can learn about from this Google talk: http://www.youtube.com/watch?v=52gL93S3usU&feature=related What's the easiest, cross-browser method for asking if the DOM has loaded already? EDIT Here's the full solution I went with. I included prototype and the asynchronous script loader using the normal method. Life is just so much easier with prototype, so I'm willing to block for that script. And actually, in my code I minified the two files above and put them together into one file to minimize transfer time and http requests. Then I define what I want to run when the DOM loads, and then call the function to load the other scripts. initPage = function(){ ... } loadScriptAsync("scriptaculous/scriptaculous.js", initPage); loadScriptAsync("scriptaculous/effects.js", initPage); loadScriptAsync("scriptaculous/controls.js", initPage); ... loadScriptAsync("mypage.js", initPage); Likewise, the requests above are actually compressed into one httpRequest using a minifier. They are left separate here for readability. There is a snippet at the bottom of this post showing what the code looks like with the minifier. The code for asyncLoader.js is the following: /** * Allows you to load js files asynchronously, with a callback that can be * called immediately after the script loads, OR after the script loads and * after the DOM is loaded. * * Prototype.js must be loaded first. * * For best results, create a regular script tag that calls a minified, combined * file that contains Prototype.js, and this file. Then all subsequent scripts * should be loaded using this function. * */ var onload_queue = []; var dom_loaded = false; function loadScriptAsync(src, callback, run_immediately) { var script = document.createElement('script'); script.type = "text/javascript"; script.async = true; script.src = src; if("undefined" != typeof callback){ script.onload = function() { if (dom_loaded || run_immediately) callback(); else onload_queue.push(callback); // clean up for IE and Opera script.onload = null; script.onreadystatechange = null; }; script.onreadystatechange = function() { if (script.readyState == 'complete'){ if (dom_loaded || run_immediately) callback(); else onload_queue.push(callback); // clean up for IE and Opera script.onload = null; script.onreadystatechange = null; }else if(script.readyState == 'loaded'){ eval(script); if (dom_loaded || run_immediately) callback(); else onload_queue.push(callback); // clean up for IE and Opera script.onload = null; script.onreadystatechange = null; } }; } var head = document.getElementsByTagName('head')[0]; head.appendChild(script); } document.observe("dom:loaded", function(){ dom_loaded = true; var len = onload_queue.length; for (var i = 0; i I added the option to run a script immediately, if you have scripts that don't rely on the page DOM being fully loaded. The minified requests actually look like: initPage = function(e){...} srcstr = "/min/?f= "; loadScriptAsync(srcstr, initPage); They are using the plugin from: [ http://code.google.com/p/minify/][1]
