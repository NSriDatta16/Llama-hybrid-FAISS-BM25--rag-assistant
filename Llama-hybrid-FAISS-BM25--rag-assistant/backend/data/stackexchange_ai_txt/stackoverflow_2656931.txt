[site]: stackoverflow
[post_id]: 2656931
[parent_id]: 2656920
[tags]: 
Don't use new and delete for anything. Sometimes you have to, but usually you don't, so try to avoid it and see how you get on. It's hard to explain exactly how without a more concrete example, but in particular if you're doing: SomeType *myobject = new SomeType(); ... use myobject for something ... delete myobject; return; Then firstly this code is leak-prone, and secondly it should be replaced with: SomeType myobject; ... use myobject for something (replacing -> with . etc.) ... return; Especially don't create a vector with new - it's almost always wrong because in practice a vector almost always has one well-defined owner. That owner should have a vector variable, not a pointer-to-vector that they have to remember to delete. You wouldn't dynamically allocate an int just to be a loop counter, and you don't dynamically allocate a vector just to hold some values. In C++, all types can behave in many respects like built-in types. The issues are what lifetime you want them to have, and (sometimes) whether it's expensive to pass them by value or otherwise copy them. shouldn't it be more like vector so they could be dynamically created? Only if they need to be dynamically created for some other reason, aside from just that you want to organise them in a vector. Until you hit that reason, don't look for one. In that case how would I return an object from a method and how to avoid memory leaks (trying to use only STL)? The standard libraries don't really provide the tools to avoid memory leaks in all common cases. If you must manage memory, I promise you that it is less effort to get hold of an implementation of shared_ptr than it is to do it right without one.
