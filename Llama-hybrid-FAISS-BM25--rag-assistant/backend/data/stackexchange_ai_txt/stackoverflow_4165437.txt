[site]: stackoverflow
[post_id]: 4165437
[parent_id]: 4165367
[tags]: 
I use overloads of my FindOne and FindAll repository calls to achieve this..something like: Function FindOne(ByVal spec As ILinqSpecification(Of T)) As T Function FindOne(ByVal spec As ILinqSpecification(Of T), ByVal strategy As IFetchingStrategy(Of T)) As T Function FindAll(ByVal spec As ILinqSpecification(Of T)) As IQueryable(Of T) Function FindAll(ByVal spec As ILinqSpecification(Of T), ByVal strategy As IFetchingStrategy(Of T)) As IQueryable(Of T) etc.. Perhaps not the cleanest approach, but it does the job. I'm not certain if this is still an issue with the trunk linq provider or not, but I can also decide whether or not to apply the distinct result transformer to my results in the FindAll scenarios based upon whether or not my fetching strategy contains a collection. My specification and fetching strategy implementations are based upon those available in the ncommon project. For reference, my full generic "read-only" repository interface is as follows: Public Interface IReadOnlyRepositoryWithTypedId(Of T As IEntityWithTypedId(Of IdT), IdT) Function LoadById(ByVal id As IdT) As T Function GetById(ByVal id As IdT) As T Function FindOne(ByVal spec As ILinqSpecification(Of T)) As T Function FindOne(ByVal spec As ILinqSpecification(Of T), ByVal strategy As IFetchingStrategy(Of T)) As T Function GetCount() As Integer Function GetCount(ByVal spec As ILinqSpecification(Of T)) As Integer Function HasAny(ByVal spec As ILinqSpecification(Of T)) As Boolean Function FindAll(ByVal spec As ILinqSpecification(Of T)) As IQueryable(Of T) Function FindAll(ByVal spec As ILinqSpecification(Of T), ByVal strategy As IFetchingStrategy(Of T)) As IQueryable(Of T) Function FindAll() As IQueryable(Of T) Function FindAll(ByVal strategy As IFetchingStrategy(Of T)) As IQueryable(Of T) End Interface
