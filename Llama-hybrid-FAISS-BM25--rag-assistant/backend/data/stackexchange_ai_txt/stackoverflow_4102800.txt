[site]: stackoverflow
[post_id]: 4102800
[parent_id]: 1200783
[tags]: 
Short answer: use subSequence() . if (line.contains("[LoadFile]")) result = line.subSequence(line.indexOf('"'), line.lastIndexOf('"')).toString(); On my machine, this consistently takes less than 10,000 ns. I am taking "efficient" to mean faster. The regex option is considerably slower (about 9 or 10 times slower). The primary advantage of the regex option is that it might be easier for another programmer to figure out what you are doing (but then use comments to help them). To make the regex option more efficient, pre-compile it: private static final String FILE_REGEX = ".*\\[LoadFile\\]\\s+file\\s+=\\s+\"([^\"].+)\".*"; private static final Pattern FILE_PATTERN = Pattern.compile(FILE_REGEX); But this still leaves it slower. I record times between 80,000 and 100,000 ns. The StringTokenizer option is more efficient than the regex: if (line.contains("[LoadFile]")) { StringTokenizer tokenizer = new StringTokenizer(line, "\""); tokenizer.nextToken(); result = tokenizer.nextToken(); } This hovers around 40,000 ns for me, putting it in at 2-3 times faster than the regex. In this scenario, split() is also an option, which for me (using Java 6_13) is just a little faster than the Tokenizer: if (line.contains("[LoadFile]")) { String[] values = line.split("\""); result = values[1]; } This averages times of 35,000 ns for me. Of course, none of this is checking for errors. Each option will get a little slower when you start factoring that in, but I think the subSequnce() option will still beat them all. You have to know the exact parameters and expectations to figure out how fault-tolerant each option needs to be.
