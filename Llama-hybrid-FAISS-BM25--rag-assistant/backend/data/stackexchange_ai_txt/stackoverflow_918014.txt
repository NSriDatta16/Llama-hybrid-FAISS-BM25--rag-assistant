[site]: stackoverflow
[post_id]: 918014
[parent_id]: 917062
[tags]: 
NOTE: The question says that the column is of datatype DATETIME , not the newer (SQL Server 2008) TIME datatype. ANSWER: REPLACE(CONVERT(VARCHAR(8),timecolumn,8),':','') Let's unpack that. First, CONVERT formats the time portion of the datetime into a varchar, in format 'hh:mi:ss' (24-hour clock), as specified by the format style value of 8. Next, the REPLACE function removes the colons, to get varchar in format 'hhmiss' . That should be sufficient to get a usable string in the format you'd need. FOLLOW-UP QUESTION (asked by the OP question) Is an inline expression faster/less server intensive than a user defined function? The quick answer is yes. The longer answer is: it depends on several factors, and you really need to measure the performance to determine if that's actually true or not. I created and executed a rudimentary test case: -- sample table create table tmp.dummy_datetimes (c1 datetime) -- populate with a row for every minute between two dates insert into tmp.dummy_datetimes select * from udfDateTimes('2007-01-01','2009-01-01',1,'minute') (1052641 row(s) affected) -- verify table contents select min(c1) as _max , max(c1) as _min , count(1) as _cnt from tmp.dummy_datetimes _cnt _min _max ------- ----------------------- ----------------------- 1052641 2007-01-01 00:00:00.000 2009-01-01 00:00:00.000 (Note, the udfDateTimes function returns the set of all datetime values between two datetime values at the specified interval. In this case, I populated the dummy table with rows for each minute for two entire years. That's on the order of a million ( 2x365x24x60 ) rows. Now, user defined function that performs the same conversion as the inline expression, using identical syntax: CREATE FUNCTION [tmp].[udfStrippedTime] (@ad DATETIME) RETURNS VARCHAR(6) BEGIN -- Purpose: format time portion of datetime argument to 'hhmiss' -- (for performance comparison to equivalent inline expression) -- Modified: -- 28-MAY-2009 spencer7593 RETURN replace(convert(varchar(8),@ad,8),':','') END NOTE: I know the function is not defined to be DETERMINISTIC . (I think that requires the function be declared with schema binding and some other declaration, like the PRAGMA required Oracle.) But since every datetime value is unique in the table, that shouldn't matter. The function is going to have to executed for each distinct value, even if it were properly declared to be DETERMINISTIC . I'm not a SQL Server 'user defined function' guru here, so there may be something else I missed that will inadvertently and unnecessarily slow down the function. Okay. So for the test, I ran each of these queries alternately, first one, then the other, over and over in succession. The elapsed time of the first run was right in line with the subsequent runs. (Often that's not the case, and we want to throw out the time for first run.) SQL Server Management Studio reports query elapsed times to the nearest second, in format hh:mi:ss, so that's what I've reported here. -- elapsed times for inline expression select replace(convert(varchar(8),c1,8),':','') from tmp.dummy_datetimes 00:00:10 00:00:11 00:00:10 -- elapsed times for equivalent user defined function select tmp.udfStrippedTime(c1) from tmp.dummy_datetimes 00:00:15 00:00:15 00:00:15 For this test case, we observe that the user defined function is on the order of 45% slower than an equivalent inline expression. HTH
