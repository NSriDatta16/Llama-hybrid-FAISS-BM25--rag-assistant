[site]: stackoverflow
[post_id]: 5461888
[parent_id]: 
[tags]: 
Objective-C: Calling and copying the same block from multiple threads

I'm dealing with neural networks here, but it's safe to ignore that, as the real question has to deal with blocks in objective-c. Here is my issue. I found a way to convert a neural network into a big block that can be executed all at once. However, it goes really, really slow, relative to activating the network. This seems a bit counterintuitive. If I gave you a group of nested functions like CGFloat answer = sin(cos(gaussian(1.5*x + 2.5*y)) + (.3*d + bias)) //or in block notation ^(CGFloat x, CGFloat y, CGFloat d, CGFloat bias) { return sin(cos(gaussian(1.5*x + 2.5*y)) + (.3*d + bias)); }; In theory, running that function multiple times should be easier/quicker than looping through a bunch of connections, and setting nodes active/inactive, etc, all of which essentially calculate this same function in the end. However, when I create a block (see thread: how to create function at runtime ) and run this code, it is slow as all hell for any moderately sized network. Now, what I don't quite understand is: When you copy a block, what exactly are you copying? Let's say, I copy a block twice, copy1 and copy2. If I call copy1 and copy2 on the same thread, is the same function called? I don't understand exactly what the docs mean for block copies: Apple Block Docs Now if I make that copy again, copy1 and copy2, but instead, I call the copies on separate threads, now how do the functions behave? Will this cause some sort of slowdown, as each thread attempts to access the same block?
