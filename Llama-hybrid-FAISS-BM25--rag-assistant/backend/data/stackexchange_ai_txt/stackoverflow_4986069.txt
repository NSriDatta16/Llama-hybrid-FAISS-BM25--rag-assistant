[site]: stackoverflow
[post_id]: 4986069
[parent_id]: 4986017
[tags]: 
I think you need to take some time to read through your code carefully, line-by-line. [inv performSelector:@selector(invokeWithTarget:) withObject:[self target] afterDelay:.5]; This isn't doing what you think it is. One half of one second after this method is executed, this will happen: [inv invokeWithTarget:[self target]]; First, your class CategoryButton doesn't have a method called target . Second, why the delay? If you're using these touches for scrolling, a delay of 0.5 seconds is going to be extremely painful for users. Why are you using the NSInvocation class at all? If you really need the delay, you can simply use the performSelector: method on your CategoryButton instance: NSArray *params = [NSArray arrayWithObjects:touches, event, nil]; [self performSelector:@selector(handleTap:) withObject:params afterDelay:0.5]; Notice the performSelector: methods only support one argument, so you have to wrap them in an NSArray. (Alternatively, you can use an NSDictionary.) You will have to update your handleTap: method to accept an NSArray/NSDictionary and snag the arguments as needed. But again, if you don't need the delay, why not just call the method yourself: - (void) touchesBegan: (NSSet *) touches withEvent: (UIEvent *) event { UITouch *theTouch = [touches anyObject]; switch ([theTouch tapCount]) { case 1: [super touchesBegan:touches withEvent:event]; break; } } Maybe I'm misunderstanding your intentions, but it seems you're making this way more complicated than it needs to be.
