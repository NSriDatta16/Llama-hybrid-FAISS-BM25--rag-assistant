[site]: stackoverflow
[post_id]: 2152101
[parent_id]: 2151960
[tags]: 
This can be difficult to do when sending from C to C. If you have a data struct, cast it so that you end up with an array of bytes/chars and then you just blindly send it you can sometimes end up with big problems decoding it on the other end. This is because sometimes the compiler has decided to optimize the way that the data is packed in the struct, so in raw bytes it may not look exactly how you expect it would look based on how you code it. It really depends on the compiler! There are compiler pragma's you can use to make packing unoptimized. See C/C++ Preprocessor Reference - pack The other problem is the 32/64-bit bit problem if you just use "int", and "long" without specifying the number of bytes... but you have done that :-) Unfortunately, Java doesnt really have structs... but it represents the same information in classes. What I recommend is that you make a class that consists of your variables, and just make a custom unpacking function that will pull the bytes out from the received packet (after you have checked its correctness after transfer) and then load them in to the class. e.g. You have a data class like class Data { public int moteID; public int status; //block or not public int tc_1; public int tc_2; } Then when you receive a byte array, you can do something like this Data convertBytesToData(byte[] dataToConvert) { Data d = Data(); d.moteId = (int)dataToConvert[0]; d.status = (int)dataToConvert[1]; d.tc_1 = ((int)dataToConvert[2] I might have the 16-bit unpacking the wrong way around, it depends on the endian of your C system, but you'll be able to play around and see if its right or not. I havent played with Java for sometime, but hopefully there might be byte[] to int functions built in these days. I know there are for C# anyway. With all this in mind, if you are not doing high data rate transfers, definately look at JSON and Protocol Buffers!
