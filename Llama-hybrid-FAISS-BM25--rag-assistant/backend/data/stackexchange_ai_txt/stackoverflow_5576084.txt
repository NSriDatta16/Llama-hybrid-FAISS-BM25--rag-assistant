[site]: stackoverflow
[post_id]: 5576084
[parent_id]: 
[tags]: 
didReceiveAuthenticationChallenge is not getting called using ftp protocol

I've been struggling for a couple of day with a NSURLConnection problem in my app. I need to connect to a server (calling getPdfFromServerAtIndex), using ftp protocol in order to get an object (a pdf page, but it doesn't matter!). When I try to connect to an http url I've no problem. Same thing for an http url asking for authentication, all my delegate methods get called. But when I use the url shown below, built using a ftp protocol, delegate methods like didReceiveAuthenticationChallenge, canAuthenticateAgainstProtectionSpace never get called. When the "while(!finished)" is looping, the connectionShouldUseCredentialStorage method only is called, and than didFailWithError method give me the error "Connection failed! Error - You do not have permission to access the requested resource. ftp://ftp.www.thephilosopher.org/ ". Nevertheless, when I try to paste the ftp url on my browser I've been ask to fill username and password. Any idea why using the ftp protocol I cannot authenticate and access to the server? -(void)getPdfFromServerAtIndex:(NSUInteger)index{ // Create the request. // Set finished to false finished = FALSE; NSString *pageNumber = [NSString stringWithFormat:@"ftp://ftp.www.thephilosopher.org/Iphone/0%i.pdf",index+1]; NSURL* nsurl = [NSURL URLWithString:pageNumber]; urlReq = [[NSMutableURLRequest alloc] initWithURL:nsurl]; BOOL canHandle = [NSURLConnection canHandleRequest:urlReq]; NSURLConnection *conn = [[NSURLConnection alloc] initWithRequest:urlReq delegate:self]; if (conn && canHandle) { // Create the NSMutableData to hold the received data. // receivedData is an instance variable declared elsewhere. receivedData = [[NSMutableData data] retain]; } else { // Inform the user that the connection failed. NSLog(@"Connection Failed!"); } while(!finished) { [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];} } -(void)connectionDidFinishLoading:(NSURLConnection *)connection{ finished = TRUE; // receivedData is declared as a method instance elsewhere NSLog(@"Succeeded! Received %d bytes of data",[receivedData length]); // release the connection, and the data object [connection release]; } - (BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace*)tmpProtectionSpace { // Check the NSURLProtectionSpace return YES;} -(NSURLRequest *)connection:(NSURLConnection *)inConnection willSendRequest:(NSURLRequest *)inRequest redirectResponse:(NSURLResponse *)inRedirectResponse{ if(inRedirectResponse){ NSMutableURLRequest *r = [[urlReq mutableCopy] autorelease]; // original request [r setURL: [inRequest URL]]; return r; } else { return inRequest; } } -(BOOL)connectionShouldUseCredentialStorage:(NSURLConnection*)connection{ NSLog(@"connectionShouldUseCredentialStorage"); return YES; } -(void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge{ if([challenge previousFailureCount] == 0) { NSURLCredential *newCredential; newCredential=[NSURLCredential credentialWithUser:@"XXXX" password:@"XXXXX" persistence:NSURLCredentialPersistenceNone]; [[challenge sender] useCredential:newCredential forAuthenticationChallenge:challenge];} else { [[challenge sender] cancelAuthenticationChallenge:challenge]; NSLog(@"Bad Username Or Password");} } - (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error{ // release the connection, and the data object [connection release]; // receivedData is declared as a method instance elsewhere [receivedData release]; // inform the user NSLog(@"Connection failed! Error - %@ %@", [error localizedDescription], [[error userInfo] objectForKey:NSURLErrorFailingURLStringErrorKey]); } - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data{ NSLog(@"Data received"); [receivedData appendData:data]; } - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response{ NSLog(@"Response received"); [receivedData setLength:0]; }
