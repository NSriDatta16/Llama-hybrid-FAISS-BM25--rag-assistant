[site]: stackoverflow
[post_id]: 5586243
[parent_id]: 5585928
[tags]: 
When you do this recursively, you split the array in two for each level, make a call for each half, then makes one of the tests a - d. The test a requires no looping, the other tests requires looping through the entire array. By average you will loop through (0 + 1 + 1 + 1) / 4 = 3 / 4 of the array for each level in the recursion. The number of levels in the recursion is based on the size of the array. As you split the array in half each level, the number of levels will be log2(n). So, the total work is (n * 3/4) * log2(n). As constants are irrelevant to the time complexity, and all logarithms are the same, the complexity is O(n * log n). Edit: If someone is wondering about the algorithm, here's a C# implementation. :) private int? FindMajority(int[] arr, int start, int len) { if (len == 1) return arr[start]; int len1 = len / 2, len2 = len - len1; int? m1 = FindMajority(arr, start, len1); int? m2 = FindMajority(arr, start + len1, len2); int cnt1 = m1.HasValue ? arr.Skip(start).Take(len).Count(n => n == m1.Value) : 0; if (cnt1 * 2 >= len) return m1; int cnt2 = m2.HasValue ? arr.Skip(start).Take(len).Count(n => n == m2.Value) : 0; if (cnt2 * 2 >= len) return m2; return null; }
