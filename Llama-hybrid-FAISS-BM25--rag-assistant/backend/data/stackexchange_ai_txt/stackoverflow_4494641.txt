[site]: stackoverflow
[post_id]: 4494641
[parent_id]: 4490721
[tags]: 
Kudos for showing me a compiler error I have never seen before. When compiling the source file generated by: public static void main(String[] args) throws Exception { PrintWriter w = new PrintWriter("C:\\test.java"); w.println("enum Test {"); for (int i = 0; i eclipse says The code for the static initializer is exceeding the 65535 bytes limit Same test with a mere 2000 constants compiles flawlessly. Of course, if you have that many constants, it would be a good idea to organize them into more than one source file. Yes, one (and only one) object is allocated for every enum constant. With 2000 constants, that's a whopping 16KB memory :-) (on Sun's 32-bit VM, other VMs might differ a little) Each enum constant is an object, and each of them has a field text . The field is not final, and hence not subject to inlining. Yes, field access is constant-time. However, in general it's wierd having mutable state in an enum. It's possible, though. Good approaches include: Delegate to a ResourceBundle as AlexR shows. Disadvantage: You have to manually manage the resource files. If you do that, I recommend a UnitTest to detect mistyped/missing/superfluous resource keys, or even a command line utility to append the missing keys to the resource file so you don't have to (mis-)type them. If you only support a few languages, you can alternatively store all languages in the enum: enum Message { Hello("Hello", "Hallo", "Salut"); String en; String de; String fr; Message(String en, String de, String fr) { this.en = en; this.fr = fr; this.it = it; } Disadvantages: No editing by laymen (needs a compiler), and the source file encoding had better support all special characters in the target language (unicode escapes are awkward ...). Also, the source file gets cluttered if you have more than 3 or 4 languages. Advantages: Adding/Deleting texts is a snap, and the compiler catches all typos in the name of the text, and the "resource file" is always consistent. Either way, you should use MessageFormat as the tutorial R.Bemrose links to in his answer explains. And finally, when working with Enums you might find the values() method handy: for (Text t : Text.values()) { }
