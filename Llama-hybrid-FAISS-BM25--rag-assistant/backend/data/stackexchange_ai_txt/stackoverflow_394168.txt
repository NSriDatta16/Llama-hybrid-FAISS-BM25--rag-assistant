[site]: stackoverflow
[post_id]: 394168
[parent_id]: 394144
[tags]: 
This is monkey patching: class Float def self.times(&block) self.to_i.times { |i| yield(i) } remainder = self - self.to_i yield(remainder) if remainder > 0.0 end end Now I imagine this might be useful sometimes, but imagine if you saw routine. def my_method(my_special_number) sum = 0 my_special_number.times { |num| sum And it breaks only occasionally when it gets called. To those paying attention you already know why, but imagine that you didn't know about the float type having a .times class-method and you automatically assumed that my_special_number is an integer. Every time the parameter is a whole number, integer or float, it would work fine (whole ints are passed back except when there is a floating-point remainder). But pass a number with anything in the decimal area in and it'll break for sure! Just imagine how often this might happen with your gems, Rails plugins, and even by your own co-workers in your projects. If there's one or two little methods in there like this and it could take some time to find and correct. If you wonder why it breaks, note that sum is an integer and a floating-point remainder could be passed back; in addition, the exponential sign only works when types are the same. So you might think it's fixed, because you converted bother numbers to floats ... only to find that the sum can't take the floating-point result.
