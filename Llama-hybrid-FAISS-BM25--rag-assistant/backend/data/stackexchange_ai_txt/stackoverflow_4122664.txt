[site]: stackoverflow
[post_id]: 4122664
[parent_id]: 4122422
[tags]: 
Another technique for crossdomain communications is (ab)using window.name . It requires an iframe to originally have a same-domain src initially after which you move to another domain that sets the window.name and then steps back to the original source (step back in history). The idea is that the window.name does not change unless it's explicitly set, this means you can transfer window.name data cross domain. This technique is described in more detail on: - http://skysanders.net/subtext/archive/2010/10/11/leveraging-window.name-transport-for-secure-and-efficient-cross-domain-communications.aspx - http://jectbd.com/?p=611 Be sure to choose the implementation that avoids clicking sounds in IE. Unfortunatly, it still messes around with your history, but it does a step forward and then backwards to the history point it was at. A big benefit though, is that you don't have to parse and encode URI strings, but can use JSON right away. Using JSON lib for example // access window.name from parent frame // note: only when iframe stepped back to same domain. var data = JSON.parse( iframe.contentWindow.name ); // set child frame name // note: only when iframe stepped back to same domain. iframe.contentWindow.name = JSON.stringify( { foo : "bar" } ); // to JSON string // set own name ( child frame ) window.name = JSON.stringify( { foo : "bar" } ); // to JSON string The cookie technique is viable as well, for both techniques you need to perform ajax requests in the target iframe if you want to avoid history changes but still require http request. so: Send data to iframe x (using cookie or window.name technique) Catch data with poller in iframe x Perform ajax requests in iframe x. Send data back to iframe y (using cookie or window.name technique) Catch data with poller in iframe y Do the hokey pokey. Any page refresh (httprequest) or url change will update the history (except for old or all IE versions), so more code is required alas.
