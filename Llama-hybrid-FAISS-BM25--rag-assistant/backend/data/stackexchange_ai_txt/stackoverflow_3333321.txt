[site]: stackoverflow
[post_id]: 3333321
[parent_id]: 
[tags]: 
C# - Xml serializing ambiguous complex types

I have a problem that can perhaps be solved in a more efficient or clean way, than my current solution. Over the past days I have gotten a fairly good understanding of how Xml serialization can be controlled via attributes, but one part of the Xml structure is so obscure, that I have not been able to find a smart solution. I have been handed an Xml schema, which cannot be altered, and to which I must create a C# class. The code that bugs me is the following: My first idea was to manage this by having a generic list, that could be one of three types of classes, which has worked so far, but the problem here is the ambiguous name "Data". Here is the code I originally made: [XmlRoot("DataRef")] public class DataRef { protected List m_Data = new List (1); [XmlElement(typeof(DataUserField))] [XmlElement(typeof(DataMasterField))] [XmlElement(typeof(DataSeparator))] public List Data { get { return m_Data; } set { m_Data = value; } } } public abstract class DataRoot { } [XmlRoot("Data")] public class DataUserField : DataRoot { protected string m_DataOwner; protected string m_Name; [XmlElement("DataOwner")] public string DataOwner { get { return m_DataOwner; } set { m_DataOwner = value; } } [XmlElement("Name")] public string Name { get { return m_Name; } set { m_Name = value; } } } [XmlRoot("Data")] public class DataMasterField : DataRoot { protected string m_XPath; [XmlElement("XPath")] public string XPath { get { return m_XPath; } set { m_XPath = value; } } } [XmlRoot("Separator")] public class DataSeparator : DataRoot { protected string m_Text = ""; [XmlText()] public string Text { get { return m_Text; } set { m_Text = value; } } } This unfortunately did not work, and I assume it is because of the ambiguous element name "Data", since the error-message is pretty vague, but does have a reference to the line-number of the error. As I said in the beginning, I already have a solution, but it is far from elegant, and definitely not in .Net spirit, which is why I would greatly appreciate any help. My solution to those interested involves one class to represent "DataType" with one field for the type and three other fields for "DataOwner", "Name" and "XPath", where the type is an enum that can be either "DataUserField" or "DataMasterField". Sorry for the long post, but I felt it would be better to have some proper code samples, please say if you need more info.
