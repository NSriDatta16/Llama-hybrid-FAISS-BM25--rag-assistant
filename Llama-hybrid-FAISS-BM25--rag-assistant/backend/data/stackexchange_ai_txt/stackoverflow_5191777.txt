[site]: stackoverflow
[post_id]: 5191777
[parent_id]: 4806772
[tags]: 
You can use a specific shader for that. If you have tex1, tex2, and texbool: # set your textures glActiveTexture(GL_TEXTURE0) glBindTexture(GL_TEXTURE_2D, tex1) glActiveTexture(GL_TEXTURE0+1) glBindTexture(GL_TEXTURE_2D, tex2) glActiveTexture(GL_TEXTURE0+2) glBindTexture(GL_TEXTURE_2D, texbool) # when you're starting your shader (id is 1 for eg) glUseProgram(1) glUniformi(glGetUniformLocation(1, "tex1"), 0) glUniformi(glGetUniformLocation(1, "tex2"), 1) glUniformi(glGetUniformLocation(1, "texbool"), 2) # and now, draw your model as you wish The fragment shader can be something like: // i assume that you'll pass tex coords too. Since the tex1 and tex2 // look the same size, i'll assume that for now. varying vec2 tex1_coords; // get the binded texture uniform sample2D tex1; uniform sample2D tex2; uniform sample2D texbool; // draw ! void main(void) { vec4 c1 = texture2D(tex1, tex1_coords); vec4 c2 = texture2D(tex2, tex1_coords); vec4 cbool = texture2D(texbool, tex1_coords / 2.); // this will mix c1 to c2, according to cbool. // if cbool is 0, c1 will be used, otherwise, it will be c2 glFragColor = mix(c1, c2, cbool); } I didn't test for your example, but that how i'll start to found a solution :)
