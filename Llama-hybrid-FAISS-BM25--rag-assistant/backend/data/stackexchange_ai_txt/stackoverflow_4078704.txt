[site]: stackoverflow
[post_id]: 4078704
[parent_id]: 4044889
[tags]: 
My issue boiled down to a real simple mistake....clock(). While I did protect my timing algorithm by only having a specific thread calculate the time, I forgot one important thing about clock()...it returns wall clock time which is the total processor time (summation over the active threads). What I needed to be calling was omp_get_wtime(). Doing this I suddenly see a speedup for many sections of my code. For the record I've modified my code to include #ifdef _OPENMP #include #define TIMESCALE 1 #else #define omp_get_thread_num() 0 #define omp_get_num_procs() 0 #define omp_get_num_threads() 1 #define omp_set_num_threads(bob) 0 #define omp_get_wtime() clock() #define TIMESCALE CLOCKS_PER_SEC #endif And my timing algorithm is now #pragma omp barrier if (tid == 0) { stime=omp_get_wtime(); printf("-----1) Calculating leap helpers"); } #pragma omp for for(i=0;i nx;i++) { for(j=0;j ny;j++) { for(k=0;k nz;k++) { // rho's rhoinv[i][j][k]=1./mhd->rho[i][j][k]; rhoiinv[i][j][k]=1./mhd->rhoi[i][j][k]; rhoeinv[i][j][k]=1./mhd->rhoe[i][j][k]; rhoninv[i][j][k]=1./mhd->rhon[i][j][k]; // 1./(gamma-1.) gaminv[i][j][k]=1./(mhd->gamma[i][j][k]-1.); gamiinv[i][j][k]=1./(mhd->gammai[i][j][k]-1.); gameinv[i][j][k]=1./(mhd->gammae[i][j][k]-1.); gamninv[i][j][k]=1./(mhd->gamman[i][j][k]-1.); } } } if (tid == 0) { printf("........%04.2f [s] -----\n",(omp_get_wtime()-stime)/TIMESCALE); stime=omp_get_wtime(); printf("-----2) Calculating leap helpers"); }
