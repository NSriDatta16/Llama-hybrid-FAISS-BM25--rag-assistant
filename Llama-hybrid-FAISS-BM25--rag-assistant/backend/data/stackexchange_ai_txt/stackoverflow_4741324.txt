[site]: stackoverflow
[post_id]: 4741324
[parent_id]: 4740647
[tags]: 
I'm still a bit fuzzy as to what you're trying to do, but if you want to run with this all the way to its logical conclusion, I'm seeing something like this: /** @param P parent @param C child @param S self */ interface Element , C extends Element , S extends Element > { public P getParent(); public Collection getChildren(); } That expresses (I think) all your constraints: my parent must be something that can have me as a child, and my children must be something that can have me as a parent. Implementations would include: /** An agglomeration of stacks: no parent */ class Agglomeration extends Element {…} /** A stack of solids */ class Stack extends Element {…} /** A solid in a stack: no children */ class Solid extends Element {…} I don't have a Java IDE open right now, though, so I can't confirm this will actually compile -- I have a feeling that the compiler will complain about those question marks, and try to drag you into something like class Agglomeration extends Element You can get around that, though, if you separate Parent and Child into separate interfaces (one with getChildren() and one with getParent() ), so Agglomeration only implements the first and Solid only implements the second, while Stack implements both. It might be more trouble than it's worth, but run with it for a while and see where it takes you. :)
