[site]: stackoverflow
[post_id]: 5517461
[parent_id]: 5365543
[tags]: 
The problem is that the field is private. If you make it public the external method works fine. The DynamicMethod works despite it being private because the CLR apparently allows intra-module private field access - from the SSCLI, clsload.cpp@2659: // pCurrentClass can be NULL in the case of a global function // pCurrentClass it the point from which we're trying to access something // pTargetClass is the class containing the member we are trying to access // dwMemberAccess is the member access within pTargetClass of the member we are trying to access BOOL ClassLoader::CheckAccess(EEClass *pCurrentClass, Assembly *pCurrentAssembly, EEClass *pTargetClass, Assembly *pTargetAssembly, DWORD dwMemberAccess) { // we're trying to access a member that is contained in the class pTargetClass, so need to // check if have access to pTargetClass itself from the current point before worry about // having access to the member within the class if (! CanAccessClass(pCurrentClass, pCurrentAssembly, pTargetClass, pTargetAssembly)) return FALSE; if (IsMdPublic(dwMemberAccess)) return TRUE; // This is module-scope checking, to support C++ file & function statics. if (IsMdPrivateScope(dwMemberAccess)) { if (pCurrentClass == NULL) return FALSE; _ASSERTE(pTargetClass); return (pCurrentClass->GetModule() == pTargetClass->GetModule()); } To access private fields externally you probably have to use reflection which pretty much defeats the purpose. Edit Just to clarify, what you posted uses reflection to create the assembly, but the IL you generate doesn't use reflection to access the field - that's a plain old direct field access, which explodes because the target field is external and private. You'd have to emit IL which itself uses Type.GetField().GetValue() which is pretty pointless.
