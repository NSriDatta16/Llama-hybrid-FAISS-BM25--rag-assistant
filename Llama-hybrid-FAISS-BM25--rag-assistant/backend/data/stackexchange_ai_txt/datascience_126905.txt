[site]: datascience
[post_id]: 126905
[parent_id]: 
[tags]: 
TypeError: unhashable type: 'slice' K-Means; Custom code for K-Means

Problem Statement The goal is to have the K-Means customer code run for clusters and not use scikit-learn libraries. Learning exercise. This K-means has the standard predict, fix, centroids, cluster means functions. This is a data science coding programming question on creating a custom K-Means for machine learning so it is appropriate to ask here in the data science forum since resources will be keen on K-Means algorithms. My Attempt to Fix the Problem The TypeError unhashable appears to suggests that slicing on self.Centroids[:, k] is not working properly. I have already used a numpy arrays (np.asarray) to properly shape the array. In the fix() function, first self attribute is casted to a numpy array before mutating the contents. The function name is has_fit(self, n_iterations) and the self.Centroids gets the self.getCentroids for the centroids in a numpy array. Shapes disparity_matrix.shape is (2700, 1) Error TypeError Traceback (most recent call last) Cell In[218], line 5 3 disparity_matrix = np.asarray(disparity_matrix) 4 stars_model = CustomKMeans(disparity_matrix, n_clusters=2) ----> 5 start_model_fit = stars_model.has_fit(n_iterations=300) 7 # Get cluster labels 8 stars = np.asarray(stars) Cell In[217], line 37, in CustomKMeans.has_fit(self, n_iterations) 34 _euclidian = np.array([]).reshape(self.m, 0) 35 for k in range(self.K): 36 # Reshape the centroid column vector to be a 2D array ---> 37 centroid_column = self.Centroids[:, k].reshape(-1, 1) 38 _distance = np.sum((self.X - centroid_column.T) ** 2, axis=1) 39 _euclidian = np.c_[_euclidian, _distance] TypeError: unhashable type: 'slice' Base Invocation Calls / Sequences My invoke python calls for my object: disparity_matrix = np.asarray(disparity_matrix) stars_model = CustomKMeans(disparity_matrix, n_clusters=2) start_model_fit = stars_model.has_fit(n_iterations=300) My Python K-Means Code My class code is listed: class CustomKMeans: def __init__(self, X, n_clusters=8, max_iter=300, tol=1e-4): self.X=np.asarray(X) self.Cluster={} self.Centroids=np.array([]).reshape(self.X.shape[1],0) self.K=n_clusters self.m=self.X.shape[0] def getCentroids(self,X,K): i = random.randint(0,X.shape[0]) _centroid = np.array([X[i]]) for z in range(1,K): _array = np.array([]) for item in X: _array = np.append(_array, np.min(np.sum((item-_centroid)**2))) _probability = _array/np.sum(_array) _cummulative_probability = np.cumsum(_probability) _random = random.random() _jmp = 0 for k, l in enumerate(_cummulative_probability): if _random 0: cluster_mean = np.mean(points, axis=0) cluster_means.append(cluster_mean) return cluster_means def has_predict(self): return self.Clusters,self.Centroids.T
