[site]: stackoverflow
[post_id]: 5628057
[parent_id]: 
[tags]: 
Solving floating-point rounding issues C++

I develop a scientific application (simulation of chromosomes moving in a cell nucleus). The chromosomes are divided in small fragments that rotate around a random axis using 4x4 rotation matrices. The problem is that the simulation performs hundreds of billions of rotations, therefore the floating-point rounding errors stack up and grow exponentially, so the fragments tend to "float away" and detach from the rest of the chromosome as time passes. I use double precision with C++. The soft runs on CPU for the moment but will be ported for CUDA, and simulations can last for 1 month at most. I have no idea how I could somehow renormalize the chromosome, because all fragments are chained together (you can see it as a doubly linked-list), but I think that would be the best idea, if possible. Do you have any suggestions ? I feel a bit lost. Thank you very much, H. EDIT: Added a simplified sample code. You can assume all matrix math are classical implementations. // Rotate 1000000 times for (int i = 0; i length; // Pick the end 20 segments further (cyclic) int iend = (istart + 20) % chromosome->length; // Build rotation axis Vector4 axis = chromosome->segments[istart].position - chromosome->segments[iend].position; axis.normalize(); // Build rotation matrix and translation vector Matrix4 rotm(axis, rand() / float(RAND_MAX)); Vector4 oldpos = chromosome->segments[istart].position; // Rotate each segment between istart and iend using rotm for (int j = (istart + 1) % chromosome->length; j != iend; ++j, j %= chromosome->length) { chromosome->segments[j].position -= oldpos; chromosome->segments[j].position.transform(rotm); chromosome->segments[j].position += oldpos; } }
