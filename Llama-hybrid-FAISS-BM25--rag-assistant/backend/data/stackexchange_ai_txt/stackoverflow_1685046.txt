[site]: stackoverflow
[post_id]: 1685046
[parent_id]: 1684785
[tags]: 
drug this up from an old college project... Maybe it'll help typedef struct matrix { flag type; /* type of matrix: {RECTANGULAR, SQUARE, BANDED } */ ushort num_rows; /* number of rows in th matrix */ union cols { ushort num_cols; /* Number of cols in Rectanular matrix */ ushort band; /* Bandwidth in a square, symmetric, banded matrix */ } double *m_val; /* ptr to start of storage of actual matrix values */ } MAT; /* row_swap ---- swap two rows of an nxn UNBANDED matrix */ void row_swap(mat, r1, r2) MAT *mat; ushort r1, r2; { double *m = mat->m_val; ushort n = m->num_row; INDEX i; double temp; for (i=0; i num_row; INDEX r,c; int sr,sc; double key, mat = m->m_val, inv = in->m_val; sr =(ref-mat)/n; sc=(ref-mat) % n; scalprod(1.0/(*ref), inv+n*sr, n); scalprod(1.0/(*ref), ref-sc, n); for ( r=0; r LT n; r++) { if ( r != sr && *(mat+n*r+sc) != 0.0 ) { key = *(mat+n*r+sc); for (c=0; c start+n*n) /* last row without non-zero entry, */ return (-1); /* Matrix must be singular */ else i += n; /* this is not the last row, goto next row */ } if (i >= start + n*n) /* we have departed the matrix */ return (0); else /* we found a non-zero entry, return it */ return(i); } /* invert -- function to invert nxn matrix */ flag invert(m, i) MAT *m, *i; { double *ref, *new, *mat = m->m_val, *inv = i->m_val; ushort n = mat->num_row; INDEX i, j, row; ushort new_row; if (det(mat,n) == 0.0) return 0; for (i=0; i
