[site]: crossvalidated
[post_id]: 63105
[parent_id]: 62957
[tags]: 
As I understand your problem, the main issue is the size of the data set, and not that it contains missing value (i.e. "sparse"). For such a problem, I would recommend doing a partial PCA in order to solve for a subset of leading PCs. The package irlba allows for this by performing a "Lanczos bidiagonalization". It is much faster for large matrices when you are only interested in returning a few of the leading PCs. In the following example, I have adapted a bootstrapping technique that I discussed here into a function that incorporates this method as well as a variable sub-sampling parameter. In the function bootpca , you can define the number of variables to sample, n , the number of PCs to return, npc , and the number of iterations B for the sub-sampling routine. For this method, I have centered and scaled the sub-sampled matrix in order to standardize the variance of the dataset and allow for comparability among the singular values of the matrix decomposition. By making a boxplot of these bootstrapped singular values, lam , you should be able to differentiate between PCs that carry signals from those that are dominated by noise. Example Generate data m=50 n=100 x load bootpca function library(irlba) bootpca Result and plot res It's obvious that the leading 5 PCs carry the most information, although there were technically 9 signals in the example data set. For your very large data set, you may want to use a smaller fraction of variables (i.e. rows) in each iteration, but do many iterations.
