[site]: stackoverflow
[post_id]: 2036846
[parent_id]: 2036709
[tags]: 
Your style looks fine to me. The different steps in the algorithm are clear, which is the most important part of making something work. This is also the tactic I use for solving Project Euler problems. First make it work, and then make it fast. As already remarked, replacing Array.BinarySearch by Set.contains makes the code even more readable. I find that in almost all PE solutions I've written, I only use arrays for lookups. I've found that using sequences and lists as data structures is more natural within F#. Once you get used to them, that is. I don't think using mutability inside a function is necessarily bad. I've optimized problem 155 from almost 3 minutes down to 7 seconds with some aggressive mutability optimizations. In general though, I'd save that as an optimization step and start out writing it using folds/filters etc. In the example case of problem 155, I did start out using immutable function composition, because it made testing and most importantly, understanding, my approach easy. Picking the wrong algorithm is much more detrimental to a solution than using a somewhat slower immutable approach first. A good algorithm is still fast even if it's slower than the mutable version ( couch hello captain obvious! cough ). Edit: let's look at your version Your problem23b() took 31 seconds on my PC. Optimization 1: use new algorithm. //useful optimization: if m divides n, (n/m) divides n also //you now only have to check m up to sqrt(n) let factorSum2 n = let rec aux acc m = match m with | m when m*m = n -> acc + m | m when m*m > n -> acc | m -> aux (acc + (if n%m=0 then m + n/m else 0)) (m+1) aux 1 2 This is still very much in functional style, but using this updated factorSum in your code, the execution time went from 31 seconds to 8 seconds. Everything's still in immutable style, but let's see what happens when an array lookup is used instead of a set: Optimization 2: use an array for lookup: let absums() = //create abundant numbers as an array for (very) fast lookup let abnums = [|1..28128|] |> Array.filter (fun n -> factorSum2 n > n) //create a second lookup: //a boolean array where arr.[x] = true means x is a sum of two abundant numbers let arr = Array.zeroCreate 28124 for x in abnums do for y in abnums do if x+y Seq.mapi (fun i isAbsum -> if isAbsum then 0 else i) //mapi: i is the position in the sequence |> Seq.sum //I always write a test once I've solved a problem. //In this way, I can easily see if changes to the code breaks stuff. let test() = euler023() = 4179871 Execution time: 0.22 seconds (!). This is what I like so much about F#, it still allows you to use mutable constructs to tinker under the hood of your algorithm. But I still only do this after I've made something more elegant work first.
