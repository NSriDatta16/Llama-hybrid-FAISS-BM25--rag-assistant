[site]: stackoverflow
[post_id]: 1486084
[parent_id]: 1486068
[tags]: 
As Bobby has suggested, SHOW indexes returns a resultset with relevant key index, check this page for further examples: SHOW INDEXES FROM products_to_categories WHERE Key_name = "PRIMARY" AND Seq_in_index = '2'; +------------------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | +------------------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+ | products_to_categories | 0 | PRIMARY | 2 | category_id | A | 0 | NULL | NULL | | BTREE | | +------------------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+ However this will probably require as much code if not more than the following workaround. Check which value you inserted collides with an existing row in the table: SELECT code FROM myTable WHERE code = 'the_value_you_tried_to_insert'; or SELECT name FROM myTable WHERE name = 'the_value_you_tried_to_insert'; Albeit not a very elegant solution.
