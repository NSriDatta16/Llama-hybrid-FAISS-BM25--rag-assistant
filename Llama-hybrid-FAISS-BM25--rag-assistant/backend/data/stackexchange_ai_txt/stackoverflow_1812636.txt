[site]: stackoverflow
[post_id]: 1812636
[parent_id]: 1812614
[tags]: 
"First" and "second" are ambiguous. They tend to refer to the storage, so endian-ness comes into play, and I assume you don't mean that. Also the number of bytes in a short is implementation-defined. I assume you want to zero out the least significant ("right") bits, and retain all other bits: #include ... inputShort & ~std::numeric_limits ::max(); Or if you're feeling brave, and you want to assume 8-bit bytes: inputShort & ~0xFF; (It doesn't take very much bravery to assume 8-bit bytes).
