[site]: stackoverflow
[post_id]: 2429272
[parent_id]: 2429237
[tags]: 
You could implement the filters as Decorators . In fact, the way you invoke the successor in your filter is exactly like Decorator, so why not implement the pattern fully. The main difference would be that the successor is passed in the constructor. Then you would be able to chain them together like this: Filter f3 = new Filter3(); Filter f2 = new Filter2(f3); Filter f = new Filter1(f2); foreach (User u in users) { foreach (GeoRegion r in regions) { f.Process(u, r, ##); } } As you probably are well aware of, you can embed your Template Method into a Strategy : one common base interface, an abstract generic Template Method subclass for each different set of filters, then the set of concrete implementation subclasses for each. The tough part is the different parameter set. If you want to use the new filters transparently intermixed with the old ones, they should have the same interface, thus they should all get (and pass forward) the superset of all existing parameters, which is rapidly getting ugly over a count of 4-5 parameters. A possibility would be to pass the special parameters in the constructor of each filter, and the common parameters to process , but this is difficult as you have many runs in a loop with different parameters... Unless you can move the whole nested foreach loop inside the filters, which would then get users and regions as parameters: public class Filter { private UserCollection users; private GeoRegionCollection regions; public void Process(UserCollection users, GeoRegionCollection regions) { this.users = users;; this.regions = regions; } public void Process() { foreach (User u in users) { foreach (GeoRegion r in regions) { Process(u, r, ##); } } } public void Process(User u, GeoRegion r, int countNeeded) { // as before } } Another possibility might be to group together those parameters in some generic structure which has enough variability to hold your different parameter sets. Typically though, that's going to end up being some ugly map-like storage where you need to look up parameters by name and then downcast them to the right type :-( Difficult to say more without knowing more detail...
