[site]: stackoverflow
[post_id]: 947534
[parent_id]: 947280
[tags]: 
I think you have a couple of issues: You are passing an integer as a pointer (your compiler should warn against this or preferably refuse to compile the code): result = write_port(outPortHandle, 128); Compare this to the definition of write_port: int write_port(HANDLE hComm,BYTE* lpBuf) { The above statements doesn't match. Later on you then pass a pointer to the lpBuf pointer to the WriteFileEx function by taking the address of the BYTE* -> "&lpBuf". This will not result in what you think it will do. Even if you fix this, you will still have potential lifetime issues whenever the write is successfully queued but won't complete within the 50 ms timeout. When using overlapped I/O, you need to make sure that the read/write buffer and the overlapped structure remain valid until the I/O is completed, cancelled or the associated device is closed. In your code above you use a pointer to an OVERLAPPED struct that lives on the stack in your call to WriteFileEx. If WriteFileEx does not complete within 50 ms, the pending I/O will have a reference to a non-existing OVERLAPPED struct and you will (hopefully) have an access violation (or worse, silently corrupted stack data somewhere in your app). The canonical way of handling these lifetime issues (if performance is not a big issue), is to use a custom struct that includes an OVERLAPPED struct and some storage for the data to be read/written. Allocate the struct when posting the write and deallocate the struct from the I/O completion routine. Pass the address of the included OVERLAPPED struct to WriteFileEx, and use e.g. offsetof to get the address to the custom struct from the OVERLAPPED address in the completion routine. Also note that WriteFileEx does not actually use the hEvent member, IIRC. EDIT: Added code sample, please note: I haven't actually tried to compile the code, there might be typos or other problems with the code. It's not the most efficient way of sending data (allocating/deallocating a memory block for each byte that is sent). It should be easy to improve, though. #include #include #include // ... typedef struct _MYOVERLAPPED { OVERLAPPED ol; BYTE buffer; } MYOVERLAPPED, *LPMYOVERLAPPED; // ... static void CALLBACK write_compl(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped) { if (NULL == lpOverlapped) { assert(!"Should never happen"); return; } LPBYTE pOlAsBytes = (LPBYTE)lpOverlapped; LPBYTE pMyOlAsBytes = pOlAsBytes - offsetof(MYOVERLAPPED, ol); LPMYOVERLAPPED pMyOl = (LPMYOVERLAPPED)pOlAsBytes; if ((ERROR_SUCCESS == dwErrorCode) && (sizeof(BYTE) == dwNumberOfBytesTransfered)) { printf("written %uc\n", pMyOl->buffer); } else { // handle error } free(pMyOl); } int write_port(HANDLE hComm, BYTE byte) { LPMYOVERLAPPED pMyOl = (LPMYOVERLAPPED)malloc(sizeof(MYOVERLAPPED)); ZeroMemory(pMyOl, sizeof(MYOVERLAPPED)); pMyOl->buffer = byte; // Issue write. if (!WriteFileEx(hComm, &pMyOl->buffer, sizeof(BYTE), pMyOl, &write_compl )) { if (GetLastError() != ERROR_IO_PENDING) { // WriteFile failed, but isn't delayed. Report error and abort. free(pMyOl); printf("last error: %ld",GetLastError()); return 0; //failed, return false; } else { return -1; //pending } } else { free(pMyOl); return 1; //finished } }
