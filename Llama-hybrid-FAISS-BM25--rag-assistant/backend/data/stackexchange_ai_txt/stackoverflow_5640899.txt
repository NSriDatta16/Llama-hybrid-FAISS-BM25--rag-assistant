[site]: stackoverflow
[post_id]: 5640899
[parent_id]: 5640748
[tags]: 
No , i is not necessarily any value. The result is implementation-defined. † The representation of pointers, in C++, is implementation-defined, including the representation of a null pointer. When you assign an integer value of zero to a pointer, you set that pointer to the implementation-defined null pointer value, which is not necessarily all-bits-zero. The result of casting that value to an integer is, by transitivity, implementation-defined. Even more troublesome, though, is that the mapping done by reinterpret_cast is implementation-defined anyway. So even if the null pointer value was all-bits-zero, an implementation is free to make the result whatever it wants. You're only guaranteed that you'll get the original value when you cast back. That all said, the next sentence after your quote includes the note: [ Note: It is intended to be unsurprising to those who know the addressing structure of the underlying machine. —end note ] So even though specific mappings are not required, pragmatically you can take an educated guess. † Assuming long is large enough. In C++0x use uintptr_t , optionally defined in .
