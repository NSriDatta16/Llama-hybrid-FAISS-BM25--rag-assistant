[site]: stackoverflow
[post_id]: 4052526
[parent_id]: 4049162
[tags]: 
As others have said, re-factoring to use interfaces or using the dynamic approach are probably the most elegant ways. If this is not possible you could cast the object to your types. I'd suggest using as and then checking that the cast worked, an unchecked cast would be dangerous if someone called this with a type that failed to cast. E.g. If types A and B both have a method called DoSomething() then this will work... public static void CallDoSomething(object o) { A aObject = o as A; if (aObject != null) { aObject.DoSomething(); return; } B bObject = o as B; if (bObject != null) { bObject.DoSomething(); return; } } BUT this is pretty ugly to be honest... I'd really try and refactor to interfaces.
