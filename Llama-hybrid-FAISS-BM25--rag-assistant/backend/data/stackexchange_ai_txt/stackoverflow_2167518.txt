[site]: stackoverflow
[post_id]: 2167518
[parent_id]: 
[tags]: 
c++ stl: a good way to parse a sensor response

Attention please: I already implemented this stuff, just not in any way generic or elegant. This question is motivated by my wanting to learn more tricks with the stl, not the problem itself. This I think is clear in the way I stated that I already solved the problem, but many people have answered in their best intentions with solutions to the problem , not answers to the question "how to solve this the stl way". I am really sorry if I phrased this question in a confusing way. I hate to waste people's time. Ok, here it comes: I get a string full of encoded Data. It comes in: N >> 64 bytes every 3 byte get decoded into an int value after at most 64 byte (yes,not divisible by 3!) comes a byte as checksum followed by a line feed. and so it goes on. It ends when 2 successive linefeeds are found. It looks like a nice or at least ok data format, but parsing it elegantly the stl way is a real bit**. I have done the thing "manually". But I would be interested if there is an elegant way with the stl- or maybe boost- magic that doesn't incorporate copying the thing. Clarification: It gets really big sometimes. The N >> 64byte was more like a N >>> 64 byte ;-) UPDATE Ok, the N>64 bytes seems to be confusing. It is not important. The sensor takes M measurements as integers. Encodes each of them into 3 bytes. and sends them one after another when the sensor has sent 64byte of data, it inserts a checksum over the 64 byte and an LF. It doesn't care if one of the encoded integers is "broken up" by that. It just continues in the next line.(That has only the effect to make the data nicely human readable but kindof nasty to parse elegantly.) if it has finished sending data it inserts a checksum-byte and LFLF So one data chunk can look like this, for N=129=43x3: | |1byte checksum|LF | |1byte checksum|LF | |1byte checksum|LF LF When I have M=22 measurements, this means I have N=66 bytes of data. After 64 byte it inserts the checksum and LF and continues. This way it breaks up my last measurement which is encoded in byte 64, 65 and 66. It now looks like this: 64, checksum, LF, 65, 66. Since a multiple of 3 divided by 64 carries a residue 2 out of 3 times, and everytime another one, it is nasty to parse. I had 2 solutions: check checksum, concatenate data to one string that only has data bytes, decode. run through with iterators and one nasty if construct to avoid copying. I just thought there might be someting better. I mused about std::transform, but it wouldn't work because of the 3 byte is one int thing.
