[site]: stackoverflow
[post_id]: 3535215
[parent_id]: 3535024
[tags]: 
It's a tough concept to implement in C++, as you're seeing. I'm always a proponent of using the Boost library, which has already solved it for you . You can typedef the complex boost variant template class to something more usable in your specific domain, so typedef boost::variant ParamT; class Param { public: // initialize the variants Param(ParamT min, ParamT max, ParamT value) : m_Min(min), m_Max(max), m_Value(value) {} // example accessor template const ParamT& value() { return boost::get (m_Value); } // other accessors for min, max ... private: ParamT m_Min, m_Value, m_Max; }; Param speed(-10.0f, 10.0f, 0.0f); float speedValue = speed.value (); Now, to add another type to your variant (eg, long, std::string, whatever) you can just modify the typedef of ParamT; The catch, here, is that the burden of checking the types is on you - it'll throw an exception if you store a float and try to receive an int, but there's no compile-time safety. If you want to get really crazy, you can implement an overloaded cast operator on a proxy object.... class ProxyValue { public: ProxyValue(ParamT& value) : m_Value(value) {} template operator ValueT() { return boost::get (m_Value); } private: ParamT& m_Value; }; You'd return this from a non-templated value() function in Param, instead of the variant itself. Now you can assign a value without the template call.. Param speed(-10.0f, 0, 10); float speedValue = speed.value(); Though fair warning, you're stepping into meta-programming hell here. Here thar be dragons. And as always, this is not a complete solution, just a pointer. YMMV. Heres a roughly working version showing how to use it, and the failures that are easy to hit.
