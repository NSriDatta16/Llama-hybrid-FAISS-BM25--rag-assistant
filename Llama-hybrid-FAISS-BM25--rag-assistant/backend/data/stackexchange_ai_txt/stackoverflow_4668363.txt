[site]: stackoverflow
[post_id]: 4668363
[parent_id]: 4668083
[tags]: 
I think what Brian was trying to say by "poorly written" is that you do not have a separation between business logic and data access code (and database connection mechanics, while at it). A correct approach to writing functions is that a function (or method) should do one thing , not 3 things at once. As a result of this big lump of functionality, when testing , you have to test ALL THREE at the same time, which is difficult (see discussion of using "test SQLite DB" in those paragraphs). Or, as an alternative, do what the chapter was devoted to, and mock the DBI object to test the business logic by pretending that the data access AND DB setup worked a certain way. But mocking a complicated-behaving object like DBI is very and very complicated to do right. What if the database is not accessible? What if there's blocking? What if your query has a syntax error? What if the DB connection times out when executing the query? What if... Good test code tests ALL those error situations and more. A more correct approach (pattern) for the code would be: my $dbh = set_up_dbh(); my $query = qq[select key, calculate(value) from my_table]; my $data = retrieve_data($dbh, $query); # Now, we don't need to test setting up database connection AND data retrieval my $calc_results = calculate_results($data); This way, to test the logic in calculate_results (e.g. summing the data), you merely need to mock DATA passed to it, which is very easy (in many cases, you just store several sets of test data in some test config); as opposed to mocking the behavior of a complicated DBI object used to retrieve the data.
