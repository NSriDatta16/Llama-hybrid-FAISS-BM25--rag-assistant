[site]: stackoverflow
[post_id]: 759674
[parent_id]: 758801
[tags]: 
There is a conceptual basis for database design. In classical database design, there are three models: conceptual, logical, and physical. The conceptual model emerges from requirements analysis, and evolves as the underlying subject matter evolves or as understanding of the subject matter evolves. The conceptual model pins down elementary data as to form and semantics, but doesn't deal with such issues as table composition. The logical model uses the relational model of data. It can be derived from the conceptual model, but it also deals with the composition of relations. Normalization and other composition issues come into play here. The logical model anticipates the table design, and also the queries and updates the application will make. The physical model implements relations as tables, and also adds all the other features like indexes, tablespaces, etc. needed to actually build the database. It's derived from the logical model, but data volume, load, performance, and disk space all come into play. This sounds lengthy and tedious, but it's actually fast, if you know how to do it. The whole thing can be done in a matter of weeks, while the rest of the team is still debating functional specs. For a really small project (6 tables, 50 columns) it can be done in days, with just pencil and paper. For larger projects, there are tools that make design more automatic, less error prone, and easily diagrammed. But what happens when you discover that the conceptual model was inaccurate or incomplete, and the other two models and the database itself need to be altered? That's where Data Independence comes to the rescue. Data independence does for database design what encapsulation does for object design. Namely, it prevents a minor adjustment in one place from propagating all over the application objects. Objects are only dependent on the data that they use. If a new table has to be added to a schema, the chances that any application will be broken is vanishingly small. Even if an existing table has to be altered, queries that only use the old columns won't see any difference. Even when objects are dependent on the change, you can still give the altered table a new name, and then create a view with the old name that makes it look like the old table is still there. And physical data independence is almost complete in a good DBMS. You can reorganize data, add and drop indexes, etc. and you shouldn't have to change any of the application. In short, change management can be done brilliantly using the really good DBMS products out there. Unfortunately, a lot of the DBAs and programmers don't know how to make adequate use of these DBMS features, even though they have been around for years.
