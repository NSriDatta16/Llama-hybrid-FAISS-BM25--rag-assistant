[site]: stackoverflow
[post_id]: 2910635
[parent_id]: 2910520
[tags]: 
If you have one single field as in your example, I think @Override public boolean equals(Object o) { return (o instanceof Thing) && (this.x == ((Thing) o).x); } is the way to go. Anything else would be overly complicated imo. But if you add a field (and don't want to pass the 80-column recommendation by sun) it would look something like @Override public boolean equals(Object o) { if (!(o instanceof Thing)) return false; Thing t = (Thing) o; return this.x == t.x && this.y == t.y; } which I think is slightly uglier than public boolean equals(Thing o) { return this.x == o.x && this.y == o.y; } @Override public boolean equals(Object o) { // note that you don't need this.equals(). return (o instanceof Thing) && equals((Thing) o); } So my rule of thumb is basically, if need to cast it more than once in override-only , do the override-/overload-combo . A secondary aspect is the runtime overhead. As Java performance programming, Part 2: The cost of casting explains: Downcast operations (also called narrowing conversions in the Java Language Specification) convert an ancestor class reference to a subclass reference. This casting operation creates execution overhead, since Java requires that the cast be checked at runtime to make sure that it's valid. By using the overload-/override-combo , the compiler will, in some cases (not all!) manage to do without the downcast. To comment on @Snehal point, that exposing both methods possibly confuses client-side developers: Another option would be to let the overloaded equals be private. The elegance is preserved, the method can be used internally, while the interface to the client side looks as expected.
