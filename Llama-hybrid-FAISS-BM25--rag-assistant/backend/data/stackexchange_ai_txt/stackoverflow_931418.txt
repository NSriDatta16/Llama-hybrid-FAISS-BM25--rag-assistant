[site]: stackoverflow
[post_id]: 931418
[parent_id]: 918776
[tags]: 
Your extension method is actually written fairly well. Its a side-effect free method, and is extending an interface, rather than a concrete class. Your almost there, but you just need to go a little farther. You are trying to mock the .GetEnabledBuildAgents(...) extension method...however thats not actually mockable (by anything except TypeMock Isolator, which is the only thing that can actually mock statics at the moment...however its fairly pricy.) You are actually interested in mocking the method on IBuildAgent that your extension method calls internally: .CreateBuildAgentSpec(...). If you think it through, mocking the CreateBuildAgentSpec method will solve your problem. The extension method is "pure", and so really doesn't need to be mocked. It has no state and causes no side effects. It calls a single method on the IBuildAgent interface...which is the first clue that directs you to what really needs to be mocked. Try the following: [TestMethod] public void SelectReturnsNullOnNullBuildAgents() { Mocks = new MockRepository(); IBuildServer buildServer = Mocks.CreateMock (); BuildAgent agent = new BuildAgent { ... }; // Create an agent BuildAgentSelector buildAgentSelector = new BuildAgentSelector(); using (Mocks.Record()) { Expect.Call(buildServer.CreateBuildAgentSpec(TeamProjectName)).Return(new List { agent }); } using (Mocks.Playback()) { BuildAgent buildAgent = buildAgentSelector.Select(buildServer, TeamProjectName); Assert.IsNull(buildAgent); } } By creating a BuildAgent instance, and returning it in a List , you effectively return an IEnumerable that your Select method may operate on. That should get you going. You may need to do some additional mocking in case simply returning a basic BuildAgent instance isn't sufficient, or in case you need more than one. When it comes to mocking results to be returned, Rhino.Mocks can be a REAL pain in the rear to work with. If you run into troubles (which, given my experience with it, you are quite likely to), I recommend you give Moq a try , as it is a much nicer and more tester-friendly framework to work with. It doesn't require a repository, and eliminates the Record/Playback and using() statement heavy notation that Rhino.Mocks required. Moq also provides additional capabilities that other frameworks don't offer yet that, once you get into heavier mocking scenarios, you will fall in love with (i.e. the It.* methods.) Hope this helps.
