[site]: stackoverflow
[post_id]: 5158467
[parent_id]: 5157936
[tags]: 
How about something like... public abstract class JobBase { private TDetails details; protected TDetails Details { get { if (details == null) { this.details = this.LoadDetails(); } return this.details; } } protected virtual TDetails LoadDetails() { // Some kind of deserialization of TDetails from your DB storage. } } public class ExampleJob : JobBase { public class ExampleJobDetails { public string ExampleProperty { get; set; } public int AnotherProperty { get; set; } } } You'd either want to have tables for each type used as TDetails or one big Key/Value based table for all of them. There are pros/cons to both. If you are super paranoid about boxing, there's no reason why TDetails can't be constrained to be a struct, too. Edit: Got it backwards, you want to save the details on a failure. How about... public abstract class JobBase { protected TDetails Details { get; private set; } public JobBase() { this.Details = this.CreateDetails(); } protected abstract TDetails CreateDetails(); protected void SaveDetails() { // Generic save to database. } } public class ExampleJob : JobBase { public class ExampleJobDetails { public string ExampleProperty { get; set; } public int AnotherProperty { get; set; } } protected override ExampleJobDetails CreateDetails() { return new ExampleJobDetails() { ExampleProperty = "Hi.", AnotherProperty = 1 }; } }
