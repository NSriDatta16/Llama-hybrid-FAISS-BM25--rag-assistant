[site]: stackoverflow
[post_id]: 4940346
[parent_id]: 4792322
[tags]: 
I cant seem to add a comment so adding another answer. It's not that complicated and I would suggest it's less fragile than putting 1/2 your business logic in your domain and the other half in your database trigger. Personally I would write my own list object with a reference to the history list for the some_list_of_other_entities and in the Remove and Add methods maintain your history records. This way your objects are automatically up to date before even saving them into your ORM. public class ListOfOtherEntities : System.Collections.IEnumerable { // Add list stuff here... public void Remove(MyEntity obj) { this.List.Remove(obj); this.History.Add(new History("Added a object!"); } public void Remove(MyEntity obj) { this.List.Remove(obj); this.History.Add(new History("Removed a object!"); } } This way your objects are automatically up to date before even saving them into your ORM and another developer looking at the code can see what you have done quite easily.
