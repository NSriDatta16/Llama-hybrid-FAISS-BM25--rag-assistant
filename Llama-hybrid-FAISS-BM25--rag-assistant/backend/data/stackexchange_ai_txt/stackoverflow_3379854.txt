[site]: stackoverflow
[post_id]: 3379854
[parent_id]: 3379795
[tags]: 
Quite simply, to save memory -- but please note carefully that declaring these arrays as char limits the result distance to either 127 or 255, depending on whether the C compiler defaults to signed char or unsigned char respectively. In C, char is an integer type -- you don't need an ord() to get its integer value. Your original code contains no mention of this limitation. Note that if a char overflows, it does so silently and the code will produce incorrect results -- 127 + 1 -> -128 (signed); 255 + 1 -> 0 (unsigned). You didn't respond to my comment on your original question: """What are the (a) maximum (b) average sizes of your strings? Do you really need to do the whole O(M*N) thing if the two strings are nothing like each other?""" ..... Please answer that now (edit your question); had you done so then, you would have had this question answered then. Update: Reading the original post again, I've noticed a problem: The code that reads m1, m2 = m2, m1 strcpy( m3, m2 ) is WRONG on three grounds: (1) it doesn't shuffle the rows properly (should do strcpy() before swapping m1 and m2 ) (2) strcpy() will not copy anything beyond the first null (zero byte) (3) there is no need to copy anything, just shuffle the pointers m3, m2, m1 = m2, m1, m3
