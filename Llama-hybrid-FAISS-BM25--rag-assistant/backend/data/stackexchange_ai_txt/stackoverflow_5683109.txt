[site]: stackoverflow
[post_id]: 5683109
[parent_id]: 5680832
[tags]: 
The issue likely has to do with "Parameter Sniffing" and the article linked by @Mikael talks about that. Unfortunately, this is one of the main down-sides to using an ORM as you lose the ability to tweak the SQL for performance. Here are some things to try: Run DBCC FREEPROCCACHE and run the query from the app again to see if that has any difference. Running it multiple times will not get a new execution plan because it is already cached from the first run. Be sure to rebuild the indexes on the Tables to make sure that the statistics are up to date (a rebuild, not defrag should automatically update the stats) If need be, you can always convert this operation to a Stored Procedure and call that from LINQ-to-SQL. You just might then have to pass in the list of values as a comma- separated list or XML. If you are on SQL Server 2008 (or newer) the best solution would be to construct a DataTable on the app side and pass that into the Proc as a Table-Valued Parameter and use that in an INNER JOIN instead of an IN list. Also, your second and third tests are basically the same as Ad Hoc queries have their plans cached with a key based on the EXACT text of the query, including spaces, etc. So wrapping it in an EXEC really shouldn't change how the optimizer sees it.
