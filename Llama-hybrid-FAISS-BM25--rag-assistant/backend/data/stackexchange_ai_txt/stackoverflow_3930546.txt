[site]: stackoverflow
[post_id]: 3930546
[parent_id]: 3930510
[tags]: 
Actually, your existing Select call is modifying the original objects themselves - it's not creating new employee objects. What makes you think it is creating new Employee instances? After all, you haven't got new Employee anywhere within the lambda expression. You could iterate through the results of calling Select without ever calling ToList , and you'd still see changes afterwards. This means your projection has side-effects - that's generally a bad idea. You do have to make something iterate over the results of the projection though. Just calling Count() would do it, for example. LINQ queries use deferred execution in many cases: they don't apply the projection/predicate/etc until the result is needed. LINQ is designed to work in a functional way: side-effects are discouraged, just as you wouldn't expect a normal SELECT query on a database to change the contents of the table it's querying. Side-effect-free code is great in terms of readability and the ability to reason about code. If you want to change values rather than create new ones, I would suggest a simple foreach loop instead. It's not what LINQ is designed for. However, I would personally try to stick to immutable types, use LINQ, and measure the performance as you go - I suspect you'll find that in many cases it's not as bad as you think.
