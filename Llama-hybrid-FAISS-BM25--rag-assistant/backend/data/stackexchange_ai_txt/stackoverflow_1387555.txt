[site]: stackoverflow
[post_id]: 1387555
[parent_id]: 1387354
[tags]: 
Update : This solution has a subtle bug. The MVC framework will call into FindView / FindPartialView twice: once with useCache=true , and if that doesn't return a result, once with useCache=false . Since there's only one cache for all types of views, mobile users may end up seeing desktop views if a desktop browser was first to arrive. For those interested in using custom view engines to solve this problem, Scott Hanselman has updated his solution here: http://www.hanselman.com/blog/ABetterASPNETMVCMobileDeviceCapabilitiesViewEngine.aspx (Apologies for the answer hijack, I just don't want anyone else to have to go through this!) Edited by roufamatic (2010-11-17) The first thing you want to do is introduce the Mobile Device Browser File to your project. Using this file you can target what ever device you want to support without having to know the specifics of what those devices send in their headers. This file has already done the work for you. You then use the Request.Browser property to tailor which view you want to return. Next, come up with a strategy on how you want to organize your views under the Views folder. I prefer to leave the desktop version at the root and then have a Mobile folder. For instance the Home view folder would look like this: Home Mobile iPhone Index.aspx BlackBerry Index.aspx Index.aspx I have to disagree with @Mehrdad about using a custom view engine. The view engine serves more than one purpose and one of those purposes is finding views for the controller. You do this by overriding the FindView method. In this method, you can do your checks on where to find the view. After you know which device is using your site, you can use the strategy you came up with for organizing your views to return the view for that device. public class CustomViewEngine : WebFormViewEngine { public override ViewEngineResult FindView(ControllerContext controllerContext, string viewName, string masterName, bool useCache) { // Logic for finding views in your project using your strategy for organizing your views under the Views folder. ViewEngineResult result = null; var request = controllerContext.HttpContext.Request; // iPhone Detection if (request.UserAgent.IndexOf("iPhone", StringComparison.OrdinalIgnoreCase) > 0) { result = base.FindView(controllerContext, "Mobile/iPhone/" + viewName, masterName, useCache); } // Blackberry Detection if (request.UserAgent.IndexOf("BlackBerry", StringComparison.OrdinalIgnoreCase) > 0) { result = base.FindView(controllerContext, "Mobile/BlackBerry/" + viewName, masterName, useCache); } // Default Mobile if (request.Browser.IsMobileDevice) { result = base.FindView(controllerContext, "Mobile/" + viewName, masterName, useCache); } // Desktop if (result == null || result.View == null) { result = base.FindView(controllerContext, viewName, masterName, useCache); } return result; } } The above code allows you set the view based on your strategy. The fall back is the desktop view, if no view was found for the device or if there isn't a default mobile view. If you decide to put the logic in your controller's instead of creating a view engine. The best approach would be to create a custom ActionFilterAttribute that you can decorate your controller's with. Then override the OnActionExecuted method to determine which device is viewing your site. You can check this blog post out on how to. The post also has some nice links to some Mix videos on this very subject.
