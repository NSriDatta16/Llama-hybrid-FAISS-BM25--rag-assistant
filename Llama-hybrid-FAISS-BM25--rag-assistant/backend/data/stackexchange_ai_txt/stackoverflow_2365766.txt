[site]: stackoverflow
[post_id]: 2365766
[parent_id]: 2365718
[tags]: 
You look like you're trying to use lockless syncronization (using while(scanning) to check a boolean that's set at the start of the function and reset at the end), but all this succeeds in doing is only running one retrieval at a time. Is there a reason that you don't want them to run concurrently? This seems like the entire point of your exercise. I can't see a reason for this, so I'd lose the scanning flag (and associated logic) entirely. If you're going to take this approach, your boolean flags need to be declared as volatile (otherwise their reads could be cached and you could wait endlessly) Your data update operations (updating the value in the DataRow ) must take place on the UI thread. You'll have to wrap these operations up in a Control.Invoke or Control.BeginInvoke call, otherwise you'll be interacting with the control across thread boundaries. BeginInvoke returns an AsyncWaitHandle . Use this for your logic that will take place when the operations are all complete. Something like this - WaitHandle[] handles = new WaitHandle[] { d.BeginInvoke(...), d.BeginInvoke(...), d.BeginInvoke(...), d.BeginInvoke(...), d.BeginInvoke(...) } WaitHandle.WaitAll(handles); This will cause the calling thread to block until all of the operations are complete.
