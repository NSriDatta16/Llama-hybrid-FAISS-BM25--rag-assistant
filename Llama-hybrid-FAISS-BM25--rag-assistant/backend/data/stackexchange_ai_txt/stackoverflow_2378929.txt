[site]: stackoverflow
[post_id]: 2378929
[parent_id]: 2378867
[tags]: 
Many-to-One Parent contains a property Child, the child may be linked from several parents. class Parent { public virtual MyItem Child { get; set; } } Many-to-Many with a join table Parent contains a collection of Children, the children may be linked from several parents. class Parent { public virtual IList Children { get; set; } } Criteria Querying // find Parent with child named "foo". DetachedCriteria.For () .CreateAlias("Child", "c") .Add(Restrictions.Eq("c.Name", "foo")); // find Parent with particular child DetachedCriteria.For () .Add(Restrictions.Eq("Child", child )); // find Parent with one of children named "foo". DetachedCriteria.For () .CreateAlias("Children", "c") .Add(Restrictions.Eq("c.Name", "foo")); // find a "page" of children for a parent DetachedCriteria.For () .Add(Restrictions.Eq("Id", parent.Id )) .CreateAlias("Children", "c") .SetFirstResult( 1041 ) .SetMaxResults( 20 ) .GetExecutableCriteria( session ) .List (); That last query may or may not be more efficiently done by using just lazy-loading the whole children collection on first access, and then indexing into it on subsequent "pages". It depends on your data and usage. Unless I knew a priori that the child collections will be gigantic, I would go the lazy load route first. If timings and profiling show serious slowness, then I would switch to the Criteria method.
