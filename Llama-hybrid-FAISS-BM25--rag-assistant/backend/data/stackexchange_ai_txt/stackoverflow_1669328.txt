[site]: stackoverflow
[post_id]: 1669328
[parent_id]: 1662466
[tags]: 
You could use the Template Method pattern with the Strategy pattern: Your Controller becomes a Template Method. For each step of the email sending process, you call out to a delegate/Strategy class that implements the step. public class EmailSender { private iOutboxGetter outboxGetter; private iMsgValidator validator; private iMsgFormatter formatter; private iMsgSender sender; //setters for each stragegy, or a constructor //good use for IOC container public iSendResult SendMessage(iMsgParams params) { try { var outbox = outboxGetter.getOutbox(params.outbox); var validationResults = validator.validate(params); if(validationResults.IsValid) { var msg = formatter.formatMsg(params.message); sender.send(msg); return new AllGoodSendResult(); } else { return new ValidationFailedSendResult(validationResults); } } catch(CatastrophicException e) { Pager.SendCriticalPage(e.message); return new CatistrophicFailureSendResult(e); } } } I prefer to use exceptions when the code must deviate from the Happy Path. I feel they keep the logic and the error handling cleanly separated. Edit: The return from the SendMessage method indicates to the caller whether validation passed or not, and what failed in validation. The caller can then prompt the user for more information and retry, or indicate success. An exception is only thrown in the event of a truely exceptional circumstance. Using this approach, each component of your algorithm can be mocked and tested independently and no Strategy needs to know how any other Strategy works, nor does it need to know how to handle someone else's errors. Finally, all of your error handleing is centeralized in a single place.
