[site]: stackoverflow
[post_id]: 5016771
[parent_id]: 5016395
[tags]: 
This works in a stream like fashion and does what I think you want: #include #include #include int main(int argc, char** argv) { long pos = 0; char buf; char str[5] = {'\0','\0','\0','\0','\0'}; while ( fread(&buf, sizeof(char), 1, stdin) > 0 ) { pos++; str[0] = str[1]; str[1] = str[2]; str[2] = str[3]; str[3] = buf; str[4] = '\0'; /* uncomment to see what got read ** printf("Read %s\n", str); */ if ( strcmp(str, "data") == 0 ) { break; } } printf("\"data\" occured after %ld bytes\n", pos); return 0; } This works by using a buffer I've called str and rotating the positions around in it. It will work until data appears. Be aware it reads binary data, not text. So anything on stdin gets read, newlines included. However, if you adapt that to a file handle that shouldn't be a problem. You can probably include this. The problem with using fread is that by design: The file position indicator for the stream (if defined) shall be advanced by the number of bytes successfully read. Therefore if you advance by 4 bytes at a time, unless your data is exactly a multiple of 4 from the start of the data, you're going to miss it. For example: 123DATA Fails if you read 4 bytes at a time. Now, given this is a documented file format, are there not some header specs somewhere that tell you exactly how wide the fields are on the header? Or at least where they vary, such that you can read them off appropriately? Reading until data works, but isn't elegant, really. Or, better still, I'm sure there must be a library for doing this somewhere. Edit In response to the header of the wave file, since it is fixed and not that large, read the whole thing into a buffer. uint8_t* hdr = malloc(36*sizeof(uint8_t)); fread(hdr, sizeof(uint8_t), 36); Don't forget to free. At this point, you have the entire header extracted. I've used uint8_t to definitely be 8 bits. At this stage you can pull some interesting tricks, like casting that data to a struct. Just be aware of the endianness of the fields. From then on, the stream is available to you in chunks, I believe. The first thing you need to do is this: uint8_t chkid; uint8_t chksz; fread(&chkid, sizeof(uint8_t), 4, stream); fread(&chksz, sizeof(uint8_t), 4, stream); That'll grab you the data of that particular chunk. Assuming you're using a little endian system, You ought to be able to use chksz directly as an integer at this point, so now you can do: uint8_t dataframe = malloc(chksz * sizeof(uint8_t)); Into which you can read the data: fread(&dataframe, sizeof(uint8_t), chksz, stream); This is of course assuming that the Apple wave format is the one described. Now, from that page: The WAVE file format is a subset of Microsoft's RIFF specification for the storage of multimedia files. A RIFF file starts out with a file header followed by a sequence of data chunks. A WAVE file is often just a RIFF file with a single "WAVE" chunk which consists of two sub-chunks -- a "fmt " chunk specifying the data format and a "data" chunk containing the actual sample data. Call this form the "Canonical form". Who knows how it really all works. I've given you instructions that if used in a continual loop until there's nothing more on the stream, will allow you to read any number of data chunks a-la RIFF. You then need to process the data you get appropriately to break it down; i.e. split your data chunk that you read in up appropriately. If this is the only format you expect to read, you could just ignore additional chunks. Now, the problem remains, what is the apple format and to be honest I've no idea!
