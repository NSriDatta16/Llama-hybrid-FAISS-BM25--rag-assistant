[site]: stackoverflow
[post_id]: 2771117
[parent_id]: 2769174
[tags]: 
If I may add my own 2 cents. First of all, as @Potatoswatter remarked, unless your elements are cheap to copy (built-in/small PODs) you'll want to use pointers to the original elements rather than copying them. Second, there are 2 strategies available. Simply ensure there is no duplicate inserted in the first place. This means, of course, controlling the insertion, which is generally achieved by creating a dedicated class (with the vector as attribute). Whenever the property is needed, check for duplicates I must admit I would lean toward the first. Encapsulation, clear separation of responsibilities and all that. Anyway, there are a number of ways depending on the requirements. The first question is: do we have to let the elements in the vector in a particular order or can we "mess" with them ? If we can mess with them, I would suggest keeping the vector sorted: Loki::AssocVector should get you started. If not, then we need to keep an index on the structure to ensure this property... wait a minute: Boost.MultiIndex to the rescue ? Thirdly: as you remarked yourself a simple linear search doubled yield a O(N 2 ) complexity in average which is no good. If is already defined, then sorting is obvious, with its O(N log N) complexity. It might also be worth it to make T Hashable, because a std::tr1::hash_set could yield a better time (I know, you need a RandomAccessIterator, but if T is Hashable then it's easy to have T* Hashable to ;) ) But in the end the real issue here is that our advises are necessary generic because we lack data. What is T , do you intend the algorithm to be generic ? What is the number of elements ? 10, 100, 10.000, 1.000.000 ? Because asymptotic complexity is kind of moot when dealing with a few hundreds.... And of course: can you ensure unicity at insertion time ? Can you modify the vector itself ?
