[site]: stackoverflow
[post_id]: 1089916
[parent_id]: 1089896
[tags]: 
There is no " Security Through Obscurity ". If you consider all code public at all times, you stand a better chance of implementing something that is actually secure. If you "hide" code or "hide" the passwords, you've made a terrible mistake. Here's how to hack the password on Jet. http://lastbit.com/access/ Security is a deep issue. You can't throw a password in a file. You can throw hashes of passwords in files. You have two complementary issues. Authentication. Who is the user? This is what passwords and passphrases can tell you: Who's connecting. Authorization. What can this user do? This is why you have separation of duties. Security officers who set passwords and users who must provide passwords and have access to data need to be separate people. Edit "A password will be picked at install time, used to secure the database, then encrypted for the application to pick up, decrypt, and use to open db connections." Doesn't work. The encryption key for the password file is available in the application, making it all open. "Is there any way to code this so that even with the file and the code, my co-workers won't be able to get into the db?" Yes. This is easy. Use hashes of passwords, not encrypted passwords. "giving the password only to management" Wrong. If you give the password to someone then too many people know the password. This breaks authentication. People have to set their own passwords, otherwise they're not authenticated. Edit What to do? Define -- precisely -- your authentication and authorization needs. Don't pick a technology. Define the users and their use cases. Define the authorizations each class of users has. Don't pick the technology. Define the access. You don't mention really, really important things in your question. You don't mention if you have multiple users, for example. You just mention a specific technology (JET) and a specific technique (the DB-level password). You don't mention if these users share a database. If you have multiple users with a shared database, then it's best for this database to be on a server somewhere. Not on a desktop somewhere. Not part of a specific desktop. Not spread across multiple desktops. If you don't have a shared database -- if every user has a private database -- then you have separate installations where the ordinary Windows security is fine. Why obscure anything? Pick an architecture. You have Active Directory. This gives you user names and securely hashed passwords. Leverage this. SQL/Server can use AD for user authentication and authorization. This is reasonably secure if people don't share their passwords. Build something that works. AD groups. Central DB in SQL/Server. Admin procedures for creating users, resetting passwords, moving users from group to group, etc. This isn't hard. It's in the AD documentation. Any Windows Sysadmin can provide guidance on how they like to do this. Document the procedures. They're part of the security model. Winforms application that can be installed on desktops. Users will be leveraging their existing windows credentials. Logged into windows means your winforms app can log them into the database and away they go. Securely. MSI for the desktop component. Since there's no "master db password" or other junk, they're just installing a simple app. They configure the location of the central DB server. They login with their existing windows credentials.
