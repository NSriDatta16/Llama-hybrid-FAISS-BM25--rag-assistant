[site]: stackoverflow
[post_id]: 4875677
[parent_id]: 4875010
[tags]: 
I agree with Vijay's answer for the most part, but it is important to note that leaks occur when references to heap blocks (pointers) are lost. The two common causes are: 1 - Losing scope of the pointer void foo(void) { char *s; s = strdup("U N I C O R N S ! ! !"); return; } In the above, we've lost scope of the pointer s , so we have absolutely no way to free it. That memory is now lost in (address) space until the program exits and the virtual memory subsystem reclaims everything the process had. However, if we just changed the function to return strdup("U N I C O R N S ! ! !"); , we'd still have reference to the block that strdup() allocated. 2 - Re-assigning pointers without saving the original void foo(void) { unsigned int i; char *s; for (i=0; i In this example, we've lost 99 references to blocks that s once pointed to, so we're only actually freeing one block at the end. Again, this memory is now lost until the OS reclaims it after the program exits. Another typical misconception is that memory that is still reachable at program exit is leaked if the program does not free it prior to exiting. This has not been true for a very long time. A leak only happens when there is no way to dereference a previously allocated block in order to free it. It should also be noted that dealing with the static storage type is a little different, as discussed in this answer .
