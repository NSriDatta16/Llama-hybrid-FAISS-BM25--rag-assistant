[site]: stackoverflow
[post_id]: 5237458
[parent_id]: 
[tags]: 
Differences between open64 versus llvm compilers

Could someone point out the differences between the open64 and llvm? I know that the open64 uses whirl IR which has 5 stages and differs a lot since each stage lowers significantly the code to the machine whereas the llvm has a single IR which is used in midlevel optimizations, later is lowered into target independent instructions (dags) and dependent ones. 1) Is whirl also SSA, 2) and does it uses virtual registers, 3) does open64 has modular design like llvm, 4) is it easy to develop pass and plug it into the toolchain? Both compilers excel at midlevel interprocedural optimizations and transformations but 5) does open64 have support for JITting or any kinds of dynamic translation natively built into the framework? It looks that the quality of CG more or less is similar in both cases. 6) What about the front ends, is it possible to easily extend ones with pragmas or bind new ones without modifying the Whirl IR (that is the problem with SUIF)? As far as I can tell the open64 is widely used in many commercial and academical projects (UPC, AMD, Nvidia, Tensilica) but it looks that there are many branches of it (growing after 2003) and each has it's own features and limitations. Moreover, there isn't fixed developer community and environment or support, the documentation hardly exists in contrast to the llvm, and simply there isn't simple one direction in which the compiler advances. There are also differences in licensing where the llvm matches more to BSD licensing style and the open64 is based on GPL.
