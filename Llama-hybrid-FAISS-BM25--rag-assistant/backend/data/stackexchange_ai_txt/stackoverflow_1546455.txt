[site]: stackoverflow
[post_id]: 1546455
[parent_id]: 1546381
[tags]: 
Actually your approach is wrong. Encoding is very important here. If you use ASCII then you can easily say that each character is stored in a byte (eight bits) but when encoding changes you cannot say that. Eg: UTF-8 uses one to three bytes (8 to 24 bits) for each character on a string. That is why you will see an overload in which you can specify the encoding on inputstream object. Choosing wrong input stream will absolutely cause a wrong string output. Thus you have to know the encoding of the file to understand which bit means what. Actually fileinputstream does this for you. If you store a digit as string it will take a char length in hard drive. Just like another character. However if you store 123456789 as string with ASCII encoding it will take 9*8 bits = 72 bits. If you store this as integer, (note that integer's data width differs in different environments) it will only take 16 bits. Also you cannot be sure that H : 01001000 e : 01100101 l : 01101100 l : 01101100 o : 01101111 : 00100000 W : 01010111 o : 01101111 r : 01110010 l : 01101100 d : 01100100 \n: 00001010 is stored in hard drive as H : 01001000 e : 01100101 l : 01101100 l : 01101100 o : 01101111 : 00100000 W : 01010111 o : 01101111 r : 01110010 l : 01101100 d : 01100100 \n: 00001010 You cannot be sure of that. File System is not that simple. Maybe Hello is successive but World string is at the end of drive. Thats why there is defrag command. But if we talk about main memory (RAM) when you define a string i expect bits to be successive. At least in C it is. You define a string like that. char[100] value; // c is a char array. (there is no string type in c) here value[0] is the first character of our string. And value only addresses to the char arrays location in memory. if value[0]'s address is 10 then value[1]'s address is 10+8 = 18.
