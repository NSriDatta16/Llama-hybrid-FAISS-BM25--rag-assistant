[site]: stackoverflow
[post_id]: 3055967
[parent_id]: 2955796
[tags]: 
This is afaik not possible. And there are several good reasons why the runtime doesn't allow this. The memory layout of your object is part of the JVM internals. Each JVM can make it own decisions how to layout objects. This layout can change over releases. When you memory-map a object to a file, you would run into trouble. What happens when the object-layout has changed? Crash, update the file, do magic? In the end memory-mapping objects to files would require to specify a fixed object-layout. What happens if you add/remove a field? Then the object-layout has changed for sure. You cannot memory-map a file with the old memory-layout. A object has also additional information, like the VTable for virtual function-calls, fields for lock-states etc. Do you want the map them also? Probably not, because thats internal runtime-state. So you would require to alway ignore a few bytes or split-up objects. That would make the memory-layout extremely complex. The garbage collector compacts the memory to minimize fragmentation by moving objects around. Therefore there needs to be a 'fixation'-mechanism for objects. (that's possible in .NET, for interop-reasons) The garbage collector works in generations. A object if first allocated on a young generation. As it survives it is moved to other generation. A memory-mapped object would require an exception. For all these reasons you cannot memory-map Java/.NET-objects. Supporting such a feature would make the JVM/CLR extremely complex. The JVM/CLR still give you access to Memory-Mapped files as an array-like abstraction, where you can write/read bytes. On top of this you can implement your persistence-mechanism. From simple serialisation to complex databases. There are object-databases which come quite close to provide transparent persistence. Then objects behave like persistent datastructures / memory-mapped objects.
