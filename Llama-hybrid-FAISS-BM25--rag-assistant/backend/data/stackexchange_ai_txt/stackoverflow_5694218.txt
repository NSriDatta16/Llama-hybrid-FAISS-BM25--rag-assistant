[site]: stackoverflow
[post_id]: 5694218
[parent_id]: 5685040
[tags]: 
OK, here's the skinny. It's an Array! $.isArray(val) will return true and identify it as such, and it can be iterated with $.each(); just like other objects. It is a valid object structure, from valid JSON, and can be avoided by using the JSON_FORCE_OBJECT option in PHP's json_encode(); function. For my needs it is better to not force the object because I'm also dealing with arrays of integers I want returned on a single line. For my needs I changed the first if() in my recusion function from this... if((val == '[object Object]') && (typeof val == 'object')){ to this... if((val != null) && (typeof val == 'object') && ((val == '[object Object]') || (val[0] == '[object Object]'))){ That will match objects, or arrays of objects, then send them back to resurse(); Oddly, Javascript complains when val is null and we test against val[0]. I guess it probably makes sense, because you aren't just testing against the value, your also trying to dive into the null object. Thanks for your attention, I figured out my issue, and I've now got an account on Stackoverflow. It's a win-win-win! Thanks again. Skip Here is the revised buildULfromOBJ(); function... function buildULfromOBJ(obj){ var fragments = []; //declare recursion function function recurse(item){ fragments.push(' '); // start a new $.each(item, function(key, val) { // iterate through items. if((val != null) && (typeof val == 'object') && // catch nested objects ((val == '[object Object]') || (val[0] == '[object Object]'))){ fragments.push(' [' + key + '] => '); // add '[key] =>' recurse(val); // call recurse to add a nested }else if(typeof(val)=='string'){ // catch strings, add double quotes fragments.push(' [' + key + '] = \"' + val + '\" '); }else if($.isArray(val)){ // catch arrays add [brackets] fragments.push(' [' + key + '] = [' + val + '] '); }else{ // default: just print it. fragments.push(' [' + key + '] = ' + val + ' '); } }); fragments.push(' '); // close } // end recursion function recurse(obj); // call recursion return fragments.join(''); // return results } // end buildULfromJSON() The top two elses are simply to make pretty output, and help deliniate between strings and literals. They can be removed to streamline the flow. Here is the same snippet I posted earlier, properly formatted this time... [text] = "#Hashtag @PithyTwits @LuvsIt2 http://link1.com http://link2.com http://link3.com" [retweet_count] = 0 [entities] => [hashtags] => [0] => [text] = "Hashtag" [indices] = [0,8] [user_mentions] => [0] => [indices] = [9,20] [screen_name] = "PithyTwits" [name] = "[object Object]" [id_str] = "258175966" [id] = 258175966 [1] => [indices] = [21,29] [screen_name] = "LuvsIt2" [name] = "Strictly Indifferent" [id_str] = "255883555" [id] = 255883555 [urls] => [0] => [indices] = [30,46] [url] = "http://link1.com" [expanded_url] = null [1] => [indices] = [47,63] [url] = "http://link2.com" [expanded_url] = null [2] => [indices] = [64,80] [url] = "http://link3.com" [expanded_url] = null [in_reply_to_screen_name] = null Notice that [entities][user_mentions][0][name] = "[object Object]" I stuck that in to ensure that string values don't break the code. Also notice the [indices] items. Those are the arrays I prefer to see on a single line (I get anal over the stupidest stuff :) ) Thanks again!
