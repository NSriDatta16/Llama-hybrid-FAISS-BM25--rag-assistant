[site]: stackoverflow
[post_id]: 4156041
[parent_id]: 4144213
[tags]: 
If the problem is to find commented-out code, what is needed is a way to find comments, and way to decide if a comment might contain code. A simple way to do this is to search for comment that contain code-like things. I'd be tempted to hunt for comments containing a ";" character (or some other rare indicator such as "="); it will be pretty hard to have any interesting commented code that doesn't contain this and in my experience with comments, I don't see many that people write that contain this. A regexp search for this should be pretty straightforward, even if it picked up a few addtional false positives (e.g. // in a string literal). A more sophisticated way to accomplish this is to use a Java lexer or parser. If you have a lexer that returns comments at tokens (not all of them do, Java compilers aren't interested in comments), then you can simply scan the lexemes for a comment and do the semicolon check I described above. You won't get any false positives hits for comment like things in string literals with this approach. If you have a re-engineering parser that captures comments as part of the AST ( such as our SD Java Front End ), you can mechanically scan the parse tree for comments, feed the comment context back to the parser to see if the content is code like, and report any that passes that test modulo some size-depedent error rate (10 errors in 15 characters implies "really is a comment"). Now the "code-like" test requires the reengineering parser be willing to recognize any substring of the (Java) language. Our DMS Software Reengineering Toolkit underlying the Java Front End can actually do that, using access to the grammar buried in the front end, as it is willing to start a parse for any language (non)terminal, and this question is "can you find a sequuence of (non)terminals that consumes the string?". The lexer and parser approaches are small and big sledgehammers respectively. If OP is going to do this just once, he can stick to the manual regex search. If the problem is to vet the code base repeatedly (needed in big organizations), he'd want a tool that can be run on regular basis.
