[site]: stackoverflow
[post_id]: 1341540
[parent_id]: 1341229
[tags]: 
Read the memory management rules . 9 simple paragraphs that explain everything you need to know. Because geekName does not begins with “alloc” or “new” or contains “copy”, it should be returning a string you do not “own”. As such, you do not need to (and indeed, must not) release it, and you also must not store a reference to it. You may return it from the method you are in, in which case your method name also should not begins with “alloc” or “new” or contains “copy”. If you wish to keep it around, you must take ownership of it by calling retain, or because its an NSString, better is copy. This might be automatic if you assign it to a copy/retain property. In the code you have now posted, you have made an error in your setter. Your setter should be taking a copy of the input parameter, something like: - (void)setGeekName:(NSString*)gName { if ( geekName != gName ) { [geekName release]; geekName = [gName copy]; } You then also need a dealloc routines which releases geekName: - (void) dealloc { [geekName release]; [super dealloc]; } Alternatively, you can use Objective C properties. Instead of your interface showing: - (NSString*) geekName; - (void) setGeekName:(NSString*)gName; Use a property: @property (nonatomic, copy) NSString* geekName; And instead of your implementation of the setters and getters, let the system synthesize them for you: @synthesize geekName; You still need the dealloc method to free geekName.
