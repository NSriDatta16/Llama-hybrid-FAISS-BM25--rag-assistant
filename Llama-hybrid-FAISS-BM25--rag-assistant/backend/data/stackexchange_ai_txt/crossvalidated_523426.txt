[site]: crossvalidated
[post_id]: 523426
[parent_id]: 
[tags]: 
Uncertainty of a trend

I need to estimate the confidence interval of the solar radiation change (in %) over time. For this, I'm going to use R default dataset airquality . Let's imagine that we know that the measurement error of Solar.R is 30% ( UME ). Hence, UME can be simulated as a random number from a normal distribution with a mean of 1 and a standard deviation of 0.30. Therefore I calculate 95% confidence intervals on the solar radiation as the difference between the 97.5% and 2.5% quantile of the 1000 simulated values. library(tidyverse) # Load dataset and keep only June df % as_tibble() %>% filter(Month == 6) %>% dplyr::select(day = Day, solar = Solar.R) # Create a function to estimate uncertainties unc % as.data.frame() %>% rownames_to_column() %>% rename(val = 2) %>% pivot_wider(names_from = rowname, values_from = val) %>% rename(lower = 1, upper = 2) } # Calculate CI attributed to measuring errors set.seed(2021) df_sim % group_by(day) %>% nest() %>% mutate(sim = map(data, ~unc(.x$solar))) %>% unnest(cols = c(data, sim)) %>% ungroup() # Plot df_sim %>% ggplot(aes(x = day, y = solar)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = .4) + geom_line() + geom_smooth(method = "lm", se = F) So there is obviously a negative trend. The main question is, how can I calculate a slope and corresponding slope's CI considering the measurement uncertainty of Solar.R ? I end up with two various solutions. Help me to select the right, please. Or suggest another, more robust way. Way 1 From googling ( here and here ), I found that I can get the difference between the lower value at the beginning and the upper in the end, and vice versa. E.g. df_sim %>% summarize( average = mean(solar), slope_lower = (first(lower) - last(upper))/30, slope_upper = (last(lower) - first(upper))/30 ) %>% mutate(change_lower = slope_lower / average * 100, change_upper = slope_upper / average * 100) #> # A tibble: 1 x 5 #> average slope_lower slope_upper change_lower change_upper #> #> 1 190. -3.12 -13.3 -1.64 -6.98 So, from these calculations, I can see that my CI is [-1.64%; -6.98%]. Way 2 Calculate 3 slopes: for original Solar.R , for its upper and lower values. E.g. df_sim %>% gather(var, val, -day) %>% group_by(var) %>% nest() %>% mutate(mod = map(data, ~lm(val ~ day, data = .x))) %>% mutate(average = map_dbl(data, ~mean(.x $val))) %>% mutate(slope = map_dbl(mod, ~(.x$ coefficients[2]))) %>% # Calculate change in % mutate(change = slope / 190 * 100) # 190 is an average #> # A tibble: 3 x 6 #> # Groups: var [3] #> var data mod average slope change #> #> 1 solar 190. -6.85 -3.61 #> 2 lower 78.5 -2.88 -1.52 #> 3 upper 303. -11.1 -5.83 Using this approach, my CI is [-1.52%; -5.83%].
