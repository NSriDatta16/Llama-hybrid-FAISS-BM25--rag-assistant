[site]: stackoverflow
[post_id]: 5559409
[parent_id]: 5559390
[tags]: 
This applies if you need the extra state per type and not instance Your best bet is to use a custom attribute against the field. 1) So create the attribute: [AttributeUsage(AttributeTargets.Field)] public class MyCustomAttribute : Attribute { } 2) Decorate the field: class MyClass { [MyCustomAttribute] private int _myField; .... } 3) And then in your reflection: if(fieldInfo.GetCustomAttributes(typeof(MyCustomAttribute), true).Length>0) { ... } If it has got to be in the instance If data is to be part of the instance then either instance needs to allow for its storage state needs to be stored on a separate class like a dictionary Second approach is the one first coming to mind and straightforward to do. On the first note, one can Define state as a separate property that can hold info. This is the one you have suggested and you are not happy with. Inherit from a base class which provides the extra functionality Create a generic type , e.g. Metadata which will provide such functionality to all types I tend to like the third which can encapsulate reflecting the type T and creating necessary placeholders for storing extra state. Main problem with this is you cannot pass the type to methods as a parameter. Which seems that the second solution is the most practical.
