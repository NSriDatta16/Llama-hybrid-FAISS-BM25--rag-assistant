[site]: datascience
[post_id]: 128438
[parent_id]: 
[tags]: 
SAS: how to replace a value in column two in a dataset for which column one = x?

So, total SAS noob here (and I don't like it al all so far). I tried 4 different methods, which all do not work. So I guess in all of these code, something similar is wrong, something rather straightforward like replacing '' by "" or so . As you see, I have different methods for storing temp_sum_reserves into the right row (that equals AGIS FIS and column (2) in mydataset. Sadly, none of them work. Some just return the mydataset unchanged, some mess up the mydataset completely, erasing all observations. Any ideas? For completeness, I give all preceding code * temp params; %let SkipImportData = 1; *not used; /* Assigning values to non-numeric variables */ %let directory = \\...\input_files_copy\01_2024; /* Example directory */ %let filename = CONSOPL_J9.xlsx; /* Example filename */ /* Concatenating directory and filename with enclosing double quotes */ %let input_path = &directory.\&filename; /* Display the value of input_path */ %put Input path: &input_path; /*createa library to store imported files in */ LIBNAME PetitsPr 'S:\Ruben_stuff\SasTests\SasTestLibrary'; *Create the structure for the output file (maybe better if this is read from excel, so the user can adapt the names... but ...); data my_dataset; length Petit_Produit $30; /* Define length for the character variable */ input Petit_Produit $ Reserve comma12.2; /* Define Reserve as numeric variable */ format Reserve comma12.2; /* Define format for Reserve */ datalines; PROTECTION EMPLOI INV, AGIS FIS, AGIS INV, AGIS RSK, LEO FIS, LEO INV, EIP INV, PAW BANK, PAW BROKER, PROTECTION FIS, ; run; /* Importing Excel file */ *Add Guessing rows; proc import datafile = "&input_path" out = PetitsPr.mydataFULL dbms = xlsx replace; /*sheet = "Sheet1"; /* Specify the sheet name if applicable */ run; /* Display information about dataset PetitsPr.dataFULL_MOD */ proc contents data=PetitsPr.dataFULL_MOD varnum; run; /* Filter data and calculate sum v5*/ data PetitsPr.TempReservesFiltered; set PetitsPr.mydataFULL; where ITEM_CRT = '1712' and (Product_CRT = '13120_F' or Product_CRT = '13130'); Total_Reserves = Reality_02_2024 + Closing_02_2024; *Total_Reserves = sum(Reality_01_2024, Closing_01_2024); run; * Filter data; data PetitsPr.TempReservesFiltered2(keep=ITEM_CRT Product_CRT Product_GROUP Reality_02_2024 Closing_02_2024 Total_Reserves); *variable names will change each month, so ... program will need to be able to handle this; set PetitsPr.TempReservesFiltered; run; /* Create a copy of my_dataset */ data updated_dataset; set my_dataset; run; /* Calculate the sum of Total_Reserves */ proc sql noprint; select sum(Total_Reserves) into :temp_sum_reserves from PetitsPr.TempReservesFiltered2; quit; *check calculation; %put Sum of Total_Reserves: &temp_sum_reserves; Some alternatives, that also don't work: /* Update the dataset with the calculated value: method 4 */ data my_dataset; merge my_dataset (keep=Petit_Produit Reserve) /* Keep Petit_Produit and Reserve variables for matching */ (rename=(Petit_Produit=_Petit_Produit)) /* Rename Petit_Produit for matching */ ; by Petit_Produit; /* Merge by Petit_Produit variable */ if _Petit_Produit = 'AGIS FIS' then do; Reserve = &temp_sum_reserves; end; drop _Petit_Produit; /* Drop temporary variable */ run; /* Output the updated dataset */ proc print data=my_dataset; run; /* Update the dataset with the calculated value: method 1*/ data my_dataset; modify my_dataset; if _iorc_ = 0 and index(Petit_Produit, 'AGIS FIS') then do; /* Check if the observation is successfully read and Petit_Produit contains 'AGIS FIS' */ Reserve = &temp_sum_reserves; /* Update Reserve with the calculated value */ replace; /* Replace the current observation with the modified one */ end; run; The code that should work, but doesn't: /* Assign the value to the output dataset: : method 3 */ data my_dataset; set my_dataset; /* Use SET statement to read existing dataset */ if Petit_Produit = 'AGIS FIS' then do; /* Check if the value in the first column is 'AGIS FIS' */ Reserve = &temp_sum_reserves; /* Assign the value to the second column */ output; /* Output the updated observation */ end; run; /* Update the copied dataset with the calculated value: method 2 */ data updated_dataset; set updated_dataset; if Petit_Produit = 'AGIS FIS' then do; Reserve = &temp_sum_reserves; end; run; /* Output the updated dataset */ proc print data=my_dataset; run; The dataset to update looks like this: Summed Reserves 10:47 Monday, March 25, 2024 20 Petit_ Obs Produit Reserve 1 PROTECTION 2 AGIS 3 AGIS 4 AGIS 5 LEO 6 LEO 7 EIP 8 PAW 9 PAW 10 PROTECTION According to chatGPT, this is the issue, but I'm pretty sure it's not: /* The issue lies in the input statement in the my_dataset data step. The input statement with datalines is used to directly input data into a dataset, and it does not support the concept of multiple lines or updating existing data in a dataset. Since you used the datalines statement to input initial data into my_dataset, the subsequent data step trying to update it using set statement will not work as expected. To address this, you need to find another way to update the existing dataset with the calculated value. One common approach is to use a merge or update statement instead of the set statement. /* Thanks!
