[site]: stackoverflow
[post_id]: 1288473
[parent_id]: 1288291
[tags]: 
Download Wikipedia Unzip it and write a quick filter program that spits out only article text (the download is generally in XML format, along with non-article metadata too). Find all instances of a(n).... and make an index on the following word and all of its prefixes (you can use a simple suffixtrie for this). This should be case sensitive, and you'll need a maximum word-length - 15 letters? (optional) Discard all those prefixes which occur less than 5 times or where "a" vs. "an" achieves less than 2/3 majority (or some other threshholds - tweak here). Preferably keep the empty prefix to avoid corner-cases. You can optimize your prefix database by discarding all those prefixes whose parent shares the same "a" or "an" annotation. When determining whether to use "A" or "AN" find the longest matching prefix, and follow its lead. If you didn't discard the empty prefix in step 4, then there will always be a matching prefix (namely the empty prefix), otherwise you may need a special case for a completely-non matching string (such input should be very rare). You probably can't get much better than this - and it'll certainly beat most rule-based systems. Edit: I've implemented this in JS/C# . You can try it in your browser , or download the small, reusable javascript implementation it uses. The .NET implementation is package AvsAn on nuget . The implementations are trivial, so it should be easy to port to any other language if necessary. Turns out the "rules" are quite a bit more complex than I thought: it's an unanticipated result but it's a unanimous vote it's an honest decision but a honeysuckle shrub Symbols: It's an 0800 number, or an âˆž of oregano. Acronyms: It's a NASA scientist, but an NSA analyst; a FIAT car but an FAA policy. ...which just goes to underline that a rule based system would be tricky to build!
