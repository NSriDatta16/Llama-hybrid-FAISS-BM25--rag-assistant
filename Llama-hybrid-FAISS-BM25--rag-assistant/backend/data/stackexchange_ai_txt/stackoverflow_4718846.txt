[site]: stackoverflow
[post_id]: 4718846
[parent_id]: 4718727
[tags]: 
Some words of explanation. In the example code, a single variable is being incremented. Now, memory and CPU caches are organised such that whenever memory is accessed, it is accessed in a cache-lines worth of data at a time. This is because memory is very slow to begin accessing, but then relatively quick to continue accessing, and because it is often the case that when one bit is accessed, a fair number of following bits will be accessed. So, we read in our integer. Let's say the integer is 8 bytes in length and the cache line is also 8 bytes (e.g. modern 64-bit Intel CPU). The read is necessary in this case since we need to know the original value. So, the read occurs and the cache line enters L3, L2 and L1 cache (Intel uses an inclusive cache; everything in L1 is present in L2, everything in L2 is present in L3, etc). Now, when you have multiple CPUs, they keep an eye on what the others are doing, because if another CPU writes to a cache line you have in your cache, your copy isn't correct any more. If we have one CPU with this cache line its in cache and it increments the value, any other CPU with a copy of this value will have its copy marked invalid. So imagine we have two threads, on different CPUs. They both read in the integer. At this point, their caches mark this cache line as shared. Then one of them writes to it. The writer will have his cache line marked as modified, the second CPU has his cache line invalidated - and so when he comes to try to write, what then happens is he tries again to read the integer from memory, but since there exists in another CPUs cache a modified copy, he grabs a copy of the modified value from the first CPU, the first CPU has his copy marked invalid, and now the second CPU writes his own new value. So, all seems well so far - how can it be that we need locking? The problem is this; one CPU reads the value in its cache - then the other does the same. The cache line is currently marked shared, so this is fine. They both then increment. One of them will write back and so his cache line becomes exclusive while this cache line for all other CPUs is marked invalid. The second CPU then writes back, which causes it to take a copy of the cache line from the current owner and then modifies it - writing back the same value. As such, one of the increments was lost.
