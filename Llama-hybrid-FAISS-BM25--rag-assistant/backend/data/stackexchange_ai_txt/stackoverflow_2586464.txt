[site]: stackoverflow
[post_id]: 2586464
[parent_id]: 2582799
[tags]: 
If all of your integers are single-digit numbers (as in your example), then you can reduce your storage space in half by simply omitting the commas. The Short Answer If you expect to have a lot of repetition, then compressing your data makes sense - your data is not so small (65K) and is highly repetitive => it will compress well. This will save you storage space and will reduce how long it takes to transfer the data back from the datastore when you query for it. The Long Answer I did a little testing starting with the short example string you provided and that same string repeated to 65000 characters (perhaps more repetitive than your actual data). This string compressed from 65K to a few hundred bytes; you may want to do some additional testing based on how well your data actually compresses. Anyway, the test shows a significant savings when using compressed data versus uncompressed data (for just the above test where compression works really well!). In particular, for compressed data: API time takes 10x less for a single entity (41ms versus 387ms on average) Storage used is significantly less (so it doesn't look like GAE is doing any compression on your data). Unexpectedly, CPU time is about 50% less (130ms versus 180ms when fetching 100 entities). I expected CPU time to be a little worse since the compressed data has to be uncompressed. There must be some other CPU work (like decoding the protocol buffer) which is even more CPU work for the much larger uncompressed data. These differences mean wall clock time is also significantly faster for the compressed version ( To make it easier to take advantage of compression, I wrote a custom CompressedDataProperty which handles all of the compressing/decompressing business so you don't have to worry about it (I used it in the above tests too). You can get the source from the above link, but I've also included it here since I wrote it for this answer: from google.appengine.ext import db import zlib class CompressedDataProperty(db.Property): """A property for storing compressed data or text. Example usage: >>> class CompressedDataModel(db.Model): ... ct = CompressedDataProperty() You create a compressed data property, simply specifying the data or text: >>> model = CompressedDataModel(ct='example uses text too short to compress well') >>> model.ct 'example uses text too short to compress well' >>> model.ct = 'green' >>> model.ct 'green' >>> model.put() # doctest: +ELLIPSIS datastore_types.Key.from_path(u'CompressedDataModel', ...) >>> model2 = CompressedDataModel.all().get() >>> model2.ct 'green' Compressed data is not indexed and therefore cannot be filtered on: >>> CompressedDataModel.gql("WHERE v = :1", 'green').count() 0 """ data_type = db.Blob def __init__(self, level=6, *args, **kwargs): """Constructor. Args: level: Controls the level of zlib's compression (between 1 and 9). """ super(CompressedDataProperty, self).__init__(*args, **kwargs) self.level = level def get_value_for_datastore(self, model_instance): value = self.__get__(model_instance, model_instance.__class__) if value is not None: return db.Blob(zlib.compress(value, self.level)) def make_value_from_datastore(self, value): if value is not None: return zlib.decompress(value)
