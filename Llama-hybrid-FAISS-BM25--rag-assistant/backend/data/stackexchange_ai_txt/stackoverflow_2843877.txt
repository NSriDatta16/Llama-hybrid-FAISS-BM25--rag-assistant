[site]: stackoverflow
[post_id]: 2843877
[parent_id]: 2843112
[tags]: 
Yes, you can (for simple cases), but you need a bit of meta-programming. Like the other answers have said, a function does not declare that it throws a particular error type, so you need to look at the module and see what exception types it defines, or what exception types it raises. You can either try to grok the documentation or leverage the Python API to do this. To first find which exception types a module defines, just write a simple script to go through each object in the module dictionary module.__dict__ and see if it ends in the word "Error" or if it is a subclass of Exception: def listexns(mod): """Saved as: http://gist.github.com/402861 """ module = __import__(mod) exns = [] for name in module.__dict__: if (issubclass(module.__dict__[name], Exception) or name.endswith('Error')): exns.append(name) for name in exns: print '%s.%s is an exception type' % (str(mod), name) return If I run this on your example of shutils I get this: $ python listexn.py shutil Looking for exception types in module: shutil shutil.Error is an exception type shutil.WindowsError is an exception type $ That tells you which error types are defined, but not which ones are thrown. To achieve the latter, we need to walk over the abstract syntax tree generated when the Python interpreter parses the module, and look for every raise statement, then save a list of names which are raised. The code for this is a little long, so first I'll state the output: $ python listexn-raised.py /usr/lib/python2.6/shutil.py Looking for exception types in: /usr/lib/python2.6/shutil.py /usr/lib/python2.6/shutil.py:OSError is an exception type /usr/lib/python2.6/shutil.py:Error is an exception type $ So, now we know that shutil.py defines the error types Error and WindowsError and raises the exception types OSError and Error . If we want to be a bit more complete, we could write another method to check every except clause to also see which exceptions shutil handles. Here's the code to walk over the AST, it just uses the compiler.visitor interface to create a walker which implements the "visitor pattern" from the Gang of Four book: class ExceptionFinder(visitor.ASTVisitor): """List all exceptions raised by a module. Saved as: http://gist.github.com/402869 """ def __init__(self, filename): visitor.ASTVisitor.__init__(self) self.filename = filename self.exns = set() return def __visitName(self, node): """Should not be called by generic visit, otherwise every name will be reported as an exception type. """ self.exns.add(node.name) return def __visitCallFunc(self, node): """Should not be called by generic visit, otherwise every name will be reported as an exception type. """ self.__visitName(node.node) return def visitRaise(self, node): """Visit a raise statement. Cheat the default dispatcher. """ if issubclass(node.expr1, compiler.ast.Name): self.__visitName(node.expr1) elif isinstance(node.expr1, compiler.ast.CallFunc): self.__visitCallFunc(node.expr1) return
