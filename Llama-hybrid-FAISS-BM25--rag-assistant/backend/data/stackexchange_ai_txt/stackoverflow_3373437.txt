[site]: stackoverflow
[post_id]: 3373437
[parent_id]: 3373108
[tags]: 
Of course there is no arguing that it is in the C standards. So expect a compliant compiler to behave that way. The technical reason behind why it was done might be rooted in how the C startup code works. There are usually several memory segments the linker has to put compiler output into including a code (text) segment, a block storage segment, and an initialized variable segment. Non-static function variables don't have physical storage until the scope of the function is created at runtime so the linker doesn't do anything with those. Program code of course goes in the code (or text) segment but so do the values used to initialize global and static variables. Initialized variables themselves (i.e. their addresses) go in the initialized memory segment. Uninitialized global and static variables go in the block storage (bss) segment. When the program is loaded at execution time, a small piece of code creates the C runtime environment. In ROM based systems it will copy the value of initialized variables from the code (text) segment into their respective actual addresses in RAM. RAM (i.e. disk) based systems can load the initial values directly to the final RAM addresses. The CRT (C runtime) also zeroes out the bss which contains all the global and static variables that have no initializers. This was probably done as a precaution against uninitialized data. It is a relatively straightforward block fill operation because all the global and static variables have been crammed together into one address segment. Of course floats and doubles may require special handling because their 0.0 value may not be all zero bits if the floating format is not IEEE 754. Note that since autovariables don't exist at program load time they can't be initialized by the runtime startup code.
