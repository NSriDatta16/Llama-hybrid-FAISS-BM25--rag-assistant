[site]: stackoverflow
[post_id]: 4164863
[parent_id]: 
[tags]: 
Backdooring Generic Lists through IList

I have a scenario where a class loads objects of one type, due do abstractions I can not use a generic class (generics tend to spread like cancer :) but I often want to work with a generic version of the objects once retrieved, which resulted in code like this (simplified): List items = Storage.LoadItems(filename).OfType ().ToList(); Where LoadItems returns a List , then I realized, why not instead have public void LoadItems(string filename,IList list); Now I can do this instead List items = new List (); LoadItems(filename,items); Which should be more efficient. It's also seems a bit more flexible since I can take an existing List and tack on new items. So my questions are, is this a common pattern or do you have a different/better way of achieving this? I'm also a bit curious that you can do this, if you try and add a object of the wrong type you get an exception, but does that mean that generic lists also do a type check? (which seems a bit unecessary) EDIT It might actually be a bit more elegant to modify the pattern to public IList LoadItems(string filename,IList list=null); that way you can use the statement fluently and if no list is passed you could simply instantiate a List
