[site]: stackoverflow
[post_id]: 344265
[parent_id]: 343954
[tags]: 
The AppDomains are unloaded, but the response from leppie, makes me wonder if the plugin-assemblies are being loaded into both the Primary AppDomain and the secondary AppDomain. When I look at the performance counters, the current AppDomain count does not constantly increase. The application is supposed to create an Secondary appDomain and then load a separate plugin assembly. Maybe some code would help: Creating the secondary AppDomain from the primary appDomain: AppDomainSetup ads = new AppDomainSetup(); ads.ApplicationName = "RemoteAgentLib"; ads.ApplicationBase = AppDomain.CurrentDomain.BaseDirectory; ads.PrivateBinPath = AppDomain.CurrentDomain.BaseDirectory; ads.ShadowCopyDirectories = AppDomain.CurrentDomain.BaseDirectory; ads.ShadowCopyFiles = "true"; m_domain = AppDomain.CreateDomain("RemoteTaskRunner", null, ads); Use the RemoteTaskRunner to load the plugin in the secondary appDomain: RemoteTaskRunner taskRunner = m_domain.CreateInstanceAndUnwrap( Assembly.GetExecutingAssembly().FullName, typeof (RemoteTaskRunner).FullName) as RemoteTaskRunner; taskRunner.LoadTask(taskInfo.Assembly, taskInfo.Type); Use the RemoteTaskRunner to Execute the task in the secondary appDomain: [Serializable] internal class RemoteTaskRunner : MarshalByRefObject { private ITask m_task; public RemoteTaskRunner() { } internal void LoadTask(string assembly, string type) { // This assembly should load in the secondary appDomain. Assembly taskAssembly = AppDomain.CurrentDomain.Load(assembly); m_task = taskAssembly.CreateInstance(type) as ITask; } internal void RunTask(string taskConfig) { // This method should run in the secondary appDomain. m_task.RunTask(taskConfig, m_logger); } ... ... To execute the plugin task, the following line of code is used in the Primary appDomain: taskRunner.RunTask(taskInfo.TaskConfig); After the task finishes, the appDomain is unloaded: AppDomain.Unload(m_domain);
