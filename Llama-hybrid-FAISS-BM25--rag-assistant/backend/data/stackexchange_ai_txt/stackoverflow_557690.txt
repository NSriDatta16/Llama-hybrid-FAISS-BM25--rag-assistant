[site]: stackoverflow
[post_id]: 557690
[parent_id]: 555807
[tags]: 
As mentioned in many of the answers here, you could have 100% code coverage and still have bugs. On top of that, you can have 0 bugs but the logic in your code may be incorrect (not matching the requirements). Code coverage, or being 100% bug-free can't help you with that at all. A typical corporate software development practice could be as follows: Have a clearly written functional specification Have a test plan that's written against (1) and have it peer reviewed Have test cases written against (2) and have them peer reviewed Write code against the functional specification and have it peer reviewed Test your code against the test cases Do code coverage analysis and write more test cases to achieve good coverage. Note that I said "good" and not "100%". 100% coverage may not always be feasible to achieve -- in which case your energy is best spent on achieving correctness of code, rather than the coverage of some obscure branches. Different sorts of things can go wrong in any of the steps 1 through 5 above: wrong idea, wrong specification, wrong tests, wrong code, wrong test execution... The bottom line is, step 6 alone is not the most important step in the process. Concrete example of wrong code that doesn't have any bugs and has 100% coverage: /** * Returns the duration in milliseconds */ int getDuration() { return end - start; } // test: start = 0; end = 1; assertEquals(1, getDuration()); // yay! // but the requirement was: // The interface should have a method for returning the duration in *seconds*.
