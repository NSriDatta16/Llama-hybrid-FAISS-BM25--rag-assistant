[site]: stackoverflow
[post_id]: 3881196
[parent_id]: 3876399
[tags]: 
Here is something that I did recently that might show off some of the power of monads. The actual code is not shown here to protect the innocent, this is just a sketch. Let's say you want to search through some dictionary and depending on what you find you want to do some other search. The searches might return Nothing (the element you are looking for doesn't exist) in which case you might try a different search, and if all searches fail you return Nothing. The idea is to make our own monad by combining monad transformers, and then we can easily make some combinators for searches. Our monad will be ReaderT Dictionary Maybe. And we define the functions find wich looks up a given key, both which will return a the list of elements it found in both of the searches and oneOf which takes two searches and tries the first and if it didn't succeed it tries the second. Here is an example of such a search: import Control.Monad import Control.Monad.Reader find a = ReaderT (lookup a) both a b = liftM2 (++) a b oneOf = mplus search = both (find 1) ((find 2) `oneOf` (find 3)) `oneOf` both (find 4) (find 5) And running: (runReaderT search) [(1,"a"),(3,"c"),(4,"d"),(5,"g")] --> Just "ac" (runReaderT search) [(6,"a")] --> Nothing The big advantage we gain from this being a monad is that we can bind searches together and lift other functions into this abstraction. Let's say for instance, I have two searches search_a and search_b, and I want to do them and then return them merged: do a or alternatively liftM2 merge search_a search_b .
