[site]: stackoverflow
[post_id]: 837090
[parent_id]: 172255
[tags]: 
NOTE: this is horribly outdated. It's around from iOS 2.x times, and has actually been fixed around iOS 3.x. Keeping it here for historical purposes only. I think I found a clean solution to this, and I made an UIScrollView subclass to encapsulate it. The sample code that illustrates both programmatic zooming (+ double-tap handling) and Photo Library-style paging+zooming+scrolling, together with ZoomScrollView class, is available at github.com/andreyvit/ScrollingMadness . In a few words, my solution is to return a new dummy view from viewForZoomingInScrollView: , temporarily making your content view (UIImageView, whatever) its child. In scrollViewDidEndZooming: we reverse that, disposing the dummy view and moving your content view back into the scroll view. Why does it help? It is a way of defeating the persistent view scale that we cannot change programmatically. UIScrollView does not keep the current view scale itself. Instead, each UIView is capable of keeping its current view scale (inside UIGestureInfo object pointed to by the _gestureInfo field). By providing a new UIView for each zooming operation, we always start with zoom scale 1.00. And how does that help? We store the current zoom scale ourself, and apply it manually to our content view, e.g. contentView.transform = CGAffineTransformMakeScale(zoomScale, zoomScale) . This however conflicts with UIScrollView wanting to reset the transform when the user pinches the view. By giving UIScrollView another view with identity transform to zoom, we no longer fight for transforming the same view. UIScrollView can happily believe it starts with zoom 1.00 each time and scales a view starting with an identity transform, and its inner view has a transform applied corresponding to our actual current zoom scale. Now, ZoomScrollView encapsulates all this stuff. Here's its code for the sake of completeness, however I really recommend to download the sample project from GitHub (you don't need to use Git, there's a Download button there). If you want to be notified about sample code updates (and you should â€” I'm planning to maintain and update this class!), either follow the project on GitHub or drop me an e-mail at andreyvit@gmail.com. Interface: /* ZoomScrollView makes UIScrollView easier to use: - ZoomScrollView is a drop-in replacement subclass of UIScrollView - ZoomScrollView adds programmatic zooming (see `setZoomScale:centeredAt:animated:`) - ZoomScrollView allows you to get the current zoom scale (see `zoomScale` property) - ZoomScrollView handles double-tap zooming for you (see `zoomInOnDoubleTap`, `zoomOutOnDoubleTap`) - ZoomScrollView forwards touch events to its delegate, allowing to handle custom gestures easily (triple-tap? two-finger scrolling?) Drop-in replacement: You can replace `[UIScrollView alloc]` with `[ZoomScrollView alloc]` or change class in Interface Builder, and everything should continue to work. The only catch is that you should not *read* the 'delegate' property; to get your delegate, please use zoomScrollViewDelegate property instead. (You can set the delegate via either of these properties, but reading 'delegate' does not work.) Zoom scale: Reading zoomScale property returns the scale of the last scaling operation. If your viewForZoomingInScrollView can return different views over time, please keep in mind that any view you return is instantly scaled to zoomScale. Delegate: The delegate accepted by ZoomScrollView is a regular UIScrollViewDelegate, however additional methods from `NSObject(ZoomScrollViewDelegateMethods)` category will be called on your delegate if defined. Method `scrollViewDidEndZooming:withView:atScale:` is called after any 'bounce' animations really finish. UIScrollView often calls it earlier, violating the documented contract of UIScrollViewDelegate. Instead of reading 'delegate' property (which currently returns the scroll view itself), you should read 'zoomScrollViewDelegate' property which correctly returns your delegate. Setting works with either of them (so you can still set your delegate in the Interface Builder). */ @interface ZoomScrollView : UIScrollView { @private BOOL _zoomInOnDoubleTap; BOOL _zoomOutOnDoubleTap; BOOL _zoomingDidEnd; BOOL _ignoreSubsequentTouches; // after one of delegate touch methods returns YES, subsequent touch events are not forwarded to UIScrollView float _zoomScale; float _realMinimumZoomScale, _realMaximumZoomScale; // as set by the user (UIScrollView's min/maxZoomScale == our min/maxZoomScale divided by _zoomScale) id _realDelegate; // as set by the user (UIScrollView's delegate is set to self) UIView *_realZoomView; // the view for zooming returned by the delegate UIView *_zoomWrapperView; // the disposable wrapper view actually used for zooming } // if both are enabled, zoom-in takes precedence unless the view is at maximum zoom scale @property(nonatomic, assign) BOOL zoomInOnDoubleTap; @property(nonatomic, assign) BOOL zoomOutOnDoubleTap; @property(nonatomic, assign) id zoomScrollViewDelegate; @end @interface ZoomScrollView (Zooming) @property(nonatomic, assign) float zoomScale; // from minimumZoomScale to maximumZoomScale - (void)setZoomScale:(float)zoomScale animated:(BOOL)animated; // centerPoint == center of the scroll view - (void)setZoomScale:(float)zoomScale centeredAt:(CGPoint)centerPoint animated:(BOOL)animated; @end @interface NSObject (ZoomScrollViewDelegateMethods) // return YES to stop processing, NO to pass the event to UIScrollView (mnemonic: default is to pass, and default return value in Obj-C is NO) - (BOOL)zoomScrollView:(ZoomScrollView *)zoomScrollView touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; - (BOOL)zoomScrollView:(ZoomScrollView *)zoomScrollView touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; - (BOOL)zoomScrollView:(ZoomScrollView *)zoomScrollView touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; - (BOOL)zoomScrollView:(ZoomScrollView *)zoomScrollView touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; @end Implementation: @interface ZoomScrollView (DelegateMethods) @end @interface ZoomScrollView (ZoomingPrivate) - (void)_setZoomScaleAndUpdateVirtualScales:(float)zoomScale; // set UIScrollView's minimumZoomScale/maximumZoomScale - (BOOL)_handleDoubleTapWith:(UITouch *)touch; - (UIView *)_createWrapperViewForZoomingInsteadOfView:(UIView *)view; // create a disposable wrapper view for zooming - (void)_zoomDidEndBouncing; - (void)_programmaticZoomAnimationDidStop:(NSString *)animationID finished:(NSNumber *)finished context:(UIView *)context; - (void)_setTransformOn:(UIView *)view; @end @implementation ZoomScrollView @synthesize zoomInOnDoubleTap=_zoomInOnDoubleTap, zoomOutOnDoubleTap=_zoomOutOnDoubleTap; @synthesize zoomScrollViewDelegate=_realDelegate; - (id)initWithFrame:(CGRect)frame { if (self = [super initWithFrame:frame]) { _zoomScale = 1.0f; _realMinimumZoomScale = super.minimumZoomScale; _realMaximumZoomScale = super.maximumZoomScale; super.delegate = self; } return self; } - (id)initWithCoder:(NSCoder *)aDecoder { if (self = [super initWithCoder:aDecoder]) { _zoomScale = 1.0f; _realMinimumZoomScale = super.minimumZoomScale; _realMaximumZoomScale = super.maximumZoomScale; super.delegate = self; } return self; } - (id )realDelegate { return _realDelegate; } - (void)setDelegate:(id )delegate { _realDelegate = delegate; } - (float)minimumZoomScale { return _realMinimumZoomScale; } - (void)setMinimumZoomScale:(float)value { _realMinimumZoomScale = value; [self _setZoomScaleAndUpdateVirtualScales:_zoomScale]; } - (float)maximumZoomScale { return _realMaximumZoomScale; } - (void)setMaximumZoomScale:(float)value { _realMaximumZoomScale = value; [self _setZoomScaleAndUpdateVirtualScales:_zoomScale]; } @end @implementation ZoomScrollView (Zooming) - (void)_setZoomScaleAndUpdateVirtualScales:(float)zoomScale { _zoomScale = zoomScale; // prevent accumulation of error, and prevent a common bug in the user's code (comparing floats with '==') if (ABS(_zoomScale - _realMinimumZoomScale) 1e-5) [self setZoomScale:_realMaximumZoomScale centeredAt:[touch locationInView:self] animated:YES]; else if (_zoomOutOnDoubleTap && ABS(_zoomScale - _realMinimumZoomScale) > 1e-5) [self setZoomScale:_realMinimumZoomScale animated:YES]; return YES; } // the heart of the zooming technique: zooming starts here - (UIView *)_createWrapperViewForZoomingInsteadOfView:(UIView *)view { if (_zoomWrapperView != nil) // not sure this is really possible [self _zoomDidEndBouncing]; // ...but just in case cleanup the previous zoom op _realZoomView = [view retain]; [view removeFromSuperview]; [self _setTransformOn:_realZoomView]; // should be already set, except if this is a different view _realZoomView.frame = CGRectMake(0, 0, _realZoomView.frame.size.width, _realZoomView.frame.size.height); _zoomWrapperView = [[UIView alloc] initWithFrame:view.frame]; [_zoomWrapperView addSubview:view]; [self addSubview:_zoomWrapperView]; return _zoomWrapperView; } // the heart of the zooming technique: zooming ends here - (void)_zoomDidEndBouncing { _zoomingDidEnd = NO; [_realZoomView removeFromSuperview]; [self _setTransformOn:_realZoomView]; _realZoomView.frame = _zoomWrapperView.frame; [self addSubview:_realZoomView]; [_zoomWrapperView release]; _zoomWrapperView = nil; if ([_realDelegate respondsToSelector:@selector(scrollViewDidEndZooming:withView:atScale:)]) [_realDelegate scrollViewDidEndZooming:self withView:_realZoomView atScale:_zoomScale]; [_realZoomView release]; _realZoomView = nil; } @end @implementation ZoomScrollView (DelegateMethods) - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView { if ([_realDelegate respondsToSelector:@selector(scrollViewWillBeginDragging:)]) [_realDelegate scrollViewWillBeginDragging:self]; } - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { if ([_realDelegate respondsToSelector:@selector(scrollViewDidEndDragging:willDecelerate:)]) [_realDelegate scrollViewDidEndDragging:self willDecelerate:decelerate]; } - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView { if ([_realDelegate respondsToSelector:@selector(scrollViewWillBeginDecelerating:)]) [_realDelegate scrollViewWillBeginDecelerating:self]; } - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView { if ([_realDelegate respondsToSelector:@selector(scrollViewDidEndDecelerating:)]) [_realDelegate scrollViewDidEndDecelerating:self]; } - (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView { if ([_realDelegate respondsToSelector:@selector(scrollViewDidEndScrollingAnimation:)]) [_realDelegate scrollViewDidEndScrollingAnimation:self]; } - (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView { UIView *viewForZooming = nil; if ([_realDelegate respondsToSelector:@selector(viewForZoomingInScrollView:)]) viewForZooming = [_realDelegate viewForZoomingInScrollView:self]; if (viewForZooming != nil) viewForZooming = [self _createWrapperViewForZoomingInsteadOfView:viewForZooming]; return viewForZooming; } - (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(float)scale { [self _setZoomScaleAndUpdateVirtualScales:_zoomScale * scale]; // often UIScrollView continues bouncing even after the call to this method, so we have to use delays _zoomingDidEnd = YES; // signal scrollViewDidScroll to schedule _zoomDidEndBouncing call [self performSelector:@selector(_zoomDidEndBouncing) withObject:nil afterDelay:0.1]; } - (void)scrollViewDidScroll:(UIScrollView *)scrollView { if (_zoomWrapperView != nil && _zoomingDidEnd) { [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(_zoomDidEndBouncing) object:nil]; [self performSelector:@selector(_zoomDidEndBouncing) withObject:nil afterDelay:0.1]; } if ([_realDelegate respondsToSelector:@selector(scrollViewDidScroll:)]) [_realDelegate scrollViewDidScroll:self]; } - (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView { if ([_realDelegate respondsToSelector:@selector(scrollViewShouldScrollToTop:)]) return [_realDelegate scrollViewShouldScrollToTop:self]; else return YES; } - (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView { if ([_realDelegate respondsToSelector:@selector(scrollViewDidScrollToTop:)]) [_realDelegate scrollViewDidScrollToTop:self]; } @end @implementation ZoomScrollView (EventForwarding) - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { id delegate = self.delegate; if ([delegate respondsToSelector:@selector(zoomScrollView:touchesBegan:withEvent:)]) _ignoreSubsequentTouches = [delegate zoomScrollView:self touchesBegan:touches withEvent:event]; if (_ignoreSubsequentTouches) return; if ([touches count] == 1 && [[touches anyObject] tapCount] == 2) if ([self _handleDoubleTapWith:[touches anyObject]]) return; [super touchesBegan:touches withEvent:event]; } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { id delegate = self.delegate; if ([delegate respondsToSelector:@selector(zoomScrollView:touchesMoved:withEvent:)]) if ([delegate zoomScrollView:self touchesMoved:touches withEvent:event]) { _ignoreSubsequentTouches = YES; [super touchesCancelled:touches withEvent:event]; } if (_ignoreSubsequentTouches) return; [super touchesMoved:touches withEvent:event]; } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { id delegate = self.delegate; if ([delegate respondsToSelector:@selector(zoomScrollView:touchesEnded:withEvent:)]) if ([delegate zoomScrollView:self touchesEnded:touches withEvent:event]) { _ignoreSubsequentTouches = YES; [super touchesCancelled:touches withEvent:event]; } if (_ignoreSubsequentTouches) return; [super touchesEnded:touches withEvent:event]; } - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event { id delegate = self.delegate; if ([delegate respondsToSelector:@selector(zoomScrollView:touchesCancelled:withEvent:)]) if ([delegate zoomScrollView:self touchesCancelled:touches withEvent:event]) _ignoreSubsequentTouches = YES; [super touchesCancelled:touches withEvent:event]; } @end
