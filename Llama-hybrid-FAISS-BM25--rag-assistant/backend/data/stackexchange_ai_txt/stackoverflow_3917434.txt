[site]: stackoverflow
[post_id]: 3917434
[parent_id]: 3917400
[tags]: 
It depends. Certain methods do check for particular interfaces before resorting to a "least common denominator" implementation (one that only uses the IEnumerable interface). For example, Count does check for both ICollection and ICollection in order to leverage a (presumably) O(1) count before resorting to just counting all elements one-by-one. It seems from driis's answer that Contains is the same way, checking for ICollection (which HashSet implements). Now, it's unclear to me what you mean here: [The previous developer] always converts whatever data structure he is using to create the enumerable object to an array before assigning it to the property. If you mean that your collections are actually copied to arrays in order to be exposed as IEnumerable , then you are definitely not getting the HashSet class's Contains method; you're getting the array's (since a T[] array does implement ICollection , though this is really not going to be any better than the naive approach).
