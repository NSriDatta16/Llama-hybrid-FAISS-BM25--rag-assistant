[site]: stackoverflow
[post_id]: 2136419
[parent_id]: 2136294
[tags]: 
From your example, it looks like you don't have a Makefile rule being activated for compiling the C++ files. Maybe your % are expanding incorrectly? Try $(OBJECTS): %.o: %.cpp ... And specify the destination in the rule part, using $(basename ..) where appropriate. It works for C for blue.c because Make has a built-in default rule for compiling C files. I suspect running Make with the --no-builtin-rules option would cause the blue.c file to stop working too. From the docs, Compiling C programs n.o is made automatically from n.c with a command of the form $(CC) -c $(CPPFLAGS) $(CFLAGS)'. Compiling C++ programs n.o is made automatically from n.cc, n.cpp, or n.C with a command of the form $(CXX) -c $(CPPFLAGS) $(CXXFLAGS)'. We encourage you to use the suffix .cc' for C++ source files instead of .C'. There is a default C++ rule, but it might not be kicking in for you because of another rule or bad variables. It is better to write the rule explicitly to be sure. You need a rule such as: %.o: %.cpp $(CPP) $(CPP_OPTS) -c -o $@ $ For compiling your object files from source, then you have: executable: $(OBJECTS) ... compile objects into final blob ... Where the objects of some format %.o trigger the dependency. Or use Autotools/Autoconf to build your Makefile for you. Here is an example I wrote that just builds C++ files into a directory of objects: SOURCES=$(wildcard path/to/src/*.cpp) OBJECTS=$(SOURCES: .cpp=.o) CC=g++ final: $(OBJECTS) mv $(OBJECTS) /path/to/build_dir %.o: %.cpp: g++ -c -o $@ $ Not a complete example by any means, but you get the idea. In the final rule, you copy the object files, but you can do whatever here or change the -o option to plonk build files in a specific location.
