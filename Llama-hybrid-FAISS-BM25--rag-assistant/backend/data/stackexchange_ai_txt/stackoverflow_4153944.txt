[site]: stackoverflow
[post_id]: 4153944
[parent_id]: 4153124
[tags]: 
Function body manipulates with copies of its arguments. So when you want to change some variable that you pass as function argument, you actually need to pass variable's address - its pointer. Function gets a copy of that pointer which has an address of original variable so function can change variable's value. In the same way, when you want to change some pointer's value, you need to pass its address as a function argument. Typical example would be a case when function needs to reallocate memory for some data structure. In this example, we want to pass a character array into a function which appends a single character to it. Function needs to reallocate memory for a new (extended) array which means that its pointer needs point to a new location in memory - it value needs to be changed. Pay attention to lines where *pp (dereferenced pointer to pointer) is assigned a value: #include using namespace std; void append_char(char** pp, char ch) { // copy of pp is passed here if(pp) { if(*pp) { // pointer is already pointing to formed array of characters // 1. allocate memory for a new (extended) array int nLen = strlen(*pp); // one place for ch and one for zero-termination int nNewLen = nLen + 2; char* pNewStr = new char[nNewLen]; // 2. copy existing array into a new one strcpy(pNewStr, (const char*)*pp); // 3. append new character pNewStr[nNewLen - 2] = ch; pNewStr[nNewLen - 1] = '\0'; // 4. free memory of old array delete[] *pp; // 5. assign new pointer's value *pp = pNewStr; } else { // pointer is NULL - passed character will be the first in a new array // 1. allocate memory, fill the array and assign new pointer's value *pp = new char[2]; (*pp)[0] = ch; (*pp)[1] = '\0'; } } } int main() { char* p = new char[3]; p[0] = 'A'; p[1] = 'B'; p[2] = '\0'; cout I used C-style string here as it's common example of memory management. In your C++ code try to avoid C strings and use C++ cast operators.
