[site]: stackoverflow
[post_id]: 5263695
[parent_id]: 5263620
[tags]: 
(The OP tells me that the nodes need to have arrays of strings, so the pointer-to-a-pointer thing is actually correct). Anyhow, it looks like your problem is that every node has a pointer to the same buffer. You just keep copying different strings into the same buffer, and then you assign the address of a pointer to that buffer to each new node. First, I'd get rid of those typedefs. I don't know how much clarity they're really adding. Next, you need to allocate new storage for each string. The standard library strdup() function is a handy way to do that: // Turns out it's a fixed-size array, so we can blow off some memory // management complexity. #define CMDARRAYSIZE 21 struct node { Node next; char * transData[ CMDARRAYSIZE ]; }; // Node initialization: int i = 0; struct node * nod = (struct node *)malloc( sizeof( struct node ) ); // Initialize alloc'd memory to all zeroes. This sets the next pointer // to NULL, and all the char *'s as well. memset( nod, 0, sizeof( struct node ) ); for ( i = 0; i transData[ i ] = strdup( data[ i ] ); } } ...but then be sure that when you free each node, you call free( nod->transData[n] ) for every non-NULL string pointer in nod->transData. C is not a labor-saving language.
