[site]: stackoverflow
[post_id]: 3938428
[parent_id]: 3925845
[tags]: 
I think jonderry is very close, but the parent pointers require \Omega(n) memory, that is they add substantially to memory usage. What he is doing is two coordinated traversals in opposite directions (small to large and viveversa) trying to keep the sum always close to the target and you can manage that with two stacks, and the stacks can only grow up to the depth of the tree and that is O(log n). I don't know if that's "little" additional memory, but certainly it is less additional memory and o(n). So this is exactly as in jonderry own comment, but there is no runtime penalty because traversing a binary tree using only a stack is a well known and efficient and definitely O(n) operation. So you have increasing iterator ii and a decreasing iterator di. x = ii.next() y = di.next() while (true) { try: if x + y > target {y = di.next()} if x + y I had just run into the same problem in the context of computing the pseudomedian, the median of all pairwise averages in a sample.
