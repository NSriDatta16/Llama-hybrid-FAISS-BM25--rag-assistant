[site]: stackoverflow
[post_id]: 4090103
[parent_id]: 4089975
[tags]: 
roughly: map::upper_bound / lower_bound to get the iterator for the index range accumulate to calculate the sum over the range (easy), and count to get the elements That runs through the range twice (doesn't scale well). For optimization: struct RunningAverage { double sum; int count; RunningAverage() { sum = 0; count = 0; } RunningAverage & operator+=(double value) { sum += value; ++count; } RunningAverage operator+(double value) { RunningAverage result = *this; result += value; return result; } double Avg() { return sum / count; } } Which you can pass to accumulate to gather both count and sum in one pass. [edit] As per comment, here's the rationale for the optimization: a O(N) algorithm with no limit given for N primitive operations (node traversal and addition) random access pattern is possible Under these circumstances, memory access is no longer guaranteed to be cache backed, and thus cost may become significant compared to the per-element operation (or even exceed that). Iterating twice will double the cost of memory access. The "variables" in this discussion depend only on data set and client computer config, not the algorithm. I'd prefer this solution over a custom "accumulate", because it's simple to extend or modify for other operations, while the "accumulate" details remain isolated. It could also be used with a hypothetical accumulate_p method that parallelizes access (you'd need a struct + struct operator, too, but that is simple). Oh, and const correctness is left as an exercise for the reader :)
