[site]: crossvalidated
[post_id]: 389331
[parent_id]: 
[tags]: 
PyMC3: up-to-date implementation of Price is Right example?

So, getting into PyMC3 a lot more and working through examples, I found I cannot implement in an up-to-date form an example from Cameron Davidson-Pilon's Bayesian Methods for Hackers , specifically the Price is Right example, in the library's current version. The model starts on page 139, and the crux of it is to calculate how one's prior changes after being modified by a summation of two previous priors, under normality assumptions. That is as much of the model's logic as I was able to deduce, and was hoping building it and tinkering would explain the rest to me. The code he uses is import pymc as pm data_mu = [3e3, 12e3] data_std = [5e2, 3e3] mu_prior = 35e3 std_prior = 75e2 true_price = pm.Normal("true_price", mu_prior, 1.0 / std_prior ** 2) prize_1 = pm.Normal("first_prize", data_mu[0], 1.0 / data_std[0] ** 2) prize_2 = pm.Normal("second_prize", data_mu[1], 1.0 / data_std[1] ** 2) price_estimate = prize_1 + prize_2 @pm.potential def error(true_price=true_price, price_estimate=price_estimate): return pm.normal_like(true_price, price_estimate, 1 / (3e3) ** 2) mcmc = pm.MCMC([true_price, prize_1, prize_2, price_estimate, error]) mcmc.sample(50000, 10000) price_trace = mcmc.trace("true_price")[:] The thing is, pm.potential is deprecated now, and sampling directly through pm.MCMC is discouraged as well, in lieu of with pm.Model() as model: ... ... pm.sample() I would extremely appreciate anyone helping me understand this model, and how a similar one would be built under modern PyMC3.
