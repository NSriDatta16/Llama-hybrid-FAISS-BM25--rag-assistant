[site]: stackoverflow
[post_id]: 3645102
[parent_id]: 3645058
[tags]: 
Your problem is algorithmic. What happens if two adjacent elements meet your criterion for deletion? The first will be deleted, but because i is incremented after each iteration of the loop, the second will be skipped. This is because a vector is contiguous in memory, and all elements after the deleted one are moved forwards one index. An ugly hack would be to do the following: std::vector myvector; for(unsigned int i = 0; i I'm not sure if using iterators would work, because calling erase invalidates iterators to elements after the erased element. The elegant solution would be to use std::remove_if , as GMan suggested. This would abstract away two things: Your removal condition The process by which the elements of a container are removed Edit: I should also add, the hacked solution is O(n 2 ) in the worst case. GMan's solution is O(n) , assuming your removal condition is O(1) . I would strongly encourage you to learn and use GMan's solution.
