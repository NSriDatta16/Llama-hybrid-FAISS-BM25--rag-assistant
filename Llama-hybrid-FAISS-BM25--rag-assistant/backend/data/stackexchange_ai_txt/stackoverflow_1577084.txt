[site]: stackoverflow
[post_id]: 1577084
[parent_id]: 
[tags]: 
Storing values of any type as type initially supplied in templated factory method in C++?

This is a slightly different question to this one ([ Accessing a method from a templated derived class without using virtual functions in c++? ) which I asked recently. I would like to create an instance of an object using a templated factory method, then from then on only be able to set and get a value based on the initial type supplied to the item. Here's a quick example of what I'm trying to achieve: boost::shared_ptr item = Item::create (); item->setValue(5); // conversion to 5.0 in setting the value float value = item->value(); // returned value = 5.0 Essentially the only time setValue will fail is if there isn't an implicit conversion from whatever has been supplied to the initial 'type' of the internal value in Item. So if I made the whole Item class a templated class taking a type, I would need to provide the type of the value every time I created a shared pointer to the Item, which I don't really care about. The next approach I took was to try and store the initial type in the class and use boost::any for the internal storage, casting the internal type to the initial type specified if there was an implicit conversion. However, I stuggled to store and compare the type information, initially looking at std::type_info, but as setValue took a boost::any, had no way of comparing what was actually passed. (A slight extension to this might be providing a variant-style list of options to the template argument in the creation and returning the value in the native supplied type.) There may be a design pattern I'm not aware of, or a different approach I haven't considered, so I'd be interested in hearing any suggestions of how to tackle this?
