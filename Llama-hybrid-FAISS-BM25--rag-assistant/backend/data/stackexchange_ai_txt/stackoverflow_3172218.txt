[site]: stackoverflow
[post_id]: 3172218
[parent_id]: 3147612
[tags]: 
Most dependency injection frameworks allow for injection binding by "convention." For example, you could put an attribute on the property to flag it for injection, and when the DI framework constructs a class it will know to inject a value into that property. public abstract class Foo { [Inject] public Bar Bar {get; set;} } public class Baz : Foo { ... } public class SomeUtil { Baz _baz; public SomeUtil(Baz baz) { _baz = baz; } } In the example above, if we can assume that the SomeUtil class is generated by dependency injection, the DI framework can be configured to generate a Baz and populate its Bar property. I don't know the specific implementation for Spring, but this is the general direction that I'd look in. Update When I spoke about binding by "convention," I was referring to auto-wiring. Tobsen's answer has some good references on auto-wiring in Spring. It appears to be more difficult than in Ninject, which is what I have been using. Looking through those docs, however, it appears that you can tell the framework to automatically inject a value into any public property with a specified name or type. In my example above, you could tell it that any property called "Bar" should be injected. Since all sub-classes of Foo contain a property called Bar, they will all have this value injected. This requires a one-time change to your configuration file, and everything after that should "just work." I'm getting the impression, however, that the real root of your problem is that you aren't using dependency injection quite the right way. Tobsen picked up on this, too. If you ever say new Baz() , this is an anti-pattern of dependency injection. Instead, your dependencies should trickle up into the highest point possible in your code (what DI books call the "context root", where you will actually have code asking for the dependency you need. Something like this: public static void Main() { var someUtil = (SomeUtil)ContextRegistry.GetContext()["SomeUtil"]; someUtil.DoSomething(); } In the process of figuring out how to construct a SomeUtil, Spring will figure out that it first needs a Baz. It will notice that the Baz has a Bar property on it, and so it will create a Bar and inject it into that property, then pass the Baz into the constructor for SomeUtil, and then return the SomeUtil that it just created. If this isn't perfectly clear to you, I'd strongly encourage you to read a good book about Dependency Injection . It takes a little time and practice to learn to recognize the patterns and anti-patterns of dependency injection, but it is very rewarding once you do.
