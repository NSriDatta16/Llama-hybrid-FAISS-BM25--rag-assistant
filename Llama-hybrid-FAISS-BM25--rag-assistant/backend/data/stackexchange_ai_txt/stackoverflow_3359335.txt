[site]: stackoverflow
[post_id]: 3359335
[parent_id]: 
[tags]: 
Doing an XSL transform of a branch of a Docbook element tree

I'd like to use the docbook XSL stylesheets to render various parts of a document, without transforming the entire thing. The complication is that some of these parts have elements whose linkend attributes are not located within the same chunk. In other words, I want to process a branch of the tree which includes the s but not the elements they reference. My attempts to do this using the Python lxml package have yielded this error message: XSLTApplyError Traceback (most recent call last) /var/www/mpd/ in () /var/www/mpd/ in ((elt,)) /usr/lib/python2.6/dist-packages/lxml/etree.so in lxml.etree.XSLT.__call__ (src/lxml/lxml.etree.c:109204)() XSLTApplyError: Internal error in xsltKeyFunction(): Could not get the document info of a context doc. This happens in response to, e.g. etree.XSLT(etree.parse('docbook.xsl'))(some_element) . I'm using the normal xhtml stylesheets. I wouldn't expect it to matter which stylesheet I'm using, though. Is there a supported way to do this? Or am I expected to, for example, apply an XSLT transform on the document to change the element to a element before doing this render? But then that wouldn't work, because then there would be multiple tags with the same ID. It would have to only do that to transformation if the tag was not being included in the resulting tree. Which I would expect to be happening already. But hopefully I just missed a switch somewhere. edit Thanks to @Jukka's answer, I've figured out that I can pass the rootid parameter to tell the XSLT processor to just render that ID. However, it does so all too faithfully, producing output that just references the footnote with the same fragment that would be useful if the document were being rendered as a single HTML page. EG >>> xsl_url_html = 'http://docbook.sourceforge.net/release/xsl/current/html/docbook.xsl' >>> from lxml import etree >>> consume_result = etree.XSLT(etree.parse(xsl_url_xhtml))( etree.parse(my_xml_file), rootid=etree.XSLT.strparam("command_consume")) >>> etree.tostring(consume_result).split('\n') [' ', ' ', ' consume { STATE } ', ' ', ' [ 2 ] ', ' Sets consume state to STATE ,', ' STATE should be 0 or 1.', '\t When consume is activated, each song played is removed from playlist.', ' '] Maybe there is another parameter that will cause the footnotes to be displayed on the same page, preferably numbered from 1? I guess it would probably be in this list somewhere. I'll go through it when I get some more time.
