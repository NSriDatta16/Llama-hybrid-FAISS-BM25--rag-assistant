[site]: stackoverflow
[post_id]: 5150714
[parent_id]: 5111903
[tags]: 
I'm no expert, but looking at the SQL-CLR type mapping tables (e.g. http://msdn.microsoft.com/en-us/library/bb386947.aspx ) you can see that SQL decimal values are converted to the CLR System.Decimal type and CLR System.Decimal values are converted to the SQL DECIMAL(29,4) type. So in your example, a.Weight as a SQL decimal is converted to a CLR System.Decimal. The division of a.Weight by a.Count is therefore treated as a System.Decimal division and the right operand ( a.Count ) must be converted to a CLR System.Decimal. Linq then translates this type conversion back to SQL which results in Count being converted to a DECIMAL(29,4). Unfortunately, a.Weight / (double) a.Count won't work because the right operand must be converted to a System.Decimal but a double can't be automatically converted like an int can. However, (double) a.Weight / a.Count will work because the division is now treated as a division of doubles, not System.Decimals, so the resulting SQL looks like this: SELECT (CONVERT(Float,[t0].[Weight])) / (CONVERT(Float,[t0].[Count])) AS [value] ... What you really want is for Linq to treat a.Count as though it is already a decimal, not an int. You can do this by changing the Type of the Count property in your DBML file ( see here ). When I did this, the Linq query: var averageweight = context.AverageWeights .Where(i => i.ID == 187) .GroupBy(w => w.ID) .Select(i => new {Average = i.Average(a => a.Weight/a.Count), Count = i.Count()}); results in the SQL: SELECT AVG([t0].[Weight] / [t0].[Count]) AS [Average], COUNT(*) AS [Count] FROM [dbo].[AverageWeight] AS [t0] WHERE [t0].[ID] = @p0 GROUP BY [t0].[ID] which is the desired result. However, changing the type of the Count property in the DBML file may have other unintended side effects. By the way, the SQL generated from your updated Linq query seems to be wrong. The Linq clearly requires that the average of all the weights be divided by the average of all the counts, but this is not what the SQL does. When I write the same Linq query, the SQL I get is: SELECT [t1].[value] / (CONVERT(Decimal(29,4),[t1].[value2])) AS [Average], [t1].[value3] AS [Count] FROM ( SELECT AVG([t0].[Weight]) AS [value], AVG([t0].[Count]) AS [value2], COUNT(*) AS [value3] FROM [dbo].[Average Weight] AS [t0] WHERE [t0].[ID] = @p0 GROUP BY [t0].[ID] ) AS [t1] Note that there are two calls to AVG rather than just one. Also note that the conversion to Decimal(29,4) is still present since Linq is still doing a System.Decimal division.
