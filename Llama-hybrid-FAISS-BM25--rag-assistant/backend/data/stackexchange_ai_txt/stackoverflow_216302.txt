[site]: stackoverflow
[post_id]: 216302
[parent_id]: 215742
[tags]: 
Prototyping . Prolog is dynamic and has been for 50 years. The compiler is liberal, the syntax minimalist, and "doing stuff" is easy, fun and efficient. SWI-Prolog has a built-in tracer (debugger!) , and even a graphical tracer . You can change the code on the fly, using make/0 , you can dynamically load modules, add a few lines of code without leaving the interpreter, or edit the file you're currently running on the fly with edit(1) . Do you think you've found a problem with the foobar/2 predicate? ?- edit(foobar). And as soon as you leave the editor, that thing is going to be re-compiled. Sure, Eclipse does the same thing for Java, but Java isn't exactly a prototyping language. Apart from the pure prototyping stuff, Prolog is incredibly well suited for translating a piece of logic into code . So, automatic provers and that type of stuff can easily be written in Prolog. The first Erlang interpreter was written in Prolog - and for a reason, since Prolog is very well suited for parsing, and encoding the logic you find in parse trees . In fact, Prolog comes with a built-in parser! No, not a library, it's in the syntax, namely DCG s. Prolog is used a lot in NLP, particularly in syntax and computational semantics . But, Prolog is underused and underappreciated. Unfortunately, it seems to bear an academic or "unusable for any real purpose" stigma. But it can be put to very good use in many real-world applications involving facts and the computation of relations between facts. It is not very well suited for number crunching, but CS is not only about number crunching.
