[site]: stackoverflow
[post_id]: 2617514
[parent_id]: 2617400
[tags]: 
This seems far too error-prone to me. It encourages situations in which a lock is implicitly/silently taken out, in a way that is not clear to the reader of the code, and makes it likely that a crucial fact about the interface will be misunderstood. Usually it's a good idea to duplicate common patterns - represent an enumerable collection with IEnumerable that is disposed when you're done with it - but the added ingredient of taking out a lock makes a big difference, unfortunately. I'd suggest the ideal approach would be to not offer enumeration on collections shared between threads at all. Try to design the whole system so it isn't needed. Obviously this is going to be a crazy pipe-dream sometimes. So the next best thing would be to define a context within which an IEnumerable is temporarily available, while the lock exists: public class SomeCollection { // ... public void EnumerateInLock(Action > action) ... // ... } That is, when the user of this collection wants to enumerate it, they do this: someCollection.EnumerateInLock(e => { foreach (var item in e) { // blah } }); This makes the lifetime of the lock explicitly stated by a scope (represented by the lambda body, working much like a lock statement), and impossible to extend accidentally by forgetting to dispose. It's impossible to abuse this interface. The implementation of the EnumerateInLock method would be like this: public void EnumerateInLock(Action > action) { var e = new EnumeratorImpl(this); try { _lock.EnterReadLock(); action(e); } finally { e.Dispose(); _lock.ExitReadLock(); } } Notice how the EnumeratorImpl (which needs no particular locking code of its own) is always disposed before the lock is exited. After disposal, it throws ObjectDisposedException in response to any method call (other than Dispose , which is ignored.) This means that even if there is an attempt to abuse the interface: IEnumerable keepForLater = null; someCollection.EnumerateInLock(e => keepForLater = e); foreach (var item in keepForLater) { // aha! } This will always throw, rather than failing mysteriously sometimes based on the timing. Using a method that accepts a delegate like this is a general technique for managing resource lifetimes commonly used in Lisp and other dynamic languages, and while it is less flexible than implementing IDisposable , that reduced flexibility is often a blessing: it removes the concern over clients "forgetting to dispose". Update From your comment, I see that you need to be able to hand a reference to the collection to an existing UI framework, which will therefore expect to be able to use the normal interface to a collection, i.e. directly get an IEnumerable from it and be trusted to clean it up quickly. In which case, why worry? Trust the UI framework to update the UI and dispose the collection rapidly. Your only other realistic option is simply to make a copy of the collection when the enumerator is requested. That way, the lock only needs to be held when the copy is being made. As soon as it's ready, the lock is released. This may be more efficient if the collections are usually small, so the overhead of the copy is less than the performance saving due to shorter locks. It's tempting (for about a nanosecond) to suggest that you use a simple rule: if the collection is smaller than some threshold, make the copy, otherwise do it in your original way; choose the implementation dynamically. That way you get the optimum performance - set the threshold (by experiment) such that the copy is cheaper than holding the lock. However, I'd always think twice (or a billion times) about such "clever" ideas in threaded code, because what if there is an abuse of the enumerator somewhere? If you forget to dispose it, you won't see a problem unless it's a large collection ... A recipe for hidden bugs. Don't go there! Another potential drawback with the "expose a copy" approach is that clients will undoubtedly fall under the assumption that if an item is in the collection it is exposed to the world, but as soon as it is removed from the collection it is safely hidden. This will now be wrong! The UI thread will obtain an enumerator, then my background thread will remove the last item from it, and then begin mutating it in the mistaken belief that, because it was removed, no one else can see it. So the copying approach requires every item on the collection to effectively have its own synchronization, where most coders will assume that they can shortcut this by using the collection's synchronization instead.
