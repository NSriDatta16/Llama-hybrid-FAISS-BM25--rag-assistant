[site]: stackoverflow
[post_id]: 693530
[parent_id]: 693325
[tags]: 
This feature was in Spec# . They defaulted to nullable references and used ! to indicate non-nullables. This was because they wanted backward compatibility. In my dream language (of which I'd probably be the only user!) I'd make the same choice as you, non-nullable by default. I would also make it illegal to use the . operator on a nullable reference (or anything else that would dereference it). How would you use them? You'd have to convert them to non-nullables first. How would you do this? By testing them for null. In Java and C#, the if statement can only accept a bool test expression. I'd extend it to accept the name of a nullable reference variable: if (myObj) { // in this scope, myObj is non-nullable, so can be used } This special syntax would be unsurprising to C/C++ programmers. I'd prefer a special syntax like this to make it clear that we are doing a check that modifies the type of the name myObj within the truth-branch. I'd add a further bit of sugar: if (SomeMethodReturningANullable() into anotherObj) { // anotherObj is non-nullable, so can be used } This just gives the name anotherObj to the result of the expression on the left of the into , so it can be used in the scope where it is valid. I'd do the same kind of thing for the ?: operator. string message = GetMessage() into m ? m : "No message available"; Note that string message is non-nullable, but so are the two possible results of the test above, so the assignment is value. And then maybe a bit of sugar for the presumably common case of substituting a value for null: string message = GetMessage() or "No message available"; Obviously or would only be validly applied to a nullable type on the left side, and a non-nullable on the right side. (I'd also have a built-in notion of ownership for instance fields; the compiler would generate the IDisposable.Dispose method automatically, and the ~Destructor syntax would be used to augment Dispose , exactly as in C++/CLI.) Spec# had another syntactic extension related to non-nullables, due to the problem of ensuring that non-nullables had been initialized correctly during construction: class SpecSharpExampleClass { private string! _nonNullableExampleField; public SpecSharpExampleClass(string s) : _nonNullableExampleField(s) { } } In other words, you have to initialize fields in the same way as you'd call other constructors with base or this - unless of course you initialize them directly next to the field declaration.
