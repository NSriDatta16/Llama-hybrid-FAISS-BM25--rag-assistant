[site]: stackoverflow
[post_id]: 5728386
[parent_id]: 2351786
[tags]: 
If one have no control over the source of the main application, -Wl,-E is not applicable. Passing -Wl,-E to the linker while building own binaries (the host so and the plugins) do not help either. In my case the only working solution was to load and unload my host so from the _init function of the host so itself using RTLD_GLOBAL flag (See code below). This solution works in both cases: the main application links against the host so. the main application loads host so using dlopen (without RTLD_GLOBAL). In both cases one has to follow the instructions stated by gcc visibility wiki . If one makes the symbols of the plugin and the host so visible to each other (by using #pragma GCC visibility push/pop or corresponding attribute) and loads the plugins (from the host so) by using RTLD_GLOBAL 1. will work also without loading and unloading the own so (as mentioned by link given above). This solution makes 2. also work which has not been the case before. // get the path to the module itself static std::string get_module_path() { Dl_info info; int res = dladdr( (void*)&get_module_path, &info); assert(res != 0); //failure... std::string module_path(info.dli_fname); assert(!module_path.empty()); // no name? should not happen! return module_path; } void __attribute__ ((constructor)) init_module() { std::string module = get_module_path(); // here the magic happens :) // without this 2. fails dlclose(dlopen(module.c_str(), RTLD_LAZY | RTLD_GLOBAL)); }
