[site]: stackoverflow
[post_id]: 219791
[parent_id]: 219770
[tags]: 
Method 1: Use the #pragma warning directive. #pragma warning allows selective modification of the behavior of compiler warning messages. #pragma warning( push ) #pragma warning( disable : 4705 ) // replace 4705 with warning number ScopeGuard close_guard = MakeGuard( &close_file, file ); #pragma warning( pop ) This code saves the current warning state, then it disables the warning for a specific warning code and then restores the last saved warning state. Method 2: Use a workaround like the following. Visual Studio will be happy and so will you. This workaround is used in many Microsoft samples and also in other projects. ScopeGuard close_guard = MakeGuard( &close_file, file ); close_guard; Or you can create a #define to workaround the warning. #define UNUSED_VAR(VAR) VAR ... ScopeGuard close_guard = MakeGuard( &close_file, file ); UNUSED_VAR(close_guard); Some users stated that the code presented will not work because ScopeGuard is a typedef. This assumption is wrong. http://www.ddj.com/cpp/184403758 According to the C++ Standard, a reference initialized with a temporary value makes that temporary value live for the lifetime of the reference itself.
