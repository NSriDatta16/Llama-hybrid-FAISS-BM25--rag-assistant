[site]: stackoverflow
[post_id]: 5637389
[parent_id]: 5636399
[tags]: 
This is similar to how we did things in my Data Structures class using FORTRAN 77 (back in the mid-Cretaceous); we allocated a fixed-size array and used it as our memory pool. Basically, you have to maintain a "free" list; these are the nodes that are available for use. When you first start up, you initialize each element in your array to explicitly point to the next element: struct node {T data; struct node *next; } pool[N]; // for some type T ... for (i = 0; i Your free list initially points to the first element in the pool: struct node *free = &pool[0]; When you allocate a node, you retrieve the element that free points to, update free to point to the next available element in the list (if one exists), then initialize the element as necessary: if (free) // is there a free node available { struct node *newNode = free; free = free->next; newNode->data = ...; newNode->next = NULL; ... } When you're done with a node, you add it back to the head of the free list: node->next = free; free = node; Naturally, real code would be better organized than this, but this should be enough to give you an idea of what to do.
