[site]: stackoverflow
[post_id]: 3650802
[parent_id]: 3482161
[tags]: 
Here are some possible parts of a solution. There are various choices at each stage, which will depend on Ncluster, on how fast the data changes, and on what you want to do with the means. 3 steps: quantize, box, K-means. 1) quantize: reduce the input XYZ coordinates to say 8 bits each, by taking 2^8 percentiles of X,Y,Z separately. This will speed up the whole flow without much loss of detail. You could sort all 1G points, or just a random 1M, to get 8-bit x0 8 bit x, unrolled binary search is fast — see Bentley, Pearls p. 95. Added: Kd trees split any point cloud into different-sized boxes, each with ~ Leafsize points — much better than splitting X Y Z as above. But afaik you'd have to roll your own Kd tree code to split only the first say 16M boxes, and keep counts only, not the points. 2) box: count the number of points in each 3d box, [xj .. xj+1, yj .. yj+1, zj .. zj+1]. The average box will have 2^(30-3*8) points; the distribution will depend on how clumpy the data is. If some boxes are too big or get too many points, you could a) split them into 8, b) track the centre of the points in each box, otherwide just take box midpoints. 3) K-means clustering on the 2^(3*8) box centres. (Google parallel "k means" -> 121k hits.) This depends strongly on K aka Ncluster, also on your radius R. A rough approach would be to grow a heap of the say 27*Ncluster boxes with the most points, then take the biggest ones subject to your Radius constraint. (I like to start with a Minimum spanning tree , then remove the K-1 longest links to get K clusters.) See also Color quantization . I'd make Nbit, here 8, a parameter from the beginning. What is your Ncluster ? Added: if your points are moving in time, see collision-detection-of-huge-number-of-circles on SO.
