[site]: stackoverflow
[post_id]: 4571886
[parent_id]: 4570998
[tags]: 
Since @Tomas already gave a direct solution, I thought I'd present a solution which highlights composition with higher-order functions as a powerful technique commonly used in functional programming; this problem can be decomposed into three discrete steps: Generate all combinations of a set of elements. This is the most difficult and reusable piece of the problem. Therefore, we isolate this part of the problem into a stand-alone function which returns a sequence of combinations given a generic list of elements. Given list of (trade,value), filter out all combinations with value sums not within a given tolerance. Map each combination from a list of (trade,value) to a list of trade. I lifted @Tomas's underlying algorithm for calculating all (expect the empty) combinations of a set but use a recursive sequence expression instead of a recursive function with an accumulator (I find this slightly easier to read and write). let combinations input = let rec loop remaining current = seq { match remaining with | [] -> () | hd::tail -> yield hd::current yield! loop tail (hd::current) yield! loop tail current } loop input [] let nettedOutTrades tolerance trades = combinations trades |> Seq.filter (fun tradeCombo -> tradeCombo |> List.sumBy snd |> abs Seq.map (List.map fst) I swapped the order of trades and tolerance in your proposed function signature, since it makes it easier to curry by tolerance and pipe in (trade,value) lists which is the typical style used in the F# community and generally encouraged by the F# library. e.g.: [("a", 2); ("b", -1); ("c", -2); ("d", 1)] |> nettedOutTrades 1
