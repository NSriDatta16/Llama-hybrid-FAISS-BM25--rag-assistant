[site]: stackoverflow
[post_id]: 4145176
[parent_id]: 4144296
[tags]: 
OK, if you're prepared to change Person from an interface into an abstract base class, then you're golden. Here's the code: public class Main { public static void main(String[] args) throws Exception { Community community = new Community(); JAXBContext context = JAXBContext.newInstance(Community.class); Marshaller marshaller = context.createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); marshaller.marshal(community, System.out); } } @XmlRootElement(name = "community") @XmlSeeAlso({Person.class}) public class Community { private List people; @XmlElementWrapper(name="people") @XmlElementRef() public List getPeople() { return people; } public Community() { people = new ArrayList (); people.add(new Girl()); people.add(new Boy()); people.add(new Girl()); people.add(new Boy()); } } @XmlRootElement(name="boy") public class Boy extends Person { public String getName() { return "John"; } } @XmlRootElement(name="girl") public class Girl extends Person { public String getName() { return "Jane"; } } @XmlRootElement(name = "person") @XmlSeeAlso({Girl.class,Boy.class}) public abstract class Person { @XmlElement(name="name") public abstract String getName(); } The main trick was the use of @XmlElementRef in the List of Community. This identifies the type of the class through it's @XmlRootElement. You may also be interested in the @XmlSeeAlso which helps to organise context declarations. And the output is Jane John Jane John
