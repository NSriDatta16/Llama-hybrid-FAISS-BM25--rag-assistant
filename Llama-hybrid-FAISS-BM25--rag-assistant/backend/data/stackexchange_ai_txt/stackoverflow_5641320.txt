[site]: stackoverflow
[post_id]: 5641320
[parent_id]: 5637963
[tags]: 
I was very curious about the relative speed of the various Perl-based methods submitted by other authors for this question. So, I decided to benchmark them. Where necessary, I slightly modified each method so that it would populate an @output array, to keep the input and output consistent. I verified that all the methods produce the same @output , although I have not documented that assertion here. Here is the script to benchmark the various methods: #!/usr/bin/perl use strict; use warnings; use Benchmark qw(cmpthese :hireswallclock); # get a convenient list of words (on Mac OS X 10.6.6, this contains 234,936 entries) open (my $fh, ' ; close $fh; # remove line breaks chomp @input; # set-up the tests ( my %tests = ( # Author: cjm RegExp => sub { my @output = grep { not /(\w).*\1/ } @input }, # Author: daotoad SplitCount => sub { my @output = grep { my @l = split ''; my %l; @l{@l} = (); keys %l == @l } @input; }, # Author: ikegami NextIfSeen => sub { my @output; INPUT: for (@input) { my %seen; while (/(.)/sg) { next INPUT if $seen{$1}++; } push @output, $_; } }, # Author: ysth BitMask => sub { my @output; for my $word (@input) { my $mask1 = $word x ( length($word) - 1 ); my $mask2 = join( '', map { substr($word, $_), substr($word, 0, $_) } 1..length($word)-1 ); if ( ( $mask1 ^ $mask2 ) !~ tr/\0// ) { push @output, $word; } } }, ); # run each test 100 times cmpthese(100, \%tests); Here are the results for 100 iterations. s/iter SplitCount BitMask NextIfSeen RegExp SplitCount 2.85 -- -11% -58% -85% BitMask 2.54 12% -- -53% -83% NextIfSeen 1.20 138% 113% -- -64% RegExp 0.427 567% 496% 180% -- As you can see, cjm's "RegExp" method is the fastest by far. It is 180% faster than the next fastest method, ikegami's "NextIfSeen" method. I suspect that the relative speed of the RegExp and NextIfSeen methods will converge as the average length of the input strings increases. But for "normal" length English words, the RegExp method is the fastest.
