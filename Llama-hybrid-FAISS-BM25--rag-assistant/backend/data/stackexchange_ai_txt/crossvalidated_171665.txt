[site]: crossvalidated
[post_id]: 171665
[parent_id]: 22974
[tags]: 
Firstly: The algorithm also falsely calls a drop to the right of a flat plateau since sign(diff(x, na.pad = FALSE)) will be 0 then -1 so that its diff will also be -1. A simple fix is to ensure that the sign-diff preceding the negative entry is not zero but positive: n 0) + 1 Second: The algorithm gives very local results, e.g. an 'up' followed by a 'down' in any run of three consecutive terms in the sequence. If one is interested instead in local maxima of a noised continuous function, then -- there are probably other better things out there, but this is my cheap and immediate solution identify the peaks first using running average of 3 consecutive points to smooth the data ever so slightly. Also employ the above mentioned control against flat then drop-off. filter these candidates by comparing, for a loess-smoothed version, the average inside a window centered at each peak with the average of local terms outside. "myfindPeaks" 0) + 1 out thresh*sig.y) out
