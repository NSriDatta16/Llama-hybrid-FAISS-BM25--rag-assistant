[site]: stackoverflow
[post_id]: 2516425
[parent_id]: 2515450
[tags]: 
By Python's rules, you cannot alter your caller's locals ; in the current implementations, if you try (e.g. with the black magic Anurag suggests) you will not get an exception (though I'd like to add that error check to some future version), but it will be essentially inoperative if your caller is a function (not if your caller is module top-level code) -- the caller's actual local variables won't in fact be affected. This holds whether the caller's locals are explicitly passed in, or fetched through black magic: they still need to be treated as a read-only dict if your code is to have any sanity. Rather, you could have the caller pass in an explicit, real, normal dict (which could be initialized from locals() if you want), and all alterations your code does in that dict will still be there for the caller's use -- just not as "new barenames" in the caller's local scope of course, but the functionality is the same whether the caller needs to use x['foo'] or x.foo or (as you'd prefer) just barename foo . BTW, to use attribute-access syntax rather than dict indexing syntax, you can do: class Bunch(object): pass ... # caller code b = Bunch() thefun(b) print b.foo ... # called function def thefun(b): b.foo = 23 This also covers, with a tiny variation, the case in which thefun wants to work with dict indexing syntax (say its body is b['foo'] = 23 instead of b.foo = 23 ): in that case, the caller just needs to use thefun(vars(b)) instead of the plain thefun(b) , but it can keep working with the b.foo access syntax afterwards.
