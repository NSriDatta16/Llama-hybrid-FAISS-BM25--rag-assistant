[site]: stackoverflow
[post_id]: 5719703
[parent_id]: 5711382
[tags]: 
The key problem was with the function: buildChord :: [[Double]] -> WAVESamples buildChord freqs = map ((:[]) . round . sum) $ transpose freqs The result of transpose freqs was a list of sound volumes for a particular point in time for each note being played (eg [45.2, 20, -10] ). The function (:[] . round . sum) firstly added them together (eg 55.2 ), rounds it (eg to 55 ), and wraps it in a list (eg [55] ). map (:[] . round . sum) just did that for all the instances of time. The problem is if you have many note playing at once, the sum results in a note that is too loud. What would be better is to take the average of the notes, rather than the sum. That means 10 notes playing at the same time wont be too loud. Surprisingly, there is no average function in the prelude. So we can either write our own average function, or just embed it in the function passed to map. I did the latter as it was less code: buildChord :: [[Double]] -> WAVESamples buildChord freqs = map (\chord -> [round $ sum chord / genericLength chord]) $ transpose freqs I'm guessing from your questions that you are writing a music making program as a way to learn haskell. I have a few ideas that may make your code easier to debug, and more "haskell like". Code in haskell is often written as a sequence of transformations from input to output. That buildChord function is a good example - firstly the input was transposed, then mapped over with a function that combined the multiple sound amplitudes. However, you could also structure your whole program in this style. The purpose of the program seems to be: "read notes from a file in some format, then create a wav file from those notes read". The way I would solve that problem would be firstly to break that up into different pure transformations (ie using no input or output), and do the reading and writing as the final step. I would firstly start by writing a sound wave to WAVE transformation. I would use the type: data Sound = Sound { soundFreqs :: [Double] , soundVolume :: Double , soundLength :: Double } Then write the function: soundsToWAVE :: Int -> [Sound] -> WAVE soundsToWAVE samplesPerSec sounds = undefined -- TODO Then I could write the functions writeSoundsToWavFile and testPlaySounds : writeSoundsToWavFile :: String -> Int -> [Sound] -> IO () writeSoundsToWavFile fileN samplesPerSec sounds = putWAVEFile $ soundsToWAVE fileN samplesPerSec sounds testPlaySounds :: [Sound] -> IO () testPlaySounds sounds = do writeSoundsToWavFile "test.wav" 32000 sounds system("afplay test.wav") -- use aplay on linux, don't know for windows return () Once that is done, all the WAVE code is done - the rest of the code doesn't need to touch it. It may be a good idea to put that in its own module. After that, I would write a transformation between music notes and Sounds. I would use the following types for notes: data Note = A | B | C | D | E | F | G data NoteAugment = None | Sharp | Flat data MusicNote = MusicNote { note :: Note, noteAugment :: NoteAugment, noteOctave :: Int } data Chord = Chord { notes :: [MusicNote], chordVolume :: Double } Then write the function: chordToSound :: Chord -> Sound chordToSound = undefined -- TODO You could then easily write the function musicNotesToWAVFile: chordsToWAVFile fileName samplesPerSec notes = writeSoundsToWavFile 32000 fileName samplesPerSec (map chordToSound notes) (the function testPlayChords can be done in the same way). You could also put this in a new module. Finally I would write the transformation note string -> [Chord]. This would just need the function: parseNoteFileText :: String -> [Chord] parseNoteFileText noteText = undefined The final program could then be wired up: main = do putStrLn "Enter the name of the file: " fileN
