[site]: stackoverflow
[post_id]: 5318896
[parent_id]: 5318068
[tags]: 
I think a programmer should have implemented his own bignum-library once, so welcome here. (Of course, later you'll get that BigInteger is better, and use this, but it is a valuable learning experience.) (You can follow the source code of this course life on github . Also, I remade this (a bit polished) into a 14-part blog series .) Creating a simple Big number class in Java So, what do we need? First, a representation of the number, based on the datatypes which Java gives us. As you think the decimal conversion is the most complicated part, let's stay in a decimal based mode. For efficiency, we'll store not real decimal digits, but work in base 1 000 000 000 = 10^9 . This fits in a Java int (up to 2^31 or 2^32 ), and the product of two such digits fits nicely in a Java long . final static int BASE = 1000000000; final static int BASE_DECIMAL_DIGITS = 9; Then the digits-array: private int[] digits; Do we store the digits in little- or big endian, i.e. the bigger parts first or last? It does not really matter, so we decide on big-endian since this is how humans want to read it. (For now we concentrate on non-negative values - later we'll add a sign bit for negative numbers.) For testing purposes, we add a constructor which allows initializing from such a int[]. /** * creates a DecimalBigInt based on an array of digits. * @param digits a list of digits, each between 0 (inclusive) * and {@link BASE} (exclusive). * @throws IllegalArgumentException if any digit is out of range. */ public DecimalBigInt(int... digits) { for(int digit : digits) { if(digit As a added bonus, this constructor is also usable for a single int (if smaller than BASE ), and even for no int (which we'll interpret as 0). So, we now can do this: DecimalBigInt d = new DecimalBigInt(7, 5, 2, 12345); System.out.println(d); This gives us de.fencing_game.paul.examples.DecimalBigInt@6af62373 , not so useful. So, we add a toString() method: /** * A simple string view for debugging purposes. * (Will be replaced later with a real decimal conversion.) */ public String toString() { return "Big" + Arrays.toString(digits); } The output is now Big[7, 5, 2, 12345] , which is more useful for testing, isn't it? Second, conversion from decimal format. We are lucky here: our base (10^9) is a power of the base we want to convert from (10). Thus, we always have the same number (9) of decimal digits representing one "our format" digit. (Of course, in the beginning there may be some digits less.) In the following code, decimal is a String of decimal digits. int decLen = decimal.length(); int bigLen = (decLen-1) / BASE_DECIMAL_DIGITS + 1; This strange formula is a Java int way of writing bigLen = ceil(decLen/BASE_DECIMAL_DIGITS) . (I hope it is correct, we'll later test it.) int firstSome = decLen - (bigLen-1) * BASE_DECIMAL_DIGITS; This is the length of the first block of decimal digits, should be between 1 and 9 (inclusive). We create our array: int[] digits = new int[bigLen]; Looping through the digits to be created: for(int i = 0; i Each of our digits is represented by a block of digits in the original number: String block = decimal.substring(Math.max(firstSome + (i-1)*BASE_DECIMAL_DIGITS, 0), firstSome + i *BASE_DECIMAL_DIGITS); (The Math.max is needed here for the first shorter block.) We now use the usual Integer parsing function, and put the result into the array: digits[i] = Integer.parseInt(block); } From the array now created we create our DecimalBigInt object: return new DecimalBigInt(digits); Let's see if this works: DecimalBigInt d2 = DecimalBigInt.valueOf("12345678901234567890"); System.out.println(d2); Output: Big[12, 345678901, 234567890] Looks right :-) We should test it with some other numbers (of different length) too. Next part will be decimal formatting, this should be even easier. Third, conversion to decimal format. We need to output our individual digits as 9 decimal digits each. For this we can use the Formatter class, which supports printf-like format strings. A simple variant would be this: public String toDecimalString() { Formatter f = new Formatter(); for(int digit : digits) { f.format("%09d", digit); } return f.toString(); } This returns 000000007000000005000000002000012345 and 000000012345678901234567890 for our two numbers. This works for a round-trip (i.e. feeding it to the valueOf method gives an equivalent object), but the leading zeros are not really nice to look at (and could create confusion with octal numbers). So we need to break apart our beautiful for-each loop and use a different formatting string for the first and the following digits. public String toDecimalString() { Formatter f = new Formatter(); f.format("%d", digits[0]); for(int i = 1; i Addition. Let's start with addition, as this is simple (and we can use parts of it for the multiplication later). /** * calculates the sum of this and that. */ public DecimalBigInt plus(DecimalBigInt that) { ... } I want method names that you can read like you would read the formula, thus plus , minus , times instead of add , subtract , multiply . So, how does addition work? It works the same as we learned it in school for decimal numbers higher than 9: add the corresponding digits, and if for some of then the result is bigger than 10 (or BASE in our case), carry one to the next digit. This can cause the resulting number to have one digit more than the original ones. First we look at the simple case that both numbers have same number of digits. Then it looks simply like this: int[] result = new int[this.digits.length]; int carry = 0; for(int i = this.digits.length-1; i > 0; i--) { int digSum = carry + this.digits[i] + that.digits[i]; result[i] = digSum % BASE; carry = digSum / BASE; } if(carry > 0) { int[] temp = new int[result.length + 1]; System.arraycopy(result, 0, temp, 1, result.length); temp[0] = carry; result = temp; } return new DecimalBigInt(result); (We go from right to left, so we can carry any overflows to the next digit. This would be a bit prettier if we had decided using Little Endian format.) If both numbers do not have the same number of digits, it gets a bit more complicated. To let it as simple as possible, we split it to several methods: This method adds one digit to an element in the array (which may already contain some non-zero value), and stores the result back in the array. If there was overflow, we carry it to the next digit (which has index one less, not one more) by means of a recursive call. This way we make sure our digits stay always in the valid range. /** * adds one digit from the addend to the corresponding digit * of the result. * If there is carry, it is recursively added to the next digit * of the result. */ private void addDigit(int[] result, int resultIndex, int addendDigit) { int sum = result[resultIndex] + addendDigit; result[resultIndex] = sum % BASE; int carry = sum / BASE; if(carry > 0) { addDigit(result, resultIndex - 1, carry); } } The next does the same for a whole array of digits to add: /** * adds all the digits from the addend array to the result array. */ private void addDigits(int[] result, int resultIndex, int... addend) { int addendIndex = addend.length - 1; while(addendIndex >= 0) { addDigit(result, resultIndex, addend[addendIndex]); addendIndex--; resultIndex--; } } Now we can implement our plus method: /** * calculates the sum of this and that. */ public DecimalBigInt plus(DecimalBigInt that) { int[] result = new int[Math.max(this.digits.length, that.digits.length)+ 1]; addDigits(result, result.length-1, this.digits); addDigits(result, result.length-1, that.digits); // cut of leading zero, if any if(result[0] == 0) { result = Arrays.copyOfRange(result, 1, result.length); } return new DecimalBigInt(result); } We could do a bit better here if we would look before if overflow is at all possible and only then create the array one bigger than necessary. Ah, one test: d2.plus(d2) gives Big[24, 691357802, 469135780] , which looks right. Multiplication. Let's remember back to school, how did we multiply bigger numbers on paper? 123 * 123 ---------- 369 So, we have to multiply each digit[i] of the first number with each digit[j] of the second number, and add the product in digit[i+j] of the result (and pay attention to carry). Of course, here the indexes are counted from right, not from left. (Now i really wish I had used little-endian numbers.) Since the product of two of our digits can get outside of the range of int , we use long for multiplication. /** * multiplies two digits and adds the product to the result array * at the right digit-position. */ private void multiplyDigit(int[] result, int resultIndex, int firstFactor, int secondFactor) { long prod = (long)firstFactor * (long)secondFactor; int prodDigit = (int)(prod % BASE); int carry = (int)(prod / BASE); addDigits(result, resultIndex, carry, prodDigit); } Now we can see why I declared my addDigits method to take a resultIndex parameter. (And I just changed the last argument to a varargs parameter, to be able to write this here better.) So, here the cross-multiplying method: private void multiplyDigits(int[] result, int resultIndex, int[] leftFactor, int[] rightFactor) { for(int i = 0; i I hope I have the index-calculations right. With a little-endian representation, it would have been multiplyDigit(result, resultIndex + i + j, leftFactor[i], rightFactor[j]) - quite clearer, isn't it? Our times method now has only to allocate the result array, invoke multiplyDigits and wrap the result. /** * returns the product {@code this × that}. */ public DecimalBigInt times(DecimalBigInt that) { int[] result = new int[this.digits.length + that.digits.length]; multiplyDigits(result, result.length-1, this.digits, that.digits); // cut off leading zero, if any if(result[0] == 0) { result = Arrays.copyOfRange(result, 1, result.length); } return new DecimalBigInt(result); } For testing, d2.times(d2) gives Big[152, 415787532, 388367501, 905199875, 19052100] , which is the same what my Emacs calc calculates here. Comparison We want to be able to compare two of our objects. So, we implement Comparable and its compareTo method. public int compareTo(DecimalBigInt that) { How to know if one of our numbers is bigger than another? First, we compare the length of the arrays. As we took care not to induce any leading zeros (did we?), the longer array should have the bigger number. if(this.digits.length If the length are same, we can compare elementwise. Since we use big endian (i.e. the big end comes first ), we start at the beginning. for(int i = 0; i If everything was same, obviously our numbers are identical, and we can return 0 . return 0; } equals + hashCode() Every good immutable class should implement equals() and hashCode() in a suitable (and compatible) way. For our hashCode() , we simply sum up the digits, multiplying them with a small prime to make sure digit-switching does not result in same hash code: /** * calculates a hashCode for this object. */ public int hashCode() { int hash = 0; for(int digit : digits) { hash = hash * 13 + digit; } return hash; } In the equals() method we simply can delegate to the compareTo method, instead of implementing the same algorithm again: /** * compares this object with another object for equality. * A DecimalBigInt is equal to another object only if this other * object is also a DecimalBigInt and both represent the same * natural number. */ public boolean equals(Object o) { return o instanceof DecimalBigInt && this.compareTo((DecimalBigInt)o) == 0; } So, enough for today. Subtraction (and maybe negative numbers) and division are more complicated, so I'm omitting them for now. For calculating the factorial of 90 this should be enough. Calculating big factorials: Here the factorial function: /** * calculates the factorial of an int number. * This uses a simple iterative loop. */ public static DecimalBigInt factorial(int n) { DecimalBigInt fac = new DecimalBigInt(1); for(int i = 2; i This gives us fac(90) = 1485715964481761497309522733620825737885569961284688766942216863704985393094065876545992131370884059645617234469978112000000000000000000000 Converting from arbitrary-radix representations Prompted by the next question of frodosamoa, I wrote my answer about how to convert from arbitrary (positional) number systems in the one in which we can (or want to) calculate . (In the example there, I converted from trinary to decimal, while the question was about decimal to binary.) Here we want to convert from an arbitrary number system (okay, with radix between 2 and 36, so we can use Character.digit() to convert single digits to ints) to our system with radix BASE (= 1.000.000.000, but this is not really important here). Basically we use Horner scheme to calculate the value of polynomial with the digits as coefficients at the point given by the radix. sum[i=0..n] digit[i] * radix^i can be calculated with this loop: value = 0; for i = n .. 0 value = value * radix + digit[i] return value Since our input strings are big-endian, we don't have to count down, but can use a simple enhanced for loop. (It looks more ugly in Java, since we have no operator overloading, and no autoboxing from int to our DecimalBigInt type.) public static DecimalBigInt valueOf(String text, int radix) { DecimalBigInt bigRadix = new DecimalBigInt(radix); DecimalBigInt value = new DecimalBigInt(); // 0 for(char digit : text.toCharArray()) { DecimalBigInt bigDigit = new DecimalBigInt(Character.digit(digit, radix)); value = value.times(bigRadix).plus(bigDigit); } return value; } In my actual implementation I added some error checking (and exception throwing) to ensure that we really have a valid number, and of course a documentation comment. Converting to an arbitrary positional system is more complicated, as it involves remainder and division (by the arbitrary radix), which we did not implement yet - so not for now. It will be done when I have a good idea on how to do division. (We need only division by small (one-digit) numbers here, which may be easier than a general division.) Division by small numbers In school, I learned long division . Here is an example for a small (one-digit) divisor, in the notation we use here in Germany (with annotations about the background calculations, which we normally would not write), in decimal system: 12345 : 6 = 02057 1 / 6 = 0 -0┊┊┊┊ 0 * 6 = 0 ──┊┊┊┊ 12┊┊┊ 12 / 6 = 2 -12┊┊┊ 2 * 6 = 12 ──┊┊┊ 03┊┊ 3 / 6 = 0 - 0┊┊ 0 * 6 = 0 ──┊┊ 34┊ 34 / 6 = 5 -30┊ 5 * 6 = 30 ──┊ 45 45 / 6 = 7 -42 7 * 6 = 42 ── 3 ==> quotient 2057, remainder 3. Of couse, we don't need to calculate these products (0, 12, 0, 30, 42) and subtract them if we have a native remainder operation. Then it looks like this (of course, we here would not need to write the operations): 12345 : 6 = 02057 1 / 6 = 0, 1 % 6 = 1 12┊┊┊ 12 / 6 = 2, 12 % 6 = 0 03┊┊ 3 / 6 = 0, 3 % 6 = 3 34┊ 34 / 6 = 5, 34 % 6 = 4 45 45 / 6 = 7, 45 % 6 = 3 3 ==> quotient 2057, remainder 3. This already looks quite like short division , if we write it in another format. We can observe (and prove) the following: If we have a two-digit number x with first digit smaller than our divisor d, than x / d is a one-digit number, and x % d is also a one-digit number, smaller than d. This, together with induction, shows that we only ever need to divide (with remainder) two-digit numbers by our divisor. Coming back to our big numbers with radix BASE: all two-digit numbers are representable as a Java long , and there we have native / and % . /** * does one step in the short division algorithm, i.e. divides * a two-digit number by a one-digit one. * * @param result the array to put the quotient digit in. * @param resultIndex the index in the result array where * the quotient digit should be put. * @param divident the last digit of the divident. * @param lastRemainder the first digit of the divident (being the * remainder of the operation one digit to the left). * This must be We will now call this method in a loop, always feeding the result from the previous call back as lastRemainder . /** * The short division algorithm, like described in * Wikipedia's * article Short division . * @param result an array where we should put the quotient digits in. * @param resultIndex the index in the array where the highest order digit * should be put, the next digits will follow. * @param divident the array with the divident's digits. (These will only * be read, not written to.) * @param dividentIndex the index in the divident array where we should * start dividing. We will continue until the end of the array. * @param divisor the divisor. This must be a number smaller than * {@link #BASE}. * @return the remainder, which will be a number smaller than * {@code divisor}. */ private int divideDigits(int[] result, int resultIndex, int[] divident, int dividentIndex, int divisor) { int remainder = 0; for(; dividentIndex This method still returns an int, the remainder. Now we want to have a public method returning a DecimalBigInt, so we create one. It has the task to check the arguments, create an array for the working method, discard the remainder, and create a DecimalBigInt from the result. (The constructor removes a leading zero which may be there.) /** * Divides this number by a small number. * @param divisor an integer with {@code 0 = BASE. */ public DecimalBigInt divideBy(int divisor) { if(divisor We also have a similar method, which returns the remainder instead: /** * Divides this number by a small number, returning the remainder. * @param divisor an integer with {@code 0 = BASE. */ public int modulo(int divisor) { if(divisor These methods can be invoked like this: DecimalBigInt d3_by_100 = d3.divideBy(100); System.out.println("d3/100 = " + d3_by_100); System.out.println("d3%100 = " + d3.modulo(100)); Conversion to arbitrary radix Now we have the basics to convert to an arbitrary radix. Of course, not really arbitrary, only radixes smaller than BASE are allowed, but this should not be a too big problem. As already answered in another answer about converting numbers, we have to do "division, remainder, multiply, add. The "multiply-add" part is in fact only putting together the individual digits, so we can replace it by a simple array-access. As we always need both the quotient and the remainder, we won't use the public methods modulo and divideBy , but instead repeatedly call the divideDigits method. /** * converts this number to an arbitrary radix. * @param radix the target radix, {@code 1 First, a special-case handling for 0. // zero has no digits. if(digits.length == 0) return new int[0]; Then, we create an array for the result digits (long enough), and some other variables. // raw estimation how many output digits we will need. // This is just enough in cases like BASE-1, and up to // 30 digits (for base 2) too much for something like (1,0,0). int len = (int) (Math.log(BASE) / Math.log(radix) * digits.length)+1; int[] rDigits = new int[len]; int rIndex = len-1; int[] current = digits; int quotLen = digits.length; quotLen is the number of digits (excluding leading zeroes) in the last quotient. If this is 0, we are done. while(quotLen > 0) { A new array for the next quotient. int[] quot = new int[quotLen]; The quotient-and-remainder operation. The quotient is now in quot , the remainder in rem . int rem = divideDigits(quot, 0, current, current.length - quotLen, radix); We put the remainder in the output array (filling it from the last digit). rDigits[rIndex] = rem; rIndex --; Then we swap the arrays for the next round. current = quot; If there are leading zeros in the quotient (there will be at most one, since radix is smaller than BASE), we shrink the quotient size by one. The next array will be smaller. if(current[0] == 0) { // omit leading zeros in next round. quotLen--; } } After the loop there may be leading zeros in the rDigits array, and we cut them off. // cut of leading zeros in rDigits: while(rIndex That's it. It looks a bit complicated, though. Here is an example of how to use it: System.out.println("d4 in base 11: " + Arrays.toString(d4.convertTo(11))); System.out.println("d5 in base 7: " + Arrays.toString(d5.convertTo(7))); These print [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0] and [1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0] , just the same numbers as we parsed before (from a String, though). Based on this we can also format as a string: /** * Converts the number to a String in a given radix. * This uses {@link Character.digit} to convert each digit * to one character. * @param radix the radix to use, between {@link Character.MIN_RADIX} * and {@link Character.MAX_RADIX}. * @return a String containing the digits of this number in the * specified radix, using '0' .. '9' and 'a' .. 'z' (as much as needed). */ public String toString(int radix) { if(radix
