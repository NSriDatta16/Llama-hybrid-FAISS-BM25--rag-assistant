[site]: stackoverflow
[post_id]: 2535232
[parent_id]: 2535148
[tags]: 
For scenario 1, the compiler should not perform any of the reorderings you mention. For scenario 2, the answer might depend on: and whether the b and c variables are visible outside the current function (either by being non-local or having had their address passed who you talk to (apparently there is some disagreement about how string volatile is in C/C++) your compiler implementation So (softening my first answer), I'd say that if you're depending on certain behavior in scenario 2, you'd have to treat it as non-portable code whose behavior on a particular platform would have be determined by whatever the implementation's documentation might indicate (and if the docs said nothing about it, then you're out of luck with a guaranteed behavior. from C99 5.1.2.3/2 "Program execution": Accessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment. Evaluation of an expression may produce side effects. At certain specified points in the execution sequence called sequence points, all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place. ... (paragraph 5) The least requirements on a conforming implementation are: At sequence points, volatile objects are stable in the sense that previous accesses are complete and subsequent accesses have not yet occurred. Here's a little of what Herb Sutter has to say about the required behavior of volatile accesses in C/C++ (from " volatile vs. volatile " http://www.ddj.com/hpc-high-performance-computing/212701484 ) : what about nearby ordinary reads and writes -- can those still be reordered around unoptimizable reads and writes? Today, there is no practical portable answer because C/C++ compiler implementations vary widely and aren't likely to converge anytime soon. For example, one interpretation of the C++ Standard holds that ordinary reads can move freely in either direction across a C/C++ volatile read or write, but that an ordinary write cannot move at all across a C/C++ volatile read or write -- which would make C/C++ volatile both less restrictive and more restrictive, respectively, than an ordered atomic. Some compiler vendors support that interpretation; others don't optimize across volatile reads or writes at all; and still others have their own preferred semantics. And for what it's worth, Microsoft documents the following for the C/C++ volatile keyword (as Microsoft-sepcific): A write to a volatile object (volatile write) has Release semantics; a reference to a global or static object that occurs before a write to a volatile object in the instruction sequence will occur before that volatile write in the compiled binary. A read of a volatile object (volatile read) has Acquire semantics; a reference to a global or static object that occurs after a read of volatile memory in the instruction sequence will occur after that volatile read in the compiled binary. This allows volatile objects to be used for memory locks and releases in multithreaded applications.
