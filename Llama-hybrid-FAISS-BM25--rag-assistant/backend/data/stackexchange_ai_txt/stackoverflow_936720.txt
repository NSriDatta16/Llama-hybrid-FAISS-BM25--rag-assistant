[site]: stackoverflow
[post_id]: 936720
[parent_id]: 933242
[tags]: 
I usually use an Exponential Moving Average to compute the speed of an operation with a smoothing factor of say 0.1 and use that to compute the remaining time. This way all the measured speeds have influence on the current speed, but recent measurements have much more effect than those in the distant past. In code it would look something like this: alpha = 0.1 # smoothing factor ... speed = (speed * (1 - alpha)) + (currentSpeed * alpha) If your tasks are uniform in size, currentSpeed would simply be the time it took to execute the last task. If the tasks have different sizes and you know that one task is supposed to be i,e, twice as long as another, you can divide the time it took to execute the task by its relative size to get the current speed. Using speed you can compute the remaining time by multiplying it by the total size of the remaining tasks (or just by their number if the tasks are uniform). Hopefully my explanation is clear enough, it's a bit late in the day.
