[site]: stackoverflow
[post_id]: 4317099
[parent_id]: 4310992
[tags]: 
According to the documentation, the code you have written is invalid. UIKit objects may not be called anywhere but on the main thread. I'll bet that what you're doing happens to work in most respects but doesn't successfully alter the display, with the screen being updated by coincidence for some other reason. Apple strongly recommend that threads are not the way to perform asynchronous URL fetches if you want to remain battery efficient. Instead you should be using NSURLConnection and allowing the runloop to organise asynchronous behaviour. It's not that hard to write a quick method that just accumulates data to an NSData as it comes then posts the whole thing on to a delegate when the connection is complete but assuming you'd rather stick with what you've got I'd recommend: url = [NSURL URLWithString:theURLString]; NSData *data = [NSData dataWithContentsOfURL:url]; [self performSelectorOnMainThread:@selector(setImageViewImage:) withObject:data waitUntilDone:YES]; ... - (void)setImageViewImage:(NSData *)data { img = [[UIImage alloc] initWithData:data]; [imageView setImage:img]; [img release]; NSLog(@"Image reloaded"); } performSelectorOnMainThread does what the name says â€” the object is sent to will schedule the selector requested with the object given as a single parameter on the main thread as soon as the run loop can get to it. In this case 'data' is an autoreleased object on the pool in the thread implicitly created by the NSOperation. Because you need it to remain valid until it has been used, I've used waitUntilDone:YES . An alternative would be to make data something that you explicitly own and have the main thread method release it. The main disadvantage of this method is that if the image returns in a compressed form (such as a JPEG or a PNG), it'll be decompressed on the main thread. To avoid that without making empirical guesses about the behaviour of UIImage that go above and beyond what is documented to be safe, you'd need to drop to the C level and use CoreGraphics. But I'm taking it as given that doing so is beyond the scope of this question.
