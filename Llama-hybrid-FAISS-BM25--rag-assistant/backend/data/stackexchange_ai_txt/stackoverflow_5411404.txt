[site]: stackoverflow
[post_id]: 5411404
[parent_id]: 5411251
[tags]: 
Have you tried the range constructor? #include #include #include #include int main() { std::ifstream file("Plop"); std::set myset; std::copy(std::istream_iterator (file), std::istream_iterator (), std::inserter(myset, myset.end())); } Tried 4 techniques with [0 -> 10,000,000) items (sorted in file): void t1(std::set & data, std::istream& file) { int x; while(file >> x) {data.insert(x); } } void t2(std::set & data, std::istream& file) { int x; while(file >> x) {data.insert(data.end(), x);} } void t3(std::set & data, std::istream& file) { std::set ::iterator it = data.begin(); int x; while(file >> x) {it = data.insert(it, x);} } void t4(std::set & data, std::istream& file) { std::copy(std::istream_iterator (file), std::istream_iterator (), std::inserter(data, data.end())); } Times in clock() average over 3 runs (normal) and 3 runs(-O4) Plain Data Normal -O4 ========= ========= t1 Result: 21057300 6748061 t2 Result: 6580081 4752549 t3 Result: 6675929 4786003 t4 Result: 8452749 6460603 Conclusion 1: for sorted data: Best: data.insert(data.end(), ) // Hint end() Worst: data.insert( ); // No Hint Conclusion 2: Optimization counts.
