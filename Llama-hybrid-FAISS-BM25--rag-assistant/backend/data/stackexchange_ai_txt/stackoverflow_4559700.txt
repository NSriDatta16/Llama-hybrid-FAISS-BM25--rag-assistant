[site]: stackoverflow
[post_id]: 4559700
[parent_id]: 
[tags]: 
How to get Hard-Disk SerialNumber in C# (no WMI)?

I know there are two articles in CodeProject (one uses WMI and the other no WMI but in C++). I tried the WMI way, not only it's slow, but it is also unreliable. So, that's why I decided not to pursue that way. I want to do it in C# through pInvoke. I tried it but got stuck in DeviceIoControl API. Can anybody give me a hint? Here is my code: using System; using System.ComponentModel; using System.Collections.Generic; using System.Linq; using System.Text; using System.Runtime.InteropServices; using Microsoft.Win32.SafeHandles; namespace Chemulator.Common { public class HDSerialNumber { [StructLayout(LayoutKind.Sequential)] private struct IDEREGS { public byte bFeaturesReg; public byte bSectorCountReg; public byte bSectorNumberReg; public byte bCylLowReg; public byte bCylHighReg; public byte bDriveHeadReg; public byte bCommandReg; public byte bReserved; } [StructLayout(LayoutKind.Sequential)] private struct SENDCMDINPARAMS { public Int32 cBufferSize; public IDEREGS irDriveRegs; public byte bDriveNumber; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)] public byte[] bReserved; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)] public Int32[] dwReserved; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)] public byte[] bBuffer; } [StructLayout(LayoutKind.Sequential)] private struct DRIVERSTATUS { public byte bDriverError; public byte bIDEError; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)] public byte[] bReserved; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)] public Int32[] dwReserved; } [StructLayout(LayoutKind.Sequential)] private struct SENDCMDOUTPARAMS { public Int32 cBufferSize; public DRIVERSTATUS DriverStatus; [MarshalAs(UnmanagedType.ByValArray, SizeConst = IDENTIFY_BUFFER_SIZE)] public byte[] bBuffer; } [StructLayout(LayoutKind.Sequential)] private struct GETVERSIONOUTPARAMS { public byte bVersion; public byte bRevision; public byte bReserved; public byte bIDEDeviceMap; public Int32 fCapabilities; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)] public Int32 dwReserved; } [StructLayout(LayoutKind.Sequential)] private struct STORAGE_PROPERTY_QUERY { public Int32 PropertyId; public Int32 QueryType; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)] public byte[] AdditionalParameters; } [StructLayout(LayoutKind.Sequential)] private struct STORAGE_DEVICE_DESCRIPTOR { public Int32 Version; public Int32 Size; public byte DeviceType; public byte DeviceTypeModifier; public byte RemovableMedia; public byte CommandQueueing; public Int32 VendorIdOffset; public Int32 ProductIdOffset; public Int32 ProductRevisionOffset; public Int32 SerialNumberOffset; public byte BusType; public Int32 RawPropertiesLength; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10240)] public byte[] RawDeviceProperties; } [DllImport("kernel32.dll", SetLastError = true)] private static extern SafeFileHandle CreateFile(string lpFileName, Int32 dwDesiredAccess, Int32 dwShareMode, IntPtr lpSecurityAttributes, Int32 dwCreationDisposition, Int32 dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32")] private static extern bool DeviceIoControl(SafeFileHandle hDevice, uint dwIoControlCode, IntPtr lpInBuffer, uint nInBufferSize, IntPtr lpOutBuffer, uint nOutBufferSize, ref uint lpBytesReturned, IntPtr lpOverlapped); private const Int32 OPEN_EXISTING = 3; private const Int32 GENERIC_READ = unchecked((int)0x80000000); private const Int32 GENERIC_WRITE = 0x40000000; private const Int32 FILE_SHARE_READ = 0x1; private const Int32 FILE_SHARE_WRITE = 0x2; private const Int32 FILE_SHARE_DELETE = 0x4; private const Int32 SMART_GET_VERSION = 0x74080; private const Int32 SMART_RCV_DRIVE_DATA = 0x7C088; private const Int32 ID_CMD = 0xEC; private const Int32 IDENTIFY_BUFFER_SIZE = 512; private const Int32 CAP_SMART_CMD = 0x4; private const Int32 IOCTL_STORAGE_QUERY_PROPERTY = 0x2D1400; private const Int32 PropertyStandardQuery = 0; private const Int32 StorageDeviceProperty = 0; public static string GetSerialNumber(int diskNumber) { string str = GetSerialNumberUsingStorageQuery(diskNumber); if (string.IsNullOrEmpty(str)) str = GetSerialNumberUsingSmart(diskNumber); return str; } public static string GetSerialNumberUsingStorageQuery(int diskNumber) { using (SafeFileHandle hDisk = OpenDisk(diskNumber)) { uint iBytesReturned = 0; var spq = new STORAGE_PROPERTY_QUERY(); var sdd = new STORAGE_DEVICE_DESCRIPTOR(); spq.PropertyId = StorageDeviceProperty; spq.QueryType = PropertyStandardQuery; if (DeviceIoControl(hDisk, IOCTL_STORAGE_QUERY_PROPERTY, spq, (uint)Marshal.SizeOf(spq), sdd, (uint)Marshal.SizeOf(sdd), ref iBytesReturned, IntPtr.Zero)) throw CreateWin32Exception(Marshal.GetLastWin32Error(), "DeviceIoControl(IOCTL_STORAGE_QUERY_PROPERTY)"); var result = new StringBuilder(); if (sdd.SerialNumberOffset > 0) { var rawDevicePropertiesOffset = Marshal.SizeOf(sdd) - sdd.RawDeviceProperties.Length; int pos = sdd.SerialNumberOffset - rawDevicePropertiesOffset; while (pos 0; } } }
