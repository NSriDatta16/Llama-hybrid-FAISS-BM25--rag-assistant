[site]: stackoverflow
[post_id]: 4831681
[parent_id]: 4825150
[tags]: 
Leaving aside issues of design for a moment. If you need a workaround then you can bind an identifier to a matched case class or case object and use the bound identifier to access members of the matched entity. The bound identifier can be used in guard statements in the match or in the action provided for the match: case class Bob(x: String, y: String) {val z = "Bragging"} val bob1 = Bob("Big", "Bad") bob1 match { case b @ Bob(x, y) if b.z == "Bragging" => println("Got "+x+", "+y+", "+b.z+" Bob!") case _ => } case object Bob {val z = "Balding"} val bob2 = Bob bob2 match { case b @ Bob if b.z == "Balding" => println("Got "+b.z+" Bob!") case _ => } Returning to design, in your case class definition you declare 'name' in the constructor body of B but you would get more useability from having 'name' as a parameter: case class B(i: Int, name: String) extends A Which could then match like this: def getType(s:String) = s match { case B(_, name) => println ("Object B("+name+")") ... Finally it's hard to say without further detail but I suspect that mapping case classes to a large set of similar entities on a one to one basis is perhaps not the best choice, better to use case objects, or instances of a limited number of case classes or even tuples.
