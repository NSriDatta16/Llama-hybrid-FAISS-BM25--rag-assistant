[site]: stackoverflow
[post_id]: 4466150
[parent_id]: 62512
[tags]: 
Below is a straightforward way to create 3D arrays using C or C++ in one chunk of memory for each array. No need to use BOOST (even if it's nice), or to split allocation between lines with multiple indirection (this is quite bad as it usually gives big performance penalty when accessing data and it fragments memory). The only thing to understand is that there is no such thing as multidimensional arrays, just arrays of arrays (of arrays). The innermost index being the farthest in memory. #include #include int main(){ { // C Style Static 3D Arrays int a[10][20][30]; a[9][19][29] = 10; printf("a[9][19][29]=%d\n", a[9][19][29]); } { // C Style dynamic 3D Arrays int (*a)[20][30]; a = (int (*)[20][30])malloc(10*20*30*sizeof(int)); a[9][19][29] = 10; printf("a[9][19][29]=%d\n", a[9][19][29]); free(a); } { // C++ Style dynamic 3D Arrays int (*a)[20][30]; a = new int[10][20][30]; a[9][19][29] = 10; printf("a[9][19][29]=%d\n", a[9][19][29]); delete [] a; } } For your actual problem, as there potentially is two unknown dimensions, there is a problem with my proposal at it allow only one unknown dimension. There is several ways to manage that. The good news is that using variables now works with C, it is called variable length arrays. You look here for details. int x = 100; int y = 200; int z = 30; { // C Style Static 3D Arrays int a[x][y][z]; a[99][199][29] = 10; printf("a[99][199][29]=%d\n", a[99][199][29]); } { // C Style dynamic 3D Arrays int (*a)[y][z]; a = (int (*)[y][z])malloc(x*y*z*sizeof(int)); a[99][199][29] = 10; printf("a[99][199][29]=%d\n", a[99][199][29]); free(a); } If using C++ the simplest way is probably to use operator overloading to stick with array syntax: { class ThreeDArray { class InnerTwoDArray { int * data; size_t y; size_t z; public: InnerTwoDArray(int * data, size_t y, size_t z) : data(data), y(y), z(z) {} public: int * operator [](size_t y){ return data + y*z; } }; int * data; size_t x; size_t y; size_t z; public: ThreeDArray(size_t x, size_t y, size_t z) : x(x), y(y), z(z) { data = (int*)malloc(x*y*z*sizeof data); } ~ThreeDArray(){ free(data); } InnerTwoDArray operator [](size_t x){ return InnerTwoDArray(data + x*y*z, y, z); } }; ThreeDArray a(x, y, z); a[99][199][29] = 10; printf("a[99][199][29]=%d\n", a[99][199][29]); } The above code has some indirection cost for accessing InnerTwoDArray (but a good compiler can probably optimize it away) but uses only one memory chunk for array allocated on heap. Which is usually the most efficient choice. Obviously even if the above code is still simple and straightforward, STL or BOOST does it well, hence no need to reinvent the wheel. I still believe it is interesting to know it can be easily done.
