[site]: stackoverflow
[post_id]: 5300535
[parent_id]: 
[tags]: 
JPA manytomany unidirectional mapping

I have two classes: ExternalTask and ExternalSource. ExternalTask has a List of ExternalSource and manytomany unidirectional relationship from ExternalTask to ExternalSource. When I want to remove a ExternalSource I check to see if it is referenced by any ExternalTask. If so, I check if this ExternalTask has only this externalsource in its List. Ä°f it is I remove ExternalTask completely; otherwise, I remove this externalsource from the list and merge externaltask. Then I remove externalsource. However, this is giving a constraint violation. I tried using jointable with no cascade, cascadetype.update, and cascadetype.refresh, but it is still not working. Any help? This is the remove method: public class Foo{ public boolean deleteExternalDataStorage(Long sid) { EntityManager em = getEntityManager(); EntityTransaction et = em.getTransaction(); try { et.begin(); ExternalDataStorage s = em.find(ExternalDataStorage.class, sid); List tasks=(List ) em.createQuery("SELECT t FROM ExternalTask t ").getResultList(); for(ExternalTask t:tasks) { if(t.getExternalSources().contains(s)){ t.getExternalSources().remove(s); if(t.getExternalSources().isEmpty()){ em.remove(t); }else{ em.merge(t); } } } em.remove(s); et.commit(); return true; } catch (Exception e) { e.printStackTrace(); } finally { if (et.isActive()) { et.rollback(); } } return false; } } @Entity public class ExternalTask { @ManyToMany @JoinTable(name = "ExternalTask_ExternalSource", joinColumns = @JoinColumn(name = "TID"), inverseJoinColumns = @JoinColumn(name = "EXID")) private List externalSources=new ArrayList (); @ManyToMany @JoinTable(name = "ExternalTask_Archive", joinColumns = @JoinColumn(name = "TID"), inverseJoinColumns = @JoinColumn(name = "AID")) protected List archives=new ArrayList (); @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "TID") protected Long id; @NotNull @Column(name = "name") protected String name; @Column(name = "description") protected String description; @Column(name="timeinterval" ) protected String interval; @Column(name="startdate") @Temporal(javax.persistence.TemporalType.TIMESTAMP) protected Date startDate; ... } @Entity @Table(name = "ExternalSource") public class ExternalDataStorage implements Serializable { private static final long serialVersionUID = 3926424342696569894L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "EXID") private Long id; @NotNull @Column(name = "NAME") private String name; @Column(name = "DESCRIPTION") private String description; @NotNull @Column(name = "USERNAME") private String username; @Column(name = "PATH") private String path; @Column(name = "PORT") private int port = 22; @NotNull @Column(name = "ISSECURE") private boolean isSecure=true; @NotNull @Column(name = "ISINDEXINGENABLED") private boolean indexingEnabled; @Column(name = "INDEXINGREGEXP") private String indexingRegExp = "({time}\\d{8}-\\d{6})"; @NotNull @Column(name = "IP") private String ip; @Column private String password; @Column private String protocol; @Transient private String publicKey; @Column(name = "RSA_PRIV_KEY", length = 4096) private String privateKey; @Transient private String regExpTestStr=""; @Transient private boolean testSucced; @Transient private InputAddress inputAddr; @Column private boolean authenticationType; @Column private boolean timeStampingEnable=true; @Column private String sshPath; @Column private String filename="(.*\\.log)"; public ExternalDataStorage() { inputAddr=new InputAddress(); } ... }
