[site]: stackoverflow
[post_id]: 1255347
[parent_id]: 
[tags]: 
Why does it take so long to get an empty resultset in linqtosql?

I'm running the following query on my database, which generates a sql query I know returns 0 results and when run in sql management studio takes less than a second to return. var query = (from item in db.Table where item.Field == FieldValue // Field is not the primary key but is indexed from other in item.Associated_Table select other.Table); List result = query.ToList(); The Associated_Table is a join table that relates items in Table to other items in Table. The resulting query looks something like this: declare @p0 as int SELECT [t2].[ItemCategoryID], [t2].[InventoryItemID], [t2].[SiteID], [t2].[ItemDescription], [t2].[AverageMonthlyUsage], [t2].[ReorderLevel], [t2].[ReorderQuantity], [t2].[OtherItemDetails], [t2].[Price] AS [IntPrice], [t2].[Ordinal], [t2].[IsBase] AS [IntIsBase], [t2].[Units], [t2].[ProfitCenterID] AS [IntProfitCenterID], [t2].[AccountID], [t2].[PLU] AS [IntPLU], [t2].[BarCode], [t2].[DisplayName], [t2].[ExtraServiceAmount] AS [IntExtraServiceAmount], [t2].[IsSearchable], [t2].[Terminated], [t2].[PdxServiceKey], [t2].[IsOpenPrice], [t2].[ItemPromotionCategoryID] FROM [dbo].[Inventory.Item] AS [t0] CROSS JOIN [dbo].[Inventory.ItemExtraAssignment] AS [t1] INNER JOIN [dbo].[Inventory.Item] AS [t2] ON [t2].[InventoryItemID] = [t1].[ExtraInventoryItemID] WHERE ([t0].[PLU] = @p0) AND ([t1].[InventoryItemID] = [t0].[InventoryItemID]) In management studio this query runs in under a second and returns 0 results. Why does it take 2 seconds to execute the 2 lines of c# that run this same query? I realize that it will take some overhead for LinqToSql parse the objects but since no objects are being returned it shouldn't have any work to do. Is there some optimization I'm missing; or maybe Some setting in the dbml or SQL server itself that needs to be changed?
