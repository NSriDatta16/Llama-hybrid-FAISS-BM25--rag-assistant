[site]: stackoverflow
[post_id]: 5715823
[parent_id]: 5701551
[tags]: 
You are on the right track, in my opinion. PostScript is a programming language, so for general purposes you must use a PostScript interpreter to process it. Simply parsing the file, or any other similar approach, won't work in the general case (though it might for a simple file). The original object you have quoted appears likely to be a glyph description in a font, probably a type 3 font, probably produced by Fontographer, but that's just guessing. Note that's a glyph not a font, a font is a collection of glyphs. If I were doing this I would start by redefining the various PostScript operators. For example, if you redefine 'show' you can pick up the text as it is drawn (actually there are several kinds of show operator, you need to redefine them all). At the same time you can pick the font dictionary up, and you can arrange to output it to the file. For example you might start with: %!PS % redefine.ps % /OutputFile (/out.txt) (w) file def /show { OutputFile exch writestring } bind def Then run this command: gswin32 redefine.ps input.ps It will run redefine.ps which redefines the operators, then it will interpret input.ps . The redefined 'show' operator will write the string arguments to any 'show' operations to a file called /out.txt . Obviously you can extend this to the other show operators. You can also take copies of the font dictionaries and then emit them as required. There's a bit of programming involved but here's an outline: %!PS % /OutputFile (/out.txt) (w) file def %% FontStore will be an array of font dictionaries /FontStore 1 array def /CheckFont { currentfont /FontName get %% Extract the name of the current font from the %% font dictionary true %% termination condition FontStore { %% forall is called for each member of the array /FontName get %% get font name from stored font dictionary 2 index %% copy the current font name from the stack eq %% See if they are the same { pop %% remove the 'false' condition false %% replace it with a 'true' exit %% and exit the loop } if } forall exch pop %% remove stored font name { %% make the array one bigger, copy the old array, add the current font dict. } if } def /show { CheckFont OutputFile exch writestring } bind def /showpage { %% Emit the fonts if required, potentially reorder the stored strings etc. } bind def Now whenever we execute a 'show', we will check to see if the current font is already stored, and store it if not. At the end of the page (when showpage is executed) we can do other things, like emitting the stored font dictionaries as fonts and so on. One thing you will probably want to do is record the positions of the strings as they arrive at 'show', the currentpoint operator will give you the x.y position at the time show occurs. Instead of writing these to a file you may decide to store the string and its position in an array. In fact you might construct a dictionary with useful information: /show { 5 dict %% make a dictionary begin %% start it (put it on the dict stack as the current dict) /String exch def %% put the string operand in the dict. currentpoint %% get the current location /Y exch def %% store in the dict /X exch def %% currentfont %% get current font dict /FontName get %% get FontName /Font exch def %% store name in dict currentfont %% copy current dict to operand stack end %% close dictionary and remove from dict stack %% %% In here, add the newly created dictionary to an array of dictionaries %% } bind def Now when you get to 'showpage', you have an array of fonts, and an array of string fragments with their properties. You can emit the fonts, then write out appropriate font selection criteria and strings to 'show' the strings in your output PostScript file. There is much more you can do, you can capture the colour, you will need the CTM so you can calculate the font point size you need and so on.
