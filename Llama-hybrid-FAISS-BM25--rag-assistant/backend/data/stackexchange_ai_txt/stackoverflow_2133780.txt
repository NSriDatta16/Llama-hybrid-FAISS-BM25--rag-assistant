[site]: stackoverflow
[post_id]: 2133780
[parent_id]: 2133566
[tags]: 
Not sure why you're getting a circular dependency. Are you sure you have declared the relationhips with the correct cardinaility? Your tables ... SQL> create table members 2 ( name varchar2(10) 3 , id number not null primary key ) 4 / Table created. SQL> create table events 2 ( id number not null primary key 3 , datetime date 4 , topic varchar2(10) 5 , organizerid number not null ) 6 / Table created. SQL> create table eventregistrations 2 ( memberid number not null 3 , eventid number not null) 4 / Table created. SQL> A member can organise any number of events. An event must have a single organiser. SQL> alter table events 2 add constraint evt_mbr_fk foreign key ( organizerid ) 3 references members (id) on delete cascade 4 / Table altered. SQL> A member can register for any number of events ... SQL> alter table eventregistrations 2 add constraint reg_mbr_fk foreign key ( memberid ) 3 references members (id) on delete cascade 4 / Table altered. SQL> An event can have any number of registered members ... SQL> alter table eventregistrations 2 add constraint reg_evt_fk foreign key ( eventid ) 3 references events (id) on delete cascade 4 / Table altered. SQL> Note: I haven't bothered implementing the rule "a member can only resister once for any given event", because it is not relevant (but it would be a compound primary key on eventregistrations. edit I share the others' concerns about the use of ON CASCADE DELETE but I think it is not strictly relevant to the question. Forcing a change of organizerId for an event is a business rule. In some scenarios ON DELETE CASACDE is appropriate and in some it is not. edit 2 This is an indication that the flavour of database does make a difference after all. Oracle is quite happy to cascade a delete of MEMBERS through to EVENTS and EVENTREGISTRATIONS without complaint.
