[site]: stackoverflow
[post_id]: 4400618
[parent_id]: 4400072
[tags]: 
A general-purpose solution with LINQ can be achieved quite easily. The idea is: Sort the two strings (reordering the characters). Compare each sorted string as a character sequence using SequenceEquals . This scheme enables a short, graceful and configurable solution, for example: // We will be using this in SequenceEquals class MyComparer : IEqualityComparer { public bool Equals(char x, char y) { return x.Equals(y); } public int GetHashCode(char obj) { return obj.GetHashCode(); } } // and then: var s1 = "ABC0102"; var s2 = "AC201B0"; Func orderFunction = char.GetNumericValue; var comparer = new MyComparer(); var result = s1.OrderBy(orderFunction).SequenceEqual(s2.OrderBy(orderFunction), comparer); Console.WriteLine("result = " + result); As you can see, it's all in 3 lines of code (not counting the comparer class). It's also very very easily configurable. The code as it stands checks if s1 is a permutation of s2 . Do you want to check if s1 has the same number and kind of characters with s2 , but not necessarily the same characters (e.g. "ABC" to be equal to "ABB")? No problem, change MyComparer.Equals to return char.GetUnicodeCategory(x).Equals(char.GetUnicodeCategory(y)); . By changing the values of orderFunction and comparer you can configure a multitude of other comparison options. And finally, since I don't find it very elegant to define a MyComparer class just to enable this scenario, you can also use the technique described in this question: Wrap a delegate in an IEqualityComparer to define your comparer as an inline lambda. This would result in a configurable solution contained in 2-3 lines of code.
