[site]: stackoverflow
[post_id]: 1870781
[parent_id]: 1870557
[tags]: 
There's a lot of text in response to this question that follows the literature very closely, and (with no offense to the posters of those answers) it makes me wonder if people simply haven't reworked a system of any significant scale that is really and truly Fucked Up. I've rewritten three significant applications in my career (Significant: 50kish LOC or larger, data tier, logic tier, integration requirements). Every system has required me to say To Hell With This at some point to good practice. You know what I learned from doing that? At a certain point, it can be really, really safe. Absolutely, you need to consider what it means to throw caution to the wind, but it is significantly more important that you ship than that you follow someone else's idea of good practice. Let me illustrate with an example of what I'm talking about: I'm working on a system today that was written over six years that was originally converted to a .NET language from an application that was at the time perhaps a decade old, and was written with a DOS client that held all of the logic. The original code and most of the subsequent updates and conversions were handled by inexperienced programmers. This is a document management engine for all intents and purposes, and there isn't a single abstraction for "document" anywhere in the code. I was asked to implement a means to transfer files across a WAN such that it would function with the core routines of the system. I started out creating a nice little test client and server with decent practices wrapped around them, tests etc. I went through the core system architecture and looked for the right place to re-stub my code. All I found was big nasty chunk after big nasty chunk of copy and pasted code with tiny modifications that constituted units. I started changing little bits of code, things started breaking, I reset my changes. I extracted methods and found that variables were scattered throughout the code and relied on changes made throughout the procedure. I tried extracting classes, only to find that I was extracting methods wholesale and that the state data from the old class was, once again, scattered throughout the code, and not amenable to transition. So I said THWI. Two weeks later we had a nice little zipping client and server and our core code was much more nicely factored for our trouble. If you know a system, if you pay attention, if you test your code, and if you PAY ATTENTION, there's often nothing wrong with making big changes in an unsafe way. I'm gonna get downvotes for this, but Agile practices have clouded people's vision too much, and it's really time for quotes from the literature to stop dominating these discussions. If you work with a system every day, you know the system, and no amount of unit testing is going to equal what you can make happen if you take charge and fix the damn system. Of course, this is why you need to work with a system and learn the system instead of just going from technology to technology. Rewriting to a new language is not nearly as good an answer as rebuilding with an eye to improving the design. If you then find there are limitations in the system that you could overcome with a new technology, it becomes substantially simpler to make that change at that point.
