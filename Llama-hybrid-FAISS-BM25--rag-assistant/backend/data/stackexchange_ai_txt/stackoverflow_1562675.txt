[site]: stackoverflow
[post_id]: 1562675
[parent_id]: 294890
[tags]: 
I have come across this same issue in a recent project. First, to restate the problem, I am trying to follow the domain-centric approach of DDD. I have entities composed into aggregates that can validate themselves, and the repositories verify validity on save. The UI can also get validity information from an aggregate in order to display error feedback to the client. The general approach is to leverage as much as possible ASP.NET MVC's model binding, and validation/form UI helpers. This creates the simple UI flow: 1) bind, 2) validate, 3) if valid, save, else re-populate view. However, it is not directly obvious how to do leverage ASP.NET MVC and this simple flow when DDD services are involved. Originally, I developed my services as such: public class SomeProcessService { public Result Execute(int anAggregateID, int anotherAggregateID, string someData) { // validate input // if invalid, return failures // else // modify aggregates // using (transaction) // { // save aggregates // commit // } // return success } } The problem is that the validation and the save are inextricably linked in the method. To leverage the MVC model binding, we need something that serves as a model to bind to. I am refactoring to this: public class SomeProcessService { public class Request : IValidateable { public int AggregateID {get;set;} public int AnotherAggregateID {get;set;} public string SomeData {get;set;} public Result Validate() { // validation } } public void Execute(Request request) { // validate input by calling request.Validate() // if invalid, throw new ValidationException(request) // else // modify aggregates // using (transaction) // { // save aggregates // commit // } // return success } } This repurposes the Parameter Object pattern to separate method input validation. I can bind to a SomeProcessService.Request object in my controller, as well as get validation information there. If all is well, from my controller I initiate the service call using the Request object as the parameter. This approach seems to happily marry DDD services with ASP.NET MVC validation requirements.
