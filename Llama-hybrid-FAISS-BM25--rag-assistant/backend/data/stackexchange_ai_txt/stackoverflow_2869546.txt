[site]: stackoverflow
[post_id]: 2869546
[parent_id]: 2793171
[tags]: 
One way of thinking of unit tests is as coded specifications. When you use the EntityGenerator to produce instances both for the Test and for the actual service, your test can be seen to express the requirement The Service uses the EntityGenerator to produce Product instances. This is what your test verifies. It's underspecified because it doesn't mention if modifications are allowed or not. If we say The Service uses the EntityGenerator to produce Product instances, which cannot be modified. Then we get a hint as to the test changes needed to capture the error: var product = EntityGenerator.Product(); // [ Change ] var originalOwner = product.Owner; // assuming owner is an immutable value object, like String // [...] - record other properties as well. Product returnedProduct = _productService.GetProduct(product.Id); Assert.AreEqual(product, returnedProduct); // [ Change ] verify the product is equivalent to the original spec Assert.AreEqual(originalOwner, returnedProduct.Owner); // [...] - test other properties as well (The change is that we retrieve the owner from the freshly created Product and check the owner from the Product returned from the service.) This embodies the fact that the Owner and other product properties must equal the the original value from the generator. This may seem like I'm stating the obvious, since the code is pretty trivial, but it runs quite deep if you think in terms of requirement specifications. I often "test my tests" by stipulating "if I change this line of code, tweak a critical constant or two, or inject a few code burps (e.g. changing != to ==), which test will capture the error?" Doing it for real finds if there is a test that captures the problem. Sometimes not, in which case it's time to look at the requirements implicit in the tests, and see how we can tighten them up. In projects with no real requirements capture/analysis this can be a useful tool to toughen up tests so they fail when unexpected changes occur. Of course, you have to be pragmatic. You can't reasonably expect to handle all changes - some will simply be absurd and the program will crash. But logical changes like the Owner change are good candidates for test strengthening. By dragging talk of requirements into a simple coding fix, some may think I've gone off the deep end, but thorough requirements help produce thorough tests, and if you have no requirements, then you need to work doubly hard to make sure your tests are thorough, since you're implicitly doing requirements capture as you write the tests. EDIT: I'm answering this from within the contraints set in the question. Given a free choice, I would suggest not using the EntityGenerator to create Product test instances, and instead create them "by hand" and use an equality comparison. Or more direct, compare the fields of the returned Product to specific (hard-coded) values in the test, again, without using the EntityGenerator in the test.
