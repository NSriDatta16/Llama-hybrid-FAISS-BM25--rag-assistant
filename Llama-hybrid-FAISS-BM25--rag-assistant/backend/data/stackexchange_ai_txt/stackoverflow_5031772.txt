[site]: stackoverflow
[post_id]: 5031772
[parent_id]: 5025669
[tags]: 
Unfortunately, Java doesn't allow this: interface Transforming X transform(Transformer transformer); interface Container extends Transforming Even if it did, it's not general enough; we want a function mapping T to another type containing T interface Transforming f(T) transform(Transformer transformer); interface Container extends Transforming Container } > But enough of fantasies. The best you can do, is to be very vague on return type: interface Transforming X transform(Transformer transformer); interface Container extends Transforming Note, we are unable to express any constraint between X and T. Now your sample code compiles, without any warning!! There is a type inference based on the assignment, and X is infered to be Container . On one hand, the type safety of this inference entirely depends on programmer supplying the correct target type. If he had put Container on the left hand, it will compile too without warning. On the other hand, if Java does not do such inference, then we must return Object instead of X , and do manual cast on return object; the safety of the manual cast of course also depends entirely on programmer supplying correct target type. Some people therefore argue, why are we punishing ourselves? If I assign A to B, of course A is a B, don't force me to write it out, infer it! Nonetheless, such inference may give false sense of security to casual observers. There is a manual cast, in spirit, but not in writting. Personally I'm quite concerned with this inference rule. It is against the very point of static typing, that is, we want to write down all the types explicitly.
