[site]: stackoverflow
[post_id]: 2784567
[parent_id]: 2783519
[tags]: 
You should only make a call to runOnUiThread from a background thread. I think you have the logic backwards. You should set it up so startAnimation and stopAnimation don't make any calls to runOnUiThread, just use the code as is. Then startAnimation should be called from the main UI thread and stopAnimation can be called by the background thread with runOnUiThread. Here's some sample code: public void onClick(View v) { // this is the main thread // ...... LoadingAnimation.startAnimation(); // Don't need to call this with runOnUiThread since we're on teh main thread thread.run(); } @Override public void run() { runOnUiThread(new Runnable() { // Need to put this in runOnUiThread since it's changing the UI from the background if (type == BOOK) { ((BookView) bookView).setBookToDisplay(book); } else if (type == CHAPTER) { ((BookView) bookView).setBookToDisplay(chapter.getBook()); ((BookView) bookView).setExpanededChapter(chapter, true); } else if (type == PARAGRAPH) { ((BookView) bookView).setBookToDisplay(paragraph.getParentChapter().getBook()); ((BookView) bookView).setExpanededChapter(paragraph.getParentChapter(), false); ((BookView) bookView).setExpandedParagraph(paragraph); } LoadingAnimation.stopAnimation(); }); } public static void startAnimation() { loadingImage.setImageResource(R.drawable.loading_background); animation.start(); Log.v("Animation", "Loading Animation started"); } public static void stopAnimation() { loadingImage.setImageResource(R.drawable.loading0); animation.stop(); Log.v("Animation", "Loading Animation stopped"); }
