[site]: stackoverflow
[post_id]: 5145932
[parent_id]: 5145074
[tags]: 
Cast is deferred and does not cause immediate execution. This is because it does not (itself) enumerate the source. Only when something is enumerated, is the query run. Upcasting is no problem. The query will work fine. Recall - the query works on database rows and not on instances. Instances are only created when the rows arrive locally. All that this call to cast does is to change the reference type used in the result - it doesn't change the type of instance new'd up. class SpecificObject : DomainObject MyDataContext myDC = new MyDataContext(); IQueryable query = myDC.SpecificObjects.Cast (); Console.WriteLine(myDC.GetCommand(query).CommandText); But - that's not really useful - as the properties on the row were on the original type and now you can't refer to those properties in the rest of the query. Downcasting doesn't really do much. LinqToSql presumes that the each row is of type T from the Table . Not some TChild. This will generate a query selecting null for each row from the table. class SpecificObject : DomainObject MyDataContext myDC = new MyDataContext(); IQueryable query = myDC.DomainObjects.Cast (); Console.WriteLine(myDC.GetCommand(query).CommandText); Implicit conversion... one should be very careful with that. Even LinqToObject's Enumerable.Cast doesn't respect implicit conversion operations (see here and here ). Of course, that doesn't have anything to do with LinqToSql - but the principle matters - .net casting is not the same as c# implicit conversion and whatever sql thing. You must bear in mind the execution environment of the code you're writing.
