[site]: stackoverflow
[post_id]: 1741207
[parent_id]: 1739890
[tags]: 
The need to use deferrable constraints is often a pointer to design problems. Certainly this data model is not a good one: it is not properly normalised. A normalised solution would look like this: PERSON ------ ID number NAME varchar2(30) PRIMARY KEY (ID) MARRIED_COUPLE -------------- PARTNER_1 number PARTNER_2 number PRIMARY KEY (PARTNER_1, PARTNER_2) FOREIGN KEY (PARTNER_1) REFERENCES (PERSON.ID) FOREIGN KEY (PARTNER_2) REFERENCES (PERSON.ID) This has the added advantage of supporting civil partnerships :) If you want to discourage bigamy then you could put unique keys on PARTNER_1 or PARTNER_2. It is trickier to model cultures where polygyny or polyandry is permitted. edit What David is objecting to (in the comments) is this: SQL> create table married_couple (partner_1 number, partner_2 number) 2 / Table created. SQL> alter table married_couple add primary key (partner_1, partner_2) 2 / Table altered. SQL> insert into married_couple values (1, 2) 2 / 1 row created. SQL> insert into married_couple values (2,1) 2 / 1 row created. SQL> It's a valid point but it is resolvable. For instance, with Oracle I can create a unique function-based to enforce uniqueness of permutations. SQL> delete from married_couple 2 / 2 rows deleted. SQL> create unique index mc_uidx on married_couple 2 (greatest(partner_1, partner_2),least(partner_1, partner_2)) 3 / Index created. SQL> insert into married_couple values (1, 2) 2 / 1 row created. SQL> insert into married_couple values (2,1) 2 / insert into married_couple values (2,1) * ERROR at line 1: ORA-00001: unique constraint (APC.MC_UIDX) violated SQL> To avoid polygamy we can use a similar trick. We don't want this: SQL> insert into married_couple values (1,3) 2 / 1 row created. So, we need two indexes: SQL> delete from married_couple where partner_2 = 3; 1 row deleted. SQL> create unique index mc1_uidx 2 on married_couple (greatest(partner_1, partner_2)) 3 / Index created. SQL> create unique index mc2_uidx 2 on married_couple (least(partner_1, partner_2)) 3 / Index created. SQL> insert into married_couple values (3, 1) 2 / insert into married_couple values (3, 1) * ERROR at line 1: ORA-00001: unique constraint (APC.MC2_UIDX) violated SQL> To those who think it's cheating to solve a data modelling issue with an implementation trick, I plead "Guilty as charged" but I have had a long and trying day of it.
