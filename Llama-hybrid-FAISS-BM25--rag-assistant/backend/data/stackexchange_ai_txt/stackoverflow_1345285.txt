[site]: stackoverflow
[post_id]: 1345285
[parent_id]: 1345109
[tags]: 
Your proposed alternative wouldn't force the entire structure to be aligned on an 8-byte (64-bit) boundary, which you mention as a requirement from RFC2553. In general, a structure takes on the strictest alignment required by any of its members. Since sa_family_t is probably a u16_t , which requires only 2-byte alignment, and an array of char requires at most 1-byte alignment, the alternative you propose would require only 2-byte alignment. (It's likely that the compiler would give it at least 4- and maybe 8-byte alignment anyway, but you can't be sure.) The style of the actual definition is an attempt to make sure that every byte in the structure is part of some named field, ie, that the the compiler does not insert any padding between fields. This is needed (sort of) so that _SS_PAD2SIZE has a value that can be computed in terms of the sizes of all other members. However, I find this definition rather complicated. I'm pretty sure the following works just as well, and is quite a bit easier to understand: struct sockaddr_storage { union { sa_family_t u_family; uint64_t u_pad[_SS_MAXSIZE / sizeof(uint64_t)]; } __ss_u; # define __ss_family __ss_u.u_family }; Here, the union acquires the alignment requirements of its most strictly aligned member, which then propagates to the enclosing struct. Note that in this version I only have the one required field (although buried in a union) and a single padding array that is the exact size I want the entire struct to be. The only slightly tricky part is the macro definition of __ss_family . It's possible that the macro trick is not strictly compliant with the requirements in the RFC, but there will be few (if any) ways to notice the difference.
