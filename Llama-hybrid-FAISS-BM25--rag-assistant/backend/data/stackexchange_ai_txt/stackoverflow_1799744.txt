[site]: stackoverflow
[post_id]: 1799744
[parent_id]: 1799733
[tags]: 
No. But you can make myfunction a functor, pass it a pointer to some memory, and store your return value through that pointer. struct MyFunctor { int *count; MyFunctor(int *count_) : count(count_) { } void operator()(int n) { if (n > 5) (*count)++; } }; int main() { vector vec; for (int i=0; i Edit: As the comments have pointed out, my first example would've failed as for_each would have made a copy of MyFunctor , so we couldn't have retrieved the return value from our original object. I've fixed along the lines of the original approach; but you really should look at GMan's solution which is more elegant. I'm not sure about the portability, but it does work on my gcc (4.4.2). And as the others have mentioned, whenever possible, use what provides.
