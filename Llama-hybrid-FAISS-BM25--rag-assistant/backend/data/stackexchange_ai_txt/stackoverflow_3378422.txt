[site]: stackoverflow
[post_id]: 3378422
[parent_id]: 2617266
[tags]: 
I've written a class that extends TextView and does this. It just uses measureText as you suggest. Basically it has a maximum text size and minimum text size (which can be changed) and it just runs through the sizes between them in decrements of 1 until it finds the biggest one that will fit. Not particularly elegant, but I don't know of any other way. Here is the code: import android.content.Context; import android.graphics.Paint; import android.util.AttributeSet; import android.widget.TextView; public class FontFitTextView extends TextView { public FontFitTextView(Context context) { super(context); initialise(); } public FontFitTextView(Context context, AttributeSet attrs) { super(context, attrs); initialise(); } private void initialise() { testPaint = new Paint(); testPaint.set(this.getPaint()); //max size defaults to the intially specified text size unless it is too small maxTextSize = this.getTextSize(); if (maxTextSize 0) { int availableWidth = textWidth - this.getPaddingLeft() - this.getPaddingRight(); float trySize = maxTextSize; testPaint.setTextSize(trySize); while ((trySize > minTextSize) && (testPaint.measureText(text) > availableWidth)) { trySize -= 1; if (trySize
