[site]: stackoverflow
[post_id]: 5281023
[parent_id]: 3217470
[tags]: 
Magic GUID provided by Mozilla if (pAccChild) { CComQIPtr provider = pAccChild; if( provider ){ const GUID refguid = {0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8}; CComPtr node; provider->QueryService(refguid, IID_ISimpleDOMNode, (void**)&node); CComQIPtr ffdocument = node; if (node) { ffdocument->get_URL(&DOM_string); if (DOM_string != 0) { addressbar = (const wchar_t *)_bstr_t(DOM_string, FALSE); } } Now, between AccessibleObjectFromWindow and getting the provider, you may need to move around the accessible heirarchy, that can be a bit messy. Have a look at this Code Project - XMSAALib for suggestions. Here is an example of some of the tree walking covering various issues. Modified from the original to use ATL smart pointers and some bug fixes (or introduced ;) ) //----------------------------------------------------------------------------- bool CXMSAALib::EnumAccessible(IAccessible *pIAccParent, IAccessibleEnumProc& lpEnumAccessibleProc ) { _ASSERTE(pIAccParent); // 2 ways to go through the children // * some parents will support the Enum(erator) interface where child ids may not be a contiguous sequence, and children may be returned as id or IAccessible directly // * others support the accChild function only where the count and ids should be contiguous. CComQIPtr pEnum = pIAccParent; if( pEnum ) pEnum->Reset(); // get child count long nChildren = 0; if( FAILED( pIAccParent->get_accChildCount(&nChildren) ) ) nChildren = 0; //TRACE(_T("nChildren=%d\n"), nChildren); bool bContinue = true; // skip 0 (self) for (long index = 1; (index Next(1, &varChildRef, &nFetched); //children may be returned as lVal id or IAccessible directly if (!SUCCEEDED(hr) || !nFetched ) { bContinue = false; break; } } else { varChildRef.vt = VT_I4; varChildRef.lVal = index; } // IAccessible doesn't always allow indirect access to children that are also of type IAccessible // change the focus to the child element if we can VARIANT varChild; VariantInit(&varChild); CComPtr pIAccChild; FocusOnChild( pIAccParent, varChildRef, pIAccChild, varChild ); bContinue = lpEnumAccessibleProc(pIAccChild, varChild); if ( bContinue && pIAccChild && CHILDID_SELF == varChild.lVal ) { bContinue = EnumAccessible(pIAccChild, lpEnumAccessibleProc); } VariantClear(&varChild); } return bContinue; } //----------------------------------------------------------------------------- bool CXMSAALib::EnumAccessible(HWND hwnd, IAccessibleEnumProc& lpEnumAccessibleProc) { if (::IsWindow(hwnd)) { CComPtr pIAccParent; HRESULT hr = AccessibleObjectFromWindow(hwnd, OBJID_CLIENT, IID_IAccessible, (void**)&pIAccParent); if (SUCCEEDED(hr) && pIAccParent) { VARIANT varChild; VariantInit(&varChild); varChild.vt = VT_I4; varChild.lVal = CHILDID_SELF; if( lpEnumAccessibleProc(pIAccParent, varChild) ) { EnumAccessible(pIAccParent, lpEnumAccessibleProc, nLevel+1); } VariantClear(&varChild); return true; } } return false; } //----------------------------------------------------------------------------- void CXMSAALib::FocusOnChild( IAccessible * pIAccParent, VARIANT &varChildRef, CComPtr &pIAccChild, VARIANT &varChild ) { // get IDispatch interface for the child CComPtr pDisp; if (varChildRef.vt == VT_I4) { pIAccParent->get_accChild(varChildRef, &pDisp); } else if (varChildRef.vt == VT_DISPATCH) { pDisp = varChildRef.pdispVal; } // get IAccessible interface for the child CComQIPtr pCAcc(pDisp); if (pCAcc && pCAcc != pIAccParent ) { VariantInit(&varChild); varChild.vt = VT_I4; varChild.lVal = CHILDID_SELF; pIAccChild = pCAcc; } else { pIAccChild = pIAccParent; varChild = varChildRef; } }
