[site]: stackoverflow
[post_id]: 4845717
[parent_id]: 4843237
[tags]: 
The Python example is elegantly short, but I suspect that you won't actually get enough control over your expressions that way. You're much better off actually building an expression tree, even though it takes more work, and then querying the tree. Here's an example in Scala (suitable for cutting and pasting into the REPL): object OpParser { private def estr(oe: Option[Expr]) = oe.map(_.toString).getOrElse("_") case class Expr(text: String, left: Option[Expr] = None, right: Option[Expr] = None) { import Expr._ def varsUsed: Set[String] = text match { case Variable(v) => Set(v) case Op(o) => left.map(_.varsUsed).getOrElse(Set()) ++ right.map(_.varsUsed).getOrElse(Set()) case _ => Set() } def printTemp(n: Int = 0, depth: Int = 0): (String,Int) = text match { case Op(o) => val (tl,nl) = left.map(_.printTemp(n,depth+1)).getOrElse(("_",n)) val (tr,nr) = right.map(_.printTemp(nl,depth+1)).getOrElse(("_",n)) val t = "t"+(nr+1) println(t + " = " + tl + " " + text + " " + tr) if (depth==0) println(t + " is the result") (t, nr+1) case _ => (text, n) } override def toString: String = { if (left.isDefined || right.isDefined) { "(" + estr(left) + " " + text + " " + estr(right) + ")" } else text } } object Expr { val Digit = "([0-9]+)"r val Variable = "([a-z])"r val Op = """([+\-*/^])"""r def parse(s: String) = { val bits = s.split(" ") val parsed = ( if (bits.length > 2 && Variable.unapplySeq(bits(0)).isDefined && bits(1)=="=") { parseParts(bits,2) } else parseParts(bits) ) parsed.flatMap(p => if (p._2 = as.length) None else as(from) match { case Digit(n) => Some(Expr(n), from+1) case Variable(v) => Some(Expr(v), from+1) case Op(o) => parseParts(as, from+1).flatMap(lhs => parseParts(as, lhs._2).map(rhs => (Expr(o,Some(lhs._1),Some(rhs._1)), rhs._2)) ) case _ => None } } } } This may be a little much to digest all at once, but then again, this does rather a lot. Firstly, it's completely bulletproof (note the heavy use of Option where a result might fail). If you throw garbage at it, it will just return None . (With a bit more work, you could make it complain about the problem in an informative way--basically the case Op(o) which then does parseParts nested twice could instead store the results and print out an informative error message if the op didn't get two arguments. Likewise, parse could complain about trailing values instead of just throwing back None .) Secondly, when you're done with it, you have a complete expression tree. Note that printTemp prints out the temporary variables you wanted, and varsUsed lists the variables used in a particular expression, which you can use to expand to a full list once you parse multiple lines. (You might need to fiddle with the regexp a little if your variables can be more than just a to z .) Note also that the expression tree prints itself out in normal infix notation. Let's look at some examples: scala> OpParser.Expr.parse("4") res0: Option[OpParser.Expr] = Some(4) scala> OpParser.Expr.parse("+ + + + + 1 2 3 4 5 6") res1: Option[OpParser.Expr] = Some((((((1 + 2) + 3) + 4) + 5) + 6)) scala> OpParser.Expr.parse("- + ^ x 2 ^ y 2 1") res2: Option[OpParser.Expr] = Some((((x ^ 2) + (y ^ 2)) - 1)) scala> OpParser.Expr.parse("+ + 4 4 4 4") // Too many 4s! res3: Option[OpParser.Expr] = None scala> OpParser.Expr.parse("Q#$S!M$#!*)000") // Garbage! res4: Option[OpParser.Expr] = None scala> OpParser.Expr.parse("z =") // Assigned nothing?! res5: Option[OpParser.Expr] = None scala> res2.foreach(_.printTemp()) t1 = x ^ 2 t2 = y ^ 2 t3 = t1 + t2 t4 = t3 - 1 t4 is the result scala> res2.map(_.varsUsed) res10: Option[Set[String]] = Some(Set(x, y)) Now, you could do this in Python also without too much additional work, and in a number of the other languages besides. I prefer to use Scala, but you may prefer otherwise. Regardless, I do recommend creating the full expression tree if you want to retain maximum flexibility for handling tricky cases.
