[site]: stackoverflow
[post_id]: 5124685
[parent_id]: 5124590
[tags]: 
As a particular concrete example, one option is a "nearest K neighbours" algorithm. To simplify things, imagine you only had ten books, and you were only tracking how many times each user viewed each book. Then, for each user, you might have an array int timesViewed[10] , where the value of timesViewed[i] is the number of times the user has viewed book number i . You can then compare the user to all of the other users using a correlation function, such as the Pearson correlation for example. Computing the correlation between the current user c and another user o gives a value between -1.0 and 1.0, where -1.0 means "this user c is the complete opposite of the other user o ", and 1.0 means "this user c is the same as the other user o ". If you compute the corellation between c and every other user, you get a list of results of how similar the user's viewing pattern is to that of each other user. You then pick the K (e.g. 5, 10, 20) most similar results (hence the name of the algorithm), that is, the K users with the correlation scores closest to 1.0. Now, you can do a weighted average of each of those user's timesViewed arrays. For example, we'll say averageTimesViewed[0] is the average of the timesViewed[0] for each of those K users, weighted by their correlation score. Then do the same for each other averageTimesViewed[i] . Now you have an array averageTimesViewed which contains, roughly speaking, the average number of times the K users with the most similar viewing patterns to c has viewed each book. Recommend the book which has the highest averageTimesViewed score, since this is the book the other users have shown most interest in. It's usually worth also excluding books the user has already viewed from being recommended, but it is still important to keep those accounted for when computing similarity/correlation. Also note that this can be trivially extended to take other data into account (such as cart lists etc). Also, you can select all users if you want (i.e. K = number of users), but that doesn't always produce meaningful results, and usually picking a reasonably small K is sufficient for good results, and is quicker to compute.
