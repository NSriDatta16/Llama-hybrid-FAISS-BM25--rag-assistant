[site]: stackoverflow
[post_id]: 4362701
[parent_id]: 4362657
[tags]: 
Use a backtracking system; whether it is by using a recursive method (not preferrable) or a stack to walk back the step. Ideally, you'd also set markers in every junction that your algorithm choose a way in, so you do not choose the same path again (choose only unmarked paths in a given junction) Wikipedia has some nice pseudocode on how to achieve this. Pay attention to the "Recursive backtracker" algorithm, replacing the "Choose randomly one of the unvisited neighbours" by "Choose left turn from one of the unvisited neighbours" (meaning choosing clock-wise from the left cell). Also, check out this e-book about recursivity. I'd go for something like (untested code) : maze.clearAllVisited(); Stack paths = new Stack (); int x = maze.getStartX(); int y = maze.getStartY(); while (!maze.isExit(x, y)) { maze.setVisited(x, y); if (maze.canGoWest(x, y)) { // check if west cell is accessible from x,y and has not been visited paths.push(new Point(x, y)); x--; } else if (maze.canGoNorth(x, y)) { // check if north cell is accessible from x,y and has not been visited paths.push(new Point(x, y)); y--; } else if (maze.canGoEast(x, y)) { // ... paths.push(new Point(x, y)); x++; } else if (maze.canGoSouth(x, y)) { // ... paths.push(new Point(x, y)); y++; } else { if (paths.isEmpty()) { break; // no more path for backtracking, exit (aka no solution for maze) } // dead end! go back! Point last = stack.pop(); x = last.x; y = last.y; } }
