[site]: stackoverflow
[post_id]: 2406101
[parent_id]: 2405461
[tags]: 
EDIT: Added detail for Grand Central Dispatch in response to OP comment. While the other answers here are useful in general, the specific answer to your question is that you shouldn't be using clock() to compare the timing. clock() measures CPU time which is added up across the threads. When you split a job between cores, it uses at least as much CPU time (usually a bit more due to threading overhead). Search for clock() on this page, to find "If process is multi-threaded, cpu time consumed by all individual threads of process are added." It's just that the job is split between threads, so the overall time you have to wait is less. You should be using the wall time (the time on a wall clock). OpenMP provides a routine omp_get_wtime() to do it. Take the following routine as an example: #include #include #include #include int main(int argc, char *argv[]) { int i, nthreads; clock_t clock_timer; double wall_timer; for (nthreads = 1; nthreads The results are: 1 threads: time on clock() = 0.258, on wall = 0.258 2 threads: time on clock() = 0.256, on wall = 0.129 3 threads: time on clock() = 0.255, on wall = 0.086 4 threads: time on clock() = 0.257, on wall = 0.065 5 threads: time on clock() = 0.255, on wall = 0.051 6 threads: time on clock() = 0.257, on wall = 0.044 7 threads: time on clock() = 0.255, on wall = 0.037 8 threads: time on clock() = 0.256, on wall = 0.033 You can see that the clock() time doesn't change much. I get 0.254 without the pragma , so it's a little slower using openMP with one thread than not using openMP at all, but the wall time decreases with each thread. The improvement won't always be this good due to, for example, parts of your calculation that aren't parallel (see Amdahl's_law ) or different threads fighting over the same memory. EDIT: For Grand Central Dispatch, the GCD reference states, that GCD uses gettimeofday for wall time. So, I create a new Cocoa App, and in applicationDidFinishLaunching I put: struct timeval t1,t2; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (int iterations = 1; iterations and I get the following results on the console: 2010-03-10 17:33:43.022 GCDClock[39741:a0f] 1 iterations: on wall = 0.254 2010-03-10 17:33:43.151 GCDClock[39741:a0f] 2 iterations: on wall = 0.127 2010-03-10 17:33:43.236 GCDClock[39741:a0f] 3 iterations: on wall = 0.085 2010-03-10 17:33:43.301 GCDClock[39741:a0f] 4 iterations: on wall = 0.064 2010-03-10 17:33:43.352 GCDClock[39741:a0f] 5 iterations: on wall = 0.051 2010-03-10 17:33:43.395 GCDClock[39741:a0f] 6 iterations: on wall = 0.043 2010-03-10 17:33:43.433 GCDClock[39741:a0f] 7 iterations: on wall = 0.038 2010-03-10 17:33:43.468 GCDClock[39741:a0f] 8 iterations: on wall = 0.034 which is about the same as I was getting above. This is a very contrived example. In fact, you need to be sure to keep the optimization at -O0, or else the compiler will realize we don't keep any of the calculations and not do the loop at all. Also, the integer that I'm taking the cos of is different in the two examples, but that doesn't affect the results too much. See the STRIDE on the manpage for dispatch_apply for how to do it properly and for why iterations is broadly comparable to num_threads in this case. EDIT: I note that Jacob's answer includes I use the omp_get_thread_num() function within my parallelized loop to print out which core it's working on... This way you can be sure that it's running on both cores. which is not correct (it has been partly fixed by an edit). Using omp_get_thread_num() is indeed a good way to ensure that your code is multithreaded, but it doesn't show "which core it's working on", just which thread. For example, the following code: #include #include int main() { int i; #pragma omp parallel for private(i) num_threads(50) for (i = 0; i prints out that it's using threads 0 to 49, but this doesn't show which core it's working on, since I only have eight cores. By looking at the Activity Monitor (the OP mentioned GCD, so must be on a Mac - go Window/CPU Usage ), you can see jobs switching between cores, so core != thread.
