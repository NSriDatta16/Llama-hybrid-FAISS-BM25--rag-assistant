[site]: stackoverflow
[post_id]: 2312001
[parent_id]: 2311842
[tags]: 
Assuming the code doesn't block and the next line runs immediately (as you seemed to indicate early in the question and in a comment ), you have a common problem when mixing non-line-based and line-based input. What happens is you have a newline left in the buffer, and fgets sees that, reads it, and returns, instead of doing what you really want: ignoring it, and then reading a line. The solution is to simply do the ignoring part yourself, and then call fgets: #include #include FILE* ignoreline(FILE* stream) { for (int c; (c = fgetc(stream)) != EOF;) { if (c == '\n') break; } return stream; } void example_use() { char buf[1000]; ignoreline(stdin); fgets(buf, sizeof buf, stdin); // or, since it returns the stream, can be more compact: fgets(buf, sizeof buf, ignoreline(stdin)); } int main() { // error handling omitted int n; printf("Enter a number: "); scanf("%d", &n); char buf[1000]; printf("Enter a line: "); ignoreline(stdin); // comment this line and compare the difference fgets(buf, sizeof buf, stdin); *strchr(buf, '\n') = '\0'; printf("You entered '%s'.\n", buf); return 0; } Note that it is also common and encouraged to "pair" the ignoreline with the scanf (or other non-line-based input) to turn that into line-based input. You may want to modify it, in that case, so you can tell the difference between input of "42 abc" and "42" (in the "Enter a number" case). Some people just use fgets everywhere, then parse that line with sscanf, and while that works, it's not necessary.
