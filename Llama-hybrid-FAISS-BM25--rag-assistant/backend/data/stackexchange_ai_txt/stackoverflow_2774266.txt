[site]: stackoverflow
[post_id]: 2774266
[parent_id]: 2773717
[tags]: 
As @tafa said, it seems to me an interface would be a good choice. Based on your signature for average , I came up with the below. AveragableValue public interface AveragableValue extends Value { public T average(T value); } NumberValue public class NumberValue implements AveragableValue { private int _n; public NumberValue(int n) { this._n = n; } @Override public void doSomething() { // from Value interface } @Override public NumberValue average(NumberValue value) { return new NumberValue((this._n + value._n) / 2); } } Then you can have your collection be of type AveragableValue . Already in your code you must have some kind of if/else clause somewhere to differentiate NumberValue and StringValue to figure out whether to call average or not. So I don't see how this would be more complicated. The hierarchy make sense - AveragableValue s are a subtype of Value , and a NumberValue is a type of AveragableValue . However, that signature for average doesn't look right. It only takes 2 values ( this and the argument) and averages them. You then lose the total count of things that have been averaged before. So assuming integers as the values (as I did), something like this: (new NumberValue(4)).average(new NumberValue(8)).average(new NumberValue(12)); would give you the value 9 instead of 8 . Is this what you want? It makes it bad for many calculations done iteratively, as you may be doing with collections. If you show us some of your code - how these classes are used, the collections holding them, how you are doing averaging right now - I can maybe give a better answer.
