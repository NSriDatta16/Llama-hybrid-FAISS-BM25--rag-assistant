[site]: stackoverflow
[post_id]: 3519080
[parent_id]: 3518703
[tags]: 
Isn't this inherently unsafe? No. It is a pointer. Since you (as the developer) have created both the function that will be executed by the thread and the argument that will be passed to the thread you are in full control. Remember this is a C API (not a C++ one) so it is as safe as you can get. This can work 'safely' only if the arg is in the heap, No. It is safe as long as its lifespan in the parent thread is as long as the lifetime that it can be used in the child thread. There are many ways to make sure that it lives long enough. and then again creating a heap variable adds to the overhead of cleaning the allocated memory up. Seriously. That's an argument? Since this is basically how it is done for all threads unless you are passing something much more simple like an integer (see below). If a stack variable is provided as the arg then the result is at best unpredictable. Its as predictable as you (the developer) make it. You created both the thread and the argument. It is your responsibility to make sure that the lifetime of the argument is appropriate. Nobody said it would be easy. This looks like a half-cooked solution to me, or am i missing some subtle aspects of the APIs? You are missing that this is the most basic of threading API. It is designed to be as flexible as possible so that safer systems can be developed with as few strings as possible. So we now hove boost::threads which if I guess is build on-top of these basic threading facilities but provide a much safer and easier to use infrastructure (but at some extra cost). If you want RAW unfettered speed and flexibility use the C API (with some danger). If you want a slightly safer use a higher level API like boost:thread (but slightly more costly) Thread specific storage with no dynamic allocation (Example) #include #include struct ThreadData { // Stuff for my thread. }; ThreadData threadData[5]; extern "C" void* threadStart(void* data); void* threadStart(void* data) { intptr_t id = reinterpret_cast (data); ThreadData& tData = threadData[id]; // Do Stuff return NULL; } int main() { for(intptr_t loop = 0;loop (loop)); } // You should wait here for threads to finish before exiting. }
