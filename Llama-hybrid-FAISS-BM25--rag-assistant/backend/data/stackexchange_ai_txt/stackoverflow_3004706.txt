[site]: stackoverflow
[post_id]: 3004706
[parent_id]: 3004181
[tags]: 
2nd and 3rd functions both resample your data set (they are basically expressing your image in a new referential). So they must reorganize the data: Create a new array of size ny*nz for YZ and nx*nz for XZ Fill the array with data laying in the given plane Return the pointer to the newly allocated array (In this scenario, the caller is responsible of deallocating the newly allocated memory.) Your algorithm for the YZ plane is: // I assume this sorting order: // Z ^ Slices are // / stacked along // / the Z axis // +-------> X // | // | // Y v // Assumes your data is stored in row major order: // +-------> X +---------> X // slice 0: | 0 1 2 | slice 1: | 6 7 8 | etc. // | 3 4 5 | | 9 10 11 | // Y v Y v // Assumes x is the column index, y the row index, z the slice index. // For example, you want element #9: // - col 0 -> x = 0 // - row 1 -> y = 1 // - slice 1 -> z = 1 // I suggest you rename nx, ny, nz into nbCols, nbRows, nbSlices to make // things explicit index computeIndex(VolumeData *vol, int x, int y, int z) { int nx = vol->nx, // nb cols ny = vol->ny, // nb rows nz = vol->nz; // nb slices int index = nx*ny*z // size of one slice, multiplied by slice index + nx*y // size of one row (nb cols), multiplied by row index + x; // offset in row (column index) return index; } unsigned char* getYZPlaneStack(VolumeData *vol,int x) { int nx = vol->nx, // nb rows ny = vol->ny, // nb columns nz = vol->nz; // nb slices unsigned char *newData = new unsigned char[ny*nz]; // Depth is now along the X axis // +-----> Z // | // | // Y v for(int y = 0; y data[i]; } return newData; }
