[site]: stackoverflow
[post_id]: 5584226
[parent_id]: 
[tags]: 
image download: memory leak using LazyList

I've got memory leak using LazyList . I use one instance of ImageLoader in whole app, I create it in Application.onCreate(), because I need image downloading in several activities: list activity, one activity with gallery widget and full-screen gallery activitiy(all of them use same cache) I modified image loader so it uses SoftReference-based HashMap. Here's code for SoftHashMap: public class SoftHashMap extends AbstractMap { private final Map hash=new HashMap(); private final int HARD_SIZE; private final LinkedList hardCache=new LinkedList(); private final ReferenceQueue queue=new ReferenceQueue(); public SoftHashMap(){ this(100); } public SoftHashMap(int hardSize){ HARD_SIZE=hardSize; } public Object get(Object key){ Object result=null; SoftReference soft_ref=(SoftReference)hash.get(key); if(soft_ref!=null){ result=soft_ref.get(); if(result==null){ hash.remove(key); }else{ hardCache.addFirst(result); if(hardCache.size()>HARD_SIZE){ hardCache.removeLast(); } } } return result; } private static class SoftValue extends SoftReference{ private final Object key; public SoftValue(Object k, Object key, ReferenceQueue q) { super(k, q); this.key=key; } } private void processQueue(){ SoftValue sv; while((sv=(SoftValue)queue.poll())!=null){ hash.remove(sv.key); } } public Object put(Object key, Object value){ processQueue(); return hash.put(key, new SoftValue(value, key, queue)); } public void clear(){ hardCache.clear(); processQueue(); hash.clear(); } public int size(){ processQueue(); return hash.size(); } public Set entrySet() { throw new UnsupportedOperationException(); } } ImageLoader class: public class ImageLoader { private SoftHashMap cache=new SoftHashMap(15); private File cacheDir; final int stub_id=R.drawable.stub; private int mWidth, mHeight; public ImageLoader(Context context, int h, int w){ mWidth=w; mHeight=h; photoLoaderThread.setPriority(Thread.NORM_PRIORITY); if (android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED)) cacheDir=new File(android.os.Environment.getExternalStorageDirectory(),"CacheDir"); else cacheDir=context.getCacheDir(); if(!cacheDir.exists()) cacheDir.mkdirs(); } public void DisplayImage(String url, Activity activity, ImageView imageView) { Log.d("IMAGE LOADER", "getNativeHeapSize()-"+String.valueOf(Debug.getNativeHeapSize()/1024)+" kb"); Log.d("IMAGE LOADER", "getNativeHeapAllocatedSize()-"+String.valueOf(Debug.getNativeHeapAllocatedSize()/1024)+" kb"); Log.d("IMAGE LOADER", "getNativeHeapFreeSize()-"+String.valueOf(Debug.getNativeHeapFreeSize()/1024)+" kb"); if(cache.get(url)!=null){ imageView.setImageBitmap((Bitmap)cache.get(url)); } else { queuePhoto(url, activity, imageView); imageView.setImageResource(stub_id); } } private void queuePhoto(String url, Activity activity, ImageView imageView) { //This ImageView may be used for other images before. So there may be some old tasks in the queue. We need to discard them. photosQueue.Clean(imageView); PhotoToLoad p=new PhotoToLoad(url, imageView); synchronized(photosQueue.photosToLoad){ photosQueue.photosToLoad.push(p); photosQueue.photosToLoad.notifyAll(); } //start thread if it's not started yet if(photoLoaderThread.getState()==Thread.State.NEW) photoLoaderThread.start(); } private Bitmap getBitmap(String url) { //I identify images by hashcode. Not a perfect solution, good for the demo. String filename=String.valueOf(url.hashCode()); File f=new File(cacheDir, filename); //from SD cache Bitmap b = decodeFile(f); if(b!=null) return b; //from web try { Bitmap bitmap=null; InputStream is=new URL(url).openStream(); OutputStream os = new FileOutputStream(f); Utils.CopyStream(is, os); os.close(); bitmap = decodeFile(f); return bitmap; } catch (Exception ex){ ex.printStackTrace(); return null; } } //decodes image and scales it to reduce memory consumption private Bitmap decodeFile(File f){ Bitmap b=null; try { //decode image size BitmapFactory.Options o = new BitmapFactory.Options(); o.inJustDecodeBounds = true; FileInputStream fis=new FileInputStream(f); BitmapFactory.decodeStream(fis,null,o); try { fis.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } //Find the correct scale value. It should be the power of 2. //final int REQUIRED_SIZE=mWidth; int width_tmp=o.outWidth, height_tmp=o.outHeight; int scale=1; while(true){ if(width_tmp/2 photosToLoad=new Stack (); public void Clean(ImageView image) { for(int j=0 ;j And my Application class, not the best way to do it, though: public class MyApplication extends Application { ImageLoader mImageLoader; @Override public void onCreate(){ int h =((WindowManager)getApplicationContext().getSystemService(WINDOW_SERVICE)).getDefaultDisplay().getHeight(); int w =((WindowManager)getApplicationContext().getSystemService(WINDOW_SERVICE)).getDefaultDisplay().getWidth(); mImageLoader=new ImageLoader(getApplicationContext(), h, w); super.onCreate(); public ImageLoader getImageLoader(){ return mImageLoader; } @Override public void onLowMemory(){ mImageLoader.clearCache(); Log.d("MY APP", "ON LOW MEMORY"); super.onLowMemory(); } } And the worst part: after some time I receive OOM exception when ImageLoader tries to decode another bitmap. I'll appreciate any your help. Thanks. EDIT I've got rid of hard cache, but i still get this OOM exception. It seems to me that I'm doing smth funny. I don't even know what extra information should I provide... The images which i download from server are pretty big, though. And app fails to allocate appr. 1.5 mb, that's what I see in LogCat. But I just can't figure out why doesn't vm clear my SoftHashMap if there is need for memory...
