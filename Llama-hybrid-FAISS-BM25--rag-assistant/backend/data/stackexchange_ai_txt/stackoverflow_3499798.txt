[site]: stackoverflow
[post_id]: 3499798
[parent_id]: 
[tags]: 
Optimize me! (C, performance) -- followup to bit-twiddling question

Thanks to some very helpful stackOverflow users at Bit twiddling: which bit is set? , I have constructed my function (posted at the end of the question). Any suggestions -- even small suggestions -- would be appreciated. Hopefully it will make my code better, but at the least it should teach me something. :) Overview This function will be called at least 10 13 times, and possibly as often as 10 15 . That is, this code will run for months in all likelihood, so any performance tips would be helpful. This function accounts for 72-77% of the program's time, based on profiling and about a dozen runs in different configurations (optimizing certain parameters not relevant here). At the moment the function runs in an average of 50 clocks. I'm not sure how much this can be improved, but I'd be thrilled to see it run in 30. Key Observation If at some point in the calculation you can tell that the value that will be returned will be small (exact value negotiable -- say, below a million) you can abort early . I'm only interested in large values. This is how I hope to save the most time, rather than by further micro-optimizations (though these are of course welcome as well!). Performance Information smallprimes is a bit array (64 bits); on average about 8 bits will be set, but it could be as few as 0 or as many as 12. q will usually be nonzero. (Notice that the function exits early if q and smallprimes are zero.) r and s will often be 0. If q is zero, r and s will be too; if r is zero, s will be too. As the comment at the end says, nu is usually 1 by the end, so I have an efficient special case for it. The calculations below the special case may appear to risk overflow, but through appropriate modeling I have proved that, for my input, this will not occur -- so don't worry about that case. Functions not defined here (ugcd, minuu, star, etc.) have already been optimized; none take long to run. pr is a small array (all in L1). Also, all functions called here are pure functions . But if you really care... ugcd is the gcd , minuu is the minimum, vals is the number of trailing binary 0s, __builtin_ffs is the location of the leftmost binary 1, star is (n-1) >> vals(n-1), pr is an array of the primes from 2 to 313. The calculations are currently being done on a Phenom II 920 x4, though optimizations for i7 or Woodcrest are still of interest (if I get compute time on other nodes). I would be happy to answer any questions you have about the function or its constituents. What it actually does Added in response to a request. You don't need to read this part. The input is an odd number n with 1 smallprimes&1 is set if the number is divisible by 3, smallprimes&2 is set if the number is divisible by 5, smallprimes&4 is set if the number is divisible by 7, smallprimes&8 is set if the number is divisible by 11, etc. up to the most significant bit which represents 313. A number divisible by the square of a prime is not represented differently from a number divisible by just that number. (In fact, multiples of squares can be discarded; in the preprocessing stage in another function multiples of squares of primes q, r, and s represent larger factors of the number. Any remaining factor (which may be greater than the square root of the number, or if s is nonzero may even be less) can be found by dividing factors out from n. Once all the factors are recovered in this way, the number of bases, 1 strong pseudoprime are counted using a mathematical formula best explained by the code. Improvements so far Pushed the early exit test up. This clearly saves work so I made the change. The appropriate functions are already inline, so __attribute__ ((inline)) does nothing. Oddly, marking the main function bases and some of the helpers with __attribute ((hot)) hurt performance by almost 2% and I can't figure out why (but it's reproducible with over 20 tests). So I didn't make that change. Likewise, __attribute__ ((const)) , at best, did not help. I was more than slightly surprised by this. Code ulong bases(ulong smallprimes, ulong n, ulong q, ulong r, ulong s) { if (!smallprimes & !q) return 0; ulong f = __builtin_popcountll(smallprimes) + (q > 1) + (r > 1) + (s > 1); ulong nu = 0xFFFF; // "Infinity" for the purpose of minimum ulong nn = star(n); ulong prod = 1; while (smallprimes) { ulong bit = smallprimes & (-smallprimes); ulong p = pr[__builtin_ffsll(bit)]; nu = minuu(nu, vals(p - 1)); prod *= ugcd(nn, star(p)); n /= p; while (n % p == 0) n /= p; smallprimes ^= bit; } if (q) { nu = minuu(nu, vals(q - 1)); prod *= ugcd(nn, star(q)); n /= q; while (n % q == 0) n /= q; } else { goto BASES_END; } if (r) { nu = minuu(nu, vals(r - 1)); prod *= ugcd(nn, star(r)); n /= r; while (n % r == 0) n /= r; } else { goto BASES_END; } if (s) { nu = minuu(nu, vals(s - 1)); prod *= ugcd(nn, star(s)); n /= s; while (n % s == 0) n /= s; } BASES_END: if (n > 1) { nu = minuu(nu, vals(n - 1)); prod *= ugcd(nn, star(n)); f++; } // This happens ~88% of the time in my tests, so special-case it. if (nu == 1) return prod
