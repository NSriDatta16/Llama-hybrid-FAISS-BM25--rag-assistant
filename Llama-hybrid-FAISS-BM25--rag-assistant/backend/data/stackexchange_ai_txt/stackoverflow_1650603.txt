[site]: stackoverflow
[post_id]: 1650603
[parent_id]: 
[tags]: 
Python: Object identity assertions thrown by differences in import statement notations

When checking an object's identity, I am getting assertion errors because the object creation code imports the object-defining module under one notation ( base.other_stuff.BarCode ) and the identity-checking code imports that same module under a different notation ( other_stuff.BarCode ). (Please see below for gory details.) It seems that the isinstance() call is sticky about the references to the object definition module, and wants it imported under the exact same notation. (I'm using version 2.5.) I suppose could fix this by changing the import notation in the code checking the identity, but I'm worried that I'll just propagate the same problem to other code that depends on it. And I'm sure there is some more elegant solution that I probably should be using in the first place. So how do I fix this? DETAILS PythonPath: '/', '/base/' Files: /__init__.py base/__init__.py base/other_stuff/__init__.py base/other_stuff/BarCode.py base/stuff/__init__.py camp/__init__.py Text of base/stuff/FooCode.py: import other_stuff.BarCode as bc class Foo: def __init__(self, barThing): assert isinstance(barThing, bc.Bar) Text of camp/new_code.py: import base.stuff.FooCode as fc import base.other_stuff.BarCode as bc thisBar = bc.Bar() assert isinstance(thisBar, bc.Bar) thisFoo = fc.Foo(barThing=thisBar) This fails. It survives its assertion test, but blows up on the assertion in the initial code. However, it works when I modify new_code to import BarCode.py with: import other_stuff.BarCode as bc . . . because both base/ and base/other_stuff are on the PythonPath.
