[site]: stackoverflow
[post_id]: 1689119
[parent_id]: 1688962
[tags]: 
In spite of the historical interchanging of these two terms, they indicate different things. They are both methods for managing moving data in memory to another storage device, called a backing store (often a hard drive), but they use different methods of doing so. Swapping involves the moving of a process's entire collection data in memory to a range of space on the backing store, often to a swapfile or swap partition. The process goes from being in memory to swapped out entirely; there is no in-between. Obviously the process will need to be entirely idle for swapping to be at all worthwhile. The advantage of this is that it is relatively simple to grasp and memory for a program is always allocated contiguously, the downside is that performance on a machine can become absolutely abysmal when the system ends up in a state where things are constantly swapping. The algorithm also involves the repeated swapping in and out of data that will not be used in the foreseeable future. Paging attempts to solve these problem, by taking physical memory, and carving it up into things called "frames" of some fixed size. It also takes the memory space of each running process, and carves it up into pages (which are the same size as frames); this is called the physical address space, due to the need to use physical addresses to access each block of memory. Each program is presented an environment by the OS, and supported by modern hardware, which makes the programs memory footprint look like a single contiguous block of a very large amount of memory; this is called a logical address space. However, each page of this contiguous block may be in memory, or it may be on the backing store. The operating system determines where each page is by consulting something called a "page table". If it finds the page the program has asked for is in memory somewhere, it will simply go to that page of memory and grab the data requested. If it finds the page is not in memory; this causes a "page fault". The OS will suspend the process while it loads the requested page in from the backing store, and may in turn move another page from memory to the backing store to make room, based on some replacement algorithm. The backing store may be called a pagefile, or may still be called a swapfile or swap partition, leading to confusion about which system is being used. Whether it is a separate partition, or just a file, depends on the operating system. There are certain parts of memory that aren't subject to being paged out. One of these is the paging code itself, and the parts of the kernel that handle things like page faults. Some operating systems, like MacOS, refer to this memory as "wired". Modern day hardware has several devices that allow an operating system to support paging far more effectively. The most common of these is a Translation Lookaside Buffer, or TLB. This stores a sort of hardware page table cache, so that whenever a program needs to do a logical address to physical address translation, it doesn't have to go ask the operating system every time. Modern operating systems also take advantage of paging by lazily-loading parts of the processes they are running. For instance, if you startup Microsoft Word, instead of loading the entire program into memory, the operating system will instead load only those parts of the program it needs into memory, and will grab the other parts of the program only as it needs them. This has trade-offs as well between memory footprint, boot speed, and how often delays occur within the program as new parts need to be loaded. Anyway, maybe more than you are looking for, but hopefully interesting.
