[site]: stackoverflow
[post_id]: 1414851
[parent_id]: 1414506
[tags]: 
The C++ Standard says about protected non-static members at 11.5/1 When a friend or a member function of a derived class references a protected nonstatic member function or protected nonstatic data member of a base class, an access check applies in addition to those described earlier in clause 11. Except when forming a pointer to member (5.3.1), the access must be through a pointer to, reference to, or object of the derived class itself (or any class derived from that class) (5.2.5). If the access is to form a pointer to member, the nested-name-specifier shall name the derived class (or any class derived from that class). In addition to fixing things mentioned earlier by others (constructor of B is private), i think rlbond's way will do it fine. However, a direct consequence of the above paragraph of the Standard is that the following is possible using a member pointer, which arguably is a hole in the type system, of course class B : public A { public: B(A &a){ int A::*dataptr = &B::data; data = a.*dataptr; } }; Of course, this code is not recommended to do, but shows that you can access it, if you really need to (I've seen this way being used for printing out a std::stack , std::queue , std::priority_queue by accessing its protected container member c )
