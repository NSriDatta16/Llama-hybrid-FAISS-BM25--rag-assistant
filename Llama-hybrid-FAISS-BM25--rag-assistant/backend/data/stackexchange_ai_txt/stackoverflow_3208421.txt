[site]: stackoverflow
[post_id]: 3208421
[parent_id]: 3208235
[tags]: 
From what you've described, you're creating an interface that will be implemented by multiple similar services. Since I don't know your requirements, constraints, or division of responsibility between interface author/implementor are, let me instead examine some of the options available to you. This is by no means an exhaustive list - just those that are common: Create a "superset" common interface which, for some implementations, it may not be possible to fully implement. Exceptions report which capabilities are unsupported. Create a "lowest-common-denominator" interface which only has members that all implementation can support. No unsupported exceptions thrown since all capabilities are required to be supported by everyone. Create completely separate interfaces for each implementing services (which effectively destroys the value of a common, unifying interface). As a variation of #1, add a property/method that can report which capabilities are supported (so you aren't using exceptions as a mean to check for supported functionality). As a variation of #2, create inherited interfaces that progressively add additional capabilities. Option #1 can make it difficult to write reliable code. You always find yourself wrapping each method call in a try/catch block - which can become unreadable. Worse yet, if you forget to do this somewhere you can propagate unhandled exceptions through your call stack, which may itself be disruptive. However, this approach is the easiest for those implementing the interface to deal with - if a capability isn't supported just throw a NotSupportedException - easy. Option #2 takes may require significant analysis to correctly identify what is a true common subset of supported functionality. This approach is further complicated by the fact that if you guess incorrectly about the ability for all implementaitons to support a feature, you may find yourself in situation #1 by default - requiring you to add all of the necessary logic to handle potential exceptions. Option #3 is basically: "I give up. There's no common interface here". Sometimes this is an acceptable answer . Trying to wedge an interface where one doesn't naturally emerge can be worse than simply coding against separate (unrelated) interfaces or implementation classes. In this case, you would normally implement "strategies" for each known implementation and group functionality into more coarse-grained methods which can be reliably implemented for all cases. Option #4 is helpful in that it allows you to first check for whether a capability is supported before invoking it. Implementors would still likely throw NotSupportedException if invoked, the difference is that you wouldn't invoke implementations that aren't supported to begin with. The problem here is that you need to design a mechanism that allows consumers to test which functionality is supported. This approach isn't very object-oriented or particularly extensible (if your inteface evolves), but it is simple. Option #5 tries to improve on #2 by partitiong functionality - it may be that there is no meaningful "lowest-common-denominator" interface - instead, there may be a family of related interfaces which can be used together. This option also creates the potential for a proliferation of fragmentary interfaces, which may become a maintenance challenge. On the upside, this approach allows you to easily test for which features are supported by an implementation by attempting to cast to a particular interface. It is also more extensible than some kind of SupportedCapabilities enum. In this approach, each implementation would be expected to either support all of an interface or none of it. This isn't always possible to achieve, and runs afoul of the challenges described in option #2. As the adage goes: " Any programming problem can be solved by adding another level of abstraction ". However, it's really up to you to decide what level of abstraction is necessary or appropriate to the problems you are trying to solve.
