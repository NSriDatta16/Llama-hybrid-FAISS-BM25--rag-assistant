[site]: crossvalidated
[post_id]: 253032
[parent_id]: 252988
[tags]: 
I don't know about pyStan specifically, but it's straight forward to compute an HDI from an MCMC sample, if you assume that the underlying distribution is unimodal . Basically, to compute the 95% HDI, you sort sample, then check all the 95% intervals, and select the shortest. Functions for computing HDI's are explained in Chapter 25 of Doing Bayesian Data Analysis Second Edition . Below is R code for the function that computes an HDI from an MCMC sample. Hopefully it's easy to translate in Python. The function is in DBDA2E-utilities.R in the software that accompanies DBDA2E . HDIofMCMC = function( sampleVec , credMass=0.95 ) { # Computes highest density interval from a sample of representative values, # estimated as shortest credible interval. # Arguments: # sampleVec # is a vector of representative values from a probability distribution. # credMass # is a scalar between 0 and 1, indicating the mass within the credible # interval that is to be estimated. # Value: # HDIlim is a vector containing the limits of the HDI sortedPts = sort( sampleVec ) ciIdxInc = ceiling( credMass * length( sortedPts ) ) nCIs = length( sortedPts ) - ciIdxInc ciWidth = rep( 0 , nCIs ) for ( i in 1:nCIs ) { ciWidth[ i ] = sortedPts[ i + ciIdxInc ] - sortedPts[ i ] } HDImin = sortedPts[ which.min( ciWidth ) ] HDImax = sortedPts[ which.min( ciWidth ) + ciIdxInc ] HDIlim = c( HDImin , HDImax ) return( HDIlim ) }
