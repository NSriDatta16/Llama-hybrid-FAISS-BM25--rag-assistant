[site]: stackoverflow
[post_id]: 2354047
[parent_id]: 2353525
[tags]: 
I might suggest FormatterServices.PopulateObjectMembers , except a: this is still slow AFAIK, and b: I tried it (below) and it seems to want to throw an exception on the property (don't know why; didn't look too deep). Another option may be Expression , but you don't really want to do the Compile each time (better to do it once only and cache it, but that demands a known format). public T create(object obj) { // simplified for illustration var bindings = obj as IDictionary ; Type type = typeof(T); var func = Expression.Lambda >(Expression.MemberInit( Expression.New(type), from pair in bindings let member = type.GetMember(pair.Key).Single() select (MemberBinding)Expression.Bind(member, Expression.Constant(pair.Value)))); return func.Compile().Invoke(); } Finally, you might cache a set of pre-compiled Action setters (keyed against the member name). In reality this is probably your best bet. Properties are easy (you use Delegate.CreateDelegate) - fields might need DynamicMethod - but if you can't predict the layout in advance it'll have the least overhead. For the keyed / IL approach (you won't get faster): public class dynamic_data_serializer { public T create(object obj) { T inst = Activator.CreateInstance (); var bindings = obj as IDictionary ; foreach (var pair in bindings) { setters[pair.Key](inst, pair.Value); } return inst; } private static readonly Dictionary > setters; static dynamic_data_serializer() { setters = new Dictionary >(StringComparer.Ordinal); foreach (PropertyInfo prop in typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance)) { setters.Add(prop.Name, CreateForMember(prop)); } foreach (FieldInfo field in typeof(T).GetFields(BindingFlags.Public | BindingFlags.Instance)) { setters.Add(field.Name, CreateForMember(field)); } } static Action CreateForMember(MemberInfo member) { bool isField; Type type; switch (member.MemberType) { case MemberTypes.Property: isField = false; type = ((PropertyInfo)member).PropertyType; break; case MemberTypes.Field: isField = true; type = ((FieldInfo)member).FieldType; break; default: throw new NotSupportedException(); } DynamicMethod method = new DynamicMethod("__set_" + member.Name, null, new Type[] { typeof(T), typeof(object) }); ILGenerator il = method.GetILGenerator(); il.Emit(OpCodes.Ldarg_0); il.Emit(OpCodes.Ldarg_1); if(type != typeof(object)) { il.Emit(type.IsValueType ? OpCodes.Unbox_Any : OpCodes.Castclass, type); } if (isField) {il.Emit(OpCodes.Stfld, (FieldInfo)member);} else { il.EmitCall(OpCodes.Callvirt, ((PropertyInfo)member).GetSetMethod(), null); } il.Emit(OpCodes.Ret); return (Action )method.CreateDelegate(typeof(Action )); } }
