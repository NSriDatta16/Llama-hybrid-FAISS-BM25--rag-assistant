[site]: stackoverflow
[post_id]: 857769
[parent_id]: 857703
[tags]: 
The problem is that droppable.drop() is called before draggable.stop(). So your Stoppos is not yet calculated. One way to deal with this would be to simply track what item is being dragged, and calculate the position for that in droppable.drop(). e.g. (subset of your code), notice the "Dragging" object. $(document).ready(function() { var Startpos = new Array; var Stoppos = new Array; var Dragging = null; // Make images draggable. $(".item").draggable({ // Elements cannot go outside #container containment: 'parent', // Make sure the element can only be dropped in a grid. grid: [150,150], // Find original position of dragged image. start: function(event, ui) { Dragging=this; // Make sure picture always are on top when dragged (z-index). $(this).css({'z-index' : '100'}); // Show start dragged position of image. Startpos = $(this).position(); $("div#start").text("START: \nLeft: "+ Startpos.left + "\nTop: " + Startpos.top); }, // Find position where image is dropped. stop: function(event, ui) { // Revert to default layer position when dropped (z-index). $(this).css({'z-index' : '10'}); // Show dropped position. Stoppos = $(this).position(); $("div#stop").text("STOP: \nLeft: "+ Stoppos.left + "\nTop: " + Stoppos.top); Dragging=null; } }); However, there are probably several other legitimate ways around this.
