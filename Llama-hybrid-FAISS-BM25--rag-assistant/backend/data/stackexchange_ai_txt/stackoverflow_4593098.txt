[site]: stackoverflow
[post_id]: 4593098
[parent_id]: 4592250
[tags]: 
Here is a state machine approach using switch statement that will do what you want: public class TagCleaner { public string CleanEM(string input) { var beginTag = " "; var endTag = " "; var parsable = input; var state = 0; var output = string.Empty; var done = false; while (!done) { switch (state) { case 0: // new attempt... find { var idx = parsable.IndexOf(beginTag); if (idx 0) { output = parsable.Substring(0, idx + beginTag.Length); } if (idx == 0) { output = beginTag; } parsable = parsable.Substring(idx + beginTag.Length); //chopped off anything before the tag for next round state = 1; // set state to go find matching } break; case 1: // found , now find matching { var idx = parsable.IndexOf(endTag); if (idx 0) { output += parsable.Substring(0, idx + endTag.Length); } if (idx == 0) // ... remove the last tag from output... { output = output.Substring(0, output.LastIndexOf(beginTag)); } parsable = parsable.Substring(idx + endTag.Length); //chopped off anything before the tag for next round if (parsable.Length } break; case 2: //just found , now look for the next { var idx = parsable.IndexOf(beginTag); if (idx = 0) { var prefix = parsable.Substring(0, idx); var re = new System.Text.RegularExpressions.Regex("^ *$"); if (re.IsMatch(prefix)) // found 0 or more spaces between the and tag... { output = output.Substring(0, output.LastIndexOf(endTag)); //chop off the last from output output += prefix; //add the spaces to the output parsable = parsable.Substring(idx + beginTag.Length); state = 1; //set state to go find } else // there are other things beside empty spaces in between... { output += parsable.Substring(0, idx + beginTag.Length); parsable = parsable.Substring(idx + beginTag.Length); state = 1; //set state to go find } } if (parsable.Length It'll do what you want and with a bit of changes, you can switch it to clean whatever tag you want. Here is a sample MS Test to prove that it work... [TestClass] public class TagCleanerTest { [TestMethod] public void Should_Clean_EM_Tag_That_Are_In_Sequence_Even_With_Spaces_In_Between() { var input = " Administration Resource Officer paragraphs "; var expected = " Administration Resource Officer paragraphs "; var sut = new TagCleaner(); var actual = sut.CleanEM(input); Assert.AreEqual(expected, actual); } }
