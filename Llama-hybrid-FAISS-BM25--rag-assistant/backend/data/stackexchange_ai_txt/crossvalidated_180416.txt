[site]: crossvalidated
[post_id]: 180416
[parent_id]: 112967
[tags]: 
In brief, given an array of $x, p(x)$ pairs: Sort the array by $p(x)$, decreasing. Find the first element for which the cumulative sum of density of the sorted array is $\ge 1 - \alpha$. Find the array elements with $p(x)\ge$ this element's density. These $x$ values form the highest density interval(s). Here's an example implementation in R, from the code associated with Doing Bayesian Data Analysis : HDIofGrid = function( probMassVec , credMass=0.95 ) { # Arguments: # probMassVec is a vector of probability masses at each grid point. # credMass is the desired mass of the HDI region. # Return value: # A list with components: # indices is a vector of indices that are in the HDI # mass is the total mass of the included indices # height is the smallest component probability mass in the HDI # Example of use: For determining HDI of a beta(30,12) distribution # approximated on a grid: # > probDensityVec = dbeta( seq(0,1,length=201) , 30 , 12 ) # > probMassVec = probDensityVec / sum( probDensityVec ) # > HDIinfo = HDIofGrid( probMassVec ) # > show( HDIinfo ) sortedProbMass = sort( probMassVec , decreasing=T ) HDIheightIdx = min( which( cumsum( sortedProbMass ) >= credMass ) ) HDIheight = sortedProbMass[ HDIheightIdx ] HDImass = sum( probMassVec[ probMassVec >= HDIheight ] ) return( list( indices = which( probMassVec >= HDIheight ) , mass = HDImass , height = HDIheight ) ) } My own in python, adapted from the above: def hdi(x, fx, alpha): """ Given x and fx, returns hdi """ sfx = fx.copy() sfx.sort() sfx[:] = sfx[::-1] lowestHeightIdx = np.min(np.where(np.cumsum(sfx) > (1. - alpha))) lowestHeight = sfx[lowestHeightIdx] return x[fx >= lowestHeight]
