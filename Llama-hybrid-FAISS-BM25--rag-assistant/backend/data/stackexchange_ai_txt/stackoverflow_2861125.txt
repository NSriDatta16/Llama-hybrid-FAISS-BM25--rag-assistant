[site]: stackoverflow
[post_id]: 2861125
[parent_id]: 2860943
[tags]: 
You can actually use a facility built in to the Java runtime to do this. The SunJCE in Java 6 supports PBKDF2, which is a good algorithm to use for password hashing. SecureRandom random = new SecureRandom(); byte[] salt = new byte[16]; random.nextBytes(salt); KeySpec spec = new PBEKeySpec("password".toCharArray(), salt, 65536, 128); SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1"); byte[] hash = f.generateSecret(spec).getEncoded(); Base64.Encoder enc = Base64.getEncoder(); System.out.printf("salt: %s%n", enc.encodeToString(salt)); System.out.printf("hash: %s%n", enc.encodeToString(hash)); Here's a utility class that you can use for PBKDF2 password authentication: import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.security.spec.KeySpec; import java.util.Arrays; import java.util.Base64; import java.util.regex.Matcher; import java.util.regex.Pattern; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.PBEKeySpec; /** * Hash passwords for storage, and test passwords against password tokens. * * Instances of this class can be used concurrently by multiple threads. * * @author erickson * @see StackOverflow */ public final class PasswordAuthentication { /** * Each token produced by this class uses this identifier as a prefix. */ public static final String ID = "$31$"; /** * The minimum recommended cost, used by default */ public static final int DEFAULT_COST = 16; private static final String ALGORITHM = "PBKDF2WithHmacSHA1"; private static final int SIZE = 128; private static final Pattern layout = Pattern.compile("\\$31\\$(\\d\\d?)\\$(.{43})"); private final SecureRandom random; private final int cost; public PasswordAuthentication() { this(DEFAULT_COST); } /** * Create a password manager with a specified cost * * @param cost the exponential computational cost of hashing a password, 0 to 30 */ public PasswordAuthentication(int cost) { iterations(cost); /* Validate cost */ this.cost = cost; this.random = new SecureRandom(); } private static int iterations(int cost) { if ((cost 30)) throw new IllegalArgumentException("cost: " + cost); return 1 Passwords should be stored in a {@code char[]} so that it can be filled * with zeros after use instead of lingering on the heap and elsewhere. * * @deprecated Use {@link #hash(char[])} instead */ @Deprecated public String hash(String password) { return hash(password.toCharArray()); } /** * Authenticate with a password in an immutable {@code String} and a stored * password token. * * @deprecated Use {@link #authenticate(char[],String)} instead. * @see #hash(String) */ @Deprecated public boolean authenticate(String password, String token) { return authenticate(password.toCharArray(), token); } }
