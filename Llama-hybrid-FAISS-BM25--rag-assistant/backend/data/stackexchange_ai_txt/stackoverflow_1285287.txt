[site]: stackoverflow
[post_id]: 1285287
[parent_id]: 1285269
[tags]: 
Notice that an object instance has no __dict__ attribute: >>> dir(object()) ['__class__', '__delattr__', '__doc__', '__getattribute__', '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__'] An example to illustrate this behavior in a derived class: >>> class Foo(object): ... __slots__ = {} ... >>> f = Foo() >>> f.bar = 42 Traceback (most recent call last): File " ", line 1, in AttributeError: 'Foo' object has no attribute 'bar' Quoting from the docs on slots : [...] The __slots__ declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable. Space is saved because __dict__ is not created for each instance. EDIT: To answer ThomasH from the comments, OP's test class is an "old-style" class. Try: >>> class test: pass ... >>> getattr(test(), '__dict__') {} >>> getattr(object(), '__dict__') Traceback (most recent call last): File " ", line 1, in AttributeError: 'object' object has no attribute '__dict__' and you'll notice there is a __dict__ instance. The object class may not have a __slots__ defined, but the result is the same: lack of a __dict__ , which is what prevents dynamic assignment of an attribute. I've reorganized my answer to make this clearer (move the second paragraph to the top).
