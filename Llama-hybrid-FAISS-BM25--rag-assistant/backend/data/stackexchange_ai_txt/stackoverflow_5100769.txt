[site]: stackoverflow
[post_id]: 5100769
[parent_id]: 5099862
[tags]: 
From you're describing, the best approach would be a custom control. Docs for that are here . Custom controls can be as simple or a complicated as you want. One reason why you would want to muck around with the map panes is if you wanted such a 'control' to lie underneath the markers / shadows / polylines etc. I'm doing this right now to show a crosshairs in the center of the map at all times. But because I keep it as an overlay, I choose the panes in such a way that the markers are above it, so they can continue to be clicked and interacted with - using the mapPane . Here's how I'm doing it: var CrosshairOverlay = function(map){ this._holder = null; this.setMap(map); }; CrosshairOverlay.prototype = new google.maps.OverlayView(); CrosshairOverlay.prototype.onAdd = function(){ var map = this.getMap(); var holder = this._holder = $(' ').attr('id', 'crosshair')[0]; var crosshairPaper = this._paper = R(holder, 150, 150); // ... all your drawing and rendering code here. var projection = this.getProjection(); var wrappedHolder = $(holder); var updateCrosshairPosition = function(){ var center = projection.fromLatLngToDivPixel(map.getCenter()); wrappedHolder.css({left:center.x-75, top:center.y-75}); } _.each(['drag','dragend','bounds_changed','center_changed','zoom_changed','idle','resize'], function(event){ google.maps.event.addListener(map, event, updateCrosshairPosition); }); google.maps.event.addListener(map, 'maptypeid_changed', function(){ _.defer(updateCrosshairPosition); }); this.getPanes().mapPane.appendChild(holder); }; CrosshairOverlay.prototype.draw = function(){ }; CrosshairOverlay.prototype.onRemove = function(){ this._holder.parentNode.removeChild(this._holder); this._holder = null; }; The reason the maptypeid_changed has its own handler with a defer is because that event is fired before the map properly sets itself up when changing the type. Just run your function after the current event loop.
