[site]: stackoverflow
[post_id]: 4165581
[parent_id]: 4151277
[tags]: 
The right way is not to use plain pointers . The moment you start to write delete pointer; , you have to reconsider if you really need that pointer and if you do need it, if there is not some pre-packaged smart-pointer class that can take the burden of memory management from you. The example code you posted can be written entirely without the use of pointers: //Class A #pragma once #include "MyContainer.h" #include "B.h" class A { public: A() { }; ~A() { }; MyContainer ListOfB; }; //Class C #pragma once #include "MyContainer.h" #include "B.h" class C { public: C() { }; ~C() { }; MyContainer ListOfB; void getListOfB(MyContainer & ListOfA); }; void C::getListOfB(MyContainer & ListOfA) { for(ListOfA.isBegin(); !ListOfA.isEnd();) { A& anA = ListOfA.getNext(); for(anA.ListOfB.isBegin(); !anA.ListOfB.isEnd();) { B aB = anA.ListOfB.getNext(); ListOfB.add(aB); } } } //Class MyContainer #pragma once #include template class MyContainer { public: MyContainer(void); ~MyContainer(void) { }; T& getNext(); void removeAll(); void add(const T& t); void isBegin(); bool isEnd(); private: std::vector items; typename std::vector ::iterator it; }; template void MyContainer ::add(const T& t) { items.push_back(t); } template void MyContainer ::removeAll() { items.clear(); } template T& MyContainer ::getNext() { if(isEnd() || isEmpty()) return throw std::out_of_range(""); return *it++; } template void MyContainer ::isBegin() { it = items.begin(); } template bool MyContainer ::isEnd() { return it==items.end(); } If the B instances need to be shared between class A and class C (the lists in A and C refer both to the same B objects), then you could store shared pointers in the lists.
