[site]: stackoverflow
[post_id]: 948705
[parent_id]: 948564
[tags]: 
i would start with a canSee(Monster monster) or canBeSeenBy(Monster monster) method and see what happens. you may end up with a Visibilility class or end up using the http://en.wikipedia.org/wiki/Visitor_pattern . an extreme example is uncle bobs triple dispatch: // visitor with triple dispatch. from a post to comp.object by robert martin http://www.oma.com /* In this case, we are actually using a triple dispatch, because we have two types to resolve. The first dispatch is the virtual Collides function which resolves the type of the object upon which Collides is called. The second dispatch is the virtual Accept function which resolves the type of the object passed into Collides. Now that we know the type of both objects, we can call the appropriate global function to calculate the collision. This is done by the third and final dispatch to the Visit function. */ interface AbstractShape { boolean Collides(final AbstractShape shape); void Accept(ShapeVisitor visitor); } interface ShapeVisitor { abstract public void Visit(Rectangle rectangle); abstract public void Visit(Triangle triangle); } class Rectangle implements AbstractShape { public boolean Collides(final AbstractShape shape) { RectangleVisitor visitor=new RectangleVisitor(this); shape.Accept(visitor); return visitor.result(); } public void Accept(ShapeVisitor visitor) { visitor.Visit(this); } // visit Rectangle } class Triangle implements AbstractShape { public boolean Collides(final AbstractShape shape) { TriangleVisitor visitor=new TriangleVisitor(this); shape.Accept(visitor); return visitor.result(); } public void Accept(ShapeVisitor visitor) { visitor.Visit(this); } // visit Triangle } class collision { // first dispatch static boolean Collides(final Triangle t,final Triangle t2) { return true; } static boolean Collides(final Rectangle r,final Triangle t) { return true; } static boolean Collides(final Rectangle r,final Rectangle r2) { return true; } } // visitors. class TriangleVisitor implements ShapeVisitor { TriangleVisitor(final Triangle triangle) { this.triangle=triangle; } public void Visit(Rectangle rectangle) { result=collision.Collides(rectangle,triangle); } public void Visit(Triangle triangle) { result=collision.Collides(triangle,this.triangle); } boolean result() {return result; } private boolean result=false; private final Triangle triangle; } class RectangleVisitor implements ShapeVisitor { RectangleVisitor(final Rectangle rectangle) { this.rectangle=rectangle; } public void Visit(Rectangle rectangle) { result=collision.Collides(rectangle,this.rectangle); } public void Visit(Triangle triangle) { result=collision.Collides(rectangle,triangle); } boolean result() {return result; } private boolean result=false; private final Rectangle rectangle; } public class MartinsVisitor { public static void main (String[] args) { Rectangle rectangle=new Rectangle(); ShapeVisitor visitor=new RectangleVisitor(rectangle); AbstractShape shape=new Triangle(); shape.Accept(visitor); } }
