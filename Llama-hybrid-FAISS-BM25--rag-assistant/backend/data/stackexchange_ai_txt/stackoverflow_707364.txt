[site]: stackoverflow
[post_id]: 707364
[parent_id]: 706673
[tags]: 
There is no option to specify the order of operations in a transaction as it is hard-coded as follows (from the documentation): The SQL statements are issued in the following order all entity insertions, in the same order the corresponding objects were saved using ISession.Save() all entity updates all collection deletions all collection element deletions, updates and insertions all collection insertions all entity deletions, in the same order the corresponding objects were deleted using ISession.Delete() (An exception is that objects using native ID generation are inserted when they are saved.) As such, can I challenge you to answer why you are adding a new entity with an existing identifier? An identifier is supposed to be unique to a specific "entity." If that entity is gone, so should be its identifier. Another option would be to do an update on that record instead of a delete/insert. This keeps the ID the same so there is no unique constraint violation (on the key at least) and you can change all the other data so that it's a "new" record. EDIT: So apparently I wasn't entirely paying attention to the question when I responded since this is a problem with a unique constraint on a non-primary-key column. I think you have two solutions to choose from: Call Session.Flush() after your delete which will execute all the changes to the session up to that point, after which you can continue with the rest (inserting your new object). This works inside of a transaction as well so you don't need to worry about atomicity. Create a ReplacePage function which updates the existing entity with new data but keeps the primary-key and the unique column the same.
