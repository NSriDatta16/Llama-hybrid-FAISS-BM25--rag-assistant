[site]: stackoverflow
[post_id]: 3647308
[parent_id]: 
[tags]: 
Misscreation of my template class causes errors with SOCKET, why?

I created a class which holds data of type and returns an vector on request. But somehow the following error occurs: error C2259: 'CAcceptor' : cannot instantiate abstract class due to following members: 'void CDataAndEvent ::InitQueue(void)' : is abstract with [ C=SOCKET ] see declaration of 'CDataAndEvent ::InitQueue' with [ C=SOCKET ] code for the class: #pragma once #include #include #include //Class which hold an Input and Output vector //and the corresponding events template class CDataAndEvent { public: CDataAndEvent(void); virtual ~CDataAndEvent(void); //Access functions //Vectors virtual Inc::STATS GetInData(__out std::vector &); virtual Inc::STATS GetOutData(__out std::vector &); virtual Inc::STATS AddDataIn(__in const C&); virtual Inc::STATS AddDataOut(__in const C&); //Queues virtual HANDLE GetOutEvent() { return m_hEventOut; }; virtual HANDLE GetInEvent() { return m_hEventIn; }; protected: //Make this class non-instanceable virtual void InitQueue() = 0; private: //Input-/Output Vector std::vector m_vecIn; std::vector m_vecOut; //Events for the input- and output vector HANDLE m_hEventIn; HANDLE m_hEventOut; //Indicators bool m_bNewIn; bool m_bNewOut; }; template CDataAndEvent ::CDataAndEvent(void) : m_bNewIn(false), m_bNewOut(false) { //create events m_hEventIn = CreateEvent(NULL, TRUE, FALSE, NULL); m_hEventOut = CreateEvent(NULL, TRUE, FALSE, NULL); } template CDataAndEvent ::~CDataAndEvent(void) { } template Inc::STATS CDataAndEvent ::GetOutData(std::vector & vec) { if(!m_bNewOut) return Inc::NEMPTY; vec = m_vecOut; m_vecOut.clear(); m_bNewOut = false; ResetEvent(m_hEventOut); return Inc::SOK; } template Inc::STATS CDataAndEvent ::GetInData(std::vector & vec) { if(!m_bNewIn) return Inc::NEMPTY; //copy vec = m_vecIn; //clear the read data m_vecIn.clear(); //no new data ResetEvent(m_hEventIn); m_bNewIn = false; return Inc::SOK; } template Inc::STATS CDataAndEvent ::AddDataOut(const C& str) { m_vecOut.push_back(str); m_bNewOut = true; SetEvent(m_hEventOut); return Inc::SOK; } template Inc::STATS CDataAndEvent ::AddDataIn(const C& str) { m_vecIn.push_back(str); //new data available m_bNewIn = true; SetEvent(m_hEventIn); return Inc::SOK; } Anyone got a clue why this happens?... The CAcceptor-class is defined as the following #pragma once #include "connection.h" #include "DataAndEvent.h" class CAcceptor : public CConnection, public CDataAndEvent { public: CAcceptor(void); virtual ~CAcceptor(void); //Bind the port Inc::STATS BindSocket(const std::string& strPort); Inc::STATS Start(); //Start accepting Inc::STATS Stop(); //Stop accepting private: //Send data: not needed for the acceptor Inc::STATS _SendData(sockaddr* pTarget, int tolen, std::string& strData) {return Inc::EUNKNOWN;}; //Recv data: not needed for the acceptor Inc::STATS _RecvData(sockaddr* pSender, int* tolen, std::string& strData) {return Inc::EUNKNOWN;}; //Create sockets Inc::STATS CreateSocket(); //Delete Sockets Inc::STATS DeleteSocket(); //Thread stuff HANDLE m_hThread; //Thread handle for the auto mode thread friend DWORD WINAPI AutoModeThread(void*); //Auto mode thread }; and as far as i checked it overrides the pure virtual functions from CConnection: #pragma once //Headers #include #include #include class CConnection { public: CConnection(); virtual ~CConnection(void); //TEST: Bind socket contained by m_mapSocketContainer virtual Inc::STATS BindSocket(const std::string& strPort) = 0; //Resolve Target Address addrinfo* ResolveAddress(const std::string& strAddress, const std::string& strPort); protected: //Sockets SOCKET m_Socket; //Target Address addrinfo* m_pTargetAddress; //Socket //Creates the sockets needed //Will be called automatically by the constructor virtual Inc::STATS CreateSocket() = 0; //closes the sockets //Will be called automatically by the destructor virtual Inc::STATS DeleteSocket() = 0; //Data Transmission User Request virtual Inc::STATS _SendData(sockaddr* pTarget, int tolen, std::string& strData) = 0; virtual Inc::STATS _RecvData(sockaddr* pSender, int* fromlen, std::string& strData) = 0; private: //Winsock startup & cleanup //Start / Stop Inc::STATS StartWinsock(); Inc::STATS StopWinsock(); WSADATA m_Wsa; unsigned short m_wWsaVer; static bool bWinsockRunning; }; Thank You!...
