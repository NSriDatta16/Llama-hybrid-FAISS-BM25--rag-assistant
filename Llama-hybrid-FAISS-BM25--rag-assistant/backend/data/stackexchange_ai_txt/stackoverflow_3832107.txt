[site]: stackoverflow
[post_id]: 3832107
[parent_id]: 3831986
[tags]: 
I often find the following sample quite illuminating when it comes to explaining this: Disclaimer: the code examples are written directly into the text, and may contain errors that I have overseen. Please let me know if you find such errors. Let's say you have a database with a Customer table, and in your code you have a customer class: class Customer { public int Id { get; set; } public string Name { get; set; } } In order to provide a mechanism to get customer data from the database, you need to write some class doing that. This can be placed in something called a repository . Now, we don't want our code to rely too much on what exact database we use. It could be SQL server, it could be a text file. So we want an abstraction layer shielding the code from this knowledge. All we need to know is what such a repository looks like: public interface ICustomerRepository { Customer GetCustomer(int id); IEnumerable FindCustomers(string beginningOfName); } We can now implement this interface for the data storage that we use: public class SqlServerCustomerRepository : ICustomerRepository { public Customer GetCustomer(int id) { using(SqlConnection connection = new SqlConnection(connectionString)) { // code to fetch data and populate Customer objects go here } } // implementations of other members of ICustomerRepository // left out to keep code short. Just imagine they are here :) } Finally, when we want to use this code, we can have a factory create the concrete ICustomerRepository implementation to use: public static class RepositoryFactory { public static ICustomerRepository CreateCustomerRepository() { return new SqlServerCustomerRepository(); } } ...and in our code where we need the data: ICustomerRepository repository = RepositoryFactory.CreateCustomerRepository(); IEnumerable customers = repository.FindCustomers("A"); This way, there is no hard coupling between the consuming code, and the particular kind of repository in use (except for in the factory method, but that is the one and only place where this knowledge exists ). This makes it easy to replace the concrete repository implementation. This is also useful for testing, where you can easily create a mock repository returning hard coded results for given input, so that you can unit test the code that needs data from the repository.
