[site]: stackoverflow
[post_id]: 2284971
[parent_id]: 2279404
[tags]: 
I chose J.F. Sebastian's answer because I think it's the simplest and thus the best, but I'm adding another solution for anyone who doesn't want to install Beautiful Soup. (Also, the Beautiful Soup tree builder is going to be deprecated in html5lib 1.0 .) This solution was thanks to Amarghosh's tip; I just fleshed it out a bit. Looking at html5lib, I realized that it will output a minidom object natively, which means I can use his suggestion of toprettyxml() . Here's what I came up with: from html5lib import HTMLParser, treebuilders from cStringIO import StringIO def tidy_html(text): """Returns a well-formatted version of input HTML.""" p = HTMLParser(tree=treebuilders.getTreeBuilder("dom")) dom_tree = p.parseFragment(text) # using cStringIO for fast string concatenation pretty_HTML = StringIO() node = dom_tree.firstChild while node: node_contents = node.toprettyxml(indent=' ') pretty_HTML.write(node_contents) node = node.nextSibling output = pretty_HTML.getvalue() pretty_HTML.close() return output And an example: >>> text = """ bold, italic a div """ >>> tidy_html(text) bold, italic a div Why am I iterating over the children of the tree, rather than just calling toprettyxml() on dom_tree directly? Some of the HTML I'm dealing with is actually HTML fragments, so it's missing the and tags. To handle this I used the parseFragment() method, which means I get a DocumentFragment in return (rather than a Document). Unfortunately, it doesn't have a writexml() method (which toprettyxml() calls), so I iterate over the child nodes, which do have the method.
