[site]: stackoverflow
[post_id]: 4039992
[parent_id]: 4039729
[tags]: 
You can do this with a modified version of the Specification pattern . Start out with an interface that expresses results as percentages: public interface ISpecification { double GetPercentSatisfiedBy(T target); } Next, create a specification which applies any arbitrary condition: public sealed class Specification : ISpecification { private readonly Func _predicate; public Specification(Func predicate) { _predicate = predicate; } public double GetPercentSatisfiedBy(T target) { return _predicate(target) ? 1 : 0; } } Now, create a specification which linearly combines the results of other specifications: public sealed class CompositeSpecification : ISpecification { private readonly IList > _specifications; public CompositeSpecification(params ISpecification [] specifications) { _specifications = specifications.ToList(); } public double GetPercentSatisfiedBy(T target) { return _specifications.Average( specification => specification.GetPercentSatisfiedBy(target)); } } Finally, build a specification which contains all of your desired conditions and apply it to a list of Foo objects: var specification = new CompositeSpecification ( new Specification (foo => foo.Quantity >= 2), new Specification (foo => foo.Value (foo => foo.Category == "Blah"), new Specification (foo => foo.Quality > 5)); var foos = new List { ... }; var results = from foo in foos let percentSatisfied = specification.GetPercentSatisfiedBy(foo) orderby percentSatisfied descending select new { Foo = foo, PercentSatisfied = percentSatisfied }; This design supports specifications of arbitrary complexity.
