[site]: stackoverflow
[post_id]: 2781894
[parent_id]: 2779289
[tags]: 
It turns out you can't. At least not with the syntax provided above and not with CakePHP 1.2.6. I went over the source (yay! to open source frameworks!) and found the file cake/libs/model/datasources/dbo_source.php which contains the code for the joins. It all starts with DboSource::renderStatement() which does a shallow walk of the $query['joins'] array, replacing those join definitions with SQL fragments via DboSource::buildJoinStatement($join) , which does some tidying up of the arguments (filling in blanks etc.) and then calls DboSource::renderJoinStatement to create the SQL fragment of a single join clause. me: That should be easy to fix! I was told not to edit stuff in cake/libs , so instead I copied the file dbo_source.php to app/models/datasources/ for editing. Then I took my axe and refactored the shallow walk of the $query['joins'] array in DboSource::renderStatement() into a new method DboSource::buildJoinStatementArray() resulting in these two methods: function buildStatement($query, $model) { $query = array_merge(array('offset' => null, 'joins' => array()), $query); # refactored (extract method) to make recursion easier $query['joins'] = $this->buildJoinStatementArray($query['joins']); return $this->renderStatement('select', array( 'conditions' => $this->conditions($query['conditions'], true, true, $model), 'fields' => implode(', ', $query['fields']), 'table' => $query['table'], 'alias' => $this->alias . $this->name($query['alias']), 'order' => $this->order($query['order']), 'limit' => $this->limit($query['limit'], $query['offset']), 'joins' => implode(' ', $query['joins']), 'group' => $this->group($query['group']) )); } /** * Replaces the join statement array syntax with SQL join clauses. */ function buildJoinStatementArray($joins) { if (!empty($joins)) { $count = count($joins); for ($i = 0; $i buildJoinStatement($joins[$i]); # $joins[$i] now contains something like "LEFT JOIN users As User on User.group_id = Group.id" } } } return $joins; } Once I had DboSource::buildJoinStatementArray() , it was time to change DboSource::buildJoinStatement() - all I did was added a check for $data['joins'] and an alternative rendering method for that case: function buildJoinStatement($join) { $data = array_merge(array( 'type' => null, 'alias' => null, 'table' => 'join_table', 'conditions' => array() ), $join); if (!empty($data['alias'])) { $data['alias'] = $this->alias . $this->name($data['alias']); } if (!empty($data['conditions'])) { $data['conditions'] = trim($this->conditions($data['conditions'], true, false)); } # allow for nested joins if (!empty($data['joins']) and is_array($data['joins'])) { $data['joins'] = $this->buildJoinStatementArray($data['joins']); return $this->renderNestedJoinStatement($data); } else { return $this->renderJoinStatement($data); } } The new renderNestedJoinStatement() method is pretty similar to DboSource::renderJoinStatement() : /** * Renders a final SQL JOIN that contains nested join statements * * @param array $data * @return string */ function renderNestedJoinStatement($data) { extract($data); $nestedJoins = implode(' ', $joins); return trim("{$type} JOIN ({$table} {$alias} {$nestedJoins})ON ({$conditions})"); }
