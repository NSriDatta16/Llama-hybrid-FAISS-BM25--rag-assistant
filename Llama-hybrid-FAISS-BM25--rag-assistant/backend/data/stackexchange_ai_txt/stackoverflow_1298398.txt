[site]: stackoverflow
[post_id]: 1298398
[parent_id]: 1296577
[tags]: 
To do path coverage, you need to get at the program control flow somehow. An obvious method is to construct a real control flow graph, and then traverse segments of it to pick out "path fragments" (e.g., basis paths) to be used in your path coverage analysis. (You can attempt to do this by string hacking the source code, but you'll likely fail; parsing and flow analysis is too complex). See What's the point of basis path coverage? for a good stackoverflow discussion on basis paths. To implement the required path coverage tool, you likely need to really parse the full legacy language completely. For 3000 programs and a strong requirement for testing, using a industrial strength parser and infrastructure to do this would make sense. Our DMS Software Reengineering Toolkit can be used to construct not only the parser, but the control flow analysis and the instrumentation required to collect path coverage data. (The "Branch Coverage for Arbitrary Languages" made this point if all you wanted to do was collect branch coverage data, but there's more to DMS than just parsing). DMS also has support for constucting control (and data flow) graphs if you need them, as you apparantly do in this case; see DMS constructed control flow graphs . DMS has been used to build control and data flow analyzers for C, Java and COBOL, and has been used to build parsers for some 30+ langauges. It can handle your legacy language if you are serious about this. EDIT 10/31/2011: DMS can now compute control flow for C++, so it would be a great foundation for a C++ path coverage tool.
