[site]: stackoverflow
[post_id]: 3483760
[parent_id]: 3483684
[tags]: 
That's a fairly good solution. You're using recursion for the children (which won't go too deep) but iteration for the siblings (which would go deep if you used recursion). Your code could certainly be more elegant as a recursion-only solution (calling tree_free for both child and next ) but the risk of stack overflow would be greatly increased so I think you made the right choice there. Having said that, there's no need for child at all if you re-arrange the order of your operations: unsigned int tree_free (struct tree *root) { struct tree *current = NULL, *next = NULL; unsigned int freecnt = 0; current = root; while(current != NULL) { freecnt += tree_free (current->child) + 1; next = current->next; xfree (current); current = next; } return freecnt; } If you think the length of your sibling list won't be that large, you could try the elegant solution: unsigned int tree_free (struct tree *root) { unsigned int freecnt; if (root == NULL) return 0; freecnt = tree_free (root->child) + tree_free (root->next); xfree (root); return freecnt + 1; } It's untested so I make no statement of warranty or fitness for purpose, especially since it's probably dangerous for your specific case of a large number of sibling links. I include it more as an indication of what's possible with recursion. My advice is to use the first one.
