[site]: stackoverflow
[post_id]: 2755980
[parent_id]: 2755843
[tags]: 
The conditions parameter needs to be a fragment of SQL. :conditions => ["when.wday=4"] is a fragment of Ruby code, so no go. Try # Model Event has a datetime field named 'when' Event.find(:all, :conditions => ["strftime('%w', events.when) = 4"]) SQLLite ref: http://www.sqlite.org/lang_datefunc.html Added: While more closely reading your post, I think you're planning to send multiple instance variables (one per day of the week) from your controller to your view. That's a good idea--moving logic out of the view. But , don't do more dbms queries! Each query has significant overhead. Eg: #Do NOT do it this way (too many db queries) @sunday_events = Event.find(:all, :conditions => ["strftime('%w', events.when) = 0"]) @monday_events = Event.find(:all, :conditions => ["strftime('%w', events.when) = 1"]) @thursday_events = Event.find(:all, :conditions => ["strftime('%w', events.when) = 4"]) # ... etc # Better: Just 1 database query-- events = Event.find(:all) @sunday_events = events.select{|e| e.when.wday == 0} @monday_events = events.select{|e| e.when.wday == 1} @thursday_events = events.select{|e| e.when.wday == 4} # ... etc Final comment: Current best practice thinking is to move code into the models from controllers wherever reasonable. This is called "Fat model, skinny controller" In the above example, you could have a class-level method in the model create the individual instance variables. Or perhaps better, one hash that contains 7 values, each being an array of the records. Eg # in Event model def Event.find_by_day events = Event.find(:all) result = {} days = [:sun, :mon, :tue, :wed, :thu, :fri, :sat] (0..6).each{|day_i| result[days[day_i]] = events.select{|e| e.when.wday == day_i} } result end # in controller @events = Event.find_by_day # in view # @events[:sun] is array of the Sunday events # so do something with them...
