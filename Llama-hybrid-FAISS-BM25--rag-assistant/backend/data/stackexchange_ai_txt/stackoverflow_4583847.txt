[site]: stackoverflow
[post_id]: 4583847
[parent_id]: 4583771
[tags]: 
The basic problem you have is that you release the synchronized block allowing both threads to go through the loop at the same time. This means either thread can obtain the lock in any order. AFAIK, The simplest solution is to use a flag. final int length = 10; final AtomicBoolean flag = new AtomicBoolean(); new Thread(new Runnable() { public void run() { for (int i=1;i The most elegant way to have this task done in sync is to have one thread. Threads are specificly designed to execute two tasks with as little dependence as possible between them. BTW If notifyAll() is called before wait() is called, the notify will be lost. wait() will wait forever. You create a Testing object you discard (remove it). You trap InterruptedException which you print and continue as if nothing happened (i.e. remove the nested catch)
