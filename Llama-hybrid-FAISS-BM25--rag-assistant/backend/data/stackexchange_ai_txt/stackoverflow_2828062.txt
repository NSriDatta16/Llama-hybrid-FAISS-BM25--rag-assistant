[site]: stackoverflow
[post_id]: 2828062
[parent_id]: 2798545
[tags]: 
but outside of a situation like that, In that case, first scan the file for your embedded code, and once you have those, parse your embedded code with a dedicated parser (without the noise before the and after the %> tags). ANTLR has the option to let the lexer parse just a (small) part of an input file and ignore the rest. Note that you cannot create a "combined grammar" (parser and lexer in one) in that case. Here's how you can create such a "partial lexer": // file EmbeddedCodeLexer.g lexer grammar EmbeddedCodeLexer; options{filter=true;} // '}?=> '%' // OR only match a `%` if `>` is not ahead of it )* // ) ' // match a close tag ; fragment String : '\'' ('\\' . | ~('\'' | '\\'))* '\'' ; If you now create a lexer from it: java -cp antlr-3.2.jar org.antlr.Tool EmbeddedCodeLexer.g and create a little test harness: import org.antlr.runtime.*; public class Main { public static void main(String[] args) throws Exception { String source = "Lorem ipsum dolor sit amet \n"+ " 1 && 10 % 3; \n"+ "print('consectetur %> adipiscing elit'); \n"+ "%> \n"+ "Phasellus volutpat dignissim sapien. \n"+ "foo bar \n"; ANTLRStringStream in = new ANTLRStringStream(source); EmbeddedCodeLexer lexer = new EmbeddedCodeLexer(in); CommonTokenStream tokens = new CommonTokenStream(lexer); for(Object o : tokens.getTokens()) { System.out.println("=======================================\n"+ "EmbeddedCode = "+((Token)o).getText()); } } } compile it all: javac -cp antlr-3.2.jar *.java and finally run the Main class by doing: // *nix/MacOS java -cp .:antlr-3.2.jar Main // Windows java -cp .;antlr-3.2.jar Main it will produce the following output: ======================================= EmbeddedCode = 1 && 10 % 3; print('consectetur %> adipiscing elit'); %> ======================================= EmbeddedCode =
