[site]: stackoverflow
[post_id]: 3290515
[parent_id]: 3286738
[tags]: 
There are multiple angles to approach your question. From a design POV it is always best to chose the datatype which expresses the quantity you want to model best. That is, get the data domain and data size right so that illegal data cannot be stored in the database in the first place. But that is not where MySQL is strong in the first place, and especially not with the default sql_mode ( http://dev.mysql.com/doc/refman/5.1/en/server-sql-mode.html ). If it works for you, try the TRADITIONAL sql_mode, which is a shorthand for many desireable flags. From a performance POV, the question is entirely different. For example, regarding the storage of email bodies, you might want to read http://www.mysqlperformanceblog.com/2010/02/09/blob-storage-in-innodb/ and then think about that. Removing redundancies and having short keys can be a big win. For example, in a project that I have seen, a log table has been storing http User-Agent information. By simply replacing each user agent string in the log table with a numeric id of a user agent string in a lookup table, data set size was considerably (more than 60%) reduced. By parsing the user agent further and then storing a bunch of ids (operating system, browser type, version index) data set size was reduced to 1% of the original size. Finally, there is a number of rules that can help you spot errors in schema design. For example, anything that has id in the name and is not an unsigned integer type is probably a bug (especially in the context of innodb). For example, anything that has price or cost in the name and is not unsigned is a potential source of fraud (fraudster creates article with negative price, and buys that). For example, anything that works on monetary data and is not using the DECIMAL data type of the appropriate size is probably doing math wrong (DECIMAL is doing BCD, decimal paper math with correct precision and rounding, DOUBLE and FLOAT do not).
