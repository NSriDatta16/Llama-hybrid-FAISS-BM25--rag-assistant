[site]: stackoverflow
[post_id]: 4256179
[parent_id]: 4255740
[tags]: 
It is rare that we get question design (I mean, interesting ones). Let's forget for a moment the (obviously) contrived example and concentrate on the notion. We have 2 solutions: Hard containment: pull in the header and build the object directly Soft containment: forward declare the header and use a pointer I'll voluntarily discard all "performances" argument for the moment. Performance doesn't matter 97% of the time (says Knuth) so unless we measure a noticeable difference, since the functionality is identical, we thus need not worry about it at the moment. We therefore have two orthogonal concepts attempting to sway our decision: Dependency make us lean toward Soft containment Simplicity make us lean toward Hard containment Some answers here have rightly spoken about polymorphism, but the exact implementation of Door is a detail that is Door 's concern, not Garage 's. If Door wishes to offer several implementations, that's fine, as long as its clients need not be concerned by this detail. I am quite a fanboy, myself, of the KISS and YAGNI principles. So I would argue in favor of Hard containment... with one caveat . When designing an interface that will be exposed, an interface therefore that stands at the frontier of the library, then this interface should expose a minimum of dependencies and internals. Ideally, this should be a Facade or a Proxy , an object whose only purpose is to hide the internals of the library, and this object should have minimal dependencies in its header and have maximal layout compatibility, which means: no virtual method a simple pointer as an attribute (Pimpl) For all internal classes, simplicity wins hands off.
