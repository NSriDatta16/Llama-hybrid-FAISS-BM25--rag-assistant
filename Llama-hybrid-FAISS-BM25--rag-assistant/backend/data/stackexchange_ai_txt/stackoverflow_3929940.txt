[site]: stackoverflow
[post_id]: 3929940
[parent_id]: 
[tags]: 
destroyFramebuffer method in an openGL app

in my OpenGL type of iphone app, I have this method below in the GLView implementation. i noticed everytime i started up the app during development that the last frame that was present when i shut the app down the last time, would draw first before the app started its animation... but when i commented out this method, the app would start up just fine without the old end frame from the last time. so i have something wrong in here. possibly directly in this method... any ideas? (now i'm getting a blank white screen (as a first frame) just before the animation, so something is amiss here) //------------------------------------------------------------------------------------ - (void)destroyFramebuffer { NSLog(@"destroyFramebuffer"); glDeleteFramebuffersOES(1, &viewFramebuffer); viewFramebuffer = 0; glDeleteRenderbuffersOES(1, &viewRenderbuffer); viewRenderbuffer = 0; if(depthRenderbuffer) { glDeleteRenderbuffersOES(1, &depthRenderbuffer); depthRenderbuffer = 0; } } here below is how the "createFrameBuffer" method looks (the way the GLView implementation was starting up was with these 3 lines): [EAGLContext setCurrentContext:context]; // [self destroyFramebuffer]; [self createFramebuffer]; //------------------------------------------------------------------------------------ - (BOOL)createFramebuffer { NSLog(@"createFramebuffer"); glGenFramebuffersOES(1, &viewFramebuffer); glGenRenderbuffersOES(1, &viewRenderbuffer); glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer); [context renderbufferStorage:GL_RENDERBUFFER_OES fromDrawable:(CAEAGLLayer*)self.layer]; glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, viewRenderbuffer); glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_WIDTH_OES, &backingWidth); glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_HEIGHT_OES, &backingHeight); if (USE_DEPTH_BUFFER) { glGenRenderbuffersOES(1, &depthRenderbuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, depthRenderbuffer); glRenderbufferStorageOES(GL_RENDERBUFFER_OES, GL_DEPTH_COMPONENT16_OES, backingWidth, backingHeight); glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_DEPTH_ATTACHMENT_OES, GL_RENDERBUFFER_OES, depthRenderbuffer); } if(glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES) != GL_FRAMEBUFFER_COMPLETE_OES) { NSLog(@"failed to make complete framebuffer object %x", glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES)); return NO; } return YES; }
