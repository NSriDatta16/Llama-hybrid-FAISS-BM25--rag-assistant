[site]: stackoverflow
[post_id]: 3888420
[parent_id]: 3888375
[tags]: 
Sure you can: var fooList = Activator .CreateInstance(typeof(List<>) .MakeGenericType(Foo.GetType())); The Problem here is that fooList is of type object so you still would have to cast it to a "usable" type. But what would this type look like? As a data structure supporting adding and looking up objects of type T List (or rather IList<> ) is not covariant in T so you cannot cast a List to a List where Foo: IFoo . You could cast it to an IEnumerable which is covariant in T . If you are using C# 4.0 you could also consider casting fooList to dynamic so you can at least use it as a list (e.g. add, look-up and remove objects). Considering all this and the fact, that you don't have any compile-time type safety when creating types at runtime anyhow, simply using a List is probably the best/most pragmatic way to go in this case.
