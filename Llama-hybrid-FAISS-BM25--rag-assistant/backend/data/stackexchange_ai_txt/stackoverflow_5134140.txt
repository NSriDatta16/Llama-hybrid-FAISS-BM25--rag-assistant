[site]: stackoverflow
[post_id]: 5134140
[parent_id]: 
[tags]: 
The type of positioning is really affecting my JavaScript

I'm currently making a drag-and-drop JavaScript engine. I'm currently making a "bounding" feature, so that the drag-object is bounded by a container with the class .bound . When I make the drag-object, I also find out if it has bounds: function makeObj(e) { obj = new Object(); obj.element = e; obj.boundX = e.parentNode.offsetWidth - e.offsetWidth; obj.boundY = e.parentNode.offsetHeight - e.offsetHeight; obj.posX = event.clientX - e.offsetLeft; obj.posY = event.clientY - e.offsetTop; var curleft = curtop = 0; if (e.offsetParent) { do { curleft += e.offsetLeft; curtop += e.offsetTop; //alert(e.id + ":" + e.innerHTML); if(~e.className.search(/bound/)) { obj.boundX = curleft - obj.element.offsetLeft; obj.boundY = curtop - obj.element.offsetTop; return obj; } } while (e = e.offsetParent); } return obj; } My loops work, however setting the bounds does not. I would like this html to affect the function: Hello World! One Two As much as this html: Hello World! One Two The difference is the .bound class, which has position: relative set. Here is the CSS: @charset "utf-8"; /* CSS Document */ * { padding: 0px; margin: 0px; } .drag { position: absolute; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .bound { position: relative; } .square { width: 100px; height: 100px; background: red; cursor:move; } #center { width: 500px; height: 300px; margin: auto; margin-top: 50px; background-color:#ccc; text-align: center; border-radius: 25px; -moz-border-radius: 25px; } #box { background-color: #FF3; height: 278px; border-radius: 0 0 25px 25px; -moz-border-radius: 0 0 25px 25px; opacity: 0.5; } How do I make it so the position: attribute doesn't affect how the engine works- So that any position will work. Absolute, Relative, Static, ect? How can I make my .drag objects have any kind of positioning besides absolute? I will post the entire engine below (and a jsfiddle link) just in case it is useful: http://jsfiddle.net/Upvdm/1/ // JavaScript Document var dragObj; document.addEventListener("mousedown", down, false); function down(event) { if(~event.target.className.search(/drag/)) { dragObj = makeObj(event.target); dragObj.element.style.zIndex="100"; document.addEventListener("mousemove", freeMovement, false); } } function freeMovement(event) { if (typeof(dragObj.element.mouseup) == "undefined") document.addEventListener("mouseup", drop, false); //Prevents redundantly adding the same event handler repeatedly dragObj.element.style.left = Math.max(0, Math.min(event.clientX - dragObj.posX, dragObj.boundX)) + "px"; dragObj.element.style.top = Math.max(0, Math.min(event.clientY - dragObj.posY, dragObj.boundY)) + "px"; } function drop() { dragObj.element.style.zIndex="1"; document.removeEventListener("mousemove", freeMovement, false); document.removeEventListener("mouseup", drop, false); //alert("DEBUG_DROP"); } function makeBoundlessObj(e) { obj = new Object(); obj.element = e; obj.boundX = e.parentNode.offsetWidth - e.offsetWidth; obj.boundY = e.parentNode.offsetHeight - e.offsetHeight; obj.posX = event.clientX - e.offsetLeft; obj.posY = event.clientY - e.offsetTop; return obj; } function makeObj(e) { obj = new Object(); obj.element = e; obj.boundX = e.parentNode.offsetWidth - e.offsetWidth; obj.boundY = e.parentNode.offsetHeight - e.offsetHeight; obj.posX = event.clientX - e.offsetLeft; obj.posY = event.clientY - e.offsetTop; var curleft = curtop = 0; if (e.offsetParent) { do { curleft += e.offsetLeft; curtop += e.offsetTop; //alert(e.id + ":" + e.innerHTML); if(~e.className.search(/bound/)) { obj.boundX = curleft - obj.element.offsetLeft; obj.boundY = curtop - obj.element.offsetTop; return obj; } } while (e = e.offsetParent); } return obj; } function findPos(obj) { // Donated by `lwburk` on StackOverflow var curleft = curtop = 0; if (obj.offsetParent) { do { curleft += obj.offsetLeft; curtop += obj.offsetTop; } while (obj = obj.offsetParent); return { x: curleft, y: curtop }; } } Thank you so much for reading and helping!
