[site]: stackoverflow
[post_id]: 4200705
[parent_id]: 4200595
[tags]: 
For the second question, I'd like to know why! To answer point 2, keeping declarations in a header file helps you avoid situations like the following. You decide that you need to keep track of your chickens in file.c : int number_of_chickens; In file2.c , you decide that it would be a great idea to represent the number of chickens as a double instead of an int, but you forget to update file.c : extern double number_of_chickens; double count_chickens() { return number_of_chickens; } void add_to_chickens(double how_many) { number_of_chickens += how_many; } This will compile just fine. The linker will treat number_of_chickens as a name referencing a 4 bit int in file.c , and an 8 bit double in file2.c . If you call the count_chickens function, it will return garbage (the high 32 bits of the double will be filled in with the contents of int number_of_chickens , the low 32 bits will be undefined - whatever comes after number_of_chickens in memory). Even worse, when you call add_to_chickens(1) in file2.c , you will write 8 bytes to a 4 byte storage location, surely causing havoc, but not necessarily causing a runtime error (at least, not right away). If you keep your external declaration in a common header file, you get a compile time error immediately. If you don't, you instead get an unexplained instability 3 months after you ship.
