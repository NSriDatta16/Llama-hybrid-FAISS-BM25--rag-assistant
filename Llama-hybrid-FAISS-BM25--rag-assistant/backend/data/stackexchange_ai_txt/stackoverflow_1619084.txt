[site]: stackoverflow
[post_id]: 1619084
[parent_id]: 1453485
[tags]: 
I'm gonna work on this, though not formally trained and really don't care if it is homework as what op asks is determining "what algorithm" which for me ( as the poster frames the work ) is "no wait state" programming involving execution tuples - exactly the sort of thing that systems programming has to address inter-alia 1) Algorithm predicts maximum execution time of this routine. One has to determine the dataset size and as well the "O" of the data structure applied to the dataset. That can involve "degenerate cases" ( things one did not plan for ) that wreck havoc at un-anticipated moments. Thus, without further details, one chooses a good "general case" approach that has known failure modes and will recover without a "weekend ruined" Robert Sedgewick has the most advanced work I am able to gain any progress with - the work is very clearly written addressing the sort of questions you ask. 2) Thread which call this routine at beginning set unique reference, what mean that is inside of this routine. Some language barriers here but I am going to guess what you are asking is that a code execution path ( sequence of instructions ) starts with a "unique" "reference" to it's dataset - thus, a unique reference means exactly that - so we just re-read the definition of that in a standard dictionary. ( no intent to be trite, that's just what I see here ) 3) Other threads which are calling the same routine check this reference and if is set than count the CPU tick count (measure time) of first involved thread. If that time is to long interrupt the current work of involved thread and overrides him job. Reference counting. Well studied - just keep reading and coding. Work it out. Interrupting an overdue thread completion is fraught with unseen failure modes. To be truthful, doing real scheduling ( of threads or process ) is only done correctly in hardware that is designed to accommodate that task. Your "assembly optimization" post works at a level where this can be done. I suggest study of the "AVL" Zero-Page algorithm. At some point, the processor and the sequence of instructions doing the scheduling will - by the definition of the problem - need to obtain exclusive locking on some value -> the trick in general is not to have two threads attempting to obtain two items to lock on without interference from another instruction pointer. This can be challenging, especially so when non-programmers have authority over the programming shop -> that has led to disaster again and again. 4) Thread which not finished job because was interrupted from task scheduler (is reposed) at the end check the reference if not belongs to him repeat the job again. This is the task of the scheduler.
