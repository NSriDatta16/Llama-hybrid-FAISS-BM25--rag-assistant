[site]: stackoverflow
[post_id]: 3687554
[parent_id]: 3687539
[tags]: 
When you call exit() , the destructors of automatic objects (local variables) do not get called. In your specific example, the std::string destructor is not called, so the memory owned by the std::string is never deallocated. The reason there is no leak if you have fail() take a const char* is that there is no destructor for const char* ; nothing is deallocated when a pointer is destroyed. If the pointer points to dynamically allocated memory, then that memory must be deallocated (by you) before the program exits, otherwise you have a memory leak. If it points to a string literal, then there is no memory leak because string literals have static storage duration (that is, they exist for the entire lifetime of your program).
