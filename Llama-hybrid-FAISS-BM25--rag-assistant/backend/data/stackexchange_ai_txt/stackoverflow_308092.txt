[site]: stackoverflow
[post_id]: 308092
[parent_id]: 308061
[tags]: 
This isn't a matter of OO principles in my view - it's up to the platform in question how it handles this particular conundrum. Calling a virtual method from a constructor is discouraged for precisely this reason, however - if you're going to do it, you need to document very explicitly that you're going to call it, so that any class overriding it knows what to expect. Java takes the same approach as .NET except that in C# any instance variable initializers are executed before the base constructor call is made. This means that in your particular example, you can fix the code by initializing random at the point of declaration. In Java that wouldn't help. As for why MC++ doesn't work this way, I don't know - I suggest you compare the IL generated. My guess is that it explicitly makes a non-virtual method call. EDIT: I suspect I misread the question - which way does MC++ work? If it works the way C# works, that's a good thing IMO, providing a consistent view across the .NET platform.
