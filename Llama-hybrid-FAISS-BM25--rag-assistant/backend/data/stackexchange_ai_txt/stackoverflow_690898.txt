[site]: stackoverflow
[post_id]: 690898
[parent_id]: 689439
[tags]: 
I would presume that the answer lies in prefetching the associations that you want to. That way you can fetch the needed part of your object graph in a single shot. You would do this in criteria queries like so. ICriteria query = session.CreateCriteria(typeof (Cat)) .SetFetchMode("Mate", FetchMode.Join) .SetFetchMode("Kittens", FetchMode.Join); IList results = query.List (); This will give you back a list of cats with both the Mate and the Kittens prepopulated. You can then navigate to these properties without incurring an N+1 penalty. If you need a more flattened result I'd do it using linq, perhaps like this. var results = query.List () .Select((c) => new {mother = c, mate = c.Mate, offspr = c.Kittens}); This will give you back a flattened list of anonymous types with the given properties. This will work if all you need is prefetching the object graph. However if you need to prefetch things such as counts or sums then you will need to examine the Projections and Alias parts of Criteria queries. One more thing. If you are trying to exactly duplicate your above query, you can do so like this. ICriteria query = session.CreateCriteria(typeof (Cat), "mother") .CreateAlias("Mate", "mate", JoinType.InnerJoin) .CreateAlias("Kittens", "offspr", JoinType.LeftOuterJoin) .SetResultTransformer(Transformers.AliasToEntityMap); This will return you basically the same as your hql query, however instead of using an indexed list it will use a dictionary that maps the alias to the entity.
