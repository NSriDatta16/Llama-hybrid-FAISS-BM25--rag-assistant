[site]: stackoverflow
[post_id]: 1581556
[parent_id]: 1554956
[tags]: 
Here's how I tend to solve problems like this: manually pull our the data you want to show (calling the repository methods, not using ObjectDataSource to do it). For efficiency, it often makes sense to make one big query which returns denormalized records, each containing all the columns you'll need (e.g. SELECT TimeSlot, CustomerName, ContractorName FROM (joins go here) ... ) create a custom collection class which puts that data into a format which is easy to data-bind. "easy to data bind" usually means that the data is organized in the same order that you're going to display it. You also might need to do hacks like, for example, making all your rows the same length in order to databind the same number of table cells per row. in your data-binding expressions, cast Container.DataItem to whatever type you need, in order to pull out properties of that type. This also has the added advantage of making databinding expressions with typos fail at compile time rather than waiting until runtime to find bugs. for nesting, set the DataSource property of a nested template control (e.g. a repeater) to a property of the parent Container.DataItem for header rows, here's a trick: put header code directly into the ItemTemplate, and use Container.ItemIndex==0 to know when to show the header line or not. Since only Repeater (but not ListView) supports the ItemIndex property, I tend to use Repeater instead of ListView for most read-only data-binding tasks. That's why I changed your ListView in my code sample below to use Repeater. The same thing can be done by adding an Index or RowNumber property to your custom data-binding classes described above, but that's harder. The general idea is that you want to push as much intelligence as possible out of your databinding code and into actual methods in your page (or code-behind) code, which is easier to write and debug. Here's a working sample (with your classes and repository classes mocked up) to give you an idea what I'm talking about. You should be able to adapt this to your situation. public class Person // replace with your class { public string person_name {get; set;} } public class Repository // replace with your class { public static IEnumerable GetCustomerByDateCategory() { // fake some data return new Record[] { new Record { Time = new DateTime(2000, 1, 1, 8, 0, 0), Contractor = new Person {person_name = "Joe the Plumber"}, Customer = new Person {person_name = "Joe Smith"} }, new Record { Time = new DateTime(2000, 1, 1, 8, 30, 0), Contractor = new Person {person_name = "Bob Vila"}, Customer = new Person {person_name = "Frank Johnson"} }, new Record { Time = new DateTime(2000, 1, 1, 8, 30, 0), Contractor = new Person {person_name = "Mr. Clean"}, Customer = new Person {person_name = "Elliott P. Ness"} }, }; } public class Record // replace this class with your record's class { public DateTime Time {get; set;} public Person Contractor { get; set; } public Person Customer { get; set; } } } // key = time, value = ordered (by contractor) list of customers in that time slot public class CustomersByTime : SortedDictionary > { public List Contractors { get; set; } public CustomersByTime (IEnumerable records) { Contractors = new List (); foreach (Repository.Record record in records) { int contractorIndex = Contractors.FindIndex(p => p.person_name == record.Contractor.person_name); if (contractorIndex == -1) { Contractors.Add(record.Contractor); contractorIndex = Contractors.Count - 1; } List customerList; if (!this.TryGetValue(record.Time, out customerList)) { customerList = new List (); this.Add(record.Time, customerList); } while (customerList.Count max) max = value.Count; } foreach (var value in this.Values) { while (value.Count td, th, table { border:solid 1px black; border-collapse:collapse;} " DataSource=" " > Times >)(Container.DataItem)).Key.ToShortTimeString() %> >)(Container.DataItem)).Value %>"> BTW, if you're building a brand-new app and have some time for learning, I definitely suggest looking at ASP.NET MVC, which has a non-trivial learning curve but makes a lot of things easier... in partiuclar this kind of complex data rendering.
