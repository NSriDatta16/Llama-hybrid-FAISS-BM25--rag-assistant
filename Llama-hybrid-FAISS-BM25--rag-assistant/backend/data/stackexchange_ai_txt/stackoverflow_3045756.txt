[site]: stackoverflow
[post_id]: 3045756
[parent_id]: 3045482
[tags]: 
As already stated errors were two: you used an int that is not big enough to hold that sum.. you should have used a long you used instead that , and it was a wrong guard for the cycle Apart from that what you are doing is really inefficient, without going too deep inside this class of algorithms (like Miller-Rabin test) I would suggest you to take a look to the Sieve of Eratosthenes .. a really old approach that teaches how to treat a complex problem in a simple manner to improve elegance and efficiency with a trade-off of memory. It's really cleaver: it keeps track of a boolean value for every prime up to your 2 millions that asserts if that number is prime or not. Then starting from the first prime it excludes all the successive numbers that are obtained by multiplying the prime it is analyzing for another number. Of couse more it goes and less numbers it will have to check (since it already excluded them) Code is fair simple (just wrote it on the fly, didn't check it): boolean[] numbers = new boolean[2000000]; long sum = 0; for (int i = 0; i Of course this approach is still unsuitable for high numbers (because it has to find all the previous primes anyway and because of memory) but it's a good example for starters to think about problems..
