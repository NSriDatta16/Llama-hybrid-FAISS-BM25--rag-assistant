[site]: stackoverflow
[post_id]: 5629346
[parent_id]: 1028858
[tags]: 
Create everything for an event Since events are kinda a pain to create in Java--all those interfaces, methods, and stuff to write just for 1 event--I made a simple template to create everything needed for 1 event. ${:import(java.util.List, java.util.LinkedList, java.util.EventListener, java.util.EventObject)} private final List ${eventname}Listeners = new LinkedList (); public final void add${eventname}Listener(${eventname}Listener listener) { synchronized(${eventname}Listeners) { ${eventname}Listeners.add(listener); } } public final void remove${eventname}Listener(${eventname}Listener listener) { synchronized(${eventname}Listeners) { ${eventname}Listeners.remove(listener); } } private void raise${eventname}Event(${eventname}Args args) { synchronized(${eventname}Listeners) { for(${eventname}Listener listener : ${eventname}Listeners) listener.on${eventname}(args); } } public interface ${eventname}Listener extends EventListener { public void on${eventname}(${eventname}Args args); } public class ${eventname}Args extends EventObject { public ${eventname}Args(Object source${cursor}) { super(source); } } If you have events that share a single EventObject , just delete the customized one inserted by the template and change the appropriate parts of raise___() and on____() . I had written a nice, little, elegant eventing mechanism using a generic interface and generic class, but it wouldn't work due to the way Java handles generics. =( Edit : 1) I ran into the issue where threads were adding/removing listeners while an event was taking place. The List can't be modified while in use, so I added synchronized blocks where the list of listeners is being accessed or used, locking on the list itself.
