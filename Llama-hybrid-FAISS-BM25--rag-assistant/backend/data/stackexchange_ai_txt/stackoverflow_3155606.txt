[site]: stackoverflow
[post_id]: 3155606
[parent_id]: 3065485
[tags]: 
What to test There are a couple of really useful concepts that helped me work this out: http://en.wikipedia.org/wiki/Equivalence_partitioning http://en.wikipedia.org/wiki/Boundary-value_analysis Equivalence partitioning says "Running the test in this context with these events is equivalent to this other test over here, so I don't need to do both." Boundary analysis says "Here's the point at which a change in context or a different event causes a different outcome, so I will want tests on either side of this boundary." Thinking about these can really help to minimize the number of tests you need to write. When to test I always manually test my code to make sure that it works. I often write an additional unit test which covers every line of code I'm about to write. The unit test fails before I write the code to make it pass. If it's something a user will do, then I often write an acceptance test or automated scenario, too. Automated testing Automated testing means either scripting or recording a test so that you don't have to do it manually - your script or code will do it for you. There are two kinds of automation tools: BDD- or English-readable acceptance-testing fixtures which let you write the scripts, and automation wrappers which let you automate more easily. So for instance, you might choose to use GivWenZen or Fitnesse as your fixture, and Selenium as your web automation tool. If you've got Visual Studio 2008+ you could download the source code from here and try out the scenario to see it run: http://code.google.com/p/wipflash/ Unit testing In its strictest sense, Unit Testing means testing an element of code in isolation from all other elements of code. We use mocks in place of real pieces of code that our Code Under Test requires. In reality we are often pragmatic about the nature of "units" - I don't mock out domain objects, for instance. However, unit testing in the way that most people use it isn't really about testing. Mostly it's a mechanism for achieving clean design and separation of responsibilities, because you're forced into this by trying to test it. I like to think of unit testing as "writing an example of how I'm going to use the code I'm about to write". The example happens to reside in a unit-testing framework and be executable. Testing frameworks Unit-testing frameworks help you to run a lot of tests together. Acceptance-testing frameworks help you to run a larger scenario and are often English-readable. Automation frameworks usually sit underneath your English-readable frameworks and help you to interact with an application. Good luck!
