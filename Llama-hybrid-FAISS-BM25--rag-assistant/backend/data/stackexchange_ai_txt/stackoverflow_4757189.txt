[site]: stackoverflow
[post_id]: 4757189
[parent_id]: 4741710
[tags]: 
Answering my own question. The root cause of my problem is a couple of things in HibernateTransactionManager. The setting 'autodetectDataSource' which defaults to true In afterPropertiesSet() with the above true it auto-detects the DataSource from the SessionFactory In doBegin() if the DataSource is not null it will bind new transactions to the SessionFactory AND the DataSource This is causing my problem because also I have a new DataSourceTransactionManager it still uses the same underlying storage (TransactionSynchronizationManager) to manage transactions and because both use the DataSource you get this leaking of transactions between txn managers. I might argue that a txn manager should include its own 'key/id' in the key for the transactional resources so there are independent but it doesn't appear to do that. The response above are sensible. Using the hibernate txn manager rather than creating a new DataSourceTransactionManager and then using REQURES_NEW would solve the problem. However in my case that would introduce a circular dependency between HTM -> SessionFactory -> IdAllocator -> HTM. I came up a solution that works but isn't the most elegant thing ever. When constructor the id allocator it is passed a DataSource in the constructor. I simply wrap that DataSource in a delegating wrapper that is 100% pass through. This changes the DataSource reference so the txn logic does not think there is a transaction in progress and works as I want it to.
