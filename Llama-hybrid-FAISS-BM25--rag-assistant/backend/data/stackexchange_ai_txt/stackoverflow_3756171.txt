[site]: stackoverflow
[post_id]: 3756171
[parent_id]: 
[tags]: 
error C2664 : 'void std::vector ::push_back(_Ty&&)': cannot convert parameter 1 from 'Node *' to 'Node &&'

error C2664 : 'void std::vector ::push_back(_Ty&&)': cannot convert parameter 1 from 'Node *' to 'Node&&' please I need help... I created node.h & heap.h node.h : #ifndef __NODE_H_ #define __NODE_H_ #include #include using namespace std; template class Node { private: Node * m_brother; int m_index; T m_data; public: Node (T data); ~Node (); int GetIndex () const; int GetBrother () const; void SetIndex (const int index); void SetBrother (const Node * brother); void SetData (const T& data); bool operator & other) const; }; template Node ::Node(T data) { SetData(data); } template int Node ::GetIndex () const { return m_index; } template int Node ::GetBrother () const { return m_brother->GetIndex(); } template void Node ::SetData (const T& data) { m_data = data; } template void Node ::SetBrother(const Node * brother) { m_brother = brother; } template void Node ::SetIndex(const int index) { if (index > 0) m_index = index; else cout bool Node :: operator & other)const { return *(this->GetData()) > *(other.GetData()); } #endif heap.h: #ifndef __HEAP_H_ #define __HEAP_H_ #pragma once #include #include "Node.h" using namespace std; template class Heap { public: Heap(); virtual ~Heap(); Node * CreateNode (T data); bool IsEmpty() const; Node * RemoveNode(int indexNode); Node * ExtractMin (); //void AddToHeap(Node * newNode); //void Add(int indexNode); void Insert(Node * newNode); void DecreaseKey (Node * newNode); void Exchange (int indexNode1, int indexNode2); void MinHeapify (int indexNode); private: vector > m_heap; int num; }; template Heap ::Heap() { } template Heap ::~Heap() { } template Node * Heap ::CreateNode(T data) { Node * node(T); return node; } template bool Heap ::IsEmpty() const { return (m_heap.size() == 0); } template Node * Heap ::RemoveNode (int indexNum) { Node * nodeToRemove=NULL; if (indexNum > 0 && indexNum GetIndex()); } return nodeToRemove; } template void Heap ::Insert(Node * newNode) { if (m_heap.size() == 0) { m_heap.push_back(newNode); } else DecreaseKey(newNode); } template void Heap ::DecreaseKey(Node * newNode) { m_heap.push_back(newNode); int index = m_heap.size(); while ((index > 0) && (m_heap[(index/2)-1] > m_heap[index-1])) { Exchange(index,index/2); index = index/2; } } template Node * Heap ::ExtractMin () { Node * minNode; minNode = m_heap[0]; m_heap[0] = m_heap[m_heap.size()-1]; m_heap.erase(m_heap[m_heap.size()-1]); MinHeapify (0); return minNode; } template void Heap ::Exchange (int indexNode1, int indexNode2) { Node * tmp = m_heap[indexNode1-1]; m_heap[indexNode1-1] = m_heap [indexNode2-1]; m_heap[indexNode2-1] = tmp; } template void Heap ::MinHeapify (int indexNode) { int leftNode = 2*indexNode; int rightNode = 2*indexNode+1; int smallest = indexNode; if ((leftNode In the main, I tried to check and it didn't compiled. int main () { Node a(car1); Heap heap; Node * p = &a; heap.Insert(p); return 0; } why?
