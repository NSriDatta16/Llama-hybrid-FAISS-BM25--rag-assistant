[site]: stackoverflow
[post_id]: 1717766
[parent_id]: 
[tags]: 
Self-Joins, Cross-Joins and Grouping

I've got a table of temperature samples over time from several sources and I want to find the minimum, maximum, and average temperatures across all sources at set time intervals. At first glance this is easily done like so: SELECT MIN(temp), MAX(temp), AVG(temp) FROM samples GROUP BY time; However, things become much more complicated (to the point of where I'm stumped!) if sources drop in and out and rather than ignoring the missing sources during the intervals in question I want to use the sources' last know temperatures for the missing samples. Using datetimes and constructing intervals (say every minute) across samples unevenly distributed over time further complicates things. I think it should be possible to create the results I want by doing a self-join on the samples table where the time from the first table is greater than or equal to the time of the second table and then calculating aggregate values for rows grouped by source. However, I'm stumped about how to actually do this. Here's my test table: +------+------+------+ | time | source | temp | +------+------+------+ | 1 | a | 20 | | 1 | b | 18 | | 1 | c | 23 | | 2 | b | 21 | | 2 | c | 20 | | 2 | a | 18 | | 3 | a | 16 | | 3 | c | 13 | | 4 | c | 15 | | 4 | a | 4 | | 4 | b | 31 | | 5 | b | 10 | | 5 | c | 16 | | 5 | a | 22 | | 6 | a | 18 | | 6 | b | 17 | | 7 | a | 20 | | 7 | b | 19 | +------+------+------+ INSERT INTO samples (time, source, temp) VALUES (1, 'a', 20), (1, 'b', 18), (1, 'c', 23), (2, 'b', 21), (2, 'c', 20), (2, 'a', 18), (3, 'a', 16), (3, 'c', 13), (4, 'c', 15), (4, 'a', 4), (4, 'b', 31), (5, 'b', 10), (5, 'c', 16), (5, 'a', 22), (6, 'a', 18), (6, 'b', 17), (7, 'a', 20), (7, 'b', 19); To do my min, max and avg calculations, I want an intermediate table that looks like this: +------+------+------+ | time | source | temp | +------+------+------+ | 1 | a | 20 | | 1 | b | 18 | | 1 | c | 23 | | 2 | b | 21 | | 2 | c | 20 | | 2 | a | 18 | | 3 | a | 16 | | 3 | b | 21 | | 3 | c | 13 | | 4 | c | 15 | | 4 | a | 4 | | 4 | b | 31 | | 5 | b | 10 | | 5 | c | 16 | | 5 | a | 22 | | 6 | a | 18 | | 6 | b | 17 | | 6 | c | 16 | | 7 | a | 20 | | 7 | b | 19 | | 7 | c | 16 | +------+------+------+ The following query is getting me close to what I want but it takes the temperature value of the source's first result, rather than the most recent one at the given time interval: SELECT s.dt as sdt, s.mac, ss.temp, MAX(ss.dt) as maxdt FROM (SELECT DISTINCT dt FROM samples) AS s CROSS JOIN samples AS ss WHERE s.dt >= ss.dt GROUP BY sdt, mac HAVING maxdt Update: chadhoc (great name, by the way!) gives a nice solution that unfortunately does not work in MySQL, since it does not support the FULL JOIN he uses. Luckily, I believe a simple UNION is an effective replacement: -- Unify the original samples with the missing values that we've calculated ( SELECT time, source, temp FROM samples ) UNION ( -- Pull all the time/source combinations that we are missing from the sample set, along with the temp -- from the last sampled interval for the same time/source combination if we do not have one SELECT a.time, a.source, (SELECT t2.temp FROM samples AS t2 WHERE t2.time Update 2: MySQL gives the following EXPLAIN output for chadhoc's code: +----+--------------------+------------+------+---------------+------+---------+------+------+-----------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+--------------------+------------+------+---------------+------+---------+------+------+-----------------------------+ | 1 | PRIMARY | temp | ALL | NULL | NULL | NULL | NULL | 18 | | | 2 | UNION | | ALL | NULL | NULL | NULL | NULL | 21 | | | 2 | UNION | s | ALL | NULL | NULL | NULL | NULL | 18 | Using where | | 4 | DERIVED | | ALL | NULL | NULL | NULL | NULL | 3 | | | 4 | DERIVED | | ALL | NULL | NULL | NULL | NULL | 7 | | | 6 | DERIVED | temp | ALL | NULL | NULL | NULL | NULL | 18 | Using temporary | | 5 | DERIVED | temp | ALL | NULL | NULL | NULL | NULL | 18 | Using temporary | | 3 | DEPENDENT SUBQUERY | t2 | ALL | NULL | NULL | NULL | NULL | 18 | Using where; Using filesort | | NULL | UNION RESULT | | ALL | NULL | NULL | NULL | NULL | NULL | Using filesort | +----+--------------------+------------+------+---------------+------+---------+------+------+-----------------------------+ I was able to get Charles' code working like so: SELECT T.time, S.source, COALESCE( D.temp, ( SELECT temp FROM samples WHERE source = S.source AND time = ( SELECT MAX(time) FROM samples WHERE source = S.source AND time Its explanation is: +----+--------------------+------------+------+---------------+------+---------+------+------+-----------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+--------------------+------------+------+---------------+------+---------+------+------+-----------------+ | 1 | PRIMARY | | ALL | NULL | NULL | NULL | NULL | 3 | | | 1 | PRIMARY | | ALL | NULL | NULL | NULL | NULL | 7 | | | 1 | PRIMARY | D | ALL | NULL | NULL | NULL | NULL | 18 | | | 5 | DERIVED | temp | ALL | NULL | NULL | NULL | NULL | 18 | Using temporary | | 4 | DERIVED | temp | ALL | NULL | NULL | NULL | NULL | 18 | Using temporary | | 2 | DEPENDENT SUBQUERY | temp | ALL | NULL | NULL | NULL | NULL | 18 | Using where | | 3 | DEPENDENT SUBQUERY | temp | ALL | NULL | NULL | NULL | NULL | 18 | Using where | +----+--------------------+------------+------+---------------+------+---------+------+------+-----------------+
