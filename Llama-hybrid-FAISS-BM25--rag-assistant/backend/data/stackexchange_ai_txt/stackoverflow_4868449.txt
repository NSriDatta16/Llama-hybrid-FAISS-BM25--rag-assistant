[site]: stackoverflow
[post_id]: 4868449
[parent_id]: 
[tags]: 
C++ : Why isn't my call to "std::uninitialized_copy" working?

I building a simple class that is supposed to mimic the functionality of the std::string class (as an exercise!): #ifndef _STR12_1_H #define _STR12_1_H #include #include class Str12_1 { public: typedef char* iterator; typedef const char* const_iterator; typedef long size_type; Str12_1(); Str12_1(const Str12_1& str); Str12_1(const char *p); Str12_1(const std::string& s); size_type size() const; //Other member functions private: iterator first; iterator onePastLast; iterator onePastAllocated; }; In order to avoid the overhead associated with "new" (and to increase my familiarity with the header), i've opted to use the library's allocator template class to allocate memory for my string. Here is an example of my use of it in the copy constructor: #include #include using std::allocator; using std::raw_storage_iterator; using std::uninitialized_copy; Str12_1::Str12_1(const Str12_1& str) { allocator charAlloc; first = charAlloc.allocate(str.size()); onePastLast = onePastAllocated = first + str.size(); *onePastLast = '\0'; raw_storage_iterator it(first); uninitialized_copy(str.first, str.onePastLast, it); } The compiler keeps telling me two errors on the "uninitialized_copy" line which both lead back to headers in the library, : error: invalid conversion from 'char' to 'char*' error: no match for 'operator!=' in '__first != __last' The problem is that I don't understand where on that line the conversion from char to char* is, and why two pointers of the same type (str.first, str.onePastLast) cannot be compared with "!=". I could use "new", but as stated before, I want to get practice with . So can someone tell me why this isn't working?
