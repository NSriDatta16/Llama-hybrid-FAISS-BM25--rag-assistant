[site]: stackoverflow
[post_id]: 4960125
[parent_id]: 
[tags]: 
AudioRecord PCM data of no use?

I have recorded using the Mic in my android app and this plays perfectly well when using the AudioPlayer class having streamed the data in. My problem is I want to append a wav header to this data so it can be played outside of the application. I am pretty sure the methods to create the header work after playing around in a hex editor with other audio files, which leads to the pcm data recorded to not being useful as raw data in a wav file? Can anybody shed any light on this? I can import the pcm/wav file into audacity as a raw file and it plays perfectly but when I try it as just opening the wav I just get noise, again hinting the pcm data is at fault. Recording Settings: int frequency = 22050; int channelConfiguration = AudioFormat.CHANNEL_CONFIGURATION_MONO; int audioEncoding = AudioFormat.ENCODING_PCM_16BIT; Header Variables: byte[] clipData = data; long myDataSize = clipData.length; long mySubChunk1Size = 16; int myBitsPerSample= 16; int myFormat = 1; long myChannels = 1; long mySampleRate = 22050; long myByteRate = mySampleRate * myChannels * myBitsPerSample/8; int myBlockAlign = (int) (myChannels * myBitsPerSample/8); long myChunk2Size = myDataSize * myChannels * myBitsPerSample/8; long myChunkSize = 36 + myChunk2Size; try { File audioDirectory = new File(Environment .getExternalStorageDirectory().getAbsolutePath() + "/Directory/"); audioDirectory.mkdir(); File file = new File(audioDirectory, "test.wav"); if (file.exists()) file.delete(); // Create the new file. try { file.createNewFile(); } catch (IOException e) { throw new IllegalStateException("Failed to create " + file.toString()); } OutputStream os = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(os); DataOutputStream outFile = new DataOutputStream(bos); // write the wav file per the wav file format outFile.writeBytes("RIFF"); // 00 - RIFF outFile.write(intToByteArray((int)myChunkSize), 0, 4); // 04 - how big is the rest of this file? outFile.writeBytes("WAVE"); // 08 - WAVE outFile.writeBytes("fmt "); // 12 - fmt outFile.write(intToByteArray((int)mySubChunk1Size), 0, 4); // 16 - size of this chunk outFile.write(shortToByteArray((short)myFormat), 0, 2); // 20 - what is the audio format? 1 for PCM = Pulse Code Modulation outFile.write(shortToByteArray((short)myChannels), 0, 2); // 22 - mono or stereo? 1 or 2? (or 5 or ???) outFile.write(intToByteArray((int)mySampleRate), 0, 4); // 24 - samples per second (numbers per second) outFile.write(intToByteArray((int)myByteRate), 0, 4); // 28 - bytes per second outFile.write(shortToByteArray((short)myBlockAlign), 0, 2); // 32 - # of bytes in one sample, for all channels outFile.write(shortToByteArray((short)myBitsPerSample), 0, 2); // 34 - how many bits in a sample(number)? usually 16 or 24 outFile.writeBytes("data"); // 36 - data outFile.write(intToByteArray((int)myDataSize), 0, 4); // 40 - how big is this data chunk outFile.write(clipData); // 44 - the actual data itself - just a long string of numbers } Convertors public static int byteArrayToInt(byte[] b) { int start = 0; int low = b[start] & 0xff; int high = b[start+1] & 0xff; return (int)( high > 8) & 0x000000FF); b[2] = (byte) ((i >> 16) & 0x000000FF); b[3] = (byte) ((i >> 24) & 0x000000FF); return b; } // convert a short to a byte array public static byte[] shortToByteArray(short data) { return new byte[]{(byte)(data & 0xff),(byte)((data >>> 8) & 0xff)}; }
