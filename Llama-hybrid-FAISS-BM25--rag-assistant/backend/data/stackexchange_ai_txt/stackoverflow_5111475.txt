[site]: stackoverflow
[post_id]: 5111475
[parent_id]: 4787431
[tags]: 
The code by @Slaks gives you only the instantaneous FPS of the last frame, which may vary or be misleading with hiccups. I prefer to use an easy-to-write-and-compute low-pass filter to remove quick transients and display a reasonable pseudo-average of recent results: // The higher this value, the less the fps will reflect temporary variations // A value of 1 will only keep the last value var filterStrength = 20; var frameTime = 0, lastLoop = new Date, thisLoop; function gameLoop(){ // ... var thisFrameTime = (thisLoop=new Date) - lastLoop; frameTime+= (thisFrameTime - frameTime) / filterStrength; lastLoop = thisLoop; } // Report the fps only every second, to only lightly affect measurements var fpsOut = document.getElementById('fps'); setInterval(function(){ fpsOut.innerHTML = (1000/frameTime).toFixed(1) + " fps"; },1000); The 'halflife' of this filter—the number of frames needed to move halfway from the old value to a new, stable value—is filterStrength*Math.log(2) (roughly 70% of the strength). For example, a strength of 20 will move halfway to an instantaneous change in 14 frames, 3/4 of the way there in 28 frames, 90% of the way there in 46 frames, and 99% of the way there in 92 frames. For a system running at about 30fps, a sudden, drastic shift in performance will be obvious in half a second, but will still 'throw away' single-frame anomalies as they will only shift the value by 5% of the difference. Here is a visual comparison of different filter strengths for a ~30fps game that has a momentary dip to 10fps and then later speeds up to 50fps. As you can see, lower filter values more quickly reflect 'good' changes, but also are more susceptible to temporary hiccups: Finally, here is an example of using the above code to actually benchmark a 'game' loop.
