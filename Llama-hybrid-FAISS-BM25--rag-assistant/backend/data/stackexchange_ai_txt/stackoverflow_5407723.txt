[site]: stackoverflow
[post_id]: 5407723
[parent_id]: 5399556
[tags]: 
My guess is that you're controller method is using @ResponseBody and that the model objects your're returning are marked up with Jaxb2 annotations (specifically @XmlRootElement). I had the same issue that you are having. The problem is, @ResponseBody bypasses the ContentNegotiatingViewResolver. You can confirm this by adding some break points to methods of the ContentNegotiatingViewResolver like "resolveViewName" and see if it actually gets hit (it won't). The current work around I am using is to actually declare a json view and specifically use it. You would have to add something like this to your xml: You can then change your list item to look something like this as well: Your controller method would then return a ModelAndView like so: @RequestMapping(value = "/{username}/get.json", method = RequestMethod.GET) public ModelAndView getUser(@PathVariable String username) { User user = service.getUser(username); return new ModelAndView("jsonView", "user", user); } Or, you can just return the view as a string, and add declare a ModelMap in your method signature: @RequestMapping(value = "/{username}/get.json", method = RequestMethod.GET) public String getUser(@PathVariable String username, ModelMap model) { User user = service.getUser(username); model.addAttribute("user", user); return "jsonView"; } Hope this helps. (Note: typing this out from memory, so there's potential for syntax errors, etc) I haven't found a more elegant solution to this problem yet, but if I do, I'll post it here. EDIT: Try removing @ResponseBody. If you do this, the MessageConverters will not be activated, and the ContentNegotiatingViewResolver will be triggered. At this point, it should be the extension that determines the view (based on your setup). You shouldn't have to change anything other than removing @ResponseBody, the return type can stay the same.
