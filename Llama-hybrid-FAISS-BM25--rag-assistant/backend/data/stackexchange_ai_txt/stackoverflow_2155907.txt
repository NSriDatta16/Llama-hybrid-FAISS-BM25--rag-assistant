[site]: stackoverflow
[post_id]: 2155907
[parent_id]: 2155675
[tags]: 
A more generic solution might also be to make use of pointers-to-members: #include #include #include struct MyClass { int varA; int varB; }; template class CompareMemberT: public std::binary_function { VarType Object::*p; public: CompareMemberT(VarType Object::*p): p(p) {} bool operator()(const Object* a, const Object* b) const { return a->*p *p; } }; //helper to deduce template arguments template CompareMemberT CompareMember(VarType Object::*p) { return CompareMemberT (p); } int main() { std::vector vec; std::sort(vec.begin(), vec.end(), CompareMember(&MyClass::varA)); std::sort(vec.begin(), vec.end(), CompareMember(&MyClass::varB)); }
