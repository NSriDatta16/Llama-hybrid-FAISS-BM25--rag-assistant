[site]: stackoverflow
[post_id]: 2411794
[parent_id]: 
[tags]: 
Storing annually repeatable values in a MySQL database

I've been hammering my head against my desk for the past few days on this, and so I turn to you, Stack Overflow. The software I'm working on has time-sensitive data. The usual solution for this is effective and expiration dates. EFF_DT XPIR_DT VALUE 2000-05-01 2000-10-31 100 2000-11-01 (null) 90 This would be easy. Unfortunately, we require data that repeats on a yearly basis arbitrarily far into the future. In other words, each May 1 (starting in 2000) we may want the effective value to be 100, and each November 1 we may want to change it to 90. This may be true for a long time (>50 years), and so I don't want to just create a hundred records. I.e., I don't want to do this: EFF_DT XPIR_DT VALUE 2000-05-01 2000-10-31 100 2000-11-01 2001-04-30 90 2001-05-01 2001-10-31 100 2001-11-01 2002-04-30 90 2002-05-01 2002-10-31 100 2002-11-01 2003-04-30 90 ... 2049-05-01 2049-10-31 100 2049-11-01 2050-04-30 90 2050-05-01 2050-10-31 100 2050-11-01 2051-04-30 90 These values may also change with time. Values before 2000 might have been constant (no flip-flopping) and values for the coming decade may be different than the values for the last: EFF_DT XPIR_DT REPEATABLE VALUE 1995-01-01 2000-04-30 false 85 2000-05-01 2010-04-30 true 100 2000-11-01 2010-10-31 true 90 2010-05-01 (null) true 120 2010-11-01 (null) true 115 We already have a text file (from a legacy app) that stores data in a form very close to this, so there are benefits to adhering to this type of structure as closely as possible. The question then comes on retrieval: which value would apply to today, 2010-03-09? It seems that the best way to do this would be to find the most recent instance of each effective date (of all the active rows), then see which is the greatest. EFF_DT MOST_RECENT XPIR_DT VALUE 2000-05-01 2009-05-01 2010-04-30 100 2000-11-01 2009-11-01 2010-10-31 90 The value for today would be 90, since 2009-11-01 is later than 2009-05-01. On, say, 2007-06-20: EFF_DT MOST_RECENT XPIR_DT VALUE 2000-05-01 2007-05-01 2010-04-30 100 2000-11-01 2006-11-01 2010-10-31 90 The value would be 100 since 2007-05-01 is later than 2006-11-01. Using the MySQL date functions, what's the most efficient way to calculate the MOST_RECENT field? Or, can anyone think of a better way to do this? The language is Java, if it matters. Thanks all!
