[site]: stackoverflow
[post_id]: 5439400
[parent_id]: 5427691
[tags]: 
I hope I understood your question correctly. There may be an option that uses copypixels to achieve what you want. You can use the bitmapdata.rect value to determine the size of the sample you want, and loop through the bigger bitmap using thet rectangle and a moving point. Let's see if I can code this out... function findBitmapInBitmap(tinyimg:BitmapData, largeimg:BitmapData):Point { var rect:Rectangle = tinyimg.rect; var xbound:uint = largeimg.rect.width; var ybound:uint = largeimg.rect.height; var imgtest:BitmapData = new BitmapData(tinyimg.rect.width, tinyimg.rect.height); for (var ypos:uint = 0, y Something along those lines should work - I'm sure there's room for code elegance and possible optimization. However, it seems like something like this method would be very slow, since you'd have to check each pixel for a match. There is a better way. Split your big image into layers, and use the blitting technique to composite them at runtime. In your case, you could create a ground texture without satellites, and then create the satellites separately, and use the copyPixels method to place them whereever you want. Google "blitting in as3" to find some good tutorials. I'm currently working on a game project that uses this technique and it's a very good method. Good luck! Edit: Forgot to code in a default return statement. Using this method, you'd have to return an invalid point (like (-1,-1)) and check for it outside the function. Alternatively, you could just copy your small bitmap to the big one within the function, which would be much more logical, but I don't know your requirements.
