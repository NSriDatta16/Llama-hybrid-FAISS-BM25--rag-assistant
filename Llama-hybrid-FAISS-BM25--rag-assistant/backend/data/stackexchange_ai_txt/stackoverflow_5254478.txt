[site]: stackoverflow
[post_id]: 5254478
[parent_id]: 
[tags]: 
my OpenGL program small error, really need help

// // This code was created by Jeff Molofee '99 // // If you've found this code useful, please let me know. // // Visit me at www.demonews.com/hosted/nehe // /**************************************************************/ // This code was ported to MacOS by Tony Parker. // I'd also appreciate it if you could drop me a line if you found // this code useful. // // Tony Parker - asp@usc.edu // // Have a nice day. #include // Header File For Standard Input / Output #include // Header File For Variable Argument Routines #include // Header File For String Management #include #include // Header File For The OpenGL32 Library #include // Header File For The GLu32 Library #include // Header File For The GLUT Library // Constants ----------------------------------------------------------------- #define kWindowWidth 512 #define kWindowHeight 256 // Structures ---------------------------------------------------------------- typedef struct // Create A Structure { GLubyte *imageData; // Image Data (Up To 32 Bits) GLuint bpp; // Image Color Depth In Bits Per Pixel. GLuint width; // Image Width GLuint height; // Image Height GLuint texID; // Texture ID Used To Select A Texture } TextureImage; // Structure Name // Function Prototypes ------------------------------------------------------- GLvoid InitGL(GLvoid); GLvoid DrawGLScene(GLvoid); GLvoid ReSizeGLScene(int Width, int Height); GLvoid Idle(GLvoid); bool LoadTGA(TextureImage *texture, char *filename); GLvoid LoadGLTextures(GLvoid); // Global Variables ---------------------------------------------------------- TextureImage texture[1]; // Texture Storage ( NEW ) GLfloat xrot; // X Rotation ( NEW ) GLfloat yrot; // Y Rotation ( NEW ) GLfloat zrot; // Z Rotation ( NEW ) // Main ---------------------------------------------------------------------- int main(int argc, char** argv) { glutInit(&argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH); glutInitWindowSize(kWindowWidth, kWindowHeight); glutInitWindowPosition (100, 100); glutCreateWindow (argv[0]); InitGL(); glutDisplayFunc(DrawGLScene); glutReshapeFunc(ReSizeGLScene); glutIdleFunc(Idle); xrot = 0; yrot = 0; zrot = 0; glutMainLoop(); return 0; } // InitGL -------------------------------------------------------------------- GLvoid InitGL(GLvoid) { LoadGLTextures(); // Load The Texture(s) ( NEW ) glEnable(GL_TEXTURE_2D); // Enable Texture Mapping ( NEW ) glClearColor(0.0f, 0.0f, 0.0f, 0.0f); // This Will Clear The Background Color To Black glClearDepth(1.0); // Enables Clearing Of The Depth Buffer glDepthFunc(GL_LESS); // The Type Of Depth Test To Do glEnable(GL_DEPTH_TEST); // Enables Depth Testing glShadeModel(GL_SMOOTH); // Enables Smooth Color Shading glMatrixMode(GL_PROJECTION); glLoadIdentity(); // Reset The Projection Matrix gluPerspective(45.0f, (GLfloat) kWindowWidth / (GLfloat) kWindowHeight, 0.1f, 100.0f); // Calculate The Aspect Ratio Of The Window glMatrixMode(GL_MODELVIEW); } // Idle ---------------------------------------------------------------------- GLvoid Idle(GLvoid) { xrot += 0.3f; // X Axis Rotation yrot += 0.2f; // Y Axis Rotation zrot += 0.4f; // Z Axis Rotation glutPostRedisplay(); } // DrawGLScene --------------------------------------------------------------- GLvoid DrawGLScene(GLvoid) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); glTranslatef(0.0f,0.0f,-5.0f); glRotatef(xrot,1.0f,0.0f,0.0f); // Rotate On The X Axis glRotatef(yrot,0.0f,1.0f,0.0f); // Rotate On The Y Axis glRotatef(zrot,0.0f,0.0f,1.0f); // Rotate On The Z Axis glBindTexture(GL_TEXTURE_2D, texture[0].texID); glBegin(GL_QUADS); // Front Face glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // Bottom Left Of The Texture and Quad glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // Bottom Right Of The Texture and Quad glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); // Top Right Of The Texture and Quad glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // Top Left Of The Texture and Quad // Back Face glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); // Bottom Right Of The Texture and Quad glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); // Top Right Of The Texture and Quad glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // Top Left Of The Texture and Quad glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // Bottom Left Of The Texture and Quad // Top Face glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); // Top Left Of The Texture and Quad glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // Bottom Left Of The Texture and Quad glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, 1.0f, 1.0f); // Bottom Right Of The Texture and Quad glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // Top Right Of The Texture and Quad // Bottom Face glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f); // Top Right Of The Texture and Quad glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // Top Left Of The Texture and Quad glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // Bottom Left Of The Texture and Quad glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // Bottom Right Of The Texture and Quad // Right face glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // Bottom Right Of The Texture and Quad glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // Top Right Of The Texture and Quad glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); // Top Left Of The Texture and Quad glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // Bottom Left Of The Texture and Quad // Left Face glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); // Bottom Left Of The Texture and Quad glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // Bottom Right Of The Texture and Quad glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // Top Right Of The Texture and Quad glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); // Top Left Of The Texture and Quad glEnd(); glutSwapBuffers(); glFlush(); } // ReSizeGLScene ------------------------------------------------------------ GLvoid ReSizeGLScene(int Width, int Height) { glViewport (0, 0, (GLsizei) Width, (GLsizei) Height); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(45.0, (GLfloat) Width / (GLfloat) Height, 0.1, 100.0); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); } // LoadGLTextures ---------------------------------------------------------- GLvoid LoadGLTextures(GLvoid) { LoadTGA(texture, "NeHe.tga"); } /********************> LoadTGA() width = header[1] * 256 + header[0]; // Determine The TGA Width (highbyte*256+lowbyte) texture->height = header[3] * 256 + header[2]; // Determine The TGA Height (highbyte*256+lowbyte) if( texture->width height bpp = header[4]; // Grab The TGA's Bits Per Pixel (24 or 32) bytesPerPixel = texture->bpp/8; // Divide By 8 To Get The Bytes Per Pixel imageSize = texture->width*texture->height*bytesPerPixel; // Calculate The Memory Required For The TGA Data texture->imageData=(GLubyte *)malloc(imageSize); // Reserve Memory To Hold The TGA Data if( texture->imageData==NULL || // Does The Storage Memory Exist? fread(texture->imageData, 1, imageSize, file)!=imageSize) // Does The Image Size Match The Memory Reserved? { if(texture->imageData!=NULL) // Was Image Data Loaded free(texture->imageData); // If So, Release The Image Data fclose(file); // Close The File return false; // Return False } for(GLuint i=0; i imageData[i]; // Temporarily Store The Value At Image Data 'i' texture->imageData[i] = texture->imageData[i + 2]; // Set The 1st Byte To The Value Of The 3rd Byte texture->imageData[i + 2] = temp; // Set The 3rd Byte To The Value In 'temp' (1st Byte Value) } fclose (file); // Close The File // Build A Texture From The Data glGenTextures(1, &texture[0].texID); // Generate OpenGL texture IDs glBindTexture(GL_TEXTURE_2D, texture[0].texID); // Bind Our Texture glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); // Linear Filtered glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Linear Filtered if (texture[0].bpp==24) // Was The TGA 24 Bits { type=GL_RGB; // If So Set The 'type' To GL_RGB } glTexImage2D(GL_TEXTURE_2D, 0, type, texture[0].width, texture[0].height, 0, type, GL_UNSIGNED_BYTE, texture[0].imageData); return true; // Texture Building Went Ok, Return True } IN LINE 47, and 194 I got "/Users/mbp/Desktop/XcodeGLUT/main.c:47:0 /Users/mbp/Desktop/XcodeGLUT/main.c:47: error: expected '=', ',', ';', 'asm' or ' attribute ' before 'LoadTGA' " I really cannot find anything wrong here..Can anybody help me.
