[site]: stackoverflow
[post_id]: 5223548
[parent_id]: 5217787
[tags]: 
Example for a set 31.01 -> 1.02 -> 3.02 instead of 31.01 -> 2.02 . In that case the only one way is to write the custom Axis similar to the DateTimeAxis . At first copy to your project the following files: c:\Program Files\Microsoft SDKs\Silverlight\v4.0\Toolkit\Apr10\Source\Source code.zip\Controls.DataVisualization.Toolkit\EnumerableFunctions.cs c:\Program Files\Microsoft SDKs\Silverlight\v4.0\Toolkit\Apr10\Source\Source code.zip\Controls.DataVisualization.Toolkit\ValueHelper.cs Copy these files with exactly the same namespace, they are internal so there will not be a name conflict. Next, add the extended class for DateTimeIntervalType : namespace System.Windows.Controls.DataVisualization.Charting { /// /// A date time interval. /// public enum ExtendedDateTimeIntervalType { /// /// Automatically determine interval. /// Auto = 0, /// /// Interval type is milliseconds. /// Milliseconds = 1, /// /// Interval type is seconds. /// Seconds = 2, /// /// Interval type is minutes. /// Minutes = 3, /// /// Interval type is hours. /// Hours = 4, /// /// Interval type is days. /// Days = 5, /// /// Interval type is weeks. /// Weeks = 6, /// /// Interval type is months. /// Months = 7, /// /// Interval type is years. /// Years = 8, /// /// Interval type is odd days /// OddDays = 9 } } To make the new member OddDays work, I've changed the class DataTimeRangeAxis . Here is a link on pastebin , because programmers of SO don't pay attention to such trifle as answers with long explanation. Change the namespace SilverlightApplication3 to whatever your want (except System.Windows.Controls.DataVisualization.Charting ). Also I've commented the code at the last function, because it contains many dependencies and I didn't want to copy extra files to the application. The axis works fine without this code, probably this function isn't used at all. The most important part of the class is in the function IncrementDateTime : //The interval type forced by a user, not actual interval type if (this.IntervalType == ExtendedDateTimeIntervalType.OddDays) { DateTime newDate; if(span != TimeSpan.Zero) //automatically created interval newDate = date.Add(span); else newDate = date.AddDays(interval); //else use the interval which is set by a user //find the nearest odd day while (newDate.Day % 2 != 1) newDate = newDate.AddDays(1); //update span span = newDate - date; } Xaml will look so: You can set Interval="2" instead of 1, but it will skip the day in the set 31.01-1.02-3.02 , so it is better to use the value 1.
