[site]: stackoverflow
[post_id]: 5071400
[parent_id]: 
[tags]: 
Cancel all outstanding QTimer events

I am looking for a way to setup a number of timed function calls in pyqt, with a way to cancel all pending calls when needed. I was looking at using QtCore.QTimer to setup the function calls, but I don't know of any good way to cancel these calls. Any ideas? I can't seem to find any way to cancel after using QtCore.QTimer.singleShot(1000, self.function) . If instead I create a list of QTimer objects I can stop them, but then I am forced to manage a list of timer objects (creation, deletion, which are active, etc.), which I would like to avoid. # Setup a timer object. timer = QtCore.QTimer(self) timer.timeout.connect(self.function) timer.setSingleShot(True) timer.start(1000) # To stop the timer object at some later point. timer.stop() I could also manage my own queue of pending function calls, which I would also like to avoid if possible (for the sake of simplicity). Here is some dummy code showing the kind of thing I am trying to do: import sys from PyQt4 import QtCore class Test(QtCore.QObject): def __init__(self, parent=None): QtCore.QObject.__init__(self, parent) def addDelayedCall(self, time, function): # Do something here. pass def clearPendingCalls(self): print(' Clearing pending function calls.') # Do something here. def setupCalls(self): self.addDelayedCall(500, self.dummy) self.addDelayedCall(1000, self.dummy) self.addDelayedCall(1500, self.dummy) self.addDelayedCall(2000, self.dummy) def dummy(self): print('dummy just got called.') if __name__ == '__main__': app = QtCore.QCoreApplication(sys.argv) test = Test(app) QtCore.QTimer.singleShot(0, test.setupCalls) QtCore.QTimer.singleShot(1250, test.clearPendingCalls) QtCore.QTimer.singleShot(5000, app.quit) sys.exit(app.exec_())
