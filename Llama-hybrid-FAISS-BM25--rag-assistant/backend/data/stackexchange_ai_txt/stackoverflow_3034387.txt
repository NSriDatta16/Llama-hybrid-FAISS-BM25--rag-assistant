[site]: stackoverflow
[post_id]: 3034387
[parent_id]: 3034289
[tags]: 
Yes and no. I mean your question really depends on how are you going to use these objects.. personally I like to split behaviours and attributes as much as possible to "clusterize" them according to the kind of object they represent without caring about reusing some code a little bit less compared to a really inheritance approach like the one you proposed. Something like: interface BigLizard { void nod(); } class Dragon implements BigLizard { Head head; void nod() { head.upAndDown(); } } class ReallyScaryDragon extends Dragon { ... } class Hydra implements BigLizard { ArrayList heads; void nod() { for (Head h : heads) h.upAndDown(); } } And so on. This approach is like "having just exactly what you need for your objects without force anything to be a specific case". Of course this means that it will have two different implementations of nod() but when you don't need to optimize (and you should care about it only at the end) just stick with your personal preference, assuming that it doesn't go against any standard, widely accepted convention. You don't have to make anything inherit from a single object, just customize the hierarchy as you like.. also a composite solution (like already suggested) would be a solution also if the concept of "head part" is not the same for your Dragon and for your Hydra .. A third solution for your specific case could be to use a LinkedList instead that an ArrayList . In this case whenever you have just one head you won't waste space (except for instantiation of the list) and you'll have just the next pointer of the head (of the list :D ) pointing nowhere.
