[site]: stackoverflow
[post_id]: 1276590
[parent_id]: 1275904
[tags]: 
Restlet doesn't currently support JSPs directly. They're difficult to handle outside of the servlet container. There's a discussion on Nabble about this issue that you may find useful, at the moment it looks like you need to either return a redirect to the JSP mapped as normal in the web.xml, or hack it to process the JSP and return the stream as the representation. The response dated "Apr 23, 2009; 03:02pm" in the thread describes how you could do the hack: if (request instanceof HttpRequest && ((HttpRequest) request).getHttpCall() instanceof ServletCall) { ServletCall httpCall = (ServletCall) ((HttpRequest) request).getHttpCall(); // fetch the HTTP dispatcher RequestDispatcher dispatcher = httpCall.getRequest().getRequestDispatcher("representation.jsp"); HttpServletRequest proxyReq = new HttpServletRequestWrapper(httpCall.getRequest()); // Overload the http response stream to grab the JSP output into a dedicated proxy buffer // The BufferedServletResponseWrapper is a custom response wrapper that 'hijacks' the // output of the JSP engine and stores it on the side instead of forwarding it to the original // HTTP response. // This is needed to avoid having the JSP engine mess with the actual HTTP stream of the // current request, which must stay under the control of the restlet engine. BufferedServletResponseWrapper proxyResp = new BufferedServletResponseWrapper(httpCall.getResponse()); // Add any objects to be encoded in the http request scope proxyReq.setAttribute("myobjects", someObjects); // Actual JSP encoding dispatcher.include(proxyReq, proxyResp); // Return the content of the proxy buffer Representation rep = new InputRepresentation(proxyResp.toInputStream(),someMediaType); The source for the BufferedServletResponseWrapper is posted a couple of entries later.
