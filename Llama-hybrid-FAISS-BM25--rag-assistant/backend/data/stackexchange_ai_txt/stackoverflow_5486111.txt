[site]: stackoverflow
[post_id]: 5486111
[parent_id]: 5485771
[tags]: 
You cannot leverage the "default" conversion and use a custom value converter at the same time. So you'd need to implement the "default" conversion in your custom value converter. Something like this leverages the default TypeConverter of the target type: public class MyConverter : IMultiValueConverter { public object Convert(object[] values, Type targetType, object parameter, System.Globalization.CultureInfo culture) { return System.Convert.ToString(values[0]); } public object[] ConvertBack(object value, Type[] targetTypes, object parameter, System.Globalization.CultureInfo culture) { // Get the type of the value, but assume string if it's null Type valueType = typeof(string); if (value != null) valueType = value.GetType(); // Convert value to the various target types using the default TypeConverter object[] values = new object[targetTypes.Length]; for (int i = 0; i
