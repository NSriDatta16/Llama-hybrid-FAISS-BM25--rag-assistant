[site]: stackoverflow
[post_id]: 4648493
[parent_id]: 4645914
[tags]: 
You don't want to iterate through the grid. That's old-skool WinForms thinking. The Grids in WPF and Silverlight have been redesigned with MVVM in mind; with separation of concerns. Instead of manipulating the grid, you work directly with your objects that are bound to the grid. So the grid just becomes a presentation concern. Its responsibility is to read the objects and display information based on the data in those objects. What you want to do instead is attach properties to the object that you're binding to and have the grid set styles for color/font/etc., based on those settings. To do this, you'll need to create an IValueConverter. Here is an example of a converter I have in a WPF and Silverlight datagrid: public class StateToBackgroundColorConverter : IValueConverter { #region IValueConverter Members public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if (value == null) return Colors.White.ToString(); var state = (State) value; return state.WebColor; } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotImplementedException(); } #endregion } In my XAML I declare it like this: In the datagrid declaration in XAML I specify the converter usage for the DataGridRow: So, the Converter does the work. It reads the value of the State object (which is a child object on my AgentState object which is what the grid is binding to; it's binding to a collection of AgentState objects). The converter reads the value of the state and returns a string representation of a color for the grid to use to set for the row. Hope that helps.
