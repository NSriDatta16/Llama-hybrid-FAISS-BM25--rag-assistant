[site]: stackoverflow
[post_id]: 1871475
[parent_id]: 
[tags]: 
Configurable rule based system in C#

I have an algorithm that returns a list of classifications(strings) dependant on the two arguments given to the algorithm: a type variable, and an extra category string that allows certain special classifications to be added to the result list. The current implementation, is unreadable and unscalable due to the expression of the rules as ifs, and switch statements. Also the rules are hard coded. A simplified version of the code: private static List DetermineTypes(Type x, object category) { List Types = new List (); if (category is DateTime) { types.Add("1"); types.Add("2"); types.Add("3"); } else if (category is string) { switch ((string)category) { case "A": Types.Add("4"); break; case "B": case "C": case "D": Types.Add("5"); break; case "": Types = DetermineTypesFromX(Types, x); break; default: Types.Add("6"); break; } } return graphTypes; } private static List DetermineTypesFromX(List Types, Type x) { if (x.Equals(typeof(int))) { Types.Add("7"); } else if (x.Equals(typeof(double))) { Types.Add("8"); } else if (x.Equals(typeof(System.DateTime))) { Types.Add("9"); Types.Add("10"); } return Types; } I was thinking that it would be good to maybe specify these with xml, so that a code change wasn't needed for new types/rules, but that is most probably too heavyweight for the situation. Basically I am trying to solve the problem that a new 'Type' may be added at anytime: common case would be that it is one of the 'rules' above, and an unlikely edge case that a new 'rule' branch may have to be added. I am still to determine whether the work needed it to make it fully dynamic using xml defined rules( or any other way) is worth it compared to the likelihood of the edge cases ever happening and the business environment(schedules etc). But my main point of the question is how could you elegantly simplify the nested conditional code above? maybe incorporating more flexibility into the design for increased scalability? I was wondering if using a combination of F# pattern matching might be an appropriate solution? (NB: Never used F# before, have been curious as of late, so thats why I am asking)
