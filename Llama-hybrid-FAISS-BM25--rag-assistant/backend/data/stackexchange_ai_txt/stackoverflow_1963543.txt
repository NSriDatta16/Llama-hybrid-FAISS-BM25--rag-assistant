[site]: stackoverflow
[post_id]: 1963543
[parent_id]: 1963269
[tags]: 
As already pointed out, you can't force Compare to have a static member compare . If your comparer doesn't implement it, you just get an compiler error. If you implement AVLTree like this it would be more elegant to declare Comparer as a template template parameter : template class DefaultComparer { public: static bool compare(K k1, K k2) { return k1 == k2; } }; template class MyComparer : public DefaultComparer { public: static bool compare(K k1, K k2) { return k1 class InvalidComparer { public: static bool bar(K k1, K k2) { return k1 != k2; } // Doesn't implement compare() }; // Compare is a template template paramenter with default template argument // DefaultComparer template class Comparer = DefaultComparer> class AVLTree { K k1, k2; public: AVLTree() : k1(0), k2(0) { } // ctor bool foo(); }; // Definiton of AVLTree::foo() template class Comparer> bool AVLTree ::foo() { return Comparer ::compare(k1, k2); } int main(int argc, char *argv[]) { // Without template template parameters you // would have to use AVLTree > AVLTree avltree; // instead of AVLTree > AVLTree avltree2; // Calling foo() will generate a compile error. // But if you never call avltree3.foo() this will compile! AVLTree avltree3; avltree.foo(); // calls DefaultComparer::compare avltree2.foo(); // calls MyComparer::compare avltree3.foo(); // fails to compile } see: http://codepad.org/OLhIPjed
