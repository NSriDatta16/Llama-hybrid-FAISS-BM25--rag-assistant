[site]: stackoverflow
[post_id]: 1797380
[parent_id]: 
[tags]: 
Template specialization with a templatized type

I want to specialize a class template with the following function: template class Foo { public: static int bar(); }; The function has no arguments and shall return a result based on the type of Foo. (In this toy example, we return the number of bytes of the type, but in the actual application we want to return some meta-data object.) The specialization works for fully specified types: // specialization 1: works template <> int Foo ::bar() { return 4; } // specialization 2: works template <> int Foo ::bar() { return 8; } // specialization 3: works typedef pair IntPair; template <> int Foo ::bar() { return 2 * Foo ::bar(); } However, I would like to generalize this to types that depend on (other) template parameters themselves. Adding the following specialization gives a compile-time error (VS2005): // specialization 4: ERROR! template <> template int Foo >::bar() { return Foo ::bar() + Foo ::bar(); } I am assuming this is not legal C++, but why? And is there a way to implement this type of pattern elegantly?
