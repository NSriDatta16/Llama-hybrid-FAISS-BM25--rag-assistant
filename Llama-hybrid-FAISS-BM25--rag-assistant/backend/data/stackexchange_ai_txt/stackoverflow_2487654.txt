[site]: stackoverflow
[post_id]: 2487654
[parent_id]: 2487509
[tags]: 
void *kid( void *local_v ) try { thlocal &local = * static_cast ( local_v ); throw local; } catch( thlocal & ) { print_thread(); return NULL; } == void *kid (void *local_v ) { print_thread(local_v); } I might be missing something here, but it's not a thread local storage, just unnecessarily complicated argument passing. Argument is different for each thread only because it is passed to pthread_create, not because of any exception juggling. It turned out that I indeed was missing that GCC is producing actual thread local storage calls in this example. It actually makes the issue interesting. I'm still not quite sure whether it is a case for other compilers, and how is it different from calling thread storage directly. I still stand by my general argument that the same data can be accessed in a more simple and straight-forward way, be it arguments, stack walking or thread local storage.
