[site]: stackoverflow
[post_id]: 4675960
[parent_id]: 4675783
[tags]: 
If you put them in a nested scope within the function (your first option), then when control reaches the end of the scope, the variables become inaccessible (either a compile error if you use them directly, or runtime undefined behavior if you save a pointer to one of them), their destructors are run (if there are destructors), and the implementation may reuse their storage space within the stack frame. But the standards do not require it to reuse the space. If you split your function in two (your second option) ... in terms of standard-hairsplitting, there is no difference! When the function returns, the variables become inaccessible, their destructors are run, and the implementation may reuse their storage space, but it is not required to. And there have been serious implementations -- albeit not of C/C++ -- that do not immediately recycle that memory: see most famously the paper " Cheney on the M.T.A. " However, all implementations of C/C++ that I am presently aware of do recycle the memory allocated for a function's local variables when a function returns. Recycling of memory for nested-local-scope variables is much less certain. In any event, as several other people have mentioned, it is not worth worrying about a few tens of bytes of stack space in this context. Personally, I would break up your code into two functions just because that way each function does only one task. That's generally better for long-term maintenance.
