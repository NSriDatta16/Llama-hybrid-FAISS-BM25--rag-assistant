[site]: stackoverflow
[post_id]: 2936650
[parent_id]: 2936205
[tags]: 
Suppose we have: 000101101 First, count the 0s ( 5 ), and count the groups of 0s surrounded by 1s ( 1 ). We can forget about the 1s for now. The number of zeros per group in any combination can be a list described as (where + means "or more"): [0+, 1+, 1+, 0+] where the sum is 6 This is just a variation of a similar problem: find all sets of N non-negative integers that sum to K. For example: [0+, 0+, 0+, 0+] where the sum is 6 Now, to solve this, start with N=1. The solution is obviously just [6] . With N=2, the solution is: [0,6] [1,5] [2,4] [3,3] [4,2] [5,1] [6,0] It's important to notice an underlying theme here: as the left side gets richer, the right side gets poorer. I'll use Haskell to describe the algorithm, as it turns out to be quite elegant for this type of thing: sumsTo k n | n == 1 = [[k]] | n > 1 = do i The n == 1 case is pretty easy to understand: it just returns one combination: [k] . In the n > 1 case, there's actually a nested loop going on here. It's basically saying: for each number i from 0 to k for each s in sumsTo (k-i) (n-1) prepend i to s Although this algorithm doesn't quite solve your problem, it's good to know in general. Now, we want the algorithm to operate differently to handle how the middle list items cannot be zero. For those cases, we want to use i instead of i . It doesn't matter for the end number since it has no free will (it depends solely on the sum of the previous items). Getting closer, we might say: sumsTo k n | n == 1 = [[k]] | n > 1 = do i However, we want our first item to be able to start at zero. To patch that up, we can say: sumsTo k n first_start | n == 1 = [[k]] | n > 1 = do i This gives us the sequences we need given K (the number of 0s) and N (the number of inner groups of 0s plus 2). All that remains is stringifying the sequences (e.g. turning [1,1,0] into "01"). We could go as far as embedding the stringification directly into our recursive algorithm. Summing it all up, here is a solution in Haskell: import Data.List sumsTo k n first_start | n == 1 = [[k]] | n > 1 = do i In conclusion, I recommend learning Haskell so you can prototype algorithms more quickly :-)
