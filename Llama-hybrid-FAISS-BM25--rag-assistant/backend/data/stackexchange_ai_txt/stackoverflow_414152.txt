[site]: stackoverflow
[post_id]: 414152
[parent_id]: 412019
[tags]: 
Note: This is a follow-up to this post. Edit: Update to calculate the same thing as this and this , taking some inspiration from this . Now look what you made me do! You made me install Mono! $ gmcs -optimize test.cs && mono test.exe Max deviation is 0.001663983 10^7 iterations using Sigmoid1() took 1646.613 ms 10^7 iterations using Sigmoid2() took 237.352 ms C is hardly worth the effort anymore, the world is moving forward :) So, just over a factor 10 6 faster. Someone with a windows box gets to investigate the memory usage and performance using MS-stuff :) Using LUTs for activation functions is not so uncommon, especielly when implemented in hardware. There are many well proven variants of the concept out there if you are willing to include those types of tables. However, as have already been pointed out, aliasing might turn out to be a problem, but there are ways around that too. Some further reading: NEURObjects by Giorgio Valentini (there's also a paper on this) Neural networks with digital LUT activation functions Boosting neural network feature extraction by reduced accuracy activation functions A New Learning Algorithm for Neural Networks with Integer Weights and Quantized Non-linear Activation Functions The effects of quantization on high order function neural networks Some gotchas with this: The error goes up when you reach outside the table (but converges to 0 at the extremes); for x approx +-7.0. This is due to the chosen scaling factor. Larger values of SCALE give higher errors in the middle range, but smaller at the edges. This is generally a very stupid test, and I don't know C#, It's just a plain conversion of my C-code :) Rinat Abdullin is very much correct that aliasing and precision loss might cause problems, but since I have not seen the variables for that I can only advice you to try this. In fact, I agree with everything he says except for the issue of lookup tables. Pardon the copy-paste coding... using System; using System.Diagnostics; class LUTTest { private const float SCALE = 320.0f; private const int RESOLUTION = 2047; private const float MIN = -RESOLUTION / SCALE; private const float MAX = RESOLUTION / SCALE; private static readonly float[] lut = InitLUT(); private static float[] InitLUT() { var lut = new float[RESOLUTION + 1]; for (int i = 0; i = MAX) return 1.0f; if (value >= 0) return lut[(int)(value * SCALE + 0.5f)]; return 1.0f - lut[(int)(-value * SCALE + 0.5f)]; } public static float error(float v0, float v1) { return Math.Abs(v1 - v0); } public static float TestError() { float emax = 0.0f; for (float x = -10.0f; x emax) emax = e; } return emax; } public static double TestPerformancePlain() { Stopwatch sw = new Stopwatch(); sw.Start(); for (int i = 0; i
