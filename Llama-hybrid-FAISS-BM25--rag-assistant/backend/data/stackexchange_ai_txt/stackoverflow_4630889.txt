[site]: stackoverflow
[post_id]: 4630889
[parent_id]: 2895658
[tags]: 
The answer is that your example is not wrong per se, but there are a few possible pitfalls. You have put the annotation on the setter, not the getter. While the JavaDoc for @XmlAttribute does not state any restrictions on this, other annotations (e.g. @XmlID) specifically allow annotation either the setter or the getter, but not both. Note that @XmlAttribute expects an attribute, not an element. Also, since it parses an attribute, it can't be a complex type. So EGroup could be an enum, perhaps? I expanded your example and added some asserts, and it works "on my machine", using the latest Java 6. @XmlRootElement @XmlAccessorType(javax.xml.bind.annotation.XmlAccessType.PROPERTY) public class E { private EGroup groupDefinition; public EGroup getGroupDefinition () { return groupDefinition; } @XmlAttribute public void setGroupDefinition (EGroup g) { groupDefinition = g; } public enum EGroup { SOME, OTHERS, THE_REST } public static void main(String[] args) throws JAXBException { JAXBContext jc = JAXBContext.newInstance(E.class); E eOne = new E(); eOne.setGroupDefinition(EGroup.SOME); Marshaller m = jc.createMarshaller(); m.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE); StringWriter writer = new StringWriter(); m.marshal(eOne, writer); assert writer.toString().equals(" "); E eTwo = (E) jc.createUnmarshaller().unmarshal(new StringReader(writer.toString())); assert eOne.getGroupDefinition() == eTwo.getGroupDefinition(); } }
