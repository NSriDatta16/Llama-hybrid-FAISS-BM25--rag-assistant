[site]: stackoverflow
[post_id]: 1616986
[parent_id]: 1616147
[tags]: 
Tangential Comments These first items are tangential to the questions you asked, but... // Execute void (*NativeFunction)(char*, char*) = &Plus; NativeFunction(Params, Result); // Call the function I think you should probably be using 'void *' instead of 'char *' here. I would also have a typedef for the function pointer type: typedef void (*Operator)(void *params, void *result); Then you can write: Operator NativeFunction = Plus; The actual function would be modified too - but only very slightly: void Plus(void *pParams, void *pResult) Also, you have a minor naming problem - this function is 'IntPlusDoubleGivesDouble()', rather than a general purpose 'add any two types' function. Direct answers to the questions 1). If I know the size of the types, is there a way to modify push and pull function to exactly synchronize with struct padding? (modify to let compiler takes care of it like Datasize and Endians problems). There isn't an easy way to do that. For example, consider: struct Type1 { unsigned char byte; int number; }; struct Type2 { unsigned char byte; double number; }; On some architectures (32-bit or 64-bit SPARC, for example), the Type1 structure will have 'number' aligned at a 4-byte boundary, but the Type2 structure will have 'number' aligned on an 8-byte boundary (and might have a 'long double' on a 16-byte boundary). Your 'push individual elements' strategy would bump the stack pointer by 1 after pushing the 'byte' value - so you would want to move the stack pointer by 3 or 7 before pushing the 'number', if the stack pointer is not already appropriately aligned. Part of your VM description will be the required alignments for any given type; the corresponding push code will need to ensure the correct alignment before pushing. 2). If I pack structure by one (using #pragma pack(1)); (2.1) Will the performance penalty be acceptable? and (2.2) Will the program stability be at risk? On x86 and x86_64 machines, if you pack the data, you will incur a performance penalty for the misaligned data access. On machines such as SPARC or PowerPC (per mecki ), you will get a bus error or something similar instead - you must access the data at its proper alignment. You might save some memory space - at a cost in performance. You'd do better to ensure performance (which here includes 'performing correctly instead of crashing') at the marginal cost in space. 3). How about padding by 2,4, or 8? Which should be good for general 32 or 64 bits system? On SPARC, you need to pad an N-byte basic type to an N-byte boundary. On x86, you will get best performance if you do the same. 4). Can you guide me to a documentation for an exact padding algorithm let's say for GCC on x86? You would have to read the manual . 5). Is there is a better way? Note that the 'Type1' trick with a single character followed by a type gives you the alignment requirement - possibly using the 'offsetof()' macro from : offsetof(struct Type1, number) Well, I would not pack the data on the stack - I would work with the native alignment because that is set to give the best performance. The compiler writer does not idly add padding to a structure; they put it there because it works 'best' for the architecture. If you decide you know better, you can expect the usual consequences - slower programs that sometimes fail and are not as portable. I am also not convinced that I would write the code in the operator functions to assume that the stack contained a structure. I would pull the values off the stack via the Params argument, knowing what the correct offsets and types were. If I pushed an integer and a double, then I'd pull an integer and a double (or, maybe, in reverse order - I'd pull a double and an int). Unless you are planning an unusual VM, few functions will have many arguments.
