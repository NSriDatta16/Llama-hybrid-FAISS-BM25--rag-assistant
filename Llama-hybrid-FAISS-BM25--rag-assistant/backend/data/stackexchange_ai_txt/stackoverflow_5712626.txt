[site]: stackoverflow
[post_id]: 5712626
[parent_id]: 5712472
[tags]: 
Effectively you want to stack the data, and select the maximum from the stack. I have had to implement something similar to this before and the approach we used, which gave us a bit more flexibility than you require, so may not be appropriate was to do this: Have an object for managing the records, and add each record to this object. when a record is added create a new date range and associate the value of the record with the range. Then check if the range overlaps with any other existing range. If it does overlap, then create a new range for each overlap and associate all of the values on the both/all (depending on if you do it as you add each range, or in a single pass) the overlapped ranges with the new range. This can either be done as you add the data, or in a single pass once all data has been added. At the end you have a object which contains unique ranges, each of which has a collection of values associated with it, a bit like your picture above. |666|666666|6666| | | |4444|444|444444444444|4444444| |55555|55555| | |222222|2222|222| |3333333|333333333|33333| | |7777777 1111111|111|111111|1111|111|111111111111|1111111|111111111|11111|11111|1111111| You can then provide a class with a flattening function (probably using the strategy pattern) which will convert the unique ranges with collections of values into unique ranges with a single value, this will obviously concatenate ranges which end up with the same value. You would want a class which selects the maximum value from each unique range, but you might also want to select the minimum value, sum the values, average them, count them etc etc. Each of these options can be done by passing a different implementation of the strategy. As I said this approach might be less efficient than an approach which only selects the maximum value, as you wouldn't need to keep all the values in the stack in that case, but the implementation was fairly straight forward as I remember.
