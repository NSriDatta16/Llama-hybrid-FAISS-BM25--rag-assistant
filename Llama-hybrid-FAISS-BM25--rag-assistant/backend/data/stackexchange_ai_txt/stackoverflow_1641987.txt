[site]: stackoverflow
[post_id]: 1641987
[parent_id]: 1633196
[tags]: 
If what you're trying to create is a table gateway for pre-existing 100-column table to this other service, a list or dictionary might be pretty quick way to get started. However if you're taking input from a large form or UI wizard, you're probably going to have to validate the contents before submission to your remote service. A simple DTO might look like this: class Form { public $stuff = array(); function add( $key, $value ) {} } A table gateway might be more like: class Form { function findBySubmitId( $id ) {} // look up my form function saveRecord() {} // save it for my session function toBillingInvoice() {} // export it when done } And you could extend that pretty easily depending on if you have variations of the invoice. (Adding a validate() method for each subclass might be appropriate.) class TPSReport extends Form { function validate() {} } If you want to separate your DTO from the delivery mechanism, because the delivery mechanism is generic to all your invoices, that could be easy. However you might be in a situation where there is business logic around the success or failure of the invoice. And this is where I'm prolly going off into the weeds. But it's where and OO model can be useful...I'll wage a penny that there will be different invoices and different procedures for different invoices, and if invoice submission barfs, you'll need extra routines :-) class Form { function submitToBilling() {} function reportFailedSubmit() {} function reportSuccessfulSubmit() {} } class TPSReport extends Form { function validate() {} function reportFailedSubmit() { /* oh this goes to AR */ } } Note David Livelys answer: it is a good insight. Often, fields on a form are each their own data structures and have their own validation rules. So you can model composite objects pretty quickly. This would associate each field type with its own validation rules and enforce stricter typing. If you do have to get further into validation, often business rules are a whole different modelling from the forms or the DTOs that supply them. You could also be faced with logic that is oriented by department and has little to do with the form. Important to keep that out of the validation of the form itself and model submission process(es) separately. If you are organizing a schema behind these forms, instead of a table with 100 columns, you would probably break down the entries by field identifiers and values, into just a few columns. table FormSubmissions ( id int formVer int -- fk of FormVersions formNum int -- group by form submission fieldName int -- fk of FormFields fieldValue text ) table FormFields ( id int fieldName char ) table FormVersions ( id name ) select s.* f.fieldName from FormSubmissions s left join FormFields f on s.fieldName = f.id where formNum = 12345 ; I would say this is definitely a case where you're going to want to re-factor your way around until you find something comfortable. Hopefully you have some control over things like schema and your object model. (BTW...is that table known a 'normalized'? I've seen variations on that schema, typically organized by data type...good?)
