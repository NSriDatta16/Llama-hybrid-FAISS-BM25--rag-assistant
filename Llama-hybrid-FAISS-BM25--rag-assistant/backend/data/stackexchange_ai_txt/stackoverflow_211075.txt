[site]: stackoverflow
[post_id]: 211075
[parent_id]: 210421
[tags]: 
I designed a big and complicated system about five years ago. I spent the next five years injecting myself into every project that affected "my" system to keep the barbarians from sullying my architecture. As long as I applied constant, unrelenting pressure I was able to keep the architecture pretty clean, but I was fighting a losing battle. Here's why: 1) Most people are judged on whether they got the job done today . Nobody has ever been reprimanded because they cut a corner (or two) three years ago to get a project out the door on time. On the other hand, many people have been reprimanded for not getting projects out the door on time. 2) You may want to keep the system tidy because you have a sense of ownership over the code, or the application, or the users, etc. Many people will not have a sense of ownership and therefore are all too happy to hack something up so they can be done with it. You can lead a horse to water, but you can't make him care. 3) If you do convince everybody to maintain the code properly, new people will come on board and need to be taught how to do things right. So even if you're successful you can feel like you're failing because you're always fighting the same battle against new opponents. 4) You might actually be wrong. Would it make financial sense for Microsoft to spend twice as many programmer hours making MS-Paint robust and maintainable? Sometimes an ugly hacked-together system is Good Enough. Most good programmers have trouble understanding this, but this is usually because they're good programmers. 5) I swear there are some people who take perverse pleasure in hacking things together either because they can do it faster, or they'll be the only ones who understand it, or they have a childish need to break rules. You can't reason with these people, and the more time you spend arguing with them the closer the project deadline gets, which will force you to hack something together anyway. 6) There's a good chance you understand the system better than they do. What looks like an ugly hack to you might look like "treading lightly" to a person who isn't as familiar with the system. Or the extra effort to make the code robust will protect the programmer against a problem he's never had before and therefore can't grok. You don't learn to check return codes until something goes wrong because you didn't check a return code. At that point it stops being "extra work" and starts being "required work". If you have a small, tight development team it's possible. But the bigger the organization the less likely you are to succeed. If you manage to get a 250-person IT shop to value doing things right over doing things fast then your powers of persuasion are legendary.
