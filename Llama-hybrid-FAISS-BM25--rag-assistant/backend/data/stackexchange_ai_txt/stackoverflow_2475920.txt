[site]: stackoverflow
[post_id]: 2475920
[parent_id]: 
[tags]: 
How to make 2 incompatible types, but with the same members, interchangeable?

Yesterday 2 of the guys on our team came to me with an uncommon problem. We are using a third-party component in one of our winforms applications. All the code has already been written against it. They then wanted to incorporate another third-party component, by the same vender, into our application. To their delight they found that the second component had the exact same public members as the first. But to their dismay, the 2 components have completely separate inheritance hierarchies, and implement no common interfaces. Makes you wonder... Well, makes me wonder. An example of the problem: Incompatible Types http://www.freeimagehosting.net/uploads/f9f6b862f1.png public class ThirdPartyClass1 { public string Name { get { return "ThirdPartyClass1"; } } public void DoThirdPartyStuff () { Console.WriteLine ("ThirdPartyClass1 is doing its thing."); } } public class ThirdPartyClass2 { public string Name { get { return "ThirdPartyClass2"; } } public void DoThirdPartyStuff () { Console.WriteLine ("ThirdPartyClass2 is doing its thing."); } } Gladly they felt copying and pasting the code they wrote for the first component was not the correct answer. So they were thinking of assigning the component instant into an object reference and then modifying the code to do conditional casts after checking what type it was. But that is arguably even uglier than the copy and paste approach. So they then asked me if I can write some reflection code to access the properties and call the methods off the two different object types since we know what they are, and they are exactly the same. But my first thought was that there goes the elegance. I figure there has to be a better, graceful solution to this problem.
