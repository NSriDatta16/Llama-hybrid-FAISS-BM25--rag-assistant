[site]: stackoverflow
[post_id]: 1337748
[parent_id]: 1337721
[tags]: 
Yes. No. Yes. Sort of. Not really. Is this a trick question? Yes! No. No. Okay, here are some real answers. The new operator allocates memory unless there isn't enough available. Even if the constructor of the object fails, and the allocated memory is quickly garbage collected, room for the new object is allocated temporarily. This allocates space for the fields of an ArrayList , which don't depend on the number of elements in the ArrayList , and in addition, it will create enough space for references to 10 objects, which don't depend on the size of the objects themselves; the pointers will be 32 bits on a 32-bit system, and 64 bits (or maybe compressed to something less by a really smart VM someday) on a 64-bit system. This is a simple assignment. Both variables have been assigned the same value. Memory has been allocated initially for 20 object references. However, if more than 20 objects are added to the list, ArrayList will automatically reallocate the necessary storage. Yes. In this case, one can see that no references to the object originally assigned to bList3 can "escape" to be strongly referenced. That unreferenced object is now eligible for garbage collection. bList4 still points to the same object, and that object cannot be garbage collected. That list references all the elements referenced by bList , but they aren't the same. In particular, changes to one list won't affect the other, but changes to the contents of the lists will be visible through either list. No, Java passes references by value, so a method can't cause a caller's reference to refer to a different object.
