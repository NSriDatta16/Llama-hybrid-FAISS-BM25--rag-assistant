[site]: stackoverflow
[post_id]: 4998552
[parent_id]: 4997313
[tags]: 
I have used SQL Profiler to do this. Configure it with the Deadlock graph and Lock: Deadlock events (under "Locks"), along with (my recommended set) columns SPID, HostName, ApplicationName, LoginName, DatabaseName, ObjectID, ObjectID2, OwnerId, Type, Mode, StartTime, EndTime, Duration, and (most importantly) TextData. Start it up, and let it run. If and when deadlocks occur, both events track useful information, but one of them (probably Deadlock graph) traps and records a ton of useful information as XML in the Text column. When the row (event) is selected in the Profiler GUI it will display a graphic showing kinda useful information... but what you do is, extract the XML from the TextData column (cut and paste works fine) and view it in your preferred XML editor to see just about anything you could ever possibly want to know about what caused that $*%& deadlock. Of course, you have to have SQL Profiler running continuosly on someone's box to do this. If you have to wait hours or days for a deadlock to happen, you'll want to set up and mangae a trace on the server itself. (Complex subject, read up on "sp_trace_create" in Books Online for details. SQL Profiler is really just a GUI sitting on top of Trace calls.) Fire them up by hand, or as @Chris.w.mclean suggests, you could configure an autorun procedure to start it up if you want it to always be running (though extracting data from an always running trace is yet another tricky issue). I've also set up a one-time-run SLQ Agent job to start traces when I want them to start (generally when I'm asleep).
