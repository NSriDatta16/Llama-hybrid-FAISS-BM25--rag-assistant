[site]: stackoverflow
[post_id]: 2470116
[parent_id]: 2470098
[tags]: 
They're asking you to create a constructor function called Circle which creates objects that will have get_area , set_radius , and toString functions that behave in the way indicated. ( toString is what will be used in the final statement, where you're outputting the value of the circle instance.) They're probably expecting you to give the objects those functions via the Circle prototype (see below). Circle is a constructor function because it creates new objects (well, technically it just populates them; they're created by the new operator). Sometimes people call these classes , but they're not really classes in the genuine class-based OOP way (they're constructor functions in the genuine prototype-based OOP way used by JavaScript). There are a few ways to do this, but again, typically you'd have a Circle function that sets up the properties for an instance on this , and then assign functions to the Circle.prototype , which all objects created via new Circle will inherit. I'd dash off an example but my impression is that this is a learning exercise, so best left to the reader. But there are some pointers: Inside the constructor function, you can refer to the object created by the new operator using the keyword this . The constructor function object will have a property on it called prototype . If you assign properties to that prototype, they'll be inherited by instances created with your constructor function (inherited through something called the prototype chain ). So if I have a constructor function Foo , I can set a property (say, bar ) on Foo.prototype ( Foo.prototype.bar = /* whatever */; ) and all instances created via new Foo() will have a bar property with that value. Functions in JavaScript are first-class objects. You can refer to them just like you can refer to strings or numbers. If I have function foo() { /* ... */ } , I can set a variable x to refer to it ( var x = foo; ) and then call it via that variable ( x(); ). Just like x can refer to a function, the bar property I mentioned above can refer to a function. Hopefully that puts you on the right track without giving the game entirely away. Re your comment about references for learning more about JavaScript: I found the book JavaScript: The Definitive Guide by David Flanagan (from O'Reilly) to be very good. It may be getting a bit dated, the fifth edition is now several years old. There are a bunch of articles from well-respected JavaScript guru Douglas Crockford at http://javascript.crockford.com , but I warn you that Crockford is terse. :-) Smart and informed, though, even if one doesn't always agree with his conclusions. I really don't like to refer to my blog [because A) SO is not about self-promotion, and B) "anemic" doesn't half say it] but there are a couple of posts there that I think might help . Re my comment below: Really I can't leave this without an example, because it's just not helpful to do so. So here's an example of a constructor function and some functions associated with it: // A constructor function called `Person` function Person(fname, lname) { // Within the constructor, we can refer to the new instance via `this`. // Let's remember the names we were given. this.firstName = fname; this.lastName = lname; // Now, the instance that is returned from `new Person(...)` will have // those properties on it. } // Let's give the Person prototype a function that returns the person's // full name. Person.prototype.getFullName = function() { return this.firstName + " " + this.lastName; }; // Okay, let's see `Person` in action: var p = new Person("John", "Doe"); console.log(p.firstName); // "John" -- this is referencing the property we set in the constructor console.log(p.getFullName()); // "John Doe" -- this calls the function we get from the prototype // `p` has the `getFullName` function because it inherits it from the // `Person.prototype` object. // Let's see what happens if I try to output the instance itself: console.log(p); // Most like you get "[object Object]" or similar -- not useful! // In that sort of situation, JavaScript will use a function called `toString` // to get a string equivalent of the instance. (It's more complicated than that, // but you don't want me to go into the details here.) So let's give // `Person.prototype` a `toString` function that does something useful: Person.prototype.toString = function() { return this.getFullName(); }; // Note there that we're using `this` again. When a function is called through // an object property (e.g., `p.toString()`), within the function call `this` // refers to the object instance. `this` is an important and flexible concept // in JavaScript and very much unlike its counterpart in (say) Java or C++, // even though in simple situations (like this) it looks similar. // Now let's try it: console.log(p); // "John Doe", because the interpreter implicitly calls `toString` for you // "Hey, wait a minute!" I hear you saying, "You didn't make a new `p`! How did it // get the new function?!" The answer is it got it the same way it got `getFullName`: // from `Person.prototype`. The `p` instance *refers* to the `Person.prototype`, it // doesn't have a *copy* of it. So changes to `Person.prototype` show up in `p` // (unless `p` overrides them, which we aren't doing in this example). (That example uses anonymous functions, which I'm not a fan of , but I didn't want to get into the whole discussion of named functions here.) (OT: Being picky, the person posing this question to you really should have declared the circle variable at the very beginning: var circle; Also, note that console.log may not exist in all JavaScript implementations -- it's best known from Firefox+Firebug.)
