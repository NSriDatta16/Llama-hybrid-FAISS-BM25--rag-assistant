[site]: stackoverflow
[post_id]: 1693335
[parent_id]: 1693315
[tags]: 
I don't believe there is a conforming interface that does what you want. I can think of a few tricks, however. You could have the failure-prone thread call a wrapper around free() instead of free() directly; the wrapper could save the address or the last few addresses so that you can determine if the block was released. You could also block signals, establish a critical section, or deal with whatever else might interrupt the *thread. Update: Does the dying thread ever free this memory prior to exit/cleanup? I've frequently written malloc front-ends (as a speed optimization) for memory that doesn't need to be freed in a steady-state. If the thread is just setting itself up, you could malloc the memory prior to thread launch and have the thread call a front-end that just hands out unlinked, unfreeable pieces of the dynamic block. It will run faster and then when the thread dies you can just free the whole block all at once. The general idea here is to have the failure-prone thread get its memory by calling a service that can clean up after-the-fact. Yet another idea: what about a per-thread heap? If threads could be persuaded to allocate memory needed only during their lifetime from their own heap, that would nicely organize the cleanup task into freeing the entire thread heap when the thread rejoins a parent.
