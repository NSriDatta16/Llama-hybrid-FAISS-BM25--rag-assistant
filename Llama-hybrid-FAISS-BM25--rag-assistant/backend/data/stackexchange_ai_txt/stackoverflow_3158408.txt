[site]: stackoverflow
[post_id]: 3158408
[parent_id]: 
[tags]: 
.Net Unit test compile error - The type or method has 2 generic parameter(s), but 1 generic argument(s) were provided

We've got a generic class which contains a private class which uses the outer class's generic type parameter. Example: public class Foo { private class Bar : IGrouping { } } The problem is that we get a compile error in a unit test project which states "The Type or method has 2 generic parameter(s), but 1 generic argument(s) were provided. A generic argument must be provided for each generic parameter." I cranked up MSBuild verbosity (Tools > Options > Projects and Solutions > Build and Run). Looking at the error location, it points to the Microsoft.TeamTest.targets file. I was able to narrow it down to this class structure above. If I replace the private class Bar with concrete generic parameters in the class definition (see below), the unit test compiles fine: private class Bar : IGrouping { } I need to provide that second generic parameter generic to accept whatever the type is in the outter class. Thoughts on this one? To clarify, the compile error is in the Unit Test Project, not the code listed above (which compiles fine). Perhaps the private accessor generation is choking in the MS unit test infrastructure? Here's [almost] the entire actual code: public class CategoryStorageService : StorageServiceBase , ICategoryStorageService where T : IStorageContent, new() { /// /// Returns a nested object graph of category-items /// /// /// public IEnumerable > GetContent(params StorageCategory[] categories) { var results = this.GetContent(categories.Select(c => c.ID).ToArray()); foreach (var result in results) { yield return new LocalNameGrouping( categories.First(c => c.ID == result.Key.ID), result); } } /// /// Returns a nested object graph of categories, each containing their items /// /// The ID(s) of the category(ies) to fetch /// private IEnumerable > GetContent(params Guid[] categories) { // implementation removed return null; } private class LocalNameGrouping : IGrouping { private IEnumerable items; private StorageCategory category; public LocalNameGrouping(StorageCategory localCategory, IGrouping items) { this.items = items; string name = string.IsNullOrEmpty(localCategory.DisplayName) ? items.Key.DisplayName : localCategory.DisplayName; this.category = new StorageCategory { DisplayName = name, ID = items.Key.ID }; } #region IGrouping Members public StorageCategory Key { get { return category; } } #endregion #region IEnumerable Members public IEnumerator GetEnumerator() { return items.GetEnumerator(); } #endregion #region IEnumerable Members System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.GetEnumerator(); } #endregion }
