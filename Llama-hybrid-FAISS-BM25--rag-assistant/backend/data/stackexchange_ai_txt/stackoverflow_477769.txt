[site]: stackoverflow
[post_id]: 477769
[parent_id]: 477750
[tags]: 
As explained in short C# (but also for other language compilers as well, like Java) There is a predefined implicit conversion from short to int, long, float, double, or decimal. You cannot implicitly convert nonliteral numeric types of larger storage size to short (see Integral Types Table for the storage sizes of integral types). Consider, for example, the following two short variables x and y: short x = 5, y = 12; The following assignment statement will produce a compilation error, because the arithmetic expression on the right-hand side of the assignment operator evaluates to int by default. short z = x + y; // Error: no conversion from int to short To fix this problem, use a cast: short z = (short)(x + y); // OK: explicit conversion It is possible though to use the following statements, where the destination variable has the same storage size or a larger storage size: int m = x + y; long n = x + y; A good follow-up question is: "why arithmetic expression on the right-hand side of the assignment operator evaluates to int by default" ? A first answer can be found in: Classifying and Formally Verifying Integer Constant Folding The Java language specification defines exactly how integer numbers are represented and how integer arithmetic expressions are to be evaluated . This is an important property of Java as this programming language has been designed to be used in distributed applications on the Internet. A Java program is required to produce the same result independently of the target machine executing it . In contrast, C (and the majority of widely-used imperative and object-oriented programming languages) is more sloppy and leaves many important characteristics open. The intention behind this inaccurate language specification is clear. The same C programs are supposed to run on a 16-bit, 32-bit, or even 64-bit architecture by instantiating the integer arithmetics of the source programs with the arithmetic operations built-in in the target processor. This leads to much more eﬃcient code because it can use the available machine operations directly. As long as the integer computations deal only with numbers being “sufficiently small”, no inconsistencies will arise. In this sense, the C integer arithmetic is a placeholder which is not defined exactly by the programming language specification but is only completely instantiated by determining the target machine. Java precisely defines how integers are represented and how integer arithmetic is to be computed. Java Integers -------------------------- Signed | Unsigned -------------------------- long (64-bit) | int (32-bit) | short (16-bit) | char (16-bit) byte (8-bit) | Char is the only unsigned integer type. Its values represent Unicode characters, from \u0000 to \uffff , i.e. from 0 to 2 16 −1. If an integer operator has an operand of type long, then the other operand is also converted to type long. Otherwise the operation is performed on operands of type int, if necessary shorter operands are converted into int . The conversion rules are exactly specified. [From Electronic Notes in Theoretical Computer Science 82 No. 2 (2003) Blesner-Blech-COCV 2003: Sabine GLESNER , Jan Olaf BLECH, Fakultät für Informatik, Universität Karlsruhe Karlsruhe, Germany]
