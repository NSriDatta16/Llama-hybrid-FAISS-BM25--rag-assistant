[site]: stackoverflow
[post_id]: 1290710
[parent_id]: 1290681
[tags]: 
Here's a solution that leverages the fact that a boolean comparison returns the integers 1 or 0: SELECT * FROM ( SELECT ID, (Col1='a') + (Col2='c') + (Col3=1) + (Col4=5) AS calculated FROM MyTable ) q WHERE calculated > 1; Note that you have to parenthesize the boolean comparisons because + has higher precedence than = . Also, you have to put it all in a subquery because you normally can't use a column alias in a WHERE clause of the same query. It might seem like you should also use a WHERE clause in the subquery to restrict its rows, but in all likelihood you're going to end up with a full table scan anyway so it's probably not a big win. On the other hand, if you expect that such a restriction would greatly reduce the number of rows in the subquery result, then it'd be worthwhile. Re Quassnoi's comment, if you can't treat boolean expressions as integer values, there should be a way to map boolean conditions to integers, even if it's a bit verbose. For example: SELECT * FROM ( SELECT ID, CASE WHEN Col1='a' THEN 1 ELSE 0 END + CASE WHEN Col2='c' THEN 1 ELSE 0 END + CASE WHEN Col3=1 THEN 1 ELSE 0 END + CASE WHEN Col4=5 THEN 1 ELSE 0 END AS calculated FROM MyTable ) q WHERE calculated > 1;
