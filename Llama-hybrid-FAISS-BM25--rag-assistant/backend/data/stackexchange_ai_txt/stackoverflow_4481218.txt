[site]: stackoverflow
[post_id]: 4481218
[parent_id]: 4130161
[tags]: 
Memoization is a good way to write a faster recursive function. However, in this case there is a recursive alternative that runs tremendously faster than original function, without requiring memoization. The key observation is to see that the original definition performs a lot of redundant calculations. Consider what happens if we calculate fib[4] : fib[4] = fib[3] + fib[2] fib[3] = fib[2] + fib[1] fib[2] = fib[1] + fib[0] fib[1] = 1 fib[0] = 1 ∴ fib[2] = 1 + 1 = 2 fib[1] = 1 ∴ fib[3] = 2 + 1 = 3 fib[2] = fib[1] + fib[0] fib[1] = 1 fib[0] = 1 ∴ fib[2] = 1 + 1 = 2 ∴ fib[4] = 2 + 1 = 3 In this process, fib[2] and fib[0] were computed twice each and fib[1] was computed thrice. For larger computations, the waste grows dramatically -- exponentially in fact. If one were to calculate the same Fibonacci number by hand, one might proceed something like this: 0: given 0 1: given 1 2: 0 + 1 = 1 3: 1 + 1 = 2 4: 1 + 2 = 3 There are no redundant calculations. At any given point, one only needs to consider the previous two results. This latter approach can be expressed recursively thus: fib2[0] = 0; fib2[n_] := Module[{f}, f[n, p1_, _] := p1; f[x_, p1_, p2_] := f[x + 1, p1 + p2, p1]; f[1, 1, 0] ] Block[{$IterationLimit = Infinity}, fib2[100000]] No doubt, this form is not as easy to read as the original. On the other hand, the original function took 35 seconds to compute fib[35] on my machine whereas the revised function's runtime for same was reported as zero. Furthermore, the revised function computes fib2[100000] in 0.281 seconds, without requiring any of the extra storage of memoization. fib[100000] is quite out of reach of the original function and the memoized version crashed my Mathematica 7.01 kernel -- too many memoized rules perhaps? Note that Mathematica, by default, will iterate a function no more than 4096 times. To raise that limit, you must assign a higher value to $IterationLimit as illustrated in the example above. Of course, in Mathematica there are plenty of non-recursive ways to calculate Fibonacci numbers, up to and including the built-in Fibonacci function. But that is not the point of this exercise. Tail Call Optimization? It is always desirable to express recursive functions using tail calls . This permits the recursion to be executed by simple iteration, without the overhead of retaining intermediate results on the stack. fib2 is tail recursive. Some languages, like Scheme, mandate tail call optimization. Other languages, like Java , could support it but don't (or won't, as in the case of Python ). In the case of Mathematica, it is not clear to what extent tail call optimization is performed. For further discussion of this point, see another SO question .
