[site]: stackoverflow
[post_id]: 3385293
[parent_id]: 3385204
[tags]: 
Look in the import statement reference , a long and involved description. The simple method is to include the module's location in sys.path . I'm quoting the starting paragraph only: Once the name of the module is known (unless otherwise specified, the term “module” will refer to both packages and modules), searching for the module or package can begin. The first place checked is sys.modules , the cache of all modules that have been imported previously . If the module is found there then it is used in step (2) of import. If the module is not found in the cache, then sys.meta_path is searched (the specification for sys.meta_path can be found in PEP 302). The object is a list of finder objects which are queried in order as to whether they know how to load the module by calling their find_module() method with the name of the module. If the module happens to be contained within a package (as denoted by the existence of a dot in the name), then a second argument to find_module() is given as the value of the path attribute from the parent package (everything up to the last dot in the name of the module being imported). If a finder can find the module it returns a loader (discussed later) or returns None. If none of the finders on sys.meta_path are able to find the module then some implicitly defined finders are queried. Implementations of Python vary in what implicit meta path finders are defined. The one they all do define, though, is one that handles sys.path_hooks , sys.path_importer_cache , and sys.path .
