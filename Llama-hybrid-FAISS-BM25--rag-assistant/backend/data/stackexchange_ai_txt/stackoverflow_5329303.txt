[site]: stackoverflow
[post_id]: 5329303
[parent_id]: 5329149
[tags]: 
From the MAN pages NAME kvm_getmaxcpu, kvm_getpcpu -- access per-CPU data LIBRARY Kernel Data Access Library (libkvm, -lkvm) SYNOPSIS #include #include #include #include int kvm_getmaxcpu(kvm_t *kd); void * kvm_getpcpu(kvm_t *kd, int cpu); DESCRIPTION The kvm_getmaxcpu() and kvm_getpcpu() functions are used to access the per-CPU data of active processors in the kernel indicated by kd. The kvm_getmaxcpu() function returns the maximum number of CPUs supported by the kernel. The kvm_getpcpu() function returns a buffer holding the per- CPU data for a single CPU. This buffer is described by the struct pcpu type. The caller is responsible for releasing the buffer via a call to free(3) when it is no longer needed. If cpu is not active, then NULL is returned instead. CACHING These functions cache the nlist values for various kernel variables which are reused in successive calls. You may call either function with kd set to NULL to clear this cache. RETURN VALUES On success, the kvm_getmaxcpu() function returns the maximum number of CPUs supported by the kernel. If an error occurs, it returns -1 instead. On success, the kvm_getpcpu() function returns a pointer to an allocated buffer or NULL. If an error occurs, it returns -1 instead. If either function encounters an error, then an error message may be retrieved via kvm_geterr(3.) EDIT Here's the kvm_t struct: struct __kvm { /* * a string to be prepended to error messages * provided for compatibility with sun's interface * if this value is null, errors are saved in errbuf[] */ const char *program; char *errp; /* XXX this can probably go away */ char errbuf[_POSIX2_LINE_MAX]; #define ISALIVE(kd) ((kd)->vmfd >= 0) int pmfd; /* physical memory file (or crashdump) */ int vmfd; /* virtual memory file (-1 if crashdump) */ int unused; /* was: swap file (e.g., /dev/drum) */ int nlfd; /* namelist file (e.g., /kernel) */ struct kinfo_proc *procbase; char *argspc; /* (dynamic) storage for argv strings */ int arglen; /* length of the above */ char **argv; /* (dynamic) storage for argv pointers */ int argc; /* length of above (not actual # present) */ char *argbuf; /* (dynamic) temporary storage */ /* * Kernel virtual address translation state. This only gets filled * in for dead kernels; otherwise, the running kernel (i.e. kmem) * will do the translations for us. It could be big, so we * only allocate it if necessary. */ struct vmstate *vmst; };
