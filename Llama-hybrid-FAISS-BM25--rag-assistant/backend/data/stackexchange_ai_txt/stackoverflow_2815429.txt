[site]: stackoverflow
[post_id]: 2815429
[parent_id]: 2815388
[tags]: 
I think that one clear functional approach would be to define a data type that represents the various (more complicated situations) that you need to handle. You mentioned that a value may be optional and that you need to distinguish numeric and textual values (for the encoding to SQL). You could define a discriminated union (if there are other cases that you'd like to handle, the definition may be a bit more complicated): type SqlValue = | Missing | Numeric of string | Textual of string Note that the Textual case also carries string , because I assume that the client who produces the value takes care of converting it to string - this is only information for your SQL query generator (so that it knows whether it needs to add quotes). Your ToSqlValuesList member would return a list of values string & SqlValue , so for example, a sample product could be represented using the following list: columns = [ "Name"; "Price"; "Description" ] values = [ Textual("Tea"); Numeric(10); Missing ] In the code that generates the SQL query, you'd use pattern matching to handle all the different cases (most importantly, encode string to avoid SQL injection in case the value is Textual :-)). EDIT You'd need to implement the conversion from the specific data types to the SqlValue representation in every client. However, this can be simplified by writing a utility type (using the fact that members can be overloaded): type SqlValue with static member From(a:int) = Numeric(a.ToString()) static member From(a:int option) = match a with None -> Missing | Some(n) -> SqlValue.From(n) // ... similarly for other types In the implementation of ToSqlValuesList , you would write SqlValue.From(description) and it would deal with the details autoamtically. A more sophisticated approach would be to annotate public members of the types representing your data entities with .NET attributes and use Reflection to extract the values (and their types) at runtime. This is more advanced, but quite elegant (there is a nice exmaple of this technique in Don Syme's Expert F# book)
