[site]: stackoverflow
[post_id]: 5665969
[parent_id]: 5663897
[tags]: 
The following gives you an idea on how to obtain the Cartesian coordinates on a Jung VisualizationViewer instance... Create an inner class as follows: protected class MyGraphMousePlugin extends TranslatingGraphMousePlugin implements MouseListener { @Override public void mouseMoved(MouseEvent e) { final VisualizationViewer vv = (VisualizationViewer )e.getSource(); Point2D p = e.getPoint();//vv.getRenderContext().getBasicTransformer().inverseViewTransform(e.getPoint()); GraphElementAccessor pickSupport = vv.getPickSupport(); if(pickSupport != null) { vv.setToolTipText (" x: "+p.getX()+" y: "+p.getY()); } } public MyGraphMousePlugin(int modifiers) { super(modifiers); // TODO Auto-generated constructor stub } public MyGraphMousePlugin() { super(); } } Add the plugin to your GraphMouse instance: graphMouse = new DefaultModalGraphMouse (); vv.setGraphMouse(graphMouse); vv.addKeyListener(graphMouse.getModeKeyListener()); graphMouse.add(new MyGraphMousePlugin()); Edited: Next modification will give you the Cartesian coordinates that take into account the translation made upon a Jung graph layout: protected class MyGraphMousePlugin extends TranslatingGraphMousePlugin implements MouseListener { @Override public void mouseMoved(final MouseEvent e) { SwingUtilities.invokeLater( new Runnable() { public void run() { final VisualizationViewer vv = (VisualizationViewer )e.getSource(); Point2D p = e.getPoint();//vv.getRenderContext().getBasicTransformer().inverseViewTransform(e.getPoint()); GraphElementAccessor pickSupport = vv.getPickSupport(); if(pickSupport != null) { AffineTransform lat = vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.LAYOUT).getTransform(); //AffineTransform vat = // vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.VIEW).getTransform(); //AffineTransform at = new AffineTransform(); double x = p.getX() - lat.getTranslateX(); //; double y = p.getY() - lat.getTranslateY(); //; vv.setToolTipText (" x: "+x+" y: "+y); } } } ); } public MyGraphMousePlugin(int modifiers) { super(modifiers); // TODO Auto-generated constructor stub } public MyGraphMousePlugin() { super(); } } It is still not perfect since it omits the scale factor, but you will get the idea... You need to calculate from the screen coordinate system to the view coordinate system to the model coordinate system to get the model's coordinates. The generic types in the above codes should be changed to your own version :) Edited Haha, the clue is already there and it is the correct way...no need to calculate! http://sourceforge.net/projects/jung/forums/forum/252062/topic/3040266?message=6522779 @Override public void mouseMoved(final MouseEvent e) { SwingUtilities.invokeLater( new Runnable() { public void run() { final VisualizationViewer vv = (VisualizationViewer )e.getSource(); Point2D p = vv.getRenderContext().getMultiLayerTransformer().inverseTransform(e.getPoint()); double x = p.getX(); double y = p.getY(); vv.setToolTipText (" x: "+(int)x+" y: "+(int)y); } } ); }
