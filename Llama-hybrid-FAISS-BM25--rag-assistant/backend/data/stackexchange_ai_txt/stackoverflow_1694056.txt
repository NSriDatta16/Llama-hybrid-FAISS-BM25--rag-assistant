[site]: stackoverflow
[post_id]: 1694056
[parent_id]: 1693315
[tags]: 
If you are calling free with a valid pointer, I don't see how it would fail. If it is failing, it must be due to an invalid pointer. In addition to synchronizing access to shared memory (with a mutex , for example), ownership must be clear too to avoid cases like double-freeing. Double-freeing is when two or more threads have a valid pointer, but then more than one thread attempts to free the memory. Despite the second thread having a non-null pointer, it is no longer valid. If you are plagued with memory issues in C/C++, you might try a memory library like HeapAgent . A memory library like this will instrument and initialize each memory allocation. Before freeing memory, it checks if the memory pointer is valid first and there were no buffer overrun errors. There should be no code changes as it can simply replace the built-in malloc/free. In addition, the library can help find memory leaks, overwrites, and invalid references. Another strategy to address your problem may be to centralize the resource cleanup to one thread. When a thread is done with the resource, it just marks it available to be cleaned up by the garbage collector thread. Of course, then there is Plan C -- use Java... Just kidding.
