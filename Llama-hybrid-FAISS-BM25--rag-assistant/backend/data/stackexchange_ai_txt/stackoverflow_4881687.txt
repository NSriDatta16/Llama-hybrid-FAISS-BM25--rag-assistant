[site]: stackoverflow
[post_id]: 4881687
[parent_id]: 4788344
[tags]: 
A Dynamic Programing Algorithm It seems what you are looking for is very similar to what the Smithâ€“Waterman algorithm does. From Wikipedia: The algorithm was first proposed by Temple F. Smith and Michael S. Waterman in 1981. Like the Needleman-Wunsch algorithm, of which it is a variation, Smith-Waterman is a dynamic programming algorithm . As such, it has the desirable property that it is guaranteed to find the optimal local alignment with respect to the scoring system being used (which includes the substitution matrix and the gap-scoring scheme). Let's see a practical example, so you can evaluate its usefulness. Suppose we have a text: text = "We the people of the United States, in order to form a more perfect union, establish justice, insure domestic tranquility, provide for the common defense, promote the general welfare, and secure the blessings of liberty to ourselves and our posterity, do ordain and establish this Constitution for the United States of America."; I isolated the segment we are going to match, just for your easy of reading. We will compare the affinity (or similarity) with a list of strings: list = { "the general welfare", "my personal welfare", "general utopian welfare", "the general", "promote welfare", "stackoverflow rulez" }; I have the algorithm already implemented, so I'll calculate the similarity and normalize the results: sw = SmithWatermanSimilarity[ text, #] & /@ list; swN = (sw - Min[sw])/(Max[sw] - Min[sw]) Then we Plot the results: I think it's very similar to your expected result. HTH! Some implementations (w/source code) Smith-Waterman CUDA Source Code (GSW) The S-M algorithm explained (presentation) An interactive step-by-step demo applet Java Source code Python source code
