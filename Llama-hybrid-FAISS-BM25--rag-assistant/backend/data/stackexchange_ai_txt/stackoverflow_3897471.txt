[site]: stackoverflow
[post_id]: 3897471
[parent_id]: 3749678
[tags]: 
To expand a convex polygon, draw a line parallel to each edge and the given number of units away. Then use the intersection points of the new lines as the vertices of the expanded polygon. The javascript/canvas at the end follows this functional breakdown: Step 1: Figure out which side is "out" The order of the vertices (points) matters. In a convex polygon, they can be listed in a clockwise (CW), or a counter-clockwise (CCW) order. In a CW polygon, turn one of the edges 90 degrees CCW to obtain an outward-facing normal. On a CCW polygon, turn it CW instead. If the turn direction of the vertices is not known in advance, examine how the second edge turns from the first. In a convex polygon, the remaining edges will keep turning in the same direction: Find the CW normal of the first edge . We don't know yet whether it's facing inward or outward. Compute the dot product of the second edge with the normal we computed. If the second edge turns CW, the dot product will be positive. It will be negative otherwise. Math: // in vector terms: v01 = p1 - p0 // first edge, as a vector v12 = p2 - p1 // second edge, as a vector n01 = (v01.y, -v01.x) // CW normal of first edge d = v12 * n01 // dot product // and in x,y terms: v01 = (p1.x-p0.x, p1.y-p0.y) // first edge, as a vector v12 = (p2.x-p1.x, p2.y-p1.y) // second edge, as a vector n01 = (v01.y, -v01.x) // CW normal of first edge d = v12.x * n01.x + v12.y * n01.y; // dot product: v12 * n01 if (d > 0) { // the polygon is CW } else { // the polygon is CCW } // and what if d==0 ? // -- that means the second edge continues in the same // direction as a first. keep looking for an edge that // actually turns either CW or CCW. Code: function vecDot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; } function vecRot90CW(v) { return { x: v.y, y: -v.x }; } function vecRot90CCW(v) { return { x: -v.y, y: v.x }; } function polyIsCw(p) { return vecDot( vecRot90CW({ x: p[1].x - p[0].x, y: p[1].y - p[0].y }), { x: p[2].x - p[1].x, y: p[2].y - p[1].y }) >= 0; } var rot = polyIsCw(p) ? vecRot90CCW : vecRot90CW; Step 2: Find lines parallel to the polygon edges Now that we know which side is out, we can compute lines parallel to each polygon edge, at exactly the required distance. Here's our strategy: For each edge, compute its outward-facing normal Normalize the normal, such that its length becomes one unit Multiply the normal by the distance we want the expanded polygon to be from the original Add the multiplied normal to both ends of the edge. That will give us two points on the parallel line. Those two points are enough to define the parallel line. Code: // given two vertices pt0 and pt1, a desired distance, and a function rot() // that turns a vector 90 degrees outward: function vecUnit(v) { var len = Math.sqrt(v.x * v.x + v.y * v.y); return { x: v.x / len, y: v.y / len }; } function vecMul(v, s) { return { x: v.x * s, y: v.y * s }; } var v01 = { x: pt1.x - pt0.x, y: pt1.y - pt0.y }; // edge vector var d01 = vecMul(vecUnit(rot(v01)), distance); // multiplied unit normal var ptx0 = { x: pt0.x + d01.x, y: pt0.y + d01.y }; // two points on the var ptx1 = { x: pt1.x + d01.x, y: pt1.y + d01.y }; // parallel line Step 3: Compute the intersections of the parallel lines --these will be the vertices of the expanded polygon. Math: A line going through two points P1 , P2 can be described as: P = P1 + t * (P2 - P1) Two lines can be described as P = P1 + t * (P2 - P1) P = P3 + u * (P4 - P3) And their intersection has to be on both lines: P = P1 + t * (P2 - P1) = P3 + u * (P4 - P3) This can be massaged to look like: (P2 - P1) * t + (P3 - P4) * u = P3 - P1 Which in x,y terms is: (P2.x - P1.x) * t + (P3.x - P4.x) * u = P3.x - P1.x (P2.y - P1.y) * t + (P3.y - P4.y) * u = P3.y - P1.y As the points P1, P2, P3 and P4 are known, so are the following values: a1 = P2.x - P1.x a2 = P2.y - P1.y b1 = P3.x - P4.x b2 = P3.y - P4.y c1 = P3.x - P1.x c2 = P3.y - P1.y This shortens our equations to: a1*t + b1*u = c1 a2*t + b2*u = c2 Solving for t gets us: t = (b1*c2 - b2*c1)/(a2*b1 - a1*b2) Which lets us find the intersection at P = P1 + t * (P2 - P1) . Code: function intersect(line1, line2) { var a1 = line1[1].x - line1[0].x; var b1 = line2[0].x - line2[1].x; var c1 = line2[0].x - line1[0].x; var a2 = line1[1].y - line1[0].y; var b2 = line2[0].y - line2[1].y; var c2 = line2[0].y - line1[0].y; var t = (b1*c2 - b2*c1) / (a2*b1 - a1*b2); return { x: line1[0].x + t * (line1[1].x - line1[0].x), y: line1[0].y + t * (line1[1].y - line1[0].y) }; } Step 4: Deal with special cases There is a number of special cases that merit attention. Left as an exercise to the reader... When there's a very sharp angle between two edges, the expanded vertex can be very far from the original one. You might want to consider clipping the expanded edge if it goes beyond some threshold. At the extreme case, the angle is zero, which suggests that the expanded vertex is at infinity, causing division by zero in the arithmetic. Watch out. When the first two edges are on the same line, you can't tell if it's a CW or a CCW polygon by looking just at them. Look at more edges. Non convex polygons are much more interesting... and are not tackled here. Full sample code Drop this in a canvas-capable browser. I used Chrome 6 on Windows. The triangle and its expanded version should animate. canvas { border: 1px solid #ccc; } $(function() { var canvas = document.getElementById('canvas'); if (canvas.getContext) { var context = canvas.getContext('2d'); // math for expanding a polygon function vecUnit(v) { var len = Math.sqrt(v.x * v.x + v.y * v.y); return { x: v.x / len, y: v.y / len }; } function vecMul(v, s) { return { x: v.x * s, y: v.y * s }; } function vecDot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; } function vecRot90CW(v) { return { x: v.y, y: -v.x }; } function vecRot90CCW(v) { return { x: -v.y, y: v.x }; } function intersect(line1, line2) { var a1 = line1[1].x - line1[0].x; var b1 = line2[0].x - line2[1].x; var c1 = line2[0].x - line1[0].x; var a2 = line1[1].y - line1[0].y; var b2 = line2[0].y - line2[1].y; var c2 = line2[0].y - line1[0].y; var t = (b1*c2 - b2*c1) / (a2*b1 - a1*b2); return { x: line1[0].x + t * (line1[1].x - line1[0].x), y: line1[0].y + t * (line1[1].y - line1[0].y) }; } function polyIsCw(p) { return vecDot( vecRot90CW({ x: p[1].x - p[0].x, y: p[1].y - p[0].y }), { x: p[2].x - p[1].x, y: p[2].y - p[1].y }) >= 0; } function expandPoly(p, distance) { var expanded = []; var rot = polyIsCw(p) ? vecRot90CCW : vecRot90CW; for (var i = 0; i 0) ? i - 1 : p.length - 1]; var pt1 = p[i]; var pt2 = p[(i 400) { pt.vx = -pt.vx; } if (pt.y 400) { pt.vy = -pt.vy; } } context.clearRect(0, 0, 800, 400); drawPolyWithMargin(p, 10); }, 50); } }); sample code disclaimers: the sample sacrifices some efficiency for the sake of clarity. In your code, you may want to compute each edge's expanded parallel just once, and not twice as in here the canvas's y coordinate grows downward, which inverts the CW/CCW logic. Things keep on working though as we just need to turn the outward normals in a direction opposite to the polygon's -- and both get flipped.
