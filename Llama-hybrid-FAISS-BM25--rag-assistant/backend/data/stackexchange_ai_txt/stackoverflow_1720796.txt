[site]: stackoverflow
[post_id]: 1720796
[parent_id]: 1718666
[tags]: 
You do need to handle a windows message to do it, but it's not complicated. You have to handle the WM_WINDOWPOSCHANGING message, doing that in WPF requires a bit of boilerplate code, you can see below the actual logic is just two lines of code. internal enum WM { WINDOWPOSCHANGING = 0x0046, } [StructLayout(LayoutKind.Sequential)] internal struct WINDOWPOS { public IntPtr hwnd; public IntPtr hwndInsertAfter; public int x; public int y; public int cx; public int cy; public int flags; } private void Window_SourceInitialized(object sender, EventArgs ea) { HwndSource hwndSource = (HwndSource)HwndSource.FromVisual((Window)sender); hwndSource.AddHook(DragHook); } private static IntPtr DragHook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handeled) { switch ((WM)msg) { case WM.WINDOWPOSCHANGING: { WINDOWPOS pos = (WINDOWPOS)Marshal.PtrToStructure(lParam, typeof(WINDOWPOS)); if ((pos.flags & (int)SWP.NOMOVE) != 0) { return IntPtr.Zero; } Window wnd = (Window)HwndSource.FromHwnd(hwnd).RootVisual; if (wnd == null) { return IntPtr.Zero; } bool changedPos = false; // *********************** // Here you check the values inside the pos structure // if you want to override them just change the pos // structure and set changedPos to true // *********************** // this is a simplified version that doesn't work in high-dpi settings // pos.cx and pos.cy are in "device pixels" and MinWidth and MinHeight // are in "WPF pixels" (WPF pixels are always 1/96 of an inch - if your // system is configured correctly). if(pos.cx
