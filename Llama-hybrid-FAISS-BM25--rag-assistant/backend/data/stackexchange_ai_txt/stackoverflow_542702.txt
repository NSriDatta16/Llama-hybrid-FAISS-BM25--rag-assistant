[site]: stackoverflow
[post_id]: 542702
[parent_id]: 542353
[tags]: 
It seems that there are two options: (1) use an NSTableView and (2) use an NSTextView. Console.app appears to use an NSTableView but an NSTextView is probably less code. For (1), I would write an NSTableDataSource that returns the appropriate line (either from memory or from disk) for tableView_objectValueForTableColumn_rowIndex_ and the total number of log lines for numberOfRowsInTableView_ . Set this data source as the dataSource for an NSTableView. You may need to call tableView.reloadData() to redisplay the data when a new log line comes in. Assuming the table view is embedded in an NSScrollView (the default if you create the table view in Interface Builder), you can scroll to the bottom with this method from the Apple Scroll View Programming Guide (easily translated to Python) - (void)scrollToBottom:sender; { NSPoint newScrollOrigin; // assume that the scrollview is an existing variable if ([[scrollview documentView] isFlipped]) { newScrollOrigin=NSMakePoint(0.0,NSMaxY([[scrollview documentView] frame]) -NSHeight([[scrollview contentView] bounds])); } else { newScrollOrigin=NSMakePoint(0.0,0.0); } [[scrollview documentView] scrollPoint:newScrollOrigin]; } Obviously, this code assumes that you've got an IBOutlet to the scroll view. For (2), you can add a line to the end of the text view with textView.textStorage().appendString_(new_log + '\n') (assuming there isn't already a newline on the end). You can force the enclosing scroll view to scroll to the end (indirectoy) by calling textView.setSelectedRange_(NSMakeRange(textView.textStorage().length(),0))
