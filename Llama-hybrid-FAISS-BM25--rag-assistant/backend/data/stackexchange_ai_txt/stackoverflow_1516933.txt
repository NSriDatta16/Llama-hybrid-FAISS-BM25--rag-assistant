[site]: stackoverflow
[post_id]: 1516933
[parent_id]: 
[tags]: 
two methods of composing functions, how different in efficiency?

Let f transform one value to another, then I'm writing a function that repeats the transformation n times. I have come up with two different ways: One is the obvious way that literally applies the function n times, so repeat(f, 4) means x → f(f(f(f(x)))) The other way is inspired from the fast method for powering, which means dividing the problem into two problems that are half as large whenever n is even. So repeat(f, 4) means x → g(g(x)) where g(x) = f(f(x)) At first I thought the second method wouldn't improve efficiency that much. At the end of the day, we would still need to apply f n times, wouldn't we? In the above example, g would still be translated into f o f without any further simplification, right? However, when I tried out the methods, the latter method was noticeable faster. ;; computes the composite of two functions (define (compose f g) (lambda (x) (f (g x)))) ;; identify function (define (id x) x) ;; repeats the application of a function, naive way (define (repeat1 f n) (define (iter k acc) (if (= k 0) acc (iter (- k 1) (compose f acc)))) (iter n id)) ;; repeats the application of a function, divide n conquer way (define (repeat2 f n) (define (iter f k acc) (cond ((= k 0) acc) ((even? k) (iter (compose f f) (/ k 2) acc)) (else (iter f (- k 1) (compose f acc))))) (iter f n id)) ;; increment function used for testing (define (inc x) (+ x 1)) In fact, ((repeat2 inc 1000000) 0) was much faster than ((repeat1 inc 1000000) 0) . My question is in what aspect was the second method more efficient than the first? Did re-using the same function object preserves storage and reduces the time spent for creating new objects? After all, the application has to be repeated n times, or saying it another way, x→((x+1)+1) cannot be automatically reduced to x→(x+2) , right? I'm running on DrScheme 4.2.1. Thank you very much.
