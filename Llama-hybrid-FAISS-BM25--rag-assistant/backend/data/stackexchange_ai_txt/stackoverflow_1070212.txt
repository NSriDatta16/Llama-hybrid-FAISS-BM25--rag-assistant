[site]: stackoverflow
[post_id]: 1070212
[parent_id]: 1070136
[tags]: 
You are on the right track. Some of the concrete implementations you probably can test, such as Data Access Components. Automated testing against a relational database is most certainly possible, but should also be factored out into its own library (with a corresponding unit test library). Since you are already using Dependency Injection, it should be a piece of cake for you compose such a dependency back into your real application. On the other hand, there will also be concrete dependencies that are essentially un-testable (or de-testable, as Fowler once joked). Such implementations should be kept as thin as possible. Often, it is possible to design the API that such a Dependency exposes in such a way that all the logic happens in the consumer, and the complexity of the real implementation is very low. Implementing such concrete Dependencies is an explicit design decision, and when you make that decision, you simultaneously decide that such a library should not be unit tested, and thus code coverage should not be measured. Such a library is called a Humble Object. It (and many other patterns) are described in the excellent xUnit Test Patterns . As a rule of thumb I accept that code is untested if it has a Cyclomatic Complexity of 1 . In that case, it's more or less purely declarative. Pragmatically, untestable components are in order as long as they have low Cyclomatic Complexity. How low 'low' is you must decide for yourself. In any case, [CoverageExclude] seems like a smell to me (I didn't even know it existed before I read your question).
