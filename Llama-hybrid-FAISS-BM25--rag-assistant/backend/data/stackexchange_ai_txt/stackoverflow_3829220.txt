[site]: stackoverflow
[post_id]: 3829220
[parent_id]: 
[tags]: 
Is there no way to upcast into an abstract class and not modify it each time a class is derived from it?

#include using namespace std; class Abs { public: virtual void hi()=0; }; class B:public Abs { public: void hi() {cout bye(); Abs *cc=new C; cc->sayonara(); }//main The compiler says test2.cpp: In function ‘int main()’: test2.cpp:26: error: ‘class Abs’ has no member named ‘bye’ test2.cpp:28: error: ‘class Abs’ has no member named ‘sayonara’ Because of this problem, I'll have to add functions to the Abs class each time I create a new derived class which inherits from it (Upcasting is compulsory for me to do. The program I'm planning requires it to be so). I don't want to touch the base class once it's created. Doesn't this problem violate the principle that once you make a base class, you won't have to modify it ever. Any way to resolve this problem? p.s: I've seen the factory design pattern and the prototype design patterns, but both of them can't seem to be able to solve it.
