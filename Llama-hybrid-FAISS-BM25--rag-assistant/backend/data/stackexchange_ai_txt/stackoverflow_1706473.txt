[site]: stackoverflow
[post_id]: 1706473
[parent_id]: 1704395
[tags]: 
First, some reformatting: (loop for e in entries do (if (and (not (member e sub)) (not (member e col))) (progn (setq choices (nconc choices (list e))) (print choices))) (if (= (length choices) 1) (setq pick (car choices)) (if (not (= (length choices) 0)) (setq pick (nth (random (+ 0 (length choices))) choices)))) Then, if you don't need the alternative clause of if , but want a progn , you can use when : (loop for e in entries do (when (and (not (member e sub)) (not (member e col))) (setq choices (nconc choices (list e))) (print choices)) (if (= (length choices) 1) (setq pick (car choices)) (if (not (= (length choices) 0)) (setq pick (nth (random (+ 0 (length choices))) choices)))) The last two if clauses are mutually exclusive, so either cond or case would be appropriate (I'll use cond for now): (loop for e in entries do (when (and (not (member e sub)) (not (member e col))) (setq choices (nconc choices (list e))) (print choices)) (cond ((= (length choices) 1) (setq pick (car choices))) ((not (= (length choices) 0)) (setq pick (nth (random (+ 0 (length choices))) choices)))) There is a zerop predicate: (loop for e in entries do (when (and (not (member e sub)) (not (member e col))) (setq choices (nconc choices (list e))) (print choices)) (cond ((= (length choices) 1) (setq pick (car choices))) ((not (zerop (length choices))) (setq pick (nth (random (+ 0 (length choices))) choices)))) I don't see what adding 0 to some value should accomplish: (loop for e in entries do (when (and (not (member e sub)) (not (member e col))) (setq choices (nconc choices (list e))) (print choices)) (cond ((= (length choices) 1) (setq pick (car choices))) ((not (zerop (length choices))) (setq pick (nth (random (length choices)) choices)))) Unless you are sure that pick is set to a sensible default to begin with, you should perhaps have a default case (this may be one of your problems): (loop for e in entries do (when (and (not (member e sub)) (not (member e col))) (setq choices (nconc choices (list e))) (print choices)) (cond ((= (length choices) 1) (setq pick (car choices))) ((not (zerop (length choices))) (setq pick (nth (random (length choices)) choices))) (t (setq pick nil)) Instead of using setq and nconc , you can use push (this puts the new element at the start of the list, but since you pick randomly anyway, this shouldn't be a concern): (loop for e in entries do (when (and (not (member e sub)) (not (member e col))) (push e choices) (print choices)) (cond ((= (length choices) 1) (setq pick (car choices))) ((not (zerop (length choices))) (setq pick (nth (random (length choices)) choices))) (t (setq pick nil)) I suspect that at the start of this snippet, choices is supposed to be () , that you don't need choices after this snippet, and that printing choices is just for debugging, so you could do this in a different way by using remove-if and changing the condition: (let ((choices (remove-if (lambda (e) (or (member e sub) (member e col))) entries))) (print choices) (cond ((= (length choices) 1) (setq pick (car choices))) ((not (zerop (length choices))) (setq pick (nth (random (length choices)) choices))) (t (setq pick nil))) If choices is printed as () now, it means that there are no choices left here, so you will have to do some backtracking then (or whatever your algorithm does when a dead end is reached). Finally, since (length choices) can only be non-negative integers, you can use case instead of cond if you test the cases in different order: (let ((choices (remove-if (lambda (e) (or (member e sub) (member e col))) entries))) (print choices) (case (length choices) (0 (setq pick nil)) (1 (setq pick (car choices))) (otherwise (setq pick (nth (random (length choices)) choices))))) Update by request. As Rainer points out, this is basically the body of a pick function, so we can get rid of all the free variables. Also, instead of car , you can use the (for lists) more descriptive name first : (defun pick (entries sub col) (let ((choices (remove-if (lambda (e) (or (member e sub) (member e col))) entries))) (print choices) (case (length choices) (0 nil) (1 (first choices)) (otherwise (nth (random (length choices)) choices))))) This function would be defined elsewhere, and in the snippet's place, it would be called like this: (pick entries sub col) In order not to compute (length choices) twice, we can put that into the let (which needs to become let* for serial evaluation): (defun pick (entries sub col) (let* ((choices (remove-if (lambda (e) (or (member e sub) (member e col))) entries)) (choices-length (length choices))) (print choices) (case choices-length (0 nil) (1 (first choices)) (otherwise (nth (random choices-length) choices))))) A final step (really optional, but perhaps you discover that you have more sequences reducing your choices, e.g. row ) would be a little generalization: (defun pick (entries &rest exclusion-sequences) (let* ((choices (remove-if (lambda (e) (some #'identity (mapcar (lambda (seq) (member e seq)) exclusion-sequences))) entries)) (choices-length (length choices))) (print choices) (case choices-length (0 nil) (1 (first choices)) (otherwise (nth (random choices-length) choices))))) The call to this function is of the same shape, but you can now use any number of exclusion sequences: (pick entries col sub row ver ima fou)
