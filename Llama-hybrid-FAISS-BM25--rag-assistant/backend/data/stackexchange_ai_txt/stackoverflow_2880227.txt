[site]: stackoverflow
[post_id]: 2880227
[parent_id]: 2879955
[tags]: 
The problem is not multi-threading: I've written a correctly multi-threaded QuickSort in Java and it owns the default Java sort. I did this after witnessing a gigantic dataset being process and had only one core of a 16-cores machine working. One of your issue (a huge one) is that you're busy looping: // Wait for the two other threads to finish while(!ma.finished || !mb.finished) ; This is a HUGE no-no: it is called busy looping and you're destroying the perfs. (Another issue is that your code is not spawning any new threads, as it has already been pointed out to you) You need to use other way to synchronize: an example would be to use a CountDownLatch . Another thing: there's no need to spawn two new threads when you divide the workload: spawn only one new thread, and do the other half in the current thread. Also, you probably don't want to create more threads than there are cores availables. See my question here (asking for a good Open Source multithreaded mergesort/quicksort/whatever). The one I'm using is proprietary, I can't paste it. Multithreaded quicksort or mergesort I haven't implemented Mergesort but QuickSort and I can tell you that there's no array copying going on. What I do is this: pick a pivot exchange values as needed have we reached the thread limit? (depending on the number of cores) yes: sort first part in this thread no: spawn a new thread sort second part in current thread wait for first part to finish if it's not done yet (using a CountDownLatch). The code spawning a new thread and creating the CountDownLatch may look like this: final CountDownLatch cdl = new CountDownLatch( 1 ); final Thread t = new Thread( new Runnable() { public void run() { quicksort(a, i+1, r ); cdl.countDown(); } } }; The advantage of using synchronization facilities like the CountDownLatch is that it is very efficient and that your not wasting time dealing with low-level Java synchronization idiosynchrasies. In your case, the "split" may look like this (untested, it is just to give an idea): if ( threads.getAndIncrement() 0 ) { try { innerLatch.await( 1000, TimeUnit.SECONDS ); } catch ( InterruptedException e ) { // Up to you to decide what to do here } } } else { mergeSort( a ); mergeSort( b ); } (don't forget to "countdown" the latch when each merge is done) Where you'd replace the number of threads (up to 4 here) by the number of available cores. You may use the following (once, say to initialize some static variable at the beginning of your program: the number of cores is unlikely to change [unless you're on a machine allowing CPU hotswapping like some Sun systems allows]): Runtime.getRuntime().availableProcessors()
