[site]: stackoverflow
[post_id]: 5123403
[parent_id]: 5122201
[tags]: 
What I came up with for caching, comments welcome. public static ConcurrentDictionary , Func > ReflectionCache { get { if (_ReflectionCache==null) { _ReflectionCache = new ConcurrentDictionary , Func >(); } return _ReflectionCache; } } private static ConcurrentDictionary , Func > _ReflectionCache = null; public static object GetCachedProperty(object obj, string name) { Func del; if (!ReflectionCache.TryGetValue(Tuple.Create (obj.GetType(), name), out del)) { MemberInfo memberInfo = (MemberInfo)obj.GetType().GetMember(name).GetValue(0); PropertyInfo prop = null; FieldInfo fld = null; switch(memberInfo.MemberType) { case MemberTypes.Field: fld = obj.GetType().GetField(name); break; case MemberTypes.Property: prop = obj.GetType().GetProperty(name); break; } if (prop == null && fld == null) { throw new Exception("No property or field named '" + name + "' could be found in the context parent."); } if (prop!=null) { prop= obj.GetType().GetProperty(name); del = prop.GetValue; } else { fld = obj.GetType().GetField(name); del = delegate(object cls,object[] index) { return fld.GetValue(cls); }; } ReflectionCache[Tuple.Create (obj.GetType(),name)]=del; } return(del(obj,null)); }
