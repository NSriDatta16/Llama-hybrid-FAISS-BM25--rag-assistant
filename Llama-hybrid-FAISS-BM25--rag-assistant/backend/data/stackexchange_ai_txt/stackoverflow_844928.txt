[site]: stackoverflow
[post_id]: 844928
[parent_id]: 844870
[tags]: 
You'll need to decide which of the agent and the environment sits "on top" - let's suppose for the rest of this answer that it's the environment on top calling into the agent since that generally makes most sense. You can keep data representations of the Agent private using the module system - just export the datatype name without any of its internals. module Agent (AgentState, other_stuff) where as opposd to module Agent (AgentState(..), other_stuff) where If the agent also needs to be passed the environment's state (though I can't see any reason this would be necessary as the environment can keep track of it for itself), then make the agent functions polymorphic so that they can be passed any state type - then the environment can pass whatever it likes in without its representation being exposed. It should also be possible to use state monads to achieve more control over what happens to the state, for example preventing the environment from duplicating a state the agent gives it and calling the agent repeatedly with that same state, but if you're new to Haskell it's probably best to get a bit of experience without monads first. (Not that monads are particularly scary or anything, but they do hide detail from you so it's harder to see what's going on.)
