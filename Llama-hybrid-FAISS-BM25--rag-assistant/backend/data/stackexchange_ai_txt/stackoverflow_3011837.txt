[site]: stackoverflow
[post_id]: 3011837
[parent_id]: 3011643
[tags]: 
This seems a difficult requirement to solve using any particular ORM framework, at least not in one easy step. A multi-step process is likely to be necessary. Something roughly similar can be accomplished via an approach to iterate through the search results and finding their children (and children's children), and flattening the hierarchy into a single list. An example implementation here, this one done using a plain in-memory list: class Employee { public int Id { get; private set; } public int? BossId { get; private set; } public string Name { get; private set; } public Employee(int id, int? bossId, string name) { Id = id; BossId = bossId; Name = name; } } Sample data: List employees = new List (); employees.Add(new Employee(1, null, "Tom Smith")); employees.Add(new Employee(2, null, "Susan Jones")); employees.Add(new Employee(3, 1, "Sally Davis")); employees.Add(new Employee(4, 1, "Robert Roberts")); employees.Add(new Employee(5, 3, "John Smith")); employees.Add(new Employee(6, 2, "Tonya Little")); employees.Add(new Employee(7, 3, "Ty Bell")); employees.Add(new Employee(8, 4, "Helen Andrews")); employees.Add(new Employee(9, 2, "Matt Huang")); employees.Add(new Employee(10, 6, "Lisa Wilson")); Process: string searchTerm = "Smith"; var searchResults = employees.Where(e => e.Name.Contains(searchTerm)); List outputList = new List (); Action , List > findUnderlings = null; findUnderlings = (input, list) => { foreach (Employee employee in input) { list.Add(employee); var underlings = employees.Where(e => e.BossId == employee.Id); findUnderlings(underlings, list); } }; findUnderlings(searchResults, outputList); Show output: foreach (Employee employee in outputList) { Console.WriteLine("{0}\t{1}\t{2}", employee.Id, employee.Name, employee.BossId); } Results: 1 Tom Smith 3 Sally Davis 1 5 John Smith 3 7 Ty Bell 3 4 Robert Roberts 1 8 Helen Andrews 4 5 John Smith 3 And you can see it follows the top result, underling, underling's underlings, next result, any underlings, etc. It works for any number of tiers. I am not sure how that can be accomplished in an "order by" within Linq or even regular SQL, but that could only mean I'm not smart enough to do it rather than it just isn't possible.
