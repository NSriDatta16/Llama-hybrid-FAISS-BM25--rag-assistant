[site]: stackoverflow
[post_id]: 2321458
[parent_id]: 
[tags]: 
HLSL and ID3DXFont/ID3DXSprite

I've started at the beginning, and my code will capably display the grand total of some text. I've been adding support for sprites. The trouble that I've run in to, is that it doesn't seem to recognize my HLSL. I set the technique, began it, began the pass, drew the sprites, flushed them, ended the pass, the technique. And D3D comes up with this little "Using FF to PS converter" in the VS output. Same for VS. I'm not trying to do anything advanced with my HLSL - just use it and get a little more familiar with it and make sure I know how to implement it. That's C++0x auto, by the way, so automatic type deduction (because I'm lazy). #define D3DCALL(a) { auto __ = a; if (FAILED(__)) DXTrace(__FILE__, __LINE__, __, WIDEN(#a), TRUE); } D3DCALL(spriteeffect->SetTechnique(spritetechnique)); D3DCALL(spriteeffect->Begin(&passes, NULL)); D3DCALL(spriteeffect->BeginPass(0)); // We know this is zero. D3DCALL(sprite->Begin(D3DXSPRITE_OBJECTSPACE | D3DXSPRITE_DO_NOT_ADDREF_TEXTURE | D3DXSPRITE_SORT_TEXTURE | D3DXSPRITE_ALPHABLEND | D3DXSPRITE_SORT_DEPTH_FRONTTOBACK)); RenderAndCleanUp(common->sprites); D3DCALL(sprite->End()); D3DCALL(spriteeffect->EndPass()); D3DCALL(spriteeffect->End()); where RenderAndCleanUp is a simple templated function that loops through the sprites, destroys those that need to be, and renders the rest, and common->sprites is a simple vector of all the sprite objects. Since DXTrace never goes off, I'll guarantee that none of the functions fail. I've also set the control panel to max debugging. I checked the D3DXHANDLEs and they're all non-NULL. It doesn't report any compilation errors, or any errors or warnings. // Contains the HLSL for sprites. // Based on transform.fx, by Frank Luna. // FX parameter (global variable to the shader). uniform extern float4x4 gWVP; // Structure struct OutputVS { float4 posH : POSITION0; float4 color : COLOR0; }; // Vertex shader OutputVS SpriteVS(float3 post : POSITION0, float4 col : COLOR0) { // Zero out our output. OutputVS outVS = (OutputVS)0; outVS.posH = mul(float4(post, 1.0f), gWVP); // Transform outVS.color = col; // Done--return the output. return outVS; } // Pixel shader - take the original colour of the pixel and just return it. Nothing fancy. float4 SpritePS( float4 col : COLOR0 ) : COLOR { return col; } technique Sprite { pass P0 { // Specify the vertex and pixel shader associated // with this pass. vertexShader = compile vs_3_0 SpriteVS(); pixelShader = compile ps_3_0 SpritePS(); } } This is native C++ looking at Direct3D9.
