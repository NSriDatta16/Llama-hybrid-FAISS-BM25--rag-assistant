[site]: stackoverflow
[post_id]: 1631814
[parent_id]: 1629269
[tags]: 
I like Enumerators a lot -- not just for existing types, but writing my own collections as Enumerator classes. Since switching to 1.9, I've twice had to build API adapters to external Web services that pull down large JSON or XML result sets. Sometimes I'd be capped on how many records I could retrieve at once, meaning I'd need to do multiple requests. (Get the first 500, then get records 501 to 1000, etc.) The "old" way I'd have processed these would have been to grab the first batch, iterate over it all at once with .each or .collect , and create an equal-sized array of Ruby objects. If I couldn't get all the records in one request, I'd loop through API requests as well, adding to the array each time. This means all the time is front-loaded, perceived as a slow retrieval, and I'm chewing up a lot of memory: for the source data, for an equal number of Ruby objects, and sometimes for intermediate array operations. This is wasteful when I'm probably only operating on one object at a time. With Enumerators, I can grab the first batch, hold the source data as my "authoritative" collection, and process and yield each Ruby object as I step into it . When I pass the last element, if I know there's more data to be pulled from the source, I can make the next API call then. (I.e., lazy loading.) This means a much faster return on the retrieval method call, and much better memory usage. Each Ruby object is eligible for garbage collection as soon as I'm done with it and have moved to the next one. An abstract implementation of the idea looks like this: class ThingyCollection Once you have that, you can walk over them like: thingies = ThingyCollection.new(foo: bar) # Whatever search options are relevant puts "Our first thingy is #{thingies.next}" puts "Our second thingy is #{thingies.next}" thingies.rewind thingies.each do |thingy| do_stuff(thingy) end What do you lose? Mostly the ability to easily jump to a particular element by reference. (Which means you also lose "last," sorts, etc.) Just getting .next and a couple of .each variants is not as rich as array functionality, but for my most common use cases it's all i need. Yes, you can do this with Ruby 1.8.7 thanks to backporting. But 1.9 is much faster at it thanks to the internal use of fibers. And if it hadn't been for 1.9, there wouldn't have been a 1.8.7, so I've decided it still qualifies as my favorite 1.9 feature.
