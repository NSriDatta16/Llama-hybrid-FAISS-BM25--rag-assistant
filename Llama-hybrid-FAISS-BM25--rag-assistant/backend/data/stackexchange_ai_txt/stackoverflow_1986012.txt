[site]: stackoverflow
[post_id]: 1986012
[parent_id]: 1985760
[tags]: 
A lot of people have provided you IL to show you that your two code fragments are effectively the same from a performance perspective. It's not really necessary to go to that level of detail to see why this is the case. Just think about this from the perspective of the call stack . Effectively what happens at the beginning of a method containing a code fragment like the two that you provided is that the compiler will emit code to allocate space at the beginning of the method for all locals that will be used within that method. In both cases what the compiler sees is a local named iTemp so when it allocates space on the stack for the locals it will allocate 32-bits to hold iTemp . It doesn't matter to the compiler that in the two code fragments iTemp have different scope; the compiler will enforce that by just not allowing you to refer to iTemp outside the for loop in the first fragment. What it will do is allocate this space once (at the beginning of the method) and reuse the space as needed during the loop in the first fragment.
