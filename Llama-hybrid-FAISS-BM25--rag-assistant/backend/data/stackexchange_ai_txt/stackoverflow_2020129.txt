[site]: stackoverflow
[post_id]: 2020129
[parent_id]: 2019951
[tags]: 
The Haskell solution is particularly elegant with the on combinator from Data.Function. import Data.Function (on) import Data.List (sortBy) lists = [ [ 5, 6, 8 ] , [ 1, 2, 3 ] ] main = do print $ sortBy (compare `on` foo) lists where foo = sum Output: [[1,2,3],[5,6,8]] There's also comparing from Data.Ord that lets us instead write main = do print $ sortBy (comparing foo) lists where foo = sum The definition of comparing is a straightforward comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering comparing p x y = compare (p x) (p y) but we could also define it in terms of on : comparing :: (Ord b) => (a -> b) -> a -> a -> Ordering comparing f = compare `on` f or completely point-free with comparing :: (Ord b) => (a -> b) -> a -> a -> Ordering comparing = (compare `on`) Haskell manipulates functions as powerfully as Perl manipulates strings.
