[site]: stackoverflow
[post_id]: 500643
[parent_id]: 481813
[tags]: 
See the bottom of this answer for updated (2013) solution using Guava. This is what I ultimately went with. It turned out we already had a utility method for null-safe String comparison, so the simplest solution was to make use of that. (It's a big codebase; easy to miss this kind of thing :) public int compareTo(Metadata other) { int result = StringUtils.compare(this.getName(), other.getName(), true); if (result != 0) { return result; } return StringUtils.compare(this.getValue(), other.getValue(), true); } This is how the helper is defined (it's overloaded so that you can also define whether nulls come first or last, if you want): public static int compare(String s1, String s2, boolean ignoreCase) { ... } So this is essentially the same as Eddie's answer (although I wouldn't call a static helper method a comparator ) and that of uzhin too. Anyway, in general, I would have strongly favoured Patrick's solution , as I think it's a good practice to use established libraries whenever possible. ( Know and use the libraries as Josh Bloch says.) But in this case that would not have yielded the cleanest, simplest code. Edit (2009): Apache Commons Collections version Actually, here's a way to make the solution based on Apache Commons NullComparator simpler. Combine it with the case-insensitive Comparator provided in String class: public static final Comparator NULL_SAFE_COMPARATOR = new NullComparator(String.CASE_INSENSITIVE_ORDER); @Override public int compareTo(Metadata other) { int result = NULL_SAFE_COMPARATOR.compare(this.name, other.name); if (result != 0) { return result; } return NULL_SAFE_COMPARATOR.compare(this.value, other.value); } Now this is pretty elegant, I think. (Just one small issue remains: the Commons NullComparator doesn't support generics, so there's an unchecked assignment.) Update (2013): Guava version Nearly 5 years later, here's how I'd tackle my original question. If coding in Java, I would (of course) be using Guava . (And quite certainly not Apache Commons.) Put this constant somewhere, e.g. in "StringUtils" class: public static final Ordering CASE_INSENSITIVE_NULL_SAFE_ORDER = Ordering.from(String.CASE_INSENSITIVE_ORDER).nullsLast(); // or nullsFirst() Then, in public class Metadata implements Comparable : @Override public int compareTo(Metadata other) { int result = CASE_INSENSITIVE_NULL_SAFE_ORDER.compare(this.name, other.name); if (result != 0) { return result; } return CASE_INSENSITIVE_NULL_SAFE_ORDER.compare(this.value, other.value); } Of course, this is nearly identical to the Apache Commons version (both use JDK's CASE_INSENSITIVE_ORDER ), the use of nullsLast() being the only Guava-specific thing. This version is preferable simply because Guava is preferable, as a dependency, to Commons Collections. (As everyone agrees .) If you were wondering about Ordering , note that it implements Comparator . It's pretty handy especially for more complex sorting needs, allowing you for example to chain several Orderings using compound() . Read Ordering Explained for more!
