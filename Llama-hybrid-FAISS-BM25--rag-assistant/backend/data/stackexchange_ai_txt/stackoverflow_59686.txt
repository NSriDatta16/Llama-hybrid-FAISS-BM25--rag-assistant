[site]: stackoverflow
[post_id]: 59686
[parent_id]: 59667
[tags]: 
The general rule is to pick CHAR if all rows will have close to the same length . Pick VARCHAR (or NVARCHAR ) when the length varies significantly. CHAR may also be a bit faster because all the rows are of the same length. It varies by DB implementation, but generally, VARCHAR (or NVARCHAR ) uses one or two more bytes of storage (for length or termination) in addition to the actual data. So (assuming you are using a one-byte character set) storing the word "FooBar" CHAR(6) = 6 bytes (no overhead) VARCHAR(100) = 8 bytes (2 bytes of overhead) CHAR(10) = 10 bytes (4 bytes of waste) The bottom line is CHAR can be faster and more space-efficient for data of relatively the same length (within two characters length difference). Note : Microsoft SQL has 2 bytes of overhead for a VARCHAR. This may vary from DB to DB, but generally, there is at least 1 byte of overhead needed to indicate length or EOL on a VARCHAR. As was pointed out by Gaven in the comments: Things change when it comes to multi-byte characters sets, and is a is case where VARCHAR becomes a much better choice. A note about the declared length of the VARCHAR : Because it stores the length of the actual content, then you don't waste unused length. So storing 6 characters in VARCHAR(6), VARCHAR(100), or VARCHAR(MAX) uses the same amount of storage. Read more about the differences when using VARCHAR(MAX) . You declare a maximum size in VARCHAR to limit how much is stored. In the comments AlwaysLearning pointed out that the Microsoft Transact-SQL docs seem to say the opposite. I would suggest that is an error or at least the docs are unclear.
