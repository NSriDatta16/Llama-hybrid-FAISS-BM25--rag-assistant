[site]: stackoverflow
[post_id]: 4115627
[parent_id]: 4115557
[tags]: 
Properties cannot have parameters in C#, so if you want to use property syntax you'll need two properties with different names. If you don't want users of your class to be aware of the fact that internally your field could be null, its pretty straightforward if you control the implementation of your property. Define the backing field of your property to be of type int? , but leave the type of your property as int . For example: private int? _someNumber = null; public int SomeNumber { get { return _someNumber.HasValue ? _someNumber.Value : 0; } set { _someNumber = value; } } Now, internally, you can always access _someNumber.HasValue to check if a value has been set or not. However, when you say "I'd like to add an option to have a nullable version.", if you do want a way to expose to your client whether or not SomeNumber has a value then you have a few options: Expose a property like bool SomeNumberHasValue Change the type of SomeNumber to int? Add a second property SomeNumberNullable that has a return type of int? However, a single property cannot sometimes return int and return int? other times. Another option would be to use a method to access the value, like so: public int? GetSomeNumber(bool canReturnNull) { if (canReturnNull) return _someNumber; return _someNumber.HasValue ? _someNumber.Value : 0; } In effect, you're doing a lot of work to make it easy for your clients to handle a null check, without hiding the fact the value can be null. What's the benefit?
