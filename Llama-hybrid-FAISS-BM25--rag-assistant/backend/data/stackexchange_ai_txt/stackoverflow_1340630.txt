[site]: stackoverflow
[post_id]: 1340630
[parent_id]: 1338277
[tags]: 
For the first paragraph, this is just how generics work for classes. For instance, for list, you can create a list of a generic type, such as integer, e.g.: ArrayList list = new ArrayList (); (in real code you'd use List of course) Now ArrayList will be defined as: public class Arraylist { // implements.... // ... public T get(int index) { // ... } } Which is what makes it possible to use the get method on list and get an Integer (because we made a class of type ArrayList so T = Integer ). Otherwise the compiler would have no idea what types of objects the list was storing and you'd have to get the method to return an Object , which is how it used to be. What the second paragraph means is that you can add type parameters to methods just as you can to classes. e.g.: public void noOp(T element) { // code here } This would allow you, for instance, to create a static utility method that returns something of type T. To return the first element of a List of T's: public static T getFirst (List list) { return list.get(0); } And you could use this method in a strongly typed fashion. Suggestions for better examples welcome. :-) edit: I just realised I once wrote something that uses this functionality. I was using the JPA API and getting really annoyed at all the times you have to return something (a list, or a single item) from a query, and running into unchecked type warnings because there's no way to infer the type here. If you're like me and trying to avoid warnings in your code, you'd have to suppress the warnings every single time. So I wrote this method to suppress the warnings for me: @SuppressWarnings("unchecked") public static List returnResultList(Query query) { return (List )query.getResultList(); } Which through the magic of type inference works on: List list = returnResultList(query);
