[site]: stackoverflow
[post_id]: 1010388
[parent_id]: 1010330
[tags]: 
Whenever you have a binary operator (one of + - * / % >> & | ^ == != > >= ) between two integral operands of different types, the two types are converted to a common type before the operation is performed. The rules for deciding the converted-to type are (from section 6.3.1.8 of the C99 standard): If both operands have the same type, then no further conversions are required. Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank. Otherwise, if the operand that has unsigned integer type has rank greater or equal to the rank of the type of the other operand, then the operand with signed integer type is converted to the type of the operand with unsigned integer type. Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type. Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type. In this case, char could be either a signed or unsigned integer type -- its signedness is implementation-defined. Fortunately, though, an int can represent all possible values of a char , whether or not char is signed, assuming you're on a system where char s are 8 bits and int s are at least 16 bits. If char is signed, then the second paragraph above applies, so both operands are converted to int (the type with higher rank; rank is defined in a somewhat complicated manner, but it's essentially equivalent to the bit size of the type). Since 0x98, as a signed char , is negative, it's converted to the integer -104, which is then less than 7. If instead char is unsigned, then the fourth paragraph applies instead. The unsigned char would be converted to 152 as an int , which is greater than 7. Do not ever rely on char s being signed or unsigned. If you need 8-bit integers of a certain signedness, explicitly use signed char or unsigned char , or use the C99 types int8_t and uint8_t , defined int . It's very easy to get bitten by subtle bugs caused by the integer promotion rules. I strongly advise you to always compile with -Wall with gcc, which will warn you about comparisons between signed and unsigned integers, which are frequently a cause of bugs.
