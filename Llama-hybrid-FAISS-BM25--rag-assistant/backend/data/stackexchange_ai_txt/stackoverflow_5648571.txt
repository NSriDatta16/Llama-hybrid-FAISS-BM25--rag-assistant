[site]: stackoverflow
[post_id]: 5648571
[parent_id]: 5637132
[tags]: 
I finally found an "elegant" solution with the decorator design pattern. This pattern is used to extend an object without changing its interface. GNode decorates/extends Node: template struct GNode : public T, public Drawable { virtual void accept(Visitor& v); // override Node::accept() } As you can see, it requires a little change in the back-end structure: struct Node { Label label; Node* r, l; virtual void accept(Visitor& v); }; That's it ! GNode is-a Node. We can now create a binary tree of GNodes and visit it thanks to the virtual method accept() in the back-end structure. In the case when we absolutely follow my question, i.e. we can't modify the back-end and it doesn't have the virtual entry point presented above, we can add features to GNode mapping the Node it wraps to itself. So that a visitor visiting GNodes (that can only have access to its sons) can find the GNodes of its sons. Yes, this is the virtual keyword job with the above solution! But we never know if someone would be in this case for real. As a conclusion to all this: the way you express a problem always influences the way to resolve it.
