[site]: stackoverflow
[post_id]: 4445575
[parent_id]: 4444045
[tags]: 
Overall, if you use HQL or Criteria to create your final SQL you won't see much difference in performance in the later versions of Hibernate (version 3.3 and above). To test this you need to create a representative query in both HQL and using the Criteria interface. Then log the resulting SQL from progressively older versions of Hibernate (perhaps using Maven to allow for rapid version changes). You will notice that as the Hibernate versions decrease, you will see changes in the final SQL. There is little point in attempting to optimise between HQL and Criteria in code since the overwhelming majority of time lost will be in network traffic between your application and the database. Of course, this assumes that you have a well-formed query that doesn't require multiple full table scans over a hundred million rows or something. The quoted blog is attempting to debunk myths so be careful that you don't take the title out of context (emphasis mine): 9) "Hibernate is slow because the SQL generated by the Criteria interface is not consistent" It has been said that Hibernate can also incur a performance hit if all queries are constructed through the Criteria interface instead of directly in HQL. The argument posits that this is because every time the query builder code is executed, say in a DAO, Hibernate will generate new alias names for the tables in the query. In Oracle this means that every time a new Criteria-based query is run, the database must create a QEP – query execution plan – as it is unable to match the SQL it has been given to any in its cache. Creating the QEP can take 30% of the time it takes for Oracle to respond to a SQL statement, so for the second and subsequent executions of the same (but for alias names) SQL statement, Criteria has a built-in overhead that makes it 50% slower than direct HQL. This is no longer the case with Hibernate 3.3 and above. If it was ever true at all is in doubt since the Hibernate team would certainly aim to create optimal SQL wherever possible . Independent tests demonstrate that the same query is generated by the Criteria interface after repeated calls spanning transactions which is the equivalent of running the application under load. In each case the query remained identical and was therefore able to be cached by Oracle. There is one grain of truth, though, in that it is necessary to create the query every time using the Criteria interface, whereas using named queries defined in HQL allows for precompilation during application start-up. However, this needs some perspective. The time taken to create a simple “between” query using the Criteria interface is approximately 3ms on an average PC. Embedding HQL within the application is not a good alternative since it does not lead to an intuitive mechanism for maintaining queries with differing fetching strategies, and so the Criteria based approach is deemed the better of the two. So the blog essentially points out that the main difference is that the Criteria interface may introduce a few milliseconds of extra processing overhead which can be avoided by a direct HQL approach. HQL is also a little more succinct in it's expression of the query that many will find appealing. In short, the difference is so small you don't need to worry about it.
