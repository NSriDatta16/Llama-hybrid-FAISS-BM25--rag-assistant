[site]: stackoverflow
[post_id]: 483780
[parent_id]: 306757
[tags]: 
Objects in .NET are not apartment-bound unless you specifically make them so. For instance, if you use thread local storage, you're going to have problems with multiple threads accessing the object, as long as you assume all access to the object will happen on one thread. On the other hand, thread local storage could be a feature, where usage of the object across multiple threads are handled at least partially separate. As for your other cases, let's take them one at a time, with comments: But what about arbitrary objects? What about: public class MyClass { int _number; public int Number { get { return _number; } set { _number = value; } } } MyClass myObject = new MyClass(); As long as i synchronize access to myObject two threads are allowed to talk to it? Answer : Yes, and in this case the need for synchronization depends on your requirements. If you timing-wise absolutely have to guarantee that if on one thread set a new value into the object, and on another read it just after setting it (but two different threads), you require the second thread to read the value the first one put in, then you need locking. However, storing the value for an int is an atomic operation. The lock is needed to get a memory barrier so that reading the value on the second thread won't use a cached copy. You can usually get by on such simple classes with just declaring things volatile, but locking is a sure way to make better guarantees. For a more complex object, say setting a struct bigger than the native bus-size of the cpu (ie. bigger than 32 or 64-bit, depending), a lock is required, since copying the data into the right spot in memory isn't an atomic operation in such a case. In other words, without the lock you risk reading half old half new data if one thread tries to read the data in the middle of a write operation executing on another thread. The same goes for: List sharedList = new List (); Two threads can talk to the list, as long as they don't do it simultaneously, usually with: lock (sharedList) { sharedList.Add(data); } are two threads allowed to touch the same object? Answer : Yes. It's usually a good idea to use the SyncRoot property of the ICollection interface on collections, or just use a different locking object altogether. The same goes for: IAsyncResult ar = BeginSetLabelToTheValueINeed(label1); ... EndSetLabelToTheValueINeed(ar); Answer : This one I'm unsure about, which one is the problematic variable here? If label1 then there is nothing here that prevents multiple threads accessing and messing with this variable, and you're required to use locking mechanisms to prevent such problems. The same goes for: //Fetch image on connection that is an existing DB transaction public static Bitmap GetImageThumbnail(DbConnection conn, int imageID) { } being converted into the asynchronous delegate pattern: //Begin fetching an image on connection that is an existing DB transaction IAsyncResult ar = BeginGetImageThumbnuts(conn, imageID, callback, stateOjbect); ... //Finish fetching an image on connection that is an existing DB transaction Bitmap thumb = EndGetImageNumbthail(ar); Answer : If by this you mean you will execute multiple such requests in parallel, you're likely to not gain much, as you will need to serialize access to the connection object, since these aren't thread safe. You're probably better off by making the thumbnail method open and close its own connection. Unless, of course, you want to only use one connection and instead serialize that access but parallelize the calculation of the thumbnail, but since these threads will in some way execute in sequence, due to most of them waiting for the first to finish accessing the connection, you're likely to not gain much here. In short, locking is usually very easy to implement and can almost always provide good guarantees that you cannot mess up the object by accessing it from two threads.
