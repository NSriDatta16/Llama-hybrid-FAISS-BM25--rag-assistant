[site]: stackoverflow
[post_id]: 2768330
[parent_id]: 2767623
[tags]: 
The char * field of your structure is known as a variable length field . When you write this field, you will need a method for determining the length of the text. Two popular methods are: 1. Writing Size First 2. Writing terminal character Writing Size First In this method, the size of the text data is written first, followed immediately by the data. Advantages: Text can load quicker by block reads. Disadvantages: Two reads required, extra space required for the length data. Example code fragment: struct My_Struct { char * text_field; }; void Write_Text_Field(struct My_Struct * p_struct, FILE * output) { size_t text_length = strlen(p_struct->text_field); fprintf(output, "%d\n", text_length); fprintf(output, "%s", p_struct->text_field); return; } void Read_Text_Field(struct My_STruct * p_struct, FILE * input) { size_t text_length = 0; char * p_text = NULL; fscanf(input, "%d", &text_length); p_text = (char *) malloc(text_length + sizeof('\0')); if (p_text) { fread(p_text, 1, text_length, input); p_text[text_length] = '\0'; } } Writing terminal character In this method the text data is written followed by a "terminal" character. Very similar to a C language string. Advantages: Requires less space than Size First. Disadvantages: Text must be read one byte at a time so terminal character is not missed. Fixed size field Instead of using a char* as a member, use a char [N] , where N is the maximum size of the field. Advantages: Fixed sized records can be read as blocks. Makes random access in files easier. Disadvantages: Waste of space if all the field space is not used. Problems when the field size is too small. When writing data structures to a file, you should consider using a database . There are small ones such as SQLite and bigger ones such as MySQL. Don't waste time writing and debugging permanent storage routines for your data when they have already been written and tested .
