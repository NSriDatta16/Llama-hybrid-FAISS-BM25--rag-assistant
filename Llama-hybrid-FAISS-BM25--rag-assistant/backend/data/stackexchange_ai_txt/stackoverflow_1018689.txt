[site]: stackoverflow
[post_id]: 1018689
[parent_id]: 1018407
[tags]: 
Not sure how elegant this is, but here you go. Since ICollection<> doesn't give you indexing I just used IEnumerable<> , and since I didn't need the index on the IList<> I used IEnumerable<> there too. public static IEnumerable IndexedLookup ( IEnumerable indexes, IEnumerable items) { using (var indexesEnum = indexes.GetEnumerator()) using (var itemsEnum = items.GetEnumerator()) { int currentIndex = -1; while (indexesEnum.MoveNext()) { while (currentIndex != indexesEnum.Current) { if (!itemsEnum.MoveNext()) yield break; currentIndex++; } yield return itemsEnum.Current; } } } EDIT: Just noticed my solution is similar to Erics.
