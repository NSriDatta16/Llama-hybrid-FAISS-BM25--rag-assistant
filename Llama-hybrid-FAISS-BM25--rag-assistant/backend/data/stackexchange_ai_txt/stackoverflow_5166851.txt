[site]: stackoverflow
[post_id]: 5166851
[parent_id]: 
[tags]: 
Intercepting subprocess.Popen call in Python

I'm writing a functional test for a legacy Python script so that I can make a one-line change to it without being paralysed by fear. ;) The script in question invokes wget(1) using subprocess.Popen to download an XML file which is then parsed: def download_files(): os.mkdir(FEED_DIR) os.chdir(FEED_DIR) wget_process = Popen( ["wget", "--quiet", "--output-document", "-", "ftp://foo.com/bar.tar"], stdout=PIPE ) tar_process = Popen(["tar", "xf", "-"], stdin=wget_process.stdout) stdout, stderr = tar_process.communicate() Obviously, it would be preferable to modify the script to use an HTTP library instead of exec-ing wget, but as I said, it is a legacy script, so I need to keep my change minimal and absolutely focused on the business requirement, which has nothing to do with how the XML file is obtained. The obvious solution to me is to intercept the call to subprocess.Popen and return my own test XML. Intercept method calls in Python demonstrates how to use setattr to do this, but I must be missing something: Python 2.6.6 (r266:84292, Sep 15 2010, 16:22:56) [GCC 4.4.5] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> import subprocess >>> object.__getattribute__(subprocess, 'Popen') >>> attr = object.__getattribute__(subprocess, 'Popen') >>> hasattr(attr, '__call__') True >>> def foo(): print('foo') ... >>> foo >>> foo() foo >>> setattr(subprocess, '__call__', foo) >>> getattr(subprocess, '__call__') >>> subprocess.Popen([ r"tail", "-n 1", "x.txt" ], stdout = subprocess.PIPE) >>> tail: cannot open `x.txt' for reading: No such file or directory As you can see, the real subprocess.Popen is being called, despite the attribute being set correctly (at least to my largely untrained eye). Is this just a result of running this in interactive Python, or should I expect the same result from dropping this sort of code into my test script: class MockProcess: def __init__(self, output): self.output = output def stderr(): pass def stdout(): return self.output def communicate(): return stdout, stderr # Runs script, returning output # def run_agent(): real_popen = getattr(subprocess.Popen, '__call__') try: setattr(subprocess.Popen, '__call__', lambda *ignored: MockProcess(' ') ) return real_popen(['myscript.py'], stdout = subprocess.PIPE).communicate()[0] finally: setattr(subprocess.Popen, '__call__', real_popen)
