[site]: stackoverflow
[post_id]: 2666218
[parent_id]: 2656456
[tags]: 
The real problem here is that Office applications aren't intended for multithreaded use. Because there can be any number of client applications issuing commands through COM, those commands are serialized to calls and processed one by one. But sometimes Office is in a state where it doesn't accept new calls (for example when it is displaying a modal dialog) and your call gets rejected (giving you the "Call was rejected by callee"-error). See also the answer of Geoff Darst in this thread. What you need to do is implement a IMessageFilter and take care of your calls being rejected. I did it like this: function TIMessageFilterImpl.HandleInComingCall(dwCallType: Integer; htaskCaller: HTASK; dwTickCount: Integer; lpInterfaceInfo: PInterfaceInfo): Integer; begin Result := SERVERCALL_ISHANDLED; end; function TIMessageFilterImpl.MessagePending(htaskCallee: HTASK; dwTickCount, dwPendingType: Integer): Integer; begin Result := PENDINGMSG_WAITDEFPROCESS; end; function ShouldCancel(aTask: HTASK; aWaitTime: Integer): Boolean; var lBusy: tagOLEUIBUSYA; begin FillChar(lBusy, SizeOf(tagOLEUIBUSYA), 0); lBusy.cbStruct := SizeOf(tagOLEUIBUSYA); lBusy.hWndOwner := Application.Handle; if aWaitTime 10000 then //show Busy dialog after 10 seconds begin if ShouldCancel(htaskCallee, dwTickCount) then Result := -1 else Result := 100; end else Result := 100; //value between 0 and 99 means 'try again immediatly', value >= 100 means wait this amount of milliseconds before trying again end else begin Result := -1; //cancel end; end; The messagefilter has to be registered on the same thread as the one issuing the COM calls. My messagefilter implementation will wait 10 seconds before displaying the standard OLEUiBusy dialog. This dialog gives you the option to retry the rejected call (in your case Save) or switch to the blocking application (Excel displaying the modal dialog). After 20 seconds of blocking, the cancel button will be enabled. Clicking the cancel button will cause your Save call to fail. So forget messing around with threads and implement the messagefilter, which is the way to deal with these issues. Edit: The above fixes "Call was rejected by callee" errors, but you have a Save that hangs. I suspect that Save brings up a popup that needs your attention (Does your workbook has a filename already?). If it is a popup that is in the way, try the following (not in a separate thread!): { Turn off Messageboxes etc. } m_vExcelWorkbook.Application.DisplayAlerts := False; try { Saves the workbook as a xls file with the name 'c:\test.xls' } m_vExcelWorkbook.SaveAs('c:\test.xls', xlWorkbookNormal); finally { Turn on Messageboxes again } m_vExcelWorkbook.Application.DisplayAlerts := True; end; Also try to debug with Application.Visible := True; If there are any popups, there is a change you will see them and take actions to prevent them in the future.
