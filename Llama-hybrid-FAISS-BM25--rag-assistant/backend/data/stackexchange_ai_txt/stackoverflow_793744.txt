[site]: stackoverflow
[post_id]: 793744
[parent_id]: 793725
[tags]: 
One easy way would be to iterate the list to get the highest value n , then you know that n+1 is not in the list. Edit: A method to find the smallest positive unused number would be to start from zero and scan the list for that number, starting over and increase if you find the number. To make it more efficient, and to make use of the high probability of the list being sorted, you can move numbers that are smaller than the current to an unused part of the list. This method uses the beginning of the list as storage space for lower numbers, the startIndex variable keeps track of where the relevant numbers start: public static int GetSmallest(int[] items) { int startIndex = 0; int result = 0; int i = 0; while (i I made a performance test where I created lists with 100000 random numbers from 0 to 19999, which makes the average lowest number around 150. On test runs (with 1000 test lists each), the method found the smallest number in unsorted lists by average in 8.2 ms., and in sorted lists by average in 0.32 ms. (I haven't checked in what state the method leaves the list, as it may swap some items in it. It leaves the list containing the same items, at least, and as it moves smaller values down the list I think that it should actually become more sorted for each search.)
