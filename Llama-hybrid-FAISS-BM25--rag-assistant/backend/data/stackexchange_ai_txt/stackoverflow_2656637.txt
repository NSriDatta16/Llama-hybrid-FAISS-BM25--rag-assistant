[site]: stackoverflow
[post_id]: 2656637
[parent_id]: 
[tags]: 
ContentType Issue -- Human is an idiot - Can't figure out how to tie the original model to a ContentType abstracted 'Favorite' model

Originally started here: Django IN query as a string result - invalid literal for int() with base 10 I have a number of apps within my site, currently working with a simple "Blog" app. I have developed a 'Favorite' app, easily enough, that leverages the ContentType framework in Django to allow me to have a 'favorite' of any type... trying to go the other way, however, I don't know what I'm doing, and can't find any examples for. I'll start off with the favorite model: favorite/models.py from django.db import models from django.contrib.contenttypes.models import ContentType from django.contrib.contenttypes import generic from django.contrib.auth.models import User class Favorite(models.Model): content_type = models.ForeignKey(ContentType) object_id = models.PositiveIntegerField() user = models.ForeignKey(User) content_object = generic.GenericForeignKey() class Admin: list_display = ('key', 'id', 'user') class Meta: unique_together = ("content_type", "object_id", "user") Now, that allows me to loop through the favorites (on a user's "favorites" page, for example) and get the associated blog objects via {{ favorite.content_object.title }}. What I want now, and can't figure out, is what I need to do to the blog model to allow me to have some tether to the favorite (so when it is displayed in a list it can be highlighted, for example). Here is the blog model: blog/models.py from django.db import models from django.db.models import permalink from django.template.defaultfilters import slugify from category.models import Category from section.models import Section from favorite.models import Favorite from django.contrib.auth.models import User from django.contrib.contenttypes.models import ContentType from django.contrib.contenttypes import generic class Blog(models.Model): title = models.CharField(max_length=200, unique=True) slug = models.SlugField(max_length=140, editable=False) author = models.ForeignKey(User) homepage = models.URLField() feed = models.URLField() description = models.TextField() page_views = models.IntegerField(null=True, blank=True, default=0 ) created_on = models.DateTimeField(auto_now_add = True) updated_on = models.DateTimeField(auto_now = True) def __unicode__(self): return self.title @models.permalink def get_absolute_url(self): return ('blog.views.show', [str(self.slug)]) def save(self, *args, **kwargs): if not self.slug: slug = slugify(self.title) duplicate_count = Blog.objects.filter(slug__startswith = slug).count() if duplicate_count: slug = slug + str(duplicate_count) self.slug = slug super(Blog, self).save(*args, **kwargs) class Entry(models.Model): blog = models.ForeignKey('Blog') title = models.CharField(max_length=200) slug = models.SlugField(max_length=140, editable=False) description = models.TextField() url = models.URLField(unique=True) image = models.URLField(blank=True, null=True) created_on = models.DateTimeField(auto_now_add = True) def __unicode__(self): return self.title def save(self, *args, **kwargs): if not self.slug: slug = slugify(self.title) duplicate_count = Entry.objects.filter(slug__startswith = slug).count() if duplicate_count: slug = slug + str(duplicate_count) self.slug = slug super(Entry, self).save(*args, **kwargs) class Meta: verbose_name = "Entry" verbose_name_plural = "Entries" Any guidance?
