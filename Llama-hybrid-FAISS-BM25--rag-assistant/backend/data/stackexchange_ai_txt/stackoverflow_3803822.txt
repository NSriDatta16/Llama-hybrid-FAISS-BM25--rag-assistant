[site]: stackoverflow
[post_id]: 3803822
[parent_id]: 3803331
[tags]: 
A few words in general first, if you don't mind. Your confusion in implementing a "prev" function comes from thinking about this problem in domains of positive and negative integers. Think about it in terms of geometry, if you visualized a circle with 10 equally spaced points then solution looks like this : As you correctly specified, given a range [x..z] , where range is circular, you can find the next m-th number as (i+m)%k where i belongs to [x..z] and k is the length of the range. Now, for the "previous" m-th member. The previous number can be found by calculating (or more visually expressed, "arriving at") the previous m-th number position like this (pseudocode) : prev(m, i) = (i + len(range) - m) % len(range) For example, if you take the previous first of number 10 , then prev(1,10) = (10+10-1)%10 = 19%10 = 9 Previous 3rd for number 5 = prev(3,5) = (5+10-3)%10 = 12%10 = 2 . Etcetera, etcetera. Very simple, and elegant, huh? The only caveat here is that if i == m , the modulo will be a zero, so you need a handling mechanism for this result in both the next() and prev() functions. Hope this helps, Jas.
