[site]: stackoverflow
[post_id]: 606722
[parent_id]: 606074
[tags]: 
Here it is. I found this in the JModem source . If you look at where it writes the data out, you can see its doing an SOH, blocknum, ~blocknum, data, and checksum. It uses a sector size of 128. Those together make up the standard XModem protocol . Its simple enough to do XModem1K, YModem, and ZModem from here, too. /** * a tiny version of Ward Christensen's MODEM program for UNIX. * Written ~ 1980 by Andrew Scott Beals. Last revised 1982. * A.D. 2000 - dragged from the archives for use in Java Cookbook. * * @author C version by Andrew Scott Beals, sjobrg.andy%mit-oz@mit-mc.arpa. * @author Java version by Ian F. Darwin, ian@darwinsys.com * $Id: TModem.java,v 1.8 2000/03/02 03:40:50 ian Exp $ */ class TModem { protected final byte CPMEOF = 26; /* control/z */ protected final int MAXERRORS = 10; /* max times to retry one block */ protected final int SECSIZE = 128; /* cpm sector, transmission block */ protected final int SENTIMOUT = 30; /* timeout time in send */ protected final int SLEEP = 30; /* timeout time in recv */ /* Protocol characters used */ protected final byte SOH = 1; /* Start Of Header */ protected final byte EOT = 4; /* End Of Transmission */ protected final byte ACK = 6; /* ACKnowlege */ protected final byte NAK = 0x15; /* Negative AcKnowlege */ protected InputStream inStream; protected OutputStream outStream; protected PrintWriter errStream; /** Construct a TModem */ public TModem(InputStream is, OutputStream os, PrintWriter errs) { inStream = is; outStream = os; errStream = errs; } /** Construct a TModem with default files (stdin and stdout). */ public TModem() { inStream = System.in; outStream = System.out; errStream = new PrintWriter(System.err); } /** A main program, for direct invocation. */ public static void main(String[] argv) throws IOException, InterruptedException { /* argc must == 2, i.e., `java TModem -s filename' */ if (argv.length != 2) usage(); if (argv[0].charAt(0) != '-') usage(); TModem tm = new TModem(); tm.setStandalone(true); boolean OK = false; switch (argv[0].charAt(1)){ case 'r': OK = tm.receive(argv[1]); break; case 's': OK = tm.send(argv[1]); break; default: usage(); } System.out.print(OK?"Done OK":"Failed"); System.exit(0); } /* give user minimal usage message */ protected static void usage() { System.err.println("usage: TModem -r/-s file"); // not errStream, not die(), since this is static. System.exit(1); } /** If we're in a standalone app it is OK to System.exit() */ protected boolean standalone = false; public void setStandalone(boolean is) { standalone = is; } public boolean isStandalone() { return standalone; } /** A flag used to communicate with inner class IOTimer */ protected boolean gotChar; /** An inner class to provide a read timeout for alarms. */ class IOTimer extends Thread { String message; long milliseconds; /** Construct an IO Timer */ IOTimer(long sec, String mesg) { milliseconds = 1000 * sec; message = mesg; } public void run() { try { Thread.sleep(milliseconds); } catch (InterruptedException e) { // can't happen } /** Implement the timer */ if (!gotChar) errStream.println("Timed out waiting for " + message); die(1); } } /* * send a file to the remote */ public boolean send(String tfile) throws IOException, InterruptedException { char checksum, index, blocknumber, errorcount; byte character; byte[] sector = new byte[SECSIZE]; int nbytes; DataInputStream foo; foo = new DataInputStream(new FileInputStream(tfile)); errStream.println( "file open, ready to send"); errorcount = 0; blocknumber = 1; // The C version uses "alarm()", a UNIX-only system call, // to detect if the read times out. Here we do detect it // by using a Thread, the IOTimer class defined above. gotChar = false; new IOTimer(SENTIMOUT, "NAK to start send").start(); do { character = getchar(); gotChar = true; if (character != NAK && errorcount
