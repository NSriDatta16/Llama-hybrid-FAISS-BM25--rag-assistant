[site]: stackoverflow
[post_id]: 4208857
[parent_id]: 487870
[tags]: 
Ya, so I struggled with this for awhile. All the same answers about creating a custom generic IBindingList for each class. That's a crazy amount of work to do if the columns in your grid views are not static. I want to be able to change my linq queries and not have to change or update a class that implements the custom IBindingList. So, here's what I did: 1) Get your IEnumerable query. var query = from o in m_ds.Objective join ot in m_ds.ObjectiveType on o.ObjectiveTypeId equals ot.Id join dst in m_ds.DevelopmentStatusType on o.DevelopmentStatusTypeId equals dst.Id join rt in m_ds.ResultType on o.PrecedenceResultTypeId equals rt.Id select new { o.Id, type = ot.Description, precedence = rt.Description, o.Symbol, o.Title, }; 2) Convert that IEnumerable result set to a DataTable ! public static DataTable DataTableFromIEnumerable( IEnumerable ien ) { DataTable dt = new DataTable(); foreach ( object obj in ien ) { Type t = obj.GetType(); PropertyInfo[] pis = t.GetProperties(); if ( dt.Columns.Count == 0 ) { foreach ( PropertyInfo pi in pis ) { dt.Columns.Add( pi.Name, pi.PropertyType ); } } DataRow dr = dt.NewRow(); foreach ( PropertyInfo pi in pis ) { object value = pi.GetValue( obj, null ); dr[ pi.Name ] = value; } dt.Rows.Add( dr ); } return dt; } 3) Bind your DataGridView to that generic DataTable object. var query = SqlHelper.GetFilteredObjective(); var bs = new BindingSource(); bs.DataSource = Utils.DataTableFromIEnumerable( query ); dgvObjectives.DataSource = bs; 4) That's it. One utility function and you're friggin' done :) Props to Alberto Poblacion who wrote the above function to go from an IEnumerable to a DataTable: function thread c# datagridview sortable linq to ADO.NET
