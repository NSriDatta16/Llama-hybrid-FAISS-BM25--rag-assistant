[site]: stackoverflow
[post_id]: 5086823
[parent_id]: 5086749
[tags]: 
This is my present solution to the problem, but as mentioned in the question is doesn't strictly look for pattern-free DownValues , nor is it very elegant. Store the DownValues for f In[6]:= dv = DownValues[f] Out[6]= {HoldPattern[f[1]] :> 3, HoldPattern[f[x_]] :> (f[x] = x + a)} Find the DownValues to clear inside a Block to avoid immediate evaluation In[7]:= dv2clear = Block[{f}, Hold@Evaluate@Cases[dv, HoldPattern[f[args__ /; Apply[And, NumericQ /@ Flatten[{args}]]]], {3}]] Out[7]= Hold[{f[1]}] Apply Unset to the targeted DownValues inside the held list and then release In[8]:= Map[Unset, dv2clear, {2}] ReleaseHold@% Out[8]= Hold[{(f[1]) =.}] This works fine In[10]:= DownValues[f] Out[10]= {HoldPattern[f[x_]] :> (f[x] = x + a)} And can be wrapped up like so: ClearCache[f_] := Module[{dv, dv2clear}, (* Cache downvalues for use inside block *) dv = DownValues[f]; (* Find the downvalues to clear in Block to avoid immediate evaluation *) dv2clear = Block[{f},Hold@Evaluate@Cases[dv,HoldPattern[ f[args__ /; Apply[And, NumericQ /@ Flatten[{args}]]]], {3}]]; (* Apply Unset to the terms inside the held list and then release *) ReleaseHold@Map[Unset, dv2clear, {2}];]
