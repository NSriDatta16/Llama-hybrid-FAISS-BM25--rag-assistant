[site]: stackoverflow
[post_id]: 2822319
[parent_id]: 2765631
[tags]: 
First of all thanks to user332768 and bert. I tried using AbstractRoutingDataSource as mentioned in the link provided by bert, but got lost trying to hook up my jpa layer (eclipselink). I reverted to my older approach with some modifications. The solution looks cleaner (IMHO) and is working fine. (switching database at runtime and also writing to multiple databases in the same transaction) public class MyEntityManagerFactoryImpl implements MyEntityManagerFactory, ApplicationContextAware { private HashMap emFactoryMap; public EntityManager getEntityManager(String releaseId) { return SharedEntityManagerCreator.createSharedEntityManager(emFactoryMap.get(releaseName)); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { Map emMap = applicationContext.getBeansOfType(LocalContainerEntityManagerFactoryBean.class); Set keys = emMap.keySet(); EntityManagerFactory entityManagerFactory = null; String releaseId = null; emFactoryMap = new HashMap (); for (String key:keys) { releaseId = key.split("_")[1]; entityManagerFactory = emMap.get(key).getObject(); emFactoryMap.put(releaseId, entityManagerFactory); } } } I now inject my DAO's with an instance (singleton) of MyEntityManagerFactoryImpl. The dao will then simply call createSharedEntityManager with the required release and will get the correct EntityManager for that database. (Note that i am now using application managed EntityManager and hence i have to explicitly close them in my dao) I also moved to jta transaction manager (to manage transaction across multiple databases) This is how my spring xml looks like now. ... .... Cheers! (comments are welcome)
