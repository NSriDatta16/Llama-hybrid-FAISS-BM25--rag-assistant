[site]: stackoverflow
[post_id]: 1049748
[parent_id]: 
[tags]: 
Improving scalability of the modified preorder tree traversal algorithm

I've been thinking about the modified preorder tree traversal algorithm for storing trees within a flat table (such as SQL). One property I dislike about the standard approach is that to insert a node you have to touch (on average) N/2 of the nodes (everything with left or right higher than the insert point). The implementations I've seen rely on sequentially numbered values. This leaves no room for updates. This seems bad for concurrency and scaling. Imagine you have a tree rooted at the world containing user groups for every account in a large system, it's extremely large, to the point you must store subsets of the tree on different servers. Touching half of all the nodes to add a node to the bottom of the tree is bad. Here is the idea I was considering. Basically leave room for inserts by partitioning the keyspace and dividing at each level. Here's an example with N max = 64 (this would normally be the MAX_INT of your DB) 0:64 ________|________ / \ 1:31 32:63 / \ / \ 2:14 15-30 33:47 48:62 Here, a node is added to the left half of the tree. 0:64 ________|________ / \ 1:31 32:63 / | \ / \ 2:11 11:20 21:30 33:47 48:62 The alogorithm must be extended for the insert and removal process to recursively renumber to the left/right indexes for the subtree. Since querying for immediate children of a node is complicated, I think it makes sense to also store the parent id in the table. The algorithm can then select the sub tree (using left > p.left && right This is more complex than just incrementing all the indexes to make room for the insert (or decrementing for removal), but it has the potential to affect far fewer nodes (only decendenants of the parent of the inserted/removed node). My question(s) are basically: Has this idea been formalized or implemented? Is this the same as nested intervals?
