[site]: stackoverflow
[post_id]: 4431785
[parent_id]: 4274763
[tags]: 
This note is explaining what an implementation might do if it encounters code for which there is no defined behaviour. The word "permissible" is not intended to be a restriction, rather some examples of common behaviours are given. It is interesting to note that a compiler almost always HAS to compile something! Consider this fragment of code: void f() { 1 / 0; } the behaviour of the translator on encountering this is not well defined, but it can't just do anything it likes! In fact if it is a compiler it is still required to compile this compilation unit. That is because the behaviour of a program containing this function could still be well defined! The compiler cannot know if the function is called. In fact this question arose where the function was "main()" and control was certain to flow through the zero division, and the upshot is that the compiler is not allowed to reject even that program. The reason is: the program is still well formed, and a conforming compiler is required to accept all well formed programs (and reject all ill-formed ones and issue a diagnostic error message, unless otherwise specified). This can't easily be made ill-formed because it is hard to specify exactly how smart compilers can be required to be in detecting when a division by zero must take place. So interestingly, the claim of the Standard that it "Imposes no requirements" is in fact very close to being wrong. It is characteristics of a compilation system supporting separate compilation that it cannot detect if a piece of code for which there is no well defined behaviour is, in fact, executed, and so the compiler is in fact required to compile something anyhow, because it cannot deduce if the program has undefined behaviour.
