[site]: stackoverflow
[post_id]: 2539666
[parent_id]: 2539654
[tags]: 
Why don't you use java.util.concurrent.ConcurrentHashMap ? It handles everything internally avoiding useless locks on the map and saving you a lot of work: you won't have to care about synchronizations on get and put.. From the documentation: A hash table supporting full concurrency of retrievals and adjustable expected concurrency for updates. This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking , and there is not any support for locking the entire table in a way that prevents all access. You can specify its concurrency level : The allowed concurrency among update operations is guided by the optional concurrencyLevel constructor argument (default 16), which is used as a hint for internal sizing . The table is internally partitioned to try to permit the indicated number of concurrent updates without contention. Because placement in hash tables is essentially random, the actual concurrency will vary. Ideally, you should choose a value to accommodate as many threads as will ever concurrently modify the table . Using a significantly higher value than you need can waste space and time, and a significantly lower value can lead to thread contention. But overestimates and underestimates within an order of magnitude do not usually have much noticeable impact. A value of one is appropriate when it is known that only one thread will modify and all others will only read. Also, resizing this or any other kind of hash table is a relatively slow operation, so, when possible, it is a good idea to provide estimates of expected table sizes in constructors. As suggested in comments read carefully the documentation of ConcurrentHashMap , especially when it states about atomic or not atomic operations. To have the guarantee of atomicity you should consider which operations are atomic, from ConcurrentMap interface you will know that: V putIfAbsent(K key, V value) V replace(K key, V value) boolean replace(K key,V oldValue, V newValue) boolean remove(Object key, Object value) can be used safely.
