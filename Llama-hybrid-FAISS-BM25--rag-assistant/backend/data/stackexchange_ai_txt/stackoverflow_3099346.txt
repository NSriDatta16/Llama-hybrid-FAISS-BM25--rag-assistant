[site]: stackoverflow
[post_id]: 3099346
[parent_id]: 3095856
[tags]: 
The upcoming C++0x standard proposes facilities for dealing with raw memory. They are already incorporated in VC++2010 (within the tr1 namespace). std::tr1::alignment_of // get the alignment std::tr1::aligned_storage // get aligned storage of required dimension Those are types, you can use them like so: static const floatalign = std::tr1::alignment_of ::value; // demo only typedef std::tr1::aligned_storage ::type raw_vector; // first parameter is size, second is desired alignment Then you can declare your class: class MyClass { public: private: raw_vector mVector; // alignment guaranteed }; Finally, you need some cast to manipulate it (it's raw memory until now): float* MyClass::AccessVector() { return reinterpret_cast ((void*)&mVector)); }
