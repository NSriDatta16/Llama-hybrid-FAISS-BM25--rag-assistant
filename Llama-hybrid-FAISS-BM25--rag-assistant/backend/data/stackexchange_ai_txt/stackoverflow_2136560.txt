[site]: stackoverflow
[post_id]: 2136560
[parent_id]: 2136424
[tags]: 
I was just going to comment below Mark's answer, but it may feel a little bit cramped. Still, this answer is in essence a comment on his answer, which I find very good in addition to being quick :). Not only is your function not MT-safe, but even without threads, the interface to use it correctly is complicated. The caller must have finished with the previous result before calling the function again. If this code is still in use two years from now, someone will scratch his head trying to use it right... or worse, use it wrong without even thinking about it. That person could even be you... Mark's suggestion (requiring the caller to free the buffer) is IMHO the most reasonable. But perhaps you don't trust malloc and free not to cause fragmentation in the long run, or have some other reason to prefer the static buffer solution. In this case you can keep the static buffer for ordinary-length lines, define a boolean flag that indicates if the static buffer is currently busy, and document that the following function (and not free ) should be called with the address of the buffer when the caller no longer uses it: char static_buffer[512]; int buffer_busy; void free_buffer(char *p) { if (p == static_buffer) { assert(buffer_busy); buffer_busy=0; } else free(p); } char *get_line(...) { char *result; if (..short line..) { result = static_buffer; assert(!buffer_busy); buffer_busy=1; } else result = malloc(...); ... return result; } The only circumstances in which the assertions will trigger are circumstances in which your previous implementation would have silently gone wrong, and the overhead is very low compared to your existing solution (only toggling the flag, and asking the caller to call free_buffer when he's finished, which is cleaner). If the assertion in get_line in particular triggers, it means you needed dynamic allocation after all, because the caller could not be finished with a buffer at the time he was asking for another. Note: this is still not MT-safe.
