[site]: stackoverflow
[post_id]: 2172606
[parent_id]: 2167518
[tags]: 
An elegant solution this isn't. It would be more so by using a "transition matrix", and only reading one character at a time. Not my style. Yet this code has a minimum of redundant data movement, and it seems to do the job. Minimally C++, it really is just a C program. Adding iterators is left as an exercise for the reader. The data stream wasn't completely defined, and there was no defined destination for the converted data. Assumptions noted in comments. Lots of printing should show functionality. // convert series of 3 ASCII decimal digits to binary // there is a checksum byte at least once every 64 bytes - it can split a digit series // if the interval is less than 64 bytes, it must be followd by LF (to identify it) // if the interval is a full 64 bytes, the checksum may or may not be followed by LF // checksum restricted to a simple sum modulo 10 to keep ASCII format // checksum computations are only printed to allowed continuation of demo, and so results can be // inserted back in data for testing // there is no verification of the 3 byte sets of digits // results are just printed, non-zero return indicates error int readData(void) { int binValue = 0, digitNdx = 0, sensorCnt = 0, lineCnt = 0; char oneDigit; string sensorTxt; while( getline( cin, sensorTxt ) ) { int i, restart = 0, checkSum = 0, size = sensorTxt.size()-1; if(size The data definition was extended with comments, you you can use the following as is: # normal 64 byte lines with 3 digit value split across lines 00100200300400500600700800901001101201301401501601701801902002105 22023024025026027028029030031032033034035036037038039040041042046 # short lines, partial values - remove checksum digit to combine short lines 30449 0451 0460479 0480490500510520530540550560570580590600610620630641 # long line with embedded checksums every 64 bytes 001002003004005006007008009010011012013014015016017018019020021052202302402502602702802903003103203303403503603703803904004104204630440450460470480490500510520530540550560570580590600610620630640 # dangling digit at end of file (with OK checksum) 37
