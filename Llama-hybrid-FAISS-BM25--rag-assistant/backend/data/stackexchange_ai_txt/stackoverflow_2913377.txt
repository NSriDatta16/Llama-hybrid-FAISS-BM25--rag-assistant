[site]: stackoverflow
[post_id]: 2913377
[parent_id]: 2913312
[tags]: 
You're going to need to post a short but complete code sample to get any meaningful help. But let me venture a guess here. Is the second project (B) referencing the first project (A)? You have to make sure that the type Tree is actually the same Tree type in both instances. In the example you describe - it sounds like project A actually has a reference to project B - in which case, how does B know about Tree ? If you have the Tree class declared in both projects - it's not the same Tree class. One project has to reference the Tree class of the other in order for this arrangement to work the way you expect it to. The general way to organize such projects, is to move the shared classes into a third Class Library assembly , and reference that assembly in both project A and project B. Then you can inherit and consume the types exposed by the class library correctly. EDIT: So now that you've posted some code, it's possible to give you a more accurate response. It looks like what you're trying to do is pass a generic list of Oak to a method that expects a generic list of Tree . This is not something you can do prior to .NET 4 which supports generic coveriance (on interface types BTW). In versions of C# prior to 4, you cannot do: List oaklist = new List (); List treeList = oaklist; // illegal Just because Oak inherits Tree does not mean that List inherits List . You can read more about generic variance at Eric Lippert's blog. So in your case, if you want to pass a list of Oaks in to TreeForm() you need to pass it in as a list of Tree . Assuming you don't want to change the type of the collection, you can just instantiate an appropriate copy: ProjectA.TreeForm tree_form = new ProjectA.TreeForm( new List ( oaklist.Cast () ) );
