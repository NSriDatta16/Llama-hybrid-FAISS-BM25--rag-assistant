[site]: stackoverflow
[post_id]: 4294925
[parent_id]: 
[tags]: 
"The expression should have a class pointer" visual studio c++ error

I've these 2 files, but the interface (and the compiler) give me this error, can you help me find what is wrong?Is really strange... should I define all body of my methods in the .cpp file? //GameMatch.h #pragma once #include "Player.h" namespace Core { class GameMatch { private: const static unsigned int MAX_PLAYERS=20; unsigned int m_HumanControlled; Score* m_LastDeclaredScore; Score* m_LastScore; unsigned int m_MaxPlayers; Player* m_Players[MAX_PLAYERS]; unsigned int m_PlayerTurn; inline void NextTurn() { m_PlayerTurn=(m_PlayerTurn+1U)%m_MaxPlayers; } public: GameMatch(void); ~GameMatch(void); void RemovePlayer(Player* _player); inline Player* getPlayingPlayer() { return m_Players[m_PlayerTurn]; } }; } and //Player.h #pragma once #include "IController.h" #include "GameMatch.h" #include #include using namespace Core::Controller; using namespace std; namespace Core { class Player { private: IController* m_Controller; unsigned int m_Lives; GameMatch* m_GameMatch; string m_Name; bool m_TurnDone; public: inline void Die() { m_Lives-=1U; if (m_Lives RemovePlayer(this);//m_GameMatch is the first error } inline const string& getName() { return m_Name; } inline bool IsPlayerTurn() { return (m_GameMatch->getPlayingPlayer()==this); }//m_GameMatch is the second error virtual void Play()=0; inline Player(GameMatch* _gameMatch,const char* name,unsigned int lives=3) { m_GameMatch=_gameMatch; m_Name=name; m_Lives=lives; } inline void WaitTurn() { while(!IsPlayerTurn()) Sleep(1); } virtual ~Player() { delete m_Controller; } }; } But as you can see, m_GameMatch is a pointer, so I don't understand why this error, maybe for "recursive inclusion" of header files... UPDATE 1: //GameMatch.h #pragma once #include "Score.h" #include "Player.h" namespace Core { class GameMatch { private: const static unsigned int MAX_PLAYERS=20; unsigned int m_HumanControlled; Score* m_LastDeclaredScore; Score* m_LastScore; unsigned int m_MaxPlayers; Player* m_Players[MAX_PLAYERS]; unsigned int m_PlayerTurn; inline void NextTurn(); public: GameMatch(void); ~GameMatch(void); void RemovePlayer(Player* _player); inline Player* getPlayingPlayer(); }; } and //Player.h #pragma once #include "IController.h" #include "GameMatch.h" #include #include using namespace Core::Controller; using namespace std; namespace Core { class Player { private: IController* m_Controller; unsigned int m_Lives; GameMatch* m_GameMatch; string m_Name; bool m_TurnDone; public: inline void Die(); inline const string& getName(); inline bool IsPlayerTurn(); virtual void Play()=0; inline Player(GameMatch* _gameMatch,const char* name,unsigned int lives=3); inline void WaitTurn(); virtual ~Player(); }; } These are the 2 headers now, however it's still not working, if I don't include Player.h and forward declare a class in this way inside GameMatch.h: class Player; It works, however what if I want use some Player methods?I should re-forward declare everything... isn't this what header files are done for? I can include an header file in a lot of places... why can't I do it in this case? SOLUTION: The answer is from Alf P. Steinbach on chat: yes, and the answer you got seems to be correct. the cyclic header dependency is a problem. there might be other problems also, but the cyclic dependency is a big one. you don't need a full definition of a class in order to use T*. so the usual breaking of the cycle is to just forward-declare a class, like class Player; that tells the compiler that Player is a class, so you can use Player* and Player&, and even declare member functions that return Player (although you can't define such a function until Player class is fully defined) well as a concrete example, all that's needed for the Core::GameMatch class definition is a forward declaration of class Player. then in implementation file you can include "player.h". if it's needed for GameMatch implementation. if you draw the files as little boxes and draw arrows to show includes, you'll see that that gets rid of the cyclic dependency This said, he explain that the answer I got is the correct one so I'll mark OJ's
