[site]: stackoverflow
[post_id]: 2814853
[parent_id]: 2814575
[tags]: 
MSN's answer is correct. However, either of a couple style guidelines can prevent this error: Declare the comparator to work on references, not objects, as operator would. Use a vector of objects, not pointers. bool comparator2(const data& a, const data& b) { return (a.tamanho You might really need the vector of pointers, in which case this doesn't apply. Use std::priority_queue (from ), which ties together pop_heap and pop_back for you, remembering your comparator. This requires a functor comparator: struct comparator2 { bool operator()(const data& a, const data& b) { return (a.tamanho , comparator2> mesas; // or std::priority_queue , comparator2> mesas.push(x1); Most elegant way is to make this the default comparison for data : struct data { int indice; int tamanho; friend bool operator mesas; mesas.push(x1); priority_queue can also take a prefilled unsorted container, which it will copy.
