[site]: crossvalidated
[post_id]: 643052
[parent_id]: 642947
[tags]: 
It sounds like you are interested in the statistical estimation of differences between the two smooths formed by the s(conc, by = treatment, k = 6) term. If this is what you are interested in, your can compute differences between (pairs of) smooths using gratia::difference_smooths() but you can also do this yourself as it is based on a particular set of contrasts forming a specific linear combination of the model coefficients. library("gratia") library("mgcv") library("tibble") library("dplyr") data(CO2, package = "datasets") plant as_tibble() |> rename(plant = Plant, type = Type, treatment = Treatment) |> mutate(plant = factor(plant, ordered = FALSE), uptake = ifelse(treatment == "chilled" & type == "Quebec", uptake+10, uptake)) # GAM m_plant With the dev version of {gratia} on GitHub this produces > diffs # A tibble: 100 × 9 .smooth .by .level_1 .level_2 .diff .se .lower_ci .upper_ci conc 1 s(conc) treatment nonchill… chilled -0.262 0.0353 -0.331 -0.193 95 2 s(conc) treatment nonchill… chilled -0.236 0.0310 -0.297 -0.175 104. 3 s(conc) treatment nonchill… chilled -0.211 0.0273 -0.264 -0.157 113. 4 s(conc) treatment nonchill… chilled -0.185 0.0246 -0.233 -0.137 122. 5 s(conc) treatment nonchill… chilled -0.161 0.0229 -0.205 -0.116 132. 6 s(conc) treatment nonchill… chilled -0.136 0.0223 -0.180 -0.0927 141. 7 s(conc) treatment nonchill… chilled -0.113 0.0227 -0.158 -0.0688 150. 8 s(conc) treatment nonchill… chilled -0.0911 0.0237 -0.137 -0.0447 159. 9 s(conc) treatment nonchill… chilled -0.0700 0.0248 -0.119 -0.0213 168. 10 s(conc) treatment nonchill… chilled -0.0503 0.0259 -0.101 0.000551 177. # ℹ 90 more rows # ℹ Use `print(n = ...)` to see more rows (The CRAN version will produce something similar but the select argument is named something else and the variables in the returned object have different names.) We can visualise this with the draw() method diffs |> draw() How do we interpret this? We can see what's happening via a few steps (that difference_smooths() doesn't actually do directly. First we create some values of conc and treatment to compute predicted values for: ds Note this also creates values for plant and type (constant) but we'll remove those effects from the fitted values in the next step, using terms to choose just the effects of the two smooths created by the factor by smooth: fv Note we are doing this on the link (log) scale as that is what is shown on the plot you were discussing. Now we can compute a difference using some dplyr foo (but we don't get any uncertainty estimates doing it this waY) fv |> group_by(conc) |> summarise(.diff = -diff(.fitted)) This produces # A tibble: 100 × 2 conc .diff 1 95 -0.262 2 104. -0.236 3 113. -0.211 4 122. -0.185 5 132. -0.161 6 141. -0.136 7 150. -0.113 8 159. -0.0911 9 168. -0.0700 10 177. -0.0503 # ℹ 90 more rows # ℹ Use `print(n = ...)` to see more rows From this we see that chilled starts off having higher uptake than nonchilled , but that difference decreases quickly up to conc ~ 200, after which nonchilled leads to larger uptake values than chilled up to about conc 600, after which the difference decreases towards 0. Given this, we see that the effect of conc on uptake changes more rapidly as we increase conc up to about conc = 300 , and after that we see similar changes in uptake as we increase conc in the two levels of the treatment, with nonchilled leading to larger uptake at a given conc . All of this is really in terms of $\log(\text{uptake})$ of course. What we just looked at is the difference in the effects of conc on uptake between treatments excluding the treatment mean effects. So we are focusing on how the effect on uptake varies with conc alone, regardless of the constant offset between the two treatment levels. In other words we focus on differences in the shape of the smooth effects on the log scale. If you're interested in the group means being included in the comparison, you can do that with group_means = TRUE : difference_smooths(m_plant, select = "s(conc)", group_means = TRUE) Does such difference in intercept/position along the y-axis have any meaning when considering the global smooth effect? Yes, it is the magnitude of the effect of conc on the response centred on the model constant term (so centred about the mean for treatment == "nonchilled" & type == "Quebec" ) However, your language suggests that you shouldn't be doing any of this on the log scale. The way you describe the problem it seems like you are interested in the actual response of uptake as a function of conc for the two treatment levels. In which case you should be using the response scale for this, excluding the effects of model terms you are not interested in: fv2 ggplot(aes(x = conc, y = .fitted, group = treatment)) + geom_ribbon(aes(ymin = .lower_ci, ymax = .upper_ci, fill = treatment), alpha = 0.2) + geom_line(aes(colour = treatment)) This plot is showing the estimated effects of conc on uptake plus the difference between chilled and nonchilled levels. We've excluded the type effects here, but we are missing the average uptake to scale the y axis in terms of observed uptake values. If you want a difference on this response scale, then the easiest way to get it is to use {marginaleffects} as Nick showed. Use comparisons() instead of avg_comparisons() if you want actual comparisons for specified data values, and you'll need to figure out what datagrid to use if you want evenly-spaced values over conc for plotting. But I actually think you should be comparing treatment effects within type , as what does the average across type s mean? You can approach this with {gratia} using fitted_samples() to do posterior sampling, and then difference the fitted values for the comparisons of interests for each posterior draw. ({gratia} doesn't do the delta method to get confidence intervals on the response scale for difference_smooths -like operations. Instead we can do it with brute force via posterior sampling.) First, set up the data we want to generate fitted values for ds mutate(.row = row_number()) Now we take a large set of posterior draws fs add on the variables from ds fs left_join(ds, by = join_by(.row == .row)) Now we compute differences between the two treatment levels and summarise the posterior distribution of those differences with the 0.25, 0.5, and 0.975 probability quantiles library("tidyr") quantile_fun pivot_wider(id_cols = c("type", "conc", ".draw"), names_from = "treatment", values_from = ".fitted") |> mutate(.diff = nonchilled - chilled) |> group_by(type, conc) |> reframe(quantile_fun(.diff)) |> pivot_wider( id_cols = c(type, conc), names_from = .q, values_from = .value, names_prefix = ".q" ) Finally we plot: diffs |> ggplot(aes(x = conc, y = .q50, group = type)) + geom_ribbon(aes(ymin = .q2.5, ymax = .q97.5, fill = type), alpha = 0.2) + geom_line(aes(colour = type)) + labs(y = "Estimated difference", title = "Difference between treatment levels", subtitle = "Comparison: nonchilled - chilled") yielding which matches what is shown in your faceted fitted values plots in the original post (just differencing the two curves per facet). What I think this illustrates is that we have to be very clear about what we want to compare when working with GAMs, especially when we are working with non-identity link functions. Are we interested in differences of shape only? Differences among which factor levels? On the response scale or the link scale? To close, how does my brute force method compare with the elegance of marginaleffects::comparisons() ? meff # note I'm negating the values because the comparison is opposite mine ggplot(aes(x = conc, y = -estimate, group = type)) + geom_ribbon(aes(ymin = -conf.low, ymax = -conf.high, fill = type), alpha = 0.2) + geom_line(aes(colour = type)) Which is pretty similar to the one I produced via brute force sampling, and that's reassuring. Hopefully this gives you examples of the different ways you can compare your smooths in the GAM, and among those is the answer you wanted.
