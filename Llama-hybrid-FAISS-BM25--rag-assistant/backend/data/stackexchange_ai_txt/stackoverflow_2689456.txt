[site]: stackoverflow
[post_id]: 2689456
[parent_id]: 2674637
[tags]: 
OK, so I've taken a different appropach, and finall come up with a method that seems to work (tested for 8 different remote users). I've ditched the Impersonation route in favour of ClientBlankets... [DllImport("ole32.dll")] static extern int CoQueryClientBlanket(out IntPtr pAuthnSvc, out IntPtr pAuthzSvc, [MarshalAs(UnmanagedType.LPWStr)] out StringBuilder pServerPrincName, out IntPtr pAuthnLevel, out IntPtr pImpLevel, out IntPtr pPrivs, out IntPtr pCapabilities); public static string CallingUser { get { IntPtr pAthnSvc = new IntPtr(); IntPtr pAthzSvc = new IntPtr(); StringBuilder pServerPrincName = new StringBuilder(); IntPtr pAuthnLevel = new IntPtr(); IntPtr pImpLevel = new IntPtr(); IntPtr pPrivs = new IntPtr(); IntPtr pCaps = new IntPtr(4); string sCallingUser = string.Empty; try { CoQueryClientBlanket(out pAthnSvc, out pAthzSvc, out pServerPrincName, out pAuthnLevel, out pImpLevel, out pPrivs, out pCaps); } catch (Exception ex) { Logger.Write(ex.Message); } finally { sCallingUser = System.Runtime.InteropServices.Marshal.PtrToStringAuto(pPrivs); } return sCallingUser; } } Using CoCreateClientBlanket seems to have the desired results, and I'm able to reliably obtain the identity of the calling user everytime, regardless of which thread is used to process the message.
