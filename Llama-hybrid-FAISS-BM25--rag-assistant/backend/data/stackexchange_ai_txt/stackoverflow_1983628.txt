[site]: stackoverflow
[post_id]: 1983628
[parent_id]: 1983611
[tags]: 
You have at least two problems: Your table probably lacks appropriate indexes; and You may be running inside a transaction. You should have an index on (Ticker,DateStamp) and the check will be much faster. That being said, I wouldn't even do that check. If the INSERT fails, it fails. No biggie. If you're running inside a transaction and not committing or doing save points then the temporary storage will get huge as you insert rows (because the database needs to be able to rollback any changes). Commit every 1000 rows or so. Either that or don't run inside a transaction. Now, the next issue is how you're constructing the INSERT statement. You don't want to use string concatenation with parameters. It's a bad practice to get into (in Web applications this is a huge cause of SQL injection vulnerabilities). Take a look at Insert command with parameters and use something like: INSERT INTO DailyPrice (Ticker,OpenPrice,ClosePrice,HighPrice,LowPrice,AdjustedClose,Volume,DateStamp) VALUES (@Ticker,@OpenPrice,@ClosePrice,@HighPrice,@LowPrice,@AdjustedClose,@Volume,@DateStamp) Lastly, you should add a primary key. You could use (Ticker,DateStammp) for this but I personally favour technical primary keys, meaning a primary key that has no external meaning. An auto-increment integer field is the most common example of this. Adding (Ticker,DateSTamp) as a primary key will add the index I was referring to above. It's the index that really makes the difference.
