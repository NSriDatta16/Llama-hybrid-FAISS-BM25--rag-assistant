[site]: stackoverflow
[post_id]: 2986509
[parent_id]: 2602110
[tags]: 
Dynamic binary search really is a cool algorithm. The reference for it is Introduction to Algorithms (Cormen, Leiserson and Rivest) problem 18-2 and it is closely related to the online mergesort (Knuth TAOCP ex 5.2.4-17). It has O(log(n)) average successful search time. Worst case succesful and unsuccesful search are both O(log 2 (n)). And is much easier to code than balanced search trees. The search is fairly straight forward, you just have to search each row until you find something (start at the biggest). I've implemented an insertion below. The merge routine does all the sorting. Note that each row is an int * which is the same as an array of ints (or NULL). If I was making a high performance version, I'd look into caching some smaller sized arrays as malloc and free tend to be slow. int *row[30]; int lastrow=0; void dbs_insert(int v); int *dbs_merge(int *a, int *b, int len); void dbs_insert(int v) { int *new_row; int i; new_row=malloc(sizeof(int)); new_row[0]=v; i=0; while (row[i]!=NULL) { new_row=dbs_merge(row[i],new_row,1 lastrow) lastrow=i; } int *dbs_merge(int *a, int *b, int len) { int ai=0; int bi=0; int ci=0; int *c; c=malloc((2*len)*sizeof(int)); while (ai
