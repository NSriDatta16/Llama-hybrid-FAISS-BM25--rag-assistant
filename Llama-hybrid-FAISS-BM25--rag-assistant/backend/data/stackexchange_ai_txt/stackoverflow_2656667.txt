[site]: stackoverflow
[post_id]: 2656667
[parent_id]: 2656641
[tags]: 
An useful table to work out with various graphs implementations: OPERATION EDGE LIST ADJ LIST ADJ MATRIX degree(v) O(m) O(d(v)) O(n) incidentEdges(v) O(m) O(d(v)) O(n) areAdjacent(v1,v2) O(m) O(min(d(v1),d(v2)) O(1) addVertex(v) O(1) O(1) O(n²) addEdge(v) O(1) O(1) O(1) removeVertex(v) O(m) O(m) O(n²) removeEdge(e) O(m) O(d(v1)+d(v2)) O(1) memory O(m+n) O(m+n) O(n²) where m is the number of edges, n is the number of vertices and d(vertex) is the number of elements in the vertex adjacency list.. adj matrix implementation has an O(n²) to add and remove vertices because you have to reallocate the matrix.. Just prepared this for an article, that why I have it ready :) This is not directly related to benchmarking, since usually you study which operations you will mostly need and choose the right implementation for your needs, so it's a sort of "theoretical" benchmark that you do by studying what you are going to implement. Otherwise you can just measure time that your code needs to do the whole work with both implementations and compare it. EDIT: since you use a sparse matrix implementation the complexity of operations could slightly change (mostly getting a little worse, since you are trading memory for speed). EDIT2: ok, now that I know that this is Java it will be fair simple: long before = System.nanoTime(); /* execution of your algorithm */ long elapsed = System.nanoTime() - before; Answer is in nanoseconds and accuracy is not guaranteed, so use this thing carefully. Doing an average of many runs (and checking that variance is low, discarding the result that are more distant from the average) will give coherence to your results.
