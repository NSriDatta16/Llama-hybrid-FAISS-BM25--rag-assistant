[site]: stackoverflow
[post_id]: 5273818
[parent_id]: 
[tags]: 
Get the view on orientation switch or when leaving application

I'm pretty new to this Android Programming. But I'm trying to make an application that receives content from a web-based server - this functionality works like a charm - finally. But, for several days have I tried to find an answer to why my application want remember its view on orientation switching, when view is change to another activity or when leaving application. I know there is something with the manifest file to do, and the bundle, but It seems like I havent implementet this functionality correctly. Here is my manifest: This is the "main-class .Onskelisten", that also includes the tabs: package com.getpublished.onskelisten; import android.app.Notification; import android.app.NotificationManager; import android.app.PendingIntent; import android.app.TabActivity; import android.content.Context; import android.content.Intent; import android.content.res.Configuration; import android.content.res.Resources; import android.os.Bundle; import android.os.Environment; import android.view.Menu; import android.view.MenuInflater; import android.view.MenuItem; import android.widget.TabHost; public class Onskelisten extends TabActivity { /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if ( checkForExtStorage( this ) ) { Session.loadConfig( getSharedPreferences(Session.PREFS_NAME, 0 ) ); if ( Session.checkToken() == false ) { startLogin(); } else { startLoggedInSession( ); } } else { finish(); } //Session.setNewToken( getSharedPreferences( Session.PREFS_NAME, 0 ) ); } public void startLogin () { Session.setNewToken( getSharedPreferences(Session.PREFS_NAME, 0), "", 0); Intent intent = (Intent) new Intent( this, UserNotLoggedInOptions.class); startActivity(intent); } private void startLoggedInSession () { setContentView(R.layout.tabhost); Resources res = getResources(); TabHost tabHost = getTabHost(); TabHost.TabSpec spec; Intent intent; intent = new Intent().setClass( this, TabHome.class); spec = tabHost.newTabSpec("home").setIndicator( "Home", res.getDrawable(R.drawable.tab_home)) .setContent(intent); tabHost.addTab(spec); intent = new Intent().setClass( this, TabWishes.class); spec = tabHost.newTabSpec("wishes").setIndicator( "Wishes", res.getDrawable(R.drawable.tab_wishes)) .setContent(intent); tabHost.addTab(spec); intent = new Intent().setClass( this, TabWishlists.class); spec = tabHost.newTabSpec("wishlists").setIndicator( "Lists", res.getDrawable(R.drawable.tab_wishlists)) .setContent(intent); tabHost.addTab(spec); tabHost.setCurrentTabByTag("home"); } public static void addNotification ( int noteId, int contentHeaderId, int contentTextId, Context context, Object className) { String ns = Context.NOTIFICATION_SERVICE; NotificationManager mNotificationManager = (NotificationManager) context.getSystemService(ns); int icon = R.drawable.icon32; String tickerTextString = (String) context.getString(contentHeaderId); CharSequence tickerText = (CharSequence) tickerTextString; long when = System.currentTimeMillis(); Notification notification = new Notification(icon, tickerText, when); String contentString = (String) context.getString(contentTextId); CharSequence contentText = (CharSequence) contentString; Intent notificationIntent = new Intent(context, (Class ) className ); PendingIntent contentIntent = PendingIntent.getActivity(context, 0, notificationIntent, 0); notification.setLatestEventInfo(context, tickerText, contentText, contentIntent); mNotificationManager.notify(1, notification); } @Override public void onResume () { super.onResume(); if ( Session.checkToken() == true ) { startLoggedInSession( ); }else { startLogin( ); } } public static boolean checkForExtStorage ( Context context ) { if ( Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) == false ) { Session.showUsertip( "External storage is missing", context ); return false; } return true; } @Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); } @Override public boolean onOptionsItemSelected(MenuItem item) { // Handle item selection switch (item.getItemId()) { case R.id.log_out_token: startLogin( ); return true; case R.id.goto_about: Intent intent = (Intent) new Intent( getApplicationContext(),AboutOnskelisten.class); startActivity(intent); return true; default: return super.onOptionsItemSelected(item); } } @Override public boolean onCreateOptionsMenu(Menu menu) { MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.lowerpopupmenu, menu); return true; } @Override public void onSaveInstanceState (Bundle savedInstanceState) { super.onSaveInstanceState(savedInstanceState); } @Override public void onRestoreInstanceState(Bundle savedInstanceState) { super.onRestoreInstanceState(savedInstanceState); } @Override public void onPause () { super.onPause(); } @Override protected void onStop(){ super.onStop(); } } This is the "home-tab-class, .TabHome", that loads content from my server. (As i mentioned; it work, but when i leave the tab'ed activity, it looses its view.) package com.getpublished.onskelisten; import java.util.ArrayList; import org.apache.http.NameValuePair; import org.apache.http.message.BasicNameValuePair; import org.json.JSONArray; import org.json.JSONObject; import android.app.Activity; import android.content.Intent; import android.content.res.Configuration; import android.graphics.Bitmap; import android.net.Uri; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.ViewGroup; import android.view.ViewGroup.LayoutParams; import android.widget.HorizontalScrollView; import android.widget.ImageView; import android.widget.LinearLayout; import android.widget.TableLayout; import android.widget.TableRow; import android.widget.TextView; public class TabHome extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); renderHomeScreen( ); } private void renderHomeScreen ( ) { Session.loadConfig( getSharedPreferences(Session.PREFS_NAME, 0 ) ); LinearLayout mainView = (LinearLayout) new LinearLayout(this); mainView.setId(1); mainView.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT)); ViewGroup hScrollView = null; try { hScrollView = getLastContentFromWWW(); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); Log.e("TabHome/getLastContentFromWWW", "" + e.getMessage()); } mainView.addView( hScrollView ); setContentView(mainView); } @Override public void onResume() { super.onResume(); renderHomeScreen( ); } @Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); } @Override public void onSaveInstanceState (Bundle savedInstanceState) { super.onSaveInstanceState(savedInstanceState); } @Override public void onRestoreInstanceState(Bundle savedInstanceState) { super.onRestoreInstanceState(savedInstanceState); } private ViewGroup getLastContentFromWWW ( ) throws Exception { ArrayList postParameters = new ArrayList (); postParameters.add(new BasicNameValuePair("Token", Session.TOKEN )); postParameters.add(new BasicNameValuePair("GetImages", "Y") ); postParameters.add(new BasicNameValuePair("Last", "10") ); postParameters.add(new BasicNameValuePair("Size", "100x100") ); HorizontalScrollView ScrollView = new HorizontalScrollView( this ); ScrollView.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT)); ScrollView.setId(2); ScrollView.setBackgroundResource(R.drawable.panelbg); TableLayout scrollWrapper = (TableLayout) new TableLayout(this); scrollWrapper.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT)); scrollWrapper.setId(3); LinearLayout scrollChildHead = (LinearLayout) new LinearLayout(this); scrollChildHead.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT)); scrollChildHead.setId(4); TableRow scrollChildContent = (TableRow) new TableRow(this); scrollChildContent.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT)); scrollChildContent.setId(5); TextView scrollHeader = new TextView(this); scrollHeader.setText(R.string.last_images_from_site); scrollHeader.setTextSize(20); scrollHeader.setId(6); scrollChildHead.addView(scrollHeader); scrollWrapper.addView(scrollChildHead); String response = null; // TODO: Fetch locally stored images? /** * QUERY: * http://onskelisten.getpublished.no/Mobile/MobileApps/ * ?Platform=Android * &Version=V1.0 * &Token=*static* * &LastContent=Y */ if ( response == null ) { try { response = CustomHttpClient.executeHttpPost(postParameters); Log.i("Response/getWWW", response); JSONGetServerResults.validateResponse(response, this, getSharedPreferences(Session.PREFS_NAME, 0)); } catch ( Exception e ) { e.printStackTrace(); Log.e("CustomHttpClient.executeHttpPost/JSONGetServerResults.validateResponse", "" + e.getMessage()); } } JSONObject lastContentObj = null; JSONArray lastContentObjPics = null; try { lastContentObj = JSONGetServerResults.createNewObject( response ); } catch ( Exception e ) { e.printStackTrace(); Log.e("lastContentObj/lastContentObj1", "" + e.getMessage()); } if ( lastContentObj.has( "LastImages") ) lastContentObjPics = lastContentObj.getJSONArray( "LastImages" ); for ( int i = 0; i And the "Session class" that saves information from the server, so the application can receive the content it needs. package com.getpublished.onskelisten; import java.io.Serializable; import java.util.Calendar; import android.content.Context; import android.content.SharedPreferences; import android.widget.Toast; public class Session { public static final String PREFS_NAME = "Onskelisten"; public static String TOKEN; public static long TOKENLIFETIME; public static long TOKENCHECKEDNOW; public static boolean TOKENCHECK; public static Serializable LastImages; public static void setNewToken ( SharedPreferences settings, String token, long tokenLifetime ) { // SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0); SharedPreferences.Editor editor = settings.edit(); editor.putString( "Token", token ).commit(); editor.putLong( "TokenLifetime", tokenLifetime ).commit(); loadConfig( settings ); checkToken(); } public static void loadConfig ( SharedPreferences settings ) { Session.TOKEN = settings.getString("Token", ""); Session.TOKENLIFETIME = settings.getLong("TokenLifetime", 0); checkToken(); } public static boolean checkToken () { Calendar timestampC = (Calendar) Calendar.getInstance(); Session.TOKENCHECKEDNOW = (timestampC.getTimeInMillis() / 1000); if ( Session.TOKEN == "" || Session.TOKENCHECKEDNOW > Session.TOKENLIFETIME ) Session.TOKENCHECK = false; else Session.TOKENCHECK = true; /*String tokenString = "Token: " + TOKEN; tokenString += "\nTokenLifetime " + TOKENLIFETIME; tokenString += "\nTokenChecked: " + TOKENCHECKEDNOW; tokenString += "\nTokenCheck: " + ( TOKENCHECK == false ? "FALSE" : "TRUE" ); Toast.makeText( getContext(), tokenString, Toast.LENGTH_SHORT).show();*/ return Session.TOKENCHECK; } public static void showUsertip ( CharSequence charSequence, Context context ) { Toast.makeText( context, charSequence, Toast.LENGTH_LONG).show(); } } Edit: I removed some code, and it seems like the application now works perfectly on screen-orientation. Updated the codes. But there is still problems when leaving the app, unfortunally.
