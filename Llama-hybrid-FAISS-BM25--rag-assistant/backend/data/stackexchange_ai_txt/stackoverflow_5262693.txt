[site]: stackoverflow
[post_id]: 5262693
[parent_id]: 
[tags]: 
C# Using Activator.CreateInstance

I asked a question yesterday regarding using either reflection or Strategy Pattern for dynamically calling methods. However, since then I have decided to change the methods into individual classes that implement a common interface. The reason being, each class, whilst bearing some similarities also perform certain methods unique to that class. I had been using a strategy as such: switch (method) { case "Pivot": return new Pivot(originalData); case "GroupBy": return new GroupBy(originalData); case "Standard deviation": return new StandardDeviation(originalData); case "% phospho PRAS Protein": return new PhosphoPRASPercentage(originalData); case "AveragePPPperTreatment": return new AveragePPPperTreatment(originalData); case "AvgPPPNControl": return new AvgPPPNControl(originalData); case "PercentageInhibition": return new PercentageInhibition(originalData); default: throw new Exception("ERROR: Method " + method + " does not exist."); } However, as the number of potential classes grow, I will need to keep adding new ones, thus breaking the closed for modification rule. Instead, I have used a solution as such: var test = Activator.CreateInstance(null, "MBDDXDataViews."+ _class); ICalculation instance = (ICalculation)test.Unwrap(); return instance; Effectively, the _class parameter is the name of the class passed in at runtime. Is this a common way to do this, will there be any performance issues with this? I am fairly new to reflection, so your advice would be welcome.
