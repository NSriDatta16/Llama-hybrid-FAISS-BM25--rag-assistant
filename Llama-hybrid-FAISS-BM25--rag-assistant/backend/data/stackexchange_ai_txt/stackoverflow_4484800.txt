[site]: stackoverflow
[post_id]: 4484800
[parent_id]: 4483670
[tags]: 
It's a nice idea to try uploading your project to blob storage first, but unfortunately this is what Visual Studio is doing for you behind the scene anyway. As has been pointed out elsewhere, most of the time in doing the deploy is not the upload itself, but the stopping and starting of all of your update domains. If you're just running this site in a development environment, then the only way I know to speed it up is to run just one instance. If this is the live environment, then... sorry, I think you're out of luck. So that I don't have to deploy to the cloud to test minor changes, what I've found works quite well is to engineer the site so that it works when running in local IIS just like any other MVC site. The biggest barrier to this working are settings that you have in the cloud config. The way we get around this is to make a copy of all of the settings in your cloud config and put them in your web.config in the appSettings. Then rather than using RoleEnvironment.GetConfigurationSettingValue() create a wrapper class that you call instead. This wrapper class checks RoleEnvironment.IsAvailable to see if it is running in the Azure fabric, if it is, it calls the usual config function above, if not, it calls WebConfigurationManager.AppSettings[] . There are a few other things that you'll want to do around getting the config setting change events which hopefully you can figure out from the code below: public class SmartConfigurationManager { private static bool _addConfigChangeEvents; private static string _configName; private static Func _configSetter; public static bool AddConfigChangeEvents { get { return _addConfigChangeEvents; } set { _addConfigChangeEvents = value; if (value) { RoleEnvironment.Changing += RoleEnvironmentChanging; } else { RoleEnvironment.Changing -= RoleEnvironmentChanging; } } } public static string Setting(string configName) { if (RoleEnvironment.IsAvailable) { return RoleEnvironment.GetConfigurationSettingValue(configName); } return WebConfigurationManager.AppSettings[configName]; } public static Action > GetConfigurationSettingPublisher() { if (RoleEnvironment.IsAvailable) { return AzureSettingsGet; } return WebAppSettingsGet; } public static void WebAppSettingsGet(string configName, Func configSetter) { configSetter(WebConfigurationManager.AppSettings[configName]); } public static void AzureSettingsGet(string configName, Func configSetter) { // We have to store these to be used in the RoleEnvironment Changed handler _configName = configName; _configSetter = configSetter; // Provide the configSetter with the initial value configSetter(RoleEnvironment.GetConfigurationSettingValue(configName)); if (AddConfigChangeEvents) { RoleEnvironment.Changed += RoleEnvironmentChanged; } } private static void RoleEnvironmentChanged(object anotherSender, RoleEnvironmentChangedEventArgs arg) { if ((arg.Changes.OfType ().Any(change => change.ConfigurationSettingName == _configName))) { if ((_configSetter(RoleEnvironment.GetConfigurationSettingValue(_configName)))) { RoleEnvironment.RequestRecycle(); } } } private static void RoleEnvironmentChanging(object sender, RoleEnvironmentChangingEventArgs e) { // If a configuration setting is changing if ((e.Changes.Any(change => change is RoleEnvironmentConfigurationSettingChange))) { // Set e.Cancel to true to restart this role instance e.Cancel = true; } } }
