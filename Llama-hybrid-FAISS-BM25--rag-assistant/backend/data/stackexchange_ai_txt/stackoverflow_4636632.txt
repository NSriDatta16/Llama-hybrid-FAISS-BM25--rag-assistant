[site]: stackoverflow
[post_id]: 4636632
[parent_id]: 4636575
[tags]: 
Suppose that you have some particular starting point (x, y) and you're curious if there's three equal numbers in a row that start at this point. Let's consider just the case where you're looking in the horizontal direction. Then one way to do this (ignoring bounds-checking) would be like this: bool IsHorizontalMatch(int x, int y) { /* Get the value of the start position. */ const int startValue = board[x][y]; /* Confirm the two values after it match. */ for (int i = 1; i You could similarly write a function like this for checking vertically: bool IsVerticalMatch(int x, int y) { /* Get the value of the start position. */ const int startValue = board[x][y]; /* Confirm the two values after it match. */ for (int i = 1; i And finally, one for the diagonals: bool IsDiagonalDownMatch(int x, int y) { /* Get the value of the start position. */ const int startValue = board[x][y]; /* Confirm the two values after it match. */ for (int i = 1; i This works, but it's just not very elegant; all three of these functions look very similar! Fortunately, you can rewrite all of them in terms of a single unifying function. The idea is this - if you'll notice, all three functions work by having some "step size" defined indicating what direction you move. In the horizontal case, the step is (+1, +0), in the vertical case it's (+0, +1), and in the diagonal it's (+1, +1) or (+1, -1). Given this, you can write one function to check if three values match in a line: bool IsLinearMatch(int x, int y, int stepX, int stepY) { /* Get the value of the start position. */ const int startValue = board[x][y]; /* Confirm the two values after it match. */ for (int i = 1; i You can then write bool IsLineStartingAt(int x, int y) { return (IsLinearMatch(x, y, 1, 0) || // Horizontal IsLinearMatch(x, y, 0, 1) || // Vertical IsLinearMatch(x, y, 1, 1) || // Diagonal Down IsLinearMatch(x, y, 1, -1)); // Diagonal Up } Given this primitive, you can check for all possible matches by just iterating over all possible starting points. Hope this helps! EDIT: Thanks to commenters for helping to fix my silly bugs. :-)
