[site]: stackoverflow
[post_id]: 2672440
[parent_id]: 2672398
[tags]: 
There are multiple ways of going about this, I think. From what I understand, n can only take on a specific range of numbers. For that, you might prevent the constructor from even being run: template class ranged_type_c { public: typedef T value_type; ranged_type_c(const value_type& pX) : mX(pX) { check_value(); } const value_type& get(void) const { return mX; } operator const value_type&(void) const { return get(); } // non-const overloads would probably require a proxy // of some sort, to ensure values remain valid private: void check_value(void) { if (mX Max) throw std::range_error("ranged value out of range"); } value_type mX; }; Could be more fleshed out, but that's the idea. Now you can clamp the range: struct foo_c { foo_c(ranged_value_c i) : x(i) {} int x; }; If you pass a value that does not lie from 0-100, the above would throw. At runtime, I think your original idea was best: template const T& check_range(const T& pX, const T& pMin, const T& pMax) { if (pX pMax) throw std::range_error("ranged value out of range"); return pValue; } struct foo { foo(int i) : x(check_range(i, 0, 100)) {} int x; } And that's it. Same as above, but 0 and 100 can be replaced with a call to some function that returns the valid minimum and maximum. If you do end up using a function call to get valid ranges (recommended, to keep clutter to a minimum and organization higher), I'd add an overload: template const T& check_range(const T& pX, const std::pair & pRange) { return check_range(pX, pRange.first, pRange.second); // unpack } To allow stuff like this: std::pair get_range(void) { // replace with some calculation return std::make_pair(0, 100); } struct foo { foo(int i) : x(check_range(i, get_range())) {} int x; } If I were to choose, I'd pick the runtime methods even if the range was compile-time. Even with low optimization the compiler will generate the same code, and it's much less clumsy and arguably cleaner to read than the class version.
