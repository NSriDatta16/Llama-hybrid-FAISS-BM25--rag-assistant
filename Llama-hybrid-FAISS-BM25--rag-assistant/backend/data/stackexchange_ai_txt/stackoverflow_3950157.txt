[site]: stackoverflow
[post_id]: 3950157
[parent_id]: 3948412
[tags]: 
In the first example, you've only stored the pointer returned by malloc in a local variable. It's lost when the function returns. Usual practice in the C language is to use the function's return value to pass the pointer to an allocated object back to the caller. As Armen pointed out, you can also pass a pointer to where the function should store its output: void Allocate2D(double*** pMatrix...) { *pMatrix = malloc(...) } but I think most people would scream as soon as they see *** . You might also consider that arrays of pointers are not an efficient implementation of matrices. Allocating each row separately contributes to memory fragmentation, malloc overhead (because each allocation involves some bookkeeping, not to mention the extra pointers you have to store), and cache misses. And each access to an element of the matrix involves 2 pointer dereferences rather than just one, which can introduce stalls. Finally, you have a lot more work to do allocating the matrix, since you have to check for failure of each malloc and cleanup everything you've already done if any of them fail. A better approach is to use a one-dimensional array: double *matrix; matrix = malloc(nrows*ncols*sizeof *matrix); then access element (i,j) as matrix[i*ncols+j] . The potential disadvantages are the multiplication (which is slow on ancient cpus but fast on modern ones) and the syntax. A still-better approach is not to seek excess generality. Most matrix code on SO is not for advanced numerical mathematics where arbitrary matrix sizes might be needed, but for 3d gaming where 2x2, 3x3, and 4x4 are the only matrix sizes of any practical use. If that's the case, try something like double (*matrix)[4] = malloc(4*sizeof *matrix); and then you can access element (i,j) as matrix[i][j] with a single dereference and an extremely fast multiply-by-constant. And if your matrix is only needed at local scope or inside a structure, just declare it as: double matrix[4][4]; If you're not extremely adept with the C type system and the declarations above, it might be best to just wrap all your matrices in structs anyway: struct matrix4x4 { double x[4][4]; }; Then declarations, pointer casts, allocations, etc. become a lot more familiar. The only disadvantage is that you need to do something like matrix.x[i][j] or matrix->x[i][j] (depending on whether matrix is a struct of pointer to struct) instead of matrix[i][j] . Edit: I did think of one useful property of implementing your matrices as arrays of row pointers - it makes permutation of rows a trivial operation. If your algorithms need to perform a lot of row permutation, this may be beneficial. Note that the benefit will not be much for small matrices, though, and than column permutation cannot be optimized this way.
