[site]: stackoverflow
[post_id]: 1642516
[parent_id]: 1642462
[tags]: 
I don't believe that a pure Black Box approach is completely right. My thinking would go like this: A). Look at the inputs. Think of ways that a person could send in bad stuff. Examples: Null reference Empty string Very long string String with all digits String with weird punctuation characters String with unprintable, or strange character sets In each case you need to know the expected outcome - that is the formal definition of what is "right". To this extent you are doing Black Box testing. You don't want to know what the code does, you want to know what it should do. B). But now we open the box. You look at the code and look for the various branches it has. Do your tests exercise those branches? There are coverage tools to analyse your tests. Suppose that you had a special case: to take a silly example, the word MY-SPECIAL-SYMBOL is subject to some special processing, there's an "If" for that. Your test case needs to include that as an input. You often can only find such corner cases by looking at the code. (Yes the spec should tell you, but the implementors often find interesting extras, so look at the code. C). What about side effects? Suppose that this method was supposed to update a cache for each symbol it found. It's a formal requriement of the component, and yet the interface doesn't tell you that. Again you are going inside the Black Box. So here you might use mocks to let you verify that the component in turn passed the right data to the cache api.
