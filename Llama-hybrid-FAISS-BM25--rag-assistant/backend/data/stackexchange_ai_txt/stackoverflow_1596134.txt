[site]: stackoverflow
[post_id]: 1596134
[parent_id]: 1595952
[tags]: 
Having many mock objects shows that: 1) You have too much dependencies. Re-look at your code and try to break it further down. Especially, try to separate data transformation and processing. Since I don't have experience in the environment you are developing in. So let me give my own experience as example. In Java socket, you will be given a set of InputStream and OutputStream simple so that you can read data from and send data to your peer. So your program looks like this: InputStream aIn = aSocket.getInputStram(); OutputStream aOut = aSocket.getOutputStram(); // Read data Object Data = aIn.read(); // Simplified read // Process if (Data.equals('1')) { // Do something // Write data aOut.write('A'); } else { // Do something else // Write another data aOut.write('B'); } If you want to test this method, you have to ends up create mock for In and Out which may require quite a complicated classes behind them for supporting. But if you look carefully, read from aIn and write to aOut can be separated from processing it. So you can create another class which will takes the read input and return output object. public class ProcessSocket { public Object process(Object readObject) { if (readObject.equals(...)) { // Do something // Write data return 'A'; } else { // Do something else // Write another data return 'B'; } } and your previous method will be: InputStream aIn = aSocket.getInputStram(); OutputStream aOut = aSocket.getOutputStram(); ProcessSocket aProcessor = ...; // Read data Object Data = aIn.read(); // Simplified read aProcessor.process(Data); This way you can test the processing with little need for mock. you test can goes: ProcessSocket aProcessor = ...; assert(aProcessor.process('1').equals('A')); Becuase the processing is now independent from input, output and even socket. 2) You are over unit testing by unit test what should be integration tested. Some tests are not for unit testing (in the sense that it require unnecessarily more effort and may not efficiently get a good indicator). Examples of these kind of tests are those involving concurrency and user interfaces. They require different ways of testing than unit testing. My advice would be that you further break them down (similar to the technique above) until some of them are unit-test suitable. So you have the little hard-to-test parts. EDIT If you believe you already broken it into very fine pieces, perhaps, that is your problem. Software components or sub-components are related to each other in some way like characters are combined to words, words are combined to sentences, sentences to paragraphs, paragraphs to subsection, section, chapters and so on. My example says, your should broken subsection to paragraphs and you things you already downs to words. Look at it this way, most of the time, paragraphs are related to other paragraphs in a less loosely degree than sentences related (or depends on) other sentences. Subsection, section are even more loosely while words and characters are more dependent (as the grammatical rules kick in). So perhaps, you are breaking it so fine that the language syntax force to those dependencies and in turn forcing you to have so much mock objects. If that is the case, your solution is to balance the test. If a part are depended by many and it is require a complex set of mock object (or simple more effort to test it). May be you don't need to test it. For example, If A uses B,C uses B and B is so damn hard to test. So why don't you just test A+B as one and C+B as anther. In my example, if SocketProcessor is so hard to test, too hard to the point that you will spend more time testing and maintain the tests more than developing it then it is not worth it and I will just test the whole things at once. Without seeing your code (and with the fact that I am never develop CocaoTouch) it will be hard to tell. And I may be able to provide good comment here. Sorry :D. EDIT 2 See your example, it is pretty clear that you are dealing with integration issue. Assuming that you already test play movie and UI separatedly. It is understandable why you need so much mock objects. If this is the first time you use these kind of integration structure (this concurrent pattern), then those mock objects may actually be needed and there is nothing much you can do about it. That's all I can say :-p Hope this helps.
