[site]: stackoverflow
[post_id]: 256174
[parent_id]: 255797
[tags]: 
Here is a tested and working example of a state machine. Say you are on a serial stream (serial port, tcp/ip data, or file are typical examples). In this case I am looking for a specific packet structure that can be broken into three parts, sync, length, and payload. I have three states, one is idle, waiting for the sync, the second is we have a good sync the next byte should be length, and the third state is accumulate the payload. The example is purely serial with only one buffer, as written here it will recover from a bad byte or packet, possibly discarding a packet but eventually recovering, you can do other things like a sliding window to allow for immediate recovery. This would be where you have say a partial packet that is cut short then a new complete packet starts, the code below wont detect this and will throw away the partial as well as the whole packet and recover on the next. A sliding window would save you there if you really needed to process all the whole packets. I use this kind of a state machine all the time be it serial data streams, tcp/ip, file i/o. Or perhaps tcp/ip protocols themselves, say you want to send an email, open the port, wait for the server to send a response, send HELO, wait for the server to send a packet, send a packet, wait for the reply, etc. Essentially in that case as well as in the case below you may be idling waiting for that next byte/packet to come in. To remember what you were waiting for, also to re-use the code that waits for something you can use state variables. The same way that state machines are used in logic (waiting for the next clock, what was I waiting for). Just like in logic, you may want to do something different for each state, in this case if I have a good sync pattern I reset the offset into my storage as well as reset the checksum accumulator. The packet length state demonstrates a case where you may want to abort out of the normal control path. Not all, in fact many state machines may jump around or may loop around within the normal path, the one below is pretty much linear. I hope this is useful and wish that state machines were used more in software. The test data has intentional problems with it that the state machine recovers from. There is some garbage data after the first good packet, a packet with a bad checksum, and a packet with an invalid length. My output was: good packet:FA0712345678EB Invalid sync pattern 0x12 Invalid sync pattern 0x34 Invalid sync pattern 0x56 Checksum error 0xBF Invalid packet length 0 Invalid sync pattern 0x12 Invalid sync pattern 0x34 Invalid sync pattern 0x56 Invalid sync pattern 0x78 Invalid sync pattern 0xEB good packet:FA081234567800EA no more test data The two good packets in the stream were extracted despite the bad data. And the bad data was detected and dealt with. #include #include #include unsigned char testdata[] = { 0xFA,0x07,0x12,0x34,0x56,0x78,0xEB, 0x12,0x34,0x56, 0xFA,0x07,0x12,0x34,0x56,0x78,0xAA, 0xFA,0x00,0x12,0x34,0x56,0x78,0xEB, 0xFA,0x08,0x12,0x34,0x56,0x78,0x00,0xEA }; unsigned int testoff=0; //packet structure // [0] packet header 0xFA // [1] bytes in packet (n) // [2] payload // ... payload // [n-1] checksum // unsigned int state; unsigned int packlen; unsigned int packoff; unsigned char packet[256]; unsigned int checksum; int process_packet( unsigned char *data, unsigned int len ) { unsigned int ra; printf("good packet:"); for(ra=0;ra =packlen) { state=0; checksum=checksum&0xFF; if(checksum) { printf("Checksum error 0x%02X\n",checksum); } else { process_packet(packet,packlen); } } break; } } //do other stuff, handle other devices/interfaces } }
