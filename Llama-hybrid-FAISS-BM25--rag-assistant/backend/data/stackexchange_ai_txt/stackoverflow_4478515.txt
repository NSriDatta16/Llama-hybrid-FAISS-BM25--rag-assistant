[site]: stackoverflow
[post_id]: 4478515
[parent_id]: 4478438
[tags]: 
If your in is a BufferedReader then you've run into the common problem with buffering more than needed. The default buffer size of BufferedReader is 8192 characters which is approximately the difference between what you expected and what you got. So the data you are missing is inside BufferedReader's internal buffer, converted to characters (I wonder why it didn't break with some kind of conversion error). The only workaround is to read the first lines byte-by-byte without using any buffered classes readers. Java doesn't provide an unbuffered InputStreamReader with readLine() capability as far as I know (with the exception of the deprecated DataInputStream.readLine(), as indicated in the comments below), so you have to do it yourself. I would do it by reading single bytes, putting them into a ByteArrayOutputStream until I encounter an EOL, then converting the resulting byte array into a String using the String constructor with the appropriate encoding. Note that while you can't use a BufferedInputReader, nothing stops you from using a BufferedInputStream from the very beginning, which will make byte-by-byte reads more efficient. Update In fact, I am doing something like this right now, only a bit more complicated. It is an application protocol that involves exchanging some data structures that are nicely represented in XML, but they sometimes have binary data attached to them. We implemented this by having two attributes in the root XML: fragmentLength and isLastFragment. The first one indicates how much bytes of binary data follow the XML part and isLastFragment is a boolean attribute indicating the last fragment so the reading side knows that there will be no more binary data. XML is null-terminated so we don't have to deal with readLine(). The code for reading looks like this: InputStream ins = new BufferedInputStream(socket.getInputStream()); while (!finished) { ByteArrayOutputStream buf = new ByteArrayOutputStream(); int b; while ((b = ins.read()) > 0) { buf.write(b); } if (b == -1) throw new EOFException("EOF while reading from socket"); // b == 0 Document xml = readXML(new ByteArrayInputStream(buf.toByteArray())); processAnswers(xml); Element root = xml.getDocumentElement(); if (root.hasAttribute("fragmentLength")) { int length = DatatypeConverter.parseInt( root.getAttribute("fragmentLength")); boolean last = DatatypeConverter.parseBoolean( root.getAttribute("isLastFragment")); int read = 0; while (read Using null-terminated XML for this turned out to be a really great thing as we can add additional attributes and elements without changing the transport protocol. At the transport level we also don't have to worry about handling UTF-8 because XML parser will do it for us. In your case you're probably fine with those two lines, but if you need to add more metadata later you may wish to consider null-terminated XML too.
