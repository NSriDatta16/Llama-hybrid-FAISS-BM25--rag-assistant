[site]: stackoverflow
[post_id]: 1919453
[parent_id]: 1919236
[tags]: 
You have already seem several perfectly good answers that depend on knowing the length of the list in advance. To fairly select a single item from a list without needing to know the length of the list in the first place do this: if (list.empty()) error_out_somehow r=list.first() // r is a reference or pointer s=list.first() // so is s i = 2 while (r.next() is not NULL) r=r.next() if (random(i)==0) s=r // random() returns a uniformly // drawn integer between 0 and i i++ return s (Useful if you list is stored as a linked list) To distribute prizes in this scenario, just walk down the list of prizes selecting a random winner for each one. (If you want to prevent double winning you then remove the winner from the participant list.) Why does it work? You start with the first item at 1/1 On the next pass, you select the second item half the time ( 1/2 ), which means that the first item has probability 1 * (2-1)/2 = 1/2 on further iteration, you select the nth item with probability 1/n , and the chance for each previous item is reduced by a factor of (n-1)/n which means that when you come to the end, the chance of having the m th item in the list (of n items) is 1/m * m/(m+1) * (m+1)/(m+2) * ... * (n-2)/(n-1) * (n-1)/n = 1/n and is the same for every item. If you are paying attention, you'll note that this means walking the whole list every time you want to select an item from the list, so this is not maximally efficient for (say) reordering the whole list (though it does that fairly).
