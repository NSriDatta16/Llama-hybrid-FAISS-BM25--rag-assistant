[site]: stackoverflow
[post_id]: 1389492
[parent_id]: 1389402
[tags]: 
Why do I even bother passing something as a reference if it gets copied twice anyway? You should consider STL container types as blackbox that can copy the objects you store as often as they need to. For instance, every time the container is resized, all of the objects will be copied. It is possible that your compiler's implementation of push_back() uses a temporary extra copy. On my machine (gcc on Mac OS X), there are no extra copies during push_back() (according to your program's output). This copy happens somewhere in the STL code, not in your copy constructor (since it uses a reference). Why does the v1.operator=(other) not destroy the elements it contains? Foo::operator= will be called for the "albert" instance with the "bert" instance as argument. Therefore, there is no implicit destroy and copy operation here. You might want to verify this by providing your own implementation for the operator: Foo& operator=(const Foo& other) { cout This produces the following output on my machine: Instance Albert of Foo created! Instance Bert of Foo created! Instance Albert of Foo copied! Instance Bert of Foo copied! Instance Bert of Foo assigned to Albert! Instance Bert of Foo destroyed! Instance Albert of Foo destroyed! Instance Bert of Foo destroyed! Instance Albert of Foo destroyed!
