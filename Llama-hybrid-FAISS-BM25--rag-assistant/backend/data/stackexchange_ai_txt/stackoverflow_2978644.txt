[site]: stackoverflow
[post_id]: 2978644
[parent_id]: 
[tags]: 
Why does Java's socket.connect() consume 100% cpu resources?

I created a threadpool and gave it 50 tasks to connect to a server. So once it was done connecting, sending some data over, then disconnecting. It also has a read timeout set at 5 seconds (5000 long of course). I even set the thread pool to a max size of 1. I then fire this up, on linux, and ran htop (a better version of top) to check the CPU usage. I consistently saw one of my cores (2 core machine) at 100% the entire time. I profiled this with hprof ( -agentlib:hprof=cpu=samples,interval=20,depth=3 ) and had socket.connect() at 99%. Here is what i find weird, isn't the point of blocking IO to block (hence wait) ? My JDK is (from java -version ): OpenJDK Runtime Environment (IcedTea6 1.6.1) (6b16-1.6.1-3ubuntu3) OpenJDK Server VM (build 14.0-b16, mixed mode) Update1 : this same problem occurs on Sun's JVM too: java -version Java version "1.6.0_20" Update2 : This is due to the doConnect method which is native. Anyone know how I can view the source for this native/C code? Update3 : I logged into windows to write the code and test it. It worked fine, no CPU resources being hosed. I log back into linux, and now the problem is still here, but not as sever as to hose the entire CPU core at 100% for just 1 connect.... Here is the code: import java.io.IOException; import java.net.InetAddress; import java.net.InetSocketAddress; import java.net.Socket; import java.net.UnknownHostException; import java.util.Vector; import java.util.concurrent.Callable; import java.util.concurrent.Executors; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public class SocketTest { public static void main(String[] args) { new SocketTest(); } public SocketTest() { ThreadPoolExecutor tpe = (ThreadPoolExecutor) Executors.newFixedThreadPool(40); Vector > tasks = new Vector >(); for (int i = 0; i
