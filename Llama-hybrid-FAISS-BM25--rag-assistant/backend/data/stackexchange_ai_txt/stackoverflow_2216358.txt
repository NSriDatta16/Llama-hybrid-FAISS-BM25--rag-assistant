[site]: stackoverflow
[post_id]: 2216358
[parent_id]: 2216239
[tags]: 
The short answer: A const is a promise that you will not try to modify the value once set. A static variable means that the object's lifetime is the entire execution of the program and it's value is initialized only once before the program startup. All statics are initialized if you do not explicitly set a value to them.The manner and timing of static initialization is unspecified . C99 borrowed the use of const from C++. On the other hand, static has been the source of many debates (in both languages) because of its often confusing semantics. Also, with C++0x until C++11 the use of the static keyword was deprecated for declaring objects in namespace scope. This deprecation was removed in C++11 for various reasons (see here ). The longer answer: More on the keywords than you wanted to know (right from the standards): C99 #include #pragma STDC FENV_ACCESS ON /* file scope, static storage, internal linkage */ static int i1; // tentative definition, internal linkage extern int i1; // tentative definition, internal linkage int i2; // external linkage, automatic duration (effectively lifetime of program) int *p = (int []){2, 4}; // unnamed array has static storage /* effect on string literals */ char *s = "/tmp/fileXXXXXX"; // static storage always, may not be modifiable char *p = (char []){"/tmp/fileXXXXXX"}; // static, modifiable const char *cp = (const char []){"/tmp/fileXXXXXX"} // static, non-modifiable void f(int m) { static int vla[ m ]; // err float w[] = { 0.0/0.0 }; // raises an exception /* block scope, static storage, no-linkage */ static float x = 0.0/0.0; // does not raise an exception /* ... */ /* effect on string literals */ char *s = "/tmp/fileXXXXXX"; // static storage always, may not be modifiable char *p = (char []){"/tmp/fileXXXXXX"}; // automatic storage, modifiable const char *cp = (const char []){"/tmp/fileXXXXXX"} // automatic storage, non-modifiable } inline void bar(void) { const static int x = 42; // ok // Note: Since an inline definition is distinct from the // corresponding external definition and from any other // corresponding inline definitions in other translation // units, all corresponding objects with static storage // duration are also distinct in each of the definitions static int y = -42; // error, inline function definition } // the last declaration also specifies that the argument // corresponding to a in any call to f must be a non-null // pointer to the first of at least three arrays of 5 doubles void f(double a[static 3][5]); static void g(void); // internal linkage C++ Has the same semantics mostly except as noted in the short answer. Also, there are no parameter qualifying static s. extern "C" { static void f4(); // the name of the function f4 has // internal linkage (not C language // linkage) and the functionâ€™s type // has C language linkage. } class S { mutable static int i; // err mutable static int j; // err static int k; // ok, all instances share the same member }; inline void bar(void) { const static int x = 42; // ok static int y = -42; // ok } There are a few more nuances of C++'s static that I leave out here. Have a look at a book or the standard.
