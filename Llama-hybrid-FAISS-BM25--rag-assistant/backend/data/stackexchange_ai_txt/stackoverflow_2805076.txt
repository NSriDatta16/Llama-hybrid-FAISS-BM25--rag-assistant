[site]: stackoverflow
[post_id]: 2805076
[parent_id]: 2767786
[tags]: 
the short answer appears to be there is no easy answer. at least no easy way to reassign range/location of the stack pointer. the loader 'ld-linux.so' at a very early stage in process activation gets the address in the hurd loader - in the glibc sources, elf/ and sysdeps/x86_64/ search out elf_machine_load_address() and elf_machine_runtime_setup(). this happens in the preamble of calling your _start() entry and related setup to call your main(), is not for the faint hearted, even i couldn't convince myself this was a safe route. as it happens - the resolution presents itself in some other old school tricks... pointer deflations/inflation... with -mcmodel=small then automatic variables, alloca() addresses, and things like argv[], and envp are assigned from high memory from where the stack will grow down. those addresses are verified in this example code: #include #include #include extern char etext, edata, end; char global_buffer[128]; int main( int argc, const char *argv[], const char *envp ) { char stack_buffer[128]; static char static_buffer[128]; char *cp = malloc( 128 ); char *ap = alloca( 128 ); char *xp = "STRING CONSTANT"; printf("argv[0] %p\n",argv[0]); printf("envp %p\n",envp); printf("stack %p\n",stack_buffer); printf("global %p\n",global_buffer); printf("static %p\n",static_buffer); printf("malloc %p\n",cp); printf("alloca %p\n",ap); printf("const %p\n",xp); printf("printf %p\n",printf); printf("First address past:\n"); printf(" program text (etext) %p\n", &etext); printf(" initialized data (edata) %p\n", &edata); printf(" uninitialized data (end) %p\n", &end); } produces this output: argv[0] 0x7fff1e5e7d99 envp 0x7fff1e5e6c18 stack 0x7fff1e5e6a80 global 0x6010e0 static 0x601060 malloc 0x602010 alloca 0x7fff1e5e69d0 const 0x400850 printf 0x4004b0 First address past: program text (etext) 0x400846 initialized data (edata) 0x601030 uninitialized data (end) 0x601160 all access to/from the 32bit parts of structures must be wrapped with inflate() and deflate() routines, e.g.: void *inflate( unsigned long ); unsigned int deflate( void *); deflate() tests for bits set in the range 0x7fff00000000 and marks the pointer so that inflate() will recognize how to reconstitute the actual pointer. hope that helps if anyone similarly must support structures with 32bit storage for 64bit pointers.
