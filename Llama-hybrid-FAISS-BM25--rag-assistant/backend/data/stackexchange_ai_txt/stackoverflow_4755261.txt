[site]: stackoverflow
[post_id]: 4755261
[parent_id]: 4754500
[tags]: 
this is easily solvable with qt using c++: you can define a new style, override drawPrimitive method and do custom painting (or just do nothing) there whenever QStyle::PE_IndicatorItemViewItemDrop constant is received via element parameter. Below is an example: class TestStyle : public QProxyStyle { public: TestStyle(QStyle *baseStyle = 0) : QProxyStyle(baseStyle) {} void drawPrimitive(PrimitiveElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const { if (element == QStyle::PE_IndicatorItemViewItemDrop) { //?? do nothing or do custom painting here } else { QProxyStyle::drawPrimitive(element, option, painter, widget); } } }; .. ui->treeView->setStyle(new TestStyle(ui->treeView->style())); now the bad news is that pyqt doesn't seem to know anything about QProxyStyle; looks like it's not wrapped there, so in order for this to work you would need to wrap style classes yourself. another solution is to create a custom QTreeView descendant and override its paintEvent method. Default implementation is calling drawTree and paintDropIndicator; where paintDropIndicator is responsible for drag and drop indicator, and drawTree renders tree items. drawTree is protected and available for you to call from your paintEvent: class TestTreeView : public QTreeView { public: explicit TestTreeView(QWidget *parent = 0) : QTreeView(parent) {} void paintEvent(QPaintEvent * event) { QPainter painter(viewport()); drawTree(&painter, event->region()); } }; this should suppress the default drag and drop indicator. Let me know if you're having troubles converting it to python. hope this helps, regards
