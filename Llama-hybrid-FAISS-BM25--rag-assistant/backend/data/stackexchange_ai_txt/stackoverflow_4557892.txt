[site]: stackoverflow
[post_id]: 4557892
[parent_id]: 
[tags]: 
Looking to arrive at a usable solution for password salting in a PHP/MySQL application?

After reading about password hashing/salting for an entire day (no lie!), I'm in need of arriving at a solution that works, can be used consistently, and is about secure enough for a variety of different sites/applications that are using a shared codebase. So, here's an idea of a MySQL user table: users { id, username, password_hash, password_salt } ..and pseudo-ish code: $s_algo = 'sha1'; $i_iterations = 1000; $s_password = 'mypw123xyuACE&.!3'; $s_salt = hash($s_algo,uniqid(mt_rand(),true)); $s_result = $s_password; for ($i = 0; $i The interaction (SQL) between PHP and MySQL is taken as read, as are the bits of PHP code that actually verify the given password from user-land against the stored (salted) hash at authentication time. It's not rocket science. This is from the perspective of already doing all that stuff, but with un-salted hash-only password storage. From my reading I suspect there could be endless debates about what $s_algo should really be (ok, probably NOT md5), and also $i_iterations. So let's just consider that they are variables within this problem scenario, which might change according to the specific context, i.e. storage limitations, server load concerns, etc. These things aside, is this methodology for creating a per-user-salted passwords in PHP generally sound? Does the 'for' loop need to be in there at all? Is the initial salt creation code ok? Is the salt-length overkill, storage-wise (equal to the eventual hash length). Please people, pick holes (but not too many!).. Other thoughts: - What about hash_hmac() - is that a critical improvement over multiple hash() iterations? - PBKDF2?
