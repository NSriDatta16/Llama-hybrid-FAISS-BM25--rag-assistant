[site]: stackoverflow
[post_id]: 1744217
[parent_id]: 1743964
[tags]: 
Instead of scanning each line for a 1 and drawing each cell, You could "walk" the walls. while not at end of your bool array: Scan until you find a 1 define a function called "Draw" which will: Draw each adjacent 0 (or out-of-bounds) as a wall Change the current 1 to a 3 (this would require you to use something other than an array of bools) Switch the current cursor to an adjacent 1 Recurse into "Draw" If no such adjacent exists, return from Draw. of wall. -upon return, resume scan until next 1 or end of input is found. Maybe not the most efficient, but you said elegant. Recursion's always elegant! (until you get a stackoverflow that is). Here is some hacked-out code (don't use magic numbers like I did :) ) to help you out: int inputIdxToOutputIdx(int idx) { return (idx + 1); } int draw(int x, int y, int arr[6][6], char outBuff[8][8]) { for (int deltaX = -1; deltaX 5 || currY > 5 || currX In the above solution, I merely draw '*''s. However, if you wanted to draw a specific piece for a given situation, I would use a lookup table like walkytalky said in his comment. Map a given set of adjacent 1's and 0's to a give piece. IE: Looking up: 0 1 0 0 1 1 0 1 0 would give a "T" result for the center wall piece. Be sure to treat "off the map" as equivelant to 0. When all is said and done just a straight scan with a a lookup table based on adjacent pieces (without recursion) might be your best bet unless you can make the above solution smarter about not rescanning what has already been scanned.
