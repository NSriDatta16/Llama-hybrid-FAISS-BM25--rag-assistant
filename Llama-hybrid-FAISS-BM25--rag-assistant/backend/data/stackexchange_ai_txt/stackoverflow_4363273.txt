[site]: stackoverflow
[post_id]: 4363273
[parent_id]: 4363180
[tags]: 
Fundamentally, quicksort is a top-down approach while mergesort is a bottom-up approach. In quicksort, we select a "pivot" or "partition" value, and partition the list into two "halves" (not always exactly half, but the closer to half the better) - those less-than the pivot and those greater. We then recurse on those two halves and the result is that they are sorted. A trace: 2, 3, 4, 1 (select pivot 3) 2, 1 | 3, 4 (partition = partition) 1, 2 | 3, 4 (recursively sort halves) 1, 2, 3, 4 (done) In merge sort, we divide the list into two halves (without sorting -- so it can be exactly half) then recursively sort the two halves. Then on the way up, we "merge" the two lists (themselves sorted but not partitioned). A trace: 2, 3, 4, 1 2, 3 | 4, 1 (cut in half) 2, 3 | 1, 4 (recursively sort halves) 1, 2, 3, 4 (merge; done) Note the difference between the traces: in QS, we first get the lists partitioned so no item in the left list is greater than any in the right, but the lists themselves are unsorted. In MS, we first get the lists sorted, but they have no relationship across lists until the merge. Both are N log N on average, but the performance details vary. Notably, quicksort can be done in-place, but its biggest flaw it having to choose a pivot. Choosing a bad pivot can result in not splitting in half, which can make for at worst O(N^2) performance. Merge sort always partitions exactly in half.
