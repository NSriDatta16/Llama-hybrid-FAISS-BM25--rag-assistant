[site]: stackoverflow
[post_id]: 3544486
[parent_id]: 3544405
[tags]: 
If you need to expose check_stuff as public (as well as do_something which currently calls it), a simple refactoring will see you through without repeating any calculations: class Object { public: bool check_stuff() { lock l(m); return internal_check_stuff(l); } void do_something() { lock l(m); if (internal_check_stuff(l)) { /* ... */ } /* ... */ } private: mutex m; bool internal_check_stuff(lock&) { return /* some calculation */; } } (as per @Logan's answer, passing a lock reference to the internal function is just a good idea to avoid forgetfulness from future maintainers;-). Recursive locks are only needed when you call a method which locks from another one which also does (with the same lock), but a little refactoring (moving the common functionality into private methods that don't lock but take lock references as "reminders";-) removes the need. No requirement to repeat any functionality -- just make public functions which expose exactly the same (locking) functionality that's also needed (in non-locking ways because the lock is already acquired) from other functions, into "semi-empty shells" that perform locking then call such private functions, which do all the necessary work. The other functions in the class that need such functionality but want to do their own locking clearly can just call the private ones directly.
