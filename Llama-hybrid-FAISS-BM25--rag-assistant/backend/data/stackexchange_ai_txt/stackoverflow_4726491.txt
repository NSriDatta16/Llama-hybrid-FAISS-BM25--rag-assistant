[site]: stackoverflow
[post_id]: 4726491
[parent_id]: 4725463
[tags]: 
After reading OSGi and Equinox , I have better understanding of OSGi class loader. Class Lookup Algorithm Here, we assume that a bundle is trying to load some class C in package P. if P starts with "java." || P is boot delegated return parent.loadClass(C) if P is imported return exporter.loadClass(C) if P is exported by some required bundles for each exporter return exporter.loadClass(C) if found if C is found locally return C if C is found in a fragment return C if P is dynamically imported return exporter.loadClass(C) if buddy loading is enabled for this bundle return BuddyLoader.loadClass(C) throw a ClassNotFoundException Step 7 is not standard OSGi behavior. Equinox adds this step. Step 1 ensures that all java.* packages implicitly available to all bundles--they need not be explicitly imported. All other packages from JRE must, however, be explicitly imported. This implies that there is a matching exporter. The OSGi specification states that the System Bundle must export the additional packages from the JRE. The System Bundle is known as org.eclipse.osgi in Equinox. It maintains a set of profiles that lists the standard API packages available in common JRE class libraries such as J2SE1.4, J2SE1.5, and JCL Foundation. These profiles do not include implementation-specific packages such as com.sun.* and sun.*, as they are not standard and are not available in all JREs. Step 1 of the class loading algorithm mentions the notion of boot delegation. This is an override mechanism that identifies particular packages whose class loads should come from the parent class loader. This is useful for accesssing packages that are not java.* and are not otherwise exported by a bundle. To get access to such packages, you can either update the JRE profile or use the org.osgi.framework.bootdelegation property in config.ini to list the set of accessible package prefixes as follows: org.osgi.framework.bootdelegation=com.sun.*,sun.*
