[site]: stackoverflow
[post_id]: 171679
[parent_id]: 171596
[tags]: 
How about using boost any? Here's an example of what it would look like #include #include using boost::any_cast; typedef std::list many; void append_int(many & values, int value) { boost::any to_append = value; values.push_back(to_append); } void append_string(many & values, const std::string & value) { values.push_back(value); } void append_char_ptr(many & values, const char * value) { values.push_back(value); } void append_any(many & values, const boost::any & value) { values.push_back(value); } void append_nothing(many & values) { values.push_back(boost::any()); } Seems nice and elegant, plus you get well tested code and can treat your values as objects instead of pointers Note: These function names are informative, but you could use overriding to have a single interface.
