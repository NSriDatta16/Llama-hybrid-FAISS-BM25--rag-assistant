[site]: stackoverflow
[post_id]: 3802332
[parent_id]: 2798071
[tags]: 
I would expect the output: I would expect the input: int bar(int x) { return foo(x) * 100; } Your code actually looks strange for me. As a maintainer I would think that either foo actually has side effects or more likely rewrite it immediately to the above function. How does it work out in practice? If I mark such functions as pure/const, could it break anything (considering that the code is all correct)? If the code is all correct then no. But the chances that your code is correct are small. If your code is incorrect then this feature can mask out bugs: int foo(int x) { globalmutex.lock(); // complicated calculation code return -1; // more complicated calculation globalmutex.unlock(); return x; } Now given the bar from above: int main() { cout This terminates with __attribute__((const)) but deadlocks otherwise. It also highly depends on the implementation. For example: void f() { for(;;) { globalmutex.unlock(); cout Where the compiler should move the call foo(42) ? Is it allowed to optimize this code? Not in general! So unless the loop is really trivial you have no benefits of your feature. But if your loop is trivial you can easily optimize it yourself. EDIT: as Albert requested a less obvious situation, here it comes: F or example if you implement operator for an ostream, you use the ostream::sentry which locks the stream buffer. Suppose you call pure/const f after you released or before you locked it. Someone uses this operator cout and f also uses cout . According to you the compiler is free to put the invocation of f into the critical section. Deadlock occurs.
