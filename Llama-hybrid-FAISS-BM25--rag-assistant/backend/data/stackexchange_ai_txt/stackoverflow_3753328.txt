[site]: stackoverflow
[post_id]: 3753328
[parent_id]: 3753252
[tags]: 
UPDATED: As @Joshua Flanagan points out below, this is default SM behaviour. The following unit tests show that. The first tests uses the default behaviour. The second shows how you would get a unique instance if you wanted it: using System; using System.Collections.Generic; using NUnit.Framework; using StructureMap; using StructureMap.Pipeline; namespace SMTest { [TestFixture] public class TestSOQuestion { class Foo : IFoo { } interface IFoo { } private interface IBar { IFoo Foo { get; set; } } class Bar : IBar { public IFoo Foo { get; set; } public Bar(IFoo foo) { Foo = foo; } } class UsesFooAndBar { public IBar Bar { get; set; } public IFoo Foo { get; set; } public UsesFooAndBar(IFoo foo, IBar bar) { Foo = foo; Bar = bar; } } [Test] public void TestOtherAnswer() { IContainer container = new Container(x => { x.For ().Use (); x.For ().Use (); }); var usesFooAndBar = container.GetInstance (); Assert.AreSame(usesFooAndBar.Foo, usesFooAndBar.Bar.Foo); } [Test] public void TestNonDefaultBehaviour() { IContainer container = new Container(x => { x.For ().AlwaysUnique().Use (); x.For ().Use (); }); var usesFooAndBar = container.GetInstance (); Assert.AreNotSame(usesFooAndBar.Foo, usesFooAndBar.Bar.Foo); } } }
