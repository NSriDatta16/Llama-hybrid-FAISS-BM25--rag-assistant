[site]: stackoverflow
[post_id]: 1053841
[parent_id]: 1053705
[tags]: 
You wrote the following in a comment: I'm not sorting. Only finding the max and min of an interval. And the interval moves every 20ms It seems that you actually want a moving minimum and moving maximum . I believe that this can be done more efficiently than to re-search the entire interval each time, assuming that the interval moves only in one direction, and that there is significant overlap between subsequent intervals. One way would be to keep a special queue, where every new element copies its value to every element in the queue that is bigger (for the moving minimum), e.g.: (5 8 4 7 7 0 7 0 4 4 3 4 0 9 7 9 5 4 2 0) ; this is the array (4 4 4 4) ; the interval is 4 elements long, and initialized to the minimum ; of the first 4 elements (4 4 4 7) ; next step, note that the current minimum is always the first element (4 7 7 0) ; now something happens, as 0 is smaller than the value before (4 7 0 0) ; there are still smaller values ... (4 0 0 0) ; and still ... (0 0 0 0) ; done for this iteration (0 0 0 7) (0 0 0 0) ; the 0 again overwrites the fatties before (0 0 0 4) (0 0 4 4) (0 3 3 3) ; the 3 is smaller than the 4s before, ; note that overwriting can be cut short as soon as a ; value not bigger than the new is found (3 3 3 4) (0 0 0 0) ; and so on... If you move by more than 1 element each time, you can first calculate the minimum of all new values and use that for the back-overwriting. Worst case for this algorithm is when the array is sorted descendingly, then it is O(nm), where m is the interval length and n the array length. Best case is when it is sorted descendingly, then it's O(n). For the average case, I conject O(n log(m)).
