[site]: stackoverflow
[post_id]: 1013331
[parent_id]: 
[tags]: 
powershell / runspace in a thread

I'm running the following code : RunspaceConfiguration config = RunspaceConfiguration.Create(); PSSnapInException warning; config.AddPSSnapIn("Microsoft.Exchange.Management.PowerShell.Admin", out warning); if (warning != null) throw warning; Runspace thisRunspace = RunspaceFactory.CreateRunspace(config); thisRunspace.Open(); string alias = usr.AD.CN.Replace(' ', '.'); string letter = usr.AD.CN.Substring(0, 1); string email = alias + "@" + (!usr.Mdph ? Constantes.AD_DOMAIN : Constantes.MDPH_DOMAIN) + "." + Constantes.AD_LANG; string db = "CN=IS-" + letter + ",CN=SG-" + letter + ",CN=InformationStore,CN=" + ((char)letter.ToCharArray()[0] The code is running in a thread created that way : t.WorkThread = new Thread(cu.CreerUser); t.WorkThread.Start(); If I run the code directly (not through a thread), it's working. When in a thread it throws the following exception : ObjectDisposedException "The safe handle has been closed." (Translated from french) I then replaced "Open" wirh "OpenAsync" which helped not getting the previous exception. But when on Invoke I get the following exception : InvalidRunspaceStateException "Unable to call the pipeline because its state of execution is not Opened. Its current state is Opening." (Also translated from french) I'm clueless... Any help welcome !!! Thanks !!! With Open: à Microsoft.Win32.Win32Native.GetTokenInformation(SafeTokenHandle TokenHandle, UInt32 TokenInformationClass, SafeLocalAllocHandle TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength) à System.Security.Principal.WindowsIdentity.GetTokenInformation(SafeTokenHandle tokenHandle, TokenInformationClass tokenInformationClass, UInt32& dwLength) à System.Security.Principal.WindowsIdentity.get_User() à System.Security.Principal.WindowsIdentity.GetName() à System.Security.Principal.WindowsIdentity.get_Name() à System.Management.Automation.MshLog.GetLogContext(ExecutionContext executionContext, InvocationInfo invocationInfo, Severity severity) à System.Management.Automation.MshLog.GetLogContext(ExecutionContext executionContext, InvocationInfo invocationInfo) à System.Management.Automation.MshLog.LogEngineLifecycleEvent(ExecutionContext executionContext, EngineState engineState, InvocationInfo invocationInfo) à System.Management.Automation.MshLog.LogEngineLifecycleEvent(ExecutionContext executionContext, EngineState engineState) à System.Management.Automation.Runspaces.LocalRunspace.OpenHelper() à System.Management.Automation.Runspaces.RunspaceBase.CoreOpen(Boolean syncCall) à System.Management.Automation.Runspaces.RunspaceBase.Open() à Cg62.ComposantsCommuns.ActiveDirectory.Exchange.BoitesAuxLettres.CreationBAL(User usr, IList`1 log) dans D:\Applications\Commun\Sources .Net\COMIAD\COMIAD\Exchange.cs:ligne 141 à Cg62.ComposantsCommuns.ActiveDirectory.ComptesUtilisateurs.CreationUser.CreerUser() dans D:\Applications\Commun\Sources .Net\COMIAD\COMIAD\ComptesUtilisateurs.cs:ligne 199 à System.Threading.ThreadHelper.ThreadStart_Context(Object state) à System.Threading.ExecutionContext.runTryCode(Object userData) à System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, Object userData) à System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) à System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) à System.Threading.ThreadHelper.ThreadStart() With OpenAsync: à System.Management.Automation.Runspaces.RunspaceBase.AddToRunningPipelineList(PipelineBase pipeline) à System.Management.Automation.Runspaces.RunspaceBase.DoConcurrentCheckAndAddToRunningPipelines(PipelineBase pipeline, Boolean syncCall) à System.Management.Automation.Runspaces.PipelineBase.CoreInvoke(IEnumerable input, Boolean syncCall) à System.Management.Automation.Runspaces.PipelineBase.Invoke(IEnumerable input) à System.Management.Automation.Runspaces.Pipeline.Invoke() à Cg62.ComposantsCommuns.ActiveDirectory.Exchange.BoitesAuxLettres.CreationBAL(User usr, IList`1 log) dans D:\Applications\Commun\Sources .Net\COMIAD\COMIAD\Exchange.cs:ligne 149 à Cg62.ComposantsCommuns.ActiveDirectory.ComptesUtilisateurs.CreationUser.CreerUser() dans D:\Applications\Commun\Sources .Net\COMIAD\COMIAD\ComptesUtilisateurs.cs:ligne 199 à System.Threading.ThreadHelper.ThreadStart_Context(Object state) à System.Threading.ExecutionContext.runTryCode(Object userData) à System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, Object userData) à System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state) à System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) à System.Threading.ThreadHelper.ThreadStart() Sorry for the late reply... I had a lot going on Upgraded to Powershell 2.0 and I got past the Open error but now I have the following on the Invoke. I changed my command to : Enable-Mailbox -Identity "Aagtest Abe" -Alias Aagtest.Abe -PrimarySmtpAddress smtp.address@domain.com -DisplayName "Aagtest Abe" -Database "myDb" -DomainController adc.domain.int The command works fine from powershell. I get the following exception CmdletInvocationException : "Une exception a été levée par l'initialiseur de type pour ' '." No idea on how to translate that... StackTrace : à Microsoft.Exchange.Data.Directory.DSAccessTopologyProvider..ctor(String machineName) à Microsoft.Exchange.Data.Directory.DSAccessTopologyProvider..ctor() à Microsoft.Exchange.Data.Directory.DirectoryServicesTopologyProvider.DiscoverConfigDC() à Microsoft.Exchange.Data.Directory.DirectoryServicesTopologyProvider..ctor() à Microsoft.Exchange.Data.Directory.TopologyProvider.InitializeInstance() à Microsoft.Exchange.Data.Directory.TopologyProvider.GetInstance() à Microsoft.Exchange.Data.Directory.ADSession.GetConnection(String preferredServer, Boolean isWriteOperation, Boolean isNotifyOperation, ADObjectId& rootId) à Microsoft.Exchange.Data.Directory.ADSession.GetReadConnection(String preferredServer, ADObjectId& rootId) à Microsoft.Exchange.Data.Directory.ADSession.IsReadConnectionAvailable() à Microsoft.Exchange.Configuration.Tasks.RecipientObjectActionTask`2.InternalBeginProcessing() à Microsoft.Exchange.Management.RecipientTasks.EnableMailbox.InternalBeginProcessing() à Microsoft.Exchange.Configuration.Tasks.Task.BeginProcessing() à System.Management.Automation.Cmdlet.DoBeginProcessing() à System.Management.Automation.CommandProcessorBase.DoBegin()
