[site]: stackoverflow
[post_id]: 3854178
[parent_id]: 3854047
[tags]: 
Your definition has two problems: Missing an * Will attempt to divide by zero if x + y == 0.0 (which covers a possibly frequent case x == y == 0.0 ) Try this instead: define approx_Equal(x, y, tolerance=0.001): return abs(x-y) Edit: Note the use of instead of ... needed to make the x == y == 0.0 case work properly. I wouldn't try to override == Edit 2: You wrote: there's no way in the world anyone would ever want to use the default == for floats.. Why is it even in the language??? No way? Suppose you have a function that returns a float, and you have a brainwave about an algorithm that would produce the same answers faster and/or more elegantly; how do you test it?
