[site]: stackoverflow
[post_id]: 501807
[parent_id]: 498142
[tags]: 
The way I have done this in a few projects is to use two copies of the table in different schemas. So something like: CREATE SCHEMA fake WITH AUTHORIZATION dbo; CREATE SCHEMA standby WITH AUTHORIZATION dbo; GO CREATE TABLE dbo.mySummary( ); CREATE TABLE fake.mySummary( ); GO Now create a stored procedure that truncates and re-populates the fake table, then in a transaction move the objects between schemas. CREATE PROCEDURE dbo.SwapInSummary AS BEGIN SET NOCOUNT ON; TRUNCATE TABLE fake.mySummary; INSERT fake.mySummary( ) SELECT ; BEGIN TRANSACTION; ALTER SCHEMA standby TRANSFER dbo.mySummary; ALTER SCHEMA dbo TRANSFER fake.mySummary; ALTER SCHEMA fake TRANSFER standby.mySummary; COMMIT TRANSACTION; END GO This is probably about the shortest amount of time you can make users wait for the new data to be refreshed and without disrupting them in the middle of a read. (There are many issues associated with NOLOCK that make it a less desirable alternative, though admittedly, it is easy to code.) For brevity/clarity I've left out error handling etc., and I should also point out that if you use scripts to synchronize your databases, make sure you name constraints, indexes etc. the same on both tables, otherwise you will be out of sync half of the time. At the end of the procedure you can TRUNCATE the new fake.MySummary table, but if you have the space, I like to leave the data there so I can always compare to the previous version. Before SQL Server 2005 I used sp_rename inside the transaction to accomplish exactly the same thing, however since I do this in a job, I was glad about switching to schemas, because when I did, the non-suppress-able warning from sp_rename stopped filling up my SQL Server Agent history logs.
