[site]: stackoverflow
[post_id]: 551847
[parent_id]: 357076
[tags]: 
Update: [Verified and is not working, ignore the edit] According to @donovan, modern days WPF supports this natively, through setting ShowInTaskbar="False" and Visibility="Hidden" in the XAML. (I haven't tested this yet, but nevertheless decided to bump the comment visibility) Original answer: There are two ways of hiding a window from the task switcher in Win32 API: to add the WS_EX_TOOLWINDOW extended window style - that's the right approach. to make it a child window of another window. Unfortunately, WPF does not support as flexible control over the window style as Win32, thus a window with WindowStyle=ToolWindow ends up with the default WS_CAPTION and WS_SYSMENU styles, which causes it to have a caption and a close button. On the other hand, you can remove these two styles by setting WindowStyle=None , however that will not set the WS_EX_TOOLWINDOW extended style and the window will not be hidden from the task switcher. To have a WPF window with WindowStyle=None that is also hidden from the task switcher, one can either of two ways: go with the sample code above and make the window a child window of a small hidden tool window modify the window style to also include the WS_EX_TOOLWINDOW extended style. I personally prefer the second approach. Then again, I do some advanced stuff like extending the glass in the client area and enabling WPF drawing in the caption anyway, so a little bit of interop is not a big problem. Here's the sample code for the Win32 interop solution approach. First, the XAML part: Nothing too fancy here, we just declare a window with WindowStyle=None and ShowInTaskbar=False . We also add a handler to the Loaded event where we will modify the extended window style. We can't do that work in the constructor, as there's no window handle at that point yet. The event handler itself is very simple: private void Window_Loaded(object sender, RoutedEventArgs e) { WindowInteropHelper wndHelper = new WindowInteropHelper(this); int exStyle = (int)GetWindowLong(wndHelper.Handle, (int)GetWindowLongFields.GWL_EXSTYLE); exStyle |= (int)ExtendedWindowStyles.WS_EX_TOOLWINDOW; SetWindowLong(wndHelper.Handle, (int)GetWindowLongFields.GWL_EXSTYLE, (IntPtr)exStyle); } And the Win32 interop declarations. I've removed all unnecessary styles from the enums, just to keep the sample code here small. Also, unfortunately the SetWindowLongPtr entry point is not found in user32.dll on Windows XP, hence the trick with routing the call through the SetWindowLong instead. #region Window styles [Flags] public enum ExtendedWindowStyles { // ... WS_EX_TOOLWINDOW = 0x00000080, // ... } public enum GetWindowLongFields { // ... GWL_EXSTYLE = (-20), // ... } [DllImport("user32.dll")] public static extern IntPtr GetWindowLong(IntPtr hWnd, int nIndex); public static IntPtr SetWindowLong(IntPtr hWnd, int nIndex, IntPtr dwNewLong) { int error = 0; IntPtr result = IntPtr.Zero; // Win32 SetWindowLong doesn't clear error on success SetLastError(0); if (IntPtr.Size == 4) { // use SetWindowLong Int32 tempResult = IntSetWindowLong(hWnd, nIndex, IntPtrToInt32(dwNewLong)); error = Marshal.GetLastWin32Error(); result = new IntPtr(tempResult); } else { // use SetWindowLongPtr result = IntSetWindowLongPtr(hWnd, nIndex, dwNewLong); error = Marshal.GetLastWin32Error(); } if ((result == IntPtr.Zero) && (error != 0)) { throw new System.ComponentModel.Win32Exception(error); } return result; } [DllImport("user32.dll", EntryPoint = "SetWindowLongPtr", SetLastError = true)] private static extern IntPtr IntSetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong); [DllImport("user32.dll", EntryPoint = "SetWindowLong", SetLastError = true)] private static extern Int32 IntSetWindowLong(IntPtr hWnd, int nIndex, Int32 dwNewLong); private static int IntPtrToInt32(IntPtr intPtr) { return unchecked((int)intPtr.ToInt64()); } [DllImport("kernel32.dll", EntryPoint = "SetLastError")] public static extern void SetLastError(int dwErrorCode); #endregion
