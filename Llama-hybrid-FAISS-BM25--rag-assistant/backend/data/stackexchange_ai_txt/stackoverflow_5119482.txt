[site]: stackoverflow
[post_id]: 5119482
[parent_id]: 2211951
[tags]: 
OSX Allows you to use sockets via the (CF)RunLoop. Or getting callbacks from the runloop. That is the most elegant way I have found to use async IO on mac. You can use your existing socket and do a CFSocketCreateWithNative. And register callbacks on your runloop. Here is a small snippet of code that shows how it can be setup, incomplete since I have cut down on a source file... // This will setup a readCallback void SocketClass::setupCFCallback() { CFSocketContext context = { 0, this, NULL, NULL, NULL }; if (CFSocketRef macMulticastSocketRef = CFSocketCreateWithNative(NULL, socketHandle_, kCFSocketReadCallBack,readCallBack, &context)) { if (CFRunLoopSourceRef macRunLoopSrc = CFSocketCreateRunLoopSource(NULL, macMulticastSocketRef, 0)) { if (!CFRunLoopContainsSource(CFRunLoopGetCurrent(), macRunLoopSrc, kCFRunLoopDefaultMode)) { CFRunLoopAddSource(CFRunLoopGetCurrent(), macRunLoopSrc, kCFRunLoopDefaultMode); macRunLoopSrc_ = macRunLoopSrc; } else CFRelease(macRunLoopSrc); } else CFSocketInvalidate(macMulticastSocketRef); CFRelease(macMulticastSocketRef); } } void SocketClass::readCallBack(CFSocketRef inref, CFSocketCallBackType type,CFDataRef , const void *, void *info) { if (SocketClass* socket_ptr = reinterpret_cast (info)) socket_ptr->receive(); // do stuff with your socket }
