[site]: stackoverflow
[post_id]: 4292976
[parent_id]: 4292740
[tags]: 
Oded is right , it doesn't seem (to him or me) to make any sense to try and make this method generic. You are trying to genericize a method whose functionality is actually specific to a few types. Now, that said, it seems the bulk of the function is independent of this property you want to access. So why not split it into two parts: that which can be genericized, and that which can't: Something like this: void BindElements (IEnumerable dataObjects, Func selector) { Paragraph para = new Paragraph(); foreach (T item in dataObjects) { // Notice: by delegating the only type-specific aspect of this method // (the property) to (fittingly enough) a delegate, we are able to // package MOST of the code in a reusable form. var property = selector(item); InlineUIContainer uiContainer = this.CreateElementContainer(property) para.Inlines.Add(uiContainer); } FlowDocument flowDoc = new FlowDocument(para); this.Document = flowDoc; } Then your overloads dealing with specific types, e.g., IPerson , can reuse this code (which I suspect may be what you were after all alongâ€”code reuse): public void BindPeople(IEnumerable people) { BindElements(people, p => p.FirstName); } ...then for IOrder : public void BindOrders(IEnumerable orders) { BindElements(orders, o => p.OrderNumber); } ...and so on.
