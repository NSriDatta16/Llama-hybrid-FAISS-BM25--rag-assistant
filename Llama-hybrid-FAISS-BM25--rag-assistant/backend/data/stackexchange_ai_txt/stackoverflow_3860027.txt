[site]: stackoverflow
[post_id]: 3860027
[parent_id]: 3859946
[tags]: 
Remove the Pack property from the [DllImport] declaration, it is wrong. You are not using a #pragma pack directive in your C code, the default value for Pack is appropriate. If it would have been in effect then your C code would have reported 16. You are seeing 24 because there's 4 bytes of padding to align the double and 4 bytes of padding at the end of the structure to make the double align when the structure is used in an array. 4 + 4 + 8 + 4 + 4 = 24. The packing in effect is 8, the default. You can make it more efficient by swapping Value2 and Value3 to get a struct of 16 bytes, no padding necessary. In case it matters. That's what the JIT compiler does. The next problem is tougher, the P/Invoke marshaller will marshal the embedded array as a SAFEARRAY. You can solve that on the unmanaged side by using this code: #include "stdafx.h" #include #include struct PurchaseOrder { char* Value1; double Value2; LPSAFEARRAY Value3; int fence; }; extern "C" __declspec(dllexport) int __stdcall MonteCarloPrint(PurchaseOrder *hostPurchaseOrders, int length) { printf("\nSize of PurchaseOrder: %d",sizeof(PurchaseOrder)); for (int i = 0; i Value1); printf("\nValue2: %f",(hostPurchaseOrders+i)->Value2); double* arrayPtr; if (S_OK == SafeArrayAccessData((hostPurchaseOrders+i)->Value3, (void**)&arrayPtr)) { printf("\nValue3[0]: %f", arrayPtr[0]); printf("\nValue3[1]: %f", arrayPtr[1]); } } return 0; } I wrote the code using the C++ compiler, you may have to tweak.
