[site]: stackoverflow
[post_id]: 2775381
[parent_id]: 2771880
[tags]: 
Unit-testing wise: Am I basically doing this the right way, or have I got the wrong idea? You've missed the boat. I don't quite get how the test becomes before the code if you don't know what structures and how you're storing data This is the point I think you need to return to, if you want the ideas to make sense. First point: data structures and storage derive from what you need the code to do, not the other way around. In more detail, if you are starting from scratch there are any number of structure/storage implementations you can use; indeed, you should be able to swap between them without needing to change your tests. Second point: In most cases, you consume your code more often than you produce it. You write it once, but you (and your colleagues) call it many times. Therefore, the convenience of calling the code ought to get a higher priority than it would if you were writing your solution purely from the inside out. So when you find yourself writing a test, and discovering that the client implementation is ugly/clumsy/unsuitable, it sets off a warning for you before you've even started to implement anything. Likewise, if you find yourself writing a lot of setup code in your tests, it tells you that you haven't really got your concerns well separated. When you find yourself saying "wow, that test was easy to write", then you've probably got an interface that's easy to use. It's very hard to reach this when you are using implementation oriented examples (like writing a test for a container). What you need is a well bounded toy problem, independent of implementation. For a trivial example, you might consider an authentication manager - pass in an identifier and a secret, and find out whether the secret matches the identifier. So you should be able to write three quick tests right off the top: verify that the correct secret allows access, verify that an incorrect secret forbids access, verify that when a secret is changed, only the new version allows access. So you perhaps write some simple tests with usernames and passwords. And as you do so, you realize that secrets shouldn't be limited to strings, but that you should be able to make a secret from anything serializable, and that maybe access isn't universal, but restricted (does that concern the authentication manager? maybe not) and oh you'll want to demonstrate that the secrets are kept safely.... You can, of course, take this same approach for containers. But I think you'll find it easier to "get it" if you start from a user/business problem, rather than an implementation problem. Unit tests that verify a specific implementation ("Do we have a fence post error here?") have value. The process for creating those is much more like "guess a bug, write a test to check for the bug, react if the test fails". These tests tend not to contribute to your design, though - you're much more likely to be cloning a code block and changing some inputs. It's often the case, though, that when unit tests follow implementation, they are often difficult to write and have large startup costs ("why do I need to load three libraries and start a remote web server to test a fencepost error in my for loop?"). Recommended Reading Freeman/Pryce, Growing Object-Oriented Software, Guided By Tests
