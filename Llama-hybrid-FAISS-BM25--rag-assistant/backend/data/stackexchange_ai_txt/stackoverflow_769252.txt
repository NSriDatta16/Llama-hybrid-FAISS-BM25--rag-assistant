[site]: stackoverflow
[post_id]: 769252
[parent_id]: 768994
[tags]: 
Are you sure you need to?! If you need to add new code when adding a new disease anyways, there is little point in making the "constants" to be data driven static (non-final) globals. (It will just complicate things.) If you are worried about a mismatch between the database and the code, you can verify that database and the constants match when starting up the application. You have the diseases defined in a table and are using some kind of referential integrity right? If you DO think You need a data driven approach, you probably should not need any fields for "known diseases" at all, as the code shouldn't really depend on those. In that case each disease should be a proper object with a identity and other properties. If you need special handling for certain types you probably should go back to an enum again... If you instead have many diseases (that might be added dynamically) and only a few types - several diseases are handled in the same way by the same code; add a type in the disease-table and in the code as an enum (or constant) for the type-of-disease and use that to run different logic. If each disease actually have a lot of complexity, it might be a good idea to try to write one class for each disease. (You can then do a proper O/R thing with sub-classes and all...) The interface enum cludge is not neccesary since java 5, as you can get both enums and do a static import if you need to. (And when using enum, validating the database is simpler as you get an enumeration for free.) Your fields should probably be located in a class called Disease or SickDude instead of a gigantic global constants class. (Like, for instance, the fields in Calendar). Possibly as an inner public enum in the class where they "belong."
