[site]: crossvalidated
[post_id]: 6075
[parent_id]: 3779
[tags]: 
It is very hard to draw a rack that does not contain any valid word in Scrabble and its variants. Below is an R program I wrote to estimate the probability that the initial 7-tile rack does not contain a valid word. It uses a monte carlo approach and the Words With Friends lexicon (I couldn’t find the official Scrabble lexicon in an easy format). Each trial consists of drawing a 7-tile rack, and then checking if the rack contains a valid word. Minimal words You don’t have to scan the entire lexicon to check if the rack contains a valid word. You just need to scan a minimal lexicon consisting of minimal words. A word is minimal if it contains no other word as a subset. For example 'em’ is a minimal word; 'empty’ is not. The point of this is that if a rack contains word x then it must also contain any subset of x . In other words: a rack contains no words iff it contains no minimal words. Luckily, most words in the lexicon are not minimal, so they can be eliminated. You can also merge permutation equivalent words. I was able to reduce the Words With Friends lexicon from 172,820 to 201 minimal words. Wildcards can be easily handled by treating racks and words as distributions over the letters. We check if a rack contains a word by subtracting one distribution from the other. This gives us the number of each letter missing from the rack. If the sum of those number is $\leq$ the number of wildcards, then the word is in the rack. The only problem with the monte carlo approach is that the event that we are interested in is very rare. So it should take many, many trials to get an estimate with a small enough standard error. I ran my program (pasted at the bottom) with $N=100,000$ trials and got an estimated probability of 0.004 that the initial rack does not contain a valid word . The estimated standard error of that estimate is 0.0002. It took just a couple minutes to run on my Mac Pro, including downloading the lexicon. I’d be interested in seeing if someone can come up with an efficient exact algorithm. A naive approach based on inclusion-exclusion seems like it could involve a combinatorial explosion. Inclusion-exclusion I think this is a bad solution, but here is an incomplete sketch anyway. In principle you can write a program to do the calculation, but the specification would be tortuous. The probability we wish to calculate is $$ P(k\text{-tile rack does not contain a word}) = 1 - P(k\text{-tile rack contains a word}) . $$ The event inside the probability on the right side is a union of events: $$ P(k\text{-tile rack contains a word}) = P\left(\cup_{x \in M} \{ k\text{-tile rack contains }x \} \right), $$ where $M$ is a minimal lexicon. We can expand it using the inclusion-exclusion formula. It involves considering all possible intersections of the events above. Let $\mathcal{P}(M)$ denote the power set of $M$, i.e. the set of all possible subsets of $M$. Then $$ \begin{align} &P(k\text{-tile rack contains a word}) \\ &= P\left(\cup_{x \in M} \{ k\text{-tile rack contains }x \} \right) \\ &= \sum_{j=1}^{|M|} (-1)^{j-1} \sum_{S \in \mathcal{P}(M) : |S| = j} P\left( \cap_{x \in S} \{ k\text{-tile rack contains }x \} \right) \end{align} $$ The last thing to specify is how to calculate the probability on the last line above. It involves a multivariate hypergeometric. $$\cap_{x \in S} \{ k\text{-tile rack contains }x \}$$ is the event that the rack contains every word in $S$. This is a pain to deal with because of wildcards. We'll have to consider, by conditioning, each of the following cases: the rack contains no wildcards, the rack contains 1 wildcard, the rack contains 2 wildcards, ... Then $$ \begin{align} &P\left( \cap_{x \in S} \{ k\text{-tile rack contains }x \} \right) \\ &= \sum_{w=0}^{n_{*}} P\left( \cap_{x \in S} \{ k\text{-tile rack contains }x \} | k\text{-tile rack contains } w \text{ wildcards} \right) \\ &\quad \times P(k\text{-tile rack contains } w \text{ wildcards}) . \end{align} $$ I'm going to stop here, because the expansions are tortuous to write out and not at all enlightening. It's easier to write a computer program to do it. But by now you should see that the inclusion-exclusion approach is intractable. It involves $2^{|M|}$ terms, each of which is also very complicated. For the lexicon I considered above $2^{|M|} \approx 3.2 \times 10^{60}$. Scanning all possible racks I think this is computationally easier, because there are fewer possible racks than possible subsets of minimal words. We successively reduce the set of possible $k$-tile racks until we get the set of racks which contain no words. For Scrabble (or Words With Friends) the number of possible 7-tile racks is in the tens of billions. Counting the number of those that do not contain a possible word should be doable with a few dozen lines of R code. But I think you should be able to do better than just enumerating all possible racks. For instance, 'aa' is a minimal word. That immediately eliminates all racks containing more than one 'a’. You can repeat with other words. Memory shouldn’t be an issue for modern computers. A 7-tile Scrabble rack requires fewer than 7 bytes of storage. At worst we would use a few gigabytes to store all possible racks, but I don’t think that’s a good idea either. Someone may want to think more about this. Monte Carlo R program # # scrabble.R # # Created by Vincent Vu on 2011-01-07. # Copyright 2011 Vincent Vu. All rights reserved. # # The Words With Friends lexicon # http://code.google.com/p/dotnetperls-controls/downloads/detail?name=enable1.txt&can=2&q= url k that contain a k-letter word for(w in k.letter.words) { # Create a regexp pattern makepattern k that are not minimal eliminate k min.dict
