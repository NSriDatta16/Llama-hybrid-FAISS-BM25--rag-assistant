[site]: stackoverflow
[post_id]: 4246850
[parent_id]: 4245459
[tags]: 
If you start yourself, the process which termination you want wait for, for example with respect of the CreateProcess, the waiting for the process end is very simple WaitForSingleObject(pi.hProcess, INFINITE); If the process, which termination you want wait for, is started before you should find the process id dwProcessId of the process and then do following HANDLE hProcess = OpenProcess (SYNCHRONIZE, FALSE, dwProcessId); WaitForSingleObject(hProcess, INFINITE); The searching of the process id can be implemented in different ways depend on which information you know about the process and the knowledge how many instances of the process can be running simultaneously. For example if you know the filename of the process which is currently running you can use EnumProcesses , OpenProcess and GetProcessImageFileName . Here is the corresponding code in a simplified form: #include #include #include #include #include #pragma comment (lib, "Psapi.lib") #pragma comment (lib, "shlwapi.lib") int _tmain (int argc, LPCTSTR argv[]) { DWORD arProcessIds[1024], cbNeeded, i, dwStatus; HANDLE hProcess = NULL; LPCTSTR pszProcessName = NULL; if (argc != 2) { _tprintf (TEXT("USAGE:\n") TEXT(" \"%s\" ExeName\n\n") TEXT("Examples:\n") TEXT(" \"%s\" TaskMgr.exe\n"), argv[0], argv[0]); return 1; // error } pszProcessName = argv[1]; if (!EnumProcesses (arProcessIds, sizeof(arProcessIds), &cbNeeded)) { // here shold be allocated array dynamically return 1; // error } for (i = 0; i 0 ) { LPCTSTR pszFileName = PathFindFileName (szFileName); //_tprintf(TEXT("Process: %s\n"),szFileName); if (StrCmpI(pszFileName, pszProcessName) == 0) { break; } } CloseHandle (hProcess); hProcess = NULL; } } } //hProcess = OpenProcess (SYNCHRONIZE, FALSE, dwProcessId); if (hProcess == NULL) { _tprintf(TEXT("The process \"%s\" is not found.\n"), pszProcessName); return 1; } _tprintf(TEXT("Start waiting for the end of the process %s\n"), pszProcessName); WaitForSingleObject(hProcess, INFINITE); _tprintf(TEXT("The process is terminated")); CloseHandle (hProcess); return 0; }
