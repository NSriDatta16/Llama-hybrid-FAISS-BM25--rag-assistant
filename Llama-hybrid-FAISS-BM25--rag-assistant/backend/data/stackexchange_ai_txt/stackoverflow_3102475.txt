[site]: stackoverflow
[post_id]: 3102475
[parent_id]: 3101530
[tags]: 
Jon is, of course correct. For some additional background I refer you to the C# specification, which states: The actual lifetime of a local variable is implementation-dependent. For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block. Using this analysis, the compiler could generate code that results in the variableâ€™s storage having a shorter lifetime than its containing block. and, also important: The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable. Notice here that we are drawing a distinction between the lifetime of the object being referenced -- that is, when the garbage collector is allowed to step in -- and the lifetime of the variable holding the reference . As Jon points out, the lifetime of both the variable and the object it refers to can be aggressively shortened by the compiler and the garbage collector both if we can prove that doing so does not release a reference that someone could still be holding on to.
