[site]: stackoverflow
[post_id]: 1090393
[parent_id]: 1085531
[tags]: 
Best practice in MVC is to have your Models be stateless, the controller gets to handle state. If you want the information to get to your models, you need to pass it from the controller. Using a creation hook here isn't really the right way to go, because you are trying to add stateful data, and those hooks are really for stateless behavior. You can pass the info in from the controller: Foo.new(params[:foo].merge {:creator_id => current_user.id}) Or you can create methods on User to handle these operations: class User def create_foo(params) Foo.new(params.merge! {:creator_id => self.id}) end end If you find yourself writing a lot of permissions code in the controller, I'd go with option 2, since it will let you refactor that code to the model. Otherwise option 1 is cleaner. Omar points out that it's trickier to automate, but it can still be done. Here's one way, using the create_something instance method on user: def method_missing(method_sym, *arguments, &block) meth = method_sym.to_s if meth[0..6] == "create_" obj = meth[7..-1].classify.constantize.new(*arguments) obj.creator_id = self.id else super end end You could also override the constructor to require user_ids on construction, or create a method inside ApplicationController that wraps new. There's probably a more elegant way to do things, but I definitely don't like trying to read state from inside Model code, it breaks MVC encapsulation. I much prefer to pass it in explicitly, one way or another.
