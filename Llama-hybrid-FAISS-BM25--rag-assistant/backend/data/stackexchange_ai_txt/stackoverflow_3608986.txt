[site]: stackoverflow
[post_id]: 3608986
[parent_id]: 3606528
[tags]: 
That's because use Module LIST; is equivalent to BEGIN { require Module; Module->import( LIST ); } (see perldoc -f use ) Particularly, require Module; can be implemented with the following bit of code (from perldoc -f require ): sub require { my ($filename) = @_; if (exists $INC{$filename}) { return 1 if $INC{$filename}; die "Compilation failed in require"; } my ($realfilename,$result); ITER: { foreach $prefix (@INC) { $realfilename = "$prefix/$filename"; if (-f $realfilename) { $INC{$filename} = $realfilename; $result = do $realfilename; ## HERE last ITER; } } die "Can't find $filename in \@INC"; } if ($@) { $INC{$filename} = undef; die $@; } elsif (!$result) { ## AND HERE delete $INC{$filename}; die "$filename did not return true value"; } else { return $result; } } See that do $realfilename ? Look at perldoc -f do , and you'll see that it's the equivalent, pretty much, of eval system("cat $realfilename") , which basically means slurp the file in, and eval it. Looking at perldoc -f eval yields: "In both forms, the value returned is the value of the last expression evaluated inside the mini-program ". That is, the last statement in the file. It's worth to mention that if the last "statement" is a subroutine declaration, that does not constitute a true value: $ perl -le'$r = eval "sub a {1}"; print $r ? "true" : "false"' false Whereas a 1; after it does: $ perl -le'$r = eval "sub a {1} 1"; print $r ? "true" : "false"' true Looking again at the sub require above, and with the knowledge of what require and do does, the $result that the do $realfilename returns is indeed the last statement eval ed from the file, which is indeed the last statement in the file. If such last statement isn't a true value, the ## AND HERE elsif() I highlighted would be called, and the require would die as the module does not return a true value. The use Module would also die, as it's doing a require behind the scenes. Long story short, it doesn't matter what you end the file with, as long as it's a value that is understood as being true by perl. Samples on the wild (CPAN) include 1; , although some these days rather end their files in 1 (no missing semicolon), and others just weirdly use stuff like '0 but true'; or 'supercalifragilisticexpiralidous'; , all of which are parsed as "truish" values by Perl.
