[site]: stackoverflow
[post_id]: 4309923
[parent_id]: 4235013
[tags]: 
Trick question! The best way is to use the STL, and advantage yourself of the fact that the sorted associative container ADT, of which set is an implementation, demands insertion of sorted ranges have amortized linear time. Any passable set of core data structures for any language should offer a similar guarantee. For a real answer, see the quite clever solutions others have provided. What's that? I should offer something useful? Hum... How about this? The smallest possible meaningful tree in a balanced binary tree is 3 nodes. A parent, and two children. The very first instance of such a tree is the first three elements. Child-parent-Child. Let's now imagine this as a single node. Okay, well, we no longer have a tree. But we know that the shape we want is Child-parent-Child. Done for a moment with our imaginings, we want to keep a pointer to the parent in that initial triumvirate. But it's singly linked! We'll want to have four pointers, which I'll call A, B, C, and D. So, we move A to 1, set B equal to A and advance it one. Set C equal to B, and advance it two. The node under B already points to its right-child-to-be. We build our initial tree. We leave B at the parent of Tree one. C is sitting at the node that will have our two minimal trees as children. Set A equal to C, and advance it one. Set D equal to A, and advance it one. We can now build our next minimal tree. D points to the root of that tree, B points to the root of the other, and C points to the... the new root from which we will hang our two minimal trees. How about some pictures? [A][B][-][C] With our image of a minimal tree as a node... [B = Tree][C][A][D][-] And then [Tree A][C][Tree B] Except we have a problem. The node two after D is our next root. [B = Tree A][C][A][D][-][Roooooot?!] It would be a lot easier on us if we could simply maintain a pointer to it instead of to it and C. Turns out, since we know it will point to C, we can go ahead and start constructing the node in the binary tree that will hold it, and as part of this we can enter C into it as a left-node. How can we do this elegantly? Set the pointer of the Node under C to the node Under B. It's cheating in every sense of the word, but by using this trick, we free up B. Alternatively, you can be sane, and actually start building out the node structure. After all, you really can't reuse the nodes from the SLL, they're probably POD structs. So now... [TreeA] [TreeB][B] And... Wait a sec. We can use this same trick to free up C, if we just let ourselves think of it as a single node instead of a tree. Because after all, it really is just a single node. [TreeC] We can further generalize our tricks. [TreeC] [TreeE][A] [TreeC] [TreeF][A] [TreeG] We are missing a critical step! [TreeG] ([TreeJ] ([TreeK] Becomes : [TreeG] [TreeL->([TreeK] [TreeL->([TreeK] [TreeM])][B] [TreeG] [TreeL->[TreeN]][B] [TreeG] [TreeO][B] [TreeP] Obviously, the algorithm can be cleaned up considerably, but I thought it would be interesting to demonstrate how one can optimize as you go by iteratively designing your algorithm. I think this kind of process is what a good employer should be looking for more than anything. The trick, basically, is that each time we reach the next midpoint, which we know is a parent-to-be, we know that its left subtree is already finished. The other trick is that we are done with a node once it has two children and something pointing to it, even if all of the sub-trees aren't finished. Using this, we can get what I am pretty sure is a linear time solution, as each element is touched only 4 times at most. The problem is that this relies on being given a list that will form a truly balanced binary search tree. There are, in other words, some hidden constraints that may make this solution either much harder to apply, or impossible. For example, if you have an odd number of elements, or if there are a lot of non-unique values, this starts to produce a fairly silly tree. Considerations: Render the element unique. Insert a dummy element at the end if the number of nodes is odd. Sing longingly for a more naive implementation. Use a deque to keep the roots of completed subtrees and the midpoints in, instead of mucking around with my second trick.
