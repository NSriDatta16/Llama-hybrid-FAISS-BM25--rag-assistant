[site]: stackoverflow
[post_id]: 764408
[parent_id]: 759288
[tags]: 
I'm afraid the short answer is that you can't do this using the FileField or ImageField classes; they just store a file path and have no real concept of the file's actual data. The long answer, however, is that anything is possible if you leverage the Django API for writing your own custom model fields . At a minimum, you'll want to implement the value_to_string method to convert the data for serialization (there's an example in the django docs at the link above). Note that the examples at the URL link above also include mention of subclassing FileField and ImageField, which is helpful for your situation! You'll also have to decide if the data should therefore be stored in the database, or on the file system. If the former, you will have to implement your custom class as a Blob field, including customization for every DB you wish to support; you'll also have to provide some support for how the data should be returned to the user out of the database when the HTML requests a .gif/.jpg/.png/.whatever url. If the latter, which is the smarter way to go IMHO, you'll have to implement methods for serializing, de-serializing binary data to the filesystem. Either way, if you implement these as subclasses of FileField and ImageField, you should still be able to use the Admin tools and other modules that expect such django features. If and only if you elect to use the more involved blob approach, here's a snippet of code from an old project of mind (back when I was learning Django) that handles blob for MySQL and PostgreSQL; you'll probably be able to find a number of improvements as I haven't touched it since :-) It does not handle serialization, though, so you'll have to add that using the method above. from django.db import models from django.conf import settings class BlobValueWrapper(object): """Wrap the blob value so that we can override the unicode method. After the query succeeds, Django attempts to record the last query executed, and at that point it attempts to force the query string to unicode. This does not work for binary data and generates an uncaught exception. """ def __init__(self, val): self.val = val def __str__(self): return 'blobdata' def __unicode__(self): return u'blobdata' class BlobField(models.Field): """A field for persisting binary data in databases that we support.""" __metaclass__ = models.SubfieldBase def db_type(self): if settings.DATABASE_ENGINE == 'mysql': return 'LONGBLOB' elif settings.DATABASE_ENGINE == 'postgresql_psycopg2': return 'bytea' else: raise NotImplementedError def to_python(self, value): if settings.DATABASE_ENGINE == 'postgresql_psycopg2': if value is None: return value return str(value) else: return value def get_db_prep_save(self, value): if value is None: return None if settings.DATABASE_ENGINE =='postgresql_psycopg2': return psycopg2.Binary(value) else: return BlobValueWrapper(value)
