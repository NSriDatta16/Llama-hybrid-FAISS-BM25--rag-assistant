[site]: stackoverflow
[post_id]: 2038823
[parent_id]: 2038717
[tags]: 
A good way to think about it is to understand what has to be done to handle up-casts. I'll try to answer your questions by showing the memory layout of objects of the classes you describe. Code sample #2 The memory layout is as follows: vptr | A::a | B::b Upcasting a pointer to B to type A will result in the same address, with the same vptr being used. This is why there's no need for additional vptr's here. Code sample #3 vptr | A::a | vptr | B::b | C::c As you can see, there are two vptr's here, just like you guessed. Why? Because it's true that if we upcast from C to A we don't need to modify the address, and thus can use the same vptr. But if we upcast from C to B we do need that modification, and correspondingly we need a vptr at the start of the resulting object. So, any inherited class beyond the first will require an additional vptr (unless that inherited class has no virtual methods, in which case it has no vptr). Code sample #4 and beyond When you derive virtually, you need a new pointer, called a base pointer , to point to the location in the memory layout of the derived classes. There can be more than one base pointer, of course. So how does the memory layout look? That depends on the compiler. In your compiler it's probably something like vptr | base pointer | B::b | vptr | A::a | C::c | vptr | A::a \-----------------------------------------^ But other compilers may incorporate base pointers in the virtual table (by using offsets - that deserves another question). You need a base pointer because when you derive in a virtual fashion, the derived class will appear only once in the memory layout (it may appear additional times if it's also derived normally, as in your example), so all its children must point to the exact same location. EDIT: clarification - it all really depends on the compiler, the memory layout I showed can be different in different compilers.
