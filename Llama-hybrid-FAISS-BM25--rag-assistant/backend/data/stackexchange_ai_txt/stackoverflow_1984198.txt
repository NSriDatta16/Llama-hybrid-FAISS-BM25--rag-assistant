[site]: stackoverflow
[post_id]: 1984198
[parent_id]: 1982257
[tags]: 
You're not really building a trie here. Your end result is effectively a randomly ordered proplist of proplists that requires full scans at each level when walking the list. Tries are typically implied ordering based on position in the array (or list). Here's an implementation that uses tuples as the storage mechanism. Calling set only rebuilds the root and direct path tuples. (note: would probably have to make the pair a triple (adding size) make delete work with any efficiency) I believe erlang tuples are really just arrays (thought I read that somewhere), so lookup should be super fast, and modify is probably straight forward. Maybe this is faster with the array module, but I haven't really played with it much to know. this version also stores an arbitrary value, so you can do things like: 1> c(trie). {ok,trie} 2> trie:get("ab",trie:set("aa",bar,trie:new("ab",foo))). foo 3> trie:get("abc",trie:set("aa",bar,trie:new("ab",foo))). undefined 4> code (entire module): note2: assumes lower case non empty string keys -module(trie). -compile(export_all). -define(NEW,{ %% 26 pairs, to avoid cost of calculating a new level at runtime {undefined,nodepth},{undefined,nodepth},{undefined,nodepth},{undefined,nodepth}, {undefined,nodepth},{undefined,nodepth},{undefined,nodepth},{undefined,nodepth}, {undefined,nodepth},{undefined,nodepth},{undefined,nodepth},{undefined,nodepth}, {undefined,nodepth},{undefined,nodepth},{undefined,nodepth},{undefined,nodepth}, {undefined,nodepth},{undefined,nodepth},{undefined,nodepth},{undefined,nodepth}, {undefined,nodepth},{undefined,nodepth},{undefined,nodepth},{undefined,nodepth}, {undefined,nodepth},{undefined,nodepth} } ). -define(POS(Ch), Ch - $a + 1). new(Key,V) -> set(Key,V,?NEW). set([H],V,Trie) -> Pos = ?POS(H), {_,SubTrie} = element(Pos,Trie), setelement(Pos,Trie,{V,SubTrie}); set([H|T],V,Trie) -> Pos = ?POS(H), {SubKey,SubTrie} = element(Pos,Trie), case SubTrie of nodepth -> setelement(Pos,Trie,{SubKey,set(T,V,?NEW)}); SubTrie -> setelement(Pos,Trie,{SubKey,set(T,V,SubTrie)}) end. get([H],Trie) -> {Val,_} = element(?POS(H),Trie), Val; get([H|T],Trie) -> case element(?POS(H),Trie) of {_,nodepth} -> undefined; {_,SubTrie} -> get(T,SubTrie) end.
