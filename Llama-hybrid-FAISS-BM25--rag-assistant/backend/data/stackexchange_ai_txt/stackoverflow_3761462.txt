[site]: stackoverflow
[post_id]: 3761462
[parent_id]: 3754599
[tags]: 
Ok, I took a shot at it. I'm also using an attribute, just as others have suggested. There's also a couple of commented lines for a version that will produce elements named after the contents of the list, instead of using attributes. The hard part of the job is done by the class below, which takes a list of strings and transforms nodes given to it so that they contain the node hierarchy represented by the list. import xml._ import transform._ class AddPath(l: List[String]) extends RewriteRule { def listToNodes(l: List[String]): Seq[Node] = l match { case Nil => Seq.empty case first :: rest => {listToNodes(rest)} % Attribute("name", Text(first), Null) //case first :: rest => // {listToNodes(rest)} copy (label = first) } def transformChild(child: Seq[Node]) = l match { case Nil => child case first :: rest => child flatMap { case elem: Elem if elem.attribute("name") exists (_ contains Text(first)) => //case elem: Elem if elem.label == first => new AddPath(rest) transform elem case other => Seq(other) } } def appendToOrTransformChild(child: Seq[Node]) = { val newChild = transformChild(child) if (newChild == child) child ++ listToNodes(l) else newChild } override def transform(n: Node): Seq[Node] = n match { case elem: Elem => elem.copy(child = appendToOrTransformChild(elem.child)) case other => other } } After this things become really simple. First, we create the list, and then produce a list of rules from it. val listOfStrings = List(List("Node0", "Node00", "Leaf0"), List("Node0", "Node00", "Leaf1"), List("Node1", "Leaf2"), List("Node0", "Leaf3"), List("Node2", "Node20", "Node200", "Leaf4")) val listOfAddPaths = listOfStrings map (new AddPath(_)) Next, we create a rule transformer out of these rules. val ruleTransformer = new RuleTransformer(listOfAddPaths: _*) Finally, we create the XML and pretty print it. Note that I'm adding a root node. If you don't want it, just get it's child . Also note that ruleTransformer will return a Seq[Node] with a single node -- our result. val results = ruleTransformer( ) val prettyPrinter = new PrettyPrinter(80, 4) results foreach { xml => println(prettyPrinter format xml) } And the output: Output of the alternate version:
