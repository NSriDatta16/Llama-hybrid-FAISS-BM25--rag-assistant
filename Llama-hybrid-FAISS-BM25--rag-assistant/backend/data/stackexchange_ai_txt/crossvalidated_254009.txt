[site]: crossvalidated
[post_id]: 254009
[parent_id]: 61034
[tags]: 
I was working on a project not that long ago for which I needed to compute a naive bayes classifier (from scratch). I started out in R, but once I had the process down, I moved the code to Python. Here's my code that I began with. Don't expect it to be polished. For the most part, I followed Wikipedia's example ( https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Examples ). The steps are simple: calculate the a priori probabilities which are the proportion of classes For your continuous data, assume a normal distribution and calculate the mean and standard deviation. To classify observations, take the new input x , calculate dnorm(x, mu, sigma) where mu and sigma come from step 2. Sum up log(apriori) + log(dnorm(...)). At this point, log(dnorm(...)) should contain two log-values (in my example). The probability that they belong in class 0 and probability they belong in class 1. This is the point Eric Peterson makes in his second paragraph. Calculate the posterior probabilities I also compared my results to R library e1071. My probability results do not line up with theirs for this simple case , though the classification does. In their predict.naiveBayes function, they have something like log(apriori) + apply(log(sapply(...compute dnorm code here...)), 1, sum) which returns log(apriori) + log(1) = log(apriori) which is an error so their classification is solely based on the a priori probabilities (actually, they use counts not the probabilities). Anyways, I hope this helps you (and anyone else) see what's under the hood as it was not clear to me either. n=30 ## samples set.seed(123) x = c(rnorm(n/2, 10, 2), rnorm(n/2, 0, 2)) y = as.factor(c(rep(0, 20), rep(1, 10))) y #library(e1071) #nb = naiveBayes(x, y, laplace = 0) #nb #nb_predictions = predict(nb, x[1], type='raw') #nb_predictions library(dplyr) nbc % group_by(y) %>% summarise(means = mean(x), var = sd(x)) print("A Priori Probabilities") print(a_priori/sum(a_priori)) print("conditional probabilities \n") print(cond_probs) return(list(apriori = a_priori, tables = cond_probs)) } predict_nbc
