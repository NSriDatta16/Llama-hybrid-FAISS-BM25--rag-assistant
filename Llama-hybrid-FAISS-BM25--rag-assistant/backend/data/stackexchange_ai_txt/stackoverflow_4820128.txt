[site]: stackoverflow
[post_id]: 4820128
[parent_id]: 1213074
[tags]: 
Seems wonderfull at first sight. I tried it but got some errors on implementations. I began to correct some errors when I decided to look for something a little bit more simplier, that do not have pointers (humm I don't like that, particularly with carbage collection, but I have no idea if it could have real impact) and that do not use Interop. I come up with that. It works for me and I hope it will work for anybody else. It is only intended to be used for local drag drop (inside the same app). How to use to drag: DragDrop.DoDragDrop(listBoxOfAvailableScopes, new DragDropLocal(GetSelectedSimulResultScopes()), DragDropEffects.Copy); How to use to drop (get): DragDropLocal dragDropLocal = (DragDropLocal)e.Data.GetData(typeof(DragDropLocal)); SimulResultScopes simulResultScopes = (SimulResultScopes)dragDropLocal.GetObject(); Code: namespace Util { [Serializable] public class DragDropLocal { private static readonly Dictionary _dictOfDragDropLocalKeyToDragDropSource = new Dictionary (); private Guid _guid = Guid.NewGuid(); public DragDropLocal(object objToDrag) { _dictOfDragDropLocalKeyToDragDropSource.Add(_guid, objToDrag); } public object GetObject() { object obj; _dictOfDragDropLocalKeyToDragDropSource.TryGetValue(_guid, out obj); return obj; } ~DragDropLocal() { _dictOfDragDropLocalKeyToDragDropSource.Remove(_guid); } } }
