[site]: stackoverflow
[post_id]: 3615658
[parent_id]: 3607161
[tags]: 
Here is an implementation in Haskell (update: took care of 3-peg case by making k = n-1 when r=3): -- hanoi for n disks and r pegs [p1, p2, ..., pr] hanoiR :: Int -> [a] -> [(a, a)] -- zero disks: no moves needed. hanoiR 0 _ = [] -- one disk: one move and two pegs needed. hanoiR 1 (p1 : p2 : rest) = [(p1, p2)] -- only needed for smart-alecks? {- -- n disks and 3 pegs -- unneeded; covered by (null rest) below. hanoiR n [p1, p2, p3] = hanoiR (n - 1) [p1, p3, p2] ++ [(p1, p2)] ++ hanoiR (n - 1) [p3, p2, p1] -} -- n disks and r > 3 pegs: use Frame-Stewart algorithm hanoiR n (p1 : p2 : p3 : rest) = hanoiR k (p1 : p3 : p2 : rest) ++ hanoiR (n - k) (p1 : p2 : rest) ++ hanoiR k (p3 : p2 : p1 : rest) where k | null rest = n - 1 | otherwise = n `quot` 2 So load this in GHCi and enter hanoiR 4 [1, 2, 3, 4] I.e. run the Towers of Hanoi with 4 disks and 4 pegs. You can name the 4 pegs whatever you want, e.g. hanoiR 4 ['a', 'b', 'c', 'd'] The output: [(1,2),(1,3),(2,3),(1,4),(1,2),(4,2),(3,1),(3,2),(1,2)] I.e. move the top disk from peg 1 to peg 2, then the top disk from peg 1 to peg 3, etc. I'm pretty new to Haskell so I must admit I'm proud that this works. But I may have silly mistakes so feedback is welcome. As you can see from the code, the heuristic for k is simply floor(n / 2). I haven't tried to optimize k, though n/2 seemed like a good guess. I've verified the correctness of the answer for 4 disks and 4 pegs. It's too late at night for me to verify more, without writing a simulator. (@_@) Here are a few more results: ghci> hanoiR 6 [1, 2, 3, 4, 5] [(1,2),(1,4),(1,3),(4,3),(2,3),(1,4),(1,5),(1,2), (5,2),(4,2),(3,1),(3,4),(3,2),(4,2),(1,2)] ghci> hanoiR 6 [1, 2, 3, 4] [(1,2),(1,4),(1,3),(4,3),(2,3),(1,2),(1,4),(2,4),(1,2), (4,1),(4,2),(1,2),(3,1),(3,4),(3,2),(4,2),(1,2)] ghci> hanoiR 8 [1, 2, 3, 4, 5] [(1,3),(1,2),(3,2),(1,4),(1,3),(4,3),(2,1),(2,3),(1,3),(1,2), (1,4),(2,4),(1,5),(1,2),(5,2),(4,1),(4,2),(1,2), (3,2),(3,1),(2,1),(3,4),(3,2),(4,2),(1,3),(1,2),(3,2)] Does this clarify the algorithm? Really the essential piece is hanoiR k (p1 : (p3 : (p2 : rest))) ++ -- step 1; corresponds to T(k,r) hanoiR (n-k) (p1 : (p2 : rest)) ++ -- step 2; corresponds to T(n-k, r-1) hanoiR k (p3 : (p2 : (p1 : rest))) -- step 3; corresponds to T(k,r) where we concatenate the sequences of moves for steps 1, 2, and 3 of the Frame-Stewart algorithm. In order to determine the moves, we annotate F-S's steps as follows: Conventionally, when hanoi is called, the goal is defined (without loss of generality) as transferring the disks from the first peg to the second peg, using all remaining pegs for temporary storage. We use this convention when recursing, to define the source, destination, and allowed storage of the divided-and-conquered subproblems. Thus the source peg is p1, and the destination peg is p2. All the remaining pegs are available as temporary storage, for the top-level hanoi problem. Step 1, "For some k, 1 Thus "without disturbing the peg that now contains the top k disks" (step 2) means to recurse using all the pegs except p3. I.e. p1, p2, and the rest beyond p3. "Transfer the top k disks to the destination peg" (step 3) means transfer from the "other peg" (p3) to p2. Does that make sense?
