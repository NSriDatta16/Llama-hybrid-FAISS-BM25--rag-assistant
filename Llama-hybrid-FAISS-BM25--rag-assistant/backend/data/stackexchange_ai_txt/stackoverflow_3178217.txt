[site]: stackoverflow
[post_id]: 3178217
[parent_id]: 3178198
[tags]: 
It sounds like you want MaxBy and MinBy functionality, e.g. var maxEntry = listAddr.MaxBy(entry => entry.Address.Length); Console.WriteLine(maxEntry.Address); var minEntry = listAddr.MinBy(entry => entry.Address.Length); Console.WriteLine(minEntry.Address); Unfortunately there's nothing like this in plain LINQ to Objects, but we have an implementation in MoreLINQ and I believe Reactive Extensions has one in System.Interactive too. Obviously you can sort by address size descending and then take the first result... that will be O(n log n) instead of O(n) complexity... that may well be fine in most cases. It feels inelegant to me though :) Code from the MoreLINQ implementation of MaxBy (without comments :) public static TSource MaxBy ( this IEnumerable source, Func selector) { return source.MaxBy(selector, Comparer .Default); } public static TSource MaxBy ( this IEnumerable source, Func selector, IComparer comparer) { source.ThrowIfNull("source"); selector.ThrowIfNull("selector"); comparer.ThrowIfNull("comparer"); using (IEnumerator sourceIterator = source.GetEnumerator()) { if (!sourceIterator.MoveNext()) { throw new InvalidOperationException("Sequence was empty"); } TSource max = sourceIterator.Current; TKey maxKey = selector(max); while (sourceIterator.MoveNext()) { TSource candidate = sourceIterator.Current; TKey candidateProjected = selector(candidate); if (comparer.Compare(candidateProjected, maxKey) > 0) { max = candidate; maxKey = candidateProjected; } } return max; } } }
