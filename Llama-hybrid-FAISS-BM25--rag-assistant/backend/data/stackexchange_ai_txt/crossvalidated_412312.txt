[site]: crossvalidated
[post_id]: 412312
[parent_id]: 287815
[tags]: 
Maybe you can try to make trees subample balanced def set_rf_balanced_subsampling(y_tt_labels): """ Changes Scikit learn's random forests to give each tree a balanced random sample of n random rows. """ each_tree_class_samples = y_tt_labels.value_counts().min() indices = {} for tt_label in ["H", "S", "BC"]: indices[tt_label] = y_tt_labels[y_tt_labels == tt_label].index.values def balanced_sampling(rs, n_samples): return np.concatenate([forest.check_random_state(rs).choice(indices["BC"], each_tree_class_samples, replace=True), forest.check_random_state(rs).choice(indices["H"], each_tree_class_samples, replace=True), forest.check_random_state(rs).choice(indices["S"], each_tree_class_samples, replace=True)]) forest._generate_sample_indices = balanced_sampling Also, I recommend you to check the Imblearn library and combine the Pipeline methods with RandomOverSample methods.
