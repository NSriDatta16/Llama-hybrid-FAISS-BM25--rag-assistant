[site]: stackoverflow
[post_id]: 5265803
[parent_id]: 5260661
[tags]: 
I think Ive solved it, basically if a timeout occurs I then iterate through my list of future objects and find the first one that has not completed, and force cancellation. Doesn't seem that elegant but seems to work. Ive changed size of pool just to show output that better demonstrates the solution but works with 2 threaded pool as well. import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.List; import java.util.concurrent.*; public class CompletionServiceTest { public static void main(final String[] args) { CompletionService cs = new ExecutorCompletionService (Executors.newFixedThreadPool(1)); Collection tasks = new ArrayList (10); tasks.add(new Worker(1)); tasks.add(new Worker(2)); tasks.add(new Worker(3)); tasks.add(new Worker(4)); tasks.add(new Worker(5)); tasks.add(new Worker(6)); List > futures = new ArrayList >(tasks.size()); try { for (Callable task : tasks) { futures.add(cs.submit(task)); } for (int t = 0; t result = cs.poll(10, TimeUnit.SECONDS); if(result==null) { System.out.println(new Date()+":Worker Timedout:"); //So lets cancel the first futures we find that havent completed for(Future future:futures) { System.out.println("Checking future"); if(future.isDone()) { continue; } else { future.cancel(true); System.out.println("Cancelled"); break; } } continue; } else { try { if(result.isDone() && !result.isCancelled() && result.get()) { System.out.println(new Date()+":Worker Completed:"); } else if(result.isDone() && !result.isCancelled() && !result.get()) { System.out.println(new Date()+":Worker Failed"); } } catch (ExecutionException ee) { ee.printStackTrace(System.out); } } } } catch (InterruptedException ie) { } finally { //Cancel by interrupting any existing tasks currently running in Executor Service for (Future f : futures) { f.cancel(true); } } System.out.println(new Date()+":Done"); } } class Worker implements Callable { private int number; public Worker(int number) { this.number=number; } public Boolean call() throws InterruptedException { try { if(number==3) { Thread.sleep(50000); } } catch(InterruptedException ie) { System.out.println("Worker Interuppted"); throw ie; } return true; } } Output is Invocation:0 Thu Mar 10 20:51:39 GMT 2011:Worker Completed: Invocation:1 Thu Mar 10 20:51:39 GMT 2011:Worker Completed: Invocation:2 Thu Mar 10 20:51:49 GMT 2011:Worker Timedout: Checking future Checking future Checking future Cancelled Invocation:3 Worker Interuppted Invocation:4 Thu Mar 10 20:51:49 GMT 2011:Worker Completed: Invocation:5 Thu Mar 10 20:51:49 GMT 2011:Worker Completed: Thu Mar 10 20:51:49 GMT 2011:Done
