[site]: stackoverflow
[post_id]: 3387630
[parent_id]: 3357180
[tags]: 
Please Google or Wikipedia for the buzzwords below. First, make sure you really want the inverse. Solving a system does not require inverting a matrix. Matrix inversion can be performed by solving n systems, with unit basis vectors as right hand sides. So I'll focus on solving systems, because it is usually what you want. It depends on what "large" means. Methods based on decomposition must generally store the entire matrix. Once you have decomposed the matrix, you can solve for multiple right hand sides at once (and thus invert the matrix easily). I won't discuss here factorization methods, as you're likely to know them already. Please note that when a matrix is large, its condition number is very likely to be close to zero, which means that the matrix is "numerically non-invertible". Remedy: Preconditionning . Check wikipedia for this. The article is well written. If the matrix is large, you don't want to store it. If it has a lot of zeros, it is a sparse matrix . Either it has structure (eg. band diagonal , block matrix , ...), and you have specialized methods for solving systems involving such matrices, or it has not. When you're faced with a sparse matrix with no obvious structure, or with a matrix you don't want to store, you must use iterative methods. They only involve matrix-vector multiplications, which don't require a particular form of storage: you can compute the coefficients when you need them, or store non-zero coefficients the way you want, etc. The methods are: For symmetric definite positive matrices: conjugate gradient method . In short, solving Ax = b amounts to minimize 1/2 x^T A x - x^T b. Biconjugate gradient method for general matrices. Unstable though. Minimum residual methods, or best, GMRES. Please check the wikipedia articles for details. You may want to experiment with the number of iterations before restarting the algorithm. And finally, you can perform some sort of factorization with sparse matrices, with specially designed algorithms to minimize the number of non-zero elements to store.
