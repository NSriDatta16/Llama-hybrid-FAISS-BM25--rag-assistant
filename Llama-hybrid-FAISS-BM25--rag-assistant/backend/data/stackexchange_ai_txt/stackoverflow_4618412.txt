[site]: stackoverflow
[post_id]: 4618412
[parent_id]: 4618098
[tags]: 
You need some form of IPC (Inter-Process Communication). Which one you choose can depend greatly upon what you want to allow, and what you don't want to allow. For instance you need to consider the following: Should any computer be able to send this request to the service, or just the local machine? Should any user be able to send this request, or just specific users/roles? If the message contents is seen by other users is this a potential security violation? Does the service need to acknowledge the message or send a response? Does the message need to be tamper proof? How many processes/threads will be sending messages at the service at a time? As you can see, there are just a host of issues you open up when you introduce IPC. Consider the questions above and research the following possible solutions: .Net Remoting - Easy, but has security & reliability issues. WCF Services - (.Net 3 or above) Easy to code, not entirely robust under heavy loads. Sockets - Hard to code, difficult to get right, but can be made to work. DCOM - Hosting a COM object in your .Net process and allow Windows to marshal the call. Win32 RPC - Raw Win32 libraries exist in C# , or you can write your own. All of these have ups and downs, pros and cons. It really depends what your specific needs are. Since you indicated your trying to call the service from the local machine, the easiest way is to either use WCF over Named Pipes (which attempts to limit communications to the local machine). If you just want to transport binary data in and out of the service then the RPC libarary linked above will work fine. The following example demonstrates using the above RPC library: Put this in your service: Guid iid = new Guid("{....}"); using (RpcServerApi server = new RpcServerApi(iid)) { server.OnExecute += delegate(IRpcClientInfo client, byte[] arg) { byte[] response; //do whatever return response; }; server.AddProtocol(RpcProtseq.ncalrpc, "MyServiceName", 5); server.AddAuthentication(RpcAuthentication.RPC_C_AUTHN_WINNT); server.StartListening(); ... And here is the client code: Guid iid = new Guid("{....}"); using (RpcClientApi client = new RpcClientApi(iid, RpcProtseq.ncalrpc, null, "MyServiceName")) { client.AuthenticateAs(null, RpcClientApi.Self, RpcProtectionLevel.RPC_C_PROTECT_LEVEL_PKT_PRIVACY, RpcAuthentication.RPC_C_AUTHN_WINNT); byte[] input, output; output = client.Execute(input); }
