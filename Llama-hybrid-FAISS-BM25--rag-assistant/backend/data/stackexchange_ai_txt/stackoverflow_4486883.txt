[site]: stackoverflow
[post_id]: 4486883
[parent_id]: 
[tags]: 
What is the cause

Here goes my first question. First of all I'm new with Java and still struggling to understand events. I have JTable with a custom model that extends AbstractTableModel, a CustomTableModelHandler that implements TableModelListener and a custom TableCellRenderer in order to show some custom tool tips (combination of data from different columns). The user can only make single row selection and I checked the option autocreaterowsorter. When removing a row I use this method: public void removeRow(int modelIndex) { fireTableRowsDeleted(modelIndex, modelIndex); rowData.remove(modelIndex); } The reason why I first fire the data change event is that I want to update a JLabel with a text that contains data from the row I'm about to delete (probably there is a more elegant way). I'm always passing the model index row, I've tried clearing the selection in the view but that didn't help. I can't seem to reproduce the error 100% of the times, but it seems it happens most of the times after I edit a row, there's a column sorting active and then delete a row (this is actually the action after which the error occurs). So, the question is: how can I tell what is the cause of my issue? The entire code is a bit too big to post it here, but I can provide it if someone wants to have a look at it. The error (which appears lots of time): run: Exception in thread "AWT-EventQueue-0" java.lang.IndexOutOfBoundsException: Index: 1, Size: 1 at java.util.ArrayList.RangeCheck(ArrayList.java:547) at java.util.ArrayList.get(ArrayList.java:322) at Contacts.ContactsGUI$CustomTableModel.getValueAt(ContactsGUI.java:1975) at javax.swing.JTable.getValueAt(JTable.java:2686) at javax.swing.JTable.prepareRenderer(JTable.java:5703) at javax.swing.plaf.basic.BasicTableUI.paintCell(BasicTableUI.java:2072) at javax.swing.plaf.basic.BasicTableUI.paintCells(BasicTableUI.java:1974) at javax.swing.plaf.basic.BasicTableUI.paint(BasicTableUI.java:1770) at javax.swing.plaf.ComponentUI.update(ComponentUI.java:143) at javax.swing.JComponent.paintComponent(JComponent.java:752) at javax.swing.JComponent.paint(JComponent.java:1029) at javax.swing.JComponent.paintToOffscreen(JComponent.java:5124) at javax.swing.RepaintManager$PaintManager.paintDoubleBuffered(RepaintManager.java:1479) at javax.swing.RepaintManager$PaintManager.paint(RepaintManager.java:1410) at javax.swing.RepaintManager.paint(RepaintManager.java:1224) at javax.swing.JComponent._paintImmediately(JComponent.java:5072) at javax.swing.JComponent.paintImmediately(JComponent.java:4882) at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:785) at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:713) at javax.swing.RepaintManager.seqPaintDirtyRegions(RepaintManager.java:693) at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:125) at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209) at java.awt.EventQueue.dispatchEvent(EventQueue.java:597) at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:269) at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:184) at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:174) at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:169) at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:161) at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)
