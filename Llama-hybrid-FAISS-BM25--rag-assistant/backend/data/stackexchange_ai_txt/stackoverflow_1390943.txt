[site]: stackoverflow
[post_id]: 1390943
[parent_id]: 1390296
[tags]: 
C89, 175 characters. #define G &&*((a+=t+1)-1)== #define H (t=strspn(a,A t;e(char*a){char A[66]="_.0123456789Aa";short*s=A+12;for(;++s 1 G 0;} I am using the standard library function strspn() , so I feel this answer isn't as "clean" as strager's answer which does without any library functions. (I also stole his idea of declaring a global variable without a type!) One of the tricks here is that by putting . and _ at the start of the string A , it's possible to include or exclude them easily in a strspn() test: when you want to allow them, use strspn(something, A) ; when you don't, use strspn(something, A+12) . Another is assuming that sizeof (short) == 2 * sizeof (char) , and building up the array of valid characters 2 at a time from the "seed" pair Aa . The rest was just looking for a way to force subexpressions to look similar enough that they could be pulled out into #define d macros. To make this code more "portable" (heh :-P) you can change the array-building code from char A[66]="_.0123456789Aa";short*s=A+12;for(;++s to char*A="_.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; for a cost of 5 additional characters.
