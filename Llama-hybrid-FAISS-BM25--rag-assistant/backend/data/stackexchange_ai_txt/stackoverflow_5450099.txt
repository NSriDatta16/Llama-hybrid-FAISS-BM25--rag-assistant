[site]: stackoverflow
[post_id]: 5450099
[parent_id]: 5447217
[tags]: 
Without the corresponding ocamlyacc parser, nobody will be able to find the issue with your code since your lexer works perfectly fine! I have taken the liberty of writing the following tiny parser (parser.mly) that constructs a list of identifier pairs, e.g. input "a=b;" should give the singleton list [("a", "b")]. %{%} %token Identifier %token EqualsSign %token Semicolon %token EOF %start start %type start %% start: | EOF {[]} | Identifier EqualsSign Identifier Semicolon start {($1, $3) :: $5} ; %% To test whether the parser does what I promised, we create another file (main.ml) that parses the string "a=b;" and prints the result. let print_list = List.iter (fun (a, b) -> Printf.printf "%s = %s;\n" a b) let () = print_list (Parser.start Lexer.next (Lexing.from_string "a=b;")) The code should compile (e.g. ocamlbuild main.byte) without any complaints and the program should output "a=b;" as promised. In response to the latest edit: In general, I don't believe that catching standard library exceptions that are meant to indicate failure or misuse (like Invalid_argument or Failure) is a good idea. The reason is that they are used ubiquitously throughout the library such that you usually cannot tell which function raised the exception and why it did so. Furthermore, you are throwing away the only useful information: the error message! The error message should tell you what the source of the problem is (my best guess is an IO-related issue). Thus, you should either print the error message or let the exception propagate to the toplevel. Personally, I prefer the latter option. However, you probably still want to deal with syntactically ill-formed inputs in a graceful manner. For this, you can define a new exception in the lexer and add a default case that catches invalid tokens. { exception Unexpected_token } ... | _ {raise Unexpected_token} Now, you can catch the newly defined exception in your main file and, unlike before, the exception is specific to syntactically invalid inputs. Consequently, you know both the source and the cause of the exception giving you the chance to do something far more meaningful than before. A fairly random OCaml development hint: If you compile the program with debug information enabled, setting the environment variable OCAMLRUNPARAM to "b" (e.g. export OCAMLRUNPARAM=b) enables stack traces for uncaught exceptions!
