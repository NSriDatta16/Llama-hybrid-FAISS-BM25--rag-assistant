[site]: stackoverflow
[post_id]: 4727149
[parent_id]: 
[tags]: 
Application randomly stops receiving key presses (CGEventTaps)

So, I've wasted a bunch of time creating this really cool keyboard macro application. It works great, the only problem is that after a couple minutes, it just stops working. It ceases to get called when I press a key. I haven't been able to lock it down, but it always takes at least 30 seconds to happen. Usually it won't happen for several minutes. I'll have intercepted and sent out many events by then. The application is still running when it happens. Here's an example of what I'm doing to listen -(void)listen { CFMachPortRef downEventTap = CGEventTapCreate(kCGHIDEventTap,kCGHeadInsertEventTap,kCGEventTapOptionDefault,CGEventMaskBit(kCGEventKeyDown),&onKeyDown,self); downSourceRef = CFMachPortCreateRunLoopSource(NULL, downEventTap, 0); CFRelease(downEventTap); CFRunLoopAddSource(CFRunLoopGetCurrent(), downSourceRef, kCFRunLoopDefaultMode); CFRelease(downSourceRef) } And the handler - CGEventRef onKeyDown(CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *refcon) { NSLog(@"DOWN (%i)", CGEventGetIntegerValueField(event, kCGKeyboardEventKeycode)); // When it matches, I return CGEventCreate(NULL) to stop the event return event; } Also note that when I intercept an event (and return that CGEventCreate(NULL) ), I usually issue one or more key presses of my own, using the following code. Note that KeyCmd, etc, are just shortcuts to the normal constants. - (void)sendKey:(KeyCode)code cmd:(BOOL)cmd alt:(BOOL)alt ctl:(BOOL)ctl shift:(BOOL)shift { CGEventFlags flags = 0; if (cmd) flags = flags | KeyCmd; if (alt) flags = flags | KeyAlt; if (ctl) flags = flags | KeyCtl; if (shift) flags = flags | KeyShift; CGEventSourceRef source = CGEventSourceCreate(kCGEventSourceStateCombinedSessionState); CGEventRef keyDownPress = CGEventCreateKeyboardEvent(source, (CGKeyCode)code, YES); CGEventSetFlags(keyDownPress, flags); CGEventPost(kCGAnnotatedSessionEventTap, keyDownPress); CFRelease(keyDownPress); CFRelease(source); } Thanks!
