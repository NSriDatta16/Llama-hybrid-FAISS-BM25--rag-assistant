[site]: stackoverflow
[post_id]: 3260236
[parent_id]: 3259962
[tags]: 
I am going to try an explain why your current code behaves like it behaves. First thing to know: | is the bitwise-or operator. Second thing to know: | has a higher operator precendance than = and therefore is executed first. So, let's have a look at the first code: $w=3|$r=2 . According to operator precedence this code may be written this way: $w=(3|$r=2) . So $r get's set correctly and then $w=3|2 is performed. 3 in the dual system is 11 and 2 is 10 . 11 | 10 ==== 11 So the result is correct. Now, let's look at the second code: $w=4|$r=2 is same as $w=(4|$r=2) . $r is set correctly, then $w=4|2 is performed. 4 is 100 in dual system, 2 is 010 : 100 | 010 ===== 110 And 110 in the decimal system is 6 ! So, now you know there the wrong values come from, now let's find a solution: Using && here is discouraged, because if the first value was set to 0 the second wouldn't be set at all. Furthermore it has wrong operator precedence: $w=1&&$r=2 is same as $w=(1&&$r=2) . So $w would always be assigned either true or false . One possible solution would be to use the xor operator. This operator requires both sides to be executed and it has the perfect precendance: $i == 9 ? ($w = 1 xor $r = 2) : ($w = 2 xor $r = 3); But, you may imagine, this is hard to read, so better not use it...
