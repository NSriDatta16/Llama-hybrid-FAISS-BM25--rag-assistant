[site]: stackoverflow
[post_id]: 1437387
[parent_id]: 1435903
[tags]: 
Maybe something like this would work for you? I just whipped it up so please poke at it. Basically, it implements an overflow thread pool that is used to feed the underlying ThreadPoolExecutor There are two major draw backs I see with it: The lack of a returned Future object on submit() . But maybe that is not an issue for you. The secondary queue will only empty into the ThreadPoolExecutor when jobs are submitted. There has got to be an elegant solution, but I don't see it just yet. If you know that there will be a stead stream of tasks into the StusMagicExecutor then this may not be an issue. ("May" being the key word.) An option might to be to have your submitted tasks poke at the StusMagicExecutor after they complete? Stu's Magic Executor: public class StusMagicExecutor extends ThreadPoolExecutor { private BlockingQueue secondaryQueue = new LinkedBlockingQueue (); //capacity is Integer.MAX_VALUE. public StusMagicExecutor() { super(5, 20, 60L, SECONDS, new SynchronousQueue (true), new RejectionHandler()); } public void queueRejectedTask(Runnable task) { try { secondaryQueue.put(task); } catch (InterruptedException e) { // do something } } public Future submit(Runnable newTask) { //drain secondary queue as rejection handler populates it Collection tasks = new ArrayList (); secondaryQueue.drainTo(tasks); tasks.add(newTask); for (Runnable task : tasks) super.submit(task); return null; //does not return a future! } } class RejectionHandler implements RejectedExecutionHandler { public void rejectedExecution(Runnable runnable, ThreadPoolExecutor executor) { ((StusMagicExecutor)executor).queueRejectedTask(runnable); } }
