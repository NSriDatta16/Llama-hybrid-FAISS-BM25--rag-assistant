[site]: stackoverflow
[post_id]: 1736623
[parent_id]: 1638864
[tags]: 
The samples from Apple's SDK actually implement the filtering in an even simpler way which is by using ramping: //ramp-speed - play with this value until satisfied const float kFilteringFactor = 0.1f; //last result storage - keep definition outside of this function, eg. in wrapping object float accel[3]; //acceleration.x,.y,.z is the input from the sensor //result.x,.y,.z is the filtered result //high-pass filter to eliminate gravity accel[0] = acceleration.x * kFilteringFactor + accel[0] * (1.0f - kFilteringFactor); accel[1] = acceleration.y * kFilteringFactor + accel[1] * (1.0f - kFilteringFactor); accel[2] = acceleration.z * kFilteringFactor + accel[2] * (1.0f - kFilteringFactor); result.x = acceleration.x - accel[0]; result.y = acceleration.y - accel[1]; result.z = acceleration.z - accel[2];
