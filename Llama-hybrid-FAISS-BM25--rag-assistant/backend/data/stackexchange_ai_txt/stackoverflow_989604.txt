[site]: stackoverflow
[post_id]: 989604
[parent_id]: 978871
[tags]: 
I refer to the answer by Robert Harvey and your comment: "Do I need to inherit anything special for the solution to work?" Yes, since you are using generics (T), you need to constrain the generic type to something, otherwise T could be anything (object, int, string, Products, etc) and "anything" can have different properties. So the ideal would be to have a base type or interface, i.e.: pulbic interface IEntity { Object Id { set; get; } } So your table object (entity) needs to inherit from IEntity and then your code would look like this: protected void Page_Load(object sender, EventArgs e) { something(Linq.AnotherTable); } public void something (System.Data.Linq.Table MyObject) where T : IEntity { var Edit = (from R in MyObject where R.ID == RecordID select R).Single(); } The something method will infer the T for you, as long as AnotherTable table inherits from IEntity. The next problem is "Id" is now of type object, or whatever type you would like it to be, but it is a fixed type. So you have a problem again, what if you have different ID types? So instead of a object, or whatever you have specified it to be (e.g. int, string, Guid), you might use "Key" as the property with a generic type and the possible solution would be: pulbic interface IEntity { TKey Key { set; get; } } This becomes more flexible, but it complicates things even more...
