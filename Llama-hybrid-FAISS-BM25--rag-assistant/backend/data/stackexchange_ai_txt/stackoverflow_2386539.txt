[site]: stackoverflow
[post_id]: 2386539
[parent_id]: 2347935
[tags]: 
This isn't an answer per se, but perhaps an alternative might work. If the problem is indeed that you have fragmented memory, then perhaps one workaround would be to just use those holes, instead of trying to find a hole big enough for everything consecutively. Here's a very simple BigArray class that doesn't add too much overhead (some overhead is introduced, especially in the constructor, in order to initialize the buckets). The statistics for the array is: Main executes in 404ms static Program-constructor doesn't show up The statistics for the class is: Main took 473ms static Program-constructor takes 837ms (initializing the buckets) The class allocates a bunch of 8192-element arrays (13 bit indexes), which on 64-bit for reference types will fall below the LOB limit. If you're only going to use this for Int32, you can probably up this to 14 and probably even make it nongeneric, although I doubt it will improve performance much. In the other direction, if you're afraid you're going to have a lot of holes smaller than the 8192-element arrays (64KB on 64-bit or 32KB on 32-bit), you can just reduce the bit-size for the bucket indexes through its constant. This will add more overhead to the constructor, and add more memory-overhead, since the outmost array will be bigger, but the performance should not be affected. Here's the code: using System; using NUnit.Framework; namespace ConsoleApplication5 { class Program { // static int[] a = new int[100 * 1024 * 1024]; static BigArray a = new BigArray (100 * 1024 * 1024); static void Main(string[] args) { int l = a.Length; for (int index = 0; index (() => { new BigArray (0); }); } [Test] public void Constructor_NegativeLength_ThrowsArgumentOutOfRangeException() { Assert.Throws (() => { new BigArray (-1); }); } [Test] public void Indexer_SetsAndRetrievesCorrectValues() { BigArray array = new BigArray (10001); for (int index = 0; index array = new BigArray (PRIME_ARRAY_SIZE); Assert.Throws (() => { array[PRIME_ARRAY_SIZE] = 0; }); } [Test] public void Indexer_RetrieveElementJustBeforeStart_ThrowsIndexOutOfRangeException() { BigArray array = new BigArray (PRIME_ARRAY_SIZE); Assert.Throws (() => { array[-1] = 0; }); } [Test] public void Constructor_BoundarySizes_ProducesCorrectlySizedArrays() { for (int index = 1; index arr = new BigArray (index); Assert.That(arr.Length, Is.EqualTo(index)); arr[index - 1] = 42; Assert.That(arr[index - 1], Is.EqualTo(42)); Assert.Throws (() => { arr[index] = 42; }); } } } public class BigArray { const int BUCKET_INDEX_BITS = 13; const int BUCKET_SIZE = 1 > BUCKET_INDEX_BITS; bool lastBucketIsFull = true; if ((length & BUCKET_INDEX_MASK) != 0) { bucketCount++; lastBucketIsFull = false; } _Buckets = new T[bucketCount][]; for (int index = 0; index > BUCKET_INDEX_BITS][index & BUCKET_INDEX_MASK]; } set { _Buckets[index >> BUCKET_INDEX_BITS][index & BUCKET_INDEX_MASK] = value; } } } }
