[site]: stackoverflow
[post_id]: 2390686
[parent_id]: 160216
[tags]: 
I'm years late to the party here, and this is perhaps more an answer to the "meta-question", but something many people initially have a hard time with when programming in Mathematica (or other functional languages) is approaching a problem from a functional rather than structural viewpoint. The Mathematica language has structural constructs, but it's functional at its core. Consider your first example: ForEach[i_, {1,2,3}, Print[i] ] As several people pointed out, this can be expressed functionally as Scan[Print, {1,2,3}] or Print /@ {1,2,3} (although you should favor Scan over Map when possible, as previously explained, but that can be annoying at times since there is no infix operator for Scan ). In Mathematica, there's usually a dozen ways to do everything, which is sometimes beautiful and sometimes frustrating. With that in mind, consider your second example: ForEach[{i_, j_}, {{1,10}, {2,20}, {3,30}}, Print[i*j] ] ... which is more interesting from a functional point of view. One possible functional solution is to instead use list replacement, e.g.: In[1]:= {{1,10},{2,20},{3,30}}/.{i_,j_}:>i*j Out[1]= {10,40,90} ...but if the list was very large, this would be unnecessarily slow since we are doing so-called "pattern matching" (e.g., looking for instances of {a, b} in the list and assigning them to i and j ) unnecessarily. Given a large array of 100,000 pairs, array = RandomInteger[{1, 100}, {10^6, 2}] , we can look at some timings: Rule-replacement is pretty quick: In[3]:= First[Timing[array /. {i_, j_} :> i*j;]] Out[3]= 1.13844 ... but we can do a little better if we take advantage of the expression structure where each pair is really List[i,j] and apply Times as the head of each pair, turning each {i,j} into Times[i,j] : In[4]:= (* f@@@list is the infix operator form of Apply[f, list, 1] *) First[Timing[Times @@@ array;]] Out[4]= 0.861267 As used in the implementation of ForEach[...] above, Cases is decidedly suboptimal: In[5]:= First[Timing[Cases[array, {i_, j_} :> i*j];]] Out[5]= 2.40212 ... since Cases does more work than just the rule replacement, having to build an output of matching elements one-by-one. It turns out we can do a lot better by decomposing the problem differently, and take advantage of the fact that Times is Listable , and supports vectorized operation. The Listable attribute means that a function f will automatically thread over any list arguments: In[16]:= SetAttributes[f,Listable] In[17]:= f[{1,2,3},{4,5,6}] Out[17]= {f[1,4],f[2,5],f[3,6]} So, since Times is Listable , if we instead had the pairs of numbers as two separate arrays: In[6]:= a1 = RandomInteger[{1, 100}, 10^6]; a2 = RandomInteger[{1, 100}, 10^6]; In[7]:= First[Timing[a1*a2;]] Out[7]= 0.012661 Wow , quite a bit faster! Even if the input wasn't provided as two separate arrays (or you have more than two elements in each pair,) we can still do something optimal: In[8]:= First[Timing[Times@@Transpose[array];]] Out[8]= 0.020391 The moral of this epic is not that ForEach isn't a valuable construct in general, or even in Mathematica, but that you can often obtain the same results more efficiently and more elegantly when you work in a functional mindset, rather than a structural one.
