[site]: stackoverflow
[post_id]: 4656965
[parent_id]: 4594698
[tags]: 
ssh , ssh-keygen , ssh-agent , ssh-add and a correct configuration in /etc/ssh_config on the remote systems are necessary ingredients for securing access to remote systems. First, a private/public keypair needs to be generated with ssh-keygen . The result of the keygen process are two files: the public key and the private key . The public key file, usually stored in ~/.ssh/id_dsa.pub (or ~/.ssh/id_rsa.pub , for RSA encryptions) needs to be copied to each remote system that will be granting remote access to the user. The private key file should remain on the originating system, or on a portable USB ("thumb") drive that is referenced from the sourcing system. When generating the key pair, a passphrase is used to protect it from usage by non-authenticated users. When establishing an ssh session for the first time, the private key can only be unlocked with the passphrase. Once unlocked, it is possible for the originating system to remember the unlocked private key with ssh-agent . Some systems (e.g., Mac OS X) will automatically start up ssh-agent as part of the login process, and then do an automatic ssh-add -k that unlocks your private ssh keys using a passphrase previously stored in the keychain file . Connections to remote systems can be direct, or proxied through ssh gateways . In the former case, the remote system only needs to have the public key corresponding to the available unlocked private keys. In the case of using a gateway, the intermediate system must have the public key as well as the eventual target system. In addition, the original ssh command needs to enable agent forwarding , either by configuration in ~/.ssh/config or by command option -A . For example, to login to remote system "app1" through an ssh gateway system called "gw", the following can be done: ssh -At gw ssh -A app1 or the following stanzas placed in the ~/.ssh/config file: Host app1 ForwardAgent = yes ProxyCommand = ssh -At gw nc %h %p 2>/dev/null which runs "net cat" (aka nc ) on the ssh gateway as a network pipe. The above setup will allow very simple ssh commands, even through ssh gateways: ssh app1 Sometimes, even more important than terminal sessions are scp and rsync commands for moving files around securely. For example, I use something like this to synchronize my personal environment to a remote system: rsync -vaut ~/.env* ~/.bash* app1: Without the config file and nc proxy command, the rsync would get a little more complicated: rsync -vaut -e 'ssh -A gw' app1: None of this will work correctly unless the remote systems' /etc/ssh_config is configured correctly. One such configuration is to remove "root" access via ssh, which improve tracking and accountability when several staff can perform root functions. In unattended batch scripts, a special ssh key-pair needs to be generated for the non-root userid under which the scripts are run. Just as with ssh session management, the batch user ssh key-pair needs to be deployed similarly, with the public key copied to the remote systems, and the private key residing on the source system. The private key can be locked with a passphrase or unlocked, as desired by the system managers and/or developers. The way to use the special batch ssh key, even in a script running under root, is to use the " ssh -i ~/.ssh/id_dsa " command options with all remote access commands. For example, to copy a file within a script using the special "batch" user access: rsync -vaut -e 'ssh -i ~batch/.ssh/id_dsa -A gw' $sourcefiles batch@app2:/Sites/www/ This causes rsync to use a special ssh command as the remote access shell. The special-case ssh command uses the "batch" user's DSA private key as its identity. The rsync command's target remote system will be accessed using the "batch" user.
