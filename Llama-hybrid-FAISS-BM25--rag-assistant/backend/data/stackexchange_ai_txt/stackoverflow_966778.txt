[site]: stackoverflow
[post_id]: 966778
[parent_id]: 966162
[tags]: 
See the file luaconf.h in the source kit for easy access to most compile-time configuration such as the actual type used for lua_Number . See the file linit.c in the source kit for the list of core libraries that are loaded by calling luaL_openlibs() . Common practice is to copy that file to your application's source, and modify it to suit your needs, calling that copy's luaL_openlibs() in place of the core version. If you are compiling Lua privately and not linking to one of the pre-built binaries of the library, then you can find a method to do the equivalent that suits your needs. Of course, you also don't need to compile or link to the sources for any library (such as os , found in loslib.c ) that you choose to leave out of luaL_openlibs() . The only library that you probably can't leave out completely is the base library that provides things like pairs() , ipairs() , pcall() , tostring() , and lots more that can be really inconvenient to do without. When porting to an environment where some of these are problematic, it is usually a good idea to look closely at its implementation in lbaselib.c and either trim features from it or reimplement them to suit your needs. Edit: Another approach to including a different list of libraries in the interpreter is to not call luaL_openlibs() at all. Although provided as a convenience, like all of the auxiliary library, luaL_openlibs() is not mandatory. Instead, explicitly open just the libraries you want. Chapter 5 of the reference manual talks about this: To have access to these libraries, the C host program should call the luaL_openlibs function, which opens all standard libraries. Alternatively, it can open them individually by calling luaopen_base (for the basic library), luaopen_package (for the package library), luaopen_string (for the string library), luaopen_table (for the table library), luaopen_math (for the mathematical library), luaopen_io (for the I/O library), luaopen_os (for the Operating System library), and luaopen_debug (for the debug library). These functions are declared in lualib.h and should not be called directly: you must call them like any other Lua C function, e.g., by using lua_call . That last sentence is occasionally the source of trouble, since older versions of Lua did not have that restriction. Each of the individual module's luaopen_xxx() functions follows the same protocol used by the require function. It should be passed a single argument: a string containing the name by which the module is known. The exception is the base module, which is passed an empty string because it has no actual name. Here's a function that creates a new Lua state and opens only the base and package libraries: #include "lua.h" #include "lualib.h" #include "lauxlib.h" lua_State *CreateBasicLua() { lua_State *L; L = luaL_newstate(); if (L) { lua_pushcfunction(L, luaopen_base); lua_pushstring(L, ""); lua_call(L, 1, 0); lua_pushcfunction(L, luaopen_package); lua_pushstring(L, LUA_LOADLIBNAME); lua_call(L, 1, 0); } return L; } It returns the new lua_State on success, or NULL on failure.
