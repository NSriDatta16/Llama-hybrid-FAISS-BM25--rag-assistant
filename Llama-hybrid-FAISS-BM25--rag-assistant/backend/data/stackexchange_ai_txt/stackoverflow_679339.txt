[site]: stackoverflow
[post_id]: 679339
[parent_id]: 679210
[tags]: 
You can use int width = 1024; int height = 1024; GLubyte * texture = new GLubyte[4*width*height]; ... glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, textureArray); delete [] texture; //remove the un-needed local copy of the texture; However you still need to specify the width and height to OpenGL in glTexImage2D call. This call copies texture data and that data is managed by OpenGL. You can delete, resize, change your original texture array all you want and it won't make a different to the texture you specified to OpenGL. Edit: C/C++ deals with only 1 dimensional arrays. The fact that you can do texture[a][b] is hidden and converted by the compiler at compile time. The compiler must know the number of columns and will do texture[a*cols + b]. Use a class to hide the allocation, access to the texture. For academic purposes, if you really want dynamic multi dimensional arrays the following should work: int rows = 16, cols = 16; char * storage = new char[rows * cols]; char ** accessor2D = new char *[rows]; for (int i = 0; i Notice that in all the cases I'm using 1D arrays. They are just arrays of pointers, and array of pointers to pointers. There's memory overhead to this. Also this is done for 2D array without colour components. For 3D dereferencing this gets really messy. Don't use this in your code.
