[site]: stackoverflow
[post_id]: 1859793
[parent_id]: 1854323
[tags]: 
The ACE library contains wrappers for dynamic library loading that work cross platform. If you want more comfort than plain loadlibrary then look at TAO The ACE ORB. Using corba with TAO is extremly performant and most likely beats any self crafted plugin infrastructure especially if you use in process calls, as TAO optimizes them. To use the dynamic library cross platform wrapper use ACE_DLL . It provides the most basic cross platform wrapper around loadlibrary() that you mentioned. In between using ACE_DLL and using TAO is the service configuration framework of ACE that allows you to dynamically load objects. After loading you can get an upcast pointer to the loaded object that you implemented and can call any method on the loaded object. The code to do that would look like this: char const * const cpc_myClass = ACE_DYNAMIC_SERVICE_DIRECTIVE( "myclass", "dllname", "_make_MyClass", "" ); result = ACE_Service_Config::process_directive(cpc_myClass); MyClass * p_obj = ACE_Dynamic_Service ::instance ("myclass"); p_obj->callAnyMethodYouLike(); Here is explained that TAO knows two types of colocation optimization (thru_poa and direct): When using the direct strategy, method invocations on collocated objects become direct calls to servant without checking POA's status. You might be amazed how effective TAO can be if used correctly. I suggest to create a simple proof of concept and do measurements.
