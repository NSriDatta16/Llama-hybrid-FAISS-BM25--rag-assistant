[site]: stackoverflow
[post_id]: 5174957
[parent_id]: 5171927
[tags]: 
If you've created a DOM yourself, you might look into the Visitor pattern. It would allow you to avoid having specific code for creating HTML documents in your DOM itself. I've done the same a while ago and still find new ways of using this way of adding new functionality to my DOM classes. Here is some example: interface IVisitable { void Assign(IVisitor); } interface IVisitor { void Visit(Document document); void Visit(Section section); void Visit(Paragraph paragraph); } class Element : IVisitable { void IVisitable.Assign(IVisitor visitor) { this.Assign(visitor); } protected abstract void Assign(IVisitor visitor); } abstract class Block : Element { } abstract class Inline : Element { } abstract class BlockContainer : Block, ICollection { } abstract class ElementContainer : Element, ICollection { } abstract class InlineContainer : Inline, ICollection { } class Paragraph : BlockContainer { protected override void Assign(IVisitor visitor) { visitor.Visit(this); } } class Section : BlockContainer { public string Title { get; set; } protected override void Assign(IVisitor visitor) { visitor.Visit(this); } } class Document : ElementContainer { protected override void Assign(IVisitor visitor) { visitor.Visit(this); } } This will give you a basic document structure, where you should add further elements, that derive from the 5 base classes I've provided. The Visitor-pattern highly relies on the fact, that the IVisitor interface knows all your implemented "visitable" elements. As you can see mine needed to know about the Document , Section and Paragraph classes (as you might have guessed, it will contain much more in a real-world example). For the part, where your elements have multiple childs, which should be rendered too, I've created two Visitor implementations: abstract class Visitor : IVisitor { public virtual void Visit(Document document) { ICollection container = document; // I dont like to use the 'as' keyword, if I only want to fool the compiler to pick another overload. this.Visit(container); } public virtual void Visit(Section section) { ICollection container = section; this.Visit(container); } public virtual void Visit(Paragraph paragraph) { ICollection container = paragraph; this.Visit(container); } protected virtual void Visit(ICollection container) { } protected virtual void Visit(ICollection container) { } protected virtual void Visit(ICollection container) { } } This one gives you an implementation where you can override only those elements you are interested in and if you don't override any of this methods are more generic Visit-method is introduced, which only targets the ICollection part of the elements (As I said before, the Visitor pattern requires you to know all about the visitable elements). To create some depth-first search behavior with this implementation, another Visitor is introduced: abstract class SearchVisitor : Visitor { protected override Visit(ICollection container) { this.AssignAll(container); } protected override Visit(ICollection container) { this.AssignAll(container); } protected override Visit(ICollection container) { this.AssignAll(container); } private void AssignAll (IEnumerable container) { foreach (IVisitable element in container) { element.Assign(this); } } } If you want to generate HTML from your "Documents", you can then implement a SearchVisitor just for this purpose: class HtmlMarkupRenderer : SearchVisitor { private readonly XmlWriter writer; private int sectionDepth = 0; public HtmlMarkupRenderer(TextWriter textWriter) { this.writer = XmlWriter.Create(textWriter, new XmlWriterSettings { ConformanceLevel = ConformanceLevel.Fragment }); public override void Visit(Section section) { this.sectionDepth++; string headingElement = String.Concat("h", Math.Max(this.sectionDepth, 6)); this.writer.WriteElementString(headingElement, section.Title); // The base implementation will assign this visitor to all childs of section. base.Visit(section); this.sectionDepth--; } public override void Visit(Paragraph paragraph) { this.writer.WriteStartElement("p"); base.Visit(paragraph); this.writer.WriteEndElement(); } } I've spend a lot of time on this "layout", so I can reproduce it quite fast, but it might create some overhead. Let me know if you want more details on this one.
