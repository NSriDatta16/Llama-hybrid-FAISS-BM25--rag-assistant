[site]: stackoverflow
[post_id]: 2075129
[parent_id]: 725938
[tags]: 
I ran into the same issue when I tried to combine scrolling with draggable rows in liteGrid, but I found a work-around. Your mileage may vary, but what I did was add logic to my drag event handler that would check to see if the grid was being scrolled (which is when I needed to force the droppable positions to be refreshed), and if so, I set refreshPositions to true on the draggable. This doesn't immediately refresh the positions, but it will cause them to refresh the next time the drag handle moves. Since refreshPositions slows things down, I then re-disable it the next time my drag event handler fires. The net result is that refreshPositions is enabled only when the grid is scrolling in liteGrid, and its disabled the rest of the time. Here's some code to illustrate: //This will be called every time the user moves the draggable helper. function onDrag(event, ui) { //We need to re-aquire the drag handle; we don't //hardcode it to a selector, so this event can be //used by multiple draggables. var dragHandle = $(event.target); //If refreshOptions *was* true, jQueryUI has already refreshed the droppables, //so we can now switch this option back off. if (dragHandle.draggable('option', 'refreshPositions')) { dragHandle.draggable('option', 'refreshPositions', false) } //Your other drag handling code if (/* logic to determine if your droppables need to be refreshed */) { dragHandle.draggable('option', 'refreshPositions', true); } } $("#mydraggable").draggable({ //Your options here, note that refreshPositions is off. drag: onDrag }); I hope that saves you from ramming your head into the keyboard as many times as I did...
