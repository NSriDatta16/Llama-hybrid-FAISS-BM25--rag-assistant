[site]: stackoverflow
[post_id]: 892938
[parent_id]: 892595
[tags]: 
To add to Norbert Hartl's answer , SuperCar.prototype.constructor isn't needed, but some people use it as a convenient way of getting the constructing function of an object (SuperCar objects in this case). Just from the first example, Car.call(this, name) is in the SuperCar constructor function because when you do this: var mySuperCar = new SuperCar("SuperCar"); This is what JavaScript does: A fresh, blank object is instantiated. The fresh object's internal prototype is set to Car. The SuperCar constructor function runs. The finished object is returned and set in mySuperCar. Notice how JavaScript didn't call Car for you. Prototypes being as they are, any property or method that you don't set yourself for SuperCar will be looked up in Car. Sometimes this is good, e.g. SuperCar doesn't have a Drive method, but it can share Car's one, so all SuperCars will use the same Drive method. Other times you don't want sharing, like each SuperCar having its own Name. So how does one go about setting each SuperCar's name to its own thing? You could set this. Name inside the SuperCar constructor function: function SuperCar(name){ this.Name = name; } This works, but wait a second. Didn't we do exactly the same thing in the Car constructor? Don't want to repeat ourselves. Since Car sets the name already, let's just call it. function SuperCar(name){ this = Car(name); } Whoops, you never want to change the special this object reference. Remember the 4 steps? Hang onto that object that JavaScript gave you, because it's the only way to keep the precious internal prototype link between your SuperCar object and Car. So how do we set Name, without repeating ourselves and without throwing away our fresh SuperCar object JavaScript spent so much special effort to prepare for us? Two things. One: the meaning of this is flexible. Two: Car is a function. It's possible to call Car, not with a pristine, fresh instantiated object, but instead with, say, a SuperCar object. That gives us the final solution, which is part of the first example in your question: function SuperCar(name){ Car.call(this, name); } As a function, Car is allowed to be invoked with the function's call method , which changes the meaning of this within Car to the SuperCar instance we're building up. Presto! Now each SuperCar gets its own Name property. To wrap up, Car.call(this, name) in the SuperCar constructor gives each new SuperCar object its own unique Name property, but without duplicating the code that's already in Car. Prototypes aren't scary once you understand them, but they're not much like the classic class/inheritence OOP model at all. I wrote an article about the prototypes concept in JavaScript . It's written for a game engine that uses JavaScript, but it's the same JavaScript engine used by Firefox, so it should all be relevant.
