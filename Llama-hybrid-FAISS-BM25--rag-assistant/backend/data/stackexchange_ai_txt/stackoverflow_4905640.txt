[site]: stackoverflow
[post_id]: 4905640
[parent_id]: 4905512
[tags]: 
In your example, &i[10] is actually not legal: it becomes i + 10 , which becomes NULL + 10 , and you can't perform arithmetic on a null pointer. (6.5.6/8 lists the conditions under which pointer arithmetic can be performed) Anyway, this rule was added in C99; it was not present in C89. My understanding is that it was added in large part to make code like the following well-defined: int* begin, * end; int v[10]; begin = &v[0]; end = &v[10]; That last line is technically invalid in C89 (and in C++) but is allowed in C99 because of this rule. It was a relatively minor change that made a commonly used construct well-defined. Because you can't perform arithmetic on a null pointer, your example ( &s->b ) would be invalid anyway. As for why there is this "inconsistency," I can only guess. It's likely that no one thought to make it consistent or no one saw a compelling use case for this. It's possible that this was considered and ultimately rejected. There are no remarks about the &* reduction in the Rationale . You might be able to find some definitive information in the WG14 papers , but unfortunately they seem to be quite poorly organized, so trawling through them may be tedious.
