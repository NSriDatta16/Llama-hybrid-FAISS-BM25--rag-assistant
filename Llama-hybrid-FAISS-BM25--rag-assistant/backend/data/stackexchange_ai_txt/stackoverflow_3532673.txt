[site]: stackoverflow
[post_id]: 3532673
[parent_id]: 3525387
[tags]: 
Here is an approach to solving your problem. It is not an ideal approach in many ways, and I sincerely hope that someone other AppEnginer will come up with a neater solution than I have. If not, give this a try. My approach utilizes the following strategy: it creates entities that act as aliases for the Category entities. The name of the Category can change, but the alias entity will retain its key, and we can use elements of the alias's key to create a keyname for your Category entities, so we will be able to look up a Category by its name, but its storage is decoupled from its name. The aliases are all stored in a single entity group, and that allows us to use a transaction-friendly ancestor query, so we can lookup or create a CategoryAlias without risking that multiple copies will be created. When I want to lookup or create a Category and item combo, I can use the category's keyname to programatically generate a key inside the transaction, and we are allowed to get an entity via its key inside a transaction. class CategoryAliasRoot(db.Model): count = db.IntegerProperty() # Not actually used in current code; just here to avoid having an empty # model definition. __singleton_keyname = "categoryaliasroot" @classmethod def get_instance(cls): # get_or_insert is inherently transactional; no chance of # getting two of these objects. return cls.get_or_insert(cls.__singleton_keyname, count=0) class CategoryAlias(db.Model): alias = db.StringProperty() @classmethod def get_or_create(cls, category_alias): alias_root = CategoryAliasRoot.get_instance() def txn(): existing_alias = cls.all().ancestor(alias_root).filter('alias = ', category_alias).get() if existing_alias is None: existing_alias = CategoryAlias(parent=alias_root, alias=category_alias) existing_alias.put() return existing_alias return db.run_in_transaction(txn) def keyname_for_category(self): return "category_" + self.key().id def rename(self, new_name): self.alias = new_name self.put() class Category(db.Model): pass class Item(db.Model): name = db.StringProperty() def get_or_create_item(category_name, item_name): def txn(category_keyname): category_key = Key.from_path('Category', category_keyname) existing_category = db.get(category_key) if existing_category is None: existing_category = Category(key_name=category_keyname) existing_category.put() existing_item = Item.all().ancestor(existing_category).filter('name = ', item_name).get() if existing_item is None: existing_item = Item(parent=existing_category, name=item_name) existing_item.put() return existing_item cat_alias = CategoryAlias.get_or_create(category_name) return db.run_in_transaction(txn, cat_alias.keyname_for_category()) Caveat emptor: I have not tested this code. Obviously, you will need to change it to match your actual models, but I think that the principles that it uses are sound. UPDATE: Simon, in your comment, you mostly have the right idea; although, there is an important subtlety that you shouldn't miss. You'll notice that the Category entities are not children of the dummy root. They do not share a parent, and they are themselves the root entities in their own entity groups. If the Category entities did all have the same parent, that would make one giant entity group, and you'd have a performance nightmare because each entity group can only have one transaction running on it at a time. Rather, the CategoryAlias entities are the children of the bogus root entity. That allows me to query inside a transaction, but the entity group doesn't get too big because the Items that belong to each Category aren't attached to the CategoryAlias. Also, the data in the CategoryAlias entity can change without changing the entitie's key, and I am using the Alias's key as a data point for generating a keyname that can be used in creating the actual Category entities themselves. So, I can change the name that is stored in the CategoryAlias without losing my ability to match that entity with the same Category.
