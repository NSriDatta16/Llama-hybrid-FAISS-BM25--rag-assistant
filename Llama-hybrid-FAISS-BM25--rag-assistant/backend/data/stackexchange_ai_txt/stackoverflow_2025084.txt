[site]: stackoverflow
[post_id]: 2025084
[parent_id]: 2024860
[tags]: 
Essentially, you're trying to pass an object of the non-generic type IQueryable to a method that accepts the generic IQueryable , which the compiler cannot "match", resulting in the CS1928 (since the two types are, in fact, different). In your overload that accepts an IQueryable (which is already doing the necessary conversion to a generic list), you simply need to call the generic version of AsQueryable instead of the non-generic one, as such: public static string TagCloud(this HtmlHelper html, IQueryable taggables, int numberOfStyleVariations, string divId) { var tags = new List (); foreach (var obj in taggables) { tags.Add(obj as ITaggable); } return TagCloud(html, tags.AsQueryable (), numberOfStyleVariations, divId); } Allow me to add, as well, that IQueryable derives from IQueryable , meaning that not all IQueryable objects are IQueryable , thus making the conversion necessary. If the situation were reversed, i.e. your "real" helper method was defined to handle IQueryable objects, then you certainly would have no problem passing an IQueryable to that method (since all IQueryable objects are, in fact, IQueryable ). Per Craig Stuntz, a much more elegant solution using LINQ features: (ITaggable)t), 6, "entity-tags") %> . You can also use (), 6, "entity-tags") %> if your queryable provider supports it.
