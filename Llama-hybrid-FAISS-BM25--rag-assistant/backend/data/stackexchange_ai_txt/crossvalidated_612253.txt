[site]: crossvalidated
[post_id]: 612253
[parent_id]: 611946
[tags]: 
In a model with interactions, you cannot study the main effects separately from the interactions. So instead of the two questions: (a) How the two main effects (Field & Distance) affect abundance? (b) How the Field × Distance interaction affects abundance, you can study (a) differences in abundance between fields at a given distance, and (b) differences in abundance between distances in each field type. This means that rather than looking at the estimated model parameters (the coefficients you get with the summary function in R), it's more constructive to compare estimated marginal means, ie. E{Abundance | Field, Distance}. It helps to illustrate this suggestion with an example. So I'll simulate data under the experimental setup described in the question. Here are the parameters I'm going to use. (I have no idea whether the chosen parameter values are at all realistic.) The rate is the average abundance for a given Field × Distance combination, ie. E{Abundance | Field, Distance}. Note that Field and Distance interact for Field = "grassland" and "production" but not for Field = "not sown". params The mock dataset is generated from a Poisson model with known parameters, so I don't need to check that the Poisson model is appropriate for the data. In their analysis, the OP should verify that the Poisson model is a reasonable fit to the actual data; this is an important and non-trivial step. Next we fit the Poisson generalized linear mixed model (GLMM). I include a random sector effect, (1|LS) , but not a random sampling round effect. I omit (1|sampling.round) because the description "the three different time points when the data was collected" suggests to me that data was collected at three different times but not necessarily at exactly the same three times for all combinations of Field × Distance. Also, it simplifies the simulation a bit. In any case, the structure of the random effects makes no difference for how analyze & compare the fixed effects in the model. model1 Once we fit the model, we can easily get the estimated model coefficients. It's not obvious how these coefficients are related to the rates E{Y | Field, Distance}. Interpreting the coefficients is challenging because (a) the coefficients depend on the parametrization: "not sown" and "50m" are the reference Field & Distance levels and don't appear in the summary table; (b) there are interactions, so we cannot vary a main effect while "keeping all other predictors fixed"; and (c) since this is a generalized model with a $\log$ link, the coefficients are on the log scale, $\log\text{rate}$ , not on the original abundance scale. summary(model1) #> Estimate Std. Error z value Pr(>|z|) #> (Intercept) -1.4253 0.2776 -5.134 2.84e-07 *** #> Field_Typegrassland 1.4053 0.3095 4.541 5.61e-06 *** #> Field_Typeproduction 1.4424 0.3084 4.677 2.91e-06 *** #> distance75m -0.3677 0.4336 -0.848 0.396429 #> distance150m 0.2076 0.3734 0.556 0.578151 #> distance200m -0.1671 0.4097 -0.408 0.683440 #> Field_Typegrassland:distance75m 0.5083 0.4725 1.076 0.282068 #> Field_Typeproduction:distance75m 1.0966 0.4637 2.365 0.018028 * #> Field_Typegrassland:distance150m -0.2861 0.4227 -0.677 0.498520 #> Field_Typeproduction:distance150m 0.5808 0.4073 1.426 0.153833 #> Field_Typegrassland:distance200m 1.2337 0.4395 2.807 0.005003 ** #> Field_Typeproduction:distance200m 1.5396 0.4366 3.526 0.000421 *** We can avoid all these challenges by interpreting the estimated marginal means instead of the model coefficients. That is, interpret the estimated rates E{Y | Field, Distance} instead of the estimated coefficients $\widehat{\beta}$ s. I'll use the emmeans package to do the calculations. First let's look at the estimated rates: emm Field_Type distance rate SE df asymp.LCL asymp.UCL #> not sown 50m 0.240 0.0668 Inf 0.1395 0.414 #> grassland 50m 0.980 0.1352 Inf 0.7481 1.285 #> production 50m 1.017 0.1377 Inf 0.7801 1.326 #> not sown 75m 0.166 0.0555 Inf 0.0866 0.320 #> grassland 75m 1.128 0.1451 Inf 0.8768 1.452 #> production 75m 2.108 0.1992 Inf 1.7520 2.537 #> not sown 150m 0.296 0.0741 Inf 0.1812 0.483 #> grassland 150m 0.906 0.1300 Inf 0.6842 1.200 #> production 150m 2.238 0.2053 Inf 1.8696 2.679 #> not sown 200m 0.203 0.0614 Inf 0.1126 0.368 #> grassland 200m 2.848 0.2322 Inf 2.4276 3.342 #> production 200m 4.013 0.2770 Inf 3.5057 4.595 #> #> Confidence level used: 0.95 #> Intervals are back-transformed from the log scale Since this is a simulation, we know the true rates, so let's plot the true rates (indicated by ×'s) alongside the estimated rates. In practice, we don't know the true rates. Instead we can compare rates between field types for each distances, and between distances for each field type. That's a lot of pairwise comparisons because there are 3 field types and 4 distances. contrast(emm, "pairwise", by = "distance", adjust = "mvt") #> distance = 50m: #> contrast ratio SE df null z.ratio p.value #> not sown / grassland 0.2453 0.0759 Inf 1 -4.541 not sown / production 0.2364 0.0729 Inf 1 -4.677 grassland / production 0.9636 0.1855 Inf 1 -0.192 0.9793 #> #> distance = 75m: #> contrast ratio SE df null z.ratio p.value #> not sown / grassland 0.1475 0.0527 Inf 1 -5.359 not sown / production 0.0789 0.0273 Inf 1 -7.333 grassland / production 0.5351 0.0849 Inf 1 -3.942 0.0002 #> #> distance = 150m: #> contrast ratio SE df null z.ratio p.value #> not sown / grassland 0.3265 0.0940 Inf 1 -3.887 0.0003 #> not sown / production 0.1322 0.0352 Inf 1 -7.606 grassland / production 0.4050 0.0686 Inf 1 -5.339 #> distance = 200m: #> contrast ratio SE df null z.ratio p.value #> not sown / grassland 0.0714 0.0223 Inf 1 -8.456 not sown / production 0.0507 0.0157 Inf 1 -9.649 grassland / production 0.7097 0.0748 Inf 1 -3.255 0.0028 #> #> P value adjustment: mvt method for 3 tests #> Tests are performed on the log scale contrast(emm, "revpairwise", by = "Field_Type", adjust = "mvt") #> Field_Type = not sown: #> contrast ratio SE df null z.ratio p.value #> 75m / 50m 0.692 0.300 Inf 1 -0.848 0.8307 #> 150m / 50m 1.231 0.460 Inf 1 0.556 0.9446 #> 150m / 75m 1.778 0.741 Inf 1 1.381 0.5100 #> 200m / 50m 0.846 0.347 Inf 1 -0.408 0.9770 #> 200m / 75m 1.222 0.549 Inf 1 0.446 0.9702 #> 200m / 150m 0.688 0.269 Inf 1 -0.957 0.7731 #> #> Field_Type = grassland: #> contrast ratio SE df null z.ratio p.value #> 75m / 50m 1.151 0.216 Inf 1 0.749 0.8749 #> 150m / 50m 0.925 0.183 Inf 1 -0.396 0.9785 #> 150m / 75m 0.803 0.154 Inf 1 -1.142 0.6587 #> 200m / 50m 2.906 0.463 Inf 1 6.698 200m / 75m 2.525 0.382 Inf 1 6.121 200m / 150m 3.143 0.515 Inf 1 6.982 #> Field_Type = production: #> contrast ratio SE df null z.ratio p.value #> 75m / 50m 2.073 0.340 Inf 1 4.440 150m / 50m 2.200 0.358 Inf 1 4.848 150m / 75m 1.061 0.139 Inf 1 0.457 0.9676 #> 200m / 50m 3.945 0.596 Inf 1 9.092 200m / 75m 1.904 0.220 Inf 1 5.565 200m / 150m 1.793 0.203 Inf 1 5.148 #> P value adjustment: mvt method for 6 tests #> Tests are performed on the log scale Finally, the distances are ordered (though the model ignores this fact), so we might not be interested in all possible pairwise distance comparisons. Here is how to look at "successive" distance pairs only; since we make fewer comparisons we apply smaller multiple comparison adjustment. This is reasonable if we believe (a priori) that the relationship between abundance rate and distance is monotonic. contrast(emm, method = list( "75m - 50m" = c(-1, 1, 0, 0), "150m - 75m" = c(0, -1, 1, 0), "200m - 150m" = c(0, 0, -1, 1) ), by = "Field_Type", adjust = "mvt" ) #> Field_Type = not sown: #> contrast ratio SE df null z.ratio p.value #> 75m / 50m 0.692 0.300 Inf 1 -0.848 0.7341 #> 150m / 75m 1.778 0.741 Inf 1 1.381 0.3805 #> 200m / 150m 0.688 0.269 Inf 1 -0.957 0.6607 #> #> Field_Type = grassland: #> contrast ratio SE df null z.ratio p.value #> 75m / 50m 1.151 0.216 Inf 1 0.749 0.7859 #> 150m / 75m 0.803 0.154 Inf 1 -1.142 0.5217 #> 200m / 150m 3.143 0.515 Inf 1 6.982 #> Field_Type = production: #> contrast ratio SE df null z.ratio p.value #> 75m / 50m 2.073 0.340 Inf 1 4.440 150m / 75m 1.061 0.139 Inf 1 0.457 0.9429 #> 200m / 150m 1.793 0.203 Inf 1 5.148 #> P value adjustment: mvt method for 3 tests #> Tests are performed on the log scale R code to simulate a dataset and reproduce the analysis: library("emmeans") library("glmmTMB") library("tidyverse") set.seed(1234) params % mutate( Field_Type = factor(Field_Type, levels = c("not sown", "grassland", "production") ), distance = factor(distance, levels = c("50m", "75m", "150m", "200m") ) ) params OWL6 % mutate( re = rnorm(n(), sd = 0.1) ) %>% crossing( sampling.round = 1:3 ) %>% mutate( Abundace = rpois(n(), exp(log(rate) + re)) ) model1 % ggplot( aes(distance, rate, group = Field_Type, color = Field_Type ) ) + geom_point( aes(distance, rate, group = Field_Type), position = position_nudge(x = 0.1), data = params, inherit.aes = FALSE, shape = 4 ) + geom_pointrange( aes( ymin = asymp.LCL, ymax = asymp.UCL ), size = 0.1 ) + facet_grid( ~Field_Type ) + theme( legend.position = "none" )
