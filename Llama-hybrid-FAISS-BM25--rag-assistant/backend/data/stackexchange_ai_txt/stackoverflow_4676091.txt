[site]: stackoverflow
[post_id]: 4676091
[parent_id]: 4675930
[tags]: 
The type of the get overload that you want is: const std::string& (*)(const boost::tuples::cons >&) If you typedef that to get0_fn_t , then you can declare a pointer to this get overload with: get0_fn_t getter_fn = &boost::tuples::get >; EDIT: This program is a complete working example: #include #include #include #include #include #include #include #include int main() { typedef boost::tuple tuple_type; std::vector tuples; tuples.push_back(boost::make_tuple(std::string("test3"), 3)); tuples.push_back(boost::make_tuple(std::string("test0"), 0)); std::vector strings; typedef const std::string& (*get0_fn_t)(const boost::tuples::cons >&); get0_fn_t getter_fn = &boost::tuples::get >; std::transform(tuples.begin(), tuples.end(), std::back_insert_iterator >(strings), getter_fn); std::vector ::const_iterator it, end = strings.end(); for (it = strings.begin(); it != end; ++it) std::cout EDIT2: This shows how to integrate it into the TestClass template: template class TestClass { private: typedef boost::tuple PairType; std::vector storage; public: void extract(std::vector & result) const { result.clear(); typedef const std::string& (*get0_fn_t)(const boost::tuples::cons >&); get0_fn_t getter_fn = &boost::tuples::get >; std::transform(storage.begin(), storage.end(), result.begin(), getter_fn); } };
