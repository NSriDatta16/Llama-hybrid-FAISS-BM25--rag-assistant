[site]: stackoverflow
[post_id]: 5268095
[parent_id]: 
[tags]: 
How does C/C++ know how long a dynamic allocated array is

This question has been bothering me for a while. If I do int* a = new int[n] , for example, I only have an pointer that points to the beginning of array a, but how does C/C++ know about n ? I know if I want to pass this array to another function, then I have to pass the length of the array with it, so I guess C/C++ does not really know how long this array is. I know we can infer the end of a character array char* by looking for the NUL terminator. But is there a similar mechanism for other arrays, like int? Meanwhile, char can be more than a character -- you can also treat it as an integer type. Then how does C++ know where this array ends then? This question starts to bother me even more when I am developing embedded Python (If you are not familiar with embedded python, you may ignore this paragraph and just answer the above questions. I will still appreciate it). In Python there is a "ByteArray", and the only way to convert this "ByteArray" to C/C++ is to use PyString_AsString() to convert it to char*. But if this ByteArray has 0 in it, then C/C++ would think that char* array stops early. This is not the worst part. The worst part is, say I do a char* arr = PyString_AsString(something) void* pt = calloc(1, 1000); if st happens to start with 0, then C/C++ will almost guarantee to wipe out everything in arr, since it thinks arr ends right after a NULL appears. Then it might just wipe out everything in arr by allocating a a trunk of memory to pt. Thank you very much for your time! I really appreciate it.
