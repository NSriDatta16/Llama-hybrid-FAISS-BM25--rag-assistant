[site]: stackoverflow
[post_id]: 814192
[parent_id]: 813693
[tags]: 
To really do it right, you should probably write a descendant class. Override the Paint method to draw the sizing grip, and override the MouseDown , MouseUp , and MouseMove methods to add resizing functionality to the control. I think that's a better solution than trying to draw onto a TPanel in your application code for a couple of reasons: The Canvas property is protected in TPanel , so you have no access to it from outside the class. You can get around that with type-casting, but that's cheating. The "resizability" sounds more like a feature of the panel than a feature of the application, so put it in code for the panel control, not in your application's main code. Here's something to get you started: type TSizablePanel = class(TPanel) private FDragOrigin: TPoint; FSizeRect: TRect; protected procedure Paint; override; procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override; procedure MouseMove(Shift: TShiftState; X, Y: Integer); override; procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override; end; procedure TSizeablePanel.Paint; begin inherited; // Draw a sizing grip on the Canvas property // There's a size-grip glyph in the Marlett font, // so try the Canvas.TextOut method in combination // with the Canvas.Font property. end; procedure TSizeablePanel.MouseDown; begin if (Button = mbLeft) and (Shift = []) and PtInRect(FSizeRect, Point(X, Y)) then begin FDragOrigin := Point(X, Y); // Need to capture mouse events even if the mouse // leaves the control. See also: ReleaseCapture. SetCapture(Handle); end else inherited; end;
