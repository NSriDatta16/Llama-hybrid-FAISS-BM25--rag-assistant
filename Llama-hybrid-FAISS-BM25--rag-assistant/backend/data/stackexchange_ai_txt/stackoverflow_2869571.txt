[site]: stackoverflow
[post_id]: 2869571
[parent_id]: 2869082
[tags]: 
Things to be concerned with regarding this pattern: Breaking Single Responsibility Principle Implementing Functional Decomposition Antipattern Failing to meet common consumer expectations Single Responsibility Principle This is a slight variation on the original principle, but applied instead to functions. If your constructor is doing more than one thing (constructing and processing) you make the maintenance of this method more difficult in the future. If a caller doesn't want to process during construction, you leave him no option. If the "processing" one day requires additional steps that shouldn't be in the constructor, you have to refactor everywhere you use this method. Functional Decomposition Antipattern Without knowing specifics, I'd be concerned that code that does this implements this antipattern. The objects aren't truly objects, but functional programming units wrapped in object oriented disguise. Common consumer expectations Would the average caller expect this behavior of the constructor? There might be places where extra processing during construction can be a short hand programming convenience. But this should be explicitly documented and well understood by the callers. The overall use of the object should still make sense in this context and it should be natural for the caller to use it in this fashion. Also understand what you are forcing on your consumer. If you are doing processing in the constructor, you are forcing the consumer to pay for that processing (in terms of processing time) whether they want it or not. You eliminate the possibility of doing "lazy" processing or other forms of optimization. Acceptable usage? Only in places where common use of the class requires initialization that can be optional at construction time. The File class is a good example: /* This is a common usage of this class */ File f; f.Open(path); /* This constructor constructs the object and puts it in the open state in one step * for convenience */ File f(path); But even this is questionable. Does the file class keep the path to the file internally or is it just used to open a file handle? If it does store the file path, now Open() and the new constructor have more than one responsibility ( SetPath(p) and Open() ). In that case, maybe the File(path) convenience constructor shouldn't open the file, but should rather just set the path in the object. There are lots of considerations based on the objects in question. Consider writing unit tests for your objects. They will help you work out a lot of these use case issues.
