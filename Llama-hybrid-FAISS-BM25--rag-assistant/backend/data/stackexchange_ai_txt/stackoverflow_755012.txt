[site]: stackoverflow
[post_id]: 755012
[parent_id]: 755005
[tags]: 
Oracle themselves have a little snippet page on how it works here . Basically, the JRE doesn't trust the JDK. That's because it has no knowledge of which JDK compiler created the class file. It treats the class file as hostile until verified. Expanding on that, the bytecode verification is a necessary step to protect from what Sun call a "hostile compiler". Sun's own Java compiler ensures that Java source code doesn't violate the safety rules but, when an application imports a code fragment, it doesn't actually know if the code fragment follows Java language rules for safety. In other words, the code may not have been produced by a trustworthy Java compiler. In that case, the Java run time system on your machine has to assume the fragment is bad and subjects it to bytecode verification. The Java virtual machine does not even see the bytecode until it's been through this verification process. Doing this as the bytecode is loaded also has the advantage that a whole lot of run time checks don't need to be performed every time the code is executed. Because it's been verified as correct, it can, once it starts running, run faster than would otherwise be possible. A rendition of the linked diagram is below: >> \ +---------------+ +-------------------+ | Java source | +--> | Class loader | --+ +---------------+ | | Bytecode verifier | | | | +-------------------+ | V | / | +---------------+ | \ V | Java compiler | Network / +-------------------+ +---------------+ | \ | JVM/JIT | | | / +-------------------+ V | \ | +---------------+ | / V | Java bytecode | --+ \ +-------------------+ +---------------+ / | Operating system | \ +-------------------+ / | \ V / +-------------------+ \ | Hardware | / +-------------------+ \ >>
