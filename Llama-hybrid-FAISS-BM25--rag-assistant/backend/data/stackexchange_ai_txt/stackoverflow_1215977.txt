[site]: stackoverflow
[post_id]: 1215977
[parent_id]: 1215953
[tags]: 
When you reference editingViewController , it is equivalent to self->editingViewController , i.e. an access to an ivar. If you want to use a getter or setter, you need to use self.editingViewController , or equivalently [self setEditingViewController:aController] . This is why I prefer to use an ivar with a different name to the property, for example: EditingViewController* i_editingViewController; @property (nonatomic, retain) EditingViewController *editingViewController; @synthesize editingViewController = i_editingViewController; Then you can write your lazy getter as: - (EditingViewController *)editingViewController { // Instantiate the editing view controller if necessary. if (i_editingViewController == nil) { i_editingViewController = [[EditingViewController alloc] init]; } return i_editingViewController; } or - (EditingViewController *)editingViewController { // Instantiate the editing view controller if necessary. if (i_editingViewController == nil) { EditingViewController *aController = [[EditingViewController alloc] init]; self.editingViewController = aController; [aController release]; } return i_editingViewController; } I would probably use the former method (not invoking the setter) because the value of editingViewController (as seen by any observer) has not really changed, but either way should work fine and the different name (for ivar and property) help avoid the confusion or accidental misused. It is also a mild encouragement to use the property (since it avoids the slightly ugly prefix). Note that Apple reserves the _ prefix, and that setters and getters should not be used in the init / dealloc routines.
