[site]: stackoverflow
[post_id]: 5599157
[parent_id]: 5596271
[tags]: 
There is a very simple solution to ensuring that they are instance variables only, which is to use the this keyword in the constructor. var MyObject = { flatAttribute: null, create: function () { var o, F = function () { this.registry = {} }; F.prototype = this; o = new F(); return o; } }; this ensures that all properties of "instance.registry.*" are local to the instance because the lookup order for javascript opjects is as follows. object -> prototype -> parent prototype ... so by adding a variable to the instance in the constructor function named "registry" that will always be found first. another solution, which I think is more elegant is to not use crockford's (java style) constructors and use a layout that reflects javascripts object system more naturally. most of those gotchas are from the misfit between practice and language. // instance stuff var F = function () { this.registry = {} }; F.prototype = { // static attributes here flatAttribute: null, methodA: function(){ // code here 'this' is instance object this.att = 'blah'; } }; var instanceA = new F(); instanceA.registry['A'] = 'hi'; var instanceB = new F(); instanceB.registry['B'] = 'hello'; instanceA.registry.A == 'hi'; // true instanceB.registry.B == 'hello'; // true F.prototype.registry == undefined; // true
