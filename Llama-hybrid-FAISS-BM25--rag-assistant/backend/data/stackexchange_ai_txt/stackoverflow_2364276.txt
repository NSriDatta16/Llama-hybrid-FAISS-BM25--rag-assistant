[site]: stackoverflow
[post_id]: 2364276
[parent_id]: 2364162
[tags]: 
L1 is typically/probably a label , associated with one particular address in memory. The programmer defines various labels for his/her convenience, and such labels are used to symbolically represent a particular location in memory (L1 is a lousy name; labels are typically indicative of the underlying purpose of the location: say, PingCounter, ErrorMessage, Login and the like). A label for 1 byte of static storage is how a C compiler would implement char L1; at global scope. In NASM syntax, mov edi, L1 will assemble to the mov eax, imm32 form of mov , i.e. the label address will become a 32-bit immediate in the machine code. (The assembler doesn't know the final numeric value, but the linker does.) Beware that in MASM syntax, this would be a load and you'd need mov edi, OFFSET L1 to get a label address as an immediate. But mov al, [L1] will assemble to a different instruction, with the 32-bit address embedded in the machine code as an address to be dereferenced. This instruction loads 1 byte from the address L1, and places it in AL. In the assembly language, this indirect addressing mode is signified by square bracketing the source or destination operand of a given instruction. (But not both: x86 only supports at most one explicit memory operand per instruction.) mov al, [L1] uses the address stored in L1, to locate some location in memory and reads 1 byte (= 8 bits = the size of AL register) at this location, and loads it into the AL register. mov [L1], al Does this in reverse. i.e., specifically, read the address stored in L1, use this address to find a particular place in memory and stores the contents of AL register there. Provided that you understand the following information to be incomplete and somewhat outdated with regards to the newer processors in the x86 family, this primer on the 8086 architecture is probably very useful to get one started with Assembly language for the x86 family. The advantage of starting with this "antiquity of a CPU" (still in use, actually), is that the fundamental concepts are all there, unencumbered of the newer sets of registers, fancy addressing modes, modes of operation and other concepts. The bigger sizes, features and modes of the newer CPUs merely introduce a combinatorial explosion of options, all (most?) of them useful in their way, but essentially irrelevant for an initiation.
