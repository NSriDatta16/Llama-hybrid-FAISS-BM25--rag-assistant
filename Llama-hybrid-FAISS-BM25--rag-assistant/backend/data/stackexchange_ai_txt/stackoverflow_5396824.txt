[site]: stackoverflow
[post_id]: 5396824
[parent_id]: 5396465
[tags]: 
You mention "circular dependencies", to be clear, F# will never let you spread circular dependencies across files. If type Foo refers to type Bar and type Bar refers to type Foo , then Foo and Bar must both be defined in the same file in the same type ... and ... group in F#. The issue here is one of organization and navigation, that is mostly about the tooling. The VS solution explorer displays a list of files; folders enable you to 'collapse' groups of files which can make it easier to organize your thoughts or navigate across 'great distances' of many files. However for navigation there are various other tools (Go To Definition, search for text in the current project, ...) to let you navigate to e.g. a particular class definition. (Hopefully these tools will continue to improve for F# in particular, as well as VS in general, in future releases.) In any case, I firmly believe that a "pretty large system of interconnected components (Controller - ViewModel - View, > 300 classes)" is a code smell. If you can't untangle these to have an archetectural layering such that there are portions that do not depend on other portions (and thus could be defined 'first' in a prior file in F#), then you have bigger problems than just "how to organize your F# code". My opinionated view is perhaps best-expressed here . EDIT (2018): meanwhile, the tools have improved, among many other things, go-to-definition, find-all-references, global renaming of identifiers, folder support, file reorganization etc have been added in the past few years. For solutions that require mutual references between classes, namespace rec and module rec have been introduced to limit the need for type ... and ... .
