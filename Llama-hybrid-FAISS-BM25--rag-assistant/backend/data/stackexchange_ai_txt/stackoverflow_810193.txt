[site]: stackoverflow
[post_id]: 810193
[parent_id]: 810129
[tags]: 
Let's assume s and t are char * s that point to strings (and assume s is at least as large as t ). In C, strings all end in 0 (ASCII "NUL"), correct? So what does this do: *s++ = *t++; First, it does *s = *t , copying the value at *t to *s . Then, it does s++ , so s now points to the next character. And then it does t++ , so t points to the next character. This has to do with operator precedence and prefix vs. postfix increment/decrement . Operator precedence is the order in which operators are resolved. For a simple example, look: 4 + 2 * 3 Is this 4 + (2 * 3) or (4 + 2) * 3 ? Well, we know it is the first one because of precedence - the binary * (multiplication operator) has higher precedence than the binary + (addition operator), and is resolved first. In *s++ , we have unary * (pointer dereference operator) and unary ++ (postfix increment operator). In this case, ++ has higher precedence (also said to "bind tighter") than * . If we had said ++*s , we would increment the value at *s rather than the address pointed to by s because prefix increment has lower precedence* as dereference, but we used postfix increment, which has higher precedence. If we had wanted to use prefix increment, we could have done *(++s) , since the parenthesis would have overridden all lower precedences and forced ++s to come first, but this would have the undesirable side effect of leaving an empty character at the beginning of the string. Note that just because it has higher precedence doesn't mean it happens first. Postfix increment specifically happens after the value has been used, which his why *s = *t happens before s++ . So now you understand *s++ = *t++ . But they put it in a loop: while(*s++ = *t++); This loop does nothing - the action is all in the condition. But check out that condition - it returns "false" if *s is ever 0, which means *t was 0, which means they were at the end of the string (yay for ASCII "NUL"). So this loop loops as long as there are characters in t , and copies them dutifully into s , incrementing s and t all the way. When this loop exits, s has been NUL-terminated, and is a proper string. The only problem is, s points to the end. Keep another pointer handy that points to the beginning of s (i.e. s before the while() loop) - that will be your copied string: char *s, *string = s; while(*s++ = *t++); printf("%s", string); // prints the string that was in *t Alternatively, check this out: size_t i = strlen(t); while(*s++ = *t++); s -= i + 1; printf("%s\n", s); // prints the string that was in *t We started by getting the length, so when we ended, we did more pointer arithmetic to put s back at the beginning, where it started. Of course, this code fragment (and all my code fragments) ignore buffer issues for simplicity. The better version is this: size_t i = strlen(t); char *c = malloc(i + 1); while(*s++ = *t++); s -= i + 1; printf("%s\n", s); // prints the string that was in *t free(c); But you knew that already, or you'll soon ask a question on everyone's favorite website about it. ;) * Actually, they have the same precedence, but that's resolved by different rules. They effectively have lower precedence in this situation.
