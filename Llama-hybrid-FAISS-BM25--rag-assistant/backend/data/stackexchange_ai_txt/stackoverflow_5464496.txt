[site]: stackoverflow
[post_id]: 5464496
[parent_id]: 
[tags]: 
Passing a Functor as a param to a method

I have the following two classes that exhibit the Command pattern. (Unfortunately, both have a unique method name.) //pseudocode class Subscriber { virtual void receive(const Event&) = 0; } class Dispatcher { virtual void dispatch(const Event&) = 0; } I have a class template that has a list of some type with a method to iterate over this list. //pseudocode template class Registry { typedef list ObjectList; ObjectList _objects; void iterate(const Event& event) { for_each(_objects.begin(), _objects.end(), ...); //not sure what to do here } } I would like to use mem_fun to create a Functor that calls receive or dispatch as appropriate. I'm able to create a simple use case where I simply invoke a method without any params. I.e. //pseudocode class Simple { void simple() {/*...*/} } and then I iterate: for_each(_objects.begin(), _objects.end(), mem_fun(&Simple::simple); Unfortunately, I have no idea how to get the event param passed to mem_fun. Looking at the headers, it does appear that I can pass a single param, but I'm not well versed in C++ to understand what I need to do. Ultimately, I would like to make the iterate method accept a type of functor so it will fire that method on every method in the list. I would prefer to avoid Boost...I think this is entirely possible without dragging this framework into the mix. Thanks!
