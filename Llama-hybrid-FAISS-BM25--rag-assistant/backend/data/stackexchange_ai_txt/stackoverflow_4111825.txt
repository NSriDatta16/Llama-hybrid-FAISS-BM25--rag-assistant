[site]: stackoverflow
[post_id]: 4111825
[parent_id]: 4103408
[tags]: 
Some (partial) suggestions: The error you get with is probably due to the short_open_tags set to ON in php.ini. When the PHP interpreter reaches the it understands it as the start of a PHP code block and then throws an error because the next statements are not recognized as PHP. You can change the setting to OFF in php.ini or using ini_set() at the start of the file. Another way around this is to output the separately from the rest, as in: print ' Next to this I see you're sending SET NAMES ut8 after you've already issued the SELECT statement. This way it has no effect at all on the connection settings relative to the SELECT query. SET NAMES should indeed be the very first statement issued, before any INSERT or SELECT . This also assumes that the data that went into the database were UTF-8 to start with. Seeing that the database uses MySQL's factory default charset and collation I suspect that whoever set up the system didn't think about character sets at all, so the UTF-8 assumption might well be wrong. What you should do is check in detail the script that wrote the original data into the database. If there is a SET NAMES in that script you should use one too when reading the records, if there's not you should avoid it - otherwise you are causing the very charset mismatch you're trying to avoid. Speaking in general terms you can think of the database as a black box storage engine: as long as you aren't doing string manipulation inside your SQL code the database will return to you exactly the sequence of bytes that was inserted to it. Plain INSERTs and SELECTs don't care if the bytes they're moving are ASCII, ISO -* or multibyte, they're just blind movers. Thus what you're supposed to use when reading the db are the very same settings used when writing the records: this way you'd get the very same byte sequence originally stored. The last thing to discover is what character set the data originally stored were. If the data came from a web page form you should check that page, specifically its character set. Browsers have a function to show this (in Firefox: menu View -> Character Encoding, in IE View -> Encoding). When in doubt check the page source for an explicit declaration like AND the HTTP headers for a header like Content-TYpe: text/html; charset=xxx . If both are present and do not match the HTTP header wins. The last resource (because it's definitely heavy on the server) is to check the stings returned from the database with mb_detect_encoding() and use this as an input to iconv() to convert it into UTF-8: setlocale(LC_ALL, "en_US.utf8"); /* or any other locale with 'utf8' in it */ $output = iconv(mb_detect_encoding($input), "UTF-8//IGNORE//TRANSLIT", $input); Hope this helps.
