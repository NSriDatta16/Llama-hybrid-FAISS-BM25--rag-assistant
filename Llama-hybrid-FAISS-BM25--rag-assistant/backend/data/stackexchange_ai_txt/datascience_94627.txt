[site]: datascience
[post_id]: 94627
[parent_id]: 
[tags]: 
Help in KERAS, a model.fit method on a array 50x50 slows the system, how can I make it faster?

i m a new member and i am a student. i have a problem. how can I make this training faster my neural network ? when I call the fit method on a 100 x 100 matrix goes very slow my model it's a sequential def build_model(env, **opt): loss = opt.get('loss', 'mse') a = opt.get('alpha', 0.24) model = Sequential() esize = env.maze.size model.add(Dense(esize, input_shape=(esize,))) model.add(LeakyReLU(alpha=a)) model.add(Dense(esize)) model.add(LeakyReLU(alpha=a)) model.add(Dense(num_actions)) model.compile(optimizer='adam', loss='mse') return model this is my Experience Class def __init__(self, model, max_memory=100, discount=0.97): self.model = model self.max_memory = max_memory self.discount = discount self.memory = list() self.num_actions = model.output_shape[-1] def remember(self, episode): # episode = [env_state, action, reward, next_env_state, game_over] # memory[i] = episode # env_state == flattened 1d maze cells info, including agent cell (see method: observe) self.memory.append(episode) if len(self.memory) > self.max_memory: del self.memory[0] def predict(self, env_state): return self.model.predict(env_state)[0] def get_data(self, data_size=10): env_size = self.memory[0][0].shape[1] # env_state 1d size (1st element of episode) mem_size = len(self.memory) data_size = min(mem_size, data_size) inputs = np.zeros((data_size, env_size)) targets = np.zeros((data_size, self.num_actions)) for i, j in enumerate(np.random.choice(range(mem_size), data_size, replace=False)): env_state, action, reward, next_env_state, game_over = self.memory[j] inputs[i] = env_state # There should be no target values for actions not taken. # Thou shalt not correct actions not taken #deep (quote by Eder Santana) targets[i] = self.predict(env_state) # Q_sa = derived policy = max quality env/action = max_a' Q(s', a') Q_sa = np.max(self.predict(next_env_state)) if game_over: targets[i, action] = reward else: # reward + gamma * max_a' Q(s', a') targets[i, action] = reward + self.discount * Q_sa return inputs, targets when i call model.fit , the system speed slows h = self.model.fit( inputs, targets, epochs = epochs, batch_size=16, verbose=0, ) the matrix that i step to it is n = 50 def build(n): mat=np.ones(n*n) return mat.reshape((n,n)) should I modify the template by adding more Danse layers? I donâ€™t know how to improve the performance because I would like to call it on a 100x100 matrix
