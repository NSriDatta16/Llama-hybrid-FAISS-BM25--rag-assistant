[site]: stackoverflow
[post_id]: 1911819
[parent_id]: 1911794
[tags]: 
When I write this kind of software, my VMs never have a reference in any way to the data model. When you couple them like this, you are pretty much married to a simple two-tier solution which can be really tough to break out. If you disconnect the DataContext entirely from your VM and have them live on their own, your application becomes: Much more testable -- your VMs can be tested without the datacontext Potentially stateless at the data layer -- it's easy to change your architecture to adopt a stateless 3-tier based solution. Able to easily integrate other data sources -- your VMs can elegantly contain aggregates and combinations of other data sources on their own. So in short, yes, I would recommend decoupling the data access classes from the ViewModel objects throughout the app. It might be a bit more code, but it will pay dividends down the road with the architecture's flexibility. EDIT: I don't use the change tracking features of the L2SQL objects once they've crossed a distribution boundary. That turns into a can of worms pretty quickly -- you can spend a lot of time with the care and feeding of your data model's object graph inside your viewmodel - which adds not only complexity to the ViewModel, but at least transitively couples the ViewModel to the schema of the database. Instead of doing that, I make the ViewModel pure. When the time comes for them to be persisted, your service layer/repository/whatever does the translation between the ViewModel and the data objects. This at first seems like a lot of work, but for anything other than simple CRUD, this design pays off pretty quickly.
