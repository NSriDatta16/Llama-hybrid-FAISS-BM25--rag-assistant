[site]: stackoverflow
[post_id]: 1518443
[parent_id]: 1515412
[tags]: 
Thanks to Alex Martelli, you have the best possible solution: def theFinalAndTrulyRealProblemAsPosed(argsList): items = iter(argsList) output = next(items, []) * 4 for item in items: output += item * 4 return output This is beautiful and elegant. First we create an iterator with iter() , then we use next() to get the first object in the list. Then we accumulate as we iterate through the rest of the list, and we are done. We never need to know the type of the objects in argsList, and indeed they can be of different types as long as all the types can have operator + applied with them. This is duck typing. For a moment there last night I was confused and thought that you wanted a function that, instead of taking an explicit list, just took one or more arguments. def four_x_args(*args): return theFinalAndTrulyRealProblemAsPosed(args) The *args argument to the function tells Python to gather up all arguments to this function and make a tuple out of them; then the tuple is bound to the name args . You can easily make a list out of it, and then you could use the .pop(0) method to get the first item from the list. This costs the memory and time to build the list, which is why the iter() solution is so elegant. def four_x_args(*args): argsList = list(args) # convert from tuple to list output = argsList.pop(0) * 4 for arg in argsList: output += arg * 4 return output This is just Wooble's solution, rewritten to use *args. Examples of calling it: print four_x_args(1) # prints 4 print four_x_args(1, 2) # prints 12 print four_x_args('a') # prints 'aaaa' print four_x_args('ab', 'c') # prints 'ababababcccc' Finally, I'm going to be malicious and complain about the solution you accepted. That solution depends on the object's base class having a sensible null or zero, but not all classes have this. int() returns 0 , and str() returns '' (null string), so they work. But how about this: class NaturalNumber(int): """ Exactly like an int, but only values >= 1 are possible. """ def __new__(cls, initial_value=1): try: n = int(initial_value) if n = 1" return super(NaturalNumber, cls).__new__ (cls, n) argList = [NaturalNumber(n) for n in xrange(1, 4)] print theFinalAndTrulyRealProblemAsPosed(argList) # prints correct answer: 24 print NaturalNumber() # prints 1 print type(argList[0])() # prints 1, same as previous line print multiplyItemsByFour(argList) # prints 25! Good luck in your studies, and I hope you enjoy Python as much as I do.
