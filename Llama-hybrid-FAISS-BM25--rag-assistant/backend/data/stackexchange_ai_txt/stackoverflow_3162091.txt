[site]: stackoverflow
[post_id]: 3162091
[parent_id]: 3162048
[tags]: 
Yes, C defines sizeof(char) to be 1, always (and C++ does as well). Nonetheless, as a general rule, I'd advise something like: char *ptr = malloc(256 * sizeof(*ptr)); This way, when your boss says something like: "Oh, BTW we just got an order from China so we need to handle all three Chinese alphabets ASAP", you can change it to: wchar_t *ptr // ... and the rest can stay the same. Given that you're going to have about 10 million headaches trying to handle i18n even halfway reasonably, eliminating even a few is worthwhile. That, of course, assumes the usual case that your char s are really intended to hold characters -- if it's just a raw buffer of some sort, and you really want 256 bytes of storage, regardless of how many (of few) characters that may be, you should probably stick with the malloc(256) and be done with it.
