[site]: stackoverflow
[post_id]: 583114
[parent_id]: 583063
[tags]: 
I'm not clear on what you're asking. But I'll try, assuming that You have a single buffer You have an array of pointers of some kind which has been processed in some way so that some or all of its contents point into the buffer That is code equivalent to: char *buf = (char*)malloc(sizeof(char)*bufsize); for (int i=0; i Now if you control the allocation of the buffer, you could substitute char *buf = (char*)malloc(sizeof(char)*(bufsize+1)); buf[bufsize]='\0'; and go ahead using strcmp. This may be possible even if you don't control the filling of the buffer. If you have to live with a buffer handed you by someone else you can Use some global storage (which you asked to avoid and good thinking). Hand the sort function something more complicated than a raw pointer (the address of a struct or class that supports the extra data). For this you need to control the deffinition of ary in the above code. Use a sort function which supports an extra input. Either sort_r as suggested by Adam , or a home-rolled solution (which I do recommend as an exercise for the student, and don't recommend in real life). In either case the extra data is probably a pointer to the end of the buffer.
