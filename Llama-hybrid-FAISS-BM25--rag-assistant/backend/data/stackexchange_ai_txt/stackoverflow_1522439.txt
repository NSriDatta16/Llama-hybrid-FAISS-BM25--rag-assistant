[site]: stackoverflow
[post_id]: 1522439
[parent_id]: 1522338
[tags]: 
As already noted in comments; note that the example given is susceptible to issues with captured variables if used asynchronously - but probably OK "as is". To do it thoroughly involves a lot of edge-cases (or you can cheat and use Compile() ) - but here's an example that shows the overall themes (without using Compile ): using System; using System.Linq.Expressions; using System.Reflection; class Program { static void Main() { string[] arr = { "abc", "def" }; for (int i = 0; i arr[i]); } } static object Foo (Expression > lambda) { object obj = Walk(lambda.Body); Console.WriteLine("Value is: " + obj); return obj; } static object Walk(Expression expr) { switch (expr.NodeType) { case ExpressionType.ArrayIndex: BinaryExpression be = (BinaryExpression)expr; Array arr = (Array)Walk(be.Left); int index = (int) Walk(be.Right); Console.WriteLine("Index is: " + index); return arr.GetValue(index); case ExpressionType.MemberAccess: MemberExpression me = (MemberExpression)expr; switch (me.Member.MemberType) { case MemberTypes.Property: return ((PropertyInfo)me.Member).GetValue(Walk(me.Expression), null); case MemberTypes.Field: return ((FieldInfo)me.Member).GetValue(Walk(me.Expression)); default: throw new NotSupportedException(); } case ExpressionType.Constant: return ((ConstantExpression) expr).Value; default: throw new NotSupportedException(); } } }
