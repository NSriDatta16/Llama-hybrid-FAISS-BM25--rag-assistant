[site]: stackoverflow
[post_id]: 5036132
[parent_id]: 5036029
[tags]: 
I'd define a role based schema too. First, let's create a class for user credentials: class CUserCredentials { public $orgID, $ordSubID, $password; // or protected instance variables an accessors } // CUserCredentials In our case, users identify by an organisational ID [a company number], a number relative to it orgID [e.g. his employee number] and a password. The process, of testing credentials against a certain role gets encapsulated by an abstract class: class CAbstractRoleVerifier { // return public static function hasRoleUsingUserCredentials( CUserCredentials $cred ); } The method hasRoleUsingUserCredentials() verifies credentials against 'whatever', e.g. a database table. Then we define an abstract role manager, which is the template for a specific implementation: class CAbstractRoleManager { static protected $possibleRoles; // The standard role protected $primaryRole; // The other roles he is able to use protected $userrRoles; // verifies all defined roles public function verifyAllRoles( CUserCredentials $cred ); } While the above class is part of our framework, our application needs to implement a concrete Role Manager, e.g. like this: class CMyRoleManager extends CAbstractRoleManager { // these two are nomal roles const ROLE_USER = 1; const ROLE_MANAGER = 2; // this is a special role, which allows to const ROLE_ADMIN = 3; protected $userRoles; public function __construct() { // prepare CMyRoleVerifierUser, CMyRoleVerifierManager as subclasses of the // above class self::$possibleRoles = array( self::ROLE_USER => new CMyRoleVerifierUser(), self::ROLE_USER => new CMyRoleVerifierManager(), self::ROLE_ADMIN => new CMyRoleVerifierAdmin(), ); // Initially, user has no role $this->userRoles = array(); $this->mainRole = FALSE; } public function verifyAllRoles( CUserCredentials $cred ) { foreach( self::$possibleRoles as $roleID => $verifier ) { if ( $verifier->hasRoleUsingUserCredentials( $cred ) ) { $this->userRoles[ $roleID ] = $roleID; } } } public function hasRole( $aRoleID ) { return isset( $this->userRoles[ $roleID ] ); } } Note, how the process of verifying the role set and the process of of verifying a specific role are separated in different classes. While one could use a class / subclass design, I prefer this design. It allows to keep a set of roles, which might have whatever relation, not only a ROLE_MANAGER is allowed to to all of ROLE_USER plus some other operations. In my case, ROLE_ADMIN is a special role. If user verifies against ROLE_ADMIN, he sees certain administrative features enabled. Besides other special operations, he is allowed to temporarily behave as if he is the other role. $this->mainRole not fully implemented here
