[site]: stackoverflow
[post_id]: 2557613
[parent_id]: 2547713
[tags]: 
Let's try a different way to explain this... This is the sequence the JVM goes through when you first reference the class MyClass . Load the byte-code into memory. Memory for the static storage is cleared (binary zero). Initialize the class: Execute each static initializer in the order that it appears, this includes static variables and static { ... } blocks. JVM then initializes your myClass static variable to a new instance of MyClass . When this happens, the JVM notices that MyClass is already loaded (byte-code) and in the process of being initialized , so it skips initialization. Allocate memory on heap for object. Execute constructor. Print out value of obj which is still null (since it is not part of the heap and constructor initialized variables). When constructor finishes, execute next static initializer which sets obj to a new instance of Object . Class initialization done. From this point, all constructor calls will behave as you presume/expect - that is obj would not be null but a reference to an Object instance. Remember that Java specifies that a final variable is assigned a value once. It is not that it is guaranteed to be assigned a value when the code references it unless you ensure that the code references it after it is assigned. This is not a bug. This is the defined way to handle usage of the class during its own initialization. If this were not so, then the JVM would go into an infinite loop. See step #3.3 (if the JVM does not skip initialization for a class that is in the process of initialization it would just keep initializing it - infinite loop). Note as well, this all happens on the same thread that first references the class. Second, the JVM guarantees that initialization will complete before any other thread is allowed to use this class.
