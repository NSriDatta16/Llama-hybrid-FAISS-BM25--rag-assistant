[site]: stackoverflow
[post_id]: 4956051
[parent_id]: 4955740
[tags]: 
In your code, you're not associating a state with the state machine the state belongs to (assuming that class A is the state machine). This information is passed in to the action method. So, if you had two instances of class A (i.e. two state machines) then you could end up having a state update the wrong state machine. If you're doing this to avoid repeated calls to new and delete for speed purposes, then this is probably a premature optimisation. A better solution, if you can show that using new and delete is too slow / causes other issues (memory fragmentation for example), is to define an operator new / delete in the State base class that allocates from its own memory pool. Here's some pseudocode for how the state machine I'm currently using works: class StateMachine { public: SetState (State state) { next_state = state; } ProcessMessage (Message message) { current_state->ProcessMessage (message); if (next_state) { delete current_state; current_state = next_state; next_state = 0; } } private: State current_state, next_state; } class State { public: State (StateMachine owner) { m_owner = owner; } virtual ProcessMessage (Message message) = 0; void *operator new (size_t size) // allocator { return memory from local memory pool } void operator delete (void *memory) // deallocator { put memory back into memory pool } protected: StateMachine m_owner; }; class StateA : State { public: StateA (StateMachine owner) : State (owner) {} ProcessMessage (Message message) { m_owner->SetState (new StateB (m_owner)); } } The memory pool could be an array of chunks of memory, each big enough to hold any State, with a pair of lists, one for the allocated blocks and one for the unallocated blocks. Allocating a block then becomes a process of removing a block from the unallocated list and adding it to the allocated list. Freeing is then the reverse process. I think the term 'free list' for this type of allocation strategy. It is very fast but has some wasted memory.
