[site]: stackoverflow
[post_id]: 1602757
[parent_id]: 1595959
[tags]: 
My first inclination to is try branch-and-bound. You can do it breadth-first or depth-first, and I prefer depth-first because I think it's cleaner. To express it simply, you have a tree-walk procedure walk that can enumerate all possibilities (maybe it just has a 5-level nested loop). It is augmented with two things: At every step of the way, it keeps track of the cost at that point, where the cost can only increase. (If the cost can also decrease, it becomes more like a minimax game tree search.) The procedure has an argument budget , and it does not search any branches where the cost can exceed the budget. Then you have an outer loop: for (budget = 0; budget The amount of time it takes is exponential in the budget, so easier cases will take less time. The fact that you are re-doing the search doesn't matter much because each level of the budget takes as much or more time than all the previous levels combined. Combine this with some sort of heuristic about the order in which you consider branches, and it may give you a workable solution for typical problems you give it. IF that doesn't work, you can fall back on basic heuristic programming. That is, do some cases by hand, and pay attention to how you did it. Then program it the same way. I hope that helps.
