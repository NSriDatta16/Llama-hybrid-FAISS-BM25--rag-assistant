[site]: stackoverflow
[post_id]: 2667241
[parent_id]: 137783
[tags]: 
I know it has been answered, but is this seems to work ok, but I can not tell you if it has a bias. My 'testing' suggests it is, at least, reasonable. Perhaps Adam Rosenfield would be kind enough to comment? My (naive?) idea is this: Accumulate rand5's until there is enough random bits to make a rand7. This takes at most 2 rand5's. To get the rand7 number I use the accumulated value mod 7. To avoid the accumulator overflowing, and since the accumulator is mod 7 then I take the mod 7 of the accumulator: (5a + rand5) % 7 = (k*7 + (5a%7) + rand5) % 7 = ( (5a%7) + rand5) % 7 The rand7() function follows: (I let the range of rand5 be 0-4 and rand7 is likewise 0-6.) int rand7(){ static int a=0; static int e=0; int r; a = a * 5 + rand5(); e = e + 5; // added 5/7ths of a rand7 number if ( e Edit: Added results for 100 million trials. 'Real' rand functions mod 5 or 7 rand5 : avg=1.999802 0:20003944 1:19999889 2:20003690 3:19996938 4:19995539 rand7 : avg=3.000111 0:14282851 1:14282879 2:14284554 3:14288546 4:14292388 5:14288736 6:14280046 My rand7 Average looks ok and number distributions look ok too. randt : avg=3.000080 0:14288793 1:14280135 2:14287848 3:14285277 4:14286341 5:14278663 6:14292943
