[site]: stackoverflow
[post_id]: 1093280
[parent_id]: 1069285
[tags]: 
Thanks for the response, I got the general idea, however setting the IsSelected to true didn't work the way I expected, when that hit it would cause the row to become selected but not unselect the other row (in the cases it should have). I was able to get around the issue by calling the HandleSelectionForCellInput in my handler. Then I just call the Lambda created from below with the grid and cell, works perfectly. public static Action CreateSelectRowMethod(bool allowExtendSelect, bool allowMinimalSelect) { var selectCellMethod = typeof(DataGrid).GetMethod("HandleSelectionForCellInput", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic); ParameterExpression dataGrid = Expression.Parameter(typeof(DataGrid), "dataGrid"); ParameterExpression paramCell = Expression.Parameter(typeof(DataGridCell), "cell"); ParameterExpression paramStartDragging = Expression.Parameter(typeof(bool), "startDragging"); var paramAllowsExtendSelect = Expression.Constant(allowExtendSelect, typeof(bool)); var paramAllowsMinimalSelect = Expression.Constant(allowMinimalSelect, typeof(bool)); var call = Expression.Call(dataGrid, selectCellMethod, paramCell, paramStartDragging, paramAllowsExtendSelect, paramAllowsMinimalSelect); return (Action )Expression.Lambda(call, dataGrid, paramCell, paramStartDragging).Compile(); }
