[site]: stackoverflow
[post_id]: 2901858
[parent_id]: 2901803
[tags]: 
Elegance is in the eye of the beholder, however do remember pointer/iterator arithmetics :) for (FooVecIter i = fooVec.begin(); i != fooVec.end(); ++i) { Foo& foo = *i; if (foo.somethingIsTrue()) // True for most elements std::cout The up-side compared to the distance method is that you won't mistakenly do this for a non-random_access_iterator, so you'll always be in O(1) .
