[site]: stackoverflow
[post_id]: 595561
[parent_id]: 595231
[tags]: 
It's not the UI that needs to be modeled as a state machine; it's the objects being displayed that it can be helpful to model as state machines. Your UI then becomes (oversimplification) a bunch of event handlers for change-of-state in the various objects. It's a change from: DoSomethingToTheFooObject(); UpdateDisplay1(); // which is the main display for the Foo object UpdateDisplay2(); // which has a label showing the Foo's width, // which may have changed ... to: Foo.DoSomething(); void OnFooWidthChanged() { UpdateDisplay2(); } void OnFooPaletteChanged() { UpdateDisplay1(); } Thinking about what changes in the data you are displaying should cause what repainting can be clarifying, both from the client UI side and the server Foo side. If you find that, of the 100 UI thingies that may need to be repainted when Foo's state changes, all of them have to be redrawn when the palette changes, but only 10 when the width changes, it might suggest something about what events/state changes Foo should be signaling. If you find that you have an large event handler OnFooStateChanged() that checks through a number of Foo's properties to see what has changed, in an attempt to minimize UI updates, it suggests something about the granularity of Foo's event model. If you find you want to write a little standalone UI widget you can use in multiple places in your UI, but that it needs to know when Foo changes and you don't want to include all the code that Foo's implementation brings with it, it suggests something about the organization of you data relative to your UI, where you are using classes vs interfaces, etc.... Fundamentally, it makes you think more seriously about what is your presentation layer, more seriously than "all the code in my form classes". -PC
