[site]: stackoverflow
[post_id]: 4661573
[parent_id]: 4645706
[tags]: 
Now I want to take that one step further and learn assembly language Is that really a step further, or a step backward? Arguably it is a path to deeper understanding, put it is hardly a path to greater productivity. There is no one "assembly language", each processor architecture has its own instruction set so learning an assembly language will equip you only to program that particular target (although it will also give you general skills in low level programming and understanding how the processor works). The code you generate will also be specific to one architecture so all your effort and investment in code will be far less portable than in a high level language. If ultimately the architecture you choose becomes obsolete (and there are many that have), you assembly skills for that architecture become largely redundant knowledge apart from the general skills it may provide (it will be faster to learn the a new instruction set and architecture). Unless you are going to be doing a lot of assembler and become highly proficient at a particular instruction set (and have a strong justification for doing so), learning assembler at all has limited value. It is useful if you are implementing start-up code to initialise a processor and establishing the run-time environment for your C or C++ code, but that may be largely provided by the chip or tool vendor and you do not need a full undestanding of an architectire or instruction set to use or adapt such code. One often suggested argument for using assembler is performance, but in general an optimising compiler will generate code nearly as or nearly as efficient as an expert assembly programmer, and most often more efficient than a less than proficient one. You see the compiler is essentially an expert system as far as the target instruction set and architecture is concerned. It generally knows every available instruction and thier execution times, every register, every addressing mode, and understands the pipelining, caching, and branch prediction mechanisms etc. On a moderatley complex processor the compilers expertise will outgun all but the most dedicated full-time assembler programmers, and on simple processors there is far less to be gained either way. One area where assembler may be useful is in utilising aspects of some processors that the compiler or its library may not touch. It is common for example to use assembler on DSP processors, but even there the use of optimised DSP libraries (generally themselves written in assembler), or compiler extensions or language idioms that the compiler recognizes and can optimise make this largely unnecessary, and learning a DSP instruction set with SIMD and parallel-execution capabilities is a significant investment. The last time I needed used assembler other than C runtime start-up code, was when porting code from one ARM defice to a new one with a VFP co-processor; although the recompiled library made use of the VFP, the sqrt() function was implemented using a convergance algorithm rather than the hardware sqrt instruction. One function, one or two lines of assembly; I certainly did not need to learn the ARM instruction set to get that far. The only assemby languages I have learned in detail are Z80 and 8051. That was a long time ago, and I hve forgotton it all, and the knowledge is now largely obsolete. However the general skills learned do allow me to tweak systems and do board bring-up as already described, but as some one who recruits aother embedded systems developers, I would not pay that much attention to a candidated assembly skills. I think with assembly language you either need tourist/phrase-book level knowledge to just get by when you need to, or speak-it-like-a-native so that your skills have real value, anything in-between has little value. That said, if you must, or feel the need, I suggest as ARM Cortex M3 device. Unlikely to become obsolete any time soon (devices from multiple licensee vendors), and sufficiently complex and nodern to give you a good grounding for other architectures.
