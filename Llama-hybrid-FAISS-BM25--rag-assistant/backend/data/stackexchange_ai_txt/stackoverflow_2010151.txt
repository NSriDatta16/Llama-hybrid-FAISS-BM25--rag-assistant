[site]: stackoverflow
[post_id]: 2010151
[parent_id]: 1983047
[tags]: 
Some good rules of thumbs imho: Consult with HLint to make sure you don't have redundant braces and that your code isn't pointlessly point-full. Avoid recreating existing library functions. Hoogle can help you find them. Often times existing library functions are more general than what one was going to make. For example if you want Maybe (Maybe a) -> Maybe a , then join does that among other things. Argument naming and documentation is important sometimes. For a function like replicate :: Int -> a -> [a] , it's pretty obvious what each of the arguments does, from their types alone. For a function that takes several arguments of the same type, like isPrefixOf :: (Eq a) => [a] -> [a] -> Bool , naming/documentation of arguments is more important. If one function exists only to serve another function, and isn't otherwise useful, and/or it's hard to think of a good name for it, then it probably should exist in it's caller's where clause instead of in the module's scope. DRY Use Template-Haskell when appropriate. Bundles of functions like zip3 , zipWith3 , zip4 , zipWith4 , etc are very meh. Use Applicative style with ZipList s instead. You probably never really need functions like those. Derive instances automatically. The derive package can help you derive instances for type-classes such as Functor (there is only one correct way to make a type an instance of Functor ). Code that is more general has several benefits: It's more useful and reusable. It is less prone to bugs because there are more constraints. For example if you want to program concat :: [[a]] -> [a] , and notice how it can be more general as join :: Monad m => m (m a) -> m a . There is less room for error when programming join because when programming concat you can reverse the lists by mistake and in join there are very few things you can do. When using the same stack of monad transformers in many places in your code, make a type synonym for it. This will make the types shorter, more concise, and easier to modify in bulk. Beware of "lazy IO". For example readFile doesn't really read the file's contents at the moment the file is read. Avoid indenting so much that I can't find the code. If your type is logically an instance of a type-class, make it an instance. The instance can replace other interface functions you may have considered with familiar ones. Note: If there is more than one logical instance, create newtype-wrappers for the instances. Make the different instances consistent. It would have been very confusing/bad if the list Applicative behaved like ZipList .
