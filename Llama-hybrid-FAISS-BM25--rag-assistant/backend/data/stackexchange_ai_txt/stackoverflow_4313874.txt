[site]: stackoverflow
[post_id]: 4313874
[parent_id]: 4313773
[tags]: 
If the number of branches is large, you might want to look at a binary search tree This will reduce the maximum number of comparisons that any specific branch will need to be tested against (although the minimum number of tests will also increase). e.g. The below case there is a minimum of 2 tests and a maximum of 3 tests. In your example above, there is a maximum of 4 tests. if ($c Edit : Depends on what you mean by 'shorten'. As per your title 'faster' am assuming performance. Edit (you've updated the List) : Case in Point 'A' needs only one comparison test, whereas the 'AA' fall through will have failed ~25 tests. Assuming an even distribution of data across all bins, the average number of tests would be ~12 ('L') whereas in a binary tree formation, the most checks would be Log2(N) + 1 - i.e. 6 tests would cover 32 branches. Unfortunately in your case, there are gaps in the data on the even '100's. If you exclude these (i.e. if value MOD 100 == 0 then fall through to 'AA') then you can do just a one sided test for the rest of the permutations.
