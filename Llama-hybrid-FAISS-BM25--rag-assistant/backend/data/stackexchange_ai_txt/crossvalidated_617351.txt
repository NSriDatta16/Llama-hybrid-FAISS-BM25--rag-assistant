[site]: crossvalidated
[post_id]: 617351
[parent_id]: 
[tags]: 
Test and Train AUC are almost exactly the same

I am trying to build a logistic regression model. My test and training sets are generating almost the same AUC. Ideally- this means that the model is performing very well. But since, I got this result at my very first attempt of building this model- I am a bit skeptical in accepting the fact that I have come up with a great model. I want to make sure that nothing else is going on with my process. Test AUC 0.7606003279815455 Train AUC 0.7613571317318779 Note: The output class is imbalanced: 10%-90% split of 1 and 0 values. So I implemented undersampling by selecting all the observations from the minority class and 3*(number of observations from minority class) from majority class. Here is my code (After data processing) df_item_date_level_v6 = df_item_date_level_v5.loc[:,~df_item_date_level_v5.columns.duplicated()].copy() X=df_item_date_level_v6.drop(["sales_ind"], axis=1) y=df_item_date_level_v6.loc[:,["sales_ind"]] X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42, train_size = .75) lr = LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, max_iter=1000, multi_class='ovr', n_jobs=1, penalty='l1', random_state=None, solver='liblinear', tol=0.0001, verbose=0 ) #lr = LogisticRegression() lr.fit(X_train, y_train) train_score=lr.score(X_train, y_train) test_score=lr.score(X_test, y_test) print(lr.intercept_) print(lr.coef_) #Plotting AUC #predict_proba generates the predicted value of Y in the very first column. train_fpr, train_tpr, thresholds = metrics.roc_curve(y_train,lr.predict_proba(X_train)[:,1]) test_fpr, test_tpr, thresholds = metrics.roc_curve(y_test, lr.predict_proba(X_test)[:,1]) plt.plot(train_fpr, train_tpr, label="trainAUC="+str(metrics.auc(train_fpr,train_tpr))) plt.plot(test_fpr, test_tpr, label="test AUC ="+str(metrics.auc(test_fpr, test_tpr))) plt.legend() plt.xlabel("FPR") plt.ylabel("TPR") plt.title("ROC for Train and Test data with best_fit") plt.grid() plt.show()
