[site]: stackoverflow
[post_id]: 4240138
[parent_id]: 
[tags]: 
How to deserialize a class hierarchy without a class enumerator

I'm using this approach to serialize and deserialize a class hierarchy: // Enumeration of classes. struct Type { enum TypeEnum { A, B } TypeEnum t; Type(TypeEnum te) : t(te) { } bool operator == (TypeEnum te); void saveToStream(Stream& stream); void loadFromStream(Stream& stream); }; // Serializable base class. struct A { Type type; A() { type = Type::A; } // ... members virtual void loadFromStream(Stream& stream); virtual void saveToStream(Stream& stream) const; }; // Serializable child class. struct B : public A { B() : A() { type = Type::B; } virtual void loadFromStream(Stream& stream); virtual void saveToStream(Stream& stream); }; // Helper class. struct Serializer { static A* loadFromStream(Stream& stream) { Type t; t.loadFromStream(stream); if (t == Type::A) { A* a = new A; a->loadFromStream(stream); return a; } else if (t == Type::B) { A* b = new B; b->loadFromStream(stream); return b; } throw "Unknown type"; return 0; // surpress warning } static void saveToStream(Stream& stream, const A& a) { a.type.saveToStream(stream); a.saveToStream(stream); } }; // Usage B b; Serializer::saveToStream(stream, b); B* b2 = static_cast (Serializer::loadFromStream(stream)); This approach is pretty straightforward and simple to understand. But I was thinking about if there's a more elegant solution without the need to update class Type every time i expand the class hierarchy. Do you have any hints how to do this without the enumerator class Type and maybe without the class Serializer ?
