[site]: stackoverflow
[post_id]: 4403699
[parent_id]: 4403324
[tags]: 
It's a bit tricky. You could do it by using a syntactic predicate (LOOK-AHEAD-TOKENS-HERE)=> before matching an "OR-chain": expr : (atom '|')=> atom ('|' atom)+ -> ^('|' atom+) | atom ; which properly handles a|b|c , a|b and a . But you might want to explain what language you're actually trying to parse: there might be better (more elegant?) ways to express it. Why wouldn't you want to have an AST as in your first diagram? Evaluating expressions is easy when the root (operand) has only two children, right?
