[site]: stackoverflow
[post_id]: 245118
[parent_id]: 241089
[tags]: 
I can suggest a way: you can write a plugin for it. For example see this improvized "tutorial", I made it, tried it works on Ganymede. A bit ugly at the final Shell variable, but working. If you know nicer solution just shoot :) ((actually there is a way: to extend your own ControlListener class, but that needs more coding :)) Create a new Plug-in Project, name it as you want, create it from a template named: Hello World Command Open the SampleHandler class, and then replace the execute() function with this code. public Object execute(ExecutionEvent event) throws ExecutionException { IWorkbenchWindow window = HandlerUtil .getActiveWorkbenchWindowChecked(event); final Shell s = window.getShell(); window.getShell().addControlListener(new ControlListener() { @Override public void controlMoved(ControlEvent e) { // TODO Auto-generated method stub } @Override public void controlResized(ControlEvent e) { MessageDialog.openInformation(s, "WindowEventHandler Plug-in", "RESIZED: " + e.toString() + "\nHello, Eclipse world"); } }); MessageDialog.openInformation(window.getShell(), "WindowEventHandler Plug-in", "Hello, Eclipse world, resize will be taken care of."); return null; } now. Start the project (Run As-> Eclipse application), and you'll se an Eclipse button on the toolbar. Click on it! It triggers the running of the above code where the essence is that the window.getShell() returns with the main window component so you can add listeners to it. If you want it to run automatically, not just for a button, you have to find out a plugin where the entry point is connected to the starting of the application. Hope this helps. b
