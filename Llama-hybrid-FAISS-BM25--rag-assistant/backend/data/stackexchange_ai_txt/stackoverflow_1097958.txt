[site]: stackoverflow
[post_id]: 1097958
[parent_id]: 
[tags]: 
DB won't reinitialize to local subscribers after Schema changes

First, I will outline my issue in case someone has an alternate fix. The Problem: I have a winform app that uses MergeReplication . This is working great except I needed to make changes to the columns and Primary Key on 5 Tables . I dropped them from the Articles and then made my changes. I then re-added them to the Articles and set the Publication to Reintilialize All . Unfortunately, this does not work. When I go to run the Subscription Program it tells me that the Subscription is InValid . EDIT 1 I have a correction/addition here. The actual errors I am getting in the Replication Monitor are such --> Error messages: The schema script 'tblCaseNotes_4.sch' could not be propagated to the subscriber. (Source: MSSQL_REPL, Error number: MSSQL_REPL-2147201001) Get help: http://help/MSSQL_REPL-2147201001 Could not drop object 'dbo.tblCaseNotes' because it is referenced by a FOREIGN KEY constraint. (Source: MSSQLServer, Error number: 3726) Get help: http://help/3726 This seems important because it means that my MergeRepl sync process is trying to ReInitialize but cannot because of the below issue. The way I was able to fix it on my machine was to use MSSSMS to DELETE the DB and then run my program which creates a db and syncs it. Unfortunately I do not have MSSSMS access to all the remote user SQL Express installs as for security reasons remote connections are off. My Idea: Create a small program that runs a .sql script to DELETE the DB on local machine. A la; DROP DATABASE MyDB This is only the test stage so no data preservation is needed. Unfortunately I haven't the faintest idea how to have a program do that. The Code: This is the code that runs as my program loads. It takes care of creating the local db's and subscription if they aren't already there. It then checks to see if they need to be syncronized and kicks off a Pull Sync if needed. I include it because of the possibility that my solution is a change to this code. I call this code like this --> MergeRepl matrixMergeRepl = new MergeRepl(SystemInformation.ComputerName + "\\SQLEXPRESS","WWCSTAGE","MATRIX","MATRIX","MATRIX"); matrixMergeRepl.RunDataSync(); MergeRepl is below --> public class MergeRepl { // Declare nessesary variables private string subscriberName; private string publisherName; private string publicationName; private string subscriptionDbName; private string publicationDbName; private MergePullSubscription mergeSubscription; private MergePublication mergePublication; private ServerConnection subscriberConn; private ServerConnection publisherConn; private Server theLocalSQLServer; private ReplicationDatabase localRepDB; public MergeRepl(string subscriber, string publisher, string publication, string subscriptionDB, string publicationDB) { subscriberName = subscriber; publisherName = publisher; publicationName = publication; subscriptionDbName = subscriptionDB; publicationDbName = publicationDB; //Create connections to the Publisher and Subscriber. subscriberConn = new ServerConnection(subscriberName); publisherConn = new ServerConnection(publisherName); // Define the pull mergeSubscription mergeSubscription = new MergePullSubscription { ConnectionContext = subscriberConn, DatabaseName = subscriptionDbName, PublisherName = publisherName, PublicationDBName = publicationDbName, PublicationName = publicationName }; // Ensure that the publication exists and that it supports pull subscriptions. mergePublication = new MergePublication { Name = publicationName, DatabaseName = publicationDbName, ConnectionContext = publisherConn }; // Create the local SQL Server instance theLocalSQLServer = new Server(subscriberConn); // Create a Replication DB Object to initiate Replication settings on local DB localRepDB = new ReplicationDatabase(subscriptionDbName, subscriberConn); // Check that the database exists locally CreateDatabase(subscriptionDbName); } /// There is insufficient metadata to synchronize the subscription.Recreate the subscription with the agent job or supply the required agent properties at run time. public void RunDataSync() { // Keep program from appearing 'Not Responding' ///// Application.DoEvents(); // Does the needed Databases exist on local SQLExpress Install /////CreateDatabase("ContactDB"); try { // Connect to the Subscriber subscriberConn.Connect(); // if the Subscription exists, then start the sync if (mergeSubscription.LoadProperties()) { // Check that we have enough metadata to start the agent if (mergeSubscription.PublisherSecurity != null || mergeSubscription.DistributorSecurity != null) { // Synchronously start the merge Agent for the mergeSubscription // lblStatus.Text = "Data Sync Started - Please Be Patient!"; mergeSubscription.SynchronizationAgent.Synchronize(); } else { throw new ApplicationException("There is insufficient metadata to synchronize the subscription." + "Recreate the subscription with the agent job or supply the required agent properties at run time."); } } else { // do something here if the pull mergeSubscription does not exist // throw new ApplicationException(String.Format("A mergeSubscription to '{0}' does not exist on {1}", publicationName, subscriberName)); CreateMergeSubscription(); } } catch (Exception ex) { // Implement appropriaate error handling here throw new ApplicationException("The subscription could not be synchronized. Verify that the subscription has been defined correctly.", ex); //CreateMergeSubscription(); } finally { subscriberConn.Disconnect(); } } /// ApplicationException . public void CreateMergeSubscription() { // Keep program from appearing 'Not Responding' // Application.DoEvents(); try { if (mergePublication.LoadProperties()) { if ((mergePublication.Attributes & PublicationAttributes.AllowPull) == 0) { mergePublication.Attributes |= PublicationAttributes.AllowPull; } // Make sure that the agent job for the mergeSubscription is created. mergeSubscription.CreateSyncAgentByDefault = true; // Create the pull mergeSubscription at the Subscriber. mergeSubscription.Create(); Boolean registered = false; // Verify that the mergeSubscription is not already registered. foreach (MergeSubscription existing in mergePublication.EnumSubscriptions()) { if (existing.SubscriberName == subscriberName && existing.SubscriptionDBName == subscriptionDbName && existing.SubscriptionType == SubscriptionOption.Pull) { registered = true; } } if (!registered) { // Register the local mergeSubscription with the Publisher. mergePublication.MakePullSubscriptionWellKnown( subscriberName, subscriptionDbName, SubscriptionSyncType.Automatic, MergeSubscriberType.Local, 0); } } else { // Do something here if the publication does not exist. throw new ApplicationException(String.Format( "The publication '{0}' does not exist on {1}.", publicationName, publisherName)); } } catch (Exception ex) { // Implement the appropriate error handling here. throw new ApplicationException(String.Format("The subscription to {0} could not be created.", publicationName), ex); } finally { publisherConn.Disconnect(); } } /// /// This will make sure the needed DataBase exists locally before allowing any interaction with it. /// /// The name of the DataBase to check for. /// True if the specified DataBase exists, False if it doesn't. public void CreateDatabase(string whichDataBase) { Database db = LocalDBConn(whichDataBase, theLocalSQLServer, localRepDB); if (!theLocalSQLServer.Databases.Contains(whichDataBase)) { //Application.DoEvents(); // Create the database on the instance of SQL Server. db = new Database(theLocalSQLServer, whichDataBase); db.Create(); } localRepDB.Load(); localRepDB.EnabledMergePublishing = false; localRepDB.CommitPropertyChanges(); if (!mergeSubscription.LoadProperties()) { CreateMergeSubscription(); } } private Database LocalDBConn(string databaseName, Server server, ReplicationDatabase replicationDatabase) { return server.Databases[replicationDatabase.Name]; } /// /// Checks for the existence of the Publication. If there is one it verifies Allow Pull is set /// /// True if Publication is present. False if not. public bool CheckForPublication() { // If LoadProperties() returns TRUE then the Publication exists and is reachable if (mergePublication.LoadProperties()) return true; if ((mergePublication.Attributes & PublicationAttributes.AllowPull) == 0) { mergePublication.Attributes |= PublicationAttributes.AllowPull; } return false; } // end CheckForPublication() /// /// Checks for the existence of a Subscription. /// /// True if a Subscription is present. False if not public bool CheckForSubscription() { // Check for the existence of the Subscription return mergeSubscription.IsExistingObject; } // end CheckForSubscription() } The Guerdon (Reward): This is extremely important to me so even if I am a flaming idiot and there is a super simple solution I will be adding a bounty to the correct answer. EDIT 2 I created this to try and remove the Subscription first....which it does but still errors out on the DROP DB portion saying it is in use... class Program { static void Main(string[] args) { DropSubscription(); DropDB(); } private static void DropSubscription() { ServerConnection subscriberConn = new ServerConnection(".\\SQLEXPRESS"); MergePullSubscription mergePullSubscription = new MergePullSubscription("MATRIX","WWCSTAGE","MATRIX","MATRIX",subscriberConn); mergePullSubscription.Remove(); } private static void DropDB() { SqlCommand cmd; string sql; string dbName = "MATRIX"; SqlConnection sqlConnection = new SqlConnection("Server=.\\SQLEXPRESS;Initial Catalog="+ dbName + ";Integrated Security=True;User Instance=False"); sqlConnection.Open(); sql = "DROP DATABASE " + dbName; cmd = new SqlCommand(sql,sqlConnection); cmd.ExecuteNonQuery(); sqlConnection.Close(); } }
