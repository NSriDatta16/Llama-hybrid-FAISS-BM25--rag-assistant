[site]: stackoverflow
[post_id]: 2500084
[parent_id]: 2439697
[tags]: 
Data retrieval performance is the function of speed of access to the data on the disk (depends on existence of indexes, size of tables, size of cache, raw I/O speed) number of records that need to be returned (some joins reduce the number of rows returned, some increase, some conditions can be applied on indexes some must go to the records) number of columns that you need to return For all of these you can optimize adding indexes reducing the size of the table by partitioning it vertically (splitting the table into two or more semantically different tables - for example if from your 5m table you actually work only with 100k records 99.5% of the time maybe you can split table into active/inactive or similar) providing you can not split vertically you might split a table horizontally - number of columns that table has also influences retrieval speed (but not as much) finally improving the raw I/O speed can be achieved by splitting the table transparently across multiple hard disks (but know your underlying file system properties) Indexes have the highest impact on the performance because they can cut down disk access time and speed in memory operations by orders of magnitude (they turn O(n) to log O(n) at the cost of index structure maintenance; so they do slow down updates) For maximum retrieval speed indexes should cover all the join and where conditions and queries should be written in such a way that query optimizer can determine which of these will yield highest benefit if executed first (highest selectivity). For your particular example try to benchmark different combination of indexes pm.production_minute should be indexed for sure with es.state_start_time and es.state_end_time you have 4 possible index options (which you can combine): index on es.state_start_time index on es.state_end_time index on (es.state_start_time, es.state_end_time) index on (es.state_end_time, es.state_start_time) Knowing your data would let you determine which one is optimal. I wouldn't be surprised if you would find that having the last two two column indexes would perform the best. Or having one single column and another two column index (but in reverse order of columns). In both of these cases decent optimizer would be able to determine resultset from just reading the indexes and not even looking at the actual records and that cuts down your disk access substantially.
