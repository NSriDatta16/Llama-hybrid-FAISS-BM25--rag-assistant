[site]: stackoverflow
[post_id]: 3868850
[parent_id]: 3868827
[tags]: 
int **b = &(&(*pointer)); This doesn't, or shouldn't compile. You can only take the address of an l-value. (See below for a description) C++03 S5.3.1-2: The result of the unary & operator is a pointer to its operand. The operand shall be an lvalue or a qualifiedid. In the first case, if the type of the expression is “T,” the type of the result is “pointer to T.” In particular, the address of an object of type “cv T” is “pointer to cv T,” with the same cv-qualifiers. For a qualified-id, if the member is a static member of type “T”, the type of the result is plain “pointer to T.” If the member is a nonstatic member of class C of type T, the type of the result is “pointer to member of class C of type ...and the reference of that is the address of a... Also you are using the term reference wrong here. & is a symbol that is used for different things. one of those things is to declare references, an unrelated thing is the address of unary operator. The later is not called a reference. Does this make sense? Could I do: &(*pointer) = a; An address of a variable, and hence &(*pointer) or equivalently &a are r-values. You can't assign anything to an r-avlue. Ignoring things like const you can consider an r-value something that must appear on the right hand side. An l-value is kind of like left hand side but really it means it can be stored in a storage location (the difference is because a const object for example can't appear on the left hand side but it is still considered an l-value).
