[site]: stackoverflow
[post_id]: 1591260
[parent_id]: 1591036
[tags]: 
Because the sample code works, something else in your program is causing the bug. Try moving bits of the code below into your own until it works, then you will know which section of code was culprit. Sample Code Alright, huge code block coming up. This code works correctly for me. (Escape, along with all other keys successfully activate and deactivate). It's large, commented, and explains things fairly well. Try this, if it works, we'll examine other parts of your program, if not, I can only leave you with "Good luck", and take what you want: // DirectInput #define DIRECTINPUT_VERSION 0x0800 #include // Standard stuff #include #include #include #include // Link from code, MSVC specific, could be done in project settings #pragma comment(lib, "dinput8.lib") #pragma comment(lib, "dxguid.lib") // Utility lexical_cast, use Boost if possible. // Simple replacement, converts a stream-able `T` // to a string template const std::string lexical_cast(const T& pValue) { std::stringstream ss; ss (&_input), 0)); CHECK_ERROR(_input->CreateDevice(GUID_SysKeyboard, &_keyboard, 0)); CHECK_ERROR(_keyboard->SetDataFormat(&c_dfDIKeyboard)); CHECK_ERROR(_keyboard->Acquire()); } ~input_manager(void) { // Free resources. Note: Many programmers // unnecessarily wrap this stuff in // `if (_keyboard !=0)`, and then // `_keyboard = 0`. This is completely unnecessary, // because destructors are only run one time. // Also, I can assume they are valid, because if they // weren't, we wouldn't be here (an exception would have // been thrown) _keyboard->Unacquire(); _keyboard->Release(); _input->Release(); // Also, if we wrapped this into a nice RAII class, we wouldn't // be forced to write a destructor, but this is outside the scope. // Feel free to ask how; additionally, since we're on the topic, if you'd // like more tips handling input (I've written PLENTY of input managers) // I'm free for asking about things like testing for triggers rather than pressed // ("was it pressed, regardless if it's being held now" versus // "is it being pressed"), etc. } // Operations void update(void) { CHECK_ERROR(_keyboard->GetDeviceState(NumberKeys, reinterpret_cast (&_keys))); } // Query bool key_pressed(int pKey) const { return test_key(pKey); } // Might wrap into an operator[] for convenience. private: // Constants static const int PressMask = 0x80; // Sorry for the confusion, but indeed, with // `char`s the mask is simply 0x80. // Utility bool test_key(int pKey) const { return (_keys[pKey] & PressMask) != 0; } // Members LPDIRECTINPUT8 _input; LPDIRECTINPUTDEVICE8 _keyboard; char _keys[NumberKeys]; }; void test_keys(const input_manager& input) { bool anyPressed = false; for (unsigned i = 0; i Old suggestion: Try catching the return value from GetDeviceState: HRESULT result = // v Prefer C++-style casts di_keyboard->GetDeviceState(sizeof(keys), reinterpret_cast (&keys); if (result != DI_OK) { // uh-oh std::cout Compare it against the table here . Old Semi-Answer: Shortly after editing in the code in the Extra Stuff section, I realized the error, sorry I didn't catch it earlier. You're testing the wrong bit :) Observe: // v HERE! Should be 0x8000, not 0x80. return (GetAsyncKeyState(pKeyCode) & 0x8000) != 0; Try that: int KeyDown(int key) { return (keys[key] & 0x8000); } Also, this should be moved into a constant to avoid magic numbers: // somewhere, probably in the private section of the class or in a detail namespace: static const int PushedMask = 0x8000; // code reads better: int KeyDown(int key) { return (keys[key] & PushedMask); } Lastly, in C++ you have a bool type, so take advantage of it! // v here bool KeyDown(int key) { return (keys[key] & PushedMask); } I know Visual Studio will warn about this conversion from int to bool , so you can get rid of it while also making your intents clearer: bool KeyDown(int key) { return (keys[key] & PushedMask) != 0; // or == 1, your choice } Extra Stuff: Try the following code: #include #include bool key_pressed(int pKeyCode) { return (GetAsyncKeyState(pKeyCode) & 0x8000) != 0; } void test_keys(void) { for (unsigned i = 0; i This works for me (responds to all keys, quits on escape). Minimal test case for GetAsyncKeyState . If this does not work, please add OS, Keyboard, etc, in your comment.
