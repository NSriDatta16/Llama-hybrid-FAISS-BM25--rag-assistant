[site]: stackoverflow
[post_id]: 5054853
[parent_id]: 5054834
[tags]: 
Hopefully final update :-) Based on your latest update, Centos is packing your structures at the byte level whilst CygWin is not. This causes alignment problems. I'm not sure why the CygWin-to-CygWin case is having problems since the padding should be identical there but I can tell you how to fix the other case. Using the code I gave earlier: #include typedef struct { unsigned char _array[28]; long long _sequence; unsigned char _type; unsigned char _num; short _size; } tType; int main (void) { tType t[2]; printf ("%d\n", sizeof(long)); printf ("%d\n", sizeof(long long)); printf ("%d\n", sizeof(tType)); printf ("%p\n", &(t[0]._array)); printf ("%p\n", &(t[0]._sequence)); printf ("%p\n", &(t[0]._num)); printf ("%p\n", &(t[0]._size)); printf ("%p\n", &(t[1])); return 0; } If you don't want any padding, you have two choices. The first is to re-organise your structure to put the more restrictive types up front: typedef struct { long long _sequence; short _size; unsigned char _array[28]; unsigned char _type; unsigned char _num; } tType; which gives you: 4 8 40 0x22cd42 0x22cd38 0x22cd5f 0x22cd40 0x22cd60 In other words, each structure is exactly 40 bytes (8 for sequence, 2 for size, 28 for array and 1 each for type and num). But this may not be possible if you want it in a specific order. In that case, you can force the alignments to be on a byte level with: typedef struct { unsigned char _array[28]; long long _sequence; unsigned char _type; unsigned char _num; short _size; } __attribute__ ((aligned(1),packed)) tType; The aligned(1) sets it to byte alignment but that won't affect much since objects don't like having their alignments reduced. To force that, you need to use packed as well. Doing that gives you: 4 8 40 0x22cd3c 0x22cd58 0x22cd61 0x22cd62 0x22cd64 Earlier history for prosperity: Well, since I wget and ftp huge files just fine from CygWin, my psychic debugging skills tell me it's more likely to be a problem with your code rather than the CygWin software. In other words, regarding the sentence "the packets are corrupted between the level Wireshark looks at and the program itself", I'd be seriously looking towards the upper end of that scale rather than the lower end :-) Usually, it's the case that you've assumed a read will get the whole packet that was sent rather than bits at a time but, without seeing the code in question, that's a pretty wild guess. Make sure you're checking the return value from read to see how many bytes are actually being received. Beyond that, post the code responsible for the read so we can give a more in-depth analysis. Based on your posted code, it looks okay. The only thing I can suggest is that you check that the buffers you're passing in are big enough and, even if they are, make sure you print them immediately after return in case some other piece of code is corrupting the data. In fact, in re-reading your question more closely, I'm a little confused. You state you have the same problem with your server code on both Linux and CygWin yet say it's working on Centos. My only advice at this point is to put debugging printf statements in that function you've shown, such as after the select and read calls to output the relevant variables, including got and buf after changing them, and also in every code path so you can see what it's doing. And also dump the entire structure byte-for-byte at the sending end. This will hopefully show you immediately where the problem lies, especially since you seem to have data showing up in the wrong place. And make sure your types are compatible at both ends. By that, I mean if long long is different sizes on the two platforms, your data will be misaligned. Okay, checking alignments at both ends, compile and run this program on both systems: #include typedef struct { unsigned char _array[28]; long long _sequence; unsigned char _type; unsigned char _num; short _size; } tType; int main (void) { tType t[2]; printf ("%d\n", sizeof(long)); printf ("%d\n", sizeof(long long)); printf ("%d\n", sizeof(tType)); printf ("%p\n", &(t[0]._array)); printf ("%p\n", &(t[0]._sequence)); printf ("%p\n", &(t[0]._num)); printf ("%p\n", &(t[0]._size)); printf ("%p\n", &(t[1])); return 0; } On my CygWin, I get: 4 long size 8 long long size 48 structure size 0x22cd30 _array start (size = 28, padded to 32) 0x22cd50 _sequence start (size = 8, padded to 9???) 0x22cd59 _type start (size = 1) 0x22cd5a _size start (size = 2, padded to 6 for long long alignment). 0x22cd60 next array element. The only odd bit there is the padding before _type but that's certainly valid though unexpected. Check the output from Centos to see if it's incompatible. However, your statement that CygWin-to-CygWin doesn't work is incongruous with that possibility since the alinments and sizes would be compatible (unless your sending and receiving code is compiled differently).
