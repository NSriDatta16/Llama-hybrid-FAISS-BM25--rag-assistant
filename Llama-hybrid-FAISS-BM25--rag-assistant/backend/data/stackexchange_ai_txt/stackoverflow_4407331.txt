[site]: stackoverflow
[post_id]: 4407331
[parent_id]: 4406110
[tags]: 
You are only specifying the time complexity, but the space complexity is also important to consider. The problem complexity can be specified in term of N (the length of the range) and K (the number of missing elements). In the question you link, the solution of using equations is O(K) in space (or perhaps a bit more ?), as you need one equation per unknown value. There is also the preservation point: may you alter the list of known elements ? In a number of cases this is undesirable, in which case any solution involving reordering the elements, or consuming them, must first make a copy, O(N-K) in space. I cannot see faster than a linear solution: you need to read all known elements (N-K) and output all unknown elements (K). Therefore you cannot get better than O(N) in time. Let us break down the solutions Destroying, O(N) space, O(N log N) time: in-place sort Preserving, O(K) space ?, O(N log N) time: equation system Preserving, O(N) space, O(N) time: counting sort Personally, though I find the equation system solution clever, I would probably use either of the sorting solutions. Let's face it: they are much simpler to code, especially the counting sort one! And as far as time goes, in a real execution, I think the "counting sort" would beat all other solutions hands down. Note : the counting sort does not require the range to be [0, X) , any range will do, as any finite range can be transposed to the [0, X) form by a simple translation. EDIT : Changed the sort to O(N), one needs to have all the elements available to sort them. Having had some time to think about the problem, I also have another solution to propose. As noted, when N grows (dramatically) the space required might explode. However, if K is small, then we could change our representation of the list, using intervals: {4, 5, 3, 1, 7} can be represented as [1,1] U [3,5] U [7,7] In the average case, maintaining a sorted list of intervals is much less costly than maintaining a sorted list of elements, and it's as easy to deduce the missing numbers too. The time complexity is easy: O(N log N), after all it's basically an insertion sort. Of course what's really interesting is that there is no need to actually store the list, thus you can feed it with a stream to the algorithm. On the other hand, I have quite a hard time figuring out the average space complexity. The "final" space occupied is O(K) (at most K+1 intervals), but during the construction there will be much more missing intervals as we introduce the elements in no particular order. The worst case is easy enough: N/2 intervals (think odd vs even numbers). I cannot however figure out the average case though. My gut feeling is telling me it should be better than O(N), but I am not that trusting.
