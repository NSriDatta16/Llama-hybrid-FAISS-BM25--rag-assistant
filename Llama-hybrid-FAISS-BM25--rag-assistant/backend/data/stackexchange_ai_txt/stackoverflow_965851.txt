[site]: stackoverflow
[post_id]: 965851
[parent_id]: 963911
[tags]: 
You can't - in C. In C initializing of global and local static variables are designed such that the compiler can put the values statically into the executable. It can't handle non-constant expressions as initializers. And only in C99, you can use non-constant expression in aggregate initializers - not so in C89! In your case, since your array is an array containing characters, each element has to be an arithmetic constant expression. Look what it says about those An arithmetic constant expression shall have arithmetic type and shall only have operands that are integer constants, ï¬‚oating constants, enumeration constants, character constants, and sizeof expressions. Surely this is not satisfied by your initializer, which uses an operand of pointer type. Surely, the other way is to initialize your array using a string literal, as it explains too All the expressions in an initializer for an object that has static storage duration shall be constant expressions or string literals. All quotes are taken out of the C99 TC3 committee draft. So to conclude, what you want to do - using non-constant expression - can't be done with C. You have several options: Write your stuff multiple times - one time reversed, and the other time not reversed. Change the language - C++ can do that all. If you really want to do that stuff, use an array of char const* instead Here is what i mean by the last option char const c[] = "ABCD"; char const *f[] = { &c[0], &c[1], &c[2], &c[3] }; char const *g[] = { &c[3], &c[2], &c[1], &c[0] }; That works fine, as an address constant expression is used to initialize the pointers An address constant is a null pointer, a pointer to an lvalue designating an object of static storage duration, or a pointer to a function designator; it shall be created explicitly using the unary & operator or an integer constant cast to pointer type, or implicitly by the use of an expression of array or function type. The array-subscript [] and member-access . and -> operators, the address & and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators. You may have luck tweaking your compiler options - another quote: An implementation may accept other forms of constant expressions.
