[site]: stackoverflow
[post_id]: 4901800
[parent_id]: 4856080
[tags]: 
Here's the solution to my question (at least the best one in my opinion): 1) Use of a regular Canvas as opposed of a custom control inherited from Canvas. 2) Use of a user control taking the data context (the instance of my business entity) via constructor 3) The binding between the Left/Top properties of my business class and the Canvas.Left/Top is declared at the UserControl level. 4) Use of a custom behavior inheriting from System.Windows.Interactivity.Behavior. This behavior is attached to the User Control. I would like to acknowlege Calvin Schrotenboer and Joe Gershgorin for their immense help. The custom behavior: public class MyMouseDragElementBehavior : Behavior { public event MouseEventHandler DragBegun; public event MouseEventHandler DragFinished; public event MouseEventHandler Dragging; private Point relativePosition; public static readonly DependencyProperty IsEnabledProperty = DependencyProperty.Register("IsEnabled", typeof(bool), typeof(MyMouseDragElementBehavior), new PropertyMetadata(true)); public bool IsEnabled { get { return (bool)GetValue(IsEnabledProperty); } set { SetValue(IsEnabledProperty, value); } } protected override void OnAttached() { AssociatedObject.AddHandler( UIElement.MouseLeftButtonDownEvent, new MouseButtonEventHandler(OnMouseLeftButtonDown), false); base.OnAttached(); } protected override void OnDetaching() { AssociatedObject.RemoveHandler( UIElement.MouseLeftButtonDownEvent, new MouseButtonEventHandler(OnMouseLeftButtonDown)); base.OnDetaching(); } private static int zIndex = 0; private void OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e) { if (!IsEnabled) { return; } zIndex++; Canvas.SetZIndex(AssociatedObject, zIndex); StartDrag(e.GetPosition(AssociatedObject)); if (DragBegun != null) { DragBegun(this, e); } } private void OnMouseLeftButtonUp(object sender, MouseButtonEventArgs e) { AssociatedObject.ReleaseMouseCapture(); } private void OnMouseMove(object sender, MouseEventArgs e) { HandleDrag(e.GetPosition(AssociatedObject)); if (Dragging != null) { Dragging(this, e); } } internal void HandleDrag(Point newPositionInElementCoordinates) { double x = newPositionInElementCoordinates.X - relativePosition.X; double y = newPositionInElementCoordinates.Y - relativePosition.Y; if (AssociatedObject != null) { var currentLeft = Canvas.GetLeft(AssociatedObject); var currentTop = Canvas.GetTop(AssociatedObject); Canvas.SetLeft(AssociatedObject, currentLeft + x); Canvas.SetTop(AssociatedObject, currentTop + y); } } internal void StartDrag(Point positionInElementCoordinates) { relativePosition = positionInElementCoordinates; AssociatedObject.CaptureMouse(); AssociatedObject.MouseMove += OnMouseMove; AssociatedObject.LostMouseCapture += OnLostMouseCapture; AssociatedObject.AddHandler(UIElement.MouseLeftButtonUpEvent, new MouseButtonEventHandler(OnMouseLeftButtonUp), false); } internal void EndDrag() { AssociatedObject.MouseMove -= OnMouseMove; AssociatedObject.LostMouseCapture -= OnLostMouseCapture; AssociatedObject.RemoveHandler( UIElement.MouseLeftButtonUpEvent, new MouseButtonEventHandler(OnMouseLeftButtonUp)); } private void OnLostMouseCapture(object sender, MouseEventArgs e) { EndDrag(); if (DragFinished != null) { DragFinished(this, e); } } }
