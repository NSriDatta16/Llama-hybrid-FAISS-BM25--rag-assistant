[site]: stackoverflow
[post_id]: 1549868
[parent_id]: 1543313
[tags]: 
The most elegant way to solve this that I know of is with a future value. If you haven't run across these before they can be quite handy in situations like this. Say you have a value that you'll need later on, but you can begin calculating concurrently. The code might look something like this: SomeValue getValue() { ... calculate the value ... } void foo() { Future future_value(getValue); ... other code that takes a long time ... SomeValue v = future_value.get(); } Upon calling the .get() method of course, the value computed is returned, either by calling the function then and there or by retrieving the cache value calculated in another thread started when the Future was created. One nice thing is that, at least for a few libraries, you can pass in a timeout parameter into the .get() method. This way if your value is taking too long to compute you can always unblock. Such elegant isn't usually achieved. For a real life library, you might try looking into the library documented here . As I recall it wasn't accepted as the official boost futures library, but it certainly had promise. Good luck!
