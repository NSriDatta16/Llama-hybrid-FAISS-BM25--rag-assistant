[site]: crossvalidated
[post_id]: 380158
[parent_id]: 379031
[tags]: 
Guillaume, if you are willing to stick with the zoib package, you will find more details about how to specify a zoib model at http://127.0.0.1:13951/library/zoib/html/zoib.html . In particular, note that you will need to specify the right hand side of the model much more carefully. Perhaps you could start out with something like this: model In the above, joint = FALSE signals that you are modelling a single response variable, racine2. Because this response variable has a distribution which exhibits both zero and one inflation, you need to set zero.inflation = TRUE and one.inflation = TRUE . Since your model does not include any random effects, you need to set random = 0 . The EUID refers to the experimental unit ID so you can just set the IDs to be 1, 2, 3 and so on until n, where n represents the number of observations in your data set. Since mu denotes the mean of the Beta distribution, link.mu denotes the link function applied to this mean to facilitate its modeling. By default, link.mu = "logit" . Other options for link.mu include link.mu = "probit" and link.mu = "cloglog" . While zoib does not explicitly include a link function for eta, where eta is the sum of the two shape parameters of the Beta distribution, it seems to use a log link function behind the scenes. There is also a link function used for modelling p0 = Pr(y=0) which is called link.x0, where y denotes the response variable. By default, link.x0 = "logit" . Finally, there is a link function used for modelling p1 = Pr(y=1|y>0) which is called link.x1. link.x1 = "logit" . The construct **genotype + traitement|genotype|traitement|1* which appears on the right hand side of the zoib model formula can be a bit confusing, as it allows you to simultaneously model different things. The way I understand it - and perhaps someone on this forum can confirm if my understanding is correct - when you have a zero-one inflated response variable, you are going to break down its modelling into 3 different components. This will allow you to model separately: The values of y for which y is in (0,1); The values of y for which y = 0; The values of y for which y = 1 (given that y was NOT 0 and also not in (0,1)). For 1., you are going to assume that y follows a Beta distribution and model its mean (i.e., mu) as well as the sum of the two shape parameters (i.e., eta) of the Beta distribution as a function of the available predictors. The mean of Beta and the sum of its two shape parameters are transformed via the link functions specified in the zoib model call. If that call includes a construct such as genotype + traitement|genotype|traitement|1 , that means that: logit(mu) = beta0 + beta1*genotype + beta2*traitement and log(eta) = delta0 + delta1*genotype. (Here, I am assuming that both genotype and treatment have only two levels each so that I can explicitly specify the models being used for mu and eta, without the need to include dummy variables to code the effect of genotype and treatment). In other words, logit(mu) depends linearly on the predictors listed first in the construct and log(eta) For 2., using the same construct genotype + traitement|genotype|traitement|1 means that you will model the following: logit(p0) = gamma0 + gamma1*treatment where recall that p0 = Pr(y=0), while for 3., you will model: logit(p1) = epsilon0 where p1 = Pr(y=1|y>0). While this is not clear from the link I provided above, I believe that mu represents the mean of y given the predictors which are used to model it . Similarly, Pr(y=0) represents the probability that y = 0 given the predictors that are used to model this probability , while Pr(y=1|y>0) is also a conditional probability that y = 1 given y > 0 and given the predictors that are used to model this probability. (In my example above, none of the predictors are actually used to model Pr(y=1|y>0), so that the probability is constant regardless of the values of the available predictors.) Note that zoib can take a while to fit your model. When done, you can just type: model at the R console to see what comes out. You can then use R code like the one below to interrogate the model: # model summary sample1 $stat[, 1], summ1$ quant[, c(1, 5)]) summ2 In the summ1 output, results will be presented for logit(mu) first, then log(eta), then logit(p0) and finally for logit(p1). The summ2 object will show only selected output from the summ1 object, namely the posterior mean and the Bayesian credible interval for each of the parameters from the fitted zoib model. You could try plotting the posterior means and credible intervals like so: paraplot(summ2, legpos = "topright", annotate=TRUE, legtext = c("zoib")) though the paraplot function needs some further rewrites to produce a quality publication plot. Please refer back to https://journal.r-project.org/archive/2015/RJ-2015-019/RJ-2015-019.pdf for more details. Addendum: It is possible to also fit a zero one inflated beta regression using the gamlss package, as follows: install.packages("gamlss") install.packages("gamlss.dist") require(gamlss) require(gamlss.dist) model.gamlss The convenience of gamlss is that it fits the model using a frequentist rather than a Bayesian framework. It also allows for model comparison using the GAIC() function - this comes in handy in terms of trying various options for mu.formula, sigma.formula, nu.formula and tau.formula and seeing which option is best supported by the data. However, you must make sure you understand how gamlss parametrizes the model and what link functions it uses for each model component. See, for example, https://rdrr.io/cran/gamlss.dist/man/BEINF.html , for more insights into the parametrization used by gamlss (you need to look under the heading Details ). The gamlss package also comes with a term.plot() function which can be used to visualize the effects of the predictors on each of the modelled components: term.plot(model.gamlss, what = "mu") term.plot(model.gamlss, what = "sigma") term.plot(model.gamlss, what = "nu") term.plot(model.gamlss, what = "tau") Diagnostic plots for model.gamlss can be obtained with functions such as: plot(model.gamlss) The worm plot for model.gamlss can be obtained with wp(model.gamlss) and the Q-statistics plot can be obtained with Q.stats(model.gamlss). You can search for the document "Instructions on how to use the gamlss package in R Second Edition" on Google for more info on gamlss.
