[site]: stackoverflow
[post_id]: 1045062
[parent_id]: 1044998
[tags]: 
So what are you trying to do? What's the simplest way for you to store the movement rate data? If it is only needed in the MoveBehavior class then it should be in there: public class MoveBehavior { public int MovementRate { get; set; } } If it is needed inherently by the Mob class then it will be easier exposed through the Mob class: public class Mob { public int MovementRate { get; set; } } public class MoveBehavior { public MoveBehavior(Mob mob) { MobInEffect = mob; } public Mob MobInEffect {get; set;} // can access MovementRate through MovInEffect.MovementRate } So it all depends on what you're trying to achieve with this behavior logic. I'd recommend you push the design decision until you really need to do it one way or another. Concentrate on doing it simple first and refactor later. Usually more often than not, doing early design guesswork can lead to overcomplicated architecture. A more pragmatic solutionâ€¦ What I mean is that you implement whatever you wanted from movement the in the Mob class first: public class Mob { // Constructors and stuff here public void Move(long ticks) { // do some voodoo magic with movement and MovementRate here } protected int MovementRate { get; set; } } And when that works, rip out that implementation to a MoveBehavior class if you really need to: public class Mob { // Constructors and stuff here public MoveBehavior Moving { set; get; } public void Move(long ticks) { Moving.Move(ticks, this); } } public class MoveBehavior { protected int MovementRate { get; set; } public void Move(long ticks, Mob mob) { // logic moved over here now } } After that if you really need to do more than one type of behavior but they share a common interface then create that interface by then and let the behaviors implement that.
