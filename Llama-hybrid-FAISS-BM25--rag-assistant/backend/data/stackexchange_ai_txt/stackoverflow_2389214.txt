[site]: stackoverflow
[post_id]: 2389214
[parent_id]: 
[tags]: 
IList with an implicit sort order

I'd like to create an IList that maintains its Child objects in a default/implicit sort order at all times (i.e. regardless of additions/removals to the underlying list). What I'm specifically trying to avoid is the need for all consumers of said IList to explicitly invoke IEnumerable .OrderBy() every time they want to enumerate it. Apart from violating DRY, such an approach would also break encapsulation as consumers would have to know that my list is even sorted, which is really none of their business :) The solution that seemed most logical/efficient was to expose IList as IEnumerable (to prevent List mutations) and add explicit Add/Remove methods to the containing Parent . This way, I can intercept changes to the List that necessitate a re-sort, and apply one via Linq: public class Child { public string StringProperty; public int IntProperty; } public class Parent{ private IList _children = new List (); public IEnumerable Children{ get { return _children; } } private void ReSortChildren(){ _children = new List (child.OrderBy(c=>c.StringProperty)); } public void AddChild(Child c){ _children.Add(); ReSortChildren() } public void RemoveChild(Child c){ _children.Remove(c); ReSortChildren() } } Still, this approach doesn't intercept changes made to the underlying Child.StringProperty (which in this case is the property driving the sort). There must be a more elegant solution to such a basic problem, but I haven't been able to find one. EDIT: I wasn't clear in that I would preferable a LINQ compatible solution. I'd rather not resort to using .NET 2.0 constructs (i.e. SortedList)
