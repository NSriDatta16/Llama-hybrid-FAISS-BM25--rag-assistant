[site]: stackoverflow
[post_id]: 1998968
[parent_id]: 1998910
[tags]: 
Sounds like XPathDocument might be what you are looking for. This class provides a fast, read-only, in-memory representation of an XML document. It doesn't build up a DOM and is optimized for XPath queries. XPathDocument can also be used to parse XML fragments. To do so you have to create it from an XmlReader that has its conformance level set to fragment. The following sample code first selects a set of XML nodes from an XML fragment and then selects the parent of each node based on an XPath expression: using System; using System.IO; using System.Xml; using System.Xml.XPath; class Program { static void Main(string[] args) { string xml = File.ReadAllText(@"C:\tmp\smplInput.xml"); XmlReaderSettings xrs = new XmlReaderSettings(); xrs.ConformanceLevel = ConformanceLevel.Fragment; using (TextReader textReader = new StringReader(xml)) { using (XmlReader xmlReader = XmlReader.Create(textReader, xrs)) { // Create a new XPathDocument XPathDocument doc = new XPathDocument(xmlReader); // Create navigator XPathNavigator navigator = doc.CreateNavigator(); // Set up namespace manager for XPath XmlNamespaceManager ns = new XmlNamespaceManager(navigator.NameTable); ns.AddNamespace("w", "http://www.example.com/2010/"); // Select nodes XPathNodeIterator users = navigator.Select("//w:user", ns); while (users.MoveNext()) { XPathNavigator user = users.Current; XPathNavigator department = user.SelectSingleNode("parent::node()", ns); Console.WriteLine(string.Format("User {0} is in department {1}", user.GetAttribute("name", ns.DefaultNamespace), department.GetAttribute("type", ns.DefaultNamespace))); } } } } } To try the code you could use the following XML input document:
