[site]: stackoverflow
[post_id]: 1767979
[parent_id]: 
[tags]: 
How to insert into nested vector without invalidating iterator(s)

I have some boolean expressions to evaluate and process. Maybe this would have all been better with Boost, but I'm still learning STL and didn't go that way. I'm now learning about iterator validation, or INvalidation as the case may be. Is there a way to insert a new element into this nested vector below safely? If you don't want to see a grown man cry, don't suggest I rewrite everything :) In all seriousness, I'd also welcome suggestions for how to rewrite this in a more elegant way after I fix my more immediate problem, which I suspect is an invalidated iterator... ... I'm not terribly concerned about performance. Based on that and reading through other posts, perhaps a std::List in place of std::vector would be better, but would I need that at every level of the nesting? ----nested.h #include struct Term { uint32_t termNumber; std::string content; uint32_t importance; uint32_t numAppearances; uint32_t ContextFlags; }; struct SubClause { std::string typeName; std::vector terms; std::string clauseExpression; }; struct Clause { std::vector subClauses; }; -----nested.cpp #include #include "nested_container.h" int main (int argc, char * const argv[]) { std::vector expression; std::vector ::iterator clauseIter = expression.begin(); std::vector ::iterator clauseEnd = expression.end(); for( ; clauseIter != clauseEnd ; clauseIter++ ) { std::vector ::iterator subIter = clauseIter->subClauses.begin(); std::vector ::iterator subEnd = clauseIter->subClauses.end(); for( ; subIter != subEnd ; subIter++ ) { std::vector ::iterator termIter = subIter->terms.begin(); std::vector ::iterator termEnd = subIter->terms.end(); for( ; termIter != termEnd ; termIter++ ) { /* Evaluate SubClause Terms based on some criteria */ /* if criteria true */ if( true/* criteria true? */ ) { Term newTerm = { }; /* fillOutTerm(newTerm) */ /* Invalidates the subIter pointer, pretty sure. Anything else???? */ subIter->terms.push_back( newTerm ); //BAD? } } } } return 0; }
