[site]: stackoverflow
[post_id]: 1450025
[parent_id]: 1450004
[tags]: 
When using dynamic linking you are in effect building [at least] two binaries: the program per-se (.exe) and a dll. For the exe, the compiler/linker can detect unused portions of the code and only produce the minimal necessary in the output. With the DLL, however, all the functions and variables marked as exported (and all the code necessary to make these work) will have to be included in the ouput. That is because the compiler/linker have no way of knowing which of these functions may be used by programs (some of them to be written in the future...). However, since it appears you'll be writing both the exe and the dll(s), you can choose what will be exported, and hence only include the minimal necessary. EDIT : in readproofing I noted that actually you are considering using an open source library, so the above statement requires some qualification. If you build the open source code as-is (assuming the sources include a build for DLL), it will likely include all publicly declared functions of the library. You may however alter the list of methods declared for export and hence getting the minimal possible amount of binary. Using dynamic linking can lead to saving in the overall amount of binary needed, because several programs can make use of the same dll. For example, a graph plotting application and a video game program can share the same graphic utilities dll. In general, the choice about using dynamic linking or not, is not such a critical one . This issue was more a problem in the past, with slower CPU (hence longer build times) and other limits regarding memory, hard disk and also distribution bandwidth (with floppies! and such...). A modern rule of thumb, in these days and age of Gigabyte-sized storage, is to pick static linkage, by default, unless one of the following applies: the DLL is a 3rd party, publicly available DLL (i.e. one that the end users may update independantly of your own update cycle) Several portions of the application are typically not used, and the underlying logic can be "stowed-away" in a DLL, making for an overall smaller run-time footprint (when the users are not using the underlying specialized/advanced features. the program is part of a suite of programs, several of then having enough commonality that can be shared. it is desirable to have multiple versions of the application. For example you may implement a basic/free/limited version of the application, and a full featured one. Assuming you manage for the program to call either version of the features with the same API, the distinct behaviors can be encapsulated in the DLLs alone, allowing the paying users to merely download the "premium dll" and merely replace the other one (no installation needed). the software is beta, and one expects to send multiple revisions to the end user(s). (as with above, dll swap rather than re-install is nice). different parts of the application are written in different languages. In this case is is often possible to use static linking (by forcing the compilers to agree on calling conventions and such), but the DLL approach may also ease this cooperation. the software is produced by different programmers / teams. The DLL provides an implicit delineation of the responsibilities. There may be a few more cases, but again, unless there are some existing needs for DLL, static linking is just as good.
