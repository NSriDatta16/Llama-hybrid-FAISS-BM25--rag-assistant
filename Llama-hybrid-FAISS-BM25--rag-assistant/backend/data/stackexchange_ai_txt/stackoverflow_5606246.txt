[site]: stackoverflow
[post_id]: 5606246
[parent_id]: 5604930
[tags]: 
The annotations and AOP points are both valid. Use annotations to alert the AOP framework about the logging. Another thing I would do is fix your logger. You have: String LOG_METHOD = "nameOfMethod(String,List ):void" if(logger.isTraceEnabled()) { Object[] params = new Object[] { string, list }; logger.trace(CompanyMessages.newMethodInstanceMessage(this, LOG_METHOD, params) ); } Instead, consider something like this: logger.trace(this, LOG_METHOD, string, list); and you can implement it like this: public void trace(Object obj, Object args...) { if (parentLogger.isTraceEnabled()) { logger.trace(CompanyMessages.newMethodInstanceMessage(obj, LOG_METHOD, args); } } Most of the logging utilities were written before we had varargs in Java, so we still see things like what you've written. We also still want the guarding to prevent calling log when it's not enabled, but the primary motivation for that is because most folks in the past would do what you did, or, even worse: logger.trace("My message: " + string + " with list " + list); Which has has an expensive expression whether trace is enabled or not. But by leveraging varargs, you can get both. Simply use something like MessageFormat (which you are probably doing already), you can easily get: logger.trace("My message: {0} with list {1}", string, list); With trace disabled, this is a cheap method call passing 3 pointers. So there is far less motivation to guard it and clutter your code. Most of the modern loggers don't override nicely, so you typically have to encapsulate it rather than simply extend it. It doesn't directly solve your issue, dynamically generating trace information. But it's a simple middle ground that readily, and incrementally, clean up your existing code base. Also, there's 2 other options. One, is to use a post processor that runs through your code and adds the logging in to places where it doesn't already exists. This saves you the burden of typing is all by hand, but it does clutter the code (since it still exists EVERYWHERE). Two, is to use an annotation processor at compile time. This is more sophisticated. But what it does is during compilation, it runs through and augments your classes at compile time with the information. The nice thing is that your code is clean (save perhaps for the annotaion), but also all of the work is does at compile. There's not runtime impact not fancy classloaders of Object factories. Once it is built, you can toss your processor away, it's not needed at runtime at all. There's a project, who's name escapes me, that leverages this. It automatically adds setters/getter to your code at compile. I've heard good things about it. The AOP frameworks may well do this for you at compile, I'm not familiar enough with them to say, but either way, the technique is worth exploring. At a minimum, though, wrap your logger. It's incremental, safe, and will gradually clean your code and aid your logging where the annotations may not work for you in general.
