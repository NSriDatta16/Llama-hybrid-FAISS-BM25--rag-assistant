[site]: stackoverflow
[post_id]: 189604
[parent_id]: 184216
[tags]: 
As suggested already, you can use anonymous inner classes to implement the ActionListener interface. As an alternative, you don't have to use anonymous inner classes, but you can use a simple nested class instead: resetButton = new JButton(new ResetAction()); redButton = new JButton(new ColorAction("Red", Color.red)); and then... private class ResetAction extends AbstractAction { public ResetAction() { super("Reset"); } public void actionPerformed(ActionEvent e) { messageX = 75; messageY = 175; setForeground(Color.black); blackButton.setSelected(true); repaint(); } } private class ResetAction extends AbstractAction { private Color color; public ColorAction(String title, Color color) { super(title); this.color = color; } public void actionPerformed(ActionEvent e) { setForeground(color); repaint(); } } For why this approach - or any approach involving inner classes - is better than implementing ActionListener in the outer class see "Design Patterns": "Favor 'object composition' over 'class inheritance'." (Gang of Four 1995:20) Choosing between anonymous inner classes and these named inner classes is a largely a matter of style, but I think this version is easier to understand, and clearer when there are lots of actions.
