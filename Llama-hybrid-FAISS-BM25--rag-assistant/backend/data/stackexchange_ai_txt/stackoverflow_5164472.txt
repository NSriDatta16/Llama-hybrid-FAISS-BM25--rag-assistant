[site]: stackoverflow
[post_id]: 5164472
[parent_id]: 5164340
[tags]: 
Entries in a std::map must have a key and a value. The normal way of getting and setting them is: my_map[a_key] = new_value; // set do_something_with(my_map[a_key]); // get and use... If you want to add new functions, they probably wouldn't look like what you're proposing because: your set is only given one parameter despite needing a key and value (admittedly, you could adopt some convention like having the first ':' or '=' separate them), and the get() function doesn't provide any key. You could instead have something more like: void set(const Key&, const Value&); std::string get(const Key&) const; But, even if you have write permissions to do so, you shouldn't add that directly in the map header file - all C++ programs compiled on that computer will share that file and won't expect it to be modified. Any small mistake could cause trouble, and if you ship your program to another computer you won't be able to compile it there without making a similar modification - if that computer uses a different C++ compiler the necessary details of that modification may be slightly different too. So, you can either write your own (preferably templated) class that derives from (inherits) or contains (composition) a std::map, providing your functions in your custom class. An inheritance based solution is easier and more concise to write: template struct My_Map : std::map { My_Map(...); // have to provide any non-default constructors you want... void set(const Key& key, const Value& value) { operator[](key) = value; } // if you want entries for non-existent keys to be created with a default Value... Value& get(const Key& key) { return operator[](key); } --- OR --- // if you want an exception thrown for non-existent keys... Value& get(const Key& key) { return at(key); } const Value& get(const Key& key) const { return at(key); } }; This is slightly dangerous if you're planning to pass My_Maps around by pointer and accidentally end up with a "new My_Map" pointer that's later deleted as a std::map pointer, as in: void f(std::map * p) { /* use *p */ delete p; } My_Map * p = new My_Map ; f(p); Still, in most programs there's no real danger of accidentally disposing of a map like this, so go ahead and do it. Further, and this is the kind of thinking that'll make me unpopular with the Standard-fearing purists around here - because My_Map hasn't added any data members or other bases , the std::map<> destructor probably does all the necessary tear-down even though it's technically Undefined Behaviour. I'm NOT encouraging you to ignore the issue (and would consider it unprofessional in a job requiring robustness), but you can at least rest a little easier. I'd be curious to hear from anyone with any compiler/settings where it demonstrably doesn't operate safely. If you use composition, you'll have to write your own "forwarding" functions to let you use My_Map like a std::map, accessing iterators, find, erase, insert etc.. It's a pain.
