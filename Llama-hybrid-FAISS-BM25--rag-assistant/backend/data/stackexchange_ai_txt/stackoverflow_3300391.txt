[site]: stackoverflow
[post_id]: 3300391
[parent_id]: 3300120
[tags]: 
Yeah, this is a little annoying. Maybe someone has a simpler idea, but the solution (hack?) that we came up with was to look for the originally-requested URL that ASP.NET appends to the query string when the user is redirected to the login page. We created a new web.config section that stores a set of keys/values that match a fragment of the redirect URL to an authorization message: ...etc... ...etc... In the Page_Load() event of the Login.aspx page, we call a method that uses this URL to determine which (un)authorization event occurred then redirect them to a message page that displays the appropriate text: private void DisplayAppropriateAuthorizationMessage () { if ( !Page.User.Identity.IsAuthenticated ) return; string redirectUrl = FormsAuthentication.GetRedirectUrl( Page.User.Identity.Name, false ); if ( string.IsNullOrEmpty( redirectUrl ) ) return; NameValueCollection authorizationFailureMessages = ConfigurationManager.GetSection( "authorizationFailureMessages" ) as NameValueCollection; if ( authorizationFailureMessages == null ) return; foreach ( string key in authorizationFailureMessages.AllKeys ) { if ( redirectUrl.Contains( key ) ) { Response.Redirect( String.Format( "Message.aspx?{0}={1}", Constants.QueryStringKeys.ERRORMESSAGENAME, authorizationFailureMessages[ key ] ), true ); } } }
