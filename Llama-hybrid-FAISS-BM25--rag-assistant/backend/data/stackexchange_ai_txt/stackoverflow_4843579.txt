[site]: stackoverflow
[post_id]: 4843579
[parent_id]: 4840988
[tags]: 
Pattern Recursion With recursive patterns, you have a form of recursive descent matching . This is fine for a variety of problems, but once you want to actually do recursive descent parsing , you need to insert capture groups here and there, and it is awkward to recover the full parse structure in this way. Damian Conway’s Regexp::Grammars module for Perl transforms the simple pattern into an equivalent one that automatically does all that named capturing into a recursive data structure, making for far easier retrieval of the parsed structure. I have a sample comparing these two approaches at end of this posting. Restrictions on Recursion The question was what kinds of grammars that recursive patterns can match. Well, they’re certainly recursive descent type matchers. The only thing that comes to mind is that recursive patterns cannot handle left recursion . This puts a constraint on the sorts of grammars that you can apply them to. Sometimes you can reorder your productions to eliminate left recursion. BTW, PCRE and Perl differ slightly on how you’re allowed to phrase the recursion. See the sections on “RECURSIVE PATTERNS” and “Recursion difference from Perl” in the pcrepattern manpage. eg: Perl can handle ^(.|(.)(?1)\2)$ where PCRE requires ^((.)(?1)\2|.)$ instead. Recursion Demos The need for recursive patterns arises surprisingly frequently. One well-visited example is when you need to match something that can nest, such as balanced parentheses, quotes, or even HTML/XML tags. Here’s the match for balenced parens: \((?:[^()]*+|(?0))*\) I find that trickier to read because of its compact nature. This is easily curable with /x mode to make whitespace no longer significant: \( (?: [^()] *+ | (?0) )* \) Then again, since we’re using parens for our recursion, a clearer example would be matching nested single quotes: ‘ (?: [^‘’] *+ | (?0) )* ’ Another recursively defined thing you may wish to match would be a palindrome. This simple pattern works in Perl: ^((.)(?1)\2|.?)$ which you can test on most systems using something like this: $ perl -nle 'print if /^((.)(?1)\2|.?)$/i' /usr/share/dict/words Note that PCRE’s implementation of recursion requires the more elaborate ^(?:((.)(?1)\2|)|((.)(?3)\4|.)) This is because of restrictions on how PCRE recursion works. Proper Parsing To me, the examples above are mostly toy matches, not all that interesting, really. When it becomes interesting is when you have a real grammar you’re trying to parse. For example, RFC 5322 defines a mail address rather elaborately. Here’s a “grammatical” pattern to match it: $rfc5322 = qr{ (?(DEFINE) (? (?&mailbox) | (?&group)) (? (?&name_addr) | (?&addr_spec)) (? (?&display_name)? (?&angle_addr)) (? (?&CFWS)? (?&CFWS)?) (? (?&display_name) : (?:(?&mailbox_list) | (?&CFWS))? ; (?&CFWS)?) (? (?&phrase)) (? (?&mailbox) (?: , (?&mailbox))*) (? (?&local_part) \@ (?&domain)) (? (?&dot_atom) | (?&quoted_string)) (? (?&dot_atom) | (?&domain_literal)) (? (?&CFWS)? \[ (?: (?&FWS)? (?&dcontent))* (?&FWS)? \] (?&CFWS)?) (? (?&dtext) | (?&quoted_pair)) (? (?&NO_WS_CTL) | [\x21-\x5a\x5e-\x7e]) (? (?&ALPHA) | (?&DIGIT) | [!#\$%&'*+-/=?^_`{|}~]) (? (?&CFWS)? (?&atext)+ (?&CFWS)?) (? (?&CFWS)? (?&dot_atom_text) (?&CFWS)?) (? (?&atext)+ (?: \. (?&atext)+)*) (? [\x01-\x09\x0b\x0c\x0e-\x7f]) (? \\ (?&text)) (? (?&NO_WS_CTL) | [\x21\x23-\x5b\x5d-\x7e]) (? (?&qtext) | (?&quoted_pair)) (? (?&CFWS)? (?&DQUOTE) (?:(?&FWS)? (?&qcontent))* (?&FWS)? (?&DQUOTE) (?&CFWS)?) (? (?&atom) | (?&quoted_string)) (? (?&word)+) # Folding white space (? (?: (?&WSP)* (?&CRLF))? (?&WSP)+) (? (?&NO_WS_CTL) | [\x21-\x27\x2a-\x5b\x5d-\x7e]) (? (?&ctext) | (?&quoted_pair) | (?&comment)) (? \( (?: (?&FWS)? (?&ccontent))* (?&FWS)? \) ) (? (?: (?&FWS)? (?&comment))* (?: (?:(?&FWS)? (?&comment)) | (?&FWS))) # No whitespace control (? [\x01-\x08\x0b\x0c\x0e-\x1f\x7f]) (? [A-Za-z]) (? [0-9]) (? \x0d \x0a) (? ") (? [\x20\x09]) ) (?&address) }x; As you see, that’s very BNF-like. The problem is it is just a match, not a capture. And you really don’t want to just surround the whole thing with capturing parens because that doesn’t tell you which production matched which part. Using the previously mentioned Regexp::Grammars module, we can. #!/usr/bin/env perl use strict; use warnings; use 5.010; use Data::Dumper "Dumper"; my $rfc5322 = do { use Regexp::Grammars; # ...the magic is lexically scoped qr{ # Keep the big stick handy, just in case... # # Match this... # As defined by these... | | ? ? \ \> ? : (?: | )? ; ? ** (,) \@ | | ? \[ (?: ? )* ? | | [\x21-\x5a\x5e-\x7e] | | [!#\$%&'*+-/=?^_`{|}~] ? + ? ? ? + (?: \. +)* [\x01-\x09\x0b\x0c\x0e-\x7f] \\ | [\x21\x23-\x5b\x5d-\x7e] | ? (?: ? )* ? ? | + # Folding white space (?: * )? + | [\x21-\x27\x2a-\x5b\x5d-\x7e] | | \( (?: ? )* ? \) (?: ? )* (?: (?: ? ) | ) # No whitespace control [\x01-\x08\x0b\x0c\x0e-\x1f\x7f] [A-Za-z] [0-9] \x0d \x0a " [\x20\x09] }x; }; while (my $input = <>) { if ($input =~ $rfc5322) { say Dumper \%/; # ...the parse tree of any successful match # appears in this punctuation variable } } As you see, by using a very slightly different notation in the pattern, you now get something which stores the entire parse tree away for you in the %/ variable, with everything neatly labelled. The result of the transformation is still a pattern, as you can see by the =~ operator. It’s just a bit magical.
