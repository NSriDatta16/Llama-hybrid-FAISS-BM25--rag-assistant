[site]: stackoverflow
[post_id]: 1812785
[parent_id]: 1213728
[tags]: 
It turns out to get around the problem with SqlType(DbType.Object) being unsupported by the Dialect, we make it supported by subclassing the SQLiteDialect with explicit support: public class SQLiteDialectWithManifestTyping : SQLiteDialect { public SQLiteDialectWithManifestTyping() : base() { base.RegisterColumnType(DbType.Object, "NONE"); } } To use this dialect in Fluent, call Dialect() on your SQLiteConfiguration object. In NHibernate, set the configuration property dialect appropriatelly (see section 3.5.1 of the ref manual). Then we can apply the above DataElementType implementation for our mappings (need to change the SqlTypes definition to this: public SqlType[] SqlTypes { get { return new[] { new SqlType(DbType.Object) }; } } Notes: It is not perfect. There is a tendency to upcast all discrete numbers to Int64 and floats to double. There is no implicit way to store large unsigned values (e.g. values of ulong >= long.MaxValue) but this is a general sqlite problem (and possible a general ado.net problem?). Due to the loss of compile time checking it is probably desireable to put some runtime checks in the NullSafeSet method to ensure the value is a primitive type. Attempting to store general objects seems to just cause the objects ToString() method to be called.
