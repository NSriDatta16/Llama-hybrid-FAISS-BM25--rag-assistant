[site]: stackoverflow
[post_id]: 299772
[parent_id]: 52952
[tags]: 
You can't just test reader["field"] for null or DBNull because a IndexOutOfRangeException is thrown if the column isn't in the reader. The code I use in my mapping layer for creating domain objects and the stored procedures that use the mapping layer might have different column names is below; you could modify it to not throw an exception if the column isn't found and return default(t) or null. I understand this isn't the most elegant or optimal solution (and really, if you can avoid it then you should), however, legacy stored procedures or Sql queries might warrant a work-around. /// /// Grabs the value from a specific datareader for a list of column names. /// /// Type of the value. /// Reader to grab data off of. /// Column names that should be interrogated. /// Value from the first correct column name or an exception if none of the columns exist. public static T GetColumnValue (IDataReader reader, params string[] columnNames) { bool foundValue = false; T value = default(T); IndexOutOfRangeException lastException = null; foreach (string columnName in columnNames) { try { int ordinal = reader.GetOrdinal(columnName); value = (T)reader.GetValue(ordinal); foundValue = true; } catch (IndexOutOfRangeException ex) { lastException = ex; } } if (!foundValue) { string message = string.Format("Column(s) {0} could not be not found.", string.Join(", ", columnNames)); throw new IndexOutOfRangeException(message, lastException); } return value; }
