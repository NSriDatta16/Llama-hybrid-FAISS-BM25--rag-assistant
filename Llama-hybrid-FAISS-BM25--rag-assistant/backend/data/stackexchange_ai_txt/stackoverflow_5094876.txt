[site]: stackoverflow
[post_id]: 5094876
[parent_id]: 5002316
[tags]: 
I disagree with the notion that an object must be destroyed by the one that created it. Many times this is the natural choice but its certainly not the only way of managing memory. A better way to look at it is that an object's lifetime should end when it is no longer needed. So what options do you have? Use Interface reference counting In many cases it is trivial to extract an interface from an existing class so don't shelve this idea just because your working with legacy code. Use an IoC container that supports lifetime management. There are a number of IoC containers for Delphi and more are popping up all the time. Spring for Delphi is one that I know of that supports lifetime management. Note: most of these containers target Delphi 2010 or newer so it may be difficult to find one for legacy code. Use a garbage collector. The Boehm GC memory manager is the only one I'm aware. All three of these can be combined with poor man's dependency injection to get the testing benefits while making minimal changes to your legacy code. For those unfamiliar with the term you use constructor chaining to instantiate a default dependency. constructor TMyClass.Create; begin Create(TMyDependency.Create); //Create(IoCContaineror.Resolve(TMyDependency)); end; constructor TMyClass.Create(AMyDependency: TMyDependency) begin FMyDependency := AMyDependency; end; Your production code continues to use the default constructor with the real object while your tests can inject a fake/mock/stub to sense what the class being exercised is playing nicely. Once your test coverage is high enough you can remove the default constructor.
