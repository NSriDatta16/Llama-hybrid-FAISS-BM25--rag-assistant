[site]: stackoverflow
[post_id]: 396494
[parent_id]: 396327
[tags]: 
Mark Santesson's answer is pretty much on the money, but the assertation that there are no vtables is incorrect. You can use g++ -fdump-class-hierarchy to show what's going on. Here's the no virtuals case: Class Base size=4 align=4 base size=4 base align=4 Base (0x19a8400) 0 Class X size=8 align=4 base size=8 base align=4 X (0x19a8440) 0 Base (0x19a8480) 0 Class Y size=8 align=4 base size=8 base align=4 Y (0x19a84c0) 0 Base (0x19a8500) 0 Class Z size=16 align=4 base size=16 base align=4 Z (0x19b1800) 0 X (0x19a8540) 0 Base (0x19a8580) 0 Y (0x19a85c0) 8 Base (0x19a8600) 8 Pay particular attention to the "base size" argument. Now the virtuals case, and showing only Z: Class Z size=20 align=4 base size=16 base align=4 Z (0x19b3000) 0 vptridx=0u vptr=((& Z::_ZTV1Z) + 12u) X (0x19a8840) 0 primary-for Z (0x19b3000) subvttidx=4u Base (0x19a8880) 16 virtual vbaseoffset=-0x0000000000000000c Y (0x19a88c0) 8 subvttidx=8u vptridx=12u vptr=((& Z::_ZTV1Z) + 24u) Base (0x19a8880) alternative-path Note the "base size" is the same, but the "size" is one pointer more, and note that there is now a vtable pointer! This in turn contains the construction vtables for the parent classes, and all the inter-class magic (construction vtables, and virtual table table (VTT)), as described here: http://www.cse.wustl.edu/~mdeters/seminar/fall2005/mi.html Note that the actual function dispatch vtable will be empty.
