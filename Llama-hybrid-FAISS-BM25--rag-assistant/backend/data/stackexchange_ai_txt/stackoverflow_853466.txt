[site]: stackoverflow
[post_id]: 853466
[parent_id]: 846487
[tags]: 
Having not been able to get Uri.EscapeDataString to take on RFC 3986 behavior, I wrote my own RFC 3986 compliant escaping method. It leverages Uri.EscapeDataString, and then 'upgrades' the escaping to RFC 3986 compliance. /// /// The set of characters that are unreserved in RFC 2396 but are NOT unreserved in RFC 3986. /// private static readonly string[] UriRfc3986CharsToEscape = new[] { "!", "*", "'", "(", ")" }; /// /// Escapes a string according to the URI data string rules given in RFC 3986. /// /// The value to escape. /// The escaped value. /// /// The method is supposed to take on /// RFC 3986 behavior if certain elements are present in a .config file. Even if this /// actually worked (which in my experiments it doesn't ), we can't rely on every /// host actually having this configuration element present. /// internal static string EscapeUriDataStringRfc3986(string value) { // Start with RFC 2396 escaping by calling the .NET method to do the work. // This MAY sometimes exhibit RFC 3986 behavior (according to the documentation). // If it does, the escaping we do that follows it will be a no-op since the // characters we search for to replace can't possibly exist in the string. StringBuilder escaped = new StringBuilder(Uri.EscapeDataString(value)); // Upgrade the escaping to RFC 3986, if necessary. for (int i = 0; i
