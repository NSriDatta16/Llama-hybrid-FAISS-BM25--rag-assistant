[site]: stackoverflow
[post_id]: 4150937
[parent_id]: 
[tags]: 
Error getting correct text after pushing, and then getting the front() from the std::queue

I am in a bit of a trouble here... I will start with the requirements first: Try to send data (msg) to the server If it fails, store it in a local hard disk file, as a list of CSV entries Try to send the msg data to the server at some predetermined point. If a msg is sent successfully, remove it from the file Continue the process till sending data to server fails. and go to step 2 What I have done: Used fstream object to write the failed msgs to a local file Used fstream object to read from this file, and store in a dynamically created std::queue For each msg read from the file, push it in the queue After pushing all msgs, take the first msg using std::front(), and read it into the custom object data structure. The problem is: I print the msgs read from the hard disk file before and after pushing it into the queue. Before pushing the queue, the data I print into a messageBox/text file logs is absolutely fine. But when I print the same data after getting the queue:front() it prints all junk. * I am not an expert on queues and STLs, so I need a guiding hand. The code is as follows: class CDFCQueueMsgs { public: char chDFCMsg_1; char chDFCMsg_2; char chDFCMsg_3; char chDFCMsg_4; char chDFCMsg_5; }; // This is how I created the fstream obj to read the file fstream_IOData_Read.open(pChPersistingFileLocation, ios::in); // The CSVs that I write to and read back from the file are like: // 1111222233334444,1234,05,0011123456,20100102112233,1234567890,7,N // Given below is how I write to the file: void CDataQueueingAndPersisting::WriteQueueMsgsToFile(char *pchAppendMsgToPersistentFile) { char chWriteBuffer[512] = {0}; fstream_IOData_Write.flush(); sprintf(chWriteBuffer, "%s\r\n", pchAppendMsgToPersistentFile); if(NULL != pchAppendMsgToPersistentFile) fstream_IOData_Write.write(chWriteBuffer,strlen(chWriteBuffer)); } // Given below is how I read from the file: while(fstream_IOData_Read >> chSingleDFCMsg) { bDataRead = ReplicateQueueInProcessMemory( (BYTE*) chSingleDFCMsg); RtlZeroMemory(chSingleDFCMsg, sizeof(chSingleDFCMsg)); } // ReplicateQueueInProcessMemory is like: pChDelimitedStrPtr = strtok((char *)byteSingleRawQueueMsg, ","); // to read every comma delimited field in the single line as shown above. I use multiple strtok()s to read all the fields of the string. // After this I get the front message in the queue: CDFCQueueMsgs oDfcQueueMsg_TopMsg; CDFCQueueMsgs & refDfcQueueMsg_TopMsg = oDfcQueueMsg_TopMsg; refDfcQueueMsg_TopMsg = *oCDataQueueingAndPersisting.poDFCMsgQUEUE.front(); // Now I get the respective member fields to the object type the queue holds: strncpy(g_chBuffer, refDfcQueueMsg_TopMsg.chDFCMsg_1, sizeof(refDfcQueueMsg_TopMsg.chDFCMsg_1)); // Now I Log the "g_chBuffer" variable in my log files. I also log each field in my logs: /* Before Pushing into queue, I log the string from the read buffer, the fields get logged fine like this: 09:50:45:093 EVENT: chDFCMsg_1:1111222233334444 chDFCMsg_2:1234 chDFCMsg_3:05 chDFCMsg_4:0011123456 chDFCMsg_5:20100102112233 After pushing and gettting the Queue::front() I see the same fields like this: 10:45:54:495 EVENT: 2 ÃÛ¬S 10:45:54:495 EVENT: ¬S 10:45:54:495 EVENT: á 10:45:54:495 EVENT: 10:45:54:495 EVENT: */ Thanks, Daniel
