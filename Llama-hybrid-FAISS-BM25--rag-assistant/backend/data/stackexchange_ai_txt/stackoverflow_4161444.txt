[site]: stackoverflow
[post_id]: 4161444
[parent_id]: 4150649
[tags]: 
Your outer loop—where you're checking for your istream_iterator to have reached its end—is tied to state stored in the istream 's inherited ios_base . The state on the istream represents the outcome of recent extraction operations performed against the istream itself , not the state of its underlying streambuf . Your inner loop—where you're using istreambuf_iterator to extract characters from the streambuf —is using lower-level functions like basic_streambuf::sgetc() (for operator* ) and basic_streambuf::sbumpc() (for operator++ ). Neither of those functions set state flags as a side effect, apart from the second one advancing basic_streambuf::gptr . Your inner loop works fine, but it's implemented in a sneaky way packaged as it is, and it violates the contract of std::basic_istream& operator>>(std::basic_istream&, T&) . If the function fails to extract an element as intended, it must call basic_ios::setstate(badbit) and, if it also encountered end-of-stream while extracting, it must also call basic_ios::setstate(eofbit) . Your extractor function sets neither flag when it fails to extract a Foo . I concur with the other advice here to avoid use of istreambuf_iterator for implementing an extraction operator meant to work at the istream level. You're forcing yourself to do extra work to maintain the istream contract, which will cause other downstream surprises like the one that brought you here.
