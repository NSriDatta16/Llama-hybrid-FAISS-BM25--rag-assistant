[site]: stackoverflow
[post_id]: 4967863
[parent_id]: 
[tags]: 
Uniface Uniface, owned by the Compuware Corporation (CPWR), is an environment for the creation of enterprise level business systems. It has been categorised as a 4th Generation Language (4GL), and a Rapid Application Development (RAD) tool. It is a model-driven development and deployment environment with its own editing suite, high-level procedural language and integrated, scalable servers capable of producing and managing sophisticated client-server and rich internet applications (RIA). Originally called UNIS, the product was created in the Netherlands in 1984 by a company called Inside Automation. The company was headed by Bodo Douque, with Frits Kress as Technical Director. Both the product and the company changed their name to Uniface by the time of the first release, Version 3, in 1986. Early versions of the product were bundled with the Sybase RDBMS under the name FastBuild, although it was not limited to accessing only that database. By the early 1990s Uniface had a presence in more than 30 countries worldwide and revenues in excess of $50M. In 1994 the company was acquired by the Detroit based Compuware Corporation, although development remained in Amsterdam, as it does today. First Principles Uniface was developed on the principles of the American National Standards Institute, (ANSI), 3-schema architecture. First proposed in 1975 this was a standard approach to the building of database management systems consisting of 3 schema (or metamodels): External schema - The different external (user) views of the data. There can be many external schemas for a database. Conceptual schema – Definition of all the data items and relationships between them. There is only one conceptual schema per database. Internal schema – Definition of the physical representation of the stored data. The founder’s ethos was that Uniface should be database independent and so they concentrated on External and Conceptual Schema, leaving internal to the many RDBMS to which it could be connected. Uniface today operates in the 3-tier architecture model. This should not be confused with the 3 schema architecture. The latter separates the logic of the application. 3 or n-tier applications divide up the physical components. Conceptual Schema (Application Model) In the Conceptual Schema, later renamed as Application Model, entities (tables), fields, keys (indexes) and relationships are defined together with referential integrity; although this is often implemented at the database level as well as, perhaps, within Uniface. Each entity and field in the model has properties and a set of triggers. Some triggers represent user or system events, for example Occurrence Gets Focus, Read or Leave Field. Others cover matters such as validation or can be place holders for methods associated with the particular object. Developers add Uniface proc code, its procedural language, to the triggers. In this way, or through the use of declaratives associated with the properties, business rules can be added to the model, that are, in turn, “inherited” by the external schema, as described below.. It was through the use of model level triggers that Uniface sought to bring together properties and behaviour within business objects. It was this separation of the logical from the physical data structures that differentiated Uniface from many other products of the time. External Schema and inheritance Objects described in the Conceptual Schema (Application Model) are reused by the external schema, which were later renamed simply as forms. Developers “paint” objects from the model on the form, for example Customer or Invoice. They can also add form level objects not described in the model. Where model objects are painted, the properties and triggers defined in the model are inherited by being copied into the form. Where a specific behaviour is required, that varies from the model defined rules, these definitions can be changed at the form level to make, what are termed, local variations. It is possible to restore the link to the model. If the model code or properties is changed at the model level, all forms holding that object need only be recompiled to collect the new definitions. This provides benefits in maintenance and ensuring that the rules associated with the object are available wherever it is used. From External Schema to Components Over time, External Schema became Forms. Hidden forms, which ran in the background without displaying to the user, were formalised and became Services. Services were later split into 3 types, Session Services, for objects of the Business Tier, Entity Services, which may be either Business or Data tier and technical Services. Forms that were printed instead of displayed, were also formalised into Report components. From Uniface Version 7, a new component type, Uniface Server Page (USP) was introduced for Web development. In Uniface 9.4 a new Dynamic Server Page is added. All of these components adhere to the principles of Uniface inheritance from the model. Virtual Machine Uniface was developed on the DEC-VAX machine, using the native VAX file-management system RMS. A link can still be seen in today’s product by its continued use of a “GOLD” key to change modes (DEC VT terminals actually had a gold or yellow key on the keyboard. Today the “GOLD” is simply mapped the numeric keyboard + key or a function key). However, from the outset, it was designed to be multi-platform, using a virtual machine and interpretation of an intermediate code into which its objects are compiled. The same path that, later, JAVA and other languages would follow. Components can be compiled on one machine and executed on another providing the Uniface Virtual Machine is present. Today Uniface operates from “mobile to mainframe” under Windows, VMS, AS400, z/OS and various flavours of UNIX and LINUX. Repository Based Uniface is repository based, maintaining a database of its own meta data for the purposes of reuse– the procedural code, component layouts, models et al. The repository is proprietary but open, its structure being fully documented and available. However, it is not a good idea to interface directly with the repository other than, perhaps, for reporting. It is a sophisticated model and best accessed through the Uniface Development Environment (UDE). Having this centralised repository means that developers share the objects they create. Although it takes some careful configuration management to handle versioning, it should mean that everyone is using the same definition for the same thing. Parallel development is the way in which time to marked is shortened: Whilst groups or developers may work on an encapsulated element of the whole, it is inevitable that definitions will be shared and need to be centralised and controlled. No Hacking please! - Repository Integrity Many 4GLs produced SQL embedded in C, or other languages, as the output from their definitions. This output was then compiled locally. When developers were testing, it was not unknown that they would directly modify the output, changing the C or the SQL and, consequently, losing the synchronisation between the executable and the repository definitions. With Uniface using an intermediate code and the Virtual Machine, this was not possible. To change the output, the developer must return to the Uniface Development Environment (UDE) to modify and recompile, thereby maintaining the integrity of the repository. The Database Connection Those 4GLs that output embedded SQL have the issue that they must look for the lowest common denominator in terms of making that SQL work with as many databases as possible. This prevents, in many cases, the best use of the database and its extensions. From the outset Uniface delivered connectors, or “drivers”, as the link to the many databases and file systems it supported. Driver mapping meant that Uniface types could be converted into the most suitable format of the particular storage medium. Database extensions could be employed through the use of specific parameters at run time. Additionally, Uniface supplied a connector “cookbook” should you wish to create your own driver. Provided the database driver is licensed, data can be converted between different data sources. ‘Not joining the union’ Uniface automates most input output operations through its kernel and default code. The database driver interface converting Uniface operations into the necessary SQL or other DML. When one entity is “painted” within another on a component, Uniface will use the relationships defined in the Application model to automatically retrieve related occurrences between parent and child. However, this is done one table at a time; Uniface does not use joined reads. There is a clear and compelling reason for this: Each table used on a Uniface component may originate from a different database or source. Uniface can maintain referential integrity across the multiple platforms and even transaction integrity providing the underlying databases support two-phase commit. It is possible to use code to modify these default behaviours and direct sql can be embedded if required. Assignment and Configuration When constructing applications, most developers need to take into account the target environment in which it will run: Operating system, database, network etc. One of the strengths of Uniface is that its database and platform independence allows developers to concentrate of the application; not the environment. Uniface uses a system of assignment files to determine: locations for data; multiple databases of varying types can be assigned to a single application where services are executed; multiple locations can be assigned. where 3GL or other non-uniface objects are executed; once again multiple locations can be assigned locations for the storage of its own runtime objects. Load balancing and fail over can be configured through assignments Evolution Uniface has opted for evolution over revolution; it has not left its customers on technology islands. Migration to the latest release, from systems written in what are now unsupported early versions, still take place today. Summary of Versions Each release brings an enriched proc language, new widgets and triggers, improvements in productivity and closer compliance with industry standards. It would be long list to enumerate each and every one of these, so set out below is only a very brief summary of the major changes of each version release: Uniface Version 3 (1986) Multiple database (RMS, Oracle, C_ISAM, Ingres and RDB) and platform support; Virtual machine interpretation; the Structure Editor, the Uniface text and command editor. Uniface Version 4 (1988) Improved form editor; Improved printing and display support; MS-DOS version; CASE tool interface. Uniface Version 5 (1990) Uniface 5 brought Client/Server deployment with the introduction of remote database access through Polyserver; Universal Presentation Interface (UPI) – graphical as well as character interface; supported some 13 databases and file systems; Available on DOS, VMS, OS/2, Stratus VOS and UNIX; Japanese character support. Uniface Six (1994) Uniface Six (it was never to be referred to as Version 6) sealed the move to the fully graphical development environments. Graphical form painter and application model editor. Improved deployment through Dynamic Object Libraries; Support for Microsoft Object Linking and Embedding (OLE). Support for MAC; Permissions; integrated Version Control; Personal Series reporting tools (later removed when the 3rd party decided not to enhance the product); Wider platform support. Uniface Seven (1997) Uniface Seven was mainly concerned with component integration, for both Uniface and external components, through the introduction of the Uniface Request Broker (URB) architecture; The URB supports bi-directional and synchronous or asynchronous communication between components. As well as remote data access, it added partitioned Application Servers and messaging. Seven also delivered the first Uniface web development and deployment tools with Web Application Server and Uniface Request Dispatcher. Components (Services, Server Pages, Reports); Signature editor and Assembly workbench; subsystems; Operations; Non-modal forms; Instances; Improved editors and navigation; Enhanced editor plug-in; New debugger; Online help and documentation; Component templates; Web Application Server. Improved validation. Uniface Name Server and graphical partitioning manager Uniface 8 (2001) Uniface 8 brought about major changes in the area of process integration. Uniface Urouter and Userver provide scalable, balanced deployment. The Web Request Dispatcher (WRD) replaced the URD, improving performance, plus support for Web Services, with SOAP and XML, were introduced. Connectivity and interoperability were improved and a method for implementing 3-tier architecture introduced. SOAP, COM, CORBA and MQSeries drivers; Improved window and local file management; Udeploy, improving application distribution; component subtypes for 3-tier; handles and automatic garbage collection. Uniface 9(2006) The themes of the Uniface 9 release were GUI, usability, thin deployment and integration. Uniface now supports deployment to mobile devices. Easy Deployment is a much simplified method of application deployment and configuration using zipped archives. Support for Unicode improves what was an already impressive multilingual capability. It also brings Uniface more into line with industry standards, as do the improvements in Web Development and XML handling. Dynamic field movement in form components has removed some of the old barriers to flexibility. Improved colour handling; dynamic menus, XML Component API; new Diagram Editor for Application Model; cross-reference; enhanced web services functionality. Uniface9.4(2010) Uniface 9.4, released in 2010, concentrates on bringing Rich Internet Development to Uniface. Related Software Since Uniface 7, there has been a business integration portal, called Uniface View, and a tool for the modeling, integration and management of Business Processes in Uniface Flow. Uniface Jti is a server based, thin client solution for delivering web-enabled applications over the Internet or Intranet, providing high-performance in low-bandwidth connections. . Licensing Licensing is managed through the Compuware Distributed License Manager(DLM), a server based system of distributing licenses to clients on request, precluding the need for them to be held locally. Uniface today In the 25 years of Uniface, 4GLs have become somewhat unfashionable. Many of its original competitors have disappeared but Uniface continues to thrive, delivering a highly-productive environment for the building of business applications that are database and platform independent allowing one code line to operate from mobile to mainframe.
