[site]: stackoverflow
[post_id]: 4161065
[parent_id]: 4160981
[tags]: 
The answer to (a) is short, but I'll go into more detail below: The compiler doesn't actually do the chaining - it happens at runtime, through the normal organization of the objects! There's far less magic here than what might appear at first glance - Jon Skeet recently completed the "Where clause" step in his blog series, Re-implementing LINQ to Objects. I'd recommend reading through that. In very short terms, what happens is this: each time you call the Where extension method, it returns a new WhereEnumerable object that has two things - a reference to the previous IEnumerable (the one you called Where on), and the lambda you provided. When you start iterating over this WhereEnumerable (for example, in a foreach later down in your code), internally it simply begins iterating on the IEnumerable that it has referenced. "This foreach just asked me for the next element in my sequence, so I'm turning around and asking you for the next element in your sequence". That goes all the way down the chain until we hit the origin, which is actually some kind of array or storage of real elements. As each Enumerable then says "OK, here's my element" passing it back up the chain, it also applies its own custom logic. For a Where , it applies the lambda to see if the element passes the criteria. If so, it allows it to continue on to the next caller. If it fails, it stops at that point, turns back to its referenced Enumerable, and asks for the next element. This keeps happening until everyone's MoveNext returns false, which means the enumeration is complete and there are no more elements. To answer (b) , there's always a difference, but here it's far too trivial to bother with. Don't worry about it :)
