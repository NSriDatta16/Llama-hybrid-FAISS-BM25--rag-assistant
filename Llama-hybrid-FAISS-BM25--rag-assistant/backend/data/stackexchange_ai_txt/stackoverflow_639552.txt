[site]: stackoverflow
[post_id]: 639552
[parent_id]: 639070
[tags]: 
I love stuff like this. Looks like it's more complicated than either of the other two answers so far have suggested. Here's a solution that will work. My apologies for the nasty formatting. Also, this will work in SQL Server, but I haven't used Access in forever, so you might need to adjust this a bit to work there. Or it may not work at all if Access doesn't support non-equijoins. SELECT productId, MAX(tbl.TimeBetween) FROM (SELECT status_1.productId as productId, status_1.statusDate as status1Date, MIN(status_3.statusDate) as status3Date, DATEDIFF(m,status_1.statusDate, MIN(status_3.statusDate)) as TimeBetween FROM (SELECT productId, status, statusDate FROM log WHERE status = '01') status_1 INNER JOIN (SELECT productId, status, statusDate FROM log WHERE status = '03') status_3 ON status_1.productId = status_3.productId AND status_3.statusDate > status_1.statusDate GROUP BY status_1.productId, status_1.statusDate) tbl GROUP BY productId, status3Date ORDER BY productId, TimeBetween The innermost selects get the records for each status. Those are then joined to give the '03' status records that are greater than their corresponding '01' records (how often do you get to use a non-equijoin?) They are then filtered to give the MIN '03' record that is still after the corresponding '01' record. The outermost select enforces your 'first time it reached '01' status rule' since it may go to '01' status multiple times before reaching '03' status. If someone else has a more elegant solution, I'd love to see it. I have had to write similar queries to this in the past, and I'd love to see a better solution to this type of problem.
