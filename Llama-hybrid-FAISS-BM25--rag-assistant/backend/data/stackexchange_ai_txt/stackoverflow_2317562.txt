[site]: stackoverflow
[post_id]: 2317562
[parent_id]: 667124
[tags]: 
You could use pthread_cleanup_push() to push a cancellation cleanup handler onto the threads cancellation cleanup stack. This handler would be responsible for unlocking the critical section. Once you leave the critical section you should call pthread_cleanup_pop(0) to remove it. i.e. CRIITICAL_SECTION g_section; void clean_crit_sec( void * ) { LeaveCriticalSection( &g_section ) } void *thrfunc( void * ) { EnterCriticalSection( &g_section ); pthread_cleanup_push( clean_crit_sec, NULL ); // Do something that may be cancellable LeaveCriticalSection( &g_section ); pthread_cleanup_pop( 0 ); } This would still leave a small race condition where the critcial section has been unlocked but the cleanup handler could still be executed if the thread was canceled between the Leave.. and the cleanup_pop. You could call pthread_cleanup_pop with 1 which would execute your cleanup code and not levae the critical section yourself. i.e CRIITICAL_SECTION g_section; void clean_crit_sec( void * ) { LeaveCriticalSection( &g_section ) } void *thrfunc( void * ) { EnterCriticalSection( &g_section ); pthread_cleanup_push( clean_crit_sec, NULL ); // Do something that may be cancellable pthread_cleanup_pop( 1 ); // this will pop the handler and execute it. }
