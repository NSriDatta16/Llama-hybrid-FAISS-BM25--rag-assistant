[site]: stackoverflow
[post_id]: 2650915
[parent_id]: 2628118
[tags]: 
Okay, now it seems I can't even sleep at night because I think about this problem... but it also seems I finally got an O(n log n) solution, in average case (but with reduced chances of having a pathological input compared to @lVlad ). We all know the Divide and Conquer technic. To ensure O(n log n) using it, we usually focus on 2 points: the divide and merge should be O(n) there exist C > 1 such that at each step the size of the subproblems is reduced by a factor C (constant throughout the problem) With these constraints in mind I have elaborated the following algorithm, which is reminiscent of qsort , and thus suffer the same pitfalls (namely, fractal inputs). Algorithm Clipping : we only consider the portion of a red that intersect with blue , they are inserted in a HashSet to remove duplicates --> O(n) Pivot Selection : more on this later --> O(n) Partition : once we have a pivot, we subdivise the space in 3 d zones, one of which being the pivot, with d being the dimension (d = 1 for segments, 2 for rectangles, 3 for cubes etc...) Repartition : we put the red in the partitions, applying the Clipping technic, note that a given red might end up giving several chunks in different partitions Recursion : we apply recursively (from step 2) on each partition, beginning by the least populated one and stopping as soon as one is not covered The Pivot Choice is the corner stone of the algorithm, if the partition is ill-tailored we cannot achieve the required complexity. Also, it must be accomplished in O(n) . I have 2 proposals so far: Maximum Area : use the rectangle with the greatest area, because it means that the partitions will have the smallest area afterward, however it suffers from being easy to trump Median of 3 : based on qsort, pick up 3 elements, selection the median (the one with the center closer to the barycenter of the 3 centers) I propose to mix them up thusly: Pick up the 3 elements with the greatest area, select the median, use it at pivot If after the repartition it turns out that one of the partition is populated with more than N/C (to be customized) elements, pick up 3 elements at random, select the median, and do the repartition (no check here) Another aspect of implementation is the Tail of the recursion. Like qsort it's probable that the algorithm is inefficient for small n . Instead of going all the way to 1, I propose to use the introsort trick: if n is smaller than say 12, then use the following algorithm instead: For each axis, project each red on the axis (only the edges) and sort them (ala introsort) This defines a raster of n d zones, check that each is covered Dimension agnostic The algorithm is formally defined to be applicable in any given dimension with the same asymptotic complexity, in average O(n log n) . This gives us the opportunity to test in dimension 1 to identify the pathological inputs. Pathological input Like qsort on which it is modelled it is sensible to factorial inputs. By factorial inputs I mean: 1.......6...9.11.13 whenever you pick the average of your interval, you have all the elements on one side of it. With such an input even choosing the median of 3 is unlikely to yield a very good cut. EDIT: I am going to show the partition idea with a little scheme, as @lVlad noted it was kind of fuzzy. +----------------+----+---------+ | 1 | 2 | 3 | +----------------+----+---------+ | 8 | P | 4 | +----------------+----+---------+ | 7 | 6 | 5 | +----------------+----+---------+ Okay, so the rectangle we check for coverage is now splitted into 9 subrectangles. We ignore P, it's our pivot. Now, we would really like that each subrectangle is covered by less red than N . The pivot is chosen as a barycenter of the centers, thus it means if our "random" choice held true that there are about as many red s centers in each direction of the pivot. It's kind of fuzzy there because some special configurations might make it so that there is little gain at one step (all rectangles have the same center and we just picked the smaller one for example), but it will create chaos and thus the following step will be different. I am happy if anyone can formalize that, I am an engineer, not a computer scientist, and my maths lag behind...
