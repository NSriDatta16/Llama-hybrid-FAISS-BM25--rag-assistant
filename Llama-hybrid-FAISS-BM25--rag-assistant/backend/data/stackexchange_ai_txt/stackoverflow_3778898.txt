[site]: stackoverflow
[post_id]: 3778898
[parent_id]: 509144
[tags]: 
It appears as though other are also taking the route (no pun intended) of putting the parameters in the context Items collection. http://bbits.co.uk/blog/archive/2008/05/19/using-asp.net-routing-independent-of-mvc---passing-parameters-to.aspx I combined a couple of these approaches for pages that have a specific parameter, I created a UserNameRouteHandler for pages that accept that type of parameter. In my PageBase class I checked the context items for that parameter and then set a property so that my pages that inherit from PageBase can use it. public class UserNameRouteHandler : IRouteHandler { #region Implementation of IRouteHandler public IHttpHandler GetHttpHandler(RequestContext requestContext) { string pageName = requestContext.RouteData.GetRequiredString("PageName"); string employeeUserName = requestContext.RouteData.GetRequiredString("UserName"); if(!string.IsNullOrEmpty(employeeUserName)) { requestContext.HttpContext.Items["UserName"] = employeeUserName; } pageName = pageName.ToLower() == "home" ? "default" : pageName; string virtualPath = string.Format("~/{0}.aspx", pageName); return (Page)BuildManager.CreateInstanceFromVirtualPath(virtualPath, typeof(Page)); } #endregion } And in my OnLoad of PageBase I set the property to pages that need it can have it...definitely looking for a more elegant solution though. protected override void OnLoad(EventArgs e) { if (!IsPostBack) { if (Context.Items["UserName"] != null) { EmployeeUserName = Context.Items["UserName"].ToString(); } } base.OnLoad(e); }
