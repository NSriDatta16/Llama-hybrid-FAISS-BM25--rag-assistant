[site]: stackoverflow
[post_id]: 2964924
[parent_id]: 2964613
[tags]: 
Members of an interface type are always public. Which requires their method implementation to be public as well. This doesn't compile for example: interface IFoo { void Bar(); } class Baz : IFoo { private void Bar() { } // CS0737 } Explicit interface implementation provides a syntax that allows the method to be private: class Baz : IFoo { void IFoo.Bar() { } // No error } A classic use for this is to hide the implementation of a base interface type. IEnumerable<> would be a very good example: class Baz : IEnumerable { public IEnumerator GetEnumerator() {} System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { } } Note how the generic version is accessible, the non-generic version is hidden. That both discourages its use and avoids a compile error because of a duplicate method. In your case, implementing Dispose() explicitly is wrong. You wrote Dispose() to allow the client code to call it, forcing it to cast to IDisposable to make the call doesn't make sense. Also, calling Dispose() from a finalizer is a code smell. The standard pattern is to add a protected Dispose(bool disposing) method to your class.
