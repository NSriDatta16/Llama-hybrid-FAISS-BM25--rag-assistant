[site]: stackoverflow
[post_id]: 2436061
[parent_id]: 2435764
[tags]: 
I would rely on the convention that functions that will become methods have a first argument named self , and other functions don't. Fragile, but then, there's no really solid way. So (pseudocode as I have comments in lieu of what you want to do in either case...): import inspect import functools def decorator(f): args = inspect.getargspec(f) if args and args[0] == 'self': # looks like a (future) method... else: # looks like a "real" function @functools.wraps(f) def wrapper # etc etc One way to make it a bit more solid, as you say all classes involved inherit from a class under your control, is to have that class provide a metaclass (which will also of course be inherited by said classes) which checks things at the end of the class body. Make the wrapped function accessible e.g. by wrapper._f = f and the metaclass's __init__ can check that all wrapped methods did indeed have self as the first argument. Unfortunately there's no easy way to check that other functions (non-future-methods) being wrapped didn't have such a first argument, since you're not in control of the environment in that case. The decorator might check for "top-level" functions (ones whose def is a top-level statement in their module), via the f_globals (globals dict, i.e., module's dict) and f_name attributes of the function -- if the function's such a global presumably it won't later be assigned as an attribute of the class (thereby becoming a future-method anyway;-) so the self named first arg, if there, can be diagnosed as wrong and warned about (while still treating the function as a real function;-). One alternative would be to do the decoration in the decorator itself under the hypothesis of a real function, but also make available the original function object as wrapper._f . Then, the metaclass's __init__ can re-do the decoration for all functions in the class body that it sees have been marked this way. This approach is much more solid than the convention-relying one I just sketched, even with the extra checks. Still, something like class Foo(Bar): ... # no decorations @decorator def f(*a, **k): ... Foo.f = f # "a killer"... function becomes method! would still be problematic -- you could try intercepting this with a __setattr__ in your metaclass (but then other assignments to class attributes after the class statement can become problematic). The more the user's code has freedom to do funky things (and Python generally leaves the programmer a lot of such freedom), the harder time your "framework-y" code has keeping things under tight control instead, of course;-).
