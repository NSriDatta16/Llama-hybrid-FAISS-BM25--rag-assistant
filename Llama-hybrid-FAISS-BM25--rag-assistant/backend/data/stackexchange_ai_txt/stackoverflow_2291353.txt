[site]: stackoverflow
[post_id]: 2291353
[parent_id]: 2291286
[tags]: 
If you want 4 hour increments divide the hour by 4 (using integer division) and then multiply by 4 when creating the new datetime element. Note you can simply use the constructor that takes year, month, day, hour, minute, and second instead of constructing a string and converting it. var q = from d in DataPointTable where d.dateStamp > DateTime.Now.AddDays(-28) && (d.dataTypeID == (int)dataType + 1) group d by new { d.dateStamp.Year, d.dateStamp.Month, d.dateStamp.Day, Hour = d.dateStamp.Hour / 4 } into groupedData orderby groupedData.Key.Year, groupedData.Key.Month, groupedData.Key.Day, groupedData.Key.Hour ascending select new { date = new DateTime( groupedData.Key.Year, groupedData.Key.Month, groupedData.Key.Day, (groupedData.Key.Hour * 4), 0, 0), avg = groupedData.Average(d => d.data), max = groupedData.Max(d => d.data), min = groupedData.Min(d => d.data) }; To improve efficiency you might want to consider adding an index on the dateStamp column. Given that you're only selecting a potentially small range of the dates, using an index should be a significant advantage. I would expect the query plan to do an index seek for the first date, making it even faster.
