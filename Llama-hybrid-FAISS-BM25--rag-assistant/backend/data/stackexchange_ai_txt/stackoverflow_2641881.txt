[site]: stackoverflow
[post_id]: 2641881
[parent_id]: 2641858
[tags]: 
You can't return a pointer to an array that's allocated locally within the function. As soon as the function returns, that array is going to be clobbered. Also, when you put char localstr[MAX_STRLENGTH] = strcpy(localstr, somestr); what happens is that strcpy() will copy the bytes into the localstr[] array, but then you have an unnecessary assignment thing going on. You could probably get the intended effect as two lines, thus .. char localstr[MAX_STRLENGTH]; strcpy(localstr, somestr); Also, it's bad form to embed a free() call inside a function like this. Ideally the free() should be visible at the same level of scope where the malloc() occurred. By the same logic it's a little dubious to allocate memory down in a function this way. If you want a function to modify a string, a common convention goes something like so // use a prototype like this to use the same buffer for both input and output int modifyMyString(char buffer[], int bufferSize) { // .. operate you find in buffer[], // leaving the result in buffer[] // and be sure not to exceed buffer length // depending how it went, return EXIT_FAILURE or maybe return EXIT_SUCCESS; // or separate input and outputs int workOnString(char inBuffer[], int inBufSize, char outBuffer[], int outBufSize) { // (notice, you could replace inBuffer with const char *) // leave result int outBuffer[], return pass fail status return EXIT_SUCCESS; Not embedding malloc() or free() inside will also help avoid memory leaks.
