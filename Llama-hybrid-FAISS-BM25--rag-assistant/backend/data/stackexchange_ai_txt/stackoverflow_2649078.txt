[site]: stackoverflow
[post_id]: 2649078
[parent_id]: 2648532
[tags]: 
I would also add that it is generally prefered to avoid using mutable values when writing F# code. It's fine when you're learning F# or when you need to optimize some code to run faster, but if you want to write a more idiomatic F# code, it's better to use recursion instead of mutable values. I tried to write the Cartesian power a bit more elegantly and here is my version. It is implemented recursively. I explicitly handle the case when we need to calculate X^1 and the recursive case performs a Cartesian product like this: X^n = X * X^(n-1) I'm using sequence expressions and the method generates elements of the sequence (to be returned as the result) using yield : let rec cartesianPow input n = seq { if (n = 1) then // This handles the case when the recursion terminates. We need to turn // each element from the input into a list containing single element: // [1; 2; 4] ^ 1 = [ [1]; [2]; [3] ] for el in input do yield [el] else // We perform one Cartesian product (and run the rest of the // power calculation recursively). Mathematically: // [1; 2; 3] ^ n = [1; 2; 3] x ([1; 2; 3] ^ (n-1)) for el in input do for rest in cartesianPow input (n - 1) do yield el :: rest } cartesianPow [ 0; 1 ] 3 This isn't the most efficient implementation (e.g. because using yield inside for loop may not be a good thing to do), but that would be only problem for large n . In F#, it is usually a good idea to start with the cleanest implementation that's easier to understand :-).
