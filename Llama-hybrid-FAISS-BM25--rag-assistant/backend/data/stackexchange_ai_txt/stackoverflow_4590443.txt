[site]: stackoverflow
[post_id]: 4590443
[parent_id]: 4588581
[tags]: 
There's already one answer about realloc , but I have a different take on it. A lot of time, I've seen people write realloc when they mean free ; malloc - in other words, when they have a buffer full of trash that needs to change size before storing new data. This of course leads to potentially-large, cache-thrashing memcpy of trash that's about to be overwritten. If used correctly with growing data (in a way that avoids worst-case O(n^2) performance for growing an object to size n , i.e. growing the buffer geometrically instead of linearly when you run out of space), realloc has doubtful benefit over simply doing your own new malloc , memcpy , and free cycle. The only way realloc can ever avoid doing this internally is when you're working with a single object at the top of the heap. If you like to zero-fill new objects with calloc , it's easy to forget that realloc won't zero-fill the new part. And finally, one more common use of realloc is to allocate more than you need, then resize the allocated object down to just the required size. But this can actually be harmful (additional allocation and memcpy ) on implementations that strictly segregate chunks by size, and in other cases might increase fragmentation (by splitting off part of a large free chunk to store a new small object, instead of using an existing small free chunk). I'm not sure if I'd say realloc encourages bad practice, but it's a function I'd watch out for.
