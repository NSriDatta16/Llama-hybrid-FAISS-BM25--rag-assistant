[site]: stackoverflow
[post_id]: 2288520
[parent_id]: 2288106
[tags]: 
BadHorse's answer is good if you want to solve a specific maze; you simply intepret your bit string as a sequence of precise instructions to guide the agent through the maze. In this case your fitness is not the sum of the bit string (as you state in your question) but rather some metric measuring how successfull the agent was in solving the problem. For example, your fitness might be defined as " distance in a straight line from end of maze after processing 20 instructions ". Hence, when evaluating each individual you allow it to process the first 20 instructions from your bit string and then compute its fitness, perform any crossovers / mutations and then create the next generation of individuals. If you wish to develop your agent to solve any maze you need to encode rules within your bit string rather than a sequence of instructions. You could define rules based on whether a wall was immediately behind, in front, left or right of the robot; e.g. FBLR Action 0000 Move Forward 0001 Move Forward 0010 Turn Right etc This gives you a bit string consisting of 16 actions, each action encoded as 2 bits (00 = Move Forward, 01 = Turn Right, 10 = Turn Left, 11 = Move Backwards). When evaluating your agent it simply determines its current state and uses the bit string as a lookup table to determine how it should respond. It then repeats this a certain number of times after which point you evaluate its fitness. Given this encoding the agent could evaluate the rule humans typically use which is "Follow the left hand wall continuously". Obviously this approach will fail if the maze is not fully connected and in this case you need to encode more state into your rules based approach (e.g. the agent could respond differently if going over "old ground"). Hope that helps. EDIT In response to your latest edit: The fact that I've encoded the agent "sensors" detecting whether it is next to a wall or not isn't relevant to the bit string (your gene), and perhaps I've slightly confused things with my example. The gene only encodes the actions (move forward, etc.) not the sensor states. You should therefore write code to look-up the relevant part of the bit string given a particular combination of sensor readings; e.g. /** * Enumeration describing the four available actions to the agent * and methods for decoding a given action from the "bit" string * (actually represented using booleans). */ public enum Action { MOVE_FORWARD, REVERSE, TURN_LEFT, TURN_RIGHT Action decodeAction(boolean b1, boolean b2) { Action ret; if (b1) { ret = b2 ? Action.MOVE_FORWARD : Action.TURN_LEFT; } else { ret = b2 ? Action.TURN_RIGHT : Action.REVERSE; } return ret; } } /** * Class encapsulating the 32-bit "bit string" represented using booleans. * Given the state of the four agent inputs the gene will provide a specific * action for the agent to perform. */ public class Gene { private final boolean[] values = new boolean[32]; public Action getActionForSensorInputs(boolean wallInFront, boolean wallBehind, boolean wallToLeft, boolean wallToRight) { int i=0; // Encode the four sensor inputs as a single integer value by // bitwise-ORing each sensor value with a power of 2. // The encoded value will be in the range [0, 15]. if (wallToRight) { i |= 0x01; } if (wallToLeft) { i |= 0x02; } if (wallBehind) { i |= 0x04; } if (wallInFront) { i |= 0x08; } // The look-up index is i * 2 because each action is encoded as 2 // booleans. int index = i * 2; // Retrieve the two action bits from the bit string. boolean b1 = this.values[index]; boolean b2 = this.values[index + 1]; // Finally decode the action to perform. return Action.decodeAction(b1, b2); } // TODO: Add method to support crossover and mutation with other Genes. } Given this simple definition of a Gene you could embed this class within an Agent implementation and record how the agent performs with the current gene "installed"; e.g. private enum Direction { NORTH, SOUTH, EAST, WEST }; public class Agent { private final Geneva gene; private final int x; // x position in maze; private final int y; // y position in maze; private Direction currentDirection; public double evaluate() { double fitness; // Perform up to 20 actions and then evaluate fitness. for (int i=0; i
