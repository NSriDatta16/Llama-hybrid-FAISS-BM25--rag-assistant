[site]: stackoverflow
[post_id]: 1367336
[parent_id]: 1363075
[tags]: 
I recommend that you and your co-worker read the The Truth About Garbage Collection . Right at the start, it says this: The specification for the Java platform makes very few promises about how garbage collection actually works. [elided] While it can seem confusing, the fact that the garbage collection model is not rigidly defined is actually important and useful-a rigidly defined garbage collection model might be impossible to implement on all platforms. Similarly, it might preclude useful optimizations and hurt the performance of the platform in the long term. In your example, the test variable becomes "invisible" (see A.3.3 of above) in the while loop. At this point some JVMs will continue to view the variable as containing a "hard reference", and other JVMs will treat it as if the variable has been nulled. Either behaviour is acceptable for a compliant JVM Quoting from the JLS edition 3 (section 12.6.1 paragraph 2): A reachable object is any object that can be accessed in any potential continuing computation from any live thread. Notice that reachability is not defined in terms of scopes at all. The quoted text continues as follows: Optimizing transformations of a program can be designed that reduce the number of objects that are reachable to be less than those which would naively be considered reachable. For example, a compiler or code generator may choose to set a variable or parameter that will no longer be used to null to cause the storage for such an object to be potentially reclaimable sooner. (My emphasis added.) This means that an object object may be garbage collected and finalization may occur earlier or later than you would expect. It is also worth noting that some JVMs take more than one GC cycles before unreachable objects are finalized. The bottom line is that a program that depends on finalization happening earlier or later is inherently non-portable, and to my mind buggy.
