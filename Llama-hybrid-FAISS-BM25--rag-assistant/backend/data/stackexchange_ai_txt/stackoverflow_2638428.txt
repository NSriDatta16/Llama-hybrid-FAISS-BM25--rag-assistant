[site]: stackoverflow
[post_id]: 2638428
[parent_id]: 2635745
[tags]: 
If you want to keep everything in the same file, why not put the logger at the top in a file scoped lexical. GetOptions( do_logging => \$do_logging ); my $logerr = $do_logging ? sub {logging_code_here()} : sub {}; $logerr is now available in any package defined after that point in the same file. However, it is generally faster to structure your logging calls as follows: my $logerr = sub { logging_code_here() }; $logerr->("some string $some_var") if $do_logging; that way you avoid a subroutine call and the string argument to $logerr does not need to be calculated if logging is off. You can also setup logging levels: $logerr->("starting loop") if $do_logging; for (@big_array) { $logerr->("processing $_") if $do_logging > 1; ... } EDIT: While I don't think its the best practice, based on your comments, here is what you are probably looking for (a pragma): use 5.010; use warnings; use strict; BEGIN { # compile time $INC{'log.pm'}++; # block 'require log;' package log; sub is_active {(caller 1)[10]{log}} # test the hints hash sub import { $^H{log} = 1; # set the hints hash for 'log' my $logmsg = (caller).'::logmsg'; # name of caller's sub no strict 'refs'; *$logmsg = sub {print "logging: @_\n" if is_active} # install sub unless *{$logmsg}{CODE}; # unless we did already } sub unimport { $^H{log} = 0; # unset the hints hash } } package MyPkg; use log; logmsg 'hello, world!'; { no log; logmsg 'nope, not here'; } logmsg 'back again';
