[site]: stackoverflow
[post_id]: 3774315
[parent_id]: 
[tags]: 
Statistical accumulator in Python

An statistical accumulator allows one to perform incremental calculations. For instance, for computing the arithmetic mean of a stream of numbers given at arbitrary times one could make an object which keeps track of the current number of items given, n and their sum, sum . When one requests the mean, the object simply returns sum/n . An accumulator like this allows you to compute incrementally in the sense that, when given a new number, you don't need to recompute the entire sum and count. Similar accumulators can be written for other statistics (cf. boost library for a C++ implementation). How would you implement accumulators in Python? The code I came up with is: class Accumulator(object): """ Used to accumulate the arithmetic mean of a stream of numbers. This implementation does not allow to remove items already accumulated, but it could easily be modified to do so. also, other statistics could be accumulated. """ def __init__(self): # upon initialization, the numnber of items currently # accumulated (_n) and the total sum of the items acumulated # (_sum) are set to zero because nothing has been accumulated # yet. self._n = 0 self._sum = 0.0 def add(self, item): # the 'add' is used to add an item to this accumulator try: # try to convert the item to a float. If you are # successful, add the float to the current sum and # increase the number of accumulated items self._sum += float(item) self._n += 1 except ValueError: # if you fail to convert the item to a float, simply # ignore the exception (pass on it and do nothing) pass @property def mean(self): # the property 'mean' returns the current mean accumulated in # the object if self._n > 0: # if you have more than zero items accumulated, then return # their artithmetic average return self._sum / self._n else: # if you have no items accumulated, return None (you could # also raise an exception) return None # using the object: # Create an instance of the object "Accumulator" my_accumulator = Accumulator() print my_accumulator.mean # prints None because there are no items accumulated # add one (a number) my_accumulator.add(1) print my_accumulator.mean # prints 1.0 # add two (a string - it will be converted to a float) my_accumulator.add('2') print my_accumulator.mean # prints 1.5 # add a 'NA' (will be ignored because it cannot be converted to float) my_accumulator.add('NA') print my_accumulator.mean # prints 1.5 (notice that it ignored the 'NA') Interesting design questions arise: How to make the accumulator thread-safe? How to safely remove items? How to architect in a way that allows other statistics to be plugged in easily (a factory for statistics)
