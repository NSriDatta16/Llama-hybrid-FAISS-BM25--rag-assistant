[site]: stackoverflow
[post_id]: 2616155
[parent_id]: 
[tags]: 
C++ Class Access Specifier Verbosity

A "traditional" C++ class (just some random declarations) might resemble the following: class Foo { public: Foo(); explicit Foo(const std::string&); ~Foo(); enum FooState { Idle, Busy, Unknown }; FooState GetState() const; bool GetBar() const; void SetBaz(int); private: struct FooPartialImpl; void HelperFunction1(); void HelperFunction2(); void HelperFunction3(); FooPartialImpl* m_impl; // smart ptr FooState m_state; bool m_bar; int m_baz; }; I always found this type of access level specification ugly and difficult to follow if the original programmer didn't organize his "access regions" neatly. Taking a look at the same snippet in a Java/C# style, we get: class Foo { public: Foo(); public: explicit Foo(const std::string&); public: ~Foo(); public: enum FooState { Idle, Busy, Unknown }; public: FooState GetState() const; public: bool GetBar() const; public: void SetBaz(int); private: struct FooPartialImpl; private: void HelperFunction1(); private: void HelperFunction2(); private: void HelperFunction3(); private: FooPartialImpl* m_impl; // smart ptr private: FooState m_state; private: bool m_bar; private: int m_baz; }; In my opinion, this is much easier to read in a header because the access specifier is right next to the target, and not a bunch of lines away. I found this especially true when working with header-only template code that wasn't separated into the usual "*.hpp/*.inl" pair. In that scenario, the size of the function implementations overpowered this small but important information. My question is simple and stems from the fact that I've never seen anyone else actively do this in their C++ code. Assuming that I don't have a "Class View" capable IDE, are there any obvious drawbacks to using this level of verbosity? Any other style recommendations are welcome!
