[site]: stackoverflow
[post_id]: 1626689
[parent_id]: 1625839
[tags]: 
While I like the idea of reducing boiler-plate code, I am deeply suspicious of tools like Modern::Perl and common::sense. The problem I have with modules like this is that they bundle up a group of behaviors and hide behid glib names with changeable meanings. For example, Modern::Perl today consists of enabling some perl 5.10 features and using strict and warnings. But what happens when Perl 5.12 or 5.14 or 5.24 come out with great new goodies, and the community discovers that we need to use the frobnitz pragma everywhere? Will Modern::Perl provide a consistent set of behaviors or will it remain "Modern". If MP keeps with the times, it will break existing systems that don't keep lock-step with its compiler requirements. It adds extra compatibility testing to upgrade. At least that's my reaction to MP. I'll be the first to admit that chromatic is about 10 times smarter than me and a better programmer as well--but I still disagree with his judgment on this issue. common::sense has a name problem, too. Whose idea of common sense is involved? Will it change over time? My preference would be for a module that makes it easy for me to create my own set of standard modules, and even create groups of related modules/pragmas for specific tasks (like date time manipulation, database interaction, html parsing, etc). I like the idea of Toolkit , but it sucks for several reasons: it uses source filters, and the macro system is overly complex and fragile. I have the utmost respect for Damian Conway, and he produces brilliant code, but sometimes he goes a bit too far (at least for production use, experimentation is good). I haven't lost enough time typing use strict; use warnings; to feel the need to create my own standard import module. If I felt a strong need for automatically loading a set of modules/pragmas, something similar to Toolkit that allows one to create standard feature groups would be ideal: use My::Tools qw( standard datetime SQLite ); or use My::Tools; use My::Tools::DateTime; use My::Tools::SQLite; Toolkit comes very close to my ideal. Its fatal defects are a bummer. As for whether the choice of pragmas makes sense, that's a matter of taste. I'd rather use the occasional no strict 'foo' or no warnings 'bar' in a block where I need the ability to do something that requires it, than disable the checks over my entire file. Plus, IMO, memory consumption is a red herring. YMMV. update It seems that there are many (how many?) different modules of this type floating around CPAN. There is latest , which is no longer the latest. Demonstrates part of the naming problem. Also, uni::perl which adds enabling unicode part of the mix. ToolSet offers a subset of Toolkit 's abilities, but without source filters. I'll include Moose here, since it automatically adds strict and warnings to the calling package. And finally Acme::Very::Modern::Perl The proliferation of these modules and the potential for overlapping requirements, adds another issue. What happens if you write code like: use Moose; use common::sense; What pragmas are enabled with what options?
