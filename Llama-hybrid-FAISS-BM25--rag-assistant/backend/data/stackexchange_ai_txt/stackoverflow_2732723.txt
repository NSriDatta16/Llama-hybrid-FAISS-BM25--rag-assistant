[site]: stackoverflow
[post_id]: 2732723
[parent_id]: 2732197
[tags]: 
I'm guessing this is homework. On the assumption that it is, then here's some ideas for how to think about the problem that might lead you to an answer: In preorder , first the current item is "reported", then recurse for all this node's tails. In postorder these two steps are done in reverse. In both cases, the recursion is "local", in the sense that it only need deal with one node at a time. Is this true for levelorder ? Or to ask it another way, when levelorder recurses, do the results of the recursions interact or no? If so, then, what is the "unit" of recursion, if not a single Tree ? Understanding the nature of the recursion (or iteration..?) of levelorder will lead you to a solution that very simple and elegant. My version is only three lines long! By the way, it might be nice to have these utility functions to make the code even clearer in some places: element :: Tree a -> a element (Nd x _) = x subtrees :: Tree a -> [Tree a] subtrees (Nd _ s) = s Or, if you are familiar with record syntax in Haskell, you can achieve exactly this by changing your original Tree definition to: data Tree a = Nd { element :: a, subtrees :: [Tree a] } deriving Show A full solution: The key is realizing that levelorder requires recursion on a list of Tree . At each step the elements from each Tree is extracted, and the next step is upon the concatenation of the subtrees: levelorder :: Tree a -> [a] levelorder t = step [t] where step [] = [] step ts = map element ts ++ step (concatMap subtrees ts) This produces the elements in a single, flattened list, much like preorder and postorder do, and is the usual definition of a breadth-first traversal. If instead you really want the elements grouped by level, a single change of the ++ operator to : will yield that version: bylevel :: Tree a -> [[a]] bylevel t = step [t] where step [] = [] step ts = map element ts : step (concatMap subtrees ts) Note: I have given type signatures for all top-level functions. This is a really good habit to get into, and will save you considerable time debugging.
