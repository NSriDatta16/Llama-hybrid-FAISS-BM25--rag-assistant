[site]: stackoverflow
[post_id]: 4435834
[parent_id]: 4435761
[tags]: 
I'm currently doing a similar thing. That is, I have an MVC View which contains various search options (checkbox, dropdown, textbox), and I wanted an elegant way to return "search results". So I created a simple class - e.g " ProductSearchCriteria ". This class contains nothing but getters/setters for the different search options (which I populate when the form is submitted via model binding). I then accept this type as a parameter on my BLL method: public ICollection FindProductsForCriteria(ProductSearchCriteria criteria) { return _repository // GenericRepository .Find() // IQueryable .WithSearchCriteria(criteria) // IQueryable .ToList(); // List } As to how to apply the filters, well that depends on a few things. Firstly, I don't know if your using Linq-To-Sql, NHibernate, Entity-Framework, etc. Also it depends on your architecture (repository). You're not going to be able to "dynamically" apply filters via lambda expressions (not easily, anyway). What I did was create an extension method to gracefully apply the filters: public static IQueryable WithSearchCriteria(this IQueryable source, ProductSearchCriteria criteria) { var query = source; if (criteria.SearchFilterOne != null) query = query.Where(x => x.FieldInModel == criteria.SearchFilterOne); // inspect other criteria } As I said, it depends on your architecture and ORM. I use Entity Framework 4.0, which supports deferred execution , meaning I can build up queries on my objects (IQueryable), and apply filters before executing the query.
