[site]: stackoverflow
[post_id]: 2344694
[parent_id]: 2344213
[tags]: 
GUID's are created using the new keyword which makes me think it's a reference type. Stop thinking that. Value types can have constructors too. It is perfectly legal, though strange, to say int x = new int(); That's the same as assigning zero to x. Is this correct? Nope. Are GUID's stored on heap? Yes. Guids are also stored on the stack. Note that the analysis below assumes that the implementation of the CLI is the Microsoft "desktop" or "Silverlight" CLR running on Windows. I have no idea what other versions of the CLI do, what they do on Macs, and so on. If you need to know whether a particular hunk of memory is stored on the stack in other implementations, you'll have to ask someone who is an expert on those implementations. A Guid is stored on the stack under the following circumstances: (1) when the Guid is a "temporary" result of an ongoing calculation or is being used as an argument to a method. For example, if you have a method call M(new Guid()) then temporary storage for the new Guid is allocated on the stack. (2) when the Guid is a local variable which is (a) not in an iterator block, (b) not a closed-over outer variable of an anonymous method or lambda expression. In all other situations the Guid is not stored on the stack. A Guid is stored on the heap when it is a field of a reference type, an element of an array, a closed-over local of an anonymous method or lambda expression, or a local in an iterator block. A Guid may also be stored in neither the GC heap nor the stack. A Guid might be stored in entirely unmanaged memory, accessed via unsafe pointer arithmetic. I am curious as to why you care so much as to whether the bits of a guid are on the stack or on the heap. What difference does it make?
