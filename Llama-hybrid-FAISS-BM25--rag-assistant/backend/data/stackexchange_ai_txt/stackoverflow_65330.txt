[site]: stackoverflow
[post_id]: 65330
[parent_id]: 65205
[tags]: 
The simplest option would be creating a table with a row per list item, a column for the item position, and columns for other data in the item. Then you can use ORDER BY on the position column to retrieve in the desired order. create table linked_list ( list_id integer not null , position integer not null , data varchar(100) not null ); alter table linked_list add primary key ( list_id, position ); To manipulate the list just update the position and then insert/delete records as needed. So to insert an item into list 1 at index 3: begin transaction; update linked_list set position = position + 1 where position >= 3 and list_id = 1; insert into linked_list (list_id, position, data) values (1, 3, "some data"); commit; Since operations on the list can require multiple commands (eg an insert will require an INSERT and an UPDATE), ensure you always perform the commands within a transaction. A variation of this simple option is to have position incrementing by some factor for each item, say 100, so that when you perform an INSERT you don't always need to renumber the position of the following elements. However, this requires a little more effort to work out when to increment the following elements, so you lose simplicity but gain performance if you will have many inserts. Depending on your requirements other options might appeal, such as: If you want to perform lots of manipulations on the list and not many retrievals you may prefer to have an ID column pointing to the next item in the list, instead of using a position column. Then you need to iterative logic in the retrieval of the list in order to get the items in order. This can be relatively easily implemented in a stored proc. If you have many lists, a quick way to serialise and deserialise your list to text/binary, and you only ever want to store and retrieve the entire list, then store the entire list as a single value in a single column. Probably not what you're asking for here though.
