[site]: stackoverflow
[post_id]: 5209342
[parent_id]: 5209273
[tags]: 
You could use the MAXRECURSION option in your current code However, there is no need to recurse line by line (using Itzik Ben-Gan's method). This will detect cases where there are no rows on Queue with ismelutash = 1 too because it uses the Tally table as a reference sequence ;WITH Pass0 as (select 1 as C union all select 1), --2 rows Pass1 as (select 1 as C from Pass0 as A, Pass0 as B),--4 rows Pass2 as (select 1 as C from Pass1 as A, Pass1 as B),--16 rows Pass3 as (select 1 as C from Pass2 as A, Pass2 as B),--256 rows Pass4 as (select 1 as C from Pass3 as A, Pass3 as B),--65536 rows Pass5 as (select 1 as C from Pass4 as A, Pass4 as B),--4,294,967,296 rows Tally as (select row_number() over(order by C) as Number from Pass5) select TOP 1 Number from Tally T LEFT JOIN --corrected, oops. [QUEUE] Q ON T.Number = Q.QueueNum AND Q.ismelutash = 1 where T.Number >= @StartOffset AND T.Number Edit: Original code with MAXRECURSION hint at the end . This link is better too DECLARE @StartOffset int SET @StartOffset = 23 ; With Missing as ( select @StartOffset as N where not exists( select * from [QUEUE] where QueueNum = @StartOffset AND ismelutash = 1) ), Sequence as ( select @StartOffset as N from [QUEUE] where QueueNum = @StartOffset union all select b.QueueNum from [QUEUE] b inner join Sequence s on b.QueueNum = s.N + 1 and b.ismelutash = 1 ) select COALESCE((select N from Missing),(select MAX(N)+1 from Sequence)) OPTION (MAXRECURSION 0)
