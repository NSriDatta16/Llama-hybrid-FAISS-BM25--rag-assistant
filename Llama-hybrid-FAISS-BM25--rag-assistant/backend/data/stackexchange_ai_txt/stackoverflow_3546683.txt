[site]: stackoverflow
[post_id]: 3546683
[parent_id]: 3546592
[tags]: 
trace is simply made impure. The point of the IO monad is to preserve purity (no IO unnoticed by the type system) and define the order of execution of statements, which would otherwise be practically undefined through lazy evaluation. On own risk however, you can nevertheless hack together some IO a -> a , i.e. perform impure IO. This is a hack and of course "suffers" from lazy evaluation, but that's what trace simply does for the sake of debugging. Nevertheless though, you should probably go other ways for debugging: Reducing the need for debugging intermediate values Write small, reusable, clear, generic functions whose correctness is obvious. Combine the correct pieces to greater correct pieces. Write tests or try out pieces interactively. Use breakpoints etc. (compiler-based debugging) Use generic monads. If your code is monadic nevertheless, write it independent of a concrete monad. Use type M a = ... instead of plain IO ... . You can afterwards easily combine monads through transformers and put a debugging monad on top of it. Even if the need for monads is gone, you could just insert Identity a for pure values.
