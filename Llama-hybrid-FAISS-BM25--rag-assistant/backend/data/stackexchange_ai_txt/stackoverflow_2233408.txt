[site]: stackoverflow
[post_id]: 2233408
[parent_id]: 2233401
[tags]: 
The "redundant include guard", as you call it, speeds up compilation. Without the redundant guard, the compiler will iterate the entire foo.h file, looking for some code that might be outside the #ifndef block. If it's a long file, and this is done many places, the compiler might waste a lot of time. But with the redundant guard, it can skip the entire #include statement and not even reopen that file. Of course, you'd have to experiment and see the actual amount of time wasted by the compiler iterating through foo.h and not actually compiling anything; and perhaps modern compilers actually look for this pattern and automatically know not to bother opening the file at all, I don't know. (Begin edit by 280Z28) The following header structure is recognized by at least GCC and MSVC. Using this pattern negates virtually all benefits you could gain with guards in the including files. Note that comments are ignored when the compiler examines the structure. // GCC will recognize this structure and not reopen the file #ifndef SOMEHEADER_H_INCLUDED #define SOMEHEADER_H_INCLUDED // Visual C++ uses #pragma once to mark headers that shouldn't be reopened #if defined(_MSC_VER) && (_MSC_VER >= 1020) # pragma once #endif // header text goes here. #endif (End edit)
