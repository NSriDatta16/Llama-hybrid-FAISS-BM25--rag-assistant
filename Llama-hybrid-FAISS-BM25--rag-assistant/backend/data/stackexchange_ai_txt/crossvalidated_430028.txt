[site]: crossvalidated
[post_id]: 430028
[parent_id]: 
[tags]: 
Boundary point errors in PCA projection using sklearn

I am preparing a small example of a projection using python , numpy and sklearn to perform PCA on a simple function, here an x^2 . My idea is to generate a 2D function, rotate it in 3D and apply PCA to it to project it to a plane again. Everything works fine, but I notice that the points nearing the extremes of the function show a bigger deviation from the plane. If everything was perfect, I would expect a first and second principal components to align with the original x and y, and a third principal component being 0. The third component is near zero, but with bigger values towards the extremes of the function. My question is about those points (particularly one), where is that error coming from? At first glance it looks like a numerical error (not big, indeed), would just like to know where and why it's there. By the way, it happens with other functions, too, not only a parabola. I attach the code for my example: ## preface, imports ---------------------------- %matplotlib notebook import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D np.set_printoptions( precision=4, suppress=True ) ## Function f(x) in 2D ------- x = np.arange( -10, 10, 0.1 ) # y = np.sin( x ) y = x**2 z = np.zeros_like( x ) ## Rotation in 3D ------------- m = np.array( [ [ 0.5, 0, -0.05 ], [ 0, 1, 0 ], [ 0.05, 0, 0.5 ] ]) points = np.dot( np.stack( [x, y, z] ).T , m ).T ## Plot of the original function in 3D ------ fig = plt.figure() ax = fig.add_subplot(111, projection='3d') x = points[0] y = points[1] z = points[2] ax.scatter(x, y, z, c='r', marker='o') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') plt.show() ## Imports for PCA ------ from sklearn.decomposition import PCA from sklearn.preprocessing import StandardScaler ## PCA ------------------- sc = StandardScaler() scaled_data = sc.fit_transform( points.T ) pca = PCA() tdata = pca.fit_transform( scaled_data ) tdata.shape ## Plot of the 3D data on the PC axes ---- plt.close( 'all' ) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') x = tdata.T[0] y = tdata.T[1] z = tdata.T[2] ax.scatter(x, y, z, c='r', marker='o') ax.set_xlabel('PC1') ax.set_ylabel('PC2') ax.set_zlabel('PC3') #ax.invert_xaxis() plt.show() The last image is rotated to show (more or less) the distribution on PC3. It can be seen that the values are very small (1e-15). Still, the error is clearly bigger on the extremes. This behaviour is the same with the sine function. Where does this come from?
