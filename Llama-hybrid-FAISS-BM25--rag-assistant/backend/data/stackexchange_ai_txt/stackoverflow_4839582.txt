[site]: stackoverflow
[post_id]: 4839582
[parent_id]: 4739875
[tags]: 
I tend to think in terms of verbs; UI tiers are filled with classes that render, view, scroll, click, and display. Data tiers save, load, update, and delete. The business layer is all about objects that mirror the real world in some way. So your app might contain; UI: PersonView, PersonEditPage, NewPersonForm Business: Person, Birthday, Address, Salesman, Employee Data: Connection, Database, Table, Column So a typical sequence of operations in a web app might go; (screen) UI Business Data (storage) Form/Page PersonView Organization Connection DB | | | | | |--type-+ | | | | | | | | | | | | | | | | |--find(#3)-->| | | | | |-LoadPerson(3)->X | | | | X-select->X | | | X X | | | X What's happening here? First, the user is typing and clicking in the browser. When they click, the PersonView object, representing the appearance of a person on the web, intercepts the call. In pseudocode: onLinkClick() { personView.FindPerson(id:3); rendertoHtml(); } PersonView now needs to find a person, so it asks the business layer; it asks an object called 'Organization' to find a particular person. Eg; PersonView.FindPerson(id) { organization.FindPerson(id) } Note that it asks without knowing about databases or XML or web servcies; it just asks the business layer directly, 'can you find person #3?'. So the UI layer is isolated from the data layer. The business layer (Organization) then goes to the data layer, and asks it to load the person record. Organization.FindPerson(id) { connection.LoadPerson(id); } Again, it isn't making data-specific requests. Now we get to the connection, which does know about the specific details of the data layer; Connection.LoadPerson(id) { connectDb(); execute("SELECT name, dob FROM Person WHERE id =@id"); return new Person(name, dob); } So the connection definitely does know about the particular storage mechanism (SQL) but has no knowledge about the UI layer that called it. It returns a Person object, and Organization passes it back to PersonView, which then knows how to generate HTML. How does this structure help? Imagine that you wanted to migrate from SQL to XML files for your data storage. You could create a different implementation of Connection which used xpath, like so; Connection.LoadPerson(id) { LoadXml(); SelectNode("//person[@id=$(ID)]"); return new Person(xml['name'], xml['dob']); } and the whole system would contine working. You can also change the UI layer (from web to windows, for instance) and neither the business layer nor the data layer need to be rewritten.
