[site]: stackoverflow
[post_id]: 2306770
[parent_id]: 2306462
[tags]: 
Suppose you had an extended exchange rate table that contained: Start Date End Date Rate ========== ========== ======= 0001-01-01 2009-01-31 40.1 2009-02-01 2009-02-28 40.1 2009-03-01 2009-03-31 41.0 2009-04-01 2009-04-30 38.5 2009-05-01 9999-12-31 42.7 We can discuss the details of whether the first two rows should be combined, but the general idea is that it is trivial to find the exchange rate for a given date. This structure works with the SQL 'BETWEEN' operator which includes the ends of the ranges. Often, a better format for ranges is 'open-closed'; the first date listed is included and the second is excluded. Note that there is a constraint on the data rows - there are (a) no gaps in the coverage of the range of dates and (b) no overlaps in the coverage. Enforcing those constraints is not completely trivial (polite understatement - meiosis). Now the basic query is trivial, and Case B is no longer a special case: SELECT T.Date, T.Amount, X.Rate FROM Transactions AS T JOIN ExtendedExchangeRates AS X ON T.Date BETWEEN X.StartDate AND X.EndDate; The tricky part is creating the ExtendedExchangeRate table from the given ExchangeRate table on the fly. If it is an option, then revising the structure of the basic ExchangeRate table to match the ExtendedExchangeRate table would be a good idea; you resolve the messy stuff when the data is entered (once a month) instead of every time an exchange rate needs to be determined (many times a day). How to create the extended exchange rate table? If your system supports adding or subtracting 1 from a date value to obtain the next or previous day (and has a single row table called 'Dual'), then a variation on this will work (without using any OLAP functions): CREATE TABLE ExchangeRate ( Date DATE NOT NULL, Rate DECIMAL(10,5) NOT NULL ); INSERT INTO ExchangeRate VALUES('2009-02-01', 40.1); INSERT INTO ExchangeRate VALUES('2009-03-01', 41.0); INSERT INTO ExchangeRate VALUES('2009-04-01', 38.5); INSERT INTO ExchangeRate VALUES('2009-05-01', 42.7); First row: SELECT '0001-01-01' AS StartDate, (SELECT MIN(Date) - 1 FROM ExchangeRate) AS EndDate, (SELECT Rate FROM ExchangeRate WHERE Date = (SELECT MIN(Date) FROM ExchangeRate)) AS Rate FROM Dual; Result: 0001-01-01 2009-01-31 40.10000 Last row: SELECT (SELECT MAX(Date) FROM ExchangeRate) AS StartDate, '9999-12-31' AS EndDate, (SELECT Rate FROM ExchangeRate WHERE Date = (SELECT MAX(Date) FROM ExchangeRate)) AS Rate FROM Dual; Result: 2009-05-01 9999-12-31 42.70000 Middle rows: SELECT X1.Date AS StartDate, X2.Date - 1 AS EndDate, X1.Rate AS Rate FROM ExchangeRate AS X1 JOIN ExchangeRate AS X2 ON X1.Date X1.Date AND X3.Date Result: 2009-02-01 2009-02-28 40.10000 2009-03-01 2009-03-31 41.00000 2009-04-01 2009-04-30 38.50000 Note that the NOT EXISTS sub-query is rather crucial. Without it, the 'middle rows' result is: 2009-02-01 2009-02-28 40.10000 2009-02-01 2009-03-31 40.10000 # Unwanted 2009-02-01 2009-04-30 40.10000 # Unwanted 2009-03-01 2009-03-31 41.00000 2009-03-01 2009-04-30 41.00000 # Unwanted 2009-04-01 2009-04-30 38.50000 The number of unwanted rows increases dramatically as the table increases in size (for N > 2 rows, there are (N-2) * (N - 3) / 2 unwanted rows, I believe). The result for ExtendedExchangeRate is the (disjoint) UNION of the three queries: SELECT DATE '0001-01-01' AS StartDate, (SELECT MIN(Date) - 1 FROM ExchangeRate) AS EndDate, (SELECT Rate FROM ExchangeRate WHERE Date = (SELECT MIN(Date) FROM ExchangeRate)) AS Rate FROM Dual UNION SELECT X1.Date AS StartDate, X2.Date - 1 AS EndDate, X1.Rate AS Rate FROM ExchangeRate AS X1 JOIN ExchangeRate AS X2 ON X1.Date X1.Date AND X3.Date On the test DBMS (IBM Informix Dynamic Server 11.50.FC6 on MacOS X 10.6.2), I was able to convert the query into a view but I had to stop cheating with the data types - by coercing the strings into dates: CREATE VIEW ExtendedExchangeRate(StartDate, EndDate, Rate) AS SELECT DATE('0001-01-01') AS StartDate, (SELECT MIN(Date) - 1 FROM ExchangeRate) AS EndDate, (SELECT Rate FROM ExchangeRate WHERE Date = (SELECT MIN(Date) FROM ExchangeRate)) AS Rate FROM Dual UNION SELECT X1.Date AS StartDate, X2.Date - 1 AS EndDate, X1.Rate AS Rate FROM ExchangeRate AS X1 JOIN ExchangeRate AS X2 ON X1.Date X1.Date AND X3.Date
