[site]: stackoverflow
[post_id]: 2806385
[parent_id]: 2666578
[tags]: 
Let's look into part 6.7 ยง4 (Declaration statement) of the C++ standard. An implementation is permitted to perform early initialization of other local objects with static storage duration under the same conditions that an implementation is permitted to statically initialize an object with static storage duration in namespace scope. Otherwise such an object is initialized the first time control passes through its declaration; such an object is considered initialized upon the completion of its initialization. So we have two cases: Either we now before we enter the function with a static local x , what value x will have. Then the compiler is allowed to initialize the value as early as possible (even at compile time). We don't now the value of x initialize it only the first time we enter our function. So yes what gcc does is not only what you want, this behavior is also standard compliant.
