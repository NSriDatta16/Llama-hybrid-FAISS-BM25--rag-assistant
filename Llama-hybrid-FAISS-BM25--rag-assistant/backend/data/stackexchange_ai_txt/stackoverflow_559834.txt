[site]: stackoverflow
[post_id]: 559834
[parent_id]: 559786
[tags]: 
A 'manager' class will often: Interogate something's state Make a decision based on that state As an antidote or contrast to that, Object-Oriented design would encourage you to design class APIs where you "tell don't ask" the class itself to do things itself (and to encapsulate its own state): for more about "tell don't ask" see e.g. here and here (and maybe someone else has a better explanation of "tell don't ask" but these are first two articles that Google found for me). It seems like the main strategy the little OO code we produce is to break the problem down into classes that are easily identifiable as discrete units and then put the left over/generalized bits in a "Manager" class. That may well be true even at the best of times. Coplien talked about this towards the end of his Advanced C++: Programming Styles and Idioms book: he said that in a system, you tend to have: Self-contained objects And, "transactions", which act on other objects Take, for example, an airplane (and I'm sorry for giving you another vehicular example; I'm paraphrasing him): The 'objects' might include the ailerons, the rudder, and the thrust The 'manager' or autpilot would implement various commands or transactions For example, the "turn right" transaction includes: flaps.right.up() flaps.left.down() rudder.right() thrust.increase() So I think it's true that you have transactions, which cut across or use the various relatively-passive 'objects'; in an application, for example, the "whatever" user-command will end up being implemented by (and therefore, invoking) various objects from every layer (e.g. the UI, the middle layer, and the DB layer). So I think it's true that to a certain extent you will have 'bits left over'; it's a matter of degree though: perhaps you ought to want as much of the code as possible to be self-contained, and encapsulating, and everything ... and the bits left over, which use (or depend on) everything else, should be given/using an API which hides as much as possible and which does as much as possible, and which therefore takes as much responsibility (implementation details) as possible away from the so-called manager. Unfortunately I've only read of this concept in that one book ( Advanced C++ ) and can't link you to something online for a clearer explanation than this paraphrase of mine.
