[site]: stackoverflow
[post_id]: 3126659
[parent_id]: 3098907
[tags]: 
Now for my preferred method. Ok, as I made mention in my previous answer rows with the same entries in each column in matrix A will multiply out to the same result in matrix AB. If we can maintain that relationship then we can theoretically speed up calculations significantly (a profiler is your friend). In this method we maintain the row * column structure of the matrix. Each row is compressed with whatever method can decompress fast enough not to affect the multiplication speed too much. RLE may be sufficient. We now have a list of compressed rows. We use an entropy encoding method (like Shannon-Fano, Huffman or arithmetic coding), but we don’t compress the data in the rows with this, we use it to compress the set of rows. We use it to encode the relative frequency of the rows. I.e. we treat a row the same way standard entropy encoding would treat a character/byte. In this example RLE compresses a row, and Huffman compresses the entire set of rows. So, for example, given the following matrix (prefixed with row numbers, Huffman used for ease of explanation) 0 | 8 8 8 8 8 8 8 8 8 8 8 8 8 | 1 | 8 4 8 8 1 1 1 1 1 8 8 8 8 | 2 | 8 4 8 8 1 1 1 1 1 8 8 8 8 | 3 | 8 4 8 8 1 1 1 1 1 8 8 8 8 | 4 | 8 4 8 8 1 1 1 1 1 8 8 8 8 | 5 | 8 4 8 8 1 1 1 1 1 8 8 8 8 | 6 | 8 8 8 8 8 8 8 8 8 8 8 8 8 | 7 | 8 8 3 3 3 3 3 3 3 3 3 3 3 | Run length encoded 0 | 8{13} | 1 | 8{1} 4{1} 8{2} 1{5} 8{4} | 2 | 8{1} 4{1} 8{2} 1{5} 8{4} | 3 | 8{1} 4{1} 8{2} 1{5} 8{4} | 4 | 8{1} 4{1} 8{2} 1{5} 8{4} | 5 | 8{1} 4{1} 8{2} 1{5} 8{4} | 6 | 8{13} | 7 | 8{2} 3{11} | So, 0 and 6 appear twice and 1 – 5 appear 5 times. 7 only once. Frequency table A: 5 (1-5) | 8{1} 4{1} 8{2} 1{5} 8{4} | B: 2 (0,6) | 8{13} | C: 1 7 | 8{2} 3{11} | Huffman tree 0|1 / \ A 0|1 / \ B C So in this case it takes one bit (for each row) to encode rows 1 – 5, and 2 bits to encode rows 0, 6, and 7. (If the runs are longer than a few bytes then do freq count on a hash that you build up as you do the RLE). You store the Huffman tree, unique strings, and the row encoding bit stream. The nice thing about Huffman is that it has a unique prefix property, so you always know when you are done. Thus, given the bit string 10000001011 you can rebuild the matrix A from the stored unique strings and the tree. The encoded bit stream tells you the order that the rows appear in. You may want to look into adaptive Huffman encoding, or its arithmetic counterpart. Seeing as rows in A with the same column entries multiply to the same result in AB over vector B you can cache the result and use it instead of calculating it again (it’s always good to avoid 100M*100M multiplications if you can). Links to further info: Arithmetic Coding + Statistical Modeling = Data Compression Priority Queues and the STL Arithmetic coding Huffman coding A Comparison Uncompressed 0 1 2 3 4 5 6 7 ================================= 0 | 3 3 3 3 3 3 3 3 | |-------+ +-------| 1 | 4 4 | 3 3 3 3 | 4 4 | | +-----------+---+ | 2 | 4 4 | 5 5 5 | 1 | 4 4 | | | | | | 3 | 4 4 | 5 5 5 | 1 | 4 4 | |---+---| | | | 4 | 5 | 0 | 5 5 5 | 1 | 4 4 | | | +---+-------+---+-------| 5 | 5 | 0 0 | 2 2 2 2 2 | | | | | 6 | 5 | 0 0 | 2 2 2 2 2 | | | +-------------------| 7 | 5 | 0 0 0 0 0 0 0 | ================================= = 64 bytes Quadtree 0 1 2 3 4 5 6 7 ================================= 0 | 3 | 3 | | | 3 | 3 | |---+---| 3 | 3 |---+---| 1 | 4 | 4 | | | 4 | 4 | |-------+-------|-------+-------| 2 | | | 5 | 1 | | | 4 | 5 |---+---| 4 | 3 | | | 5 | 1 | | |---------------+---------------| 4 | 5 | 0 | 5 | 5 | 5 | 1 | 4 | 4 | |---+---|---+---|---+---|---+---| 5 | 5 | 0 | 0 | 2 | 2 | 2 | 2 | 2 | |-------+-------|-------+-------| 6 | 5 | 0 | 0 | 2 | 2 | 2 | 2 | 2 | |---+---+---+---|---+---+---+---| 7 | 5 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ================================= 0 +- 0 +- 0 -> 3 | +- 1 -> 3 | +- 2 -> 4 | +- 3 -> 4 +- 1 -> 3 +- 2 -> 4 +- 3 -> 5 1 +- 0 -> 3 +- 1 +- 0 -> 3 | +- 1 -> 3 | +- 2 -> 4 | +- 3 -> 4 +- 2 +- 0 -> 5 | +- 1 -> 1 | +- 2 -> 5 | +- 3 -> 1 +- 3 -> 4 2 +- 0 +- 0 -> 5 | +- 1 -> 0 | +- 2 -> 5 | +- 3 -> 0 +- 1 +- 0 -> 5 | +- 1 -> 5 | +- 2 -> 0 | +- 3 -> 2 +- 2 +- 0 -> 5 | +- 1 -> 0 | +- 2 -> 5 | +- 3 -> 0 +- 3 +- 0 -> 0 +- 1 -> 2 +- 2 -> 0 +- 3 -> 0 3 +- 0 +- 0 -> 5 | +- 1 -> 1 | +- 2 -> 2 | +- 3 -> 2 +- 1 +- 0 -> 4 | +- 1 -> 4 | +- 2 -> 2 | +- 3 -> 2 +- 2 +- 0 -> 2 | +- 1 -> 2 | +- 2 -> 0 | +- 3 -> 0 +- 3 +- 0 -> 2 +- 1 -> 2 +- 2 -> 0 +- 3 -> 0 ((1*4) + 3) + ((2*4) + 2) + (4 * 8) = 49 leaf nodes 49 * (2 + 1) = 147 (2 * 8 bit indexer, 1 byte data) + 14 inner nodes -> 2 * 14 bytes (2 * 8 bit indexers) = 175 Bytes Region Hash 0 1 2 3 4 5 6 7 ================================= 0 | 3 3 3 3 3 3 3 3 | |-------+---------------+-------| 1 | 4 4 | 3 3 3 3 | 4 4 | | +-----------+---+ | 2 | 4 4 | 5 5 5 | 1 | 4 4 | | | | | | 3 | 4 4 | 5 5 5 | 1 | 4 4 | |---+---| | | | 4 | 5 | 0 | 5 5 5 | 1 | 4 4 | | + - +---+-------+---+-------| 5 | 5 | 0 0 | 2 2 2 2 2 | | | | | 6 | 5 | 0 0 | 2 2 2 2 2 | | +-------+-------------------| 7 | 5 | 0 0 0 0 0 0 0 | ================================= 0: (4,1; 4,1), (5,1; 6,2), (7,1; 7,7) | 3 1: (2,5; 4,5) | 1 2: (5,3; 6,7) | 1 3: (0,0; 0,7), (1,2; 1,5) | 2 4: (1,0; 3,1), (1,6; 4,7) | 2 5: (2,2; 4,4), (4,0; 7,0) | 2 Regions: (3 + 1 + 1 + 2 + 2 + 2) * 5 = 55 bytes {4 bytes rectangle, 1 byte data) {Lookup table is a sorted array, so it does not need extra storage}. Huffman encoded RLE 0 | 3 {8} | 1 1 | 4 {2} | 3 {4} | 4 {2} | 2 2,3 | 4 {2} | 5 {3} | 1 {1} | 4 {2} | 4 4 | 5 {1} | 0 {1} | 5 {3} | 1 {1} | 4 {2} | 5 5,6 | 5 {1} | 0 {2} | 2 {5} | 3 7 | 5 {1} | 0 {7} | 2 RLE Data: (1 + 3+ 4 + 5 + 3 + 2) * 2 = 36 Bit Stream: 20 bits packed into 3 bytes = 3 Huffman Tree: 10 nodes * 3 = 30 = 69 Bytes One Giant RLE stream 3{8};4{2};3{4};4{4};5{3};1{1};4{4};5{3};1{1};4{2};5{1};0{1}; 5{3};1{1};4{2};5{1};0{2};2{5};5{1};0{2};2{5};5{1};0{7} = 2 * 23 = 46 Bytes One Giant RLE stream encoded with common prefix folding 3{8}; 4{2};3{4}; 4{4};5{3};1{1}; 4{4};5{3}; 1{1};4{2};5{1};0{1};5{3}; 1{1};4{2};5{1};0{2};2{5}; 5{1};0{2};2{5}; 5{1};0{7} 0 + 0 -> 3{8};4{2};3{4}; + 1 -> 4{4};5{3};1{1}; 1 + 0 -> 4{2};5{1} + 0 -> 0{1};5{3};1{1}; | + 1 -> 0{2} | + 1 -> 2{5};5{1} + 0 -> 0{2}; + 1 -> 0{7} 3{8};4{2};3{4} | 00 4{4};5{3};1{1} | 01 4{4};5{3};1{1} | 01 4{2};5{1};0{1};5{3};1{1} | 100 4{2};5{1};0{2} | 101 2{5};5{1};0{2} | 110 2{5};5{1};0{7} | 111 Bit stream: 000101100101110111 RLE Data: 16 * 2 = 32 Tree: : 5 * 2 = 10 Bit stream: 18 bits in 3 bytes = 3 = 45 bytes
