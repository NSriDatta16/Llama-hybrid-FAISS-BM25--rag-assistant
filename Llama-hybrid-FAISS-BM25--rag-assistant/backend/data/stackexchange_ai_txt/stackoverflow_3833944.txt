[site]: stackoverflow
[post_id]: 3833944
[parent_id]: 3832911
[tags]: 
First of all, I think you have pretty weak design, because your class violate Single Responsibility Principle . Much more preferable distinguish two responsibilities: serializable entity and saving/reading this entity to/from persistent storage. In most cases serializable entities are lightwait and finalizable classes are not. Second, you should avoid complex logic inside your finalizers. For example, it would be much better save your serializable class into persistent storage into Storage.Dispose method. And from finalizer method only write warning into log file because it shows inappropriate class Storage usage: [Serializable] public class MySerializableClass { } public sealed class MyStorage : IDisposable { ~MyStorage() { Dispose(false); } public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } void Dispose(bool disposing) { if (!this.disposed) { if (disposing) { //We can access to all managed resources using (var ms = new MemoryStream()) { BinaryFormatter bf = new BinaryFormatter(); bf.Serialize(ms, mySerializableClass); byte[] output = Dostuff(ms); File.WriteAllBytes(DBPATH, output); } } else { //Inappropriate storage usage! //We can't guarantee that mySerializableClass object would //properly saved to persistant storage. //Write warning to log-file. We should fix our code //and add appropriate usage! } } this.disposed = true; } }
