[site]: stackoverflow
[post_id]: 3192296
[parent_id]: 2241059
[tags]: 
I had the same problem, so I crafted a workaround. Subclass the NSManagedObject and manually transform the UIImage by overriding the accessor methods for the image property. In the setter method, transform the UIImage object into an instance of NSData , and then set the managed object's image property. In the getter method, transform image property's data, and return an instance of UIImage . Let's get to work: In the data model, when you click the attribute, "image", delete the Value Transformer Name 's text. It defaults to NSKeyedUnarchiveFromData , which is what you now want. Next, subclass the entity by clicking on it in the data model, click New File . When you have the entity selected, you should see a new class in Cocoa Touch Classes titled "Managed Object Class." Click Next , leave the file's location as is by clicking Next again, and then put a checkmark next to all the entities you want to subclass. In the implementation file of your subclassed NSManagedObject , override the image property's accessor methods by including the following two: - (void)setImage:(UIImage *)image { [self willChangeValueForKey:@"image"]; NSData *data = UIImagePNGRepresentation(image); [self setPrimitiveValue:data forKey:@"image"]; [self didChangeValueForKey:@"image"]; } - (UIImage *)image { [self willAccessValueForKey:@"image"]; UIImage *image = [UIImage imageWithData:[self primitiveValueForKey:@"image"]]; [self didAccessValueForKey:@"image"]; return image; } Then, whenever you set the image, use: object.image = [UIImage imageNamed:@"icon.png"]; rather than: [object setValue:[UIImage imageNamed:@"icon.png"] forKey:@"image"]; Whenever you get the image, use: UIImage *myImage = object.image; rather than: UIImage *myImage = [object valueForKey:@"image"];
