[site]: stackoverflow
[post_id]: 1634333
[parent_id]: 1634261
[tags]: 
Actually I think your algorithm is wrong. Why would you bother with a foreach statement if you're only going to check the first value? Also, all the else's after the returns are kind of redundant and make the code harder to follow. I suspect what you're trying to do is something more like this: private bool IsDestinationNodeAChildOfDraggingNode(TreeNode draggingNode, TreeNode destinationNode) { // special case, no children if (draggingNode.Nodes.Count == 0) return false; // check if the target is one of my children if (draggingNode.Nodes.Contains(destinationNode)) return true; // recursively check each of my children to see if one of their descendants is the target foreach (TreeNode node in draggingNode.Nodes) if (IsDestinationNodeAChildOfDraggingNode(node, destinationNode)) return true; // didn't find anything return false; } Some people will insist that early return is evil which would result in this version of the function: private bool IsDestinationNodeAChildOfDraggingNode(TreeNode draggingNode, TreeNode destinationNode) { bool retVal = false; if (draggingNode.Nodes.Count != 0) { // check if the target is one of my children if (draggingNode.Nodes.Contains(destinationNode)) { retVal = true; } else { // recursively check each of my children to see if one of their descendants is the target foreach (TreeNode node in draggingNode.Nodes) if (IsDestinationNodeAChildOfDraggingNode(node, destinationNode)) { retVal = true; break; } } } return retVal; }
