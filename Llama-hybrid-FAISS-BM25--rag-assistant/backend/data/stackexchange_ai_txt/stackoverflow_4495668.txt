[site]: stackoverflow
[post_id]: 4495668
[parent_id]: 4495490
[tags]: 
lots of information missing, but the things i'd check first: if on MyISAM tables: extremely fragmented files, especially index files. Use filefrag to check that. This can happen if the database grew slowly with time. If so, just shut down MySQL, copy the database directory, rename the original and new copies and restart MySQL if you use InnoDB tables: a file-based datastore, again too fragmented. In this case, fragmentation can be both at filesystem level (check and handle as above) or at datastore level, for that use the InnoDB tools. In the worst case a block-device-based datastore (which can't get externally fragmented) can exhibit a bad case of internal fragmentation. some index with extremely low cardinality. That is, a non-unique index with few distinct values present, that is, lots of repeats. This indexes approach asymptotically a linear list, with O(n) time profiles. This can be either an index on the table or the referred foreign index. reader contention. unlikely, but a huge number of concurrent readers can stall a single writer. Edit : After reading your definitions, i think ingredients.unit_id and ingredients.ingredient_group_id are the first candidates to check, since they seem to have very low cardinality. The first one is unlikely to be useful (do you plan to select all ingredients that are measured in spoons?), so you can probably just drop it. The second one can be very useful; but if there are few ingredient groups, the cardinality can be very low, degrading performance. To raise cardinality, add some part to make it more discriminating. If no other field is likely to appear in a query together with group id, just add the main id or creation date, making it (ingredient_group_id, id) or (ingredient_group_id, created_at) . Seems counterintuitive to add complexity to make it faster, but it can really help. As a bonus, you can add a sort by created_at to any query that selects by ingredient_group_id without performance penalty.
