[site]: stackoverflow
[post_id]: 4294953
[parent_id]: 4294928
[tags]: 
What happens when you change the printing to: fprintf(fp, "%.*s", bytesRead, recvData); There is a guarantee that recvfrom() will not null terminate your messages; you would have to transmit the null terminator yourself. I can't tell what your residual problem is. I have the following to complete programs working back to back. I've scrutinized the saved file for NULs with no problem. I ran them as: ./recv & sleep 1; ./send; kill %1 recv.c #include "posixver.h" #include #include #include #include #include /* sockaddr_in */ #include /* inet_ntoa() */ #include "stderr.h" static void receiveFile(int sock, int port, char *filename) { //Keep reading data from the socket FILE *fp = fopen(filename, "ab"); if (fp == 0) err_syserr("failed to open file %s", filename); printf("\nWaiting for data on port %d\n", port); while (1) { char recvData[BUFSIZ]; // Buffer to store received data struct sockaddr_storage addr; struct sockaddr_in *client_addr = (struct sockaddr_in *)&addr; memset(recvData, 0, sizeof(recvData)); socklen_t addr_len = sizeof (struct sockaddr_storage); int bytesRead = recvfrom(sock, recvData, sizeof(recvData), 0, (struct sockaddr *) &client_addr, &addr_len); if (bytesRead sin_addr); //int rem_port = ntohs(client_addr->sin_port); //printf("Receiving %d bytes from %s:%d\n", bytesRead, rem_host ? rem_host : " ", rem_port); } fclose(fp); } int main(int argc, char **argv) { int fd; struct sockaddr_storage addr; struct sockaddr_in *server_addr = (struct sockaddr_in *)&addr; memset(&addr, 0, sizeof(addr)); server_addr->sin_family = AF_INET; server_addr->sin_addr.s_addr = htonl(INADDR_ANY); server_addr->sin_port = htons(5190); err_setarg0(argv[0]); if (argc > 1) err_usage(""); if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) send.c #include "posixver.h" #include #include #include #include #include #include #include #include "stderr.h" #define bzero(b,len) (memset((b), '\0', (len)), (void)0) enum { DEBUG = 1 }; static void sendFile(int sock, const char *filename, char *address, int port) { // Announce who we're sending data to if (DEBUG) printf("\nSending %s to %s:%d\n", filename, address, port); // Open file FILE * file = fopen(filename, "rb"); if (file == 0) err_syserr("Failed to open file %s", filename); // Get size of the file fseek(file, 0, SEEK_END); int filesize = ftell(file); rewind(file); int curPos = 0; int dataSize = 0; while (curPos 0) { byte = fgetc(file); sendData[i] = byte; curPos++; dataSize++; } else break; } recvr = gethostbyname(address); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); server_addr.sin_addr = *((struct in_addr *) recvr->h_addr_list[0]); bzero(&(server_addr.sin_zero), 8); if(DEBUG) { char tempData[1201]; strncpy(tempData, sendData, 1200); tempData[1201] ='\0'; printf("SEND:\n%s\n\n\n", tempData); } if (sendto(sock, sendData, dataSize, 0, (struct sockaddr *) &server_addr, sizeof (struct sockaddr)) 1) err_usage(""); if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) posixver.h #ifndef JLSS_ID_POSIXVER_H #define JLSS_ID_POSIXVER_H /* ** Include this file before including system headers. By default, with ** C99 support from the compiler, it requests POSIX 2001 support. With ** C89 support only, it requests POSIX 1997 support. Override the ** default behaviour by setting either _XOPEN_SOURCE or _POSIX_C_SOURCE. */ /* _XOPEN_SOURCE 700 is loosely equivalent to _POSIX_C_SOURCE 200809L */ /* _XOPEN_SOURCE 600 is loosely equivalent to _POSIX_C_SOURCE 200112L */ /* _XOPEN_SOURCE 500 is loosely equivalent to _POSIX_C_SOURCE 199506L */ #if !defined(_XOPEN_SOURCE) && !defined(_POSIX_C_SOURCE) #if __STDC_VERSION__ >= 199901L #define _XOPEN_SOURCE 600 /* SUS v3, POSIX 1003.1 2004 (POSIX 2001 + Corrigenda) */ #else #define _XOPEN_SOURCE 500 /* SUS v2, POSIX 1003.1 1997 */ #endif /* __STDC_VERSION__ */ #endif /* !_XOPEN_SOURCE && !_POSIX_C_SOURCE */ #endif /* JLSS_ID_POSIXVER_H */ stderr.c and stderr.h Actually, not standard at all, except in my code. The functions used have the declarations: extern void err_setarg0(const char *argv0); extern void err_error(const char *format, ...) PRINTFLIKE(1,2) NORETURN(); extern void err_remark(const char *format, ...) PRINTFLIKE(1,2); extern void err_syserr(const char *format, ...) PRINTFLIKE(1,2) NORETURN(); extern void err_usage(const char *usestr) NORETURN(); The first records the program name. The second reports an error message and exits; the third reports a message and returns; the fourth reports an error message and adds error information from 'errno' and 'strerror()' if there is any to use; the last reports on how to use the program - in this case, the programs accept no arguments. The full source code (quite large) is available from the IIUG Software site as part of the SQLCMD package available there, and various other programs that I've also submitted there.
