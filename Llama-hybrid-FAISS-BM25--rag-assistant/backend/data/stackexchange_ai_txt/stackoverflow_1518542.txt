[site]: stackoverflow
[post_id]: 1518542
[parent_id]: 1518522
[tags]: 
This is the obvious slow solution (O(n^2)) if neither sorting nor hashing is feasible, but equality comparison ( == ) is available: def most_common(items): if not items: raise ValueError fitems = [] best_idx = 0 for item in items: item_missing = True i = 0 for fitem in fitems: if fitem[0] == item: fitem[1] += 1 d = fitem[1] - fitems[best_idx][1] if d > 0 or (d == 0 and fitems[best_idx][2] > fitem[2]): best_idx = i item_missing = False break i += 1 if item_missing: fitems.append([item, 1, i]) return items[best_idx] But making your items hashable or sortable (as recommended by other answers) would almost always make finding the most common element faster if the length of your list (n) is large. O(n) on average with hashing, and O(n*log(n)) at worst for sorting.
