[site]: stackoverflow
[post_id]: 660156
[parent_id]: 658868
[tags]: 
The main issue are the using retries in a random scenario to ensure you get unique values. This quickly gets out of control, specially if the amount of items requested is near to the amount of items to get i.e. if you increase the amount of keys, you will see the issue less often but that can be avoided. The following method does it by keeping a list of the keys remaining. List GetSomeKeys(string[] cachedKeys, int requestedNumberToGet) { int numberPossibleToGet = Math.Min(cachedKeys.Length, requestedNumberToGet); List keysRemaining = new List (cachedKeys); List keysToReturn = new List (numberPossibleToGet); Random rand = new Random(); for (int i = 0; i The timeout was necessary on your version as you could potentially keep retrying to get a value for a long time. Specially when you wanted to retrieve the whole list, in which case you would almost certainly get a fail with the version that relies on retries. Update: The above performs better than these variations: List GetSomeKeysSwapping(string[] cachedKeys, int requestedNumberToGet) { int numberPossibleToGet = Math.Min(cachedKeys.Length, requestedNumberToGet); List keys = new List (cachedKeys); List keysToReturn = new List (numberPossibleToGet); Random rand = new Random(); for (int i = 0; i GetSomeKeysEnumerable(string[] cachedKeys, int requestedNumberToGet) { Random rand = new Random(); return TakeRandom(cachedKeys, requestedNumberToGet, rand).ToList(); } Some numbers with 10.000 iterations: Function Name Elapsed Inclusive Time Number of Calls GetSomeKeys 6,190.66 10,000 GetSomeKeysEnumerable 15,617.04 10,000 GetSomeKeysSwapping 8,293.64 10,000
