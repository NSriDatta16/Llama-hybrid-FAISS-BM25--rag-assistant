[site]: stackoverflow
[post_id]: 3580872
[parent_id]: 
[tags]: 
.NET refactoring, DRY. dual inheritance, data access and separation of concerns

Back story: So I've been stuck on an architecture problem for the past couple of nights on a refactor I've been toying with. Nothing important, but it's been bothering me. It's actually an exercise in DRY , and an attempt to take it to such an extreme as the DAL architecture is completely DRY. It's a completely philosophical/theoretical exercise. The code is based in part on one of @JohnMacIntyre 's refactorings which I recently convinced him to blog about at http://whileicompile.wordpress.com/2010/08/24/my-clean-code-experience-no-1/ . I've modified the code slightly, as I tend to, in order to take the code one level further - usually, just to see what extra mileage I can get out of a concept... anyway, my reasons are largely irrelevant. Part of my data access layer is based on the following architecture: abstract public class AppCommandBase : IDisposable { } This contains basic stuff, like creation of a command object and cleanup after the AppCommand is disposed of. All of my command base objects derive from this. abstract public class ReadCommandBase : AppCommandBase This contains basic stuff that affects all read-commands - specifically in this case, reading data from tables and views. No editing, no updating, no saving. abstract public class ReadItemCommandBase : ReadCommandBase { } This contains some more basic generic stuff - like definition of methods that will be required to read a single item from a table in the database, where the table name, key field name and field list names are defined as required abstract properties (to be defined by the derived class. public class MyTableReadItemCommand : ReadItemCommandBase { } This contains specific properties that define my table name, the list of fields from the table or view, the name of the key field, a method to parse the data out of the IDataReader row into my business object and a method that initiates the whole process. Now, I also have this structure for my ReadList... abstract public ReadListCommandBase : ReadCommandBase > { } public class MyTableReadListCommand : ReadListCommandBase { } The difference being that the List classes contain properties that pertain to list generation (i.e. PageStart, PageSize, Sort and returns an IEnumerable) vs. return of a single DataObject (which just requires a filter that identifies a unique record). Problem: I'm hating that I've got a bunch of properties in my MyTableReadListCommand class that are identical in my MyTableReadItemCommand class. I've thought about moving them to a helper class, but while that may centralize the member contents in one place, I'll still have identical members in each of the classes, that instead point to the helper class, which I still dislike. My first thought was dual inheritance would solve this nicely, even though I agree that dual inheritance is usually a code smell - but it would solve this issue very elegantly. So, given that .NET doesn't support dual inheritance, where do I go from here? Perhaps a different refactor would be more suitable... but I'm having trouble wrapping my head around how to sidestep this problem. If anyone needs a full code base to see what I'm harping on about, I've got a prototype solution on my DropBox at http://dl.dropbox.com/u/3029830/Prototypes/Prototype%20-%20DAL%20Refactor.zip . The code in question is in the DataAccessLayer project. P.S. This isn't part of an ongoing active project, it's more a refactor puzzle for my own amusement. Thanks in advance folks, I appreciate it.
