[site]: stackoverflow
[post_id]: 1583521
[parent_id]: 1583142
[tags]: 
I am probably at heart, mostly a C++ programmer, because I have used it so much, so you may find my experiences interesting. In chronological order, here are the languages I learned, and my epiphanies. I've highlighted the big ones for me. Of course there are many different languages that can provide the same insights, I am just sharing my own personal experiences. Atari Basic - Cool I can make my computer do almost anything, but I keep running up into my 8k memory limit (or I run out of line numbers)! Logo - No line numbers. I can incrementally build and run my programs (later I saw this in Lisp, Scheme, and Forth) Pascal - It's just like Basic but with more functionality (and no line numbers). C - So that's what pointers are (now I understand peek and poke). Assembly - Ah, that's why C is designed the way it is. I might as well just use C instead of assembly. C++ - Objects are a great way to structure my program into logical chunks BASH - Programming with stream (filters, sources, and sinks) can be very powerful PostScript - Fonts are programs! Stack-based programming is a very powerful paradigm . Prolog - So you can just write a bunch of constraints, and get the computer to work out the answer itself. But, gosh, its hard to know what constraints to get it to do what I want! Perl - It doesn't matter if people don't know all the rules. I guess some languages are designed to be easier to write than read. SQL - What a convenient way to query data. It reminds me of Prolog. (later it reminds me of functional programming). Lisp - So you don't need manual memory management, to make linked lists ! (Note I didn't spend enough time on Lisp. Many later lessons could have been learned with it.) Object Pascal - Cool, Pascal can have objects too. Modula-2 - Strange, this looks like Pascal. Simula-67 - Hmmm... so this is where object-oriented languages came from? Java - Everything can be an object (I later learned that even more things can be objects, see Smalltalk below) and code can be compiled-once and run on different platforms. Other epiphanies I had were interfaces are a great way to construct software and garbage collection is really powerful . Delphi - Wow, GUI libraries can be easy to use. Events are an awesome abstraction . C++ templates - Writing code at compile-time is extremely powerful (see Scheme and Lisp). C++ functors and binders - Passing functions to functions is powerful , but the syntax is awful. (This was actually my first real experiences with functional programming, most languages obviously do it better). JavaScript - Prototypes and eval functions are really powerful . XSLT - I can't believe that this is Turing complete. This must be what happens when academics go bad. Eiffel - Contracts are a great way of expressing design assumptions and requirements . AspectJ - Cross-cutting concerns make perfect sense, and it's true that they are hard to express in other OOPLs . But identifying them by the name of a function seems like a hack? Scala - Fields and methods are the same . Higher-order functions can be simple to write. The compiler can guess the type of simple expressions (but not templates). Object code can be much simpler. Pattern matching is neat, but when do I use them? Traits and mix-ins are even better than interfaces . C# - This is like Delphi mixed with C++ and Scala. I can reflect over everything at runtime, and even emit code easily. D - So that is what it looks like to combine unit-testing with design-by-contract, and a bunch of other things, while maintaining a C++ mentality. Smalltalk - Didn't really learn it, but Smalltalk programmers pointed out to me around this time that in Smalltalk everything really was an object (no boxing/unboxing necessary), including code blocks. LINQ - SQL is basically just functional programming. Lua - Everything can be a table! Sounds like JavaScript, but it is easier to embed. ML - When you only use patterns, you can write a lot of code much simpler. Lambda calculus - So this is where Lisp and functional programming came from . Scheme - Generating code at compile-time can be really easy . This is really easy to extend. Numerical handling can be done really well. Functions holding state is powerful. Continuations are neat, but I don't care. Frink - I never realized that units of measurement could be so sophisticated. Joy - That is the shortest code I have ever seen . This is the most under-rated language out there. Combinatory Logic (SKI-Calculus) - You don't need arguments, but can use combinators instead. This is to Joy what Lambda-calculus is to Lisp . Haskell - I wish I could make my code compile. The Haskell standard prelude, has got to be one of the most elegant libraries I have ever seen . Factor - There is so much cool stuff in there, I just wish I could be bothered to learn the syntax. K - Array (vector) based primitive operations are extremely powerful . Forth - This is like a super-powered high-level assembly. There is so much to learn though. Python - This is really readable stuff. It's like a combination of a bunch other languages. Erlang - Expressing programs as actors is a great way to express parallelism. Executable UML - Asynchronous message passing is a great way to express concurrent algorithms without having to think about threads . Ruby - Build systems ( Rake ) can be written in a real programming language. Code blocks can be data too (well technically I learned that with Scala). So of course this list is far longer than you (or anyone else) would probably want. For maximum effect my short list would be: Scheme (or Lisp), Joy (or PostScript), Erlang, Eiffel, AspectJ, Erlang, ML, and Haskell. If you only want to focus on a couple of languages, and are willing to go into them in great depth, then you could get a lot out of mastering Scala or C#. There is of course probably still a thing or two you could learn from C++ 0x, especially if you push and prod it a bit.
