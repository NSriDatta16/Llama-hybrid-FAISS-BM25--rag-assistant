[site]: stackoverflow
[post_id]: 2329449
[parent_id]: 2329294
[tags]: 
Others have told you what needs to be done to fix the immediate problem: either allocate space for tempMake using new or malloc, or else use a std:string. You probably don't want to return a pointer to a struct's member from a function. While you can make correct code while doing so, and there are also very good reasons to do so, this might not be one of those instances. The problem has to do with ownership. If you expose the variable by pointer, then the end user is free to pass that guy around into other functions that may eventually free it before you want them to, or change it in some other way. Additionally, what happens when you decide to free that memory yourself? What if the guy on your team who doesn't know your code was using that pointer value after you deleted it? What if nobody frees it and you use this struct over and over? This is a memory leak. The best model is to hide this functionality is to no allow direct access to your class members, and don't return a pointer from a function unless absolutely necessary. In C++, I think the most elegant solution would be to return a std::string. In straight C, instead pass a char** (let's call it x) into the function, and do this: int askMake(char** x) { char tempMake[100];//or some value you know to be large enough cout > tempMake;//i would use cin.get() so you know the length of the string. //so let's pretend we have that length in a variable called stringLen. *x = new char[stringLen]; for(int i = 0; x && i
