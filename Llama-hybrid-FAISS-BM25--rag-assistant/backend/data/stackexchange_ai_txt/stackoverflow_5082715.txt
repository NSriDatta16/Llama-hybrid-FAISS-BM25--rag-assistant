[site]: stackoverflow
[post_id]: 5082715
[parent_id]: 5082680
[tags]: 
This is a much more complex question than it looks. The simple answer is 1) When you want to stack storage and scope bound resource management, when the scope is left the destructor on this object will be called and storage on the stack will be popped. Be careful not to pass a pointer to one of these scope-bound objects up the call stack (returning, output parameters), this is an easy way to segfault. 2) When you want the object allocated on the free-store, this pointer must be deleted or a memory leak will occur. Take a look at shared_ptr, scoped_ptr, auto_ptr, et al. for some alternatives that make #2 act in some ways like #1. Also, take a look at this question for some pointers on memory management in C++.
