[site]: stackoverflow
[post_id]: 5414857
[parent_id]: 5413963
[tags]: 
Your view controller needs to implement the UIPickerViewDataSource as well as the UIPickerViewDelegate . In the XIB of the UIPickerView you need to link the File's Owner with the UIPickerView's delegate and datasource. Like in the UITabelDataSource you need to provide the number of components (table: sections) inside [numberOfComponentsInPickerView] . Then you need to provide the number of rows for each component in [numberOfRowsInComponent] . Finally you need to provide the title for the each entry inside [titleForRow] . Now to bring everything to life you can use [didSelectRow] to load the next component if the previous one was selected. Attention: UIPickerView has a little bug not to call [didSelectRow] when the component is filled / changed. In order to make it work more smoothly I added a "None" entry as the first entry which is a non-selection and does not cause the next component to be loaded. This is a rudimentary code: - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView { return 3; // Number of Components aka Columns } - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { if( component == 0 ) { return [self.firstColumnEntries count] + 1; } else if( component == 1 ) { return [self.secondColumnEntries count] + 1; } else if( component == 2 ) { return [self.thirdColumnEntries count] + 1; } return 0; } - (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { NSLog( @"titleForRow(), component: %d, row: %d", component, row ); NSDictionary *item = nil; if( row == 0 ) { return @" --- "; } else { int correctedRow = row - 1; if( component == 0 ) { item = [self.firstColumnEntries objectAtIndex:correctedRow]; } else if( component == 1 ) { item = [self.secondColumnEntries objectAtIndex:correctedRow]; } else if( component == 2 ) { item = [self.thirdColumnEntries objectAtIndex:correctedRow]; } return [item objectForKey:@"name"]; // My objects are NSDictionarys } } - (void) pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component { DLog( @"SSVC.didSelectRow(), component: %d, row: %d", component, row ); ActionRequest *action = nil; if( row == 0 ) { if( component == 0 ) { [self refreshFirstColumn:self.firstColumnEntries]; } else if( component == 1 ) { ... } } else { // Last Column is selected. Now selection is complete ... } } Because the UIPickerView takes away a lot of space and you cannot change it size I would recommend to place it on an additional UIView (make the rest transparent) and display it when the user selected the field that is assigned to the value (UITextField). When the selection is done (either when last value is selected or when the user enter a button) you let the View disappear and set the value onto the UITextField. Make sure that the UITextField cannot be edited and that entering it make the View with the Picker View appear. When done make sure that you also move to the next field.
