[site]: stackoverflow
[post_id]: 5397638
[parent_id]: 5397447
[tags]: 
If you have the opportunity to design the struct yourself, it should be possible. The basic idea is that you should design it so that there would be no need to insert pad bytes into it. the second trick is that you must handle differences in endianess. I'll describe how to construct the struct using scalars, but the you should be able to use nested structs, as long as you would apply the same design for each included struct. First, a basic fact in C and C++ is that the alignment of a type can not exceed the size of the type. If it would, then it would not be possible to allocate memory using malloc(N*sizeof(the_type)) . Layout the struct, starting with the largest types. struct { uint64_t alpha; uint32_t beta; uint32_t gamma; uint8_t delta; Next, pad out the struct manually, so that in the end you will match up the largest type: uint8_t pad8[3]; // Match uint32_t uint32_t pad32; // Even number of uint32_t } Next step is to decide if the struct should be stored in little or big endian format. The best way is to "swap" all the element in situ before writing or after reading the struct, if the storage format does not match the endianess of the host system.
