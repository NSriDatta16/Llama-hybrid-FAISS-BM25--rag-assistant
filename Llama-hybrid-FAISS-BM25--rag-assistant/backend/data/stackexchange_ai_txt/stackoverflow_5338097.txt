[site]: stackoverflow
[post_id]: 5338097
[parent_id]: 
[tags]: 
Two sets of serialization attributes on same class

I'm facing a class design problem. I'm using data contract serializer. So, in the assembly that is shared across all my applications, I have something like this: // Assembly DataContracts.dll: .NET 3.0, used by every subsystems [DataContract] public class User { /// Nickname. [DataMember] public string displayName; } There are many more fields: I've left only the displayName trying to compact my code listings. However, one of the applications is a server, who needs another serializer to be applied to the same class, in the following way: // Assembly ServerDatabase.dll, .NET 4.0, used only by server. [EseTable] public class User { /// Nickname. [EseText(bUnicode=true, maxChars=71)] public string displayName; } ServerDatabase.dll is linked to .NET 4. Moreover, [Ese*] attributes are defined in a DLL that can only be loaded by the server component due to the security reasons out of my control, so I can't just have a single class with both sets of attributes shared by every subsystem. Currently, I wrote something like this: // DataContracts.dll [DataContract] public class User { [DataMember] public string displayName; } // ServerDatabase.dll [EseTable] public class UserRecord: User { [EseText(bUnicode=true, maxChars=71)] new public string displayName { get { return base.displayName; } set { base.displayName=value; } } // Note I need to implement an upcasting copy constructor, to convert from User to UserRecord :-( public UserRecord(User that) { base.displayName=that.displayName; } } I don't really like my solution: looks like a hack, and error-prone. Any different better ideas, corrections or fixes? Thanks in advance!
