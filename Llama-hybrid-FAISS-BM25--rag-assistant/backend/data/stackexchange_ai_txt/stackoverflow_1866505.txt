[site]: stackoverflow
[post_id]: 1866505
[parent_id]: 1865727
[tags]: 
Try to keep things loosely coupled, and use interfaces liberally to help. I'd start the design with the Separation of Concerns . The major architectural layers are: Problem Domain (aka. Engine, Back-end): the domain classes, which do all the actual work, have domain knowledge implement domain behaviour Persistence: storage management for domain classes, database/filesystem layer User Interface: the GUI, which talks to the domain classes System Interfaces: talking to other systems, eg. networking, web services The domain classes do the work, but don't know about the UI. The persistence layer knows about the domain classes, enough to save/load as required. The system interface layer abstracts away external systems, which lets you plug a simulator in behind while testing. The UI should ideally use MVC, for maximum flexibility. Without putting too fine a point on it, one would not ordinarily look to Drupal as an exemplar of good architectural design. It has grown rather organically, and there have been many upheavals of the design, as evidenced by the regular plugin breakage upon system upgrades. I would also echo what MicSim said, regarding carefully designing the plugin interface and writing multiple different plugins to exercise it. This is the only way to really flesh out the issues of how the app and plugins interact.
