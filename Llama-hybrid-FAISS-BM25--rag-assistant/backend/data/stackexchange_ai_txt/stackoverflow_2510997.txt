[site]: stackoverflow
[post_id]: 2510997
[parent_id]: 2510521
[tags]: 
KeithB has a really good point that I would like to extend (in a sense that is not related to the question, but that will not fit in a comment): In the specific case of the relation of an object with its subobjects the lifetimes are guaranteed: the parent object will always outlive the child object. In this case the child (member) object does not share the ownership of the parent (containing) object, and a shared_ptr should not be used. It should not be used for semantic reasons (no shared ownership at all) nor for practical reasons: you can introduce all sorts of problems: memory leaks and incorrect deletions. To ease discussion I will use P to refer to the parent object and C to refer to the child or contained object. If P lifetime is externally handled with a shared_ptr , then adding another shared_ptr in C to refer to P will have the effect of creating a cycle. Once you have a cycle in memory managed by reference counting you most probably have a memory leak: when the last external shared_ptr that refers to P goes out of scope, the pointer in C is still alive, so the reference count for P does not reach 0 and the object is not released, even if it is no longer accessible. If P is handled by a different pointer then when the pointer gets deleted it will call the P destructor, that will cascade into calling the C destructor. The reference count for P in the shared_ptr that C has will reach 0 and it will trigger a double deletion. If P has automatic storage duration, when it's destructor gets called (the object goes out of scope or the containing object destructor is called) then the shared_ptr will trigger the deletion of a block of memory that was not new-ed. The common solution is breaking cycles with weak_ptr s, so that the child object would not keep a shared_ptr to the parent, but rather a weak_ptr . At this stage the problem is the same: to create a weak_ptr the object must already be managed by a shared_ptr , which during construction cannot happen. Consider using either a raw pointer (handling ownership of a resource through a pointer is unsafe, but here ownership is handled externally so that is not an issue) or even a reference (which also is telling other programmers that you trust the referred object P to outlive the referring object C )
