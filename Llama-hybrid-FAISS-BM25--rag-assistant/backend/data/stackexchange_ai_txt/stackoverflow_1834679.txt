[site]: stackoverflow
[post_id]: 1834679
[parent_id]: 1834437
[tags]: 
If you go back to the 80s and read literature published on the topic of transaction processing you'll find that one of the most discussed example was the airline reservation systems. And for good reason, as it was one of the OLTP topics that exposed all the issues around transaction processing: correctness, troughput, contention, deadlocks. What you describe is a very similar problem, but instead of air flight seats you have event slots. So yes, you will have all those issues. There is no magic pixie dust. This is a hard problem. But there are some guiding lines: Forgetful Fred cannot lock a slot for ever. Forgetful Fred is the user that opens the reservation screen, picks a seat, then goes to lunch without finishing the transaction. If this is allowed, then the system will slowly 'leak' slots that aren't used Database locks are too expensive to be held while waiting for user input. Throughput can only be achieved with granular locks. The business logic should not attempt concurent updates on correlated items. Everything displayed to the user should be treated as 'tentative'. The user interface should be prepared to handle update conflicts. The update logic should always follow the same hierachy (eg. if the agreed update logic is Account->User->Event->Booking then a rogue transaction trying to update Booking->Event->User will cause deadlocks). And as a matter of fact there is an approach that limits these concerns: workflow processing backed by transactional queues that leverage correlated items exclusive lock out . Not your everyday ASP task for sure, so I'd recommend you stick with what you know.
