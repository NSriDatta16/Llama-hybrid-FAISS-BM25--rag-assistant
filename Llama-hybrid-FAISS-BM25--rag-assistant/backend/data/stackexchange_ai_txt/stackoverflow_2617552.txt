[site]: stackoverflow
[post_id]: 2617552
[parent_id]: 2617453
[tags]: 
As the other answers said, the shell does the wildcard expansion - and you stop it from doing so by enclosing arguments in quotes. Note that options -R and -r are usually used to indicate recursive - see cp , ls , etc for examples. Assuming you organize things appropriately so that wildcards are passed to your program as wildcards and you want to do recursion, then POSIX provides routines to help: nftw - file tree walk (recursive access). fnmatch , glob , wordexp - to do filename matching and expansion There is also ftw , which is very similar to nftw but it is marked 'obsolescent' so new code should not use it. Adrian asked: But I can say ls -R *.txt without single quotes and get a recursive listing. How does that work? To adapt the question to a convenient location on my computer, let's review: $ ls -F | grep '^m' makefile mapmain.pl minimac.group minimac.passwd minimac_13.terminal mkmax.sql.bz2 mte/ $ ls -R1 m* makefile mapmain.pl minimac.group minimac.passwd minimac_13.terminal mkmax.sql.bz2 mte: multithread.ec multithread.ec.original multithread2.ec $ So, I have a sub-directory 'mte' that contains three files. And I have six files with names that start 'm'. When I type 'ls -R1 m*', the shell notes the metacharacter '*' and uses its equivalent of glob() or wordexp() to expand that into the list of names: makefile mapmain.pl minimac.group minimac.passwd minimac_13.terminal mkmax.sql.bz2 mte Then the shell arranges to run ' /bin/ls ' with 9 arguments (program name, option -R1 , plus 7 file names and terminating null pointer). The ls command notes the options (recursive and single-column output), and gets to work. The first 6 names (as it happens) are simple files, so there is nothing recursive to do. The last name is a directory, so ls prints its name and its contents, invoking its equivalent of nftw() to do the job. At this point, it is done. This uncontrived example doesn't show what happens when there are multiple directories, and so the description above over-simplifies the processing. Specifically, ls processes the non-directory names first, and then processes the directory names in alphabetic order (by default), and does a depth-first scan of each directory.
