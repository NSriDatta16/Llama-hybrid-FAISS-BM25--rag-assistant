[site]: stackoverflow
[post_id]: 3527705
[parent_id]: 3527248
[tags]: 
With Visual C++, there is an issue with derived to base delegation of the copy constructor argument: struct Derived; struct Base { Base(){ } private: Base(Derived const&); }; struct Derived : Base { }; Derived d1; Derived d2(d1); This code is valid, but Visual C++ fails to compile it, because they call the base-class copy constructor using a Derived object. The Standard however require the compiler to pass a Base const (or Base in some cases) down to the base class. This is the first part of your puzzle: The template is a better match, because the copy constructor would need a derived to base conversion, but your template accepts the derived class directly, and then would need another copy, and so on and so on. Notice that the template will not act as a copy constructor here (given the VC++ bug), just as the above declaration of Base(Derived const&) did not declare a copy constructor. The second part is the answer to your other question: The Standard was ambiguous and not clear in C++03 as to whether instantiated templates could act as copy constructors or not. In a note, it says Because a template constructor is never a copy constructor, the presence of such a template does not suppress the implicit declaration of a copy constructor. Template constructors participate in overload resolution with other constructors, including copy constructors, and a template constructor may be used to copy an object if it provides a better match than other constructors. but a few paragraphs below that, it says A member function template is never instantiated to perform the copy of a class object to an object of its class type. Because of the context that this text appears on (forbidding by-value parameter copy constructors) one may argue that this is not forbiding an instantiation of a by-reference copy constructor from a template. But such arguing is moot, facing this vague wording. The C++0x FCD clearified it, and removed the weird note. It now is clear that templates are never instantiated to perform a copy, no matter whether it would yield to by-reference or by-value parameters. But as explained above, if you happen to use VC++ by any chance, and it exhibits that behavior, then it has nothing to do with copy constructors.
