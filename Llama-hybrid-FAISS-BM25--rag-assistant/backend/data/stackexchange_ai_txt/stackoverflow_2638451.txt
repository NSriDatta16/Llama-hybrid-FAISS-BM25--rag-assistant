[site]: stackoverflow
[post_id]: 2638451
[parent_id]: 2628118
[tags]: 
I've been thinking about it and I think I finally understood what @algorithmist meant by sweep line . However the very presence of sorting operations means that I have: O(n log n) in average O(n**2) in the worst case Sweep Line First of all, we need some sorting, because our sweep line will consist of walking an ordered set. This ordered set will feature the top and bottom line of each of the red s, as long as they are between the top and bottom of blue . This divides our space into (at most) n*2 horizontal strips. Now, we need to make sure that in each strip , the whole of blue is covered, and this operation cannot have more than O(log n) complexity, this could be done if we had (for each strip) a list of the covered intervals. This is the 'event' @algorithmist is speaking of To handle this event, we'll use a binary tree described below which handles adding or removing a rectangle in exactly O(log n) operations and yields the rightmost interval covered by the tree, which we use to tell if the strip of blue is covered or not. Binary Tree First of all, I am going to index the red rectangles. We sort them using this function: def __lt__(lhs, rhs): return (lhs.left I am going then to create a dedicated binary tree. It will have N leaves, each representing a red rectangle and indicating its presence or absence. They are ordered according to the index. Each intermediary node will have for value the rightmost interval covered by its children Handling the bug "code block cannot follow list": class Node: def __init__(self): self.interval = [] self.left = None self.right = None Now we have two possibilities, let's say the children cover [a,b] and [c,d] : if c , then the node hold [a,d] else it holds [c,d] Why does it works ? Let's take an example using 4 leaves: _ [1,9] _ / \ [1,7] [6,9] The special node ignore [3,5] because it's not the rightmost interval. The reasoning is that the rectangles are ordered: No rectangle on the right of [6,9] will cover the missing [5,6] interval since they begin after 6 The rectangles on the left of [3,5] begin before 3 , so if they cover the missing [5,6] they'll cover [3,5] anyway The root may not indicate the exact set of intervals covered: only the rightmost interval covered. However, it's perfectly sufficient for us to tell if blue is completely covered or not! There are 2 operations available on this tree: Marking a rectangle as present Marking a rectangle as absent Each is similar: if the rectangle was already in this state, do nothing else, toggle its state, then update its parent interval (recursively, up to the root) The recursive bit takes O(log n) . It's a classic property of the balanced binary trees. And once it's done we have the rightmost interval covered by the root which is sufficient to tell whether or not the blue segment is entirely covered or not. Complexity The complexity of the algorithm is simple: We have O(n) events Each event is handled in O(log n) Which yields O(n log n) for the core part. However, we should not forget that we also have 2 sort operations: one to classify the events (for the sweep line) the other to classify the rectangles (for the binary tree) Each shall take O(n log n) in average , but may degenerate into O(n**2) in the worst case, depending on the sorting algorithm used.
