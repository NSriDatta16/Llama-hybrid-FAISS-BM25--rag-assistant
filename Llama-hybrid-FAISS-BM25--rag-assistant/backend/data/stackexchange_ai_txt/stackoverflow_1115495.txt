[site]: stackoverflow
[post_id]: 1115495
[parent_id]: 1114883
[tags]: 
In DSiWin32 we have: var GCF_HTML: UINT; {:Checks if HTML format is stored on the clipboard. @since 2008-04-29 @author gabr } function DSiIsHtmlFormatOnClipboard: boolean; begin Result := IsClipboardFormatAvailable(GCF_HTML); end; { DSiIsHtmlFormatOnClipboard } {:Retrieves HTML format from the clipboard. If there is no HTML format on the clipboard, function returns empty string. @since 2008-04-29 @author MP002, gabr } function DSiGetHtmlFormatFromClipboard: string; var hClipData : THandle; idxEndFragment : integer; idxStartFragment: integer; pClipData : PChar; begin Result := ''; if DSiIsHtmlFormatOnClipboard then begin Win32Check(OpenClipboard(0)); try hClipData := GetClipboardData(GCF_HTML); if hClipData <> 0 then begin pClipData := GlobalLock(hClipData); Win32Check(assigned(pClipData)); try idxStartFragment := Pos(' ', pClipData); // len = 20 idxEndFragment := Pos(' ', pClipData); if (idxStartFragment >= 0) and (idxEndFragment >= idxStartFragment) then Result := Copy(pClipData, idxStartFragment + 20, idxEndFragment - idxStartFragment - 20); finally GlobalUnlock(hClipData); end; end; finally Win32Check(CloseClipboard); end; end; end; { DSiGetHtmlFormatFromClipboard } {:Copies HTML (and, optionally, text) format to the clipboard. @since 2008-04-29 @author MP002, gabr } procedure DSiCopyHtmlFormatToClipboard(const sHtml, sText: string); function MakeFragment(const sHtml: string): string; const CVersion = 'Version:1.0'#13#10; CStartHTML = 'StartHTML:'; CEndHTML = 'EndHTML:'; CStartFragment = 'StartFragment:'; CEndFragment = 'EndFragment:'; CHTMLIntro = ' HTML clipboard '; CHTMLExtro = ' '; CNumberLengthAndCR = 10; CDescriptionLength = // Let the compiler determine the description length. Length(CVersion) + Length(CStartHTML) + Length(CEndHTML) + Length(CStartFragment) + Length(CEndFragment) + 4*CNumberLengthAndCR; var description : string; idxEndFragment : integer; idxEndHtml : integer; idxStartFragment: integer; idxStartHtml : integer; begin // The sHtml clipboard format is defined by using byte positions in the entire block // where sHtml text and fragments start and end. These positions are written in a // description. Unfortunately the positions depend on the length of the description // but the description may change with varying positions. To solve this dilemma the // offsets are converted into fixed length strings which makes it possible to know // the description length in advance. idxStartHtml := CDescriptionLength; // position 0 after the description idxStartFragment := idxStartHtml + Length(CHTMLIntro); idxEndFragment := idxStartFragment + Length(sHtml); idxEndHtml := idxEndFragment + Length(CHTMLExtro); description := CVersion + SysUtils.Format('%s%.8d', [CStartHTML, idxStartHtml]) + #13#10 + SysUtils.Format('%s%.8d', [CEndHTML, idxEndHtml]) + #13#10 + SysUtils.Format('%s%.8d', [CStartFragment, idxStartFragment]) + #13#10 + SysUtils.Format('%s%.8d', [CEndFragment, idxEndFragment]) + #13#10; Result := description + CHTMLIntro + sHtml + CHTMLExtro; end; { MakeFragment } var clipFormats: array[0..1] of UINT; clipStrings: array[0..1] of string; hClipData : HGLOBAL; iFormats : integer; pClipData : PChar; begin { DSiCopyHtmlFormatToClipboard } Win32Check(OpenClipBoard(0)); try //most descriptive first as per api docs clipStrings[0] := MakeFragment(sHtml); if sText = '' then clipStrings[1] := sHtml else clipStrings[1] := sText; clipFormats[0] := GCF_HTML; clipFormats[1] := CF_TEXT; Win32Check(EmptyClipBoard); for iFormats := 0 to High(clipStrings) do begin if clipStrings[iFormats] = '' then continue; hClipData := GlobalAlloc(GMEM_DDESHARE + GMEM_MOVEABLE, Length(clipStrings[iFormats]) + 1); Win32Check(hClipData <> 0); try pClipData := GlobalLock(hClipData); Win32Check(assigned(pClipData)); try Move(PChar(clipStrings[iFormats])^, pClipData^, Length(clipStrings[iFormats]) + 1); finally GlobalUnlock(hClipData); end; Win32Check(SetClipboardData(clipFormats[iFormats], hClipData) <> 0); hClipData := 0; finally if hClipData <> 0 then GlobalFree(hClipData); end; end; finally Win32Check(CloseClipboard); end; end; { DSiCopyHtmlFormatToClipboard } initialization GCF_HTML := RegisterClipboardFormat('HTML Format'); EDIT: @Edelcom: In Delphi 7, DSiWin32 should define _STARTUPINFOW = record cb: DWORD; lpReserved: PWideChar; lpDesktop: PWideChar; lpTitle: PWideChar; dwX: DWORD; dwY: DWORD; dwXSize: DWORD; dwYSize: DWORD; dwXCountChars: DWORD; dwYCountChars: DWORD; dwFillAttribute: DWORD; dwFlags: DWORD; wShowWindow: Word; cbReserved2: Word; lpReserved2: PByte; hStdInput: THandle; hStdOutput: THandle; hStdError: THandle; end; TStartupInfoW = _STARTUPINFOW; PStartupInfoW = ^TStartupInfoW; I'll put this in and release new version.
