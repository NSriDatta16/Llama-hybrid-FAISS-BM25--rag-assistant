[site]: stackoverflow
[post_id]: 3660982
[parent_id]: 3660806
[tags]: 
You can use the syntax without brackets in the way your example shows, but I never saw this in "real life". I think almost always the new feature is simply used to get parent packages in scope: package bobrockets.navigation package tests //now the content of bobrockets.navigation is in scope This is basically the same as writing package bobrockets.navigation.test import bobrockets.navigation._ However, the first version follows the DRY principle. E.g. if you rename the package bobrockets to robertsrockets, you could forget to change the import in the second version (which might point to some "old" code), which is impossible in the first version. In a sense, this (together with the possibility to have modifiers like private[bobsrockets.navigation] ) allows to use package groups as "modules" or "superpackages" with a very lightweight syntax. This is the main usage I'm aware of, but Scala shows often surprising synergy effects, and is blurring the lines (e.g. between objects, packages and package objects, between vals and objects, between defs and functions etc) in interesting ways. So the future will show if this feature has other useful applications. [Update] Here is a new article about this topic by Martin Odersky himself: http://www.artima.com/scalazine/articles/chained_package_clauses_in_scala.html
