[site]: stackoverflow
[post_id]: 4319696
[parent_id]: 4299449
[tags]: 
Managed to speed up the process using an NIO ByteBuffer. On the C++ JNI side... JNIEXPORT jobject JNICALL Java_graphicanalyzer_ImageFeedOpenCV_getFrame (JNIEnv * env, jobject jThis, jobject camera) { //... IplImage *frame = cvQueryFrame(pCaptureDevice); jobject byteBuf = env->NewDirectByteBuffer(frame->imageData, frame->imageSize); return byteBuf; } and on the Java side... void getFrame(Camera cam) { ByteBuffer frameData = cam.getFrame(); //NATIVE call byte[] imgArray = new byte[frame.data.capacity()]; frameData.get(imgArray); //although it seems like an array copy, this call returns very quickly DataBufferByte frameDataBuf = new DataBufferByte(imgArray,imgArray.length); //determine image sample model characteristics int dataType = DataBuffer.TYPE_BYTE; int width = cam.getFrameWidth(); int height = cam.getFrameHeight(); int pixelStride = cam.getPixelStride(); int scanlineStride = cam.getScanlineStride(); int bandOffsets = new int[] {2,1,0}; //BGR //create a WritableRaster with the DataBufferByte PixelInterleavedSampleModel pism = new PixelInterleavedSampleModel ( dataType, width, height, pixelStride, scanlineStride, bandOffsets ); WritableRaster raster = new ImgFeedWritableRaster( pism, frameDataBuf, new Point(0,0) ); //create the BufferedImage ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB); ComponentColorModel cm = new ComponentColorModel(cs, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE); BufferedImage newImg = new BufferedImage(cm,raster,false,null); handleNewImage(newImg); } Using the java.nio.ByteBuffer, I can quickly address the char array returned by the OpenCV code without (apparently) doing much gruesome array copying.
