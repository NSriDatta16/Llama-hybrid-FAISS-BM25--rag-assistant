[site]: stackoverflow
[post_id]: 1647343
[parent_id]: 1647074
[tags]: 
I will just give you general guidelines on a simple way to construct such a system. I assume that the Writer is somehow Registered into the system, and his/her profile contains a valid mail address. So, when he submits the sample, you would create an entry on the "Sample" table. Then you would mail a Manager with the sample and a link. This link would point to a script giving the database "id" of the sample as a parameter (this script should verify that the manager is logged on -- if not, show the login screen and after successful login redirect him back). This script would then be aware of the Manager's intention to allow the Writer to submit his work. Now the fun begins. There are many possibilities: You can create an entry in an appropriate "SubmitAuthorizations" DB table containing the id of the Writer and the date this authorization was given (ie, the date when the row was added to your DB). Then you simply send a mail to the Writer with a link like "upload.php?id=42", where the id is the authorization id. This script would check if the logged user is the correct Writer, and if he is within the allowed timeframe (by comparing the stored "authorization date" and the current date). The next is the one I prefer: without a special table just for handling something trivial (let's say you will never want to "edit" an authorization, nor "cancel" it, but it may still "expire"). You simply simply give the Writer a link with 2 parameters: the date the authorization was given and an authorization key , like: "upload.php?authDate=20091030&key=87a62d726ef7..." Let me explain how it works. The script would first verify if the Writer is logged on (if not, show the login page with a redirection after successful login). So, now it's time to validate the request: that is, check if this is not a "forged" link. How to do this? It's just a "smart" way of construction this authorization key. You can do something like: key = hash(concat(userId, ";", authDate, ";", seed)); Well, here hash() is what we call a "one-way function", like MD5, SHA1, etc. Then concat() is simply a string concatenation function. Finally seed is something like a "master password", completely random and that will not change (for if you change it all the issued links would stop working) just to increase security -- let's say a hacker correctly guesses you are using MD5 (which is easy) and the he tries to hack your system by hashing some combinations of the username and the date. Also, for a request to be valid, it must be in the correct time frame. So, if both the key is valid, and the date is within the time frame, you are able to accept an upload. Some points to note: This is a very simple system, but might be exactly what you need. You should avoid MD5 for the hashing function, take something like SHA1 instead. For the link sent to the Writer, you could "obfuscate" the parameter names, ie, call them "k" for the "key" and "d" for the "authDate". For the date, you could chose another format, more "cryptic", like the unix epoch. Finally, you can encode the parameters with something like "base64" (or simply apply some character replacing function like rot13 for instance, but that take digits into account aswell) just in order to make them more difficult to guessing Just for completeness, in the validation script you can also check if the Writer has already sent a file on the time frame, thus making it impossible to him to send many files within the time frame. I have recently implemented something like this twice on the company I work for, for two completely different uses. Once you get the idea, it is extremelly simple to implement it -- maybe less than 10 lines of code for the whole key-generation and validation process. On one of them, the agent equivalent to your Writer had no account into the system (actually it would be his first contact with the system) -- there was only his "profile" on the system, managed by someone else. In this case, you would have to include the "Writer"'s id on the parameters to the "Upload" script aswell. I hope this helps, and that it was clear enough. If I find the time, I will blog about it with an working example on some language.
