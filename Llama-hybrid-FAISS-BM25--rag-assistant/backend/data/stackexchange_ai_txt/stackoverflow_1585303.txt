[site]: stackoverflow
[post_id]: 1585303
[parent_id]: 1560523
[tags]: 
Finally! Following up leads in sdcvvc's answer , we have it: the O(n log n) algorithm for the problem! It is simple too, after you understand it. Those who guessed FFT were right. The problem: we are given a binary string S of length n , and we want to find three evenly spaced 1s in it. For example, S may be 110110010 , where n =9. It has evenly spaced 1s at positions 2, 5, and 8. Scan S left to right, and make a list L of positions of 1. For the S=110110010 above, we have the list L = [1, 2, 4, 5, 8]. This step is O(n). The problem is now to find an arithmetic progression of length 3 in L , i.e. to find distinct a, b, c in L such that b-a = c-b , or equivalently a+c=2b . For the example above, we want to find the progression (2, 5, 8). Make a polynomial p with terms x k for each k in L . For the example above, we make the polynomial p(x) = (x + x 2 + x 4 + x 5 +x 8 ) . This step is O(n). Find the polynomial q = p 2 , using the Fast Fourier Transform . For the example above, we get the polynomial q(x) = x 16 + 2x 13 + 2x 12 + 3x 10 + 4x 9 + x 8 + 2x 7 + 4x 6 + 2x 5 + x 4 + 2x 3 + x 2 . This step is O(n log n). Ignore all terms except those corresponding to x 2k for some k in L . For the example above, we get the terms x 16 , 3x 10 , x 8 , x 4 , x 2 . This step is O(n), if you choose to do it at all. Here's the crucial point: the coefficient of any x 2b for b in L is precisely the number of pairs (a,c) in L such that a+c=2b . [CLRS, Ex. 30.1-7] One such pair is (b,b) always (so the coefficient is at least 1), but if there exists any other pair (a,c) , then the coefficient is at least 3, from (a,c) and (c,a) . For the example above, we have the coefficient of x 10 to be 3 precisely because of the AP (2,5,8). (These coefficients x 2b will always be odd numbers, for the reasons above. And all other coefficients in q will always be even.) So then, the algorithm is to look at the coefficients of these terms x 2b , and see if any of them is greater than 1. If there is none, then there are no evenly spaced 1s. If there is a b in L for which the coefficient of x 2b is greater than 1, then we know that there is some pair (a,c) — other than (b,b) — for which a+c=2b . To find the actual pair, we simply try each a in L (the corresponding c would be 2b-a ) and see if there is a 1 at position 2b-a in S . This step is O(n). That's all, folks. One might ask: do we need to use FFT? Many answers, such as beta's , flybywire's , and rsp's , suggest that the approach that checks each pair of 1s and sees if there is a 1 at the "third" position, might work in O(n log n), based on the intuition that if there are too many 1s, we would find a triple easily, and if there are too few 1s, checking all pairs takes little time. Unfortunately, while this intuition is correct and the simple approach is better than O(n 2 ), it is not significantly better. As in sdcvvc's answer , we can take the "Cantor-like set" of strings of length n=3 k , with 1s at the positions whose ternary representation has only 0s and 2s (no 1s) in it. Such a string has 2 k = n (log 2)/(log 3) ≈ n 0.63 ones in it and no evenly spaced 1s, so checking all pairs would be of the order of the square of the number of 1s in it: that's 4 k ≈ n 1.26 which unfortunately is asymptotically much larger than (n log n). In fact, the worst case is even worse: Leo Moser in 1953 constructed (effectively) such strings which have n 1-c/√(log n) 1s in them but no evenly spaced 1s, which means that on such strings, the simple approach would take Θ(n 2-2c/√(log n) ) — only a tiny bit better than Θ(n 2 ) , surprisingly! About the maximum number of 1s in a string of length n with no 3 evenly spaced ones (which we saw above was at least n 0.63 from the easy Cantor-like construction, and at least n 1-c/√(log n) with Moser's construction) — this is OEIS A003002 . It can also be calculated directly from OEIS A065825 as the k such that A065825(k) ≤ n not give the longest such string. For example, for n =9, we can get 5 1s (110100011) but the greedy gives only 4 (110110000), for n =26 we can get 11 1s (11001010001000010110001101) but the greedy gives only 8 (11011000011011000000000000), and for n =74 we can get 22 1s (11000010110001000001011010001000000000000000010001011010000010001101000011) but the greedy gives only 16 (11011000011011000000000000011011000011011000000000000000000000000000000000). They do agree at quite a few places until 50 (e.g. all of 38 to 50), though. As the OEIS references say, it seems that Jaroslaw Wroblewski is interested in this question, and he maintains a website on these non-averaging sets . The exact numbers are known only up to 194.
