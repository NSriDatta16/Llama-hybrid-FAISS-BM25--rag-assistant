[site]: stackoverflow
[post_id]: 1597177
[parent_id]: 1595613
[tags]: 
I have not used Spring.NET so I can't comment on that. However, the rest sounds remarkably (or perhaps not so remarkably; we're hardly the first to implement these things ;) similar to my own experience. I too had trouble finding a One True Best Practice so I just read as much as I could and came up with my own interpretation. In my situation I wanted transaction/session management to be external to the repository as well as keep repository concerns from bubbling up out of them (i.e. the code using the repository should not need to know that it's using NHibernate internally and shouldn't need to know anything about NHibernate session management). In my case it was decided that transactions would be created by default lest developers forget them, so I had to have a read-only escape mechanism. I went with the Unit of Work pattern with the NHibernate ISession instance store inside. Calling code (I also created a DSL interface for the UoW) might look something like: using (var uow = UoW.Start().ReadOnly().WithHttpContext() .InNewScope().WithScopeContext(ScopeContextProvider.For ()) { // Repository access } In practice, that could be as short as UoW.Start() depending on how much context is already available. The HttpContext part refers to the storage location for the UoW which is, unsurprisingly, the HttpContext in this case. As you mentioned, for a ASP .NET application, HttpContext is the safest place to store things. ScopeContextProvider basically makes sure the right data context is provided for the UoW (ISession instance to the appropriate database/server, other settings). The "ScopeContext" concept also makes it easy to insert a "test" scope context. Going this route makes the repositories explicitly dependent on the UoW interface. Actually, you might be able to abstract it some but I'm not sure I see the benefit. What I mean is, each repository method retrieves the current UoW instance and then pulls out the ISession object (or simply a SqlConnection for those methods that don't use NHibernate) to run the NHibernate query/operation. This works for me though because it also seems like the ideal time to make sure that the current UoW is not read-only for methods that might need to run CRUD. Overall, I think this is one approach that solves all your points: Allows session management to be external to the repository ISession context can be mocked or pointed at a context provider for a test environment Avoids unnecessary transactions (well, you'd have to invert what I did and have a .Transactional() call or something) I can't see why you couldn't test with SQLite since that's more of an NHibernate concern I use Fluent NHibernate myself Allows the repository to be ignorant of the host environment (that is, the repository caller controls the UoW storage context) As for the UoW implementation, I'm partially kicking myself for not looking around more before I started. There's a project called machine.uow which I understand is fairly popular and works well with NHibernate. I haven't played with it much so I can't say if it solves all my requirements as neatly as the one I wrote myself, but it might have saved development time as well. Perhaps we'll get some comments as to where I went wrong or how to improve things, but I hope this is at least helpful in some way. For reference, the software stack I'm using is: ASP.NET MVC Fluent NHibernate on top of NHibernate Ninject for dependency injection
