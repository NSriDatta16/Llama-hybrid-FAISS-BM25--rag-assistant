[site]: stackoverflow
[post_id]: 5493457
[parent_id]: 5493422
[tags]: 
I'm fairy new in C++, previously I mainly was programing in C#. Unlike C#, C++ has no garbage collection. Any time that you use new (e.g., new Point(0,0) ), you are responsible for using delete to destroy that object. Ideally, you should avoid dynamically allocating objects explicitly and eschew new and delete altogether. You should prefer to create objects with automatic storage duration (on the stack) and work with copies of them (by passing them by value or reference, returning them by value, and storing copies of them in containers). Among other things, you should almost certainly be using a std::vector instead of a std::vector . return *(new Point(this->x * varValue,this->y * varValue)); All of your functions that have code like this are wrong: you dynamically allocate an object, return a copy of that object, and lose all references to the original. You are left without any way to destroy the dynamically allocated object. You don't need to dynamically allocate anything here. The following would suffice: return Point(x * varValue, y * varValue); if(&matchingPointVector!=NULL) This can never be false in a correct program: & takes the address of an object and no object can have the address NULL . The only way this could happen is if you had already dereferenced a null pointer somewhere in your program, in which case you're already in a heap of trouble. Make sure that you have a good introductory C++ book . C++ and C# are very different programming languages.
