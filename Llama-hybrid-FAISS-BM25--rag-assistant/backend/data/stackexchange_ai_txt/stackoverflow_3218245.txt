[site]: stackoverflow
[post_id]: 3218245
[parent_id]: 3217922
[tags]: 
How would the structure of a Bin packing algorithm look in C++? Well, ideally you would have several bin-packing algorithms, separated into different functions, which differ only by the logic of the algorithm. That algorithm should be largely independent from the representation of your data, so you can change your algorithm with only a single function call. You can look at what the STL Algorithms have in common. Mainly, they operate on iterators instead of containers, but as I detail below, I wouldn't suggest this for you initially. You should get a feel for what algorithms are available and leverage them in your implementation. Is STL containers a good tool to make the implementation be able to handle inputs of arbitrary length? It usually works like this: create a container, fill the container, apply an algorithm to the container. Judging from the description of your requirements, that is how you'll use this, so I think it'll be fine. There's one important difference between your bin packing algorithm and most STL algorithms. The STL algorithms are either non-modifying or are inserting elements to a destination. bin-packing, on the other hand, is "here's a list of bins, use them or add a new bin". It's not impossible to do this with iterators, but probably not worth the effort. I'd start by operating on the container, get a working program, back it up, then see if you can make it work for only iterators. How should I handle the containers in a good, easy to read and implement way? I'd take this approach, characterize your inputs and outputs: Input: Collection of items, arbitrary length, arbitrary order. Output: Collection of bins determined by algorithm. Each bin contains a collection of items. Then I'd worry about "what does my algorithm need to do?" Constantly check bins for "does this item fit?" Your Class_bin is a good encapsulation of what is needed. Avoid cluttering your code with unrelated stuff like "print()" - use non-member help functions. type_item struct type_item { int size; int life; bool operator It's unclear what life (or death) is used for. I can't imagine that concept being relevant to implementing a bin-packing algorithm. Maybe it should be left out? This is personal preference, but I don't like giving operator to my objects. Objects are usually non-trivial and have many meanings of less-than. For example, one algorithm might want all the alive items sorted before the dead items. I typically wrap that in another struct for clarity: struct type_item { int size; int life; struct SizeIsLess { // Note this becomes a function object, which makes it easy to use with // STL algorithms. bool operator() (const type_item& lhs, const type_item& rhs) { return lhs.size items; std::sort(items.begin, items.end(), type_item::SizeIsLess); Class_bin class Class_bin { double load; list contents; list ::iterator i; public: Class_bin (); bool operator I would skip the Class_ prefix on all your types - it's just a bit excessive, and it should be clear from the code. (This is a variant of hungarian notation . Programmers tend to be hostile towards it.) You should not have a class member i (the iterator). It's not part of class state. If you need it in all the members, that's ok, just redeclare it there. If it's too long to type, use a typedef . It's difficult to quantify "bin1 is less than bin2", so I'd suggest removing the operator . bool full(type_item) is a little misleading. I'd probably use bool can_hold(type_item) . To me, bool full() would return true if there is zero space remaining. check_load() would seem more clearly named load() . Again, it's unclear what check_dead() is supposed to accomplish. I think you can remove print_bin and write that as a non-member function, to keep your objects cleaner. Some people on StackOverflow would shoot me, but I'd consider just making this a struct, and leaving load and item list public. It doesn't seem like you care much about encapsulation here (you're only need to create this object so you don't need do recalculate load each time). Class_list_of_bins class Class_list_of_bins { list list_of_bins; list ::iterator i; public: void push_list (type_item); void sort_list (); void check_dead (); void print_list (); private: Class_bin new_bin (type_item); bool comparator (type_item, type_item); }; I think you can do without this class entirely. Conceptually, it represents a container, so just use an STL container. You can implement the methods as non-member functions. Note that sort_list can be replaced with std::sort . comparator is too generic a name, it gives no indication of what it compares or why, so consider being more clear. Overall Comments Overall, I think the classes you've picked adequately model the space you're trying to represent, so you'll be fine. I might structure my project like this: struct bin { double load; // sum of item sizes. std::list items; bin() : load(0) { } }; // Returns true if the bin can fit the item passed to the constructor. struct bin_can_fit { bin_can_fit(type_item &item) : item_(item) { } bool operator()(const bin &b) { return item_.size void bin_pack_first_fit(ItemIter curr, ItemIter end, BinOutputIter output_bins) { std::vector bins; // Create a local bin container, to simplify life. for (; curr != end; ++curr) { // Use a helper predicate to check whether the bin can fit this item. // This is untested, but just for an idea. std::vector ::iterator bin_it = std::find_if(bins.begin(), bins.end(), bin_can_fit(*curr)); if (bin_it == bins.end()) { // Did not find a bin with enough space, add a new bin. bins.push_back(bin); // push_back invalidates iterators, so reassign bin_it to the last item. bin_it = std::advance(bins.begin(), bins.size() - 1); } // bin_it now points to the bin to put the item in. bin_it->items.push_back(*curr); bin_it->load += curr.size(); } std::copy(bins.begin(), bins.end(), output_bins); // Apply our bins to the destination. } void main(int argc, char** argv) { std::vector items; // ... fill items std::vector bins; bin_pack_first_fit(items.begin(), items.end(), std::back_inserter(bins)); }
