[site]: stackoverflow
[post_id]: 2257844
[parent_id]: 2257341
[tags]: 
I'm not claiming that it's all that elegant, but it works. I use the conversions from JavaConversions explicitly rather than implicitly to allow type inference to help a little. JavaConversions is new in Scala 2.8. import collection.JavaConversions._ import java.util.{ArrayList, HashMap} import collection.mutable.Buffer val javaMutable = new HashMap[String, ArrayList[ArrayList[Double]]] val scalaMutable: collection.Map[String, Buffer[Buffer[Double]]] = asMap(javaMutable).mapValues(asBuffer(_).map(asBuffer(_))) val scalaImmutable: Map[String, List[List[Double]]] = Map(asMap(javaMutable).mapValues(asBuffer(_).map(asBuffer(_).toList).toList).toSeq: _*) UPDATE : Here is an alternative approach that uses implicits to apply a given set of conversions to an arbitrarily nested structure. trait ==>>[A, B] extends (A => B) { def apply(a: A): B } object ==>> { def convert[A, B](a: A)(implicit a2b: A ==>> B): B = a // the default identity conversion implicit def Identity_==>>[A] = new (A ==>> A) { def apply(a: A) = a } // import whichever conversions you like from here: object Conversions { import java.util.{ArrayList, HashMap} import collection.mutable.Buffer import collection.JavaConversions._ implicit def ArrayListToBuffer[T, U](implicit t2u: T ==>> U) = new (ArrayList[T] ==>> Buffer[U]) { def apply(a: ArrayList[T]) = asBuffer(a).map(t2u) } implicit def HashMapToMap[K, V, VV](implicit v2vv: V ==>> VV) = new (HashMap[K, V] ==>> collection.Map[K, VV]) { def apply(a: java.util.HashMap[K, V]) = asMap(a).mapValues(v2vv) } } } object test { def main(args: Array[String]) { import java.util.{ArrayList, HashMap} import collection.mutable.Buffer // some java collections with different nesting val javaMutable1 = new HashMap[String, ArrayList[ArrayList[Double]]] val javaMutable2 = new HashMap[String, ArrayList[HashMap[String, ArrayList[ArrayList[Double]]]]] import ==>>.{convert, Conversions} // here comes the elegant part! import Conversions.{HashMapToMap, ArrayListToBuffer} val scala1 = convert(javaMutable1) val scala2 = convert(javaMutable2) // check the types to show that the conversion worked. scala1: collection.Map[String, Buffer[Buffer[Double]]] scala2: collection.Map[String, Buffer[collection.Map[String, Buffer[Buffer[Double]]]]] } }
