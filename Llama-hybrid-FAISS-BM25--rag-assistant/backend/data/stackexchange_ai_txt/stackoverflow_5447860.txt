[site]: stackoverflow
[post_id]: 5447860
[parent_id]: 5447301
[tags]: 
I've recently been working on my own application that is using WPF drag/drop extensively and after spending half a day (debugging, googling, re-reading documentation) on exactly same issue you are seeing, I could only conclude there's a "future enhancement" buried somewhere in WPF library. It appears there's a quirk in the drag/drop system. While the user is dragging the object over our control it appears the system will quite frequently send us DragLeave events, followed immediately by DragEnter events. So when we get DragLeave , we can't be sure that the drag/drop operation was actually terminated. Therefore, instead of doing cleanup immediately, we schedule the cleanup to execute later and if during that time we receive another DragEnter or DragOver event, then we don't do the cleanup. This was my solution: protected virtual void OnTargetDragLeave(object sender, DragEventArgs e) { _dragInProgress = false; _target.Dispatcher.BeginInvoke( new Action( ()=> { if( _dragInProgress == false ) OnRealTargetDragLeave( sender, e ); } ) ); } protected virtual void OnTargetDragOver(object sender, DragEventArgs e) { _dragInProgress = true; OnQueryDragDataValid( sender, e ); }
