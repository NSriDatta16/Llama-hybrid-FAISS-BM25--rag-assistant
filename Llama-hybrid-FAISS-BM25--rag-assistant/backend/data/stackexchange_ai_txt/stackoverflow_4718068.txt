[site]: stackoverflow
[post_id]: 4718068
[parent_id]: 4717959
[tags]: 
it should be unique string; string length should be 8 characters; it should contains 2 digits; all symbols (non-digital characters) - should be upper case. Assuming: requirements #2 and #3 are exact (exactly 8 chars, exactly 2 digits) and not a minimum the "symbols" in requirement #4 are the 26 capital letters A through Z you would like an evenly-distributed random string Then your proposed method has two issues. One is that the letters A - Z are ASCII 65 - 90, not 64 - 89. The other is that it doesn't distribute the numbers evenly within the possible string space. That can be remedied by doing the following: Generate two different integers between 0 and 7, and sort them. Generate 2 random numbers from 0 to 9. Generate 6 random letters from A to Z. Use the two different integers in step #1 as positions, and put the 2 numbers in those positions. Put the 6 random letters in the remaining positions. There are 28 possibilities for the two different integers ((8*8 - 8 duplicates) / 2 orderings), 26 6 possibilities for the letters, and 100 possibilities for the numbers, the total # of valid combinations being N comb = 864964172800 = 8.64 x 10 11 . edit: If you want to avoid the database for storage, but still guarantee both uniqueness of strings and have them be cryptographically secure, your best bet is a cryptographically random bijection from a counter between 0 and N max comb to a subset of the space of possible output strings. ( Bijection meaning there is a one-to-one correspondence between the output string and the input counter.) This is possible with Feistel networks , which are commonly used in hash functions and symmetric cryptography (including AES). You'd probably want to choose N max = 2 39 which is the largest power of 2 comb , and use a 39-bit Feistel network, using a constant key you keep secret. You then plug in your counter to the Feistel network, and out comes another 39-bit number X, which you then transform into the corresponding string as follows: Repeat the following step 6 times: Take X mod 26, generate a capital letter, and set X = X / 26. Take X mod 100 to generate your two digits, and set X = X / 100. X will now be between 0 and 17 inclusive (2 39 / 26 6 / 100 = 17.796...). Map this number to two unique digit positions (probably easiest using a lookup table, since we're only talking 28 possibilities. If you had more, use Floyd's algorithm for generating a unique permutation , and use the variable-base technique of mod + integer divide instead of generating a random number). Follow the random approach above, but use the numbers generated by this algorithm instead. Alternatively, use 40-bit numbers, and if the output of your Feistel network is > N comb , then increment the counter and try again. This covers the entire string space at the cost of rejecting invalid numbers and having to re-execute the algorithm. (But you don't need a database to do this.) But this isn't something to get into unless you know what you're doing.
