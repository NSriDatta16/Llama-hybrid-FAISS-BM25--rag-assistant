[site]: stackoverflow
[post_id]: 2903765
[parent_id]: 2897297
[tags]: 
Okay, here's a (near complete) comprehensive benchmarking I've done tonight to see which code runs the fastest. Hopefully someone will find this list useful. I omitted anything that takes more than 30 seconds to complete on my machine. I would like to thank everyone that put in an input. I've gained a lot of insight from your efforts, and I hope you have too. My machine: AMD ZM-86, 2.40 Ghz Dual-Core, with 4GB of RAM. This is a HP Touchsmart Tx2 laptop. Note that while I may have linked to a pastebin, I benchmarked all of the following on my own machine. I will add the gmpy2 benchmark once I am able to build it. All of the benchmarks are tested in Python 2.6 x86 Returning a list of prime numbers n up to 1,000,000: ( Using Python generators) Sebastian's numpy generator version (updated) - 121 ms @ Mark's Sieve + Wheel - 154 ms Robert's version with slicing - 159 ms My improved version with slicing - 205 ms Numpy generator with enumerate - 249 ms @ Mark's Basic Sieve - 317 ms casevh's improvement on my original solution - 343 ms My modified numpy generator solution - 407 ms My original method in the question - 409 ms Bitarray Solution - 414 ms @ Pure Python with bytearray - 1394 ms @ Scott's BitString solution - 6659 ms @ '@' means this method is capable of generating up to n In addition, if you don't need the generator and just want the whole list at once: numpy solution from RosettaCode - 32 ms @ (The numpy solution is also capable of generating up to 1 billion, which took 61.6259 seconds. I suspect the memory was swapped once, hence the double time.)
