[site]: stackoverflow
[post_id]: 1066237
[parent_id]: 1066174
[tags]: 
Simple: The entire point in a class is to encapsulate some kind of abstraction. For example, we want an object that behaves as a text string. Now, if everything had been virtual, I would be able to do this: class MessedUpString : String{ override void Trim() { throw new Exception(); } } and then pass this to some function that expects a string. And the moment they try to trim that string, it explodes. The string no longer behaves as a string. How is that ever a good thing? If everything is made virtual, you're going to have a hard time enforcing class invariants. You allow the class abstraction to be broken. By default, a class should encapsulate the rules and behaviors that it is expected to follow. Everything you make virtual is in principle an extensibility hook, the function can be changed to do anything whatsoever. That only makes sense in a few cases, when we have behavior that is actually user-defined. The reason classes are useful is that they allow us to ignore the implementation details. We can simply say "this is a string object, I know it is going to behave as a string. I know it will never violate any of these guarantees". If that guarantee can not be maintained, the class is useless. You might as well just make all data members public and move the member methods outside the class. Do you know the Liskov Substitution Principle ? Anywhere an object of base class B is expected, you should be able to pass an object of derived class D. That is one of the most fundamental rules of object-oriented programming. We need to know that derived classes will still work when we upcast them to the base class and pass them to a function that expect the base class. That means we have to make some behavior fixed and unchangeable.
