[site]: stackoverflow
[post_id]: 178917
[parent_id]: 178838
[tags]: 
(Was 'Use std::vector') Edit: On reading feedback, I suppose I should expand my answer. You can effectively fit two variable length arrays in your structure as follows, and the storage will be freed for you automatically when file_data goes out of scope: struct nodeheader { std::vector data; std::vector friend_buf; // 'friend' is a keyword! // etc... }; nodeheader file_data; Now file_data.data.size(), etc gives you the length and and &file_data.data[0] gives you a raw pointer to the data if you need it. You'll have to fill file data from the file piecemeal - read the length of each buffer, call resize() on the destination vector, then read in the data. (There are ways to do this slightly more efficiently. In the context of disk file I/O, I'm assuming it doesn't matter). Incidentally OP's technique is incorrect even for his 'fine and dandy' cases, e.g. with only one VLA at the end. char file_data[1024]; nodeheader* node = &(file_data[10]); There's no guarantee that file_data is properly aligned for the nodeheader type. Prefer to obtain file_data by malloc() - which guarantees to return a pointer aligned for any type - or else (better) declare the buffer to be of the correct type in the first place: struct biggestnodeheader { int flags; int data_size; char data[ENOUGH_SPACE_FOR_LARGEST_HEADER_I_EVER_NEED]; }; biggestnodeheader file_data; // etc...
