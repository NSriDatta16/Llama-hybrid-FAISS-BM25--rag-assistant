[site]: stackoverflow
[post_id]: 5329142
[parent_id]: 5327083
[tags]: 
There are a couple of items embedded in this question that need addressed. First is that a RoutedEvent will propagate outwards and up the visual tree. Therefore if you have embedded controls within controls such as this... Button 1 Button 2 Button 3 ...attaching an event to handle KeyDown behavior on MyGrid ; will receive any KeyDown RoutedEvent from within its children. There is one caveat in that if the event is marked handled by a control within the visual tree, which would be the case for the Button control and the MouseLeftButtonDown RoutedEvent; you would then need to adjust how you register. This is simple enough and can be done like this; where true is stating you want to be notifed even if another handler marked the event handled. public Window1() { InitializeComponent(); MyGrid.AddHandler(UIElement.MouseLeftButtonDownEvent, new RoutedEventHandler(MouseLeftButtonDown), true); } private void MouseLeftButtonDown(object sender, RoutedEventArgs e) { Console.WriteLine("MouseLeftButtonDown Fired"); } If you were to step through with the debugger you will see that the source of the RoutedEvent when you click on the text Button 3 is indeed the TextBlock . This will address your need to hook into varying controls; since you can leverage the varying RoutedEvents . Focus still must exist somewhere within the application however; that can be easily set via the parent control and calling Focus .
