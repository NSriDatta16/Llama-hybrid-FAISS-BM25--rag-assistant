[site]: stackoverflow
[post_id]: 3106754
[parent_id]: 3106408
[tags]: 
Here are some suggestions. But it's a matter of taste whether you like the intermediate variable assignments. Just be aware the 'case' and 'if' are expressions that always evaluate to something. I've also removed the "( , ) -> ok" catch all; this appears to be defensive programming which is discouraged in Erlang. Process = fun([RockA, FishA, TreeA, BarkA, DogA, CowA, MooA, MilkA, CheeseA, BreadA, WineA, GrapesA], [RockB, FishB, TreeB, BarkB, DogB, CowB, MooB, MilkB, CheeseB, BreadB, WineB, GrapesB]) -> FirstStuff = case RockA of [ 0,0,0] -> [RockB, FishB, TreeB, BarkB, DogB]; _ -> [RockA, FishA, TreeA, BarkA, DogA] end, NewCow = if CowA > CowB -> CowA; true -> CowB end, lists:flatten( [ FirstStuff, NewCow, MooA + MooB, MilkA + MilkB, CheeseA + CheeseB, BreadA + BreadB, WineA + WineB, GrapesA + GrapesB ]); end. Or even... Process = fun([RockA, FishA, TreeA, BarkA, DogA, CowA, MooA, MilkA, CheeseA, BreadA, WineA, GrapesA], [RockB, FishB, TreeB, BarkB, DogB, CowB, MooB, MilkB, CheeseB, BreadB, WineB, GrapesB]) -> lists:flatten( [ case RockA of [ 0,0,0] -> [RockB, FishB, TreeB, BarkB, DogB]; _ -> [RockA, FishA, TreeA, BarkA, DogA] end, lists:max([CowA,CowB]), MooA + MooB, MilkA + MilkB, CheeseA + CheeseB, BreadA + BreadB, WineA + WineB, GrapesA + GrapesB ]); end.
