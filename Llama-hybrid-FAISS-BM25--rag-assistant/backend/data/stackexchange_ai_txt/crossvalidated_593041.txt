[site]: crossvalidated
[post_id]: 593041
[parent_id]: 592518
[tags]: 
This truly is a different answer... You won't believe this, but this can be done via a new counterfactuals argument that I added to ref_grid() : > emmeans(mod, "species", counterfact = "species") species prob SE df asymp.LCL asymp.UCL Adelie 0.5821 0.0367 Inf 0.510 0.6540 Chinstrap 0.0602 0.0190 Inf 0.023 0.0975 Gentoo 0.9061 0.0751 Inf 0.759 1.0534 Results are averaged over the levels of: .obs.no. Confidence level used: 0.95 The estimates shown are the same as those shown in the OP using stdReg::stdGlm . All that I did was re-define the reference grid so that there is a new factor .obs.no. and we use that in place of any predictors not included in counterfactuals . Note that we do not use weights = "prop" here because we already give the same weight to each observation. Alternative covariances The SEs above are somewhat lower than those from stdGlm , because they are conditional on the covariate values. We get closer if we substitute a sandwich estimate of the covariance, e.g., > emmeans(mod, "species", counter = "species", + vcov. = sandwich::vcovHC(mod)) species prob SE df asymp.LCL asymp.UCL Adelie 0.5821 0.0402 Inf 0.5032 0.6610 Chinstrap 0.0602 0.0202 Inf 0.0205 0.0999 Gentoo 0.9061 0.0852 Inf 0.7392 1.0731 Results are averaged over the levels of: .obs.no. Confidence level used: 0.95 A humble approach If you really like what you got from stdReg , maybe you should just use it by importing it into the emmeans machinery: > std = stdGlm(fit = mod, data = dat_pen, X = "species") > mod.emm = emmobj(bhat = std $est, V = std$ vcov, + levels = list(species = levels(dat_pen$species))) > mod.emm species estimate SE df asymp.LCL asymp.UCL Adelie 0.5821 0.0435 NA 0.4969 0.667 Chinstrap 0.0602 0.0204 NA 0.0202 0.100 Gentoo 0.9061 0.0826 NA 0.7441 1.068 Confidence level used: 0.95 > pairs(mod.emm) contrast estimate SE df z.ratio p.value Adelie - Chinstrap 0.522 0.0470 NA 11.106
