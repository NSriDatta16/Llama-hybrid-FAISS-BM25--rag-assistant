[site]: stackoverflow
[post_id]: 5200297
[parent_id]: 5190328
[tags]: 
As you can see from the answers (notably Daniel's, but also your own), it is possible, but it doesn't look elegant. The difficulty appears because when you use the Cake pattern, you mix all required traits into one object (using "with" keyword), and you cannot mix a trait more than once into one instance. That is how mixins work, and the Cake is based on them. The fact you can force Cake to handle non-singleton dependencies doesn't mean you should do it. I would advise you to simply use plain-old constructor in such cases, that is where self-type annotation doesn't fit well: trait HttpService { ... } /* HttpServiceImpl has become a top-level class now, * as the Cake pattern adds no more value here. * In addition, trait HttpServiceComponent gets deleted */ class HttpServiceImpl(address:String) extends HttpService { ... } trait TradeService { def lastTrade(symbol:String):String } trait TradeServiceComponent { // The dependency on HttpService is no longer declared as self-type val tradeService:TradeService // It is declared as a constructor parameter now class TradeServiceImpl(httpService: HttpService) extends TradeService { def lastTrade(symbol:String):String = httpService.get("symbol=" + symbol) } } trait CompanyService { def getCompanySymbols(exchange:String):String } trait CompanyServiceComponent { // Again, self-type annotation deleted val companyService:CompanyService // Again, the dependency is declared as a constructor parameter class CompanyServiceImpl(httpService: HttpService) extends CompanyService { def getCompanySymbols(exchange:String):String = httpService.get("exchange=" + exchange) } } The App and AppComponent traits stay in their original form. Now you can use the all components in the following way: object App { def main(args:Array[String]):Unit = { val appAssembly = new AppComponent with TradeServiceComponent with CompanyServiceComponent { // Note, that HttpServiceComponent it neither needed nor mixed-in now val tradeService = new TradeServiceImpl( new HttpServiceImpl("http://trades-r-us.com")) val companyService = new CompanyServiceImpl( new HttpServiceImpl("http://exchange-services.com")) val app = new AppImpl } appAssembly.app.run(args(0)) } } Also, you may want do double-check if the Cake pattern is really best suited for your needs, as it is actually a complex pattern and dependency injection is only one part of it. If you use it only for DI, I would advise you to use a simpler solution. I've blogged about that here .
