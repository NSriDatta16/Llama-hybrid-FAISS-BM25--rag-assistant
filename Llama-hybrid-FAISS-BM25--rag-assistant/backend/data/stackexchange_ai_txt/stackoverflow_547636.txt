[site]: stackoverflow
[post_id]: 547636
[parent_id]: 547622
[tags]: 
A trivial recursive solution: int count() { Tree l = getLeftTree(); Tree r = getRightTree(); return 1 + (l != null ? l.count() : 0) + (r != null ? r.count() : 0); } A less trivial non-recursive one: int count() { Stack s = new Stack (); s.push(this); int cnt = 0; while (!s.empty()) { Tree t = s.pop(); cnt++; Tree ch = getLeftTree(); if (ch != null) s.push(ch); ch = getRightTree(); if (ch != null) s.push(ch); } return cnt; } The latter is probably slightly more memory-efficient, because it replaces recursion with a stack and an iteration. It's also probably faster, but its hard to tell without measurements. A key difference is that the recursive solution uses the stack, while the non-recursive solution uses the heap to store the nodes. Edit: Here's a variant of the iterative solution, which uses the stack less heavily: int count() { Tree t = this; Stack s = new Stack (); int cnt = 0; do { cnt++; Tree l = t.getLeftTree(); Tree r = t.getRightTree(); if (l != null) { t = l; if (r != null) s.push(r); } else if (r != null) { t = r; } else { t = s.empty() ? null : s.pop(); } } while (t != null); return cnt; } Whether you need a more efficient or a more elegant solution naturally depends on the size of your trees and on how often you intend to use this routine. Rembemer what Hoare said: "premature optimization is the root of all evil."
