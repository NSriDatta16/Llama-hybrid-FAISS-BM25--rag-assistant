[site]: stackoverflow
[post_id]: 5460191
[parent_id]: 5459810
[tags]: 
You don't need to pass it to your UserControl . DataContext objects are inexpensive to create, so if you need access to the object there you can just instantiate a new one. However, to answer your question directly, you can share an HttpContext -scoped DataContext among all user controls by storing it in HttpContext.Items such as HttpContext.Items["DataContextKey"] = new MyDataContext(); Then, you can initialize a field in your constructor like from your controls via _dataContext = (MyDataContext)Context.Items["DataContextKey"]; A more elegant implementation of this approach (and other approaches) for managing the DataContext life cycle in general is available at http://www.west-wind.com/weblog/posts/246222.aspx , in a DataContextFactory class. The method that will be most interesting to you is: static object GetWebRequestScopedDataContextInternal(Type type, string key, string connectionString) { object context; if (HttpContext.Current == null) { if (connectionString == null) context = Activator.CreateInstance(type); else context = Activator.CreateInstance(type, connectionString); return context; } // *** Create a unique Key for the Web Request/Context if (key == null) key = "__WRSCDC_" + HttpContext.Current.GetHashCode().ToString("x") + Thread.CurrentContext.ContextID.ToString(); context = HttpContext.Current.Items[key]; if (context == null) { if (connectionString == null) context = Activator.CreateInstance(type); else context = Activator.CreateInstance(type, connectionString); if (context != null) HttpContext.Current.Items[key] = context; } return context; }
