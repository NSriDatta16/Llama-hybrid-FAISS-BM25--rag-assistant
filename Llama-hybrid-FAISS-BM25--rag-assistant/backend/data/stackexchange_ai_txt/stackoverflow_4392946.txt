[site]: stackoverflow
[post_id]: 4392946
[parent_id]: 4382942
[tags]: 
This might work because of how your vendor happens to implement std::set and std::set ::iterator , but it's not guaranteed to. Standard section 23.1.2 Paragraph 7 and Table 69 say that the expression a.erase(q) is valid when a is an object of an associative container class type ( set is an associative container) and " q denotes a valid dereferenceable iterator to a ". When the iterator is not from the container, you get Undefined Behavior. Appearing to work is one valid result of Undefined Behavior.
