[site]: stackoverflow
[post_id]: 4386024
[parent_id]: 4385160
[tags]: 
Are you looking for details especially about compiling lazy-evaluation? There is Simon Peyton-Jones's book mentioned by Max Bolingbroke, also the book detailing Clean's implementation is online: http://wiki.clean.cs.ru.nl/Functional_Programming_and_Parallel_Graph_Rewriting If you have a university affiliation and want something smaller you could try to get these books (Henderson & Diller are certainly out of print): Antoni Diller "Compiling Function Languages" ISBN 0 471 92027 4 Peter Henderson "Functional Programming Application and Implementation" ISBN 0-13-331579-7 AJT Davie "An Introduction to Functional Programming Systems using Haskell" ISBN 0 521 27724 8 Diller has a full compiler for a lazy language (implemented in Pascal) via combinator reduction. This was the implementation technique invented by David Turner for SASL. Henderson has many parts of a compiler for LISPkit a miniature, lazy variant of Lisp. Davie details quite a bit of the machinery for compiling a lazy language, for instance there's a description of the STG thats much shorter than Simon Peyton-Jones's book (the STG is the abstract machine SPJ used for Haskell). The Clean developers have quite a bit of info on implementing SAPL (a Simple Applicative Language) if you look through their publications list: https://clean.cs.ru.nl/Publications Finally there are quite a number of papers documenting aspects of the Utrecht Haskell Compiler UHC (and EHC). I think most of the information is how the compiler is organized (with attribute grammars and "Shuffle") and how the type systems (there are various levels of type system in EHC) are implemented, rather than how the back-end 'compilation' works.
