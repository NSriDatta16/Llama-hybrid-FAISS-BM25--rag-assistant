[site]: stackoverflow
[post_id]: 5141241
[parent_id]: 5140817
[tags]: 
The relevant paragraph in the standard is this An assignment operator stores a value in the object designated by the left operand. An assignment expression has the value of the left operand after the assignment, but is not an lvalue. The type of an assignment expression is the type of the left operand unless the left operand has qualified type, in which case it is the unqualified version of the type of the left operand. The side effect of updating the stored value of the left operand shall occur between the previous and the next sequence point. So this clearly makes the difference between "the value of the left operand" and the update of the stored value. Also note that the return is not an lvalue (so there is no reference to the variable in the return of the expression) and all qualifiers are lost. So I read this as gcc doing the right thing when it returns the value that it knowingly has to store. Edit: The upcoming standard plans to clarify that by adding a footnote: The implementation is permitted to read the object to determine the value but is not required to, even when the object has volatile-qualified type. Edit 2: Actually there is another paragraph about expression statements that might shed a light on that: The expression in an expression statement is evaluated as a void expression for its side effects.\footnote{Such as assignments, and function calls which have side effects} Since this implies that the effect of returning a value is not wanted for such a statement, this strongly suggests that the value may only be loaded from the variable if the value is used. As a summary, your customer really is rightly upset when he sees that the variable is loaded. This behavior might be in accordance with the standard if you stretch the interpretation of it, but it clearly is on the borderline of being acceptable.
