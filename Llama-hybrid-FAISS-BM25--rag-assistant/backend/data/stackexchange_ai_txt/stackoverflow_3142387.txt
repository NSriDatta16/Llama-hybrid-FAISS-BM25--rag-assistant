[site]: stackoverflow
[post_id]: 3142387
[parent_id]: 3141733
[tags]: 
When I write programs, I like to concentrate on my problem domain and not on the minutiae of unrelated implementation details. For example, if I'm writing, say, a web server, my problem domain is network connections, protocols, data transmission/reception, and so on, not memory allocation and deallocation. If I'm writing a video game, my problem domain is graphical performance and perhaps AI and again not memory allocation and deallocation. Any time I spend working on things that are not part of my problem domain is time wasted that could be spent on, you know, my problem domain. By concentrating on low-level details, in other words, the quality of my actual work—the problem I'm actually trying to solve—suffers. Further, your "all you need to do is actually just be wise with memory allocation/deallocation" bit only serves to highlight two possibilities (that I can think of, at any rate): You are very inexperienced. You have been – likely subconsciously – crippling your designs to keep them within the restrictions of your simplistic assumptions about memory management. Memory management in real-world software is a decidedly non -trivial endeavour. Complex data structures typical of any sizeable piece of modern software lead to incredible obfuscation in terms of determining the "liveness" and "ownership" of any given piece of dynamically-allocated memory. This is rendered even more complex (potentially by orders of magnitude) with the introduction of threading or, worse, multi-processing (both symmetric and otherwise) with any form of shared state. It is no accident that the most common bugs in software written in unmanaged memory environments are related to poorly-managed dynamically allocated memory. So why use garbage collection? Because you're not as smart as you think you are when dealing with the vagaries of dynamically allocated memory. Really, you're not. No matter how smart you think you are. If you recognize that you're not that smart, you cripple your designs to keep your memory management simple enough to understand. If you arrogantly believe, however, that you can deal with anything, you just screw your users who have to deal with your crappy, crash-prone and/or memory-eating software.
