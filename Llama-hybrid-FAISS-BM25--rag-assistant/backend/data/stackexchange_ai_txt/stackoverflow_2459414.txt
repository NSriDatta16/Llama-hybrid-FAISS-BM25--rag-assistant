[site]: stackoverflow
[post_id]: 2459414
[parent_id]: 
[tags]: 
OSX: How to get a volume name (or bsd name) from a IOUSBDeviceInterface or location id

I'm trying to write an app that associates a particular USB string descriptor (of a USB mass storage device) with its volume or bsd name. So the code goes through all the connected USB devices, gets the string descriptors and extracts information from one of them. I would like to get the volume name of those USB devices. I can't find the right API to do that. I have tried to do that: DASessionRef session = DASessionCreate(kCFAllocatorDefault); DADiskRef disk_ref = DADiskCreateFromIOMedia(kCFAllocatorDefault, session, usb_device_ref); const char* name = DADiskGetBSDName(disk_ref); But the DADiskCreateFromIOMedia function returned nil, I assume the usb_device_ref that I passed was not compatible with the io_service_t that the function is expecting. So how can I get the volume name of a USB device? Could I use the location id to do that? Thanks for reading. -L FOO_Result result = FOO_SUCCESS; mach_port_t master_port; kern_return_t k_result; io_iterator_t iterator = 0; io_service_t usb_device_ref; CFMutableDictionaryRef matching_dictionary = NULL; // first create a master_port if (FOO_FAILED(k_result = IOMasterPort(MACH_PORT_NULL, &master_port))) { fprintf(stderr, "could not create master port, err = %d\n", k_result); goto cleanup; } if ((matching_dictionary = IOServiceMatching(kIOUSBDeviceClassName)) == NULL) { fprintf(stderr, "could not create matching dictionary, err = %d\n", k_result); goto cleanup; } if (FOO_FAILED(k_result = IOServiceGetMatchingServices(master_port, matching_dictionary, &iterator))) { fprintf(stderr, "could not find any matching services, err = %d\n", k_result); goto cleanup; } while (usb_device_ref = IOIteratorNext(iterator)) { IOReturn err; IOCFPlugInInterface **iodev; // requires IOUSBDeviceInterface **dev; SInt32 score; err = IOCreatePlugInInterfaceForService(usb_device_ref, kIOUSBDeviceUserClientTypeID, kIOCFPlugInInterfaceID, &iodev, &score); if (err || !iodev) { printf("dealWithDevice: unable to create plugin. ret = %08x, iodev = %p\n", err, iodev); return; } err = (*iodev)->QueryInterface(iodev, CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID), (LPVOID*)&dev); (*iodev)->Release(iodev); // done with this FOO_String string_value; UInt8 string_index = 0x1; FOO_Result result = FOO_SUCCESS; CFStringRef device_name_as_cf_string; do { if (FOO_SUCCEEDED(result = FOO_GetStringDescriptor(dev, string_index, 0, string_value))) { printf("String at index %i is %s\n", string_index, string_value.GetChars()); // extract the command code if it is the FOO string if (string_value.CompareN("FOO:", 4) == 0) { FOO_Byte code = 0; FOO_HexToByte(string_value.GetChars() + 4, code); // Get other relevant information from the device io_name_t device_name; UInt32 location_id = 0; // Get the USB device's name. err = IORegistryEntryGetName(usb_device_ref, device_name); device_name_as_cf_string = CFStringCreateWithCString(kCFAllocatorDefault, device_name, kCFStringEncodingASCII); err = (*dev)->GetLocationID(dev, &location_id); // TODO: get volume or BSD name // add the device to the list break; } } string_index++; } while (FOO_SUCCEEDED(result)); err = (*dev)->USBDeviceClose(dev); if (err) { printf("dealWithDevice: error closing device - %08x\n", err); (*dev)->Release(dev); return; } err = (*dev)->Release(dev); if (err) { printf("dealWithDevice: error releasing device - %08x\n", err); return; } IOObjectRelease(usb_device_ref); // no longer need this reference }
