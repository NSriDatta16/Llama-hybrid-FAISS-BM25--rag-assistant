[site]: stackoverflow
[post_id]: 5100358
[parent_id]: 5097514
[tags]: 
I don't know about Ganymed. But I have used JSch extensively for remote login and script executions. I used Google's Expect4j with Jsch for executing scripts on remote machines in expect mode(send/wait). You can get the whole output of executed command or scripts in your code using JSch/Expect4j/Closures. For jsch, go to http://www.jcraft.com/jsch/ For Expect4j, go to http://code.google.com/p/expect4j/ The following is a small code sample for logging in and executing file for remote Java class. private Expect4j SSH(String hostname, String username,String password, int port) throws Exception { JSch jsch = new JSch(); Session session = jsch.getSession(username, hostname, port); if (password != null) { session.setPassword(password); } Hashtable config = new Hashtable (); config.put("StrictHostKeyChecking", "no"); session.setConfig(config); session.connect(60000); channel = (ChannelShell) session.openChannel("shell"); Expect4j expect = new Expect4j(channel.getInputStream(), channel.getOutputStream()); channel.connect(); return expect; } This method will open up a SSH stream to the remote server which will be used by expect4j for sending commands. private boolean executeCommands() { boolean isSuccess = true; Closure closure = new Closure() { public void run(ExpectState expectState) throws Exception { buffer.append(expectState.getBuffer());//buffer is string buffer for appending output of executed command expectState.exp_continue(); } }; List lstPattern = new ArrayList (); String[] regEx = SSHConstants.linuxPromptRegEx; if (regEx != null && regEx.length > 0) { synchronized (regEx) { for (String regexElement : regEx) {//list of regx like, :>, /> etc. it is possible command prompts of your remote machine try { RegExpMatch mat = new RegExpMatch(regexElement, closure); lstPattern.add(mat); } catch (MalformedPatternException e) { return false; } catch(Exception e) { return false; } } lstPattern.add(new EofMatch( new Closure() { // should cause entire page to be collected public void run(ExpectState state) { } })); lstPattern.add(new TimeoutMatch(defaultTimeOut, new Closure() { public void run(ExpectState state) { } })); } } try { Expect4j expect = SSH(objConfig.getHostAddress(), objConfig.getUserName(), objConfig.getPassword(), SSHConstants.SSH_PORT); expect.setDefaultTimeout(defaultTimeOut); if(isSuccess) { for(String strCmd : lstCmds) isSuccess = isSuccess(lstPattern,strCmd); } boolean isFailed = checkResult(expect.expect(lstPattern)); return !isFailed; } catch (Exception ex) { return false; } finally { closeConnection(); } } private boolean isSuccess(List objPattern,String strCommandPattern) { try { boolean isFailed = checkResult(expect.expect(objPattern)); if (!isFailed) { expect.send(strCommandPattern); expect.send("\r"); return true; } return false; } catch (MalformedPatternException ex) { return false; } catch (Exception ex) { return false; } }
