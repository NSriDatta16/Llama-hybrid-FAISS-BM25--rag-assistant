[site]: stackoverflow
[post_id]: 3314241
[parent_id]: 
[tags]: 
Are there any exsisting abstract file catalog libraries?

I'd like to make sure I'm not reinventing the wheel with my current project. I'm writing a tool that creates a catalog of content for a CAD program, which catalogs files. My Catalog class represents a hierarchical structure of files and folders. Files in the catalog can have additional meta data stored with them, which should not modify the actual file. This meta data can also include other files such as thumbnails, or attachments. Catalogs provide an interface for the typical CRUD interactions, and should also allow for files (along with their meta data) to bet copied between catalogs. I'm trying to abstract the interface to a catalog to the point where it could be stored almost anywhere. For example right now I'm creating a format of a catalog which is stored on a file system. Metadata files such as thumbnails and attachments are stored in sidecar files within the catalog folder, and the remaining catalog data is stored in an XML file at the root of the catalog folder. However, I'm trying to abstract the Catalog class to the point where I could create versions that are stored in a SQL Server, HTTP server, ZIP file, binary file etc.. etc.. Thus rather then referring to files by a disk path I'm using System.IO.Stream as the most abstract representation of binary data. Ultimately I want to be able to create a drag and drop interface where users can move files between catalogs of any format. This gets pretty complicated as moving a file between catalogs also requires moving the related metadata files. So I'm also trying to figure out a transaction system that will ensure that all or none of the requested File IO actions complete. My ICatalog interface is shown below for reference. Hopefully it will provided a better idea of what I'm trying to accomplish. So anyway now I'm wondering if I'm reinventing the wheel, or if there are any existing tools or libraries out there that provided similar functionality. interface ICatalog { string Location { get; } string Name { get; set; } //NOTE: File is not System.IO.File, but a custom class System.Collections.Generic.IEnumerable GetFiles(); System.Collections.Generic.IEnumerable GetFiles(string relativeFolderPath, bool recursiveSearch); ITransaction ImportNewFile(File f, System.IO.Stream sourceDataStream); ITransaction CopyFileTo(File f, string destRelativePath); ITransaction DeleteFile(string relativePath); ITransaction MoveFile(File f, string destRelativePath); event EventHandler FileAdded; event EventHandler FileRemoved; System.Collections.Generic.IEnumerable Folders { get; } ITransaction AddFolder(string relativePath); ITransaction DeleteFolder(string relativePath); event EventHandler FolderAdded; event EventHandler FolderRemoved; void WriteMetaDataFile(File file, string relPath, System.IO.Stream dataStream, bool overwrite); System.IO.Stream ReadMetaDataFile(File file, string relPath); ITransaction DeleteMetaDataFile(File file, string relPath); System.Collections.Generic.IList GetCleanUpTransactions(ProgressUpdateDelegate callbackDelegate); void RefreshFilesStatus(ProgressUpdateDelegate callbackDelegate); void SaveAndClose(ProgressUpdateDelegate callbackDelegate); }
