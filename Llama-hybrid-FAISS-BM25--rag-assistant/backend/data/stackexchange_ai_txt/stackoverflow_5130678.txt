[site]: stackoverflow
[post_id]: 5130678
[parent_id]: 5130395
[tags]: 
I think all the answers posted before give a fine solution. Interestingly, this is not something that could be elegantly solved using F# sequence expressions - you have to use either lists & recursion, some tricky functions (e.g. pairwise ) or use the IEnumerator interface. I wrote a computation builder that allows you to work with IEnumerator (see the full source code on fssnip.net ). Using this computation, you could solve it very nicely: let loadFile path = // Recursive function that generates IEnumerator of key * value pairs let rec loop source = iter { // Read key & value and continue if both are available let! key = source let! value = source match key, value with | Some key, Some value -> // Produce key * value pair and continue looping yield key, value yield! loop source | _ -> () } // Create sequence that reads data and convert it to dictionary Enumerator.toSeq (fun () -> loop (File.ReadAllLines(@"keyvalue.txt").GetEnumerator())) |> dict I find the iter computation very nice - there are some cases where you cannot solve problem using F# seq . Then you can use recursion and lists - but the same recursion pattern can be also quite neatly written using iter .
