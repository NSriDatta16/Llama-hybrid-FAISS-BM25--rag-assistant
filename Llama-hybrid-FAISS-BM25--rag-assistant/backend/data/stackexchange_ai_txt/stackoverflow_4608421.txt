[site]: stackoverflow
[post_id]: 4608421
[parent_id]: 4607128
[tags]: 
Here's the exact language from the C standard ( n1256 ): 6.3.2.1 Lvalues, arrays, and function designators ... 3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type ’’ is converted to an expression with type ‘‘pointer to type ’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined. The important thing to remember here is that there is a difference between an object (in C terms, meaning something that takes up memory) and the expression used to refer to that object. When you declare an array such as int a[10]; the object designated by the expression a is an array (i.e., a contiguous block of memory large enough to hold 10 int values), and the type of the expression a is "10-element array of int ", or int [10] . If the expression a appears in a context other than as the operand of the sizeof or & operators, then its type is implicitly converted to int * , and its value is the address of the first element. In the case of the sizeof operator, if the operand is an expression of type T [N] , then the result is the number of bytes in the array object, not in a pointer to that object: N * sizeof T . In the case of the & operator, the value is the address of the array, which is the same as the address of the first element of the array, but the type of the expression is different: given the declaration T a[N]; , the type of the expression &a is T (*)[N] , or pointer to N-element array of T. The value is the same as a or &a[0] (the address of the array is the same as the address of the first element in the array), but the difference in types matters. For example, given the code int a[10]; int *p = a; int (*ap)[10] = &a; printf("p = %p, ap = %p\n", (void *) p, (void *) ap); p++; ap++; printf("p = %p, ap = %p\n", (void *) p, (void *) ap); you'll see output on the order of p = 0xbff11e58, ap = 0xbff11e58 p = 0xbff11e5c, ap = 0xbff11e80 IOW, advancing p adds sizeof int (4) to the original value, whereas advancing ap adds 10 * sizeof int (40). More standard language: 6.5.2.1 Array subscripting Constraints 1 One of the expressions shall have type ‘‘pointer to object type ’’, the other expression shall have integer type, and the result has type ‘‘ type ’’. Semantics 2 A postfix expression followed by an expression in square brackets [] is a subscripted designation of an element of an array object. The definition of the subscript operator [] is that E1[E2] is identical to (*((E1)+(E2))) . Because of the conversion rules that apply to the binary + operator, if E1 is an array object (equivalently, a pointer to the initial element of an array object) and E2 is an integer, E1[E2] designates the E2 -th element of E1 (counting from zero). Thus, when you subscript an array expression, what happens under the hood is that the offset from the address of the first element in the array is computed and the result is dereferenced. The expression a[i] = 10; is equivalent to *((a)+(i)) = 10; which is equivalent to *((i)+(a)) = 10; which is equivalent to i[a] = 10; Yes, array subscripting in C is commutative; for the love of God, never do this in production code. Since array subscripting is defined in terms of pointer operations, you can apply the subscript operator to expressions of pointer type as well as array type: int *p = malloc(sizeof *p * 10); int i; for (i = 0; i Here's a handy table to remember some of these concepts: Declaration: T a[N]; Expression Type Converts to Value ---------- ---- ------------ ----- a T [N] T * Address of the first element in a; identical to writing &a[0] &a T (*)[N] Address of the array; value is the same as above, but the type is different sizeof a size_t Number of bytes contained in the array object (N * sizeof T) *a T Value at a[0] a[i] T Value at a[i] &a[i] T * Address of a[i] Declaration: T a[N][M]; Expression Type Converts to Value ---------- ---- ------------ ----- a T [N][M] T (*)[M] Address of the first subarray (&a[0]) &a T (*)[N][M] Address of the array (same value as above, but different type) sizeof a size_t Number of bytes contained in the array object (N * M * sizeof T) *a T [M] T * Value of a[0], which is the address of the first element of the first subarray (same as &a[0][0]) a[i] T [M] T * Value of a[i], which is the address of the first element of the i'th subarray &a[i] T (*)[M] Address of the i-th subarray; same value as above, but different type sizeof a[i] size_t Number of bytes contained in the i'th subarray object (M * sizeof T) *a[i] T Value of the first element of the i'th subarray (a[i][0]) a[i][j] T Value at a[i][j] &a[i][j] T * Address of a[i][j] Declaration: T a[N][M][O]; Expression Type Converts to ---------- ---- ----------- a T [N][M][O] T (*)[M][O] &a T (*)[N][M][O] *a T [M][O] T (*)[O] a[i] T [M][O] T (*)[O] &a[i] T (*)[M][O] *a[i] T [O] T * a[i][j] T [O] T * &a[i][j] T (*)[O] *a[i][j] T a[i][j][k] T From here, the pattern for higher-dimensional arrays should be clear. So, in summary: arrays are not pointers. In most contexts, array expressions are converted to pointer types.
