[site]: stackoverflow
[post_id]: 3965455
[parent_id]: 3965409
[tags]: 
Don't send -init... twice to the same object, ever. Use NSBundle's loadNibNamed:owner:options: instead to load other nibs. Anyway, I suspect your view controller already has a view set up. What do you load from the other nib? If you need to present another view as modal, you should have another view controller object for that. Asking a view controller to present itself as a modal view controller doesn't make sense. It can present another view controller, though. EDIT: -presentModalViewController:animated: tells one view controller to show another view controller modally . The opposite operation, -dismissModalViewControllerAnimated:, tells the first vc to dismiss the modal vc it has presented previously. This approach requires two distinct view controller objects (they may be of the same class, though). If you don't need a whole new view controller to display a certain view, you can use NSBundle's loadNibNamed:owner:options: to load a view and then add it as a subview to another view. More often than not, you set up a view in Interface Builder, set the File Owner's class to the class of your view controller and connect the necessary outlets of the view controller. Now, the important part. When the nib loads, the outlets are assigned actual objects unarchived from the nib. If your view controller has a "main" nib (where its view outlet is connected) and a "secondary" nib which you load by sending [[NSBundle mainBundle] loadNibNamed:@"MySubview" owner:self options:nil], you must not connect the same view outlet in the secondary nib. Make other outlets (relevant only for the secondary nib) and connect only them, otherwise really bad things will happen. I encourage you to thoughtfully read about the NSBundle method , NIBs in detail and modal view controllers . They may appear to be boring basics stuff, but they're very important to understand and use correctly.
