[site]: stackoverflow
[post_id]: 494502
[parent_id]: 
[tags]: 
Finding sets that have specific subsets

I am a graduate student of physics and I am working on writing some code to sort several hundred gigabytes of data and return slices of that data when I ask for it. Here is the trick, I know of no good method for sorting and searching data of this kind. My data essentially consists of a large number of sets of numbers. These sets can contain anywhere from 1 to n numbers within them (though in 99.9% of the sets, n is less than 15) and there are approximately 1.5 ~ 2 billion of these sets (unfortunately this size precludes a brute force search). I need to be able to specify a set with k elements and have every set with k+1 elements or more that contains the specified subset returned to me. Simple Example: Suppose I have the following sets for my data: (1,2,3) (1,2,3,4,5) (4,5,6,7) (1,3,8,9) (5,8,11) If I were to give the request (1,3) I would have the sets: (1,2,3), (1,2,3,4,5), and (1,3,8,9). The request (11) would return the set: (5,8,11). The request (1,2,3) would return the sets: (1,2,3) and (1,2,3,4,5) The request (50) would return no sets: By now the pattern should be clear. The major difference between this example and my data is that the sets withn my data are larger, the numbers used for each element of the sets run from 0 to 16383 (14 bits), and there are many many many more sets. If it matters I am writing this program in C++ though I also know java, c, some assembly, some fortran, and some perl. Does anyone have any clues as to how to pull this off? edit: To answer a couple questions and add a few points: 1.) The data does not change. It was all taken in one long set of runs (each broken into 2 gig files). 2.) As for storage space. The raw data takes up approximately 250 gigabytes. I estimate that after processing and stripping off a lot of extraneous metadata that I am not interested in I could knock that down to anywhere from 36 to 48 gigabytes depending on how much metadata I decide to keep (without indices). Additionally if in my initial processing of the data I encounter enough sets that are the same I might be able to comress the data yet further by adding counters for repeat events rather than simply repeating the events over and over again. 3.) Each number within a processed set actually contains at LEAST two numbers 14 bits for the data itself (detected energy) and 7 bits for metadata (detector number). So I will need at LEAST three bytes per number. 4.) My "though in 99.9% of the sets, n is less than 15" comment was misleading. In a preliminary glance through some of the chunks of the data I find that I have sets that contain as many as 22 numbers but the median is 5 numbers per set and the average is 6 numbers per set. 5.) While I like the idea of building an index of pointers into files I am a bit leery because for requests involving more than one number I am left with the semi slow task (at least I think it is slow) of finding the set of all pointers common to the lists, ie finding the greatest common subset for a given number of sets. 6.) In terms of resources available to me, I can muster approximately 300 gigs of space after I have the raw data on the system (The remainder of my quota on that system). The system is a dual processor server with 2 quad core amd opterons and 16 gigabytes of ram. 7.) Yes 0 can occur, it is an artifact of the data acquisition system when it does but it can occur.
