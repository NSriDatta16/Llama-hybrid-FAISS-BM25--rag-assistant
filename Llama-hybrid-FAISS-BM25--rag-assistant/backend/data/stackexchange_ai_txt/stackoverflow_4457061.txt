[site]: stackoverflow
[post_id]: 4457061
[parent_id]: 4446341
[tags]: 
Found a "workable" solution myself. For the top-level EBase , I exposed the interface ( IEnumBase ) as a Friend , then created generic methods in EBase to handle the overload operators: Protected Shared Function _ op_BitwiseOr(Of T As {IEnumBase, Class})(ByVal lhOp As T, ByVal rhOp As T, ByVal RetEnum As T) As T RetEnum.Name = String.Concat(lhOp.Name, "|"c, rhOp.Name) RetEnum.Value = (lhOp.Value Or rhOp.Value) Return RetEnum End Function The trick here, is the generic method simply returns RetEnum back to the caller. In the derived Enums (i.e., EExample ), I have: Public Shared Shadows Operator Or(ByVal lhOp As Enums, ByVal rhOp As Enums) As Enums Return EBase.op_BitwiseOr(lhOp, rhOp, New Enums) End Operator This allows me to keep the bulkier code defined once in EBase , and not replicated each time in my many derived enum classes. Those enum classes simply call on the parent's implementation and use generics to pass-in their sub-defined Enums implementation! Yeah, not groundbreaking. I could do better, but this works well enough for my needs and doesn't over-inflate the codebase too much. It also reduces code duplication and technically makes maintenance easier, IMHO. Still leaving Gideon Engelberth's answer as the accepted answer, however. My question initially asked if overloaded operators could be genericized, and he found the snippet on MSDN that says they can't.
