[site]: stackoverflow
[post_id]: 3970754
[parent_id]: 3966294
[tags]: 
Your eventual goal is to separate the UI, data storage and business logic into distinct layers. Its very difficult to test a UI with automatic testing frameworks. You'll want to eventually separate as much of the business logic from the UI as possible. This can be accomplished using one of the various Model/View/* patterns. I prefer MVP passive view, which attempts to make the UI nothing more than an interface. If you're using a Dataset MVP Supervising Controller may be a better fit. Data storage needs to have its own suite of tests but these are different from unit tests (though you can use the same unit testing framework) and there are usually fewer of them. You can get away with this because most of the heavy lifting is being done by third party data components and a dbms (in your case T*Dataset). These are integration tests. Basically making sure your code plays nice with the vendor's code. Also needed if you have any stored procedures defined in the DB. They are much slower that unit tests and don't need to be run as often. The business logic is what you want to test the most. Every calculation, loop or branch should have at least one test(more is preferable). In legacy code this logic often touches the UI and db directly and does multiple things in a single function. Here Extract Method is your friend. Good places to extract methods are: for I:=0 to List.Count - 1 do begin //HERE end; if /*HERE if its a complex condition*/ then begin //HERE end else begin //HERE end Answer := Var1 / Var2 + Var1 * Var3; //HERE When you come across one of these extraction points Decide what you want the method signature to look like for your new method: Method name, parameters, return value. Write a test that calls it and checks the expected outcome. Extract the method. If all goes well you will have a newly extracted method with at least one passing unit test. Delphi's built in Extract Method doesn't give you any way to adjust the signature so if that's your own option you'll have to make do and fix it after extraction. You'll also want to make the new method public so your test can access it. Some people balk at making a private utility method public but at this early stage you have little choice. Once you've made sufficient progress you'll start to see that some utility methods you've extracted belong in their own class (in which case they'd have to be public anyway) while others can be made private/protected and tested indirectly by testing methods that depend on them. As your test suite grows you'll want to run them after each change to ensure your latest change hasn't broken something elsewhere. This topic is much too large to cover completely in an answer. You'll find the vast majority of your questions are covered when that book arrives.
