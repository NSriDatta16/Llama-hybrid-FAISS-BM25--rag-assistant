[site]: stackoverflow
[post_id]: 1835261
[parent_id]: 1835230
[tags]: 
You'll likely want to create a composite index for this type of query - when the query runs slowly it is most likely choosing to scan down an index on the CreatedAt column and perform a residual filter on the SourceUserId value, when in reality what you want to happen is to jump directly to all records for a given SourceUserId ordered properly - to achieve this, you'll want to create a composite index primarily on SourceUserId (performing an equality check) and secondarily on CreateAt (to preserve the order within a given SourceUserId value). You may want to try adding the TypeId in as well, depending on the selectivity of this column. So, the 2 that will most likely give the best repeatable performance (try them out and compare) would be: Index on (SourceUserId, CreatedAt) Index on (SourceUserId, TypeId, CreatedAt) As always, there are also many other considerations to take into account with determining how/what/where to index, as Remus discusses in a separate answer one big consideration is covering the query vs. keeping lookups. Additionally you'll need to consider write volumes, possible fragmentation impact (if any) , singleton lookups vs. large sequential scans, etc., etc.
