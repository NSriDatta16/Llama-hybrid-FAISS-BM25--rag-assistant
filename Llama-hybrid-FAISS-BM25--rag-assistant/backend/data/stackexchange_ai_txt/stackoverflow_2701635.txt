[site]: stackoverflow
[post_id]: 2701635
[parent_id]: 2653812
[tags]: 
Assume that neighboring countries share common vertices and edges (if not, the problem becomes much more difficult). For each region, go through the poylgons corresponding to countries in the region and create a list of vertices and edges. Each edge should have pointers to the two vertices that are its endpoints, and each vertex should have pointers to the edges of which it is an endpoint. As you add vertices to the list, make sure they are unique vertices. In other words, if you are adding a vertex with coordinates (x,y) , if there is already such a vertex in the list don't add a new one. This means you potentially have to check every new vertex against ones already in the list. You can speed this up by breaking up the bounding box of the region into, say, n x n bins in which you can store vertices. When a new vertex comes in, look up its bin and check it against the other vertices in that bin. As you add edges to the edge list, do the same thing - if an edge (v0,v1) is being added, check to see whether there is an existing edge (v0,v1) or (v1,v0). Except in this case, eliminate the existing edge from the list, and don't add the new edge. That's because these two edges 'cancel' each other - they come from neighboring countries. And don't forget to eliminate the edge pointers in the vertex list that correspond to the deleted edge. When you're do, you should have a list of edges not shared by two countries. These are the edges that form the border of the region. You should also have a list of vertices, some pointing to two edge, and others pointing to no edges. The former vertices are on the region border. Now pick an edge from the edge list, and delete it (and delete the corresponding edge pointers from the vertices that are its endpoints) from the edgelist. Go to one of the vertex endpoints, and it will point to another edge. In this way, you'll walk from edge to edge along the region boundary. Add these edges to your regionShape as you delete them from your edgelist. Eventually you'll get back to the endpoint of your first edge and you'll have a closed loop. If there are any edges remaining in the edgelist, start the process again to extract another border loop, and keep going until all the border loops have been extracted and the edgelist is empty. I've mentioned one optimization, which is to organize the vertices spatially into bins so that you can more quickly test them equality. Another optimization is to avoid physically deleting edges from lists, but just to mark them as 'deleted'.
