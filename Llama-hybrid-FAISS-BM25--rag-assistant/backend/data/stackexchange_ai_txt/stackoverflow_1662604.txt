[site]: stackoverflow
[post_id]: 1662604
[parent_id]: 743164
[tags]: 
Here is a crazier solution of a different pattern -- using coroutines. The code is still very similar, but with one important difference; there are no exit conditions at all! The coroutine (chain of coroutines really) just stops when you stop feeding it with data. def coroutine(func): """Coroutine decorator Coroutines must be started, advanced to their first "yield" point, and this decorator does this automatically. """ def startcr(*ar, **kw): cr = func(*ar, **kw) cr.next() return cr return startcr @coroutine def collector(storage): """Act as "sink" and collect all sent in @storage""" while True: storage.append((yield)) @coroutine def state_machine(sink): """ .send() new parts to be tokenized by the state machine, tokens are passed on to @sink """ s = "" state = STATE_CODE while True: if state is STATE_CODE : if "//" in s : sink.send((TOKEN_COMMENT, s.split( "//" )[1] )) state = STATE_COMMENT else : sink.send(( TOKEN_CODE, s )) if state is STATE_COMMENT : if "//" in s : sink.send(( TOKEN_COMMENT, s.split( "//" )[1] )) else state = STATE_CODE # re-evaluate same line continue s = (yield) tokens = [] sm = state_machine(collector(tokens)) for piece in i: sm.send(piece) The code above collects all tokens as tuples in tokens and I assume there is no difference between .append() and .add() in the original code.
