[site]: stackoverflow
[post_id]: 1185420
[parent_id]: 918614
[tags]: 
I completely agree that IDisposable needs better language suppprt. Here's my variant of it from a while ago . The details are probably wrong, but C++/CLI serves as a pretty good model for this. Unfortunately it confuses the hell out of C# programmers when I show them examples in C++/CLI. But it already does "the right thing" in terms of implementation; we would just need a new syntax in C#. Even the simplest Windows Forms application has a Dispose method in it, which is generated by a wizard and is fragile in the face of inexpert changes. The idea of composing components together such that one component can "own" several others is so fundamental that IDisposable is practically unavoidable, and unfortunately it seems to take several pages of most books to explain how to implement it correctly. The existing using statement takes care of the client side. Where we need more language support is on the implementation side. Some of the fields of a class are references to things that the class "owns", and some not owned. So we have to be able to mark a field as owned. Also, it would be a very bad idea to automatically generate a finalizer. Most often, a class will own other objects that implement IDisposable . Not all classes are thread safe, nor should they need to be. If they are called from a finalizer, that happens on another thread, forcing them to be thread safe. This is probably the one area around IDisposable that causes the most confusion - a lot of people read the books and come away with the mistaken impression that you have to write a finalizer on an object that supports IDisposable .
