[site]: stackoverflow
[post_id]: 3846462
[parent_id]: 3846317
[tags]: 
You actually violate the strict aliasing rules (section 3.10 of the C++ standard) with these reinterpret casts. This will probably blow up in your face when you turn on the compiler optimizations. C++ standard, section 3.10 paragraph 15 says: If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined the dynamic type of the object, a cv-qualified version of the dynamic type of the object, a type similar to the dynamic type of the object, a type that is the signed or unsigned type corresponding to the dynamic type of the object, a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object, an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), a type that is a (possibly cv-qualified) base class type of the dynamic type of the object, a char or unsigned char type. Specifically, 3.10/15 doesn't allow us to access a float object via an lvalue of type unsigned int. I actually got bitten myself by this. The program I wrote stopped working after turning on optimizations. Apparently, GCC didn't expect an lvalue of type float to alias an lvalue of type int which is a fair assumption by 3.10/15. The instructions got shuffled around by the optimizer under the as-if rule exploiting 3.10/15 and it stopped working. Under the following assumptions float really corresponds to a 32bit IEEE-float, sizeof(float)==sizeof(int) unsigned int has no padding bits or trap representations you should be able to do it like this: /// returns a 30 bit number unsigned int pack_float(float x) { unsigned r; std::memcpy(&r,&x,sizeof r); return r >> 2; } float unpack_float(unsigned int x) { x This doesn't suffer from the "3.10-violation" and is typically very fast. At least GCC treats memcpy as an intrinsic function. In case you don't need the functions to work with NaNs, infinities or numbers with extremely high magnitude you can even improve accuracy by replacing "r >> 2" with "(r+1) >> 2": unsigned int pack_float(float x) { unsigned r; std::memcpy(&r,&x,sizeof r); return (r+1) >> 2; } This works even if it changes the exponent due to a mantissa overflow because the IEEE-754 coding maps consecutive floating point values to consecutive integers (ignoring +/- zero). This mapping actually approximates a logarithm quite well.
