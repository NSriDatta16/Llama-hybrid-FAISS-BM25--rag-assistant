[site]: stackoverflow
[post_id]: 1734647
[parent_id]: 1733656
[tags]: 
I suppose you know how to model a 2-Sat problem to solve it with SCC. The way I handle vars and its negation isn't very elegant, but allows a short implementation: Given n variables numbered from 0 to n-1, in the clauses -i means the negation of variable i, and in the graph i+n means the same (am I clear ?) #include #include #include #include #include #include typedef std::pair clause; //Properties of our graph. By default oriented graph typedef boost::adjacency_list<> Graph; const int nb_vars = 5; int var_to_node(int var) { if(var clauses; clauses.push_back(clause(1,2)); clauses.push_back(clause(2,-4)); clauses.push_back(clause(1,4)); clauses.push_back(clause(1,3)); clauses.push_back(clause(-2,4)); //Creates a graph with twice as many nodes as variables Graph g(nb_vars * 2); //Let's add all the edges BOOST_FOREACH(clause c, clauses) { int v1 = c.first; int v2 = c.second; boost::add_edge( var_to_node(-v1), var_to_node(v2), g); boost::add_edge( var_to_node(-v2), var_to_node(v1), g); } // Every node will belong to a strongly connected component std::vector component(num_vertices(g)); std::cout
