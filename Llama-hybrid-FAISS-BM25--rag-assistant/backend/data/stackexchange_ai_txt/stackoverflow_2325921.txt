[site]: stackoverflow
[post_id]: 2325921
[parent_id]: 2323082
[tags]: 
It may be helpful to understand what problem the dependency property is trying to solve. If we put the Binding, Animation and the Change Event model to one side as they've been discussed in other answers, the benefit is memory usage and thus scalability to host many thousand WPF objects in a window. If a window contains 1000 Label objects with each Label object having the usual Foreground , Background , FontFamily , FontSize , FontWeight , etc., then traditionally this would consume memory because each property would have a private backing field to store the value. Most applications will change only a few properties, the majority of which will be left at their default values. Basically very wasteful and redundant information (each object just holding the same default values in memory) This is where dependency properties are different. // Lets register the Dependency Property with a default value of 20.5 public static readonly DependencyProperty ColumnWidthProperty = DependencyProperty.Register("ColumnWidth", typeof(double), typeof(MyWPFControl), new UIPropertyMetadata(20.5, ColWitdhPropChanged)); public double ColumnWidth { get { return (double)GetValue(ColumnWidthProperty); } set { SetValue(ColumnWidthProperty, value); } } There is no private backing field. When the dependency property is registered a default value can be specified. So in most cases the returned value from GetValue is the default value that has only been stored the once to cover all instances of the Label object across all windows of your application. When a dependency property is set using the SetValue it stores the non-default value in a collection identified by the object instance, to be returned in all subsequent GetValue calls. This storage method will therefore only consume memory for the properties of the WPF objects that have changed from the default value. i.e. only the differences from the default value.
