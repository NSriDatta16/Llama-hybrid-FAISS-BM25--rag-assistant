[site]: crossvalidated
[post_id]: 596907
[parent_id]: 325217
[tags]: 
What you have is not a regular fractional factorial design, for the future you would be better off planning for a regular design. For four factors that would require at least 8 runs. I would start by looking at the correlation matrix: cor(mydata) A B C D A 1.0000000 0.0000000 0.0000000 -0.6324555 B 0.0000000 1.0000000 0.3333333 0.4472136 C 0.0000000 0.3333333 1.0000000 0.4472136 D -0.6324555 0.4472136 0.4472136 1.0000000 which doesn't look that bad, but checking its rank by svd(mydata) $d [1] 26.82130799 2.74710427 2.02563450 1.41832132 0.06786225 the smallest singular value is quite small ... I guess you could make a better 6-run fractional factorial by using algorithmic design, see for example How to select runs from a full factorial experiment design matrix to build a fractional factorial design . So again, if you are forced to use only 6 runs, for the future, that would be better. Otherwise, to investigate the design you can simulate some data and fit a linear model (6 runs only admits for main effects). If you have some idea of the noise level to expect, that can be quite useful. set.seed(7 * 11 * 13) mydata$Y |t|) (Intercept) -0.9891 1.8388 -0.538 0.686 A 0.7027 1.8388 0.382 0.768 B -1.3560 1.3900 -0.976 0.508 C 1.4762 1.3900 1.062 0.481 D 7.5585 2.7799 2.719 0.224 Residual standard error: 2.78 on 1 degrees of freedom Multiple R-squared: 0.9598, Adjusted R-squared: 0.799 F-statistic: 5.968 on 4 and 1 DF, p-value: 0.2967 This is of course only one simulation run ... but if the coefficient values and variance I used in the simulation are about real, it is not encouraging! This design will only be useful for large effects or very low noise. For comparison, here is how you can make a better 6-run fraction of a $2^4$ -factorial by algorithmic design: library(AlgDesign) cand $design) A B C D A 1.0000000 -0.3333333 0 0.3333333 B -0.3333333 1.0000000 0 -0.3333333 C 0.0000000 0.0000000 1 0.0000000 D 0.3333333 -0.3333333 0 1.0000000 > svd(des$ design) $d [1] 3.162278 2.449490 2.000000 2.000000 This is obviously a much better design. For completeness, the code used to read your data: text
