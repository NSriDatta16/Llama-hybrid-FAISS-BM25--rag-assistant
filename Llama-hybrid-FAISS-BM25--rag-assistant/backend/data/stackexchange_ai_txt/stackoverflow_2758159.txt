[site]: stackoverflow
[post_id]: 2758159
[parent_id]: 
[tags]: 
How to embed a Python interpreter in a PyQT widget

I want to be able to bring up an interactive python terminal from my python application. Some, but not all, variables in my program needs to be exposed to the interpreter. Currently I use a sub-classed and modified QPlainTextEdit and route all "commands" there to eval or exec , and keep track of a separate namespace in a dict. However there got to be a more elegant and robust way! How? Here is an example doing just what I want, but it is with IPython and pyGTK... http://ipython.scipy.org/moin/Cookbook/EmbeddingInGTK Below is what I currently have. But there are so many corner cases that I probably missed some. It is very slow, try a large print loop... It got to be a simpler and less bug prone way, ...I hope!! It is the def runCommand(self) function that is the key to understanding my problem. I ideally don't want to improve it, I rather want to replace its content with something simpler and smarter. The functionality of the console.updateNamespace({'myVar1' : app, 'myVar2' : 1234}) statement in "main" is also important. import sys, os import traceback from PyQt4 import QtCore from PyQt4 import QtGui class Console(QtGui.QPlainTextEdit): def __init__(self, prompt='$> ', startup_message='', parent=None): QtGui.QPlainTextEdit.__init__(self, parent) self.prompt = prompt self.history = [] self.namespace = {} self.construct = [] self.setGeometry(50, 75, 600, 400) self.setWordWrapMode(QtGui.QTextOption.WrapAnywhere) self.setUndoRedoEnabled(False) self.document().setDefaultFont(QtGui.QFont("monospace", 10, QtGui.QFont.Normal)) self.showMessage(startup_message) def updateNamespace(self, namespace): self.namespace.update(namespace) def showMessage(self, message): self.appendPlainText(message) self.newPrompt() def newPrompt(self): if self.construct: prompt = '.' * len(self.prompt) else: prompt = self.prompt self.appendPlainText(prompt) self.moveCursor(QtGui.QTextCursor.End) def getCommand(self): doc = self.document() curr_line = unicode(doc.findBlockByLineNumber(doc.lineCount() - 1).text()) curr_line = curr_line.rstrip() curr_line = curr_line[len(self.prompt):] return curr_line def setCommand(self, command): if self.getCommand() == command: return self.moveCursor(QtGui.QTextCursor.End) self.moveCursor(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor) for i in range(len(self.prompt)): self.moveCursor(QtGui.QTextCursor.Right, QtGui.QTextCursor.KeepAnchor) self.textCursor().removeSelectedText() self.textCursor().insertText(command) self.moveCursor(QtGui.QTextCursor.End) def getConstruct(self, command): if self.construct: prev_command = self.construct[-1] self.construct.append(command) if not prev_command and not command: ret_val = '\n'.join(self.construct) self.construct = [] return ret_val else: return '' else: if command and command[-1] == (':'): self.construct.append(command) return '' else: return command def getHistory(self): return self.history def setHisory(self, history): self.history = history def addToHistory(self, command): if command and (not self.history or self.history[-1] != command): self.history.append(command) self.history_index = len(self.history) def getPrevHistoryEntry(self): if self.history: self.history_index = max(0, self.history_index - 1) return self.history[self.history_index] return '' def getNextHistoryEntry(self): if self.history: hist_len = len(self.history) self.history_index = min(hist_len, self.history_index + 1) if self.history_index
