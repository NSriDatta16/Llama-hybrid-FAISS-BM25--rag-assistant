[site]: stackoverflow
[post_id]: 4397939
[parent_id]: 4397019
[tags]: 
I think you're right, unions in C++ are under-featured. They're pretty much a straight copy of unions from C, which means that they don't serve as variant types for C++ . There's no simple way for union in C++ to represent a proper variant type. Consider the following code, if it were legal: union X { int i; std::string s; }; X x; x.s = "Hello"; x.i = 23; No amount of constructors or destructors for X is going to ensure that the assignment in the final line calls ~string before storing 23 . For the compiler to do it, the union would have to contain some kind of indicator what type is stored. That's why everything must be POD. I don't know the reasons for the differences between named and unnamed unions, though, this applies to both. Perhaps C++ unions could have been defined to be like C unions if all their members are POD, but to contain this extra information, and call the correct destructors at the correct times, if any member is non-POD. But this isn't the simple change you proposed. You can somewhat laboriously write a variant type by writing a class which has a value to indicate the type currently stored, and then the constructors, copy assignment operator, and destructor that you would have put in your union, had you been allowed. Use a char array for storage, placement new for construction/assignment, and a direct call to the correct destructor in your destructor. Beware of the alignment issue - you need to ensure that your raw storage is adequately aligned for any of the types you place in it. One way to do this is to dynamically allocate it. Another is to put your char array into a union with whatever built-in type has the greatest alignment requirement (if you don't know: all of them). The only thing that's different in usage, from the union you want, is that instead of public data members int a , float b , string c , you'll have to provide accessors that return a proxy object (possibly a reference to the object itself), that is capable of assigning correctly, which means calling the destructor for the old type first. Then you can write x.i() = 23 instead of x.i = 23 . Or, you can use Boost.Variant .
