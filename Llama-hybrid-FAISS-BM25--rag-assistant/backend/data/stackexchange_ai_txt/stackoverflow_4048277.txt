[site]: stackoverflow
[post_id]: 4048277
[parent_id]: 4048248
[tags]: 
As per perldoc's perldiag for that error, your problem is that the inner sub is referencing a lexical variable (%marked) defined in the outer sub. The fix is in the third paragraph (use anonymous sub): (Warning; closure) An inner (nested) named subroutine is referencing a lexical variable defined in an outer named subroutine. When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the first call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared. This problem can usually be solved by making the inner subroutine anonymous, using the sub {} syntax. When inner anonymous subs that reference variables in outer subroutines are created, they are automatically rebound to the current values of such variables. Fixed code using anonymous sub: # .... my $connected_sub; $connected_sub = sub { no warnings 'recursion'; my $node = shift; return if exists $marked{$node}; # Line 280 $marked{$node} = 1; push @stack, $node; # Line 282 my $children = $links{$node}; # Line 283 &$connected_sub($_) for keys %$children; }; for my $node (sort keys %links) { next if exists $marked{$node}; @stack = (); &$connected_sub($node); #print "@stack\n"; push @all_ccomp, [@stack]; } # ....
