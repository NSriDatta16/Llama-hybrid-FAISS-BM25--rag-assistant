[site]: stackoverflow
[post_id]: 3452636
[parent_id]: 3452566
[tags]: 
Several observations about your program: In function turtle : You do not initialize the variable msg . You set the gtot file descriptor for O_NONBLOCK . BUT you do not check the return value of read . This is a significant problem. read is returning immediately and you are printing the uninitialized value of msg . The way you fork and close is also contributing. You have closed gtot[1] prior to fork -ing the "god" process. If you choose to use this one-parent of two-child-processes approach, don't close the file handles until you are done fork -ing. Also, it appears that you intended for at least the turtle function, and probably the god function, to loop. As written, your turtle function will immediately exit: it has no loop and it performs read with the O_NONBLOCK flag set. But wait, there is more. When you do call fcntl to set O_NONBLOCK , what you are doing is also resetting every flag other than O_NONBLOCK . Here is a function taken from the libc documentation which handles the other flags while setting or resetting the non-blocking flag: /* Set the O_NONBLOCK flag of desc if value is nonzero, or clear the flag if value is 0. Return 0 on success, or -1 on error with errno set. */ int set_nonblock_flag (int desc, int value) { int oldflags = fcntl (desc, F_GETFL, 0); /* If reading the flags failed, return error indication now. */ if (oldflags == -1) return -1; /* Set just the flag we want to set. */ if (value != 0) oldflags |= O_NONBLOCK; else oldflags &= ~O_NONBLOCK; /* Store modified flag word in the descriptor. */ return fcntl (desc, F_SETFL, oldflags); } There are some other things which could also be contributing to your problem: It would be best to replace every occurence of " 4 " with sizeof(int) wherever you are calling read and write . It is possible that integers are 8 bytes on your machine (64 bit integer?), although pretty unlikely. In the future, it is more likely that int would be 8 bytes, and your code is very fragile in this regard. There is also something "Strange" about your program that I am observing: Why is the decimal output from printf being prefixed with a leading 0 (zero)? That would be an octal representation, but the printf specifier is not "%o" . "%d" should not show leading zeros unless you use a width-specifier with a leading zero, a la "%08d" . So I don't know what to make about that.
