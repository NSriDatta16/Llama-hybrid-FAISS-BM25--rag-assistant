[site]: stackoverflow
[post_id]: 5678410
[parent_id]: 5677709
[tags]: 
In complement to Simon Sarris response. I've used a 'double canvas' technique to avoid screen fickering with heavy canvas. The way it works is always have 2 version of the canvas, one in DOM, one outside, and always draw on the one which is not in DOM . I use it with a redraw queue. here's a part of a working code (...) clear: function() { //rotating on 2 canvas, one for draw (outside DOM) one for show var self = this; if (null == self.canvasbackup) { var tmpcanvas = self.canvas.clone(true); self.canvasbackup = self.canvas; self.canvas=tmpcanvas; } else { var tmpcanvas = self.canvasbackup; self.canvasbackup = self.canvas; self.canvas=tmpcanvas; } self.ctx = self.canvas[0].getContext('2d'); self.ctx.clearRect( 0, 0, self.options.width, self.options.height ); jQuery.each(self.elements,function(idx,elt){ // custom function: my elements need to know which canvas they depends on elt.reconnectCanvas(self.canvas,self.ctx); }); }, inDOM: function() { var self = this; if(null==self.canvasbackup) { //1st time need to get all things in DOM self.canvas.appendTo(self.div); self.div.appendTo(self.container); } else { // remove current shown canvas self.connectHuman(); self.canvasbackup.remove(); // loosing some events here... self.canvas.appendTo(self.div); // div is already in DOM, we are in redraw } }, redraw: function() { var self = this; self.clear(); jQuery.each(self.elements,function(idx,elt){ elt.draw(); elt.enddraw(); }); self.inDOM(); } (...)
