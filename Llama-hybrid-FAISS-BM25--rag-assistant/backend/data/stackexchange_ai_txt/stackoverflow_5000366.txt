[site]: stackoverflow
[post_id]: 5000366
[parent_id]: 4991264
[tags]: 
From a Moq perspective, everything you are doing is technically correct. You are using Moq's Callback mechanism, which is typically used for inspecting inbound parameters but in this case you're invoking custom logic to simulate what the service does. If you configure the Mocks to return the correct values, you should be able to exercise the logic in your presentation model. You'll need several tests with different return values to properly exercise all paths of execution. To your point, it's going to get confusing. You can probably clean things up a bit by creating a utility class that will help define the mocks. Here's a crude example that takes some of the crazy plumbing in your test and encapsulates it a bit: public class BookClubContextFixtureHelper { Mock _mockService; ObservableCollection _categories; public BookClubContextFixtureHelper() { // initialize your context } public BookDataService Service { get { return _mockService.Object; } } public void SetupCategories(param Category[] categories) { _categories = new ObservableCollection (categories); _mockService .Setup( s => s.GetCategories( DefaultInput() ) .Callback( OnGetCategories ) .Verifiable(); } public void VerifyAll() { _mockService.VerifyAll(); } Action > DefaultInput() { return It.IsAny >>(); } void OnGetCategories(Action > action) { action( _categories ); } } However, whenever a test becomes too complicated or needs "advanced" logic, it's often an alarm that something might be wrong. If a ViewModel can't be instantiated because of dependencies that's a deal breaker for me. In your example, you are creating two dependencies (TestDomain and Context) in order to create your Mock BookDataService. This suggests that although you can create dummy stand-ins for your service you aren't fully decoupled from its implementation. Few options to consider: You may want to introduce an interface to wrap your existing service. This will definitely solve the viewmodel instantiation problem and may give you an easier to work with API. This however won't solve the back-n-forth logic in your view model. Externalize the loading logic into another testable component. For example, associate your viewmodel with an observer/controller that can listen to the property change event or be notified when new data is needed. You might be able to remove your dataservice as a dependency from the view model altogether.
