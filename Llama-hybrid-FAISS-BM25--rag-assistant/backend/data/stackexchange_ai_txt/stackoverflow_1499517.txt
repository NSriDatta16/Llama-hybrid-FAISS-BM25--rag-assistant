[site]: stackoverflow
[post_id]: 1499517
[parent_id]: 1495173
[tags]: 
Others have already responded with respect to linking CRT statically. If you also want a small binary at the same time, then your best bet is forego CRT entirely, and use only Win32 API functions as much as possible. You'll still get some CRT code, most notably related to startup (i.e. that which calls main ) and shutdown ( atexit handling etc), but otherwise the linker won't link CRT functions that you do not use. You can avoid linking CRT altogether by using /Zl compiler switch. This means that main will no longer work, however - you'll need to define WinMain (name doesn't matter, but signature must match, and it must be __stdcall ), and you will have to specify the name of your WinMain -like function as an entry point via linker /entry: switch. This will save you ~30Kb of CRT code (tested on a .cpp with an empty main ). If you go the latter route, you might also have to deal with issue of compiler intrinsics. There are some functions that are nominally defined by the CRT (and declared in its headers), but which are treated specially by the compiler, so that it inserts optimized assembly instructions at the point of the call where possible - examples are memset , strlen , and a good chunk of functions in ; a complete list can be found here . Since you don't have CRT, if you need these functions, or could avoid it but prefer the intrinsic because of improved performance (hard to do better than memset , for example), then you have to declare them yourself, and use #pragma intrinsic . E.g.: // Contains macros and typedef only, so safe to include without CRT. // We need it here for size_t. #include extern "C" { int abs(int); void* memset(void*, int, size_t); } #pragma intrinsic(abs, memset) int __stdcall main(void*, void*, char*, int) { char tmp[10]; memset(tmp, abs(-123), 10); return 0; } The above can be compiled with: cl /c /Zl foo.cpp link /entry:main foo.obj
