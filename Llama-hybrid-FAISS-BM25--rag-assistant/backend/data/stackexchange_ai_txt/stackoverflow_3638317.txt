[site]: stackoverflow
[post_id]: 3638317
[parent_id]: 
[tags]: 
Why does a struct consisting of a char, short, and char (in that order), when compiled in C++ with 4-byte packing enabled, come to a 6-byte struct?

I thought I understood how C/C++ handled struct member alignment. But I'm getting strange results for a particular arrangement in Visual Studio 2008 and 2010. Specifically, I'm finding that a struct consisting of a char, short, and char is compiled into a 6-byte struct, even with 4- or 8-byte packing enabled. I am at a loss as to why this would be. I can understand a 4-byte struct. I could perhaps understand an 8-byte struct. But I would think that a 6-byte struct would be impossible when 4-byte packing is enabled. A program that demonstrates the problem is: #include using namespace std; #pragma pack (4) struct Alignment { char c1; short s; char c2; }; #define REPORT_VAR_POSITION( structName, varName ) cout The output is: Sizeof struct Alignment is 6 bytes. Member 'c1' sits at byte # 0. Member 's' sits at byte # 2. Member 'c2' sits at byte # 4. Press any key to continue . . . Can anyone explain why VC is padding each of those chars with an additional byte?
