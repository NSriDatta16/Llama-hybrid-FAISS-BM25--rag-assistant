[site]: stackoverflow
[post_id]: 5292730
[parent_id]: 5281617
[tags]: 
Another simple (although not free, but still rather cheap) solution is to use the SQL# library which would allow you to do this in just a few lines of T-SQL. This would make it really easy to automate via a SQL Agent Job. You could emulate the Powershell method (suggested by Mitch) with a single command to grab the CSV file and then read it into the table with another command: DECLARE @Dummy VARBINARY(1) SELECT @Dummy = SQL#.INET_DownloadFile('http://www.location.tld/file.csv', 'C:\file.csv') INSERT INTO dbo.RealTable (Column1, Column2, ...) EXEC SQL#.File_SplitIntoFields 'C:\file.csv', ',', 0, NULL, NULL OR, you could bypass going to the file system by reading the CSV file straight into a local variable, splitting that on the carriage-returns into a Temp Table, and then split that into your table: CREATE TABLE #CSVRows (CSV VARCHAR(MAX)) DECLARE @Contents VARBINARY(MAX) SELECT @Contents = SQL#.INET_DownloadFile('http://www.location.tld/file.csv', NULL) INSERT INTO #CSVRows (CSV) SELECT SplitVal FROM SQL#.String_Split(CONVERT(VARCHAR(MAX), @Contents), CHAR(13) + CHAR(10), 1) INSERT INTO dbo.RealTable (Column1, Column2, ...) EXEC SQL#.String_SplitIntoFields 'SELECT CSV FROM #CSVRows', ',', NULL You can find SQL# at: http://www.SQLsharp.com/ I am the author of the SQL# library, but this seems like a valid solution to the question.
