[site]: stackoverflow
[post_id]: 4764273
[parent_id]: 4764150
[tags]: 
I would do it using XDocument but without LINQ, if you don't expect the general structure of the document to change. var publicKey = (string)xDoc.Root.Element("PublicKey"); var agentGuid = (Guid)xDoc.Root.Element("AgentGUID"); If you know there's only one instance of a given tag, it's less trouble to just go get that instance than to call a method that selects all tags with a given name, and then extract a single value from the resulting IEnumerable<> . However, your original code was almost right. IEnumerable publicKeys = from item in xDoc.Descendants("PublicKey") select (string)item; But then you'd have to follow that up with: string publicKey = publicKeys.First(); The XElement type defines custom conversion operators for many different primitive types. It has a Value property that returns a string, so you could use that and not have any cast at all if a string is what you want - but often it's more convenient to just cast an XElement containing a value directly to the data type you want. Update If you need an XmlDocument you can convert an XDocument like this... var doc = new XmlDocument(); doc.Load(xDoc.CreateReader()); However, it's probably more efficient to just use an XmlDocument to begin with, even if it's less convenient. One way to get the same values from an XmlDocument is like this: var publicKey = doc.GetElementsByTagName("PublicKey")[0].InnerText; var agentGuid = new Guid(doc.GetElementsByTagName("AgentGUID")[0].InnerText);
