[site]: stackoverflow
[post_id]: 2684447
[parent_id]: 2681415
[tags]: 
David, thanks for taking the time to write this up. I'm a C# programmer, so my Java skills are a bit vague these days. Because of this, I decided to port your code over and test it myself. I found some interesting differences and similarities, which are pretty much worth the price of admission as far as I'm concerned. Among the major differences are: I didn't have to implement TryGet because it's built into Dictionary. In order to use the native TryGet, instead of inserting nulls to simulate misses, I simply omitted those values. This still means that v = map[k] would have set v to null , so I think it's a proper porting. In hindsight, I could have inserted the nulls and changed (_map.TryGetValue(key, out value)) to (_map.TryGetValue(key, out value) && value != null)) , but I'm glad I didn't. I want to be exceedingly fair. So, to keep the code as compact and maintainable as possible, I used lambda calculus notation, which let me define the callbacks painlessly. This hides much of the complexity of setting up anonymous delegates, and allows me to use closures seamlessly. Ironically, the implementation of Lookup uses TryGet internally. Instead of declaring a new type of Dictionary, I used an extension method to graft Lookup onto the standard dictionary, much simplifying the code. With apologies for the less-than-professional quality of the code, here it is: using System; using System.Collections.Generic; using System.Linq; namespace ConsoleApplication1 { static class CallbackDictionary { public static void Lookup (this Dictionary map, K key, Action found, Action missed) { V v; if (map.TryGetValue(key, out v)) found(key, v); else missed(key); } } class TryGetExample { private Dictionary _map; private List _found; private List _missing; public TryGetExample(Dictionary map) { _map = map; _found = new List (_map.Count); _missing = new List (_map.Count); } public void TestTryGet() { for (int i = 0; i _found.Add(k + ": " + v), k => _missing.Add(k)); Console.WriteLine(_found.Count() + " found"); Console.WriteLine(_missing.Count() + " missing"); } } class Program { static void Main(string[] args) { int size = 2000000; var map = new Dictionary (size); for (int i = 0; i My performance expectations, as I said in the article that inspired this one, would be that neither one is much faster or slower than the other. After all, most of the work is in the searching and adding, not in the simple logic that structures it. In fact, it varied a bit among runs, but I was unable to detect any consistent advantage. Part of the problem is that I used a low-precision timer and the test was short, so I increased the count by 10x to 2000000 and that helped. Now callbacks are about 3% slower, which I do not consider significant. On my fairly slow machine, callbacks took 17773437 while tryget took 17234375. Now, as for code complexity, it's a bit unfair because TryGet is native, so let's just ignore the fact that I had to add a callback interface. At the calling spot, lambda notation did a great job of hiding the complexity. If anything, it's actually shorter than the if/then/else used in the TryGet version, although I suppose I could have used a ternary operator to make it equally compact. On the whole, I found the C# to be more elegant, and only some of that is due to my bias as a C# programmer. Mainly, I didn't have to define and implement interfaces, which cut down on the plumbing overhead. I also used pretty standard .NET conventions, which seem to be a bit more streamlined than the sort of style favored in Java.
