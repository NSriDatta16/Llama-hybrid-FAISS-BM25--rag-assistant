[site]: stackoverflow
[post_id]: 4130180
[parent_id]: 
[tags]: 
How to use VS C++ GetEnvironmentVariable as cleanly as possible?

(This is not so much a problem as an exercise in pedantry, so here goes.) I've made a nice little program that is native to my linux OS, but I'm thinking it's useful enough to exist on my Windows machine too. Thus, I'd like to access Windows' environment variables, and MSDN cites an example like this: const DWORD buff_size = 50; LPTSTR buff = new TCHAR[buff_size]; const DWORD var_size = GetEnvironmentVariable("HOME",buff,buff_size); if (var_size==0) { /* fine, some failure or no HOME */ } else if (var_size>buff_size) { // OK, so 50 isn't big enough. if (buff) delete [] buff; buff = new TCHAR[var_size]; const DWORD new_size = GetEnvironmentVariable("HOME",buff,var_size); if (new_size==0 || new_size>var_size) { /* *Sigh* */ } else { /* great, we're done */ } } else { /* in one go! */ } This is not nearly as nice (to me) as using getenv and just checking for a null pointer. I'd also prefer not to dynamically allocate memory since I'm just trying to make the program run on Windows as well as on my linux OS, which means that this MS code has to play nicely with nix code. More specifically: template // let the compiler sort out between char* and TCHAR* inline bool get_home(T& val) { // return true if OK, false otherwise #if defined (__linux) || (__unix) val = getenv("HOME"); if (val) return true; else return false; #elif defined (WINDOWS) || defined (_WIN32) || defined (WIN32) // something like the MS Code above #else // probably I'll just return false here. #endif } So, I'd have to allocate on the heap universally or do a #ifdef in the calling functions to free the memory. Not very pretty. Of course, I could have just allocated 'buff' on the stack in the first place, but then I'd have to create a new TCHAR[] if 'buff_size' was not large enough on my first call to GetEnvironmentVariable. Better, but what if I was a pedant and didn't want to go around creating superfluous arrays? Any ideas on something more aesthetically pleasing? I'm not that knowledgeable, so would anyone begrudge me deliberately forcing GetEnvironmentVariable to fail in order to get a string size? Does anyone see a problem with: const DWORD buff_size = GetEnvironmentVariable("HOME",0,0); TCHAR buff[buff_size]; const DWORD ret = GetEnvironmentVariable("HOME",buff,buff_size); // ... Any other ideas or any suggestions? (Or corrections to glaring mistakes?) UPDATE: Lots of useful information below. I think the best bet for what I'm trying to do is to use a static char[] like: inline const char* get_home(void) { // inline not required, but what the hell. #if defined (__linux) || (__unix) return getenv("HOME"); #elif defined (WINDOWS) || defined (WIN32) || defined (_WIN32) static char buff[MAX_PATH]; const DWORD ret = GetEnvironmentVariableA("USERPROFILE",buff,MAX_PATH); if (ret==0 || ret>MAX_PATH) return 0; else return buff; #else return 0; #endif } Perhaps it's not the most elegant way of doing it, but it's probably the easiest way to sync up what I want to do between *nix and Windows. (I'll also worry about Unicode support later.) Thank you to everybody who has helped.
