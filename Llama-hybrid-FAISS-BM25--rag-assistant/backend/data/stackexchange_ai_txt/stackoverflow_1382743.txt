[site]: stackoverflow
[post_id]: 1382743
[parent_id]: 1382586
[tags]: 
Coroutines are one approach to implementing this. Your pauseSimulation() can internally call coroutine.yield() , and be restarted later by a call to coroutine.resume() from the button's action. The problem is that your UI is at the mercy of your script fragments, since the only way to halt a running coroutine is for it to eventally call yield() . Alternatively, you can use the Lanes module to put part of your Lua application into a separate thread. You would use a Linda to pass messages from the main Qt widget thread to your simulator's worker thread. This would have the advantage that the UI thread is not blocked by the simulation which runs in its own thread.
