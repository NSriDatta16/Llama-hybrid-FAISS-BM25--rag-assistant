[site]: stackoverflow
[post_id]: 5323263
[parent_id]: 5322586
[tags]: 
They don't generate the same code but boil down to the same thing, you get an object implementing IEnumerable . The difference is that linq provides iterator from its library (in this case most likely by using WhereSelectArrayIterator or WhereSelectListIterator ) whereas in the second example you yourself generate an iterator block that dissects a collection. An iterator block method is always, by ways of compiler magic, compiled as a separate class implementing IEnumerable which you don't see but instantiate implicitly when you call iterator block method. Performance wise, #1 should be slightly (but just slightly) faster for indexable collections because when you loop through the resulting IEnumerable you go directly from your foreach into collection retrieval in an optimized linq iterator. In example #2 you go from foreach into your iterator block's foreach and from there into collection retrieval and your performance depends mostly on how smart the compiler is at optimizing yield logic. In any case I would imagine that for any complex collection mechanism the cost of retrieval marginalizes this difference. IMHO, I would always go with #1, if nothing else it saves me from having to write a separate method just for iterating.
