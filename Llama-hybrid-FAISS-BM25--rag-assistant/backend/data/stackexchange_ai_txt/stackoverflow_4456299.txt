[site]: stackoverflow
[post_id]: 4456299
[parent_id]: 4456271
[tags]: 
I'm guessing that this is a compiler error, because the compiler realizes it cannot assume that all objects are strings. Try casting your returned value like so: String sDividendDate1 = (String)data[0][0]; This tells the compiler that you recognize the array might not return a String, but that you're willing to risk it because you think you know what that value will actually be at runtime. If the code finds that there isn't really a string there when it goes to do the cast, you'll get a runtime exception. Edit Andy K has a good point about type safety. Based on the example you gave it seems like you're trying to represent data that is interrelated. If you can think of names to represent the way the data is related, you can model this more naturally using a class, like so: public class PlayerAverage { public PlayerAverage(String name, double average) { this.name = name; this.average = average } private String name; private double average; public String getName() {return name;} public double getAverage() {return average;} } Then you could create an array of these: PlayerAverage[] playerAverages = { new PlayerAverage("Tom Jones", 5), new PlayerAverage("Paul Smith", 5) }; Because it would be typed, you could easily iterate over this array without the need for any type casting: for(PlayerAverage playerAverage : playerAverages) { String name = playerAverage.getName(); double average = playerAverage.getDouble(); } Note that this approach uses a lot of best-practices like private fields with public getters, which might be overkill for what you're doing. But it's generally a good idea to create classes to indicate how your data is related and what it is supposed to represent.
