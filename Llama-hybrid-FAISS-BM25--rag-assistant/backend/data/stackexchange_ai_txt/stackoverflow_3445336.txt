[site]: stackoverflow
[post_id]: 3445336
[parent_id]: 3440449
[tags]: 
This transformation : when applied on this XML document (based on the provided XML fragment, but wrapped the XML fragmentwithin a top element and added one more child to criteria to make the problem less trivial): produces the wanted result (no other published answer at the time of writing this produces a correct result): Step-by-step explanation : The XPath expression: /*/*[not(self::criteria)]/* selects every element whose parent is an element not named "criteria" and which is a child of the top element of the document. Within the instruction we check if the current node has a name that is not one of the names of any children of criteria and only copy such a node: self::node()[not(/*/criteria/*[name()=name(current())])] This XPath expression selects the current node ( self::node() ) only if there doesn't exist a child of /*/criteria , whose name is the same as the name of the current node ( not(/*/criteria/*[name()=name(current())]) ). Here we use the fact that not(someNode-Set) is false() only if the nodeset someNode-Set is empty.
