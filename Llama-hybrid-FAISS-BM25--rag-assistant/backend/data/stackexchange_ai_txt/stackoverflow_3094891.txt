[site]: stackoverflow
[post_id]: 3094891
[parent_id]: 3094722
[tags]: 
While s is One mistake people often do in such algorithms is not precomputing square root. while (s is much, much slower than int limit = sqrt(N); while (s But generally speaking, Eiko is right in his comment. If you want people to offer low-level optimisations, you have to provide code. update Ok, now about your code. You may notice that number of iterations in your code is just little bigger than 'l'. (you may put counter inside first 'for' loop, it will be just 2-3 times bigger) And, obviously, complexity of your solution can't be less then O(l) (you can't have less than 'l' iterations). What can make real difference is accessing memory effectively. Note that guy who wrote that article tries to reduce storage size not just because he's memory-greedy. Making compact arrays allows you to employ cache better and thus increase speed. I just replaced boolean[] with int[] and achieved immediate x2 speed gain. (and 8x memory) And I didn't even try to do it efficiently. update2 That's easy. You just replace every assignment a[i] = true with a[i/32] |= 1 and each read operation a[i] with (a[i/32] & (1 . And boolean[] a with int[] a , obviously. From the first replacement it should be clear how it works: if f(i) is true, then there's a bit 1 in an integer number a[i/32] , at position i%32 ( int in Java has exactly 32 bits, as you know). You can go further and replace i/32 with i >> 5 , i%32 with i&31 . You can also precompute all 1 for each j between 0 and 31 in array. But sadly, I don't think in Java you could get close to C in this. Not to mention, that guy uses many other tricky optimizations and I agree that his could would've been worth a lot more if he made comments.
