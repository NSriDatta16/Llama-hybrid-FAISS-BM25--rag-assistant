[site]: stackoverflow
[post_id]: 5239585
[parent_id]: 4092793
[tags]: 
After trying a number of approaches, including the ones here as well as using UIAutomation Events and ETW for WPF , I've decided on a simple attachment of a handler to WPF events. This allows me to not only capture the event data, but also the UIElement which has the users attention, so it is much easier to trace the user action and intention. Without this, I'd need to capture a visual of the screen and make a visual determination of what is going on. Here's a sample: private Int32 _eventCount; public MainWindow() { InitializeComponent(); EventManager.RegisterClassHandler(typeof(UIElement), MouseEnterEvent, (RoutedEventHandler)handleEvent, true); EventManager.RegisterClassHandler(typeof(UIElement), MouseLeaveEvent, (RoutedEventHandler)handleEvent, true); EventManager.RegisterClassHandler(typeof(UIElement), MouseMoveEvent, (RoutedEventHandler)handleEvent, true); EventManager.RegisterClassHandler(typeof(UIElement), MouseUpEvent, (RoutedEventHandler)handleEvent, true); EventManager.RegisterClassHandler(typeof(UIElement), MouseDownEvent, (RoutedEventHandler)handleEvent, true); EventManager.RegisterClassHandler(typeof(UIElement), KeyUpEvent, (RoutedEventHandler)handleEvent, true); EventManager.RegisterClassHandler(typeof(UIElement), KeyDownEvent, (RoutedEventHandler)handleEvent, true); } private void handleEvent(object sender, RoutedEventArgs e) { var uiElement = e.Source as UIElement; if (uiElement == null) { return; } EventStatusDisplay.Text = e.Source + " " + e.RoutedEvent.Name; EventCountDisplay.Text = (++_eventCount).ToString(); var over = Mouse.DirectlyOver as UIElement; MouseIsOverDisplay.Text = over == null ? "" : over.ToString(); } While it is not shown here, once I get the UIElement I perform logging and can even then use the UIElement.DataContext to determine the state of the ViewModel which is driving the view so we can find patterns of usage during certain workflows and data-states as well as visual states. We can then get reports on this, as well as differentiate and compare our heat maps by paths through workflow and data values.
