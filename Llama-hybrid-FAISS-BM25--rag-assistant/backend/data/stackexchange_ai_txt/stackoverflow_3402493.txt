[site]: stackoverflow
[post_id]: 3402493
[parent_id]: 3402081
[tags]: 
Here is the algorithm I think you are describing in your question. For each pixel: If the pixel value is less than 10, do nothing. If the pixel value is greater than or equal to 10, replace the pixel value by the average of the non-zero 4-connected nearest neighbors. If this is correct (as it appears to be from the sample matrices you gave), then you could use the function NLFILTER from the Image Processing Toolbox (if you have access to it) to perform this operation: fcn = @(x) [x(5) sum(x(2:2:8))/max(sum(x(2:2:8) > 0),1)]*[x(5) = 10]; new_x = nlfilter(X,[3 3],fcn); EDIT: If you don't have access to the Image Processing Toolbox , you can also do this using the built-in CONV2 function, like so: kernel = [0 1 0; ... %# Convolution kernel 1 0 1; ... 0 1 0]; sumX = conv2(X,kernel,'same'); %# Compute the sum of neighbors %# for each pixel nX = conv2(double(X > 0),kernel,'same'); %# Compute the number of non-zero %# neighbors for each pixel index = (X >= 10); %# Find logical index of pixels >= 10 new_x = X; %# Initialize new_x new_x(index) = sumX(index)./max(nX(index),1); %# Replace the pixels in index %# with the average of their %# non-zero neighbors The above handles your radius = 1 case. To address your radius = 2 case, you just have to change the convolution kernel to the following and rerun the above code: kernel = [0 0 1 0 0; ... 0 1 1 1 0; ... 1 1 0 1 1; ... 0 1 1 1 0; ... 0 0 1 0 0];
