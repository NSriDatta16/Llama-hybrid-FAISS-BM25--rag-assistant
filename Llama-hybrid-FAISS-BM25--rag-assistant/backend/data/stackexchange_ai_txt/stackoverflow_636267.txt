[site]: stackoverflow
[post_id]: 636267
[parent_id]: 636180
[tags]: 
If there's more code between the call to CallAnAsyncMethod and the return, then there's potential value in doing it asynchronously (although it's likely an unnecessary preoptimization), otherwise synchronize your code. If you don't have any control over an architecture that's forcing you to do this code asynchronously, you'll have to monitor a variable and loop to wait for completion. bool myBool; bool retrievingMyBool; RetrieveABoolean(5); public bool RetrieveABoolean(int id) { client.CallAnAsyncMethod(id); // value is returned in a completed event handler. Need to somehow get that value into aBool. retrievingMyBool = true; while (retrievingMyBool) { Thread.Sleep(100); } } private void completedEventHandler([[parameters go here]]) { // code to handle parameters myBool = // whatever retrievingMyBool = false } This is a horrible solution, and will cause you gigantic headaches in the future, especially if you ever need the code to be thread safe, but as a hack, it could work.
