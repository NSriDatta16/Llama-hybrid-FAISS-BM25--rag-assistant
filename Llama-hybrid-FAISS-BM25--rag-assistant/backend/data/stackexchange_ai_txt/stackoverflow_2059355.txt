[site]: stackoverflow
[post_id]: 2059355
[parent_id]: 2059251
[tags]: 
You don't provide some important details, but under some reasonable assumptions it is 4 and 5 that are broken, while 1-3 are fairly OK. I assume that you are insisting on the use of bigger intermediate integral type because you want to avoid overflow on addition. It is also not clear whether you are working with signed on unsigned types and why your are mixing them like that. Anyway, the minimal proper way to perform the addition and shift would be bucket = ((long) ADCBUF0 + ADCBUF7) >> 1; Switching to bigger type in just one operand is sufficient. Of course, you can keep both casts if you like the more "symmetrical" look better. Or you can do it without any casts at all (assuming that bucket is declared with "bigger" type) bucket = ADCBUF0; bucket = (bucket + ADCBUF7) >> 1; As for the final assignment, if the recipient is an unsigned int by itself (this is completely unclear from your question), there's no real need for any cast, unless you are trying to suppress the compiler warnings. I assume that it is an unsigned int . In that case just rem_volt = bucket; will work. If it is not an unsigned int , then the explicit cast might make a difference, but there no way to say, until you provide this important detail. It doesn't matter where you do the shift in your case (in the first or in the second statement), again, if bucket has "bigger" type. If bucket is declared with the same type as the ADC... variables, then the shift must be done early (in the first expression). As for your variants: 1 is OK, but the second cast is technically redundant (matter of style). 2 is OK, with two excessive casts. 3 is also OK, with an excessive cast. 4 is broken, since it doesn't protect from overflow (if that was your intent). 5 is broken in the same way. In other words, out of all your variants number 1 looks the best (again, assuming that the cast to unsigned int is redundant). P.S. If you want to divide something by 2, the most reasonable way to do it is to use the division operator / and the constant 2 as a divisor. There's no meaningful reason to bring any shifts into the picture. Also Matthew Slattery in his answer provided a non-overflowing way to calculate the average using bit-twiddling operations. It can also be done in another, (arguably) more readable way through average = ADCBUF0 / 2 + ADCBUF7 / 2 + (ADCBUF0 % 2 & ADCBUF7 % 2); or, if you prefer the bit-twiddling approach average = (ADCBUF0 >> 1) + (ADCBUF7 >> 1) + (ADCBUF0 & ADCBUF7 & 1);
