[site]: stackoverflow
[post_id]: 2339219
[parent_id]: 650437
[tags]: 
OK here is your answer: Subclass UIButton. (NOTE: call [super ....] at the start of each override. Add a property. One of type BOOL (called enableToRestore) Add a property. One of type CGPoint (called startTouchPosition) in the awakeFromNib and initWithFrame, set the enableToRestore to the isEnabled property) Override "touchesBegan: withEvent:" to store the start of the touch position. Override "touchesMoved: withEvent:" to check to see if there is horizontal movement. If YES, set enabled to NO and selected to NO. Sample code: - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { UITouch *touch = [touches anyObject]; [super touchesBegan:touches withEvent:event]; [self setStartTouchPosition:[touch locationInView:self]]; } // // Helper Function // - (BOOL)isTouchMovingHorizontally:(UITouch *)touch { CGPoint currentTouchPosition = [touch locationInView:self]; BOOL rValue = NO; if (fabsf([self startTouchPosition].x - currentTouchPosition.x) >= 2.0) { rValue = YES; } return (rValue); } // // This is called when the finger is moved. If the result is a left or right // movement, the button will disable resulting in the UIScrollView being the // next responder. The parrent ScrollView will then re-enable the button // when the finger event is ended of cancelled. // - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesMoved:touches withEvent:event]; if ([self isTouchMovingHorizontally:[touches anyObject]]) { [self setEnabled:NO]; [self setSelected:NO]; } } This will activate the UIScrollView. Subclass UIScrollView. (NOTE: call [super ....] at the start of each override. Override both "touchesEnded: withEvent:" and "touchesCancelled: withEvent:" In the override, reset all subviews (and their subviews) enabled flag. NOTE: Use a Category and add the method to UIView: . - (void) restoreAllEnables { NSArray *views = [self subviews]; for (UIView *aView in views) { if ([aView respondsToSelector:@selector(restoreEnable)]) { [aView restoreEnable]; } } } - (void) touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesEnded:touches withEvent:event]; [self restoreAllEnables]; } - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesEnded:touches withEvent:event]; [self restoreAllEnables]; } In the Category: . -(void) restoreEnable { NSArray *views = [self subviews]; if ([self respondsToSelector:@selector(enableToRestore)]) { [self setEnabled:[self enableToRestore]]; } for (UIView *aView in views) { if ([aView respondsToSelector:@selector(restoreEnable)]) { [aView restoreEnable]; } } } EDIT Note: I never got Answer 3 to work. Likewise: the setDelaysContentTouches:NO (set in the view controller or someplace) is to be set for best results on Answer 4. This provides very fast response to the buttons. Setting setDelaysContentTouches:YES puts a serious impact (150ms) on response time to the buttons and makes light,fast touching not possible.
