[site]: stackoverflow
[post_id]: 1103937
[parent_id]: 1102853
[tags]: 
+1 for 1800 and Ylisar. Using an union for this kind of things is probably the way to go. But, as others pointed out, it has several drawbacks: inherently error prone. not safely extensible. can't handle members with constructors (although you can use pointers). So unless you can built a nice wrapper, going the boost::variant way is probably safer. This is a bit offtopic, but this issue is one of the reasons why languages of the ML family have such a strong appeal (at least for me). For example, your issue is elegantly solved in OCaml with: (* * LData, FData and StrData are constructors for this sum type, * they can have any number of arguments *) type structData = LData of int | FData of float | StrData of string (* * the compiler automatically infers the function signature * and checks the match exhaustiveness. *) let print x = match x with | LData(i) -> Printf.printf "%d\n" i | FData(f) -> Printf.printf "%f\n" f | StrData(s) -> Printf.printf "%s\n" s
