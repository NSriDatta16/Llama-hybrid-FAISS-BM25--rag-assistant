[site]: stackoverflow
[post_id]: 736561
[parent_id]: 736376
[tags]: 
First, a disclaimer: Any attempt to slice and dice XML with regular expressions is fragile; a real XML parser would do better. The pattern: \( \)\@ \)\@= Let's break it down... Group 1 is . It matches the start-tag of the Attribute element. Group 2, which is embedded in Group 1, matches an attribute and may be repeated 0 or more times. Group 2 is \s*\w\+="[^"]\{-}"\s\{-} . Most of these pieces are commonly used; the most unusual is \{-} , which means non-greedy repetition ( *? in Perl-compatible regular expressions). The non-greedy whitespace match at the end is important for performance; without it, Vim will try every possible way to split the whitespace between attributes between the \s* at the end of Group 2 and the \s* at the beginning of the next occurrence of Group 2. Group 1 is followed by \@ . This is a zero-width positive look-behind. It prevents the start-tag from being included in the matched text (e.g., for s///). Group 3 is \( . It includes Group 4, which matches the beginning of the Attribute end-tag. The \@! is a zero-width negative look-ahead and \_. matches any character (including newlines). Together, this groups matches at any character except where the Attribute end-tag starts. Group 3 is followed by a non-greedy repetition marker \{-} so that it matches the smallest block of text before MATCH. If you were to use \_. instead of Group 3, the matched text could include the end-tag of an Annotation element that did not include MATCH and continue through into the next Annotation element with MATCH. (Try it.) The next bit is straightforward: Find MATCH and a minimal number of other characters before the end-tag. Group 5 is easy: It's the end tag. \@= is a zero-width positive look-ahead, which is included here for the same reason as the \@ for the start-tag. We have to repeat rather than use \4 because groups with zero-width modifiers aren't captured.
