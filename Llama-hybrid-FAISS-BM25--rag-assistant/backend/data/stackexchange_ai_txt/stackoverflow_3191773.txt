[site]: stackoverflow
[post_id]: 3191773
[parent_id]: 3191727
[tags]: 
Have all the threads put their results into a single contiguous vector just like before. You have to ensure each thread only accesses parts of the vector that are separate from the others. As long as that's the case (which it should be regardless -- you don't want to generate the same output twice) each is still working with memory that's separate from the others, and you don't need any locking (etc.) for things to work. You do, however, need/want to ensure that the vector for the result has the correct size for all the results first -- multiple threads trying (for example) to call resize() or push_back() on the vector will wreak havoc in a hurry (not to mention causing copying, which you clearly want to avoid here). Edit: As Billy O'Neal pointed out, the usual way to do this would be to pass a pointer to each part of the vector where each thread will deposit its output. For the sake of argument, let's assume we're using the std::vector > mentioned as the original version of things. For the moment, I'm going to skip over the details of creating the threads (especially since it varies across systems). For simplicity, I'm also assuming that the number of curves to be generated is an exact multiple of the number of threads -- in reality, the curves won't divide up exactly evenly, so you'll have to "fudge" the count for one thread, but that's really unrelated to the question at hand. std::vector inputs; // input data std::vector > outputs; // space for output data const int thread_count = 4; struct work_packet { // describe the work for one thread USERPOINT *inputs; // where to get its input std::vector *outputs; // where to put its output int num_points; // how many points to process HANDLE finished; // signal when it's done. }; std::vector packets(thread_count); // storage for the packets. std::vector events(thread_count); // storage for parent's handle to events outputs.resize(inputs.size); // can't resize output after processing starts. for (int i=0; i Note that although we have to be sure that the outputs vector doesn't get resized while be operated on by multiple threads, the individual vectors of points in outputs can be, because each will only ever be touched by one thread at a time.
