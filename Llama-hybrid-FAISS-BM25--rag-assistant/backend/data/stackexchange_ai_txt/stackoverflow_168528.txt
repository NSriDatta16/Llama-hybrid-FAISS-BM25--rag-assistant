[site]: stackoverflow
[post_id]: 168528
[parent_id]: 
[tags]: 
Handling Managed Delegates in Unmanaged code

I know I can get this to technically work but I'd like to implement the cleanest possible solution. Here's the situation: I have a managed library which wraps an unmanaged C-style library. The C-style library functionality I'm currently wrapping does some processing involving a list of strings. The library's client code can provide a delegate, such that during the list processing, if an "invalid" scenario is encountered, the library can callback to the client via this delegate and allow them to choose the strategy to use (throw an exception, replace the invalid characters, etc.) What I'd ideally like to have is all of the managed C++ isolated in one function, and then be able to call a separate function which takes only unmanaged parameters so that all of the native C++ and unmanaged code is isolated at that one point. Providing the callback mechanism to this unmanaged code is proving to be the sticking point for me. #pragma managed public delegate string InvalidStringFilter(int lineNumber, string text); ... public IList DoListProcessing(IList listToProcess, InvalidStringFilter filter) { // Managed code goes here, translate parameters etc. } #pragma unmanaged // This should be the only function that actually touches the C-library directly std::vector ProcessList(std::vector list, ?? callback); In this snippet, I want to keep all of the C-library access within ProcessList, but during the processing, it will need to do callbacks, and this callback is provided in the form of the InvalidStringFilter delegate which is passed in from some client of my managed library.
