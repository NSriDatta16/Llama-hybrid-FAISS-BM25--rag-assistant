[site]: stackoverflow
[post_id]: 4951591
[parent_id]: 4950834
[tags]: 
Maybe something along those lines: #define BOOST_CLASS_TEMPLATE_EXPORT_IMPLEMENT(T) \ namespace boost { \ namespace archive { \ namespace detail { \ namespace { \ template \ struct init_guid > { \ static guid_initializer > const & g; \ }; \ template \ guid_initializer > const & init_guid >::g = \ ::boost::serialization::singleton > \ >::get_mutable_instance().export_guid(); \ }}}} \ /**/ #define BOOST_CLASS_TEMPLATE_EXPORT_KEY2(T, K) \ namespace boost { \ namespace serialization { \ template \ struct guid_defined > : boost::mpl::true_ {}; \ template \ inline const char * guid >(){ \ return K + " () + ">"; //this doesn't work, I know! \ } \ } /* serialization */ \ } /* boost */ \ /**/ #define BOOST_CLASS_TEMPLATE_EXPORT_KEY(T) \ BOOST_CLASS_TEMPLATE_EXPORT_KEY2(T, BOOST_PP_STRINGIZE(T)) \ /**/ #define BOOST_CLASS_TEMPLATE_EXPORT_GUID(T, K) \ BOOST_CLASS_TEMPLATE_EXPORT_KEY2(T, K) \ BOOST_CLASS_TEMPLATE_EXPORT_IMPLEMENT(T) \ /**/ It might work with some additional tweaks to it. Of course, it would probably assume that the user_type is also exported already. But still, it would reduce the combinatorial dimension, all you need is one export per class and one export per class template, not one export per template instantiation (number of classes X number of class templates). This is probably the kind of thing that should be asked / requested / proposed to the guy in charge of the Boost.Serialization library (I guess that would be Robert Ramey).
