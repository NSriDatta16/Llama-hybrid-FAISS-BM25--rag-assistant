[site]: stackoverflow
[post_id]: 4929548
[parent_id]: 
[tags]: 
Best way to initialize a statically initialized per-struct character buffer?

Continuing from Absolute fastest (and hopefully elegant) way to return a certain char buffer given a struct type I want to now initialize once each static character buf per struct individually. Ie, for: #pragma pack(push, 1); struct Header { int a; int b; char c; }; struct X { int x; int y; }; struct Y { char someStr[20]; }; struct Msg { Header hdr; union { X x; Y y; }; }; #pragma pack(pop) We have: tempate struct Buffer { static char buffer[sizeof(T)]; } template inline char* get_buffer() { return Buffer ::buffer; } The two things I'm looking for are: There are exactly 2 buffers: 1 for X and one for Y. They should each be the length of sizeof(Msg.hdr) + sizeof(Msg.x) and sizeof(Msg.hdr) + sizeof(Msg.y), respectively. Each buffer will be retrieved a lot during the application lifetime and only some fields really (or need to) change. 2a. Msg for X backed by it's char buffer should be initialized to m.hdr.a = 1, m.hdr.b = 0; and for Msg Y it should be m.hdr.a = 16; m.hdr.b = 1; as an example. The app will frequently fetch these buffers as type Msg backed by either X or Y (the app would know which one) and then change x and y or someStr only and then output it to the file for example then repeat. Just wondering what nice way builds on these great examples by @6502 and @Fred Nurk to elegantly initialize these 2 buffers while being human readable. I'd prefer to keep using structs and to limit the use of reinterpret_cast<>() as much as possible as there may be aliasing issues that might develop. Please let me know if I'm not clear and I will do my best to answer any questions and/or edit this question description. Thanks. *** Update: my usage pattern of these buffers is that I will be sending copying the char* out to a stream or file. hence I need to get a char* pointer to the underlying data. However I need to work on the char buffers via their structs for readability and convenience. Also this char buffer should be decoupled and not necessarily contained or "attached" to the struct as the structs are pretty much in separate files and used elsewhere where the buffers are not needed/wanted. Would just doing a simple static X x; static Y y; suffice or Maybe better buffers of length Header + X for X's Msg buffer? and then somehow just keep a char* reference to each Msg for X and Y? Will I run into aliasing issues potentially?
