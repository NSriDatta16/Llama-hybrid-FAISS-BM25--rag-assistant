[site]: stackoverflow
[post_id]: 4481414
[parent_id]: 4481285
[tags]: 
You are missing the virtual keyword. In C++ methods are not virtual by default like they are in some other programming languages (e.g., Java). Try the following instead: #include class User { static const int min_pass_len = 10; public: virtual ~User() {} virtual int getPasswordLength() const { return min_pass_len; } }; class AdminUser: public User { static const int min_pass_len = 42; public: virtual ~AdminUser() {} virtual int getPasswordLength() const { return min_pass_len; } }; int main() { AdminUser a; User u, *p = &a; std::cout getPasswordLength() If you want to get rid of the method altogether, then either use the example of the "curiously reoccuring template pattern" mentioned by Sanjit or externalize the constant instead embedding it within the class. I was thinking of something similar to how std::numeric_limits is implemented: template struct UserTraits { static const int minimum_password_length = 0; }; template<> struct UserTraits { static const int minimum_password_length = 10; }; template<> struct UserTraits { static const int minimum_password_length = 10; }; int main() { std::cout ::minimum_password_length ::minimum_password_length I usually prefer the first approach since it works when you have a pointer to an instance. The latter method isn't nearly as useful since you cannot use it to extract the constant from an instance without resorting to writing a free function and even then you loose the dynamic typed aspect. template int getPasswordLength(T*) { return UserTraits ::minimum_password_length; } template int getPasswordLength(T&) { return UserTraits ::minimum_password_length; } The problem with this approach is that you would get the wrong result if you called getPasswordLength(p) using p in the first snippet.
