[site]: stackoverflow
[post_id]: 1512164
[parent_id]: 1511935
[tags]: 
I can only think of a few differences - here are some examples that don't necessarily cause harm (i think). I'm omitting definitions to keep it terse template T inc(const T& t); namespace G { using ::inc; } template <> int inc(const int& t); namespace G { void f() { G::inc(10); } } // uses explicit specialization // --- against --- template T inc(const T& t); namespace G { using ::inc; } int inc(const int& t); namespace G { void f() { G::inc(10); } } // uses template That is because specializations are not found by name lookup, but by argument matching, so a using declaration will automatically consider a later introduced specialization. Then, you of course cannot partially specialize function templates. Overloading however accomplishes something very similar by partial ordering (using different types now, to make my point) template void f(T t); // called for non-pointers template void f(T *t); // called for pointers. int a; void e() { f(a); // calls the non-pointer version f(&a); // calls the pointer version } That wouldn't be possible with function template explicit specialization. Another example is when references are involved, which causes template argument deduction to look for an exact match of the types involved (modulo base/derived class relationships and constness): template void f(T const &); template<> void f(int * const &); template void g(T const &); void g(int * const &); int a[5]; void e() { // calls the primary template, not the explicit specialization // because `T` is `int[5]`, not `int *` f(a); // calls the function, not the template, because the function is an // exact match too (pointer conversion isn't costly enough), and it's // preferred. g(a); } I recommend you to always use overloading, because it's richer (allows something like partial specialization would allow), and in addition you can place function in whatever namespace you want (although then it's not strictly overloading anymore). For example, instead of having to specialize std::swap in the std:: namespace, you can place your swap overload in your own namespace and make it callable by ADL. Whatever you do, never mix specialization and overloading , it will be a hell of a mess like this article points out. The Standard has a lovely paragraph about it The placement of explicit specialization declarations for function templates, class templates, member functions of class templates, static data members of class templates, member classes of class templates, member class templates of class templates, member function templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, member function templates of member classes of class templates, etc., and the placement of partial specialization declarations of class templates, member class templates of non-template classes, member class templates of class templates, etc., can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below. When writing a specialization, be careful about its location; or to make it compile will be such a trial as to kindle its self-immolation.
