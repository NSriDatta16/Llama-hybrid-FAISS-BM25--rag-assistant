[site]: stackoverflow
[post_id]: 3113465
[parent_id]: 
[tags]: 
Why does TextView.setText cause the enclosing ScrollView to scroll?

I've got this odd problem which is happening on 1.6, 2.2, and a MyTouch 3G Slide (which is API #7, and listed as "2.1-Update1" in the Android Device Chooser). If anyone can explain what I'm doing wrong & how to fix it (or possibly confirm that this is an Android bug), I'd greatly appreciate it! The basic idea for my app is to make a stopwatch-sort of thing, in that the user can tap a button to start a timer, then tap it again to stop (pause) the timer; further taps alternate between resuming the timer and pausing the timer. I've got a top-level ScrollView which contains a RelativelLayout, which contains a bunch of widgets. The first widget is a HUGE button (so that it's easy to press), which pushes all my other widgets below the bottom of the screen. This is intentional, as I want to rely on the ScrollView (and an on-screen reminder to the user) to make the rest of the input options available. I've got a simple state-machine type setup, where mState is the current mode (STATE_TIMER_NOT_STARTED before the user presses any buttons, ...RUNNING after the first press, and then ...PAUSED after the second, back to ...RUNNING after the third, etc, etc). All this works great EXCEPT that when the timer is running, and the user presses the start/stop/resume button again, the ScrollView will scroll down a ways. I am NOT issuing this command (I don't even have a reference to ScrollView object), and I'm not sure why it's doing this. REPRO: Compile + run the below samples. When the app starts, press the 'Start Timing' button. Use your thumb (or the mouse) to touch-drag the screen upwards (so you can see the RatingBar), then drag it back downwards (so the button is again completely on-screen). Tap the button (which now reads 'PauseTiming') again, and it'll jump down a bit. It should NOT be jumping/scrolling down, since there's no statement (that I can see) that tells it to scroll down. As near as I can tell, it's the setText that causes the scrolling ( when I comment those lines out, no scrolling occurs). WHAT I'M ASKING FOR: If I'm doing something dumb & you could point out what it is, I'd really appreciate it! :) *** I wonder if 'touch mode' might have something to do with this, since it does NOT appear to happen (in the emulator) when I use the mouse's scroll wheel to move the panel upwards (i.e.,instead of the simulated finger-dragging). I can't find a whole lot on touch-mode, and nothing specific on focus/selection in touch mode within a ScrollView If you can confirm that this error occurs for you too, that would be ok, too (since misery loves company. AHEM I mean, since it might help confirm that it's not just me :) ). MyTestApp.java package bug.android.scrollview; import android.app.Activity; import android.os.Bundle; import android.text.format.Time; import android.view.Display; import android.view.View; import android.view.WindowManager; import android.widget.Button; import android.widget.TextView; public class MyTestApp extends Activity { public final static int STATE_TIMER_NOT_STARTED = 1; public final static int STATE_TIMER_RUNNING = 2; public final static int STATE_TIMER_PAUSED = 3; private int mState; Time t = new Time(); private Time data = new Time(); private Button btnStartStopResume; private TextView lblSpacer; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.new_time_entry); btnStartStopResume = (Button) findViewById(R.id.btnStartStopResume); // Set the button's size so that the other info will also be visible Display display = ((WindowManager) getSystemService(WINDOW_SERVICE)) .getDefaultDisplay(); // This is such a hack, but the windowScroller doesn't appear to // have a height at this point in the lifecycle (nor in 'onResume' :( ) btnStartStopResume.setHeight(display.getHeight() - 200); lblSpacer = (TextView) findViewById(R.id.lblSpacer); reset(); } public void doStartStopResume(View v) { if (mState == MyTestApp.STATE_TIMER_NOT_STARTED) { mState = MyTestApp.STATE_TIMER_RUNNING; data.setToNow(); } else if (mState == MyTestApp.STATE_TIMER_RUNNING) { mState = MyTestApp.STATE_TIMER_PAUSED; String s = getString(R.string.add_scroll_down_to_add); lblSpacer.setText(s); } else if (mState == MyTestApp.STATE_TIMER_PAUSED) { mState = MyTestApp.STATE_TIMER_RUNNING; } } public void doReset(View v) { } public void doNewRunClick(View v) { } public void doAddTiming(View v) { } public void reset() { mState = STATE_TIMER_NOT_STARTED; } } new_time_entry.xml strings.xml Timer Edit A Timing &lt; Scroll down for more options! &gt; &lt; Scroll down to save this timing! &gt; Start Timing\n\n Pause Timing\n\n Resume Timing\n\n AndroidManifest.xml UPDATE 1: Adding if( btnStartStopResume.isInTouchMode() ) Toast.makeText(this, "TOUCH MODE", 2000); else Toast.makeText(this, "NOT touch mode", 2000); then setting breakpoints in the debugger confirms that the button is always in touch mode (regardless of whether I finger-drag the panel up/down, or mouse-wheel it up/down). So it's a combination of being in touch-mode AND finger-dragging the panel after the 2nd button-press (i.e, when the app is in 'stopped/paused timing' mode) that's causing the odd extra-timing in subsequent pauses. UPDATE 2: I just noticed that it's scrolling down to the EditText, and no further. It looks like when you move the panel down the EditText gets the selection, and after the click event the ScrollView scrolls back to the thing that has the selection. Seems to explain why the mouse-wheel approach doesn't have this problem (it moves the selection/focus back up to the button).
