[site]: stackoverflow
[post_id]: 3581027
[parent_id]: 3580940
[tags]: 
First of all, why do you need to load the 2k rows at the same time? Why don't you do it lazily? First, when loading the table view, you would use your datasource to only count the number of rows that you would display, querying the core data to get only the number, and so your table view would be ready to show all the necessary cells. Second, load from core data only the content that you would need, it means, only the content on screen. Imagine if the user drag and scroll the table view very fast, many cell would be loaded without the need for it. The right thing to do is loading only the visible cells and it means the ones that would be visible when the scrolling process stops. Have a look at this example from Apple on how to load resources for table view lazily: http://developer.apple.com/iphone/library/samplecode/LazyTableImages/Listings/Classes_RootViewController_m.html#//apple_ref/doc/uid/DTS40009394-Classes_RootViewController_m-DontLinkElementID_12 It's for images, but you can do the same idea for the fetching of objects. Doing this lazily you wouldn't need the activity indicator. BTW, going back to the issue with the activity indicator, you may need to ask you cell to update: - (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath; { [tableView deselectRowAtIndexPath:indexPath animated:YES]; //-- start activity indicator (will be stopped when view disappears) UITableViewCell * cell = [tableView cellForRowAtIndexPath:indexPath]; [cell.contentView addSubview:m_activityIndicator]; [m_activityIndicator startAnimating]; [cell setNeedsDisplay]; return indexPath; } Cheers
