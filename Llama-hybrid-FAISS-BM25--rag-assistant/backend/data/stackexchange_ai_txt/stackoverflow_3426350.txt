[site]: stackoverflow
[post_id]: 3426350
[parent_id]: 727707
[tags]: 
Haskell: I tried to come up with an elegant list monad-y way to this: import Control.Applicative brackets :: Int -> [String] brackets n = f 0 0 where f pos depth = if pos close else stop where -- Add an open bracket if we can open = if depth f (pos+1) (depth+1) else empty -- Add a closing bracket if we can close = if depth > 0 then (')' :) f (pos+1) (depth-1) else empty -- Stop adding text. We have 2*n characters now. stop = pure "" main = readLn >>= putStr . unlines . brackets
