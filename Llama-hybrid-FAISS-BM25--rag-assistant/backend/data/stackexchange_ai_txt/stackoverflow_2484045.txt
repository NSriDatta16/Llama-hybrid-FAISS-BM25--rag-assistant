[site]: stackoverflow
[post_id]: 2484045
[parent_id]: 2468493
[tags]: 
Note: I always assumed an SO user should never answer their own question. But, after reading-up on SO-Meta on this issue, I find it's actually encouraged. Personally, I would never vote on my own answer as "accepted." This "new solution" uses a strategy based on distinguishing between a control being updated as a result of end-user action, and a control being updated by synchronizing code: this issue was mentioned, as a kind of "rhetorical question," in the original question. I consider this an improvement: it works; it prevents multiple update calls; but, I also "suspect" it's still "not optimal": appended to this code example is a list of "suspicions." // VS Studio 2010 RC 1, tested under Framework 4.0, 3.5 using System; using System.Collections.Generic; using System.Windows.Forms; namespace SynchronizationTest_3 { public partial class Form1 : Form { private readonly Dictionary > ControlToAction = new Dictionary >(); // new code : keep a reference to the control the end-user clicked private Control ClickedControl; public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { ControlToAction.Add(treeView1, (i => { treeView1.SelectedNode = treeView1.Nodes[i]; })); ControlToAction.Add(listView1, (i => { listView1.Items[i].Selected = true; })); ControlToAction.Add(comboBox1, (i => { comboBox1.SelectedIndex = i; })); // new code : screen out redundant calls generated by other controls // being updated treeView1.AfterSelect += (obj, evt) => { if (treeView1 == ClickedControl) SynchronizeSelection(evt.Node.Index); }; listView1.SelectedIndexChanged += (obj, evt) => { if (listView1.SelectedIndices.Count > 0 && listView1 == ClickedControl) { SynchronizeSelection(listView1.SelectedIndices[0]); } }; comboBox1.SelectedValueChanged += (obj, evt) => { if (comboBox1 == ClickedControl) SynchronizeSelection(comboBox1.SelectedIndex); }; // new code here : all three controls share a common MouseDownHandler treeView1.MouseDown += SynchronizationMouseDown; listView1.MouseDown += SynchronizationMouseDown; comboBox1.MouseDown += SynchronizationMouseDown; // trigger the first synchronization ClickedControl = treeView1; SynchronizeSelection(0); } // get a reference to the control the end-user moused down on private void SynchronizationMouseDown(object sender, MouseEventArgs e) { ClickedControl = sender as Control; } // revised code using state of ClickedControl as a filter private void SynchronizeSelection(int i) { // we're done if the reference to the clicked control is null if (ClickedControl == null) return; foreach (Control theControl in ControlToAction.Keys) { if (theControl == ClickedControl) continue; // for debugging only Console.WriteLine(theControl.Name + " synchronized"); ControlToAction[theControl](i); } // set the clicked control to null ClickedControl = null; } } } Why I "suspect" this is not optimal: the idiosyncratic behavior of WinForms controls has to be taken into account: for example, the ListView Control fires its Selected### Events before it fires a Click Event: ComboBox and TreeView fire their Click Events before their SelectedValueChanged and AfterSelect Events respectively: so had to experiment to find that using 'MouseDown would work the same across all three controls. a "gut level" feeling that I've gone "too far" out on "some kind of limb" here: a sense a much simpler solution might be possible.
