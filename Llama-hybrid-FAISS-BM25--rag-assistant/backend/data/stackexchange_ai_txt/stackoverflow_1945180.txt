[site]: stackoverflow
[post_id]: 1945180
[parent_id]: 1945052
[tags]: 
Apart from being not so elegant, and maybe being slow, adding step continuously to get close to the number being checked will result in less accurate calculations because floating-point errors tend to accumulate. I don't know Java well, but an algorithm to do this would be to take the ratio: (value-min)/step , round it to the nearest integer n , and then calculate v = min+step*n . If v and value are "close enough", then you can mark value as valid. To test for "close enough" floating-point values, one should use a relative and an absolute tolerance. For example, the package fcmp implements a fairly good algorithm to compare floating-point values.
