[site]: stackoverflow
[post_id]: 4594498
[parent_id]: 
[tags]: 
Understanding Memory Models

I've been reading up on memory models recently and I was sort of confused on how this worked. To quote http://cis.poly.edu/muller/CS623/weakmemory.htm if processor writes a new X then writes a new Y, all other processors that subsequently execute a read Y then a read X, will access either the new Y and new X, the old Y and the new X, or old X and the old Y: but no processor will access the new Y and the old X. This assumption of strong ordering was, at one time, reasonable. Current computer manufactures, however, recommend that programmers not rely on memory ordering. This is because newer memory management systems attempt to reorder memory access for optimization purposes. Systems that are allowed to reorder memory request are called weakly-ordered memory systems (models). To examine how a reordering might be used to improve performance, consider the following assembler code [2]. Load reg1, A // register1 = contents of memory A Load reg2, B // register2 = contents of memory B ADD reg3, reg1, reg2 // register3 = register1 + register2 Store reg3, C // contents of memory C = contents of register3 If we assume that location B is currently in cache and location A is not cached, then loading A will take longer than B. Instead of waiting for A, the CPU can fetch B from its cache, hiding Bâ€™s latency: thus the CPU can perform the addition as soon as A is available. By relaxing the strong (sequential) memory model of execution (i.e., A must load first, followed by B), greater performance is possible----but reordering may not be transparent to software. Consider the code fragment below, it is part of the code that can be used to implements a spinlock semaphore [2]. My question is, how is it possible that with a weaker memory model could lead to the case that a processor could access the new Y and old X. Isn't it written to the same memory (ram) or does it work differently? I assume if one process modifies a variable and another reads it after that, it reads the latest value. Another thing I'm not sure about is which component allows memory access reordering, my assumption now is that a compiler is allowed to reorder instructions. But could a CPU also reorder them? Thanks
