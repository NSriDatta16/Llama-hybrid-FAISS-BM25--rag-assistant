[site]: stackoverflow
[post_id]: 4455714
[parent_id]: 4454957
[tags]: 
There are likely many ways to dramatically improve performance, but to be able to suggest any, we really need to know more about what the objects in the arrays "are": what do they represent? How are they being used? (For example, are the items in the store array being displayed in a table view?) NSMutableDictionary , NSMutableSet , etc. could be combined with NSMutableArray to organize and implement the model in an efficient manner. For example, let's say we know the object represents a person: MDPerson . A person has a gender, a date of birth, a name, a unique id, and a set of attributes that can change. Given this higher level understanding of what the object represents, we know that 2 people are equal only if their unique ids are the same (in other words, 2 different people can have the same name, gender, and date of birth). Let's say that your main NSMutableArray is made up of a list of 3000 people. The incoming array is made up of 500 people which are already in the main NSMutableArray . A few of these 500 people instances might have "updated" attributes, which means that their instance in the main array needs to be updated with that info. Given that understanding, it's clear that the main list should be implemented as an NSMutableDictionary rather than an NSMutableArray . In the dictionary, the person's unique id would be the key, and their person instance would be the value for the key. You could then loop through the incoming array of 500 persons only once: // main dictionary is called personIDsAndPersons for (MDPerson *person in incomingPersons) { MDPerson *existingPerson = [personIDsAndPersons objectForKey:[person uniqueID]]; // if nil, the person doesn't exist if (existingPerson) { // update the existing person's attributes [existingPerson setUniqueAttributes:[person uniqueAttributes]]; } } Again, without knowing more of the details or having a higher level understanding of what the objects are, we're really just shooting in the dark. You mention that 2 items are only the same if they have the same name. So, does that mean that each item in the main array of 3000 objects each have a unique name? If so, you could use an NSMutableDictionary to allow access to the objects in an efficient manner by having the keys in the dictionary be the name and the values be the object instance. You could then use a separate NSMutableArray that's used merely for display purposes: it allows an ordered, sorted organization of the same objects that are stored in the NSMutableDictionary . Remember that when you add an object to an array or a dictionary, normally you're not creating a new copy, you're just retaining the existing object.
