[site]: stackoverflow
[post_id]: 4359487
[parent_id]: 4357022
[tags]: 
This is a fragment from an incoming mail handler I use: bodies = message.bodies(content_type='text/html') allBodies = u""; for body in bodies: allBodies = allBodies + u"\n" + unicode(goodDecode(body[1]), errors="ignore") if not allBodies: bodies = message.bodies(content_type='text/plain') for body in bodies: allBodies = allBodies + u"\n" + unicode(goodDecode(body[1]), errors="ignore") msg = EmailMessageModel() ...fill in various stuff... msg.sender = message.sender msg.date = datetime.datetime.now() msg.message = allBodies # Calling put() before dealing with attachments because it seems like that could throw various exceptions msg.put() event.email = True event.put() event.project.email = True event.project.put() # attachments is a list of element pairs containing file names and contents. try: if hasattr(message, 'attachments'): for a in message.attachments: msg.attachmentNames.append(a[0]) msg.attachmentContents.append(db.Blob(goodDecode(a[1]))) msg.put() except: logging.exception("Exception decoding attachments in email from %s" % message.sender) Note that goodDecode is a function I wrote because there was a bug in the underlying GAE decode (it lowercased everything, which munged base64-encoded text): def goodDecode(encodedPayload): if not hasattr(encodedPayload, 'encoding'): return encodedPayload encoding = encodedPayload.encoding payload = encodedPayload.payload if encoding and encoding.lower() != '7bit': payload = payload.decode(encoding) return payload This is probably not necessary any more, because I'm pretty sure they fixed that bug. In my case, I'm stuffing the attachments into the database: class EmailMessageModel(db.Model): ....various stuff... sender = db.StringProperty() date = db.DateTimeProperty() message = db.TextProperty() attachmentNames = db.StringListProperty() attachmentContents = db.ListProperty(db.Blob) When I want to show this email, I'm using this: {{ e.sender }} {{ e.date|date:"M j, Y f A " }} GMT From: {{ e.sender }} Date: {{ e.date|date:"M j, Y f A" }} GMT ({{ e.date|timesince }} ago) Subject: {{ e.subject }} {% if e.attachmentNames %} Attachments: {% for a in e.attachmentNames %} {{ a }} {% endfor %} {% endif %} {{ e.message }} The attachment handler is: class AttachmentHandler(webapp.RequestHandler): def get(self): email = EmailMessageModel.get(self.request.get('email')) index = self.request.get('index') if index: index = int(index) filename = email.attachmentNames[index] self.response.headers['Content-Type'] = str(mimetypes.guess_type(filename)[0]) or 'application/octet-stream' self.response.out.write(email.attachmentContents[index]) (So, basically, I'm letting the browser figure out what to do with the attachments.) Hope this helps!
