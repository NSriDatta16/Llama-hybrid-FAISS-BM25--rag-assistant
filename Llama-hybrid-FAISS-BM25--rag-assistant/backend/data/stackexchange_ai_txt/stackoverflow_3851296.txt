[site]: stackoverflow
[post_id]: 3851296
[parent_id]: 
[tags]: 
F# return element pairs in list

I have been looking for an elegant way to write a function that takes a list of elements and returns a list of tuples with all the possible pairs of distinct elements, not taking into account order, i.e. (a,b) and (b,a) should be considered the same and only one of them be returned. I am sure this is a pretty standard algorithm, and it's probably an example from the cover page of the F# documentation, but I can't find it, not even searching the Internet for SML or Caml. What I have come up with is the following: let test = [1;2;3;4;5;6] let rec pairs l = seq { match l with | h::t -> yield! t |> Seq.map (fun elem -> (h, elem)) yield! t |> pairs | _ -> () } test |> pairs |> Seq.toList |> printfn "%A" This works and returns the expected result [(1, 2); (1, 3); (1, 4); (1, 5); (1, 6); (2, 3); (2, 4); (2, 5); (2, 6); (3, 4); (3, 5); (3, 6); (4, 5); (4, 6); (5, 6)] but it looks horribly unidiomatic. I should not need to go through the sequence expression and then convert back into a list, there must be an equivalent solution only involving basic list operations or library calls... Edited: I also have this one here let test = [1;2;3;4;5;6] let rec pairs2 l = let rec p h t = match t with | hx::tx -> (h, hx)::p h tx | _ -> [] match l with | h::t -> p h t @ pairs2 t | _ -> [] test |> pairs2 |> Seq.toList |> printfn "%A" Also working, but like the first one it seems unnecessarily involved and complicated, given the rather easy problem. I guess my question is mor about style, really, and if someone can come up with a two-liner for this.
