[site]: stackoverflow
[post_id]: 3435630
[parent_id]: 3435508
[tags]: 
This is a really common way of setting up a DB storage class. What happens is you instantiate an object based on PropertyObject (as PropertyObject is abstract) class MyObj extends PropertyObject { } $m = new MyObj(); Which inherits the __get() and __set() methods. Any time the object's data is accessed via the -> operator, the __get() and __set() methods are called, respectively. $m->foo; #calls MyObject::__get('foo'); $m->bar = 'baz'; #calls MyObject::__set('bar','baz'); The __get() method first checks to see if the there is a key defined in the property table (which here models fields from the DB), and if one does not exist, throws an exception. Then, get() will see if there is a function defined with the word 'get' prepended. So, assuming foo was a key in the propertyTable , __get() would see if we had defined a method getfoo , and if we had, call it for us, and return its value. //if(method_exists($this,'get'.$propertyName)) //{ // return call_user_func(array($this,'get'.$propertyName)); //} $m->foo; # checks if MyObj::getfoo is defined, and if so, calls it Lastly, if there is a key foo in the propertyTable but no method named getfoo , it would simply return the value of the array position in $m->data whose key is the value of the array position in propertyTable whose key is foo __set() is defined much the same way, but rather than returning the value stored in the data array instead checks for a prepended 'set', and checks to see if the value being set on the object is any different from the value in the data array, and if it is, adds the property name to the changedProperties array before setting the new value.
