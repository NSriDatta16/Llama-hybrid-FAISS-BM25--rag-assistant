[site]: stackoverflow
[post_id]: 4831559
[parent_id]: 4831276
[tags]: 
Javascript engines are single-threaded, meaning that only one piece of code is ever executing at once. Asynchronous features (AJAX, timeouts / intervals ) cause different blocks of code to run in sequence, not in parallel (i.e. you'll never get any use out of multiple processor cores in Javascript). The simplest way to produce asynchronous (non-blocking) code is using setTimeout ( I strongly discourage using setInterval ), as others have suggested, but there is no performance benefit to doing so. This simply ensures that your browser won't "hang" during slow JS computations, by allowing the browser's other tasks (such as page repainting and user input) the opportunity to run. It won't actually increase the speed of those computations (in fact, it slightly slows them, due to the small additional overhead of the timeouts). It is possible to create separate threads in Javascript using web workers , but their capabilities are limited (for example, they cannot alter the DOM) and they are not yet supported by IE . An example of a long-running, non-blocking task using "recursive" setTimeout calls: function getStarted(elements) { // this function must be inside the outer function // so that `i` (below) can be accessed via a closure function processElement() { // do work on elements[i] here // or pass it to another function // this continues only if we haven't hit the end of the array, // like the second and third clauses of a `for` loop if (++i
