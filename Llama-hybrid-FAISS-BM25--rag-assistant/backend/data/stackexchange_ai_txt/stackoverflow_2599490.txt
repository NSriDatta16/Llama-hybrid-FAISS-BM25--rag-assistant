[site]: stackoverflow
[post_id]: 2599490
[parent_id]: 2599118
[tags]: 
We implemented a system for this along the following lines: Added a property to the users Profile to hold their session ID. Whenever a user logs in, store their session ID in the Profile. On any page that requires a this level of security, check to see if the session ID stored in the profile matches their session. This check could be performed in a custom AuthorizeRequest event handler, or it could be performed in a Base class that these pages derive from, and if not, redirect them to the login page. We went for the base class option as we have two levels of authentication: The user has a cookie token to prove that they have logged in at some point in the past - this is fine for showing them restricted site content. The user has actually provided their login details this session - this is required when showing them any personal details (email addresses, preferences, saved job searches, etc). The main issues you'll find with almost any system: Using the users IP address is unreliable - corporate users, those behind proxies, etc, often share an IP address, so would "appear" to be the same user. Relying on a user to log out is unreliable - the users computer/browser might crash not giving them the opportunity to log out, the user can/will forget to log out. Relying on session time-outs is unreliable - if you're not using InProc sessions, the SessionEnd event never fires, if your server crashes the event isn't called, etc. The issues you'll find with a solution like mine are: It doesn't stop the second user logging in - instead it will lock out the first user, which should discourage sharing of details in the first place. If you don't implement this as an AuthorizeRequest handler you have to remember perform the check on the pages that should be locked down. Responding to comment In response to your specific queries: The default Profile Provider stores the data in the same SQL database as the membership provider (the tables are created along with the membership and roles tables). If you were to store it "in the cache" this would need to be the global application cache, along the lines KMan suggests in option 2 - and as pointed out the comments, you'd need to build a time-out for this, and that leads back to the issue of reliably determining this. The user doesn't log out: This is handled in our system by not locking out future users, but by locking out previously logged in users - so: Alice comes to the site, logs in, starts browsing. Bob comes to the site, and logs in with Alice's details, starts browsing. Alice tries to continue browsing, is locked out, has to log in again. Bob is now locked out. etc. At its most basic, this won't stop the users sharing their logins, but will cause them annoyance, forcing them to keep logging in. If you need to you can add a delay to the login process - so if a different session id attempts to log into the site within the session time-out (defaults to 20 minutes) or some other time, say based on the average time a user spends on a page, then deny the login attempt.
