[site]: stackoverflow
[post_id]: 1167148
[parent_id]: 1166677
[tags]: 
Wow - what serendipity - I had just recently posted a question about opaque keys in C# ... and because I'm trying to implement something related to function result caching. How funny. This type of metaprogramming can be tricky with C# ... especially because generic type parameters can result in awkward code duplication. You often end up repeating almost the same code in multiple places, with different type parameters, to achieve type safety. So here's my variation on your approach that uses my opaque key pattern and closures to create cacheable functions. The sample below demonstrates the pattern with either one or two arguments, but it's relatively easy to extend to more. It also uses extension methods to create a transparent pattern for wrapping a Func<> with a cachable Func<> using the AsCacheable() method. Closures capture the cache that is associated with the function - and make it's existence transparent to other callers. This technique has many of the same limitations as your approach (thread safety, holding on to references, etc) - I suspect they aren't too hard to overcome - but it DOES support an easy way to extend to multiple parameters, and it allows cacheable functions to be completely substitutable with regular ones - since they are just a wrapper delegate. It's also worth noting that if you create a second instance of the CacheableFunction - you get a separate cache. This can be both a strength and a weakness ... since it some situations you may not realize this is happening. Here's the code: public interface IFunctionCache { void InvalidateAll(); // we could add more overloads here... } public static class Function { public class OpaqueKey { private readonly object m_Key; public A First { get; private set; } public B Second { get; private set; } public OpaqueKey(A k1, B k2) { m_Key = new { K1 = k1, K2 = k2 }; First = k1; Second = k2; } public override bool Equals(object obj) { var otherKey = obj as OpaqueKey ; return otherKey == null ? false : m_Key.Equals(otherKey.m_Key); } public override int GetHashCode() { return m_Key.GetHashCode(); } } private class AutoCache : IFunctionCache { private readonly Dictionary m_CachedResults = new Dictionary (); public bool IsCached( TArgs arg1 ) { return m_CachedResults.ContainsKey( arg1 ); } public TR AddCachedValue( TArgs arg1, TR value ) { m_CachedResults.Add( arg1, value ); return value; } public TR GetCachedValue( TArgs arg1 ) { return m_CachedResults[arg1]; } public void InvalidateAll() { m_CachedResults.Clear(); } } public static Func AsCacheable ( this Func function ) { IFunctionCache ignored; return AsCacheable( function, out ignored ); } public static Func AsCacheable ( this Func function, out IFunctionCache cache) { var autocache = new AutoCache (); cache = autocache; return (a => autocache.IsCached(a) ? autocache.GetCachedValue(a) : autocache.AddCachedValue(a, function(a))); } public static Func AsCacheable ( this Func function ) { IFunctionCache ignored; return AsCacheable(function, out ignored); } public static Func AsCacheable ( this Func function, out IFunctionCache cache ) { var autocache = new AutoCache , TR>(); cache = autocache; return ( a, b ) => { var key = new OpaqueKey ( a, b ); return autocache.IsCached(key) ? autocache.GetCachedValue(key) : autocache.AddCachedValue(key, function(a, b)); }; } } public class CacheableFunctionTests { public static void Main( string[] args ) { Func Reversal = s => new string( s.Reverse().ToArray() ); var CacheableReverse = Reversal.AsCacheable(); var reverse1 = CacheableReverse("Hello"); var reverse2 = CacheableReverse("Hello"); // step through to prove it uses caching Func Average = (a,b) => (a + b)/2.0; var CacheableAverage = Average.AsCacheable(); var average1 = CacheableAverage(2, 4); var average2 = CacheableAverage(2, 4); } }
