[site]: stackoverflow
[post_id]: 2132140
[parent_id]: 2132114
[tags]: 
Recursion is a tool like any other. You don't have to use every tool that's available but you should at least understand it. Recursion makes a certain class of problems very easy and elegant to solve and your "hatred" of it is irrational at best. It's just a different way of doing things. The "canonical" recursive function (factorial) is shown below in both recursive and iterative forms and, in my opinion, the recursive form more clearly reflects the mathematical definition of f(1) = 1, f(n) = n*f(n-1) for n>1 . Iterative: Recursive: def fact(n): def fact(n): r = n if n == 1: while n > 1: return 1 r = r * n return n * fact(n-1) n = n - 1 return r Pretty much the only place I would prefer an iterative solution to a recursive one (for solutions that are really well suited for recursion) is when the growth in stack size may lead to problems (the above factorial function may well be one of those since stack growth depends on n but it may also be optimised to an iterative solution by the compiler). But this stack overflow rarely happens since: Most stacks can be configured where necessary. Recursion (especially tail-end recursion where the recursive call is the last thing that happens in the function) can usually be optimised to an iterative solution by an intelligent compiler. Most algorithms I use in recursive situations (such as balanced trees and so on, as you mention) tend to be O(logN) and stack use doesn't grow that fast with increased data. For example, you can process a 16-way tree storing two billion entries with only seven levels of stack (16 7 =~ 2.6 billion).
