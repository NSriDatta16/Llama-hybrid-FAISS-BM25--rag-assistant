[site]: stackoverflow
[post_id]: 1631702
[parent_id]: 1631425
[tags]: 
There is not an easy solution to this problem. You can usually create separate structures and tell the compiler to pack them tightly, something like: /* GNU has attributes */ struct PackedData { char cmember; int imember; } __attribute__((packed)); or: /* MSVC has headers and #pragmas */ #include struct PackedData { char cmember; int imember; }; #include Then you have to write code that transforms your unpacked structures into packed structures and vice-versa. If you are using C++, you can create template helper functions that are predicated on the structure type and then specialize them: template std::ostream& encode_to_stream(std::ostream& os, T const& object) { return os.write((char const*)&object, sizeof(object)); } template std::istream& decode_from_stream(std::istream& is, T& object) { return is.read((char*)&object, sizeof(object)); } template<> std::ostream& encode_to_stream (std::ostream& os, Data const& object) { encode_to_stream (os, object.cmember); encode_to_stream (os, object.imember); return os; } template <> std::istream& decode_from_stream (std::istream& is, Data& object) { decode_from_stream (is, object.cmember); decode_from_stream (is, object.imember); return is; } The bonus is that the defaults will read and write POD objects including the padding. You can specialize as necessary to optimize your storage. However, you probably want to consider endianess, versioning, and other binary storage issues as well. It might be prudent to simply write an archival class that wraps your storage and provides methods for serialization and deserialization of primitives and then an open ended method that you can specialize as needed: class Archive { protected: typedef unsigned char byte; void writeBytes(byte const* byte_ptr, std::size_t byte_size) { m_fstream.write((char const*)byte_ptr, byte_size); } public: template void writePOD(T const& pod) { writeBytes((byte const*)&pod, sizeof(pod)); } // Users are required to specialize this to use it. If it is used // for a type that it is not specialized for, a link error will occur. template void serializeObject(T const& obj); }; template<> void Archive::serializeObject (Data const& obj) { writePOD(cmember); writePOD(imember); } This is the approach that I have always ended up at after a bunch of perturbations in between. It is nicely extensible without requiring inheritance and gives you the flexibility to change your underlying data storage format as needed. You can even specialize writePOD to do different things for different underlying data types like ensuring that multibyte integers are written in network order or whatnot.
