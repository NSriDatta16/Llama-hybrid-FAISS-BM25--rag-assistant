[site]: stackoverflow
[post_id]: 1264686
[parent_id]: 1264661
[tags]: 
If your hashCode() method returns a constant value all your keys will hash to the same bucket in the HashMap , effectively reducing your HashMap to be a linked list, with access time O(n) (instead of approximating O(1)). One possible solution (not space-efficient): For each string store multiple keys corresponding to the possible String prefices, but all referencing the same value . For example, for the word "Hello" you would store keys "H", "He", "Hel", "Hell", "Hello". This would obviously consume more space but look-up time would be very fast and you would not need to botch the class's equals() method to perform a "fuzzy" comparison. You could improve space efficiency by writing a custom class; e.g. /** * Class representing String prefix. * Storage overhead == original string + two ints. */ public class Prefix { private final String str; private final int len; private final int hc; public Prefix(String str, int len) { this.str = str; this.len = len; this.hc = toString().hashCode(); // Precompute and store hash code. } public String toString() { return str.substring(0, len); } public int hashCode() { return hc; } public boolean equals(Object o) { boolean ret; if (this == o) { ret = true; } else if (o instanceof Prefix) { ret = toString().equals(((Prefix)o).toString()); } else { ret = false; } return ret; } }
