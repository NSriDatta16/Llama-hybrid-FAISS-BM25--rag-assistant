[site]: stackoverflow
[post_id]: 810939
[parent_id]: 810657
[tags]: 
The question cannot easily be answered for the simple reason that the performance of one algorithm relative to another depends as much the on compiler / processor / data structure combination as on the algorithm itself, as you surely know Therefore your approach to try a couple of them seems good enough. And yes, quicksort should be pretty fast. If you haven't done so, you might want to try insertionsort which often performs better on small data sets. This said, just settle on a sorting algo that does the job fast enough. You will typically not get 10-times faster just be picking the "right" algo. To get substantial speed-ups, the better way frequently is to use more structure. Some ideas that worked for me in the past with large-scale problems: Can you efficiently pre-calculate while creating the voxels and store 28 instead of 27 floats? Is an approximate solution good enough? If so, just look at the median of, say 9 values, since "in general it can be expected that values are relatively close." Or you can replace it with the average as long as the values are relatively close. Do you really need the median for all billions of voxels? Maybe you have an easy test whether you need the median, and can then only calculate for the relevant sub-set. If nothing else helps: look at the asm code that the compiler generates. You might be able write asm code that is substantially faster (e.g. by doing all the calcs using registers). Edit: For what it's worth, I have attached the (partial) insertionsort code mentioned in the comment below (totally untested). If numbers[] is an array of size N , and you want the smallest P floats sorted at the beginning of the array, call partial_insertionsort (numbers); . Hence if you call partial_insertionsort (numbers); , numbers[13] will contain the median. To gain additional speed, you would have to unfold the while loop, too. As discussed above, to get really fast, you have to use your knowledge about the data (e.g. is the data already partially sorted? Do you know properties of the distribution of the data? I guess, you get the drift). template class Tag{}; template inline void partial_insertionsort_for(T a[], Tag , Tag ) { long j = i 0) { a[j] = a[j - 1]; j--;} a[j] = temp; partial_insertionsort_for (a,Tag (),Tag ());} template inline void partial_insertionsort_for(T a[], Tag , Tag ){} template inline void partial_insertionsort(T a[]) {partial_insertionsort_for (a, Tag (), Tag ());}
