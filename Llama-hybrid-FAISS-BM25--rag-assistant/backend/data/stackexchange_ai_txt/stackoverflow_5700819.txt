[site]: stackoverflow
[post_id]: 5700819
[parent_id]: 
[tags]: 
looking for a proper way to implement my generic factory

I'm struggling with implementing a factory object. Here's the context : I've in a project a custom store. In order to read/write records, I've written this code in a POCO model/separated repository: public class Id { /* skip for clarity*/} // My custom ID representation public interface IId { Id Id { get; set; } } public interface IGenericRepository where T : IId { T Get(Id objectID); void Save(T @object); } public interface IContext { TRepository GetRepository () where TRepository : IGenericRepository where T:IId; IGenericRepository GetRepository () where T:IId; } My IContext interface defines two kind of repositories. The former is for standard objects with only get/save methods, the later allows me to define specifics methods for specific kind of objects. For example : public interface IWebServiceLogRepository : IGenericRepository { ICollection GetOpenLogs(Id objectID); } And it the consuming code I can do one of this : MyContext.GetRepository ().Get(myID); --> standard get MyContext.GetRepository ().GetOpenLogs(myID); --> specific operation Because most of objects repository are limited to get and save operations, I've written a generic repository : public class BaseRepository : IGenericRepository where T : IId, new() { public virtual T Get(Id objectID){ /* provider specific */ } public void Save(T @object) { /* provider specific */ } } and, for custom ones, I simply inherits the base repository : internal class WebServiceLogRepository: BaseRepository , IWebServiceLogRepository { public ICollection GetByOpenLogsByRecordID(Id objectID) { /* provider specific */ } } Everything above is ok (at least I think it's ok). I'm now struggling to implement the MyContext class. I'm using MEF in my project for other purposes. But because MEF doesn't support (yet) generic exports, I did not find a way to reach my goal. My context class is looking like by now : [Export(typeof(IContext))] public class UpdateContext : IContext { private System.Collections.Generic.Dictionary m_Implementations; public UpdateContext() { m_Implementations = new System.Collections.Generic.Dictionary (); } public TRepository GetRepository () where T : IId where TRepository : IGenericRepository { var tType = typeof(T); if (!m_Implementations.ContainsKey(tType)) { /* this code is neither working nor elegant for me */ var resultType = AppDomain.CurrentDomain.GetAssemblies().SelectMany( (a) => a.GetTypes() ).Where((t)=>t.GetInterfaces().Contains(typeof(TRepository))).Single(); var result = (TRepository)resultType.InvokeMember("new", System.Reflection.BindingFlags.CreateInstance, null, null, new object[] { this }); m_Implementations.Add(tType, result); } return (TRepository)m_Implementations[tType]; } public IGenericRepository GetRepository () where T : IId { return GetRepository >(); } } I'd appreciate a bit of help to unpuzzle my mind with this quite common scenario
