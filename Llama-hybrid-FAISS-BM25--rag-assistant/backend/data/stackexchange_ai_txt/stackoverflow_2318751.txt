[site]: stackoverflow
[post_id]: 2318751
[parent_id]: 2318617
[tags]: 
The basic idea of recursion is you use the stack as a temporary store for variables on each call. However, you are referencing a global variable in your recursive call. When you change it (via the filter function) it will invalidate all prior calls in the recursion. You need to remove the recursion or push a new copy (and not a reference like you are doing) of the control variable (the rows) on the stack. edit based on comment I hate putting code out there without being able to test it, but I believe something like this should work to solved the problem I described. Here is the problem area: // using the Find method uses a Predicate generic delegate. if (nodeList.Find(FindNode) == null) { var tmpCNoteID = dr["CaseNoteID"].ToString(); var filter = "ParentNote='" + tmpCNoteID + "'"; DataRow[] childRows = cNoteDT.Select(filter); if (childRows.Length > 0) { // Recursively call this function for all childRows TreeNode[] childNodes = RecurseRows(childRows); // Add all childnodes to this node node.Nodes.AddRange(childNodes); } // Mark this noteID as dirty (already added) nodeList.Add(node); } Something like this should fix the problem I see (note: this is not elegant or good code, it is just a fix to the problem I describe above, I would never put my name to this code). Also, without being able to test the code I can't even be sure this is the problem. // using the Find method uses a Predicate generic delegate. if (nodeList.Find(FindNode) == null) { var tmpCNoteID = dr["CaseNoteID"].ToString(); var filter = "ParentNote='" + tmpCNoteID + "'"; DataTable DTCopy = cNoteDT.Copy() DataRow[] childRows = DTCopy.Select(filter); if (childRows.Length > 0) { // Recursively call this function for all childRows TreeNode[] childNodes = RecurseRows(childRows); // Add all childnodes to this node node.Nodes.AddRange(childNodes); } // Mark this noteID as dirty (already added) nodeList.Add(node); }
