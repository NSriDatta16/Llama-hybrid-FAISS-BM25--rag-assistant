[site]: stackoverflow
[post_id]: 3315679
[parent_id]: 3314822
[tags]: 
Let's see if I understand your question. You're expecting to capture two Tree entities from each native query result row. The first entity should be formed from t1 's columns. The second entity should be formed from t2 's columns. Contrary to expectation, you actually receive two instances formed from t1 . No instances from t2 appear. You made a doppelganger Entity for Tree called TreeSelf while debugging, but TreeSelf is ultimately unnecessary and you want to get rid of it. Stop me if any of that was wrong. I think the problem is due to ambiguous column names. Each column name in the native query appears twice, once from t1 and once from t2 . The result mapper seems to be arbitrarily picking the first occurrence of each ambiguous column name for both Tree entities. I'm surprised that works at all. I would have expected an SQLException complaining about column reference ambiguity. Also, are you sure you want a left outer join? What if no match is found for a t1 row? It will be paired with all NULL in t2 's columns. Then you have a null-valued Tree entity. I think. I don't even know what the result mapper would do in that case. Perhaps you want an inner join? Consider translating this native query into a JPQL query. (JPA Criteria API is just as well, but I find it more cumbersome for examples.) Here's a JPQL version of the native query: SELECT t1, t2 FROM Tree t1, Tree t2 WHERE t2.lft t1.rgt AND t2.regCodePar = 'ALL' AND t1.statusCode = 'A' AND t2.statusCode = 'A' N.B. : This changes the join semantics to inner instead of left outer. Here's a sketch of code that could run this query: EntityManager em = ... // EntityManager by injection, EntityManagerFactory, etc. String jpql = ... // Like example above TypedQuery q = em.createQuery(jpql, Object[].class); for (Object[] oa : q.getResultList()) { Tree t1 = (Tree)oa[0]; Tree t2 = (Tree)oa[1]; } In case you are stuck with the native query for whatever reason, here's how you can work around the column name ambiguity. Instead of starting the native query like select t1.*, t2.* , alias each column with AS . The SELECT clause would resemble this: SELECT t1.REG_CODE AS t1_REG_CODE, t1.RGT AS t1_RGT, (... rest of t1 cols ...), t2.REG_CODE AS t2_REG_CODE, t2.RGT AS t2_RGT, (... rest of t2 cols ...) The column attribute in each FieldResult must change accordingly. So the column attributes under the first EntityResult should all start with t1_ and the second's should all start with t2_ . I'd humbly recommend deleting the native query and sql result mapper and using JPA Query Language or Criteria API, if you can find a way. Update : As confirmed in your comments, a useful answer to your question must preserve left (outer) join semantics. Unfortunately, JPQL and the Criteria API don't support complex left join conditions. There is no way to qualify a JPQL left join with an explicit ON condition. To my knowledege, the only way to do a left outer join under the spec is by traversing an entity relationship. The JPA implementation then generates an ON condition that tests identity equality. The relevant spec bits are 4.4.5 "Joins" and 4.4.5.2 "Left Outer Joins". To satisfy this constraint, each Tree you want to left-join to its ultimate parent must have an additional column storing the ultimate parent's id. You might be able to cheat around this constraint in a variety of ways (views?). But the path of least resistance seems to be modifying the native query to use aliased arguments, deleting TreeSelf, and updating the result mapper accordingly. Cleverer solutions welcome, though...
