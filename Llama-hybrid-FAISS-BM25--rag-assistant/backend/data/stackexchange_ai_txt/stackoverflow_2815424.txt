[site]: stackoverflow
[post_id]: 2815424
[parent_id]: 2815083
[tags]: 
You can try a string-matrix: 0,1: A 1,5: APPLE 2,5: AXELS 3,5: EAGLE 4,5: HELLO 5,5: WORLD 6,6: ORANGE 7,8: LONGWORD 8,13:SUPERLONGWORD Let's call this a ragged index-matrix, to spare some memory. Order it on length, and then on alphabetical order. To address a character I use the notation x,y:z : x is the index, y is the length of the entry, z is the position. The length of your string is f and g is the number of entries in the dictionary. Create list m , which contains potential match indexes x . Iterate on z from 0 to f . Is it a wildcard and not the latest character of the search string? Continue loop (all match). Is m empty? Search through all x from 0 to g for y that matches length. !!A!! Does the z character matches with search string at that z ? Save x in m . Is m empty? Break loop (no match). Is m not empty? Search through all elements of m . !!B!! Does not match with search? Remove from m . Is m empty? Break loop (no match). A wildcard will always pass the "Match with search string?". And m is equally ordered as the matrix. !!A!!: Binary search on length of the search string. O(log n) !!B!!: Binary search on alphabetical ordering. O(log n) The reason for using a string-matrix is that you already store the length of each string (because it makes it search faster), but it also gives you the length of each entry (assuming other constant fields), such that you can easily find the next entry in the matrix, for fast iterating. Ordering the matrix isn't a problem: since this has only be done once the dictionary updates, and not during search-time.
