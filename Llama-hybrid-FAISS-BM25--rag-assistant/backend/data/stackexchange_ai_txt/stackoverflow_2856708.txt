[site]: stackoverflow
[post_id]: 2856708
[parent_id]: 2737500
[tags]: 
I ended up using Danvil 's approach. I wrapped the C code in a C++ dll and then I made another C# dll that referenced the C++ dll and exposed the functionality that I wanted in managed code. So here it is: C++ dll: .h File // Definition of a callback function to be called when some data arrives typedef void (*FncDlg) (const unsigned char*, int len); // Declaration of the function that will be exposed in managed code. // The managed code will use this function to pass in a delegate extern "C" __declspec(dllexport) void AttachCallback(FncDlg f); // Declaration of a function that receives data and passes it to managed code void PassData(const unsigned char *Body, int BodyLen); .cpp File // Instantiate a global function pointer to nothing void (*callback)(const unsigned char*, int len) = 0; // This is called by C# to pass in a delegate void AttachCallback(FncDlg f) { // Save delegate globally (to be triggered later when we receive data) callback = f; } // This is the function called when data is read from the socket void PassData(const unsigned char *Body, int BodyLen) { if(callback) { callback(Body, BodyLen); } } C# dll: public static class Parser { public delegate void DlgDumpTipData(IntPtr a, int len); [DllImport("C++ dll name here", EntryPoint = "AttachCallback", ExactSpelling = true)] public static extern void AttachCallback(DlgDumpTipData callback); public static int ConnectAndStartReceive(...) { // Attach a callback function (called when a message is received from data feed) AttachCallback(DumpDataCalback); ... } public delegate void MsgHandler(string msg); // When data arrives from the C library, this event passes it on to C# clients public static event MsgHandler OnMessageArrived = delegate { }; public static void DumpDataCalback(IntPtr ptr, int len) { //string str = Marshal.PtrToStringAnsi(ptr); string dumpData; sbyte[] byteArr = new sbyte[len]; for (int i = 0; i 127 we have a problem when casting from Byte to SByte // In this case there is no problem, tested with values over 127 and it // converts fine to Latin-1 using the String overload byteArr[i] = (sbyte)Marshal.ReadByte(ptr, i); } unsafe { fixed (sbyte* pbyteArr = byteArr) // Instruct the GC not to move the memory { dumpData = new String(pbyteArr, 0, len, Encoding.GetEncoding("ISO-8859-1")); } } // Send data to whoever subscribes to it OnMessageArrived(dumpData); GC.Collect(); // This slows things down but keeps the memory usage low } }
