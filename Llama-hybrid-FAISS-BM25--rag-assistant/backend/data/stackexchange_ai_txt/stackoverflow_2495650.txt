[site]: stackoverflow
[post_id]: 2495650
[parent_id]: 2495550
[tags]: 
This works (tested in irb): NOTE: This changes only str - not all instances of String. Read below for details as to why this works another_str = "please don't change me!" str = "ha, try to change my to_s! hahaha!" proc = Proc.new { "take that, Mr. str!" } singleton_class = class "take that, Mr. str!" puts another_str.to_s #=> "please don't change me!" # What! We called String#define_method, right? puts String #=> String puts singleton_class #=> # > # ... nope! singleton_class is *not* String # Keep reading if you're curious :) This works because you are opening str's singleton class and defining a method there. Because this, as well as the call to Module#define_method , have what some call a "flat scope", you're able to access variables that would be out of scope if you used def to_s; 'whatever'; end . You may want to check out some of these other "metaprogramming spells" here: media.pragprog.com/titles/ppmetr/spells.pdf Why does it only change str ? Because Ruby has a couple interesting tricks up it's sleeves. In the Ruby object model, a method invocation results in the reciever searching not only it's class (and it's ancestors), but also it's singleton class (or as Matz would call it, it's eigenclass). This singleton class is what allows you to [re]define a method for a single object. These methods are called "singleton methods". In the example above, we are doing just that - defining a singleton method name to_s . It's functionaly identical to this: def str.to_s ... end The only difference is that we get to use a closure when calling Module#define_method , whereas def is a keyword, which results in a change of scope. Why can't it be simpler? Well, the good news is that you're programming in Ruby, so feel free to go crazy: class Object def define_method(name, &block) singleton = class hello puts str.bark #=> woof! puts str.yell #=> AAAH! And, if you're curious... You know class methods? Or, in some languages, we'd call them static methods? Well, those don't really exist in Ruby. In Ruby, class methods are really just methods defined in the Class object's singleton class. If that all sounds crazy, take a look at the links I provided above. A lot of Ruby's power can only be tapped into if you know how to metaprogram - in which case you'll really want to know about singleton classes/methods, and more generally, the Ruby object model. HTH -Charles
