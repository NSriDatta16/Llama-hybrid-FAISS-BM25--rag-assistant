[site]: stackoverflow
[post_id]: 1705472
[parent_id]: 1705449
[tags]: 
Various observations Don't make the pipes non-blocking; you want the children to block when there's no data. At least, in the early phases of the design; later, you may want to let them get on with work when there's no data waiting. You need to be careful with your plumbing. The parent needs 10 pipes, one for each child. But it only needs the write end of the pipe, not the read end. The children each need one pipe, for reading. Any superfluous pipes (for example, the write ends of the pipes that the parent had already opened before forking the Nth child) need to be closed. You could consider using threads - in which case you could perhaps pass the data to the children. But in the long term, it appears that you will be periodically passing data to the children, and then you need a mechanism to get the data to them (other than the function call). Pipes are 'easy' as long as you pay meticulous attention to which file descriptors are in use. Close all the descriptors you do not need. The parent will have to loop around all ten pipes writing the same data to each. It will also need to consider what to do if a child exits. It should close the pipe (no use any more), and decide whether to start a new child (but how will it ensure that the new child has all the accumulated information it needs?). Watch out for SIGPIPE - maybe install a handler, or maybe use SIG_IGN and detect write errors instead of signals. Working code #include #include #include #include #include enum { NUM_CHILDREN = 10 }; enum { NUM_MESSAGES = 10 }; static int write_pipes[NUM_CHILDREN]; static int n_pipes; static void be_childish(int *pipe) { int i; char buffer[32]; int nbytes; int pid = getpid(); close(pipe[1]); for (i = 0; i 0) { printf("Child %d: %d %.*s\n", pid, nbytes, nbytes, buffer); fflush(0); } printf("Child %d: finished\n", pid); exit(0); } int main(void) { pid_t pid; int i, j; /* Create the pipes and the children. */ for (i = 0; i
