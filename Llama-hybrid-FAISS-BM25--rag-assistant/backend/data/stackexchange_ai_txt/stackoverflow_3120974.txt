[site]: stackoverflow
[post_id]: 3120974
[parent_id]: 3120951
[tags]: 
You need the template keyword template template struct A ::B : C ::template T > { int foo; }; GCC is correct to give a diagnostic here. This is because T cannot be looked up in the dependent scope D . The meaning of the after it depends on whether T is a template or not. The Standard says that T shall be assumed to be not a template and thus T cannot be followed by a template argument list. template is like typename in that it tells the compiler to treat T as a template and that the is the start of an argument list in any case. The Standard says in paragraphs 14.2/2 and 14.2/4 For a template-name to be explicitly qualified by the template arguments, the name must be known to refer to a template. When the name of a member template specialization appears after . or -> in a postfix-expression, or after nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2), the member template name must be prefixed by the keyword template. Otherwise the name is assumed to name a non-template. In your case, you have T appear after the nested-name-specifier D which depends on the template-parameter TA . For the typename-specifier to parse correctly, the construct D ::T must interpret T as the name of a class template, which 14.2 forbids. On that topic, it's always a good idea to try and compile with Clang main1.cpp:21:37: error: use 'template' keyword to treat 'T' as a dependent template name struct A ::B : C ::T > ^ template 1 error generated.
