[site]: stackoverflow
[post_id]: 1205328
[parent_id]: 
[tags]: 
Scheduling issues in python

I'm using python to interface a hardware usb sniffer device with the python API provided by the vendor and I'm trying to read (usb packets) from the device in a separate thread in an infinite loop (which works fine). The problem is that my main loop does not seem to ever get scheduled again (my read loop gets all the attention). The code looks much like this: from threading import Thread import time usb_device = 0 def usb_dump(usb_device): while True: #time.sleep(0.001) packet = ReadUSBDevice(usb_device) print "packet pid: %s" % packet.pid class DumpThread(Thread): def run(self): usb_dump() usb_device = OpenUSBDevice() t = DumpThread() t.start() print "Sleep 1" time.sleep(1) print "End" CloseUSBDevice(usb_device) sys.exit(0) (I could paste actual code, but since you need the hardware device I figure it won't help much). I'm expecting this code to start dumping usb packets for about a second before the main thread terminates the entire program. However, all I see is "Sleep 1" and then the usb_dump() procedure runs forever. If I uncomment the "time.sleep(0.001)" statement in the inner loop of the usb_dump() procedure things start working the way I expect, but then the python code becomes unable to keep up with all the packets coming in :-( The vendor tells me that this is an python scheduler problem and not their api's fault and therefor won't help me: «However, it seems like you are experiencing some nuances when using threading in Python. By putting the time.sleep in the DumpThread thread, you are explicitly signaling to the Python threading system to give up control. Otherwise, it is up the Python interpreter to determine when to switch threads and it usually does that after a certain number of byte code instructions have been executed.» Can somebody confirm that python is the problem here? Is there another way to make the DumpThread release control? Any other ideas?
