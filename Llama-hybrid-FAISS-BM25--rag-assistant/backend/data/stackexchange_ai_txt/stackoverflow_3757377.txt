[site]: stackoverflow
[post_id]: 3757377
[parent_id]: 3757147
[tags]: 
Based on what it's said on the documentation, by using the class method from NSEntityDescription to instantiate the NSManagedObject it's possible to do it without declaring/importing its header. By setting the name of the class you will get back a "fully configured instance" of the object. It's useful on early stages of development when things are changing constantly but it can be a risk factor since you don't get any compilation errors or warnings if you misspell the name of your class, since it's a string. The method from NSManagedObject needs that the interface of the specific class imported to your file, and make it more robust against errors, since the compiler can check if that class exist. For instance they will have the same result, they will return an instance of the specified class. Although the retain counts will be different: - initWithEntity:insertIntoManagedObjectContext: (retain count == +1) + insertnewObjectForEntityForName:inManagedObjectContext: (retain count == 0) Here it is the documentation NSEntityDescription Class Reference ( insertNewObjectForEntityForName:inManagedObjectContext: ) Return Value A new, autoreleased, fully configured instance of the class for the entity named entityName. The instance has its entity description set and is inserted it into context. Discussion This method makes it easy for you to create instances of a given entity without worrying about the details of managed object creation. The method is particularly useful on Mac OS X v10.4, as you can use it to create a new managed object without having to know the class used to represent the entity. This is especially beneficial early in the development life-cycle when classes and class names are volatile. On Mac OS X v10.5 and later and on iOS, you can instead use initWithEntity:insertIntoManagedObjectContext: which returns an instance of the appropriate class for the entity. NSManagedObject Class Reference ( initWithEntity:insertIntoManagedObjectContext: ) Return Value An initialized instance of the appropriate class for entity. Discussion NSManagedObject uses dynamic class generation to support the Objective-C 2 properties feature (see “Declared Properties”) by automatically creating a subclass of the class appropriate for entity.initWithEntity:insertIntoManagedObjectContext: therefore returns an instance of the appropriate class for entity. The dynamically-generated subclass will be based on the class specified by the entity, so specifying a custom class in your model will supersede the class passed to alloc. If context is not nil, this method invokes [context insertObject:self] (which causes awakeFromInsert to be invoked). You are discouraged from overriding this method—you should instead override awakeFromInsert and/or awakeFromFetch (if there is logic common to these methods, it should be factored into a third method which is invoked from both). If you do perform custom initialization in this method, you may cause problems with undo and redo operations. In many applications, there is no need to subsequently assign a newly-created managed object to a particular store—see assignObject:toPersistentStore:. If your application has multiple stores and you do need to assign an object to a specific store, you should not do so in a managed object's initializer method. Such an assignment is controller- not model-level logic.
