[site]: stackoverflow
[post_id]: 2775742
[parent_id]: 1994360
[tags]: 
Here's AutoHidingWindow - a subclass of SlidingWindow which pops up when the mouse hits the edge of the screen. Feedback welcome. @interface ActivationWindow : NSWindow { AutoHidingWindow *_activationDelegate; NSTrackingArea *_trackingArea; } - (ActivationWindow*)initWithDelegate:(AutoHidingWindow*)activationDelegate; @property (assign) AutoHidingWindow *activationDelegate; @property (retain) NSTrackingArea *trackingArea; - (void)adjustWindowFrame; - (void)adjustTrackingArea; @end @interface AutoHidingWindow () - (void)autoShow; - (void)autoHide; @end @implementation AutoHidingWindow - (id)initWithContentRect:(NSRect) contentRect styleMask:(unsigned int) styleMask backing:(NSBackingStoreType) backingType defer:(BOOL) flag { if ((self = [super initWithContentRect:contentRect styleMask:NSBorderlessWindowMask backing:backingType defer:flag])) { _activationWindow = [[ActivationWindow alloc] initWithDelegate:self]; } return self; } @synthesize activationWindow = _activationWindow; - (void)dealloc { [_activationWindow release], _activationWindow = nil; [super dealloc]; } - (void)makeKeyAndOrderFront:(id)sender { [super makeKeyAndOrderFront:sender]; } - (void)autoShow { [self makeKeyAndOrderFront:self]; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(autoHide) object:nil]; [self performSelector:@selector(autoHide) withObject:nil afterDelay:2]; } - (void)autoHide { NSPoint mouseLocation = [NSEvent mouseLocation]; NSRect windowFrame = [self frame]; if (NSPointInRect(mouseLocation, windowFrame)) { [self performSelector:@selector(autoHide) withObject:nil afterDelay:2]; } else { [self orderOut:self]; } } @end @implementation ActivationWindow - (ActivationWindow*)initWithDelegate:(AutoHidingWindow*)activationDelegate { if ((self = [super initWithContentRect:[[NSScreen mainScreen] frame] styleMask:NSBorderlessWindowMask backing:NSBackingStoreBuffered defer:NO]) != nil) { _activationDelegate = activationDelegate; [self setBackgroundColor:[NSColor clearColor]]; [self setExcludedFromWindowsMenu:YES]; [self setCanHide:NO]; [self setHasShadow:NO]; [self setLevel:NSScreenSaverWindowLevel]; [self setAlphaValue:0.0]; [self setIgnoresMouseEvents:YES]; [self setOpaque:NO]; [self orderFrontRegardless]; [self adjustWindowFrame]; [self.activationDelegate addObserver:self forKeyPath:@"slidingEdge" options:0 context:@"slidingEdge"]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(screenParametersChanged:) name:NSApplicationDidChangeScreenParametersNotification object:nil]; } return self; } @synthesize activationDelegate = _activationDelegate; @synthesize trackingArea = _trackingArea; - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if ([@"slidingEdge" isEqual:context]) { [self adjustTrackingArea]; } else { [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; } } - (void)dealloc { [[NSNotificationCenter defaultCenter] removeObserver:self]; [self.activationDelegate removeObserver:self forKeyPath:@"slidingEdge"]; _activationDelegate = nil; [_trackingArea release], _trackingArea = nil; [super dealloc]; } - (void)screenParametersChanged:(NSNotification *)notification { [self adjustWindowFrame]; } - (void)adjustWindowFrame { NSScreen *mainScreen = [NSScreen mainScreen]; CGFloat menuBarHeight = [NSMenuView menuBarHeight]; NSRect windowFrame = [mainScreen frame]; windowFrame.size.height -= menuBarHeight; [self setFrame:windowFrame display:NO]; [self adjustTrackingArea]; } - (void)adjustTrackingArea { NSView *contentView = [self contentView]; NSRect trackingRect = contentView.bounds; CGRectEdge slidingEdge = self.activationDelegate.slidingEdge; CGFloat trackingRectSize = 2.0; switch (slidingEdge) { case CGRectMaxXEdge: trackingRect.origin.x = trackingRect.origin.x + trackingRect.size.width - trackingRectSize; trackingRect.size.width = trackingRectSize; break; case CGRectMaxYEdge: trackingRect.origin.y = trackingRect.origin.y + trackingRect.size.height - trackingRectSize; trackingRect.size.height = trackingRectSize; break; case CGRectMinXEdge: trackingRect.origin.x = 0; trackingRect.size.width = trackingRectSize; break; case CGRectMinYEdge: default: trackingRect.origin.y = 0; trackingRect.size.height = trackingRectSize; } NSTrackingAreaOptions options = NSTrackingMouseEnteredAndExited | NSTrackingMouseMoved | NSTrackingActiveAlways | NSTrackingEnabledDuringMouseDrag; NSTrackingArea *trackingArea = self.trackingArea; if (trackingArea != nil) { [contentView removeTrackingArea:trackingArea]; } trackingArea = [[NSTrackingArea alloc] initWithRect:trackingRect options:options owner:self userInfo:nil]; [contentView addTrackingArea:trackingArea]; self.trackingArea = [trackingArea autorelease]; } - (void)mouseEntered:(NSEvent *)theEvent { [self.activationDelegate autoShow]; } - (void)mouseMoved:(NSEvent *)theEvent { [self.activationDelegate autoShow]; } - (void)mouseExited:(NSEvent *)theEvent { } @end
