[site]: stackoverflow
[post_id]: 147538
[parent_id]: 147351
[tags]: 
The meanings of wParam and lParam have changed in many places. I strongly encourage you to be paranoid and convert as much as possible to use message crackers . They will save you no end of headaches. If there is only one piece of advice I could give you, this would be it. As long as you're using message crackers, also enable STRICT . It'll help you catch the Win16 code base using int where it should be using HWND , HANDLE , or something else. Converting these will greatly help with #9 on this list. hPrevInstance is useless. Make sure it's not used. Make sure you're using Unicode-friendly calls. That doesn't mean you need to convert everything to TCHAR s, but means you better replace OpenFile , _lopen , and _lcreat with CreateFile , to name the obvious LibMain is now DllMain , and the entire library format and export conventions are different Win16 had no VMM. GlobalAlloc , LocalAlloc , GlobalFree , and LocalFree should be replaced with more modern equivalents. When done, clean up calls to LocalLock , LocalUnlock and friends; they're now useless. Not that I can imagine your app doing this, but make sure you don't depend on WM_COMPACTING while you're there. Win16 also had no memory protection. Make sure you're not using SendMessage or PostMessage to send pointers to out-of-process windows. You'll need to switch to a more modern IPC mechanism, such as pipes or memory-mapped files. Win16 also lacked preemptive multitasking. If you wanted a quick answer from another window, it was totally cool to call SendMessage and wait for the message to be processed. That may be a bad idea now. Consider whether PostMessage isn't a better option. Pointer and integer sizes change. Remember to check carefully anywhere you're reading or writing data to diskâ€”especially if they're Win16 structures. You'll need to manually redo them to handle the shorter values. Again, the least painful way to deal with this will be to use message crackers where possible. Otherwise, you'll need to manually hunt down and convert int to DWORD and so on where applicable. Finally, when you've nailed the obvious, consider enabling 64-bit compilation checks. A lot of the issues faced with going from 16 to 32 bits are the same as going from 32 to 64, and Visual C++ is actually pretty smart these days. Not only will you catch some lingering issues; you'll get yourself ready for your eventual Win64 migration, too. EDIT : As @ChrisN points out, the official guide for porting Win16 apps to Win32 is available archived, and both fleshes out and adds to my points above.
