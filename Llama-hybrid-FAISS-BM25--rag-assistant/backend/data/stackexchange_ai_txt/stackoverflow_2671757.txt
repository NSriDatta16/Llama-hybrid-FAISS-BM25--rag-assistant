[site]: stackoverflow
[post_id]: 2671757
[parent_id]: 2670031
[tags]: 
You can extract the common functionality into a separate module and make your apps depend on it: my_portal auth_module profiles_module application1 (depends on auth_module) application2 (depends on auth_module and profiles_module) I think the fact that a 'classical' Django project appear to 'contain' the apps it's using prevent you from seeing the picture - in fact, it's not necessary. For a project where you're going to have some sort of pluggable modules I'd suggest organizing the apps as eggs and using zc.buildout+djangorecipe to manage everything. This way you'll be able to keep your modules in a flat one-level structure. Eggs have the ability to specify dependencies, so if you install application1 (see above), auth_module will be installed automatically. Also it'll be easy to have different configurations deployed to different servers. Suppose, you have server1 which has application1 installed and server2 which has both application1 and application2 installed - you can just have two configs: server1.cfg: [buildout] extends = base_deployment.cfg eggs += application1 server2.cfg: [buildout] extends = base_seployment.cfg eggs += application1 application2 djangorecipe also allows you to specify different settings files for each buildout config so you'll be able to add the necessary bits to the main project's urls and installed apps settings. Not to mention, you can also have a separate config for development configuration (with debug=True and Django Debug Toolbar installed, for example).
