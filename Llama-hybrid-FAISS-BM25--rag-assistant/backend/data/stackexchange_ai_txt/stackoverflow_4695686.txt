[site]: stackoverflow
[post_id]: 4695686
[parent_id]: 4695021
[tags]: 
Here is a primitive example, that demonstrate how to create a thread that produces random numbers and puts them in a queue, and three consumer thread which extract random numbers from the queue and print them if the random numbers are odd only. This example can be vastly improved, and many best practices are not followed for the sake of explaining the basic facilities(thread_group, mutex and random number generation all using boost): #include #include #include #include #include #include std::queue random_stream; boost::mutex random_stream_mutex, output_mutex; // create a random number generator similar to good ol' std::rand! boost::mt19937 rand_generator; boost::uniform_int<> distribution; auto random_producer = boost::bind(distribution, rand_generator); bool isodd(int number) { return number % 2 == 1; } void random_generator() { for(;;) { // generate a random number, then lock the queue and push // the number into it. int random_number = random_producer(); random_stream_mutex.lock(); random_stream.push(random_number); random_stream_mutex.unlock(); } } void output_odd_randoms() { for(;;) { // lock the queue then extract the number. random_stream_mutex.lock(); int random_number = random_stream.front(); random_stream.pop(); random_stream_mutex.unlock(); // print the extracted number if it is odd! if(isodd(random_number)) { output_mutex.lock(); std::cout As you can see, the code uses global variables but encapsulating your data is a better idea. Also, using RAII locking mechanism is more elegant but modifying the code to add them is trivial. Hope that helps,
