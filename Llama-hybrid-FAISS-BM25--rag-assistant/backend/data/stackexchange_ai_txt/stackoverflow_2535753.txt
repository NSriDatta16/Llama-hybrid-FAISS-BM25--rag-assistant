[site]: stackoverflow
[post_id]: 2535753
[parent_id]: 2535501
[tags]: 
The only efficient way to do what you want is a lookup table (these can get complicated, before you embark on this, do some performance tests - the brute force search approaches listed here may work fine for you). The basic idea is that you keep a list of all the paragraphs where a particular word occurred. So, if "foobar" appeared in paragraphs 1, 2, and 7, we would want the following to be true: myLookupTable["foobar"] = [1,2,7]; If we do this for every word in every paragraph, we get a nice little list. This is the basic idea: var myHugeArray:Array = // fill your array data in here var lookup:Object = {}; // Now we iterate through each item in your array and index all the words that we find for (var idx:int in myHugeArray) { var par:String = myHugeArray[idx] as String; par = par.replace(/['",.;:-()!?]/g, " "); // remove common punctuation var words:Array = par.split(" "); // split the paragraph into specific words for each(var word:String in words) { if(lookup[word] == undefined} lookup[word] = []; lookup[word].push(idx); // record the index of the paragraph that contained the word } } // now do search for a word var results:Array = lookup["foobar"]; if(results != null) { for each(var idx:int in results) trace("Hit!", myHugeArray[idx]); } Now, you have to update your lookup table whenever you add or remove items from the array (not shown here). In addition, you may want to create a "stop list" of common words such as "the" and "a" that aren't indexed. Finally, this will only return exact matches on words. If you want to be able to type in "foob" and still get hits for "foobar", then you need to create within-word indexes, which are much more complex and memory-intensive.
