[site]: stackoverflow
[post_id]: 1549735
[parent_id]: 1548306
[tags]: 
Agreed to both answers so far; your assessment that Template #2 won't get processed as such is exactly right. Note that a node's children (i.e. its child elements, comments, text, and processing instructions, but not attributes) are only special in two ways: The default value of the select attribute is " node() ", the XPath for selecting children, and The built-in template rules for root nodes and element nodes is to process children. Other than in those two respects, children have no special status when it comes to selecting nodes to process. You can select whatever nodes you want, including ancestors. You can traverse a tree in any order you like. An extreme way to demonstrate this would be to write a stylesheet that reverses the hierarchy of a document (turns it upside down). (You'd probably want to use another mode so that a different rule is invoked when parent nodes are processed than when children are processed.) I also want to check and make sure you understand the distinction between the "root node" (renamed the "document node" in XPath/XSLT 2.0) and the root (or document) element . In your example XML, is not the root node; it's the outermost element , which itself is a child of the root node, the invisible outer container at the root of every tree in the XPath/XSLT data model. If you want to take control of processing right of the bat, you can always use or (assuming the source tree represents a well-formed XML document and not a fragment) . They're alternative ways to do it. One feature of the latter is that imported code that includes a rule for match="/" would be triggered earlier, since explicit template rules (even if they have the lowest import precedence) always take precedence over built-in template rules. If you don't explicitly have in the importing stylesheet, then, until you import code that has it, you're relying on the built-in template rule for root nodes (apply templates to children--in this case, apply templates to the element child). An alternative way to take control off the bat, for this example, would be to use match="/person". Such a rule would match any element, provided that it's the child of the root node. If the XML doesn't have as its outermost element, then it won't get invoked. And if you also have
