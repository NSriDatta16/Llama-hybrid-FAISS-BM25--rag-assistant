[site]: stackoverflow
[post_id]: 2878470
[parent_id]: 2878368
[tags]: 
The x86 has always had more than four registers. Originally, it has CS, DS, ES, SS, AX, BX, CX, DX, SI, DI, BP, SP, IP and Flags. Of those, seven (AX, BX, CX, DX, SI, DI, and BP) supported most general operations (addition, subtraction, etc.) BP and BX also supported use as "Base" register (i.e., to hold addresses for indirection). SI and DI can also be used as index registers, which are about the same as base registers, except that an instruction can generate an address from one base register and one index register, but NOT from two index registers or two base registers. At least in typical use, SP is devoted to acting as the stack pointer. Since then, the registers have gotten larger, more have been added, and some of them have become more versatile, so (for example) you can now use any 2 general-purpose registers in 2-register addressing modes. Somewhat strangely, two segment registers (FS and GS) were added in the 386, which also allowed 32-bit segments, which mostly rendered all the segment registers nearly irrelevant. They are sometimes used for thread-local storage. I should also add that when you do multi-tasking, multi-threading, etc., lots of registers can have a pretty serious penalty -- since you don't know which registers are in use, when you do a context switch you have to save all the registers in one task, and load all the saved registers for the next task. In a CPU like the Itanium or the SPARC with 200+ registers, this can be rather slow. Recent SPARCs devote a fair amount of chip area to optimizing this, but their task switches are still relatively slow. It's even worse on the Itanium -- one reason it's less than impressive on typical server tasks, even though it blazes on scientific computing with (very) few task switches. Finally, of course, all this is really quite different from how a reasonably modern implementation of x86 works. Starting with the Pentium Pro, Intel decoupled the architectural registers (i.e., the ones that can be addressed in an instruction) from the implementation. To support concurrent, out of order execution, the Pentium Pro had (if memory serves) a set of 40 internal registers, and used "register renaming" so two (or more) of those might correspond to a given architectural register at a given time. For example, if you manipulate a register, then store it, load a different value, and manipulate that, the processor can detect that the load breaks the dependency chain between those two sets of instructions, so it can execute both of those manipulations simultaneously. The Pentium Pro is now quite old, of course--and of course, AMD has also been around for a while (though their designs are reasonably similar in this respect). While the details change with new processors, having renaming capability that decouples architectural registers from physical registers is now more or less a fact of life.
