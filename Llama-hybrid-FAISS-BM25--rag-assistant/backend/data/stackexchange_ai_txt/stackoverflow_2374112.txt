[site]: stackoverflow
[post_id]: 2374112
[parent_id]: 2373411
[tags]: 
One way might be to create a derived TreeNode object, force it to contain a List : // requires declaration of : using System.Windows.Forms; // sample data class public class data { public string Name; public int ID; } public class XTreeNode : TreeNode { List theData = new List (); public XTreeNode(string theNodeID) { this.Text = theNodeID; } public void addData(data newData) { theData.Add(newData); } } Here's a (not elegant) sample of what building an instance of the above data structure might look like (on a WinForm) : assume you have a TreeView, named 'treeView1 on the Form : XTreeNode currentNode; data currentData; for (int i = 0; i of the derived TreeNode currentData = new data {Name = "one", ID = 100}; currentNode.addData(currentData); currentData = new data { Name = "two", ID = 200 }; currentNode.addData(currentData); currentData = new data { Name = "three", ID = 300 }; currentNode.addData(currentData); // sample of adding a child node currentNode.Nodes.Add(new XTreeNode((i * 100).ToString())); } For the question of how you woud visually display the List associated with each Node : the usual way would be to combine the Treeview with a ListView, and synchronize their locations and item heights : then display the List on the same "row" as the corresponding TreeNode. Of course you can implement your own Node and NodeCollection entities which are completely independent of any control : this example presents a mixed-case of relying on a .NET control to serve as both data structure and presentation mechanism. There's an excellent example of a combination TreeView/ListView on CodeProject that has been maintained, updated, and extended, for years : Phillip Piper's : "A Much Easier to Use ListView" , first published 2006, last update October, 2009 : its functionality is so rich that if compares favorably, imho, with commercial components.
