[site]: stackoverflow
[post_id]: 4928509
[parent_id]: 4928461
[tags]: 
You said: ... and correct me if I am wrong but I believe in a function and only in a function if you were to have some func(char x[]) and char func(char *x) they would be the same thing? So you can look at both of them as a char array. If it were outside the function definition char x[]; would be an char array and char *x; would be a pointer. It would be better to regard them both as pointers (rather than both as arrays) inside the function, but you've got the key point - in function argument lists, the distinctions between arrays and pointers are blurred, but elsewhere pointers and arrays are different. In the code, since itoa() is assumed to return an integer in the absence of information to the contrary, you cannot store that in a pointer or as a pointer (without using a sledgehammer cast, which would leave your code broken). What does itoa() return? It isn't a standard C function (as in, not in ISO/IEC 9899:1999, nor in POSIX). Wikipedia suggests it returns no value, so you should not be assigning its value anywhere. Linux has it as a non-standard extension in with a different interface that returns a char * (which is the value of its second argument). You can safely ignore the return value; in fact, you can also do the assignment (after including the header) but the assignment is a no-op. You do need to know that the function is non-standard, that it has a variety of definitions, and therefore you have to be aware of what is correct for your platform, or avoid using it (maybe by using snprintf() instead). Quoting the linked Linux manual page: char* itoa (int __val, char * __s, int __radix) Convert an integer to a string. The function itoa() converts the integer value from val into an ASCII representation that will be stored under s. The caller is responsible for providing sufficient storage in s. Note: The minimal size of the buffer s depends on the choice of radix. For example, if the radix is 2 (binary), you need to supply a buffer with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one character for each bit plus one for the string terminator. Using a larger radix will require a smaller minimal buffer size. Warning: If the buffer is too small, you risk a buffer overflow. Conversion is done using the radix as base, which may be a number between 2 (binary conversion) and up to 36. If radix is greater than 10, the next digit after '9' will be the letter 'a'. If radix is 10 and val is negative, a minus sign will be prepended. The itoa() function returns the pointer passed as s. You don't want to use n+1 as the radix.
