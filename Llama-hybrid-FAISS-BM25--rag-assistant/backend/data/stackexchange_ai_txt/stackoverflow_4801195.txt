[site]: stackoverflow
[post_id]: 4801195
[parent_id]: 4801089
[tags]: 
This can get kind of ugly. The compiler looks at the types of the operands for a single operation, and promotes both to the "larger" type (e.g., if one is int and the other double , it'll convert the int to double , then do the operation). In your case, that could have some rather unexpected results. Right now you have: 2*pi*j*X*Y/n . The operators group from left to right, so this is equivalent to ((((2*pi)*j)*X)*Y)/n . In this case, that'll probably work out reasonably well -- one of the operands in the "first" operation is a float, so all the other operands will be converted to float as you want. If, however, you rearrange the operands (even in a way that seems equivalent in normal math) the result could be completely different. Just for example, if you rearranged it to 2*Y/n*pi*j*X , the 2*Y/n part would be done using integer arithmetic because 2 , Y , and n are all integers. This means the division would be done on integers, giving an integer result, and only after that integer result was obtained would that integer be converted to a float for multiplication by pi . Bottom line: unless you're dealing with something like a large array so converting to smaller types is likely to really save quite a bit of memory, you're generally much better off keeping all the operands of the same type if possible. I'd also note that in this case, your attempt at "managing memory intelligently" probably won't do any good anyway -- on a typical current machine, a long int and a float are both 32 bits, so they both use the same amount of memory in any case. Also note that exp takes a double as its operand, so even if you do float math for the rest, it'll be promoted to a double anyway. Also note that conversions from int to float (and back) can be fairly slow. If you're really only dealing with a half dozen variables or so, you're almost certainly best off leaving them as double and being done with it. Converting to a combination of float and long will save about 14 bytes of data storage, but then add (around) 14 bytes of extra instructions to handle all the conversions between int , float , and double at the right times, so you'll end up with slower code that uses just as much memory anyway.
