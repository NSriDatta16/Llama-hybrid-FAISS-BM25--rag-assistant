[site]: stackoverflow
[post_id]: 3752695
[parent_id]: 3749168
[tags]: 
Let's start by looking at how the contents of i and p would be laid out in memory (assuming big-endian order): Item Address 0x00 0x01 0x02 0x03 ---- ------- ---------------------- i 0x08000000 0x00 0x00 0x00 0x28 p 0x08000004 0x?? 0x?? 0x?? 0x?? Since p is being declared as an auto variable, it's not initialized to anything and contains a random bit pattern represented by 0x?? . In the line p = (char *)&i; the expression &i evaluates to the address of i , or 0x08000000, and its type is pointer to int , or int * . The cast converts the type from int * to char * , and the result is assigned to p . Here's how things look in memory after the assignment: Item Address 0x00 0x01 0x02 0x03 ---- ------- ---------------------- i 0x08000000 0x00 0x00 0x00 0x28 p 0x08000004 0x08 0x00 0x00 0x00 So the value of p is now the address of i . In the line printf("%d", *p); the type of the expression *p is char , and its value is whatever is stored in address 0x08000000, which in this particular case is 0. Since printf is a variadic function, the value of *p is promoted from type char to type int . So for this particular case, the ouput is "0". If the order were little-endian, the map would look like Item Address 0x03 0x02 0x01 0x00 ---- ------- ---------------------- i 0x08000000 0x00 0x00 0x00 0x28 p 0x08000004 0x08 0x00 0x00 0x00 and the output would be "40". Note that this whole example assumes that integer and character pointers have the same size and layout; that's not guaranteed to be true everywhere (see the Online C Standard (n1256 draft) , section 6.2.5, paragraph 27), so you can't rely on this working everywhere the way you expect (assuming I'm correct in thinking that int and char are not compatible types as defined by the standard, but I could be wrong on that). Type punning in general is not safe.
