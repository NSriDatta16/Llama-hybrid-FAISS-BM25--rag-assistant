[site]: stackoverflow
[post_id]: 3864707
[parent_id]: 3864431
[tags]: 
The immediate problem is that you have: Arena: Campgrounds That is, there is no following the value for favorites such as Arena . Now, the correct way to do this would involve using a proper HTML parser. The fragile solution is to adapt your pattern (untested): my ($favarena) = $content =~ m{ Arena: ([^ That should put everything up to the of the next in $favarena . Now, if all arenas are single words with no spaces in them, my ($favarena) = $content =~ m{ Arena: (\S+)}; would save you the trouble of having to trim whitespace afterwards. Note that it is easy for such regex based solutions to be fooled with simple things like commented out snippets in the source. E.g., if the source were to be changed to: Arena: here --> Arena: Campgrounds your script would be in trouble where as a solution using an HTML parser would not. An example using HTML::TokeParser::Simple : #!/usr/bin/perl use strict; use warnings; use HTML::TokeParser::Simple; my $p = HTML::TokeParser::Simple->new( 'martianbuddy.html' ); while ( my $tag = $p->get_tag('p') ) { next unless $tag->is_start_tag; next unless defined (my $class = $tag->get_attr('class')); next unless grep { /^prf_faves\z/ } split ' ', $class; my $fav = $p->get_tag('b'); my $type = $p->get_text('/b'); my $value = $p->get_text('/p'); $value =~ s/\s+\z//; print "$type = $value\n"; } Output: Arena: Campgrounds Game Type: Clan Arena Weapon: Rocket Launcher And, here is an example using HTML::TreeBuilder : #!/usr/bin/perl use strict; use warnings; use HTML::TreeBuilder; use YAML; my $tree = HTML::TreeBuilder->new; $tree->parse_file('martianbuddy.html'); my @p = $tree->look_down(_tag => 'p', sub { return unless defined (my $class = $_[0]->attr('class')); return unless grep { /^prf_faves\z/ } split ' ', $class; return 1; } ); for my $p ( @p ) { my $text = $p->as_text; $text =~ s/^\s+//; my ($type, $value) = split ': ', $text; print "$type: $value\n"; } Output: Arena: Campgrounds Game Type: Clan Arena Weapon: Rocket Launcher Given that the document is an HTML fragment rather than a full document, you will have more success with modules based on HTML::Parser rather than those that expect to operate on well-formed XML documents.
