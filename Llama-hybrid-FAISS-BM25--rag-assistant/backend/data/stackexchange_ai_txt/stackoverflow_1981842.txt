[site]: stackoverflow
[post_id]: 1981842
[parent_id]: 1977504
[tags]: 
First: don't worry about the identity transform; it does not build an in-memory representation of the data. To implement your "tee" functionality, you have to create a content handler that listens to the stream of events produced by the parser, and passes them on to the handler provided for you by the transformer. Unfortunately, this is not as easy as it sounds: the parser wants to send events to a DefaultHandler , while the transformer wants to read events from an XMLReader . The former is an abstract class, the latter is an interface. The JDK also provides the class XMLFilterImpl , which implements all of the interfaces of DefaultHandler , but does not extend from it ... that's what you get for incorporating two different projects as your "reference implementations." So, you need to write a bridge class between the two: import java.io.IOException; import java.io.StringReader; import java.io.StringWriter; import javax.xml.parsers.SAXParser; import javax.xml.parsers.SAXParserFactory; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.sax.SAXSource; import javax.xml.transform.stream.StreamResult; import org.xml.sax.Attributes; import org.xml.sax.InputSource; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.XMLReader; import org.xml.sax.helpers.DefaultHandler; import org.xml.sax.helpers.XMLFilterImpl; /** * Uses a decorator ContentHandler to insert a "tee" into a SAX parse/serialize * stream. */ public class SaxTeeExample { public static void main(String[] argv) throws Exception { StringReader src = new StringReader(" text "); StringWriter dst = new StringWriter(); Transformer xform = TransformerFactory.newInstance().newTransformer(); XMLReader reader = new MyReader(SAXParserFactory.newInstance().newSAXParser()); xform.transform(new SAXSource(reader, new InputSource(src)), new StreamResult(dst)); System.out.println(dst.toString()); } private static class MyReader extends XMLFilterImpl { private SAXParser _parser; public MyReader(SAXParser parser) { _parser = parser; } @Override public void parse(InputSource input) throws SAXException, IOException { _parser.parse(input, new XMLFilterBridge(this)); } // this is an example of a "tee" function @Override public void startElement(String uri, String localName, String name, Attributes atts) throws SAXException { System.out.println("startElement: " + name); super.startElement(uri, localName, name, atts); } } private static class XMLFilterBridge extends DefaultHandler { private XMLFilterImpl _filter; public XMLFilterBridge(XMLFilterImpl myFilter) { _filter = myFilter; } @Override public void characters(char[] ch, int start, int length) throws SAXException { _filter.characters(ch, start, length); } // override all other methods of DefaultHandler // ... } } The main method sets up the transformer. The interesting part is that the SAXSource is constructed around MyReader . When the transformer is ready for events, it will call the parse() method ofthat object, passing it the specified InputSource . The next part is not obvious: XMLFilterImpl follows the Decorator pattern. The transformer will call various setter methods on this object before starting the transform, passing its own handlers. Any methods that I don't override (eg, startDocument() ) will simply call the delegate. As an example override, I'm doing "analysis" (just a println) in startElement() . You'll probably override other ContentHandler methods. And finally, XMLFilterBridge is the bridge between DefaultHandler and XmlReader ; it's also a decorator, and every method simply calls the delegate. I show one override, but you'll have to do them all.
