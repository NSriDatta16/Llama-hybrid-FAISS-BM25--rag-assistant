[site]: stackoverflow
[post_id]: 1727737
[parent_id]: 1727250
[tags]: 
The only real uses for inheritance are: Polymorphism Go's interface's "static duck typing" system solves this problem Borrowing implementation from another class This is what embedding is for Go's approach doesn't exactly map 1-to-1, consider this classical example of inheritance and polymorphism in Java ( based on this ): //roughly in Java (omitting lots of irrelevant details) //WARNING: don't use at all, not even as a test abstract class BankAccount { int balance; //in cents void Deposit(int money) { balance += money; } void withdraw(int money) { if(money > maxAllowedWithdrawl()) throw new NotEnoughMoneyException(); balance -= money; } abstract int maxAllowedWithdrawl(); } class Account extends BankAccount { int maxAllowedWithdrawl() { return balance; } } class OverdraftAccount extends BankAccount { int overdraft; //amount of negative money allowed int maxAllowedWithdrawl() { return balance + overdraft; } } Here, inheritance and polymorphism are combined, and you can't translate this to Go without changing the underlying structure. I haven't delved deeply into Go, but I suppose it would look something like this: //roughly Go? .... no? //for illustrative purposes only; not likely to compile // //WARNING: This is totally wrong; it's programming Java in Go type Account interface { AddToBalance(int) MaxWithdraw() int } func Deposit(account Account, amount int) { account.AddToBalance(amount) } func Withdraw(account Account, amount int) error { if account.MaxWithdraw() As per the note, this is totally a wrong way to code since one is doing Java in Go. If one was to write such a thing in Go, it would probably be organized a lot different than this.
