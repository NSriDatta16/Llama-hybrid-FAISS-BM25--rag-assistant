[site]: stackoverflow
[post_id]: 1178982
[parent_id]: 1164492
[tags]: 
Why a table? This very fast function has its worst noise peak at -90db when the signal is at -20db. That's crazy good. For resampling of audio, I always use one of the interpolators from the Elephant paper. This was discussed in a previous SO question . If you're on a processor that doesn't have fp, you can still do these things, but they are harder. I've been there. I feel your pain. Good luck! I used to do conversions for fp to integer for fun, but now you'd have to pay me to do it. :-) Cool online references that apply to your problem: http://www.audiomulch.com/~rossb/code/sinusoids/ http://www.dattalo.com/technical/theory/sinewave.html Edit: additional thoughts based on your comments Since you're working on a tricky processor, maybe you should look into how to make your sine table have more angles to look up, but still keep it small. Suppose you break a quadrant into 90 pieces (in reality, you'd probably use 256 pieces, but let's keep it 90 for familiarity and clarity). Encode those as 16 bits. That's 180 bytes of table so far. Now, for every one of those degrees, we're going to have 9 (in reality probably 8 or 16) in-between points. Let's take the range between 3 degrees and 4 degrees as an example. sin(3)=0.052335956 //this will be in your table as a 16-bit number sin(4)=0.069756474 //this will be in your table as a 16-bit number so we're going to look at sin(3.1) sin(3.1)=0.054978813 //we're going to be tricky and store the result // in 8 bits as a percentage of the distance between // sin(3) and sin(4) What you want to do is figure out how sin(3.1) fits in between sin(3) and sin(4). If it's half way between, code that as a byte of 128. If it's a quarter of the way between, code that as 64. That's an additional 90 bytes and you've encoded down to a tenth of a degree in 16-bit res in only 180+90*9 bytes. You can extend as needed (maybe going up to 32-bit angles and 16-bit tween angles) and linearly interpolate in between very quickly. To minimize storage space, you're taking advantage of the fact that consecutive values are close to each other. Edit 2: better way to encode the in-between angles in a table I just remembered that when I did this, I ended up very compactly expressing the difference between the expected value according to linear interpolation and the actual value. This error is always in the same direction. I first calculated the maximum error in the range and then based the scale on that. Worked great. I feel like I should do the code in a blog entry to illustrate. :-)
