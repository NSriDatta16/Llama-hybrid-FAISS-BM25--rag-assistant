[site]: stackoverflow
[post_id]: 1286797
[parent_id]: 1261673
[tags]: 
You could use a custom class as the file's owner, but you don't have to. I'll show you two techniques to load a table cell from a NIB, one that uses the file's owner, and one that doesn't. Without using the file's owner, here's a way to load a table cell from a NIB: - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *myCell = [tableView dequeueReusableCellWithIdentifier:@"MyID"]; if (!myCell) { NSBundle *bundle = [NSBundle mainBundle]; NSArray *topLevelObjects = [bundle loadNibNamed:@"MyNib" owner:nil options:nil]; myCell = [topLevelObjects lastObject]; } /* setup my cell */ return myCell; } The above code is fragile because in the future if you modify the XIB to have more top level objects, this code will probably fail by getting the wrong object from "[topLevelObjects lastObject]". It isn't fragile in any other way though, so this technique is fine to use. To be a little more explicit, and robust, you can use the file's owner and an outlet instead of using the top level objects. Here's an example of that: @interface MyTableViewDataSource : NSObject { UITableViewCell *loadedCell; } @property (retain) UITableViewCell *loadedCell; @end @implementation MyTableViewDataSource @synthesize loadedCell; - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *myCell = [tableView dequeueReusableCellWithIdentifier:@"MyID"]; if (!myCell) { [[NSBundle mainBundle] loadNibNamed:@"MyNib" owner:self options:nil]; myCell = [[[self loadedCell] retain] autorelease]; [self setLoadedCell:nil]; } /* setup my cell */ return myCell; } @end
