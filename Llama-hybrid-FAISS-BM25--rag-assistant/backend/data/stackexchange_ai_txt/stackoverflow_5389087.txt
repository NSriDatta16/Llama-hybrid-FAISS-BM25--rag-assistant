[site]: stackoverflow
[post_id]: 5389087
[parent_id]: 
[tags]: 
Optimizating my code simulating a database

I have been working on a program, simulating a small database where I could make queries, and after writing the code, I have executed it, but the performance is quite bad. It works really slow. I have tried to improve it, but I started with C++ on my own a few months ago, so my knowledge is still very low. So I would like to find a solution to improve the performance. Let me explain how my code works. Here I have atached a summarized example of how my code works. First of all I have a .txt file simulating a database table with random strings separated with "|". Here you have an example of table (with 5 rows and 5 columns). Table.txt 0|42sKuG^uM|24465\lHXP|2996fQo\kN|293cvByiV 1|14772cjZ`SN|28704HxDYjzC|6869xXj\nIe|27530EymcTU 2|9041ByZM]I|24371fZKbNk|24085cLKeIW|16945TuuU\Nc 3|16542M[Uz\|13978qMdbyF|6271ait^h|13291_rBZS 4|4032aFqa|13967r^\\`T|27754k]dOTdh|24947]v_uzg This information in a .txt file is read by my program and stored in the computer memory. Then, when making queries, I will access to this information stored in the computer memory. Loading the data in the computer memory can be a slow process, but accessing to the data later will be faster, what really matters me. Here you have the part of the code that read this information from a file and store in the computer. Code that reads data from the Table.txt file and store it in the computer memory string ruta_base("C:\\a\\Table.txt"); // Folder where my "Table.txt" is found string temp; // Variable where every row from the Table.txt file will be firstly stored vector buffer; // Variable where every different row will be stored after separating the different elements by tokens. vector RowsCols; // Variable with a class that I have created, that simulated a vector and every vector element is a row of my table ifstream ifs(ruta_base.c_str()); while(getline( ifs, temp )) // We will read and store line per line until the end of the ".txt" file. { size_t tokenPosition = temp.find("|"); // When we find the simbol "|" we will identify different element. So we separate the string temp into tokens that will be stored in vector buffer while (tokenPosition != string::npos) { string element; tokenPosition = temp.find("|"); element = temp.substr(0, tokenPosition); buffer.push_back(element); temp.erase(0, tokenPosition+1); } ElementSet ss(0,buffer); buffer.clear(); RowsCols.push_back(ss); // We store all the elements of every row (stores as vector buffer) in a different position in "RowsCols" } vector TablesDescriptor; Table TablesStorage(RowsCols); TablesDescriptor.push_back(TablesStorage); DataBase database(1, TablesDescriptor); After this, comes the IMPORTANT PART . Let's suppose that I want to make a query, and I ask for input. Let's say that my query is row "n", and also the consecutive tuples "numTuples", and the columns "y". (We must say that the number of columns is defined by a decimal number "y", that will be transformed into binary and will show us the columns to be queried, for example, if I ask for columns 54 (00110110 in binary) I will ask for columns 2, 3, 5 and 6). Then I access to the computer memory to the required information and store it in a vector shownVector. Here I show you the part of this code. Code that access to the required information upon my input int n, numTuples; unsigned long long int y; clock_t t1, t2; cout >n; // We get the row to be represented -> "n" cout >numTuples; // We get the number of followed tuples to be queried-> "numTuples" cout >y; // We get the "columns" to be represented ' "y" unsigned int r; // Auxiliar variable for the columns path int t=0; // Auxiliar variable for the tuples path int idTable; vector columnsToBeQueried; // Here we will store the columns to be queried get from the bitset binarynumber, after comparing with a mask vector shownVector; // Vector to store the final information from the query bitset mask; mask=0x1; t1=clock(); // Start of the query time bitset binaryNumber = Utilities().getDecToBin(y); // We get the columns -> change number from decimal to binary. Max number of columns: 5000 // We see which columns will be queried for(r=0;r colTab; colTab.push_back(1); // Don't really worry about this //idTable = colTab.at(i); // We identify in which table (with the id) is column_i // In this simple example we only have one table, so don't worry about this const Table& selectedTable = database.getPointer().at(0); // It simmulates a vector with pointers to different tables that compose the database, but our example database only have one table, so don't worry ElementSet selectedElementSet; ElementSet selectedElementSet; selectedElementSet=selectedTable.getRowsCols().at(n); shownVector.push_back(selectedElementSet.getElements().at(i)); // We save in the vector shownVector the element "i" of the row "n" } n=n+1; t++; }while(t Class definitions Here I attached some of the class definitions so that you can compile the code, and understand better how it works: class ElementSet { private: int id; vector elements; public: ElementSet(); ElementSet(int, vector ); const int& getId(); void setId(int); const vector & getElements(); void setElements(vector ); }; class Table { private: vector RowsCols; public: Table(); Table(vector ); const vector & getRowsCols(); void setRowsCols(vector ); }; class DataBase { private: int id; vector pointer; public: DataBase(); DataBase(int, vector ); const int& getId(); void setId(int); const vector & getPointer(); void setPointer(vector ); }; class Utilities { public: Utilities(); static bitset getDecToBin(unsigned long long int); }; So the problem that I get is that my query time is very different depending on the table size (it has nothing to do a table with 100 rows and 100 columns, and a table with 10000 rows and 1000 columns). This makes that my code performance is very low for big tables, what really matters me... Do you have any idea how could I optimizate my code???? Thank you very much for all your help!!! :)
