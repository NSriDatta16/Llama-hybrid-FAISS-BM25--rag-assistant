[site]: stackoverflow
[post_id]: 3834255
[parent_id]: 3834121
[tags]: 
IMHO, the first example is really more a question of how catastrophic failures are presented to the user. In the event that someone does something really silly and sets activeGames to none, most languages will throw a NullPointer/InvalidReference type of exception. If you have a good system for catching these kinds of errors and handling them elegantly, then I would argue that you leave these guards out entirely. If you have a decent set of unit tests, they will ensure with huge amounts of certainty that this kind of problem does not escape the developers machine. As for the second one, what you're really guarding against is a race condition. What if the "doStuffToMakeFooTrue()" method never makes foo true? This code will eventually run itself into the ground. Rather than risk that, I'll usually put code like this on a timer. If your language has closures or function pointers (honestly not sure about Python...), you can hide the implementation of the timing logic in a nice helper method, and call it this way: withTiming(hmph, 30) // run for 30 seconds, then fail If you don't have closures or function pointers, you'll have to do it the long way everywhere: stopwatch = new Stopwatch(30) stopwatch.start() while stopwatch.elapsedTimeInSeconds()
