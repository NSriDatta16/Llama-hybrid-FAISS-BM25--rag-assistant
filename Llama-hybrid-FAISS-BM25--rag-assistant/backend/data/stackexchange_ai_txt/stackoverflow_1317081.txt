[site]: stackoverflow
[post_id]: 1317081
[parent_id]: 
[tags]: 
GCC's assembly output of an empty program on x86, win32

I write empty programs to annoy the hell out of stackoverflow coders, NOT. I am just exploring the gnu toolchain. Now the following might be too deep for me, but to continuie the empty program saga I have started to examine the output of the C compiler, the stuff GNU as consumes. gcc version 4.4.0 (TDM-1 mingw32) test.c: int main() { return 0; } gcc -S test.c .file "test.c" .def ___main; .scl 2; .type 32; .endef .text .globl _main .def _main; .scl 2; .type 32; .endef _main: pushl %ebp movl %esp, %ebp andl $-16, %esp call ___main movl $0, %eax leave ret Can you explain what happens here? Here is my effort to understand it. I have used the as manual and my minimal x86 ASM knowledge: .file "test.c" is the directive for the logical filename. .def : according to the docs "Begin defining debugging information for a symbol name" . What is a symbol (a function name/variable?) and what kind of debugging information? .scl : docs say "Storage class may flag whether a symbol is static or external" . Is this the same static and external I know from C? And what is that '2'? .type : stores the parameter "as the type attribute of a symbol table entry" , I have no clue. .endef : no problem. .text : Now this is problematic, it seems to be something called section and I have read that its the place for code, but the docs didn't tell me too much. .globl "makes the symbol visible to ld." , the manual is quite clear on this. _main: This might be the starting address (?) for my main function pushl_ : A long (32bit) push, which places EBP on the stack movl : 32-bit move. Pseudo-C: EBP = ESP; andl : Logical AND. Pseudo-C: ESP = -16 & ESP , I don't really see whats the point of this. call : Pushes the IP to the stack (so the called procedure can find its way back) and continues where __main is. (what is __main?) movl : this zero must be the constant I return at the end of my code. The MOV places this zero into EAX. leave : restores stack after an ENTER instruction (?). Why? ret : goes back to the instruction address that is saved on the stack Thank you for your help!
