[site]: stackoverflow
[post_id]: 1966211
[parent_id]: 1831386
[tags]: 
This is how I would encode the game steps. For a game with 40 steps this will take about 180 bits or so. First, create a list of all the choices using an engine that knows all the chess rules. Each step, do this: Enumerate all pieces that are possible to move (at start, white can move 8 pawns and 2 knights, totals 10. Store both the number of possible choices and the choice itself. Enumerate all possible movement positions. (when pawn was choosen at the start, you can move 1 or 2 fields forward, so you have 2 possible choices. Again, store the number of possible choices and the choice itself. This will get you a list like this: [[10, 3], # choose white pawn at index #3 [2, 0], # move it one step forward [10, 2], # choose black pawn #2 [2, 1], # move it two steps forward ... ] And so on. To encode it, you just need to store the choice, not the number of possible moves. One way to store it is to find out how many bits are required for each choice: [[10, 3], # 10 choices => 4 bits [2, 0], # 2 choices => 1 bit [10, 2], # 10 choices => 4 bits [2, 1], # 2 choices => 1 bit ... ] Totals 4+1+4+1=10 bits for the first two moves. But a few bits are wasted, using 4 bits for 10 choices wastes 6 possible choices. It is possible to do better: reverse the list, and calculate a number based on the possible choices and the choice taken: n = 0 # last position n = n*2 + 1 # from [2, 1] n=1 n = n*10 + 2 # from [10, 2] n=12 n = n*2 + 0 # from [2, 0] n=24 n = n*10 + 3 # from [10, 3] n=243 Now we have the number 243 , binary 11110011 , which encodes all the above steps in just 8 bits. To decode, we know that the initial opening position has 10 possible choices. Calculate n = 243 choice = n % 10 # we know there are 10 moveable pieces. => choice=3 n /= 10 # n=24 choice = n % 2 # we know 2 possible moves for selected pawn => choice=0 n /= 2 # n=12 choice = n % 10 # 10 moveable pieces for black player. => choice=2 n /= 10 # n=1 choice = n % 2 # 2 possible moves for pawn => choice=1 n /= 2 # n=0, finished decoding Encoding is extremely efficient, especially the endgame because there are not many possible choices left. Also, when you only have one possible move left, you do not need any storage at all for that move.
