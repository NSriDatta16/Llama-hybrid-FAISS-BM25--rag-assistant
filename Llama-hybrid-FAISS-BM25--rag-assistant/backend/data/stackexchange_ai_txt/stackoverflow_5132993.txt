[site]: stackoverflow
[post_id]: 5132993
[parent_id]: 
[tags]: 
Using C++ Macro with arguments into a linked piece of code

i have a macro that i use to speed up the implementation of Factory classes. For example, to build a Factory for a CameraGenerator i use the macro this way: GENERATOR_BUILD_FACTORY_START(CameraGenerator) ... do some stuff ... GENERATOR_BUILD_FACTORY_END(CameraGenerator) This build AND ALSO INSTANTIATE a class named CameraGeneratorFactory. All this is done into the .cpp file, not in the .h, so that the particural instance of the Factory become a global variable but the particular factory definition is not available outside of this file. All factories inherits from a base Factory class. The problem comes when in another .cpp i need to define and instantiate another particular Factory, say FileGeneratorFactory, so i do GENERATOR_BUILD_FACTORY_START(FileGenerator) ... do some other stuff ... GENERATOR_BUILD_FACTORY_END(FileGenerator) when compiled in DEBUG, the second use of this macro executes again the "CameraGenerator" Factory constructor, not the correct "FileGenerator" Factory one, like if once the macro had been preprocessed, compiled and linked into the first .cpp, it is always executed with the same argument. I repeat, the issue is only when compiled in debug mode . Does anyone know something about this behaviour? thanks in previous Here is the code of the macro: #define GENERATOR_BUILD_FACTORY_START(GEN_NAME) \ class GEN_NAMEFactory : public AbstractGeneratorFactory{ \ public: \ GEN_NAMEFactory() : AbstractGeneratorFactory(){ \ #define GENERATOR_BUILD_FACTORY_CONF_SECTION(GEN_NAME) \ extern GeneratorBuilder generator_builder; \ generator_builder.add_factory(#GEN_NAME, this); #define GENERATOR_BUILD_FACTORY_END_CONF_SECTION(GEN_NAME) \ } \ GEN_NAMEFactory(const GEN_NAMEFactory& f) : AbstractGeneratorFactory(f){} \ GEN_NAMEFactory& operator=(const GEN_NAMEFactory& f){ \ if (this == &f) return *this; \ AbstractGeneratorFactory::operator =(f); \ return *this; \ } \ virtual ~GEN_NAMEFactory(){} \ virtual Generator* build() const{ \ return new GEN_NAME(); \ } \ Generator* build(const Configuration& cfg) const throw(bad_parameter) { \ Generator* g = 0; \ #define GENERATOR_BUILD_FACTORY_END(GEN_NAME) \ return g; \ } \ }; \ GEN_NAMEFactory instance_of_GEN_NAMEFactory;
