[site]: datascience
[post_id]: 49560
[parent_id]: 
[tags]: 
Sequence classification using oneClass SVM

In the code below, I'm using a sequence to sequence approach as a prediction model for anomaly detection. The data set I'm working with is ADFA-LD. The training phase is done using only normal sequences. After predicting the next sequence, I want to add a classifier, which will detect abnormal sequences (the test data contains normal and abnormal sequences). To do this, I used oneClass SVM as a classifier. I don't know why but sometimes the program runs normally and sometimes displays this error: ValueError: setting an array element with a sequence at line: fraud_pred = oneclass.predict(np.array(x_test)) The code: # Train - Test Split X=lines[['eng','Class1']] y=lines[['fr','Class2']] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2) #fonction pour charger le data par lot (batch size) #séquence du générateur utilisée pour entraîner le réseau de neurones def generate_batch(X = X_train, y = y_train, batch_size = 128): ''' Generate a batch of data ''' encoder_inputs = Input(shape=(None,)) en_x= Embedding(num_encoder_tokens, embedding_size,mask_zero = True) (encoder_inputs) #convertit chaque mot en un vecteur de taille fix encoder = GRU(256, return_state=True) encoder_outputs, state_h = encoder(en_x) decoder_inputs = Input(shape=(None,)) dex= Embedding(num_decoder_tokens, embedding_size,mask_zero = True)#convertit chaque mot en un vecteur de taille fix final_dex= dex(decoder_inputs) decoder_gru = GRU(256, return_sequences=True) decoder_gru2 = GRU(256, return_sequences=True,return_state=True) decoder_outputs= decoder_gru(final_dex,initial_state=encoder_states) decoder_dense = Dense(num_decoder_tokens, activation='softmax') decoder_outputs = decoder_dense(decoder_outputs) model = Model([encoder_inputs, decoder_inputs], decoder_outputs) start = time.time() model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics= ['acc']) train_samples = len(X_train) val_samples = len(X_test) batch_size = 128 epochs = 1 mod_train=model.fit_generator(generator = generate_batch(X_train, y_train, batch_size = batch_size), steps_per_epoch = train_samples//batch_size, epochs=epochs, validation_data = generate_batch(X_test, y_test, batch_size = batch_size), validation_steps = val_samples//batch_size) df_history = pd.DataFrame (mod_train.history) print(df_history) ##################################### #modeles de prédiction # define inference encoder encoder_model = Model(encoder_inputs,encoder_states) # define inference decoder decoder_state_input_h = Input(shape=(256,)) decoder_states_inputs = [decoder_state_input_h] final_dex2= dex(decoder_inputs) print(final_dex2) decoder_outputs2,state_h2 = decoder_gru2(final_dex2, initial_state=decoder_states_inputs) decoder_states2 = [state_h2] decoder_outputs2 = decoder_dense(decoder_outputs2) decoder_model = Model([decoder_inputs] + decoder_states_inputs, [decoder_outputs2] + decoder_states2) def decode_sequence(input_seq): # Encode the input as state vectors. states_value = encoder_model.predict(input_seq) print(len(states_value),states_value.shape) # Generate empty target sequence of length 1. target_seq = np.zeros((1,1)) # Populate the first word of target sequence with the start word. target_seq[0,0] = target_token_index['0000'] stop_condition = False decoded_sentence = '' while not stop_condition: output_tokens,h= decoder_model.predict([target_seq]+[states_value]) sampled_token_index = np.argmax(output_tokens[0, -1, :]) sampled_char = reverse_target_char_index[sampled_token_index] decoded_sentence +=' '+sampled_char # Exit condition: either hit max length # or find stop character. if (sampled_char =='1111' or len(decoded_sentence.split(' '))> max_len_fr-2):#critere d'arret (la fin de la phrase en français) stop_condition = True # Update the target sequence (of length 1). target_seq = np.zeros((1,1)) target_seq[0] = sampled_token_index # Update states states_value = h return decoded_sentence y_true=[] NN=[] test_gen = generate_batch(X_train, y_train, batch_size = 1) k=0 while k If anyone can help me, I'll be so thankful.
