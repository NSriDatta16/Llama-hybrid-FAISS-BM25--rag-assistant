[site]: stackoverflow
[post_id]: 4714654
[parent_id]: 4714222
[tags]: 
(I have not timed this, but) if you're going to use this function often it might be worth pre-compiling the regex expression. Here's my take on your function: re_timestr = re.compile(""" ((?P \d+)y)?\s* ((?P \d+)M)?\s* ((?P \d+)w)?\s* ((?P \d+)d)?\s* ((?P \d+)h)?\s* ((?P \d+)m)?\s* ((?P \d+)s)? """, re.VERBOSE) def interval3(patt): p = {} match = re_timestr.match(patt) if not match: raise ValueError("invalid pattern : %s" % (patt)) for k,v in match.groupdict("0").iteritems(): p[k] = int(v) # cast string to int p["days"] += p.pop("years") * 365 # convert years to days p["days"] += p.pop("months") * 30 # convert months to days return datetime.timedelta(**p) update From this question , it looks like precompiling regex patterns does not bring about noticeable performance improvement since Python caches and reuses them anyway. You only save the time it takes to check the cache which, unless you are repeating it numerous times, is negligible. update2 As you quite rightly pointed out, this solution does not support interval3("1h 30s" + "2h 10m") . However, timedelta supports arithmetic operations which means one you can still express it as interval3("1h 30s") + interval3("2h 10m") . Also, as mentioned by some of the comments on the question, you may want to avoid supporting "years" and "months" in the inputs. There's a reason why timedelta does not support those arguments; it cannot be handled correctly (and incorrect code are almost never elegant). Here's another version, this time with support for float, negative values, and some error checking. re_timestr = re.compile(""" ^\s* ((?P [+-]?\d+(\.\d*)?)w)?\s* ((?P [+-]?\d+(\.\d*)?)d)?\s* ((?P [+-]?\d+(\.\d*)?)h)?\s* ((?P [+-]?\d+(\.\d*)?)m)?\s* ((?P [+-]?\d+(\.\d*)?)s)?\s* $ """, re.VERBOSE) def interval4(patt): p = {} match = re_timestr.match(patt) if not match: raise ValueError("invalid pattern : %s" % (patt)) for k,v in match.groupdict("0").iteritems(): p[k] = float(v) # cast string to int return datetime.timedelta(**p) Example use cases: >>> print interval4("1w 2d 3h4m") # basic use 9 days, 3:04:00 >>> print interval4("1w") - interval4("2d 3h 4m") # timedelta arithmetic 4 days, 20:56:00 >>> print interval4("0.3w -2.d +1.01h") # +ve and -ve floats 3:24:36 >>> print interval4("0.3x") # reject invalid input Traceback (most recent call last): File "date.py", line 19, in interval4 raise ValueError("invalid pattern : %s" % (patt)) ValueError: invalid pattern : 0.3x >>> print interval4("1h 2w") # order matters Traceback (most recent call last): File "date.py", line 19, in interval4 raise ValueError("invalid pattern : %s" % (patt)) ValueError: invalid pattern : 1h 2w
