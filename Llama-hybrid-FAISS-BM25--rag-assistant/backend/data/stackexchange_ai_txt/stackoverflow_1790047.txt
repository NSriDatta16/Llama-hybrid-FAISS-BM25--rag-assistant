[site]: stackoverflow
[post_id]: 1790047
[parent_id]: 1789841
[tags]: 
On the implementation end (once you have a parser, organizing and performing searches): What about creating a Condition tree, where Condition objects may be simple conditions, or compound conditions joining 2 simple conditions with a boolean (IE ANDCondition parent node with children RangeCondition and EqualsCondition ). Then you evaluate the top of the tree against each item. This solution is O(mn), where m is number of conditions, and n is number of of items to search, but you can optimize this by removing redundant conditions. It is much faster if the first condition eliminates most items. Version 2: assign a unique key to each item (say, an array index), and perform the searches for each condition, building a HashSet for each condition. Then, starting with the smallest set of required keys, remove or add keys for each condition until you have final results. This may be faster than the above, depending. Note: these approaches mimic how an SQL Database will operate -- if your system is sufficiently large or complex, you should probably investigate using a database instead of writing your own code to do the same thing.
