[site]: stackoverflow
[post_id]: 2561515
[parent_id]: 2561451
[tags]: 
If you enable the strict pragma, the code doesn't even compile: Global symbol "@_IncludePath" requires explicit package name at Packet.pm line 15. Global symbol "@_IncludePath" requires explicit package name at Packet.pm line 29. Global symbol "@_IncludePath" requires explicit package name at Packet.pm line 30. Global symbol "@_IncludePath" requires explicit package name at Packet.pm line 40. Don't use @ unquoted in your keys because it will confuse the parser. I recommend removing them entirely to avoid confusing human readers of your code. You seem to want to pull all the attribute values from the arguments to the constructor, so continue peeling off the scalar values with shift , and then everything left must be the include path. I assume that the components of the include path will be simple scalars and not references; if the latter is the case, then you'll want to make deep copies for safety. sub new { my $class = shift; my $Packet = { _PacketName => shift, _Platform => shift, _Version => shift, _IncludePath => [ @_ ], }; bless $Packet, $class; } Note that there's no need to store the blessed object in a temporary variable and then immediately return it because of the semantics of Perl subs : If no return is found and if the last statement is an expression, its value is returned. The methods below will also make use of this feature. Given the constructor above, GetIncludePath becomes sub GetIncludePath { my( $Packet ) = @_; my @path = @{ $Packet->{_IncludePath} }; wantarray ? @path : \@path; } There are a couple of things going on here. First, note that we're careful to return a copy of the include path rather than a direct reference to the internal array. This way, the user can modify the value returned from GetIncludePath without having to worry about mucking up the packet's state. The wantarray operator allows a sub to determine the context of its call and respond accordingly. In list context, GetIncludePath will return the list of values in the array. Otherwise, it returns a reference to a copy of the array. This way, client code can call it either as in foreach my $path (@{ $packet->GetIncludePath }) { ... } or foreach my $path ($packet->GetIncludePath) { ... } SetIncludePath is then sub SetIncludePath { my ( $Packet, @IncludePath ) = @_; $Packet->{_IncludePath} = \@IncludePath; } Note that you could have used similar code in the constructor rather than removing one parameter at a time with shift . You might use the class defined above as in #! /usr/bin/perl use strict; use warnings; use Packet; sub print_packet { my($p) = @_; print $p->GetPacketName, "\n", map(" - [$_]\n", $p->GetIncludePath), "\n"; } my $p = Packet->new("MyName", "platform", "v1.0", qw/ foo bar baz /); print_packet $p; my @includeobjects = ( "./input/myMockPacketName", "./input/myPacket/my3/*.txt", "./input/myPacket/in.html", ); $p->SetIncludePath(@includeobjects); print_packet $p; print "In scalar context:\n"; foreach my $path (@{ $p->GetIncludePath }) { print $path, "\n"; } Output: MyName - [foo] - [bar] - [baz] MyName - [./input/myMockPacketName] - [./input/myPacket/my3/*.txt] - [./input/myPacket/in.html] In scalar context: ./input/myMockPacketName ./input/myPacket/my3/*.txt ./input/myPacket/in.html
