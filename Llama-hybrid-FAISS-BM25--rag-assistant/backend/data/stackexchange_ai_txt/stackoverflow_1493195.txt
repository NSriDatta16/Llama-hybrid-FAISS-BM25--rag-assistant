[site]: stackoverflow
[post_id]: 1493195
[parent_id]: 236129
[tags]: 
An efficient, small, and elegant solution using a template function: template void split(const std::string& str, ContainerT& tokens, const std::string& delimiters = " ", bool trimEmpty = false) { std::string::size_type pos, lastPos = 0, length = str.length(); using value_type = typename ContainerT::value_type; using size_type = typename ContainerT::size_type; while (lastPos I usually choose to use std::vector types as my second parameter ( ContainerT )... but list may sometimes be preferred over vector . It also allows you to specify whether to trim empty tokens from the results via a last optional parameter. All it requires is std::string included via . It does not use streams or the boost library explicitly but will be able to accept some of these types. Also since C++-17 you can use std::vector which is much faster and more memory-efficient than using std::string . Here is a revised version which also supports the container as a return type: #include #include #include template > ContainerT split(StringT const& str, DelimiterT const& delimiters = ' ', bool trimEmpty = true, ContainerT&& tokens = {}) { typename StringT::size_type pos, lastPos = 0, length = str.length(); while (lastPos (tokens); } Care has been taken not to make any unneeded copies. This will allow for either: for (auto const& line : split(str, '\n')) Or: auto& lines = split(str, '\n'); Both returning the default template container type of std::vector . To get a specific container type back, or to pass an existing container, use the tokens input parameter with either a typed initial container or an existing container variable: auto& lines = split(str, '\n', false, std::vector ()); Or: std::vector lines; split(str, '\n', false, lines);
