[site]: stackoverflow
[post_id]: 3032951
[parent_id]: 
[tags]: 
How to calculate 2^n-1 efficiently without overflow?

I want to calculate 2 n -1 for a 64bit integer value. What I currently do is this for(i=0; i and I wonder if there is more elegant way to do it. The line is in an inner loop, so I need it to be fast. I thought of r=(1ULL but it doesn't work for n=64 , because is only defined for values of n up to 63. EDIT: Thanks for all your answers and comments. Here is a little table with the solutions that I tried and liked best. Second column is time in seconds of my (completely unscientific) benchmark. r=N2MINUSONE_LUT[n]; 3.9 lookup table = fastest, answer by aviraldg r =n?~0ull>>(64 - n):0ull; 5.9 fastest without LUT, comment by Christoph r=(1ULL answer by Gabe r=((1ULL answer by drawnonward r=(1ULL answer by David Lively r=pow(2, n)-1; 99.0 Just for comparison for(i=0; i I accepted r =n?~0ull>>(64 - n):0ull; as answer because it's in my opinion the most elegant solution. It was Christoph who came up with it at first, but unfortunately he only posted it in a comment . Jens Gustedt added a really nice rationale, so I accept his answer instead. Because I liked Aviral Dasgupta's lookup table solution it got 50 reputation points via a bounty.
