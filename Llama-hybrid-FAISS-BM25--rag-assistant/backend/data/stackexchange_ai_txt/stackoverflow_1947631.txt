[site]: stackoverflow
[post_id]: 1947631
[parent_id]: 1947146
[tags]: 
I don't know if you would call this elegant or efficient, but it is probably the best you can do: WITH trace_CTE AS ( SELECT trcCorrId, trcProgram + trcCode AS trcUniqueCode, trcDateTime FROM trace WHERE (trcProgram = 'HIP' AND trcCode IN ('0250', '0299')) OR (trcProgram = 'Orch1' AND trcCode IN ('0010', '9999')) OR ([more conditions here]) ) SELECT trcCorrId, [HIP0250] AS startHIP, [HIP0299] AS stopHIP, [Orch10010] AS startOrch1, [Orch19999] AS stopOrch1 -- // etc., continue this for the other events FROM trace_CTE PIVOT ( MIN(trcDateTime) FOR trcUniqueCode IN ( [HIP0250], [HIP0299], [Orch10010], [Orch19999], [(continue with other codes)] ) ) I'm using a CTE just to clean up the syntax, it won't actually create another pass. PIVOT is pretty efficient, although if your trace table is massive, this is still going to be slow. In my experience, these problems are best handled with triggers whenever possible (context accumulation). Especially for what is probably set up as a write-only table, the overhead is minimal to do a few checks on INSERT, and it's going to be a lot more painful to do the same thing on-the-fly. If you don't do this, you'll probably end up with a nightly batch process crunching the numbers and putting them into an analysis table so users don't have to wait for the query to run. Final note: In order to get any kind of performance whatsoever on this query, you are definitely going to need an index on (trcProgram, trcCode) that covers (trcCorrId, trcDateTime).
