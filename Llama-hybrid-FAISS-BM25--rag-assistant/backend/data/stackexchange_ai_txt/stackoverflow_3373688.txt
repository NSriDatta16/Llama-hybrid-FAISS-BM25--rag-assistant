[site]: stackoverflow
[post_id]: 3373688
[parent_id]: 3371807
[tags]: 
You can try to use other level as 2 for example 11. You can aslo try LsaGetLogonSessionData (see http://msdn.microsoft.com/en-us/library/aa378290.aspx ). The struct SECURITY_LOGON_SESSION_DATA has a lot of information which can be helpful for you. The LUID (the first parameter of LsaGetLogonSessionData ) you can get from GetTokenInformation with TokenStatistics and get AuthenticationId field of the TOKEN_STATISTICS struct. UPDATED : I read more carefully your code and I see now your main error. Function NetUserGetInfo is very old. It exists in the time before Windows NT 3.1. The group of functions which Microsoft named now "Network Management" has the name "LAN Manager API". All the functions were introduced in the time where no local login exists. So you can use NetUserGetInfo with NULL as the first parameter only on a domain controller . So in the case that you login with the domain account you should call NetGetDCName , NetGetAnyDCName or better DsGetDcName to get the name of a domain controller and use this name (started with two backslashes) as the first parameter of NetUserGetInfo . If you login with a local workstation account your program should work, but the account seems me must be UNICODE string like L"Administrator" and not "Administrator". By the way if I login locally on my Windows 7 64-bit computer your program work without any problem. The code nStatus = NetUserGetInfo(NULL, L"administrator", dwLevel, (LPBYTE *) & pBuf); works also. I repeat then in my opinion the best way to get user's last logon is the usage of LSA (Local Security Authority) API like LsaGetLogonSessionData . How promised I wrote for you a code example which shows how to use LsaGetLogonSessionData in C: #include #include #include #include #include //#include #include #include #pragma comment (lib, "Secur32.lib") #pragma comment (lib, "strsafe.lib") // The following constant may be defined by including NtStatus.h. #ifndef STATUS_SUCCESS #define STATUS_SUCCESS ((NTSTATUS)0x00000000L) #endif // The LSA authentication functions are available in Unicode only. BOOL GetLogonLUID (LUID *pLuid) { BOOL bSuccess; HANDLE hThread = NULL; DWORD cbReturnLength; TOKEN_STATISTICS ts; __try { bSuccess = OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &hThread); // TOKEN_QUERY_SOURCE if (!bSuccess) __leave; cbReturnLength = sizeof(TOKEN_STATISTICS); bSuccess = GetTokenInformation (hThread, TokenStatistics, &ts, sizeof(TOKEN_STATISTICS), &cbReturnLength); if (bSuccess) *pLuid = ts.AuthenticationId; } __finally { if (hThread) CloseHandle (hThread); } return bSuccess; } void PrintUnicodeString (LPCTSTR pszPrefix, LSA_UNICODE_STRING lsaString) { if (lsaString.MaximumLength >= lsaString.Length + sizeof(WCHAR) && lsaString.Buffer[lsaString.Length/sizeof(WCHAR)] == L'\0') _tprintf (TEXT("%s: %ls\n"), pszPrefix, lsaString.Buffer); else if (lsaString.Length CachedUnlock) // This is used to specify an undefied logon type _tprintf (TEXT("LogonType: UndefinedLogonType\n")); else { static LPTSTR szTypes[] = { TEXT("Interactive"), // Interactively logged on (locally or remotely) TEXT("Network"), // Accessing system via network TEXT("Batch"), // Started via a batch queue TEXT("Service"), // Service started by service controller TEXT("Proxy"), // Proxy logon TEXT("Unlock"), // Unlock workstation TEXT("NetworkCleartext"), // Network logon with cleartext credentials TEXT("NewCredentials"), // Clone caller, new default credentials TEXT("RemoteInteractive"), // Remote, yet interactive. Terminal server TEXT("CachedInteractive"), // Try cached credentials without hitting the net. // The types below only exist in Windows Server 2003 and greater TEXT("CachedRemoteInteractive"), // Same as RemoteInteractive, this is used internally for auditing purpose TEXT("CachedUnlock") // Cached Unlock workstation }; _tprintf (TEXT("LogonType: %s\n"), szTypes[(int)type-Interactive]); } } void PrintFilefime (LPCTSTR pszPrefix, const FILETIME *lpFileTime) { SYSTEMTIME st; FILETIME ft; BOOL bSuccess; TCHAR szTime[1024], szDate[1024]; bSuccess = FileTimeToLocalFileTime (lpFileTime, &ft); if (!bSuccess) return; bSuccess = FileTimeToSystemTime (&ft, &st); if (!bSuccess) return; if (GetDateFormat (LOCALE_USER_DEFAULT, // or LOCALE_CUSTOM_UI_DEFAULT DATE_SHORTDATE, &st, NULL, szDate, sizeof(szDate)/sizeof(TCHAR)) > 0) { if (GetTimeFormat (LOCALE_USER_DEFAULT, // or LOCALE_CUSTOM_UI_DEFAULT 0, &st, NULL, szTime, sizeof(szTime)/sizeof(TCHAR)) > 0) { _tprintf (TEXT("%s: %s, %s\n"), pszPrefix, szDate, szTime); } } } int main() { LUID LogonLuid; // LOGONID_CURRENT PSECURITY_LOGON_SESSION_DATA pLogonSessionData = NULL; LPWSTR pszSid = NULL; NTSTATUS ntStatus; GetLogonLUID (&LogonLuid); __try { ntStatus = LsaGetLogonSessionData (&LogonLuid, &pLogonSessionData); if (ntStatus == STATUS_SUCCESS) { if (pLogonSessionData->UserName.Length) PrintUnicodeString (TEXT("UserName"), pLogonSessionData->UserName); if (pLogonSessionData->LogonDomain.Length) PrintUnicodeString (TEXT("LogonDomain"), pLogonSessionData->LogonDomain); if (pLogonSessionData->AuthenticationPackage.Length) PrintUnicodeString (TEXT("AuthenticationPackage"), pLogonSessionData->AuthenticationPackage); PrintLogonType ((SECURITY_LOGON_TYPE)pLogonSessionData->LogonType); _tprintf (TEXT("Session: %d\n"), pLogonSessionData->Session); if (ConvertSidToStringSidW (pLogonSessionData->Sid, &pszSid)) _tprintf (TEXT("Sid: %ls\n"), pszSid); if (pLogonSessionData->LogonTime.QuadPart) PrintFilefime (TEXT("LogonTime"), (const FILETIME *)&pLogonSessionData->LogonTime); if (pLogonSessionData->LogonServer.Length) PrintUnicodeString (TEXT("LogonServer"), pLogonSessionData->LogonServer); if (pLogonSessionData->DnsDomainName.Length) PrintUnicodeString (TEXT("DnsDomainName"), pLogonSessionData->DnsDomainName); if (pLogonSessionData->Upn.Length) PrintUnicodeString (TEXT("Upn"), pLogonSessionData->Upn); // one can dump more information like HomeDirectory, ProfilePath and so on // if _WIN32_WINNT >= 0x0600 and user login a domain } } __finally { if (pLogonSessionData) LsaFreeReturnBuffer(pLogonSessionData); if (pszSid) pszSid = (LPTSTR)LocalFree (pszSid); } }
