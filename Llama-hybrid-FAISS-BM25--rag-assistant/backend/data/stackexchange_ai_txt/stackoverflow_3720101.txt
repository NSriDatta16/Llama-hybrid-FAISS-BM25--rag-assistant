[site]: stackoverflow
[post_id]: 3720101
[parent_id]: 3680799
[tags]: 
Yeah, you hit the nail on the head. It's not working because you're using a fake repository. Linq-to-Sql does all the wiring up for you and sets the related collections based on the properties (& their attributes) that you setup in your model. I don't know how to accomplish this without a connection to the database because internal EntityRef > _category; is completely foreign to me - I'm more of a POCO model type of guy. After a quick google, I found this - How to: Map Database Relationships (LINQ to SQL) Could you change your model to read: [Column(IsPrimaryKey=true, IsDbGenerated=true, AutoSync=AutoSync.OnInsert)] public Int64 CatId { get; set; } [Column] public Int64 ParentCatId { get; set; } [Column] public string CatName { get; set; } [Column] public string CatDescription { get; set; } private EntitySet _ChildCategories; [Association(Storage = "_ChildCategories", OtherKey = "ParentCatId")] public EntitySet ChildCategories { get { return this._ChildCategories; } set { this._ChildCategories.Assign(value); } } private EntityRef _ParentCategory; [Association(Storage = "_ParentCategory", ThisKey = "ParentCatId")] public Category ParentCategory { get { return this._ParentCategory.Entity; } set { this._ParentCategory.Entity = value; } } Now because your ChildCategories is of type EntitySet (which inherits from IList ) you should be able to wire fake relationships up yourself. So you could do something like this: private static IQueryable GetFakeCategories() { var categories = new List { new Category { CatId = 1, ParentCatId = 0, CatName = "Root", CatDescription = "" }, new Category { CatId = 2, ParentCatId = 1, CatName = "Category w/subs", CatDescription = "" }, //Blah new Category { CatId = 8, ParentCatId = 3, CatName = "Brand new cats", CatDescription = "" }, new Category { CatId = 9, ParentCatId = 8, CatName = "Brand new cats sub", CatDescription = "" } }; //Loop over the categories to fake the relationships foreach (var category in categories) { category.ChildCategories = new EntitySet (); //new up the collection foreach (var subLoopCategory in categories) { if (category.ParentCatId == subLoopCategory.CatId) category.ParentCategory = subLoopCategory; if (category.Id == subLoopCategory.ParentCatId) category.ChildCategories.Add(subLoopCategory); } } return categoies.AsQueryable(); } It works in my head at least... :-) HTHs, Charles EDIT: Re: Comment below about a null reference on _childCategories . You could change the model to look like: private EntitySet _ChildCategories = new EntitySet ();
