[site]: stackoverflow
[post_id]: 5284248
[parent_id]: 5277633
[tags]: 
Like John's answer, I'd suggest just building a bounded TChan yourself. My code is different because it: adds abstraction (makes BTChan an ADT) removes the corner case due to his reading the current size in IO. tries not to build thunks in the size TVar when reading (it's less important when writing because the thunk can only be "one deep" - the next operation always needs to evaluate the size). is now on hackage: http://hackage.haskell.org/package/bounded-tchan NOTE: Honestly, if I were you I'd ignore all these answers and just go with the code ephemient linked to in his comment (unless it turns out to be bad code). I'd bet it does the same I do here but with more thought. {-# LANGUAGE BangPatterns #-} module BTChan ( BTChan , newBTChanIO , newBTChan , writeBTChan , readBTChan ) where import Control.Concurrent.STM data BTChan a = BTChan {-# UNPACK #-} !Int (TChan a) (TVar Int) -- | `newBTChan m` make a new bounded TChan of max size `m` newBTChanIO :: Int -> IO (BTChan a) newBTChanIO m = do szTV STM (BTChan a) newBTChan m | m a -> STM () writeBTChan (BTChan mx c szTV) x = do sz = mx then retry else writeTVar szTV (sz + 1) >> writeTChan c x readBTChan :: BTChan a -> STM a readBTChan (BTChan _ c szTV) = do x STM Int sizeOfBTChan (BTChan _ _ sTV) = readTVar sTV Some things of note for the STM programmer: Explicitly calling retry will yield, putting your haskell thread in a blocked state waiting for the state of one of the TVar or TChan to change so it can retry. This is how you avoid checking values in IO and using the yield function. Like MVars, TVars can refer to thunks, which usually isn't what you want. Perhaps someone should make a hackage package defining STVar , STChan , SBTChan and BTChan (Strict and/or bounded TVars and TChans). It is actually necessary to write newBTChanIO instead of leverage newBTChan because the implementations of new{TVar,TChan}IO are made to work even when under unsafePerformIO , which atomically can not do. EDIT: you can actually get 2-5 times better performance (depending on the bound you use) by separating out the TVar into one for the reader and one for the writer, thus reducing contention. Verified using criterion. The improved version, 0.2.1, is already on hackage.
