[site]: stackoverflow
[post_id]: 4128648
[parent_id]: 4128487
[tags]: 
It can be solved in O( n ), like this: C[ i ] represents the maximum cash you can hold at the end of day i , and G[ i ] represents the maximum amount of goods you can hold at the end of day i . I'm going to suppose you start out with 1 unit of cash and no goods, but the algorithm will work for other initial conditions. Initialize: C[0] = 1; G[0] = 0. Repeat for i from 1 to n : Let the selling price on day i be S[ i ] and the buying price B[ i ]. Set C[ i ] = max(C[ i − 1], G[ i − 1]S[ i ]) and G[ i ] = max(G[ i − 1], C[ i − 1]/B[ i ]). Here's an implementation in Python: from __future__ import division def max_cash(cash, goods, selling_price, buying_price): """Return the maximum amount of cash you can have, if you start with the given cash and goods, and on day i you can sell goods at selling_price[i] or buy them at buying_price[i]. Cash and goods are assumed to be arbitrarily divisible. """ for sell, buy in zip(selling_price, buying_price): assert(sell Let's check this on some of the alleged counter-examples raised in comments: JPvdMerwe suggests that this case "breaks all greedy algorithms I can think of", but the algorithm above works fine: >>> max_cash(0, 1, [2 ** i for i in range(10)], [float('inf')] * 10) 512 Keegan Carruthers-Smith suggests this counter-example: >>> max_cash(1, 0, [2, 2, 2], [2, 2, 2]) 1 which is unsurprising since the selling price is always the same as the buying price, and so no profit can be made, and so you can't possibly end up with more cash than you started with.
