[site]: stackoverflow
[post_id]: 3347817
[parent_id]: 3347660
[tags]: 
By default all Linq to Sql generated objects implement INotifyPropertyChanging which the DBContext will use for change tracking and in which case it will not detect setting an identical value. Only in cases where the object doesn't implement INotifyPropertyChanging will the change tracking mechanism use a hidden copy of the object to detect changes during calls to SubmitChanges() . Take a look at Object States and Change-Tracking (LINQ to SQL) for an explanation of the change tracking. --- Update: This actually isn't totally correct; here is an excerpt from a Linq to Sql class from the DBContext designer.cs file: [global::System.Data.Linq.Mapping.TableAttribute(Name="dbo.Tasks")] public partial class Task : INotifyPropertyChanging, INotifyPropertyChanged { private int _TaskId; [global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_TaskId", AutoSync=AutoSync.OnInsert, DbType="Int NOT NULL IDENTITY", IsPrimaryKey=true, IsDbGenerated=true)] public int TaskId { get { return this._TaskId; } set { if ((this._TaskId != value)) { this.OnTaskIdChanging(value); this.SendPropertyChanging(); this._TaskId = value; this.SendPropertyChanged("TaskId"); this.OnTaskIdChanged(); } } } } Are your primary key values integers and does your code check the previous value like this?
