[site]: stackoverflow
[post_id]: 5287942
[parent_id]: 5283269
[tags]: 
When parsing markup with PHP and regex, the preg_replace_callback() function combined with the (?R), (?1), (?2)... recursive expressions, make for a very powerful tool indeed. The following script handles your test data quite nicely: ]*> # CODE opening tag (?R)+ # CODE contents w/nested CODE tags. # CODE closing tag ) # End $1: CODE section. | # Or... ( # $2: Non-CODE section (may be empty). [^ User::setup(array( 'key1' => 'value1', 'key2' => 'value1', 'key42' => ' Pay no attention to this. It has been proven over and over again that it is unpossible to parse nested stuff with regex! ' )); "; // Demonstrate that it works on one small test string. echo("BEFORE:\n". $data ."\n\n"); echo("AFTER:\n". clean_non_code($data) ."\n\nTesting..."); // Build a large test string. $bigdata = ''; for ($i = 0; $i Here are the script benchmark results when run on my test box: WinXP32 PHP 5.2.14 (cli) 'Test string size: 10410000 bytes. Time: 1.219 sec. Speed: 8337 KB/s.' Note that this solution does not handle CODE tags having <> angle brackets in their attributes (probably a very rare edge case), but the regex could be easily modified to handle these as well. Note also that the maximum string length will depend upon the composition of the string content (i.e. Big CODE blocks reduce the maximum input string length.) p.s. Note to SO staff. The doesn't work.
