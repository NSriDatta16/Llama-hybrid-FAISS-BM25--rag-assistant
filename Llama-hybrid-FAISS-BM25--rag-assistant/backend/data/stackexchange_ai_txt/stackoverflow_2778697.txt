[site]: stackoverflow
[post_id]: 2778697
[parent_id]: 2778289
[tags]: 
Struct allocation normally occurs on a 4 byte boundary. That is the compiler will pad data types within a struct up to the 4 byte boundary before starting with the next data type. Given that this is c++ (bool is a sizeof 1) and not c (bool needs to be #define as something) struct blockHeaderStruct { bool allocated; // 1 byte followed by 3 pad bytes unsigned int length; // 4 bytes }; typedef struct blockHeaderStruct blockHeader; typedef struct blockHeaderStruct *blockHeaderPtr; A sizeof operation would result: sizeof(blockHeader) == 8 sizeof(struct blockHeader) == 8 sizeof(blockHeaderPtr) == 4 (Note: The last entry will be 8 for a 64 bit compiler. ) There should be no difference in sizes between the first two lines of code. A typedef merely assigns an alias to an existing type. The third is taking the sizeof a pointer which is 4 bytes in a 32 bit machine and 8 bytes on a 64 bit machine. To fix this, simply apply the #pragma pack directive before a structure is defined. This forces the compiler to pack on the specified boundary. Usually set as 1,2,or 4 (although 4 is normally the default and doesn't need to be set). #include #include #pragma pack(1) struct blockHeaderStruct { bool allocated; unsigned int length; }; typedef struct blockHeaderStruct blockHeader; int main() { printf("sizeof(blockHeader) == %li\n", sizeof(blockHeader)); printf("sizeof(struct blockHeader) == %li\n", sizeof(struct blockHeaderStruct)); return 0; } Compiled with g++ (Ubuntu 4.4.1-4ubuntu9) 4.4.1 Results in: sizeof(blockHeader) == 5 sizeof(structblockHeader) == 5 You don't normally need this directive. Just remember to pack your structs efficiently. Group smaller data types together. Do not alternate
