[site]: stackoverflow
[post_id]: 5671091
[parent_id]: 5668904
[tags]: 
Pyparsing is a fallback from unreadable and fragile regex processors. The parser example below handles your stated format, plus any variety of extra whitespace, and arbitrary order of the assignment expressions. Just as you have used named groups in your regex, pyparsing supports results names, so that you can access the parsed data using dict or attribute syntax (data['Lint'] or data.Lint). from pyparsing import Suppress, Word, nums, oneOf, Regex, ZeroOrMore, Optional # define basic punctuation EQ,LPAR,RPAR,LBRACK,RBRACK = map(Suppress,"=()[]") # numeric values integer = Word(nums).setParseAction(lambda t : int(t[0])) real = Regex(r"[+-]?\d+\.\d*").setParseAction(lambda t : float(t[0])) # id and assignment fields idRef = LBRACK + integer("id") + RBRACK typesep = LPAR + oneOf("D G") + RPAR lExpr = 'L' + EQ + integer("Lint") rExpr = 'R' + EQ + integer("Rint") pExpr = 'p' + EQ + real("pFloat") eExpr = 'e' + EQ + integer("Eint") nExpr = 'n' + EQ + integer("Nint") # accept assignments in any order, with or without leading (D) or (G) assignment = lExpr | rExpr | pExpr | eExpr | nExpr line = idRef + lExpr + ZeroOrMore(Optional(typesep) + assignment) # test the parser text = "[ 0 ] L= 9 (D) R= 14 (D) p= 0.0347222 e= 10 n= 34" data = line.parseString(text) print data.dump() # prints # [0, 'L', 9, 'D', 'R', 14, 'D', 'p', 0.034722200000000002, 'e', 10, 'n', 34] # - Eint: 10 # - Lint: 9 # - Nint: 34 # - Rint: 14 # - id: 0 # - pFloat: 0.0347222 Also, the parse actions do the string->int or string->float conversion at parse time, so that afterward the values are already in a usable form. (The thinking in pyparsing is that, while parsing these expressions, you know that a word composed of numeric digits - or Word(nums) - will safely convert to an int, so why not do the conversion right then, instead of just getting back matching strings and having to re-process the sequence of strings, trying to detect which ones are integers, floats, etc.?)
