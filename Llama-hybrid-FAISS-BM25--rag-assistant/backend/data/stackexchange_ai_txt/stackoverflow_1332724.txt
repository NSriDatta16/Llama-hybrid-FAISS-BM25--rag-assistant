[site]: stackoverflow
[post_id]: 1332724
[parent_id]: 1332670
[tags]: 
There are many more types of errors than just leaks. In order from worst to best: Memory corruption. Data is stored to an area where it shouldn't. This results in both the majority of security problems and is by far the hardest to track down. "Random location" corruption Data is stored to a memory location that the user can control. Data is stored to an array without checking the indices. An object of a type derived from X is stored to an array element reserved for a base type of X , and the size of X is greater than the size of its base. Lifetime corruption Data is store to a memory location after it is freed. Incorrect method of freeing is used (mismatch resulting in new / free , malloc / delete ) delete or free is called twice on the same pointer. Failure to release memory Memory no longer in use by the program remains allocated. Incorrect method of freeing is used: mismatch resulting in new[] / delete instead of new[] / delete[] . Memory is not automatically release because of a circular reference in a reference counting scheme, such as can happen when smart_ptr is used in a circular data structure without attention to using weak_ptr for the circular link. Memory is not freed due to a lost pointer - the last pointer to the memory was cleared before free was called, so there is no way to release it. Memory is not freed due to not properly identifying when the data it contains is no longer needed. An example is a static cache used for some temporary task is never cleared out.
