[site]: crossvalidated
[post_id]: 92894
[parent_id]: 92876
[tags]: 
As a start, I wanted to refer you to a journal article called A Fast Algorithm for Approximate Quantiles in High Speed Data Streams . This is a paper that I have referenced myself before and used in practice when building software that analyze stream data. Additionally, this method was also discussed and implemented here on Intel's site. Below is a snapshot of the simplest code snippet used to compute snapshots of quantiles for streaming data taken from the Intel site showing how the algorithm was implemented. #include "mkl_vsl.h" #include #define DIM 3 /* dimension of the task */ #define N 1000 /* number of observations */ #define M 100 /* number of quantiles to compute */ #define EPS 0.01 /* accuracy of quantile computation */ int main() { int i, status; VSLSSTaskPtr task; float x[DIM][N]; /* matrix of observations */ float q_order[M], quants[M]; float params; MKL_INT q_order_n; MKL_INT p, n, nparams, xstorage; int indices[DIM]={1,0,0}; /* the first vector component is processed */ /* Parameters of the task and initialization */ p = DIM; n = N; q_order_n = M; xstorage = VSL_SS_MATRIX_STORAGE_ROWS; params = EPS; nparams = VSL_SS_SQUANTS_ZW_PARAMS_N; /* Calculate percentiles */ for ( i = 0; i As Zhang notes in his paper, "Streaming quantile computation has several constraints. Data streams are transient and can arrive at a high speed. Furthermore, the stream size may not be known apriori. Streaming computations therefore require single pass algorithms with small space requirement and which are able to handle arbitrary sized streams. In order to guarantee the precision of the result, the algorithm should ensure random or deterministic error bound for the quantile computation." I would start by reading the paper and then going from there. Here is a link to the PDF of the paper. Multiple methods are discussed before their fast algorithm is introduced.
