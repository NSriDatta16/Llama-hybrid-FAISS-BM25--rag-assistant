[site]: stackoverflow
[post_id]: 5519337
[parent_id]: 5519128
[tags]: 
Or you can use the mono CLR embedder Managed code can invoke unmanaged code in two ways, [using P/Invoke or] using the low-level Mono embedding API . This works a lot like the oldfashioned embedding of a Perl, Python or Ruby 'interpreter' (actually, virtual machines) in your C/C++ executable. I don't think there is actually such a thing as a Swig(++) wrapper generator for this (yet), but here is a snippet of what a call into CIL code looks like: class MyClass { static void Foo (int value) { ... } int Bar (string name) { ... } } assuming you got the corresponding MonoMethod* in foo_method and bar_method and this_arg is a MonoObject* of type MyClass, you simply execute: /* we execute methods that take one argument */ void *args [1]; int val = 10; /* Note we put the address of the value type in the args array */ args [0] = &val; /* execute Foo (10); * it's a static method, so use NULL as the second argument. */ mono_runtime_invoke (foo_method, NULL, args, NULL); /* a string is a reference, so we put it directly in the args array */ args [0] = mono_string_new (domain, "Hello"); /* execute my_class_instance.Bar ("Hello"); * See the Creating Objects section to learn how to get this_arg. */ MonoObject *result = mono_runtime_invoke (bar_method, this_arg, args, NULL); /* we always get a MonoObject* from mono_runtime_invoke (), so to get * the integer value we need to unbox (which returns a pointer to * the value stored in the object) and dereference. */ int int_result = *(int*)mono_object_unbox (result); For extra entertainment value : if you AOT-compile all of your CIL code, you'll be able to statically link your assembly into your native binary (effectively doing what Managed C++ (c++-cli) calls mixed mode assemblies). Look at mono --aot=static myassembly.dll and mkbundle
