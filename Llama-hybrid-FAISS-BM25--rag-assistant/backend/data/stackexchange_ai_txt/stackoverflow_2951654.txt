[site]: stackoverflow
[post_id]: 2951654
[parent_id]: 2951586
[tags]: 
I suppose nothing at all. Foo() is allowed, even if it makes no sense... I've tried to change struct into class and tried a diff on the generated exe, and they resulted to be the same, meaning that a class without method is like a struct from a practical and "effective" point of view. But : if you use only one of the alternative, keeping struct or class no matter, it happens that new Foo and new Foo() gives executables which differ! (At least using g++) I.e. struct Foo { int i; double d; } int main() { Foo *f1 = new Foo; delete f1; } is compiled into somehing different from struct Foo { int i; double d; } int main() { Foo *f1 = new Foo(); delete f1; } and the same happens with class instead of struct . To know where the difference is we should look at the generated code... and to know if it is a g++ idiosincracy or not, I should try another compiler but I have only gcc and no time now to analyse the asm output of g++... Anyway from a "functional" (practical) point of view, it is the same thing. Add At the end it is always better to know or do deeper investigation for some common human problems on Q/A sites... the only difference in the code generated by g++ in () and no () cases, movl $0, (%eax) fldz fstpl 4(%eax) which is a fragment that initializes to 0/0.0 the int and the double of the struct... so Seymour knows it better (but I could have discovered it without knowing if I had taken a look at the asm first!)
