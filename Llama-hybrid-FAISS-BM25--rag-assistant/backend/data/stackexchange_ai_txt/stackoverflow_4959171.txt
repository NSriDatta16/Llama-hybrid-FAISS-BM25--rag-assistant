[site]: stackoverflow
[post_id]: 4959171
[parent_id]: 
[tags]: 
Improving memory usage in an array-wide filter to avoid block-processing

I am implementing some satellite image filters, starting with one known as the Enhanced Lee filter. The images are easily up to 5000x5000 pixels and more. My current implementation is running out of memory trying to compute the filters on those large arrays (note that the moving average and moving stddev filters can be run in one shot). The main difficulty is the number of arrays that must be kept in memory in order to return the final filtered array. In this question , I asked for help on refining a block-processing function, but my question is: is there a way of improving this code so that I don't need to use block-processing? def moving_average(Ic, filtsize): Im = numpy.empty(Ic.shape, dtype='Float32') scipy.ndimage.filters.uniform_filter(Ic, filtsize, output=Im) return Im def moving_stddev(Ic, filtsize): Im = numpy.empty(Ic.shape, dtype='Float32') scipy.ndimage.filters.uniform_filter(Ic, filtsize, output=Im) S = numpy.empty(Ic.shape, dtype='Float32') scipy.ndimage.filters.uniform_filter(((Ic-Im) ** 2), filtsize, output=S) return numpy.sqrt(S) def enh_lee(Ic, filtsize, nlooks, dfactor): # Implementation based on PCI Geomatica's FELEE function documentation Ci = moving_stddev(Ic, filtsize) / moving_average(Ic, filtsize) #1st array in memory Cu = numpy.sqrt(1 / nlooks) #scalar Cmax = numpy.sqrt(1 + (2 * nlooks)) #scalar W = numpy.exp(-dfactor * (Ci - Cu) / (Cmax - Ci)) #2nd array in memory Im = moving_average(Ic, filtsize) #3rd array in memory If = Im * W + Ic * (1 - W) #4th array in memory W = None # Back to 3 arrays in memory return numpy.select([Ci = Cmax], [Im, If, Ic]) where nlooks and dfactor are scalars and Ic is the unfiltered array. EDIT based on your suggestions (I am also looking at numexpr ), my improved code for enh_lee is as follows, but is still not enough to get past the last step without running out of memory: def enh_lee(Ic, filtsize, nlooks, dfactor): Im = moving_average(Ic, filtsize) Ci = moving_stddev(Ic, filtsize) Ci /= Im Cu = numpy.sqrt(1 / nlooks) Cmax = numpy.sqrt(1 + (2 * nlooks)) W = Ci W -= Cu W /= Cmax - Ci W *= -dfactor numpy.exp(W, W) If = 1 If -= W If *= Ic If += Im * W W = None return numpy.select([Ci = Cmax], [Im, If, Ic])
