[site]: stackoverflow
[post_id]: 4118435
[parent_id]: 4118211
[tags]: 
If you see the source code of jquery about the .load() method they do ... self.html( selector ? // Create a dummy div to hold the results jQuery(" ") // inject the contents of the document in, removing the scripts // to avoid any 'Permission Denied' errors in IE .append(res.responseText.replace(rscript, "")) // Locate the specified elements .find(selector) : // If not, just inject the full result res.responseText ); ... So if a selector is provided (as is in your case) they remove the script to avoid Permission Denied errors in IE. You will need to imitate this code using the jquery .get() method something like $("#nav a").click(function() { $.get( this.hash.substring(1), function(response){ var dummy = $(' ').append( response ).find('#content_inload'); $("#inload_container").html(dummy); } ); }); Also note that i have used the #inload_container as the target element as you were inserting the #content_inload into itself, in effect duplicating .. Update Well after your comment i tried the following that worked $("#nav a").click(function() { $.get( this.hash.substring(1), function(response){ $("#inload_container").empty().append(response).find('>*:not(#content_inload)').remove(); } ); }); Seems that there might be an issue when you create script elements in in-memory jquery objects ? ( cant be sure of the reason ) In your specific case the above solution will work, but it is not very elegant, in the sense that it adds to the DOM everything returned from the ajax call and it then filters out the stuff we do not want.. It might be better altogether to just alter your actual video page ( the one loaded from ajax ) and do a normal .load() without filtering anything out..
