[site]: stackoverflow
[post_id]: 1182430
[parent_id]: 1182338
[tags]: 
Unfortunately, this isn't particularly easy to do, as the HttpApplication doesn't lend itself to mocking very easily; there is no interface to mock against and most of the methods aren't marked as virtual. I recently had a similar problem with HttpRequest and HttpWebResponse. In the end, the solution I went for was to create a straight "pass-through" wrapper for the methods I wanted to use: public class HttpWebRequestWrapper : IHttpWebRequestWrapper { private HttpWebRequest httpWebRequest; public HttpWebRequestWrapper(Uri url) { this.httpWebRequest = (HttpWebRequest)HttpWebRequest.Create(url); } public Stream GetRequestStream() { return this.httpWebRequest.GetRequestStream(); } public IHttpWebResponseWrapper GetResponse() { return new HttpWebResponseWrapper(this.httpWebRequest.GetResponse()); } public Int64 ContentLength { get { return this.httpWebRequest.ContentLength; } set { this.httpWebRequest.ContentLength = value; } } public string Method { get { return this.httpWebRequest.Method; } set { this.httpWebRequest.Method = value; } } public string ContentType { get { return this.httpWebRequest.ContentType; } set { this.httpWebRequest.ContentType = value; } } } etc, etc This let me mock against my own wrapper interface. Not necessarily the most elegant thing in the world, but a very useful way of mocking out some of the less "mockable" parts of the framework. Before you rush off and do this though, it is worth reviewing what you've got and seeing if there is a better approach to your tests that would avoid you having to wrap classes. In the case of HttpWebRequest, HttpApplication et al, there often isn't IMHO. In order to set this wrapper in mock (using my HttpWebRequest example above) you then do stuff like this with Moq: var mockWebRequest = new Mock (); mockWebRequest.SetupSet (c => c.Method = "POST").Verifiable(); mockWebRequest.SetupSet (c => c.ContentType = "application/x-www-form-urlencoded").Verifiable(); mockWebRequest.SetupSet (c => c.ContentLength = 0).Verifiable();
