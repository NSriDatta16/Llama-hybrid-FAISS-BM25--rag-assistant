[site]: stackoverflow
[post_id]: 5498570
[parent_id]: 5497284
[tags]: 
Instantiating any of the iostream classes, or basic_string, on anything but char or wchar_t, without providing a specific custom traits class, is undefined behavior; most of the libraries I've seen do define it to do something, but that definition often isn't specified, and is different between VC++ and g++ (the two cases I've looked at). If you define and use your own traits class, some of the functionality should work. For just about all of the formatted inserters and extractors (the and >> operators), istream and ostream delegate to various facets in the locale; if any of these are used, you'll have to take steps to ensure that these work as well. (This usually means providing a new numpunct facet.) Even if you only use the streambuf (as in your example), filebuf uses the codecvt facet. And an implementation isn't required to provide a codecvt, and if it does, can do pretty much whatever it wants in it. And since filebuf always writes and reads char to and from the file, this translation must do something. I'm actually rather surprised that your code worked, because of this. But you still don't know what was actually on the disk, which means you can't document it, which means that you won't be able to read it sometime in the future. If your goal is to write binary data, your first step should be to define the binary format, then write read and write functions which implement it. Possibly using the iostream > syntax, and probably using a basic_streambuf for the actual input and output; a basic_streambuf that you've carefully imbued with the "C" locale. Or rather than define your own binary format, just use an existing one, like XDR. (All of this paragraph supposes that you want to keep the data, and read it later. If these are just temporary files, for spilling temporary internal data to disk during a single run, and will be deleted at the end of the program execution, simpler solutions are valid.)
