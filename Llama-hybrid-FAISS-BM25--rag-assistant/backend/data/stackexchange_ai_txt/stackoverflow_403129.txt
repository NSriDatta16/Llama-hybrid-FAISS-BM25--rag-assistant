[site]: stackoverflow
[post_id]: 403129
[parent_id]: 402957
[tags]: 
A 0xC0000005 is an access violation, so something is trying to read from or write to an address that it doesn't have rights to access. These tend to be really hard to find and experience is one of the best tools (well Platform Builder's debugger is really helpful too, but that's a whole separate avenue of debugging and requires experience that you probably don't have or you'd have already tried it). I find that logging tends to be less useful that subtractive coding - removing P/invoke calls with mock managed calls whenever possible. Access violations in managed apps typically happen for one of these reasons: You P/Invoke a native API passing in a handle to a managed object and the native API uses that handle. If you get a collection and compaction while the native API is running, the managed object may move and the pointer becomes invalid. You P/Invoke something with a buffer that is too small or smaller than the size you pass in and the API overruns a read or write A pointer (IntPtr, etc) you pass to a P/Invoke call is invalid (-1 or 0) and the native isn't checking it before use You P/Invoke a native call and the native code runs out of memory (usually virtual) and isn't checking for failed allocations and reads/writes to an invalid address You use a GCHandle that is not initialized or that somehow is pointing to an already finalized and collected object (so it's not pointing to an object, it's pointing to an address where an object used to be) Your app uses a handle to something that got invalidated by a sleep/wake. This is more esoteric but certainly happens. For example, if you're running an application off of a storage card, the entire app isn't loaded into RAM. Pieces in use are demand-paged in for execution. This is all well and good. Now if you power the device off, the drivers all shut down. When you power back up, many devices simply re-mount the storage devices. When your app needs to demand-page in more program, it's no longer where it was and it dies. Similar behavior can happen with databases on mounted stores. If you have an open handle to the database, after a sleep/wake cycle the connection handle may no longer be valid. You'll note the trend here that almost all of these are P/Invokes and that's no accident. It's quite difficult to get managed code to do this on its own.
