[site]: stackoverflow
[post_id]: 47932
[parent_id]: 30710
[tags]: 
I can perhaps give you a taste of our experience when we began looking at unit testing our middle-tier process that included a ton of "business logic" sql operations. We first created an abstraction layer that allowed us to "slot in" any reasonable database connection (in our case, we simply supported a single ODBC-type connection). Once this was in place, we were then able to do something like this in our code (we work in C++, but I'm sure you get the idea): GetDatabase().ExecuteSQL( "INSERT INTO foo ( blah, blah )" ) At normal run time, GetDatabase() would return an object that fed all our sql (including queries), via ODBC directly to the database. We then started looking at in-memory databases - the best by a long way seems to be SQLite. ( http://www.sqlite.org/index.html ). It's remarkably simple to set up and use, and allowed us subclass and override GetDatabase() to forward sql to an in-memory database that was created and destroyed for every test performed. We're still in the early stages of this, but it's looking good so far, however we do have to make sure we create any tables that are required and populate them with test data - however we've reduced the workload somewhat here by creating a generic set of helper functions that can do a lot of all this for us. Overall, it has helped immensely with our TDD process, since making what seems like quite innocuous changes to fix certain bugs can have quite strange affects on other (difficult to detect) areas of your system - due to the very nature of sql/databases. Obviously, our experiences have centred around a C++ development environment, however I'm sure you could perhaps get something similar working under PHP/Python. Hope this helps.
