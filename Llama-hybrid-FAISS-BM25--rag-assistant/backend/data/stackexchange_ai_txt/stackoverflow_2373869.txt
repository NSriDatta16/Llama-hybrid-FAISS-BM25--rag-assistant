[site]: stackoverflow
[post_id]: 2373869
[parent_id]: 2373579
[tags]: 
The key is to parse one chunk at a time and match all the relevant stuff at once. See qr in perldoc perlop and $/ in perldoc perlvar . Keeping in mind the fact that you also wanted to put the information in a data structure that would allow you to query and manipulate the information, here is one final revision. The code below uses the ability of SQLite to create in-memory databases. You might actually want to split the functionality into two scripts: One to parse and store the data and another one to do whatever manipulation you need. In fact, it might be possible to do all necessary manipulation in SQL. #!/usr/bin/perl use v5.010; use strict; use warnings; use DBI; my $dbh = get_dbh(); my $header_pattern = qr{ History[ ]for: [ ](? [^\n]+) \n Description: [ ](? [^\n]+) \n Locked[ ]by: [ ]?(? [^\n]*) \n Status: [ ](? .[^\n]+) \n }x; my $revision_pattern = qr{-+\n Revision: [ ](? \d+) [ ] View: [ ](? .+) [ ] Branch[ ]Revision: [ ](? [^\n]+) \n Author: [ ](? .+) [ ] Date: [ ](? [^\n]+) \n (? .*) \n }x; local $/ = '=' x 77 . "\n"; while ( my $entry = <>) { if ( $entry =~ $header_pattern ) { my %file = %+; $dbh->do(sprintf( q{INSERT INTO files (%s) VALUES (%s)}, join(',', keys %file), join(',', ('?') x keys %file), ), {}, values %file ); while ( $entry =~ /$revision_pattern/g ) { my %rev = %+; $dbh->do(sprintf( q{INSERT INTO revisions (%s) VALUES (%s)}, join(',', filename => keys %rev), join(',', ('?') x (1 + keys %rev)), ), {}, $file{filename}, values %rev ); } } } my $revs = $dbh->selectall_arrayref( q{SELECT * FROM revisions JOIN files ON files.filename = revisions.filename}, { Slice => {} } ); use Data::Dumper; print Dumper $revs; sub get_dbh { my $dbh = DBI->connect( 'dbi:SQLite:dbname=:memory:', undef, undef, { RaiseError => 1, AutoCommit => 1 } ); $dbh->do(q{PRAGMA foreign_keys = ON}); $dbh->do(q{CREATE TABLE files ( filename VARCHAR PRIMARY KEY, description VARCHAR, lockedby VARCHAR, status VARCHAR )}); $dbh->do(q{CREATE TABLE revisions ( filename VARCHAR, revision VARCHAR, view VARCHAR, branch_revision VARCHAR, author VARCHAR, revdate VARCHAR, summary VARCHAR, CONSTRAINT pk_revisions PRIMARY KEY (filename, revision), CONSTRAINT fk_revisions_files FOREIGN KEY (filename) REFERENCES files(filename) )}); return $dbh; } Output: C:\Temp> y.pl test.txt $VAR1 = [ { 'status' => 'Current', 'revdate' => '3/22/08 11:16:16 AM CST', 'author' => 'John Smith', 'description' => 'Some files', 'revision' => '1', 'filename' => 'main.h', 'summary' => 'Main header', 'view' => 'The View Name', 'branch_revision' => '1.0', 'lockedby' => '' }, { 'status' => 'Current', 'revdate' => '3/22/08 1:55:55 PM CST', 'author' => 'Jane Doe', 'description' => 'Some files', 'revision' => '2', 'filename' => 'main.c', 'summary' => 'Made an update.', 'view' => 'The View Name', 'branch_revision' => '1.1', 'lockedby' => '' }, { 'status' => 'Current', 'revdate' => '3/22/08 11:16:16 AM CST', 'author' => 'John Smith', 'description' => 'Some files', 'revision' => '1', 'filename' => 'main.c', 'summary' => 'Initial revision', 'view' => 'The View Name', 'branch_revision' => '1.0', 'lockedby' => '' } ];
