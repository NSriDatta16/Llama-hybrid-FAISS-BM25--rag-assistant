[site]: stackoverflow
[post_id]: 2501107
[parent_id]: 2366698
[tags]: 
I am still working through some issues trying to solve this issue, but I wanted to update with some details of the approach I've settled on. The first thing that I realized was that I had to upgrade from using JAXWS-RI 2.1 to Metro 2.0. We had previously used JAXWSRI-2.1 in this project, but we'd never had to deal with any WS-Security before. Anyway, I realized that I needed to upgrade, so I did that to take advantage of Metro 2.0 and the WSIT jars that were included with it. Then, I was still confused about exactly how to do about generating the WS-Security headers that I needed w/o having the WS-Policy info from the service's WSDL file. I had attempted to set a CallbackHandlerFeature using the APIs suggested by LES2, but that was not generating the headers for me. So, I posted a question on the Metro/JAXB board at java.net here: http://forums.java.net/jive/message.jspa?messageID=392451#392451 In the responses to that, one answerer suggested using NetBeans to write a dummy web service and set up the security settings that I though the .NET's service was using. Once I did that, NetBeans generated a WS-Policy section in the wsit-.xml file that I could use. I plugged that WS-Policy section into my local copy of the .NET service's WSDL, and also used it to create a wsit-client.xml file that I put in my WEB-INF/classes directory. Once I did that, Metro/WSIT began adding the WS-Security headers to request for me. I was then running into some issues, because Metro was using a different version of WS-Addressing than was required by the .NET service (they use MemberSubmissionAddressing). So, I ended up tweaking my WS-Policy settings to use Now, I'm at the point where I've got my SOAP request looking like this: https://10.49.38.78/2009/12/CaseDetailsService.asmx http://schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous uuid:89a0dfdf-014c-4be7-a677-ab1b4d30cdb5 2010-03-22T19:48:04Z 2010-03-22T19:53:04Z DATA_HERE CN=server -24583240032357195994117623470001087391 vtf9n+OcI1nT0exavD4/ZQy6jm8= hn2umVvzokVW6dgXUzXcG00vfq8= MIH/94A7R2iHn/und3ElJLRTWKY= olcbTjCNnXuZ5eVR1glEWRJxQpw= And, while that doesn't exactly match the sample given to me by the .NET team, I think it that it is correct. However, I'm still getting an error when I call the .NET service. This is the error message that comes back in a SOAPFault from them: System.Web.Services.Protocols.SoapHeaderException: Server unavailable, please try later ---> System.ApplicationException: WSE841: An error occured processing an outgoing fault response. ---> System.Web.Services.Protocols.SoapHeaderException: Microsoft.Web.Services3.Security.SecurityFault: The security token could not be authenticated or authorized ---> System.Security.SecurityException: WSE3003: The certificate's trust chain could not be verified. Please check if the certificate has been properly installed in the Trusted People Certificate store. Or you might want to set allowTestRoot configuration section to true if this is a test certificate. So, I'm currently working with them to figure out why the certificate's trust chain can't be verified - I'm unclear on whether that particular issue is on my end or theirs. Any suggestions would be appreciated!
