[site]: stackoverflow
[post_id]: 3676592
[parent_id]: 3597985
[tags]: 
Original answer was updated to address pthread_exit() scenario. Assuming you want to tell whether all threads were pthread_join() -ed properly before you return from main() , there are a few ways: Run it under the gdb and break on the last line of main() , then look at the output of "threads" command. There should only be main thread. Make a shared library that overrides pthread_create with a wrapper that keeps a counter of how many threads are started. Thread wrapper increments a counter and calls the actual thread function, and a function registered with pthread_create_key() will decrement it when a thread returns or exits. Library destructor will check if the counter is zero, which means that all of them were terminated. Use it with your executable with LD_PRELOAD=checker.so ./your_executable (no code modification necessary). Tested on Debian 5.0.5. checker.c #define _GNU_SOURCE #include #include #include #include /* thread-local storage key */ static pthread_key_t tls_key = 0; static int counter = 0; static pthread_mutex_t g_mutex; /* TLS destructor prototype */ void on_thread_end(void*); void __attribute__ ((constructor)) init_checker() { pthread_mutexattr_t attr; pthread_mutexattr_init(&attr); pthread_mutex_init(&g_mutex, &attr); pthread_mutexattr_destroy(&attr); pthread_key_create(&tls_key, &on_thread_end); } void __attribute__ ((destructor)) finalize_checker() { int remain; pthread_mutex_lock(&g_mutex); remain = counter; pthread_mutex_unlock(&g_mutex); pthread_mutex_destroy(&g_mutex); if (remain) fprintf(stderr, "Warning: %d threads not terminated\n", remain); pthread_key_delete(tls_key); } /* thread function signature */ typedef void* (*ThreadFn)(void*); struct wrapper_arg { ThreadFn fn; void* arg; }; /* TLS destructor: called for every thread we created when it exits */ void on_thread_end(void *arg) { free(arg); pthread_mutex_lock(&g_mutex); --counter; pthread_mutex_unlock(&g_mutex); } static void* thread_wrapper(void *arg) { void *ret; struct wrapper_arg *warg; warg = (struct wrapper_arg*)arg; /* Thread started, increment count. */ pthread_mutex_lock(&g_mutex); ++counter; pthread_mutex_unlock(&g_mutex); /* set thread-specific data to avoid leaks * when thread exits */ pthread_setspecific(tls_key, arg); /* Run the actual function. */ ret = (*warg->fn)(warg->arg); /* Thread finishes, TLS destructor will be called. */ return ret; } /* pthread_create signature */ typedef int (*CreateFn)(pthread_t*,const pthread_attr_t*,ThreadFn,void*); /* Overriding phtread_create */ int pthread_create( pthread_t *thread, const pthread_attr_t *attr, ThreadFn start_routine, void *arg) { CreateFn libc_pthread_create; struct wrapper_arg *warg; /* Get a handle to the real function. */ libc_pthread_create = (CreateFn)dlsym(RTLD_NEXT, "pthread_create"); if (!libc_pthread_create) return -1; /* Wrap user function. */ warg = malloc(sizeof(struct wrapper_arg)); if (!warg) return -1; warg->fn = start_routine; warg->arg = arg; /* Create a thread with a wrapper. */ return libc_pthread_create(thread, attr, &thread_wrapper, warg); } Makefile CFLAGS+=-fpic -O3 checker.so: checker.o gcc -shared -Wl,-soname,$@ -o $@ $^ -ldl -lpthread
