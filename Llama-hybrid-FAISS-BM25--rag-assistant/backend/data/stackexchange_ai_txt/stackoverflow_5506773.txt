[site]: stackoverflow
[post_id]: 5506773
[parent_id]: 5506729
[tags]: 
---EDIT---: (Previous wrong trials removed) 2nd try (not really relational algebra). This works but only when the fields are char(1): SELECT colA, colB, colC FROM mytable WHERE CONCAT(colA, colB, colC) BETWEEN CONCAT('A', 'B', 'C') AND CONCAT('D', 'E', 'F') ORDER BY colA, colB, colC LIMIT 1 ; I thought that a view that shows all combinations of tuples from mytable that are less than or equal to tuples of the same table might be helpful, as it can be used for other comparisons: CREATE VIEW lessORequal AS ( SELECT a.colA AS smallA , a.colB AS smallB , a.colC AS smallC , b.colA AS largeA , b.colB AS largeB , b.colC AS largeC FROM mytable a JOIN mytable b ON (a.colA Using similar technique, this solves the question. It works with any kind of fields (int, float, char of any length). It's going to be kind of awkard and complicated though if one tries to add more fields. SELECT colA, colB, colC FROM mytable m WHERE ( ('A' One also define a function: CREATE FUNCTION IslessORequalThan( lowA CHAR(1) , lowB CHAR(1) , lowC CHAR(1) , highA CHAR(1) , highB CHAR(1) , highC CHAR(1) ) RETURNS boolean RETURN ( (lowA and use it to solve the same or similar problems. This solves the question again. The query is elegant but a new function has to be created if the type or number of fields is changed. SELECT colA , colB , colC FROM mytable WHERE IslessORequalThan( 'A', 'B', 'C', colA, colB, colC ) AND IslessORequalThan( colA, colB, colC, 'D', 'E', 'F' ) ORDER BY colA, colB, colC LIMIT 1; Until then, and because the condition (colA, colB, colC) BETWEEN ('A', 'B', 'C') AND ('D', 'E', 'F') was not allowed in MySQL, I thought that ('A', 'B', 'C') was not allowed as well. But I was wrong.
