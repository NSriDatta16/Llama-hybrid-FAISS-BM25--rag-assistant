[site]: stackoverflow
[post_id]: 4628066
[parent_id]: 4627305
[tags]: 
Hard to tell from the snippet. The standard mistake is to draw through Control.CreateGraphics() instead of the OnPaint() method. Won't work, Windows lets the OnPaint method run when parts of the control get uncovered. Which wipes out whatever you drew. Another failure mode is deriving from a control that's a wrapper for a native Window control. UserPaint is not supported for these type of controls, the native Windows code has to do the drawing. It is clear from the screen shot, note how the text is staggered. That's because the OnPaint() override is using the e.ClipRectangle property to figure out where to draw. That value always changes when you slowly drag a window across your control, it only tells you what part of the control needs to be redrawn. It does not tell you where to draw. That has to be based on the control bounds, routinely the rectangle from (0,0) to (ClientSize.Width, ClientSize.Height). Only ever use e.ClipRectangle to optimize the drawing. Like skipping an expensive drawing detail when it is outside of the clipping rectangle. It is otherwise a small one, Windows is already quite good at clipping automatically.
