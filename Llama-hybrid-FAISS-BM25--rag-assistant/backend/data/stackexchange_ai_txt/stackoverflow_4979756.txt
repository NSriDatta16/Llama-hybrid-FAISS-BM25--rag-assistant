[site]: stackoverflow
[post_id]: 4979756
[parent_id]: 4979038
[tags]: 
Look into binding your button to a Command Binding instead of the click event. You can find implementations of DelegateCommand using Google. Next you can expose a ImageSource from your ViewModel that you can bind to your Image from your XAML. I've included some code fragments to get you started. Once you get past the basics take a look at MVVM Frameworks, like Cinch , you'll find a way to handle OpenFileDialog using the Services Interfaces IOpenFileService.cs to not violate the MVVM pattern. Here is the XAML: Here is the ViewModel: public MainViewModel() { UpdatePictureCommand = new DelegateCommand (OnUpdatePictureCommand, CanUpdatePictureCommand); } public ICommand UpdatePictureCommand { get; private set; } private void OnUpdatePictureCommand(object obj) { OpenFileDialog OpenFileDialog = new OpenFileDialog(); if (OpenFileDialog.ShowDialog() == true) { //(listbox.SelectedItem as ContactManager.ViewModel.Contact).Photo = // LoadPhoto(OpenFileDialog.FileName); Stream reader = File.OpenRead(OpenFileDialog.FileName); System.Drawing.Image photo = System.Drawing.Image.FromStream((Stream)reader); MemoryStream finalStream = new MemoryStream(); photo.Save(finalStream, ImageFormat.Png); // translate to image source PngBitmapDecoder decoder = new PngBitmapDecoder(finalStream, BitmapCreateOptions.PreservePixelFormat, BitmapCacheOption.Default); EmployeePicture = decoder.Frames[0];; } private bool CanMoveFirstCommand(object obj) { return true; } private ImageSource _employeePicture; public ImageSource EmployeePicture { get { return _employeePicture; } set { _employeePicture = value; OnPropertyChanged("EmployeePicture"); } }
