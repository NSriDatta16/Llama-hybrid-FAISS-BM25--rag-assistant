[site]: stackoverflow
[post_id]: 4551635
[parent_id]: 4551054
[tags]: 
Haskell â€” 174 142 137 133 characters import List a#m=maybe[](\x->"->"++x++x#m)$lookup a m q[f,s]=f\\s>>=(\a->a++a#zip f s++"\n") main=interact$q.transpose.map words.lines Ungolfed: import Data.List type Node = String follow :: Node -> [(Node,Node)] -> String follow node pairs = maybe "" step $ lookup node pairs where step next = "->" ++ next ++ follow next pairs chains :: [[Node]] -> String chains [firsts,seconds] = concatMap chain $ firsts \\ seconds where chain node = node ++ follow node pairs ++ "\n" pairs = zip firsts seconds process :: [String] -> String process = chains . transpose . map words main :: IO () main=interact $ process . lines Less elegant approach than before, but shorter! Inspired by Nas Banov's idea of h.keys-h.values
