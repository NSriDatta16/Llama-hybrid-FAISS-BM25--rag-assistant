[site]: stackoverflow
[post_id]: 1374540
[parent_id]: 1374468
[tags]: 
The ss.str() temporary is destroyed after initialization of cstr2 is complete. So when you print it with cout , the c-string that was associated with that std::string temporary has long been destoryed, and thus you will be lucky if it crashes and asserts, and not lucky if it prints garbage or does appear to work. const char* cstr2 = ss.str().c_str(); The C-string where cstr1 points to, however, is associated with a string that still exists at the time you do the cout - so it correctly prints the result. In the following code, the first cstr is correct (i assume it is cstr1 in the real code?). The second prints the c-string associated with the temporary string object ss.str() . The object is destroyed at the end of evaluating the full-expression in which it appears. The full-expression is the entire cout expression - so while the c-string is output, the associated string object still exists. For cstr2 - it is pure badness that it succeeds. It most possibly internally chooses the same storage location for the new temporary which it already chose for the temporary used to initialize cstr2 . It could aswell crash. cout The return of c_str() will usually just point to the internal string buffer - but that's not a requirement. The string could make up a buffer if its internal implementation is not contiguous for example (that's well possible - but in the next C++ Standard, strings need to be contiguously stored). In GCC, strings use reference counting and copy-on-write. Thus, you will find that the following holds true (it does, at least on my GCC version) string a = "hello"; string b(a); assert(a.c_str() == b.c_str()); The two strings share the same buffer here. At the time you change one of them, the buffer will be copied and each will hold its separate copy. Other string implementations do things different, though.
