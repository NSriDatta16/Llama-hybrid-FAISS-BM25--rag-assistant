[site]: stackoverflow
[post_id]: 2166241
[parent_id]: 2165740
[tags]: 
This kind of reverses IEnumerable , and is more comparable to what we did with PushLINQ - but it is a lot simpler than implementing an iterator block on the fly (through IL), while retaining blinding performance thanks to dynamic-method; the use of object is in case your data is non-orthogonal and you need multiple types through the same API: using System; using System.Reflection; using System.Reflection.Emit; // the type we want to iterate efficiently without hard code class Foo { public int X, Y; } // what we want to do with each item of data class DemoPusher : IPusher { public void Push(int value) { Console.WriteLine(value); } } // interface for the above implementation interface IPusher { void Push(T value); } static class Program { // see it working static void Main() { Foo foo = new Foo { X = 1, Y = 2 }; var target = new DemoPusher(); var pushMethod = CreatePusher (typeof(Foo)); pushMethod(foo, target); } // here be dragons static Action > CreatePusher (Type source) { DynamicMethod method = new DynamicMethod("pusher", typeof(void), new[] { typeof(object), typeof(IPusher ) }, source); var il = method.GetILGenerator(); var loc = il.DeclareLocal(source); il.Emit(OpCodes.Ldarg_0); il.Emit(OpCodes.Castclass, source); il.Emit(OpCodes.Stloc, loc); MethodInfo push = typeof(IPusher ).GetMethod("Push"); foreach (var field in source.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) { if (field.FieldType != typeof(T)) continue; il.Emit(OpCodes.Ldarg_1); il.Emit(OpCodes.Ldloc, loc); il.Emit(OpCodes.Ldfld, field); il.EmitCall(OpCodes.Callvirt, push, null); } il.Emit(OpCodes.Ret); return (Action >) method.CreateDelegate(typeof(Action >)); } }
