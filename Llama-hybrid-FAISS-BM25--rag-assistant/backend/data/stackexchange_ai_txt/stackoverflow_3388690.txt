[site]: stackoverflow
[post_id]: 3388690
[parent_id]: 3388008
[tags]: 
I guess it depends on the level of control you want to have over what happens during the AJAX call. Webmethods will certainly work, but what I've been using in a recent project is creating a .ASHX handler per distinct functionality you want to expose to your AJAX calls. You still have access to any context variables such as request, response, querystring, session etc and the logic is nicely encapsulated away from any pages and you also don't get the overhead of a 'normal' page processing and life cycle, which should improve performance. Just be careful to set your caching levels, because ASHX handlers seem very 'cacheable' by default. Example, ashx to retrieve all employees for a certain position and return the results in JSON format: public class GetEmployeesForPosition : IHttpHandler { public void ProcessRequest(HttpContext context) { context.Response.ContentType = "application/json"; context.Response.Clear(); context.Response.AddHeader("Pragma", "no-cache"); context.Response.AddHeader("Expires", "-1"); var position = new Entity.Model.Position { Code = context.Request.QueryString["code"] }; var language = new Language { Key = context.Request.QueryString["language"] }; var list = new EmployeeManager().GetForPosition(position, language); var employeeMenuList = new List >(); foreach (var emp in list) { var item = new KeyValuePair (emp.Person.Number, emp.Person.DisplayName); employeeMenuList.Add(item); } var json = JsonSerializer.ToJson(employeeMenuList); context.Response.Write(json); } public bool IsReusable { get { return true; } } }
