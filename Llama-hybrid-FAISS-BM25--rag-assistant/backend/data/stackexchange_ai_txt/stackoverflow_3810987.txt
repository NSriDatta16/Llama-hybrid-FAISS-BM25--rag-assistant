[site]: stackoverflow
[post_id]: 3810987
[parent_id]: 3810866
[tags]: 
I'll tell you one thing that you can look at for increasing the speed. You only generally have NULL values in the data for either unknown or non-applicable rows. It appears to me that, since you're treating NULL as 0 anyway, you should think about getting rid of them and making sure that all extrasPrice values are 0 where they were previously NULL so that you can get rid of the time penalty of the coalesce . In fact, you could go one step further and introduce another column called totalPrice which you set with an insert/update trigger to the actual value ItemsPrice + extrasPrice or ( ItemsPrice + COALESCE(extrasPrice,0.0) if you still need nullability of extrasPrice ). Then, you can simply use: SELECT COUNT(*) AS ordersCount, SUM(totalPrice) AS totalValue, SUM(ItemsPrice) AS totalValue2, : (I'm not sure you should have two output columns with the same name or whether that was a typo, that's going to be, at worst, an error, at best, confusing). This moves the cost of the calculation to insert/update time rather than select time and amortises that cost over all the selects - most database tables are read far more often than written. The consistency of the data is maintained due to the trigger and the performance should be better, at the cost of some storage requirements. But, since the vast majority of database questions are "How can I get more speed?" rather than "How can I use less disk?", that's often a good idea. Another suggestion is to provide a non-composite index on the column that reduces your result set the fastest (high cardinality). In other words, if you store only two weeks worth of data (14 different dates) in your table but 400 different shops, you should have an index on senderShop_id and make sure your statistics are up to date. This should cause the DBMS execution engine to whittle down the result set using that key so that subsequent operations are faster. A composite index on deliveryDate,senderShop_id,... will not be able to use senderShop_id to whittle down the results because the key ordering will be senderShop_id within deliveryDate .
