[site]: stackoverflow
[post_id]: 3083193
[parent_id]: 3057341
[tags]: 
I read answers and comments and I see that few things weren't mentioned: data.frame uses list(...) version. Fragment of the code: object object is used to do some magic with column names, but x is used to create final data.frame . For use of unevaluated ... argument look at write.csv code where match.call is used. As you write in comment result in Dirk answer is not a list of lists. Is a list of length 4, which elements are language type. First object is a symbol - list , second is expression 1:10 and so on. That explain why [-1L] is needed: it removes expected symbol from provided arguments in ... (cause it is always a list). As Dirk states substitute returns "parse tree the unevaluated expression". When you call my_ellipsis_function(a=1:10,b=11:20,c=21:30) then ... "creates" a list of arguments: list(a=1:10,b=11:20,c=21:30) and substitute make it a list of four elements: List of 4 $ : symbol list $ a: language 1:10 $ b: language 11:20 $ c: language 21:30 First element doesn't have a name and this is [[1]] in Dirk answer. I achieve this results using: my_ellipsis_function As above we can use str to check what objects are in a function. my_ellipsis_function It's ok. Lets see substitute version: my_ellipsis_function Isn't what we needed. You will need additional tricks to deal with these kind of objects (as in write.csv ). If you want use ... then you should use it as in Shane answer, by list(...) .
