[site]: stackoverflow
[post_id]: 4093750
[parent_id]: 2254872
[tags]: 
You can achieve this through the use of the JsonConverter class. Suppose you have a class with an interface property; public class Organisation { public string Name { get; set; } [JsonConverter(typeof(TycoonConverter))] public IPerson Owner { get; set; } } public interface IPerson { string Name { get; set; } } public class Tycoon : IPerson { public string Name { get; set; } } Your JsonConverter is responsible for serializing and de-serializing the underlying property; public class TycoonConverter : JsonConverter { public override bool CanConvert(Type objectType) { return (objectType == typeof(IPerson)); } public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) { return serializer.Deserialize (reader); } public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) { // Left as an exercise to the reader :) throw new NotImplementedException(); } } When you work with an Organisation deserialized via Json.Net the underlying IPerson for the Owner property will be of type Tycoon.
