[site]: stackoverflow
[post_id]: 2697187
[parent_id]: 2697024
[tags]: 
Let's start with an easier example. Say we have an array of strings we want to have in caps: ['foo', 'bar', 'blah'].map { |e| e.upcase } # => ['FOO', 'BAR', 'BLAH'] Also, you can create so called Proc objects (closures): block = proc { |e| e.upcase } block.call("foo") # => "FOO" You can pass such a proc to a method with the & syntax: block = proc { |e| e.upcase } ['foo', 'bar', 'blah'].map(&block) # => ['FOO', 'BAR', 'BLAH'] What this does, is call to_proc on block and then calls that for every block: some_object = Object.new def some_object.to_proc proc { |e| e.upcase } end ['foo', 'bar', 'blah'].map(&some_object) # => ['FOO', 'BAR', 'BLAH'] Now, Rails first added the to_proc method to Symbol, which later has been added to the ruby core library: :whatever.to_proc # => proc { |e| e.whatever } Therefore you can do this: ['foo', 'bar', 'blah'].map(&:upcase) # => ['FOO', 'BAR', 'BLAH'] Also, Symbol#to_proc is even smarter, as it actually does the following: :whatever.to_proc # => proc { |obj, *args| obj.send(:whatever, *args) } This means that [1, 2, 3].inject(&:+) equals [1, 2, 3].inject { |a, b| a + b }
