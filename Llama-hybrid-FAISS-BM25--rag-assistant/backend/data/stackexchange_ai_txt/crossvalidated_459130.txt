[site]: crossvalidated
[post_id]: 459130
[parent_id]: 
[tags]: 
Determining standard error of the mean from a correlated, stationary time series using known autocorrelation without block averaging

I'd like to determine the SEM of measurements taken from a stationary time series. SEM calculation using all measurements isn't accurate because adjacent measurements may be highly correlated, so the number of independent samples is lower than the number of actual measurements. The use-case is energy measurements from molecular dynamics simulation, but I'm using simulated data to control the autocorrelation first. I'd like to achieve this using the estimated autocorrelation and not by block averaging. Here's a simulated dataset with autocorrelation=0.95 , using python: import numpy as np T = 1000 y = np.zeros((T,)) autocorr = 0.95 for i in range(1,T): y[i] = autocorr * y[i-1] + np.random.normal() One could then perform block averaging to visualize how the SEM approaches the true value while using larger and larger block sizes. Using skimage.measure.block_reduce to do the blocking shows the following, and you might guesstimate the SEM to be around 0.4: from scipy.stats import sem from skimage.measure import block_reduce import matplotlib.pyplot as plt plt.plot([sem(block_reduce(y, (i,), func=np.mean)) for i in range(1,200)], '-o') plt.xlabel('Block size (no. data points)') plt.ylabel('SEM') However I'd rather use the autocorrelation since block averaging has a bunch of arbitrary choices - when do you decide the SEM has converged? From which measurement do you start the blocking? Also block averaging requires removing the data that doesn't fit into a block, which seems wasteful. Alternatively, autocorrelation can be estimated by a bunch of methods, for example in numpy: ac = np.correlate(y-y.mean(), y-y.mean(), mode='full') #correlation of y against itself ac /= ac.max() #normalize ac = ac[int(ac.shape[0]/2):] #only return the autocorrelation starting from timelag 0. print(ac[1]) out: 0.9304976 Pretty close to the true value. Or perhaps autocorrelation is found by fitting an AR(1) autoregressive model. I used pymc3 to do that but the code isn't essential for the question, and it generates an estimate for the autocorrelation consistent with the above. So at this point, how does one determine the SEM given the estimated autocorrelation? Thanks!
