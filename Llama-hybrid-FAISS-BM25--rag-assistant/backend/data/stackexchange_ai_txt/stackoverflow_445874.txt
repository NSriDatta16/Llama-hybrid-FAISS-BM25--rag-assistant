[site]: stackoverflow
[post_id]: 445874
[parent_id]: 441599
[tags]: 
This is the code that works for me. It is based on erisu's answer and Wikipedia's description of the BMP format . For anyone else using this answer, I recommend that you understand the BMP format as fully as possible, so you can adjust the header fields accordingly. The complicated loop at the end is my workaround for an issue with my hardware/OS, where it would not write all of the data I supplied to fwrite. It should work in any environment, though. #if _MSC_VER > 1000 #pragma once #endif // _MSC_VER > 1000 #define WIN32_LEAN_AND_MEAN #include #include #define NPAL_ENT 256 INT WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, INT nShowCmd ) { int w = 1920, h = 1080; // My values, yours may vary //////////////////////// File Operations /////////////////////////////// // Reading raw img FILE* f = fopen("\\FlashDisk\\raw_img.bin","r"); if(NULL == f){printf("BAD");exit(1);} // Obtaining size of raw img fseek (f , 0L , SEEK_END); DWORD fsize = (DWORD)ftell (f); fseek (f , 0L , SEEK_SET); char *imgData = (char*) malloc (sizeof(char)*fsize); if(NULL == imgData) {printf("NOT imgData");exit(2);} // Copy contents of file into buffer DWORD result = fread(imgData,1,fsize,f); if (result != fsize) { printf ("Reading error. Expected: %d, Got: %d\n",fsize, result ); if(ferror(f)){printf("An error: %d\n", ferror(f)); } if(feof(f)) {printf("EOF\n");} delete[] imgData; fclose(f); exit (3); } fclose(f); //////////////////////// BMP Operations /////////////////////////////// /* A bitmap has the following components: * 1. BMP file header * 2. Bitmap Information (DIB) header * 3. Color Palette * 4. Raw Data */ BITMAPFILEHEADER bmfh; ZeroMemory( &bmfh, sizeof( bmfh ) ); bmfh.bfType = 0x4D42; // Magic # bmfh.bfSize = sizeof( bmfh ) + sizeof( BITMAPINFOHEADER ) + NPAL_ENT*sizeof(PALETTEENTRY) + w*h; // Or total file size if w/h not known bmfh.bfOffBits = sizeof( bmfh ) + sizeof( BITMAPINFOHEADER ) + NPAL_ENT*sizeof(PALETTEENTRY); BITMAPINFOHEADER bmih; ZeroMemory( &bmih, sizeof( bmih ) ); bmih.biWidth = w; bmih.biHeight = h; bmih.biSize = sizeof(bmih); bmih.biPlanes = 1; bmih.biBitCount = 8; bmih.biCompression = BI_RGB; bmih.biSizeImage = w * h; int palSize = NPAL_ENT*sizeof(PALETTEENTRY); LOGPALETTE *logpal=(LOGPALETTE*)new BYTE[sizeof(LOGPALETTE)+palSize]; if(!logpal) {delete [] imgData; printf("!logpal\n"); exit(4);} logpal->palVersion=0x300; logpal->palNumEntries=NPAL_ENT; int i=0; do { // Exact palette format varies. This is what worked for me logpal->palPalEntry[i].peRed=i; logpal->palPalEntry[i].peGreen=i; logpal->palPalEntry[i].peBlue=i; logpal->palPalEntry[i].peFlags=NULL; } while(++i palPalEntry)+offset, 1, palSize-offset, bmpFile ); } else { // Image data offset = totWrit - sizeof(bmfh) - sizeof(bmih) - palSize; if(bmfh.bfSize-totWrit >= IO_SIZE) { writeAmt = IO_SIZE; } else { writeAmt = bmfh.bfSize-totWrit; } totWrit += fwrite( &imageBuffer[offset], 1, writeAmt, bmpFile ); } // Close and open after each iteration to please WinCE fflush(bmpFile); fclose(bmpFile); Sleep(4000); bmpFile = _wfopen(bmpfname,L"ab"); if(!bmpFile) {flog->lprintf("Couldn't reopen bmpfile"); delete [] logpal; return 0;} } fclose(bmpFile); if(totWrit != bmfh.bfSize) { printf("BMP Size mismatch: %d/%d.",totWrit,bmfh.bfSize); delete [] imgData; delete [] logpal; exit(-1); } // Cleanup delete [] imgData; delete [] logpal; return 0; }
