[site]: stackoverflow
[post_id]: 3092519
[parent_id]: 3092041
[tags]: 
Let's start with the Table API. This is the practice of mediating access to tables through a PL/SQL API. So, we have a package per table, which should be generated from the data dictionary. The package presents a standard set of procedures for issuing DML against the table and some functions for retrieving data. By comparison a Transactional API represents a Unit Of Work. It doesn't expose any information about the underlying database objects at all. Transactional APIs offer better encapsulation, and a cleaner interface. The contrast is like this. Consider these business rules for creating a new Department: The new Department must have a Name and Location The new Department must have a manager, who must be an existing Employee Other existing Employees may be transferred to the new Department New employees may be assigned to the new Department The new Department must have at least two Employees assigned (including the manager) Using Table APIs the transaction might look something like this: DECLARE dno pls_integer; emp_count pls_integer; BEGIN dept_utils.insert_one_rec(:new_name, :new_loc, dno); emp_utils.update_one_rec(:new_mgr_no ,p_job=>'MGRâ€™ ,p_deptno=>dno); emp_utils.update_multi_recs(:transfer_emp_array, p_deptno=>dno); FOR idx IN :new_hires_array.FIRST..:new_hires_array.LAST LOOP :new_hires_array(idx).deptno := dno; END LOOP; emp_utils.insert_multi_recs(:new_hires_array); emp_count := emp_utils.get_count(p_deptno=>dno); IF emp_count Whereas with a Transactional API it is much simpler: DECLARE dno subtype_pkg.deptno; BEGIN dept_txns.create_new_dept(:new_name , :new_loc , :new_mgr_no , :transfer_emps_array , :new_hires_array , dno); END; / So why the difference in retrieving data? Because the Transactional API approach discourages generic get() functions in order to avoid the mindless use of inefficient SELECT statements. For example, if you just want the salary and commission for an Employee, querying this ... select sal, comm into l_sal, l_comm from emp where empno = p_eno; ... is better than executing this ... l_emprec := emp_utils.get_whole_row(p_eno); ...especially if the Employee record has LOB columns. It is also more efficient than: l_sal := emp_utils.get_sal(p_eno); l_comm := emp_utils.get_comm(p_eno); ... if each of those getters executes a separate SELECT statement. Which is not unknown: it's a bad OO practice that leads to horrible database performance. The proponents of Table APIs argue for them on the basis that they shield the developer from needing to think about SQL. The people who deprecate them dislike Table APIs for the very same reason . Even the best Table APIs tend to encourage RBAR processing. If we write our own SQL each time we're more likely to choose a set-based approach. Using Transactional APis doesn't necessarily rule out the use of get_resultset() functions. There is still a lot of value in a querying API. But it's more likely to be built out of views and functions implementing joins than SELECTs on individual tables. Incidentally, I think building Transactional APIs on top of Table APIs is not a good idea: we still have siloed SQL statements instead of carefully written joins. As an illustration, here are two different implementations of a transactional API to update the salary of every Employee in a Region (Region being a large scale section of the organisation; Departments are assigned to Regions). The first version has no pure SQL just Table API calls, I don't think this is a straw man: it uses the sort of functionality I have seen in Table API packages (although some use dynamic SQL rather than named SET_XXX() procedures). create or replace procedure adjust_sal_by_region (p_region in dept.region%type , p_sal_adjustment in number ) as emps_rc sys_refcursor; emp_rec emp%rowtype; depts_rc sys_refcursor; dept_rec dept%rowtype; begin depts_rc := dept_utils.get_depts_by_region(p_region); > loop fetch depts_rc into dept_rec; exit when depts_rc%notfound; emps_rc := emp_utils.get_emps_by_dept(dept_rec.deptno); > loop fetch emps_rc into emp_rec; exit when emps_rc%notfound; emp_rec.sal := emp_rec.sal * p_sal_adjustment; emp_utils.set_sal(emp_rec.empno, emp_rec.sal); end loop emps; end loop depts; end adjust_sal_by_region; / The equivalent implementation in SQL: create or replace procedure adjust_sal_by_region (p_region in dept.region%type , p_sal_adjustment in number ) as begin update emp e set e.sal = e.sal * p_sal_adjustment where e.deptno in ( select d.deptno from dept d where d.region = p_region ); end adjust_sal_by_region; / This is much nicer than the nested cursor loops and single row update of the previous version. This is because in SQL it is a cinch to write the join we need to select Employees by Region. It is a lot harder using a Table API, because Region is not a key of Employees. To be fair, if we have a Table API which supports dynamic SQL, things are better but still not ideal: create or replace procedure adjust_sal_by_region (p_region in dept.region%type , p_sal_adjustment in number ) as emps_rc sys_refcursor; emp_rec emp%rowtype; begin emps_rc := emp_utils.get_all_emps( p_where_clause=>'deptno in ( select d.deptno from dept d where d.region = '||p_region||' )' ); > loop fetch emps_rc into emp_rec; exit when emps_rc%notfound; emp_rec.sal := emp_rec.sal * p_sal_adjustment; emp_utils.set_sal(emp_rec.empno, emp_rec.sal); end loop emps; end adjust_sal_by_region; / last word Having said all that, there are scenarios where Table APIs can be useful, situations when we only want to interact with single tables in fairly standard ways. An obvious case might be producing or consuming data feeds from other systems e.g. ETL. If you want to investigate the use of Table APIs, the best place to start is Steven Feuerstein's Quest CodeGen Utility (formerly QNXO). This is about as good as TAPI generators get, and it's free.
