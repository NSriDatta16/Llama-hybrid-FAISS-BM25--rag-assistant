[site]: stackoverflow
[post_id]: 574035
[parent_id]: 
[tags]: 
How to handle db constraint violations in the user interface?

We implement the majority of our business rules in the database, using stored procs. I can never decide how best to pass data constraint violation errors from the database back to the user interface. The constraints I'm talking about are tied more to business rules than data integrity. For example, a db error such as "Cannot insert duplicate key row" is the same as the business rule "you can't have more than one Foo with the same name". But we've "implemented" it at the most common sense location: as a unique constraint that throws an exception when the rule is violated. Other rules such as "You're only allowed 100 Foos per day" do not cause errors per-say, since they're gracefully handled by custom code such as return empty dataset that the application code checks for and passes back to the ui layer. And therein lies the rub. Our ui code looks like this (this is AJAX.NET webservices code, but any ajax framework will do): WebService.AddFoo("foo", onComplete, onError); // ajax call to web service function onComplete(newFooId) { if(!newFooId) { alert('You reached your max number of Foos for the day') return } // update ui as normal here } function onError(e) { if(e.get_message().indexOf('duplicate key')) { alert('A Foo with that name already exists'); return; } // REAL error handling code here } (As a side note: I notice this is what stackoverflow does when you submit comments too quickly: the server generates a HTTP 500 response and the ui catches it.) So you see, we are handling business rule violations in two places here, one of which (ie the unique constaint error) is being handled as a special case to the code that is supposed to handle real errors (not business rule violations), since .NET propagates Exceptions all the way up to the onError() handler. This feels wrong. My options I think are: catch the 'duplicate key violation' exception at the app server level and convert it to whatever it is the ui expects as the "business rule violated" flag, preempt the error (say, with a "select name from Foo where name = @Name" ) and return whatever it is the app server expects as the "business rule violated" flag, in the same ballpark as 2): leverage the unique constraint built into the db layer and blindly insert into Foo , catching any exceptions and convert it to whatever it is the app server expects as the "business rule violated" flag blindly insert into Foo (like 3) and let that Exception propagate to the ui, plus have the app server raise business rule violations as real Exceptions (as opposed to 1). This way ALL errors are handled in the ui layer's onError() (or similar) code. What I like about 2) and 3) is that the business rule violations are "thrown" where they are implemented : in the stored proc. What I don't like about 1) and 3) is I think they involve stupid checks like "if error.IndexOf('duplicate key')" , just like what is in the ui layer currently. Edit : I like 4), but most people say to use Exception s only in exceptional circumstances. So, how do you people handle propagating business rule violations up to the ui elegantly?
