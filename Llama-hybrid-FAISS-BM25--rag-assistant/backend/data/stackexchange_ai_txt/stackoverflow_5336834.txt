[site]: stackoverflow
[post_id]: 5336834
[parent_id]: 
[tags]: 
How to wait on a Mutex with OpenMP

I've a for loop that will launch processes in parallel every launched process will return a response back indicating that it is ready. I want to wait for the response and I'll abort if a certain timeout is reached. Development environment is VS2008 Here is the pseudo code: void executeCommands(std::vector commands) { #pragma omp parallel for for (int i = 0; i getWorkingDirectory(), cmd->getCommandToExcecute(), cmd->params); //Should I wait for process to become ready? if (cmd->getWaitStatusTimeout() > 0) { ProcessStatusManager::getInstance().addListener(*this); //TODO: emit process launching signal //BEGINNING OF QUESTION //I don't how to do this part. //I might use QT's QWaitCondition but if there is another solution in omp //I'd like to use it bool timedOut; SOMEHANDLE handle = Openmp::waitWithTimeout(cmd->getWaitStatusTimeout(), &timedOut); mWaitConditions[pid]) = handle; //END OF QUESTION if (timedOut) { ProcessStatusManager::getInstance().removeListener(*this); //TODO: kill process //TODO: emit fail signal } else { //TODO: emit process ready signal } } else { //TODO: emit process ready signal } } } void onProcessReady(DWORD sourceProcessPid) { ProcessStatusManager::getInstance().removeListener(*this); SOMEHANDLE handle = mWaitConditions[sourceProcessPid]; if (mWaitConditions[sourceProcessPid] != 0) { Openmp::wakeAll(handle); } }
