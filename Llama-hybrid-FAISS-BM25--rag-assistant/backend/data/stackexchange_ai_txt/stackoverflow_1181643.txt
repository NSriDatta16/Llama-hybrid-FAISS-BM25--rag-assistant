[site]: stackoverflow
[post_id]: 1181643
[parent_id]: 1181512
[tags]: 
The reason why many objects don't support NSCopying is because it's not always clear on what a copied object should be, and in particular, the excessively pedantic details of what it means to 'copy an object'. I would take a pragmatic approach in this case. If you need an instance of AVAudioPlayer duplicated just once, I'd recommend this: AVAudioPlayer *audioPlayer; // Assumed to be valid. AVAudioPlayer *copiedPlayer = NULL; copiedPlayer = [[[AVAudioPlayer allocate] initWithData:audioPlayer.data] autorelease]; This is not meant to be a general solution because it does not handle all cases. It's meant to be an example of how you can over come the problem while relying on some usage specific invariants. The most notable example in which this breaks is if audioPlayer was not initialized with a NSData object, but a url instead. It also makes certain relatively safe assumptions about the mutability of data , and how AVAudioPlayer was coded to handle those cases. (I did not look at the documentation long enough to see if such corner case behaviors are documented). If this is something you need to do a lot, you can probably lash together a more complicated bit of code that implements NSCopying . Since a quick pass at the documentation turns up only two ways to init the object, via a NSData or via a url , and the instantiated object to be copied provides that information... then the implementation of a non-optimal deep copy NSCopying subclass is left as an exercise for the reader. :)
