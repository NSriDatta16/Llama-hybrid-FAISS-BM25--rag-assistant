[site]: stackoverflow
[post_id]: 1964244
[parent_id]: 1964143
[tags]: 
Most objects in Ruby are passed by reference and can be dupped. Eg: s = "Hello" t = s # s & t reference to the same string t.upcase! # modifying either one will affect the other s # ==> "HELLO" A few objects in Ruby are immediate, though. They are passed by value, there can only be one of this value and it therefore cannot be duped. These are any (small) integers, true , false , symbols and nil . Many floats are also immediates in Ruby 2.0 on 64 bit systems. In this (preposterous) example, any "42" will hold the same instance variable. class Fixnum attr_accessor :name alias_method :original_to_s, :to_s def to_s name || original_to_s end end 42.name = "The Answer" puts *41..43 # => 41, The Answer, 43 Since you would normally expect something.dup.name = "new name" to not affect any other object than the copy obtained with dup , Ruby chooses not to define dup on immediates. Your question is more complex than it appears. There was some discussion on ruby-core as to how this can be made easier. Also, other types of Numeric objects (floats, bignums, rationals and complex numbers) can not be duped although they are not immediates either. Note that ActiveSupport (part of rails) provide the method duplicable? on all objects
