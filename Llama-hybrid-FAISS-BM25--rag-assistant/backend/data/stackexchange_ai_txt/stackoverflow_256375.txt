[site]: stackoverflow
[post_id]: 256375
[parent_id]: 256073
[tags]: 
A couple of different ways to solve the problem: Just replace Environment.Exit with return. The compiler knows that return ends the method, but doesn't know that Environment.Exit does. static void Main(string[] args) { if(args.Length != 0) { if(Byte.TryParse(args[0], out maxSize)) queue = new Queue(){MaxSize = maxSize}; else return; } else { return; } Of course, you can really only get away with that because you're using 0 as your exit code in all cases. Really, you should return an int instead of using Environment.Exit. For this particular case, this would be my preferred method static int Main(string[] args) { if(args.Length != 0) { if(Byte.TryParse(args[0], out maxSize)) queue = new Queue(){MaxSize = maxSize}; else return 1; } else { return 2; } } Initialize queue to null, which is really just a compiler trick that says "I'll figure out my own uninitialized variables, thank you very much". It's a useful trick, but I don't like it in this case - you have too many if branches to easily check that you're doing it properly. If you really wanted to do it this way, something like this would be clearer: static void Main(string[] args) { Byte maxSize; Queue queue = null; if(args.Length == 0 || !Byte.TryParse(args[0], out maxSize)) { Environment.Exit(0); } queue = new Queue(){MaxSize = maxSize}; for(Byte j = 0; j Add a return statement after Environment.Exit. Again, this is more of a compiler trick - but is slightly more legit IMO because it adds semantics for humans as well (though it'll keep you from that vaunted 100% code coverage) static void Main(String[] args) { if(args.Length != 0) { if(Byte.TryParse(args[0], out maxSize)) { queue = new Queue(){MaxSize = maxSize}; } else { Environment.Exit(0); return; } } else { Environment.Exit(0); return; } for(Byte j = 0; j
