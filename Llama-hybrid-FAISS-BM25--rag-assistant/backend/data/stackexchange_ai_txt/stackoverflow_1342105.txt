[site]: stackoverflow
[post_id]: 1342105
[parent_id]: 1341917
[tags]: 
Short answer: optimization: needed at compiler time debug flag: needed at compile time debugging symbols: need at both compile and linking time Take note that the linker decides what bits of each object file and library need to be included in the final executable. It could throw out the debugging symbols (I don't know what the default behavior is), so you need to tell it not to. Further, the linker will silently ignore options which do not apply to it. To the comments: The above are very general claims based on knowing what happens at each stage of compilation, so no reference. A few more details: optimization: takes two major forms: peephole optimization can occur very late, because it works on a few assembly instructions at a time (I presume that in the GNU tool chain the assembler is responsible for this step), but the big gains are in structural optimizations that are generally accomplished by re-writing the Abstract Syntax Tree (AST) which is only possible during compilation. debug flag: In your example this is a preprocessor directive, and only affects the first part of the compilation process. debugging symbols: Look up t he ELF file format (for instance), you'll see that various bits of code and data are organized into different blocks. Debugging symbols are stored in the same file along as the code they relate to, but are necessarily kept separate from the actual code. As such, any program that manipulates these files could just dump it. Therefore both the compiler and the linker need to know if you want them or not.
