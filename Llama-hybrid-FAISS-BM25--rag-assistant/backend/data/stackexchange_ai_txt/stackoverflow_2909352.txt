[site]: stackoverflow
[post_id]: 2909352
[parent_id]: 2909282
[tags]: 
However, this makes little sense to me because almost all real-world practical programs need/have state to take care of. You'd be surprised! Yes, all programs need some state (I/O in particular) but often you don't need much more. Just because most programs have heaps of state doesn't mean they need it. Programming in a functional language encourages you to use less state, and thus your programs become easier to parallelise. Many functional languages are "impure" which means they allow some state. Haskell doesn't, but Haskell has monads which basically let you get something from nothing: you get state using stateless constructs. Monads are a bit fiddly to work with which is why Haskell gives you a strong incentive to restrict state to as small a part of your program as possible. I also find it interesting that most major scaling libraries, i.e. MapReduce, are typically written in imperative languages like C or C++. Programming concurrent applications is "hard" in C/C++. That's why it's best to do all the dangerous stuff in a library which is heavily tested and inspected. But you still get the flexibility and performance of C/C++.
