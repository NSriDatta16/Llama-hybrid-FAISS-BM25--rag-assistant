[site]: stackoverflow
[post_id]: 2909096
[parent_id]: 2893200
[tags]: 
In the hope that someone will contribute something... Further in my experiments at boost::asio I've decided that right after the server app is up & running I'll put a breakpoint at C++'s 'new' code, i.e at "new.cpp" @ function "void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)". Note, I'm using MSVC 2008. Using the code above, of the original post : Now that the BP is on I'm connecting one client. Allocation is done (several times) (as expected) (I know it because the debugger stops at the 'new' keyword as I set) and the new client is now ready to send/receive data. I send "hi" from the client to the server. The BP at 'new' is hit at handle_read(). The source to is was the call to async_write() (I stack trace with MSVC). Hitting F5 (continue) generates another breakpoint at 'new' - this time the async_read_some() call generated it. Conclusion: Each such operation generates a call to 'new' !!!!!! Worst case a real server might have! So, further on looking for some way to use some sort of memory pool so these 'new' calls won't exist brought me to the example: "allocation". Path to it: ".......\boost_1_43_0\libs\asio\example\allocation\". Doing the same with this new code (written below) gave me cheering results ; Calls to async_write() and async_read_some() do not generate a call to 'new'. So far it's nice, but to be honest I can't say I understand exactly how this is done; The allocator is broke down into several pieces as you can see, and that makes things a bit confusing to me. make_custom_alloc_handler() What's shared_from_this()?? I see that a "session" object has the member "handler_allocator allocator_". Does every "session" object holds a pool of these objects?! Can I have one of this, at the "server" class level which will be shared or something? "allocator" example code: // // server.cpp // ~~~~~~~~~~ // // Copyright (c) 2003-2010 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include #include #include #include #include #include #include #include #include using boost::asio::ip::tcp; // Class to manage the memory to be used for handler-based custom allocation. // It contains a single block of memory which may be returned for allocation // requests. If the memory is in use when an allocation request is made, the // allocator delegates allocation to the global heap. class handler_allocator : private boost::noncopyable { public: handler_allocator() : in_use_(false) { } void* allocate(std::size_t size) { if (!in_use_ && size storage_; // Whether the handler-based custom allocation storage has been used. bool in_use_; }; // Wrapper class template for handler objects to allow handler memory // allocation to be customised. Calls to operator() are forwarded to the // encapsulated handler. template class custom_alloc_handler { public: custom_alloc_handler(handler_allocator& a, Handler h) : allocator_(a), handler_(h) { } template void operator()(Arg1 arg1) { handler_(arg1); } template void operator()(Arg1 arg1, Arg2 arg2) { handler_(arg1, arg2); } friend void* asio_handler_allocate(std::size_t size, custom_alloc_handler * this_handler) { return this_handler->allocator_.allocate(size); } friend void asio_handler_deallocate(void* pointer, std::size_t /*size*/, custom_alloc_handler * this_handler) { this_handler->allocator_.deallocate(pointer); } private: handler_allocator& allocator_; Handler handler_; }; // Helper function to wrap a handler object to add custom allocation. template inline custom_alloc_handler make_custom_alloc_handler( handler_allocator& a, Handler h) { return custom_alloc_handler (a, h); } class session : public boost::enable_shared_from_this { public: session(boost::asio::io_service& io_service) : socket_(io_service) { } tcp::socket& socket() { return socket_; } void start() { socket_.async_read_some(boost::asio::buffer(data_), make_custom_alloc_handler(allocator_, boost::bind(&session::handle_read, shared_from_this(), boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred))); } void handle_read(const boost::system::error_code& error, size_t bytes_transferred) { if (!error) { boost::asio::async_write(socket_, boost::asio::buffer(data_, bytes_transferred), make_custom_alloc_handler(allocator_, boost::bind(&session::handle_write, shared_from_this(), boost::asio::placeholders::error)) ); } } void handle_write(const boost::system::error_code& error) { if (!error) { socket_.async_read_some(boost::asio::buffer(data_), make_custom_alloc_handler(allocator_, boost::bind(&session::handle_read, shared_from_this(), boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred))); } } private: // The socket used to communicate with the client. tcp::socket socket_; // Buffer used to store data received from the client. boost::array data_; // The allocator to use for handler-based custom memory allocation. handler_allocator allocator_; }; typedef boost::shared_ptr session_ptr; class server { public: server(boost::asio::io_service& io_service, short port) : io_service_(io_service), acceptor_(io_service, tcp::endpoint(tcp::v4(), port)) { session_ptr new_session(new session(io_service_)); acceptor_.async_accept(new_session->socket(), boost::bind(&server::handle_accept, this, new_session, boost::asio::placeholders::error)); } void handle_accept(session_ptr new_session, const boost::system::error_code& error) { if (!error) { new_session->start(); new_session.reset(new session(io_service_)); acceptor_.async_accept(new_session->socket(), boost::bind(&server::handle_accept, this, new_session, boost::asio::placeholders::error)); } } private: boost::asio::io_service& io_service_; tcp::acceptor acceptor_; }; int main(int argc, char* argv[]) { try { if (argc != 2) { std::cerr \n"; return 1; } boost::asio::io_service io_service; using namespace std; // For atoi. server s(io_service, atoi(argv[1])); io_service.run(); } catch (std::exception& e) { std::cerr
