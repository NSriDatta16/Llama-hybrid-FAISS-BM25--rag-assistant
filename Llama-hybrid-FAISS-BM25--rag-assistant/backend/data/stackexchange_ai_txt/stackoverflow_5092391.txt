[site]: stackoverflow
[post_id]: 5092391
[parent_id]: 5036050
[tags]: 
By itself, expression trees can't do this as there's no way for an expression tree to know what calling the OrgName property does under the covers. However if you were to put an attribute on the property, perhaps then some factory could replace a call to property1 ("OrgName") with the property path Organization.Name Sample code below. static void Main(string[] args) { Company company = new Company { Organization = { Name = "Microsoft" } }; Expression > lambdaExpression = c => c.OrgName.Length; var expanded = Expand(lambdaExpression); } private static Expression > Expand (Expression > lambdaExpression) { Expression expanded = GetExpandedExpression(lambdaExpression.Body); if (Object.ReferenceEquals(lambdaExpression.Body, expanded)) { return lambdaExpression; } return Expression.Lambda >( expanded, lambdaExpression.Parameters ); } private static Expression GetExpandedExpression(Expression expression) { Expression expandedContainer; switch (expression.NodeType) { case ExpressionType.MemberAccess: MemberExpression memberExpression = (MemberExpression)expression; if (memberExpression.Expression != null) { expandedContainer = GetExpandedExpression(memberExpression.Expression); PropertyPathAttribute attribute = memberExpression.Member.GetCustomAttributes(typeof(PropertyPathAttribute), false).Cast ().FirstOrDefault(); if (attribute != null && !String.IsNullOrEmpty(attribute.Path)) { string[] parts = attribute.Path.Split('.'); expression = expandedContainer; for (int i = 0; i
