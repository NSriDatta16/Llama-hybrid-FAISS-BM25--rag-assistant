[site]: stackoverflow
[post_id]: 3518588
[parent_id]: 3446011
[tags]: 
In some very narrow circumstances, you can implement a java.util.concurrent.RejectedExecutionHandler that does what you need. RejectedExecutionHandler block = new RejectedExecutionHandler() { rejectedExecution(Runnable r, ThreadPoolExecutor executor) { executor.getQueue().put( r ); } }; ThreadPoolExecutor pool = new ... pool.setRejectedExecutionHandler(block); Now. This is a very bad idea for the following reasons It's prone to deadlock because all the threads in the pool may die before the thing you put in the queue is visible. Mitigate this by setting a reasonable keep alive time. The task is not wrapped the way your Executor may expect. Lots of executor implementations wrap their tasks in some sort of tracking object before execution. Look at the source of yours. Adding via getQueue() is strongly discouraged by the API, and may be prohibited at some point. A almost-always-better strategy is to install ThreadPoolExecutor.CallerRunsPolicy which will throttle your app by running the task on the thread which is calling execute(). However, sometimes a blocking strategy, with all its inherent risks, is really what you want. I'd say under these conditions You only have one thread calling execute() You have to (or want to) have a very small queue length You absolutely need to limit the number of threads running this work (usually for external reasons), and a caller-runs strategy would break that. Your tasks are of unpredictable size, so caller-runs could introduce starvation if the pool was momentarily busy with 4 short tasks and your one thread calling execute got stuck with a big one. So, as I say. It's rarely needed and can be dangerous, but there you go. Good Luck.
