[site]: stackoverflow
[post_id]: 1926516
[parent_id]: 1926001
[tags]: 
The primary reason is historical: regexes have always worked that way, going back to Perl and beyond. But it's not really bad design. Usually, if you want every match like that, you just leave off the outermost quantifier ( + in ths case) and use the Matches() method instead of Match() . Every regex-enabled language provides a way to do that: in Perl or JavaScript you do the match in /g mode; in Ruby you use the scan method; in Java you call find() repeatedly until it returns false . Similarly, if you're doing a replace operation, you can plug the captured substrings back in as you go with placeholders ( $1 , $2 or \1 , \2 , depending on the language). On the other hand, I know of no other Perl 5-derived regex flavor that provides the ability to retrieve intermediate capture-group matches like .NET does with its CaptureCollections. And I'm not surprised: it's actually very seldom that you really need to capture all the matches in one go like that. And think of all the storage and/or processing power it can take to keep track of all those intermediate matches. It is a nice feature though.
