[site]: stackoverflow
[post_id]: 1062976
[parent_id]: 1058390
[tags]: 
This has more than a kernel of truth about it... Spin wait can be much better than a signal based interrupt or a yield. You trade some throughput for much reduced latency. Often this is vitally important within an OS itself. You allow yourself the freedom to do operations not possible within an interrupt handler memory allocation for example. You can get considerably finer grained control of the interval waited since you can essentially measure the cycle count. However spin waits are tricky to get right. If you can you should use use proper idle instructions which: can power down parts of the core, improving power usage/heat dissipation and even allowing other cores to go faster. In Hyper Thread based CPUs you allow the other logical thread to use the full CPU pipeline while you spin . an instruction you might think was a no-op could cause the CPU to execute them out of order via the super scalar execution units. The resulting code may get unforeseen out of order artefacts which force the CPU to apply a great deal of effort in terms of stalls and memory barriers which are unwanted. This is why you let someone else write the spin wait loop for you in most cases.. In Linux there is the cpu_relax macro on arm this is barrier() on x86 this is rep_nop() In Windows there is YieldProcessor Accessible in .Net via Thread.SpinWait OS X eschews providing a standard implementation unless you are in the kernel see this document and note that it encourages the use only of lck_spin_t As to some citations of using PAUSE for spin waits: PostGresSQL Linux See also the note that this is better on non P4 as well due to reducing power
