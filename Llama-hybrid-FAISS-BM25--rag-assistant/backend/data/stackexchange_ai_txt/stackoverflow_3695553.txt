[site]: stackoverflow
[post_id]: 3695553
[parent_id]: 3694356
[tags]: 
Embedding the ga.js code the way you describe (with a hardcoded tag) is indeed blocking, and if you load the script like that, the best practice is considered to be loading it at the just before the tag. But this is not the recommended practice if you're using the new asynchronous code. Google explicitly recommends placing the new asynchronous code in the . The new asynchoronous code is non-blocking in two ways. First, it queues up the variables for the page in a global _gaq variable. That way, the data is prepared either way. Then, as described in this SO answer , using javascript directly to write out the script as in the new async code is non-blocking (this direct inject method is the way to achieve asynchronous-ness, even in browsers that don't directly observe the async attribute). The rest of the site can continue to load if for some reason Google's servers are down or slow to respond. And that's only if the user doesn't have ga.js cached already, as many do, since ga.js is used on many, many popular websites. The benefit of all this is that the earlier the ga.js loads and is able to transmit the _gaq object to Google, the more likely you'll be to capture ALL of your potential data, like the data of the users who click very quickly on your page. This is particularly important for 'big' websites that tend to have lots of regular users who follow quick-clicking habits. If you're skeptical, test it out using a page load inspector like the webkit developer tools. I've tested it extensively and found no evidence of significant blocking when using the async code in the as described.
