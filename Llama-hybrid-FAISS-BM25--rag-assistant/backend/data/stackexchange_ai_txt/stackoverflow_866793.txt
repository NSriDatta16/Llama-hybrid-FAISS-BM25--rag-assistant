[site]: stackoverflow
[post_id]: 866793
[parent_id]: 862388
[tags]: 
Like others I have used os.walk and os.path.join to build the list of files to delete, with fnmatch.fnmatch to select files that must be included or excluded: #-------------------------------# # make list of files to display # #-------------------------------# displayList = [] for imageDir in args : for root,dirs,files in os.walk(imageDir) : for filename in files : pathname = os.path.join( root, filename ) if fnmatch.fnmatch( pathname, options.includePattern ) : displayList.append( pathname ) #----# now filter out excluded patterns #----# try : if len(options.excludePattern) > 0 : for pattern in options.excludePattern : displayList = [pathname for pathname in displayList if not fnmatch.fnmatch( pathname, pattern ) ] except ( AttributeError, TypeError ) : pass If fnmatch isn't enough, you can use the re module to test patterns. Here I have built the file list before I do anything with it, but you could process the files as they are generated. The try/except block...is there in case my options class instance doesn't have an exclude pattern, or if it causes an exception in fnmatch because it is the wrong type. A limitation of this method is that it first includes files matching a pattern, then excludes . If you need more flexibility than this (include matching pattern a, but not pattern b unless pattern c...) well, then the fragment above isn't up to it. In fact, working through this exercise, you start to see why the find command syntax is the way it is. Seems clunky, but in fact it is exactly the way to do this. But if you generate a list, you can filter it according to whatever inclusion/exclusion rules you need. One nice thing about generating a list is you can check it before you go ahead with the deletion. This is sort of a '--dryrun' option. You can do this interactively in the python interpreter, print the list to see how it looks, apply the next filter, see if it has removed too much or too little and so on.
