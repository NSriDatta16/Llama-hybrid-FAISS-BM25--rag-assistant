[site]: stackoverflow
[post_id]: 3388621
[parent_id]: 3379660
[tags]: 
There's no way to specify constraints on generics such that you can require the types to be numbers, so there's no way you can use numeric operators on the values in your list. Craig Stuntz wrote a series of posts describing how to build a generic statistical library, and he came up against the same problem. He solved it by providing additional arguments to his functions so that the caller could provide implementations for the type-specific numeric operations â€” the template method pattern. Here's how he declared the Average operation: type TBinaryOp = reference to function(ALeft, ARight: T): T TStatistics = class public class function Average(const AData: TEnumerable ; AAdder, ADivider: TBinaryOp ; AMapper: TFunc ): T; overload; Callers of that function need to provide their own code for adding, dividing, and "mapping" the generic type. (Mapping is covered in a later post and isn't important here.) You could write your Invert function like this: type TUnaryOp = reference to function(Arg: T): T; TKList = class procedure Invert(ANegater: TUnaryOp ); procedure TKList .Invert; var i: Integer; begin for i := 0 to Pred(Count) do Values[i] := ANegater(Values[i]); end; To make it more convenient to call the methods without having to provide the extra arguments all the time, Stuntz showed how to declare a type-specific descendant that provides the right arguments. You could do it like this: type TIntKList = class(TKList ) private class function Negate(Arg: Integer): Integer; public procedure Invert; end; procedure TIntKList.Invert; begin inherited Invert(Negate); end; You can provide type-specific descendants for the common numeric types, and if consumers of your class need to use other number-like types, they can provide their own implementations for the basic numeric operations without having to re-implement your entire list class.
