[site]: datascience
[post_id]: 71582
[parent_id]: 71454
[tags]: 
The output is going to be "continuous" if you don't use it for "classification". You can follow few approaches here: This would be the simplest approaches but you probably need some post processing to fill holes in lines: Define a Threshold to make the image binary; Redefine the last layer to output a image with 2 channels and define your final image by taking the index of the maximum channel value for each pixel (as it was a classification problem) You can also redefine your problem: PS:Every time a mention "line" from now on I actually mean line segment. Given that your images are a set of geometric figures, which can all be broken down to lines and any line can be described by a set of 4 numbers, you can use a RNN to generate the set of lines (pair of points) that can be drawn easily afterwards. To do so you need to rewrite your training set: Define a line width for your images Based on that line width you can set a number of line orientations possible (for example, with width of one pixel you can only draw lines in 4 orientations 0, 45, 90 135 degrees) Use that to find every point that define line (start and end) by finding points where these orientation changes To transform the set of points into a set of lines you can check if there is a black pixel in that orientation that is in the interval. Binary Layer Issue Your binary layer implements a Heaveside Step function which will kill the gradient since it's derivative is 0 for all values other than x=0. In x=0 the derivative is actually not defined (limit goes to infinity). Thus your weights can't update, so every forward pass will filter data with random weights, causing random effects to the output. Check this answer to understand more about why we don't use Heaveside Step function as an activation function on neural networks
