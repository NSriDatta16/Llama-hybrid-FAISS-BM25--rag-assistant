[site]: stackoverflow
[post_id]: 5627815
[parent_id]: 4116171
[tags]: 
The solution I found was to use the Objective-C runtime API. I'm sure there's a better way to organize this, but here's how I did it: Here are my .h and .m files for creating the category. Notice how lowerVolume is not an actual method, but a C function with the arguments id self , and SEL _CMD . You'll also notice a setupCategories function. We'll call that later. // iTunes+Volume.h #import #import "iTunes.h" void lowerVolume(id self, SEL _cmd, int dest, float speed); void setupCategories(); @interface iTunesApplication (Volume) - (void)lowerVolume:(int)dest speed:(float)speed; @end // iTunes+Volume.m #import "iTunes+Volume.h" void lowerVolume(id self, SEL _cmd, int dest, float speed) { NSLog(@"Lower Volume: %i, %f", dest, speed); } void setupCategories() { id object = [[SBApplication alloc] initWithBundleIdentifier:@"com.apple.iTunes"]; Class class = [object class]; [object release]; class_addMethod(class, @selector(lowerVolume:speed:), (IMP)lowerVolume, "@:if"); } Now that I've made the functions, I need to actually add them to the scripting bridge class using the Objective-C runtime API. I'll do this in main.m to make sure that the methods are ready to be used when the run loop starts. // main.m #import #import "iTunes+Volume.h" int main(int argc, char *argv[]) { NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init]; setupCategories(); return NSApplicationMain(argc, (const char **) argv); [pool drain]; } Now, I can use my method wherever I want as long as I include the header files: - (void)mute { iTunesApplication* iTunes = [[SBApplication alloc] initWithBundleIdentifier:@"com.apple.iTunes"]; [iTunes lowerVolume:0 speed:1]; [iTunes release]; } If any of this doesn't make sense, just tell me and I'll try to explain it better.
