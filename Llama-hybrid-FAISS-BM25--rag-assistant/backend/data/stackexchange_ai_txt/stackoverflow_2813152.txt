[site]: stackoverflow
[post_id]: 2813152
[parent_id]: 2806522
[tags]: 
If you know in advance the dependencies of each node, you can easily build layers. It's amusing, but I faced the very same problem when organizing... the compilation of the different modules of my application :) The idea is simple: def buildLayers(nodes): layers = [] n = nodes[:] # copy the list while not len(n) == 0: layer = _buildRec(layers, n) if len(layer) == 0: raise RuntimeError('Cyclic Dependency') for l in layer: n.remove(l) layers.append(layer) return layers def _buildRec(layers, nodes): """Build the next layer by selecting nodes whose dependencies already appear in `layers` """ result = [] for n in nodes: if n.dependencies in flatten(layers): result.append(n) # not truly python return result Then you can pop the layers one at a time, and each time you'll be able to send the request to each of the nodes of this layer in parallel. If you keep a set of the already selected nodes and the dependencies are also represented as a set the check is more efficient. Other implementations would use event propagations to avoid all those nested loops... Notice in the worst case you have O(n 3 ), but I only had some thirty components and there are not THAT related :p
