[site]: stackoverflow
[post_id]: 4337544
[parent_id]: 4329777
[tags]: 
The answer is definitively YES. Read my OP and all the comments to understand why exactly, but here's the short version. If you doubt or question any of this, I encourage you to read the entire thread and all of the comments. Otherwise accept this as true: The C++ standard includes parts of the C standard, including the definitions for LONG_MIN and LONG_MAX LONG_MIN is defined as no greater than -2147483647 LONG_MAX is defined as no less than +2147483647 In C++ integral types are stored in binary in the underlying representation In order to represent -2147483647 and +2147483647 in binary, you need 32 bits. A C++ long is guaranteed to be able to represent the minimum range LONG_MIN through LONG_MAX Therefore a long must be at least 32 bits 1 . EDIT: LONG_MIN and LONG_MAX have values with magnitudes dictated by the C standard (ISO/IEC 9899:TC3) in section §5.2.4.2.1: [...] Their implementation-defined values shall be equal or greater in magnitude [...] (absolute value) to those shown, with the same sign [...] — minimum value for an object of type long int LONG_MIN -2147483647 // -(2 ^ 31 - 1) — maximum value for an object of type long int LONG_MAX +2147483647 // 2 ^ 31 - 1 1 32 bits : This does not mean that sizeof (long) >= 4 , because a byte is not necessarily 8 bits. According to the Standard, a byte is some unspecified (platform-defined) number of bits. While most readers will find this odd, there is real hardware on which CHAR_BIT is 16 or 32.
