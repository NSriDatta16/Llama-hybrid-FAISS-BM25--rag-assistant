[site]: stackoverflow
[post_id]: 1784453
[parent_id]: 1784294
[tags]: 
There are a couple different things that could at play here, the 3 that come to mind initially (in probable-ish order) would be as follows - if you would like some help interpreting the results, follow the instructions below and paste the stat outputs in the question: Your query/batch is taking a long time to compile an execution plan. Execution plans are determined and cached (see this post on serverfault for an overview of understanding for how long, when they are rebuilt, etc.) To verify this, turn on statistics time output , which will provide you information on how long the engine is taking to generate a query plan. For the query/batch in question: DBCC FREEPROCCACHE SET STATISTICS TIME ON Execute the batch, capture the stats output Execute the batch again, capture the stats output Compare the 2 stat outputs, paying particular attention to the parse/compile time differences between the 2 executions. If this is the problem, you can take a couple of approaches to resolving the issue, including specifying a plan guide , specifying a static plan with use plan , or possibly other options like creating a scheduled job to simply compile the plan every few minutes (not as good on option on Sql 2k5 as the others). Your query/batch is touching a lot of data - on the first execution the data may not be in the buffer pool (basically the cached pages of data the server needs) and the query is performing physical IO operations as opposed to logical IO operations (i.e. reads from disk vs. reads from cache). To verify this, turn on statistics io output , which will provide you information on the types of IOs and how many of those the engine is performing for the batch. For the query/batch in question: DBCC DROPCLEANBUFFERS SET STATISTICS IO ON Execute the batch, capture the stats output Execute the batch again, capture the stats output Compare the 2 stat outputs, paying particular attention to the physical/read-ahead and logical IO outpus between the 2 executions. To resolve this, you've basically got only 1 option - optimize the query in question so it performs fewer IO operations. You could consider creating a scheduled job that runs the query every so ofter to keep the data in the buffer pool, but this wouldn't be as good an option. Your query/batch is getting a poor execution plan and/or a poor execution plan choice for different variable values - is this a batch/query that is using a parameterized statement (i.e. you are using variables/static values in the where/join clauses?)? If so, are you seeing the difference in execution times for the same values or different values? If for the same values, the answer is likely #1 or #2 - if for different values, this is potentially your problem. If you think this is the issue after researching #1 and #2, repost with the .sqlplan, the TSQL, and the different parameter values you are using.
