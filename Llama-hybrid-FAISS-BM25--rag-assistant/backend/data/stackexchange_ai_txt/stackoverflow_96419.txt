[site]: stackoverflow
[post_id]: 96419
[parent_id]: 96196
[tags]: 
Let's say we'll ignore obvious things like header guards. Sometimes, you want to generate code that needs to be copy/pasted by the precompiler: #define RAISE_ERROR_STL(p_strMessage) \ do \ { \ try \ { \ std::tstringstream strBuffer ; \ strBuffer which enables you to code this: RAISE_ERROR_STL("Hello... The following values " And can generate messages like: Error Raised: ==================================== File : MyFile.cpp, line 225 Function : MyFunction(int, double) Message : "Hello... The following values 23 and 12 are wrong" Note that mixing templates with macros can lead to even better results (i.e. automatically generating the values side-by-side with their variable names) Other times, you need the __FILE__ and/or the __LINE__ of some code, to generate debug info, for example. The following is a classic for Visual C++: #define WRNG_PRIVATE_STR2(z) #z #define WRNG_PRIVATE_STR1(x) WRNG_PRIVATE_STR2(x) #define WRNG __FILE__ "("WRNG_PRIVATE_STR1(__LINE__)") : ------------ : " As with the following code: #pragma message(WRNG "Hello World") it generates messages like: C:\my_project\my_cpp_file.cpp (225) : ------------ Hello World Other times, you need to generate code using the # and ## concatenation operators, like generating getters and setters for a property (this is for quite a limited cases, through). Other times, you will generate code than won't compile if used through a function, like: #define MY_TRY try{ #define MY_CATCH } catch(...) { #define MY_END_TRY } Which can be used as MY_TRY doSomethingDangerous() ; MY_CATCH tryToRecoverEvenWithoutMeaningfullInfo() ; damnThoseMacros() ; MY_END_TRY (still, I only saw this kind of code rightly used once ) Last, but not least, the famous boost::foreach !!! #include #include #include int main() { std::string hello( "Hello, world!" ); BOOST_FOREACH( char ch, hello ) { std::cout (Note: code copy/pasted from the boost homepage) Which is (IMHO) way better than std::for_each . So, macros are always useful because they are outside the normal compiler rules. But I find that most the time I see one, they are effectively remains of C code never translated into proper C++.
