[site]: stackoverflow
[post_id]: 4839671
[parent_id]: 4839626
[tags]: 
Let's say I have an array arr. When would the following not give the number of elements of the array: sizeof(arr) / sizeof(arr[0])? One thing I've often seen new programmers doing this: void f(Sample *arr) { int count = sizeof(arr)/sizeof(arr[0]); //what would be count? 10? } Sample arr[10]; f(arr); So new programmers think the value of count will be 10. But that's wrong. Even this is wrong: void g(Sample arr[]) //even more deceptive form! { int count = sizeof(arr)/sizeof(arr[0]); //count would not be 10 } It's all because once you pass an array to any of these functions, it becomes pointer type, and so sizeof(arr) would give the size of pointer , not array! EDIT: The following is an elegant way you can pass an array to a function, without letting it to decay into pointer type: template void h(Sample (&arr)[N]) { size_t count = N; //N is 10, so would be count! //you can even do this now: //size_t count = sizeof(arr)/sizeof(arr[0]); it'll return 10! } Sample arr[10]; h(arr); //pass : same as before!
