[site]: stackoverflow
[post_id]: 2252418
[parent_id]: 2235126
[tags]: 
I decided to try something myself. I came up with a straightforward GDI+ code, which uses the tiles I've already got. I just filter out the parts which are relevant for current clipping region. It works like magic! Please find my code below. (Form settings double buffering for the best results) protected override void OnPaint(PaintEventArgs e) { base.OnPaint(e); Graphics dc = e.Graphics; dc.ScaleTransform(1.0F, 1.0F); Size scrollOffset = new Size(AutoScrollPosition); int start_x = Math.Min(matrix_x_size, (e.ClipRectangle.Left - scrollOffset.Width) / 256); int start_y = Math.Min(matrix_y_size, (e.ClipRectangle.Top - scrollOffset.Height) / 256); int end_x = Math.Min(matrix_x_size, (e.ClipRectangle.Right - scrollOffset.Width + 255) / 256); int end_y = Math.Min(matrix_y_size, (e.ClipRectangle.Bottom - scrollOffset.Height + 255) / 256); // start * contain the first and last tile x/y which are on screen // and which need to be redrawn. // now iterate trough all tiles which need an update for (int y = start_y; y To test it, I've created a matrix of 80x80 of 256 tiles (420 MPixel). Of course I'll have to add some deferred loading in real life. I can leave tiles out (empty) if they are not yet loaded. In fact, I've asked my client to stick 8 GByte in his machine so I don't have to bother about performance too much. Once loaded tiles can stay in memory. public partial class Form1 : Form { bool dragging = false; float Zoom = 1.0F; Point lastMouse; PointF viewPortCenter; private readonly Brush solidYellowBrush = new SolidBrush(Color.Yellow); private readonly Brush solidBlueBrush = new SolidBrush(Color.LightBlue); const int matrix_x_size = 80; const int matrix_y_size = 80; private Bitmap[,] BmpMatrix = new Bitmap[matrix_x_size, matrix_y_size]; public Form1() { InitializeComponent(); Font font = new Font("Times New Roman", 10, FontStyle.Regular); StringFormat strFormat = new StringFormat(); strFormat.Alignment = StringAlignment.Center; strFormat.LineAlignment = StringAlignment.Center; for (int y = 0; y Turned out this was the easy part. Getting async multithreaded i/o done in the background was a lot harder to acchieve. Still, I've got it working in the way described here. The issues to resolve were more .NET/Form multithreading related than to this topic. In pseudo code it works like this: after onPaint (and on Tick) check if tiles on display need to be retrieved from disc if so: post them to an async io queue if not: check if tiles close to display area are already loaded if not: post them to an async io/queue check if bitmaps have arrived from io thread if so: updat them on screen, and force repaint if visible Result: I now have my own Custom control which uses roughly 50 MByte for very fast access to arbitrary size (tiled) TIFF files.
