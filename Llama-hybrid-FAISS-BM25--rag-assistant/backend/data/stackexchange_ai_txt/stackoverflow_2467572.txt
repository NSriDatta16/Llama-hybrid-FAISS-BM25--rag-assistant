[site]: stackoverflow
[post_id]: 2467572
[parent_id]: 2466396
[tags]: 
I see that you made your Semaphore fair. So I guess you care about the order these "system tasks" are executed? Then, relying on the ordered arrival of threads is very fragile and dangerous in my opinion. This problem will also be present if you use synchronized keyword. I'd say you should use CountdownLatch instead. class TaskOrganizer { private final CountdownLatch firstTask = new CountdownLatch(1); public void firstTaskIsDone(){ firstTask.countDown(); } public void permissionForSecondaryTask(){ firstTask.await(); } } If you can't pass TaskOrganizer objects to your threads, then I guess making it static is okay, but generally it's better to pass instances to your threads (well, to the Runnables to be exact). You never know if you are going to need 2 TaskOrganizers. If you had used static , then things won't be as cleaner as it could have been. I guess it's obvious, but one thread calls firstTaskIsDone() , and the other one blocks until it is done, calling permissionForSecondaryTask(); . If you have tons of task to organize with tons of threads, you might want to roll out Phaser (scheduled to appear in JDK 7, backport available at http://gee.cs.oswego.edu/dl/concurrency-interest/ ).
