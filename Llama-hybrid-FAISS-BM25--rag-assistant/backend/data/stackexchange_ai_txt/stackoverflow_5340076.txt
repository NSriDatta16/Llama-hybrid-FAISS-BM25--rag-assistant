[site]: stackoverflow
[post_id]: 5340076
[parent_id]: 5326470
[tags]: 
As described, your conceptual schema involves the following predicates: task exists computer exists setting exists program exists task executes on computer task is to change setting task is to install program You also appear to one constraint, you need to judge how significant it is: | P6 join P7 | = 0 -- there is no task to install program and change setting Some might suggest the natural Django solution would be to use model inheritance to represent a base "Task" model, with two subclasses - "InstallTask" and "SettingTask". You then either carry the "computer" as an attribute of the base class, or alternatively have another model "ComputerTask" or such. Using model inheritance would afford some benefits, including (1) getting some support for creating the base Task at the same time as you create, say, the ChangeTask, and (2) encouraging, but not enforcing, maintenance of the constraint. However, in my experience, there are conceptual problems with model inheritance, and you may encounter surprising and unwanted behavior, for example, updating tasks. In this case, I might simply place Task 1:1 with InstallTask and 1:1 with SettingTask. This is actually more flexible.
