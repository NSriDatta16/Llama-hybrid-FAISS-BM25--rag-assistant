[site]: stackoverflow
[post_id]: 5034568
[parent_id]: 2767295
[tags]: 
Some comments on the quote, in the context of C# which is my "first" language: Unit tests to be specific and strong theorems, Yes, but they might not give you first order logic checks, like "for all x there exists a y where f(y)", more like "there exists a y, here it is (!), f(y)", aka setup, act, assert. ;)* checked quasi-statically on particular “interesting instances” and Types to be general but weak theorems (usually checked statically), Types are not necessarily that weak**. and contracts to be general and strong theorems, checked dynamically for particular instances that occur during regular program operation. (from B. Pierce's Types Considered Harmful), Unit Testing Pex + Moles I think is getting closer to the first-order logic type of checking, as it generates the edge-cases and uses the C9 solver to work with integer constraint solving. I would really like to see more Moles tutorials (moles is for replacing implementations), specifically together with some sort of inversion of control container that can leverage what stub- and real- implementations of abstract classes and interfaces already exist. Weak Types In C# they are fairly weak, sure: generic typing/types allows you to add protocol semantics for one operation -- i.e. constraining types to be on interfaces, which are in some sense protocols which implementing classes agree to. However, the static typing of the protocol is just for one operation . Example: Reactive Extensions API Let's take Reactive Extensions as a discussion topic. The contract required by the consumer, implemented by the observable. interface IObserver : IDisposable { void OnNext(T); void OnCompleted(); void OnError(System.Exception); } There are more to the protocol than this interface shows: methods called on an IObserver instance must follow this protocol: Ordering: OnNext{0,n} (OnCompleted | OnError){0, 1} Furthermore, on another axis; time-dimension: Time: for all t|-> t:(method -> time). t(OnNext) t:(method -> time). t(OnNext) i.e. no invocation to OnNext may be done after one to OnCompleted xor OnError. Furthermore, the axis of parallelism: Parallelism: no invocation to OnNext may be done in parallel i.e. there's a scheduling constraint that needs to be followed from implementers of IObservable. No IObservable may push from multiple threads at the same time, without first synchronizing the invocation around a context. How do you test this contract holds in an easy way? With c#, I don't know. Consumer of API From the consuming side of the application, there might be interactions between different contexts , such as Dispatcher, Background/other threads, and preferably we'd like to give guarantees that we don't end up in a deadlock. Further, there is the requirement to handle deterministic disposing of the observables. It might not be clear all the time when an extension method's returned IObservable instance takes care of the method's arguments' IObservable instances and dispose those, so there's a requirement to know about the inner workings of the black box (alternatively you can let the references go in a "reasonable way" and the GC will take them at some point) There is the task pool on top of TPL is implemented. In the task pool we have a work-stealing queue of delegates to invoke on the worker threads. Using the APM/begin/end or the async pattern (which queues to the task pool) could leave us open to callback-ordering bugs if we mutating state. Also, the protocol of begin-invocations and their callbacks might be too convoluted and hence impossible to follow. I read a post-mortem the other day about a silverlight project having problems seeing the business logic-forest for all the callback-trees. Then there's the possibility of implementing the poor-man's async monad, the IEnumerable with an async 'manager' iterating through it and calling MoveNext() every time a yielded IAsyncResult completes. ...and don't get me started on the nuuuumerous hidden protocols in IAsyncResult. Another problem, without using Reactive extensions is the turtles problem - once you decide that you want an IO-blocking operation to be async, there need to be turtles all the way down to the p/invoke call that places the associated Win32-thread on an IO-completion port! If you have three layers and then some logic as well inside of your topmost layer, you need to make all three layers implement the APM pattern; and fulfil the numerous contract obligations of IAsyncResult (or leave it partially broken) -- and there's no default public AsyncResult implementation in the base class library. >>> Working with exceptions from the interface Even with the above memory-management + parallelism + contract + protocol items covered, there are still exceptions to be handled (not just received and forgotten about), in a good, reliable application. I want to make an example; Context Let's say that we find ourselves catching an exception from the contract/interface (not necessarily from reactive extensions' IObservable implementations here which have monadic exception handling rather than stack-frame based). Hopefully the programmer was diligent and documented the possible exceptions, but there might be exception possibilities all the way down. If everything is correctly defined with code contracts at least we can be sure we are capable of catching a few of the exceptions, but many different causes may be lumped together inside of one exception type, and once an exception is thrown, how do we ensure that the work of the least possible size is rectified ? Aim Say that we are pushing some data-record from a message-bus-consumer in our application, and receiving them on the background thread which decides what to do with them. Example A real-life example here could be Spotify, which I'm using every day. My $100 router/access point throws in the towel at random times. I guess it has a cache-bug or some sort of stack overflow bug, as it happens every time I push more than 2 MB/s LAN/WAN data through it. I have to NICs up; the wifi and the ethernet card. Ethernet's connection goes down. The sockets of Spotify's event-handler loop return an invalid code (I think it's C or C++) or throw exceptions. Spotify has to handle it, but it doesn't know what my network topology looks like (and there is no code to try all routes/update the routing table and hence the interface to be used); I still have a route to the internet, but just not on the same interface. Spotify crashes. A thesis Exceptions are simply not semantic enough. I believe one can look at exceptions from the perspective of the Error monad in Haskell. We either continue or break: unwinding the stack, executing the catches, executing the finally's an praying we don't end up with race conditions on either other exception handlers or the GC, or async exceptions for outstanding IO-completion ports. But when one of my interfaces' connection/route goes down, Spotify crashes freezes. Now we have SEH/Structured Exception Handling, but I think we will have SEH2 in the future, where each source of exception gives, with the actual exception, a discriminated union (i.e. it should be statically typed to the linked library/assembly), of possible compensating actions -- in this example, I could imagine Windows' network API telling the application to execute a compensating action to open the same socket on another interface, or to handle it on its own (like now), or to retry the socket, with some kernel-managed retry policy. Each of these options are parts of a discriminated union type, so the implementer must use one of them. I think that, when we have SEH2, it won't be called exceptions anymore. ^^ Anyway, I have digressed too much already. Instead of reading my thoughts, listen to some of Erik Meijer's -- this is a very good round-table discussion between him and Joe Duffy . They discuss handling side-effects of calls. Or have a look at this search listing . I'm finding myself in a position, today, as a consultant, of maintaining a system where stronger static semantics could be good, and I'm looking at tools which can give me the speed of programming + the correctness verification on a level which is accurate and precise. I haven't found it yet. I simply think we are another 20 years if not more away from developer oriented reliable computing. There are just too many languages, frameworks, marketing BS and concepts in the air right now, for the ordinary develop to stay on top of things. Why is this under the heading of "weak types"? Because I find that the type system will be part of the solution; types need not be weak! Terse code and strong type systems (think Haskell) help programmers build reliable software.
