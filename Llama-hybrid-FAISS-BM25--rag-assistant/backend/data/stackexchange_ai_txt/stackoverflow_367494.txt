[site]: stackoverflow
[post_id]: 367494
[parent_id]: 
[tags]: 
Using elements of a constant array as cases in a switch statement

I'm attempting to map a set of key presses to a set of commands. Because I process the commands from several places, I'd like to set up a layer of abstraction between the keys and the commands so that if I change the underlying key mappings, I don't have to change very much code. My current attempt looks like this: // input.h enum LOGICAL_KEYS { DO_SOMETHING_KEY, DO_SOMETHING_ELSE_KEY, ... countof_LOGICAL_KEYS }; static const SDLKey LogicalMappings[countof_LOGICAL_KEYS] = { SDLK_RETURN, // Do Something SDLK_ESCAPE, // Do Something Else ... }; // some_other_file.cpp ... switch( event.key.keysym.key ) { case LogicalMappings[ DO_SOMETHING_KEY ]: doSomething(); break; case LogicalMappings[ DO_SOMETHING_ELSE_KEY ]: doSomethingElse(); break; ... } When I try to compile this (gcc 4.3.2) I get the error message: error: 'LogicalMappings' cannot appear in a constant-expression I don't see why the compiler has a problem with this. I understand why you're not allowed to have variables in a case statement, but I was under the impression that you could use constants, as they could be evaluated at compile-time. Do constant arrays not work with switch statements? If so, I suppose I could just replace the array with something like: static const SDLKey LOGICAL_MAPPING_DO_SOMETHING = SDLK_RETURN; static const SDLKey LOGICAL_MAPPING_DO_SOMETHING_ELSE = SDLK_ESCAPE; ... But that seems much less elegant. Does anybody know why you can't use a constant array here? EDIT: I've seen the bit of the C++ standard that claims that, "An integral constant-expression can involve only literals (2.13), enumerators, const variables or static data members of integral or enumeration types initialized with constant expressions (8.5)...". I still don't see why a constant array doesn't count as an "enumeration type initialized with a constant expression." It could just be that the answer to my question is "because that's the way that it is," and I'll have to work around it. But if that's the case, it's sort of disappointing, because the compiler really could determine those values at compile-time.
