[site]: stackoverflow
[post_id]: 1557572
[parent_id]: 1557538
[tags]: 
I think you need to classify the levels of multithreading, not the different API's. Depending on your threading needs, you may or may not need to know certain subsets of the API's you have listed. If I were to organize them, I would do it along these lines: Basic Multi-threading: Requirements Need to run concurrent processes. Do not need access to shared resources. Maximizing utilization of available hardware resources. API Knowledge Thread ThreadPool BackgroundWorker Asynchronous Operations/Delegates Shared Resource Multi-threading: Requirements Basic Multi=-threading requirements Use of shared resources API Knowledge Basic Multi-threading API's lock()/Monitor (they are the same thing) Interlocked ReaderWriterLock and variants volatile Multi-thread Synchronization Requirements Basic Multi=-threading requirements Shared Resource Multi-threading requirements Synchronization of behavior across multiple threads API Knowledge Basic Multi-threading API's Shared Resource Multi-threading API's WaitHandle Manual/AutoResetEvent Mutex Semaphore Concurrent Shared Resource Multi-threading (hyperthreading) Requirements Basic Multi=-threading requirements Shared Resource Multi-threading requirements Concurrent read/write access to shared collections API Knowledge Basic Multi-threading API's Shared Resource Multi-threading API's Parallel Extensions to .NET/.NET 4.0 The rest of the API's I would simply lump into general threading knowledge, stuff that could be picked up as needed, as they fit into all three levels. Things like MemoryBarrier are pretty fringe, and there are usually better ways to accomplish the same thing it accomplishes, with less ambiguity into their behavior and meaning.
