[site]: stackoverflow
[post_id]: 1960888
[parent_id]: 
[tags]: 
Register allocation and spilling, the easy way?

I'm looking for a way to allocate local variables to registers. I'm aware of a couple of serious methods for doing it (namely, those mentioned on Wikipedia ), but I'm stuck on how "spilling" is accomplished. Also, the relevant literature is quite intimidating. I'm hoping there's something simpler that will satisfy my priorities: Correctness -- an algorithm that will generate correct code regardless of how many local variables there are. Simplicity -- something I can understand without having to read too much literature. Efficiency -- it needs to be better than the current method, which is: Translate an operation x = y # z to: movl y, %eax movl z, %ebx op %ebx, %eax movl %eax, x As I'm targeting Intel 386, some relevant constraints are: Binary operations take two arguments, one of which is a source and destination. Unary operations take a single argument. Operations can only access one memory location; binary operations therefore need at least one argument in a register. There is a maximum of six registers available: %eax %ebx %ecx %edx %esi %edi . ( %ebp could also be included as a last resort.) There are special cases such as for integer division and return registers, but I can ignore them for now. There are three steps the compiler gets through at the moment: i386ification: all operations are converted to a form a = a # b (or a = #a for unary operations). Liveness analysis: the sets of live variables before and after each operation are determined. Register allocation: an interference graph is built and coloured. And then the compiler throws its crayons in the air and doesn't know what to do next. Example public int mf(int cr, int ci) { int i = 0; int zr = 0; int zi = 0; while (i Here's the rather pretty interference graph for the function, and the CFG with liveness information. The CFG image does require some vertical scrolling, unfortunately. Interference graph for a function on 14 variables Control-flow graph for a function, with liveness information Seven colours were used. I would like to spill one of them (or the set of variables assigned that colour). The method of choosing which isn't too important. What gets tricky is how to deal with the spilt variables. Let's say I spill "pink", which is the set of variables t , $t4 , $t7 . This means that those operations referring to one of these variables will access it from its position on the stack frame, rather than through a register. This should work for this example. But what if the program was: ... a = a + b ... and both a and b had to be spilled? I can't emit an instruction addl b, a with two memory addresses. I would need another spare register to temporarily hold one of the operands, and that means spilling another colour. This suggests a general method of: If all variables can be coloured with r colours, great! Otherwise, spill some colours and their associated variables. If an operation exists that accesses two spilled variables, spill another colour and use the spare register for temporary storage for all such operations. At this point I would suspect that a lot more stuff is being spilled than necessary, and wonder if there is some smarter way to spill things, such as spilling part of a variable's lifetime, rather than the whole variable itself. Are there some simple(ish) techniques that I could use here? Again, I'm not aiming particularly high -- certainly not high enough to require reading anything too deep. ;-) Specific problems The main specific problem is: when a variable is spilled, how does this affect the instructions generated? Do all instructions using that variable need to access it directly in memory (from its stack position) ? How will this work if an operation uses two spilled variables? (The architecture does not permit instructions to access two distinct memory locations.) Secondary problems are: How do I determine where to insert load/store instructions, for correctness (and less importantly, efficiency) ? Can I spill a variable for only that part of its lifetime when it is not in immediate use, and unspill it later? So that all instructions act on unspilled registers. A variable might live in different registers at different times. Can I be a little more efficient with special cases. For example, %eax is used for the return value, so it would be nice if the variable to be returned happened to be allocated to that register by the time the return was encountered. Similarly, some registers are "callee-save", so if fewer variables happened to be live at the time of a function call, having them allocated to non-callee-save registers would mean I can avoid storing those registers. Would SSA form help much (if at all) ? Being able to eliminate common subexpressions and evaluate constants might reduce(?) register pressure, but otherwise would it have any effect? The aspects I'm not concerned about (right now) are: Stack allocation and optimisation: it's implemented naively already, and can be optimised using the interference graph if need be. Compile-time efficiency, just as long as it terminates. (NP-completeness does not imply a given algorithm should be avoided.) Update Sorry about the downtime -- I've been thinking about the answers given and trying to find an easy approach to take to start implementing some of the ideas. To be honest, I've been procrastinating... :-\ I found the very nice presentation (PPT, sadly): http://www.cs.princeton.edu/courses/archive/spr05/cos320/notes/Register%20Allocation.ppt Which answers the question about how to deal with specific operation needs (like using the same register for source and destination; or needing a certain register for some operations). What I'm not sure about is whether the Liveness-Colouring-Allocation cycle terminates. I'll try to do some actual work soon and hopefully close the question.
