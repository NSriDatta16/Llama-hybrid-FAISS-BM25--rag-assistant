[site]: stackoverflow
[post_id]: 834058
[parent_id]: 313127
[tags]: 
Yes and no.. If you want to be able to program as normal, but having the system 'magically' use multiple threads, then you need to look at some of the multi-processing frameworks out there. For example: OpenMP . If you want to run through an array, using all your cores, code similar to this: int main(int argc, char **argv) { const int N = 100000; int i, a[N]; #pragma omp parallel for for (i = 0; i Just adding the #pragma makes your code magically multi-threaded. Now, you will have to understand some restrictions, eg. you cannot use the value of one element in the processing of the next (ie you cannot set a[0] to 1, then a 1 to a[0]+1, etc as they'll no doubt be processed by different threads, and therefore may not be computed when you need them) or you'll get an error from the openmp compiler, but if you work within these restrictions (and there are many) then you can get what you want. The restrictions are what makes your ultimate goal of making your code impossible. As in my example, you simply cannot compute 1 element based on another unless the first element is already computed. This effectively means code like that can only be single-threaded, no matter how many cores you have. It also means that 80-core chips will not really take off anytime soon, not unless they are all 3Ghz general purpose processors, so you don't need to worry too much about having to code for them. Now, add-on co-processors that can crunch arrays coded like in my example, that's another matter, and I expect to see more of that in the future. You'll probably use the graphics card for that kind of thing and have thousands of 'cpus' instead of a mere 80.
