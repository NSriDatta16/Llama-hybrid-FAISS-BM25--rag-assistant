[site]: stackoverflow
[post_id]: 4078264
[parent_id]: 4075189
[tags]: 
With a bit of pretty horrible hacking, you can use the MailboxProcessor type from C# using async . Some difficulties are that the type uses some F# specific features (optional arguments are options, functions are FSharpFunc type, etc.) Technically, the biggest difference is that F# async is dealyed while C# async creates a task that is already running. This means that to construct F# async from C#, you need to write a method that takes unt -> Task and creates Async . I wrote a blog post that discusses the difference . Anwyay, if you want to experiment, here is some code you can use: static FSharpAsync CreateAsync (Func > f) { return FSharpAsync.FromContinuations ( FuncConvert.ToFSharpFunc , FSharpFunc , FSharpFunc >>(conts => { f().ContinueWith(task => { try { conts.Item1.Invoke(task.Result); } catch (Exception e) { conts.Item2.Invoke(e); } }); })); } static void MailboxProcessor() { var body = FuncConvert.ToFSharpFunc , FSharpAsync >(mbox => CreateAsync (async () => { while (true) { var msg = await FSharpAsync.StartAsTask ( mbox.Receive(FSharpOption .None), FSharpOption .None, FSharpOption .None ); Console.WriteLine(msg); } return null; })); var agent = FSharpMailboxProcessor .Start(body, FSharpOption .None); agent.Post(1); agent.Post(2); agent.Post(3); Console.ReadLine(); } As you can see, this looks really horrible :-). In principle, it could be possible to write a C# friendly wrapper for the MailboxProcessor type (just extract the ugly bits from this code), but there are some problems. In F# you often use tail-recursive asyncs to implement the state machine in the mailbox processor. If you write the same thing in C#, you'll eventually get StackOverflow , so you'd need to write loops with mutable state. It is perfectly possible to write the agent in F# and call it from C#. This is just a matter of exposing C#-friendly interface from F# (using the Async.StartAsTask method).
