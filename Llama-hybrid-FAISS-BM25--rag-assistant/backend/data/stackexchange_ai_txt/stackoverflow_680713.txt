[site]: stackoverflow
[post_id]: 680713
[parent_id]: 300855
[tags]: 
Karma or Protractor Karma is a JavaScript test-runner built with Node.js and meant for unit testing. The Protractor is for end-to-end testing and uses Selenium Web Driver to drive tests. Both have been made by the Angular team. You can use any assertion-library you want with either. Screencast: Karma Getting started related : Should I be using Protractor or Karma for my end-to-end testing? Can Protractor and Karma be used together? pros : Uses Node.js, so compatible with Win/OS X/Linux Run tests from a browser or headless with PhantomJS Run on multiple clients at once Option to launch, capture, and automatically shut down browsers Option to run server/clients on development computer or separately Run tests from a command line (can be integrated into ant/maven) Write tests xUnit or BDD style Supports multiple JavaScript test frameworks Auto-run tests on save Proxies requests cross-domain Possible to customize: Extend it to wrap other test-frameworks (Jasmine, Mocha, QUnit built-in) Your own assertions/refutes Reporters Browser Launchers Plugin for WebStorm Supported by NetBeans IDE Cons : Does not support Node.js (i.e. backend) testing No plugin for Eclipse (yet) No history of previous test results mocha.js I'm totally unqualified to comment on mocha.js's features, strengths, and weaknesses, but it was just recommended to me by someone I trust in the JS community. List of features, as reported by its website: browser support simple async support, including promises test coverage reporting string diff support JavaScript # API for running tests proper exit status for CI support etc auto-detects and disables coloring for non-ttys maps uncaught exceptions to the correct test case async test timeout support test-specific timeouts growl notification support reports test durations highlights slow tests file watcher support global variable leak detection optionally run tests that match a regexp auto-exit to prevent "hanging" with an active loop easily meta-generate suites & test-cases mocha.opts file support clickable suite titles to filter test execution node debugger support detects multiple calls to done() use any assertion library you want extensible reporting, bundled with 9+ reporters extensible test DSLs or "interfaces" before, after, before each, after each hook arbitrary transpiler support (coffee-script etc) TextMate bundle yolpo This no longer exists, redirects to sequential.js instead Yolpo is a tool to visualize the execution of JavaScript. JavaScript API developers are encouraged to write their use cases to show and tell their API. Such use cases forms the basis of regression tests. AVA Futuristic test runner with built-in support for ES2015. Even though JavaScript is single-threaded, I/O in Node.js can happen in parallel due to its async nature. AVA takes advantage of this and runs your tests concurrently, which is especially beneficial for I/O heavy tests. In addition, test files are run in parallel as separate processes, giving you even better performance and an isolated environment for each test file. Minimal and fast Simple test syntax Runs tests concurrently Enforces writing atomic tests No implicit globals Isolated environment for each test file Write your tests in ES2015 Promise support Generator function support Async function support Observable support Enhanced asserts Optional TAP o utput Clean stack traces Buster.js A JavaScript test-runner built with Node.js. Very modular and flexible. It comes with its own assertion library, but you can add your own if you like. The assertions library is decoupled, so you can also use it with other test-runners. Instead of using assert(!...) or expect(...).not... , it uses refute(...) which is a nice twist imho. A browser JavaScript testing toolkit. It does browser testing with browser automation (think JsTestDriver), QUnit style static HTML page testing, testing in headless browsers (PhantomJS, jsdom, ...), and more. Take a look at the overview ! A Node.js testing toolkit. You get the same test case library, assertion library, etc. This is also great for hybrid browser and Node.js code. Write your test case with Buster.JS and run it both in Node.js and in a real browser. Screencast: Buster.js Getting started (2:45) pros : Uses Node.js, so compatible with Win/OS X/Linux Run tests from a browser or headless with PhantomJS (soon) Run on multiple clients at once Supports Node.js testing Don't need to run server/clients on development computer (no need for IE) Run tests from a command line (can be integrated into ant/maven) Write tests xUnit or BDD style Supports multiple JavaScript test frameworks Defer tests instead of commenting them out SinonJS built-in Auto-run tests on save Proxies requests cross-domain Possible to customize: Extend it to wrap other test-frameworks (JsTestDriver built in) Your own assertions/refutes Reporters (xUnit XML, traditional dots, specification, tap, TeamCity and more built-in) Customize/replace the HTML that is used to run the browser-tests TextMate and Emacs integration Cons : Stil in beta so can be buggy No plugin for Eclipse/IntelliJ (yet) Doesn't group results by os/browser/version like TestSwarm *. It does, however, print out the browser name and version in the test results. No history of previous test results like TestSwarm * Doesn't fully work on windows as of May 2014 * TestSwarm is also a Continuous Integration server, while you need a separate CI server for Buster.js . It does, however, output xUnit XML reports, so it should be easy to integrate with Hudson , Bamboo or other CI servers. TestSwarm https://github.com/jquery/testswarm TestSwarm is officially no longer under active development as stated on their GitHub webpage. They recommend Karma, browserstack-runner, or Intern. Jasmine This is a behavior-driven framework (as stated in quote below) that might interest developers familiar with Ruby or Ruby on Rails. The syntax is based on RSpec that are used for testing in Rails projects. Jasmine specs can be run from an HTML page (in qUnit fashion) or from a test runner (as Karma). Jasmine is a behavior-driven development framework for testing your JavaScript code. It does not depend on any other JavaScript frameworks. It does not require a DOM. If you have experience with this testing framework, please contribute with more info :) Project home: http://jasmine.github.io/ QUnit QUnit focuses on testing JavaScript in the browser while providing as much convenience to the developer as possible. Blurb from the site: QUnit is a powerful, easy-to-use JavaScript unit test suite. It's used by the jQuery, jQuery UI, and jQuery Mobile projects and is capable of testing any generic JavaScript code QUnit shares some history with TestSwarm (above): QUnit was originally developed by John Resig as part of jQuery. In 2008 it got its own home, name and API documentation, allowing others to use it for their unit testing as well. At the time it still depended on jQuery. A rewrite in 2009 fixed that, now QUnit runs completely standalone. QUnit's assertion methods follow the CommonJS Unit Testing specification, which was to some degree influenced by QUnit. Project home: http://qunitjs.com/ Sinon Another great tool is sinon.js by Christian Johansen, the author of Test-Driven JavaScript Development . Best described by himself: Standalone test spies, stubs and mocks for JavaScript. No dependencies works with any unit testing framework. Intern The Intern Web site provides a direct feature comparison to the other testing frameworks on this list. It offers more features out of the box than any other JavaScript-based testing system. JEST A new but yet very powerful testing framework. It allows snapshot based testing as well this increases the testing speed and creates a new dynamic in terms of testing Check out one of their talks: https://www.youtube.com/watch?v=cAKYQpTC7MA Better yet: Getting Started
