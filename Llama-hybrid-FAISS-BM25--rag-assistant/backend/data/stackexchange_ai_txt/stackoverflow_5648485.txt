[site]: stackoverflow
[post_id]: 5648485
[parent_id]: 5647336
[tags]: 
You definitely can: outer.c: #include #include #include void inner(int n); int main(int argc, char **argv) { int n=15; #pragma omp parallel shared(n) num_threads(4) { inner(n); } return 0; } inner.c: #include #include void inner(int n) { int thread = omp_get_thread_num(); printf("%3d: got %d\n", thread, n); #pragma omp for for (int i=0;i and running: $ make gcc -fopenmp -std=c99 -c -o outer.o outer.c gcc -fopenmp -std=c99 -c -o inner.o inner.c gcc -o nested outer.o inner.o -fopenmp -std=c99 -lgomp $ ./nested 3: got 15 3: doing iter 12. 3: doing iter 13. 3: doing iter 14. 0: got 15 0: doing iter 0. 0: doing iter 1. 0: doing iter 2. 0: doing iter 3. 1: got 15 1: doing iter 4. 1: doing iter 5. 1: doing iter 6. 1: doing iter 7. 2: got 15 2: doing iter 8. 2: doing iter 9. 2: doing iter 10. 2: doing iter 11. But no, you can't set the sharing attributes of variables in one routine from another -- they're just not in scope. You can't set their sharing any more than you can set their value. Once you've launched (say) inner, everything there is private; you'd have to pass any shared things in as shared. Just to clairify that bit about "everything there is private": the above isn't any different than int n=15; #pragma omp parallel shared(n) num_threads(4) { int thread = omp_get_thread_num(); printf("%3d: got %d\n", thread, n); #pragma omp for for (int i=0;i since thread, i, and newthread are defined inside the parallel block -- whether inside a function or not -- they're all necessarily private.
