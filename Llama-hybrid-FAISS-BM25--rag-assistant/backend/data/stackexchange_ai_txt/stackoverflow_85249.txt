[site]: stackoverflow
[post_id]: 85249
[parent_id]: 85147
[tags]: 
My vote is- mostly you can just avoid them :) The main advantage for generics is to save casting, if you end up doing casting internally that doesn't make any sense. If you try to look into this issue you would found that mostly the candidates for generics are really those collections/sets which could create native storage internally for such benefit. Most other components, on the other hand, gain little/no performance, and degrades the flexibility significantly comparing to an interface inheritance implementation. If casting annoys you so much, maybe time for you to consider dynamic languages like IronPython :) And- if you really come across a scenario you think generic make sense, post it out as another question, the brains here could look together and solve it case by case :) Update: Yep compiler checking is nice, but check Castle Project's source, you can see many situations where a generic type gets into the way because you can't do casting- making things like IBusinessObject is a lot more flexible than BusinessObject- because you can't cast something inherit from BusinessObject back to BusinessObject and expects to access a function inherited. Usually I saw code end up as BusinessObjectBase -> BusinessObject ->Your actual class. That's why I kinda feel its not always beneficial to use generics- and I was one of those who did abuse such implementation and end up having tons of funny function with generic typing, not nice at all. Update #2: Boxing/Unboxing just means the requirement to cast the object when you use an abstract type (like object) to store value and use a strong typed value to store it back again (which requires casting), not much difference I can see apart from the collection situation I stated. AND code like this still does boxing: public T GetValue () { return (T) ...; } Thats the generic abuse I have seen most often. People think they are dealing with native type here, in fact they are not. Instead they just make the casting into generic syntax. What really make sense is this: public class MyList { private List _list; ... public T GetValue(int index) { return _list[index]; } Then thats again back to our collection storage. Thats why I said after collection storage I don't see a lot of chance generic helps. Referred from this tutorial: http://en.csharp-online.net/Understanding_Genericsâ€”Revisiting_Boxing_and_Unboxing
