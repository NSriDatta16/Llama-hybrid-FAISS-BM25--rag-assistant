[site]: stackoverflow
[post_id]: 3641748
[parent_id]: 3346439
[tags]: 
I am not sure if there are any extensibility point for VS 2010 metrics. Alternatively, you can opt for NDepend that comes with 82 code metrics and defining threshold is as easy as writing a short Code Rule over LINQ Query (CQLinq) like: warnif count > 0 from m in Application.Methods where m.NbLinesOfCode > 30 || m.CyclomaticComplexity > 10 select new { m, m.NbLinesOfCode, m.CyclomaticComplexity } You can also look for trending like in the default CQLinq code rule: Avoid making complex methods even more complex (Source CC) // Avoid making complex methods even more complex (Source CC) // To visualize changes in code, right-click a matched method and select: // - Compare older and newer versions of source file // - Compare older and newer versions disassembled with Reflector warnif count > 0 from m in JustMyCode.Methods where !m.IsAbstract && m.IsPresentInBothBuilds() && m.CodeWasChanged() let oldCC = m.OlderVersion().CyclomaticComplexity where oldCC > 6 && m.CyclomaticComplexity > oldCC select new { m, oldCC , newCC = m.CyclomaticComplexity , oldLoc = m.OlderVersion().NbLinesOfCode, newLoc = m.NbLinesOfCode, } You can also compose proposed code metrics, to define your own code metric like in C.R.A.P method code metric : // C.R.A.P method code metric // Change Risk Analyzer and Predictor (i.e. CRAP) code metric // This code metric helps in pinpointing overly complex and untested code. // Reference: http://www.artima.com/weblogs/viewpost.jsp?thread=215899 // Formula: CRAP(m) = comp(m)^2 * (1 â€“ cov(m)/100)^3 + comp(m) warnif count > 0 from m in JustMyCode.Methods // Don't match too short methods where m.NbLinesOfCode > 10 let CC = m.CyclomaticComplexity let uncov = (100 - m.PercentageCoverage) / 100f let CRAP = (CC * CC * uncov * uncov * uncov) + CC where CRAP != null && CRAP > 30 orderby CRAP descending, m.NbLinesOfCode descending select new { m, CRAP, CC, uncoveredPercentage = uncov*100, m.NbLinesOfCode }
