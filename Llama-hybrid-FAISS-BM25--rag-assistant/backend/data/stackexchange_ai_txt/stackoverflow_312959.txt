[site]: stackoverflow
[post_id]: 312959
[parent_id]: 312957
[tags]: 
Indeed that can be done, if the library or your code provides the overloads for operator and operator>> for it to work. Simple example on how one could do it: class transformer { public: virtual std::iostream& transform(std::iostream&) = 0; }; class noise : public transformer { public: virtual std::iostream& transform(std::iostream&) { /* extract, change and put into again */ } }; class echo : public transformer { public: virtual std::iostream& transform(std::iostream&) { /* extract, change and put into again */ } }; std::iostream& operator>>(std::iostream& io, transformer& ts) { return ts.transform(io); } int main() { std::stringstream data; std::ifstream file("sound.wav"); noise n; echo e; data > n >> e; /* pipelined data now ready to be played back */ } The problem with using a pure std::istream is that you would read, but then you wouldn't have a way to put the transformed data back for the next step in the pipeline. Thus i'm using std::iostream here. This approach doesn't seem to be efficient, as every operator>> call would extract the whole data, and put into again. To have a more performant way to stream this would be to create an expression template . This means, while operator>> is called, you don't do the transforming yet, but you return expression types that will record the chain of operations within its type: typedef transform > > pipeline; std::ifstream file("file.wav"); pipeline pipe(file); int byte = pipe.get(); would be an example of such a type. The pipelines' structure is decoded into the type itself. Therefore, no virtual functions are needed anymore in the pipeline. It's not constructed on-demand, but using typedef here, to show the principle. Programming such a system is not easy. So you probably should look into existing systems, like Boost.Iostreams (see below). To give you an idea how it would look like, here is an example i just coded up for you :) : #include template struct transformer { int get() { return static_cast (this)->read(); } }; struct echot { template struct chain : transformer > { Chain c; int read() { return c.get() + 1; } chain(Chain const& c):c(c) { } }; } echo; struct noiset { template struct chain : transformer > { Chain c; int read() { return c.get() * 2; } chain(Chain c):c(c) { } }; } noise; template typename T::template chain operator>>(std::istream& is, T) { return typename T::template chain (is); } template typename U::template chain operator>>(T t, U u) { return typename U::template chain (t); } int main() { std::cout > echo >> noise).get() Entering 0 yields the ASCII code 48 here, which is added 1, and multiplied by 2, yielding a value of 98, which is also finally output. I think you agree this is not some code a starter would want to write. So maybe look into boost. Boost has an sophisticated iostreams library, which can do many things. I'm sure you would find something fitting to this. Boost.Iostreams
