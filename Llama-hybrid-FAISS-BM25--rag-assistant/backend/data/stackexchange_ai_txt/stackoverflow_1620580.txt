[site]: stackoverflow
[post_id]: 1620580
[parent_id]: 1620393
[tags]: 
As others have said, document what your module does and trust the user. However, it is worth thinking about the philosophical difference between a call on a class and a call on an object. If your Perl module provides a way of creating objects, many of the methods in that class are likely to rely on data specific to an individual object. This is probably the most common way of calling methods: once you have an object, you simply do $object->method(…) . However, it is likely that some class methods are general and do not need data from a specific object. These are often called using the package name, and this is most commonly seen in calling a new() method, such as LWP::UserAgent->new() . Conveniently, Perl allows you to treat these two cases in the same way, using something like my $self = shift; at the beginning of the method: if the method is called on an object, $self gets the value of the object reference, if called on the class, $self gets the package name. Even if the method is called on a class, so $self contains the package name, you can still call other methods on this package in the same way by doing $self->method(…) . This is then compatible with calling the original method on a specific object, so everything holds together. As just one example, the Perl Math::BigInt package includes quite a lot of methods, some of which are designed to be called on the package (class) itself (e.g. new() ), some of which are to be called on individual objects (e.g. round() ), and some on either (e.g. accuracy() ). The moral: it should be up to the functionality of the method as to whether it is capable of sensible meaning. It's reasonable to assume that the any method is being called with the expectation that it will do what you advertise it to. However, don't require a method call to be on an object when it might make sense for that method to be called on the class itself.
