[site]: stackoverflow
[post_id]: 1450341
[parent_id]: 1450275
[tags]: 
I just tested exec and it works in Python 2.6.2 >>> def test(): ... exec "a = 5" ... print a ... >>> test() 5 If you are using Python 3.x, it does not work anymore because locals are optimized as an array at runtime, instead of using a dictionary. When Python detects the "exec statement", it will force Python to switch local storage from array to dictionary. However since "exec" is a function in Python 3.x, the compiler cannot make this distinction since the user could have done something like "exec = 123". http://bugs.python.org/issue4831 To modify the locals of a function on the fly is not possible without several consequences: normally, function locals are not stored in a dictionary, but an array, whose indices are determined at compile time from the known locales. This collides at least with new locals added by exec. The old exec statement circumvented this, because the compiler knew that if an exec without globals/locals args occurred in a function, that namespace would be "unoptimized", i.e. not using the locals array. Since exec() is now a normal function, the compiler does not know what "exec" may be bound to, and therefore can not treat is specially.
