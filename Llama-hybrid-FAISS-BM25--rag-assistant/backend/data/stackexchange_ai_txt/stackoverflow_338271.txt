[site]: stackoverflow
[post_id]: 338271
[parent_id]: 
[tags]: 
How can a member know in what class instance it is constructed?

class C { public T x; }; Is there an elegant way for the constructor of x to know implicitly in what instance of C it is constructing? I've implemented such behavior with some dirty inelegant machinery. I need this for my sqlite3 wrapper. I don't like all wrappers I've seen, their API IMO ugly and inconvenient. I want something like this: class TestRecordset: public Recordset { public: // The order of fields declarations specifies column index of the field. // There is TestRecordset* pointer inside Field class, // but it goes here indirectly so I don't have to // re-type all the fields in the constructor initializer list. Field field1; Field field2; Field field3; // have TestRecordset* pointer too so only name of parameter is specified // in TestRecordset constructor Param param; virtual string get_sql() { return "SELECT 1, '1', NULL FROM test_table WHERE param=:PARAM"; } // try & unlock are there because of my dirty tricks. // I want to get rid of them. TestRecordset(wstring param_value) try : Recordset(open_database(L"test.db")), param("PARAM") { param = param_value; // I LOVE RAII but i cant use it here. // Lock is set in Recordset constructor, // not in TestRecordset constructor. unlock(this); fetch(); } catch(...) { unlock(this); throw; } }; I want to clarify the fact - it is a part of the working code. You can do this in C++. I just want to do it in a more nice way. I've found a way to get rid of unlock and try block. I've remembered there is such a thing as thread local storage. Now I can write constructor as simple as that: TestRecordset(wstring param_value): Recordset(open_database(L"test.db")), param("PARAM") { param = param_value; fetch(); } to dribeas: My objective is to avoid redundant and tedious typing. Without some tricks behind the scene I will have to type for each Field and Param: TestRecordset(wstring param_value): Recordset(open_database(L"test.db")), param(this, "PARAM"), field1(this, 0), field2(this, 1), field3(this, 2) { ... } It is redundant, ugly and inconvenient. For example, if I'll have to add new field in the middle of SELECT I'll have to rewrite all the column numbers. Some notes on your post: Fields and Params are initialized by their default constructors. Order of initializers in constructor is irrelevant. Fields are always initialized in order of their declaration. I've used this fact to track down column index for fields Base classes are constructed first. So when Fields are constructed internal field list in Recordset are ready to use by Filed default constructor. I CAN'T use RAII here. I need to acquire lock in Recorset constructor and release it obligatory in TestRecordset constructor after all Fields are constructed .
