[site]: stackoverflow
[post_id]: 5244017
[parent_id]: 5236533
[tags]: 
BitBlt using the screen's HDC (pass NULL to the GetDC function) is your best bet unless you want to use a hook DLL. If that does not work, you have few options left. glReadPixels will not work just like this. You need the application's GL context being the current context in your thread, otherwise you get a black image in the best, and a segmentation fault in the average case. wglShareLists or wglCopyContext and such won't help you either, because you can share a context only within the same process . That's where the DLL hooking comes in. Basically, you make a DLL that will be placed in the program's folder, which exports the same symbols as the OpenGL DLL and simply forwards them all to the original (simply, huh!). However, for SwapBuffers, you would do a little more than that. You would first forward the function to the original and then do your glReadPixels. As it happens, when that function is called, the GL context is necessarily current in your thread, so it will work. Also, since SwapBuffers has just done its work, you are guaranteed that all draw calls belonging to the previous frame have finished and a complete image is now in the front buffer.
