[site]: stackoverflow
[post_id]: 1598787
[parent_id]: 1598248
[tags]: 
I've previously made a django app do precisely this without modifying the actual admin code. Rather by creating a subclass of admin.ModelAdmin with several of it's methods extended with queryset filters. This will display only records that are owned by the user (in this case business is the AUTH_PROFILE_MODEL). There are various blogs on the web on how to achieve this. You can use this technique to filter lists, form select boxes, Form Fields validating saves etc. So Far it's survived from NFA to 1.0 to 1.1 but this method is susceptible to api changes. In practice I've found this far quicker to generate new row level access level admin forms for new models in the app as I have added them. You just create a new model with a user fk, subclass the AdminFilterByBusiness or just admin.site.register(NewModel,AdminFilterByBusiness) if it doesnt need anything custom. It works and is very DRY. You do however run the risk of not being able to leverage other published django apps. So consider this technique carefully for the project you are building. Example Filter admin Class below inspired by http://code.djangoproject.co/wiki/NewformsHOWTO #AdminFilterByBusiness {{{2 class AdminFilterByBusiness(admin.ModelAdmin): """ Used By News Items to show only objects a business user is related to """ def has_change_permission(self,request,obj=None): self.request = request if request.user.is_superuser: return True if obj == None: return super(AdminFilterByBusiness,self).has_change_permission(request,obj) if obj.business.user == request.user: return True return False def has_delete_permission(self,request,obj=None): self.request = request if request.user.is_superuser: return True if obj == None: return super(AdminFilterByBusiness,self).has_delete_permission(request,obj) if obj.business.user == request.user: return True return False def has_add_permission(self, request): self.request = request return super(AdminFilterByBusiness,self).has_add_permission(request) def queryset(self, request): # get the default queryset, pre-filter qs = super(AdminFilterByBusiness, self).queryset(request) # if not (request.user.is_superuser): # filter only shows blogs mapped to currently logged-in user try: qs = qs.filter(business=request.user.business_set.all()[0]) except: raise ValueError('Operator has not been created. Please Contact Admins') return qs def formfield_for_dbfield(self, db_field, **kwargs): """ Fix drop down lists to populate as per user request """ #regular return for superuser if self.request.user.is_superuser: return super(AdminFilterByBusiness, self).formfield_for_dbfield( db_field, **kwargs) if db_field.name == "business": return forms.ModelChoiceField( queryset = self.request.user.business_set.all() ) #default return super(AdminFilterByBusiness, self).formfield_for_dbfield(db_field, **kwargs)
