[site]: stackoverflow
[post_id]: 1106501
[parent_id]: 1105938
[tags]: 
You don't want to use long int. That can be different sizes on different platforms, so is a non-starter for a platform-independent format. You have to decide what range of values needs to be stored in the file. 32 bits is probably easiest. You say you aren't worried about other platforms yet . I'll take that to mean you want to retain the possibility of supporting them, in which case you should define the byte-order of your file format. x86 is little-endian, so you might think that's the best. But big-endian is the "standard" interchange order if anything is, since it's used in networking. If you go for big-endian ("network byte order"): // can't be bothered to support really crazy platforms: it is in // any case difficult even to exchange files with 9-bit machines, // so we'll cross that bridge if we come to it. assert(CHAR_BIT == 8); assert(sizeof(uint32_t) == 4); { // write value uint32_t value = 23; const uint32_t networkOrderValue = htonl(value); fwrite(&networkOrderValue, sizeof(uint32_t), 1, file); } { // read value uint32_t networkOrderValue; fread(&networkOrderValue, sizeof(uint32_t), 1, file); uint32_t value = ntohl(networkOrderValue); } Actually, you don't even need to declare two variables, it's just a bit confusing to replace "value" with its network order equivalent in the same variable. It works because "network byte order" is defined to be whatever arrangement of bits results in an interchangeable (big-endian) order in memory. No need to mess with unions because any stored object in C can be treated as a sequence of char. No need to special-case for endianness because that's what ntohl/htonl are for. If this is too slow, you can start thinking about fiendishly optimised platform-specific byte-swapping, with SIMD or whatever. Or using little-endian, on the assumption that most of your platforms will be little-endian and so it's faster "on average" across them. In that case you'll need to write or find "host to little-endian" and "little-endian to host" functions, which of course on x86 just do nothing.
