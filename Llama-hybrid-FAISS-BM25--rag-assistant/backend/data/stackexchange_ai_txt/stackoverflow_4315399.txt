[site]: stackoverflow
[post_id]: 4315399
[parent_id]: 
[tags]: 
error C2143: syntax error : missing ';' before '*'

I'm not new to C++ but I am used to running a g++ compiler vs Microsoft's VS C++. I understand what this error should mean. It should mean that I'm missing a ';' on the line before or in the class Polygon. I can't seem to find anything wrong. g++ compiles the code without error. It seems like the Polygon Class isn't being loaded. Can anyone please show me what I'm missing please.I have the Application.cpp, Polygon.h, and Polygon.cpp below. Application.cpp throwing errors but if I can fix the first others will follow: application.cpp(121) : error C2143: syntax error : missing ';' before '*' application.cpp(121) : error C4430: missing type specifier - int assumed. Note: C++ does not support default-int application.cpp(121) : error C2365: 'Polygon' : redefinition; previous definition was 'function' c:\program files\microsoft sdks\windows\v6.0a\include\wingdi.h(4203) : see declaration of 'Polygon' #include #include #include #include "Polygon.h" #define PI 3.14159265 //use standard namespace using namespace std; /**************************** Window Variables ****************************/ double _window_height = 500; double _window_width = 500; double _window_position_x = 0; double _window_position_y = 0; string _window_title ("Assignment 5"); /**************************** Object Variables ****************************/ int _my_shape = 0; GLint _object_shine = 40; double _object_y_rotation = 0; GLfloat ambient_reflection[3] = {1.0, 1.0, 1.0}; GLfloat diffuse_reflection[3] = {1.0, 1.0, 1.0}; GLfloat specular_reflection[3] = {1.0, 1.0, 1.0}; GLfloat emissive_color[3] = {0.0, 0.0, 0.0}; int specular_exponent = 0; /*************************** Lighting Variables ***************************/ //Global Light settings GLfloat _global_ambient_light[] = {0.5, 0.5, 0.5, 1.0}; GLfloat _global_diffuse_light[] = {0.7, 0.7, 0.7, 1.0}; int rotation_int = 0; int rotation_angle = 90; int _CAMERA_DISTANCE = 2; //Light 0 Settings GLfloat _z_axis_rotations[8][4] = {{(_CAMERA_DISTANCE*cos((90)*PI/180)), (_CAMERA_DISTANCE*sin((90)*PI/180)), 0.0, 1.0}, {(_CAMERA_DISTANCE*cos((45)*PI/180)), (_CAMERA_DISTANCE*sin((45)*PI/180)), 0.0, 1.0}, {(_CAMERA_DISTANCE*cos((0)*PI/180)), (_CAMERA_DISTANCE*sin((0)*PI/180)), 0.0, 1.0}, {(_CAMERA_DISTANCE*cos((315)*PI/180)), (_CAMERA_DISTANCE*sin((315)*PI/180)), 0.0, 1.0}, {(_CAMERA_DISTANCE*cos((270)*PI/180)), (_CAMERA_DISTANCE*sin((270)*PI/180)), 0.0, 1.0}, {(_CAMERA_DISTANCE*cos((225)*PI/180)), (_CAMERA_DISTANCE*sin((225)*PI/180)), 0.0, 1.0}, {(_CAMERA_DISTANCE*cos((180)*PI/180)), (_CAMERA_DISTANCE*sin((180)*PI/180)), 0.0, 1.0}, {(_CAMERA_DISTANCE*cos((135)*PI/180)), (_CAMERA_DISTANCE*sin((135)*PI/180)), 0.0, 1.0}}; GLfloat _ambient_0_light[] = {0.3f, 0.3f, 0.3f, 1.0f}; GLfloat _diffuse_0_light[] = {0.6f, 0.6f, 0.6f, 1.0f}; GLfloat _specular_0_light[] = {0.6f, 0.6f, 0.6f, 1.0f}; GLfloat _specular_0_property[] = {0.6f, 0.6f, 0.6f, 1.0f}; //Light 1 Settings // Green Spotlight with narrow angle GLfloat _light_1_position[] = {2.0, 0.0, -0.5, 1.0}; GLfloat _diffuse_1_light[] = {0.2, 0.4, 0.9, 1.0}; GLfloat _spot_1_direction[] = {-0.3, -2.0, -0.3}; //Light 2 Settings // Red Spotlight with wide angle GLfloat _light_2_position[] = {0.3, -0.5, 4.0, 1.0}; GLfloat _diffuse_2_light[] = {1.0, 0.2, 0.6, 1.0}; GLfloat _spot_2_direction[] = {0.3, -0.5, -2.0}; GLfloat _cutoff = 90.0; GLfloat _AMBIENT_CONSTANT = 0.1; GLfloat _DIFFUSE_CONSTANT = 0.1; GLfloat _EMISSION_CONSTANT = 0.05; GLfloat _SPECULAR_CONSTANT = 0.1; int _SPECULAR_EXPONENT_CONSTANT = 1; int _CUTOFF_CONSTANT = 1; /*************************** Shading Variables ***************************/ bool _shade_model_smooth = true; /**************************** File Variables *****************************/ //Error String printed if the file is not found string _FILE_OPEN_ERROR = "Error: File could not be found or opened."; //Error String printed if the file is not formed correctly string _CHOICE_INVALID_ERROR = "Error: The choice you made was not one that is defined."; /** for file reading **/ //The Array for holding all the Polygons Polygon** _Polygons; //the current size of the Polygon Array int _polygons_max = 10; //the current element for processing in the Polygon Array int _polygons_current = 0; /* ReadFromFile * * This method will ask a filename from the user and either return to * the user a file not found error or will read in from the file the * coordinates and place them in the coordinate array, while also setting * the number of lines that make up a shape. */ void ReadFromFile(){ ifstream input; // input file stream string filename = ""; // used to store filename string line = ""; // temporary storage for reading lines at a time // cout > filename; //cout = _polygons_max){ _polygons_max = _polygons_max * 2; //double max size Polygon** temp = new Polygon*[_polygons_max]; //create bigger array for (int j = 0; j setAmbientReflection(_light_settings[0], _light_settings[1], _light_settings[2]); _Polygons[_polygons_current]->setDiffuseReflection(_light_settings[3], _light_settings[4], _light_settings[5]); _Polygons[_polygons_current]->setSpecularReflection(_light_settings[6], _light_settings[7], _light_settings[8]); _Polygons[_polygons_current]->setEmissiveColor(_light_settings[9], _light_settings[10], _light_settings[11]); _Polygons[_polygons_current]->setSurfaceNormals(_normals[0], _normals[1], _normals[2]); _Polygons[_polygons_current]->setSpecularExponent(SH); for(int i=0; i = _coordinate_max){ _coordinate_max = _coordinate_max * 2; //double max size double** temp = new double*[_coordinate_max]; //create bigger array for (int i = 0; i 180){ _cutoff = 180; }else{ _cutoff += _CUTOFF_CONSTANT; } glLightf(GL_LIGHT0, GL_SPOT_CUTOFF, _cutoff); break; case '-': /* Decrease the cutoff angle of the positional light. */ if(_cutoff == 180){ _cutoff = 90; }else if((_cutoff-_CUTOFF_CONSTANT) 0){ _global_ambient_light[0] = _global_ambient_light[1] = _global_ambient_light[2] -= _AMBIENT_CONSTANT; glLightModelfv(GL_LIGHT_MODEL_AMBIENT, _global_ambient_light); } break; case 'A': /* Increase the ambient light. */ if(_global_ambient_light[0] 0){ _global_diffuse_light[0] = _global_diffuse_light[1] = _global_diffuse_light[2] -= _DIFFUSE_CONSTANT; glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, _global_diffuse_light); } break; case 'D': /* Increase the diffuse light. */ if(_global_diffuse_light[0] getSpecularReflection(); for(int j=0; j 1.0){ specular_reflection[i] = 1.0; }else{ specular_reflection[i] += _SPECULAR_CONSTANT; } } }else{ for(int i=0; i getSpecularReflection(); for(int j=0; j 1.0){ sr[j] = 1.0; }else{ sr[j] += _SPECULAR_CONSTANT; } } } } break; case 'h': /* Decrease the shininess of the object. */ if(_my_shape != 1){ if((specular_exponent-_SPECULAR_EXPONENT_CONSTANT) getSpecularExponent(); if((sh-_SPECULAR_EXPONENT_CONSTANT) setSpecularExponent(0); }else{ _Polygons[i]->setSpecularExponent(sh-_SPECULAR_EXPONENT_CONSTANT); } } } break; case 'H': /* Increase the shininess of the object. */ if(_my_shape != 1){ if((specular_exponent+_SPECULAR_EXPONENT_CONSTANT) > 128){ specular_exponent = 128; }else{ specular_exponent+=_SPECULAR_EXPONENT_CONSTANT; } }else{ for(int i=0; i getSpecularExponent(); if((sh+_SPECULAR_EXPONENT_CONSTANT) > 128){ _Polygons[i]->setSpecularExponent(128); }else{ _Polygons[i]->setSpecularExponent(sh+_SPECULAR_EXPONENT_CONSTANT); } } } break; case 'e': /* Decrease the emissive light of the object. */ if(_my_shape != 1){ if((emissive_color[0]-_EMISSION_CONSTANT) getEmissiveColor(); if((ep[0]-_EMISSION_CONSTANT) 1){ emissive_color[0] = 1; }else{ emissive_color[0] += _EMISSION_CONSTANT; } if((emissive_color[1]+_EMISSION_CONSTANT) > 1){ emissive_color[1] = 1; }else{ emissive_color[1] += _EMISSION_CONSTANT; } if((emissive_color[2]+_EMISSION_CONSTANT) > 1){ emissive_color[2] = 1; }else{ emissive_color[2] += _EMISSION_CONSTANT; } }else{ for(int i=0; i getEmissiveColor(); if((ep[0]+_EMISSION_CONSTANT) > 1){ ep[0] = 1; }else{ ep[0] += _EMISSION_CONSTANT; } if((ep[1]+_EMISSION_CONSTANT) > 1){ ep[1] = 1; }else{ ep[1] += _EMISSION_CONSTANT; } if((ep[2]+_EMISSION_CONSTANT) > 1){ ep[2] = 1; }else{ ep[2] += _EMISSION_CONSTANT; } } } break; case 'p': /* Rotate the positional light about the Z-axis */ glLoadIdentity(); if(rotation_int == 7){ rotation_int = 0; }else{ rotation_int++; } glLightfv(GL_LIGHT0, GL_POSITION, _z_axis_rotations[rotation_int]); break; case 'P': /* Rotate the positional light about the Z-axis */ glLoadIdentity(); if(rotation_int == 0){ rotation_int = 7; }else{ rotation_int--; } glLightfv(GL_LIGHT0, GL_POSITION, _z_axis_rotations[rotation_int]); break; case 'o': /* Rotate the objects around the Y-axis : negative */ _object_y_rotation -= 15.0; break; case 'O': /* Rotate the objects around the Y-axis : positive */ _object_y_rotation += 15.0; break; case 'q': case 'Q': /* Quit the program */ exit(0); } //Call redisplay to draw changes glutPostRedisplay(); } void DrawFromFile(){ glPushMatrix(); for(int i=0; i getAmbientReflection(); double* dp = _Polygons[i]->getDiffuseReflection(); double* ep = _Polygons[i]->getEmissiveColor(); double* sp = _Polygons[i]->getSpecularReflection(); GLfloat amt[] = {ap[0], ap[1], ap[2], 1}; GLfloat dif[] = {dp[0], dp[1], dp[2], 1}; GLfloat emc[] = {ep[0], ep[1], ep[2], 1}; GLfloat spc[] = {sp[0], sp[1], sp[2], 1}; int _p_sides = _Polygons[i]->getSides(); glMaterialfv(GL_FRONT, GL_AMBIENT, amt); glMaterialfv(GL_FRONT, GL_DIFFUSE, dif); glMaterialfv(GL_FRONT, GL_EMISSION, emc); glMaterialfv(GL_FRONT, GL_SPECULAR, spc); glMateriali(GL_FRONT, GL_SHININESS, _Polygons[i]->getSpecularExponent()); glBegin(GL_POLYGON); for(int j=0; j getSurfaceNormals()); glVertex3dv(_Polygons[i]->getVertex(j)); } glEnd(); } glPopMatrix(); } void Display(void){ glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ); glShadeModel (GL_SMOOTH); //Perspective data here glMatrixMode(GL_PROJECTION); gluPerspective(45, 1, 0, 2); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glPushMatrix(); switch(_my_shape){ case 1: glTranslated(0, 0, -1); glRotated(_object_y_rotation, 0, 1, 0); DrawFromFile(); break; case 2: glMaterialfv(GL_FRONT, GL_AMBIENT, ambient_reflection); glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse_reflection); glMaterialfv(GL_FRONT, GL_EMISSION, emissive_color); glMaterialfv(GL_FRONT, GL_SPECULAR, specular_reflection); glMateriali(GL_FRONT, GL_SHININESS, specular_exponent); glRotated(_object_y_rotation, 0, 1, 0); glutSolidTeapot(0.8); break; case 3: glMaterialfv(GL_FRONT, GL_AMBIENT, ambient_reflection); glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse_reflection); glMaterialfv(GL_FRONT, GL_EMISSION, emissive_color); glMaterialfv(GL_FRONT, GL_SPECULAR, specular_reflection); glMateriali(GL_FRONT, GL_SHININESS, specular_exponent); glRotated(_object_y_rotation, 0, 1, 0); glutSolidIcosahedron(); break; case 4: glMaterialfv(GL_FRONT, GL_AMBIENT, ambient_reflection); glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse_reflection); glMaterialfv(GL_FRONT, GL_EMISSION, emissive_color); glMaterialfv(GL_FRONT, GL_SPECULAR, specular_reflection); glMateriali(GL_FRONT, GL_SHININESS, specular_exponent); glRotated(_object_y_rotation, 0, 1, 0); glutSolidTorus(0.3, 0.8, 10, 30); break; default: cout > choice; return choice; } int main(int argc, char** argv){ _my_shape = PollUser(); InitializeWindow(argc, argv); /* Initialize window */ InitializeEnvironment(); /* Initialize other parameter */ glutDisplayFunc(Display); /* Redisplay callback event handling */ glutKeyboardFunc(Keyboard); /* Keyboard callback function */ ReadFromFile(); /* Read from file */ glutMainLoop(); /* Start glut functions */ return 0; } Polygon.h #ifndef POLYGON_H_ #define POLYGON_H_ #include #include #include class Polygon { public: Polygon(); Polygon(int, double**); virtual ~Polygon(); void *operator new(size_t size); void operator delete(void *p); void *operator new[](size_t size); void operator delete[](void *p); double* getVertex(int); void setSpecularExponent(int); void setSurfaceNormals(double,double,double); void setAmbientReflection(double,double,double); void setDiffuseReflection(double,double,double); void setSpecularReflection(double,double,double); void setEmissiveColor(double,double,double); int getSides(void); int getSpecularExponent(void); double* getSurfaceNormals(void); double* getAmbientReflection(void); double* getDiffuseReflection(void); double* getSpecularReflection(void); double* getEmissiveColor(void); private: double** verticies; double surface_normals[3]; double ambient_reflection[3]; double diffuse_reflection[3]; double specular_reflection[3]; double emissive_color[3]; int sides; int spec_ex; }; #endif /* POLYGON_H_ */ Polygon.cpp #include "Polygon.h" using namespace std; Polygon::Polygon(){ sides = 0; } Polygon::Polygon(int numberOfSides, double** polyVerticies){ sides = numberOfSides; verticies = new double*[numberOfSides]; for(int n=0; n Thanks for any help anyone can offer.
