[site]: stackoverflow
[post_id]: 1725166
[parent_id]: 1724675
[tags]: 
Probably not for elegance, but just because I can do it in a oneliner :) >>> reduce(lambda a,ij:a[:-1]+[str[a[-1]:ij[0]],'('+str[ij[0]:ij[1]+1]+')', ij[1]], split_points, [0])[:-1] + [str[split_points[-1][-1]+1:]] ['M', '(SEP)', 'PAGD', '(VRQN)', 'NP', '(CG)', 'SKAC'] Maybe you like it. Here some explanation: In your question you pass one set of slices, and implicitly you want to have the complement set of slices as well (to generate the un-parenthesized [is that English?] slices). So basically, each slice [i,j] lacks the previous j. e.g. [7,10] lacks the 3 and [1,3] lacks the 0. reduce processes lists and at each step passes the output so far ( a ) plus the next input element ( ij ). The trick is that apart from producing the plain output, we add each time an extra variable --- a sort of memory --- which is in the next step retrieved in a[-1] . In this particular example we store the last j value, and hence at all times we have the full information to provide both the unparenthesized and the parenthesized substring. Finally, the memory is stripped with [:-1] and replaced by the remainder of the original str in [str[split_points[-1][-1]+1:]] .
