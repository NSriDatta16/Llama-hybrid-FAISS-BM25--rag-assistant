[site]: stackoverflow
[post_id]: 4802849
[parent_id]: 4802674
[tags]: 
You need to properly learn about arrays and pointers. This includes the lesson "huh! They are not as useful as I thought they were". After you've gotten familiar with how arrays and pointers work exactly you should rethink your design. For example, in my opinion, the following design has lots of advantages: #ifndef MATRIX_HPP_INCLUDED #define MATRIX_HPP_INCLUDED #include #include class matrix { public: typedef std::vector ::size_type st; matrix() : rows_(0), cols_(0) {} matrix(int r, int c) : rows_(r), cols_(c), coeffs_(st(r)*c,0.0) {} void reset(int r, int c) { rows_=r; cols_=c; coeffs_.clear(); coeffs_.resize(st(r)*c,0.0); } int rows() const {return rows_;} int cols() const {return cols_;} double const& operator()(int i, int j) const {return coeffs_[indexof(i,j)];} double & operator()(int i, int j) {return coeffs_[indexof(i,j)];} double const* operator[](int i) const {return &coeffs_[indexof(i,0)];} double * operator[](int i) {return &coeffs_[indexof(i,0)];} void swap(matrix& that) { std::swap(this->rows_,that.rows_); std::swap(this->cols_,that.cols_); this->coeffs_.swap(that.coeffs_)); } private: int rows_, cols_; std::vector coeffs_; st indexof(int i, int j) const {return st(i)*cols+j;} // row major storage }; inline void swap(matrix& a, matrix& b) {a.swap(b);} matrix& operator+=(matrix& lhs, matrix const& rhs); matrix operator+(matrix const& lhs, matrix const& rhs); matrix operator*(matrix const& lhs, matrix const& rhs); inline matrix& operator*=(matrix& lhs, matrix const& rhs) { matrix tmp = lhs * rhs; swap(tmp,lhs); return lhs; } ... #endif This way you won't waste any space for small matrices, and you can support large matrices. Also, the use of std::vector instead of a pointer member which points to dynamically allocated memory removes the need to define your own copy constructor, assignment operator and destructor. Of course, you could use boost::multi_array as a matrix replacement but using a custom matrix class allows you to declare overloaded operators in your own namespace which is desirable due to ADL (argument dependent lookup). You might think that this doesn't really answer your question. In that case, let me stress that I think you don't fully understand how arrays and pointers work / behave. This is something you should look up in a decent C++ book. One could write many pages about this topic. You can't expect to see a short answer explaining all the quirks. Check out the Definite C++ Book Guide thread.
