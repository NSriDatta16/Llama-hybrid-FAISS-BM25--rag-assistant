[site]: stackoverflow
[post_id]: 5496282
[parent_id]: 5496068
[tags]: 
I would use a Queue of strings with a critical section inside push() and pop() . Inside the thread I would pop strings off, and log them. Inside the GUI thread I would push strings on the queue. I have done something similar before, and it is simple to implement. Edit Interface: TThreadSafeQueue = class(TQueue) protected procedure PushItem(AItem: Pointer); override; function PopItem: Pointer; override; function PeekItem: Pointer; override; end; var CRITICAL_SECTION: TCriticalSection; Implementation: function TThreadSafeQueue.PeekItem: Pointer; begin CRITICAL_SECTION.Enter; Result := inherited PeekItem; CRITICAL_SECTION.Leave; end; function TThreadSafeQueue.PopItem: Pointer; begin CRITICAL_SECTION.Enter; Result := inherited PopItem; CRITICAL_SECTION.Leave; end; procedure TThreadSafeQueue.PushItem(AItem: Pointer); begin CRITICAL_SECTION.Enter; inherited PushItem(AItem); CRITICAL_SECTION.Leave; end; Initialization CRITICAL_SECTION := TCriticalSection.Create; Finalization FreeAndNil(CRITICAL_SECTION); This code uses pointers to objects, but you can create storage for your strings inside the object, using a stringlist or array or whatever best fits your purpose, and change the pop and push methods to operate on your own storage. Edit Something like this: procedure TMyThread.Execute; var Msg: string; begin while not Terminated do begin if FQueue.Count > 0 then begin Msg := FQueue.pop(); PerformLog(Msg); {Whatever your logging method is} end; Sleep(0); end; end;
