[site]: stackoverflow
[post_id]: 1444660
[parent_id]: 1443886
[tags]: 
I'm going to attempt to explain with examples why this is a bad idea, rather than using cryptic terms. Your proposal would be to have code that looks like this: public class Base { public int Item1 { get; set; } public int Item2 { get; set; } } public class WithHidden : Base { hide Item1; // Assuming some new feature "hide" in C# } public class WithoutHidden : Base { } This would then make the following code invalid: WithHidden a = new WithHidden(); a.Item1 = 10; // Invalid - cannot access property Item1 int i = a.Item1; // Invalid - cannot access property Item1 And that would be just what you wanted. However, suppose we now have the following code: Base withHidden = new WithHidden(); Base withoutHidden = new WithoutHidden(); SetItem1(withHidden); SetItem1(withoutHidden); public void SetItem1(Base base) { base.Item1 = 10; } The compiler doesn't know what runtime type the argument base in SetItem1 will be, only that it is at least of type Base (or some type derived from Base, but it can't tell which -- it may be obvious looking at the code snippet, but more complex scenarios make it practically impossible). So the compiler will not, in a large percentage of the cases, be able to give a compiler error that Item1 is in fact inaccessible. So that leaves the possibility of a runtime check. When you try and set Item1 on an object which is in fact of type WithHidden it would throw an exception. Now accessing any member, any property on any non-sealed class (which is most of them) may throw an exception because it was actually a derived class which hid the member. Any library which exposes any non-sealed types would have to write defensive code when accessing any member just because someone may have hidden it. A potential solution to this is to write the feature such that only members which declare themselves hideable can be hidden. The compiler would then disallow any access to the hidden member on variables of that type (compile time), and also include runtime checks so that a FieldAccessException is thrown if it is cast to the base type and tried to be accessed from that (runtime). But even if the C# developers did go to the huge trouble and expense of this feature (remember, features are expensive , especially in language design) defensive code still has to be written to avoid the problems of potential FieldAccessExceptions being thrown, so what advantage over reorganising your inheritance hierarchy have you gained? With the new member hiding feature there would be a huge number of potential places for bugs to creep into your application and libraries, increasing development and testing time.
