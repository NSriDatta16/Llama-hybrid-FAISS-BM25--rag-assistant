[site]: stackoverflow
[post_id]: 3396462
[parent_id]: 3396393
[tags]: 
Since a container is tied to one type of data it can contain, you could create a class GeometryBase from which all Geometry are derived and then store GeometryBase pointers in your container. struct GeometryBase { // Non-template methods might go here. // Don't forget to declare the base class destructor virtual. }; template struct Geometry : public GeometryBase { // Template methods go here }; Edit: At some point you will have to decide which type of vertex container you want to get (my approach) or what you want to do with a vertex (Vijay Mathew's approach) and then you'll have to dynamic_cast<> in order to get access to the derived class methods. Another suggestion: If the types are as different as your describe in your comments, it might actually be better to treat them as different types. For example, you could create a separate container for each Geometry<> template instance. class SomeStorageClass { /* ... */ private: std::vector > m_vertex1Geometries; std::vector > m_vertex2Geometries; }; If you have functions that operate on one kind of geometry (using Vertex1::GetPos() , to use your example) or the other ( Vertex2::GetUV() ) then these functions are probably implemented quite differently and thus deserve to be separate functions expecting diferent types of parameters.
