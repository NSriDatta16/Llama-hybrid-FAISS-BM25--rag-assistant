[site]: stackoverflow
[post_id]: 1479517
[parent_id]: 1412751
[tags]: 
top k is usually a bit better than n(log k) template class TopK { public: typedef std::multiset BEST_t; BEST_t best; const size_t K; TopK(const size_t k) : K(k){ } const BEST_t& insert(const t& item){ if(best.size() const BEST_t& insert(it i,const it last){ for(;i!=last;++i){ insert(*i); } return best; } }; Of course the special_allocator can in essence be just an array of k multiset value_types and a list of those nodes (which typically has nothing on it as the other k are in use in the multiset until its time to put a new one in and we erase and then immediate ly reuse it. Good to have this or else the memory alloc/free in std::multiset and the cache line crap kills ya. Its a (very) tiny bit of work to give it static state without violating STL allocator rules. Not as good as a specialized algo for exactly 2 but for fixed k , I would GUESS (2n+delta*n) where delta is small - my DEK ACP vol3 S&S is packed away and an estimate on delta is a bit more work that I want to do. average worst is I would guess n(log(k-1) + 2) when in opposite order and all distinct. best is 2n + k(log k) for the k best being the first
