[site]: stackoverflow
[post_id]: 2690245
[parent_id]: 
[tags]: 
Proper use of "atomic directive" to lock STL container

I have a large number of sets of integers, which I have, in turn, put into a vector of pointers. I need to be able to update these sets of integers in parallel without causing a race condition. More specifically. I am using OpenMP's "parallel for" construct. For dealing with shared resources, OpenMP offers a handy "atomic directive," which allows one to avoid a race condition on a specific piece of memory without using locks. It would be convenient if I could use the "atomic directive" to prevent simultaneous updating to my integer sets, however, I'm not sure whether this is possible. Basically, I want to know whether the following code could lead to a race condition vector * > membershipDirectory(numSets, new set ); #pragma omp for schedule(guided,expandChunksize) for(int i=0; i * sp = membershipDirectory[rand()]; #pragma omp atomic sp->insert(45); } Note that I use a random integer for the index, because in my application, any thread might access any index (there is a random element in my larger application, but I need not go into details). I have seen a similar example of this for incrementing an integer , but I'm not sure whether it works when working with a pointer to a container as in my case.
