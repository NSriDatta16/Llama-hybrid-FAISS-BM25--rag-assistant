[site]: stackoverflow
[post_id]: 4086799
[parent_id]: 4084884
[tags]: 
Yes, the change you made is indeed critical. :-) What the for-each loop does is select each element matching your XPath expression, make that element the context node for what's inside the for-each (called the template even though it's not an ), and then instantiate that inner template with the new context node. When you were continuing to use "$doc/..." inside the for-each loop, you were throwing away the context node, so the for-each was having no effect (except to repeat n times). Your statements were evaluating whether there was any such node in the whole document instead of under the context element . The statement pays attention to only the first node in the selected nodeset, so you were always getting the value from the first , regardless of the context node. When you started selecting and testing relative to the context node: everything became better. :-) You asked for valuable input. For stylistic reasons, you may want to replace your tests with . (For one thing you'll make @Dimitre Novatchev happy. :-) So becomes and then you need a separate template for those: There are several advantages to doing that. The biggest is that you don't have to duplicate that long XPath expression, which was error-prone if the expression ever needed to be modified. If there are no em:comment elements, the apply-templates will not do anything, so will not emit a comment. It also modularizes your stylesheet, so that you can modify how em:comments are rendered, separately from wherever they may occur. That may not matter too much in simple XML documents where em:comments occurs in only one place, but it is the style that takes best advantage of XSLT's power. Also note that this modified version will output multiple comments if there are multiple em:comments, which your version will not. Again you probably don't have multiples in the input, so it may not matter. Similarly for the output attributes: can become with a separate template Note the [1] , which avoids attempting to output multiple old="..." attributes for the same element if the input em:VanityUrl has multiple em:old elements. That would be cause your stylesheet to raise an error. But maybe you want to raise an error in that case. If so, you are probably already validating your input XML. In fact, you can generalize the apply-templates and the template here to apply to all three attributes: Again, if any of these elements are not present, nothing will be done for them (no empty attribute will be produced). The template: local-name() gives us the name of the element, without the namespace prefix. Update: Another way to handle that would be to use a mode: Then your make-attribute template can be used from anywhere, and the match pattern doesn't have to be updated to match every possible element you might want to make an attribute from. The only other thing I would say is that the use of namespaces above is confusing...it shouldn't work as-is. E.g. your stylesheet uses this namespace URI for elements like VanityURL: "http://www.espire.com/tridion/schemas" but the second input document uses this namespace URI for those elements: "uuid:922EEC29-2DE3-4BA1-A46A-A300CB8FA85F" It doesn't matter that the namespace prefixes are different ("em:" vs. default), but the namespace URIs have to match. I guess VanityURL's namespace URI must have changed, or else your stylesheet wouldn't work... HTH!
