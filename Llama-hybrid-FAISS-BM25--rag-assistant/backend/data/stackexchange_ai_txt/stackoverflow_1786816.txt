[site]: stackoverflow
[post_id]: 1786816
[parent_id]: 1785862
[tags]: 
I was going to leave George to point out that you can now consume the interface rather than the concrete class. It seems like everyone here understands what interfaces are and how to define them, but most have failed to explain the key point of them in a way a student will easily grasp - and something that most courses fail to point out instead leaving you to either grasp at straws or figure it out for yourself so I'll attempt to spell it out in a way that doesn't require either. So hopefully you won't be left thinking "so what, it still seems like a waste of time/effort/code." public interface ICar { public bool EngineIsRunning{ get; } public void StartEngine(); public void StopEngine(); public int NumberOfWheels{ get; } public void Drive(string direction); } public class SportsCar : ICar { public SportsCar { Console.WriteLine("New sports car ready for action!"); } public bool EngineIsRunning{ get; protected set; } public void StartEngine() { if(!EngineIsRunning) { EngineIsRunning = true; Console.WriteLine("Engine is started."); } else Console.WriteLine("Engine is already running."); } public void StopEngine() { if(EngineIsRunning) { EngineIsRunning = false; Console.WriteLine("Engine is stopped."); } else Console.WriteLine("Engine is already stopped."); } public int NumberOfWheels { get { return 4; } } public void Drive(string direction) { if (EngineIsRunning) Console.WriteLine("Driving {0}", direction); else Console.WriteLine("You can only drive when the engine is running."); } } public class CarFactory { public ICar BuildCar(string car) { switch case(car) case "SportsCar" : return Activator.CreateInstance("SportsCar"); default : /* Return some other concrete class that implements ICar */ } } public class Program { /* Your car type would be defined in your app.config or some other * mechanism that is application agnostic - perhaps by implicit * reference of an existing DLL or something else. My point is that * while I've hard coded the CarType as "SportsCar" in this example, * in a real world application, the CarType would not be known at * design time - only at runtime. */ string CarType = "SportsCar"; /* Now we tell the CarFactory to build us a car of whatever type we * found from our outside configuration */ ICar car = CarFactory.BuildCar(CarType); /* And without knowing what type of car it was, we work to the * interface. The CarFactory could have returned any type of car, * our application doesn't care. We know that any class returned * from the CarFactory has the StartEngine(), StopEngine() and Drive() * methods as well as the NumberOfWheels and EngineIsRunning * properties. */ if (car != null) { car.StartEngine(); Console.WriteLine("Engine is running: {0}", car.EngineIsRunning); if (car.EngineIsRunning) { car.Drive("Forward"); car.StopEngine(); } } } As you can see, we could define any type of car, and as long as that car implements the interface ICar, it will have the predefined properties and methods that we can call from our main application. We don't need to know what type of car is - or even the type of class that was returned from the CarFactory.BuildCar() method. It could return an instance of type "DragRacer" for all we care, all we need to know is that DragRacer implements ICar and we can carry on life as normal. In a real world application, imagine instead IDataStore where our concrete data store classes provide access to a data store on disk, or on the network, some database, thumb drive, we don't care what - all we would care is that the concrete class that is returned from our class factory implements the interface IDataStore and we can call the methods and properties without needing to know about the underlying architecture of the class. Another real world implication (for .NET at least) is that if the person who coded the sports car class makes changes to the library that contains the sports car implementation and recompiles, and you've made a hard reference to their library you will need to recompile - whereas if you've coded your application against ICar, you can just replace the DLL with their new version and you can carry on as normal.
