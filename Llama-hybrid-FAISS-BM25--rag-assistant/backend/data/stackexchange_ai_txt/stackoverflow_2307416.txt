[site]: stackoverflow
[post_id]: 2307416
[parent_id]: 2307062
[tags]: 
You don't normally get mouse messages when the mouse isn't over your window. But you need to in order to do drag and drop operations. So, Windows provides a mechanism called mouse capture. To prevent mouse capture from being abused, you can only capture the mouse on a button down message. Once you have capture, you get mouse move messages no matter where the mouse is on screen until you release capture or when Windows sees the corresponding button up message. The C++ code for this looks something like this case WM_LBUTTONDOWN: { SetCapture(hwnd); } break; case WM_MOUSEMOVE: if (GetCapture() == hwnd) { POINT pt = {GET_MOUSE_X(lParam), GET_MOUSE_Y(lParam)); ClientToScreen(hwnd, &pt); HWND hwndAtPoint = WindowFromPoint(pt); // Show info for hwndAtPoint.... } break; case WM_LBUTTONUP: if (GetCapture() == hwnd) { ReleaseCapture(); } break; case WM_CANCELMODE: // this is a request from Windows that leave my modal state if (GetCapture() == hwnd) ReleaseCapture(hwnd); break; case WM_CAPTURECHANGED: // notification that I lost capture (I released it or it was taken from me) break; The GetAncestor function can be helpful to go from the window at the point, to the top level window that own it. GetWindow can be used to walk around the window tree. In .NET, the Control class has a Capture property that does the same thing see http://msdn.microsoft.com/en-us/library/system.windows.forms.control.capture.aspx
