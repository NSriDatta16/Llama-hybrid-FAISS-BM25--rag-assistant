[site]: stackoverflow
[post_id]: 3304092
[parent_id]: 
[tags]: 
Orphans remain in database even with orphanRemoval=true on one-to-many relationship (JPA/Hibernate)

@Entity @Inheritance(strategy = InheritanceType.SINGLE_TABLE) @Table(name = "company_policies") @DiscriminatorColumn(name = "rule_name") public abstract class AbstractPolicyRule implements Serializable { @Transient private static final long serialVersionUID = 1L; @Id @GeneratedValue private Long id; private String value; ... } _ @Entity public class Category implements Serializable { @Transient private static final long serialVersionUID = 1L; @Id @GeneratedValue private Long id; @Column(name = "category_name") private String name; @OneToMany(fetch = FetchType.EAGER, cascade = { CascadeType.ALL }, orphanRemoval = true) @JoinColumn(name = "category_policy_id", referencedColumnName = "id") private Set activePolicyRules; ... } When this Set is updated the existing activePolicyRules have their category_policy_id set to null in the database and new ones are inserted. I'd like for the original ones to be deleted. I thought adding the orphanRemoval = true would do that but it's not. Other questions I've seen on this appear to have bi-directional relationships and setting the parent to null solves it, but this is not a bi-directional relationship. Any suggestions? Using Hibernate 3.5.3 Edit: This only happens when an existing AbstractPolicyRule exists in the database, I remove it from the list and then save the Category again. It's foreign key, category_policy_id, is set to null instead of being deleted. [DEBUG] Collection found: [domain.category.Category.activePolicyRules#1], was: [ ] (initialized) [DEBUG] Flushed: 0 insertions, 2 updates, 0 deletions to 2 objects [DEBUG] Flushed: 1 (re)creations, 0 updates, 1 removals to 1 collections ... [DEBUG] Deleting collection: [domain.category.Category2.activePolicyRules#1] [DEBUG] about to open PreparedStatement (open PreparedStatements: 0, globally: 0) [DEBUG] update company_policies set category_policy_id=null where category_policy_id=? [DEBUG] done deleting collection Also tried a join table since the Hibernate documentation discourages the previous way: @Entity public class Category implements Serializable { @Transient private static final long serialVersionUID = 1L; @Id @GeneratedValue private Long id; @Column(name = "category_name") private String name; @OneToMany(fetch = FetchType.EAGER, cascade = { CascadeType.ALL }, orphanRemoval = true) @JoinTable(name = "policy_rule_mapping", joinColumns = @JoinColumn(name = "category_id"), inverseJoinColumns = @JoinColumn(name = "rule_id")) private Set activePolicyRules; ... } This has the same issue. The row in the mapping table is deleted but the AbstractPolicyRule still contains the removed item.
