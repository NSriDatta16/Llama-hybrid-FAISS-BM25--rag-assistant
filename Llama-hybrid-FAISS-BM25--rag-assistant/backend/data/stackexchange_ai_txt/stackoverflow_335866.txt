[site]: stackoverflow
[post_id]: 335866
[parent_id]: 335660
[tags]: 
Let's say that the box is defined as a set of four points (P1, P2, P3 and P4). For the sake of simplicity, we'll say you are dragging P1, and that P3 is the opposite corner (the one you are using as an anchor). Let's label the mouse position as M, and the new points you wish to calculate as N1, N2 and N4. P3 will, of course, remain the same. Your scaling factor can be simply computed using vector subtraction and the vector dot product: scale = ((M - P3) dot (P1 - P3)) / ((P1 - P3) dot (P1 - P3)) And the three new points can be found using scalar multiplication and vector addition: N1 = scale*P1 + (1 - scale)*P3 N2 = scale*P2 + (1 - scale)*P3 N4 = scale*P4 + (1 - scale)*P3 edit: I see that MizardX has answered the question already, so my answer is here to help with that difficult explanation. I hope it helps! edit: here is the algorithm for non-proportional scaling. In this case, N1 is equal to M (the point being dragged follows the mouse), so the only points of interest are N2 and N4: N2 = ((M - P3) dot (P2 - P3)) / ((P2 - P3) dot (P2 - P3)) * (P2 - P3) + P3 N4 = ((M - P3) dot (P4 - P3)) / ((P4 - P3) dot (P4 - P3)) * (P4 - P3) + P3 where * represents scalar multiplication edit: Here is some C++ code which answers the question. I'm sure this question is long-dead by now, but it was an interesting problem, and I had some fun writing the code. #include class Point { public: float x; float y; Point() { x = y = 0; } Point(float nx, float ny) { x = nx; y = ny; } }; Point& operator-(Point& A, Point& B) { return Point(A.x-B.x, A.y-B.y); } Point& operator+(Point& A, Point& B) { return Point(A.x+B.x, A.y+B.y); } Point& operator*(float sc, Point& P) { return Point(sc*P.x, sc*P.y); } float dot_product(Point A, Point B) { return A.x*B.x + A.y*B.y; } struct Rect { Point point[4]; }; void scale_points(Rect box, int anchor, Point mouse, vector points) { Point& P3 = box.point[anchor]; Point& P2 = box.point[(anchor + 1)%4]; Point& P1 = box.point[(anchor + 2)%4]; Point& P4 = box.point[(anchor + 3)%4]; Point A = P4 - P3; Point aFactor = dot_product(mouse - P3, A) / dot_product(A, A) * A; Point B = P2 - P3; Point bFactor = dot_product(mouse - P3, B) / dot_product(B, B) * B; for (int i = 0; i
