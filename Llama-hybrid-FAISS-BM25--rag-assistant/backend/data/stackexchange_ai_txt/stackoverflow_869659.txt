[site]: stackoverflow
[post_id]: 869659
[parent_id]: 867653
[tags]: 
The default OpenGL framebuffer uses the RGB colour-space, which doesn't store an explicit saturation. You need an approach for extracting the saturation, modifying it, and change it back again. My previous suggestion which simply used the RGB vector length to represent 0 in luminance was incorrect, as it didn't take scaling into account, I apologize. Credit for the new short snippet goes to the regular user "RTFM_FTW" from ##opengl and ##opengl3 on FreeNode/IRC, and it lets you modify the saturation directly without computing the costly RGB->HSV->RGB conversion, which is exactly what you want. Though the HSV code is inferior with respect to your question, I let it stay. void main( void ) { vec3 R0 = texture2DRect( S, gl_TexCoord[0].st ).rgb; gl_FragColor = vec4( mix( vec3( dot( R0, vec3( 0.2125, 0.7154, 0.0721 ) ) ), R0, T ), gl_Color.a ); } If you want more control than just the saturation, you need to convert to HSL or HSV colour-space. As shown below by using a GLSL fragment shader. Read the OpenGL 3.0 and GLSL 1.30 specification available on http://www.opengl.org/registry to learn how to use GLSL v1.30 functionality. #version 130 #define RED 0 #define GREEN 1 #define BLUE 2 in vec4 vertexIn; in vec4 colorIn; in vec2 tcoordIn; out vec4 pixel; Sampler2D tex; vec4 texel; const float epsilon = 1e-6; vec3 RGBtoHSV(vec3 color) { /* hue, saturation and value are all in the range [0,1> here, as opposed to their normal ranges of: hue: [0,360>, sat: [0, 100] and value: [0, 256> */ int sortindex[3] = {RED,GREEN,BLUE}; float rgbArr[3] = float[3](color.r, color.g, color.b); float hue, saturation, value, diff; float minCol, maxCol; int minIndex, maxIndex; if(color.g
