[site]: stackoverflow
[post_id]: 3349361
[parent_id]: 3349195
[tags]: 
For 1) and 3), String::split will do it. It would be something like: /* \n is the end of line character. Depending on the program that creates the text file, you might need to change it to \r\n or \r Note I'm not doing any error checking, you might want to add it... */ var lines:Array = e.target.data.split("\n"); var lastLine:String = lines[lines.length - 1]; If the format is fixed, you can split the last line on "*" or even use substr to get the Artist and song name. /* Again, I'm not checking for any errors */ var songAndArtist:String = lastLine.split("*")[1]; or var songAndArtist:String = lastLine.substr(25); For 2), just poll the server at a reasonable interval. There are a couple of ways of doing this. One could be, whenever you load your file, start a Timer ; when the this timer is done, stop the timer and reload the file. You could also use setTimeout instead of the timer. Edit Not sure what your problem was with the code you posted, but the part that parses the log works fine for me. I re-arrenged it a bit and added checks for errors during the loading of the data. One problem with your code: you call your timer before waiting for you current load operation to finish. This could lead to problems. You don't need to have two downloads at the same time, so you are better of waiting for the download to complete (succesfully or not) before trying to reload (You might not want to try to reload on error; or maybe limit your retries to 2, 3 or something like that, but that's up to you). Also, note I changed the timer's repeat count to 1, so you don't have to stop it. This means it will run once and then it will stop until you call start again). I structured a bit your code to separate its parts into different functions so it's easier to follow. In the parseTracks function I wrapped all the code in a try/catch that catches almost all errors. This is kind of quick and dirty, so I'd generally not recommed that style of error handling, but might do the job here. var reload:Timer = new Timer(5000, 1); reload.addEventListener(TimerEvent.TIMER, onTimer); var tracksLoader:URLLoader = new URLLoader(); tracksLoader.addEventListener(Event.COMPLETE,onTracksLoaded); tracksLoader.addEventListener(IOErrorEvent.IO_ERROR,onTracksError); tracksLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR,onTracksError); loadTracks(); function onTracksLoaded(e:Event):void { trace("onTracksLoaded"); parseTracks(tracksLoader.data); reload.start(); } function onTimer(event:TimerEvent):void{ loadTracks(); } function onTracksError(e:Event):void { trace("onTracksError", e); reload.start(); } function loadTracks():void { tracksLoader.load(new URLRequest("tracks.txt")); } function parseTracks(data:String):void { try { var lines:Array = data.split("\n"); var lastLine:String = lines[lines.length - 1]; var artistAndSong:String = lastLine.substr(24); trace(artistAndSong); } catch(e:Error) { } } Edit 2 Add this function and print its result to try to detect if there's some problem with the characters involved... Call it from parseTracks like this: debugChars(data); function debugChars(str:String):void { var buffer:ByteArray = new ByteArray(); buffer.writeUTFBytes(str); buffer.position = 0; var result:String = ""; while(buffer.bytesAvailable) { result += "0x" + uint(buffer.readUnsignedByte()).toString(16) + ", "; if(buffer.position % 16 == 0) { result += "\n"; } } // print this string... trace(result); }
