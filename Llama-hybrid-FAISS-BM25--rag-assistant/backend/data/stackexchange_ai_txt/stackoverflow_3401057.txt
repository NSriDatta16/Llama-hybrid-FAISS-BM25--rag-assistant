[site]: stackoverflow
[post_id]: 3401057
[parent_id]: 
[tags]: 
How do you define the login page you want unauthorized user to be redirected to

I have decorated my controller with an Authorize attribute, as so: [Authorize(Roles="ExecAdmin")] If I try to go to that controller after logging in as a user who is not ExecAdmin, it does appear to be attempting to redirect to a login page. BUT, the page it is attempting to redirect to is not my login page, it is a view called LogOnUserControl.ascx. This is a partial view that is not displayed by my login page. I have no idea why it is doing this -- or maybe it is trying to redirect to some other page altogether, one which does display LogOnUserControl.ascx. Or maybe it is looking for anything with "LogOn" in the name? (Though the name of my login view is LogOn.aspx...) How can I tell it what page to redirect to? UPDATE: I do have this in the global.asax protected void Application_AuthenticateRequest(Object sender, EventArgs e) { HttpCookie authCookie = Context.Request.Cookies[FormsAuthentication.FormsCookieName]; if (authCookie == null || authCookie.Value == "") { return; } FormsAuthenticationTicket authTicket = null; try { authTicket = FormsAuthentication.Decrypt(authCookie.Value); } catch { return; } string[] roles = authTicket.UserData.Split(new char[] { ';' }); //Context.ClearError(); if (Context.User != null) { Context.User = new System.Security.Principal.GenericPrincipal(Context.User.Identity, roles); } } ... since I am using a non-standard way of defining roles; i.e., I am not using ASP.NET membership scheme (with role providers defined in web.config, etc.). Instead I am setting roles this way: // get user's role string role = rc.rolesRepository.GetUserType(rc.loginRepository.GetUserID(userName)).ToString(); // create encryption cookie FormsAuthenticationTicket authTicket = new FormsAuthenticationTicket( 1, userName, DateTime.Now, DateTime.Now.AddMinutes(120), createPersistentCookie, role //user's role ); // add cookie to response stream string encryptedTicket = FormsAuthentication.Encrypt(authTicket); System.Web.HttpCookie authCookie = new System.Web.HttpCookie(FormsAuthentication.FormsCookieName, encryptedTicket); System.Web.HttpContext.Current.Response.Cookies.Add(authCookie); (This is called after the user has been validated.) Not sure how this could be impacting the whole thing, though ... UPDATE: Thanks to Robert's solution, here's how I solved it -- extend AuthorizeAttribute class: public class AuthorizeAttributeWithMessage : AuthorizeAttribute { private string _message = ""; public string Message { get { return _message; } set { _message = value; } } protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext) { if (filterContext.HttpContext.Request.IsAuthenticated) { // user is logged in but wrong role or user: filterContext.Controller.TempData.Add("Message", Message); } base.HandleUnauthorizedRequest(filterContext); } } Then in the LogOn view: And in the home page view: 0 && TempData.ContainsKey("Message")) { %> And atop the affected controllers: [AuthorizeAttributeWithMessage(Roles = "Consultant,ExecAdmin", Message = "You do not have access to the requested page")] This has the advantage of ALWAYS redirecting any authenticated user who ends up on Logon.aspx -- authenticated users should not be there. If there is a message in the TempData, it will print it out on the home page; if not, it will at least have done the redirect.
