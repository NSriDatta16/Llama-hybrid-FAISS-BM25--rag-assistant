[site]: datascience
[post_id]: 122811
[parent_id]: 121698
[tags]: 
A common approach is to keep audit information separate from the current version of the data. So in your case, the feature_store table would contain just the current version of each row and another table (say feature_store_audit ) would contain the information needed to reconstruct past versions of the rows. This solution allows you to efficiently access the current data. There are a few ways of setting up the feature_store_audit table, depending on your requirements. The most obvious one is that the feature_store_audit table contains a complete copy of every version of the row, plus versioning information such as operation , start_date and end_date . This allows you to easily find historical data, but is inefficient storage-wise especially if the feature_store has a lot of columns. Another solution is to make the feature_store_audit table more like a logging table. It should have columns like primary_key , action_date , action , feature_name , old_value , new_value . Each time you add, delete, or update features you add a row to the audit table for every row and feature combination changed. This solution is more efficient storage-wise (unless you update a lot features at once) than the first solution and makes it easy to see changes to individual features, but it's harder to reconstruct historical versions of entire rows. These first two solutions are fairly standard auditing methods and can be maintained using database triggers, if you want to automate the auditing. A third solution is a sort of combination of both. This would only work if you always add/delete/update features/columns for all rows in the feature_store table at the same time. This solution needs two extra tables, called (say) feature_store_audit and feature_store_column_hist . feature_store_column_hist keeps a log of column changes - so it records when a column is added, deleted, or updated. It needs columns such as audit_column_name , feature_name , start_date , and end_date . The feature_store_audit table then contains only one row for each feature_store record, but a new column (called the same as the audit_column_name) is added each time a feature is added or updated (deleting a feature would result in the end date in feature_store_column_hist being updated, but would not change the feature_store_audit table). The feature_store_column_hist is maintain as follows: to add a feature_store column, create a new record for the column. to update a feature_store column, set the end date of the existing column record and create a new record for the updated column using a new audit_column name. to delete a feature_store column, set the end date of the existing column record. To reconstruct historical records, you would get a list of columns that were "active" at the required time, then select just those columns from the feature_store_audit table. It's a more complicated solution, but avoids the main disadvantages of the previous two solutions.
