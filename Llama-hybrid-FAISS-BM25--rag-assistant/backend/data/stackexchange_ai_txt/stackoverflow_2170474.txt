[site]: stackoverflow
[post_id]: 2170474
[parent_id]: 2170316
[tags]: 
Ok, so as long as you know you are doing something non-portable. You know that right? I mean, it's not like a dozen people haven't said it already... so. for functions on x86 (but not X64) when frame pointer omission and other optimizations aren't enabled, this should work. doesn't work for all calling conventions, but it should work for standard C/C++ calling convention. void ** puEBP = NULL; __asm { mov puEBP, ebp }; void * pvReturn = puEBP[1]; // this is the caller of my function puEBP = (void**)puEBP[0]; // walk back to the previous frame void * pvReturn2 = puEBP[1]; // this is the caller's caller edit: Ok I'm officially confused now. I looked again at your question, and as far as I can tell, the your first code fragment is functionally the same as what I just wrote. But you say that that code gives you the address of your function - but that shouldn't be true. that code fragment should be returning the address of the caller to your function. edit2: added code to get the caller of the caller. By the way this code that you show in your question long addressOfCaller = (*((long*)(returnTo - sizeof(long)))) + returnTo) won't work. It's based on the assumption that the only way to make a call is call symbol where symbol is a 4 byte absolute address of a function. But thats not the only way to make a call. it's also possible to call indirect mov eax, symbol call [eax] or call [ref_symbol] And it also possible to call relative to the current instruction call +12 But you don't need to do this, once you know any address within the calling function, you can use the Debug Help Library to find the address of the function that called you. In order to use DebugHelp, you must have the debug symbols for the code. then just use SymFromAddr .
