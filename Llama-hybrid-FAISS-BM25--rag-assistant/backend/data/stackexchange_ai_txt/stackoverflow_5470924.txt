[site]: stackoverflow
[post_id]: 5470924
[parent_id]: 
[tags]: 
C# LINQ Z-Score query output to a Dictionary >

I have written a query that performs a Z-Score calculation on all the values for a given date. The calculation seems fine, but I am having trouble getting the results of this query into a format that can be returned by the function. The Z-scores are put into a List in the format of {symbol, date, z-score}. The problem is really how to roll that List into the format I need. I would like it to return a Dictionary > that consists of the security string and a sorted list containing all all the date & z-score value pairs for that security. ie. Dictionary > The query calculation is correct ( I think ;->), but any advice on improving the query would also be appreciated as I am still very much a LINQ challenged individual! Here is a sample implementation: using System; using System.Collections.Generic; using System.Linq; namespace Ranking_Query { class Program { static void Main(string[] args) { // created an instance of the datasource and add 4 securities and their time-series to it Datasource ds = new Datasource() { Name = "test" }; ds.securities.Add("6752 JT", new Security() { timeSeries = new Dictionary >() { { "Mkt_Cap", new SortedList () { {new DateTime(2011,01,16),300}, {new DateTime(2011,01,17),303}, {new DateTime(2011,01,18),306}, {new DateTime(2011,01,19),309} } } , { "Liquidity_Rank", new SortedList () { {new DateTime(2011,01,16),1}, {new DateTime(2011,01,17),2}, {new DateTime(2011,01,18),3}, {new DateTime(2011,01,19),4} } } } }); ds.securities.Add("6753 JT", new Security() { timeSeries = new Dictionary >() { { "Mkt_Cap", new SortedList () { {new DateTime(2011,01,16),251}, {new DateTime(2011,01,17),252}, {new DateTime(2011,01,18),253}, {new DateTime(2011,01,19),254} } } , { "Liquidity_Rank", new SortedList () { {new DateTime(2011,01,16),2}, {new DateTime(2011,01,17),3}, {new DateTime(2011,01,18),4}, {new DateTime(2011,01,19),1} } } } }); ds.securities.Add("6754 JT", new Security() { timeSeries = new Dictionary >() { { "Mkt_Cap", new SortedList () { {new DateTime(2011,01,16),203}, {new DateTime(2011,01,17),205}, {new DateTime(2011,01,18),207}, {new DateTime(2011,01,19),209} } }, { "Liquidity_Rank", new SortedList () { {new DateTime(2011,01,16),3}, {new DateTime(2011,01,17),4}, {new DateTime(2011,01,18),1}, {new DateTime(2011,01,19),2} } } } }); ds.securities.Add("6755 JT", new Security() { timeSeries = new Dictionary >() { { "Mkt_Cap", new SortedList () { {new DateTime(2011,01,16),100}, {new DateTime(2011,01,17),101}, {new DateTime(2011,01,18),103}, {new DateTime(2011,01,19),104} } }, { "Liquidity_Rank", new SortedList () { {new DateTime(2011,01,16),4}, {new DateTime(2011,01,17),1}, {new DateTime(2011,01,18),2}, {new DateTime(2011,01,19),3} } } } }); // set minimum liquidty rank int MinLiqRank = 2; // Initial query to get a sequence of { Symbol, Date, Mkt_Cap } entries that meet minimum liquidty rank. var entries = from securityPair in ds.securities from valuation_liq in securityPair.Value.timeSeries["Liquidity_Rank"] from valuation_MC in securityPair.Value.timeSeries["Mkt_Cap"] where (valuation_liq.Key == valuation_MC.Key) && (valuation_liq.Value >= MinLiqRank) select new { Symbol = securityPair.Key, Date = valuation_liq.Key, MktCap = valuation_MC.Value }; // Now group by date var groupedByDate = from entry in entries group entry by entry.Date into date select date.OrderByDescending(x => x.MktCap) .ThenBy(x => x.Symbol) .Select(x => new { x.Symbol, x.MktCap, x.Date }); // final results should populate the following Dictionary of symbols and their respective Z-score time series var zScoreResult = new Dictionary >(); // Calculate the Z-scores for each day bool useSampleStdDev = true; var results = new List (); foreach (var sec in groupedByDate) { // calculate the average value for the date double total = 0; foreach (var secRank in sec) total += secRank.MktCap; double avg = total/ sec.Count(); // calculate the standard deviation double SumOfSquaredDev = 0; foreach (var secRank in sec) SumOfSquaredDev += ((secRank.MktCap - avg) * (secRank.MktCap - avg)); double stdDev; if (useSampleStdDev) // sample standard deviation stdDev = Math.Sqrt(SumOfSquaredDev / (sec.Count() - 1)); else // population standard deviation stdDev = Math.Sqrt(SumOfSquaredDev / sec.Count()); Console.WriteLine("{0} AvgMktCap {1}, StdDev {2}", sec.First().Date, Math.Round(avg,2), Math.Round(stdDev,2)); // calculate the Z-score double zScore; foreach (var secRank in sec) { zScore = ((secRank.MktCap - avg) / stdDev); results.Add(new { Symbol = secRank.Symbol, Date = sec.First().Date, zScore = zScore }); Console.WriteLine(" {0} MktCap {1} Z-Score {2}", secRank.Symbol, secRank.MktCap, Math.Round(zScore, 2)); } } } class Datasource { public string Name { get; set; } public Dictionary securities = new Dictionary (); } class Security { public string symbol { get; set; } public Dictionary > timeSeries; } } } Any assistance would be greatly appreciated.
