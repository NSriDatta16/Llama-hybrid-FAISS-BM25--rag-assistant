[site]: stackoverflow
[post_id]: 5439750
[parent_id]: 5439042
[tags]: 
I have approached this problem in several ways, including with WebClient and just with BitmapImage. EDIT: Original suggestion was to use the BitmapImage(Uri, RequestCachePolicy) constructor, but I realized my project where I tested this method was only using local files, not web. Changing guidance to use my other tested web technique. You should run the download and decoding on a background thread because during loading, whether synchronous or after download the image, there is a small but significant time required to decode the image. If you are loading many images, this can cause the UI thread to stall. (There are a few other intricacies here like DelayCreation but they don't apply to your question.) There are a couple ways to load an image, but I've found for loading from the web in a BackgroundWorker, you'll need to download the data yourself using WebClient or a similar class. Note that BitmapImage internally uses a WebClient, plus it has a lot of error handling and settings of credentials and other things that we'd have to figure out for different situations. I'm providing this snippet but it has only been tested in a limited number of situations. If you are dealing with proxies, credentials, or other scenarios you'll have to massage this a bit. BackgroundWorker worker = new BackgroundWorker(); worker.DoWork += (s, e) => { Uri uri = e.Argument as Uri; using (WebClient webClient = new WebClient()) { webClient.Proxy = null; //avoids dynamic proxy discovery delay webClient.CachePolicy = new RequestCachePolicy(RequestCacheLevel.Default); try { byte[] imageBytes = null; imageBytes = webClient.DownloadData(uri); if (imageBytes == null) { e.Result = null; return; } MemoryStream imageStream = new MemoryStream(imageBytes); BitmapImage image = new BitmapImage(); image.BeginInit(); image.StreamSource = imageStream; image.CacheOption = BitmapCacheOption.OnLoad; image.EndInit(); image.Freeze(); imageStream.Close(); e.Result = image; } catch (WebException ex) { //do something to report the exception e.Result = ex; } } }; worker.RunWorkerCompleted += (s, e) => { BitmapImage bitmapImage = e.Result as BitmapImage; if (bitmapImage != null) { myImage.Source = bitmapImage; } worker.Dispose(); }; worker.RunWorkerAsync(imageUri); I tested this in a simple project and it works fine. I'm not 100% about whether it is hitting the cache, but from what I could tell from MSDN, other forum questions, and Reflectoring into PresentationCore it should be hitting the cache. WebClient wraps WebRequest, which wraps HTTPWebRequest, and so on, and the cache settings are passed down each layer. The BitmapImage BeginInit/EndInit pair ensures that you can set the settings you need at the same time and then during EndInit it executes. If you need to set any other properties, you should use the empty constructor and write out the BeginInit/EndInit pair like above, setting what you need before calling EndInit. I typically also set this option, which forces it to load the image into memory during EndInit: image.CacheOption = BitmapCacheOption.OnLoad; This will trade off possible higher memory usage for better runtime performance. If you do this, then the BitmapImage will be loaded synchronously within EndInit, unless the BitmapImage requires async downloading from a URL. Further notes: BitmapImage will async download if the UriSource is an absolute Uri and is an http or https scheme. You can tell whether it is downloading by checking the BitmapImage.IsDownloading property after EndInit. There are DownloadCompleted, DownloadFailed, and DownloadProgress events, but you have to be extra tricky to get them to fire on the background thread. Since BitmapImage only exposes an asynchronous approach, you would have to add a while loop with the WPF equivalent of DoEvents() to keep the thread alive until the download is complete. This thread shows code for DoEvents that works in this snippet: worker.DoWork += (s, e) => { Uri uri = e.Argument as Uri; BitmapImage image = new BitmapImage(); image.BeginInit(); image.UriSource = uri; image.CacheOption = BitmapCacheOption.OnLoad; image.UriCachePolicy = new RequestCachePolicy(RequestCacheLevel.Default); image.EndInit(); while (image.IsDownloading) { DoEvents(); //Method from thread linked above } image.Freeze(); e.Result = image; }; While the above approach works, it has a code smell because of DoEvents(), and it doesn't let you configure the WebClient proxy or other things that might help with better performance. The first example above is recommended over this one.
