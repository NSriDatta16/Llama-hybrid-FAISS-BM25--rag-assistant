[site]: stackoverflow
[post_id]: 5013746
[parent_id]: 5012551
[tags]: 
Basically, whether this works depends on what members your struct has. The in storage class is equivalent to const scope . So, writing void addLine(in Line l) means that l is const. And since const is transitive, all Line l struct members are const , too. The Shape member Line[] lines is however not const . So, you are trying to append a const Line l to something that is not const . Whether this is possible depends on the types of all members of the struct Line l . If all members of line have value (copy) semantics, this appending (which is an assignment) is possible. If any one member has (some) reference semantics (e.g. a pointer gets copied), this appending is no longer possible. Otherwise, you could give a const Line lc into addLines , but would get a non-const member of lines . Through this, you could change the value with reference semantics, changing the value of the original lc indirectly, too, thereby violating the const guarantee, namely the transitivity of const in D. Example: class C { } struct Line { int i; // int* p; // if you uncomment this, addLine fails // C c; // if you uncomment this, addLine fails } struct Shape { Line[] lines; void addLine(in Line l) { lines ~= l; } } void main() { } Edit: BTW, another way to make it work is to change Line[] lines; to const(Line)[] lines; . Than the array contains only const elements, and the appending of a const l in addLine is possible.
