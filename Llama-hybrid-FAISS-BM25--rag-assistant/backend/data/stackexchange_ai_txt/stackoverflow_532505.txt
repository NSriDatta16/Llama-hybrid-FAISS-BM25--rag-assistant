[site]: stackoverflow
[post_id]: 532505
[parent_id]: 531550
[tags]: 
As Squeegy said, all of the above methods you reference return autoreleased objects. The second code example will crash because you are overreleasing the string objects. Squeegy pointed one way of handling this, using NSMutableStrings. I'd recommend that approach. For example, the following rewrite of your method: -(NSString*) unescape:(NSString*)string { NSMutableString *unescapedString = [[NSMutableString alloc] initWithString:string]; [unescapedString replaceOccurrencesOfString:@"&apos;" withString:@"'" options:0 range:NSMakeRange(0, [unescapedString length])]; [unescapedString replaceOccurrencesOfString:@"&amp;" withString:@"&" options:0 range:NSMakeRange(0, [unescapedString length])]; [unescapedString replaceOccurrencesOfString:@"&quot;" withString:@"\"" options:0 range:NSMakeRange(0, [unescapedString length])]; [unescapedString replaceOccurrencesOfString:@"&gt;" withString:@">" options:0 range:NSMakeRange(0, [unescapedString length])]; [unescapedString replaceOccurrencesOfString:@"&lt;" withString:@" only returns an autoreleased NSMutableString at the end. Even better would be if you passed in a pointer to an NSMutableString pointer (NSMutableString **). That way, you could modify the string that you'd created outside of your method without creating a new temporary string. If this seems strange, take a look at methods that deal with NSError instances as an example. EDIT: Ignore my statement about needing a double pointer in the previous paragraph. As erikprice points out, you just need to pass in an NSMutableString pointer. The double pointer is only needed if you create a new NSMutableString instance in your method to replace the one being passed in, which is not the case here.
