[site]: stackoverflow
[post_id]: 2535875
[parent_id]: 2535835
[tags]: 
You can create an explicit conversion from Foo within Foo . class Program { static void Main() { Foo foo = new Foo(); foo.Name = "Blah"; Foo newfoo = (Foo )foo; Console.WriteLine(newfoo.Name); Console.Read(); } } class Foo { public string Name { get; set; } public object Data { get; set; } } class Foo { public string Name { get; set; } public T Data { get; set; } public static explicit operator Foo (Foo foo) { Foo newfoo = new Foo (); newfoo.Name = foo.Name; return newfoo; } } Edit: This only works without inheritance. It appears you are not able to do a user-defined conversion from a base to a derived class. See comments from Mads Torgersen here http://social.msdn.microsoft.com/forums/en-US/csharplanguage/thread/14cf27cf-b185-43d6-90db-734d2ca3c8d4/ : We have taken the liberty of predefining conversions (casts) between base classes and derived classes, and to make the semantics of the language predictable we don't allow you to mess with it . It looks like you may be stuck with defining a method to turn a Foo into a Foo . That, or drop the inheritance. Neither solution sounds particularly ideal.
