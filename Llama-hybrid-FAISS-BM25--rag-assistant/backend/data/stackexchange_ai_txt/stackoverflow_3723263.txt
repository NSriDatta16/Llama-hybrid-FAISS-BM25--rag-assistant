[site]: stackoverflow
[post_id]: 3723263
[parent_id]: 3722709
[tags]: 
Some terminology is certainly needed. In your code the tokens Code and ListObject are both "data types" and are in one name space. A second concept is "Constructors", commands used to construct a particular instance of a data type. Constructors live in a separate name space - in your code these include the tokens Code_A , Code_B , Code_C and Code , Int . Here's your confusion. You think you've said you want a data type called ListObject which contains data types of either Code or Int . When instead you've defined ListObject with two Null (zero content) constructors called Code and Int . Now we get to the solution, which Robert jumped to in his answer: data ListObject = CodeObject Code | IntObject Int Notice the syntax: data [DataTypeName] = [ConstructorName] [Component Data Type 1] | ... Working out the above code in English, we have a data type ListObject with two constructors ( CodeObject and IntObject ), each constructor takes a single data type ( Code and Int respectively) to create an instance of the ListObject type. Stop here if you understand! Some people have an easier time (and some a harder time) with using function type signatures for constructors. The above ListObject using such notation looks like: data ListObject where CodeObject :: Code -> ListObject IntObject :: Int -> ListObject This makes it clear that CodeObject is some sort of function accepting Code and returning a ListObject . Similar story with IntObject
