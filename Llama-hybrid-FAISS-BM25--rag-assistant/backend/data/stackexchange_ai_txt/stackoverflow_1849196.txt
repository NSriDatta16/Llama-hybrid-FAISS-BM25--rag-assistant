[site]: stackoverflow
[post_id]: 1849196
[parent_id]: 1119914
[tags]: 
I suggest starting by asking yourself: what does it mean to be a first-class continuation? The continuation of an expression essentially consists of two pieces of data: first, the closure (i.e., environment) of that expression; and second, a representation of what should be done with the result of the expression. A language with first-class continuations, then, is one which has data structures encapsulating these parts, and which treats these data structures just as it would any other. call/cc is a particularly elegant way to realise this idea: the current continuation is packaged up as a procedure which encapsulates what-is-to-be-done-with-the-expression as what the procedure does when applied to the expression; to represent the continuation this way simply means that the closure of this procedure contains the environment at the site it was invoked. You could imagine realising the idea of first-class continuations in other ways. They wouldn't be call/cc, and it's hard for me to imagine how such a representation could be simpler. On a parting note, consider the implementation of let/cc that Eli mentioned, which I prefer to call bind/cc: (define-syntax bind/cc (syntax-rules () ((bind/cc var . body) (call/cc (lambda (var) . body))))) And as an exercise, how would you implement call/cc based on bind/cc?
