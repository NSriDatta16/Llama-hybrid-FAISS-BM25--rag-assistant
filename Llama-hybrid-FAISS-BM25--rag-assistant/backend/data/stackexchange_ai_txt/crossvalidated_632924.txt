[site]: crossvalidated
[post_id]: 632924
[parent_id]: 
[tags]: 
Understanding clustering using oblique decision tree

I would like to understand the following post with regards to the code below. https://www.kaggle.com/competitions/optiver-realized-volatility-prediction/discussion/276137#1559582 Initially, Principal Component Analysis (PCA) of a feature array (e.g. returns) with dimensions [ time ids x stock ids ] is carried out. There are 112 stocks. The output is another array c which contains the PCs. This array has dimensions [ stock ids x principal components ]. All 112 principal components are selected. c is the transpose of the output from the PCA function in sklearn. p = otree_clusters(c, depth=3) # c has shape [112 x 112] def get_cut(X): y = X X = np.hstack((X, np.ones((X.shape[0], 1)))) y2 = np.sum(y**2, axis=1, keepdims=True)/2 y = np.hstack((y, y2, 0*y+1, y2 + 1)) yX = np.matmul(y.T, X) minkowski = -np.ones((y.shape[1],1)) minkowski[-1,0] = +1.0 A = np.matmul(yX.T, minkowski*yX) Ao = np.expand_dims(A[:-1,-1],1) Aoo = A[-1,-1] A = A[:-1,:-1] - np.matmul(Ao, Ao.T)/Aoo lam, v = sp.linalg.eigh(A, eigvals=(0,0)) v = np.vstack((v, -np.dot(Ao[:,0],v)/Aoo)) c = np.matmul(X, v) > 0.0 return c[:,0] def otree_clusters(X, max_depth): sets = np.zeros((X.shape[0])).astype(int) for k in range(max_depth): new_sets = 0*sets for kk in range(np.max(sets)+1): b = sets==kk Xs = X[b, :] #x[features x components] c = get_cut(Xs) new_sets[b] = 2*sets[b] + c sets = new_sets return sets Basically, I want to understand how the otree_clusters() function calculates p. I believe p is some cutoff value to group clusters of stocks? The input to this function is c. In get_cut(X) function What is the point of augementing the matrix y with ones and sum of squares etc. y = np.hstack((y, y2, 0*y+1, y2 + 1)) yX = np.matmul(y.T, X) Similarly, what is find the the eigenvalues have to do with solving the following optimization? I would like to understand what is happening inside this function and how this is linked to $min(v, b)[ \sum_{ij} [ || y_i - y_j ||^2 * ( x_i . v + b ) * ( x_j . v + b ) ] ] $ Thanks.
