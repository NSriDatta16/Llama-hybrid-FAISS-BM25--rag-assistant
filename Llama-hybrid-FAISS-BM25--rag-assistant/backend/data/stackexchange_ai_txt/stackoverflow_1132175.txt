[site]: stackoverflow
[post_id]: 1132175
[parent_id]: 
[tags]: 
Custom sorting, always force 0 to back of ascending order?

Premise This problem has a known solution (shown below actually), I'm just wondering if anyone has a more elegant algorithm or any other ideas/suggestions on how to make this more readable, efficient, or robust. Background I have a list of sports competitions that I need to sort in an array. Due to the nature of this array's population, 95% of the time the list will be pre sorted, so I use an improved bubble sort algorithm to sort it (since it approaches O(n) with nearly sorted lists). The bubble sort has a helper function called CompareCompetitions that compares two competitions and returns >0 if comp1 is greater, The priority field is the trick to this problem. It is an int that holds a positve value or 0. They are sorted with 1 being first, 2 being second, and so on with the exception that 0 or invalid values are always last. e.g. the list of priorities 0, 0, 0, 2, 3, 1, 3, 0 would be sorted as 1, 2, 3, 3, 0, 0, 0, 0 The other little quirk, and this is important to the question, is that 95% of the time, priority will be it's default 0, because it is only changed if the user wants to manually change the sort order, which is rarely. So the most frequent case in the compare function is that priorities are equal and 0. The Code This is my existing compare algorithm. int CompareCompetitions(const SWI_COMPETITION &comp1,const SWI_COMPETITION &comp2) { if(comp1.nPriority == comp2.nPriority) { //Priorities equal //Compare start time int ret = comp1.sStartTime24Hrs.CompareNoCase(comp2.sStartTime24Hrs); if(ret != 0) { return ret; //return compare result }else { //Equal so far //Compare Home team Name ret = comp1.sHLongName.CompareNoCase(comp2.sHLongName); return ret;//Home team name is last field to sort by, return that value } } else if(comp1.nPriority > comp2.nPriority) { if(comp2.nPriority Question How can this algorithm be improved? And more importantly... Is there a better way to force 0 to the back of the sort order? I want to emphasize that this code seems to work just fine, but I am wondering if there is a more elegant or efficient algorithm that anyone can suggest. Remember that nPriority will almost always be 0, and the competitions will usually sort by start time or home team name, but priority must always override the other two.
