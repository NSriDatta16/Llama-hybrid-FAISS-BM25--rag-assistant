[site]: stackoverflow
[post_id]: 2897266
[parent_id]: 
[tags]: 
header confusion. Compiler not recognizing datatypes

I am getting confused on why the compiler is not recognizing my classes. So I am just going to show you my code and let you guys decide. My error is this error C2653: 'RenderEngine' : is not a class or namespace name and it's pointing to this line std::vector m_verts; Here is the code for rModel, in its entirety. It contains the varible. the class that holds it is further down. #ifndef _MODEL_H #define _MODEL_H #include "stdafx.h" #include #include //#include "RenderEngine.h" #include "rTri.h" class rModel { public: typedef tri sTri; std::vector m_tris; std::vector m_verts; std::wstring m_name; ID3D10Buffer *m_pVertexBuffer; ID3D10Buffer *m_pIndexBuffer; rModel( const TCHAR *filename ); rModel( const TCHAR *name, int nVerts, int nTris ); ~rModel(); float GenRadius(); void Scale( float amt ); void Draw(); //------------------------------------ Access functions. int NumVerts(){ return m_verts.size(); } int NumTris(){ return m_tris.size(); } const TCHAR *Name(){ return m_name.c_str(); } RenderEngine::cDefaultVertex *VertData(){ return &m_verts[0]; } sTri *TriData(){ return &m_tris[0]; } }; #endif at the very top of the code there is a header file #include "stdafx.h" that includes this // stdafx.h : include file for standard system include files, // or project specific include files that are used frequently, but // are changed infrequently // #include "targetver.h" #define WIN32_LEAN_AND_MEAN // Exclude rarely-used stuff from Windows headers // Windows Header Files: #include // C RunTime Header Files #include #include #include #include #include "resource.h" #include "d3d10.h" #include "d3dx10.h" #include "dinput.h" #include "RenderEngine.h" #include "rModel.h" // TODO: reference additional headers your program requires here as you can see, RenderEngine.h comes before rModel.h #include "RenderEngine.h" #include "rModel.h" According to my knowledge, it should recognize it. But on the other hand, I am not really that great with organizing headers. Here my my RenderEngine Declaration. #pragma once #include "stdafx.h" #define MAX_LOADSTRING 100 #define MAX_LIGHTS 10 class RenderEngine { public: class rDefaultVertex { public: D3DXVECTOR3 m_vPosition; D3DXVECTOR3 m_vNormal; D3DXCOLOR m_vColor; D3DXVECTOR2 m_TexCoords; }; class rLight { public: rLight() { } D3DXCOLOR m_vColor; D3DXVECTOR3 m_vDirection; }; static HINSTANCE m_hInst; HWND m_hWnd; int m_nCmdShow; TCHAR m_szTitle[MAX_LOADSTRING]; // The title bar text TCHAR m_szWindowClass[MAX_LOADSTRING]; // the main window class name void DrawTextString(int x, int y, D3DXCOLOR color, const TCHAR *strOutput); //static functions static LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); static INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam); bool InitWindow(); bool InitDirectX(); bool InitInstance(); int Run(); void ShutDown(); void AddLight(D3DCOLOR color, D3DXVECTOR3 pos); RenderEngine() { m_screenRect.right = 800; m_screenRect.bottom = 600; m_iNumLights = 0; } protected: RECT m_screenRect; //direct3d Members ID3D10Device *m_pDevice; // The IDirect3DDevice10 // interface ID3D10Texture2D *m_pBackBuffer; // Pointer to the back buffer ID3D10RenderTargetView *m_pRenderTargetView; // Pointer to render target view IDXGISwapChain *m_pSwapChain; // Pointer to the swap chain RECT m_rcScreenRect; // The dimensions of the screen ID3D10Texture2D *m_pDepthStencilBuffer; ID3D10DepthStencilState *m_pDepthStencilState; ID3D10DepthStencilView *m_pDepthStencilView; //transformation matrixs system D3DXMATRIX m_mtxWorld; D3DXMATRIX m_mtxView; D3DXMATRIX m_mtxProj; //pointers to shaders matrix varibles ID3D10EffectMatrixVariable* m_pmtxWorldVar; ID3D10EffectMatrixVariable* m_pmtxViewVar; ID3D10EffectMatrixVariable* m_pmtxProjVar; //Application Lights rLight m_aLights[MAX_LIGHTS]; // Light array int m_iNumLights; // Number of active lights //light pointers from shader ID3D10EffectVectorVariable* m_pLightDirVar; ID3D10EffectVectorVariable* m_pLightColorVar; ID3D10EffectVectorVariable* m_pNumLightsVar; //Effect members ID3D10Effect *m_pDefaultEffect; ID3D10EffectTechnique *m_pDefaultTechnique; ID3D10InputLayout* m_pDefaultInputLayout; ID3DX10Font *m_pFont; // The font used for rendering text // Sprites used to hold font characters ID3DX10Sprite *m_pFontSprite; ATOM RegisterEngineClass(); void DoFrame(float); bool LoadEffects(); void UpdateMatrices(); void UpdateLights(); }; The classes are defined within the class class rDefaultVertex { public: D3DXVECTOR3 m_vPosition; D3DXVECTOR3 m_vNormal; D3DXCOLOR m_vColor; D3DXVECTOR2 m_TexCoords; }; class rLight { public: rLight() { } D3DXCOLOR m_vColor; D3DXVECTOR3 m_vDirection; }; Not sure if thats good practice, but I am just going by the book. In the end, I just need a good way to organize it so that rModel recognizes RenderEngine. and if possible, the other way around. [edit] I can literally just point to the render engine class, and it still won't recognize #ifndef _MODEL_H #define _MODEL_H //#include "stdafx.h" #include #include #include "RenderEngine.h" // sTri; std::vector m_tris; std::vector m_verts; std::wstring m_name; ID3D10Buffer *m_pVertexBuffer; ID3D10Buffer *m_pIndexBuffer; rModel( const TCHAR *filename ); rModel( const TCHAR *name, int nVerts, int nTris ); ~rModel(); float GenRadius(); void Scale( float amt ); void Draw(); //------------------------------------ Access functions. int NumVerts(){ return m_verts.size(); } int NumTris(){ return m_tris.size(); } const TCHAR *Name(){ return m_name.c_str(); } RenderEngine::cDefaultVertex *VertData(){ return &m_verts[0]; } sTri *TriData(){ return &m_tris[0]; } }; #endif
