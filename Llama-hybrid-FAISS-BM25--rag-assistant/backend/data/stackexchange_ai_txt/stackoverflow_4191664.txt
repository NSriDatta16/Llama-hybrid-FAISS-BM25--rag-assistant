[site]: stackoverflow
[post_id]: 4191664
[parent_id]: 4191624
[tags]: 
There's no clean way to solve this problem. It has no elegant solution within the bounds of the standard language. One thing you can do is to provide a global or static variable that will serve as this pointer for the intermediate callback wrapper function (see below), and write a static intermediate callback wrapper function which will delecate the call to a non-static class method class myclass { ... static myclass *myclass_this; double callback_wrapper(double d) { assert(myclass_this != NULL); return myclass_this->callback(d); // calls the actual implementation } }; Also write the actual callback implementation in myclass class myclass { ... double callback(double d) { // do whatever you want with `a`, `b` etc. return /* whatever */; } ... }; Now you can initialize myclass_this and use the intermediate callback wrapper from inside mymethod ... void mymethod(...) { myclass_this = this; // initilize the context legacy_function(&callback_wrapper); } ... All this, of course, is terribly inelegant since it relies on global or static variables and therefore is non-reentrant. There are alternative methods, which all happen to be non-portable and non-standard. (Read about closures and delegates ).
