[site]: stackoverflow
[post_id]: 759663
[parent_id]: 
[tags]: 
Pointer Arithmetic In C

Consider the following code fragment: int (*p)[3]; int (*q)[3]; q = p; q++; printf("%d, %d\n", q, p); printf("%d\n", q-p); I know that pointer arithmetic is intelligent, meaning that the operation q++ advances q enough bytes ahead to point to a next 3-integers-array, so it does not surprises me that the first print is ' 12, 0 ' which means that incrementing q made it larger in 12. But the second print does surprises me. It prints 1! So why would it print 1 instead of 12? it just puzzles me.
