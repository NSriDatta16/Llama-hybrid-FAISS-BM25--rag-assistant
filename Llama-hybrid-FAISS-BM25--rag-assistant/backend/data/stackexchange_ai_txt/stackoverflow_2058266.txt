[site]: stackoverflow
[post_id]: 2058266
[parent_id]: 2057946
[tags]: 
You need a compatible string type: typedef std::basic_string tstring; is a good choice. For input only arguments, you can use the .c_str() method. For buffers, the choice is slightly less clear: std::basic_string is not guaranteed to use contiguous storage like std::vector is. However, all std::basic_string implementations I've seen do use contiguous storage, and the C++ standards committee consider the missing guarantee to be a defect in the standard. The defect has been corrected in the C++0x draft. If you're willing to bend the rules ever so slightly - with no negative consequences - you can use &(*aString.begin()) as a pointer to a TCHAR buffer of length aString.size(). Otherwise, you're stuck with std::vector for now. Here's what the C++ standard committee have to say about contiguous string storage: Not standardizing this existing practice does not give implementors more freedom. We thought it might a decade ago. But the vendors have spoken both with their implementations, and with their voice at the LWG meetings. The implementations are going to be contiguous no matter what the standard says. So the standard might as well give string clients more design choices.
