[site]: stackoverflow
[post_id]: 4247700
[parent_id]: 
[tags]: 
Image Stabilization

Hey, I'm doing a project to stabilize video sequence by using optical flow method. I have done well the optical flow so far. But I have 2 branches in front of me to work on it.. 1- after getting the optical flow, I have found the average of the image displacement and then I have subtracted the average from the features of the second frame, my question is what to do next? 2- Or I could use the openCV function in order stabilize image, which I calculated the transformation Matrix and then I used cvPerspectiveTransform then cvWarpPerspective, but I'm getting error which is "bad flag" you can see the code, what I want is what to do to stabilize the image? I wanna any solution you can provide? enter code here #include #include //#include "/usr/include/opencv/cv.h" #include #include #include #include #include #define PI 3.1415926535898 double rads(double degs) { return (PI/180 * degs); } CvCapture *cap; IplImage *img; IplImage *frame; IplImage *frame1; IplImage *frame3; IplImage *frame2; IplImage *temp_image1; IplImage *temp_image2; IplImage *frame1_1C; IplImage *frame2_1C; IplImage *eig_image; IplImage *temp_image; IplImage *pyramid1 = NULL; IplImage *pyramid2 = NULL; char * mapx; char * mapy; int h; int corner_count; CvMat* M = cvCreateMat(3,3,CV_32FC1); CvPoint p,q,l,s; double hypotenuse; double angle; int line_thickness = 1, line_valid = 1, pos = 0; CvScalar line_color; CvScalar target_color[4] = { // in BGR order {{ 0, 0, 255, 0 }}, // red {{ 0, 255, 0, 0 }}, // green {{ 255, 0, 0, 0 }}, // blue {{ 0, 255, 255, 0 }} // yellow }; inline static double square(int a) { return a * a; } char* IntToChar(int num){return NULL;} /*{ char* retstr = static_cast (calloc(12, sizeof(char))); if (sprintf(retstr, "%i", num) > 0) { return retstr; } else { return NULL; } }*/ inline static void allocateOnDemand( IplImage **img, CvSize size, int depth, int channels ) { if ( *img != NULL ) return; *img = cvCreateImage( size, depth, channels ); if ( *img == NULL ) { fprintf(stderr, "Error: Couldn't allocate image. Out of memory?\n"); exit(-1); } } void clearImage (IplImage *img) { for (int i=0; i imageSize; i++) img->imageData[i] = (char) 0; } int main() { cap = cvCaptureFromCAM(0); //cap = cvCaptureFromAVI("/home/saif/Desktop/NAO.. the project/jj/Test3.avi"); CvSize frame_size; // Reading the video's frame size frame_size.height = (int) cvGetCaptureProperty( cap, CV_CAP_PROP_FRAME_HEIGHT ); frame_size.width = (int) cvGetCaptureProperty( cap, CV_CAP_PROP_FRAME_WIDTH ); cvNamedWindow("Optical Flow", CV_WINDOW_AUTOSIZE); while(true) { frame = cvQueryFrame( cap ); if (frame == NULL) { fprintf(stderr, "Error: Hmm. The end came sooner than we thought.\n"); return -1; } // Allocating another image if it is not allocated already. allocateOnDemand( &frame1_1C, frame_size, IPL_DEPTH_8U, 1 ); cvConvertImage(frame, frame1_1C, 0); allocateOnDemand( &frame1, frame_size, IPL_DEPTH_8U, 3 ); cvConvertImage(frame, frame1, 0); //Get the second frame of video. frame = cvQueryFrame( cap ); if (frame == NULL) { fprintf(stderr, "Error: Hmm. The end came sooner than we thought.\n"); return -1; } if(!frame) { printf("bad video \n"); exit(0); } allocateOnDemand( &frame2_1C, frame_size, IPL_DEPTH_8U, 1 ); cvConvertImage(frame, frame2_1C, 0); allocateOnDemand( &frame2, frame_size, IPL_DEPTH_8U, 3 ); cvConvertImage(frame, frame2, 0); CvSize optical_flow_window = cvSize(5,5); eig_image = cvCreateImage( frame_size, IPL_DEPTH_32F, 1 ); temp_image = cvCreateImage( frame_size, IPL_DEPTH_32F, 1 ); CvTermCriteria optical_flow_termination_criteria = cvTermCriteria( CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 20, .3 ); // Feature tracking CvPoint2D32f frame1_features[4]; CvPoint2D32f frame2_features[4]; //cvCornerEigenValsAndVecs(eig_image, temp_image, 1 ); corner_count = 4; cvGoodFeaturesToTrack(frame1_1C,eig_image , temp_image, frame1_features, &corner_count, 0.1, .01, NULL, 5, 1); cvFindCornerSubPix( frame1_1C, frame1_features, corner_count,cvSize(5, 5) ,optical_flow_window , optical_flow_termination_criteria); if ( corner_count
