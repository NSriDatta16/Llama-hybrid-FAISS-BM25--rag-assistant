[site]: stackoverflow
[post_id]: 4869937
[parent_id]: 4869860
[tags]: 
Normally, the standard input of a daemon should be connected to /dev/null , so that if anything is read from standard input, you get an EOF immediately. Normally, standard output should be connected to a file - either a log file or /dev/null . The latter means all writes will succeed, but no information will be stored. Similarly, standard error should be connected to /dev/null or to a log file. All programs, including daemons, are entitled to assume that stdin, stdout and stderr are appropriately opened file streams. It is usually appropriate for a daemon to control where its input comes from and outputs go to. There is seldom occasion for input to come from other than /dev/null . If the code was written to survive without standard output or standard error (for example, it opens a standard log channel, or perhaps uses syslog(3) ) then it may be appropriate to close stdout and stderr. Otherwise, it is probably appropriate to redirect them to /dev/null , while still logging messages to a log file. Alternatively, you can redirect both stdout and stderr to a log file - beware continuously growing log files. Your sluggish-to-impossible response time might be because your program is not paying attention to EOF in a read loop somewhere. It might be prompting for user input on /dev/null, and reading a response from /dev/null, and not getting a 'y' or 'n' back, it tries again, which chews up your system horribly. Of course, the code is flawed in not handling EOF, and counting the number of times it gets an invalid response and stopping being silly after a reasonable number of attempts (16, 32, 64). The program should shut up shop sanely and safely if it expects a meaningful input and continues not to get it.
