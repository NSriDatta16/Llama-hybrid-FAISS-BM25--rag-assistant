[site]: stackoverflow
[post_id]: 3623220
[parent_id]: 3587940
[tags]: 
This was my final solution. Please note that this is a hack that gets SQLite to reformat the date on retrieval. A better solution would be to store the date and retrieve it on its own. Have fields for retrieval keys: public static final String KEY_TIMESTAMP = "timestamp"; public static final String KEY_DATESTAMP = "strftime('%d/%m/%Y'," + KEY_TIMESTAMP +")"; Store the timestamp like normal in the database entry: String timeStamp = new Timestamp( Calendar.getInstance().getTimeInMillis() ).toString(); ContentValues initialValues = new ContentValues(); ... initialValues.put(KEY_TIMESTAMP, timeStamp); return mDb.insert(DATABASE_TABLE, null, initialValues); Where mDb is an SQLiteDatabase object. When retrieving the timestamp in yyyy-MM-dd HH:mm:ss.SSS format, use the regular KEY_TIMESTAMP . The following method retrieves a row with both items in there. Use the appropriate key for retrieval. public Cursor fetchItem(long rowId) throws SQLException { Cursor cursor = mDb.query(true, DATABASE_TABLE, new String[] {KEY_ITEMID,KEY_TIMESTAMP,KEY_DATESTAMP}, KEY_ITEMID + "=" + rowId, null, null, null, null, null ); return cursor; } Use the appropriate key for retrieval mTimestamp = quote.getString( quote.getColumnIndex(QuotesDbAdapter.KEY_TIMESTAMP))); mDatestamp = quote.getString( quote.getColumnIndex(QuotesDbAdapter.KEY_DATESTAMP)));
