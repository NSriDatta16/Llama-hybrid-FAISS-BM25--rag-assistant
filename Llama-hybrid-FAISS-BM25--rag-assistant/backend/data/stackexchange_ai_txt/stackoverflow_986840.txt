[site]: stackoverflow
[post_id]: 986840
[parent_id]: 986543
[tags]: 
After tinkering with the StringTokenizer class, I could not find a way to satisfy the requirements to return ["dog", "", "cat"] . Furthermore, the StringTokenizer class is left only for compatibility reasons, and the use of String.split is encouaged. From the API Specification for the StringTokenizer : StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the split method of String or the java.util.regex package instead. Since the issue is the supposedly poor performance of the String.split method, we need to find an alternative. Note: I am saying "supposedly poor performance" because it's hard to determine that every use case is going to result in the StringTokenizer being superior to the String.split method. Furthermore, in many cases, unless the tokenization of the strings are indeed the bottleneck of the application determined by proper profiling, I feel that it will end up being a premature optimization, if anything. I would be inclined to say write code that is meaningful and easy to understand before venturing on optimization. Now, from the current requirements, probably rolling our own tokenizer wouldn't be too difficult. Roll our own tokenzier! The following is a simple tokenizer I wrote. I should note that there are no speed optimizations, nor is there error-checks to prevent going past the end of the string -- this is a quick-and-dirty implementation: class MyTokenizer implements Iterable , Iterator { String delim = ","; String s; int curIndex = 0; int nextIndex = 0; boolean nextIsLastToken = false; public MyTokenizer(String s, String delim) { this.s = s; this.delim = delim; } public Iterator iterator() { return this; } public boolean hasNext() { nextIndex = s.indexOf(delim, curIndex); if (nextIsLastToken) return false; if (nextIndex == -1) nextIsLastToken = true; return true; } public String next() { if (nextIndex == -1) nextIndex = s.length(); String token = s.substring(curIndex, nextIndex); curIndex = nextIndex + 1; return token; } public void remove() { throw new UnsupportedOperationException(); } } The MyTokenizer will take a String to tokenize and a String as a delimiter, and use the String.indexOf method to perform the search for delimiters. Tokens are produced by the String.substring method. I would suspect there could be some performance improvements by working on the string at the char[] level rather than at the String level. But I'll leave that up as an exercise to the reader. The class also implements Iterable and Iterator in order to take advantage of the for-each loop construct that was introduced in Java 5. StringTokenizer is an Enumerator , and does not support the for-each construct. Is it any faster? In order to find out if this is any faster, I wrote a program to compare speeds in the following four methods: Use of StringTokenizer . Use of the new MyTokenizer . Use of String.split . Use of precompiled regular expression by Pattern.compile . In the four methods, the string "dog,,cat" was separated into tokens. Although the StringTokenizer is included in the comparison, it should be noted that it will not return the desired result of ["dog", "", "cat] . The tokenizing was repeated for a total of 1 million times to give take enough time to notice the difference in the methods. The code used for the simple benchmark was the following: long st = System.currentTimeMillis(); for (int i = 0; i The Results The tests were run using Java SE 6 (build 1.6.0_12-b04), and results were the following: Run 1 Run 2 Run 3 Run 4 Run 5 ----- ----- ----- ----- ----- StringTokenizer 172 188 187 172 172 MyTokenizer 234 234 235 234 235 String.split 1172 1156 1171 1172 1156 Pattern.compile 906 891 891 907 906 So, as can be seen from the limited testing and only five runs, the StringTokenizer did in fact come out the fastest, but the MyTokenizer came in as a close 2nd. Then, String.split was the slowest, and the precompiled regular expression was slightly faster than the split method. As with any little benchmark, it probably isn't very representative of real-life conditions, so the results should be taken with a grain (or a mound) of salt.
