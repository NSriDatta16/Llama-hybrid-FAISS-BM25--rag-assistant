[site]: stackoverflow
[post_id]: 4457420
[parent_id]: 4457119
[tags]: 
No need for recursion here. It's a fixed size. Just iterate. Recursion is more useful when you're dealing with trees or variable-sized operations. In this case, you know the size is fixed ahead of time. Don't stick that 5 in the middle of a method body. If you change the card game (i.e. the business rules , in douche-speak), what then? By sticking the hand size in a static variable, you can now inherit this class and redeclare the hand size, but everything still works as intended. Note that this maintains the rule that all hands are of equal size, which may not be a very good rule , e.g. if you play a game that involves dealing the entire deck out to all players and you have 5 players, such that not all players have the same size hand. You don't actually need to create a count object. Since you're just filling an array, you already have the count; it's the size of the array. Get rid of that entirely and just use the count() function. It's good that you understand that an assignment expression evaluates to the assigned value, but don't try to write slick code. It's hard to read. "Elegance" for vanity; clarity for sanity. The "public" keyword in that return statement doesn't make any sense. Nor does the function keyword. You're not returning the function when you recurse, you're calling it. The "do" keyword is evil and stupid and should be avoided when possible. Use a "do" when you want to ensure that the body of your loops is always executed at minimum one time, regardless of the evaluation of your predicate. Under every other circumstance, cut that do doo-doo out. write it like this: _pokerHand) _pokerHand)) { array_push($this->_pokerHand, $card); } } } public function showHand() { print_r($this->_pokerHand); } } $hand = new pokerHand(); $hand->showHand(); ?> I could easily have truncated that a litte bit so that the while loop looks like so: while(count($this->_pokerHand) _pokerHand)) array_push($this->_pokerHand, $card); But really. Look at that thing. So hard to look at. You go back to that in a month and you'll sit there figuring out what it does; executing the program in your head. Just put more code in there. People get all wound up about "elegance" when in reality all they're doing is wanking off to how short they can write a program. Meanwhile the Lisp community is laughing their dicks off because everything every other language does can be done in a single amazing Lisp macro that only takes three lines to express but is impossible for 99% of coders to comprehend. But I digress. The point is that "elegance" is often misunderstood as meaning requiring less typing for the programmer , when in reality elegance in code is the marriage of efficiency and clarity; not a measure of code shortness. Writing code for other coders is like the programming equivalent of playing jazz. A million chords and only three people in the audience. How awesome. Pop musicians are successful because they appeal to animal instincts. Programmers are successful when they help a hungry person find a cheeseburger. So code for users; not for coders. Anyway, I hate it when people get on their soap box and don't just answer the question that was asked, so you can write it recursively like this, but it's stupid: _pokerHand) >= self::$handsize) return $this; if(!in_array($card = rand(1, 52), $this->_pokerHand)) $this->_pokerHand[] = $card; return $this->__construct(); } public function showHand() { print_r($this->_pokerHand); } } $hand = new pokerHand(); $hand->showHand(); ?> When you're writing a recursive function, the first statement you should write is the statement that gets you out of the recursion. In this case, it's return $this;. That was absent from your solution. This is the first time I've ever written a recursive constructor. I didn't even know you could do that.
