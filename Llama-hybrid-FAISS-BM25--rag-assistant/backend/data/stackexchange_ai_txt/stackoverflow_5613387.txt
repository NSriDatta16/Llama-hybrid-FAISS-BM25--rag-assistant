[site]: stackoverflow
[post_id]: 5613387
[parent_id]: 5611465
[tags]: 
As Jakub noted, asynchronous event handling is one of the nice bits of JavaScript. I'd suggest rethinking your application flow to support this rather than trying to serialize it. Moreover, you aren't promised that the order in which the events fire is the order in which you expect them to fire. Dragging in multiple bookmarks could generate events in arbitrary order. If you really need to ensure that your program handles things in the order they come in, and only processes one item at a time, you could split your logic into two parts: the eventHandler itself could be a function that populates a queue of events that you need to deal with in some way, and you could have another function that runs in a timeout-driven loop, checking the queue, pulling an item off, and processing it. Something like the following (untested) code: function SerializedEventHandler() { chrome.bookmarks.onCreated.addListener(this.enqueue.bind(this)); } SerializedEventHandler.prototype = { queue_: [], timer_: null, enqueue: function (e) { this.queue_.push(e); this.startProcessing(); }, startProcessing: function () { if (!this.timer_) this.timer_ = setTimeout(this.process.bind(this), 100); }, process: function () { if (this.queue_.length) { var item = this.queue_.shift(); // do something with `item` this.timer_ = clearTimeout(this.timer_); this.startProcessing(); } } }; Does that make sense?
