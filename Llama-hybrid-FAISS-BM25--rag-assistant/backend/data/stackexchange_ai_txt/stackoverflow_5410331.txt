[site]: stackoverflow
[post_id]: 5410331
[parent_id]: 5410173
[tags]: 
It's a Cartesian product of Cartesian products: var groups = from x in (from v in values from s in states select new {v,s}) group x by x.v into gx select gx; var perms = from a in groups[0] from b in groups[1] from c in groups[2] select new {a,b,c}; The groups query produces a Lookup (conceptually a read-only Dictionary of IEnumerables) containing the simple Cartesian product of all values and states (6 elements), grouped by their value. Then, the second query produces a Cartesian product of the elements of the Cartesian product taken three at a time, one from each group in the Lookup. To make this work with an unknown number of dimensions would be tricky; if you don't absolutely have to make it work that way I would avoid it. I think the most elegant way would be to define a set of extension methods for the System.Tuple generic classes: public static Tuple Append(this Tuple tuple, T2 addend) { return Tuple.Create(tuple.Item1, addend); } public static Tuple Append(this Tuple tuple, T3 addend) { return Tuple.Create(tuple.Item1, tuple.Item2, addend); } ... Then, you can take these helpers and use them in a looped version of the second query: var perms = from a in groups[0] select Tuple.Create(a); foreach(var group in groups.Skip(1)) perms = from a in perms from b in group select a.Append(b); This will produce an enumerable of Tuples of the required length, containing the elements of the anonymous type produced in the first query (which can be refactored to produce strongly-typed 2-item Tuples if you wish). You may have an issue with using the perms collection variable to refer to collections of ever-growing Tuples; this is the tricky part.
