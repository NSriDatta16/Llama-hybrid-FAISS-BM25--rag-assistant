[site]: stackoverflow
[post_id]: 5507751
[parent_id]: 5507715
[tags]: 
There's no "special rule" for register used in conjunction with void * , register will work on void * as with any variable, suggesting to the compiler that such variable will be heavily used and that it should be put into a CPU register. Still, in general there's no reason to use register anywhere, since optimizers included in current compilers are much better than programmers at guessing what variables should be put into registers, and almost always will happily ignore the register keyword completely. The C99 standard also provides some additional details about register (§6.7.1 ¶4): A declaration of an identifier for an object with storage-class specifier register suggests that access to the object be as fast as possible. The extent to which such suggestions are effective is implementation-defined. 101) 101) The implementation may treat any register declaration simply as an auto declaration. However, whether or not addressable storage is actually used, the address of any part of an object declared with storage-class specifier register cannot be computed, either explicitly (by use of the unary & operator as discussed in 6.5.3.2) or implicitly (by converting an array name to a pointer as discussed in 6.3.2.1). Thus, the only operator that can be applied to an array declared with storage-class specifier register is sizeof . So using register you most probably get only the downsides of pretending having a variable in a register. :) Notice that the C++ standard relaxes these restrictions, but obviously if you try to take the address of a register variable it won't stay in a register anymore. Long story short, register is there mostly as a relic of the past, avoiding it is the best use you can do of it. :)
