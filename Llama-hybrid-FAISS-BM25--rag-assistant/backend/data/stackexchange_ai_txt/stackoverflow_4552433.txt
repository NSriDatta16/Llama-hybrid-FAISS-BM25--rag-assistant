[site]: stackoverflow
[post_id]: 4552433
[parent_id]: 2711456
[tags]: 
You have here a parallel for loop, but the scheduling is unspecified. #pragma omp parallel for private(i) for(i = 2; i There are some scheduling types defined in OpenMP 3.0 standard. They can be changed by setting OMP_SCHEDULE environment variable to type[,chunk] where type is one of static , dynamic , guided , or auto chunk is an optional positive integer that specifies the chunk size Another way of changing schedule kind is calling openmp function omp_set_schedule The is_prime function can be rather fast. /I suggest/ prime[i-2] = is_prime(i); So, the problem can came from wrong scheduling mode, when a little number is executed before barrier from scheduling. And the printf have 2 parts inside it /I consider glibc as popular Linux libc implementation/ Parse the format string and put all parameters into buffer Write buffer to file descriptor (to FILE buffer, as stdout is buffered by glibc by default) The first part of printf can be done in parallel, but second part is a critical section and it is locked with _IO_flockfile .
