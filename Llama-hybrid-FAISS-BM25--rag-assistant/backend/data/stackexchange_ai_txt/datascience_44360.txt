[site]: datascience
[post_id]: 44360
[parent_id]: 
[tags]: 
predict future value in every one hour using (t+60 minutes) LSTM neural network in python

I have a data csv file including with three inputs and two output with time series. Here data took an every one hour one hour. So I need to predict my next future value at t+60 according to the previous input value and at that time period if having new input value using regression neural network. So I choose LSTM neural network to predict next future value. But I don't know how to give time period to predict my future value. Can anyone suggest me how to solve this problem? Can anyone give me any examples to clear out this problem? Here that prediction value will come as input value (g). subset of my csv file here I upload my code; def create_data(data, look_back=1): dataX, dataY = [], [] for i in range(len(data) - look_back - 1): a = data[i:(i + look_back), :] dataX.append(a) dataY.append(data[i + look_back, 2]) return numpy.array(dataX), numpy.array(dataY) data = pd.DataFrame(data,columns=['g','p','c']) numpy.random.seed(7) data = data.values scaler = MinMaxScaler(feature_range=(0, 1)) data = scaler.fit_transform(data) train_size = int(len(data) * 0.67) test_size = len(data) - train_size train, test = data[0:train_size, :], data[train_size:len(data), :] # reshape into X=t and Y=t+1 look_back = 3 trainX, trainY = create_data(train, look_back) testX, testY = create_data(test, look_back) # reshape input to be [samples, time steps, features] trainX = numpy.reshape(trainX, (trainX.shape[0], look_back, 3)) testX = numpy.reshape(testX, (testX.shape[0],look_back, 3)) model = Sequential() model.add(LSTM(6, input_shape=(look_back,3))) model.add(Dense(1)) model.compile(loss='mean_squared_error', optimizer='adam') history= model.fit(trainX, trainY,validation_split=0.33, nb_epoch=10, batch_size=30) trainPredict = model.predict(trainX) testPredict = model.predict(testX) trainPredict_extended = numpy.zeros((len(trainPredict),3)) trainPredict_extended[:,2] = trainPredict[:,0] trainPredict = scaler.inverse_transform(trainPredict_extended) [:,2] print(trainPredict) testPredict_extended = numpy.zeros((len(testPredict),3)) testPredict_extended[:,2] = testPredict[:,0] testPredict = scaler.inverse_transform(testPredict_extended)[:,2] trainY_extended = numpy.zeros((len(trainY),3)) trainY_extended[:,2]=trainY trainY=scaler.inverse_transform(trainY_extended)[:,2] testY_extended = numpy.zeros((len(testY),3)) testY_extended[:,2]=testY testY=scaler.inverse_transform(testY_extended)[:,2] trainScore = math.sqrt(mean_squared_error(trainY, trainPredict)) print('Train Score: %.2f RMSE' % (trainScore)) testScore = math.sqrt(mean_squared_error(testY, testPredict)) print('Test Score: %.2f RMSE' % (testScore)) # shift train predictions for plotting trainPredictPlot = numpy.empty_like(data) trainPredictPlot[:, :] = numpy.nan trainPredictPlot[look_back:len(trainPredict)+look_back, 2] = trainPredict # shift test predictions for plotting testPredictPlot = numpy.empty_like(data) testPredictPlot[:, :] = numpy.nan testPredictPlot[len(trainPredict)+(look_back*2)+1:len(data)-1, 2] = testPredict
