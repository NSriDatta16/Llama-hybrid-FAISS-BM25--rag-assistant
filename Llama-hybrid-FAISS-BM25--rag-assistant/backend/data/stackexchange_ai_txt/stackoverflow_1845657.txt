[site]: stackoverflow
[post_id]: 1845657
[parent_id]: 1838461
[tags]: 
Don't extend Repository : A database is not a repository, a repository has a database Your database/session/config aren't related and shouldn't be. Liskov substitution principle : [...] if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program (e.g., correctness). Edit: trying to answer follow-up questions in this reply. This technique is called dependency injection. A session example: class Session { // notice the clean API since no methods are carried along from a possibly huge base class public function __construct(ISessionStorage $storage) { $this->_storage = $storage; } public function set($key, $value) { $this->_storage->set($key, $value); } } interface ISessionStorage { public function set($key, $value); } class DatabaseSessionStorage implements ISessionStorage { public function __construct(Db $db) { $this->_db = $db } public function set($key, $value) { $this->_db->query("insert...."); } } class CookieSessionStorage implements ISessionStorage { public function set($key, $value) { $_SESSION[$key] = $value; } } // example where it's easy to track down which object went where (no strings used to identify objects) $session = new Session(new DatabaseSessionStorage(new Db())); $session->set('user', 12512); // or, if you'd prefer the factory pattern. Note that this would require some modification to Session $session = Session::factory('database'); $session->set('user', 12512); Sure you could store connection settings hardcoded in a config-file. This only means the other files need to get hold of that config class without going through their parents. For example: class Database { // The same pattern could be used as with the sessions to provide multiple database backends (mysql, mssql etc) through this "public" Database class public function __construct(Config $config) { $this->_config = $config; $this->_connect(); } private function _connect() { $this->_config->getDatabaseCredentials(); // do something, for example mysql_connect() and mysql_select_db() } } If you'd prefer to keep config information out of php-files (for easier editing/reading), see the Zend_Config -classes for examples of accessing different storage devices including the more common ones: ini, php array, xml. (I'm only mentioning Zend_Config since I've used it and am satisfied, parse_ini_file would do as well.) A good & hopefully easy read: Fabience Potencier - What is dependency injection? Edit #2: Also see the slide: Matthew Weier O'Phinney - Architecting your models
