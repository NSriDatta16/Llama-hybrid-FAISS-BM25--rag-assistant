[site]: stackoverflow
[post_id]: 416570
[parent_id]: 416432
[tags]: 
Hibernate (or any JPA solution) is the wrong tool for this job. JPA/Hibernate isn't a lightweight solution. In high-volume applications, the overhead is not only significant but prohibitive. You really need to look into grid and cluster solutions . I won't repeat the overview of the various technologies here. I've got a lot of experience in financial market information systems. A few of the things you said stuck out to me: You have a lot of raw data; You want to apply various aggregations to that data (eg open/high/low/close daily summaries); High availability is probably an issue (it always is in these kinds of systems); and Low latency is probably an issue (ditto). Now for grid/cluster type solutions I divide them loosely into two categories: Map-based solutions like Coherence or Terracotta; and Javaspaces-based solutions like GigaSpaces. I've used Coherence a lot and the Map solution can be nice but it can be problematic too. Coherence maps can have listeners on them and you can use this sort of thing to do things like: Market price alerts (users may want a notification when a price reaches a certain level); Derivative pricing (eg an exchange-traded option pricing system will want to reprice when an underlying security changes last traded price); A trade-matching/booking system may want to match received trade notifications for reconciliation purposes; etc. All of these can be done with listeners but in Coherence for example listeners have to be cheap, which leads to things like a Map having a listener than writes something to another Map and this can chain on for awhile. Also, modifying the cache entry can be problematic (although there are mechanisms for dealing with that kind of problem too; I'm talking about situations like turning off a market price alert so it doesn't trigger a second time). I found GigaSpaces type grid solutions to be far more compelling for this kind of application. The read (or destructive read) operation is a highly elegant and scalable solution and you can get transactional grid updates with sub-millisecond performance. Consider the two classic queueing architectures: Request/Response: a bad message can block the queue and while you can many senders and receivers (for scalability) scaling up the number of pipes isn't always straightforward; and Publish/Subscribe: this decouples the sender and receiver but lacks scalability in that if you have multiple subscribers they'll each receive the message (not necessarily what you want with say a booking system). In GigaSpaces, a destructive read is like a scalable publish-subscribe system and a read operation is like the traditional publish-subscribe model. There is a Map and JMS implementation built on top of the grid and it can do FIFO ordering. Now whaqt about persistence I hear you ask? Persistence is a consequence of deciding all the other stuff. For this kind of application, I like the Persistence as a Service model (ironically written about Hibernate but it applies to anything). Basically this means your date store hits are asynchronous and it works nicely with doing summary data. Like you can have a service listening for trade notifications and persist just the ones it's interested in (aggregating in memory if required). You can do open/high/low/close prices this way. For high volume data you don't really want to write it all to the database. Not synchronously anyway. A persistent store plus a data warehouse is probably more the route you want to go but again this depends on requirements, volumes, etc. It's a complicated topic and I've only really touche don it. Hope that helps you.
