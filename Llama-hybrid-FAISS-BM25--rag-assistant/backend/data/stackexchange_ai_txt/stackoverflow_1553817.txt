[site]: stackoverflow
[post_id]: 1553817
[parent_id]: 
[tags]: 
C++ Read from shared memory

I want to read status information that an application provides via shared memory. I want to use C++ in order to read the content of that named shared memory and then call it with pinvoke from a C#-class. From the software I know that it has a certain file structure: A struct STATUS_DATA with an array of four structs of SYSTEM_CHARACTERISTICS . I'm not (yet) familiar with C++, so I tried to follow msdn basically. To find the size of the file to be mapped, I added the sizes of the struct members as to be seen in the code below. This results in a ACCESS DENIED, so I figured, that the result based on the structs is too high. When I use sizeof(STATUS_DATA) (I added the struct to my source), it still ends up in an ACCESS DENIED. If I try something lower, like 1024 Bytes, only thing I can see in pbuf is a , while debugging. This is what I got so far: #include #include #include #include #include #pragma comment(lib, "user32.lib") using namespace std; signed int BUF_SIZE = 4 * (10368 + 16 + 4 + 16 + 4 + 16 + 4 + 1 + 4); // sizeof(STATUS_DATA); TCHAR szName[]=TEXT("ENGINE_STATUS"); int main() { HANDLE hMapFile; unsigned char* pBuf; hMapFile = OpenFileMapping( FILE_MAP_READ, // read access FALSE, // do not inherit the name szName); // name of mapping object if (hMapFile == NULL) { _tprintf(TEXT("Could not open file mapping object (%d).\n"), GetLastError()); return 1; } pBuf = (unsigned char*) MapViewOfFile(hMapFile, // handle to map object FILE_MAP_READ, // read/write permission 0, 0, BUF_SIZE); // 1024); if (pBuf == NULL) { _tprintf(TEXT("Could not map view of file (%d).\n"), GetLastError()); CloseHandle(hMapFile); return 1; } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; } I also made sure that this Shared Mem "is there" by following that hint . Can somebody give me a hint, what I'm missing? Thanks!
