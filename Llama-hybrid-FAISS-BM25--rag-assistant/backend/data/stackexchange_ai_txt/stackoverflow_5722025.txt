[site]: stackoverflow
[post_id]: 5722025
[parent_id]: 5721894
[tags]: 
Not sure if I completely understand you but yes you can create a container class that provides static methods. It may be worthwhile to make the constructors private to prevent people from instantiation an instance of the class. class HelperFunctions { public: static void DoSomethingUseful() { /* useful bits */ } // yata yata private: HelperFunctions(); // private default constructor HelperFunctions(const HelperFunctions&); // private copy constructor }; Then you could do something like this: HelperFunctions::DoSomethingUseful(); But you couldn't do something like this: HelperFunctions myHelperFunction; // private constructor = compile error You also could create namespaces for the purpose of organization non-member functions. namespace HelperFunctions { void DoSomethingUseful() { /* useful bits */ } // yata yata } Remember you can define namespaces across multiple files as well making these particular useful for grouping objects and functions wherever they may be. This is preferable as it logically separates the functions making the design and intended use more obvious Unlike Java where everything is a method in C++ we can have functions at a global, namespace, or member scope. You also can have non-member friend functions which can access internal members of a class without being a member of the class themselves. Basically you can do whatever you want including shoot yourself in the foot. Edit: Why so serious? I wasn't suggesting what the OP should or shouldn't do. It seemed as though they were new to C++ coming from the Java world where everything is a method and all "functions" are class members. To that affect my answer was to show how firstly you can create something in C++ similar to what you might have in Java and secondly how you can do other things as well and why that is. As others have stated it's considered good practice to prefer non-member non-friend functions when possible for various reasons. I agree if you do not need an object with state than you probably shouldn't design one. However I'm not sure if the OP was looking for a philosophical discussion on best practice in design and implementation or just a curiosity for equivalent C++. I had hoped my last line joking about shooting yourself in the foot was enough to make the point that "just because you can, doesn't mean you should" but perhaps not with this crowd.
