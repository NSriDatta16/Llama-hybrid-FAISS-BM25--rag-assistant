[site]: crossvalidated
[post_id]: 496352
[parent_id]: 493731
[tags]: 
Note: This answer is wrong/incomplete and will need an update according to the comments Y̶o̶u̶ ̶c̶a̶n̶ ̶a̶p̶p̶r̶o̶a̶c̶h̶ ̶t̶h̶e̶ ̶f̶u̶n̶c̶t̶i̶o̶n̶ ̶b̶u̶t̶ ̶n̶o̶t̶ ̶g̶e̶t̶ ̶e̶q̶u̶a̶l̶ Suppose we are given a coin with arbitrary (unknown) head probability $p$ , I am wondering if there is an easy-to-implement algorithm for generating a $\min\{p, 0.5\}$ coin for any $p\in [0,1]$ . Function $f(p) = \min\{p, 0.5\} \geq \min\{p, 1-p\}$ so the famous paper by Keane and O’Brien guarantees such an algorithm exists W̶e̶ ̶s̶h̶o̶u̶l̶d̶ ̶b̶e̶ ̶m̶o̶r̶e̶ ̶n̶u̶a̶n̶c̶e̶d̶.̶ ̶T̶h̶e̶r̶e̶ ̶i̶s̶ ̶ ̶n̶o̶ ̶ ̶s̶u̶c̶h̶ ̶a̶l̶g̶o̶r̶i̶t̶h̶m̶ ̶t̶h̶a̶t̶ ̶a̶l̶l̶o̶w̶s̶ ̶y̶o̶u̶ ̶t̶o̶ ̶g̶e̶n̶e̶r̶a̶t̶e̶ ̶a̶ $min\lbrace 0,0.5 \rbrace$ c̶o̶i̶n̶.̶ ̶W̶h̶a̶t̶ ̶K̶e̶a̶n̶e̶ ̶a̶n̶d̶ ̶O̶'̶B̶r̶i̶e̶n̶ ̶s̶t̶a̶t̶s̶ ̶i̶s̶ ̶t̶h̶a̶t̶ ̶y̶o̶u̶ ̶c̶a̶n̶ ̶ ̶a̶p̶p̶r̶o̶a̶c̶h̶ ̶ ̶t̶h̶e̶ ̶d̶e̶s̶i̶r̶e̶d̶ ̶f̶u̶n̶c̶t̶i̶o̶n̶ ̶a̶s̶ ̶c̶l̶o̶s̶e̶ ̶a̶s̶ ̶y̶o̶u̶ ̶l̶i̶k̶e̶.̶ Intuitive example We can generalize the method from Luis Mendo to get a procedure which allows you to generate a Bernoulli variable with probability $f(p)$ given a Bernoulli variable with probability $p$ . The steps are as following: Use $m$ coin flips to estimate $\hat p$ , the bias of the coin. Based on the bias of the coin, use $n$ unbiased coin flips (for which you can use John von Neumann's algorithm ) to generate a coin with approximately $\hat{f}(\hat{p})$ probability. In the computational example below the $\hat{f}(\hat{p})$ is equal to one of the quantiles of a Bernoulli variable with size $n$ and probability $0.5$ By increasing $m$ you can make $\hat p$ get closer to the true value $p$ . By increasing $n$ you can make $\hat{f}(\hat p)$ , get closer to ${f}(\hat p)$ . In the end we can make $\hat{f}(\hat p)$ as close to ${f}(p)$ as we like by increasing $m$ and $n$ . The code below demonstrates this construction for some function $f(p) = \frac{1}{2} + \frac{1}{2} \sin(4\pi p)$ with a simulation. We see that with $m = n = 1000$ you get to the following approximation: ### estimate p by **tossing m coins** and use average number of 1's estimate_p Trick for a more efficient example The above example is simple and helps to see intuititively how an algorithm can approach as close as we like. However, we could try to see how to make a faster method. The trick is that we can tabulate the results like toss probability HH p² HT p(1-p) TH (1-p)p TT (1-p)² then select a few of the tosses that create a desirable ratio. For instance in the case of John von Neumann's trick ( generating a fair coin out of a biased coin ) we could decide 'heads' if we observe HT with the unfair coin 'tails' if we observe TH with the unfair coin 'toss again' if we did not observe either. (Yes, this approach throws away results which is not efficient. There's a lot of ways to improve, and complicate, the strategies to solve these kind of problems). Then the ratio's of heads and tails is $\frac{p(1-p)}{(1-p)p} = 1$ so you get the fair coin independent of $p$ . Generalizing the trick What we will try to do now is find out the best combination of events for tails and heads given $n$ coin flips to get a ratio like $$\frac{a_1 p^n + a_2 p^{n-1}(1-p) + \dots + a_n (1-p)^n }{b_1 p^n + b_2 p^{n-1}(1-p) + \dots + b_n (1-p)^n}$$ that approximates our desired function the best. (the coefficients $a_i$ and $b_i$ will need to be integers and are bounded by binomial coefficients) The r-code below computes the optimal for 3 coin tosses (I am computing just 3 tosses because the least-squares problem with integer constraints is for the moment computed in a dumb way) We will be selecting 'heads' for HHT and HTT and 'tails' for HTH and TTT which will give an odds ratio of $$\frac{p^2(1-p)+p(1-p)^2}{p^2(1-p)+(1-p)^3}=\frac{p}{1-2p+2p^2}$$ ### function in numerator and denominator simulated $message != "OK") { int1$value = 10^6 } if (int2$ message != "OK") { int2 $value = 10^6 } return(int1$ value+int2$value) } ### compute best option for 3 tosses ### by just trying every option choose(3,0:3) RSS = 10^6 solution = c(0,0,0,0,0,0,0,0) for (a1 in 0:1) { for (a2 in 0:3) { for (a3 in 0:3) { for (a4 in 0:1) { for (b1 in 0:(1-a1)) { for (b2 in 0:(3-a2)) { for (b3 in 0:(3-a3)) { for (b4 in 0:(1-a4)) { if ((a1+a2+a3+a4+b1+b2+b3+b4)>0) { test_RSS
