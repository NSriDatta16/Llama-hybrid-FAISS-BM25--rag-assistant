[site]: stackoverflow
[post_id]: 291797
[parent_id]: 288513
[tags]: 
It looks like the language supplies date/day methods for a given date. If anybody was interested you can read about Zeller's congruence . I don't think that's what they wanted you to do but you could find the day of week of the first day of a month from that. Now that I thought about it you could find the day of week for the given day as N and get that modulo 7. Oh wait, is that the Nth occurance of a day of the week (like Sunday) or like the Nth weekday of the month! Okay I see the examples. Maybe it would make a difference if you could construct a date such as the 1st of a month.. Given that it is Nth occurance of a day of the week , and that you can't fiddle with whatever datetime datatype, and that you have access to both a get day of week and get day of month functions. Would Sunday be a zero? 1) First, the day of the week would have to match the day of the week given. 2) N would have to be at least 1 and at most 4. 3) The day of the month would range between n*7*dayOfWeek + 1 and n*7*dayOfWeek + 6 for the same n. - Let me think about that. If Sunday was the first.. 0*7*0+1 = 1 and Saturday the 6th would be 0*7*0+6. Think 1 and 3 above are sufficient since a get day of month function shouldn't violate 2. (* first try, this code sucks *) function isNthGivenDayInMonth(date : dateTime; dow : dayOfWeek; N : integer) : boolean; var B, A : integer (* on or before and after day of month *) var Day : integer (* day of month *) begin B := (N-1)*7 + 1; A := (N-1)*7 + 6; D := getDayOfMonth(date); if (dow <> getDayOfWeek(date) then return(false) else return( (B = Day) ); end; (* function *) Hope there isn't a bug in that lol! [edit: Saturday would have been the 7th, and the upper bound above (N-1)*7 + 7 .] Your solution looks like it would match 2 different weeks? Looks like it would always return zero for Sundays? Should have done pseudocode in C#.. short circuit && is like my if.. hey shouldn't Sunday the first match for N = 1 in months that start on Sunday? d/ 7 == n That would result in (either 0 or 1)/7 == 1 , that can't be right! Your || catches the (n-1) also, Robert has that. Go with Robert Wagner's answer! It's only 2 lines, short is good! Having (Day-1) mod 7 [edit: (Day-1) div 7 ] eliminates my unnecessary variables and 2 lines of setup. For the record this should be checked for boundary cases and so forth like what if August 31st was a Sunday or Saturday. [edit: Should have checked the end of week case too. Sorry!]
