[site]: stackoverflow
[post_id]: 3789407
[parent_id]: 3788853
[tags]: 
As to why people find them so fascinating, I think because they're such a simple idea. The recent discussion on Haskell-cafe about a denotational semantics for iteratees devolved into a consensus that they're so simple they're barely worth describing. The phrase "little more than a glorified left-fold with a pause button" sticks out to me from that thread. People who like Haskell tend to be fond of simple, elegant structures, so the iteratee idea is likely very appealing. For me, the chief benefits of iteratees are Composability. Not only can iteratees be composed, but enumerators can too. This is very powerful. Safe resource usage. Resources (memory and handles mostly) cannot escape their local scope. Compare to strict I/O, where it's easier to create space leaks by not cleaning up. Efficient. Iteratees can be highly efficient; competitive with or better than both lazy I/O and strict I/O. I have found that iteratees provide the greatest benefits when working with single logical data that comes from multiple sources. This is when the composability is most helpful, and resource management with strict I/O most annoying (e.g. nested alloca s or bracket s). For an example, in a work-in-progress audio editor, a single logical chunk of sound data is a set of offsets into multiple audio files. I can process that single chunk of sound by doing something like this (from memory, but I think this is right): enumSound :: MonadIO m => Sound -> Enumerator s m a enumSound snd = foldr (>=>) enumEof . map enumFile $ sndFiles snd This seems clear, concise, and elegant to me, much more so than the equivalent strict I/O. Iteratees are also powerful enough to incorporate any processing I want to do, including writing output, so I find this very nice. If I used lazy I/O I could get something as elegant, but the extra care to make sure resources are consumed and GC'd would outweigh the advantages IMO. I also like that you need to explicitly retain data in iteratees, which avoids the notorious mean xs = sum xs / length xs space leak. Of course, I don't use iteratees for everything. As an alternative I really like the with* idiom, but when you have multiple resources that need to be nested that gets complex very quickly.
