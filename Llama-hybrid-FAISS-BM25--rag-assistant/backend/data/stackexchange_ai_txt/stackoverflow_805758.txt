[site]: stackoverflow
[post_id]: 805758
[parent_id]: 805462
[tags]: 
The key thing to realize is that your stylesheet dictates the name of each element you add to the result tree. An element's name has two parts: the local name and the namespace URI. In your code above, you supply the local name (the value of $xmlElem ), but you don't specify a namespace URI, which means it will default to the empty string. (Actually, it takes on the default namespace of that stylesheet module; since there is none, then it's the empty string.) In other words, the element will be not in a namespace . When serializing the document, the XSLT processor must include the xmlns="" un-declarations so as to undeclare the default namespace that appears at the top. Otherwise, the element would take on that namespace, which is not what your stylesheet dictated. The least intrusive way of fixing this would be to add another parameter (e.g. $namespaceURI ), just as you have with $xmlElem . Then you'd write: Now, the resulting element will take on whatever namespace you tell it to take on (which will have the effect of removing those default namespace un-declarations). That should answer your question. I offer the following as free bonus material. ;-) You should remove the text() node test in your value comparison. Very rarely will you need to directly compare the values of text nodes. Instead, you can just compare the string-value of the element itself (which is defined as the concatenation of the string-values of all its descendant text nodes). That would look like this: The advantage of doing it this way is that your code won't break if there's a comment hiding in there: 2 00 In this case, there are two text nodes ("2" and "00"). Your original test would fail, since it checks to see if any of them are equal to "200". Not very likely to happen in this case, but in any case testing the string-value of the element (as opposed to its text node children) is a good practice when that's your intention. Finally, I encourage you to learn about template rules and XPath context. I tend to avoid , , and whenever possible. For one thing, template rules can help you avoid a lot of the ugly, verbose parts of XSLT. ... ... Even if you keep using , you shouldn't have to pass that $structure parameter, as the current node will remain unchanged in the called template. You can access //databean (or /databean , which I suspect is what you mean) just as easily from within either of your StructureA or StructureB templates, because the current node will still be "/" (the document node). If you're interested in learning more about XSLT's core processing model, and its most powerful features (template rules), then I encourage you to check out "How XSLT Works" , the free sample chapter from my XSLT 1.0 Pocket Reference . I hope this has been helpful to you, even if it's more than you bargained for!
