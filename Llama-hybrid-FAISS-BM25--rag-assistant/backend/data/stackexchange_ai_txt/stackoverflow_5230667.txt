[site]: stackoverflow
[post_id]: 5230667
[parent_id]: 5224807
[tags]: 
If you want phone-calls 24/7, then you should go for the RegEx-thing and let the user freely enter some cryptography in a TEdit. If you want happy users and a good night sleep, then be creative and drop the boring RegEx-approach. Create your own filename-decoder by using an Angry bird approach. Here's the idea: Create some birds with different string manipulation personalities. Let the user select and arrange these birds. Execute the user generated string manipulation. Sample code: program AngryBirdFilenameDecoder; {$APPTYPE CONSOLE} uses SysUtils; procedure PerformEatUntilDash(var aStr: String); begin if Pos('-', aStr) > 0 then Delete(aStr, 1, Pos('-', aStr)); WriteLn(':-{ > ' + aStr); end; procedure PerformEatUntilUnderscore(var aStr: String); begin if Pos('_', aStr) > 0 then Delete(aStr, 1, Pos('_', aStr)); WriteLn(':-/ > ' + aStr); end; function FetchDate(var aStr: String): String; begin Result := Copy(aStr, 1, 10); Delete(aStr, 1, 10); WriteLn(':-) > ' + aStr); end; var i: Integer; FileName: String; TempFileName: String; SelectedBirds: String; MyDate: String; begin Write('Enter a filename to decode (eg. ''01-ThisIsAText-Img_01-Date_2011-03-08.png''): '); ReadLn(FileName); if FileName = '' then FileName := '01-ThisIsAText-Img_01-Date_2011-03-08.png'; repeat TempFileName := FileName; WriteLn('Now, select some birds:'); WriteLn('Bird No.1 :-{ ==> I''ll eat letters until I find a dash (-)'); WriteLn('Bird No.2 :-/ ==> I''ll eat letters until I find a underscore (_)'); WriteLn('Bird No.3 :-) ==> I''ll remember the date before I eat it'); WriteLn; Write('Chose your birds: (eg. 112123):'); ReadLn(SelectedBirds); if SelectedBirds = '' then SelectedBirds := '112123'; for i := 1 to Length(SelectedBirds) do case SelectedBirds[i] of '1': PerformEatUntilDash(TempFileName); '2': PerformEatUntilUnderscore(TempFileName); '3': MyDate := FetchDate(TempFileName); end; WriteLn('Bird No.3 found this date: ' + MyDate); WriteLn; WriteLn; Write('Check filename with some other birds? (Y/N): '); ReadLn(SelectedBirds); until (Length(SelectedBirds)=0) or (Uppercase(SelectedBirds[1])<>'Y'); end. When you'll do this in Delphi with GUI, you'll add more birds and more checking of course. And find some nice bird glyphs. Use two list boxes. One one the left with all possible birds, and one on the right with all the selected birds. Drag'n'drop birds from left to right. Rearrange (and remove) birds in the list on the right. The user should be able to test the setup by entering a filename and see the result of the process. Internally you store the script by using enumerators etc.
