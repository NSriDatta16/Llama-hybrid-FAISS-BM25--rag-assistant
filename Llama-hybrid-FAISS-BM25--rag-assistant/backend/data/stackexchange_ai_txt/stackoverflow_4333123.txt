[site]: stackoverflow
[post_id]: 4333123
[parent_id]: 
[tags]: 
Why does ostream_iterator need to explicitly declare the type of objects to output?

In current C++, the class ostream_iterator was designed like the following: // excerpted from the standard C++ template class ostream_iterator { public: ostream_iterator(ostream_type&); ... ostream_iterator & operator =(const T&); ... }; To me, this design is suboptimal. Because the user must specify the type T when declaring an ostream_iterator like this: ostream_iterator oi(cout); In fact, cout can take any type of object as its argument, rather than only one type. This is an obvious restriction. // Below is my own version // doesn't need any template parameter here class ostream_iterator { public: ostream_iterator(ostream_type&); ... // define a template member function which can take any type of argument and output it template ostream_iterator & operator =(const T&); ... }; Now, we can use it as follows: ostream_iterator oi(cout); I think it is more generic and more elegant than ostream_iterator oi(cout); Am I right?
