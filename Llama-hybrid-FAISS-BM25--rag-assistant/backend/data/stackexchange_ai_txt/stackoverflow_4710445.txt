[site]: stackoverflow
[post_id]: 4710445
[parent_id]: 4689098
[tags]: 
Context Good question, but a big question. First some context, the specific major failures, and then the specific answers. Scroll down to UML * Gross Failures if you would like to skip the Context UML is just the new kid on the block. Yeah sure, not so new as Agile; but new in comparison to what was available before. It might help to understand something first. We have been using models, modelling techniques, and symbols for 40 years. They are many of them. The most common is not the most appropriate or successful (in the technical and purpose sense); it just happens to be the most advertised and "sold". The second criterion re models is that it is a tool for communication, both between teams (different skill sets), and between teams and users. It gets silly when one team uses one set of symbols and another uses another set, or when the symbols are not meaningful to the user, who has to approve functional definitions, and funds the project. We use standards for building bridges, so that they do not fall over (at least in developed countries); to ensure that the purchaser and the supplier mean the same thing when they draw a symbol for a standard bolt; and we use standards in IT to in the same way. to convey unambiguous meaning for each symbol to be complete (if it is a Data Model, then the relations are not missing) to convey the complexities and subtleties of the design (which non-standard symbols and diagrams cannot). . A word about Standards. The IT industry as deteriorated badly in the last 20 years. We have many unqualified and untrained people doing technical work. So there is a looseness and naïveté that is common in the smaller companies. Even the word standard has been hijacked. People talk loosely about "industry standards": actually there is no such thing, they simply mean whatever is most common in the industry. That is a convention, not a Standard. Standards are set by international standards bodies. Not by a single vendor. Since MS have never complied with Standards, they have created their single-vendor anti-standard, and sought to monopolise the industry in that manner (illegal, which is why the US Justice Dept were able to take them apart quite easily.) MS may be the most common PC or PC application software (Windows is not an OS, even though it passes for one), but it is not standard in any way, shape, or form. Re (4) MS is famous for coming up with at least 20 (that I know of) tools for "modelling" databases, different for each product and version; each with a different set of cute symbols; but none of them are Standard as a counterpoint, SQL is a Standard, identified by IEC/ISO and more recently, ANSI. Sybase, DB2 and MSQL SQL Server comply with the SQL Standard (Oracle doesn't, even though they state that they do) none of the freeware "SQLs" comply with the SQL Standard . One Standard or "standard" for everything ? Ah yes, the MS approach to computers, buy our gear, and you will be happy; if not, you just need to buy more of our gear. It is stupid in the extreme. Each Subject Area in IT has been around for quite a while, a specialised area, requiring specialised qualifications and skills. A good Data Modeller may make a horrible programmer, and vice versa. You do not want a gynaecologist who is good with c-sections performing brain surgery. Therefore, as the Standards bodies have recognised for decades, Standards are specific to a Subject Area further, the Standards are Normalised. That means that a Standard in one Subject Area is integrated with the Standard in any other applicable Subject Area By reference (without duplicating the whole text) This allows each Standard to develop and progress on its own path, whilst maintaining its reference to other Standards Standards are public domain, they are free (you might have to pay a printing price for a copy) . The other reason One "standard" for all Subject Areas will never work, the reason for this gross inadequacy, is of course Maslow's Hammer , (if you bother to click the link, make sure you read the last sentence). To the man who only has a hammer in the toolkit, every problem looks like a nail. The authors of UML, as well as the Fowlers and Amblers of today, use a hammer for all tasks. A "database" is a nail; architecture is a nail. Standards are also not set by groups of vendors or consortia, as they do not have the regulatory control or authority to put their stamp on submissions. Most of such consortia make their own submissions to themselves, there is no transparency or peer review or oversight. UML may be marvellous and rich and all that (to those know nothing else), OMG may be a great consortium, but OMG is not an international Standards body, and the full UML (14 models) is not a Standard. it is supported a consortium it has not been accepted by any international Standards body the portion that has been recognised as a Standard by ISO is the Object Class modelling portion only it exists in it own universe, separate from the rest of the universe they would like you to think it is a full-blown Standard, so they use the word all over the place at the end of the day, it is about selling product much like MS . AFAIK, other than the ObjectClass Modelling portion, UML is not a Standard, there is no ISO/IEC/ANSI/NIST designation for the other portions. There are two reasons for that. Re (6). Several different Modelling Standards, each highly specialised for its Subject Area, existed long before UML was hatched. Instead of extending the existing Standard Modelling techniques, as any qualified technical person would do, the authors created a completely new model. UML, in each of those Subject Areas does not come close to providing the utility of the Standard; does not comply with the Standard requirement; does not identify or convey the full meaning. Example. Given that modelling data and modelling software are quite different sciences, with different rules, and that Databases are designed to be independent of any software that uses it, it is stupid to model a "database" using OO concepts or UML. Which is what OMG would have you do, and states UML can do. Just check the number of identical questions on SO, where OO types are stuck with this exact problem. First, it will not be a Database in any way, shape or form; it will be only a data storage location. You will have none of the power or speed or integrity of a Relational Database. Second, the sequence is backwards. Data does not change; programs do (frequently), so if you model the objects after modelling the data, nothing changes. But if you model the data after the objects, you spend your life incrementally changing both, going backwards and forwards. Third, UML may be good for defining a data location to "persist" data to, but it is completely inadequate for defining the elements of a Relational Database. Since there has been a Standard for Modelling Relational Databases for 30 years, that provides complete difinition, you will be better off using that. Re (7). It tries to do everything. First, due to its inadequacy in the Subject Areas, it does not stand a reasonable chance of displacing the established Standards. Second, it suffers the Jack of all trades, master of none problem. Of course, OMG has 14 different UML models, which can be covered with 2 to 4 Standard models. Using that many different models, for different purposes, has an additional set of problems. to be clear, UML replaces nothing. OO is relatively new. It only supplies OO Modelling for the OO portions of a project. Last, UML is specialised for OO. And nothing but OO. As if the entire Universe was OO and nothing else existed. Even die-hard COBOL programmers aren't this blinkered. This is a very common and sad attitude among OO types who know nothing else about systems and IT, and it is generated by the idiots like Martin Fowler, who write about OO that way. This is the reason OO is limited to small projects, and why OO types fail miserably at anything outside OO, because they are unwilling to learn about any other Subject Area in depth. And why there has been perhaps 30 OO "database" products, over the last 15 years, and why all of them have failed. Example. Fowler will first teach you how to create and implement incomplete classes and "persist" them to a "database". When that does not work, you have to buy the next book to figure out how to correct them, by adding more definition (er, no surprise). When you realise that you are correcting them an awful lot, and the corrections are in fact similar, you have to buy the next book to figure out how to "re-factor" the classes, automate the corrections, make sure they are all applied to the relevant locations at the same time. And each time, you will have to "re-factor" the "database" as well. Good for the OO types who have no other knowledge. For IT professionals who do not "buy" fowling pieces, who have some knowlede and depth outside OO, can produce definitions, so that we do not waste time or money re-defining and re-factoring and re-implementing. We define and build once, then improve as necessary. And we keep our software Normalised, so there is never a need to "re-factor", we just keep extending the classes and methods. Which is only possible if the initial structure had structure. Since we Normalise and Model our Relational Databases, although the apps can keep changing and growing, we never need to "re-factor" the Database . Re-implementing code is expensive enough; the cost of re-implementing large Databases is prohibitive. Professionals are expected to avoid that. The reason it is so popular, is that these days, people have been trained in the MS approach to life (anyone can be a programmer, no qualification required, if only you believe ), and in OO/UML, they see the magic bullet (now with this shiny new hammer, you too, can build anything ). Snake oil salesmen. Don't shoot the marshall, but the truth is, there is no magic bullet, you need more than a hammer to build anything , and you need to put in the hard yards. UML • Gross Failure The main failures of UML as a "standard", are these. This means the specific discrete issues with the diagrams and the "method", not the resulting problems that you will have if you use it (later). One Symbol One rectangle for absolutely anything and everything. With sections that are relevant to the 14 different types of diagrams. Whereas Standards have a different symbol for Data, vs Process, vs GUI, etc. Since there is no fixed set of items that are required to define a thing (14 types of things), each person implements what they think the thing is, or worse, what they know the thing to be, which is very little. One does not know what creature one is looking at, or what the level of completeness is. Too Few Minor Symbols Since it tries to do everything for everyone, and tries to "model" both small and large projects, there are many, many minor symbols. Actually, too many (if you understand what I have stated above), there should be a few minor symbols for each of the 14 types of drawing, and they should be required , otherwise it is not a Standard, it is loose and floppy. Nevertheless, the minor symbols are too few. In normal use, each person invents a few minor symbols of their own, to fill in the gaps in UML symbols. The result is of course, horrendous: each project team has various additional minor symbols that are not in UML, and thus not understood outside the project. The very opposite of the purpose of a Standard. The result overall (not limited to one project team), is too many minor symbols , hundreds of them, some of which mean the same thing, and others which mean slightly (importantly) different things. . I stopped counting at 200. Compared with genuine Standards, the above two points result in a gross lack of Definition in the documentation of objects (things), the very thing that is expected (demanded) from a Standard. It is a total failure at the first criterion of a Standard: *first and foremost, it is a communication tool. On receipt of a UML "model", in order to understand it, one has to set it aside and manually communicate with the author. Last, but the most important ... No Facility for Composition/Decomposition Analysis comes before Design, we need to analyse (as a science) what an application is supposed to do, before we can design (as a science) the program to implement it. (Unfortunately, these days, untrained people throw themselves at the Design phase, clueless that they do not know what the app is, because they have not analysed it. Guaranteed disaster.) Both the Analysis phase and the Design phase demand the ability to look at the Function that the application comprises: at different levels: a. from 10,000 metres: see the whole scope with little detail ... but all interfaces, [zoom out] or b. 1,000 metres, or c. 1 metre: see all detail for a small scope [zoom in] . That means, the ability to break the app into its Functions, first large components, and then again, into smaller components, until the smallest or Atomic components are defined (single Object or Function() or Stored Proc or Subroutine). That affords Analysis , a complete phase of modelling, before achieving confidence to proceed with the next phase ... That affords Design , now the objects and articles can be arranged and organised, Normalised, into a legitimate set of Functions. Normalised code means no function duplication. IDEF0 and SSADM have full Composition - Decomposition. A large app is modelling using a tree structure (which the app is), on many pages, each page showing only what is relevant at that Level . (In addition to that, which cannot be skipped, if it is an OO client, we may have an UML diagram for those Objects only. The result of using UML is, you get none of that . No analysis is possible. Great, for those who do not know that Analysis is a science, that it is the first phase in any serious project. No genuine design is possible. Great, for those who do not know that Design is a science, steps are relevant to the platform, etc. That it is the second phase in any serious project. People go straight into "designing" their OO objects, as if that is the centre of the universe. They even try to control their data integrity via these hilarious creatures. In addition to not being designed, the app ends up being one great big monolith, with massive code duplication. A joke to genuine engineers. Answer First and foremost, make sure you acquire a few tools for your toolkit, and always use the right tool for the job. OO is a fine idea, UML may be a great technique for modelling object classes , but it is completely inadequate for modelling anything else, or for communicating with users. The only users who will be impressed are those who fancy themselves as "technical" and who have not seen any Modelling Standard (ie. they have no point of reference, and are easily impressed). At best, using accurate words, UML is a Standard for modelling Object Classes only and relevant to OO types only (ie. no specialised skills in any other subject Area). As in, I find it does not convey all the control and subtlety of modern object classes and complex Methods, and thus I have to add notations to the UML diagram to make it complete. it is adequate for for small projects, which are to be modelled and implemented by OO types onlly. I do not see much that is "unified", it is more of an anti-standard. It integrates with nothing, except (maybe) another of the 14 UML models. We did not put men on the Moon, or build space shuttles for regular space flight or fighter aircraft, using UML. We did that using the following Standards. Standards are required (demanded ?) by banks and financial institutions (my ambit) and govt depts in developed countries. As per (6), they are all integrated with each other: IDEF1 for Information Modelling IDEF1X for Relational Database Modelling, IDEF0 for Function Modelling SSADM (the Gane & Sarson original, not the volumes created by others) , in particular the Data Flow Diagramsfor Function Modelling. It is good for non-technical users or projects that do not need the high definiton of IDEF0. And sure, for communicating various details, at the relevant stage of the project, wireframes, screenshots, State and Sequence Diagrams. And sure, for Modelling object classes, if that is a substantial task that requires a special modelling technique, use UML or anything else. In large projects, boundaries, a clear separation of skills and responsibilities, is important. We need teams of Master builders. Jacks will not survive. Banks do not spend money to prototype software incrementally, they work to fixed budgets, and suppliers like my firm work to fixed price/fixed delivery contracts. That means definition (not specification these days) before coding. In all my large projects, the OO team used UML within their team only, stuffed around for ages, and never published it outside the team. As architect, I ended up drawing their class diagrams from their UML and code, just to get the documentation out the door and signed off (very fast on my cheap drawing tool, no need for "UML Modeling software"). No "Use Cases" etc were necessary, because that content was already delivered (before writing code) in much more understandable form, in SSADM/IDEF0 and page layouts. State Transition and Sequence diagrams, network diagrams, overall architecture diagrams, all used applicable Standards and were more complete than the UML diagrams they replaced. Come to think of it, all my projects recently are second generation, full re-implementations of "pure OO" projects, which promised magick, because they were failures, the "databases" were crippled, and the Auditors had rejected them. The re-writes simply used the appropriate science, and complied with Standard, for each Subject Area. there is no magic involved in science. The result is 100% success in each area, with 20% OO, instead of 20% success in each area using 100% OO. Usually using the exact same OO indiividuals.
