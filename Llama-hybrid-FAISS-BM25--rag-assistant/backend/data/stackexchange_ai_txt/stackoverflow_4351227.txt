[site]: stackoverflow
[post_id]: 4351227
[parent_id]: 4351175
[tags]: 
At the very first run, when the history file wasn't created, you don't load the history. However you seem to not clean the history array (the default values are not all zeroes, contrary to Java), so it contains some garbage. At the exit, when you write your values out, you put into the history file that garbage, and than read it back. You should ensure that all your strings are NULL-terminated. Always. Please try to do the following: Delete the existing history file At the beginning of main , initialize history so that each line contains NULL at the beginning Whenever storing anything to the history, make sure that you are either using some standard string copying functions (like strcpy ), or copy the terminating NULL as well. By the way, the check if(history[i] != '\0') is wrong, as history[i] points to the already allocated part of history buffer. Did you want to put if (history[i][0] == '\0') (which would check if the i-th history line is empty)? Well, fixed sizes of buffers are evil, but this is other story. To the newly posted code: there are massive problems everywhere. One of them: the check (strcmp(inputBuffer, "r\n\0") != 0) && (strncmp(inputBuffer, "r x", 2) != 0) in setup is totally wrong. First, you don't need to add explicitly \0 , because each string literal ends implicitly by \0 . Second: the first part (strcmp(inputBuffer, "r\n\0") != 0) checks if the inputBuffer 's content is r\n , and the second part (strncmp(inputBuffer, "r x", 2) != 0) checks if inputBuffer starts with r x . Clearly these two conditions are mutually exclusive, so if you put && between them, the result will never be true. Many code constructs in the given code do not what you seem to intend. I suggest that you step slowly through the code in debugger, inspecting every variable and any result of the function call, I bet you'll be surprised. One of the biggest problems with the code is the work with strings, and overall memory management. Please read something on this topic: it's vitally important for the C programs. A few notes: Pointer points to some raw memory. The compiler doesn't check whether the memory under the char* pointer really contains char s or not. To make it worse, there is a convention that string is kind of the same as pointer to its first character. The end of the string is 0, always. There is no other means to determine the end of the string. If you somehow overwrite the trailing 0, the string's end will be at the next 0 in the memory. It's usually impractical to work with strings on single character level. There are numerous utility functions like strcmp or strcpy which can do this for you. Usually those functions are more efficient, and have no bugs. I still cannot find the code in setup which put the data into the history. There is a part with the comment "checks to see if the command is a history retrieval command. If it isn't then add it to the history", but this part doesn't do it (partially because it's never executed because of the wrong check at the beginning, partially because the code inside doesn't copy anything from the inputBuffer , only to it).
