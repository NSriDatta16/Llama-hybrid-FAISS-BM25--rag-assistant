[site]: stackoverflow
[post_id]: 4453907
[parent_id]: 4453746
[tags]: 
Your "next step" would not be the same as mine. My next step would be to find another example of this "common code" you're trying to refactor. Perhaps a "`CustomerEntity.Get(int id)'" method. Now, let's pretend the only difference between the CustomerEntity and OrganisationEntity versions are the query string and the replacement of the term "Organisation" with "Customer". My next step would be to try to make the two methods more and more identical. Assuming this method is part of an OrganisationEntityRepository class, I'd refactor that towards an EntityRepository1 class, and the CustomerEntityRepository towards EntityRepository2. Steps 1 would be to introduce a generic parameter for the type of the entity. You'll have to do the same for the OrganisationEntityMapper and CustomerEntityMapper classes. Next, go back and look at what's still different. I see they use different mapper classes, so let's make the mapper type generic. In order to do that and still reference the MapAll method, I'll introduce an IMapper interface with the MapAll method, and have my two concrete mapper classes implement that. Now, the next big difference is the query. I'll put that into a virtual "CommandText" property. Now I think I'm ready for a base class, perhaps EntityRepositoryBase . With suitable assumptions, I wind up with the following: public abstract class EntityRepositoryBase where TMapper : IMapper { public virtual TEntity Get(int id) { List entities; using (var command = new SqlCommand {CommandText = CommandText}) { command.Parameters.Add("@id", SqlDbType.Int).Value = id; entities = new List (); using (var reader = Database.ExecuteQuery(command, ConnectionName.Dev)) { while (reader.Read()) { var mapper = Mapper; entities = mapper.MapAll(reader); } } } return entities.First(); } protected abstract string CommandText { get; } protected abstract TMapper Mapper { get; } } public class OrganisationEntityRepository : EntityRepositoryBase > { protected override string CommandText { get { return @"SELECT t.Id, t.Description FROM Organisation t Where t.Id = @Id"; } } protected override OrganisationEntityMapper Mapper { get { throw new NotImplementedException(); } } } public class CustomerEntityRepository : EntityRepositoryBase > { protected override string CommandText { get { return @"SELECT t.Id, t.Description FROM Customer t Where t.Id = @Id"; } } protected override CustomerEntityMapper Mapper { get { throw new NotImplementedException(); } } } And, needless to say, though I'll say it anyway: props to JetBrains ReSharper 5.1 for doing all the moving around of things, so I didn't have to.
