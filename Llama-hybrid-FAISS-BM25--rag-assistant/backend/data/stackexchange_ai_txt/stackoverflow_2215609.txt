[site]: stackoverflow
[post_id]: 2215609
[parent_id]: 
[tags]: 
Problem in luabind with default_converter and tables

===Edit=== The problem is actually much simpler than this, any wrapped function that takes a table is causing the problem. If I wrap a function that takes luabind::object, and call that function with a table argument, then the gc causes an invalid free(). I'm starting to think that this may be some kind of crazy compilation/linking problem, as my compiled luabind dylib has lua symbols in it (resulting in two copies of those symbols, one in that library and one in my binary). Maybe I have duplicates of some lua static variables or something? I might just be grasping at straws here. ===Edit=== Using luabind 0.9 and gcc 4.2.1 on mac os x 10.6 I'm seeing what could (maybe?) be a problem with using a default_converter from lua tables. I'm trying to define converters for various list-like types in my code, specifically std::vector. When I pass a table to a c++ method with such a default_converter, lua crashes with free() on an invalid pointer as soon as the garbage collector is called. I'm probably missing something simple here, but I can't figure it out. Thanks! * Lua Code * function first () -- Doesn't crash -- t = TestClass(1, 3) -- Crashes t = TestClass({1, 2, 3}) print(t:get(0)) print(t:get(1)) print(t:get(2)) end function second () print("About to call collectgarbage...") collectgarbage() print("Done calling collectgarbage!") end function test () first() second() end * C++ Code * #include #include #include #include using namespace std; using namespace luabind; namespace luabind { template struct default_converter > : native_converter_base > { static int compute_score(lua_State* L, int index) { return lua_type(L, index) == LUA_TTABLE ? 0 : -1; } std::vector from(lua_State* L, int index) { std::vector list; for (luabind::iterator i(luabind::object(luabind::from_stack(L, index))), end; i != end; ++i) list.push_back(luabind::object_cast (*i)); return list; } void to(lua_State* L, const std::vector & l) { luabind::object list = luabind::newtable(L); for (size_t i = 0; i v) : m_vec(v) {} TestClass(int b, int e) { for (int i = b; i m_vec; }; int main(int argc, char** argv) { if (argc != 2) { cout " ("TestClass") .def(constructor >()) .def(constructor ()) .def("get", &TestClass::get) ]; if (luaL_loadfile(L, scriptName.c_str()) || lua_pcall(L, 0, 0, 0)) { cout (globals(L)["test"]); lua_close(L); return 0; }
