[site]: stackoverflow
[post_id]: 1329259
[parent_id]: 1326118
[tags]: 
std::for_each is for doing something with each element. If you want get a result from a calculation on all the elements, there's std::accumulate . If you are wanting Haskell's map behaviour, use std::transform . You can abuse either of these three to do the same thing as any of the others, since ultimately they are just iterating over an iterator (except for transform 's form that takes two iterators as input.) The point is that for_each is not a replacement for map/fold - that should be done by transform/accumulate - although C++ doesn't natively have something that expresses the map/fold concept as well as Haskell does - but both gcc and VC++ support OpenMP which has a much better analogue in #pragma omp parallel for . Inject in Ruby is a much closer match to calling for_each with a full-fledged functor, like GMan explained above. Lambda functions with variable capture in C++0X will make the behaviour between the two languages even more similar: int main(void) { int arr[] = {1,2,3,4}; std::vector a (arr ,arr + sizeof(arr)/sizeof(arr[0])); int sum = 0; std::for_each(a.begin(), a.end(), [&](int i) { sum += i*i;} ); std::cout
