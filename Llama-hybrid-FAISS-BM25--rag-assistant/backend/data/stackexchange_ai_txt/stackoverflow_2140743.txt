[site]: stackoverflow
[post_id]: 2140743
[parent_id]: 975211
[tags]: 
When I made a circuit emulator (sadly, also incomplete and also unreleased), here's how I handled loops: Each circuit element stores its boolean value When an element "E0" changes its value, it notifies (via the observer pattern) all who depend on it Each observing element evaluates its new value and does likewise When the E0 change occurs, a level-1 list is kept of all elements affected. If an element already appears on this list, it gets remembered in a new level-2 list but doesn't continue to notify its observers. When the sequence which E0 began has stopped notifying new elements, the next queue level is handled. Ie: the sequence is followed and completed for the first element added to level-2, then the next added to level-2, etc. until all of level-x is complete, then you move to level-(x+1) This is in no way complete. If you ever have multiple oscillators doing infinite loops, then no matter what order you take them in, one could prevent the other from ever getting its turn. My next goal was to alleviate this by limiting steps with clock-based sync'ing instead of cascading combinatorials, but I never got this far in my project.
