[site]: stackoverflow
[post_id]: 1975204
[parent_id]: 
[tags]: 
What are the major differences between coding an AVR ATmega32 and an Arduino Mega?

I'm trying to modify this code in an attempt to make it work on an Arduino Mega. I'm pretty much new to C, so I may have made some major mistakes. By the way, this is for a self balancing skateboard. This code is taken from an ATmega32 (from here ) and I'm trying to make it work on a Arduino Mega. This code was written for an ATmega32 development board . I've done some modifications (corrected some mistakes) but, at the end, I encounter: In function 'int main()': error: redefinition of 'int main() Here is the complete code: #include #include #include #include #define CLOCK_SPEED 16000000 #define OCR1_MAX 1023 typedef unsigned char u8; void set_motor_idle(void); void InitPorts(void); float level=0; float Throttle_pedal; float aa; float accelraw; float x_acc; float accsum; float x_accdeg; float gyrosum; float gangleratedeg; float gangleraterads; float ti = 2.2; float overallgain; float gaincontrol; float batteryvolts = 24; float gyroangledt; float angle; float anglerads; float balance_torque; float softstart; float cur_speed; float cycle_time = 0.0064; float Balance_point; float a0, a1, a2, a3, a4, a5, a6;//Savitzky-Golay variables for accelerometer int i; int j; int tipstart; void InitPorts(void) { PORTC=0x00; //Port C pullups set to low (no output voltage) to begin with DDRC=0xFF; //Port C pins all set as output via the port C direction register //PORTC |= (1 OSMC pin 6 PD4/OC1B BLI -> OSMC pin 8 PC1 Disable -> OSMC pin 4 PC2 BHI -> OSMC pin 7 PC3 AHI -> OSMC pin 5 PA6/ADC6 Vbatt/10 -> OSMC pin 3 PA1/ADC1 pitch rate gyro PA0/ADC0 accelerometer */ void adc_init(void) { /* turn off analogue comparator as we don't use it */ ACSR = (1 100) Balance_point=534; if (adc5>100) Balance_point=494; PORTB |= (1 250) x_acc=250; /* Accelerometer angle change is about 3.45 units per degree tilt in range 0-30 degrees(sin theta) Convert tilt to degrees of tilt from accelerometer sensor. Sin angle roughly = angle for small angles so no need to do trigonometry. x_acc below is now in DEGREES*/ x_accdeg= (float) x_acc/-3.45; //The minus sign corrects for a back to front accelerometer mounting! /*GYRO signal processing*/ /*Subtract offsets: Sensor reading is 0-1024 so "balance point" i.e. my required zero point will be that reading minus 512*/ /*Gyro angle change of 20mV per deg per sec from datasheet gives change of 4.096 units (on the scale of 0 - 1023) per degree per sec angle change This limits the rate of change of gyro angle to just less than the maximum rate it is actually capable of measuring (100deg/sec). Note all these fractions are rounded up to an integer later just before it is sent to the PWM generator which in turn is connected to the motor controller*/ gangleratedeg=(float)((gyrosum/7) - 508)/4.096; //gyrosum is a sum of a group of 7 samples so divide by 7 for gyro value if (gangleratedeg 92) gangleratedeg=92; /*I turn port B2 on and off once per main program cycle so I can attach an oscilloscope to it and work out the program cycle time I use the cycle time to work out gyro angle change per cycle where you have to know the length of this time interval*/ PORTB &= (0 0.9) level=0.9; int16_t leveli = (int16_t)(level*1023); //NOTE here we take the floating point value we have ended up with for "level", we multiply it by 1023 and then make it into an integer before feeding the value into the PWM generator as "leveli" if (leveli 1020) leveli=1020; /*Set up LED or buzzer on Port B1 to warn me to slow down if torque to be delivered is more than 50% of max possible The reason for this is that you always need some reserve motor power in case you start tipping forward at speed If motor already running flat-out you would be about to fall over at high speed! Some use an auto-tip back routine to automatically limit top speed. For now I will do it this way as easier*/ if (level 0.7) { PORTB |= (1 1.0) softstart=1.0; //PORTC |= (0 524) { // if (x_accdeg>0) { tipstart=0; } else { tipstart=1; softstart=0.4; } } angle=0; cur_speed=0; /* end of tilt start code. If go beyond this point then machine has become level and is active*/ sei(); while (1) { sample_inputs(); set_motor(); } }
