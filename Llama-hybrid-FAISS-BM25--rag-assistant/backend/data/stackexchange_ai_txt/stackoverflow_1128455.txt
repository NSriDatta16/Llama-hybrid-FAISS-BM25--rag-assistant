[site]: stackoverflow
[post_id]: 1128455
[parent_id]: 1126588
[tags]: 
Haskell is defined by having a small set of core language functionality surrounded by a rich set of syntactic choices. List comprehensions are one choice, but they provide nothing that the monad sugar that RWH spends the entire book building up intuition for doesn't also provide. There are many cases where Haskell provides two syntaxes for the same thing, let vs. where, case and combinator oriented programming style, and list comprehensions and monad sugar. List comprehensions were originally implemented as monad comprehensions, a fact which changed in the "great monomorphization revolution of '98" (aka Haskell '98). In fact, the design of LINQ in .NET languages derives heavily from the older monad comprehension design. List comprehensions could be far more general than they are, but were deliberately crippled to make them yield easier to understand error messages. Given a finite amount of paper, you have to choose what material to emphasize, and RWH avoids talking about them for the most part so you don't fall into the trap of thinking of lists as anything special. That said, there is a brief mention of them in Chapter 12. By that point sufficient intuition has been built up for the underlying concepts that they aren't really a danger. In the end, the name of the book is Real World Haskell. It wants to teach you good real world programming techniques. A number of Haskellers (not all) avoid list comprehensions because the notation doesn't scale well, and because eventually, you may want to come back in and retrofit a monad transformer or something and would wind up rewriting whole swathes of comprehension code in monadic style anyways. [Update: Now that GHC has regained monad comprehensions this objection isn't quite as strong as it used to be. You can get some interesting new functionality out of them.]
