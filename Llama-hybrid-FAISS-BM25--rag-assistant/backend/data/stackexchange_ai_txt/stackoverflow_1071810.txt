[site]: stackoverflow
[post_id]: 1071810
[parent_id]: 1071768
[tags]: 
First, a few observations... You've forgotten to call [super dealloc] at the end of your own dealloc method. Since 'a' created 'b', and if no other objects have retained 'b', there no point in nilling the delegate in the -dealloc , since 'b' is about to be destroyed anyhow. If it's possible that other objects have a reference to 'b' (meaning it might outlive 'a') then set the delegate to nil. Object 'b' should be the one to take care of its delegate in its own -dealloc if necessary . (Generally, the delegator does not retain the delegate.) Avoid using properties in -init... and -dealloc methods — Apple discourages this, and for good reason. (Not only could it have unexpected side effects, but can also cause nastier, crashier problems.) Using properties (via the dot syntax) when you don't need to invisibly adds extra work. For instance, self.b.delegate = self is equivalent to [[self getB] setDelegate:self] — it's just syntactic sugar that makes it look like you're accessing the ivar directly, but you're actually not. Using properties without understanding what they do can lead to trouble. If self.b retains the value (the property is set to "assign"), you have a memory leak on your hands. Here's how I would probably write it: - (void) someFunc { b = [[B alloc] init]; b.delegate = self; // or [b setDelegate:self]; } - (void) dealloc { b.delegate = nil; [b release]; [super dealloc]; }
