[site]: stackoverflow
[post_id]: 813978
[parent_id]: 813383
[tags]: 
Hacks are hacks are hacks, but perhaps this one is a bit more elegant than some of the others, since calling syntax would be similar to what you want and you wouldn't need to modify the original classes at all: Function.prototype.build = function(parameterArray) { var functionNameResults = (/function (.{1,})\(/).exec(this.toString()); var constructorName = (functionNameResults && functionNameResults.length > 1) ? functionNameResults[1] : ""; var builtObject = null; if(constructorName != "") { var parameterNameValues = {}, parameterNames = []; for(var i = 0; i Now you can do either of these to build an object: var instance1 = MyClass.build(["arg1","arg2"]); var instance2 = new MyClass("arg1","arg2"); Granted, some may not like modifying the Function object's prototype, so you can do it this way and use it as a function instead: function build(constructorFunction, parameterArray) { var functionNameResults = (/function (.{1,})\(/).exec(constructorFunction.toString()); var constructorName = (functionNameResults && functionNameResults.length > 1) ? functionNameResults[1] : ""; var builtObject = null; if(constructorName != "") { var parameterNameValues = {}, parameterNames = []; for(var i = 0; i And then you would call it like so: var instance1 = build(MyClass, ["arg1","arg2"]); So, I hope those are useful to someone - they allow you to leave the original constructor functions alone and get what you are after in one simple line of code (unlike the two lines you need for the currently-selected solution/workaround. Feedback is welcome and appreciated. UPDATE: One other thing to note - try creating instances of the same type with these different methods and then checking to see if their constructor properties are the same - you may want that to be the case if you ever need to check the type of an object. What I mean is best illustrated by the following code: function Person(firstName, lastName) { this.FirstName = firstName; this.LastName = lastName; } var p1 = new Person("John", "Doe"); var p2 = Person.build(["Sara", "Lee"]); var areSameType = (p1.constructor == p2.constructor); Try that with some of the other hacks and see what happens. Ideally, you want them to be the same type. CAVEAT: As noted in the comments, this will not work for those constructor functions that are created using anonymous function syntax, i.e. MyNamespace.SomeClass = function() { /*...*/ }; Unless you create them like this: MyNamespace.SomeClass = function SomeClass() { /*...*/ }; The solution I provided above may or may not be useful to you, you need to understand exactly what you are doing to arrive at the best solution for your particular needs, and you need to be cognizant of what is going on to make my solution "work." If you don't understand how my solution works, spend time to figure it out. ALTERNATE SOLUTION: Not one to overlook other options, here is one of the other ways you could skin this cat (with similar caveats to the above approach), this one a little more esoteric: function partial(func/*, 0..n args */) { var args = Array.prototype.slice.call(arguments, 1); return function() { var allArguments = args.concat(Array.prototype.slice.call(arguments)); return func.apply(this, allArguments); }; } Function.prototype.build = function(args) { var constructor = this; for(var i = 0; i Enjoy!
