[site]: stackoverflow
[post_id]: 775964
[parent_id]: 774394
[tags]: 
I've been tinkering with this thought a bit (since I actually had to implement something like this some time ago) and I've come to the conclusion that there's two ways I'd do it to make it both work and especially maintainable. But before going into those, here's some history first. 1. Why does the problem even exist Most search functions are based on algorithms and technologies derivated from the ones in databases. SQL was originally developed in the early 1970's ( Wikipedia says 1974 ) and back then programming was a whole another kind of beast than it is today because every byte counted, every extra function call could make the difference between excellent performance and bankruption, code was made by people who thought in Assembly...well you get the point. The problem is that those technologies originally have mostly been carried over to modern world without changing them (and why should they be changed, don't fix something which isn't broken ) which means the old paradigms creep around too. And then there's cases when the original algorithm is misinterpreted for some reason and you end up with what you now have, like slow regular expressions . A bit of underlining here is required though, the technologies themselves aren't bad, it's usually just the legacy paradigms which are! 2. Solutions to the problem The solution I ended up using was a system which was a mix of builder pattern and query object pattern (linked by mausch already). As an example if I were to make a pragmatic system to build SQL queries, it would look something like this: SQL.select("column1", "column2") .from("relation") .where().valueEquals("column1", "hello") .and().valueIsLargerThan("column2", 3) .toSQL(); The obvious downside of this is that the builder pattern has the tendency to be a bit too verbose. Upsides are that the each of the build steps (=methods) are quite small by nature, for example .valueIsLargerThan("a", x) merely may just be return columnName + ">=" + x; . This means they're easily unit-testable and one of the biggest upsides is that they can be generated easily from external sources like XML/whatnot and most notably it's rather easy to create a converter from, say, SQL query to Lucene query ( Lucene has automation for this already afaik, this is just an example ). The second one I'd rather use but really avoid is because it's not order-safe ( unless you spend a good amount of time creating metadata helper classes ) while builders are. It's easier to write an example than to go into more detail what I mean, so: import static com.org.whatever.SQL.*; query(select("column1", "column2"), from("relation"), where(valueEquals("column1", "hello"), valueIsLargerThan("column2", 3))); I do count static imports as a downside but other than that, that looks like something I'd really want to use.
