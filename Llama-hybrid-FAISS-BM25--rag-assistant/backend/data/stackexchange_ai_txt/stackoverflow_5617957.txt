[site]: stackoverflow
[post_id]: 5617957
[parent_id]: 5617027
[tags]: 
I'm not sure what Dispatch brings to the party, except inconvenience. Instead, I'd focus on the state of a single Cab and replicate that as many times as needed. In the example below, a Cab has an adjustable color and an odometer. A Timer increments the odometer value periodically. Each independent Cab occupies a separate tab in a JTabbedPane . Addendum: Returning to the question, "How do I pause main()," the answer is "don't." Rather, use a separate thread, e.g. the one managed by Timer , to advance the state of your model and update the display. import java.awt.Color; import java.awt.Dimension; import java.awt.EventQueue; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.text.DecimalFormat; import java.util.Random; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JTabbedPane; import javax.swing.Timer; /** @see http://stackoverflow.com/questions/5617027 */ public class Cab extends JPanel { private static final Random random = new Random(); private static final String format = "00000000"; private static final DecimalFormat df = new DecimalFormat(format); private Hue hue = Hue.Yellow; private Timer timer; private JLabel odometer = new JLabel(df.format(0)); private int km; public Cab() { this.setPreferredSize(new Dimension(320, 240)); this.setBackground(hue.getColor()); this.add(odometer); final JComboBox colorBox = new JComboBox(); for (Hue h : Hue.values()) { colorBox.addItem(h); } colorBox.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { Hue h = (Hue) colorBox.getSelectedItem(); Cab.this.setBackground(h.getColor()); } }); this.add(colorBox); timer = new Timer(250, new ActionListener() { @Override public void actionPerformed(ActionEvent e) { km += random.nextInt(100); odometer.setText(df.format(km)); } }); timer.start(); } private enum Hue { Yellow(Color.yellow), Cyan(Color.cyan), Magenta(Color.magenta); private final Color color; private Hue(Color color) { this.color = color; } public Color getColor() { return color; } } private static void display() { JFrame f = new JFrame("Dispatch"); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JTabbedPane tabbedPane = new JTabbedPane(); tabbedPane.add("Cab #1", new Cab()); tabbedPane.add("Cab #2", new Cab()); tabbedPane.add("Cab #3", new Cab()); f.add(tabbedPane); f.pack(); f.setLocationRelativeTo(null); f.setVisible(true); } public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { @Override public void run() { display(); } }); } }
