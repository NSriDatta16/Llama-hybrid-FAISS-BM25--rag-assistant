[site]: stackoverflow
[post_id]: 4588586
[parent_id]: 4588359
[tags]: 
You have to add a PropertyChanged listener to each item (which must implement INotifyPropertyChanged ) to get notification about editing objects in a observable list. public ObservableCollection Names { get; set; } public List ModifiedItems { get; set; } public ViewModel() { this.ModifiedItems = new List (); this.Names = new ObservableCollection (); this.Names.CollectionChanged += this.OnCollectionChanged; } void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e) { if (e.NewItems != null) { foreach(Item newItem in e.NewItems) { ModifiedItems.Add(newItem); //Add listener for each item on PropertyChanged event newItem.PropertyChanged += this.OnItemPropertyChanged; } } if (e.OldItems != null) { foreach(Item oldItem in e.OldItems) { ModifiedItems.Add(oldItem); oldItem.PropertyChanged -= this.OnItemPropertyChanged; } } } void OnItemPropertyChanged(object sender, PropertyChangedEventArgs e) { Item item = sender as Item; if(item != null) ModifiedItems.Add(item); } Maybe you have to check if some item is already in the ModifedItems-List (with List's method Contains(object obj)) and only add a new item if the result of that method is false . The class Item must implement INotifyPropertyChanged . See this example to know how. As Robert Rossney said you can also make that with IEditableObject - if you have that requirement.
