[site]: stackoverflow
[post_id]: 5102096
[parent_id]: 5089030
[tags]: 
I have studied this issue a little bit more and it seems now to be best to create a new function for plotting radial cluster directly from the linkage output (rather than hacking the plotted one). I may cook up eventually something, but nothing very soon. I'm assuming that your data naturally admit this kind of radial embedding. Have you verified that? Does there exists a suitable method in the linkage for your purposes? It seems that for any method linkage will return a binary-tree structure. In your examples you have more general tree. You need some extra knowledge how to consolidate tree nodes. This all ready invalidates the idea of hacking the original dendrogram. Update: Would this naive example plot be a reasonable similar enough for your purposes? If so, I'll be able to post some really simple code to achieve it. Update 2 : Here is the code: radial_demo.py : from numpy import r_, ones, pi, sort from numpy.random import rand from radial_grouper import tree, pre_order, post_order from radial_visualizer import simple_link from pylab import axis, figure, plot, subplot # ToDo: create proper documentation def _s(sp, t, o): subplot(sp) t.traverse(simple_link, order= o) axis('equal') def demo1(n): p= r_[2* pi* rand(1, n)- pi, ones((1, n))] t= tree(p) f= figure() _s(221, t, pre_order) _s(222, t, post_order) t= tree(p, tols= sort(2e0* rand(9))) _s(223, t, pre_order) _s(224, t, post_order) f.show() # f.savefig('test.png') # ToDO: implement more demos if __name__ == '__main__': demo1(123) radial_grouper.py : """All grouping functionality is collected here.""" from collections import namedtuple from numpy import r_, arange, argsort, array, ones, pi, where from numpy import logical_and as land from radial_support import from_polar __all__= ['tree', 'pre_order', 'post_order'] Node= namedtuple('Node', 'ndx lnk') # ToDo: enhance documentation def _groub_by(p, tol, r): g, gm, gp= [], [], p- p[0] while True: if gp[-1] radial_support.py : """All supporting functionality is collected here.""" from numpy import r_, arctan2, cos, sin from numpy import atleast_2d as a2d # ToDo: create proper documentation strings def _a(a0, a1): return r_[a2d(a0), a2d(a1)] def from_polar(p): """(theta, radius) to (x, y).""" return _a(cos(p[0])* p[1], sin(p[0])* p[1]) def to_polar(c): """(x, y) to (theta, radius).""" return _a(arctan2(c[1], c[0]), (c** 2).sum(0)** .5) def d_to_polar(D): """Distance matrix to (theta, radius).""" # this functionality is to adopt for more general situations # intended functionality: # - embedd distance matrix to 2D # - return that embedding in polar coordinates pass if __name__ == '__main__': from numpy import allclose from numpy.random import randn c= randn(2, 5) assert(allclose(c, from_polar(to_polar(c)))) # ToDO: implement more tests radial_visualizer.py : """All visualization functionality is collected here.""" from pylab import plot # ToDo: create proper documentation def simple_link(t, ndx, level): """Simple_link is just a minimal example to demonstrate what can be achieved when it's called from _grouper.tree.traverse for each link. - t, tree instance - ndx, a pair of (from, to) indicies - level, of from, i.e. root is in level 0 """ plot(t.points[0, ndx], t.points[1, ndx]) if 0== level: plot(t.points[0, ndx[0]], t.points[1, ndx[0]], 's') if t.is_leaf(ndx[1]): plot(t.points[0, ndx[1]], t.points[1, ndx[1]], 'o') # ToDO: implement more suitable link visualizers # No doubt, this will the part to burn most of the dev. resources if __name__ == '__main__': # ToDO: implement tests pass You can find the source code here . Please feel free to modify it anyway you like, but please keep the future modifications synced with the gist.
