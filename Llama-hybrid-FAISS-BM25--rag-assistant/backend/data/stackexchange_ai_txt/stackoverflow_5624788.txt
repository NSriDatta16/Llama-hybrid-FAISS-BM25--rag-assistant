[site]: stackoverflow
[post_id]: 5624788
[parent_id]: 
[tags]: 
C++ Boolean Variables Changing

I have a C++ class; this class is as follows: First, the header: class PageTableEntry { public: PageTableEntry(bool modified = true); virtual ~PageTableEntry(); bool modified(); void setModified(bool modified); private: PageTableEntry(PageTableEntry &existing); PageTableEntry &operator=(PageTableEntry &rhs); bool _modified; }; And the .cpp file #include "PageTableEntry.h" PageTableEntry::PageTableEntry(bool modified) { _modified = modified; } PageTableEntry::~PageTableEntry() {} bool PageTableEntry::modified() { return _modified; } void PageTableEntry::setModified(bool modified) { _modified = modified; } I set a breakpoint on all 3 lines in the .cpp file involving _modified so I can see exactly where they are being set/changed/read. The sequence goes as follows: Breakpoint in constructor is triggered. _modified variable is confirmed to be set to true Breakpoint in accessor is triggered. _modified variable is FALSE! This occurs with every instance of PageTableEntry. The class itself is not changing the variable - something else is. Unfortunately, I don't know what. The class is created dynamically using new and is passed around (as pointers) to various STL structures, including a vector and a map. The mutator is never called by my own code (I haven't gotten to that point yet) and the STL structures shouldn't be able to, and since the breakpoint is never called on the mutator I can only assume that they aren't. Clearly there's some "gotcha" where private variables can, under certain circumstances, be changed without going through the class's mutator, triggered by who-knows-what situation, but I can't imagine what it could be. Any thoughts? UPDATE: The value of this at each stage: Constructor 1: 0x100100210 Constructor 2: 0x100100400 Accessor 1: 0x1001003f0 Accessor 2: 0x100100440 UPDATE2: (code showing where PageTableEntry is accessed) // In constructor: _tableEntries = std::map (); // To get an entry in the table (body of testAddr() function, address is an unsigned int: std::map ::iterator it; it = _tableEntries.find(address); if (it == _tableEntries.end()) { return NULL; } return (PageTableEntry *)&(*it); // To create a new entry: PageTableEntry *entry = testAddr(address); if (!entry) { entry = new PageTableEntry(_currentProcessID, 0, true, kStorageTypeDoesNotExist); _tableEntries.insert(std::pair (address, entry)); } Those are the only points at which PageTableEntry objects are stored and retrieved from STL structures in order to cause the issue. All other functions utilize the testAddr() function to retrieve entries. UNRELATED: Since C++ now has 65663 questions, and so far 164 have been asked today, that means that only just today the number of C++ tagged questions exceeded a 16-bit unsigned integer. Useful? No. Interesting? Yes. :)
