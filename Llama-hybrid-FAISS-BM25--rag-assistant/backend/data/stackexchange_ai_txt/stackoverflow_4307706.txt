[site]: stackoverflow
[post_id]: 4307706
[parent_id]: 4306861
[tags]: 
You have a few options, depending on how the rest of your socket code is laid out. The simpliest approach, from a coding perspective, is to just read 1 char at a time until you encounter the char you are looking for. This is not the best approach from a performance perspective, though you can use a local buffer to help you avoid fragmenting memory at least, eg: std::string sockread(void) { char buffer[DEFAULT_BUFLEN]; int buflen = 0; char c; std::string s; do { int result = recv(m_socket, &c, 1, 0); if (result > 0) { if (c == '\n') break; if (buflen == DEFAULT_BUFLEN) { s += std::string(buffer, buflen); buflen = 0; } buffer[buflen] = c; ++buflen; continue; } if (result == SOCKET_ERROR) { if (WSAGetLastError() == WSAEWOULDBLOCK) continue; std::cout 0) s += std::string(buffer, buflen); return s; } On the other hand, reading the raw socket data into an intermediate buffer that the rest of your reading functions access when needed allows for more efficient reading of the socket so the data is gotten out of the socket's buffers quicker (causing less blocking on the other side), eg: std::vector buffer; std::string sockread(void) { unsigned char buf[DEFAULT_BUFLEN]; int result; std:vector ::iterator it; do { it = std::find(buffer.begin(), buffer.end(), '\n'); if (it != buffer.end()) break; result = recv(m_socket, buf, DEFAULT_BUFLEN, 0); if (result > 0) { std::vector ::size_type pos = buffer.size(); buffer.resize(pos + result); memcpy(&buffer[pos], buf, result); continue; } if (result == SOCKET_ERROR) { if (WSAGetLastError() == WSAEWOULDBLOCK) continue; std::cout
