[site]: stackoverflow
[post_id]: 4150926
[parent_id]: 
[tags]: 
In App Purchase Crashes on [[SKPaymentQueue defaultQueue] addPayment:payment]

My In-App-Purchases work. I present a ModalView with a "Buy" UIButton. You click the button and the In App Purchase goes through the process. You can even do it several times in a row. The problem occurs if you open the Modal View, then close the Modal View (using a UITabBarButtonItem), then reopen the Modal View and tap the "Buy" button. The app crashes and I get an NSZombie that reads *** -[InAppPurchaseManager respondsToSelector:]: message sent to deallocated instance 0x1c7ad0 The NSZombie points to line 160 in the .m file. I have marked it with comments. I got the original code from this page: http://troybrant.net/blog/2010/01/in-app-purchases-a-full-walkthrough/ I have been struggling with this for many days now... any help would be awesome. Here is the .h // // InAppPurchaseManager.h // Copyright 2010 __MyCompanyName__. All rights reserved. #import #import #define kInAppPurchaseManagerProductsFetchedNotification @"kInAppPurchaseManagerProductsFetchedNotification" #define kInAppPurchaseManagerTransactionFailedNotification @"kInAppPurchaseManagerTransactionFailedNotification" #define kInAppPurchaseManagerTransactionSucceededNotification @"kInAppPurchaseManagerTransactionSucceededNotification" #define kInAppPurchaseCreditProductId @"com.myname.app.iap" @interface InAppPurchaseManager : UIViewController { SKProduct *productID; SKProductsRequest *productsRequest; IBOutlet UIBarButtonItem *closeButton; IBOutlet UIButton *buyButton; IBOutlet UILabel *testLabel; } @property (retain, nonatomic) SKProduct *productID; @property (retain, nonatomic) SKProductsRequest *productsRequest; @property (retain, nonatomic) IBOutlet UIBarButtonItem *closeButton; @property (retain, nonatomic) IBOutlet UIButton *buyButton; @property (retain, nonatomic) IBOutlet UILabel *testLabel; // public methods -(void)loadStore; -(BOOL)canMakePurchases; -(void)purchaseCredit; -(void)requestInAppPurchaseData; -(void)buyButtonAction:(id)sender; -(void)closeButtonAction:(id)sender; -(void)updateButtonStatus:(NSString *)status; @end Here is the .m // InAppPurchaseManager.m #import "InAppPurchaseManager.h" @implementation InAppPurchaseManager @synthesize productID; @synthesize productsRequest; @synthesize closeButton; @synthesize buyButton; @synthesize testLabel; - (void)dealloc { [productID release]; //[productsRequest release]; [closeButton release]; [buyButton release]; [testLabel release]; [super dealloc]; } - (void)viewDidLoad { [super viewDidLoad]; [closeButton release]; closeButton = [[UIBarButtonItem alloc] initWithTitle:@"Close" style:UIBarButtonItemStyleBordered target:self action:@selector(closeButtonAction:)]; self.navigationItem.leftBarButtonItem = closeButton; [self loadStore]; self.navigationItem.title = @"Credits"; } -(void)closeButtonAction:(id)sender { [self dismissModalViewControllerAnimated:YES]; } -(void)buyButtonAction:(id)sender { if([self canMakePurchases]) { [self updateButtonStatus:@"OFF"]; [self performSelectorOnMainThread:@selector(requestInAppPurchaseData) withObject:nil waitUntilDone:NO]; } else { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:nil message:[NSString stringWithString:@"Your account settings do not allow for In App Purchases."] delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil]; [alertView show]; [alertView release]; } } -(void)updateButtonStatus:(NSString *)status { if ([status isEqual:@"OFF"]) { closeButton.enabled = NO; buyButton.enabled = NO; buyButton.titleLabel.textColor = [UIColor grayColor]; } else { closeButton.enabled = YES; buyButton.enabled = YES; buyButton.titleLabel.textColor = [UIColor blueColor]; } } #pragma mark - #pragma mark SKProductsRequestDelegate methods // // call this method once on startup // - (void)loadStore { // restarts any purchases if they were interrupted last time the app was open [[SKPaymentQueue defaultQueue] addTransactionObserver:self]; } - (void)requestInAppPurchaseData { NSSet *productIdentifiers = [NSSet setWithObject:kInAppPurchaseCreditProductId]; productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; productsRequest.delegate = self; [productsRequest start]; // we will release the request object in the delegate callback } - (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response { NSArray *products = response.products; productID = [products count] == 1 ? [[products objectAtIndex:0] retain] : nil; if (productID) { /* NSLog(@"Product title: %@" , productID.localizedTitle); NSLog(@"Product description: %@" , productID.localizedDescription); NSLog(@"Product price: %@" , productID.price); NSLog(@"Product id: %@" , productID.productIdentifier); */ NSUserDefaults *standardUserDefaults = [NSUserDefaults standardUserDefaults]; NSString *currentCredits = ([standardUserDefaults objectForKey:@"currentCredits"]) ? [standardUserDefaults objectForKey:@"currentCredits"] : @"0"; testLabel.text = [NSString stringWithFormat:@"%@", currentCredits]; } for (NSString *invalidProductId in response.invalidProductIdentifiers) { //NSLog(@"Invalid product id: %@" , invalidProductId); testLabel.text = @"Try Again Later."; } // finally release the reqest we alloc/initâ€™ed in requestProUpgradeProductData [productsRequest release]; [[NSNotificationCenter defaultCenter] postNotificationName:kInAppPurchaseManagerProductsFetchedNotification object:self userInfo:nil]; [self performSelectorOnMainThread:@selector(purchaseCredit) withObject:nil waitUntilDone:NO]; } // // call this before making a purchase // - (BOOL)canMakePurchases { return [SKPaymentQueue canMakePayments]; } // // kick off the upgrade transaction // - (void)purchaseCredit { SKPayment *payment = [SKPayment paymentWithProductIdentifier:kInAppPurchaseCreditProductId]; // ********************************************************************************************************* [[SKPaymentQueue defaultQueue] addPayment:payment]; //
