[site]: crossvalidated
[post_id]: 376676
[parent_id]: 312908
[tags]: 
It seems that the package psych dos some nonstandard things, which are not always necessary for PCA regression. I suggest you use a different method. A straightforward one is to use the function prcomp that comes with the default stats package or do PCA by simply taking the singulr value decompositon ( svd ) of the data matrix appropriately standardised. Minimal example: set.seed(55) X = matrix(rnorm(100), 20) X = scale(X) #centres the vriables and scales them to unit variance pca_stats = prcomp(x = X) #from the stats package pca_svd = svd(X) # the svd of X # the loadings are the same pca_svd $v pca_stats$ rotation #one needs to compute the scores (the "new" variables, i.e. the PCs' scores) by hand for the prcomp output pca_stats $scores = X %*% pca_stats$ rotation # one may want to rescale the left singular value to obtain standard PCs as pca_svd $u = pca_svd$ u %*% diag(pca_svd$d) now you have two sets of identical PCs sum(abs(pca_stats $scores - pca_svd$ u)) and you can select the first two PCs with PCs_stats = pca_stats $scores[, 1:2] # or PCs_svd = pca_svd$ u[, 1:2] Note that here I have assumed that you want to run PCA on the correlation matrix as opposed to the covariance matrix. This is most likely to be the best approach. The package psych by default rotates the PCs. This is not always accepted and may cause the rotated components to be correlated (depending on how the loadings are scaled before rotation). However, since PCA is carried out not considering the response variables, it is not assured that the standard PCs will be better predictors than the rotated ones. So you may want to try out some rotatons as well, for example with pca_svd_vari = varimax(pca_svd $v[, 1:2], normalize = FALSE) # or TRUE PCs_svdRot = X %*% pca_svd_vari$ loadings There are several details I did not discuss. Maybe you should do some reading before using PCA regression?
