[site]: stackoverflow
[post_id]: 2519398
[parent_id]: 2519271
[tags]: 
This compiles for me (although with a warning about the return type from main() ). The result, in terms of what main() will print, is undetermined because you have not initialized the value of var in main.c. The most likely result when the compiler is invoked without optimizations is zero because the OS will have zeroed the physical memory supplied to the process for data storage (the OS does this to avoid leaking confidential data between processes). The static qualifier to the var variable definitions means that the variable is not visible outside the source file it is defined in. It also means that each of the three var variables gets its own storage location. If we add a printf("[module name] *var=%p\n", &var) to foo() , bar() and main() respectively to print the address of the memory location that stores those three variables you should get something like this:- foo() *var=0x8049620 bar() *var=0x8049624 main() *var=0x8049628 Note that each variable gets its own storage location. The code in each source file will access the version of var that is specific to to that source file. Using static like this in .c files is typically used to implement the concept of information hiding in C.
