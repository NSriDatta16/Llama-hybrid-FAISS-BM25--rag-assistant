[site]: crossvalidated
[post_id]: 486743
[parent_id]: 223196
[tags]: 
Edit : My answer uses binning just like @gunes' answer, but my algorithm uses uniformly distributed numbers instead of a bell curve distribution. The binning is also done by taking mod 10 instead of a more complicated procedure that a bell curve would require. In fact, the fast version of the following algorithm is so simple it can actually be done with a real die and mental arithmetic if you know your times table for 6 up through $6 \times 6$ . I tested it myself with a real die and it takes only a few seconds with $N = 4$ rolls to actually generate an emulated value of rolling a 10-sided die. A Simple Algorithm We start with the standard 6-sided die with faces from the set $[1:6] = \{ 1, 2, 3, 4, 5, 6\}$ . Choose the number $N$ which will be the number of times we roll this 6-sided die (larger $N$ -values will make the resulting emulated roll of a 10-sided die closer to being uniformly distributed. There's a formula below for exactly what these probabilities will be in terms of $N$ ). Then let $d_n$ denote the result of the $n^\text{th}$ roll. The algorithm is as follows: Let $r \leftarrow d_1 - 1$ For $n = 2, \dots , N$ , let $r \leftarrow \text{mod} (r + 6(d_n - 1), 10)$ Return the result $r + 1$ , which will be approximately uniformly distributed on the values $[1:10]$ . (Alternatively, since $r$ is a number in $[0:9]$ , you could just interpret $0$ as $10$ instead of adding 1 to $r$ ). Note : I have the minus 1's in the algorithm to help explain how it works, but they aren't necessary. For a truly fast algorithm, you can simply do Let $r \leftarrow d_1$ For $n = 2, \dots , N$ , let $r \leftarrow \text{mod} (r + 6(d_n), 10)$ Return the result $r + 1$ . An Example Run Let's choose $N = 4$ . Then suppose we roll the 6-sided die once and our first roll is $d_1 = 6$ . We set $r \leftarrow d_1 - 1 = 5$ . Now roll a second time and supposed we get $d_2 = 4$ . We compute $6(d_2 - 1) = 18$ . Because we are only interested in the sum mod 10, we can "forget" the tens place at each step. Interpret all "=" as equal mod 10 from this point forward. So the update for $r$ is $r \leftarrow r + 6(3) = 5 + 18 = 5 + 8 = 13 = 3$ . We repeat this process. If the third roll is $d_3 = 1$ , then $6(d_3 - 1) = 0$ , and we update $r \leftarrow r + 0 = 3$ , which happens to be the same as the previous step. If the last roll is $d_4 = 5$ , we update $r \leftarrow r + 6(d_4 - 1) = 3 + 6(4) = 3 + 24 = 3 + 4 = 7$ . The result of the emulation is then $r + 1 = 7 + 1 = 8$ in this example. Why it Works First, note that the following Lemma holds: Lemma : For all integers $n \ge 1$ , $\text{mod}(6^n, 10) = 6$ . In other words, every power of 6 (with $n \ge 1$ ) has a 6 in the ones place. Proof : The proof is a simple induction proof. See here for details. Now, each roll minus one of the 6-sided die is a uniformly random digit in $\{ 0, 1, 2, 3, 4, 5 \}$ . Put the $N$ digits together and you get the senary (base-6) representation of a number in $\{ 0, 1, \dots, 6^N - 1\}$ . In the above example with $N = 4$ and $(d_4, d_3, d_2, d_1) = (5, 1, 4, 6)$ , we first subtract one from every roll to get the numbers $(4, 0, 3, 5)$ . Interpret these as the senary number $$4035_6 = 4(6^3) + 0(6^2) + 3(6^1) + 5(6^0) = 887,$$ which we take mod 10 of to get $r = 7$ , and the resulting roll is $r + 1 = 8$ . The Lemma above lets us simplify the computation by "forgetting" the tens place repeatedly in the powers of 6 (which will then always give us 6 in the ones place), which makes the shortcut of updating $r \leftarrow \text{mod} (r + 6(d_n - 1), 10)$ instead of having to calculating the full base 10 representation of the senary number. Because each digit of the senary number is uniformly distributed and independent, the senary number is itself uniformly distributed as well on the set $[0:6^N - 1]$ . Taking mod 10 then partitions this set into 10 bins. Unfortunately, because of the Lemma above, the last four bins will always be one possibility short of the first six, so each bin won't quite have the same probability. However, we can compute these probabilities exactly as $$ P(r + 1 = i) = \begin{cases} \left( \left\lfloor{6^N / 10}\right\rfloor + 1 \right)/6^N , & \text{ if } i = 1, 2, \dots, 6 \\ \left \lfloor{6^N / 10}\right \rfloor /6^N , & \text{ if } i = 7, 8, 9, 10 \\ \end{cases} $$ where $\lfloor{\cdot}\rfloor$ is the floor function. With $N = 4$ , these probabilities are $0.1003086$ and $0.0995370$ respectively, which is a pretty good approximation of the desired value of $0.1$ . In my subjective opinion, for a tabletop game $N = 2$ and $N = 3$ don't seem like good enough approximations, but $N = 4$ seems passable. A Julia Simulation for $N = 2, 3, 4$ Here's some simulation code in the Julia Language to test the algorithm """Run one emulated roll of a 10-sided die using a 6-sided die""" function emulate_10_sided(N) r = rand(1:6) - 1 for n = 2:N r = mod(r + 6(rand(1:6) - 1), 10) end return r + 1 end """Run `iters` emulated rolls of a 10-sided die using a 6-sided die""" function emulate_10_sided(N, iters) [emulate_10_sided(N) for i = 1:iters] end # Plot the results histogram using Plots n_trials = 1000000 # Number of trials to average over theme(:dark) histogram(emulate_10_sided(2, n_trials), legend=false, normalize=:probability, ylim=(0, .12), title="Simulated Probabilities with N = 2") histogram(emulate_10_sided(3, n_trials), legend=false, normalize=:probability, ylim=(0, .12), title="Simulated Probabilities with N = 3") histogram(emulate_10_sided(4, n_trials), legend=false, normalize=:probability, ylim=(0, .12), title="Simulated Probabilities with N = 4") which generates the following plots:
