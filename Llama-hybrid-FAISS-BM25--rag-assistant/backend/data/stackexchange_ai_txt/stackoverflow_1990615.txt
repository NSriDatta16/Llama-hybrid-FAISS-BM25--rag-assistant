[site]: stackoverflow
[post_id]: 1990615
[parent_id]: 1989969
[tags]: 
I got it work, but it's wonky. I do love templates. template class Base1 { }; template class Base2 { }; class Derived; template<> class Base1 { public: double foo(){return 0.1;} }; template<> class Base2 { public: int foo(){return 1;} }; class Derived : public Base1 , public Base2 { public: using Base1 ::foo; }; int main() { double sum = 0; Derived d; sum += d.foo(); //+ .1 Base1 * pI = &d; sum += pI->foo(); //+ .1 Base2 * pF = &d; sum += pF->foo(); //+ 1 return (sum*10); } I couldn't get it to work without templates, although it seems like it should be able to. I'm not sure if you can get away with just doing templated member functions in the same manner, but my gut says "no". In terms of code organization, I would then define the Base# stuff right after the definition or declaration of Derived, since that's really what it's for. Keep in mind you can then use typename Base1 something to make things prettier. Edit: Oh, right! It doesn't allow you to do the "using" trick or have different return types, but it's otherwise simpler: class Derived : public Base1 , public Base2 { double Base1::foo(){...} double Base2::foo(){...} } There may be a terrible, horrible, awesome way to combine these two approaches, but I don't think it'll actually help out when using the code. I may get back to you on that.
