[site]: stackoverflow
[post_id]: 1916218
[parent_id]: 
[tags]: 
Find the longest common starting substring in a set of strings

This is a challenge to come up with the most elegant JavaScript, Ruby or other solution to a relatively trivial problem. This problem is a more specific case of the Longest common substring problem . I need to only find the longest common starting substring in an array. This greatly simplifies the problem. For example, the longest substring in [interspecies, interstelar, interstate] is "inters". However, I don't need to find "ific" in [specifics, terrific] . I've solved the problem by quickly coding up a solution in JavaScript as a part of my answer about shell-like tab-completion ( test page here ). Here is that solution, slightly tweaked: function common_substring(data) { var i, ch, memo, idx = 0 do { memo = null for (i=0; i This code is available in this Gist along with a similar solution in Ruby. You can clone the gist as a git repo to try it out: $ git clone git://gist.github.com/257891.git substring-challenge I'm not very happy with those solutions. I have a feeling they might be solved with more elegance and less execution complexity—that's why I'm posting this challenge. I'm going to accept as an answer the solution I find the most elegant or concise. Here is for instance a crazy Ruby hack I come up with—defining the & operator on String: # works with Ruby 1.8.7 and above class String def &(other) difference = other.to_str.each_char.with_index.find { |ch, idx| self[idx].nil? or ch != self[idx].chr } difference ? self[0, difference.last] : self end end class Array def common_substring self.inject(nil) { |memo, str| memo.nil? ? str : memo & str }.to_s end end Solutions in JavaScript or Ruby are preferred, but you can show off clever solution in other languages as long as you explain what's going on. Only code from standard library please. Update: my favorite solutions I've chosen the JavaScript sorting solution by kennebec as the "answer" because it struck me as both unexpected and genius. If we disregard the complexity of actual sorting (let's imagine it's infinitely optimized by the language implementation), the complexity of the solution is just comparing two strings. Other great solutions: "regex greed" by FM takes a minute or two to grasp, but then the elegance of it hits you. Yehuda Katz also made a regex solution , but it's more complex commonprefix in Python — Roberto Bonvallet used a feature made for handling filesystem paths to solve this problem Haskell one-liner is short as if it were compressed, and beautiful the straightforward Ruby one-liner Thanks for participating! As you can see from the comments, I learned a lot (even about Ruby).
