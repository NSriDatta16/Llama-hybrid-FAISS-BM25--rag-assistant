[site]: stackoverflow
[post_id]: 1603055
[parent_id]: 1602451
[tags]: 
I know valarrays have some syntactic sugar I have to say that I don't think std::valarrays have much in way of syntactic sugar. The syntax is different, but I wouldn't call the difference "sugar." The API is weird. The section on std::valarray s in The C++ Programming Language mentions this unusual API and the fact that, since std::valarray s are expected to be highly optimized, any error messages you get while using them will probably be non-intuitive. Out of curiosity, about a year ago I pitted std::valarray against std::vector . I no longer have the code or the precise results (although it shouldn't be hard to write your own). Using GCC I did get a little performance benefit when using std::valarray for simple math, but not for my implementations to calculate standard deviation (and, of course, standard deviation isn't that complex, as far as math goes). I suspect that operations on each item in a large std::vector play better with caches than operations on std::valarray s. ( NOTE , following advice from musiphil , I've managed to get almost identical performance from vector and valarray ). In the end, I decided to use std::vector while paying close attention to things like memory allocation and temporary object creation. Both std::vector and std::valarray store the data in a contiguous block. However, they access that data using different patterns, and more importantly, the API for std::valarray encourages different access patterns than the API for std::vector . For the standard deviation example, at a particular step I needed to find the collection's mean and the difference between each element's value and the mean. For the std::valarray , I did something like: std::valarray original_values = ... // obviously I put something here double mean = original_values.sum() / original_values.size(); std::valarray temp(mean, original_values.size()); std::valarray differences_from_mean = original_values - temp; I may have been more clever with std::slice or std::gslice . It's been over five years now. For std::vector , I did something along the lines of: std::vector original_values = ... // obviously, I put something here double mean = std::accumulate(original_values.begin(), original_values.end(), 0.0) / original_values.size(); std::vector differences_from_mean; differences_from_mean.reserve(original_values.size()); std::transform(original_values.begin(), original_values.end(), std::back_inserter(differences_from_mean), std::bind1st(std::minus (), mean)); Today I would certainly write that differently. If nothing else, I would take advantage of C++11 lambdas. It's obvious that these two snippets of code do different things. For one, the std::vector example doesn't make an intermediate collection like the std::valarray example does. However, I think it's fair to compare them because the differences are tied to the differences between std::vector and std::valarray . When I wrote this answer, I suspected that subtracting the value of elements from two std::valarray s (last line in the std::valarray example) would be less cache-friendly than the corresponding line in the std::vector example (which happens to also be the last line). It turns out, however, that std::valarray original_values = ... // obviously I put something here double mean = original_values.sum() / original_values.size(); std::valarray differences_from_mean = original_values - mean; Does the same thing as the std::vector example, and has almost identical performance. In the end, the question is which API you prefer.
