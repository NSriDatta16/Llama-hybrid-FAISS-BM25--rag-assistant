[site]: stackoverflow
[post_id]: 5123069
[parent_id]: 5122963
[tags]: 
All STL containers store a copy of the inserted data. Look here in section "Description" in the third paragraph: A Container (and std::set models a Container) owns its elements. And for more details look at the following footnote [1]. In particular for the std::set look here under the section "Type requirements". The Key must be Assignable. Apart from that you can test this easily: struct tester { tester(int value) : value(value) { } tester(const tester& t) : value(t.value) { std::cout v; v.push_back(t); std::set s; s.insert(t); } You'll always see Copy construction! . If you really want to store something like a reference to an object you either can store pointers to these objects: tester* t = new tester(10); { std::set s; s.insert(t); // do something awesome with s } // here s goes out of scope just as well the contained objects // i.e. the *pointers* to tester objects. The referenced objects // still exist and thus we must delete them at the end of the day: delete t; But in this case you have to take care of deleting the objects correctly and this is sometimes very difficult. For example exceptions can change the path of execution dramatically and you never reach the right delete . Or you can use smart pointers like boost::shared_ptr : { std::set > s; s.insert(boost::shared_ptr (new tester(20))); // do something awesome with your set } // here s goes out of scope and destructs all its contents, // i.e. the smart_ptr objects. But this doesn't mean // the referenced objects will be deleted. Now the smart pointers takes care for you and delete their referenced objects at the right time. If you copied one of the inserted smart pointers and transfered it somewhere else the commonly referenced object won't be delete until the last smart pointer referencing this object goes out of scope. Oh and by the way: Never use std::auto_ptr s as elements in the standard containers. Their strange copy semantics aren't compatible with the way the containers are storing and managing their data and how the standard algorithms are manipulating them. I'm sure there are many questions here on StackOverflow concerning this precarious issue.
