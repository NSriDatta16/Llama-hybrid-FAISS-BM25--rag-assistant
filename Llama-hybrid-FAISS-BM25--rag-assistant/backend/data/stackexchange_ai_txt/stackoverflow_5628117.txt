[site]: stackoverflow
[post_id]: 5628117
[parent_id]: 5628059
[tags]: 
The two are not contradictory. Allocators are a PolicyPattern or StrategyPattern used by the STL libraries' container adapters to allocate chunks of memory for use with objects. These allocators frequently optimize memory allocation by allowing * ranges of elements to be allocated at once, and then initialized using a placement new * items to be selected from secondary, specialized heaps depending on blocksize One way or another, the end result will (almost always) be that the objects are allocated with new (placement or default) Another vivid example would be how e.g. boost library implements smartpointers. Because smartpointers are very small (with little overhead) the allocation overhead might become a burden. It would make sense for the implementation to define a specialized allocator to do the allocations, so one may have efficient std::set<> of smartpointers, std::map etc. (Now I'm almost sure that boost actually optimizes storage for most smartpointers by avoiding any virtuals, therefore the vft, making the class a POD structure, with only the raw pointer as storage; some of the example will not apply. But then again, extrapolate to other kinds of smartpointer (refcounting smartpointers, pointers to member functions, pointers to member functions with instance reference etc. etc.))
