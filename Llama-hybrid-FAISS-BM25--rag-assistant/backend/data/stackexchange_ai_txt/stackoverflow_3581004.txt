[site]: stackoverflow
[post_id]: 3581004
[parent_id]: 3580872
[tags]: 
Separate the result processing from the data retrieval. Your inheritance hierarchy is already more than deep enough at ReadCommandBase. Define an interface IDatabaseResultParser. Implement ItemDatabaseResultParser and ListDatabaseResultParser, both with a constructor parameter of type ReadCommandBase ( and maybe convert that to an interface too ). When you call IDatabaseResultParser.Value() it executes the command, parses the results and returns a result of type T. Your commands focus on retrieving the data from the database and returning them as tuples of some description ( actual Tuples or and array of arrays etc etc ), your parser focuses on converting the tuples into objects of whatever type you need. See NHibernates IResultTransformer for an idea of how this can work (and it's probably a better name than IDatabaseResultParser too). Favor composition over inheritance. Having looked at the sample I'll go even further... Throw away AppCommandBase - it adds no value to your inheritance hierarchy as all it does is check that the connection is not null and open and creates a command. Separate query building from query execution and result parsing - now you can greatly simplify the query execution implementation as it is either a read operation that returns an enumeration of tuples or a write operation that returns the number of rows affected. Your query builder could all be wrapped up in one class to include paging / sorting / filtering, however it may be easier to build some form of limited structure around these so you can separate paging and sorting and filtering. If I was doing this I wouldn't bother building the queries, I would simply write the sql inside an object that allowed me to pass in some parameters ( effectively stored procedures in c# ). So now you have IDatabaseQuery / IDatabaseCommand / IResultTransformer and almost no inheritance =)
