[site]: stackoverflow
[post_id]: 3954350
[parent_id]: 3954120
[tags]: 
It is clearly some sort of race condition. I don't think it is as simple as Erick Robertson's answer. Dialog's show() code is quite complicated, it contains some special logic for being called from the event dispatch thread and it also posts events to the event queue. Maybe the order in which events are posted is somehow affected by thread delays. Perhaps what you need is SwingUtilities.invokeAndWait() , this way you guarantee that setVisible(true) has finished execution before you call setVisible(false) . As Skip Head pointed out, invokeAndWait will block until the dialog is closed. And why do you need it anyways? EDIT: This is my scenario of what's happening: you call d.show() that posts setVisible(true) event the thread is put so sleep by the scheduler and EDT kicks in and starts executing the first event EDT gets kicked out before the first task has finished and posted an actual event that shows the dialog your thread executes d.hide() that posts the setVisible(false) event. The thread is finished and EDT kicks in EDT finished the first task, puts its showing event to the event queue It goes to the next event, and, voila, it is the setVisible(false) event! It messes up the whole state of the dialog and it stays visible and unresponsive. EDIT2: Looks like ProgressMonitor has the functionality you are trying to implement.
