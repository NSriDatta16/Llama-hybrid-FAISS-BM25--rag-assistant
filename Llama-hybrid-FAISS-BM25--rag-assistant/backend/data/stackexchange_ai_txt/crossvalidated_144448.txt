[site]: crossvalidated
[post_id]: 144448
[parent_id]: 144442
[tags]: 
If your Gibbs sampler produces a non-irreducible Markov chain, it means there are parts of the space with positive mass under the target distribution that are never visited by the chain (for some starting values). In order to produce an irreducible chain, you need adding moves to the original Gibbs sampler, for instance by using re-parametrisations that link the disconnected parts of the support that the original Markov chain cannot simultaneously visit. However, your example has nothing to do with Gibbs sampling so I do not understand the question. If the distribution to be simulated is of the form $$\prod_{t=1}^T \prod_\limits{i=1}^4P(x_{t,i}\vert X_{t-1})$$ with a fixed value for $X_0$, it proceeds by simulating once $X_1$ by simulating its components, then $X_2$ by simulating its components, and so on until $X_T$. There is no reason to cycle iteratively through the $X_t$ and to condition upon the neighbours as in Gibbs sampling. If you insist on using Gibbs sampling for a reason I cannot fathom!, your counterexample does not work because you cannot simulate values for any $x_{it}$ that is incompatible with the other components of $X_t$ and/or the next and/or the previous values $X_{t+1}$ and $X_{t-1}$. In essence, the current value of the variable to be simulated should always be acceptable as the next value. "This happens with probability $\gamma > 0$" is invalid, because $x_{3(t-1)}$ needs to be simulated conditional on $X_{t-2}$ and $X_t$, not on its own. A basic Gibbs sampler applied to this problem produces a Markov chain that is not irreducible because the identically zero sequence is a trapping state and it can be reached with positive probability from any starting sequence, moving backward by replacing the rightmost non-zero $X_t$ by $(0,...,0)$ [this happens with positive probability], one term at a time. To find the MAP of this system (whether or not this makes sense, since the null sequence has the highest probability of $1$), I would suggest dynamic programming.
