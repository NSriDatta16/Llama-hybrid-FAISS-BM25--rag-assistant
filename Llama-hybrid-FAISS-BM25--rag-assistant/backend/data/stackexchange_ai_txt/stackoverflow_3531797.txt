[site]: stackoverflow
[post_id]: 3531797
[parent_id]: 3531580
[tags]: 
Rather than giving personal opinion, I will quote from an authoritative source in the Java community, and examples from 2 very reputable third party libraries. A quote from Effective Java 2nd Edition, Item 4: Enforce noninstantiability with a private constructor : Occasionally you'll want to write a class that is just a grouping of static methods and static fields. Such classes have acquired a bad reputation because some people abuse them to avoid thinking in terms of objects, but they do have valid uses . They can be used to group related methods on primitive values or arrays, in the manner of java.lang.Math or java.util.Arrays . They can also be used to group static methods, including factory methods, for objects that implements a particular interface, in the manner of java.util.Collections . Lastly, they can be used to group methods on a final class, instead of extending the class. Java libraries has many examples of such utility classes. Apache Commons Lang follows the Type Utils naming convention ArrayUtils , StringUtils , ObjectUtils , BooleanUtils , etc Guava follows the Type s naming convention Objects , Strings , Throwables , Collections2 , Iterators , Iterables , Lists , Maps , etc. The package summary actually has a specific section on classes of static utility methods Another entire package consists of nothing but utility classes for working with Java primitives, Ints , Floats , Booleans , etc. Short summary Prefer good OOP design, always static utility classes have valid uses to group related methods on: Primitives (since they're not objects) Interfaces (since they can't have anything concrete of their own) final classes (since they're not extensible) Prefer good organization, always Group utility methods for SomeType to SomeType Utils or SomeType s Avoid a single big utility class that contains various unrelated tasks on different types/concepts
