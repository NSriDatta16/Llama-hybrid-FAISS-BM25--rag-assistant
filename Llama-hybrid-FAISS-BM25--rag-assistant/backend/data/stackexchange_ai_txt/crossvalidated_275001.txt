[site]: crossvalidated
[post_id]: 275001
[parent_id]: 37795
[tags]: 
Normally, the predicted label $\hat{y}$ from SVM is given by $\hat{y}=\mbox{sign}({\mathbf w^T x}+b)$, where ${\mathbf w}$ is the SVM-optimized weights of the hyper-plane, and the $b$ is the SVM-optimized intercept. This can also be re-written as follows: \begin{eqnarray} \hat{y} & = & \left\{\begin{array}{cc} 0 & \mbox{if}~~{\mathbf w^T x}+b However, if we introduce a threshold $\eta$, we can control the positive detection rate by varying $\eta$, i.e. \begin{eqnarray} \hat{y} & = & \left\{\begin{array}{cc} 0 & \mbox{if}~~{\mathbf w^T x}+b By varying $\eta$, we can produce an ROC using SVM, and thereby adjusting the sensitivity and specificity rate. For example, if we want to do it in python, we can extract ${\mathbf w}$ and $b$ using threshold $\eta$ as follows. >>> from sklearn.svm import SVC >>> model = SVC(kernel='linear', C=0.001, probability=False, class_weight='balanced') >>> model.fit(X, y) >>> # The coefficients w are given by >>> w = list(model.coef_) >>> # The intercept b is given by >>> b = model.intercept_[0] >>> y_hat = X.apply(lambda s: np.sum(np.array(s)*np.array(w))+b, axis=1) >>> y_hat = (y_hat > eta).astype(float)
