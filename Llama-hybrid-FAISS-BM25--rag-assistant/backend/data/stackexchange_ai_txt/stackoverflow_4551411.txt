[site]: stackoverflow
[post_id]: 4551411
[parent_id]: 4544781
[tags]: 
I found out that if I do instrumentation (which was the point of me even bothering with the NUnit VS integration), then I manage to avoid these problems. Not sure which exact combination of settings did the trick, but these are the settings I am using: In-place instrumentation The MSTest test project only has a dependency on the NUnit test project The generic test deploys the NUnit test (from the MSTest bin output folder), the NUnit test app.config (from the NUnit test bin output folder), and the problem DLL. The rest of the dependencies, including the DLL under test, get deployed by code coverage. If you don't need instrumentation, I found this work-around: Don't link to the top-level DLL that's causing a problem (in this case, the DLL under test) Modify the solution build setting to make your project dependent on that project Embed all DLLs in the dependency chain that are causing problems as Embedded Resources During runtime, grab the resource stream for each DLL, create a file, and copy the stream across. Basically, extract the resources and output them again as files Write file from assembly resource stream to disk Then, there is no link-time dependency, so MSTest won't see those DLLs. This won't work well with instrumentation because the DLLs only appear at runtime, and MSTest wants to instrument during deploy time. It also won't work well if you actually have to link to those DLLs :) In my case, they derived from an abstract interface, which was free from the problem.
