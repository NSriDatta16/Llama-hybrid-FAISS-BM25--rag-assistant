[site]: stackoverflow
[post_id]: 596154
[parent_id]: 596093
[tags]: 
If you have a class that's designed for copy semantics and you're allocating/deallocating a bunch of memory unnecessarily, I could see this being bad practice. In general, though, it's not. There are a lot of classes that can make use of heap storage. Just make sure you're free of memory leaks (deallocate things in the destructor, reference count, etc.) and you're fine. If you want more flexibility, consider letting your user specify an Allocator . I'll explain. Certain classes, e.g. std::vector , string, map, etc. need heap storage for the data structures they represent. It's not considered bad manners; when you have an automatically allocated vector , the user is expected to know that a buffer is allocated when the vector constructor gets called: void foo() { // user of vector knows a buffer that can hold at least 10 ints // gets allocated here. std::vector foo(10); } Likewise, for std::string , you know there's an internal, heap-allocated char* . Whether there's one per string instance is usually up to the STL implementation; often times they're reference counted. However, for nearly all of the STL classes, users do have a choice of where things are put, in that they can specify an allocator. vector is defined kind of like this: template > class vector { // etc. }; Internally, vector uses Alloc (which defaults to whatever the default allocator is for T) to allocate the buffer and other heap storage it may need. If users doesn't like the default allocation strategy, they can specify one of their own: vector foo(10); Now when the constructor allocates, it will use a MyCustomAllocator instead of the default. Here are some details on writing your own STL allocator . If you're worried that it might be "bad manners" to use the heap for certain storage in your class, you might want to consider giving users of your class an option like this so that they can specify how things are to be allocated if your default strategy doesn't fit their needs.
