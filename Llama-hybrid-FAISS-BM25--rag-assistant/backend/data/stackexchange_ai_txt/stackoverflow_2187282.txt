[site]: stackoverflow
[post_id]: 2187282
[parent_id]: 2179286
[tags]: 
Actually this sort of problem is really a matter of using the right pattern to track the mouse. I've seen this issue in variety of cases not just in Silverlight. The best pattern is to trap the original locations of both mouse and subject, then recalculate the new offset from the fixed original values. That way the mouse stays planted solid at a single point on the image being panned. Here is my simple Repro:- Start with a fresh Silverlight Application in visual studio. Modify MainPage.Xaml thus:- Add the following code to the MainPage.xaml.cs file:- public MainPage() { InitializeComponent(); Map.MouseLeftButtonDown += new MouseButtonEventHandler(Map_MouseLeftButtonDown); } void Map_MouseLeftButtonDown(object sender, MouseButtonEventArgs e) { Point mapOrigin = new Point(Scroller.HorizontalOffset, Scroller.VerticalOffset); Point mouseOrigin = e.GetPosition(Application.Current.RootVisual); MouseEventHandler moveHandler = null; MouseButtonEventHandler upHandler = null; moveHandler = (s, args) => { Point mouseNew = args.GetPosition(Application.Current.RootVisual); Scroller.ScrollToHorizontalOffset(mapOrigin.X - (mouseNew.X - mouseOrigin.X)); Scroller.ScrollToVerticalOffset(mapOrigin.Y - (mouseNew.Y - mouseOrigin.Y)); }; upHandler = (s, args) => { Scroller.MouseMove -= moveHandler; Scroller.MouseLeftButtonUp -= upHandler; }; Scroller.MouseMove += moveHandler; Scroller.MouseLeftButtonUp += upHandler; } } Give it a reasonably large test.jpg (doesn't need to be 1600x1200 Image will scale it). You'll note that when dragging the mouse remains exactly over a fixed point in the image until you hit a boundary. Move the mouse as fast as you like it always tracks, this is because it doesn't depend on deltas being accurate and up-to-date. The only variable is the current mouse position, the other values remain fixed as they were at mouse down.
