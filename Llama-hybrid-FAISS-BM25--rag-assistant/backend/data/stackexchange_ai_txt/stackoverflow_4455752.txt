[site]: stackoverflow
[post_id]: 4455752
[parent_id]: 4453746
[tags]: 
Here is how I would refactor it: public class Repository : IRepository where T : class, new() { private IEntityMapper _mapper; public Repository(IEntityMapper mapper) { _mapper = mapper; } public virtual T Find(string value) { SqlCommand command = new SqlCommand(); command.CommandText = @"SELECT t.Id, t.Description FROM Organisation t Where t.Description LIKE @value"; command.Parameters.Add("@value").Value = value + "%"; SqlDataReader reader = Database.ExecuteQuery(command, ConnectionName.Dev); return FillCollection(reader); } public void T Get(int id) { SqlCommand command = new SqlCommand(); command.CommandText = @"SELECT t.Id, t.Description FROM Organisation t Where t.id = @value"; command.Parameters.Add("@value").Value = id; SqlDataReader reader = Database.ExecuteQuery(command, ConnectionName.Dev); if (!reader.Read()) return null; T entity = new T(); _mapper.Map(entity, reader); return entity; } protected IList FillCollection(IDataReader reader) { List items = new List (); while (reader.Read()) { T entity = new T(); _mapper.Map(entity, reader); _items.Add(entity); } return items; } } public interface IEntityMapper { //row is the most generic part of a DataReader void Map(T entity, IDataRow row); } Keypoints: Created a base class with FillCollection as a protected method. Forced entity to be a class with a default constructor to speed up object creation. Using a interface for the mapper and taking it in the constructor. I would not fill an entire collection to just get the first item. waste of cpu. Try to use as generic interfaces as possible, as IDataRecord instead of DbDataReader
