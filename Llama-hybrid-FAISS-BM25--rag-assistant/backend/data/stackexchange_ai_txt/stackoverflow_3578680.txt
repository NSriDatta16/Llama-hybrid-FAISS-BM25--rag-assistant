[site]: stackoverflow
[post_id]: 3578680
[parent_id]: 
[tags]: 
UISwitch and UITableViewCell iOS4

Caveat: I have looked for the answer to my question and several come close, but I'm still missing something. Here is the scenario: I want a way to create UITableViewCell s that contain UISwitch es dynamically at run time, based on the data in a table (which I can do). The problem becomes connecting the switches such that I can get their value when that view is changed (navigated away, closed, etc). I have tried to use the events UIControlEventValueChanged to be notified, but have failed to specify it correctly, because it dumps when that switch is tapped. Also, there doesn't seem to be any way to uniquely identify the switch so that if all the events are handled by a single routine (ideal), I can't tell them apart. So... If I have a UITableView: @interface RootViewController : UITableViewController { UISwitch * autoLockSwitch; } @property (nonatomic, retain) UISwitch * autoLockSwitch; -(void) switchFlipState: (id) sender; @end // the .m file: @implementation RootViewController // ... - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString * CellIdentifier = @"Cell"; int row = 0; NSString * label = nil; TableCellDef_t * cell_def = nil; row = indexPath.row; cell_def = &mainMenuTableCellsDef[ row ]; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease]; } label = (NSString *) mainMenuTableCellsDef[indexPath.row].text; [cell.textLabel setText:(NSString *) mainMenuItemStrings[ indexPath.row ]]; if (cell_def->isSpecial) // call special func/method to add switch et al to cell. { (*cell_def->isSpecial)(cell ); // add switch, button, etc. } else { [cell setAccessoryType:UITableViewCellAccessoryDisclosureIndicator]; } } and this is the 'special' function: -(void) autoLockSpecialItem :(UITableViewCell *) cell { autoLockSwitch = [[[UISwitch alloc] initWithFrame:CGRectZero] autorelease]; [autoLockSwitch addTarget:self action:@selector(switchFlipState:) forControlEvents:UIControlEventValueChanged ]; [cell addSubview:autoLockSwitch]; cell.accessoryView = autoLockSwitch; } and finally: -(void) switchFlipState: (id) sender { NSLog(@"FLIPPED"); } ============================================================== Questions: Why would it crash (bad selector) when the switch was tapped? I believe that my code follows all the example code that I have seen, but obviously something is wrong. I cannot put a instance method into a table as a function pointer; and it doesn't seem to like a class method either. If I make it a 'C/C++' function, how do I get access to the class/instance member variables? That is, if I want to put a call to autoLockSpecialItem into a static table (or reasonable facsimile) such that I can get autoLockSwitch member variable? If I make it a class method and the autoLockSwitch var a static, will that be valid? More simply: how do I connect the UIControlEventValueChanged to my view (I have tried and failed) and can I differentiate at runtime within the event handler which switch has changed? Is there a better way? I cannot believe that I am the first person to have to solve this type of problem. Apologies for the length, appreciation for attention and grateful for any and all help. :bp:
