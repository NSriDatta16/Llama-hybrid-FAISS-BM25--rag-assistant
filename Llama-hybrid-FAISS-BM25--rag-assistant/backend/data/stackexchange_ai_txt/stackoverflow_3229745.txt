[site]: stackoverflow
[post_id]: 3229745
[parent_id]: 3229102
[tags]: 
Playing around with ast and compile (built-in) it seems that you could possibly use the NodeTransformer to modify some nodes... You can also edit them manually if you know what you're looking for. test.py print 'Dumb Guy' x = 4 + 4 print x * 3 change.py import ast with open('test.py') as f: expr = f.read() e = ast.parse(expr) e.body[0].values[0].s = 'Cool Guy' # Replace the string e.body[1].targets[0].id = 'herring' # Change x to herring e.body[2].values[0].left.id = 'herring' # Change reference to x to reference to herring c = compile(e, ' ', 'exec') exec(c) Ouput of change.py: Cool Guy 24 You can also add code to the body this way (or replace elements in the usual way of replacing list elements): p = ast.parse('print "Sweet!"', mode='single') e.body.extend(p) and then just recompile and exec: c = compile(e, ' ', 'exec') exec(c) You can replace function definitions or single lines that way. A function definition will have its own body, so if you added some function (or loop) you could access it with e.body[N].body # Replace N with the index of the FunctionDef object However, the only way that I know of to execute a single ast object ( _ast.Print or _ast.Assign or whatever) is to do something like this: e2 = ast.parse('', mode='exec') e2.body.append(e.body[0]) exec(compile(e2, ' ', 'exec')) which seems a bit hackish to me. As far as lines go - each object in the AST has a lineno attribute, so if you can retrieve the line number from the exception you can fairly easily figure out which statement threw the exception. Of course this doesn't really solve the problem of rewinding the stack to the pre-exception state, which is what you really want to do, it sounds like. However, it might be possible to do such a thing via pdb .
