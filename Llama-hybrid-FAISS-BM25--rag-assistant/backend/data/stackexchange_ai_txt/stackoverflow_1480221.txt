[site]: stackoverflow
[post_id]: 1480221
[parent_id]: 1480023
[tags]: 
c (K&R) 339 necessary characters after more suggestions from strager. The physicist in me noted that the propagation and reflection operations are time-reversal invariant, so this version, throws rays from the target and checks to see if the arrive at the laser emitter. The rest of the implementation is very straight forward and is taken more or less exactly from my earlier, forward going effort. Compressed: #define R return #define C case #define Z x,y int c,i,j,m[99][99],Z;s(d,e,Z){for(;;)switch(m[x+=d][y+=e]){C'^':R 1==e; C'>':R-1==d;C'v':R-1==e;C' 0)c==10?i=0,j++:(c==120?x=i,y=j: i,m[i++][j]=c);puts(s(1,0,Z)|s(0,1,Z)|s(-1,0,Z)|s(0,-1,Z)?"true":"false");} Uncompressed(ish): #define R return #define C case #define Z x,y int c,i,j,m[99][99],Z; s(d,e,Z) { for(;;) switch(m[x+=d][y+=e]){ C'^': R 1==e; C'>': R-1==d; C'v': R-1==e; C' 0) c==10?i=0,j++: (c==120?x=i,y=j:i,m[i++][j]=c); puts(s(1,0,Z)|s(0,1,Z)|s(-1,0,Z)|s(0,-1,Z)?"true":"false"); } There is no input validation, and bad input can send it into an infinite loop. Works properly with input no larger than 99 by 99. Requires a compiler that will link the standard library without including any of the headers. And I think I'm done, strager has me beat by a considerable stretch, even with his help. I'm rather hoping someone will demonstrate a more subtle way to accomplish the task. There s nothing wrong with this, but it is not deep magic.
