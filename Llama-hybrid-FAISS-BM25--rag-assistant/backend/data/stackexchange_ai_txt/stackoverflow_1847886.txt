[site]: stackoverflow
[post_id]: 1847886
[parent_id]: 1847789
[tags]: 
In C or C++ local objects are usually allocated on the stack. You are allocating a large array on the stack, more than the stack can handle, so you are getting a stackoverflow. Don't allocate it local on stack, use some other place instead. This can be achieved by either making the object global or allocating it on the global heap . Global variables are fine, if you don't use the from any other compilation unit. To make sure this doesn't happen by accident, add a static storage specifier, otherwise just use the heap. This will allocate in the BSS segment, which is a part of the heap. Since it's in static storage, it's zero initialized if you don't specify otherwise, unlike local variables (automatic storage) including arrays. static int c[1000000]; int main() { cout A non-zero initializer will make a compiler allocate in the DATA segment, which is a part of the heap too. (And all the data for the array initializer will take space in the executable, including all the implicit trailing zeros, instead of just a size to zero-init in the BSS) int c[1000000] = {1, 2, 3}; int main() { cout This will allocate at some unspecified location in the heap: int main() { int* c = new int[1000000]; // size can be a variable, unlike with static storage cout
