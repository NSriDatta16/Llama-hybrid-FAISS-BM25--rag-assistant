[site]: stackoverflow
[post_id]: 4914865
[parent_id]: 4884557
[tags]: 
This is meant as an affirmation (and addition) to templatetypedef's suggestion, which is a solid one. First off, you will need to make sure you use multiple Threads to do this -- then the JVM and OS scheduler will decide exactly how to spawn and load-balance native threads across multiple cores if necessary. You have no control over this (google for 'java multi-core processor support' for more information). Second, you will want to look at using BufferedImage.getData(Rectangle) to chop up the image and pull out sections of it for processing. NOTE: Most all image algorithms use an area around individual pixels to figure out what the new scaled amount will be... an average of sorts. So take care along the internal edges of the section that you are chopping out, to include ADDITIONAL pixels beyond what you need so the scaling algorithm gives you a more accurate color value. More specifically, say you chop out the TOP-LEFT corner of your image for processing, so it's dimensions start at 0,0 and extend to say 150,150. You will want to cut out to say 160x160 so all the pixel values calculated along that right cut-line and bottom cut-line are more accurate and not just blended with nothing on their right or bottom respectively. Now when you go to re-assemble your image, throw away the "buffer" space that you included along those sliced edges, cause you don't need them any more, you just needed that for the image-scaling algorithm to average with. This overall method, will processor friendly will required roughly 3x the memory per image to process (as is usually the way with these types of processor-friendly approaches). You have: Original image 4x quarter-sliced copies of the original image data During the scaling operations, there is possibly a point in time where the JVM will be holding on to all the 4x quarter-sliced copies AND 4x of their scaled down versions. We would assume right before the scale operation returns you could flush/dispose of the original 4 slices. At the moment of re-assembly you have Original image still (unless you flushed it?) then the 4 smaller quarters and a full-sized reassembled scaled instance. 3x memory requirement would be roughly a worst case scenario, but just be aware of it.
