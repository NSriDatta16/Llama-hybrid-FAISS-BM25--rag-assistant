[site]: stackoverflow
[post_id]: 490653
[parent_id]: 490289
[tags]: 
EDIT: The short answer: If you are "betting the farm on it", it is "production" . This is a great question--an absolutely critical distinction that routinely gets everyone in trouble due to misunderstandings. The question of what is " production " is a subset of the related question of what is an " environment ". So part of the answer is that " production " is THE " environment " that is most important and is most trusted as THE " real " thing. So now we must define " environment " (and then revisit " production "). We are still far from a satisfactory answer. We programmers use the term " environment " constantly to refer to computer systems consisting of hardware that is executing software. That software is the code that we wrote plus software that it depends upon, which was written by others. We write our code and integrate it with the other software, then we typically run the integrated software through an escalating series of tests (unit tests, integration tests, functional tests, acceptance tests, regression tests, etc.), until we finally run the integrated software in the full manner in which it was intended. Of course, not everything is fully automated. There are usually numerous people involved, and they have manual processes to perform. We programmers look for ways to automate as many of these processes as possible, but there is always a "man/machine boundary" in the systems we work on. Often, there are many such boundaries in any particular case. On the other hand, there may not be any significant automation at all. For example, we spoke of " production " way back when we had a room full of people performing manual labor which produced a product . So, there doesn't have to be any automation present in our " production " " environment ". There is also a middle ground, where the automation involved does not include software, such as in the case of a person running a loom to weave cloth. Also, there may not be a product , since we have adapted our language of " production " " environment " to include product-less service providers. Likewise, the testing may not involve software, since we may be testing a non-software-driven machine (e.g., the loom) or even the people (training and evaluation). Now we have touched on all the crucial elements of an " environment ": there is a purpose, an intent , being pursued an intent requires an intender, so there must be a sponsor (a person or group, but not a machine) that specifies the intent that intent is pursued through various processes that are performed by various actors those actors may be people, they may be software executing on hardware, or they may be non-software-driven machines, so there may or may not be automation present Now we can properly and fully define our original terms. An environment consists of all the processes and their actors that collaborate to pursue a particular intent on behalf of its sponsor . That means software executing on hardware, that means non-software-driven machines, and that means people performing their various duties. It is the intent that primarily defines an environment , not its processes or its actors . Furthermore... If the intent being pursued in a particular environment is the sponsor's ultimate goal, which usually involves producing a product or providing a service in exchange for money, then we refer to that environment as production . Now we can go a bit further. If the intent being pursued in an environment is the verification of processes and their actors in preparation for production , we call that a test environment . We further call it an integration environment if that testing involves the initial joining together of significant individuals or groups of processes and their actors . If that preparation involves the "programming" of human actors to perform new processes , or the subsequent verification (evaluation), then we call that a training environment . Armed with these distinctions and definitions, we can now understand several common scenarios. An environment can be mislabeled with a name that does not match its intent , such as when a training environment is used as test . An environment can be grossly misused, such as when integration or training is done in production . An environment can be misrepresented, such as when key processes or actors are left unidentified (e.g., manual reconciliations, or even by ignoring the people altogether). An environment can be retasked, by repurposing its processes and actors to a new intent . A very successful technique for some organizations is to routinely "flip" several sets of actors (servers hosting software) between production , test , training , and integration upon each release. In most cases, a single actor (person or hardware) can execute multiple processes which can participate in multiple environments . For example, a single computer server can host software that performs production transactions while also hosting other software that performs test or training functions. Normally, a single instance of an actor should participate in only one environment at a time. On very rare occasion, a single actor can be shared across environments if the intents are mutually compatible. Most of the time, it is very unwise to attempt such sharing because the intents are not really compatible. A perfect example is running a test process on a server that also supports production processes , resulting in downtime because the test caused the entire server to fail. Therefore, the intent of an environment must be construed with very wide latitude, to include concepts such as availability , reliability , performance , disaster recovery , accuracy , precision , repeatability , longevity , etc. This means that the actors and processes must often be construed to include things like providing power , cooling , backups , and redundancy . Finally, note that the situation can get quite complex. For example, a desktop computer ( actor ) may be tasked by the development team ( sponsor ) to host their source control ( process ), which the team relies upon for their primary jobs ( production ). Nevertheless, the IT staff sees that same desktop computer as simply a developer workstation ( development , not production ) and treats it with contempt and nonchalance when it develops a hardware problem. But the developers are producing production code, so aren't they also part of production ? Perspective matters. EDIT: Production quality A solid verification ( testing ) methodology should take packaged code from development and run it through a series of tests (integration, TQA, functional, regression, acceptance, etc.) until it comes out the other side "stamped" for production use. However, that makes the package production quality , but not actually production . The package only becomes production when a sponsor actually deploys it into an environment with that ultimate level of intent . However, if your organization merely produces that package (its product ) for the consumption of others, then such a release comes as close to production as that organization will experience with respect to that product , so it is common to stretch the term production to apply rather than clarify that it is production quality . In reality, that organization's production environment consists of the actors and processes involved in its development/release efforts that result in that product . I said it could get quite complex...
