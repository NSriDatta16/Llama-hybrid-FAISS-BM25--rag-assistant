[site]: stackoverflow
[post_id]: 5533753
[parent_id]: 5529223
[tags]: 
If I'm reading this correctly, you're performing the critical operations in the script that is called when the storage service redirects the user back to your website. I see two options for ensuring that the critical steps are performed in their entirety: Ensure that PHP is ignoring connection status and is running scripts through to completion using ignore_user_abort() . Trigger some back-end process that performs the critical operations separately from the user-facing scripts. This could be as simple as dropping a job into the at queue if you're using a *NIX server ( man at for more details) or as complex as having a dedicated queue management daemon, much like the one LrdCasimir suggested. The problems like this that I've faced have all had pretty time-consuming processes associated with their operation, so I've always gone with Option 2 to provide prompt responses to the browser, and to free up the web server. Option 1 is easy to implement, but Option 2 is ultimately more fault-tolerant, as updates would stay in the queue until they could be successfully communicated to the storage server. The connection handling page in the PHP manual provides a lot of good insights into what happens during the HTTP connection.
