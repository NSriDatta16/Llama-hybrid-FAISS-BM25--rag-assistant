[site]: stackoverflow
[post_id]: 5656820
[parent_id]: 5656691
[tags]: 
Fixed some type-o's and specialized MakeCallback to accept function pointers. As GMan said, your template arguments to MakeCallback are in a non-deducible context. #include template class CallbackBase { public: typedef std::shared_ptr > CallbackPtr; virtual ~CallbackBase() { } virtual R Call( Args ... args) = 0; }; template class FunctionCallback : public CallbackBase { public: typedef R (*funccb)(Args...); FunctionCallback( funccb cb_ ) : CallbackBase (), cb( cb_ ) { } virtual ~FunctionCallback() { } virtual R Call(Args... args) { return cb( args... ); } private: funccb cb; }; template typename CallbackBase ::CallbackPtr MakeCallback( R (*cb)(Args...) ) { typename CallbackBase ::CallbackPtr p( new FunctionCallback ( cb ) ); return p; } bool Foo_1args( const int & t) { return true; } int main() { auto cbObj = MakeCallback( & Foo_1args ); } Update: The C++ standard defines non-deduced context in 14.8.2.5 [temp.deduct.type], paragraphs 5 - 6. There is a bulleted list there which I won't claim to fully understand. The marker for me is: Any time you see "::" after your template parameter, that template parameter is in a non-deduced context , meaning it must be explicitly specified at the call site.
