[site]: stackoverflow
[post_id]: 3669186
[parent_id]: 3668126
[tags]: 
If you want an alternative to the obvious algorithm, then assuming your numbers are in a bounded range, and you have plenty of memory, you can beat O(N^2) time, N being the number of values: Create an array of a small integer type, indexes 1 to the max input. O(1) For each value, increment the count of every element of the index which is a factor of the number (make sure you don't wraparound). O(N). Starting at the end of the array, scan back until you find a value >= 2. O(1) That tells you the max gcd, but doesn't tell you which pair produced it. For your example input, the computed array looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 4 2 1 1 2 0 0 0 0 0 0 0 0 0 1 I don't know whether this is actually any faster for the inputs you have to handle. The constant factors involved are large: the bound on your values and the time to factorise a value within that bound. You don't have to factorise each value - you could use memoisation and/or a pregenerated list of primes. Which gives me the idea that if you are memoising the factorisation, you don't need the array: Create an empty set of int, and a best-so-far value 1. For each input integer: if it's less than or equal to best-so-far, continue. check whether it's in the set. If so, best-so-far = max(best-so-far, this-value), continue. If not: add it to the set repeat for all of its factors (larger than best-so-far). Add/lookup in a set could be O(log N), although it depends what data structure you use. Each value has O(f(k)) factors, where k is the max value and I can't remember what the function f is... The reason that you're finished with a value as soon as you encounter it in the set is that you've found a number which is a common factor of two input values. If you keep factorising, you'll only find smaller such numbers, which are not interesting. I'm not quite sure what the best way is to repeat for the larger factors. I think in practice you might have to strike a balance: you don't want to do them quite in decreasing order because it's awkward to generate ordered factors, but you also don't want to actually find all the factors. Even in the realms of O(N^2), you might be able to beat the use of the Euclidean algorithm: Fully factorise each number, storing it as a sequence of exponents of primes (so for example 2 is {1}, 4 is {2}, 5 is {0, 0, 1}, 15 is {0, 1, 1}). Then you can calculate gcd(a,b) by taking the min value at each index and multiplying them back out. No idea whether this is faster than Euclid on average, but it might be. Obviously it uses a load more memory.
