[site]: stackoverflow
[post_id]: 408393
[parent_id]: 408358
[tags]: 
Depending on the nature of your actionscript interpreter and the pre-processing done on the shapes, you may see a speed improvement (over the direct approach pointed out by Yuval) by initially creating a second copy of the bitmap/array mirrored diagonally, then using row or string manipulation functions to sum the points on each row and column in single steps. This would be O(2m n) instead of O(n n) [see below], but with more overhead. xSum = 0 ySum = 0 points = 0 for row in matrix ySum += rowX * countpoints(row) points += countpoints(row) for row in mirroredmatrix xSum += rowX * countpoints(row) return (xSum/points, ySum/points) Where countpoints() counts the on-points in a row. This relies on countpoints (which has O(n) runtime) having a lower constant multiplier than the naive approach's runtime (hence above, 'm' being the runtime of countpoints and 'n' being the time for the interpreter to loop through a row). The nature of countpoints() depends on your storage method, which may involve counting characters in a string, or bits in a bitfield.
