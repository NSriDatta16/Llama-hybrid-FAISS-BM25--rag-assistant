[site]: stackoverflow
[post_id]: 5584580
[parent_id]: 5581548
[tags]: 
Okay, somehow I kind of found the answer, not for all though. Question 1: Thx @noob comment, "Whenever you wait and notify on an object (in this case, lock), you need to execute these actions in a synchronized block". So I just make the lock in a synchronize block. Like this: int gx = (int)Point2D.this.X(); int gy = (int)Point2D.this.Y(); Object lock = new Object(); player.move(gx,gy,lock); synchronized(lock){ try { lock.wait(); } catch (InterruptedException ex){} } Of course, when the lock giving notify also give it a synchronized block. But it's made a warning: "Synchronization on non-final field". It is because there is a chance the lock can be modified by other process, and will make a deadlock, because the lock is lose the reference. Question 2: No. The land is still active. So it's using the resource. The thread still active while waiting the player thread died. You can use number 1 technique by making the thread wait. Thread that found wait() will give the monitor to other thread. it's kind of sleep, and wake up when object that invoke wait() invoke notify(). Question 3: Kind of found the answer, but still haven't trying it, so I won't answer. Question 4: Yeah. It is possible. Make the player have a queue of lock instead of a lock. So in move(), instead of setting lock, it's adding lock to the queue. And the notify also do the same, it's only notify the front lock. After front lock, give a notify. Question 5: Thx to @Gandalf answer, but still don't know whether I'm doing right or not. Don't know how to test it.
