[site]: stackoverflow
[post_id]: 3714359
[parent_id]: 3714344
[tags]: 
Yes, there is a much cleaner way to do this: one table tracks the relations from Section to Section and enforces them as foreign key constraints one table tracks the relations from Section to Content and enforces them as foreign key constraints one table tracks the relations from Content to Section and enforces them as foreign key constraints one table tracks the relations from Content to Content and enforces them as foreign key constraints This is much cleaner than a single table with overloaded IDs that cannot be enforced by foreign key constraints. The fact that the data modeling, nor the domain modeling patterns, never mention a pattern like the one you describe should be your first alarm bell. The second alarm should be that the engine cannot enforce the constraints you envision and you have to dwell into triggers. Having four distinct relationships modeled in one table brings no elegance to the model, it only adds obfuscation. Relational model is not C++: it has no inheritance, it has no polymorphism, it has no overloading. Trying to enforce a OO mind set into data modeling has led many a fine developers into a mud of unmaintainable trigger mesh of on-disk table-like bits vaguely resembling 'data'.
