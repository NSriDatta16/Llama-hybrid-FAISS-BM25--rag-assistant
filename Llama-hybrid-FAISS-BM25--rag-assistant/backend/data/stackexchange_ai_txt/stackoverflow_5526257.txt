[site]: stackoverflow
[post_id]: 5526257
[parent_id]: 
[tags]: 
PyObjC's about page explains potential advantages the bridge offers to developers in either language. The bridge allows custom Objective-C and Python code to be co-mingled (nearly) painlessly, so that each can be used where its strengths are greatest. The most obvious advantage for Python developers is that it allows them to write applications for Mac OS X with native appearance and behaviors. The use of Apple's frameworks facilitates the creation of the expected user experience, while familiar Python modules are always available when needed. A Python class can be a subclass of any framework class. Objective-C users may find some of their models and application logic to be easier to express succinctly in Python. In particular, the setup and access of NSArray and NSDictionary objects can be cumbersome. The bridge makes a Python list or dictionary able to be used any place that its Cocoa counterpart is expected. Python's literal lists and dictionaries, list comprehensions, iteration, and dictionary lookup syntax make sometimes awkward Objective-C constructions into elegant and readable code. Python code that uses the bridge will also manage the memory of any Cocoa object it uses. An excellent five-part tutorial, written by Will Larson, can be found on his website, titled "An Epic Introduction to PyObjC and Cocoa" . Like the bridge itself, the tutorial serves more as an introduction for Python users to Cocoa than the reverse, but is nonetheless worth reading for anyone who wants to use PyObjC. The PyObjC Introduction goes through the basics of using the bridge. Where syntax differs, the bridge tends towards making Python code more like Objective-C code. Two syntax differences are worth singling out here: method calls and instance variable access, which can cause confusion for users of the bridge. Objective-C's message-call syntax uses positional arguments, but the name of the method is actually interleaved with the arguments: // The name of this method is "actOnArg:usingOtherArg:andThisOneToo:" [anInstance actOnArg:arg1 usingOtherArg:arg2 andThisOneToo:arg3]; It seems obvious, then, to use Python's keyword argument feature to emulate this: // The name of this method is "actOnArg", and it has keyword arguments anInstance.actOnArg(arg1, usingOtherArg=arg2, andThisOneToo=arg3) However, because keyword arguments ignore position, it is not feasible to make this kind of translation. To Python, the following call is equivalent to the preceding one: anInstance.actOnArg(arg1, andThisOneToo=arg3, usingOtherArg=arg2) while the Objective-C call: // The name of this method is "actOnArg:andThisOneToo:usingAnotherArg:" [anInstance actOnArg:arg1 andThisOneToo:arg3 usingOtherArg:arg2]; refers to an entirely different method than the original example. PyObjC's solution is to use underscores in place of colons in method names: anInstance.actOnArg_usingOtherArg_andThisOneToo_(arg1, arg2, arg3) which unambiguously represents the name of the Objective-C method. This, unavoidably, is one of the main warts of the bridge -- the verbosity of Cocoa method names sometimes causes unwieldy Python calls: NSTimer.scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_(1.0, self, objc.selector(self.actOnTimer_, signature='v@:@'), timerInfoDict, False) As for instance variables, Objective-C has a separate namespace in each class for instance variables and method names, where Python has only one. A class in Objective-C can, and by convention does, have a method with the same name as an instance variable, which is a getter for that variable: @interface MyObject : NSObject { int someIvar; } - (int)someIvar; - (void)setSomeIvar:(int)newVal; // The setter method for this ivar Whereas this is impossible in Python. Python convention is to access instance variables directly, using the dot syntax: anInstance.someIvar anInstance.someIvar = 10 This especially causes confusion with the Objective-C 2.0 dot syntax, which is sugar for the standard accessor method: anInstance.someIvar; // Equivalent to [anInstance someIvar]; anInstance.someIvar = 10; // Equivalent to [anInstance setSomeIvar:10]; PyObjC is forced to have its own convention, which is to give the ivar the name of the setter method, but prefixed with a single underscore. The convenience function objc.synthesize("someIvar") will create the ivar, the setter method, and the getter method with the expected names. The PyObjC source is available and well worth a perusal; it especially repays investigation when getting into the trickier areas of the bridge, such as Objective-C methods which use out or plain-C parameters. In addition, the default Apple installation of PyObjC lags behind the latest version. On Snow Leopard particularly, this means that the bridge does not include some information needed to use new features of Apple's frameworks. (See "Problem with openPanelDidEnd" here on SO for an example.) That information is fortunately easily updated.
