[site]: stackoverflow
[post_id]: 1611208
[parent_id]: 1610361
[tags]: 
Wait. Stop. Msaeed's answer is correct, line-by-line, but fails to emphasize the real problem. You are either failing to think like a computer or you are assuming way too much magic per line of code. Please don't take it as an insult -- it is a very easy mistake to make and one that just about every programmer makes when new to an environment (I made some truly fantastic magical assumptions when starting with Objective-C in 1989). Let's reconsider the situations. SITUATION #1: ... delete irrelevant code ... foo = fooToo; This is a simple assignment. Whatever foo contained before this -- a reference to an object in your case -- will now be overwritten by the value of fooToo . There is no magic. There is no additional method execution or lines of code involved. If foo contained a reference to a retained object pior to that line of code. The reference will be overwritten. If you need to release foo before overwriting the reference, do so, but that is orthogonal to the assignment. SITUATION #2: ... delete irrelevant code ... -(void)dealloc{ [super dealloc]; [foo release]; } Play computer; you are asking super to dealloc and then assuming an instance variable is valid after super has been deallocated. Bad news. Boom. There is no magic here. foo is a reference through self to the instance variable. The -dealloc destroys self and, thus, foo is no longer valid. (I believe the static analyzer will catch this. If not, it should.) SITUATION #3: See #2. This is the exact same problem. You are accessing an instance variable of an instance that is no longer valid. SITUATION #4: self.foo = bar; Is the exact same thing as: `[self setFoo: bar]; (Barring any setter= shenanigans) Thus, the key difference is whatever the implementation -- hand written or @synthesized -- of -setFoo: does. In your case, it retain s bar. Which is different than foo = bar; in that no retain happens; it is just an assignment of the reference to bar . I would highly recommend that you revisit the Objective-C introduction documentation. It'll help. However, I would also encourage you to step back and really think through exactly what each line of code in the above situations are doing. There is no magic and the actual behavior is very straightforward.
