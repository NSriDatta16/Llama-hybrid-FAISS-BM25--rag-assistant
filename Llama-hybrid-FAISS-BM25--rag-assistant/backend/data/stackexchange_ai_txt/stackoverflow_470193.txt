[site]: stackoverflow
[post_id]: 470193
[parent_id]: 48605
[tags]: 
There are some excellent answers here, but if you're looking for a concrete reason, look no further than Unit Testing. Consider that you want to test a method in the business logic that retrieves the current tax rate for the region where a transaction occurrs. To do this, the business logic class has to talk to the database via a Repository: interface IRepository { T Get(string key); } class TaxRateRepository : IRepository { protected internal TaxRateRepository() {} public TaxRate Get(string key) { // retrieve an TaxRate (obj) from database return obj; } } Throughout the code, use the type IRepository instead of TaxRateRepository. The repository has a non-public constructor to encourage users (developers) to use the factory to instantiate the repository: public static class RepositoryFactory { public RepositoryFactory() { TaxRateRepository = new TaxRateRepository(); } public static IRepository TaxRateRepository { get; protected set; } public static void SetTaxRateRepository(IRepository rep) { TaxRateRepository = rep; } } The factory is the only place where the TaxRateRepository class is referenced directly. So you need some supporting classes for this example: class TaxRate { public string Region { get; protected set; } decimal Rate { get; protected set; } } static class Business { static decimal GetRate(string region) { var taxRate = RepositoryFactory.TaxRateRepository.Get(region); return taxRate.Rate; } } And there is also another other implementation of IRepository - the mock up: class MockTaxRateRepository : IRepository { public TaxRate ReturnValue { get; set; } public bool GetWasCalled { get; protected set; } public string KeyParamValue { get; protected set; } public TaxRate Get(string key) { GetWasCalled = true; KeyParamValue = key; return ReturnValue; } } Because the live code (Business Class) uses a Factory to get the Repository, in the unit test you plug in the MockRepository for the TaxRateRepository. Once the substitution is made, you can hard code the return value and make the database unneccessary. class MyUnitTestFixture { var rep = new MockTaxRateRepository(); [FixtureSetup] void ConfigureFixture() { RepositoryFactory.SetTaxRateRepository(rep); } [Test] void Test() { var region = "NY.NY.Manhattan"; var rate = 8.5m; rep.ReturnValue = new TaxRate { Rate = rate }; var r = Business.GetRate(region); Assert.IsNotNull(r); Assert.IsTrue(rep.GetWasCalled); Assert.AreEqual(region, rep.KeyParamValue); Assert.AreEqual(r.Rate, rate); } } Remember, you want to test the business logic method only, not the repository, database, connection string, etc... There are different tests for each of those. By doing it this way, you can completely isolate the code that you are testing. A side benefit is that you can also run the unit test without a database connection, which makes it faster, more portable (think multi-developer team in remote locations). Another side benefit is that you can use the Test-Driven Development (TDD) process for the implementation phase of development. I don't strictly use TDD but a mix of TDD and old-school coding.
