[site]: stackoverflow
[post_id]: 3457543
[parent_id]: 3457497
[tags]: 
The conversion is standard. The relevant part of the ISO C99 standard is in section 6.8.6.4, paragraph 3: If the expression has a type different from the return type of the function in which it appears, the value is converted as if by assignment to an object having the return type of the function. So it's implicitly converted, in the same way that it is in this assignment: float f = 3.0f; int i; i = f; The allowed conversions are: the return type has qualified or unqualified arithmetic type and the expression has arithmetic type; the return type has a qualified or unqualified version of a structure or union type compatible with the type of the expression; the return type and expression are both pointers to qualified or unqualified versions of compatible types, and the return type has all the qualifiers of the expression type; one of the return type or expression is a pointer to an object or incomplete type and the other is a pointer to a qualified or unqualified version of void , and the return type has all the qualifiers of the expression type; the return type is a pointer and the expression is a null pointer constant; or the return type has type _Bool and the expression is a pointer. (Your example matches the first one - both int and float are arithmetic types)
