[site]: stackoverflow
[post_id]: 3317022
[parent_id]: 650131
[tags]: 
I like the idea of Adrian to use the characters rather than images. But I don't like the box, it need only the checkmark itself (@"\u2713"). I draw a box (a rounded box) programmatically and place an UILabel contains the checkmark inside it. This way of implementation makes it easy to use the custom view in any application without care about any dependent resource. You can also customize the color of the checkmark, the rounded box and the background with ease. Here's the complete code: #import @class CheckBoxView; @protocol CheckBoxViewDelegate - (void) checkBoxValueChanged:(CheckBoxView *) cview; @end @interface CheckBoxView : UIView { UILabel *checkMark; bool isOn; UIColor *color; NSObject *delegate; } @property(readonly) bool isOn; @property(assign) NSObject *delegate; - (void) drawRoundedRect:(CGRect) rect inContext:(CGContextRef) context; @end #import "CheckBoxView.h" #define SIZE 30.0 #define STROKE_WIDTH 2.0 #define ALPHA .6 #define RADIUS 5.0 @implementation CheckBoxView @synthesize isOn, delegate; - (id)initWithFrame:(CGRect)frame { if ((self = [super initWithFrame:CGRectMake(frame.origin.x, frame.origin.y, SIZE, SIZE)])) { // Initialization code } //UIColor *color = [UIColor blackColor]; color = [[UIColor alloc] initWithWhite:.0 alpha:ALPHA]; self.backgroundColor = [UIColor clearColor]; checkMark = [[UILabel alloc] initWithFrame:CGRectMake(STROKE_WIDTH, STROKE_WIDTH, SIZE - 2 * STROKE_WIDTH, SIZE - 2*STROKE_WIDTH)]; checkMark.font = [UIFont systemFontOfSize:25.]; checkMark.text = @"\u2713"; checkMark.backgroundColor = [UIColor clearColor]; checkMark.textAlignment = UITextAlignmentCenter; //checkMark.textColor = [UIColor redColor]; [self addSubview:checkMark]; [checkMark setHidden:TRUE]; isOn = FALSE; return self; } // Only override drawRect: if you perform custom drawing. // An empty implementation adversely affects performance during animation. - (void)drawRect:(CGRect)rect { // Drawing code CGRect _rect = CGRectMake(STROKE_WIDTH, STROKE_WIDTH, SIZE - 2 * STROKE_WIDTH, SIZE - 2*STROKE_WIDTH); [self drawRoundedRect:_rect inContext:UIGraphicsGetCurrentContext()]; [checkMark setHidden:!isOn]; } - (void)dealloc { [checkMark release]; [color release]; [super dealloc]; } - (void) drawRoundedRect:(CGRect) rect inContext:(CGContextRef) context{ CGContextBeginPath(context); CGContextSetLineWidth(context, STROKE_WIDTH); CGContextSetStrokeColorWithColor(context, [color CGColor]); CGContextMoveToPoint(context, CGRectGetMinX(rect) + RADIUS, CGRectGetMinY(rect)); CGContextAddArc(context, CGRectGetMaxX(rect) - RADIUS, CGRectGetMinY(rect) + RADIUS, RADIUS, 3 * M_PI / 2, 0, 0); CGContextAddArc(context, CGRectGetMaxX(rect) - RADIUS, CGRectGetMaxY(rect) - RADIUS, RADIUS, 0, M_PI / 2, 0); CGContextAddArc(context, CGRectGetMinX(rect) + RADIUS, CGRectGetMaxY(rect) - RADIUS, RADIUS, M_PI / 2, M_PI, 0); CGContextAddArc(context, CGRectGetMinX(rect) + RADIUS, CGRectGetMinY(rect) + RADIUS, RADIUS, M_PI, 3 * M_PI / 2, 0); CGContextClosePath(context); CGContextStrokePath(context); } #pragma mark Touch - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event{ UITouch *touch = [touches anyObject]; CGPoint loc = [touch locationInView:self]; if(CGRectContainsPoint(self.bounds, loc)){ isOn = !isOn; //[self setNeedsDisplay]; [checkMark setHidden:!isOn]; if([delegate respondsToSelector:@selector(checkBoxValueChanged:)]){ [delegate checkBoxValueChanged:self]; } } }
