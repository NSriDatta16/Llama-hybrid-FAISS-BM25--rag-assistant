[site]: stackoverflow
[post_id]: 316181
[parent_id]: 
[tags]: 
Why does the compiler choose bool over string for implicit typecast of L""?

Having recently introduced an overload of a method the application started to fail. Finally tracking it down, the new method is being called where I did not expect it to be. We had setValue( const std::wstring& name, const std::wstring& value ); std::wstring avalue( func() ); setValue( L"string", avalue ); std::wstring bvalue( func2() ? L"true", L"false" ); setValue( L"bool", bvalue ); setValue( L"empty", L"" ); It was changed so that when a bool value is stored we use the same strings (internal data storage of strings) setValue( const std::wstring& name, const std::wstring& value ); setValue( const std::wstring& name, const bool& value ); std::wstring avalue( func() ); setValue( L"string", avalue ); setValue( L"bool", func2() ); setValue( L"empty", L"" ); The problem with L"" is that it is implicitly casting and previously it was happy to be a std::wstring, but not it prefers to be a bool. The MSVC compiler does not complain, or raise warning, so I'm worried that even if I "fix" the setValue( L"empty", L"" ); to be setValue( L"empty", std::wstring() ); somebody else may come later and simply use setValue( L"empty", L"" ); and have to track down this issue again. We thought to use explicit on the method but it is not a valid keyword for this usage. Is there some way to get the compiler to complain about this, or otherwise prevent the issue? Otherwise I'm thinking to change the name of the method which takes a bool to ensure it can't make an incorrect guess.
