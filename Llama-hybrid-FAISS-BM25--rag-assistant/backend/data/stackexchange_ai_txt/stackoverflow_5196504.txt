[site]: stackoverflow
[post_id]: 5196504
[parent_id]: 5195242
[tags]: 
I'm guessing that here the 'compiler' ('synthesizer') would automatically infer that it needs 3 bits of storage length, as this integer is ranged with values between 0 and 5 According to the spec it should, but it is not required. From IEEE 1076.6-2004: 1.3 Terminology The word shall indicates mandatory requirements strictly to be followed in order to conform to the standard and from which no deviation is permitted (shall equals is required to). The word should is used to indicate that a certain course of action is preferred but not necessarily required; 8.3.1.2 Integer Types It is recommended that a synthesis tool should convert a signal or variable that has an integer subtype indication to a corresponding vector of bits. If the range contains no negative values, the item should have an unsigned binary representation. If the range contains one or more negative values, the item should have a twos-complement implementation. The vector should have the smallest width consistent with these representations. The synthesis tool shall support integer types and positive, negative, and unconstrained (universal) integers whose bounds lie within the range –2 147 483 648 to +2 147 483 647 inclusive (the range that successfully maps 32 bit twos-complement numbers) Example: “INTEGER range 9 to 10” should be synthesized using an equivalent vector length of 4 bits, just as if it had been defined with a subtype indication of “INTEGER range 0 to 15”. I can say definitively at least one synthesis tool does not use range in this manner as I had to debug the formal verification miscompares. For Xilinx FPGAs, the XST synthesis report will tell which storage elements have unused bits, but not simple wires.
