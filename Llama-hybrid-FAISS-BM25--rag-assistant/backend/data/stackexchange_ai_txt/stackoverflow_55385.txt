[site]: stackoverflow
[post_id]: 55385
[parent_id]: 50394
[tags]: 
There's nothing wrong with using a command line utility to do what you want. If you put a nice wrapper around the service, you can implement the internals however you want! For example: class Whois(object): _whois_by_query_cache = {} def __init__(self, query): """Initializes the instance variables to defaults. See :meth:`lookup` for details on how to submit the query.""" self.query = query self.domain = None # ... other fields. def lookup(self): """Submits the `whois` query and stores results internally.""" # ... implementation Now, whether or not you roll your own using urllib, wrap around a command line utility (like you're doing), or import a third party library and use that (like you're saying ), this interface stays the same. This approach is generally not considered ugly at all -- sometimes command utilities do what you want and you should be able to leverage them . If speed ends up being a bottleneck, your abstraction makes the process of switching to a native Python implementation transparent to your client code. Practicality beats purity -- that's what's Pythonic. :)
