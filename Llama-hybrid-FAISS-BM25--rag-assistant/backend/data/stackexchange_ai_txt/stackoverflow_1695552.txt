[site]: stackoverflow
[post_id]: 1695552
[parent_id]: 1695452
[tags]: 
I think this solution is the fastest, since it iterates only once, albeit on the longer list and exits before finishing the iteration if a match is found. (Edit: However, it is not as succinct or as fast as Alex's latest solution) def ck(l1,l2): i,j = 0,len(l1) for e in l2: if e == l1[i]: i += 1 if i == j: return True return False An improvement was suggested by Anurag Uniyal (see comment) and is reflected in the showdown below. Here are some speed results for a range of list size ratios (List l1 is a 10-element list containing random values from 1-10. List l2 ranges from 10-1000 in length (and also contain random values from 1-10). Code that compares run times and plots the results: import random import os import pylab import timeit def paul(l1,l2): i = 0 j = len(l1) try: for e in l2: if e == l1[i]: i += 1 except IndexError: # thanks Anurag return True return False def jed(list1, list2): try: for num in list1: list2 = list2[list2.index(num):] except: return False else: return True def alex(L1,L2): # wow! i2 = iter(L2) return all(lookfor in i2 for lookfor in L1) from itertools import dropwhile from operator import ne from functools import partial def thc4k_andrea(l1, l2): it = iter(l2) try: for e in l1: dropwhile(partial(ne, e), it).next() return True except StopIteration: return False ct = 100 ss = range(10,1000,100) nms = 'paul alex jed thc4k_andrea'.split() ls = dict.fromkeys(nms) for nm in nms: ls[nm] = [] setup = 'import test_sublist as x' for s in ss: l1 = [random.randint(1,10) for i in range(10)] l2 = [random.randint(1,10) for i in range(s)] for nm in nms: stmt = 'x.'+nm+'(%s,%s)'%(str(l1),str(l2)) t = timeit.Timer(setup=setup, stmt=stmt).timeit(ct) ls[nm].append( t ) pylab.clf() for nm in nms: print len(ss), len(ls[nm]) pylab.plot(ss,ls[nm],label=nm) pylab.legend(loc=0) pylab.xlabel('length of l2') pylab.ylabel('time') pylab.savefig('cmp_lsts.png') os.startfile('cmp_lsts.png') results:
