[site]: stackoverflow
[post_id]: 3531820
[parent_id]: 3479270
[tags]: 
I guess I somewhat figured this out. The main method to use is jvmti->GetLineNumberTable(...), which fills up a jvmtiLineNumberEntry array. Given the BCI line number n (which is to be mapped to a source line number), one can test for which int i is: jvmtiLineNumberEntryArray[i] One catch is that AsyncGetCallTrace, for some reason, consistently returns weird BCIs, so although the mapping gives precise source code line numbers, they are still not accurate , because the original BCIs are not accurate. Why this is, I do not know. I was hoping to use the Sun Studio profiler, which also uses AsyncGetCallTrace, to test whether the returned line numbers would be the same as they are for my profiler. In that case, the AsyncGetCallTrace function is inaccurate. But so far, using the Sun Studio turned into a challenge of its own. IF ANYONE KNOWS HOW TO USE THIS TOOL, PLEASE HELP! A bigger catch is that Java methods are often inlined, so line numbers do not always map correctly. In fact, this MIGHT be the cause of the problem described in the paragraph above, although this seems unlikely based on the numbers I've been seeing. Here is some information about solving the inlining problem: http://developer.amd.com/documentation/articles/pages/JVMTIEventPiggybacking.aspx
