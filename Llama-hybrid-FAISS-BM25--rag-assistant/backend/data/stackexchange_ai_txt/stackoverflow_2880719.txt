[site]: stackoverflow
[post_id]: 2880719
[parent_id]: 2880682
[tags]: 
I don't understand what you are asking. F# does not use 'threads behind the scenes', or at least no more than any .NET process does. In fact F#'s async facilities make it much easier to write non-blocking I/O programs that do not consume threads (as compared to C#/VB which has a more difficult threadless/non-blocking programming model). (And, of course, typically you don't just pick one arbitrary aspect to compare two things and then decide 'X is better than Y'. There is more to a programming language than just a threading/process model.) You may enjoy reading http://blogs.msdn.com/dsyme/archive/2010/02/15/async-and-parallel-design-patterns-in-f-part-3-agents.aspx The final three paragraphs are worth quoting: Indeed, there are few other .NET or JVM-based languages that support lightweight reactive agents at all – in early .NET it was said to be “impossible” because of the costs of threads. In this context, F#’s integration of “async { ... }” in 2007 can be seen as somewhat of a breakthrough in applied language design – it allows lightweight, compositional async programming and reactive agents in the context of an industrially accepted and interoperable programming platform. Along with the Axum language prototype (which has been influential on F#), F# has proven that an asynchronous language feature is a feasible way to break through the logjam of “do we make threads lightweight or not” that currently bedevils industrial runtime system design. F# async programming can be seen as an implementation of resumptions, and there are many precursors here, for example OCaml delimited continuations, Haskell embeddings of monadic concurrency and papers emphasising the importance of resumptions with regard to concurrency. You can use F# asynchronous agents on .NET 2.0, 3.5, 4.0, on Linux/Mono/Mac and on Silverlight. Indeed, you can even use F# async programming when F# is translated to Javascript using the WebSharper platform. Enjoy!
