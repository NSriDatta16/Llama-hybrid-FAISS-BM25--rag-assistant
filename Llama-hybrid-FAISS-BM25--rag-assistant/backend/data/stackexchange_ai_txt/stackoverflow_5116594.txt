[site]: stackoverflow
[post_id]: 5116594
[parent_id]: 5115043
[tags]: 
So. after reformatting your code, I'll comment on it: First lets have a look at code 2 float inverse[16]; glMatrixMode(GL_MODELVIEW); glPushMatrix(); Okay, operating on the modelview matrix, pushing the modelview matrix stack. glMultMatrixf(m_mat); Multiplying with a matrix m_mat OpenGLUtility::InverseMatrix(m_mat, inverse); Inverting itâ€¦ glMultMatrixf(inverse); And there you multiply it back, so you've done M * M^-1 = I of course this only works if mat_m was invertible at all. But if it is invertible then those two operations cancel out nothing will happen. BTW: You're missing a closing glPopMatrix(); Then this: glBegin(GL_LINES); glColor3f(0.0,1.0, 0.0); glVertex4f( tOrigin[0], tOrigin[1], tOrigin[2], tOrigin[3] ); glVertex4f( tNormal[0]*tOrigin[3] + tOrigin[0], tNormal[1]*tOrigin[3] + tOrigin[1], tNormal[2]*tOrigin[3] + tOrigin[2], tOrigin[3] ); glEnd(); glMultMatrixf(m_mat); What are you expecting that last glMultMatrix to do? Let me guess? You somehow expect OpenGL to multiply that vector with the matrix (it does this) and returning it back to you (this is does not , at least not in this way). Now here's some important thing for you to know: OpenGL IS NOT A MATH LIBRARY In fact all matrix manipulation functions have been removed from OpenGL-4, so that people no longer to things with OpenGL that it's not been purposed for. If the first code works for you: Fine! This is exactly how it's supposed to be done. However it is not entirely clear what exactly you are trying to achieve; there might be a more elegant or straigtforward way of doing it.
