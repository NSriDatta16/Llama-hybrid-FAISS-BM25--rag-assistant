[site]: stackoverflow
[post_id]: 477742
[parent_id]: 476589
[tags]: 
EDITED: I removed the generic implementation and cleaned up this response to fit better to the originally stated problem. NOTE: The answer by Marc Gravell is probably the most concise if you just want the parsed value given the type. The answer below shows you how to get at the method (i.e., the MethodInfo object and how to invoke it). The following should work, at least for types that implement public static bool TryParse(string, T value): public static class Parsing { static MethodInfo findTryParseMethod(Type type) { //find member of type with signature 'static public bool TryParse(string, out T)' BindingFlags access = BindingFlags.Static | BindingFlags.Public; MemberInfo[] candidates = type.FindMembers( MemberTypes.Method, access, delegate(MemberInfo m, object o_ignored) { MethodInfo method = (MethodInfo)m; if (method.Name != "TryParse") return false; if (method.ReturnParameter.ParameterType != typeof(bool)) return false; ParameterInfo[] parms = method.GetParameters(); if (parms.Length != 2) return false; if (parms[0].ParameterType != typeof(string)) return false; if (parms[1].ParameterType != type.MakeByRefType()) return false; if (!parms[1].IsOut) return false; return true; }, null); if (candidates.Length > 1) { //change this to your favorite exception or use an assertion throw new System.Exception(String.Format( "Found more than one method with signature 'public static bool TryParse(string, out {0})' in type {0}.", type)); } if (candidates.Length == 0) { //This type does not contain a TryParse method - replace this by your error handling of choice throw new System.Exception(String.Format( "Found no method with signature 'public static bool TryParse(string, out {0})' in type {0}.", type)); } return (MethodInfo)candidates[0]; } public static bool TryParse(Type t, string s, out object val) { MethodInfo method = findTryParseMethod(t); //can also cache 'method' in a Dictionary if desired object[] oArgs = new object[] { s, null }; bool bRes = (bool)method.Invoke(null, oArgs); val = oArgs[1]; return bRes; } //if you want to use TryParse in a generic syntax: public static bool TryParseGeneric (string s, out T val) { object oVal; bool bRes = TryParse(typeof(T), s, out oVal); val = (T)oVal; return bRes; } } Use the following test code: public bool test() { try { object oVal; bool b = Parsing.TryParse(typeof(int), "123", out oVal); if (!b) return false; int x = (int)oVal; if (x!= 123) return false; } catch (System.Exception) { return false; } try { int x; bool b = Parsing.TryParseGeneric ("123", out x); if (!b) return false; if (x != 123) return false; } catch (System.Exception) { return false; } try { object oVal; bool b = Parsing.TryParse(typeof(string), "123", out oVal); //should throw an exception (//no method String.TryParse(string s, out string val) return false; } catch (System.Exception) { //should throw an exception } return true; } } And use this in your case: //input: string s, Config Type tNum = Type.GetType(Config.numberType); object oVal; bool ok = Parsing.TryParse(tNum, s, out oVal); //oVal is now of type tNum and its value is properly defined if ok == true About the use of var: you may have a misconception of what var does: It is not a "variant" type (the type object already is used for that) but moves the declaration syntax for the type to the assignment's right side. The following declarations are equivalent: var i = 1; //the compiler infers the type from the assignment, type of i is int. int i = 1; //type of i is int via declaration The primary use of var is allowing to create anonymous types : var anon = new { Name = "abc", X = 123 };
