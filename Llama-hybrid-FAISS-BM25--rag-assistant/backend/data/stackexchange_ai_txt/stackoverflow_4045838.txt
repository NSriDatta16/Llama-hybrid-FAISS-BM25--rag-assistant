[site]: stackoverflow
[post_id]: 4045838
[parent_id]: 4035088
[tags]: 
Firstly thanks to Noah Roberts ' answer which deserves as an upvote for being the inspiration to this answer. Following on from his answer I extracted and refactored boost::mpl::for_each and boost::mpl::range to obtain what I believe is the minimal complete definition which satisfies the question's criteria. It has no longer has any dependancy on Boost and is used as such: struct eat_fruit; // As Noah's answer void eatAllFruit() { EnumIteration ::for_each( eat_fruit() ); } My EnumIteration struct is defined as below, and I welcome any comments or improvements. The only notable difference to the Boost version is that the range excludes the final enum value (i.e. eTotal ), unlike boost::mpl::range which includes it. template struct EnumIteration { private: template struct Iterator { static const ENUM value = N; typedef Iterator ( N+1 ) > next; operator ENUM() const { return static_cast ( this->value ); } }; template struct End { enum { value = false }; }; template<> struct End > { enum { value = true }; }; template struct for_each_impl { template static void execute( Iterator*, F ) {} }; template<> struct for_each_impl { template static void execute( Iterator*, F f ) { f( typename Iterator() ); typedef typename Iterator::next next; for_each_impl ::value >::execute( static_cast ( 0 ), f ); } }; public: template static void for_each( F f ) { typedef Iterator first; for_each_impl ::value >::execute( static_cast ( 0 ), f ); } };
