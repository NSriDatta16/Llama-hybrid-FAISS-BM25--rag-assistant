[site]: stackoverflow
[post_id]: 4224242
[parent_id]: 
[tags]: 
Implement a scala collection so that map, filter, etc. produce the right type

I'm trying to implement a default valued map , and I'd like filters, maps, etc. over a DefaultingMap to also produce a DefaultingMap whenever possible. Here's my initial implementation: class DefaultingMap[K, V](defaultValue: => V) extends mutable.HashMap[K, V] with mutable.MapLike[K, V, DefaultingMap[K, V]] { override def empty = new DefaultingMap[K, V](defaultValue) override def default(key: K): V = { val result = this.defaultValue this(key) = result result } } I get objects of type DefaultingMap when I use filter , but not when I use map : scala> val counter = new DefaultingMap[Char, Int](0) counter: DefaultingMap[Char,Int] = Map() scala> for (c counter.filter{case (k, v) => v > 1} res1: DefaultingMap[Char,Int] = Map((a,2), (b,5)) scala> counter.map{case (k, v) => (k, v * 2)} res2: scala.collection.mutable.HashMap[Char,Int] = Map((a,4), (c,2), (b,10)) The difference between these two methods seems to be that map takes an implicit CanBuildFrom . So I gather that I need to have an implicit def somewhere to provide the CanBuildFrom . My first intuition was to do what's done in HashMap: object DefaultingMap extends generic.MutableMapFactory[DefaultingMap] { def empty[K, V]: DefaultingMap[K, V] = // Not possible! implicit def canBuildFrom[K, V]: generic.CanBuildFrom[Coll, (K, V), DefaultingMap[K, V]] = new MapCanBuildFrom[K, V] } I believe this would get it to compile, but this approach won't work because it's impossible to define the empty method - you need to know what the defaultValue should be. If I could define the CanBuildFrom in the class itself, instead of the companion object, I would be okay because the defaultValue is available there. How can I get this to work?
