[site]: stackoverflow
[post_id]: 5448611
[parent_id]: 5448335
[tags]: 
Here's a Clojure specific answer, but I expect most of it would be equally applicable to other Lisps as well. Clojure has its own testing framework called clojure.test . This lets you simply define assertions with the "is" macro: (deftest addition (is (= 4 (+ 2 2))) (is (= 7 (+ 3 4)))) In general I find that unit testing in Clojure/Lisp follows very similar best practices to testing for other languages. It's the sample principle: you want to write focused tests that confirm your assumptions about a specific piece of code behaviour. The main differences / features I've noticed in Clojure testing are: Since Clojure encourages functional programming, it tends to be the case that tests are simpler to write because you don't have to worry as much about mutable state - you only need to confirm that the output is correct for a given input, and not worry about lots of setup code etc. Macros can be handy for testing - e.g. if you want to generate a large number of tests that follow a similar pattern programatically It's often handy to test at the REPL to get a quick check of expected behaviour. You can then copy the test code into a proper unit test if you like. Since Clojure is a dynamic language you may need to write some extra tests that check the type of returned objects. This would be unnecessary in a statically typed language where the compiler could provide such checks.
