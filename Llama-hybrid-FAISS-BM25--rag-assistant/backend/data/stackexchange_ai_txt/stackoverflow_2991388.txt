[site]: stackoverflow
[post_id]: 2991388
[parent_id]: 2989979
[tags]: 
For your table, yes, 124 bytes does appear to be the correct row size, and since your clustered index is unique, you shouldn't be wasting space on a uniqueifier. So let's consider how it fits together: Page size = 8 KB (8192 bytes) Header = 96 bytes Available for data = 8096 bytes Row size (fixed data) = 124 bytes Header = 4 bytes Null bitmap = 5 bytes (for 21 columns) Variable data size = 2 (for 0 variable columns) Total = 135 bytes Rows per page = (8096 / 137) = 59 Total rows = 117076054 Total pages = 117076054 / 59 = 1984440 Actual size = 1984440 * 8 KB = 15875520 KB (Note: calculations are derived from Estimating the Size of a Clustered Index ) So you can see from this that the absolute minimum ratio you'd be able to achieve (using the more simplistic math of total data size / max row size ) is approximately 139 bytes per row. Of course, you say that you're seeing these statistics immediately after inserting a bunch of data - data for which the clustering key is not on an auto-incrementing ( IDENTITY or NEWSEQUENTIALID ) column and will therefore may not be inserted in a truly sequential fashion. If that's the case, you are probably suffering from a huge number of page splits and need to defragment the clustered index: ALTER INDEX idx ON OHLC_Bar_Trl REORGANIZE -- or REBUILD Note: I'm not sure if this command is available on SQL Server 2005. The older syntax is: DBCC INDEXDEFRAG('MyDB', 'OHLC_Bar_Trl', indexnum) You may also need to shrink the database to reclaim all of the lost space (although most people will recommend against shrinking the data, unless you have a very good reason to do so).
