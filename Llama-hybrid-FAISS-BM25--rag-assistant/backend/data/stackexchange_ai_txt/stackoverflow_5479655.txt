[site]: stackoverflow
[post_id]: 5479655
[parent_id]: 5479243
[tags]: 
When performing these queries, your performance bottlenecks will generally fall under one of two categories: Getting too much data that you don't need. Making too many round-trips to the database. Your first example may suffer from the first of these. If you look at the data that gets returned from the database, all the data for the Project will be repeated for every Task connected with it. If your Project has a lot of data associated with it, that can cause a lot of overhead. If it's fairly lean, it won't cost that much more. Your second example creates a second round-trip to get the tasks. The additional round-trip introduces extra overhead, but it means that less duplicated data will be returned overall. A single extra round-trip probably isn't a big deal, but if you're doing this for multiple projects, you could easily end up with dozens of unnecessary round-trips. So deciding which way to go will really be a balancing act, based on what your data typically looks like and what you really want from it. In this particular case, you'd be better off with: count = db.Tasks.Count(t => t.AssignedTo.Id == db.Members.FirstOrDefault().Id) ... which will create a single optimized query that just returns the count, with no superfluous data or extra round-trips. So you can see how the answer to questions like this will really depend on what you're trying to get out of the database, exactly. Reponse to Comment If you're trying to get all the tasks related to something, your query should only be getting tasks. There are lots of ways to do this: var memberTasks = db.Tasks.Where(t => t.AssignedTo.Id == memberId).ToList(); or (if you don't know the member's ID yet): var memberTasks = db.Tasks.Where(t => t.AssignedTo.[your criterion])) .ToList(); or (if you want the tasks for multiple members at once): var tasksByMemberId = (from t in db.Tasks where t.AssignedTo.[your criterion]) select new {MemberId = t.AssignedTo.Id, t}) .ToLookup(e => e.MemberId, e => e.t); I could go on. The point is that all of these queries specifically get the Tasks out, without worrying the Member's data. Adding an additional layer of data shouldn't change things much, either: var projectTasks = db.Tasks.Where(t => t.Iteration.Project.Id == projectId).ToList();
