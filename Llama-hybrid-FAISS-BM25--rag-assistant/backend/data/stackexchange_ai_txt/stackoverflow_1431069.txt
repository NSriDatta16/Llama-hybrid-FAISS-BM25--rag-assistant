[site]: stackoverflow
[post_id]: 1431069
[parent_id]: 1430221
[tags]: 
Here's another approach, bouncing between start and start+span in increments of increment, with a helper function: // Goes from start to start + span, and repeats. int ramp(start, increment, span) { static int lastval = start; lastval += increment; lastval = lastval % (span + 1); return lastval; } // Goes from start up to start+span and back down, and repeats. int bounce(start, increment, span) { val = ramp(0, increment, 2*span - 1); if (val > span) val = span - val; return val + start; } Essentially what this is doing is creating a continuously increasing line, then using a MOD function to chop that into a sawtooth, and then reflecting the top half of the sawtooth back down to make a zigzag. Note that, unlike all the other implementations presented (unless I've missed one), this one actually takes you the same distance along the zigzag even if increment doesn't divide evenly -- for example, for a start of 0, a span of 10, and a step of 3, it will go up 3 to 3, up 3 to 6, up 3 to 9, up 1 and down the other 2 to 8, down 3 to 5, down 3 to 2, down 2 and up the other 1 to 1, and so forth -- 3, 6, 9, 8, 5, 2, 1, 4, 7, 10, 7, 4, 1, .... And it also guarantees that the numbers always fall in the right range and does the right thing even if increment is much larger than span or is negative. (You should probably rewrite this to put things like start, increment, and span somewhere in static storage rather than in function arguments, because this will get rather confused if they change, but I'm feeling lazy about that. And, really, it will still fall in the right range and do somewhat sensible things if they change -- you can change increment at any point and it will speed up or slow down without jumping around.)
