[site]: stackoverflow
[post_id]: 5019536
[parent_id]: 4985917
[tags]: 
You need to attach the gesture recognizer to something "up the chain". Don't attach them to the individual nodes; attach them to the UIView (i.e., [[CCDirector sharedDirector] openGLView]). Here's what I did: - (UIPanGestureRecognizer *)watchForPan:(SEL)selector number:(int)tapsRequired { UIPanGestureRecognizer *recognizer = [[[UIPanGestureRecognizer alloc] initWithTarget:self action:selector] autorelease]; recognizer.minimumNumberOfTouches = tapsRequired; [[[CCDirector sharedDirector] openGLView] addGestureRecognizer:recognizer]; return recognizer; } - (void)unwatch:(UIGestureRecognizer *)gr { [[[CCDirector sharedDirector] openGLView] removeGestureRecognizer:gr]; } This particular code is used in a superclass for scene controllers, so the target for the selector is hard-coded to "self", but you could easily abstract that to a passed-in object. Also, you could extrapolate the above to easily create gesture recognizers for taps, pinches, etc. In the subclass for the controller, then, I just do this: - (MyController *)init { if ((self = [super init])) { [self watchForPan:@selector(panning:) number:1]; } return self; } - (void)panning:(UIPanGestureRecognizer *)recognizer { CGPoint p; CGPoint v; switch( recognizer.state ) { case UIGestureRecognizerStatePossible: case UIGestureRecognizerStateBegan: p = [recognizer locationInView:[CCDirector sharedDirector].openGLView]; (do something when the pan begins) break; case UIGestureRecognizerStateChanged: p = [recognizer locationInView:[CCDirector sharedDirector].openGLView]; (do something while the pan is in progress) break; case UIGestureRecognizerStateFailed: break; case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateCancelled: (do something when the pan ends) (the below gets the velocity; good for letting player "fling" things) v = [recognizer velocityInView:[CCDirector sharedDirector].openGLView]; break; } }
