[site]: stackoverflow
[post_id]: 3811540
[parent_id]: 
[tags]: 
Restricting template instantiation using is_integral / BOOST_STATIC_ASSERT

I am trying to implement a free operator function in order to stream values of arbitrary data type into some container class (DataVector). I did a template for basic data types and some specializations for the complex data types used in my project (examples covers std::string only). To make sure the template won't be used with a data type which is not properly handled by the basic implementation, I want to restrict instatiation using type traits (is_integral). Several attempts embedding is_enabled is_integral into the signature of the operator failed and I ended up with the implementation show in the example below. typedef std::vector DataVector; template DataVector& operator ::value == true) { // ... do something return vecArchive; } BOOST_STATIC_ASSERT(false); }; template<> inline DataVector& operator (DataVector& vecArchive, string dataToAppend) { // do something different return vecArchive; }; The problem is that it won't compile, even for integral data types. I guess BOOST_STATIC_ASSERT cannot be used in conditional expressions. How can it be done? Any help would be greatly appreciated. main() { DataVector vecTel; vecTel Compiler error: d:...\TcpSerializable.h(52) : error C2027: use of undefined type 'boost::STATIC_ASSERTION_FAILURE' with [ x=false ] .\Telegram050.cpp(38) : see reference to function template instantiation 'BasisKlassen::DataVector &BasisKlassen::operator
