[site]: stackoverflow
[post_id]: 3272545
[parent_id]: 3146847
[tags]: 
(Disclaimer: I didn't read details on Vanish or the Sybil attack, which may be similar the what comes below) First of all: Email messages are generally quite small, esp. compared to a 50 mb youtube vid you can download 10 times a day or more. On this I base the assumption that storage and bandwidth are not a real concern here. Encryption, in the common sense of the word, introduces parts into your system that are hard to understand, and therefore hard to verify. (think of the typical openssl magic everybody just performs, but 99% of people really understand; if some step X on a HOWTO would say "now go to site X and upload *.cer *.pem and *.csr" to verify steps 1 to X-1, I guess 1 in 10 people will just do it) Combining the two observations, my suggestion for a safe(*) and understandable system: Say you have a message M of 10 kb. Take N times 10 kb from /dev/(u)random , possibly from hardware based random sources, call it K(0) to K(N-1). Use a simple xor operation to calculate K(N) = M^K(0)^K(1)^...^K(N-1) now, by definition M = K(0)^K(1)^...^K(N) i.e. to understand the message you need all K's. Store the K's with N different (more or less trusted) parties, using whatever protocol you fancy, under random 256 bit names. To send a message, send the N links to the K's. To destroy a message, make sure at least one K is deleted. (*) as regards to safety, the system will be as safe as the safest party hosting a K. Don't take a fixed N, don't have a fixed number of K's on a single node per message (i.e. put 0-10 K's of one message on the same node) to make a brute force attack hard, even for those who have access to all nodes storing keys. NB: this of course would require some additional software, as would any solution, but the complexity of the plugins/tools required is minimal.
