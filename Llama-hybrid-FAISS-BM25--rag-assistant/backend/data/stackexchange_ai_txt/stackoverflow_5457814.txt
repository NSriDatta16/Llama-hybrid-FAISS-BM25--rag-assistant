[site]: stackoverflow
[post_id]: 5457814
[parent_id]: 5408154
[tags]: 
I was just about to ask this question myself with my own solution, to provide for the community, so to speak, when I saw you question pop up in the suggestions. My simple and pretty elegant solution, if I say so myself, uses a simple custom decorator. It does nothing to the content it receives, but it alters the element. class App_Form_Decorator_ErrorClass extends Zend_Form_Decorator_Abstract { protected $_placement = null; protected $_options = array( 'class' => 'error' ); public function render( $content ) { $element = $this->getElement(); if( $element->hasErrors() ) { $errorClass = $this->getOption( 'class' ); $currentClass = $element->getAttrib( 'class' ); $element->setAttrib( 'class', ( !empty( $currentClass ) ? $currentClass . ' ' . $errorClass : $errorClass ) ); } return $content; } } Usage: All you need to do is add the decorator before the ViewHelper decorator, and your set. public function init() { $elementDecorators = array( 'ErrorClass', 'ViewHelper', // etc.. ); // or: $elementDecorators = array( array( 'ErrorClass', array( 'class' => 'custom-class' ) // defaults to 'error' ), 'ViewHelper', // etc.. ); // then just add the decorators to an element the way you usually do, for instance like so: $someElement = new Zend_Form_Element_Text( 'someElement' ); $someElement->setDecorators( $elementDecorators ); // etc... O, PS.: Be sure to add the correct prefix path in your form: $this->addPrefixPath( 'App_Form', 'App/Form' ); // or your own namespace
