[site]: stackoverflow
[post_id]: 1477516
[parent_id]: 1477312
[tags]: 
DISCLAIMER: I haven't written scheme regularly in 20 years. I think you want to think about this problem in terms of the whole lispy/schemey approach which is to establish your conditions. Given an input, item, you want to find if a list contains that item. A list may contain an item if the list is not null. A list contains an item if the car of the list matches the item or if the car of the list contains the item A list contains an item if the cdr of the list contains the item. A final question to consider, what is the result of (part? '(a b) '(a b))? I would write the code like this (define part? (lambda (item l) (cond ((null? l) f) ((or (same? item (car l)) (part? item (car l)))) (t (part? item (cdr l))) ) )) (define same? (lambda (a b) (eq? a b))) I used the cond structure because it fits well with problems of this sort - it just feels right to break the problem out - notice the null check. I wrote same? as a helper function in case you want to write it yourself. You could just as easily to it this way: (define same? (lambda (a b) (cond ((and (atom? a) (atom? b)) (eq? a b)) ((and (list? a) (list? b)) (and (same? (car a) (car b)) (same? (cdr a) (cdr b)))) (f f) ) )) which basically says that two items are the same if they are both atoms and they are eq or they are both lists and the cars are the same and the cdrs are the same, otherwise false. You can just as easily rewrite same? as this: (define same? (lambda (a b) (equal? a b))) The point of doing that is that there is a bottleneck in the code - how to determine if two items are the same. If you break that bottleneck out into its own function, you can replace it with different mechanisms. I know you're not here yet, but you will be at one point: you will also be able to rewrite the code so that the predicate is passed in. Something like this (and more up-to-date scheme programmers, feel free to correct me): (define part-pred? (lambda (same-pred item l) (cond ((null? l) f) ((or (same-pred item (car l)) (part? item (car l)))) (t (part? item (cdr l))) ) )) (define part-eq? (lambda (item l) (part-pred? 'eq? item l))) (define part-same? (lambda (item l) (part-pred? 'same? item l))) (define part-equal? (lambda (item l) (part-equal? 'equal? item l))) This has now abstracted the notion of part to be a function that applies the part structural rules and an equality predicate which is supplied by you. That makes it really easy to change the rules. This will make more sense when you hit mapcar.
