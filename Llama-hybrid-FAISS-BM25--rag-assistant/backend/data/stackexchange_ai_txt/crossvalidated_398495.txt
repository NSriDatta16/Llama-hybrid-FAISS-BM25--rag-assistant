[site]: crossvalidated
[post_id]: 398495
[parent_id]: 237585
[tags]: 
accuracy() uses the training sample on which a particular forecast is based. As you note, this will change in each iteration of your rolling origin evaluation. So indeed, you need to "roll your own". This is less onerous than it looks like. Note that the MASE is the MAE or MAD, divided by some scaling factor. accuracy() will give you the MAE. (Of course you can use this in rolling origin evaluation.) So you only need to calculate a single scaling factor for each time series, which you will then apply to the rolling origin MAEs. For instance, the "classical" scaling factor Hyndman & Koehler (2006) originally proposed is simply the in-sample MAE of the naive random walk forecast. If the data you want to base this on (e.g., the "common" history) is foo then you can calculate this very easily by mean(abs(foo[-1]-foo[-20])) (Note: it should be possible to use tail(foo,-1)-head(foo,-1) , but this yields a vector of all zeros... I wonder whether something is buggy here, though both tail(foo,-1) and head(foo,-1) look fine. Weird.) (Update: tail(foo,-1)-head(foo,-1) works on plain vanilla R, but not if I load the forecast 8.5 package. Sounds like a bug. I'll inform Rob Hyndman.) (Update 2: I got the following answer back from Rob - This is a feature, not a bug. By defining head.ts and tail.ts, we are ensuring that head() and tail() on ts objects now retain their class (essential for plotting, etc.). By retaining the "ts" class, the - operation will now use Ops.ts . This will compute math operations with respect to time rather than with respect to position in the vector. )
