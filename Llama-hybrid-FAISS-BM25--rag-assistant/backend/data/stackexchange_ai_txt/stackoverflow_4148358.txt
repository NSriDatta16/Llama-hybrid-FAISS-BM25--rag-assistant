[site]: stackoverflow
[post_id]: 4148358
[parent_id]: 4148169
[tags]: 
The problem is with this line: public static InstanceContext site = new InstanceContext(new CallbackHandler()); This line is really evil! The static initialization of CallbackHandler must be finished before the new CallbackHandler() from the line given above is executed (because this would create an instance). But this line is implicitly a part of the static constructor! So I suppose the .NET runtime cannot execute this line, and leaves site uninitialized (or initialized later). That's why at the proxy initialization site is still null . By the way, I am not sure if the order of static initializations is defined at all. Consider such an example: class Test { static Twin tweedledum = new Twin(tweedledee); static Twin tweedledee = new Twin(tweedledum); } Edit: the paragraph 10.4.5.1 of C# language specs says that the static fields are initialized in the textual order, not considering the dependencies. Edit: Eureka! The part 10.11 of C# language specs clearly states: It is possible to construct circular dependencies that allow static fields with variable initializers to be observed in their default value state. What we did is indeed a circular dependency: CallbackHandler depends on itself. So the behaviour you get is actually documented and is according to the standard. Edit: Strange enough, when I test the code ( here and here ), I get static constructor running after instance constructor finishes. How is this possible? Edit: having got the answer to this question, I can explain what happens. In the 1st case, your code is implicitly rewritten as public static InstanceContext site; public static ServiceReference1.StockServiceClient proxy; static CallbackHandler() { site = new InstanceContext(new CallbackHandler()); proxy = new ServiceReference1.StockServiceClient(site); } In the 2nd case, you get public static InstanceContext site; public ServiceReference1.StockServiceClient proxy; static CallbackHandler() { site = new InstanceContext(new CallbackHandler()); // (*) } public CallbackHandler() { proxy = new ServiceReference1.StockServiceClient(site); } In the 2nd case, the instance constructor in the line marked (*) runs before the completion of the static constructor (yes, it's possible), but at that point site is still not assigned. So, basically in your second variant of code you have at each instance a separate proxy, which points to a static site, which in turn references some another "default" instance of CallbackHandler . Is that really what you want? Maybe, you just need to have site an instance field as well? So, in the 2nd variant of the code the following happens: Main starts. Before the line CallbackHandler cbh = new CallbackHandler(); the static constructor of CallbackHandler is called The argument for new InstanceContext is calculated The constructor new CallbackHandler() is executed As a part of constructor, proxy is initialized with the new ServiceReference1.StockServiceClient(site) , the value of site is null . This throws, but let's forget about this just now, and consider what would happen next. With the calculated argument, the constructor new InstanceContext is called The result of the constructor is assigned to site , which is now not null any more. This finishes the static constructor Now, the constructor called in Main can start. As a part of it, a new proxy is constructed, now with non- null value of site The just created CallbackHandler is assigned to the variable cbh . In your case, ServiceReference1.StockServiceClient(site) throws because site is null ; if it wouldn't care about null s, the code would run as it is described above.
