[site]: stackoverflow
[post_id]: 3380353
[parent_id]: 3380294
[tags]: 
The general technique of allowing a window instance to be represented by as class instance is to make use of the SetWindowLongPtr and GetWindowLongPtr to associate your class instance pointer with the window handle. Below is some sample code to get you started. It may not compile without a few tweaks. It's only meant to be a reference. Personally, I've stopped rolling my own window classes back a few years ago when I discovered ATL's CWindow and CWindowImpl template class. They take care of doing all this mundane coding for you so can focus on just writing methods that handle window messages. See the example code I wrote up here . Hope this helps. class CYourWindowClass { private: HWND m_hwnd; public: LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_CREATE: return OnCreate(wParam, lParam); case wM_PAINT: return OnPaint(wParam, lParam); case WM_DESTROY: { SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL); m_hwnd = NULL; return 0; } } return DefWindowProc(m_hwnd, uMsg, wParam, lParam); } CYourWindowClass() { m_hwnd = NULL; } ~CYourWindowClass() { ASSERT(m_hwnd == NULL && "You forgot to destroy your window!"); if (m_hwnd) { SetWindowLong(m_hwnd, GWLP_USERDATA, 0); } } bool Create(...) // add whatever parameters you want { HWND hwnd = CreateWindow("Your Window Class Name", "Your Window title", dwStyle, x, y, width, height, NULL, hMenu, g_hInstance, (LPARAM)this); if (hwnd == NULL) return false; ASSERT(m_hwnd == hwnd); return true; } static LRESULT __stdcall StaticWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { CYourWindowClass* pWindow = (CYourWindowClass*)GetWindowLongPtr(hwnd, GWLP_USERDATA); if (uMsg == WM_CREATE) { pWindow = ((CREATESTRUCT*)lParam)->lpCreateParams; SetWindowLongPtr(hwnd, GWLP_USERDATA, (void*)pWindow); m_hWnd = hwnd; } if (pWindow != NULL) { return pWindow->WndProc(uMsg, wParam, lParam); } return DefWindowProc(hwnd, uMsg, wParam, lParam); }; };
