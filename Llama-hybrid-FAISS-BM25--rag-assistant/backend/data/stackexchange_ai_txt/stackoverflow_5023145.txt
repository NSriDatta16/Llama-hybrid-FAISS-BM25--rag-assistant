[site]: stackoverflow
[post_id]: 5023145
[parent_id]: 
[tags]: 
Strange Compile Errors in g++ (clang++ compiles fine)

I'm attempting to compile a file that instantiates this class. GCC gives me cryptic errors, but clang compiles it without a complaint. Errors: statemachine.h: In member function ‘void state_machine ::start_submachine(void (*)(state_machine &, T), void (*)(state_machine &, T))’: statemachine.h:245: error: ‘substate_machine ::substate_machine(state_machine *)’ is protected statemachine.h:215: error: within this context statemachine.h: In member function ‘state_machine * substate_machine ::parent()’: main.cpp:282: instantiated from here statemachine.h:138: error: ‘state_machine * state_machine ::parent()’ is protected statemachine.h:241: error: within this context statemachine.h: In member function ‘void substate_machine ::state_return()’: main.cpp:282: instantiated from here statemachine.h:232: error: ‘void state_machine ::return_from_sub()’ is protected statemachine.h:254: error: within this context Main.cpp is 282 lines long, the line that it's pointing to is just a closing brace }. Parent() is never called outside the class (so why would it complain about it being protected)? And why would it complain about state_return() calling a protected method, as this is a member of the class. Does GCC/G++ screw up with protected data members in templates? I suspect (and this is just a hunch) it's trying to inline expand the functions like macros... but why? The code: #ifndef STATEMACHINE_H_INC #define STATEMACHINE_H_INC //#include TODO: Make better templated stream type #include #include const std::string null_string = ""; /* Class state_machine: * Templated class to allow easy implementation of FSMs. * * HOW TO USE: * - Make a type containing whatever data needs to be passed * to the current state. * - If necessary, create a preprocessor function run before * the actual state is invoked (prefunc) * - Create a function for each state. In addition, each * state can be made a submachine by using substate_machine * - If necessary, specialize (INLINE and in the HEADER FILE) * the finalize() method. * - The function names should pretty much be self explanitory. * * Hooray for function pointers. The code was 5x longer and 10x * buggier before I implemented lexer as a state machine :D. * * NOTE: This class COPY CONSTRUCTS from the hints provided (at least * for now), so *don't* try and use your old pointer- it's not the * same object! This was done to simplify this class's * implementation. At some point I should probably change it... * */ template class state_machine { public: //public use typedefs typedef void (*state)(state_machine &, T); typedef state prefunc_t; static void defprefunc(state_machine &, T); static void defstate(state_machine &, T); static void submachine_handle(state_machine &, T); //The above works with submachines because references are treated //by the standard like pointers- so polymorphism is allowed private: prefunc_t prefunc; //don't feel like writing a full on destructor for one pointer std::auto_ptr internal_data; state curstate; state returnstate; //this MUST be an auto_ptr or our memory management gets REAL tricky std::auto_ptr > substate; protected: void init(); void call(state_machine &, T); //this method allows submachine to get data from top of hierarchy. virtual state_machine * parent(); //return TOP of tree void return_from_sub(); //this is a slot, to use the qt term public: //public interface state_machine(prefunc_t = defprefunc, Data * = NULL); Data& data(); void change_state(state); //TODO: change std::istream to a stream dependent on T //void add_stream(std::istream&); void add_char(T); //NULL here means curstate: void start_submachine(state, state = NULL); //this method is available for specialization void finalize(); virtual void state_return(); }; /* class substate_machine: * This class is a helper class to allow the creation of state * machines as states within another state machine. Submachines: * -Share the same data. * -Behave exactly like a regular state, except upon exiting * the submachine the state should call the state_return() * method, which allows control to flow to the parent machine. * -Are invoked with the start_submachine() method. * Basically, what allows them to share data is the protected * virtual method parent(), which gets the state_machine object * at the hierarchy's root. This is never used by the submachine, * only in the parent machine methods when accessing shared data * (i.e. the subclass provides 'plug-in' functionality with this * method), so it *could* be made a private virtual, but those seem * to be 1. poorly understood and 2. overprotective in cases like * this (i.e. do we *really* care if the submachine knows how to * access its parent? no, in fact, we encourage it). * * The user should never see this class. It is only to be used * by the state_machine parent class provide transparent operation * of substates (don't you love polymorphism>) */ template class substate_machine : public state_machine { state_machine * parentsm; //direct parent state machine substate_machine() {} //Default construction causes failure protected: virtual state_machine * parent(); substate_machine(state_machine *); public: virtual void state_return(); //send a signal to the parent machine }; // definitions //note that state_machine ::parent() returns the TOP of the //hierarchy, NOT the direct parent. template state_machine * state_machine ::parent() { return this; //base class state machine must be at top of hierarchy } template void state_machine ::finalize() { //this is left to be specialized over } template Data& state_machine ::data() { //use parent here to allow all subs to access the hierarchy's shared //data as if they own it. return *(parent()->internal_data); } //these are two different functions for clarity's sake template void state_machine ::defstate (state_machine & self, T c) { //do nothing - default behavior } template void state_machine ::defprefunc (state_machine & self, T c) { //do nothing - default behavior } template void state_machine :: submachine_handle(state_machine & self, T c) { //handle a submachine self.substate->curstate(*(self.substate), c); } template void state_machine ::state_return() { //should NOT happen, but handle just in case. } template void state_machine ::init() { curstate = defstate; prefunc = defprefunc; } template state_machine ::state_machine (prefunc_t func, Data * d) { init(); //make a new data - copy construct if d is not null if (d) { internal_data = std::auto_ptr (new Data(*d)); } else { internal_data = std::auto_ptr (new Data); } prefunc = func; } template void state_machine ::change_state(state s) { curstate = s; } //the first state is the state to start a submachine in, the second //state is the state to go into when the submachine returns to the //parent, which is by default NULL (the current state) template void state_machine ::start_submachine(state s, state rs) { //get arround default argument errors (static resolution...) if (rs == NULL) { rs = curstate; } //set up submachines substate = std::auto_ptr >(new substate_machine (this)); substate->change_state(s); returnstate = rs; //set up the submachine state handler curstate = submachine_handle; } //preprocess and then process a character through the state machine. template void state_machine ::add_char(T c) { prefunc(*this, c); curstate(*this, c); } //this is a slot for the submachine to send its return signal to. //basically just switches the function pointer back. template void state_machine ::return_from_sub() { curstate = returnstate; } //now for the substate template state_machine * substate_machine ::parent() { //remember, this is the top of the hierarchy. return parentsm->parent(); } template substate_machine :: substate_machine(state_machine * sm) { this->init(); parentsm = sm; //initialization. MUST BE INITIALIZED BY A PARENT THROUGH THIS CTOR } template void substate_machine ::state_return() { parentsm->return_from_sub(); //sends the parent the return signal. } #endif Thanks in advance for any input. I would tag with clang++ but it won't let me...
