[site]: stackoverflow
[post_id]: 2585439
[parent_id]: 
[tags]: 
how to implement class with collection of string/object pairs so that an object can be returned with generic method?

The values in a file are read as string and can be double, string or int or maybe even lists. An example file: DatabaseName=SomeBase Classes=11;12;13 IntValue=3 //this is required! DoubleValue=4.0 I was thinking something like this: class ConfigValues { private static SomeObject _utiObject; private static string _cfgFileName = "\\SomeSettings.cfg"; private static Dictionary _settingNamesAndTypes = new Dictionary (); private static Dictionary _settings = new Dictionary (); private static string _directory = string.Empty; const string _impossibleDefaultValue = "987ABC654DEF321GHI"; public static T GetConfigValue (string cfgName) { object value; if (_settings.TryGetValue(cfgName, out value)) return (T)value; else return default(T); } public static bool LoadConfig(Dictionary reqSettings, Dictionary optSettings, Dictionary optDefaultValues, out string errorMsg) { errorMsg = string.Empty; try { _utiObject = new SomeObject(new string[] { "-c", CfgFileNameAndPath }); } catch (Exception e) { errorMsg = string.Format("Unable to read {0}. Exception: {1}", CfgFileNameAndPath, e.Message); return false; } foreach (KeyValuePair kVPair in reqSettings) { if (!ReadCheckAndStore(kVPair, null, out errorMsg)) return false; _settingNamesAndTypes.Add(kVPair.Key, kVPair.Value); } foreach (KeyValuePair kVPair in optSettings) { if (!ReadCheckAndStore(kVPair, optDefaultValues[kVPair.Key], out errorMsg)) return false; _settingNamesAndTypes.Add(kVPair.Key, kVPair.Value); } return true; } private static bool ReadCheckAndStore(KeyValuePair kVPair, object defaultValue, out string errorMsg) { errorMsg = string.Empty; string usedDefaultValue, value = string.Empty; /* required setting */ if (defaultValue == null) usedDefaultValue = _impossibleDefaultValue; else usedDefaultValue = defaultValue.ToString(); //all string parameters below _utiObject.GetConfigValue(kVPair.Key, usedDefaultValue, ref value); if (_impossibleDefaultValue == value) { errorMsg = string.Format("Required configuration setting {0} was not" + "found in {1}", kVPair.Key, CfgFileNameAndPath); return false; } Type type = kVPair.Value; _settings[kVPair.Key] = Convert.ChangeType(value, type); return true; } } PS. Additional issue is default values for optional settings. It's not elegant to pass them to LoadConfig in separate Dictionary, but that is an other issue...
