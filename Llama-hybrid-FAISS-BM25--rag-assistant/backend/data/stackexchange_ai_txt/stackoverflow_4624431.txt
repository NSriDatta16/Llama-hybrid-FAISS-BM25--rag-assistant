[site]: stackoverflow
[post_id]: 4624431
[parent_id]: 4624112
[tags]: 
This is pretty straightforward, although I feel like it could be faster: from __future__ import division import numpy as np Norig = 100 Ndown = 20 step = Norig//Ndown assert step == Norig/Ndown # ensure Ndown is an integer factor of Norig x = np.arange(Norig*Norig).reshape((Norig,Norig)) #for testing y = np.empty((Ndown,Ndown)) # for testing for yr,xr in enumerate(np.arange(0,Norig,step)): for yc,xc in enumerate(np.arange(0,Norig,step)): y[yr,yc] = np.mean(x[xr:xr+step,xc:xc+step]) You might also find scipy.signal.decimate interesting. It applies a more sophisticated low-pass filter than simple averaging before downsampling the data, although you'd have to decimate one axis, then the other.
