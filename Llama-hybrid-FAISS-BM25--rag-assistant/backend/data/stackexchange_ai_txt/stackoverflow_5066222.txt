[site]: stackoverflow
[post_id]: 5066222
[parent_id]: 5065318
[tags]: 
It seems you are misunderstanding pointer arithmetic cb->buffer_end = (DataFragment *)cb->buffer + (capacity-1)*sz; cb->head = (DataFragment*)cb->head + cb->sz; cb->tail = (DataFragment*)cb->tail + cb->sz; Pointer arithmetic already takes into account the size of the underlying type. All you really need is ++cb->head; ++cb->tail; If the idea is to hack around sizeof(DataFragment) - perhaps to allocate more storage for one item than the struct's size - for some evil purpose - you'll need to first cast the pointer to a char* (because sizeof(char) == 1 ). cb->tail = (DataFragment*)((char*)cb->tail + cb->sz); Design-wise the struct appears to have too many members: buffer_end and capacity duplicate each other (given one you can always find the other), and the sz member is not necessary (it should always be sizeof(DataFragment) . Also, I believe you can just assign structs *(cb->head) = *item; there seem to be completely unnecessary casts (probably resulting from the misunderstanding of pointer arithmetic): cb->buffer_end = (DataFragment *)cb->buffer + (capacity-1)*sz; And if it is supposed to be C++, then it contains lots of "C-isms" (typedeffing structs, using struct XXX var; - despite having it typedeffed, etc), and the code is generally designed in a purely C style (not taking advantage of C++'s greatest strength, automatic resource management with RAII). May I also point out that clock() hardly gives you a date :)
