[site]: stackoverflow
[post_id]: 4050756
[parent_id]: 4049133
[tags]: 
There is nothing keeping you from having View constructs in your ViewModel... especially if you consider the ViewModel to be a model of the View (as opposed to a view of the model). Not all purists think this is a good idea. Most pragmatists, however, do. Having properties like FontWeight, FontColor, FontSize, etc in your EditorTabViewModel would work for you here, and you can then bind them in the properties of the MarkdownEditor . It would allow for you to dynamically change the UI properties of the text via the ViewModel. If you are a purist, and you don't like having the ViewModel know about WPF specific View constructs, you could create your own text formatting class, called something like TextFormatting . TextFormatting can include your own representation of the information you want to communicate (bold, italics, color, font size, etc). You can then bind that TextFormatting object to the MarkdownEditor using an attached property/behavior. The attached property/behavior would be responsible for mapping the formatting representation to the WPF representation. Doing it the second way is very useful if you have different Views (WinForms/WPF) that might use the same ViewModel, since it remains view engine agnostic. It also adds a layer of complexity that the first option does not.
