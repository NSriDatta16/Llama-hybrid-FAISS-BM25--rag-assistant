[site]: stackoverflow
[post_id]: 256630
[parent_id]: 256625
[tags]: 
Typically, if one doesn't have closures, one must define a class to carry with it the equivalent of the closure's environment, and pass it around. For example, in a language like Lisp, one can define a function that returns a function (with a closed-over environment) to add some predefined amount to its argument thusly: (defun make-adder (how-much) (lambda (x) (+ x how-much))) and use it like this: cl-user(2): (make-adder 5) # cl-user(3): (funcall * 3) ; calls the function you just made with the argument '3'. 8 In a language without closures, you would do something like this: public class Adder { private int howMuch; public Adder(int h) { howMuch = h; } public int doAdd(int x) { return x + howMuch; } } and then use it like this: Adder addFive = new Adder(5); int addedFive = addFive.doAdd(3); // addedFive is now 8. The closure implicitly carries its environment with it; you seamlessly refer to that environment from inside the executing part (the lambda). Without closures you must make that environment explicit. That should explain to you when you would use closures: all the time . Most instances where a class is instantiated to carry with it some state from another part of the computation and apply it elsewhere are elegantly replaced by closures in languages which support them. One can implement an object system with closures.
