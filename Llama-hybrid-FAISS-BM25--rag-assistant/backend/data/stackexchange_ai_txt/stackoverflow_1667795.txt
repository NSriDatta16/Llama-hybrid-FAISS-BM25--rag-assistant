[site]: stackoverflow
[post_id]: 1667795
[parent_id]: 1665232
[tags]: 
Calling Start() and Stop() sets an internal "enabled" flag, which performs the following work every time it is set (in the case of Start) or unset (in the case of Stop): public virtual void set_Enabled(bool value) { lock (this.syncObj) { if (this.enabled != value) { this.enabled = value; if (!base.DesignMode) { if (value) { if (this.timerWindow == null) { this.timerWindow = new TimerNativeWindow(this); } this.timerRoot = GCHandle.Alloc(this); this.timerWindow.StartTimer(this.interval); } else { if (this.timerWindow != null) { this.timerWindow.StopTimer(); } if (this.timerRoot.IsAllocated) { this.timerRoot.Free(); } } } } } } As you can see, there is work involved, including handle allocation and management, which goes above and beyond simply setting an internal flag. This may be the expense of the issue you are seeing. As a possible solution to your issue, I would like to call your attention to the fact that there are three timer implementations in the .NET Framework: System.Timers.Timer System.Threading.Timer System.Windows.Forms.Timer The System.Timers.Timer and the System.Threading.Timer implementations are lighter-weight implementations of timer functionality, and you should investigate whether one of those lighter implementations will be more performant and still meet the requirements of your project. For the differences in functionality between the implementations, please see this blog post from Mark Michaelis .
