[site]: stackoverflow
[post_id]: 1737632
[parent_id]: 1737171
[tags]: 
Here is the bare bones of an implementation of the interface for Json : package main import {"json"; "fmt"; "os";} type MyTest struct { MyMap map[string]string;} func (t * MyTest) Kind() int { return json.MapKind } func (t * MyTest) Len() int { return len (t.MyMap) } func (t * MyTest) Number() float64 { return 0 } func (t * MyTest) Bool() bool { return false } func (t * MyTest) Elem(int) json.Json { return json.Null } func (t * MyTest) String() (s string) { s = "{"; count := 0; for key, value := range t.MyMap { s += json.Quote(key) + ":" + json.Quote(value); count++; if (count Here is some testing code: func main () { var megaburger = new (MyTest); megaburger.MyMap = make(map[string]string); megaburger.MyMap["frog"] = "toad"; megaburger.MyMap["captain"] = "kirk"; megaburger.MyMap["laser"] = "phaser"; fmt.Println (megaburger.Kind()); fmt.Println (megaburger.Len()); fmt.Println (json.JsonToString (megaburger)); } This puts a JsonToString method onto the type MyTest by defining the interface for the Json package. Clearly this doesn't do anything interesting yet, but you could define various things like these for your particular data structure in order to have a "JSON-izer" which created whatever JSON you liked from your structure. There is a nice example of how to do embedding using something called _Null in the library source code file generic.go .
