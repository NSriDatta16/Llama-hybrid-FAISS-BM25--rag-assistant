[site]: stackoverflow
[post_id]: 1632885
[parent_id]: 1556349
[tags]: 
I've implemented this as follows for the same workflow use-case. While it works sufficiently for me, I do wish there was a simpler and more elegant approach where the selection event could be vetoed before proceeding. If I have time to investigate and figure that out I'll repost, but it might rank as a case where the return on investment isn't worth it (i.e. customizing Swing classes, handling lower level mouse/keyboard events directly, etc). Anyway what I'm doing currently is saving the last good 'validated' selection, and reverting back to it if the user cancels a future selection. It's admittedly not the prettiest solution, but it works: // save the last good (i.e. validated) selection: private ProjectClass lastSelectedProj; // listing of available projects: private JList list; // true if current selected project has been modified without saving: private boolean dirty; list.addListSelectionListener(new ListSelectionListener() { public void valueChanged(ListSelectionEvent evt) { if (evt.getValueIsAdjusting()) return; // first validate this selection, and give the user a chance to cancel. // e.g. if selected project is dirty show save: yes/no/cancel dialog. if (dirty) { int choice = JOptionPane.showConfirmDialog(this, "Save changes?", "Unsaved changes", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE); // if the user cancels the selection event revert to previous selection: if (choice == JOptionPane.CANCEL_OPTION) { dirty = false; // don't cause yet another prompt when reverting selection list.setSelectedValue(lastSelectedProj, true); dirty = true; // restore dirty state. not elegant, but it works. return; } else { // handle YES and NO options dirty = false; } } // on a validated selection event: lastSelectedProj = list.getSelectedValue(); // proceed to update views for the newly selected project... } }
