[site]: stackoverflow
[post_id]: 2869423
[parent_id]: 2868651
[tags]: 
The trick here is that the .h file is being used in two different ways - it's being used as a normal .h file where all the globals are declared extern and it's also being used to define the globals themselves (with no extern ). This is an ugly hack but you can understand why someone felt it necessary if you have a large number of globals (a sure sign of very bad software design !). Anyway, there is a somewhat more elegant solution - you can put all your globals in a single global struct, e.g. // // globals.h // typedef struct { int a; int b; // ... int z; } Globals; extern Globals globals; // declaration - // // globals.c // #include "globals.h" Globals globals; // definition - Then when you need to refer to a global it's e.g. globals.a instead of just a , which might seem like an inconvenience but this is arguably clearer and more manageable than just having naked globals scattered throughout the code.
