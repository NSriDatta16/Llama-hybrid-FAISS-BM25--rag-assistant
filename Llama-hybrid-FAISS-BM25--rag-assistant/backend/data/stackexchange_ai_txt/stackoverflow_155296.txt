[site]: stackoverflow
[post_id]: 155296
[parent_id]: 155260
[tags]: 
That is the generic syntax for C#. The basic concept is that it allows you to use a Type placeholder and substitute the actual real type in at compile time. For example, the old way: ArrayList foos = new Arraylist(); foos.Add("Test"); worked by making ArrayList store a list of System.Objects (The base type for all things .NET). So, when adding or retrieving an object from the list, The CLR would have to cast it to object, basically what really happens is this: foos.Add("Test" as System.Object); string s = foos[1] as String. This causes a performance penalty from the casting, and its also unsafe because I can do this: ArrayList listOfStrings = new ArrayList(); listOfStrings.Add(1); listOfStrings.Add("Test"); This will compile just fine, even though I put an integer in listOfStrings. Generics changed all of this, now using Generics I can declare what Type my collection expects: List listOfIntegers = new List (); List listOfStrings = new List (); listOfIntegers.add(1); // Compile time error. listOfIntegers.add("test"); This provides compile-time type safety, as well as avoids expensive casting operations. The way you leverage this is pretty simple, though there are some advanced edge cases. The basic concept is to make your class type agnostic by using a type placeholder, for example, if I wanted to create a generic "Add Two Things" class. public class Adder { public T AddTwoThings(T t1, T t2) { return t1 + t2; } } Adder stringAdder = new Adder (); Console.Writeline(stringAdder.AddTwoThings("Test,"123")); Adder intAdder = new Adder (); Console.Writeline(intAdder.AddTwoThings(2,2)); For a much more detailed explanation of generics, I can't recommend enough the book CLR via C#.
