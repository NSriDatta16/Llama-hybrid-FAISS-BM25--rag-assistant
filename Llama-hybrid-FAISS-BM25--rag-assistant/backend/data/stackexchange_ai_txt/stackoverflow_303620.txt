[site]: stackoverflow
[post_id]: 303620
[parent_id]: 303562
[tags]: 
The problem you are having is related to the fact that operator is not a member of ostream, and your temporary ostream instance cannot bind to a non- const reference. Instead, it picks the void* overload, which is a member of ostream, and thus doesn't have that restriction. The best (but not easiest or most elegant, by any stretch of imagination!) would be to use the Boost Preprocessor to generate a large number of function overloads, each templated on a large number of objects (includes have been omitted and assuming using namespace std; ): #define MAKE_OUTPUT(z, n, data) \ BOOST_PP_TUPLE_ELEM(2, 0, data) \ inline string format(BOOST_PP_ENUM_BINARY_PARAMS_Z(z, BOOST_PP_INC(n), T, p)) \ { \ ostringstream s; \ BOOST_PP_REPEAT_##z(z, n, MAKE_OUTPUT, (s, p)); \ return s.str(); \ } It's not guaranteed to work exactly (wrote it without testing), but that's basically the idea. You then call BOOST_PP_REPEAT(N, MAKE_FORMAT, ()) to create a series of functions taking up to N parameters that will format your string as you want to (replace N with the integer of choice. Higher values may negatively affect compile times). This should suffice until you get a compiler with variadic templates. You should read the boost preprocessor documentation, it has very powerful features for things like this. (you can subsequently #undef the macros, after calling the BOOST_PP_REPEAT invocation to generate the functions)
