[site]: stackoverflow
[post_id]: 2816053
[parent_id]: 
[tags]: 
Java: Typecasting to Generics

This method that uses method-level generics, that parses the values from a custom POJO, JXlistOfKeyValuePairs (which is exactly that). The only thing is that both the keys and values in JXlistOfKeyValuePairs are String s. This method wants to taken in, in addition to the JXlistOfKeyValuePairs instance, a Class that defines which data type to convert the values to (assume that only Boolean , Integer and Float are possible). It then outputs a HashMap with the specified type for the values in its entries. This is the code that I have got, and it is obviously broken. private Map fromListOfKeyValuePairs(JXlistOfKeyValuePairs jxval, Class clasz) { Map val = new HashMap (); List jxents = jxval.getEntry(); T value; String str; for (Entry jxent : jxents) { str = jxent.getValue(); value = null; if (clasz.isAssignableFrom(Boolean.class)) { value = (T)(Boolean.parseBoolean(str)); } else if (clasz.isAssignableFrom(Integer.class)) { value = (T)(Integer.parseInt(str)); } else if (clasz.isAssignableFrom(Float.class)) { value = (T)(Float.parseFloat(str)); } else { logger.warn("Unsupported value type encountered in key-value pairs, continuing anyway: " + clasz.getName()); } val.put(jxent.getKey(), value); } return val; } This is the bit that I want to solve: if (clasz.isAssignableFrom(Boolean.class)) { value = (T)(Boolean.parseBoolean(str)); } else if (clasz.isAssignableFrom(Integer.class)) { value = (T)(Integer.parseInt(str)); } I get: Inconvertible types required: T found: Boolean Also, if possible, I would like to be able to do this with more elegant code, avoiding Class#isAssignableFrom. Any suggestions? Sample method invocation: Map foo = fromListOfKeyValuePairs(bar, Boolean.class); Solved, thanks to both @Chris Dolan and @polygenelubricants. The cause was the typecast was getting confused when combine with the autoboxing of the primitive. Compiler warnings are avoided because the method parameter clasz is of the type Class , instead of just Class or Class , so invoking the cast method was typesafe. Impl. soln.: private Map fromListOfKeyValuePairs( JXlistOfKeyValuePairs jxval, Class clasz) { Map val = new HashMap (); List jxents = jxval.getEntry(); T value; String str; for (Entry jxent : jxents) { str = jxent.getValue(); value = null; if (clasz.isAssignableFrom(Boolean.class)) { value = clasz.cast(Boolean.parseBoolean(str)); } else if (clasz.isAssignableFrom(Integer.class)) { value = clasz.cast(Integer.valueOf(Integer.parseInt(str))); } else if (clasz.isAssignableFrom(Float.class)) { value = clasz.cast((Object)Float.parseFloat(str)); } else { logger.warn("Unsupporteded value type encountered in key-value pairs, continuing anyway: " + clasz.getName()); } val.put(jxent.getKey(), value); } return val; }
