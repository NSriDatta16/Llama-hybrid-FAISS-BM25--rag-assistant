[site]: stackoverflow
[post_id]: 2806226
[parent_id]: 2806039
[tags]: 
This is really appropriate for the Flyweight . That is basically what you are trying to accomplish with the statics. In terms of how to serve the Flyweight object so that you don't create thousands of them, here are some ideas. One is the factory, which you state you thought about and rejected, although you didn't state why (so any other ideas may suffer from the same problem) so I won't go into it. Another is to have the value type have a method which can serve its converter. Something like this: public class ValueType { public static final TextTransformable CONVERT = .... } And then use it like this: ValueType value = ValueType.CONVERT.fromText(text); String text = ValueType.CONVERT.toText(value); Now that doesn't enforce that all ValueType's provide their converters via the same mechanism, for that I think you need a factory of some kind. Edit: I guess I don't know what you find inelegant about a factory, but I think you are focused on callers, so how does this feel to you: ValueType value = getTransformer(ValueType.class).fromText(text); The above can be done with a static import of the factory and a method that has a signature like so: public static TextTransformable getTransformer(Class type) { ... } The code to find the right transformer isn't necessarily the prettiest, but from the callers perspective everything is nicely presented. Edit 2: Thinking about this further, what I see is that you want to control object construction. You can't really do that. In other words, in Java you can't force an implementer to use or not use a factory to create their object. They can always expose a public constructor. I think your problem is that you aren't happy with the mechanisms for enforcing construction. If that understanding is right, then the following pattern may be of use. You create an object with only private constructors which wraps your value type. The object may have a generic type parameter to know what value type it wraps. This object is instantiated with a static factory method which takes a factory interface to create the "real" value object. All framework code that uses the object only takes this object as a parameter. It does not accept the value type directly, and that object cannot be instantiated without a factory for the value type. The problem with this approach is that it is quite restricting. There is only one way to create objects (those supported by the factory interface) and there is limited ability to use the value objects, as the code processing these text elements has limited interaction only through this object. I guess they say there isn't a software problem that can't be solved via an extra layer of indirection, but this may be a bridge too far. At least its food for thought.
