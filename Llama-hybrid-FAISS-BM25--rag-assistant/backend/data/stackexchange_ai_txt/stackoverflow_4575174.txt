[site]: stackoverflow
[post_id]: 4575174
[parent_id]: 4557899
[tags]: 
As @Newbie posted in the comments, @quixoto: open your image in Paint program, click with fill tool somewhere in the seam, and you see it makes 90 degree angle line there... means theres only 1 color, no brighter anywhere in the "seam". its just an illusion. True. While I'm not familiar with this part of math under OpenGL, I believe this is the implicit result of how the interpolation of colors between the triangle vertices is performed... I'm positive that it's called "Bilinear interpolation". So what to do to solve that? One possibility is to use a texture and just draw a textured quad (or several textured quads). However, it should be easy to generate such a border in a fragment shader . A nice solution using a GLSL shader... Assume you're drawing a rectangle with the bottom-left corner having texture coords equal to (0,0), and the top-right corner with (1,1). Then generating the "miter" procedurally in a fragment shader would look like this, if I'm correct: varying vec2 coord; uniform vec2 insetWidth; // width of the border in %, max would be 0.5 void main() { vec3 borderColor = vec3(0,0,1); vec3 backgroundColor = vec3(1,1,1); // x and y inset, 0..1, 1 means border, 0 means centre vec2 insets = max(-coord + insetWidth, vec2(0,0)) / insetWidth; If I'm correct so far, then now for every pixel the value of insets.x has a value in the range [0..1] determining how deep a given point is into the border horizontally, and insets.y has the similar value for vertical depth. The left vertical bar has insets.y == 0, the bottom horizontal bar has insets.x = 0, , and the lower-left corner has the pair (insets.x, insets.y) covering the whole 2D range from (0,0) to (1,1). See the pic for clarity: Now we want a transformation which for a given (x,y) pair will give us ONE value [0..1] determining how to mix background and foreground color. 1 means 100% border, 0 means 0% border. And this can be done in several ways! The function should obey the requirements: 0 if x==0 and y==0 1 if either x==1 or y==1 smooth values in between. Assume such function: float bias = max(insets.x,insets.y); It satisfies those requirements. Actually, I'm pretty sure that this function would give you the same "sharp" edge as you have above. Try to calculate it on a paper for a selection of coordinates inside that bottom-left rectangle. If we want to have a smooth, round miter there, we just need another function here. I think that something like this would be sufficient: float bias = min( length(insets) , 1 ); The length() function here is just sqrt(insets.x*insets.x + insets.y*insets.y) . What's important: This translates to: "the farther away (in terms of Euclidean distance) we are from the border, the more visible the border should be", and the min() is just to make the result not greater than 1 (= 100%). Note that our original function adheres to exactly the same definition - but the distance is calculated according to the Chessboard (Chebyshev) metric, not the Euclidean metric. This implies that using, for example, Manhattan metric instead, you'd have a third possible miter shape! It would be defined like this: float bias = min(insets.x+insets.y, 1); I predict that this one would also have a visible "diagonal line", but the diagonal would be in the other direction ( "\" ). OK, so for the rest of the code, when we have the bias [0..1], we just need to mix the background and foreground color: vec3 finalColor = mix(borderColor, backgroundColor, bias); gl_FragColor = vec4(finalColor, 1); // return the calculated RGB, and set alpha to 1 } And that's it! Using GLSL with OpenGL makes life simpler. Hope that helps!
