[site]: stackoverflow
[post_id]: 2361209
[parent_id]: 2361148
[tags]: 
You can drag out of a component, even out of a window, quite by design in order to support drag and drop. For drag events you just have to constrain the event location to within it's container: static public final int MAX_X=(CANVAS_WIDTH - PADDLE_WIDTH); ... public void mouseDragged(MouseEvent e) { int px=Math.max(0,Math.min(e.getX(),MAX_X)); int dx=(px-lastX); if(dx!=0) { gobj.move(dx); lastX=px; } } After sleeping on it, and re-reading the comments, I have an idea where the problem might lie - in the code provided GObject is not shown, nor is how it's created/initialized. So it's hard to guess at the context for the code in the question. I would wager that the paddle is created to be initially in the middle (perhaps middle/bottom) of the canvas. The code above, and in the question, only constrains a delta to prevent the delta from exceeding the bounds of the canvas - it does not account for the initial position of the paddle. That is, if the paddle starts out at x=350, and the delta allows for a total of 700-150=550, then the constrained delta will allow the paddle to move to 350-550=-200, the paddle will move to 200 pixels beyond the left edge. So you need to pass the move method the upper bounds and constrain the resulting position to 0 ... if(dx!=0) { gobj.moveX(dx,MAX_X); lastX=px; } ... GObject: public void moveX(int dlt, int max) { positionX=Util.limitInt((positionX+dlt),0,max); } Util: /** * Limit the range of a number to the specified values. */ static public int limitInt(int val, int low, int hgh) { return ((val And I would repeat all the code for Y, and manipulate this axis separately. Otherwise you will need to extend your move method to: public void move(int dltX, int maxX, int dltY, int maxY) { positionX=Util.limitInt((positionX+dltX),0,maxX); positionY=Util.limitInt((positionX+dltY),0,maxY); }
