[site]: stackoverflow
[post_id]: 4961662
[parent_id]: 4961635
[tags]: 
It helps avoid having these supposedly constant values change just because somebody rearranges the class. Say you have a new employee that decides "None" should go at the back of the list: public enum EmployeeRole { Manager, Admin, Operator, None } Well, if you were only ever accessing these values directly from EmployeeRole.Whatever, that's not a huge deal. But most enums I've seen get converted at some point to an integer value when they're persisted in a database. That means all your "None" elements in storage just got converted to "Manager"s. The same problem would arise if someone merely inserted a new EmployeeRole between, say, Admin and Operator. Another advantage arises when you don't consider there to be an appropriate "default" value for your enum. For example, if somebody forgot to map an EmployeeRole field in the ORM, objects pulled from the repository would always appear to have None role (0 is always the default for enums). Depending on how your software handles None , this sort of bug may go uncaught for some time. But if you do this: public enum EmployeeRole { Manager = 1, Admin = 2, Operator = 3 } ... and then combine it with fail-fast techniques, you can quickly catch errors where an invalid "0" value was provided: public RightsManager GetByEmployeeRole(EmployeeRole role) { Require.That(role.IsDefined()); // throws an exception if role is not defined. // find the rights manager for this role. }
