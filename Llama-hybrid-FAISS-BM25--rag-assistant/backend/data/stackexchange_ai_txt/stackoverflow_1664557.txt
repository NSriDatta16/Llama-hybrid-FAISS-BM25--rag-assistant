[site]: stackoverflow
[post_id]: 1664557
[parent_id]: 1663932
[tags]: 
This is what I do for Seach Engine Friendly URLs with unlimited amount of levels. It also gives you the option of allowing query strings or not, and will not rewrite urls to real folders or files like images, CSS and JavaScript. Apache... # Do not use htaccess if you can avoid it, instead write all of this in the httpd.conf and disable .htaccess for performance/security. RewriteEngine On RewriteBase / # Redirect non-www traffic to www.domain.co.uk/request RewriteCond %{HTTP_HOST} !^www\.domain\.co\.uk$ [NC] RewriteRule ^(.*)$ http://www.domain.co.uk/$1 [R=301,L] # Do not rewrite real files RewriteCond %{REQUEST_FILENAME} -f [OR] RewriteCond %{REQUEST_FILENAME} -d RewriteRule ^.*/ - [L] # Use 1 or 2 Below # 1. SEO Friendly URLs (don't allow additional query strings /foo/bar/) # RewriteRule ^([A-Za-z0-9/-]*)$ index.php?request=$1 [L] # 2. SEO Friendly URLs (allow additional query strings /foo/bar/?q=search) RewriteRule ^([A-Za-z0-9/-]*)$ index.php?request=$1 [L,QSA] PHP... $request = /path/to/page/ > var_dump($request); > array(3) { [0]=> string(4) "path" [1]=> string(2) "to" [2]=> string(4) "page" } */ // Check request exists if (isset($_GET['request']) && !empty($_GET['request'])) { // Yes. Sanitize request. // request should be made lowercase, as URLs should not be case-sensitive. $request = strtolower($_GET['request']); // Sanitize request incase the user tries to circumvent the .htaccess rules and uses the query string directly. index.php?request= $request = preg_replace("([^a-z0-9-/])", '', $request); // Check if request ends with trailing slash to ensure all crawled URLs end with a trailing slash. ($request does not include other query strings or anchors) if ((substr($request, -1, 1)) == '/') { // Yes, request should now be safe to use. $safe['url'] = $request; // Split request into an array with values for each directory. $safe['request'] = explode('/', $request, -1); // Destroy user input to prevent usage. unset($_GET['request'], $request); } else { // No, redirect to request with trailing slash. header('Location: /' . $request . '/', true, 301); exit; } } else { // No. $safe['request'] = false; } ?> I then have a routing file which handles the request with the appropriate functions. It might seem like a lot of code but helps keep things organised and efficient as I only include the classes/functions that the request requires. I'm considering releasing a library of code (Urgh, not another framework I hear you cry) I use for my projects so feel free to use the code under GPL v3. Hope this helps.
