[site]: stackoverflow
[post_id]: 2521930
[parent_id]: 2521895
[tags]: 
1.is there a flaw with the above implementation of the getInstance method? It does not work. You can end up with several instances of your Singleton. 2.What is the difference between the two implementations.? The second one works, but requires synchronization, which could slow down the system when you have a lot of accesses to the method from different threads. The most straightforward correct implementation: public class MySingleton{ private static final MySingleton _instance = new MySingleton(); private MySingleton(){} public static MySingleton getInstance() { return _instance; } } Shorter and better (safely serializable): public enum MySingleton{ INSTANCE; // methods go here } Lazy initialization of singletons is a topic that gets attention way out of proportion with its actual practical usefulness (IMO arguing about the intricacies of double-checked locking, to which your example is the first step, is nothing but a pissing contest). In 99% of all cases, you don't need lazy initialization at all, or the "init when class is first referred" of Java is good enough. In the remaining 1% of cases, this is the best solution: public enum MySingleton{ private MySingleton(){} private static class Holder { static final MySingleton instance = new MySingleton(); } static MySingleton getInstance() { return Holder.instance; } } See Initialization-on-demand holder idiom
