[site]: stackoverflow
[post_id]: 4284509
[parent_id]: 4227549
[tags]: 
Thank you for any comments. This one may be used with WinXP and newer. The implementation mentioned before may still be used with a PowerPC architecture (if you have a proper implementation of CompareAndSwap, see "http://publib.boulder.ibm.com/infocenter/aix/v6r1/topic/com.ibm.aix.aixassem/doc/alangref/stwcx.htm"). Best regards, Friedrich /// @brief Lock-free memory-pool implementation /// @tparam T Type stored within the memory-pool /// @tparam S Number of elements stored in the memory-pool. template class MemoryPool { public: /// @brief Type stored within the memory-pool. typedef T TYPE; enum { /// @brief Number of enrties in the memory-pool. SIZE = S }; private: // we need to align the memory-pool-chunks. #pragma pack(push, MEMORY_ALLOCATION_ALIGNMENT) /// @brief The memory-chunk used by the memory-pool. template struct MemoryChunk { /// @brief Next entry in the single-linked list. SLIST_ENTRY Next; /// @brief The value stored within the memory-pool. /// Do not call the constructor char Value[sizeof(TYPE)]; }; typedef MemoryChunk CHUNK_TYPE; #pragma pack(pop, MEMORY_ALLOCATION_ALIGNMENT) /// @brief Head of the single-linked list. SLIST_HEADER Head; /// @brief The pool itself CHUNK_TYPE Pool[SIZE]; // no copying is supported MemoryPool& operator=(const MemoryPool&); MemoryPool(const MemoryPool&); public: /// @brief Constructs the memory-pool. MemoryPool() { InitializeSListHead(&Head); for(int i = 0; i (InterlockedPopEntrySList(&Head)); if(c) return reinterpret_cast (&c->Value[0]); else return 0; } /// @brief Deallocates a memory chunk (the destructor is not called) /// @param c Point to the memory-chunk allocated by us. void Deallocate(void* c) { if(c (&Pool[0]) || c > static_cast (&Pool[SIZE])) return; // was not allocated by us char* p = static_cast (c); p -= sizeof(SLIST_ENTRY); CHUNK_TYPE* t = reinterpret_cast (p); InterlockedPushEntrySList(&Head, &t->Next); } };
