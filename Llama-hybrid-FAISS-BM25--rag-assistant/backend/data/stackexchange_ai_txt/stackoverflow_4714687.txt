[site]: stackoverflow
[post_id]: 4714687
[parent_id]: 4713919
[tags]: 
It looks to me like you are getting close to reinventing Moose poorly. Consider using Moose instead of building something similar, but less useful. The error message means that you are passing in a string in a place where your code expects a code reference. Get a stack trace to figure out where the error is coming from. You can do this by using Carp::Always, overriding the $SIG{__DIE__} handler to generate a stack trace, or inserting a Carp::confess into your code. Here's a sigdie solution, stick this in your code where it will run before your module initialization: $SIG{__DIE__} = sub { Carp::confess(@_) }; You may need to put it in a BEGIN block. I'd really like to discourage you from taking this approach to building objects. You happily bless any random crap passed in to the constructor as part of your object! You blithely reach into your object internals. Field validation rules *do not belong in the constructor--they belong in the attribute mutators. If you must use a DIY object, clean up your practices: # Here's a bunch of validators. # I set them up so that each attribute supports: # Multiple validators per attribute # Distinct error message per attribute my %VALIDATORS = ( some_attribute => [ [ sub { 'foo1' }, 'Foo 1 is bad thing' ], [ sub { 'foo2' }, 'Foo 2 is bad thing' ], [ sub { 'foo3' }, 'Foo 3 is bad thing' ], ], other_attribute => [ [ sub { 'bar' }, 'Bar is bad thing' ] ], ); sub new { my $class = shift; # Get the invocant my %args = @_; # Get named arguments # Do NOT make this a clone method as well my $self = {}; bless $class, $self; # Initialize the object; for my $arg ( keys %args ) { # Make sure we have a sane error message on a bad argument. croak "Bogus argument $arg not allowed in $class\n" unless $class->can( $arg ); $self->$arg( $args{$arg} ); } return $self; } # Here's an example getter/setter method combined in one. # You may prefer to separate get and set behavior. sub some_attribute { my $self = shift; if( @_ ){ my $val = shift; # Do any validation for the field $_->[0]->($val) or croak $_->[1] for @{ $VALIDATORS{some_attribute} || [] }; $self->{some_attribute} = $val; } return $self->{some_attribute}; } All this code is very nice, but you have to repeat your attribute code for every attribute. This means a lot of error-prone boilerplate code. You can get around this issue by learning to use closures or string eval to dynamically create your methods, or you can use one of Perl's many class generation libraries such as Class::Accessor, Class::Struct, Accessor::Tiny and so forth. Or you can learn [Moose][3]. Moose is the new(ish) object library that has been taking over Perl OOP practice. It provides a powerful set of features and dramatically reduces boilerplate over classical Perl OOP: use Moose; type 'Foo' => as 'Int' => where { $_ > 23 and $_ message 'Monkeys flew out my butt'; has 'some_attribute' => ( is => 'rw', isa => 'Foo', );
