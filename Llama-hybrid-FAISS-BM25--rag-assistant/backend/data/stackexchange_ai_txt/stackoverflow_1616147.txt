[site]: stackoverflow
[post_id]: 1616147
[parent_id]: 
[tags]: 
C memory management for Cross-platform VM

I asked a question about C-type sizes which I get a pretty good answer but I realized that I may not formulate the question very well to be useful for my purpose. My background was from Computer Engineer before moves to Software Engineer so I like computer architectures and always thinking about making VM. I've just finished an interesting project making VM on Java which I am quite proud with. But there is some legal problems I can't open-source it now and I am currently have some free time. So I want to see if I can make another VM on C (with better speed) just for fun and educational. The thing is I am not a C program the last time I wrote a non-trivia C problem was more than 10 years ago. I was Pascal, Delphi, and now Java and PHP programmer. There are number of obstacles I can foresee and I am trying to tackle one and that is accessing existing library (in Java, reflection solves this problem). I plan to solve this by having a buffer of data (similar to stack). The client of my VM can program to put data into these stack before giving me to pointer to native function. int main(void) { // Prepare stack int aStackSize = 1024*4; char *aStackData = malloc(aStackSize); // Initialise stack VMStack aStack; VMStack_Initialize(&aStack, (char *)aStackData, aStackSize); // Push in the parameters char *Params = VMStack_CurrentPointer(&aStack); VMStack_Push_int (&aStack, 10 ); // Push an int VMStack_Push_double(&aStack, 15.3); // Push a double // Prepare space for the expected return char *Result = VMStack_CurrentPointer(&aStack); VMStack_Push_double(&aStack, 0.0); // Push an empty double for result // Execute void (*NativeFunction)(char*, char*) = &Plus; NativeFunction(Params, Result); // Call the function // Show the result double ResultValue = VMStack_Pull_double(&aStack); // Get the result printf("Result: %5.2f\n", ResultValue); // Print the result // Remove the previous parameters VMStack_Pull_double(&aStack); // Pull to clear space of the parameter VMStack_Pull_int (&aStack); // Pull to clear space of the parameter // Just to be sure, print out the pointer and see if it is `0` printf("Pointer: %d\n", aStack.Pointer); free(aStackData); return EXIT_SUCCESS; } The push, pull and invocation of native function can be triggered by a byte code (that is how VM will later be made). For the sake of completeness (so that you can try it on you machine), here is the code for Stack: typedef struct { int Pointer; int Size; char *Data; } VMStack; inline void VMStack_Initialize(VMStack *pStack, char *pData, int pSize) __attribute__((always_inline)); inline char *VMStack_CurrentPointer(VMStack *pStack) __attribute__((always_inline)); inline void VMStack_Push_int(VMStack *pStack, int pData) __attribute__((always_inline)); inline void VMStack_Push_double(VMStack *pStack, double pData) __attribute__((always_inline)); inline int VMStack_Pull_int(VMStack *pStack) __attribute__((always_inline)); inline double VMStack_Pull_double(VMStack *pStack) __attribute__((always_inline)); inline void VMStack_Initialize(VMStack *pStack, char *pData, int pSize) { pStack->Pointer = 0; pStack->Data = pData; pStack->Size = pSize; } inline char *VMStack_CurrentPointer(VMStack *pStack) { return (char *)(pStack->Pointer + pStack->Data); } inline void VMStack_Push_int(VMStack *pStack, int pData) { *(int *)(pStack->Data + pStack->Pointer) = pData; pStack->Pointer += sizeof pData; // Should check the overflow } inline void VMStack_Push_double(VMStack *pStack, double pData) { *(double *)(pStack->Data + pStack->Pointer) = pData; pStack->Pointer += sizeof pData; // Should check the overflow } inline int VMStack_Pull_int(VMStack *pStack) { pStack->Pointer -= sizeof(int);// Should check the underflow return *((int *)(pStack->Data + pStack->Pointer)); } inline double VMStack_Pull_double(VMStack *pStack) { pStack->Pointer -= sizeof(double);// Should check the underflow return *((double *)(pStack->Data + pStack->Pointer)); } On the native function side, I created the following for testing purpose: // These two structures are there so that Plus will not need to access its parameter using // arithmetic-pointer operation (to reduce mistake and hopefully for better speed). typedef struct { int A; double B; } Data; typedef struct { double D; } DDouble; // Here is a helper function for displaying void PrintData(Data *pData, DDouble *pResult) { printf("%5.2f + %5.2f = %5.2f\n", pData->A*1.0, pData->B, pResult->D); } // Some native function void Plus(char* pParams, char* pResult) { Data *D = (Data *)pParams; // Access data without arithmetic-pointer operation DDouble *DD = (DDouble *)pResult; // Same for return DD->D = D->A + D->B; PrintData(D, DD); } When executed, the above code returns: 10.00 + 15.30 = 25.30 Result: 25.30 Pointer: 0 This work well on my machine (Linux x86 32bits GCC-C99). It will be very nice if this works on other OS/Architecture too. But there are AT LEAST three memory-related issures we have to be aware of. 1). Data size - It seems like if I compile both VM and native functions using the same compiler on the same architecture, the size types should be the same. 2). Endianness - Same with Data size. 3). Memory alignment - Which is the problem as padding-bytes may be added in struct but it is hard to synchronize it when prepare parameter stack as (there is no way to know how padding is added except for hard coding). My questions are: 1). If I know the size of the types, is there a way to modify push and pull function to exactly synchronize with struct padding? (modify to let compiler takes care of it like Datasize and Endians problems). 2). If I pack structure by one (using #pragma pack(1) ); (2.1) Will the performance penalty be acceptable? and (2.2) Will the program stability be at risk? 3). How about padding by 2,4, or 8? Which should be good for general 32 or 64 bits system? 4). Can you guide me to a documentation for an exact padding algorithm let say for GCC on x86? 5). Is there is a better way? NOTE: Cross-platform it is not my ultimate goal but I can't resist. Also, performance is not my target as soon as it is not so ugly. All these are for fun and learning. Sorry for my English and the very long post. Thanks everyone in advance.
