[site]: stackoverflow
[post_id]: 3239733
[parent_id]: 
[tags]: 
Replace Color Gradient In Transparent Image

I have small function which will recolor pixels in a Bitmap from a given color to a new given color. The problems I have with the code are as follows: 1) The function gives results which are remapping white pixels which should not be concidered since I have a threshold... (unless I have defined this calculation wrong) 2) When certain colors are given e.g. LimeGreen wierd results are seen in the image returned from the function (I beleive this is due to overflow of the byte type in the addition or subtraction case) The base image I am using can be found here: http://www.freeimagehosting.net/uploads/c8745a9de1.png Results I have obtained can be found here: freeimagehosting.net/uploads/fa48e5a0eb.png (Called with Color.Magenta as remapColor, Color.Red as newColor, Seems like white pixels are effected and the end of the gradient is not colored correctly) freeimagehosting.net/uploads/8faec6a569.png (Called with Color.Magenta as remapColor, Color.Yellow as newColor, Seems like white pixels are effected and the end of the gradient is not colored correctly) freeimagehosting.net/uploads/2efd4c04aa.png (Called with Color.Magenta as remapColor, Color.Blue as newColor, Seems like gradient not colored correctly) freeimagehosting.net/uploads/defdf04e16.png (Called with Color.Magenta as remapColor, Color.Teal as newColor, Seems like white pixels are effected and none of the gradient is calculated correctly) The function I have for this code is below: UPDATED per suggestions public unsafe static Bitmap RecolorImage(Bitmap original, Color remapColor, Color newColor) { Bitmap result = new Bitmap(original.Width, original.Height); //lock the original bitmap in memory BitmapData originalData = original.LockBits( new Rectangle(0, 0, original.Width, original.Height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb); //lock the new bitmap in memory BitmapData newData = result.LockBits( new Rectangle(0, 0, original.Width, original.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb); //set the number of bytes per pixel int pixelSize = 4; int rthreshold = 128; int gthreshold = 128; int bthreshold = 128; for (int y = 0; y 0 && Math.Abs(remapColor.R - r) remapColor.R) r = (byte)(r - newColor.R); else r = (byte)(r + newColor.R); } if (newColor.G == 0) { g = 0; } else { if (newColor.G > remapColor.G) g = (byte)(g - newColor.G); else g = (byte)(g + newColor.G); } if (newColor.B == 0) { b = 0; } else { if (newColor.B > remapColor.B) b = (byte)(b - newColor.B); else b = (byte)(b + newColor.B); } } //set the new image's pixel remaped pixel color nRow[x * pixelSize] = b; //B nRow[x * pixelSize + 1] = g; //G nRow[x * pixelSize + 2] = r; //R nRow[x * pixelSize + 3] = a; //A } } original.UnlockBits(originalData); result.UnlockBits(newData); return result; } What gives.... Is what I am trying to do possible? Is it reliable? Is there just a bug in my code? Is there a better way to achive this "re-mapable technique" on bitmaps using gradients? Thank you for your time.
