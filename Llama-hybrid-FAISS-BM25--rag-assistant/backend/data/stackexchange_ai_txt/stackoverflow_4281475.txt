[site]: stackoverflow
[post_id]: 4281475
[parent_id]: 4281068
[tags]: 
A way to get rid of those unwanted prints permanently would be to use bytecode manipulation to remove the print statements from the troublesome library. This can be done for example using ASM (or one of the other higher level and easier to use AOP frameworks). You can do this either at runtime or as a one-time operation of rewriting the library's class files. Refer to ASM's documentation to find out how. Here is a proof of concept. What it does is that it replaces all references to System.out with a reference to a PrintStream which does nothing. First the tests. They use some utility classes from my project to help with testing bytecode transformations (testing it requires creating a custom class loader and applying the bytecode transformations to the right class but not any other classes). package net.orfjackal.dimdwarf.aop; import net.orfjackal.dimdwarf.aop.conf.*; import org.junit.*; import org.objectweb.asm.*; import org.objectweb.asm.util.CheckClassAdapter; import java.io.*; import java.lang.instrument.ClassFileTransformer; import java.lang.reflect.*; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.*; public class RemoveCallsToSystemOutTest { private PrintStream originalOut; private ByteArrayOutputStream collectedOut; @Before public void collectSystemOut() { originalOut = System.out; collectedOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(collectedOut)); } @After public void restoreOriginalSystemOut() { System.setOut(originalOut); } @Test public void the_target_class_prints_when_not_manipulated() throws Exception { String safetyCheck = callPrintSomething(TroublesomePrinter.class); assertThat(safetyCheck, is("it did execute")); assertThat(collectedOut.size(), is(greaterThan(0))); } @Test public void the_target_class_does_not_print_when_it_has_been_manipulated() throws Exception { String safetyCheck = callPrintSomething(instrumentClass(TroublesomePrinter.class)); assertThat(safetyCheck, is("it did execute")); assertThat(collectedOut.size(), is(0)); } private static String callPrintSomething(Class clazz) throws Exception { Method m = clazz.getMethod("printSomething"); m.setAccessible(true); return (String) m.invoke(null); } private static Class instrumentClass(Class cls) throws ClassNotFoundException { ClassFileTransformer transformer = new AbstractTransformationChain() { protected ClassVisitor getAdapters(ClassVisitor cv) { cv = new CheckClassAdapter(cv); cv = new RemoveCallsToSystemOut(cv); return cv; } }; ClassLoader loader = new TransformationTestClassLoader(cls.getPackage().getName() + ".*", transformer); return loader.loadClass(cls.getName()); } } class TroublesomePrinter { public static String printSomething() { System.out.println("something"); return "it did execute"; } } And then the implementation. Please note that you should not use this code without first understanding it. Do not program by coincidence . class SilentSystem { public static final PrintStream out = new PrintStream(new OutputStream() { public void write(int b) { } }); } class RemoveCallsToSystemOut extends ClassAdapter { public RemoveCallsToSystemOut(ClassVisitor cv) { super(cv); } @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { return new MyMethodAdapter(super.visitMethod(access, name, desc, signature, exceptions)); } private static class MyMethodAdapter extends MethodAdapter { public MyMethodAdapter(MethodVisitor mv) { super(mv); } @Override public void visitFieldInsn(int opcode, String owner, String name, String desc) { if (opcode == Opcodes.GETSTATIC && owner.equals("java/lang/System") && name.equals("out") && desc.equals("Ljava/io/PrintStream;")) { super.visitFieldInsn(opcode, "net/orfjackal/dimdwarf/aop/SilentSystem", name, desc); } else { super.visitFieldInsn(opcode, owner, name, desc); } } } }
