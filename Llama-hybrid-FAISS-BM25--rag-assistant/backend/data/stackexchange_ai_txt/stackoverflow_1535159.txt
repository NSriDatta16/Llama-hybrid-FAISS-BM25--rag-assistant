[site]: stackoverflow
[post_id]: 1535159
[parent_id]: 1532819
[tags]: 
This can be done in one pass with an O(N log N) algorithm and no extra storage. Proceed from element a[1] to a[N] . At each stage i , all of the elements to the left of a[i] comprise a sorted heap of elements a[0] through a[j] . Meanwhile, a second index j , initially 0, keeps track of the size of the heap. Examine a[i] and insert it into the heap, which now occupies elements a[0] to a[j+1] . As the element is inserted, if a duplicate element a[k] is encountered having the same value, do not insert a[i] into the heap (i.e., discard it); otherwise insert it into the heap, which now grows by one element and now comprises a[0] to a[j+1] , and increment j . Continue in this manner, incrementing i until all of the array elements have been examined and inserted into the heap, which ends up occupying a[0] to a[j] . j is the index of the last element of the heap, and the heap contains only unique element values. int algorithm(int[] a, int n) { int i, j; for (j = 0, i = 1; i Looking at the example, this is not exactly what was asked for since the resulting array preserves the original element order. But if this requirement is relaxed, the algorithm above should do the trick.
