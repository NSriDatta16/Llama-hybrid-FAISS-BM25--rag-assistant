[site]: stackoverflow
[post_id]: 5262236
[parent_id]: 
[tags]: 
Are there alternatives to deriving classes from LINQ to SQL joins and [Table] mappings?

Pardon the length, please. Also, this is a completely hypothetical, off-the-cuff situation and code samples should not be scrutinized for complete accuracy. So, .Net plays nice when you have a simple, straightforward LINQ: Invoice tbl_invoice = from invoice in DbContext.Invoice where invoice.RecordID == 1 select invoice; Assuming there is an Invoice class as follows: [Table] public class Invoice { [Column] public int RecordID {get; set;} [Column] public DateTime RecordDate {get; set;} } Given the execution of the sample LINQ, the above class would be instanced with the appropriate values in the attributed Column properties. Let's advance the query a bit: var purchases = (from invoice in DbContext.Invoice join order in DbContext.Order on invoice.RecordID equals order.InvoiceID select new ProductPurchase { invoice.RecordID, invoice.RecordDate, order.PartID, order.Quantity }) .ToList(); // this is used to create a BindingList There must be two classes that resemble the following: [Table] public class Order { [Column] public int InvoiceID {get; set;} [Column] public string OrderID {get; set;} [Column] public string Quantity {get; set;} } [Table] public class ProductPurchase : Invoice { [Column] public int InvoiceID {get; set;} [Column] public string PartID {get; set;} [Column] public string Quantity {get; set;} } The goal in the second sample is to create a BindingList so that the data can be used as a DataSource. So with the second LINQ sample we could do the following: BindingList purchases = new BindingList (purchases); We cannot do this as easily as it seems. We must inherit concrete classes in order for this to work. In my opinion, this is highly inelegant. I thought, it sure would be nice if I could create an interface. Something like: [Table] public interface IInvoice { [Column] public int RecordID {get; set;} [Column] public DateTime RecordDate {get; set;} } Now, assume there is a similar IOrder interface, I could create a ProductPurchase concrete class as follows: [Table] public class ProductPurchase : IInvoice, IOrder { } ... IF the [TableAttribute()] were allowed on interfaces. Let's say I want to include a join to the PartID in tblParts that would retrieve a PartsDescription and PartsCost; only one base (concrete or abstract) class can be inherited. It seems like you have to create a bunch of junk derivations to be able to accommodate the joins. Is there an alternative? I grow weary of using DataTable/DataView as the data source to a DataGridView. It would be much simpler to be able to use the classes I've created as mappings. One example of a task I am trying to complete: List records in DataGridView displaying certain joined data. User double-clicks the selected datagrid row view. New WinForm displays queried info now from several joined tables In step 2, when the user selects an Invoice, I convert the DataGridRowView to a DataRow. Not so bad, really. But when I finish the query, I have an anonymous datatype which can be used to instance a new DataTable and populate the values of the DataRow. Binding the DataRow to the new WinForm is not as straightforward as binding a class. Thus my question and curiosity about alternatives. Any ideas would be helpful. EDIT: A couple of links that explain a little more: Code Project Linq2Sql - Explicit Construction of Entity Exception EDIT 2: Let's say I have a query from 3 tables: tblInvoices : InvoiceID | InvoiceDate | Balance | Paid | PaidDate tblPurchaseItem : PartNumber | InvoiceID | PartCost| PartDescription tblInventory : PartNumber | OnHands | ReOrder | Restock Assume there are 3 classes decorated with [Table] mapping attribute with all appropriate [Column] mapping attributes { get; set; }. I may have a method resembling the following: public static BindingList GetInvoiceDetails (int InvoiceID) { // LINQ is probably incorrect - feel free to post corrections :) IList invDetails = (from purchItems in DbContext.PurchaseItemsMap join invoices in DbContext.Invoices on purchItems.InvoiceID equals invoices.InvoiceID join invItems in DbContext.InventoryItemsMap on purchItems.PartNumber equals invItems.PartNumber where purchItems.InvoiceID == InvoiceID where invItems.Restock == true select new InvoiceDetails { invoices.InvoiceID, purchItems.PartDescription, purchItems.PartCost, invItems.OnHands }) .ToList(); return new BindingList(invDetails); } In order for this to work I would need the following: [Table] public class InvoiceDetails : PurchaseItems { // invoices column getters & setters } [Table] public class PurchaseItems : InventoryItems { // purchasItems column getters & setters } [Table] public class InventoryItems { // inventoryItems column getters & setters } Now, which is more nonsensical? Having to create weird combinations of class derivations that would create a maintenance nightmare; or, hypothetically, create interfaces for table mappings and simply derive classes like InvoiceDetails as follows: public class InvoiceDetails : IInventoryItems, IPurchaseItems, IInvoices { }
