[site]: stackoverflow
[post_id]: 3713518
[parent_id]: 3712954
[tags]: 
The lazy solution shown above is the most elegant, with one caveat which I'll mention below. Plan A You can code up your own version of Lazy pretty easily (this is untested code): class Lazy { private bool IsEvaluated; private T Value; private Func Suspension; public Lazy (Func susp) { Suspension = susp; } public static implicit operator T(Lazy thunk) { if (thunk.IsEvaluated) { return thunk.Value; } thunk.Value = thunk.Suspension(); thunk.IsEvaluated = true; return thunk.Value; } } Of course, you'll need to define overloaded arithmetic operators as well. Plan B Another way of tackling your problem is to sort your cells into increasing dependency order (where cell A depends on cell B if A contains a formula that uses B, directly or indirectly) and evaluate them in that order. Caveat If your dependencies contain a cycle then neither of these approaches is guaranteed to work since you will need to evaluate to a fixed point. In that case you probably need something like Plan B, but first break your dependency graph into strongly connected components (there is a good answer on SCCs on this site). Hope this helps.
