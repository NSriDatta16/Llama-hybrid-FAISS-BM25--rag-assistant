[site]: stackoverflow
[post_id]: 714666
[parent_id]: 
[tags]: 
Is it appropriate to extend Control to provide consistently safe Invoke/BeginInvoke functionality?

In the course of my maintenance for an older application that badly violated the cross-thread update rules in winforms, I created the following extension method as a way to quickly fix illegal calls when I've discovered them: /// /// Execute a method on the control's owning thread. /// /// The control that is being updated. /// The method that updates uiElement. /// True to force synchronous execution of /// updater. False to allow asynchronous execution if the call is marshalled /// from a non-GUI thread. If the method is called on the GUI thread, /// execution is always synchronous. public static void SafeInvoke(this Control uiElement, Action updater, bool forceSynchronous) { if (uiElement == null) { throw new ArgumentNullException("uiElement"); } if (uiElement.InvokeRequired) { if (forceSynchronous) { uiElement.Invoke((Action)delegate { SafeInvoke(uiElement, updater, forceSynchronous); }); } else { uiElement.BeginInvoke((Action)delegate { SafeInvoke(uiElement, updater, forceSynchronous); }); } } else { if (!uiElement.IsHandleCreated) { // Do nothing if the handle isn't created already. The user's responsible // for ensuring that the handle they give us exists. return; } if (uiElement.IsDisposed) { throw new ObjectDisposedException("Control is already disposed."); } updater(); } } Sample usage: this.lblTimeDisplay.SafeInvoke(() => this.lblTimeDisplay.Text = this.task.Duration.ToString(), false); I like how I can leverage closures to read, also, though forceSynchronous needs to be true in that case: string taskName = string.Empty; this.txtTaskName.SafeInvoke(() => taskName = this.txtTaskName.Text, true); I don't question the usefulness of this method for fixing up illegal calls in legacy code, but what about new code? Is it good design to use this method to update UI in a piece of new software when you may not know what thread is attempting to update the ui, or should new Winforms code generally contain a specific, dedicated method with the appropriate Invoke() -related plumbing for all such UI updates? (I'll try to use the other appropriate background processing techniques first, of course, e.g. BackgroundWorker.) Interestingly this won't work for ToolStripItems . I just recently discovered that they derive directly from Component instead of from Control . Instead, the containing ToolStrip 's invoke should be used. Followup to comments: Some comments suggest that: if (uiElement.InvokeRequired) should be: if (uiElement.InvokeRequired && uiElement.IsHandleCreated) Consider the following msdn documentation : This means that InvokeRequired can return false if Invoke is not required (the call occurs on the same thread), or if the control was created on a different thread but the control's handle has not yet been created. In the case where the control's handle has not yet been created, you should not simply call properties, methods, or events on the control. This might cause the control's handle to be created on the background thread, isolating the control on a thread without a message pump and making the application unstable. You can protect against this case by also checking the value of IsHandleCreated when InvokeRequired returns false on a background thread. If the control was created on a different thread but the control's handle has not yet been created, InvokeRequired returns false. This means that if InvokeRequired returns true , IsHandleCreated will always be true. Testing it again is redundant and incorrect.
