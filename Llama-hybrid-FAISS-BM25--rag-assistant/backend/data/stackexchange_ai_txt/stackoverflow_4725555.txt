[site]: stackoverflow
[post_id]: 4725555
[parent_id]: 4725077
[tags]: 
You can reuse this if you utilize functional programming. There are a number of libraries out there that have a lot of this stuff written for you. For this example, I simply used Guava (http://code.google.com/p/guava-libraries/), but libraries such as Functional Java (http://functionaljava.org/) would work just as well. One of the major benefits of functional programming is the capability to abstract away an algorithm so that you can reuse that algorithm wherever you need. For your case, your algorithm is essentially this: For each element in a list Do operation x to that element Return the new list The trick is being able to pass in a new operation in place of "x" depending on what you want to do. In the world of functional programming, we create an object called a "functor", which is really just a way to encapsulate a function in an object. (If Java had closures, this would be even easier, but this is what we have.) Anyway, here's a bit of code that will do what you want: Class: Inverse import com.google.common.base.Function; public class Inverse implements Function { @Override public Double apply(Double arg0) { return Math.pow(arg0, -1); } } Class: Logarithm import com.google.common.base.Function; public class Logarithm implements Function { @Override public Double apply(Double arg0) { return Math.log(arg0); } } Class: Driver import static org.junit.Assert.*; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.junit.Test; import com.google.common.collect.Collections2; public class Driver { @Test public void testInverse() { List initialValues = Arrays.asList(new Double[] {1.0, 2.0, 3.0}); List logValues = new ArrayList(Collections2.transform(initialValues, new Inverse())); assertEquals(3, logValues.size()); assertEquals(Double.valueOf(1.0), logValues.get(0), 0.01); assertEquals(Double.valueOf(0.5), logValues.get(1), 0.01); assertEquals(Double.valueOf(0.333), logValues.get(2), 0.01); } } The Driver class just contains a single test case, but it does illustrate the usage of the Functors defined above. You'll notice the use of a method called Collections2.transform in the testInverse method above. You can find the documentation for this method here: http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/collect/Collections2.html#transform%28java.util.Collection,%20com.google.common.base.Function%29 Essentially, what this method does is abstract away the algorithm of stepping over a list and applying some function to each element of that list - all you have to do is apply the function to perform. So, in this case, I pass to that method a list of Doubles and a functor (Inverse). It gives me back a new list that contains the inverse of every value in the initial list. If you would rather do logs of each value, pass a different functor to the transform method. This type of programming does come with a little bit of a learning curve, but it can be absolutely awesome for the type of code reuse you want to do. And by leveraging existing libraries (like Guava), you can make your code even easier to write. Notice the code I wrote is actually a little easier than what you had written because I don't have to deal with lists/arrays when performing my mathematical functions - I just perform it on one element; the transform function takes care of applying that function across an entire list.
