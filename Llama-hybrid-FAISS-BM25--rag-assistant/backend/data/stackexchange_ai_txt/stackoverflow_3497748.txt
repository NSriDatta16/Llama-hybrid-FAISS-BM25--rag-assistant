[site]: stackoverflow
[post_id]: 3497748
[parent_id]: 
[tags]: 
How would I organize these calls using Reactive Extensions (Rx) in Silverlight?

I have some calls that must execute sequentially. Consider an IService that has a Query and a Load method. The Query gives a list of widgets, and the load provides a "default" widget. Hence, my service looks like this. void IService.Query(Action ,Exception> callback); void IService.Load(Action callback); With that in mind, here is a rough sketch of the view model: public class ViewModel : BaseViewModel { public ViewModel() { Widgets = new ObservableCollection (); WidgetService.Query((widgets,exception) => { if (exception != null) { throw exception; } Widgets.Clear(); foreach(var widget in widgets) { Widgets.Add(widget); } WidgetService.Load((defaultWidget,ex) => { if (ex != null) { throw ex; } if (defaultWidget != null) { CurrentWidget = defaultWidget; } } }); } public IService WidgetService { get; set; } // assume this is wired up public ObservableCollection Widgets { get; private set; } private Widget _currentWidget; public Widget CurrentWidget { get { return _currentWidget; } set { _currentWidget = value; RaisePropertyChanged(()=>CurrentWidget); } } } What I'd like to do is simplify the sequential workflow of calling query and then the default. Perhaps the best way to do this is nested with lambda expressions as I've shown, but I figured there may be a more elegant way with Rx. I don't want to use Rx for the sake of Rx, but if it can allow me to organize the logic above so it is easier to read/maintain in the method, I'll take advantage of it. Ideally, something like: Observable.Create( ()=>firstAction(), ()=>secondAction()) .Subscribe(action=>action(),error=>{ throw error; }); With the power threading library, I'd do something like: Service.Query(list=>{result=list}; yield return 1; ProcessList(result); Service.Query(widget=>{defaultWidget=widget}; yield return 1; CurrentWidget = defaultWidget; That makes it far more evident that the workflow is sequential and eliminates nesting (the yields are part of the async enumerator and are boundaries that block until the results come back). Anything similar would make sense to me. So the essence of the question: am I trying to fit a square peg into a round hole, or is there a way to redefine the nested asynchronous calls using Rx?
