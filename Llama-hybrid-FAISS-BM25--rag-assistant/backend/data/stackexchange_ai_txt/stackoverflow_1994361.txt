[site]: stackoverflow
[post_id]: 1994361
[parent_id]: 1994303
[tags]: 
The program below has been coded by making the methods non-static. import java.util.Scanner; public class NumberArray2{ private int tab[]; // Now table becomes an instance variable. // allocation and initilization of the table now happens in the constructor. public NumberArray2() { Scanner Scan = new Scanner(System.in); System.out.println("How many numbers?"); int s = Scan.nextInt(); tab = new int[s]; System.out.println("Write a numbers: "); for(int i=0; i maxNum) maxNum = tab[i]; } System.out.println(maxNum); } public void divide(){ for(int i=0; i 2) || n == 2) { return true; } else { return false; } } public static void main(String[] args) { // instatiate the class. NumberArray2 obj = new NumberArray2(); System.out.println("Written numbers:"); obj.output(); // call the methods on the object..no need to pass table anymore. System.out.println("Largest number: "); obj.max(); System.out.println("All numbers that can be divided by three: "); obj.divide(); System.out.println("Average value: "); obj.average(); System.out.println("Prime numbers: "); obj.isPrime(); } } Changes made: int tab[] has now been made an instance variable. allocation and initialization of the table happens in the constructor. Since this must happen for every instantiated object, it is better to keep this in a constructor. The methods need not be called with table as an argument as all methods have full access to the instance variable(table in this case) The methods have now been made non-static, so they cannot be called using the class name, instead we need to instantiate the class to create an object and then call the methods on that object using the obj.method() syntax.
