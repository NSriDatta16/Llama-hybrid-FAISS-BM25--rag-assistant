[site]: stackoverflow
[post_id]: 4800651
[parent_id]: 4800337
[tags]: 
I tried golfing it a bit, still not a single method though: (1..9).chunk{|i|i%3==0}.reject{|sep,ans| sep}.map{|sep,ans| ans} Or faster: (1..9).chunk{|i|i%3==0 || nil}.map{|sep,ans| sep&&ans}.compact Also, Enumerable#chunk seems to be Ruby 1.9+, but it is very close to what you want. For example, the raw output would be: (1..9).chunk{ |i|i%3==0 }.to_a => [[false, [1, 2]], [true, [3]], [false, [4, 5]], [true, [6]], [false, [7, 8]], [true, [9]]] (The to_a is to make irb print something nice, since chunk gives you an enumerator rather than an Array) Edit : Note that the above elegant solutions are 2-3x slower than the fastest implementation: module Enumerable def split_by result = [a=[]] each{ |o| yield(o) ? (result
