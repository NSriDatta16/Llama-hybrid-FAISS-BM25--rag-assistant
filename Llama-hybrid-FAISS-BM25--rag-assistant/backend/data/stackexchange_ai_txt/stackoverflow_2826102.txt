[site]: stackoverflow
[post_id]: 2826102
[parent_id]: 2824243
[tags]: 
Remember that these aren't the typical software architecture problems that the usual 'design pattern' sets out to solve - they are game design problems, ie. a set of requirements for the end software. As such the typical software patterns don't really apply. And for that reason, there aren't really software patterns for the type of thing you describe because in most cases there is no agreed set of specifications and requirements across multiple games. These features typically depend heavily on the game design and the program structure follows from there. There are certainly examples given in various books - eg. the Game Programming Gems series is highly recommended - but they are just starting points which you must customise for your specific requirements. eg. Quests - Can they be repeated? Can a quest be 'failed' or do they remain incomplete? Do they contain multiple stages? Are there criteria that must be met before the quest can even be offered? Is there a journal that needs updating? Is there an automatic reward at the end? What are the conditions for completion, and how and when are they checked? Are certain events triggered by acceptance of the quest, or by its completion? Is there a notion of a player's progress within a quest? Are some quests mandatory? Are quests ordered in some way? All this will differ massively from game to game, based on the design. Now, there are a few techniques and approaches that game programmers find themselves using quite a lot, eg. embedding of a scripting language, spatial databases using 2D hashing or partitioning, finite state machines, etc., but these are really just generic tools that happen to map quite well to the problems game developers face.
