[site]: stackoverflow
[post_id]: 3746843
[parent_id]: 3742466
[tags]: 
Well the easy way to start is to consider how to rotate the bits in a single value. Let's say that you have x , which is an N -bit value and you want to rotate it by k places. (I'm only going to look at rotating upwards/left, it is easy to convert to downwards/right). The first thing to observe is that if k = N then x is unchanged. So before rotating we want to reduce k modulo N to throw away complete rotations. Next we should observe that during the rotation the k upper-bits will move to the bottom of the value, and the lower N-k bits will move up k places. This is the same as saying that the top k -bits move down N-k places. The reason that we phrase it this way is that C has shift operators, but not rotation. In psuedo-C we can say: #define N sizeof(type)*8 type rotate(type x, int k) { type lower = x & ((1 > (N-k) & ((1 This takes care of the simple atomic case, simply replace type with char or int as appropriate. If type is unsigned then the mask on the value of upper is unnecessary. The next thing to consider is rotating in an array of values. If you think of the above code as glueing together two halves of a value then for the more complicated case we need to glue together upper and lower parts from different places in the array. If k is small then these places are adjacent in the array, but when k>N we are rotating through more than one intermediate word. In particular if we are rotating up k places then we are moving bits from k/N words away in the array, and the N bits can span floor(k/N) and ceil(k/N) locations away in the array. Ok, so now we're ready to put it all together. For each word in the array the new upper N-(k mod N) bits will be the lower bits of floor(k/N) words away, and the new lower (k mod N) bits will be the upper bits of ceil(k/N) words away. In the same psuedo-C (i.e replace type with what you are using) we can say: #define N sizeof(type)*8 #define ARR_SIZE ... type rotate(type *x, int k,type *out) { int r = k % N; int upperOff = k/N; int lowerOff = (k+N-1)/N; for(int i=0; i > (N-k) & ((1 Anyway, that's a lot more than I was intending to write so I'll quit now. It should be easy enough to convert this to a form that works inplace on a single array, but you'll probably want to fix the types and the range of k first in order to bound the temporary storage. If you have any more problems in this area then one place to look is bitmap sprite graphics. For example this rotation problem was used to implement scrolling many, many moons ago in 8-bit games.
