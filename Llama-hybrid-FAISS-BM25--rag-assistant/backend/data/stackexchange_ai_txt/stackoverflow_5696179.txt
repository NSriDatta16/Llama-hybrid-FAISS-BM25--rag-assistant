[site]: stackoverflow
[post_id]: 5696179
[parent_id]: 
[tags]: 
Use of recursion in Scala when run in the JVM

From searching elsewhere on this site and the web, tail call optimization is not supported by the JVM. Does that therefore mean that tail recursive Scala code such as the following, which may run on very large input lists, should not be written if it is to run on the JVM? // Get the nth element in a list def nth[T](n : Int, list : List[T]) : T = list match { case Nil => throw new IllegalArgumentException case _ if n == 0 => throw new IllegalArgumentException case _ :: tail if n == 1 => list.head case _ :: tail => nth(n - 1, tail) } Martin Odersky's Scala by Example contains the following paragragh which seems to suggests that there are circumstances or other environments where recursion is appropriate: In principle, tail calls can always re-use the stack frame of the calling function. However, some run-time environments (such as the Java VM) lack the primitives to make stack frame re-use for tail calls efficient. A production quality Scala implementation is therefore only required to re-use the stack frame of a di- rectly tail-recursive function whose last action is a call to itself. Other tail calls might be optimized also, but one should not rely on this across implementations. Can anyone explain what this middle two sentences of this paragraph mean? Thank you!
