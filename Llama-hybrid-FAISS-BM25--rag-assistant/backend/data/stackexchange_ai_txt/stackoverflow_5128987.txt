[site]: stackoverflow
[post_id]: 5128987
[parent_id]: 5126881
[tags]: 
This test: if ([newManagedObject isKindOfClass:[myClass1 class]]) { ... is always going to fail because this line: NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context]; ... always defines newManagedObject as of class NSManagedObject . It is common to confuse entites, the NSManagedObject class and NSManagedObject subclasses. Entities are abstraction akin to class definitions. They tell the managed object context how the data in the object is to be structured. NSManagedObject is confusing because any generic instance of NSManagedObject can store data from any entity using associative storage. Associative storage works like a dictionary. The entity provides the keys to the dictionary. So, a line like this: NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context]; ... inserts a generic NSManagedObject instance into the context and then sets the key name of its associative storage to the names define by the entity. The class of the object is always NSManagedObject regardless of what entity provides its keys. You only see a different class when you create a subclass of NSManagedObject which is locked into a specific entity. The key names of the entity become the defined attributes of the class. I don't know exactly what you are shooting for in your design by shifting fetchedResultControllers. Normally, this produces a very confusing interface as users expect a single table to present the same data. Normally, you would use different tables to present data from different entities so that the users can orient themselves to the changes in data. However, if you still want to do it the simplest method would be to define a currentEntity attribute for your tableview controller. Like so: @property(nonatomic, retain) NSString *currentEntity; ... then add a test to your fetchedResultsController getter method: - (NSFetchedResultsController *)fetchedResultsController { if (fetchedResultsController != nil) { if ([[[fetchedResultsController entity] name] isEqualToString:self.currentEntity]) { return fetchedResultsController; } } // configure the FRC as normal but for the fetch entity name use currentEntity NSEntityDescription *entity = [NSEntityDescription entityForName:self.currentEntity inManagedObjectContext:managedObjectContext]; [fetchRequest setEntity:entity]; //.... Now, to change entities for the controllers fetch, you just need to change the name stored in currentEntity . The next time the FRC is called, it will automatically be reset to the new entity fetch. However, I've got to warn you that the FRC and the associated table methods are not really setup for swapping like this. You will have to be careful with the table updates and I don't think it will be reliable or stable.
