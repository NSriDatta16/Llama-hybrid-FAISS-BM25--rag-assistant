[site]: stackoverflow
[post_id]: 4952463
[parent_id]: 4952426
[tags]: 
This question really depends on whose responsibility it is to clean up the entries in the list. If your struct is responsible for cleaning up the memory referenced by the void * fields, then you have a much bigger problem at hand here, namely that given a void * referencing some arbitrary block of memory you can never know what the right way to deallocate it is. For example, if you have an implementation of a dynamic array along the lines of the C++ std::vector , then your void * might point at a struct that itself contains a pointer, and your list will need to know that it has to descend into that struct to recursively free its dynamically-allocated block. The case you're describing, where you're leaking a nested list - is just a special case of this more general issue. If, on the other hand, the list is not responsible for cleaning up the memory referenced by the void * s it stores, then you shouldn't worry about this problem at all. If your list does have ownership semantics and is required to clean up the memory for the elements stored in it, I would strongly discourage you from using a magic number to determine whether you have a nested list. Rather, you should probably have the client provide you a function pointer containing a deallocation routine to run on the elements inserted into the list. That way, your code can use the user's provided cleanup code to ensure that any elements stored in the list are cleaned up.
