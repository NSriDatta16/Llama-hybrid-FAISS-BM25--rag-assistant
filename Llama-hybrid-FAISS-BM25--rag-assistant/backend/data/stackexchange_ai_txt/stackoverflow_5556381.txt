[site]: stackoverflow
[post_id]: 5556381
[parent_id]: 5556256
[tags]: 
Already answered - PHP Recursive Backup Script Edit To add to an old, and extremely poor original answer... Here is a simple class which basically uses, PHP 5 >= 5.2.0 ZipArchive class - For zipping. PHP 5 RecursiveIteratorIterator class - For recursively scanning the path. Usage: You simply pass the project path as a construct parameter. It will recursively zip and store the project in a folder called ./project_backups/ , you can optionally set a second construct parameter to just send the file as a download. Something a little different from the other answers. ./path/to/project/yada [backup_file] => ./project_backups/yada.zip ) Alternatively set the second parameter and just send the project as a download. BackupMyProject('./path/to/project/yada', true); */ /** * Zip a directory into a backups folder, * optional send the zip as a download * * @author Lawrence Cherone * @version 0.1 */ class BackupMyProject{ // project files working directory - automatically created const PWD = "./project_backups/"; /** * Class construct. * * @param string $path * @param bool $download */ function __construct($path=null, $download=false){ // check construct argument if(!$path) die(__CLASS__.' Error: Missing construct param: $path'); if(!file_exists($path)) die(__CLASS__.' Error: Path not found: '.htmlentities($path)); if(!is_readable($path)) die(__CLASS__.' Error: Path not readable: '.htmlentities($path)); // set working vars $this->project_path = rtrim($path, '/'); $this->backup_file = self::PWD.basename($this->project_path).'.zip'; // make project backup folder if(!file_exists(self::PWD)){ mkdir(self::PWD, 0775, true); } // zip project files try{ $this->zipcreate($this->project_path, $this->backup_file); }catch(Exception $e){ die($e->getMessage()); } if($download !== false){ // send zip to user header('Content-Description: File Transfer'); header('Content-Type: application/zip'); header('Content-Disposition: attachment; filename="'.basename($this->backup_file).'"'); header('Content-Transfer-Encoding: binary'); header('Expires: 0'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Pragma: public'); header('Content-Length: '.sprintf("%u", filesize($this->backup_file))); readfile($this->backup_file); // cleanup unlink($this->backup_file); } } /** * Create zip from extracted/fixed project. * * @uses ZipArchive * @uses RecursiveIteratorIterator * @param string $source * @param string $destination * @return bool */ function zipcreate($source, $destination) { if (!extension_loaded('zip') || !file_exists($source)) { throw new Exception(__CLASS__.' Fatal error: ZipArchive required to use BackupMyProject class'); } $zip = new ZipArchive(); if (!$zip->open($destination, ZIPARCHIVE::CREATE)) { throw new Exception(__CLASS__. ' Error: ZipArchive::open() failed to open path'); } $source = str_replace('\\', '/', realpath($source)); if (is_dir($source) === true) { $files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($source), RecursiveIteratorIterator::SELF_FIRST); foreach ($files as $file) { $file = str_replace('\\', '/', realpath($file)); if (is_dir($file) === true) { $zip->addEmptyDir(str_replace($source.'/', '', $file.'/')); } else if (is_file($file) === true) { $zip->addFromString(str_replace($source.'/', '', $file), file_get_contents($file)); } } } return $zip->close(); } }
