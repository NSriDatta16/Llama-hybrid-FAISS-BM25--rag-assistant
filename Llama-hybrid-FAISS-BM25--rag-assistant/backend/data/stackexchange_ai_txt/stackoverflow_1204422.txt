[site]: stackoverflow
[post_id]: 1204422
[parent_id]: 1192145
[tags]: 
I have encountered a similar problem. Where I work, we have a set of libraries that get used by every client-side application we write, which contains cleanup code that needs to be executed upon application exit. AppDomain.CurrentDomain.ProcessExit works great for us, and we have to use that method because we can't rely on the top-level application (running Program.Main) to explicitly call our cleanup method, nor do we have any control over that (since it's not our code, it belongs to the user using our libraries). However... in your situation, I don't think you need to worry about a ProcessExit event to fire your cleanup code. You're writing some sort of network server, hosted in a console application. How about: public static void Main(string[] args) { StartUpMyServer(); Console.WriteLine("Press the ESCAPE key to shut down the server."); while (Console.ReadKey(true).Key != ConsoleKey.Escape); ShutDownMyServer(); } Then when the user presses ESCAPE, your server will be shut down. The really elegant way to do this for a networked server would be to create a Windows service, which will give you handy OnStart() and OnStop() methods, where you just include your appropriate start-up and shut-down code, and the Windows service manager handles calling those for you. Ultimately, the real problem is ensuring that you're not sleeping forever... you need some way to signal your application to exit. There are many ways to do it, it all depends on how you're intending your app to run.
