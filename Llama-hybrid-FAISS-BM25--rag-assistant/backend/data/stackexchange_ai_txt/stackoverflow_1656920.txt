[site]: stackoverflow
[post_id]: 1656920
[parent_id]: 1654967
[tags]: 
A better solution than passing in None — in this particular instance, rather than in general — is to treat the arr parameter to __init__ as an enumerable set of items to pre-initialize the FruitContainer with, rather than an array to use for internal storage: class FruitContainer: def __init__(self, arr=()): self.array = list(arr) ... This will allow you to pass in other enumerable types to initialize your container, which more advanced Python users will expect to be able to do: myFruit = ('apple', 'pear') # Pass a tuple myFruitContainer = FruitContainer(myFruit) myOtherFruit = file('fruitFile', 'r') # Pass a file myOtherFruitContainer = FruitContainer(myOtherFruit) It will also defuse another potential aliasing bug: myFruit = ['apple', 'pear'] myFruitContainer1 = FruitContainer(myFruit) myFruitContainer2 = FruitContainer(myFruit) myFruitContainer1.addTo('banana') 'banana' in str(myFruitContainer2) With all other implementations on this page, this will return True, because you have accidentally aliased the internal storage of your containers. Note: This approach is not always the right answer: "if not None" is better in other cases. Just ask yourself: am I passing in a set of objects, or a mutable container? If the class/function I'm passing my objects in to changes the storage I gave it, would that be (a) surprising or (b) desirable? In this case, I would argue that it is (a); thus, the list(...) call is the best solution. If (b), "if not None" would be the right approach.
