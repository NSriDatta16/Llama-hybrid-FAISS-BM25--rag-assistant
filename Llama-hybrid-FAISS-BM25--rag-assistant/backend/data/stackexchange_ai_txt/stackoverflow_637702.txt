[site]: stackoverflow
[post_id]: 637702
[parent_id]: 637672
[tags]: 
(removed approach bound to attributes) edit: and here's the meta-model way (so it works with mapping files as well as attributed objects): static TEntity Get (this DataContext ctx, int key) where TEntity : class { return Get (ctx, key); } static TEntity Get (this DataContext ctx, TKey key) where TEntity : class { var table = ctx.GetTable (); var pkProp = (from member in ctx.Mapping.GetMetaType(typeof(TEntity)).DataMembers where member.IsPrimaryKey select member.Member).Single(); ParameterExpression param = Expression.Parameter(typeof(TEntity), "x"); MemberExpression memberExp; switch (pkProp.MemberType) { case MemberTypes.Field: memberExp = Expression.Field(param, (FieldInfo)pkProp); break; case MemberTypes.Property: memberExp = Expression.Property(param, (PropertyInfo)pkProp); break; default: throw new NotSupportedException("Invalid primary key member: " + pkProp.Name); } Expression body = Expression.Equal( memberExp, Expression.Constant(key, typeof(TKey))); var predicate = Expression.Lambda >(body, param); return table.Single(predicate); }
