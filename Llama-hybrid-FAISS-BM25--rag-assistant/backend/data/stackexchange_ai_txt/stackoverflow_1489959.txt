[site]: stackoverflow
[post_id]: 1489959
[parent_id]: 1473900
[tags]: 
Ok, I have solved my own issue. It turns out that the method that Watir uses to enumerate IE windows (i.e. Shell.Application) does not work across user spaces. So I had to write an intermediate application to retrieve the IWebBrowser2 COM pointer for the IE window, and modify the 'eval_in_spawned_process' Watir function to use this handle for 'pc = Watir::IE.bind(iWebBrowserPtr)'. It's possible that I didn't need the external app to retrieve the IWebBrowser2 object, but I didn't know how to do it in Ruby, and I already had an IE BHO app that I could leverage for the purposes. This now works fine. :) Watir/page-container.rb:56 # This evaluates a cmd (e.g. "button(:id, 1).click!") in a new ruby process # This is to primarily avoid a script hanging while a modal dialog is displayed in IE. # It gets an IE handle from our IE BHO based off of window handle. It needs to do this # to get around the problem of finding the IE window itself using Shell.Application # which does not work across User-contexts. # Note: This change probably invalidates the Watir unit-test for this API. def eval_in_spawned_process(command) command.strip! load_path_code = _code_that_copies_readonly_array($LOAD_PATH, '$LOAD_PATH') ruby_code = "require 'watir/ie'; " ruby_code
