[site]: stackoverflow
[post_id]: 1795967
[parent_id]: 1793603
[tags]: 
First, two general remarks about your code: Use return True instead of return 1 . Use isinstance(form, list) instead of isinstance(form, type([])) . Second, some other observations: I assume you also want to get rid of double negations. Currently your code doesn't do that. Likewise, you'll need to apply one of DeMorgan's laws to push negations to the leaves. Aside from that, I think the readability of this code can be improved greatly. I'll give an alternative implementation which I believe to be correct. Let me know whether the code below works for you; I didn't go crazy with creating expressions, so I may have missed an edge case. Lastly, I will focus only on the regular propositional connectives. It should be clear how to apply transformations involving CTL-specific connectives. Create a class Op which represents an operator (connective): class Op(list): def __init__(self, *args): super().__init__(args) The arguments to __init__ are the operands. This code uses super as defined in PEP 3135 and works only in Python 3.x In Python 2.x, you'll have to use super as defined in PEP 367 : class Op(list): def __init__(self, *args): super(Op, self).__init__(args) Create simple subclasses of Op for each operator. For debugging purposes you may want to implement a custom __str__ method: class Neg(Op): def __str__(self): return '!(%s)' % tuple(self) class And(Op): def __str__(self): return '(%s) & (%s)' % tuple(self) class Or(Op): def __str__(self): return '(%s) | (%s)' % tuple(self) class AX(Op): def __str__(self): return 'AX (%s)' % tuple(self) ... Now the formula !(a & b) can be created as Neg(And('a', 'b')) . Create very simple functions which apply a certain transformation once . This will keep the implementation clean. Annotate these functions which some information on how they should be applied. A preorder function should be applied from top to bottom: first transform the root of the expression tree, then recurse. A postorder function should be applied to an expression after it has been recursively applied to subexpressions. Use isinstance to check the type of connectives. We start easy: the function removeDoubleNeg removes double negations: @expressionTransformation('postorder') def removeDoubleNeg(expr): if isinstance(expr, Neg) and isinstance(expr[0], Neg): return expr[0][0] Next, let's define one of DeMorgan's laws: @expressionTransformation('preorder') def deMorgan(expr): if isinstance(expr, Neg) and isinstance(expr[0], And): return Or(Neg(expr[0][0]), Neg(expr[0][1])) And now the function which this question is all about: @expressionTransformation('preorder', 'postorder') def distribute(expr): if isinstance(expr, And): if isinstance(expr[0], Or): return Or(And(expr[0][0], expr[1]), And(expr[0][1], expr[1])) if isinstance(expr[1], Or): return Or(And(expr[0], expr[1][0]), And(expr[0], expr[1][1])) Wow! That's a lot less code! Okay, so how does this work? Observe that any naive implementation of an expression transformation f will involve boilerplate code: Test whether the argument is a connective (as opposed to a constant or variable). Attempt to apply f to the root of the expression tree. Recurse. Return the result. Depending on f , step 1 and 2 may need to be reversed ( postorder instead of preorder ). Still, every implementation of f will look alike. You will want to avoid boilerplate code, especially if you plan to define many more transformations. It is the lack of this boilerplate that made the functions defined in the previous step so concise (and thus easy to debug!). The decorators returned by the function expressionTransformation solved this problem. Its implementation is as follows: from functools import wraps def expressionTransformation(*args): def wrap(f): @wraps(f) def recursiveTransformation(expr): if not isinstance(expr, Op): return expr if 'postorder' in args: expr[:] = map(recursiveTransformation, expr) res = f(expr) expr = expr if res is None else res if 'preorder' in args: expr[:] = map(recursiveTransformation, expr) return expr return recursiveTransformation return wrap What happens here is the following: The function expressionTransformation returns a decorator (named wrap ) which receives the transformation function f as its argument. wrap returns a recursive function recursiveTransformation which applies f to its argument expr only if this argument is a connective. Depending on the arguments args supplied to expressionTransformation , f will be applied before or after (or before and after) applying f to the subexpressions. The assumption is made that f may return None if no transformation is made. The function functools.wraps is used to copy certain properties of f , such as its name, to recursiveTransformation . This functionality is non-essential. (Note that there are more efficient way to create preorder and postorder transformations than using the tests 'postorder' in args and 'preorder' in args over and over, but I chose this for clarity.) That's all. We can now easily combine these functions (note that this function should not be decorated): def toDNF(expr): return distribute(removeDoubleNeg(deMorgan(expr))) You can test the code with statements like these: toDNF(AX(And(Or('a', 'b'), And(Or('c', 'd'), Or('e', 'f'))))) toDNF(Neg(And(Or(Neg(Neg('a')), 'b'), And(Or('c', 'd'), Or('e', 'f')))))
