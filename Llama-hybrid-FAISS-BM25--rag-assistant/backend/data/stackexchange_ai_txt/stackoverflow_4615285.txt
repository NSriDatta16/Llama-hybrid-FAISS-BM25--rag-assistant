[site]: stackoverflow
[post_id]: 4615285
[parent_id]: 3030649
[tags]: 
Drew is right, I think the ConcurrentQueue even though it sounds perfect for the job is actually the underlying data structure that the BlockingCollection uses. Seems very back to front to me too. Check out chapter 7 of this book* http://www.amazon.co.uk/Parallel-Programming-Microsoft-NET-Decomposition/dp/0735651590/ref=sr_1_1?ie=UTF8&qid=1294319704&sr=8-1 and it will explain how to use the BlockingCollection and have multiple producers and multiple consumers each taking off the "queue". You will want to look at the "GetConsumingEnumerable()" method and possibly just call .ToObservable() on that. *the rest of the book is pretty average. edit: Here is a sample program that I think does what you want? class Program { private static ManualResetEvent _mre = new ManualResetEvent(false); static void Main(string[] args) { var theQueue = new BlockingCollection (); theQueue.GetConsumingEnumerable() .ToObservable(Scheduler.TaskPool) .Subscribe(x => ProcessNewValue(x, "Consumer 1", 10000000)); theQueue.GetConsumingEnumerable() .ToObservable(Scheduler.TaskPool) .Subscribe(x => ProcessNewValue(x, "Consumer 2", 50000000)); theQueue.GetConsumingEnumerable() .ToObservable(Scheduler.TaskPool) .Subscribe(x => ProcessNewValue(x, "Consumer 3", 30000000)); LoadQueue(theQueue, "Producer A"); LoadQueue(theQueue, "Producer B"); LoadQueue(theQueue, "Producer C"); _mre.Set(); Console.WriteLine("Processing now...."); Console.ReadLine(); } private static void ProcessNewValue(string value, string consumerName, int delay) { Thread.SpinWait(delay); Console.WriteLine("{1} consuming {0}", value, consumerName); } private static void LoadQueue(BlockingCollection target, string prefix) { var thread = new Thread(() => { _mre.WaitOne(); for (int i = 0; i
