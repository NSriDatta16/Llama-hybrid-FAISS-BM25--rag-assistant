[site]: stackoverflow
[post_id]: 5559242
[parent_id]: 5559135
[tags]: 
I'd allocate on the stack only if the lifetime of the allocated object is tightly bound to the procedural scope. If you ever need to pass references around that might (need to) be kept after the function returns, you need to dynamically allocate it. Of course in C++ the point quickly becomes moot for the actual storage volumes, since e.g. STL containers (vector, list, map et friends) do their element allocations dynamically anyway [1] So it really is about lifetimes. I find myself managing lifetimes by class-responsability rather than function scope[1]. I regularly end up with a single Application (class) instance containing all 'global' objects, each containing their objects etc. The application object can be a static global, or just a stack alloc-ed local variable in main - it doesn't matter much as long as you don't declare a const char [300][400] member in it :) $0.02 [1] that is: in the absense of a particularly mischievous custom allocator which you are probably not interested in at the moment :) [2] With closures, function scope can get eerily close to class responsability - in the same way that functional languages use closures to mimic OOP patternss
