[site]: stackoverflow
[post_id]: 400246
[parent_id]: 
[tags]: 
Creating a local Token cache using the Geneva Framework

Haven't seen many Geneva related questions yet, I have posted this question in the Geneva Forum as well... I'm working on a scenario where we have a win forms app with a wide installbase, which will be issuing frequent calls to various services hosted by us centrally throughout it's operation. The services are all using the Geneva Framework and all clients are expected to call our STS first to be issued with a token to allow access to the services. Out of the box, using the ws2007FederationHttpBinding, the app can be configured to retrieve a token from the STS before each service call, but obviously this is not the most efficient way as we're almost duplicating the effort of calling the services. Alternatively, I have implemented the code required to retrieve the token "manually" from the app, and then pass the same pre-retrieved token when calling operations on the services (based on the WSTrustClient sample and helpon the forum); that works well and so we do have a solution,but I believeit's not very elegant as it requires building the WCF channel in code, moving away from the wonderful WCF configuration. I much prefer the ws2007FederationHttpBinding approach where by the client simply calls the service like any other WCF service, without knowing anything about Geneva, and the bindings takes care of the token exchange. Then someone (Jon Simpson) gave me [what I think is] a great idea - add a service, hosted in the app itself to cache locally retrieved tokens. The local cache service would implement the same contract as the STS; when receiveing a request it would check to see if a cahced token exists, and if so would return it, otherwise it would call the 'real' STS, retrive a new token, cache it and return it. The client app could then still use ws2007FederationHttpBinding, but instead of having the STS as the issuer it would have the local cache; This way I think we can achieve the best of both worlds - caching of tokens without the service-sepcific custom code; our cache should be able to handle tokens for all RPs. I have created a very simple prototype to see if it works, and - somewhat not surprising unfortunately - I am slightly stuck - My local service (currently a console app) gets the request, and - first time around - calls the STS to retrieve the token, caches it and succesfully returns it to the client which, subsequently, uses it to call the RP. all works well. Second time around, however, my local cahce service tries to use the same token again, but the client side fails with a MessageSecurityException - "Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties. This can occur if the service is configured for security and the client is not using security." Is there something preventing the same token to be used more than once? I doubt it because when I reused the token as per the WSTrustClient sample it worked well; what am I missing? is my idea possible? a good one? Here's the (very basic, at this stage) main code bits of the local cache - static LocalTokenCache.STS.Trust13IssueResponse cachedResponse = null; public LocalTokenCache.STS.Trust13IssueResponse Trust13Issue(LocalTokenCache.STS.Trust13IssueRequest request) { if (TokenCache.cachedResponse == null) { Console.WriteLine("cached token not found, calling STS"); //create proxy for real STS STS.WSTrust13SyncClient sts = new LocalTokenCache.STS.WSTrust13SyncClient(); //set credentials for sts sts.ClientCredentials.UserName.UserName = "Yossi"; sts.ClientCredentials.UserName.Password = "p@ssw0rd"; //call issue on real sts STS.RequestSecurityTokenResponseCollectionType stsResponse = sts.Trust13Issue(request.RequestSecurityToken); //create result object - this is a container type for the response returned and is what we need to return; TokenCache.cachedResponse = new LocalTokenCache.STS.Trust13IssueResponse(); //assign sts response to return value... TokenCache.cachedResponse.RequestSecurityTokenResponseCollection = stsResponse; } else { } //...and reutn return TokenCache.cachedResponse;
