[site]: crossvalidated
[post_id]: 636944
[parent_id]: 636792
[tags]: 
I'm assuming you want the linear predictor, response residuals (others are not defined for this link family), and possibly some kind of pseudo-R2 from your coefficients. Anything beyond that will require a very deep dive into the guts of glmmTMB and this is already very close to a programming question which is off-topic on this site. Reconstructing the linear predictor is easy enough: just multiply your averaged coefficients by the design matrix. linp $fit$ par[1:4])) > [1] -0.03805171 -1.41477115 -0.76106155 0.34344611 1.15593206 ## Note that this matches `predict()` all.equal(orig, predict(model)) > TRUE ## Do the same for the updated coefficients dredged [1] 0.04027557 -0.89044152 -0.02504540 1.20635796 1.38840273 These are your fitted values in the log-odds scale. In a pinch you can overwrite model$fit$par[1:4] with these coefficients and get the same result using predict(..., fast=FALSE) , the other parameters are not required to calculate predicted means. Calculating predicted responses and residuals is the same as you would for any other model (deviance and Pearson aren't implemented in your chosen link): expit [1] -0.01006753 -0.09101872 -0.19373898 -0.16965390 -0.05033713 ## Confirm this matches `resid()` - names differ all(y - expit(orig) == resid(model, type="response")) > TRUE The performance::r2 function you mentioned doesn't seem to know what to do with your original model. You can calculate a pseudo-R2 as described in the link above: x $fit$ par[1:4])**2 > 0.522 ## Dredged weighted means cor(qlogis(y), x %*% coeffs)**2 > 0.242 At least in this dummy example it doesn't look like your dredged coefficients did that great. If you need more, such as standard error predictions, that will require the betad / psi parameters in the fit and I couldn't tell you how to update these without refitting the model.
