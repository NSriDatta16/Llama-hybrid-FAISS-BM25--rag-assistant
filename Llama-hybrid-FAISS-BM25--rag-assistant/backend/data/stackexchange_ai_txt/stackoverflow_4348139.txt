[site]: stackoverflow
[post_id]: 4348139
[parent_id]: 4347839
[tags]: 
A hackish solution [Edited solution] var clickDown = false; var currentlySelected = null; $("#ListBox").mousedown(function (event) { clickDown = this; }); $(document).mouseup(function () { setTimeout(function() { if (clickDown) { if (currentlySelected != clickDown.selectedIndex) { alert("change"); currentlySelected = clickDown.selectedIndex; } clickDown = false; } }, 0); }); Basically on mouseDown we set a flag saying you click on the listbox. Then we check every mouseUp in the entire document. We wrap the entire function in a timeout to ensure that IE8 sets the selectedIndex correctly. And if the clickDown flag is set we know that the clickUp came from a listbox. For convience I also store the listbox object in the flag since (object === true) in javascript. Then we simply check if our variable containing the current index has changed. If so a change occurs and we update that variable to reflect the new index. Finally we have to set clickDown to false again outer wise other click ups in the document would think there from the listbox. This involves checking every click up and is by no means an elegant solution http://jsfiddle.net/as7EN/37/ [Edit] That only fixed it for chrome. Not for IE8. Working on it. I've narrowed it down to the fact that IE changes the selectedIndex after the mouseUp event is triggered. This bug can be avoided by wrapping it in a timeOut so that the function gets called after IE8 sets selectedIndex to the real value. I dont care about IE6/7 fix that yourself. Also if you want multiselect to work tell me and I'll hack that around aswell
