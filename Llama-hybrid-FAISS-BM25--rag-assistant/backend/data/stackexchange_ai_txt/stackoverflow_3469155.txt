[site]: stackoverflow
[post_id]: 3469155
[parent_id]: 3469080
[tags]: 
Summary Use \h to match horizontal whitespace, in perl since v5.10.0 (released in 2007) For non- PCRE engines, use a double-negative: [^\S\r\n] Unicode properties: \p{Blank} or \p{HorizSpace} Be direct, in ASCII: [\t\f\cK ] Be direct, in Unicode (but don’t, really) Other applications of double-negatives and Unicode properties Horizontal Whitespace The “Character Classes and other Special Escapes” section of perlre includes \h Horizontal whitespace \H Not horizontal whitespace Double-Negative If you might use your pattern with other engines, particularly ones that are not Perl-compatible or otherwise don’t support \h , express it as a double-negative: [^\S\r\n] That is, not-not-whitespace (the capital S complements) or not-carriage-return or not-newline. Distributing the outer not ( i.e. , the complementing ^ in the bracketed character class ) with De Morgan’s law , this is equivalent to subtracting \r and \n from \s . Including both carriage return and newline in the pattern correctly handles all of Unix (LF), classic Mac OS (CR), and DOS-ish (CRLF) newline conventions . No need to take my word for it: #! /usr/bin/env perl use strict; use warnings; my $ws_not_crlf = qr/[^\S\r\n]/; for (' ', '\f', '\t', '\r', '\n') { my $qq = qq["$_"]; printf "%-4s => %s\n", $qq, (eval $qq) =~ $ws_not_crlf ? "match" : "no match"; } Output: " " => match "\f" => match "\t" => match "\r" => no match "\n" => no match Note the exclusion of vertical tab, but this is addressed in v5.18 . Before objecting too harshly, the Perl documentation uses the same technique. A footnote in the “Whitespace” section of perlrecharclass reads Prior to Perl v5.18, \s did not match the vertical tab. [^\S\cK] (obscurely) matches what \s traditionally did. Unicode Properties The aforementioned perlre documentation on \h and \H references the perlunicode documentation where we read about a family of useful Unicode properties. \p{Blank} This is the same as \h and \p{HorizSpace} : A character that changes the spacing horizontally. \p{HorizSpace} This is the same as \h and \p{Blank} : a character that changes the spacing horizontally. The Direct Approach: ASCII Edition The “Whitespace” section of perlrecharclass also suggests other approaches that won’t offend grammar instructors’ opposition to double-negatives. Say what you want rather than what you don’t. Outside locale and Unicode rules or when the /a or /aa switch is in effect, “ \s matches [\t\n\f\r ] and, starting in Perl v5.18, the vertical tab, \cK .” To match whitespace but not newlines (broadly), discard \r and \n to leave [\t\f\cK ] The Direct Approach: Unicode Edition If your text is Unicode, use code similar to the sub below to construct a pattern from the table in the “Whitespace” section of perlrecharclass . sub ws_not_nl { local($_) = This above is for completeness. Use the Unicode properties rather than writing it out longhand. Other Applications The double-negative trick is also handy for matching alphabetic characters too. Remember that \w matches “word characters,” alphabetic characters and digits and underscore. We ugly-Americans sometimes want to write it as, say, if (/[A-Za-z]+/) { ... } but a double-negative character-class can respect the locale: if (/[^\W\d_]+/) { ... } Expressing “a word character but not digit or underscore” this way is a bit opaque. A POSIX character-class communicates the intent more directly if (/[[:alpha:]]+/) { ... } or with a Unicode property as szbalint suggested if (/\p{Letter}+/) { ... } Pingui asked about nesting the double-negative character class to effectively modify the \s in /(\+|0|\()[\d()\s-]{6,20}\d/g The best I could come up with is to use | for an alternative and move the \s to the other branch: /(\+|0|\()(?:[\d()-]|[^\S\r\n]){6,20}\d/g
