[site]: stackoverflow
[post_id]: 3592283
[parent_id]: 
[tags]: 
Camera force close when returning from sleep. Android

In my app I'm capturing an image. Everything is working fine unless the phone goes to sleep while the preview is running. Not really sure how to handle it, I'm thinking that it may be best just to prevent the phone from automatically going to sleep while this process is in action. Which i do not know how to do. and if i do that will it prevent the phone from sleeping when i press the power button? perhaps there is a deeper issue here. LogCat: 08-28 16:17:10.879: WARN/dalvikvm(9652): threadid=3: thread exiting with uncaught exception (group=0x4001b390) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): Uncaught handler: thread main exiting due to uncaught exception 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): java.lang.RuntimeException: Method called after release() 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at android.hardware.Camera.setHasPreviewCallback(Native Method) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at android.hardware.Camera.access$600(Camera.java:58) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at android.hardware.Camera$EventHandler.handleMessage(Camera.java:339) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at android.os.Handler.dispatchMessage(Handler.java:99) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at android.os.Looper.loop(Looper.java:123) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at android.app.ActivityThread.main(ActivityThread.java:4595) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at java.lang.reflect.Method.invokeNative(Native Method) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at java.lang.reflect.Method.invoke(Method.java:521) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:860) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:618) 08-28 16:17:10.879: ERROR/AndroidRuntime(9652): at dalvik.system.NativeStart.main(Native Method) takephoto activity: public class takephoto extends Activity { private static final String TAG = "GrowJournalDemo"; Preview preview; // Button buttonClick; // String journ_id; String plant_id; // private String plantid = ((resource) this.getApplication()).getplantId(); /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.photo); preview = new Preview(this); // ((FrameLayout) findViewById(R.id.preview)).addView(preview); // String journalid = ((resource) this.getApplication()).getjournalName(); plant_id = ((resource) this.getApplication()).getplantId(); journ_id = journalid; buttonClick = (Button) findViewById(R.id.buttonClick); buttonClick.setOnClickListener(new OnClickListener() { public void onClick(View v) { // // preview.camera.takePicture(shutterCallback, rawCallback, jpegCallback); preview.camera.autoFocus(new Camera.AutoFocusCallback() { Camera.ShutterCallback shutterCallback = new Camera.ShutterCallback() { public void onShutter() { // Play your sound here. } }; public void onAutoFocus(boolean success, Camera camera) { preview.camera.takePicture(null, null, jpegCallback); } }); } }); Log.d(TAG, "onCreate'd"); } // Called when shutter is opened ShutterCallback shutterCallback = new ShutterCallback() { // public void onShutter() { Log.d(TAG, "onShutter'd"); } }; // Handles data for raw picture PictureCallback rawCallback = new PictureCallback() { // public void onPictureTaken(byte[] data, Camera camera) { Log.d(TAG, "onPictureTaken - raw"); } }; // Handles data for jpeg picture PictureCallback jpegCallback = new PictureCallback() { // public void onPictureTaken(byte[] data, Camera camera) { FileOutputStream outStream = null; try { android.os.Environment.getExternalStorageState(); // create a File object for the parent directory File PhotoDirectory = new File( android.os.Environment.getExternalStorageDirectory()+ "/GrowJournalPhotos/"+journ_id+"/"+plant_id+"/"); // have the object build the directory structure, if needed. PhotoDirectory.mkdirs(); // create a File object for the output file File outputFile = new File(PhotoDirectory, "photo.jpg"); // now attach the OutputStream to the file object, instead of a String representation outStream = new FileOutputStream(outputFile); outStream.write(data); outStream.close(); Log.d(TAG, "onPictureTaken - wrote bytes: " + data.length); setResult(RESULT_OK); finish(); } catch (FileNotFoundException e) { // e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { } Log.d(TAG, "onPictureTaken - jpeg"); } }; } Preview surfaceview: public class Preview extends SurfaceView implements SurfaceHolder.Callback { private static final String TAG = "Preview"; SurfaceHolder mHolder; // public Camera camera; // Preview(Context context) { super(context); // Install a SurfaceHolder.Callback so we get notified when the // underlying surface is created and destroyed. mHolder = getHolder(); // mHolder.addCallback(this); // mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); // } // Called once the holder is ready public void surfaceCreated(SurfaceHolder holder) { // // The Surface has been created, acquire the camera and tell it where // to draw. camera = Camera.open(); // try { camera.setPreviewDisplay(holder); // camera.setPreviewCallback(new PreviewCallback() { // // Called for each frame previewed public void onPreviewFrame(byte[] data, Camera camera) { // Log.d(TAG, "onPreviewFrame called at: " + System.currentTimeMillis()); Preview.this.invalidate(); // } }); } catch (IOException e) { // e.printStackTrace(); } } // Called when the holder is destroyed public void surfaceDestroyed(SurfaceHolder holder) { // camera.stopPreview(); camera.release(); camera = null; } // Called when holder has changed public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) { // camera.startPreview(); } } I've added a wake lock to prevent the phone from dimming, I feel this is a temporary solution though as there is still a force close when the device is forced to sleep via power button.
