[site]: stackoverflow
[post_id]: 3345099
[parent_id]: 3345003
[tags]: 
Containers don't become invalidated -- iterators referring to elements in containers become invalidated. An iterator is a handle to a particular item within a container. The iterator is valid so long as that item remains inside the container, and the container does not internally rearrange itself. An iterator is invalidated when one of those two things happens, since afterwords the iterator is no longer valid as a handle into the container. The most obvious way to invalidate an iterator is to remove its referred-to item from the collection, e.g.: std::set s; s.insert(4); s.insert(2); std::set ::iterator itr = s.find(4); // itr is a handle to 4 std::cout The more subtle way to invalidate an iterator is to cause the container to internally rearrange itself (e.g. reallocate its internal storage). This can be done, for example, by causing certain types of containers to expand: std::vector v; v.push_back(4); v.push_back(2); std::vector ::iterator itr = v.begin(); // itr is a handle to 4 std::cout You can prevent this in some containers by pre-reserving space: std::vector v; v.reserve(3); // Pre-allocate 3 elements v.push_back(4); v.push_back(2); std::vector ::iterator itr = v.begin(); // itr is a handle to 4 std::cout The documentation for each STL container should describe under what circumstances iterator invalidation will or might occur.
