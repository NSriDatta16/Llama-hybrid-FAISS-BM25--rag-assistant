[site]: stackoverflow
[post_id]: 233255
[parent_id]: 
[tags]: 
How does SetUnhandledExceptionFilter work in .NET WinForms applications?

I am working on a project to enhance our production debugging capabilities. Our goal is to reliably produce a minidump on any unhandled exception, whether the exception is managed or unmanaged, and whether it occurs on a managed or unmanaged thread. We use the excellent ClrDump library for this currently, but it does not quite provide the exact features we need, and I'd like to understand the mechanisms behind exception filtering, so I set out to try this for myself. I started out by following this blog article to install an SEH handler myself: http://blogs.microsoft.co.il/blogs/sasha/archive/2007/12.aspx . This technique works for console applications, but when I try the same thing from a WinForms application, my filter is not called for any variety of unmanaged exceptions. What can ClrDump be doing that I'm not doing? ClrDump produces dumps in all cases, so its exception filter must still be called... Note: I'm aware of ADPlus's capabilities, and we've also considered using the AeDebug registry keys... These are also possibilities, but also have their tradeoffs. Thanks, Dave // Code adapted from LONG WINAPI MyExceptionFilter(__in struct _EXCEPTION_POINTERS *ExceptionInfo) { printf("Native exception filter: %X\n",ExceptionInfo->ExceptionRecord->ExceptionCode); Beep(1000,1000); Sleep(500); Beep(1000,1000); if(oldFilter_ == NULL) { return EXCEPTION_CONTINUE_SEARCH; } LONG ret = oldFilter_(ExceptionInfo); printf("Other handler returned %d\n",ret); return ret; } #pragma managed namespace SEHInstaller { public ref class SEHInstall { public: static void InstallHandler() { oldFilter_ = SetUnhandledExceptionFilter(MyExceptionFilter); printf("Installed handler old=%x\n",oldFilter_); } }; }
