[site]: stackoverflow
[post_id]: 4698132
[parent_id]: 4697877
[tags]: 
Relative jumps make it possible for compilers to generate relocatable code, which means the code will run anywhere in memory; it's not tied to a fixed location. This is the critical concept behind libraries: you can write the code once and compile it into a relocatable object file that can be linked as-is into any program. The linker needs to assign absolute addresses only for the functions that are externally accessible (so your own code can find them); all of the "internal" jumps are relative and needn't change from one executable to the next. It's worth your time to write some code in a high-level language like C, have the compiler generate assembly code (check the -S option to gcc), and then read the assembly output. Pay special attention to conditionals and loops, such as if , for , and while , and you'll see that they all generate relative jumps. Here's a contrived example using fictitious assembly instructions: // Sample C code Address Assembly Code Comments if (x =10 } else { 0005 SUB do_true_stuff ; x =10) do_more_stuff(); 000D SUB do_more_stuff ; Finished if/else Here, the compiler generates relative jumps ( JGE and JMP ) to skip over the un-executed branch of the if-else block. These jumps will work no matter where in memory the linker puts the code. If they were absolute jumps the linker would need to recalculate the addresses each time it linked the code. You'll even find that many function calls will generate relative jumps, particularly if the functions are scoped within a single file. Not only does this speed up the linking process, but it makes the running code smaller and more efficient, too. That's because relative addresses are typically limited to a much smaller range than absolute addresses, which means they can be represented in fewer bytes. Hope that helps!
