[site]: stackoverflow
[post_id]: 5369671
[parent_id]: 5205240
[tags]: 
Here is some pseudocode for one way you could test your database with RSpec: describe "prc_liste_motif" do before(:all) do # Set up database connection here end describe "good values" do context "Le beau chien" do let(:texte) { "Le beau chien" } # Set up other variables here let(:results) { # call prc_liste_motif here } it "has the correct out_nb_motif" do out_nb_motif = # however you derive this from the results of the procedure out_nb_motif.should == 3 end it "has the correct out_positions" do # test out_positions here end end end end One thing I noticed in your sample manual test was how you are checking the results: SELECT @nb_motif = @out_nb_motif AND @positions = @out_positions; This will tell you whether or not those two values are correct, but if you get 0 results for this query, you do not immediately know which of the two values is incorrect and you do not know what the value you are getting instead is; getting that information requires more investigation. By splitting up the checking for these two values into 2 RSpec tests, when the tests have finished running you can know if both are correct, if one is incorrect, or if both are incorrect. If one or both are incorrect, RSpec will also return a message for the failed test that says "Expected 3, got 4" which can help you debug faster. As you add more tests for different inputs, I recommend refactoring the pseudocode I've given here to use shared_examples_for. The PragProg RSpec book that you're already reading is a great reference.
