[site]: stackoverflow
[post_id]: 2775468
[parent_id]: 2771407
[tags]: 
In answer to your actual question: You should add a DepencyPropertyChanged handler, as you mentioned. In this handler, you should add an event handler to the CollectionChanged property on the new collection and remove the handler from the old collection, like this: public ObservableCollection WorkItems { get { return (ObservableCollection )GetValue(WorkItemsProperty); } set { SetValue(WorkItemsProperty, value); } } // Using a DependencyProperty as the backing store for WorkItems. This enables animation, styling, binding, etc... public static readonly DependencyProperty WorkItemsProperty = DependencyProperty.Register("WorkItems", typeof(ObservableCollection ), typeof(DragGrid), new FrameworkPropertyMetadata(null, OnWorkItemsChanged)); private static void OnWorkItemsChanged(object sender, DependencyPropertyChangedEventArgs e) { DragGrid me = sender as DragGrid; var old = e.OldValue as ObservableCollection ; if (old != null) old.CollectionChanged -= me.OnWorkCollectionChanged; var n = e.NewValue as ObservableCollection ; if (n != null) n.CollectionChanged += me.OnWorkCollectionChanged; } private void OnWorkCollectionChanged(object sender, NotifyCollectionChangedEventArgs e) { if (e.Action == NotifyCollectionChangedAction.Reset) { // Clear and update entire collection } if (e.NewItems != null) { foreach (WorkItem item in e.NewItems) { // Subscribe for changes on item item.PropertyChanged += OnWorkItemChanged; // Add item to internal collection } } if (e.OldItems != null) { foreach (WorkItem item in e.OldItems) { // Unsubscribe for changes on item item.PropertyChanged -= OnWorkItemChanged; // Remove item from internal collection } } } private void OnWorkItemChanged(object sender, PropertyChangedEventArgs e) { // Modify existing item in internal collection } As gehho explained, it sounds like you are not using the Grid class as originally intended, although you may be too far into development to want to start over at this point. Classes derived from Panel are actually intended only to visually draw/arrange their children, rather than manipulating and enhancing them. Check out ItemsControl and the WPF Content Model to learn more.
