[site]: stackoverflow
[post_id]: 2929404
[parent_id]: 2928886
[tags]: 
(Reference http://graphics.stanford.edu/~seander/bithacks.html#Interleave64bitOps ): If your number is below 256, you may use @magic def double_digits_holger8(x): m = (x * 0x0101010101010101 & 0x8040201008040201) * 0x0102040810204081 return ((m >> 49) & 0x5555) | ((m >> 48) & 0xAAAA) and if it is below 65536, @more_magic def double_digits_binmag16(x): x = (x | x Comparison with other solutions (the function must take an integer and return an integer for fair comparison): Method Time per 256 calls -------------------------------- Do nothing 46.2 usec Holger8 256 usec BinMag16 360 usec Mark 367 usec # http://stackoverflow.com/questions/2928886/doubling-binary-digits/2929198#2929198 Max 720 usec # http://stackoverflow.com/questions/2928886/doubling-binary-digits/2928938#2928938 Peter 1.08 msec # http://stackoverflow.com/questions/2928886/doubling-binary-digits/2928973#2928973 Phiµµ w/o Log 1.11 msec # http://stackoverflow.com/questions/2928886/doubling-binary-digits/2929106#2929106 Jim16 1.26 msec # http://stackoverflow.com/questions/2928886/doubling-binary-digits/2929038#2929038 Elegant 1.66 msec # int(''.join([''.join(i) for i in zip(X,X)]),2) More Elegant 2.05 msec # int(''.join(chain(*zip(X, X))), 2) Benchmark source code can be found in http://gist.github.com/417172 .
