[site]: stackoverflow
[post_id]: 3613491
[parent_id]: 
[tags]: 
C++ COM design. Composition vs multiple inheritance

I'm trying to embed a browser control in my application (IWebBrowser2). I need to implement IDispatch, IDocHostShowUI, IDocHostUIHandler etc to make this work. I am doing this in pure C++/Win32 api. I'm not using ATL, MFC or any other framework. I have a main class, called TWebf, that creates a Win32 window to put the browser control in and makes all the OLE calls needed to make it work. It's also used for controlling the browser control, with methods like Refresh(), Back(), Forward() etc. Right now this is implemented with composition. TWebf has classes implementing all the different interfaces (IDispatch, IDocHostShowUI...) as (stack allocated) members. First thing TWebf does in its constructor is give all those members a pointer back to itself ( dispatch.webf = this; etc). QueryInterface, AddRef and Release are implemented as calls to those methods in TWebf for all interface implementations (by calling return webf->QueryInterface(riid, ppv); for example) I don't like this circular dependency between TWebf and the classes implementing the interfaces. TWebf has a TDispatch member that has a TWebf member that has a... So I was thinking about solving this with multiple inheritance instead. That would also simplify QueryInterface to always be able to just return this . A UMLish sketch of what I want would be something like this: (Click for a bigger view) As can be seen in the uml I want to provide bare-minimum implementations of all the interfaces so I only have to override those methods in the interfaces I actually want to do something substantial in TWebf. Is my "multiple inheritance implementation" possible? Is it a good idea? Is it the best solution? EDIT: For future discussion, here's the current implementation of QueryInterface in TWebf HRESULT STDMETHODCALLTYPE TWebf::QueryInterface(REFIID riid, void **ppv) { *ppv = NULL; if (riid == IID_IUnknown) { *ppv = this; } else if (riid == IID_IOleClientSite) { *ppv = &clientsite; } else if (riid == IID_IOleWindow || riid == IID_IOleInPlaceSite) { *ppv = &site; } else if (riid == IID_IOleInPlaceUIWindow || riid == IID_IOleInPlaceFrame) { *ppv = &frame; } else if (riid == IID_IDispatch) { *ppv = &dispatch; } else if (riid == IID_IDocHostUIHandler) { *ppv = &uihandler; } if (*ppv != NULL) { AddRef(); return S_OK; } return E_NOINTERFACE; } EDIT 2: I tried implementing this for just a couple of the interfaces. Having TWebf inherit from IUnknown and TOleClientSite seems to work fine, but when I added TDispatch to the inheritance list it stopped working. Apart from the warning C4584: 'TWebf' : base-class 'IUnknown' is already a base-class of 'TDispatch' warning I also get runtime errors. The runtime error is "Access violation reading location 0x00000000" The runtime error happens on a line dealing with IOleClientSite, not IDispatch for some reason. I don't know why this is happening, or if it really has to do with the multiple inheritance or not. Any clues anyone? EDIT 3: A bad implementation of QueryInterface seems to have been the reason for the runtime exception. As Mark Ransom correctly noted the this pointer needs to be casted before it's assigned to *ppv, and special care is needed when IUnknown is requested. Read Why exactly do I need an explicit upcast when implementing QueryInterface in an object with multiple inheritance for an excellent explanation of that. Why exactly I got that specific runtime error I still do not know.
