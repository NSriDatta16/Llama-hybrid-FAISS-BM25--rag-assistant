[site]: stackoverflow
[post_id]: 1665603
[parent_id]: 1665459
[tags]: 
Without doing your homework for you let me see if I can give you some hints. Implementing a deque (double ended queue) is really quite easy if you can get your head around a few concepts. Firstly, it is key to note that since we will be popping off the front and/or back in order to efficiently code an algorithm which uses contiguous storage we need to be able to pop front/back without shifting the entire array (what you currently do). A much better and in my mind simpler way is to track the front AND the back of the relevant data within your deque. As a simple example of the above concept consider a static (cannot grow) deque of size 10: class Deque { public: Deque() : front(0) , count(0) {} private: size_t front; size_t count; enum { MAXSIZE = 10 }; int data[MAXSIZE]; }; You can of course implement this and allow it to grow in size etc. But for simplicity I'm leaving all that out. Now to allow a user to add to the deque: void Deque::push_back(int value) { if(count>=MAXSIZE) throw std::runtime_error("Deque full!"); data[(front+count)%MAXSIZE] = value; count++; } And to pop off the back: int Deque::pop_back() { if(count==0) throw std::runtime_error("Deque empty! Cannot pop!"); int value = data[(front+(--count))%MAXSIZE]; return value; } Now the key thing to observe in the above functions is how we are accessing the data within the array. By modding with MAXSIZE we ensure that we are not accessing out of bounds, and that we are hitting the right value. Also as the value of front changes (due to push_front, pop_front) the modulus operator ensures that wrap around is dealt with appropriately. I'll show you how to do push_front, you can figure out pop_front for yourself: void Deque::push_front(int value) { if(count>=MAXSIZE) throw std::runtime_error("Deque full!"); // Determine where front should now be. if (front==0) front = MAXSIZE-1; else --front; data[front] = value; ++count; }
