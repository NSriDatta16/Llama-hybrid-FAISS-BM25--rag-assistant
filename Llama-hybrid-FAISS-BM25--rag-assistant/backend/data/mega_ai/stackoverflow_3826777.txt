[site]: stackoverflow
[post_id]: 3826777
[parent_id]: 3825279
[tags]: 
Agreed: Use namespaces for logical organization, not projects. One approach is to think of projects as units of deployment. Will Project.Client always be deployed with Project.ViewModels? Project.Models? Is one referencing the other? Just include in the same project and use namespaces for organization. A few reasons why you may want to separate Silverlight class libraries/applications into individual projects: Reuse. You want to develop APIs that will be used for other applications. Your Project.Infrastructure may fall into this category. Modularity. MajorFunctionA is only used by the end user 20% of the time. Maybe only certain authenticated users have access. Maybe it is only access when navigated to a specific page that noone goes to. You could choose to build into separate Silverlight apps and only download the .xaps as needed using frameworks like MEF or PRISM. Developer Workflows. One team in one city/office is working on Project.Client and another team in another city/office is working on Project.Models. It might make sense to build into separate projects to make life easier. One other thing to note about assemblies is that you can't have circular references between assemblies. In other words, if ClassA and ClassB are in the same assembly, ClassA can reference ClassB, and ClassB can reference ClassA. But if they're in separate assemblies, they can't. Now, if your classes have a lot of circular references, that's probably not a good thing, but sometimes it's difficult to avoid, and your options are much more limited if they happen to be in separate assemblies. But on the flip side, increasing the number of assemblies limits the opportunity for circular references, which can improve the quality of your design. Just something else to be aware of. Following that logic, one alternative would be grouping Project.Client, Project.Data, Project.Model, Project.UIControls, and Project.ViewModels in one project and grouping Project.Common and Project.Infrastructure into another. MajorFunctions could be left separate or grouped into Project.Client. You would end up with: Project.Client - Application specific interface, view models, and models. Project.Infrastructure - Common, reusable helpers, converters, and interfaces. Project.UnitTests Project.Web Project.Web.Infrastructure Also. There's not really a correct answer for this. I'm tagging as Community Wiki.
