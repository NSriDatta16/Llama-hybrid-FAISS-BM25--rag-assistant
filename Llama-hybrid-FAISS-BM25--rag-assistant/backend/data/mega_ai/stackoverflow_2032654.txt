[site]: stackoverflow
[post_id]: 2032654
[parent_id]: 
[tags]: 
Can you call a copy constructor from another method?

/** @file ListP.cpp * ADT list - Pointer-based implementation. */ #include #include // for NULL #include // for bad_alloc #include "ListP.h" // header file using namespace std; List::List() : size(0), head(NULL) { } // end default constructor List::List(const List& aList) : size(aList.size) { if (aList.head == NULL) head = NULL; // original list is empty else { // copy first node head = new ListNode; head->item = aList.head->item; // copy rest of list ListNode *newPtr = head; // new pointer // newPtr points to last node in new list // origPtr points to nodes in original list for (ListNode *origPtr = aList.head->next; origPtr != NULL; origPtr = origPtr->next) { newPtr->next = new ListNode; newPtr = newPtr->next; newPtr->item = origPtr->item; } // end for newPtr->next = NULL; } // end if } // end copy constructor void List::copy(const List& aList) { List::List(aList); } // end copy I am trying to create a method called copy that simply calls the copy constructor. When I test this method in main the target list still remains empty. I have stepped through it and all the right lines are executed, but when the copy constructor returns nothing seems to be saved. I feel this has something to do with scope, but cannot pinpoint the problem. Here is the driver program: #include using namespace std; #include "ListP.h" int main () { List aList; ListItemType dataItem; aList.insert(1, 9); aList.insert(2, 4); aList.insert(3, 1); aList.insert(4, 2); List bList; bList.copy(aList); bList.retrieve(1, dataItem); cout
