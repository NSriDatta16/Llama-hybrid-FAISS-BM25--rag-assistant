[site]: stackoverflow
[post_id]: 5432964
[parent_id]: 
[tags]: 
Is it somehow possible to *live* modify Python code (like in Lisp or Erlang)

I was wondering if it is somehow possible to modify Python code live, while keeping all state of instantiated objects and methods, like I think is possible in Lisp or Erlang (*) ? Say, I have an active Python sessions, where I instantiated the foo class from a self-written module: class foo(): @classmethod def do_something(self): print "this is good" Python command line: >>> f =foo() >>> f.do_something() Now, I would like to change the print statement into something else (e.g. print "this is better" ). If I edit my module file to do so, and reload it, I have to re-instantiate the f object. Is there a way to be able to just call f.do_something() again without having to call f=foo() first? So, I have to do this: >>> reload my_module >>> f =foo() >>> f.do_something() # with changed print statement But I want to do this: >>> reload my_module >>> f.do_something() # with changed print statement (*) I am basing this statement on the cool Erlang movie and this fragment from Practical Common Lisp : ' When the bug manifested in the wild--100 million miles away from Earth--the team was able to diagnose and fix the running code , allowing the experiments to complete. ' Edit: I've been thinking a bit more about this and maybe what I want is inherently flawed for applying to OO (i.e., what about the state of the class and methods). I think Erlang allows this because, as far as I recall, it is more about separate communicating objects, so live updating the code of an object makes more sense. I am not sure though, so still open for answers. Edit2: Maybe the best way to describe what I want is recapitulate what I said in a comment in a post below: "When called, the methods just have to point to the new method definitions/locations."
