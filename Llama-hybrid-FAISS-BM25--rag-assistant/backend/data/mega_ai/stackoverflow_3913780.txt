[site]: stackoverflow
[post_id]: 3913780
[parent_id]: 3913503
[tags]: 
Here's my implementation; less elegant than @sepp2k's one, it follows a different approach, actually counting the bits and providing both the position of the MSB and the number of significant bits. #include #include // Number: the number to be examined; Bit: parameter used internally to specify the bit to // examine (the work starts from the leftmost bit) template ::digits-1> class BitCounter { public: // Most Significant Bit number; if it's the current, fine, otherwise // delegate the work to another template that will examine the next bit static const int MSB=(Number&(1 ::MSB; // Count of significant bits - actually, MSB+1 static const int Count=MSB+1; }; // Corner case: we reached the first bit template class BitCounter { public: // If it's 1, the MSB is the bit 0 (the rightmost), while if it's 0 it's "one before"; // this is somewhat arbitrary to make Count get 0 for 0 and 1 for 1, you may want to // change it just to 0 static const int MSB=Number==0?-1:0; static const int Count=MSB+1; }; int main() { std::cout ::Count ::Count ::Count ::Count ::Count ::Count Sample output: matteo@teoubuntu:~/cpp$ g++ tpl_bitcount.cpp -Wall -Wextra -ansi -pedantic -O3 -o tpl_bitcount.x && ./tpl_bitcount.x 8 3 11 5 1 0
