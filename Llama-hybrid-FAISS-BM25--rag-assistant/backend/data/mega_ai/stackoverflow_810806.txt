[site]: stackoverflow
[post_id]: 810806
[parent_id]: 810797
[tags]: 
Return values are almost always the right choice when the method doesn't have anything else to return. (In fact, I can't think of any cases where I'd ever want a void method with an out parameter, if I had the choice. C# 7's Deconstruct methods for language-supported deconstruction acts as a very, very rare exception to this rule.) Aside from anything else, it stops the caller from having to declare the variable separately: int foo; GetValue(out foo); vs int foo = GetValue(); Out values also prevent method chaining like this: Console.WriteLine(GetValue().ToString("g")); (Indeed, that's one of the problems with property setters as well, and it's why the builder pattern uses methods which return the builder, e.g. myStringBuilder.Append(xxx).Append(yyy) .) Additionally, out parameters are slightly harder to use with reflection and usually make testing harder too. (More effort is usually put into making it easy to mock return values than out parameters). Basically there's nothing I can think of that they make easier ... Return values FTW. EDIT: In terms of what's going on... Basically when you pass in an argument for an "out" parameter, you have to pass in a variable. (Array elements are classified as variables too.) The method you call doesn't have a "new" variable on its stack for the parameter - it uses your variable for storage. Any changes in the variable are immediately visible. Here's an example showing the difference: using System; class Test { static int value; static void ShowValue(string description) { Console.WriteLine(description + value); } static void Main() { Console.WriteLine("Return value test..."); value = 5; value = ReturnValue(); ShowValue("Value after ReturnValue(): "); value = 5; Console.WriteLine("Out parameter test..."); OutParameter(out value); ShowValue("Value after OutParameter(): "); } static int ReturnValue() { ShowValue("ReturnValue (pre): "); int tmp = 10; ShowValue("ReturnValue (post): "); return tmp; } static void OutParameter(out int tmp) { ShowValue("OutParameter (pre): "); tmp = 10; ShowValue("OutParameter (post): "); } } Results: Return value test... ReturnValue (pre): 5 ReturnValue (post): 5 Value after ReturnValue(): 10 Out parameter test... OutParameter (pre): 5 OutParameter (post): 10 Value after OutParameter(): 10 The difference is at the "post" step - i.e. after the local variable or parameter has been changed. In the ReturnValue test, this makes no difference to the static value variable. In the OutParameter test, the value variable is changed by the line tmp = 10;
