[site]: stackoverflow
[post_id]: 3600760
[parent_id]: 3600712
[tags]: 
an object declared in a function is created when its definition is encountered and destroyed when its name goes out of scope This can easily be disproven for local statics: void f() { static string s = ""; } // out of scope, but still alive! Note that the scope of a name is a static, compile time concept. But lifetime of an object is a runtime concept. So you can entirely get a refer to to an already destroyed object. It's not possible for the compiler to protect you from this at compile time. In case that the storage duration that object was assigned stopped at this point too, you cannot do anything anymore with your variable, because memory is not guaranteed to exist anymore. Storage duration for automatic variables lasts only until the exit of its block. Sometimes an object ends lifetime, but the storage that object was allocated on still exists. This is true if you manually call a class's destructor or for the active member of an union if you write to the other member. The destruction time is important for RAII to work. Let's take an example where we lock a mutex void f() { { lock x(mutex); /* do something */ } // lock destroyed => mutex unlocked /* do non-exclusive stuff */ }
