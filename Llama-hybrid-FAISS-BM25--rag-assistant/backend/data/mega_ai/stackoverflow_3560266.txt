[site]: stackoverflow
[post_id]: 3560266
[parent_id]: 
[tags]: 
Refreshing and Deleting content in background thread error (NSFetchedResultsController)

I'm using an NSFetchedResultsController to fill content for my UITableViewController. I'm using an NSOperation to gather data from a webService (I'm using a separated ManagedObjectContext as it's another thread) When the data is saved my ViewController (wich is the NSFetchedResultsControllerDelegate) is called and i merge my MOCs using mergeChangesFromContextDidSaveNotification #pragma mark - #pragma mark Parsers delegate - (void)parserWillSave:(id)parser{ TopNewsParser *emp = (TopNewsParser *)parser; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(parserContextDidSave:) name:NSManagedObjectContextDidSaveNotification object:emp.managedObjectContext]; [NSFetchedResultsController deleteCacheWithName:@"aLaUne"]; } - (void)parserDidSave:(id)parser{ TopNewsParser *emp = (TopNewsParser *)parser; [[NSNotificationCenter defaultCenter] removeObserver:self name:NSManagedObjectContextDidSaveNotification object:emp.managedObjectContext]; } /** Notification from the add controller's context's save operation. This is used to update the fetched results controller's managed object context with the new book instead of performing a fetch (which would be a much more computationally expensive operation). */ - (void)parserContextDidSave:(NSNotification*)saveNotification { DLog(@""); NSManagedObjectContext *fetchContext = [_fetchedResultsController managedObjectContext]; // Merging changes causes the fetched results controller to update its results [fetchContext performSelectorOnMainThread:@selector(mergeChangesFromContextDidSaveNotification:) withObject:saveNotification waitUntilDone:YES]; } For the NSFetchedResultsControllerDelegate i'm using the code from the CoreData Books sample #pragma mark - #pragma mark NSFetchedResultsControllerDelegate - (void)controllerWillChangeContent:(NSFetchedResultsController *)controller { // The fetch controller is about to start sending change notifications, so prepare the table view for updates. [self.tableView beginUpdates]; } - (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath { //ALog(@"indexPath: %@ newIndexPath : %@ | type : %d # %@",indexPath,newIndexPath,type,anObject); UITableView *tableView = self.tableView; switch(type) { case NSFetchedResultsChangeInsert: [tableView insertRowsAtIndexPaths:[NSArray arrayWithObject:newIndexPath] withRowAnimation:UITableViewRowAnimationFade]; break; case NSFetchedResultsChangeDelete: [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade]; break; case NSFetchedResultsChangeUpdate: [self configureCell:[tableView cellForRowAtIndexPath:indexPath] atIndexPath:indexPath]; break; case NSFetchedResultsChangeMove: [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade]; // Reloading the section inserts a new row and ensures that titles are updated appropriately. [tableView reloadSections:[NSIndexSet indexSetWithIndex:newIndexPath.section] withRowAnimation:UITableViewRowAnimationFade]; break; } } - (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id )sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type { switch(type) { case NSFetchedResultsChangeInsert: [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; case NSFetchedResultsChangeDelete: [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; } } - (void)controllerDidChangeContent:(NSFetchedResultsController *)controller { UIBarButtonItem *reloadButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemRefresh target:self action:@selector(refreshTableViewContent)]; reloadButton.accessibilityLabel = @"Reload"; self.navigationItem.leftBarButtonItem = reloadButton; // The fetch controller has sent all current change notifications, so tell the table view to process all updates. [self.tableView endUpdates]; } My problem is when load new content where some object where deleted, my tableView is messed up ! The row is still visible even if my countOfRow is reduced by 1 : Then when i scroll down my tableview is empty (only the 4 visible rows) are still in the tableview otherwise it's a blank scrollView In the console i can see the following message. Serious application error. An exception was caught from the delegate of NSFetchedResultsController during a call to -controllerDidChangeContent:. *** -[NSMutableArray removeObjectAtIndex:]: index 0 beyond bounds for empty array with userInfo (null) In the beggining i tought this was due to the cache of my NSFetchedResultsController but even when i disable it i have the same problem. Does someone have an idea on how to fix this ?
