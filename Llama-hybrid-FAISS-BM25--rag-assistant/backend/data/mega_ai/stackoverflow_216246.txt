[site]: stackoverflow
[post_id]: 216246
[parent_id]: 215908
[tags]: 
EDIT: This solution doesn't work. Robert Gamble's is the correct solution. I brainstormed a bit and came up with this solution: (I know most of you won't know REBOL, but it's a fairly readable language.) REBOL [] sets: [[1 2 3] [4 5] [6]] ; Here's a set of sets elems: 1 result: copy [] foreach set sets [elems: elems * (length? set)] for n 1 elems 1 [ row: copy [] foreach set sets [ index: 1 + (mod (n - 1) length? set) append row set/(index) ] append/only result row ] foreach row result [ print result ] This code produces: 1 4 6 2 5 6 3 4 6 1 5 6 2 4 6 3 5 6 (Upon first reading the numbers above, you may think there are duplicates. I did. But there aren't.) Interestingly, this code uses almost the very same algorithm (1 + ((n - 1) % 9) that torpedoed my Digital Root question.
