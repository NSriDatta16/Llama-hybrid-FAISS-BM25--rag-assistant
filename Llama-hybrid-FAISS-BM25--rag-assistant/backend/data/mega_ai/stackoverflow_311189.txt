[site]: stackoverflow
[post_id]: 311189
[parent_id]: 311102
[tags]: 
You can use reinterpret_cast to cast to an integral type and back to the pointer type. If the integral type is large enough to store the pointer value, then that conversion will not change the pointer value. As others already say, it is not defined behavior to use dynamic_cast on a non-polymorphic class (except when you do an upcast, which is implicit anyway and be ignored here), and it also only works on pointers or references. Not on integral types. You better use ::intptr_t found in on various posix systems. You can use that type as your intermediate type you cast to. Regarding your check whether the conversion will succeed, you can use sizeof: BOOST_STATIC_ASSERT(sizeof(T1) >= sizeof(T2)); will fail at compile time if the conversion couldn't be done. Or continue to use assert with that condition, and it will assert at run-time instead. Warning: This won't prevent you from casting T* to intptr_t back to U* with U another type than T. Thus, this only guarantees you the cast won't change the value of the pointer if you cast from T* to intptr_t and back to T* . (Thanks to Nicola pointing out you may expect another protection).
