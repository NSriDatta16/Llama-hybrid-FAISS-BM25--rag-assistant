[site]: stackoverflow
[post_id]: 1812316
[parent_id]: 1812225
[tags]: 
It's considered elegant because it's orthogonal . That's a fancy way of saying that similar operations apply to similar operands. Simple example: + on integers adds them; on floating point numbers, ditto. On big integers, too. On strings, it concatenates them (which you'd kind of expect too). Now this is not a big deal for + , you kind of expect it from any decent programming language. But there are operations like map or filter , they work on lists (they should!) but they also work on arrays and in fact on anything that can be enumerated or iterated through. I like how array (or list) indexing works, you can use positive integer indexes to index from the start, or negative indexes to specify a position back from the end of the structure, you can specify a range to pull out a subset... this works for lists, arrays and (sub)strings too. It works on the right side of an assignment ( = ), it works on the left side too (you can assign to a substring, thus replacing part of a string). So you don't need a substring_replace function, you just leverage an existing, general concept. The author of Ruby expressed this in terms of satisfying the user's (i.e. the programmer's) expectations: There should be as few surprises as possible, whenever common sense would lead you to expect that something works in a certain way, it simply should. He worked very hard to satisfy this requirement. Also, while Ruby borrows a little bit from Perl, the author disagrees with Perl's TMTOWTDI principle in favor of the Zen of Python: "There should be one –and preferably only one– obvious way to do it." It's also nice that Ruby does closures (= code blocks) so you can specify a function simply by wrapping it in a pair of braces. There are places where it's appropriate to specify a function inline, and Ruby lets you do it conveniently. Ruby lets you do things with a small amount of coding because its constructs fit together in powerful ways. I dabble in Project Euler and I find that often the shortest legible and understandable solutions were done in Ruby. The very shortest are in J, but that's an APL dialect and to the uninitiated it looks like line noise. My personal experience bears this out: I taught myself Ruby and Rails and wrote a Web application with medium-complex data analysis in one week. Every principle I learned, I could apply in different places with different data – It Just Works™!
