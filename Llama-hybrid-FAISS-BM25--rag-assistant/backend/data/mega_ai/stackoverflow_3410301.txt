[site]: stackoverflow
[post_id]: 3410301
[parent_id]: 3408098
[tags]: 
Your question contains a wrong statement: Correct is that POCOs do not depend on IObjectSet. POCOs themselves are independent from EF. Or better: They are supposed to be independent from EF. Since YOU are implementing the POCO classes you are finally responsible to make this sure. (Otherwise the term POCO would be the wrong one.) If you are using the standard T4 template to create POCO classes from a model description instead of writing the classes on your own the template ensures that the classes do not depend on EF - they are not derived from Entity and collections as members of a class are generated with ICollection by this template, not with IObjectSet. Repository pattern is another question. The POCO T4 template does not create a Repository as an abstract interface to act on a database with POCOs. It creates a derived ObjectContext which is rather an EF specific implementation of a possible repository interface (or at least helps to easily implement a possible repository interface). If you want to have a repository interface which doesn't depend on EF or LINQ you have to define it this way. Nothing forces you to use IObjectSet or IQueryable in that interface. Perhaps the examples of implementing the Repository pattern you saw didn't intend to be independent from Entity Framework or LINQ. An example: Suppose, in your business layer you need a list of all products of a given category returned from the persistance layer. What would this layer expose to fulfill the request? If you only have databases in mind which offer a LINQ provider you might design the repository interface like so: public interface IProductsRepository { IQueryable AllProducts { get; } // Product is the POCO class } A concrete implementation of this repository based on EF would simply return an ObjectSet from the ObjectContext which the T4 template did create. And your business layer runs a query this way: IProductsRepository rep = new SomeConcreteImplementationOfProductsRepository(); IList productsOfCategory = rep.AllProducts.Select(p => p.Category == "stuff").ToList(); But if you want to be more open what kind of persistance storage you like to support it might be better to design the repository independent from IQueryable. The consequence could be that your abstract repository interface needs more specific methods to answer requests from the business layer, for instance you need now: public interface IProductsRepository { IList GetProductsOfCategory(string category); } and the business layer does this: IProductsRepository rep = new SomeConcreteImplementationOfProductsRepository(); IList productsOfCategory = rep.GetProductsOfCategory("stuff"); A concrete implementation of this Repository using EF (or another data framework supporting LINQ) could still leverage a LINQ query like the business layer did in the first example. But other implementations could work in another way (say: you have a "database" which stores products in one text file per category. Then the implementation for that interface method would read one specific file from disk. Or your repository implementation asks a webservice for the data, and so on...) Key point is: If you are using POCO classes you are open for all those kinds of repositories. EF with POCO support doesn't force you to build repository interfaces based on IQueryable or even IObjectSet. It finally depends on what kind of persistance layers you have in mind. The more different they are the more specific methods you might need to support in your repository interface and the more work you'll have to implement those methods. Using IQueryable is a comfortable compromise which allows to define a simple repository interface while enabling simple implementations by EF but also other databases with LINQ provider. I think that's the only reason why you see examples of repository pattern implementations with IQueryable so often. It's not an inherent restriction imposed by EF with POCOs. (That's how I think about it, not being an expert in design patterns, so heavy attacks and corrections in the comments are welcome.)
