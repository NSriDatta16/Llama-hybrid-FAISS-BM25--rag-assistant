[site]: stackoverflow
[post_id]: 2826863
[parent_id]: 2826589
[tags]: 
The C++ standard 1.8.5 states :- Unless it is a bit-field (9.6), a most derived object shall have a non-zero size and shall occupy one or more bytes of storage. Base class subobjects may have zero size . An object of trivially copyable or standard-layout type (3.9) shall occupy contiguous bytes of storage. So, the standard alows a base-class that has no data members (and no virtuals) to share the same address as another subobject with a distinct type. You can play around with the empty base class size like ... struct a{}; struct a1{}; struct b : public a, public a1{char c;}; int main() { std::cout because the two instances of a (as a base and as a member) must have distinct addresses. BTW : "b::a" is another way to say "a". The presence of the scope access operator does not request the "base-class subobject of b of type a". Verse 5.3.3/2 says :- When applying sizeof to a base class subobject, the result is the size of that object's type .
