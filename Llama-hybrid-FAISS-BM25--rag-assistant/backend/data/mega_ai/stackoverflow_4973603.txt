[site]: stackoverflow
[post_id]: 4973603
[parent_id]: 4973424
[tags]: 
One way it to use With , to create a compiled function programmatically: Clear[makeCompiled]; makeCompiled[lnum_Integer] := With[{listNames = Table[Unique["list"], {lnum}]}, With[{compileArgs = {#, _Integer, 1} & /@ listNames}, Compile @@ Join[Hold[compileArgs], Replace[Hold[Outer[Plus, listNames]], Hold[Outer[Plus, {x__}]] :> Hold[Outer[Plus, x]], {0}]]]]; It can probably be done prettier, but it works. For example: In[22]:= p2 = makeCompiled[2] Out[22]= CompiledFunction[{list13,list14},Outer[Plus,list13,list14],-CompiledCode-] In[23]:= p2[{1,2,3},{4,5}] Out[23]= {{5,6},{6,7},{7,8}} In[24]:= p3 = makeCompiled[3] Out[24]= CompiledFunction[{list15,list16,list17},Outer[Plus,list15,list16,list17],-CompiledCode-] In[25]:= p3[{1,2},{3,4},{5,6}] Out[25]= {{{9,10},{10,11}},{{10,11},{11,12}}} HTH Edit: You can hide the compiled function behind another one, so that it is created at run-time and you don't actually see it: In[33]:= Clear[computeSums] computeSums[lists : {__?NumberQ} ..] := makeCompiled[Length[{lists}]][lists]; In[35]:= computeSums[{1, 2, 3}, {4, 5}] Out[35]= {{5, 6}, {6, 7}, {7, 8}} You face an overhead of compiling in this case, since you create then a compiled function afresh every time. You can fight this overhead rather elegantly with memoization, using Module variables for persistence, to localize your memoized definitions: In[44]:= Clear[computeSumsMemoized]; Module[{compiled}, compiled[n_] := compiled[n] = makeCompiled[n]; computeSumsMemoized[lists : {__?NumberQ} ..] := compiled[Length[{lists}]][lists]]; In[46]:= computeSumsMemoized[{1, 2, 3}, {4, 5}] Out[46]= {{5, 6}, {6, 7}, {7, 8}}
