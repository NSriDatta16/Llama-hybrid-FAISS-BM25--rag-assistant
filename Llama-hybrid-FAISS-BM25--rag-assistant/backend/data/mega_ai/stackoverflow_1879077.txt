[site]: stackoverflow
[post_id]: 1879077
[parent_id]: 1878785
[tags]: 
Without a memory barrier ( synchronized , volatile , or equivalent from java.util.concurrent ), a thread may see actions of another thread occur in a different order than they appear in source code. Since there's no memory barrier on the read of timesSafelyGotten , it can appear to another thread that timesSafelyGotten is incremented before helper is assigned. That would result in returning null from the method. In practice, this might work on many architectures during your unit tests. But it's not correct and will eventually fail somewhere. Double-checked locking does work now, but it's tricky to implement correctly and fairly expensive. There are patterns for lazy initialization that are less fragile, more readable, and don't require anything exotic.
