[site]: stackoverflow
[post_id]: 1987509
[parent_id]: 1933929
[tags]: 
Your Revisions table as you have shown it models a many-to-many relationship between Posts and Text . This is probably not what you want, unless a given row in Text may provide the content for multiple rows in Posts . This is not how most CMS architectures work. You certainly don't need three tables. I have no idea why you think this is needed for 3NF. The point of 3NF is that an attribute should not depend on a non-key attribute, it doesn't say you should split into multiple tables needlessly. So you might only need a one-to-many relationship between two tables: Posts and Revisions . That is, for each post, there can be multiple revisions, but a given revision applies to only one post. Others have suggested two alternatives for finding the current post: A flag column in Revisions to note the current revision. Changing the current revision is as simple as changing the flag to true in the desired revision and to false to the formerly current revision. A foreign key in Posts to the revision that is current for the given post. This is even simpler, because you can change the current revision in one update instead of two. But circular foreign key references can cause problems vis-a-vis backup & restore, cascading updates, etc. You could even implement the revision system using a single table : CREATE TABLE PostRevisions ( post_revision_id SERIAL PRIMARY KEY, post_id INT NOT NULL, is_current TINYINT NULL, date DATE, title VARCHAR(80) NOT NULL, text TEXT NOT NULL, UNIQUE KEY (post_id, is_current) ); I'm not sure it's duplication to store the title with each revision, because the title could be revised as much as the text, couldn't it? The column is_current should be either 1 or NULL. A unique constraint doesn't count NULLs, so you can have only one row where is_current is 1 and an unlimited number of rows where it's NULL. This does require updating two rows to make a revision current, but you gain some simplicity by reducing the model to a single table. This is a great advantage when you're using an ORM. You can create a view to simplify the common case of querying current posts: CREATE VIEW Posts AS SELECT * FROM PostRevisions WHERE is_current = 1; update: Re your updated question: I agree that proper relational design would encourage two tables so that you could make a few attributes of a Post invariant for all that post's revisions. But most ORM tools assume an entity exists in a single table, and ORM's are clumsy at joining rows from multiple tables to constitute a given entity. So I would say if using an ORM is a priority, you should store the posts and revisions in a single table. Sacrifice a little bit of relational correctness to support the assumptions of the ORM paradigm. Another suggestion is to consider Dimensional Modeling . This is a school of database design to support OLAP and data warehousing. It uses denormalization judiciously, so you can usually organize data in a Star Schema . The main entity (the "Fact Table") is represented by a single table, so this would be a win for an ORM-centric application design.
