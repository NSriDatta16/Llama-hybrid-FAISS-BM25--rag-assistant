[site]: stackoverflow
[post_id]: 3520931
[parent_id]: 
[tags]: 
Receiving assert failure on Reference Call

(Disclaimer: I have removed the Qt tag in case the problem is in my syntax / understanding of the references involved here) I have a foreach loop with an object Member . When I enumerate through the list and try to access a member field, the debugger stops and I get a message: Stopped: 'signal-received' - The assert failure is: inline QString::QString(const QString &other) : d(other.d) { Q_ASSERT(&other != this); d->ref.ref(); } I have checked if the member is NULL, and it isn't. I have tried re-working the code, but I keep failing on this simple call. Some thing's I missed out. MemberList is a singleton (definitely initialized and returns a valid pointer) that is created as the application launches and populates the MemberList with Members from a file. When this is created, there are definitely values, as I print them to qDebug() . This page is literally the next page. I am unsure as to how the List items can be destroyed. The code is as follows: int i = 0; QList members = ml->getMembers(); foreach (Member* mem, members) { QString memID = mem->getMemberID(); // Crash happens here QListWidgetItem *lstItem = new QListWidgetItem(memID, lsvMembers); lsvMembers->insertItem(i, lstItem); i++; } The Member classes get is as follows: QString getMemberID() const; and the actual function is: QString Member::getMemberID() const { return MemberID; } The ml variable is received as follows: QList MemberList::getMembers() { return MemberList::getInstance()->memberList; } Where memberList is a private variable. Final answer: I decided to rework the singleton completely and found that I was not instantiating a new Member, rather reusing the previous object over and over. This caused the double reference. S'pose thats pointers for you. Special thanks to Troubadour for the effort!
