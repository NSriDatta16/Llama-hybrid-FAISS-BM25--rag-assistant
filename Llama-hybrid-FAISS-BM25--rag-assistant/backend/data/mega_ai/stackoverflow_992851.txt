[site]: stackoverflow
[post_id]: 992851
[parent_id]: 992497
[tags]: 
The simplest way to solve it is to resolve the type where you have the information, namely inside the Tag implementation, so add the following to your existing types (only showing the additions!) public interface ITag { void CopyFrom(bool sourceIsMem, ITag sourceTag, bool targetIsMem); } public class Tag : ITag { public void CopyFrom(bool sourceIsMem, ITag sourceTag, bool targetIsMem) { ITag castSource = sourceTag as ITag ; if (castSource == null) throw new ArgumentException( "Source tag is of an incompatible type", "sourceTag"); if (targetIsMem) InMemValue = sourceIsMem ? castSource.InMemValue : castSource.OnDiscValue; else OnDiscValue = sourceIsMem ? castSource.InMemValue : castSource.OnDiscValue; } } Note that you really should use enum types for the sourceIsMem and targetIsMem instead, because a bool is really ugly and hard to read in the invocation as the following fragment will show. This is how you would make your routine work now: public static void DoSomething_HelpMe() { MusicTrack track1 = new MusicTrack(); MusicTrack track2 = new MusicTrack(); // Set some values on the tracks foreach (ITag tag in track1.Tags.Values) tag.CopyFrom(false, track2.Tags[tag.TagName], true); }
