[site]: stackoverflow
[post_id]: 2627724
[parent_id]: 
[tags]: 
SetWindowLong in CustomDraw causes unhandled exception

I am making some changes to a CSliderCtrl using the Custom Draw, the control is to be used in a dialog. Here is the structure: In my MessageMap I have : ON_NOTIFY_REFLECT_EX(NM_CUSTOMDRAW, OnNMCustomdraw) The OnNMCustomdraw method looks like the following: BOOL CCustomSliderCtrl::OnNMCustomdraw(NMHDR *pNMHDR, LRESULT *pResult) { *pResult = CDRF_DODEFAULT; LPNMCUSTOMDRAW pNMCD = reinterpret_cast (pNMHDR); switch(pNMCD->dwDrawStage) { case CDDS_PREPAINT: { //Dialogs don't receive CDRF_NOTIFYITEMDRAW notifcations by returning it as part of pResult, we must //use the following so we ensure we receive the msg SetWindowLong(pNMHDR->hwndFrom, DWL_MSGRESULT, CDRF_NOTIFYITEMDRAW); return TRUE; } case CDDS_ITEMPREPAINT: if(pNMCD->dwItemSpec == TBCD_CHANNEL) { ...SNIP... SetWindowLong(pNMHDR->hwndFrom, DWL_MSGRESULT, CDRF_SKIPDEFAULT); return TRUE; } } return FALSE; } Reading around I learnt that you had to use SetWindowLong to set the return value for the custom draw, otherwise your method will not always receive the CDDS_ITEMPREPAINT message. However, when using SetWindowLong my application will never receive the CDDS_ITEMPREPAINT and so my slider just looks like a standard slider. The application crashes when any sort of interaction takes place upon the slider, such as hovering over it or minimizing and maximizing the dialog. I snipped the TBCD_CHANNEL code as it is never reached. When running in debug mode, it crashes at the end of the AfxUnlockGlobals method, in afxcrit.cpp. Here is a stack trace: Update: Since adding debug symbols, the crash seems to be picked up at CWnd::DefWindowProc mwthod. comctl32.dll!_TrackBarWndProc@16() + 0x551 bytes user32.dll!_InternalCallWinProc@20() + 0x28 bytes user32.dll!_UserCallWinProcCheckWow@32() + 0xb7 bytes user32.dll!_CallWindowProcAorW@24() + 0x51 bytes user32.dll!_CallWindowProcW@20() + 0x1b bytes mfc90ud.dll!CWnd::DefWindowProcW(unsigned int nMsg=15, unsigned int wParam=0, long lParam=0) Line 1043 + 0x20 bytes C++ mfc90ud.dll!CWnd::WindowProc(unsigned int message=15, unsigned int wParam=0, long lParam=0) Line 1756 + 0x1c bytes C++ mfc90ud.dll!AfxCallWndProc(CWnd * pWnd=0x0012fdbc, HWND__ * hWnd=0x000308fe, unsigned int nMsg=15, unsigned int wParam=0, long lParam=0) Line 240 + 0x1c bytes C++ mfc90ud.dll!AfxWndProc(HWND__ * hWnd=0x000308fe, unsigned int nMsg=15, unsigned int wParam=0, long lParam=0) Line 403 C++ mfc90ud.dll!AfxWndProcBase(HWND__ * hWnd=0x000308fe, unsigned int nMsg=15, unsigned int wParam=0, long lParam=0) Line 441 + 0x15 bytes C++ user32.dll!_InternalCallWinProc@20() + 0x28 bytes user32.dll!_UserCallWinProcCheckWow@32() + 0xb7 bytes user32.dll!_DispatchClientMessage@20() + 0x4d bytes user32.dll!___fnDWORD@4() + 0x24 bytes ntdll.dll!_KiUserCallbackDispatcher@12() + 0x13 bytes user32.dll!_NtUserDispatchMessage@4() + 0xc bytes user32.dll!_DispatchMessageW@4() + 0xf bytes mfc90ud.dll!AfxInternalPumpMessage() Line 183 C++ mfc90ud.dll!CWinThread::PumpMessage() Line 900 C++ mfc90ud.dll!AfxPumpMessage() Line 190 + 0xd bytes C++ mfc90ud.dll!CWnd::RunModalLoop(unsigned long dwFlags=4) Line 4386 + 0x5 bytes C++ mfc90ud.dll!CDialog::DoModal() Line 584 + 0xc bytes C++ SetSelection.exe!CSetSelectionApp::InitInstance() Line 64 + 0xb bytes C++ mfc90ud.dll!AfxWinMain(HINSTANCE__ * hInstance=0x00400000, HINSTANCE__ * hPrevInstance=0x00000000, wchar_t * lpCmdLine=0x00020a84, int nCmdShow=1) Line 37 + 0xd bytes C++ SetSelection.exe!wWinMain(HINSTANCE__ * hInstance=0x00400000, HINSTANCE__ * hPrevInstance=0x00000000, wchar_t * lpCmdLine=0x00020a84, int nCmdShow=1) Line 34 C++ SetSelection.exe!__tmainCRTStartup() Line 578 + 0x35 bytes C SetSelection.exe!wWinMainCRTStartup() Line 403 C kernel32.dll!_BaseProcessStart@4() + 0x23 bytes So, does anyone have any insight into this matter? If you need more info just let me know. Update: I have found a work around for now, instead of using SetWindowLong I just assign the result to pResult, then return. I force a re-draw that does repaint the sub items by calling SetRangeMin(GetRangeMin(), TRUE);, not exactly elegant but it works.
