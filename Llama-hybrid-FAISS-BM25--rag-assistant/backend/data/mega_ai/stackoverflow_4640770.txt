[site]: stackoverflow
[post_id]: 4640770
[parent_id]: 4640700
[tags]: 
cmmUser. ExecuteReader() executes the stored procedure and returns a SqlDataReader object. Thus you need to use the SqlDataReader that you commented out like this: SqlDataReader drdUser; drdUser = cmmUser.ExecuteReader(); while(drdUser.Read()){ //You can get at each column in the row by indexing the reader using either the column number // like drdUser[0] or the column name drdUser["COlumnName"]. Since I don't know the names of your // columns I will use numbers Console.WriteLine(String.Format("{0} {1} {2}", drdUser[0], drdUser[1], drdUser[2]); } drdUser.Close(): Also I would recommend wrapping the instantiation of your SqlConnection into a using block so that it gets disposed once you are done with it like this: namespace ExecuteStoredProc { class Program { static void Main(string[] args) { //Instantiate and open the connection using(SqlConnection cnnUserMan = new SqlConnection("Your connection string")) { cnnUserMan.Open(); //Instantiate and initialize command using(SqlCommand cmmUser = new SqlCommand("SelectID", cnnUserMan)) { cmmUser.CommandType = System.Data.CommandType.StoredProcedure; using(SqlDataReader drdUser = cmmUser.ExecuteReader()) { while(drdUser.Read()) { Console.WriteLine(String.Format("{0} {1} {2}", drdUser[0], drdUser[1], drdUser[2]); } } } Console.ReadLine(); } } } } UPDATE As per marc_s's comment, it makes sense to wrap all the disposable components, SqlConnection, SqlCommand, and SqlDataReader in a using block to make sure they are disposed of properly rather than my original solution that ONLY wrapped the SqlConnection with a using block. UPDATE 2 As per the comment by Thorarin it looks cleaner to declare the variable as part of the using block, especially in this case where you don't need the variables outside each of the using block.
