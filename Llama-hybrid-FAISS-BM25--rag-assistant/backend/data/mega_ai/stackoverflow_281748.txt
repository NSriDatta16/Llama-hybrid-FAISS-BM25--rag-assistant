[site]: stackoverflow
[post_id]: 281748
[parent_id]: 281488
[tags]: 
I'm not seeing exactly the solution you asked for in c. You might consider one of these ideas: If you have access to the source for your libc 's qsort() , you might copy it and simply replace all the array access and indexing code with appropriately generalized equivalents. This gives you some modest assurance that the underling sort is efficient and has few bugs. No help with the risk of introducing your own bugs, of course. Big O like the system qsort , but possibly with a worse multiplier. If the region to be sorted is small compared to the size of the buffer, you could use the straight ahead linear sort, guarding the call with a test-for-wrap and doing the copy-to-linear-buffer-sort-then-copy-back routine only if needed. Introduces an extra O(n) operation in the cases that trip the guard (for n the size of the region to be sorted), which makes the average O(n^2/N) . I see that C++ is not an option for you. ::sigh:: I will leave this here in case someone else can use it. If C++ is an option you could (subclass the buffer if needed and) overload the [] operator to make the standard sort algorithms work. Again, should work like the standard sort with a multiplier penalty.
