[site]: stackoverflow
[post_id]: 3080083
[parent_id]: 3079723
[tags]: 
Principles that may apply to this example are: Information Hiding : Segregate design details in your code that are likely to change. Create a stable interface that protects the rest of the program from the implementation. Encapsulation : Compartmentalize the elements of an abstraction that constitute its structure and behavior. Separate the contractual interface of an abstraction from its implementation. Use standard language mechanisms to bundle the data with the interface. Note that the definitions of Information Hiding and Encapsulation I've given are quite similar, and various people have their own definitions of what these mean. I've pulled these from Wikipedia. Interface Segregation Principle : The dependency of one class to another should depend on the smallest possible interface. The question you must determine is whether writing your class this way, where Child itself is part of the interface, is a stable and minimal interface for clients to depend on. In most cases, OO programmers prefer to rely on an explicit set of methods as their interface instead of data members, so that they can change out the data members at will. Some will recommend that technique as a dictum. It may or may not apply in your case. There's another principle that may or may not apply to your example: Law of Demeter : Only talk to your immediate friends. The Law of Demeter discourages deep access hierarchies like p.Child.Child.Child. Why? Because clients are then assuming deep structural knowledge about the objects they are talking to, and it increases coupling between the client and those objects. Having said this, I think there are plenty of examples in the world where this coupling is acceptable; you'd need to decide whether it applies in your case as well. EDIT : With your revised example, the Law of Demeter looks to me much closer to what you're looking for.
