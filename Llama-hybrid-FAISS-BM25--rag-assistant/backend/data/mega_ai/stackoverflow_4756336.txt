[site]: stackoverflow
[post_id]: 4756336
[parent_id]: 4752091
[tags]: 
Ok, if we split text into words and paragraphs, then we can simply add word by word to output: const int linewidth = 50; static void Main(string[] args) { using(StreamReader r = new StreamReader("text1.txt")) { using(StreamWriter w = new StreamWriter("text2.txt")) { int written = 0; while(true) { string word = ReadWord(r); if(word == null) break; //end of file if(word == "") { //end of paragraph w.Write("\r\n\r\n"); written = 0; } if(written + word.Length > linewidth) { //endline w.Write("\r\n"); written = 0; int i = 0; while(word[i] == ' ') i++; w.Write(word.Substring(i)); written = word.Length - i; } else { w.Write(word); written += word.Length; } } } } } So we need some smart "word reader": static int c = -1; static string ReadWord(StreamReader r) { string word = ""; bool started = false; if(c == -1) c = ReadChar(r); while(true) { if(c == -1) { //eof if(word == "") return null; return word; } word += (char)c; c = r.Read(); if(c != ' ') started = true; else if(started) break; } return word; } And this word reader needs a smart character reader, which treats all line ends as spaces and recognizes empty lines as paragraphs: static bool lineend = false; static int ReadChar(StreamReader r) { int c = r.Read(); if(c == '\n') c = r.Read(); if(c == '\r') { if(lineend) return '\r'; lineend = true; return ' '; } lineend = false; return c; } As you can see, I use no internal array buffers, so the program can be used for any large files, but isn't possibly as fast as the algorithm in memory with strings. Words longer than line are written to their own lines (see Main). Only spaces and CRLF are treated as word delimiters. In real word situation wyou should probably extend this to TAB or other whitespaces.
