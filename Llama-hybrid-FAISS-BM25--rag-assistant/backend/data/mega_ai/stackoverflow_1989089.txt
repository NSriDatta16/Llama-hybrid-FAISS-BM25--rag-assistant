[site]: stackoverflow
[post_id]: 1989089
[parent_id]: 1988978
[tags]: 
As much as I would like to say that you want to inject into the std namespace, it really is a sticky wicket as Neil pointed out. The related thread of std::swap points out a number of the details as does the now infamous USENET discussion on the subject . To sum it up, the only way that you are allowed to inject a name into std is if you can fully specialize it. So, you can write: namespace std { template <> MyFunction for_each(stxxl::vector ::const_iterator first, stxxl::vector ::const_iterator last, MyFunction func) { return stxxl::for_each(first, last, func); } } for every combination of container and function and you are well within the rules. Unfortunately, partial function template specialization doesn't exist in the current incarnation of the Standard. If you are really curious, dedicate an evening to reading the entire USENET post . It really is quite enlightening and a little frightening. You can probably write a nifty macro (gasp) to automate this for you if you only use a few type/function combinations. You can use ADL to solve the problem as well provided that none of the stxxl stuff simply exposes an iterator from std using a typedef. I believe that this is generally the preferred solution today. I would add your own wrapper around for_each that forwards to the appropriate one and call it done. This isn't the most elegant, but it will work now and doesn't rely on any magic to make it happen.
