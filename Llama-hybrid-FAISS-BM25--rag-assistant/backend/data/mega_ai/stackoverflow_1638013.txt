[site]: stackoverflow
[post_id]: 1638013
[parent_id]: 1637961
[tags]: 
The pseudocode for that looks something like: Load the word list (dictionary) Input the words to unscramble For each word: Find every permutation of letters in that word (permutation) For each permutation: Add this permutation to the solution list if it exists in the dictionary Print the solutions that were found. The dictionary() function is populating your word list from a file. The permutation() function returns every permutation of letters in a given word. The permutation() function is doing the following: for an in permutation(s[1:]): s[1:] returns the string with the first character truncated. You'll see that it uses recursion to call permutation() again until there are no characters left to be truncated from the front. You must know recursion to understand this line. Using recursion allows this algorithm to cover every number of letters and still be elegant. for pos in range(len(an)+1): For each letter position remaining. ans.append(an[:pos]+s[0]+an[pos:]) Generate the permutation by moving the first letter (which we truncated earlier) to each of the positions between every other letter. So, take the word "watch" for example. After recursion, there will be a loop that generates the following words: awtch atwch atcwh atchw All I did to generate those words was take the first letter and shift its position. Continue that, combined with truncating the letters, and you'll create every permutation. (wow, this must be my longest answer yet)
