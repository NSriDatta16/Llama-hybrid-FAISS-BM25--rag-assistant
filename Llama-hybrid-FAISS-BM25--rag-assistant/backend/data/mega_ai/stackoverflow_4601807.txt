[site]: stackoverflow
[post_id]: 4601807
[parent_id]: 
[tags]: 
Reference-counting caveats in Objective-C?

I've long considered myself a garbage collection snob – despite a secret love for C++, I find myself sneering at developers who actively choose to use languages without (read: missing ) garbage collection when they're given the option. And then I met Objective-C. Wow! Its system of reference counting seems brilliantly simple – I'd even go so far as to say elegant . When developing for OSX, developers are given the option to use a snazzy GC; when developing for iOS, developers are stuck with reference counting. My question is: If I am developing an OSX application that could potentially be ported to iOS, is Objective-C's reference counting system time-consuming enough (development-wise and bug-fixing-wise) to warrant ignoring it for the application's first version? What problems am I likely to run into if I rely on reference counting*, assuming I'm not clever enough to construct any diabolically complex cyclical data structures? With features like autorelease , it all seems so easy, but I know that Apple wouldn't have invested the effort into creating a garbage collector if this were really the case. What should I be on the lookout for? * I am aware that I can use the garbage collector even if I am throwing around retain s and release s (they'll be ignored). However, considering non-GC applications often use RAII , I don't understand how that would work if a generational GC were to "replace" calls to retain and release . Wouldn't resources potentially be released late?
