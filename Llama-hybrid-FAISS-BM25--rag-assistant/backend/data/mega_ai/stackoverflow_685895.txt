[site]: stackoverflow
[post_id]: 685895
[parent_id]: 685542
[tags]: 
that loop will kill performance! create a table like this: CREATE TABLE Numbers ( Number int not null primary key ) that has rows containing values 1 to 8000 or so and use this function: CREATE FUNCTION [dbo].[FN_ListAllToNumberTable] ( @SplitOn char(1) --REQUIRED, the character to split the @List string on ,@List varchar(8000) --REQUIRED, the list to split apart ) RETURNS @ParsedList table ( RowNumber int ,ListValue varchar(500) ) AS BEGIN /* DESCRIPTION: Takes the given @List string and splits it apart based on the given @SplitOn character. A table is returned, one row per split item, with a columns named "RowNumber" and "ListValue". This function workes for fixed or variable lenght items. Empty and null items will be included in the results set. PARAMETERS: @List varchar(8000) --REQUIRED, the list to split apart @SplitOn char(1) --OPTIONAL, the character to split the @List string on, defaults to a comma "," RETURN VALUES: a table, one row per item in the list, with a column name "ListValue" TEST WITH: ---------- SELECT * FROM dbo.FN_ListAllToNumTable(',','1,12,123,1234,54321,6,A,*,|||,,,,B') DECLARE @InputList varchar(200) SET @InputList='17;184;75;495' SELECT 'well formed list',LEFT(@InputList,40) AS InputList,h.Name FROM Employee h INNER JOIN dbo.FN_ListAllToNumTable(';',@InputList) dt ON h.EmployeeID=dt.ListValue WHERE dt.ListValue IS NOT NULL SET @InputList='17;;;184;75;495;;;' SELECT 'poorly formed list join',LEFT(@InputList,40) AS InputList,h.Name FROM Employee h INNER JOIN dbo.FN_ListAllToNumTable(';',@InputList) dt ON h.EmployeeID=dt.ListValue SELECT 'poorly formed list',LEFT(@InputList,40) AS InputList, ListValue FROM dbo.FN_ListAllToNumTable(';',@InputList) **/ /*this will return empty rows, and row numbers*/ INSERT INTO @ParsedList (RowNumber,ListValue) SELECT ROW_NUMBER() OVER(ORDER BY number) AS RowNumber ,LTRIM(RTRIM(SUBSTRING(ListValue, number+1, CHARINDEX(@SplitOn, ListValue, number+1)-number - 1))) AS ListValue FROM ( SELECT @SplitOn + @List + @SplitOn AS ListValue ) AS InnerQuery INNER JOIN Numbers n ON n.Number I have other versions that do not return empty or null rows, ones that return just the item and not the row number, etc. Look in the header comment to see how to use this as part of a JOIN, which is much faster than in a where clause.
