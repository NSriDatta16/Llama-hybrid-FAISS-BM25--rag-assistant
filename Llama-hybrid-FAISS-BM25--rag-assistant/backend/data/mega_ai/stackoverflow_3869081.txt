[site]: stackoverflow
[post_id]: 3869081
[parent_id]: 3869067
[tags]: 
You probably want to put a coderef onto the beginning @INC, as described in perldoc -f require . From there, you can raise exceptions to prevent certain modules from being loaded, or do nothing to let require carry on with its normal job of looking up the module in the other @INC entries. $ perl -E'BEGIN { unshift @INC, sub { die q{no NEXT} if pop eq q{NEXT.pm}; () }; }; use Carp; say q{success}' success $ perl -E'BEGIN { unshift @INC, sub { die q{no NEXT} if pop eq q{NEXT.pm}; () }; }; use NEXT; say q{success}' no NEXT at -e line 1. BEGIN failed--compilation aborted at -e line 1. If you want that behaviour to be lexical, you should make use of Perl's hints hash %^H . Dealing with that is a little fiddly, so I'd recommend using Devel::Pragma , which can take care of all the gory details for you. As you pointed out, the @INC hooks won't be executed for a module that's already loaded. If you also need to hook into the use or require of a loaded module, overriding CORE::GLOBAL::require would work, as it is called for every attempt to load a module. $ perl -E'BEGIN { *CORE::GLOBAL::require = sub { warn @_ } } use NEXT; use NEXT;' NEXT.pm at -e line 1 NEXT.pm at -e line 1. Also, as the maintainer of NEXT, I completely approve of preventing people from using it, at all, ever. :-)
