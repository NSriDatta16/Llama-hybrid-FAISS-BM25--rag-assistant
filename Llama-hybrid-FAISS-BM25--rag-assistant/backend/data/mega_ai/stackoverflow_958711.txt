[site]: stackoverflow
[post_id]: 958711
[parent_id]: 958040
[tags]: 
From the Pragmatic Ajax book: What Is Ajax? Ajax is a hard beast to distill into a one-liner. The reason it is so hard is because it has two sides to it: Ajax can be viewed as a set of technologies. Ajax can be viewed as an architecture. Ajax: Asynchronous JavaScript and XML The name Ajax came from the bundling of its enabling technologies: an asynchronous communication channel between the browser and server, JavaScript, and XML. When it was deﬁned, it was envisioned as the following: Standards-based presentation using XHTML and CSS Dynamic display and interaction using the browser’s DocumentObject Model (DOM) Data interchange and manipulation using XML and XSLT Asynchronous data retrieval using XMLHttpRequest or XMLHTTP (from Microsoft) JavaScript binding everything together Although it is common to develop using these enabling technologies, it can quickly become more trouble than reward. It is for these reasons that the more important deﬁnition for Ajax is... Ajax: The Architecture The exciting evolution that is Ajax is in how you architect web applications. Let’s look ﬁrst at the conventional web architecture: Deﬁne a page for every event in the application: view items, purchase items, check out, and so on. Each event, or action, returns a full page back to the browser. That page is rendered to the user. This seems natural to us now. It made sense at the beginning of the Web, as the Web wasn’t really about applications. The Web started off as more of a document repository; it was a world in which you could simply link between documents in an ad hoc way. It was about document and data sharing, not interactivity in any meaningful sense. Picture a rich desktop application for a moment. Imagine what you would think if, on every click, all of the components on the application screen redrew from scratch. Seems a little nuts, doesn’t it? On the Web, that was the world we inhabited until Ajax came along. Ajax is a new architecture. The important parts of this architecture are: Small server-side events: Now components in a web application can make small requests back to a server, get some information, and tweak the page that is viewed by changing the DOM. No full page refresh. Asynchronous: Requests posted back to the server don’t cause the browser to block. The user can continue to use other parts of the application, and the UI can be updated to alert the user that a request is taking place. onAnything: We can interact with the server based on almost anything the user does. Modern browsers trap most of the same user events as the operating system: mouseovers, mouse clicks, keypresses, etc. Any user event can cause an asynchronous request. This all sounds great, doesn’t it? With this change we have to be careful, though. One of the greatest things about the Web is that anybody can use it. Having simple semantics helps that happen. If we go overboard, we might begin surprising the users with new UI abstractions. This is a common complaint with Flash UIs, where users are confronted with new symbols, metaphors, and required actions to achieve useful results.
