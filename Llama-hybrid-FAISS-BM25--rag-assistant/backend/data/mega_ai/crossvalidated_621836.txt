[site]: crossvalidated
[post_id]: 621836
[parent_id]: 
[tags]: 
Fundamental question regarding interaction term replacements using SQL

group by = an sql function that merges all repeating values of each column(regression variable) into a single distinct value. group by can take multiple arguments: group by createdate, ad, campaign creates a table of distinct campaigns for each distinct ad for each distinct createdate(i.e. in this case, each distinct value of createdate will repeat as many times as number of distinct ads * number distinct campaigns and each distinct ad will repeat as many times as number of distinct campaigns, creating a total number of rows of createdate * ad * campaign.) What it means to apply an aggregate function : Notice how group by in the example has a total number of rows of createdate * ad * campaign. group by initially begins as a table with as many rows as all the distinct values of one variable, and then expands each row by the number of distinct variables in the extra variable being grouped by, every time a new variable is added as an argument of group by, recursively. This however, means that the rest of the variables not added as an argument of group by will be processed by an aggregate function. An aggregate function can be of all types, such as but not limited to sum, average, weighted average, even_sum, etc. Please refer to the definition of group by and aggregate function above. I couldn't change my question in less technical terms, because the validity of the method I'm trying to prove necessarily involves sql. I have a fundamental question regarding interaction terms and their valid replacements. Say I have 2 variables that are highly correlated. Adding an interaction term, x1 * x2 essentially rewards high values of x1 or x2. Instead of adding interaction terms, I want to group by by a more restricted variable than ad in sql(so that the variable becomes a subgroup of ad), regress on each of those groups to predict their respective y values, and group by ..., ad (so ad is the new most restricted domain by uniqueness) while applying an aggregate_function: average , to each of the groups dropped in group by this time by averaging their y values within each ad group and summing their own respective values. *What I'm trying to do here is compute the y value I want for a single ad group: installs / impressions * 1000 by averaging its subgroup's y values. Is this valid logic? As an example, if the columns, ad and campaign are multi-collinear, can I group by until ..., ad, campaign, choose the y value to be trained on as whatever aggregate value that is calculated for each campaign of an ad, and then average those y values for each ad group to approximate the y value that would have existed for ad? I'm averaging in this case, because the y value I'm interested in is ipm(installs / impressions * 1000), which should not be added to each other to find the overall ipm for each ad group, but averaged. Is this entire line of thought valid logic?
