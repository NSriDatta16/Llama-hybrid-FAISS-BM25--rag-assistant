[site]: stackoverflow
[post_id]: 1177212
[parent_id]: 1176298
[tags]: 
Don't confuse the following cases: int global_x[6]; // an array with static storage duration struct Foo { int *pointer_x; // a pointer member in instance data int member_x[6]; // an array in instance data Foo() { pointer_x = new int[6]; // a heap-allocated array } ~Foo() { delete[] pointer_x; } }; int main() { int auto_x[6]; // an array on the stack (automatic variable) Foo auto_f; // a Foo on the stack Foo *dyn_f = new Foo(); // a heap-allocated Foo. } Now: auto_f.member_x is on the stack, because auto_f is on the stack. (*dyn_f).member_x is on the heap, because *dyn_f is on the heap. For both Foo objects, pointer_x points to a heap-allocated array. global_x is in some data section which the OS or runtime creates each time the program is run. This may or may not be from the same heap as dynamic allocations, it doesn't usually matter. So regardless of whether it's on the heap or not, member_x is a better bet than pointer_x in the case where the length is always 6, because: It's less code and less error-prone. Your object only needs a single allocation if the object is heap-allocated, instead of 2. Your object requires no heap allocations if the object is on the stack. It uses less memory in total, because of fewer allocations, and also because there's no need for storage for the pointer value. Reasons to prefer pointer_x : If you need to reallocate during the lifetime of the object. If different objects will need a different size array (perhaps based on constructor parameters). If Foo objects will be placed on the stack, but the array is so large that it won't fit on the stack. For instance if you've got 1MB of stack, then you can't use automatic variables which contain an int[262144] .
