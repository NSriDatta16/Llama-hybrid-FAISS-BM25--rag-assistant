[site]: stackoverflow
[post_id]: 3660051
[parent_id]: 3656918
[tags]: 
Yes, there are several ways to do that in C#. First off, what is a "variable"? A variable is a storage location. Local variables, formal parameters of methods (and indexers, constructors and so on), static and instance fields, array elements and pointer dereferences are all variables. Some variables can be declared as "readonly". A "readonly" variable can only be changed once, either by an initializer in the declaration, or in a constructor. Only fields declarations can be readonly; C# does not support user-declared readonly locals. There are certain restrictions on readonly variables that help ensure that the normal operation of C# does not introduce a mutation. This can lead to some unexpected results! See http://ericlippert.com/2008/05/14/mutating-readonly-structs/ for details. Some locals are effectively readonly as well. For example, when you say using(Stream s = whatever) then inside the embedded statement of the using you cannot change the value of s. The reason for this restriction is to prevent the bug whereby you create a resource that is to be disposed, and then dispose of a different resource when the contents of variable s are disposed. It had better be the same. (Unfortunately there are bugs in C# involving the situation where the disposed resource is a struct type, the struct has a method which mutates the struct, and the local variable is or is not a closed-over local of an anonymous function or iterator block; since the scenarios are obscure and the fix would be potentially breaking we haven't done anything about it yet, pending further analysis.) The local variable declared in a foreach statement is also effectively readonly -- that variable changes value every time through the loop, but you are not allowed to change its value. There is no way to make a readonly formal parameter, array element or pointer dereference. There are various ways to "break" the readonly restriction and write to a variable that is supposed to be read only. You can use Reflection or unsafe code to break pretty much any safety restriction of the CLR if you have sufficient privilege to do so. If it hurts when you do that, don't do that; with those powers comes the responsibility to know what you're doing and do it right.
