[site]: stackoverflow
[post_id]: 1579720
[parent_id]: 404676
[tags]: 
I commented on rkj's answer above regarding lambda's. This code demonstrates the example you asked for; def abs(n); (n The first point to notice is that the fixed_point method handles the general idea of progressively applying a process to some data until it passes a certain test. The sqrt function defines the process of finding a square root and the test to determine when we're to be satisfied. These 'procedures' are then passed just like any other form of data so that fixed_point can work it's magic. Instead of temporarily storing the process and test the whole thing could be anonymous. We could rewrite sqrt as; def sqrt(n) fixed_point( n, 1.0, lambda {|n,g| average g, (n/g)}, lambda {|n,g| abs(square(g) - n) Without this ability, I would have to define both the process and the test as individual functions and create a special sqrt_fixed_point function to call them. As far as I'm aware Java can do something similar using Functors but I don't know enough to comment. The consensus I've seen in blogs or similar is that Java makes this so horrendously complicated that you'll get a nosebleed just trying it. Of course, another option that Ruby gives is metaprogramming. I could rewrite sqrt so that it rewrites (on the fly) fixed_point using the correct process and test, but this is probably an abuse of the feature :-) ps. The JoelOnSoftware link is posted deserves repeating; http://www.joelonsoftware.com/items/2006/08/01.html
