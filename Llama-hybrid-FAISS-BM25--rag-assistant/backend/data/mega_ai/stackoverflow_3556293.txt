[site]: stackoverflow
[post_id]: 3556293
[parent_id]: 3556241
[tags]: 
The best one will depend on how your going to access it and where you're going to remove elements from. std::vector should usually be your default choice. Here you can iterate over the HANDLE elements and storage is efficient. The issue with vector may arise when you're erasing. If you are removing elements from the middle of the container, vector is not as efficient as something like a list or set and it will invalidate all iterators beyond the element you are erasing. Note that lists are more performant than a vector when erasing from the middle, but list is not terribly space efficient. I typically use list only as a last resort. A good option over the use of a list is the deque container if you need only efficient removal from the ends of the container. If you need the data sorted (i.e. without using something like std::sort to sort a vector), you want to remove from anywhere without invalidating other iterators, then a set may be just what you're looking for. It should be noted that I'm assuming your HANDLE class is either a pointer or is a class that meets the criteria for storage in a C++ std container. (Copy semantics, etc.) If using a pointer, then you will be responsible for closing and/or deallocating the resource that the pointer is referring too. This should be done via some RAII class. You SHOULD NOT use auto_ptr for this as it does not meet the requirements to be stored in a standard container. You can however use the shared_ptr class provided by the Boost libraries. Here is some general info all these containers and the other container options available in C++. Here is a simple example of how to use a vector from the reference pages. You can easily take this and produce what you want with your HANDLE class/handle. I've added an example loop printing the contents via iterators also. // erasing from vector #include #include using namespace std; int main () { unsigned int i; vector myvector; // set some values (from 1 to 10) for (i=1; i ::const_iterator it = myvector.begin(); it != myvector.end(); ++it) { cout
