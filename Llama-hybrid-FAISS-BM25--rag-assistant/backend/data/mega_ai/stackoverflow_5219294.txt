[site]: stackoverflow
[post_id]: 5219294
[parent_id]: 5190911
[tags]: 
In the bootstrap, you can set your database connections: protected function _initDb () { $config['my_db1'] = new Zend_Config_Ini(APPLICATION_PATH . '/configs/my_db1.ini'); $config['my_db2'] = new Zend_Config_Ini(APPLICATION_PATH . '/configs/my_db2.ini'); $my_db1 = new Plugin_Replication($config['my_db1']->toArray()); $my_db1->query("SET CHARACTER SET utf8;"); $my_db2 = new Plugin_Replication($config['my_db2']->toArray()); $my_db2->query("SET CHARACTER SET utf8;"); Zend_Db_Table::setDefaultAdapter($dmy_db1); Zend_Registry::set('my_db1', $my_db1); Zend_Registry::set('my_db2', $my_db2); } Each connection is specified in a separate .ini file in my case. I find this pretty intuitively organised. A database ini file does not require the resources.db.whatever names. Mine go like this: [Master] host = "xxx" username = "xxx" password = "xxx" dbname = "xxx" charset = utf8 [Slaves] first.host = "xxx" first.username = "xxx" first.password = "xxx" first.dbname = "xxx" first.charset = utf8 second.host = "xxx" second.username = "xxx" second.password = "xxx" second.dbname = "xxx" second.charset = utf8 Once you have multiple databases set up like this, when creating a model (in any module you wish), you can inform ZF about the database you would like to use: protected function _setupDatabaseAdapter() { $this->_db = Zend_Registry::get('my_db1'); } This will be your default adapter. In case you need to use two databases in the same query, start your model's function with: public function myAwesomeSqlQuery () { $db1 = $this->getAdapter()->getConfig(); //default adapter $db2 = Zend_Registry::get('my_db2')->getConfig(); //additional adapter Now, you can write your query using the two databases this way: $sql = $this ->select() ->setIntegrityCheck(false) ->from(array('col1' => $db1['dbname'].'.some_column')) ->join(array('col2' => $db2['dbname'].'.some_other_column')),'col1.id = col2.id') ; As I suggested in a comment, you can also use module-specific bootstraps. The structure would go like this: /application/ -- /modules/ -- /v1/ -- /controllers/ -- /views/ -- /Bootstrap.php -- /v2/ -- /controllers/ -- /views/ -- /Bootstrap.php The module-specific bootstraps are constructed pretty much like any other bootstrap, but they affect the module in question. The class names are typically prefixed with the modules names, e.g.: I generally try not to use module-specific bootstraps because they are all launched with each request (Zend Framework 2 is supposed to correct this), running functions that aren't necessary for your current module. Anyway, I found a module-specific bootstrap in one of my modules, which contains something like this: class MyModule_Bootstrap extends Zend_Application_Bootstrap_Bootstrap { protected function _initLoggers () { $my_db1 = Zend_Registry::get('my_db1'); $my_db2 = Zend_Registry::get('my_db2'); $my_db1->setProfiler(new Zend_Db_Profiler_Firebug())->getProfiler()->setEnabled(true); $my_db2->setProfiler(new Zend_Db_Profiler_Firebug())->getProfiler()->setEnabled(true); $auth = Zend_Auth::getInstance(); $columnMapping = array('priority' => 'priority' , 'message' => 'message' , 'timestamp' => 'timestamp' , 'username' => 'username'); $logger = new Zend_Log(new Zend_Log_Writer_Db($my_db1, 'logs', $columnMapping)); print_r($auth->getIdentity()); if ($auth->hasIdentity()) $logger->setEventItem('username', $auth->getIdentity()->username); Zend_Registry::set('logger', $logger); } That's pretty much it. I hope it helps.
