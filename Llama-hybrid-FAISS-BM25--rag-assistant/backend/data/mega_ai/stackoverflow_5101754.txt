[site]: stackoverflow
[post_id]: 5101754
[parent_id]: 5099967
[tags]: 
First, class types have a vtable. Instances of that type have a pointer to the vtable. This means that if the contents of the vtable change for a type all instances of that type are affected. But specific instance can have their vtable pointer changed. There is no standard way to retrieve the vtable pointer from an instance because it is dependent upon the compiler's implementation. See this post for more details. However, G++ and MSVC++ seem to layout class objects as described on wikipedia . Classes can have pointers to multiple vtables. For the sake of simplicity I'll talk about classes that only have one vtable pointer. To get the pointer of a function out of a vtable it can be done as simply as this: int* cVtablePtr = (int*)((int*)c)[0]; void* doSomethingPtr = (void*)cVtablePtr[1]; Where c is an instance of class C for this class definition: class A { public: virtual void A1() { cout A1" A1" C1" The class C is just a struct whose first member is the pointer to a vtable in this case. In the case of a JIT compiler it might be possible to cache the lookup in the vtable by regenrating code. At first the JIT compiler might produce this: void* func_ptr = obj_instance[vtable_offest][function_offset]; func_ptr(this, param1, param2) Now that the func_ptr is known the JIT can kill off that old code and simply hard code that function address into the compiled code: hardcoded_func_ptr(this, param1, param2) One thing I should note is while you can overwrite the instances vtable pointer it is not always possible to overwrite the contents of a vtable. For example, on Windows the vtable is marked as read only memory but on OS X it is read/write. So on windows trying to change the contents of the vtable will result in an Access Violation unless you change the page access with VirtualProtect .
