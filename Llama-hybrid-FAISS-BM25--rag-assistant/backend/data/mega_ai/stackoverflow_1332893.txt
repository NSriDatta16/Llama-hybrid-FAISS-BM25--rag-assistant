[site]: stackoverflow
[post_id]: 1332893
[parent_id]: 1332404
[tags]: 
Since I can't think of any way to detect the last method call, I'm going to suggest a different approach. It is similar to what ActiveRecord does; a proxy class that builds the options and doesn't fetch the data until you call a method that operates on the data. class Flickr def initialize @result = FlickrResult.new end def method_missing(method, *args, &block) if @result.data.respond_to?(method) @result.run(method, args, block) else @result.append(method, args[0]) return self end end class FlickrResult attr_reader :data def initialize @data = [] @keys = [] @options = {} end def append(key, options) @keys "123").pools.thing.users(:user_id => "456") @flickr.each {|f| p f } # => "Only runs once!" # => "foo" # => "bar" p @flickr.map {|f| f.upcase } # => ["FOO", "BAR"] It only fetches the data when you each or map it or whatever (any array method).
