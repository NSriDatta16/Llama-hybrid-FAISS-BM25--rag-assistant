[site]: stackoverflow
[post_id]: 3047694
[parent_id]: 3047063
[tags]: 
The biggest problem is that your queries become more complicated. Say you want to find all accounts with balance over $10,000 with the owner. In a normalized DB, that would be something like: select firstname, lastname, accountnumber, balance from account join customeraccount using (accountnumber) join customer using (customernumber) where balance>10000 But with three accountnumber fields, it becomes select firstname, latname, accountnumber, balance from account join customer on customer.accountnumber1=account.accountnumber or customer.accountnumber2=account.accountnumber or customer.accountnumber3=account.accountnumber where balance>10000 Every query that joins Account to Customer now gets more complicated like this. Sooner or later, someone will write a query that fails to check accountnumber3, or he tries to make the three tests by copy-and-paste and after copying accountnumber1 two times he forgets to change one of them. It's an error that's easy to overlook when reading a query. If you mess up one of the three compares, the program will work for all customers who have only two accounts but fail for customers who have three. This is the sort of problem that can easily slip through testing. You now have to think through exactly how the joins work when the same customer has multiple accounts. If a customer has two qualifying accounts in some query, do you want him to show up once or twice? You probably need to index on the account number field in customer. Now you need three indexes instead of one. More overhead for the database. Are you sure that the maximum will never ever change? Because if it ever does, now every one of those queries that check the three slots will have to be changed to check four slots. That could be a ton of work. What do you gain in exchange for all this pain? Automatic enforcement of the max-3 limit. One less table. You might possibly get better performance on some queries because there is one less table to be joined. Then again you might not get better performance, depending on many details of the inner workings of the database engine and the actual data. All told, I would say it is almost certainly not worth doing. Stick with the normalized database. I speak from experience. I did something very similar to this once. We had a database where we had to record three types of "managers" for each book our organization published (#1 in charge of budgeting and administration, #2 in charge of distribution, and #3 in charge of contents (i.e. the editor). As the three were different, I created three separate points. Huge mistake. I would have been much better off to create a book-manager table with a type code and enforce only one of each type with triggers or code. The queries would have been way simpler. (Experience enables you to make good decisions. Experience is gained by making bad decisions.)
