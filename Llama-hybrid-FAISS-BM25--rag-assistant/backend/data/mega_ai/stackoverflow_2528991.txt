[site]: stackoverflow
[post_id]: 2528991
[parent_id]: 2528974
[tags]: 
What is the point of passing a state to the BeginReceive method if we're only working with a single socket? Is it to avoid using a class field? It seems like there's little point in doing it, but maybe I'm missing something. You're right that if you didn't use the state then you'd have to use a member instead. But this is less local than a state variable. The more local things are, the less likely they are to break when you make changes in other parts of the code. Compare it to ordinary method calls. Why don't we just set the parameters as members and then call all functions without any parameters? It would work... but it would be horrible to read the code. By keeping the scope as local as possible it makes the design easier to understand and modify. The improved encapsulation leads to more robust code. The same applies here. If you only have one asynchoronous callback then you can probably get away with just setting a member on the class but if you have many such calls then this strategy will soon lead to similar problems as described above - confusing and fragile code. How can the state parameter help when dealing with multiple sockets? You can pass a different state object for each call, each containing its own client object. Note that the client is fetched from the state, not from a member variable: //Socket client = this.client; // Don't do this. Socket client = state.workSocket; If you notice all the other methods in the MSDN documentation take a Client as parameter. The state is just a way of passing parameters since the method signature is fixed. Update: Regarding your question in the comments, .NET checks that you use the correct client object and if not throws an ArgumentException . From decompiling EndReceive in .NET Reflector we see this: if ((result == null) || (result.AsyncObject != this)) { throw new ArgumentException(SR.GetString("net_io_invalidasyncresult"), "asyncResult"); }
