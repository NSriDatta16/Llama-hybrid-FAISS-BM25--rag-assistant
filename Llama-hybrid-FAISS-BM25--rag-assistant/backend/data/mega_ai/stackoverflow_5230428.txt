[site]: stackoverflow
[post_id]: 5230428
[parent_id]: 5221724
[tags]: 
Current solution The current solution I use at work is based on dynamic dispatch, that is, the keyword dynamic as defined on C# 4.0. The code is something like (from memory) : public class Parser { static public void TryParse (string p_input, out T p_output) { // Because m_p is dynamic, the function to be called will // be resolved at runtime, after T is known... m_p.DoTryParse(p_input, out p_output) ; } // The dynamic keyword means every function called through // m_p will be resolved at runtime, at the moment of the call private dynamic m_p = new Parser() ; // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - private void DoTryParse(string p_input, out double p_output) { /* Do something and return the right value */ } private void DoTryParse(string p_input, out int p_output) { /* Do something and return the right value */ } // etc. private void DoTryParse (string p_input, out T p_output) { // fallback method... There are no dedicated method for T, // so p_output becomes the default value for T p_output = default(T) ; } } The elegant part is that it can't fail (the fallback function will be called, if none with a better signature match is found), and that it follows a simple pattern (overload the function). Of course, the real-life, production code is somewhat different, and more complicated because, with but one public static method, I want to : parse both reference objects (classes) and value objects (structs) parse enums parse nullable types I want to offer the user the possibility to derive from Parser to offer its own overloads in addition to the default ones But I guess the use of dynamic in the current solution is, in the end, the same thing as doing reflection as done in the original answer below. Only the "notation" changes. Conclusion, I now have the following method : public class Parser { static public void TryParse (string p_input, out T p_output) { // etc. } } which is able to parse anything, including in situations where T is not known at compile time (because the code is generic). Original answer Jason's answer was right about the first question (about the compiler errors). Still, I had no solution to my problem (dispatching from a generic method to non-generic methods according to the runtime generic type T). I tried LukeH's answer , but it didn't work: The generic method is always called, no matter what ( even when removing the out qualifier of the second parameter ). Morten's answer is the most sane one that should works, but it doesn't make use of reflection. So, to solve my own problem, I used reflection. This needs the rewriting of the generic TryParse method: public class MyType { public void TryParse(string p_value) { T value = default(T); // search for the method using reflection System.Reflection.MethodInfo methodInfo = typeof(Parser).GetMethod ( "TryParse", new System.Type[] { typeof(string), typeof(T).MakeByRefType() } ); if (methodInfo != null) { // the method does exist, so we can now call it var parameters = new object[] { p_value, value }; methodInfo.Invoke(null, parameters); value = (T)parameters[1]; } else { // The method does not exist. Handle that case } } } I have the source code available if needed.
