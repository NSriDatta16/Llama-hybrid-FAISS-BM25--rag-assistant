[site]: stackoverflow
[post_id]: 5162649
[parent_id]: 5162580
[tags]: 
It really depends on the system, but modern operating systems with virtual memory tend to load their process images and allocate memory something like this: +---------+ | stack | function-local variables, return addresses, return values, etc. | | often grows downward, commonly accessed via "push" and "pop" (but can be | | accessed randomly, as well; disassemble a program to see) +---------+ | shared | mapped shared libraries (C libraries, math libs, etc.) | libs | +---------+ | hole | unused memory allocated between the heap and stack "chunks", spans the | | difference between your max and min memory, minus the other totals +---------+ | heap | dynamic, random-access storage, allocated with 'malloc' and the like. +---------+ | bss | Uninitialized global variables; must be in read-write memory area +---------+ | data | data segment, for globals and static variables that are initialized | | (can further be split up into read-only and read-write areas, with | | read-only areas being stored elsewhere in ROM on some systems) +---------+ | text | program code, this is the actual executable code that is running. +---------+ This is the general process address space on many common virtual-memory systems. The "hole" is the size of your total memory, minus the space taken up by all the other areas; this gives a large amount of space for the heap to grow into. This is also "virtual", meaning it maps to your actual memory through a translation table, and may be actually stored at any location in actual memory. It is done this way to protect one process from accessing another process's memory, and to make each process think it's running on a complete system. Note that the positions of, e.g., the stack and heap may be in a different order on some systems (see Billy O'Neal's answer below for more details on Win32). Other systems can be very different. DOS, for instance, ran in real mode , and its memory allocation when running programs looked much differently: +-----------+ top of memory | extended | above the high memory area, and up to your total memory; needed drivers to | | be able to access it. +-----------+ 0x110000 | high | just over 1MB->1MB+64KB, used by 286s and above. +-----------+ 0x100000 | upper | upper memory area, from 640kb->1MB, had mapped memory for video devices, the | | DOS "transient" area, etc. some was often free, and could be used for drivers +-----------+ 0xA0000 | USER PROC | user process address space, from the end of DOS up to 640KB +-----------+ |command.com| DOS command interpreter +-----------+ | DOS | DOS permanent area, kept as small as possible, provided routines for display, | kernel | *basic* hardware access, etc. +-----------+ 0x600 | BIOS data | BIOS data area, contained simple hardware descriptions, etc. +-----------+ 0x400 | interrupt | the interrupt vector table, starting from 0 and going to 1k, contained | vector | the addresses of routines called when interrupts occurred. e.g. | table | interrupt 0x21 checked the address at 0x21*4 and far-jumped to that | | location to service the interrupt. +-----------+ 0x0 You can see that DOS allowed direct access to the operating system memory, with no protection, which meant that user-space programs could generally directly access or overwrite anything they liked. In the process address space, however, the programs tended to look similar, only they were described as code segment, data segment, heap, stack segment, etc., and it was mapped a little differently. But most of the general areas were still there. Upon loading the program and necessary shared libs into memory, and distributing the parts of the program into the right areas, the OS begins executing your process wherever its main method is at, and your program takes over from there, making system calls as necessary when it needs them. Different systems (embedded, whatever) may have very different architectures, such as stackless systems, Harvard architecture systems (with code and data being kept in separate physical memory), systems which actually keep the BSS in read-only memory (initially set by the programmer), etc. But this is the general gist. You said: I also know that a computer program uses two kinds of memory: stack and heap, which are also part of the primary memory of the computer. "Stack" and "heap" are just abstract concepts, rather than (necessarily) physically distinct "kinds" of memory. A stack is merely a last-in, first-out data structure. In the x86 architecture, it can actually be addressed randomly by using an offset from the end, but the most common functions are PUSH and POP to add and remove items from it, respectively. It is commonly used for function-local variables (so-called "automatic storage"), function arguments, return addresses, etc. (more below) A "heap" is just a nickname for a chunk of memory that can be allocated on demand, and is addressed randomly (meaning, you can access any location in it directly). It is commonly used for data structures that you allocate at runtime (in C++, using new and delete , and malloc and friends in C, etc). The stack and heap, on the x86 architecture, both physically reside in your system memory (RAM), and are mapped through virtual memory allocation into the process address space as described above. The registers (still on x86), physically reside inside the processor (as opposed to RAM), and are loaded by the processor, from the TEXT area (and can also be loaded from elsewhere in memory or other places depending on the CPU instructions that are actually executed). They are essentially just very small, very fast on-chip memory locations that are used for a number of different purposes. Register layout is highly dependent on the architecture (in fact, registers, the instruction set, and memory layout/design, are exactly what is meant by "architecture"), and so I won't expand upon it, but recommend you take an assembly language course to understand them better. Your question: At what point is the stack used for the execution of the instructions? Instructions go from the RAM, to the stack, to the registers? The stack (in systems/languages that have and use them) is most often used like this: int mul( int x, int y ) { return x * y; // this stores the result of MULtiplying the two variables // from the stack into the return value address previously // allocated, then issues a RET, which resets the stack frame // based on the arg list, and returns to the address set by // the CALLer. } int main() { int x = 2, y = 3; // these variables are stored on the stack mul( x, y ); // this pushes y onto the stack, then x, then a return address, // allocates space on the stack for a return value, // then issues an assembly CALL instruction. } Write a simple program like this, and then compile it to assembly ( gcc -S foo.c if you have access to GCC), and take a look. The assembly is pretty easy to follow. You can see that the stack is used for function local variables, and for calling functions, storing their arguments and return values. This is also why when you do something like: f( g( h( i ) ) ); All of these get called in turn. It's literally building up a stack of function calls and their arguments, executing them, and then popping them off as it winds back down (or up ;). However, as mentioned above, the stack (on x86) actually resides in your process memory space (in virtual memory), and so it can be manipulated directly; it's not a separate step during execution (or at least is orthogonal to the process). FYI, the above is the C calling convention , also used by C++. Other languages/systems may push arguments onto the stack in a different order, and some languages/platforms don't even use stacks, and go about it in different ways. Also note, these aren't actual lines of C code executing. The compiler has converted them into machine language instructions in your executable. They are then (generally) copied from the TEXT area into the CPU pipeline, then into the CPU registers, and executed from there. [This was incorrect. See Ben Voigt's correction below.]
