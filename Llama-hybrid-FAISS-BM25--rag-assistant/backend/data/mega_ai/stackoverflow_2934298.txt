[site]: stackoverflow
[post_id]: 2934298
[parent_id]: 2934042
[tags]: 
I'm going to provide another answer in response to your comment with the Matrix example. For your Matrix example, you can do this: enum MatrixOrder { ColumnMajor, RowMajor }; template class Dense {}; template class Sparse {}; template class Storage, MatrixOrder Order> class Matrix { public: Matrix() { ::printf("Primary\n"); } }; template class Matrix { public: Matrix() { ::printf("Specialized\n"); } }; int main() { // Trying out some combinations... Matrix a; // Prints "Specialized" Matrix b; // Prints "Specialized" Matrix c; // Prints "Primary" Matrix d; // Prints "Primary" Matrix e; // Prints "Specialized" Matrix f; // Prints "Specialized" Matrix g; // Prints "Primary" Matrix h; // Prints "Primary" return 0; }; It takes on a similar pattern to my last answer. Now, all storage schemes taking on Dense will be specialized. Hope this helps, at least a little bit. :-)
