[site]: stackoverflow
[post_id]: 4771769
[parent_id]: 2678009
[tags]: 
I've been beating my head against this one on and off for years, and I just today came up with something I'm proud of - elegant, unobtrusive, and you can do it only two or three (really long) lines of code. ParentFoo has_many NestedBars, with appropriate accepts_nested_parameters and all those goodies. You render a set of fields for a nested_bar into a data-add-nested attribute on the link, using the :child_index to set a string that you can replace later. You pass that string in a second parameter, data-add-nested-replace parent_foos/_form.html.haml - semantic_form_for @parent_foo do |f| -# render existing records - f.semantic_fields_for :nested_bars do |i| = render 'nested_bar_fields', :f => i # magic! - reuse_fields = f.semantic_fields_for :nested_bars, @parent_foo.nested_bars.build, :child_index => 'new_nested_bar_fields' do |n| render('nested_bar_fields', :f => n) end = link_to 'Add nested bar', '#', 'data-add-nested' => reuse_fields, 'data-add-nested-replace' => 'new_nested_bar_fields' the nested fields partial is nothing fancy parent_foos/_nested_bar_fields.html.haml - f.inputs do = f.input :name = f.input :_delete, :as => :boolean In your jQuery you bind the click of elements with a data-add-nested field (I've used live() here so ajax-loaded forms will work) to insert the fields into the DOM, replacing the string with a new ID. Here I'm doing the simple thing of inserting the new fields before() the link, but you could also provide an add-nested-replace-target attribute on the link saying where in the DOM you want the new fields to wind up. application.js $('a[data-add-nested]').live('click', function(){ var regexp = new RegExp($(this).data('add-nested-replace'), "g") $($(this).data('add-nested').replace(regexp, (new Date).getTime())).insertBefore($(this)) }) You could put this in a helper, of course; I'm presenting it here directly in the view so the principle is clear without mucking about in metaprogramming. If you're worried about names colliding, you could generate a unique ID in that helper and pass it in nested-replace. getting fancy with the delete behaviour is left as an exercise for the reader. (shown for Rails 2 because that's the site I'm working on today - almost the same in Rails 3)
