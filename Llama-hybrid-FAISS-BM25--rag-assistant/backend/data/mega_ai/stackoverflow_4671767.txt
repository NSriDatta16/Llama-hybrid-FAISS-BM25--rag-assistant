[site]: stackoverflow
[post_id]: 4671767
[parent_id]: 4671644
[tags]: 
You might find this answer useful to a similar question. And you can get the nth prime numbers with List primes = findPrimes(0, n); System.out.println( primes.get(i) ); ** EDIT ** Here is the integral test program that I came up (modified since the last posted answer above) with benchmark tests and all. I know there are faster implementations, and some optimizations can still be made, but here are some algorithms to generate prime numbers : public class PrimeTests { public static void main(String... args) { AbstractPrimeGenerator[] generators = new AbstractPrimeGenerator[] { new DefaultPrimeGenerator(), new AtkinSievePrimeGenerator(), new SundaramSievePrimeGenerator() }; int[] primes; int[] old_primes = null; double[] testAvg = new double[generators.length]; long ts, te; double time; DecimalFormat df = new DecimalFormat("0.0######################"); int max = 10000000; int testCountLoop = 10; int it = 0, ti; while (it++ 2) { primes[found++] = 2; for (int x = 3; x x) { break; } } if (isPrime) { primes[found++] = x; // add x to our prime numbers } } } return Arrays.copyOf(primes, found); } } /** * Sieve of Atkin prime number generator Implementation following the Sieve * of Atkin to generate prime numbers * * @see http://en.wikipedia.org/wiki/Sieve_of_Atkin */ static public class AtkinSievePrimeGenerator extends AbstractPrimeGenerator { @Override public String getName() { return "Sieve of Atkin generator"; } @Override public int[] findPrimes(int max) { boolean[] isPrime = new boolean[max + 1]; double sqrt = Math.sqrt(max); for (int x = 1; x y && (n 2) { primes[found++] = 2; } if (max > 3) { primes[found++] = 3; } for (int n = 5; n 2) { primes[found++] = 2; } for (int i = 1; i On my machine, the result gives : Results: 1. Average time finding 10000000 primes numbers from Default generator = 1108.7848961000002 ms or 0.0016684019448402676 ms per prime 2. Average time finding 10000000 primes numbers from Sieve of Atkin generator = 199.8792727 ms or 0.0003007607413114167 ms per prime 3. Average time finding 10000000 primes numbers from Sieve of Sundaram generator = 132.6467922 ms or 0.00019959522073372766 ms per prime Using one of the class's method above (you don't need the actual base class and all, only the actual method), you can do : public class PrimeTest2 { static public int[] findPrimes(int max) { int[] primes = new int[max]; int found = 0; boolean isPrime; // initial prime if (max > 2) { primes[found++] = 2; for (int x = 3; x x) { break; } } if (isPrime) { primes[found++] = x; // add x to our prime numbers } } } return Arrays.copyOf(primes, found); } public static void main(String... args) { Scanner input = new Scanner(System.in); int MAX_N = Integer.MAX_VALUE / 100; int n = 0; while (n = MAX_N) { System.out.print("Enter N: "); n = input.nextInt(); if (n = MAX_N) { System.out.println("n must be smaller than " + MAX_N); } } int max = n * 100; // just find enough prime numbers.... int[] primes = findPrimes(max); System.out.println("Number of prime numbers found from " + 0 + " to " + max + " = " + primes.length); System.out.println("The " + n + (n == 1 ? "st" : n == 2 ? "nd" : n == 3 ? "rd" : "th") + " prime number is : " + primes[n - 1]); } } Which will output (for example) : Enter N: 10000 Number of prime numbers found from 0 to 1000000 = 78498 The 10000th prime number is : 104729 With that in hand, you pretty have all that is to say about finding the nth prime number. For larger numbers (beyond int's), you'll have to modify the "default generator's" un-optimized method to accept long or use other methodologies (i.e. other language and/or libraries) Cheers!
