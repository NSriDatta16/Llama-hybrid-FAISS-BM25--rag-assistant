[site]: stackoverflow
[post_id]: 843360
[parent_id]: 643410
[tags]: 
I would like to narrow the problem down to it's core. The Problem Of course, most of your changes will be caught by the test. But there is subset of Scenarios where your test won't fail - although it should: As you write code, you use your methods multiple times. You get a 1:n relation between method definition and use. Each class that uses that method will use it's mock in the according test. So the mock is also used n times. Your methods result was once expected to never be null . After you change this, you probably will remember to fix the according test. So far so good. You run your Tests - all pass . But over time you forgot something ... the mock never returns a null . So n test for n classes that use the mock do not test for null . Your QA will fail - although your tests did not fail. Obviously you will have to modify your other tests. But there are no fails to work along. So you need a solution, that works better than remembering all referencing tests. A Solution To avoid problems like this, you will have to write better tests from the beginning. If you miss out the cases, where the tested class should handle errors or null values, you simply have incomplete tests . It's like not testing all functions of your class. It's hard to add this later. - So start early and be extensive with your tests. As mentioned by other users - the code coverage reveals some untested cases. But missing error-handling code and the missing according test won't appear in code coverage. (Code coverage of 100% doesn't mean, that you are not missing something.) So write good test: Assume the outside world to be malicious. That does not only include to pass bad parameters (like null values). Your mocks are a part of the outside world too. Pass null s and exceptions - and watch your class handling them as expected. If you decide null to be a valid value - these test will later fail (because of missing exceptions). So you get a list of fails to work along. Because each calling class handles the errors or null different - it is not duplicate code that could be avoided. Different treatment needs different tests. Hint: Keep your mock simple and clean. Move the expected return values to the testing method. (Your mock can pass them simply back.) Avoid testing decisions in mocks.
