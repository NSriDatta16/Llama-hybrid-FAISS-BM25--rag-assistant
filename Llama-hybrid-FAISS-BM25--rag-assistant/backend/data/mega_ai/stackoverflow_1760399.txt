[site]: stackoverflow
[post_id]: 1760399
[parent_id]: 
[tags]: 
Is it common (or encouraged) practice to overload a function to accept IEnumerable , ICollection , IList , etc.?

EDIT : From the answers given, it's been made rather clear to me how the design I'm asking about below should actually be implemented. With those suggestions in mind (and in response to a comment politely pointing out that my example code does not even compile ), I've edited the following code to reflect what the general consensus seems to be. The question that remains may no longer make sense in light of the code, but I'm leaving it as it is for posterity. Suppose I have three overloads of a function, one taking IEnumerable , one taking ICollection , and one taking IList , something like the following: public static T GetMiddle (IEnumerable values) { IList list = values as IList ; if (list != null) return GetMiddle(list); int count = GetCount (values); T middle = default(T); int index = 0; foreach (T value in values) { if (index++ >= count / 2) { middle = value; break; } } return middle; } private static T GetMiddle (IList values) { int middleIndex = values.Count / 2; return values[middleIndex]; } private static int GetCount (IEnumerable values) { // if values is actually an ICollection (e.g., List ), // we can get the count quite cheaply ICollection genericCollection = values as ICollection ; if (genericCollection != null) return genericCollection.Count; // same for ICollection (e.g., Queue , Stack ) ICollection collection = values as ICollection; if (collection != null) return collection.Count; // otherwise, we've got to count values ourselves int count = 0; foreach (T value in values) count++; return count; } The idea here is that, if I've got an IList , that makes my job easiest; on the other hand, I can still do the job with an ICollection or even an IEnumerable ; the implementation for those interfaces just isn't as efficient. I wasn't sure if this would even work (if the runtime would be able to choose an overload based on the parameter passed), but I've tested it and it seems to. My question is: is there a problem with this approach that I haven't thought of? Alternately, is this in fact a good approach, but there's a better way of accomplishing it (maybe by attempting to cast the values argument up to an IList first and running the more efficient overload if the cast works)? I'm just interested to know others' thoughts.
