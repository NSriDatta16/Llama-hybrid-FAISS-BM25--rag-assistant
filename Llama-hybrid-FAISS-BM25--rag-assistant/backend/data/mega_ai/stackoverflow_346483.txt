[site]: stackoverflow
[post_id]: 346483
[parent_id]: 346345
[tags]: 
But my question is in large projects where each class is dependent on many other classes how do you go about unit testing the class ? First, you understand that "each class is dependent on many other classes" is a bad thing, right? And that it isn't a function of having a large project but rather of bad design? (This is one of the benefits of TDD, that it tends to discourage such highly coupled code.) Stubbing out every other class doesn't make much sense because of both complexity and the time required to write the stubs. Not to mention that it doesn't help the design problem. Worse, the investment in all the stubs can actually be a hinderance to refactoring, if only a psychological one. A better approach (IMHO) is to start from inside out on the classes, changing the design as you go. Typically I would approach this by doing what I call "internal dependency injetion". This involves leaving the method signatures unchanged but extracting the data needed from the dependencies and then extracting functions that hold the actual logic. A trivial example might be: public int foo(A a, B b) { C c = a.getC(); D d = b.getD(); Bar bar = calculateBar(c, d); return calculateFoo(bar, this.baz); } Bar calculateBar(C c, D d) { ... } int calculateFoo(Bar bar, Baz baz) { ... } Now I can write a test for calculateBar and calculateBaz, but I don't need to worry in setting up internal states (this.baz) and I don't need to worry about creating mock versions of A and B. After creating tests like this with the existing interfaces then I look for opportunity to push the changes out to the interface, like changing the Foo method to take C and D rather than A and B. Any of that make sense?
