[site]: stackoverflow
[post_id]: 689836
[parent_id]: 689778
[tags]: 
This doesn't look all that language-agnostic to me, since lots of languages don't have anything corresponding to the preprocessing phase. However, it's reasonably accurate for a start. You seem to be confusing virtual address space with disk file storage. Actually, it's an adjunct to physical memory, and works the same way (except for performance). It uses the disk, but not in the same way as using a file. You know how physical memory works. Virtual memory is a way of faking a larger memory in a way that's usually transparent. The file is divided into "pages", and the pages are read in from the disk as needed. Physical memory is divided into "page frames", and the physical memory address doesn't have anything to do with the virtual address it's currently representing. Obviously, if the program uses more memory than is physically available, page frames will have to be reused, so the contents of the page frame will have to be written back (if changed from when it was read), and a new page loaded. If the program uses only part of its address space at a time (the "working set"), and that part is few enough pages so they can all sit in physical memory at once, this works well. If it's constantly referring to more pages than can fit in physical memory, pages constantly have to be read in from the disk ("thrashing"), performance drops drastically, and the disk is under constant load. Therefore, when I have compiled and linked a program, there's an executable file on the disk, in the file system. When I execute it, it gets assigned an address space, and then it gets more complicated. Effectively, it's loaded into memory, and how much physical and how much virtual memory is irrelevant to the user (except that if it doesn't have enough physical it's going to run awfully slow). Therefore, it is possible to run a 512M program with 256M of physical memory. When memory is requested from the heap, it is assigned to memory locations. At least the C and C++ standard require that it be usable, unless the request failed, so "committed" looks to me to be an odd choice of words. It doesn't have to be in physical memory until it's used.
