[site]: stackoverflow
[post_id]: 4431599
[parent_id]: 4430995
[tags]: 
Maybe you should have the "board" view handle all the dragging. When a touch begins and there is a tile at that point, then start dragging it. Otherwise check whenever the touch is moved and as soon as you find a tile, start dragging it. You could override hitTest:withEvent: in the board view so that it can still detect when a touch hits a tile, but always return itself so that touch events go to the board view (e.g. record the subview that was hit in a separate member variable, so that you know what to start dragging later on when touch events start coming in). More Details When handling touches, UIView will use hitTest to find the view that should receive touch events. The default implementation checks each subview so that the "deepest" subview in the hierarchy gets the touches. In order for the board view to receive touches, you would have to disable userInteraction on all of the tile views. But that means you can't use hitTest to find the tile that was touched, since it ignores views that have userInteraction disabled. So what I am saying is leave userInteraction enabled on the touch views. But override hitTest on the board view so that it first calls the super implementation in order to find a tile (if the result is self , the board itself was hit). No need to implement your own tile searching. Something like this: - (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent*)event { UIView *hitView = [super hitTest:point withEvent:event]; if ( hitView != self ) self.draggingTile = hitView; return self; } Now you know what tile to move in touchesMoved . However, I don't think hitTest is called as the touch is moved, so if no tile has been picked up yet, you may have to call it manually (you can get the point and event from the touch passed to touchesMoved .
