[site]: stackoverflow
[post_id]: 203760
[parent_id]: 202471
[tags]: 
In IB, start an empty XIB. Now go to the pallete and drag in a UITableViewCell, double click to bring up and edit. include only the custom UITableViewCell (no other UIViews or other top level controls) - make sure it's a real UITableViewCell in IB, or you cannot set a reuse identifier (as opposed to casting a UIView in IB as your custom UITableViewCell class). Then you can add lables or whatever you like within the cell, as well as setting the reuse identifier or set whatever disclosure indicator you might like. To use, you provide code like this in the tableView:cellForRow:atIndexPath: method: YourCustomCellClass *cell = (YourCustomCellClass *)[tableView dequeueReusableCellWithIdentifier: ]; if ( cell == nil ) { NSArray *topLevelObjects = [[NSBundle mainBundle] loadNibNamed: owner:self options:nil]; id firstObject = [topLevelObjects objectAtIndex:0]; if ( [ firstObject isKindOfClass:[UITableViewCell class]] ) cell = firstObject; else cell = [topLevelObjects objectAtIndex:1]; } If you have any labels or other controls you want to reference in your code, wire them in IB to your custom cell class - NOT the file's owner, which you do not ever need to set using the above code (you can leave it as NSObject). Edit: I note you are really looking for an NSCell answer, but the code approach to using IB should be identical in Cocoa with the Cocoa Touch code I used above as loadNibNamed is a standard Cocoa call.
