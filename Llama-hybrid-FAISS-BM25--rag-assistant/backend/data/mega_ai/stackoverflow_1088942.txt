[site]: stackoverflow
[post_id]: 1088942
[parent_id]: 1074403
[tags]: 
The best I could up with is to use a fast out on the looping logic. Combined with the possibility of using the Non-Zero approach as described by themis, you can answer you question by inspecting less than 2% of the N^2 problem. Below is some code that gives the timing for numbers that are between 80% and 99% zero. When the numbers get around 88% zero, using themis' approach switches to being better (was not coded in the sample below, though). This is not a highly theoretical solution, but it is practical. OK, here is some "theory" of the problem space: Basically, each bit for X (the output) is the OR summation of the bits on the diagonal of a grid constructed by having the bits of A along the top (MSB to LSB left to right) and the bits of B along the side (MSB to LSB from top to bottom). Since the bit of X is 1 if any on the diagonal is 1, you can perform an early out on the cell traversal. The code below does this and shows that even for numbers that are ~87% zero, you only have to check ~2% of the cells. For more dense (more 1's) numbers, that percentage drops even more. In other words, I would not worry about tricky algorithms and just do some efficient logic checking. I think the trick is to look at the bits of your output as the diagonals of the grid as opposed to the bits of A shift-OR with the bits of B. The trickiest thing is this case is keeping track of the bits you can look at in A and B and how to index the bits properly. Hopefully this makes sense. Let me know if I need to explain this a bit further (or if you find any problems with this approach). NOTE: If we knew your problem space a bit better, we could optimize the algorithm accordingly. If your numbers are mostly non-zero, then this approach is better than themis since his would result is more computations and storage space needed (sizeof(int) * NNZ). NOTE 2: This assumes the data is basically bits, and I am using .NET's BitArray to store and access the data. I don't think this would cause any major headaches when translated to other languages. The basic idea still applies. using System; using System.Collections; namespace BigIntegerOr { class Program { private static Random r = new Random(); private static BitArray WeightedToZeroes(int size, double pctZero, out int nnz) { nnz = 0; BitArray ba = new BitArray(size); for (int i = 0; i
