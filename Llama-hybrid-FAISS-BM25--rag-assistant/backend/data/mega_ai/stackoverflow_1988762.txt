[site]: stackoverflow
[post_id]: 1988762
[parent_id]: 472059
[tags]: 
Damn, this particular problem was a real pain in my ass too!! And here is how I got rid of it, thanks to damelin answer. In my case, the dijit.form.filteringSelect backed by a dojox.data.QueryReadStore was needed to be filled by a formatted string coming from multiple db values itself coming from complex tables (with some parent and even manyToMany relationship). Please don't ask why, just consider I love separating db tables as soon as possible, in order to avoid duplicates. All of that is in the context of a Zend Framework application, where the QueryReadStore is served by a controller action which I'll name here autocompletelistAction . Therefore, starting from damelin answer, I began working on my autocompletelisteAction to separate the two cases of QueryReadStore request, reading the GET parameter and its eventual asterisk. First, I clean the parameter and search for its last char : $txt = (String) $this->_request->getParam('parameter'); $lastChar = substr($txt, -1); Then, if the parameter has more than 1 char and no asterisk at the end, I'm gonna get rid of my $txt parameter and build my like clauses by hand : if ((strlen($txt) >= 1) && ($lastChar != '*')) { // here, the parameter is the full text, which the user selected by // clicking on a shown element of the filteringSelect // Therefore, I "explode" the parameter to correspond to my searched values // and I build my SQL LIKE clauses without "%" // Consequence? There is only one result which is the good one. } else { // here, the parameter is a "part" of the search, which the user typed in // Therefore, I build my SQL LIKE clauses with "%$txt%" } // Here I can just launch my SQL queries with the built LIKE clauses // and return result(s) to the QueryReadStore Why checking if $txt is more than one char? Because within the Zend Framework, sometimes I can "autoload" the filteringSelect with the page, which sends a fully empty argument (even without asterisk), which then would go to my "explode" functions. This complex scenario is mine, but I think each could adapt this simple PHP test on the parameter in order to serve the right answer. So the real job was done by damelin here because he investigated the reasons through dojo elements.
