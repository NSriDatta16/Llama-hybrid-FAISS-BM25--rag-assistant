[site]: stackoverflow
[post_id]: 5655056
[parent_id]: 5654120
[tags]: 
I think this is not doable with your given constraints ( O(n) time and O(1) space, i.e. no additional space) for an array or array-based list. (Assuming of course, that we can't simply create a new List object delegating to the original ones.) If you have two linked lists, this is doable - if we assume the garbage collector is fast enough, i.e. deleting an element from one list and adding it to another list does not violate the space limitation. public void interleaveLists(List first, List second) { ListIterator firstIt = first.listIterator(); ListIterator secondIt = second.listIterator(); while(secondIt.hasNext()) { fistIt.next(); firstIt.add(secondIt.next()); secondIt.remove(); } } This method works for any pair of lists, but is only O(n) for linked lists. For a custom linked list where we can modify the pointers, we don't have to rely on the garbage collector, we would simply change the nodes. Here for a singly-linked list: public void interleaveLinkedLists(Node firstList, Node secondList) { while(secondList != null) { Node nextFirst = firstList.next; Node nextSecond = secondList.next; firstList.next = secondList; secondList.next = nextFirst; firstList = nextFirst; secondList = nextSecond; } } For a doubly-linked list, we would also have to adapt the prev-pointers. Here the wrapping variant mentioned in the first paragraph: public List interleaveLists(final List first, final List second) { if (first.size() != second.size()) throw new IllegalArgumentException(); return new AbstractList () { public int size() { return 2 * first.size(); } public X get(int index) { return index % 2 == 0 ? first.get(index / 2) : second.get(index / 2); } // if necessary, add a similar set() method. add/remove are not sensible here. }; } This is actually O(1) in time, too.
