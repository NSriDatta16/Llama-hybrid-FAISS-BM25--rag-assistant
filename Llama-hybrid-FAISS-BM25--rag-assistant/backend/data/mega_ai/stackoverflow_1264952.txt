[site]: stackoverflow
[post_id]: 1264952
[parent_id]: 
[tags]: 
Reading from a HttpResponseStream fails

I'm running into an issue where reading from a HttpResponseStream fails because the StreamReader that I'm wrapping around in reads faster that the Response Stream gets the actual response. I'm retrieving a reasonably small sized file (around 60k) but the Parser which processes the response into an actual object fails because it hits an unexpected character (Code 65535) which from experience I know to be the character produced when you read from a StreamReader and there are no further characters available. For the record I know that the content being returned is valid and will parse correctly since the failure occurs at different points in the file each time I run the code. It's the parser.Load() line in the following where it fails. Is there a way to ensure I've read all the content before attempting to parse it short of copying the response stream into a MemoryStream or string and then processing it? /// /// Makes a Query where the expected Result is an RDF Graph ie. CONSTRUCT and DESCRIBE Queries /// /// SPARQL Query String /// RDF Graph public Graph QueryWithResultGraph(String sparqlQuery) { try { //Build the Query URI StringBuilder queryUri = new StringBuilder(); queryUri.Append(this._endpoint.ToString()); queryUri.Append("?query="); queryUri.Append(Uri.EscapeDataString(sparqlQuery)); if (!this._defaultGraphUri.Equals(String.Empty)) { queryUri.Append("&default-graph-uri="); queryUri.Append(Uri.EscapeUriString(this._defaultGraphUri)); } //Make the Query via HTTP HttpWebResponse httpResponse = this.DoQuery(new Uri(queryUri.ToString()),false); //Set up an Empty Graph ready Graph g = new Graph(); g.BaseURI = this._endpoint; //Parse into a Graph based on Content Type String ctype = httpResponse.ContentType; IRDFReader parser = MIMETypesHelper.GetParser(ctype); parser.Load(g, new StreamReader(httpResponse.GetResponseStream())); return g; } catch (UriFormatException uriEx) { //URI Format Invalid throw new Exception("The format of the URI was invalid", uriEx); } catch (WebException webEx) { //Some sort of HTTP Error occurred throw new Exception("A HTTP Error occurred", webEx); } catch (RDFException) { //Some problem with the RDF or Parsing thereof throw; } catch (Exception) { //Other Exception throw; } } /// /// Internal Helper Method which executes the HTTP Requests against the SPARQL Endpoint /// /// URI to make Request to /// Indicates if only SPARQL Result Sets should be accepted /// HTTP Response private HttpWebResponse DoQuery(Uri target, bool sparqlOnly) { //Expect errors in this function to be handled by the calling function //Set-up the Request HttpWebRequest httpRequest; HttpWebResponse httpResponse; httpRequest = (HttpWebRequest)WebRequest.Create(target); //Use HTTP GET/POST according to user set preference if (!sparqlOnly) { httpRequest.Accept = MIMETypesHelper.HTTPAcceptHeader(); //For the time being drop the application/json as this doesn't play nice with Virtuoso httpRequest.Accept = httpRequest.Accept.Replace("," + MIMETypesHelper.JSON[0], String.Empty); } else { httpRequest.Accept = MIMETypesHelper.HTTPSPARQLAcceptHeader(); } httpRequest.Method = this._httpMode; httpRequest.Timeout = this._timeout; //HTTP Debugging if (Options.HTTPDebugging) { Tools.HTTPDebugRequest(httpRequest); } httpResponse = (HttpWebResponse)httpRequest.GetResponse(); //HTTP Debugging if (Options.HTTPDebugging) { Tools.HTTPDebugResponse(httpResponse); } return httpResponse; } Edit To clarify what I already stated this is not a bug in the Parser, this is an issue of the StreamReader reading faster than the Response Stream provides data. I can get around this by doing the following but would like suggestions of better or more elegant solutions: //Parse into a Graph based on Content Type String ctype = httpResponse.ContentType; IRDFReader parser = MIMETypesHelper.GetParser(ctype); Stream response = httpResponse.GetResponseStream(); MemoryStream temp = new MemoryStream(); Tools.StreamCopy(response, temp); response.Close(); temp.Seek(0, SeekOrigin.Begin); parser.Load(g, new StreamReader(temp)); Edit 2 BlockingStreamReader class as per Eamon's suggestion: /// /// A wrapper to a Stream which does all its Read() and Peek() calls using ReadBlock() to handle slow underlying streams (eg Network Streams) /// public sealed class BlockingStreamReader : StreamReader { private bool _peeked = false; private int _peekChar = -1; public BlockingStreamReader(StreamReader reader) : base(reader.BaseStream) { } public BlockingStreamReader(Stream stream) : base(stream) { } public override int Read() { if (this._peeked) { this._peeked = false; return this._peekChar; } else { if (this.EndOfStream) return -1; char[] cs = new char[1]; base.ReadBlock(cs, 0, 1); return cs[0]; } } public override int Peek() { if (this._peeked) { return this._peekChar; } else { if (this.EndOfStream) return -1; this._peeked = true; char[] cs = new char[1]; base.ReadBlock(cs, 0, 1); this._peekChar = cs[0]; return this._peekChar; } } public new bool EndOfStream { get { return (base.EndOfStream && !this._peeked); } } } Edit 3 Here is a much improved solution which can wrap any TextReader and provide an EndOfStream property. It uses an internal buffer which is filled by using ReadBlock() on the wrapped TextReader . All the Read() methods of the reader can the be defined using this buffer, buffer size is configurable: /// /// The BlockingTextReader is an implementation of a TextReader designed to wrap other readers which may or may not have high latency. /// /// /// /// This is designed to avoid premature detection of end of input when the input has high latency and the consumer tries to read from the input faster than it can return data. All methods are defined by using an internal buffer which is filled using the ReadBlock() method of the underlying TextReader /// /// public sealed class BlockingTextReader : TextReader { private char[] _buffer; private int _pos = -1; private int _bufferAmount = -1; private bool _finished = false; private TextReader _reader; public const int DefaultBufferSize = 1024; public BlockingTextReader(TextReader reader, int bufferSize) { if (reader == null) throw new ArgumentNullException("reader", "Cannot read from a null TextReader"); if (bufferSize = 1", "bufferSize"); this._reader = reader; this._buffer = new char[bufferSize]; } public BlockingTextReader(TextReader reader) : this(reader, DefaultBufferSize) { } public BlockingTextReader(Stream input, int bufferSize) : this(new StreamReader(input), bufferSize) { } public BlockingTextReader(Stream input) : this(new StreamReader(input)) { } private void FillBuffer() { this._pos = -1; if (this._finished) { this._bufferAmount = 0; } else { this._bufferAmount = this._reader.ReadBlock(this._buffer, 0, this._buffer.Length); if (this._bufferAmount == 0 || this._bufferAmount = 0"); if (count = 0"); if ((buffer.Length - index) = this._bufferAmount) { if (!this._finished) { this.FillBuffer(); if (this.EndOfStream) return 0; } else { return 0; } } this._pos = Math.Max(0, this._pos); if (count = this._bufferAmount - 1) { if (!this._finished) { this.FillBuffer(); if (this.EndOfStream) return -1; } else { return -1; } } this._pos++; return (int)this._buffer[this._pos]; } public override int Peek() { if (this._bufferAmount == -1 || this._pos >= this._bufferAmount - 1) { if (!this._finished) { this.FillBuffer(); if (this.EndOfStream) return -1; } else { return -1; } } return (int)this._buffer[this._pos + 1]; } public bool EndOfStream { get { return this._finished && (this._pos >= this._bufferAmount - 1); } } public override void Close() { this._reader.Close(); } protected override void Dispose(bool disposing) { this.Close(); this._reader.Dispose(); base.Dispose(disposing); } }
