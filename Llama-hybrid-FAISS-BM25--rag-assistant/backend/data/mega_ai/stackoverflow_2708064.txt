[site]: stackoverflow
[post_id]: 2708064
[parent_id]: 2704583
[tags]: 
With the lack of responses, I decided to evaluate on the answers below with that I've learned.. As @Scott stated, .NET 4 added the Task Parallel Library which adds a number of innovations, new methods and approaches to parallelism. One of the first things to mention is the Parallel.For and Parallel.ForEach methods, which allow the developer to process multiple items in multiple threads. The Framework in this case will decide how many threads are necessary, and when to create new threads, and when not to. This is a very simple and straightforward way to parallelize existing code, and add some performance boost. Another way, somewhat similar to the previous approaches is using the PLINQ extenders. They take an existing enumeration, and extend it with parallel linq extenders. So if you have an existing linq query, you can easily convert it to PLINQ. What this means is all the operations on the PLINQ enumerable will also take advantage of multiple threads, and filtering your list of objects using a .Where clause, for example, will run in multiple threads now! One of the bigger innovations in the TPL is the new Task class. In some ways it may look like the already well known Thread class, but it takes advantage of the new Thread Pool in .NET 4 (which has been improved a lot compared on previous versions), and is much more functional than the regular Thread class. For example you can chain Tasks where tasks in the middle of the chain will only start when the previous ones finish. Examples and in-depth explanation in a screencast on Channel 9 To enhance the work with Task classes, we can use the BlockingCollection<> . This works perfectly in situations where you have a producer-consumer scenario. You can have multiple threads producing some objects, that will then be consumed and processed by consumer methods. This can be easily parallelised and controlled with the Task factory and the blocking collection. Useful screencast with examples from Channel 9 These can also use different backing storage classes (ConcurrentQueue, ConcurentStack, ConcurrentBag), which are all thread safe, and are different in terms of element ordering and performance. Examples and explanations of them in a different video here One more new thing that has been added (which probably isn't part of the TPL, but helps us here anyway) is the CountdownEvent class, which can help us in "task coordination scenarios" (c). Basically allows us to wait until all parallel tasks are finished. Screencast with example usage on Channel 9 You can see a number of screencasts and videos on Channel 9 that are tagged with "Parallel Computing"
