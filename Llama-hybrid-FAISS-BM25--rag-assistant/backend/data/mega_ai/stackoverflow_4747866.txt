[site]: stackoverflow
[post_id]: 4747866
[parent_id]: 4747511
[tags]: 
The code simply loops over a set of nop -instructions for a set amount of time. The movlb instruction is used to load the BSR (only an 8-bit register, thus the shift). The decfsz instruction is then used to decrement the loop counter and skip the next instruction if the result is zero, to break out of the loop. If the next instruction is not skipped, the Jumpback instruction is called (a goto ) which jumps back to the top of the loop. Since each instruction on an 18F is two bytes wide (double word instructions are four bytes), you have to jump 12 lines back for the 32MHz version (5 nop s and a decfsz ). Now, you could follow paxdiablo's advice and make a new version with more nop s, but that would take up some unnecessary space if you are only going to run @ 64MHz anyway. I would think that you could just do something like #if PIC_CLK == 64000000 #define WaitFor1NOP asm("nop") #define Jumpback asm("goto $ - 4") #else #error delay.h - please define PIC_CLK correctly #endif #define DelayUs(x) { \ delayus_variable=(unsigned char)(x*SOME_NUMBER); \ asm("movlb (_delayus_variable) >> 8"); \ WaitFor1NOP; } \ asm("decfsz (_delayus_variable)&0ffh,f"); \ Jumpback; Here SOME_NUMBER is the number of nop s you need to loop over to reach 1Âµs @ 64MHz, 13 according to paxdiablo's excellent math. EDIT: paxdiablo brought to my attention that this solution will limit the range of delay times more than his, since the largest number you can pass to the macro is 1/13th of what goes into an unsigned char. An unsigned char is 8 bits, which leaves us with 255/13 = 19. I don't know if that is too small for you. You could work around this by calling the delay macro multiple times, possibly even creating a new macro to do that for you.
