[site]: stackoverflow
[post_id]: 2316645
[parent_id]: 2315930
[tags]: 
If you use .Net framework 2.0 SP2 or higher, than you may use new asyncrhronous sockets model based on IO Completion ports . In this case you shouldn't create your own threads, because IO Completion ports do all job for you. Here some examples: tcpServer = new System.Net.Sockets.TcpListener(IPAddress.Any, port); tcpServer.Start(); tcpServer.BeginAcceptSocket(EndAcceptSocket, tcpServer); private void EndAcceptSocket(IAsyncResult asyncResult) { TcpListener lister = (TcpListener)asyncResult.AsyncState; Socket sock = lister.EndAcceptSocket(asyncResult); //handle socket connection (you may add socket to you internal storage or something) //start accepting another sockets lister.BeginAcceptSocket(EndAcceptSocket, lister); SocketAsyncEventArgs e = new SocketAsyncEventArgs(); e.Completed += ReceiveCompleted; e.SetBuffer(new byte[socketBufferSize], 0, socketBufferSize); sock.ReceiveAsync(e); } void ReceiveCompleted(object sender, SocketAsyncEventArgs e) { var sock = (Socket)sender; if (!sock.Connected) { //handle socket disconnection } var buf = new byte[size]; Array.Copy(e.Buffer, buf, size); //handle received data //start reading new data sock.ReceiveAsync(e); }
