[site]: stackoverflow
[post_id]: 4441894
[parent_id]: 4441837
[tags]: 
Well I made some progress on this but I still don't understand where hibernate gets its names. I debugged into the guts of hibernate and found the following class: org.hibernate.persister.entity.AbstractPropertyMapping In this class there is a method: public Type toType(String propertyName) throws QueryException { Type type = (Type) typesByPropertyPath.get(propertyName); if (type == null) { throw propertyException(propertyName); } return type; } Which tries to resolve the name given in the criteria against the object. So in the typesByPropertyPath map I found the following values: id -> DBGroupId=org.hibernate.type.LongType@1e96ffd key -> value=org.hibernate.type.StringType@aa2ee4 value -> value=org.hibernate.type.StringType@aa2ee4 systemUserId -> DBGroupId=org.hibernate.type.LongType@1e96ffd securityRoleId -> DBGroupId=org.hibernate.type.LongType@1e96ffd externalGroupId -> DBGroupId=org.hibernate.type.LongType@1e96ffd DBGroupId -> DBGroupId=org.hibernate.type.LongType@1e96ffd Here you can see that the CAPITALIZATION of DBGroupId did not match what I had in my criteria. So I changed that from dbgroupid to DBGroupId like this: public Collection getPreferencesForDBGroup(long dbgroupId) { final DetachedCriteria criteria = DetachedCriteria.forClass(Preference.class) .add(Restrictions.eq("DBGroupId", dbgroupId)) .setResultTransformer(DistinctRootEntityResultTransformer.INSTANCE); return getHibernateTemplate().findByCriteria(criteria); } Now it works.
