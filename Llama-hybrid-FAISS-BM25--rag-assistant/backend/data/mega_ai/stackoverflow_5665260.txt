[site]: stackoverflow
[post_id]: 5665260
[parent_id]: 
[tags]: 
OutOfMemoryError: bitmap size exceeds VM budget

Sorry it seems like a repeated question, BUT I think I don't qualify to any of the recommendations already posted. I've a Gallery of maximum 20 images on my application. After playing a while flinging back and forth I'm getting OutOfMemoryError. The strange thing is that I don't hold any static references, and I've searched for possible memory leaks I can assure that I've not found one so far. Anyway, 20 images (PNG of 100KB on average) doesn't be like that much. And I've implemented a view cache, SoftReference holders for the bitmaps, etc. Is it 20 PNG images of 100KB on average enough to kill my app?? seriously? how can I get rid of this? I've followed this great post also http://blog.jteam.nl/2009/09/17/exploring-the-world-of-android-part-2/ Any more ideas? This is the ImageCache: public class AsyncImageLoader { private final String TAG = getClass().getSimpleName(); private Context mContext; private HashMap > mImageCache; public AsyncImageLoader(Context context) { mContext = context; mImageCache = new HashMap >(); } public Bitmap loadImage(final String identifier, final String imagePath, final ImageCallback imageCallback) { if (mImageCache.containsKey(imagePath)) { SoftReference softReference = mImageCache.get(imagePath); Bitmap bitmap = softReference.get(); if (bitmap != null) { Log.i(TAG, "Retrieving image from cache: " + imagePath); return bitmap; } } final Handler handler = new Handler() { @Override public void handleMessage(Message message) { imageCallback.imageLoaded((Bitmap) message.obj, imagePath, identifier); } }; new Thread() { @Override public void run() { Bitmap bitmap = loadImageFromPath(imagePath); mImageCache.put(imagePath, new SoftReference (bitmap)); Message message = handler.obtainMessage(0, bitmap); handler.sendMessage(message); } }.start(); return null; } public Bitmap loadImageFromPath(String path) { if(!GeneralUtilities.isEmpty(path)) { Log.i(TAG, "Loading image: " + path); InputStream imageInputStream = null; try { final AssetManager assetManager = mContext.getResources().getAssets(); imageInputStream = assetManager.open(path); Bitmap bitmap = GeneralUtilities.decodeFile(imageInputStream); imageInputStream.close(); return bitmap; } catch (final IOException e) { Log.e(TAG, e.getMessage()); } } return null; } public interface ImageCallback { public void imageLoaded(Bitmap imageBitmap, String imagePath, String identifier); } } and the method GeneralUtilities.decodeFile is: public static Bitmap decodeFile(InputStream is){ //Decode image size BitmapFactory.Options o = new BitmapFactory.Options(); o.inJustDecodeBounds = true; BitmapFactory.decodeStream(is, null, o); //The new size we want to scale to final int REQUIRED_SIZE=140; //Find the correct scale value. It should be the power of 2. int width_tmp = o.outWidth, height_tmp = o.outHeight; int scale = 1; while(true) { if(width_tmp / 2 And in the getView of the ArrayAdapter I've something like this: final ImageView itemImage = cache.getHistoryImage(); //final ImageView itemFrame = cache.getFrame(); String filename = item.getFilename().trim(); itemImage.setTag("front_" + filename); Bitmap cachedImage = mAsyncImageLoader.loadImage("front_" + filename, filename, new ImageCallback() { public void imageLoaded(Bitmap imageBitmap, String imagePath, String identifier) { ImageView imageViewByTag = (ImageView) mGallery.findViewWithTag(identifier); if (imageViewByTag != null) { imageViewByTag.setImageBitmap(imageBitmap); } } }); itemImage.setImageBitmap(cachedImage);
