[site]: crossvalidated
[post_id]: 628759
[parent_id]: 
[tags]: 
How to detect moments of state change in boolean time series?

Let $A = (X_1, ... X_n)$ be a series consisting of long periods of ones interrupted with shorter periods of zeros, like $$A = 111111111 00000001111111111100000011111111111111.$$ The plot below (left) shows this kind of data but with larger number of points. Plot on the right shows the same data but the pattern is slightly disrupted (for example due to defect of device used to collect the data) $$A_d = 11101111100000001111111011100001011111111111111.$$ Code used to generate the plotted data: import numpy as np lengths = [80, 40, 100, 40, 100] data = np.array([]) for i,l in enumerate(lengths): if i % 2 == 0: data = np.append(data, np.array([1] * l)) else: data = np.append(data, np.array([0] * l)) bad_ones = list(range(99,105)) + [115,117] + [230, 232, 250] bad_zeros = [40,43, 300,301, 310] data_with_errors = data.copy() data_with_errors[bad_ones] = 1 data_with_errors[bad_zeros] = 0 My questions are: Given a smooth pattern array data what is the most efficient way to detect times of change in state? In our example this algorithm should return array [ 80 120 220 260] (red points). The same problem but for data_with_errors (for plot on the right should still return [ 80 120 220 260] ). My solution to problem 1 (I don't know if it can be optimized): diffs = np.diff(data) np.where(diffs != 0)[0] + 1 # plus 1 because we want to know the index of the first element of the new pattern not last of the current pattern I don't know what to do about problem 2 - my guess is that I should somehow smooth the disrupted pattern first, but right now I don't know how to smooth this kind of data and even how to properly google it.
