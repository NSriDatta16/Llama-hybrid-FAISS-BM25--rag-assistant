[site]: crossvalidated
[post_id]: 25414
[parent_id]: 25385
[tags]: 
You have to combine, or rather to stack, the historic data and the actual data. In Stata, this can be done via the append command. Then you have to use the logit and regress commands to estimate the models. In a last step, you have use predict to obtain the out-of-sample predictions for the outcome variable. In the case of a logit model, predict gives you the predicted probability of observing an outcome, given a set of values for the covariates. Note that your understanding of the predict command is not quite correct. What you describe rather corresponds to the margins command. Example I use a dataset from William Greene's Econometric Analysis textbook , availabe on the web: clear infile obs gpa tuce psi grade /// using "http://people.stern.nyu.edu/wgreene/Text/Edition7/TableF14-1.txt" I want to predict the probability of a grade increase. For the sake of illusration I assume that the first 20 observations of the dataset are the historical data, and that the remaining 12 observations are the ones for which you want to have a prediction. Hence, I set observations 21 to 32 missing. replace grade = . if _n > 20 I estimate a logistic regression model that predicts the probability of a grade increase (grade = 1) as a function of the gpa and tuce scores. logit grade gpa tuce Note that I have used the logit rather than the logistic command, because I want to resue the coefficient in a moment. Now I can compute the predicted probabilities, for all the observations. predict phat1, p To understand, or to be sure of what predict does, I compute the following. local X "_b[_cons] + _b[gpa]*gpa + _b[tuce]*tuce" generate phat2 = exp(`X') /(1 + exp(`X')) I could have direclty used Stata's invlogit function: generate phat3 = invlogit(`X') All the three methods yield the same results. summarize phat1 phat2 phat3 With a continuous outcome and the regress command, the principle is the same. Here is an illustration. replace gpa = . if _n > 20 regress gpa tuce psi predict xbhat1, xb gen xbhat2 = _b[_cons] + _b[tuce] * tuce + _b[psi] * psi summarize xbhat1 xbhat2
