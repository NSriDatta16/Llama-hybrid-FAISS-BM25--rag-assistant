[site]: stackoverflow
[post_id]: 3125660
[parent_id]: 3125552
[tags]: 
Not quite. The file comes in big-endian mode because it has streamed packets accumulated. I have to reverse the length of the packets in order to "reinterpret_cast" them into the right variable type. You need to reverse the bytes on the level of stored data, not the file and not the packets. For example, if a file stores a struct. struct S { int i; double d; char c; }; to read the struct you will need to reverse: int: [4321]->[1234] // sizeof(int) == 4, swap the order of 4 bytes double: [87654321]->[12345678] // sizeof(double) == 8, swap the order of 8 bytes char: [1]->[1] // sizeof(char) == 1, swap 1 byte (no swapping needed) Not the entire struct at once. Unfortunately, it's not as trivial as just reversing the block of data in the file, or the file itself. You need to know exactly what data type is being stored, and reverse the bytes in it. The functions in inet.h are used for exactly this purpose, so I encourage you to use them. So, that brings us to c strings. If you're storing c strings in a file, do you need to swap their endianness? Well, a c string is a sequence of 1 byte char s. You don't need to swap 1 byte char s, so you don't need to swap the data in a c string! If you really want to swap 6 bytes, you can use the std::reverse function: char in[6] = get6bytes(); cout If you're doing this on any large scale (a large amount of types), then you may want to consider writing a code generator that generates these byte swapping functions (and file reading functions), it's not too hard, as long as you can find a tool to parse the structs in c (I've used gcc-xml for this, or maybe clang would help). This makes serialization a harder problem. If it's in your power, you may want to consider using XML or Google's protocol buffers to solve these problems for you.
