[site]: stackoverflow
[post_id]: 5320466
[parent_id]: 5320449
[tags]: 
The question is not relevant: there's no preferred way, those just do different things. C++ both has value and reference semantics. When a function asks for a value , it means you'll pass it a copy of your whole object. When it asks for a reference (or a pointer), you'll only pass it the memory address of that object. Both semantics are convertible, that is, if you get a value, you can get a reference or a pointer to it and then use it, and when you get a reference you can get its value and use it. Take this example: void foo(int bar) { bar = 4; } void foo(int* bar) { *bar = 4; } void test() { int someNumber = 3; foo(someNumber); // calls foo(int) std::cout It is a very, very common thing to create a reference to a value (i.e. get the pointer of a value), because references are very useful, especially for complex types, where passing a reference notably avoids a possibly costly copy operation. Now, the instantiation way you'll use depends on what you want to achieve. The first way you've shown uses automatic storage; the second uses the heap. The main difference is that objects on automatic storage are destroyed with the scope in which they existed (a scope being roughly defined as a pair of matching curly braces). This means that you must not ever return a reference to an object allocated on automatic storage from a regular function, because by the time your function returns, the object will have been destroyed and its memory space may be reused for anything at any later point by your program. (There are also performance benefits for objects allocated on automatic storage because your OS doesn't have to look up a place where it might put your new object.) Objects on the heap, on the other hand, continue to exist until they are explicitly deleted by a delete statement. There is an OS- and platform-dependant performance overhead to this, since your OS needs to look up your program's memory to find a large enough unoccupied place to create your object at. Since C++ is not garbage-collected, you must instruct your program when it is the time to delete an object on the heap. Failure to do so leads to leaks: objects on the heap that are no longer referenced by any variable, but were not explicitly deleted and therefore will exist until your program exits. So it's a matter of tradeoff. Either you accept that your values can't outlive your functions, or you accept that you must explicitly delete it yourself at some point. Other than that, both ways of allocating objects are valid and work as expected. For further reference, automatic storage means that the object is allocated wherever its parent scope was. For instance, if you have a class Foo that contains a std::string , the std::string will exist wherever you allocate your Foo object. class Foo { public: // in this context, automatic storage refers to wherever Foo will be allocated std::string a; }; int foo() { // in this context, automatic storage refers to your program's stack Foo bar; // 'bar' is on the stack, so 'a' is on the stack Foo* baz = new Foo; // 'baz' is on the heap, so 'a' is on the heap too // but still, in both cases 'a' will be deleted once the holding object // is destroyed } As stated above, you cannot directly leak objects that reside on automatic storage, but you cannot use them once the scope in which they were created is destroyed. For instance: int* foo() { int a; // cannot be leaked: automatically managed by the function scope return &a; // BAD: a doesn't exist anymore } int* foo() { int* a = new int; // can be leaked return a; // NOT AS BAD: now the pointer points to somewhere valid, // but you eventually need to call `delete a` to release the memory }
