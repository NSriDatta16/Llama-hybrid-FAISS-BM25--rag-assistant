[site]: stackoverflow
[post_id]: 2861416
[parent_id]: 2860626
[tags]: 
Things you could do in C with void, but can't in C++ : void*'s are automatically converted to other pointer types. (You know its a void* - you gain no type safety from forcing an explicit cast) Struct* p = malloc( sizeof(Struct) ); // vs C++ Struct* p = (Struct*)malloc( sizeof(Struct) ); // Some will argue that that cast style is deprecated too, and c++ programmers // need to actually do this: Struct* p = reinterpret_cast malloc( sizeof(Struct) ); // See what C++ did there? By making you write Struct a 3rd time, you can now be sure // you know what you are doing! void*'s also did indirection counting in C, allowing greater safety when passing pointers to functions that take a pointer to a pointer. void funcInitializingOutPtr( void** ppOut) { *ppOut = malloc( x ); } int* out = NULL; funcInitializingPtr(out); // C would signal this as an error funcInitializingPtr(&out); // correct // vs C++ funcInitializingPtr( (void**)&out ); // so much safer needing that exlicit cast. funcInitializingPtr( (void**)out); // oops. thanks C++ for hiding the common error
