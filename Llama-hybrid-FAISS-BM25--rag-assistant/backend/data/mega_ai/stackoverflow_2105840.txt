[site]: stackoverflow
[post_id]: 2105840
[parent_id]: 2024933
[tags]: 
The rule is that any non-volatile, non-static local variable in the stack frame calling setjmp might be clobbered by a call to longjmp. The easiest way to deal with it is to ensure that the frame you call setjmp doesn't contain any such variables you care about. This can usually be done by putting the setjmp into a function by itself and passing in references to things that have been declared in another function that doesn't call setjmp: #include #include int wrap_libcall(std::vector &foo) { jmp_buf env; // no other local vars if (setjmp(env)) return 1; // do stuff with your library that might call longjmp return 0; } int main(int argc, char**) { std::vector foo(argc); return wrap_libcall(foo); } Note also that in this context, clobbering really just means resetting to the value it had when setjmp was called. So if longjmp can never be called after a modification of a local, you're ok too. Edit The exact quote from the C99 spec on setjmp is: All accessible objects have values, and all other components of the abstract machine have state, as of the time the longjmp function was called, except that the values of objects of automatic storage duration that are local to the function containing the invocation of the corresponding setjmp macro that do not have volatile-qualified type and have been changed between the setjmp invocation and longjmp call are indeterminate.
