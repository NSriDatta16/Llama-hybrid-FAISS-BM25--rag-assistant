[site]: stackoverflow
[post_id]: 3682731
[parent_id]: 3676954
[tags]: 
I use the following snippet to fill and un-fill paragraphs (using only M-q ), it is really, really handy. I borrowed it from Xah Lee, but removed some comments and whitespace in order to make it fit in here. The link in the first comment goes to his original code. ;; http://xahlee.org/emacs/modernization_fill-paragraph.html (defun compact-uncompact-block () "Remove or add line endings on the current block of text. This is similar to a toggle for fill-paragraph and unfill-paragraph When there is a text selection, act on the region. When in text mode, a paragraph is considered a block. When in programing language mode, the block defined by between empty lines. Todo: The programing language behavior is currently not done. Right now, the code uses fill* functions, so does not work or work well in programing lang modes. A proper implementation to compact is replacing newline chars by space when the newline char is not inside string. " (interactive) (let (bds currentLineCharCount currentStateIsCompact (bigFillColumnVal 4333999) (deactivate-mark nil)) (save-excursion (setq currentLineCharCount (progn (setq bds (bounds-of-thing-at-point 'line)) (length (buffer-substring-no-properties (car bds) (cdr bds))))) (setq currentStateIsCompact (if (eq last-command this-command) (get this-command 'stateIsCompact-p) (if (> currentLineCharCount fill-column) t nil))) (if (and transient-mark-mode mark-active) (if currentStateIsCompact (fill-region (region-beginning) (region-end)) (let ((fill-column bigFillColumnVal)) (fill-region (region-beginning) (region-end))) ) (if currentStateIsCompact (fill-paragraph nil) (let ((fill-column bigFillColumnVal)) (fill-paragraph nil)))) (put this-command 'stateIsCompact-p (if currentStateIsCompact nil t))))) (global-set-key (kbd "M-q") 'compact-uncompact-block)
