[site]: stackoverflow
[post_id]: 96783
[parent_id]: 92546
[tags]: 
To answer the question, "does the static mean only one copy of VAL is created, in case the header is included by more than one source file?"... NO . VAL will always be defined separately in every file that includes the header. The standards for C and C++ do cause a difference in this case. In C, file-scoped variables are extern by default. If you're using C, VAL is static and ANOTHER_VAL is extern. Note that Modern linkers may complain about ANOTHER_VAL if the header is included in different files (same global name defined twice), and would definitely complain if ANOTHER_VAL was initialised to a different value in another file In C++, file-scoped variables are static by default if they are const, and extern by default if they are not. If you're using C++, both VAL and ANOTHER_VAL are static. You also need to take account of the fact that both variables are designated const. Ideally the compiler would always choose to inline these variables and not include any storage for them. There is a whole host of reasons why storage can be allocated. Ones I can think of... debug options address taken in the file compiler always allocates storage (complex const types can't easily be inlined, so becomes a special case for basic types)
