[site]: stackoverflow
[post_id]: 4017799
[parent_id]: 4017437
[tags]: 
There might be possibility that you can reduce lock contention (thus improving through-put) by using "lock-striping" -- essentially, split one lock into several ones, each lock protecting particular group of users. The tricky part is how to figure out how to assign users to groups. The simplest case is when you can assign request from any user to any group. If your data model requires that requests from one user must be processed sequentially, you must introduce some mapping between user requests and groups. Here's sample implementation of StripedLock: import java.util.concurrent.locks.ReentrantLock; /** * Striped locks holder, contains array of {@link java.util.concurrent.locks.ReentrantLock}, on which lock/unlock * operations are performed. Purpose of this is to decrease lock contention. * When client requests lock, it gives an integer argument, from which target lock is derived as follows: * index of lock in array equals to id & (locks.length - 1) . * Since locks.length is the power of 2, locks.length - 1 is string of '1' bits, * and this means that all lower bits of argument are taken into account. * Number of locks it can hold is bounded: it can be from set {2, 4, 8, 16, 32, 64}. */ public class StripedLock { private final ReentrantLock[] locks; /** * Default ctor, creates 16 locks */ public StripedLock() { this(4); } /** * Creates array of locks, size of array may be any from set {2, 4, 8, 16, 32, 64} * @param storagePower size of array will be equal to Math.pow(2, storagePower) */ public StripedLock(int storagePower) { if (storagePower 6) throw new IllegalArgumentException("storage power must be in [1..6]"); int lockSize = (int) Math.pow(2, storagePower); locks = new ReentrantLock[lockSize]; for (int i = 0; i
