[site]: stackoverflow
[post_id]: 4202443
[parent_id]: 4202382
[tags]: 
ELAPSED_TIME is the accumulated time for all the times that SQL statement has been run. So it will be high for frequently executed queries. Consider this a snappy query (the HINT-style comment is for the purposes of getting the SQL_ID in V$SQLAREA): select /*+ fast_running_query */ id from big_table where id = 1 / How long does it take to run? This long: SQL> select elapsed_time 2 , executions 3 , elapsed_time / executions as avg_ela_time 4 from v$sqlarea 5 where sql_id = '73c1zqkpp23f0' 6 / ELAPSED_TIME EXECUTIONS AVG_ELA_TIME ------------ ---------- ------------ 235774 1 235774 SQL> That's a relatively large chunk o' microsecs, because of the parse time. We can see that running it a couple more times doesn't add much to the elapsed time, and the average is much lower: SQL> r 1 select elapsed_time, 2 executions, 3 elapsed_time / executions as avg_ela_time 4 from v$sqlarea 5* where sql_id = '5v4nm7jtq3p2n' ELAPSED_TIME EXECUTIONS AVG_ELA_TIME ------------ ---------- ------------ 237570 3 79190 SQL> And after running it another 100000 times ... SQL> r 1 select elapsed_time, 2 executions, 3 elapsed_time / executions as avg_ela_time 4 from v$sqlarea 5* where sql_id = '5v4nm7jtq3p2n' ELAPSED_TIME EXECUTIONS AVG_ELA_TIME ------------ ---------- ------------ 1673900 100003 14.3809724 SQL> Now, what you wantt is to find active sessions which have been doing something continuously for more than five seconds. So you need session-level timings, and in particular the LAST_CALL_ET on V$SESSION, which is the number of seconds the session has been doing something (if its status is ACTIVE) or the total elapsed time since its last action (if its status is INACTIVE). select sid , serial# , sql_address , last_call_et from v$session where status = 'ACTIVE' and last_call_et > sysdate - (sysdate-(5/86400)) / So, consider this query. It's slow: SQL> select /*+ slow_running_query */ * 2 from big_table 3 where col2 like '%whatever%' 4 / no rows selected Elapsed: 00:00:07.56 SQL> That's long enough to monitor using a query on V$SESSION. This one searches for statements which have been running for more than 3 seconds... SQL> select sid 2 , serial# 3 , sql_id 4 , last_call_et 5 from v$session 6 where status = 'ACTIVE' 7 and last_call_et > sysdate - (sysdate - (3/86400)) 8 and username is not null 9 / SID SERIAL# SQL_ID LAST_CALL_ET ---------- ---------- ------------- ------------ 137 7 096rr4hppg636 4 170 5 ap3xdndsa05tg 7 SQL> and lo! SQL> select sql_text from v$sqlarea where sql_id = 'ap3xdndsa05tg' 2 / SQL_TEXT -------------------------------------------------------------------------------- select /*+ slow_running_query */ * from big_table where col2 like '%whatever%' SQL> "it should give me the list of queries which are currently executing or have recently finished executing and I can find the total time the query took to complete" The LAST_ACTIVE_TIME on the V$SQLAREA view records the most recent time the statement was executed. However, there is no view which exposes the metrics for each individual execution of the statement. If you want that sort of detail you will need to start tracing. And that is a separate question.
