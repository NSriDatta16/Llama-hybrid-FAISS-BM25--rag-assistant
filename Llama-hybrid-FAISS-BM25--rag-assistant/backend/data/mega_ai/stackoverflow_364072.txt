[site]: stackoverflow
[post_id]: 364072
[parent_id]: 44965
[tags]: 
I've been thinking of Monads in a different way, lately. I've been thinking of them as abstracting out execution order in a mathematical way, which makes new kinds of polymorphism possible. If you're using an imperative language, and you write some expressions in order, the code ALWAYS runs exactly in that order. And in the simple case, when you use a monad, it feels the same -- you define a list of expressions that happen in order. Except that, depending on which monad you use, your code might run in order (like in IO monad), in parallel over several items at once (like in the List monad), it might halt partway through (like in the Maybe monad), it might pause partway through to be resumed later (like in a Resumption monad), it might rewind and start from the beginning (like in a Transaction monad), or it might rewind partway to try other options (like in a Logic monad). And because monads are polymorphic, it's possible to run the same code in different monads, depending on your needs. Plus, in some cases, it's possible to combine monads together (with monad transformers) to get multiple features at the same time.
