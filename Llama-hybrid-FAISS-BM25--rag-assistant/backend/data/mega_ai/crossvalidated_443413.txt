[site]: crossvalidated
[post_id]: 443413
[parent_id]: 443096
[tags]: 
The Bayesian options mentioned in the comment thread appropriately treat the outcome as if it were drawn from a beta distribution, but because the beta distribution restricts values to be between >0 & zoib and brms allow you to model the inflation you have at 1. They do so by estimating a separate model for the range >0 & Beta regression of proportion data including 1 and 0 . Below is code that I used on your data to transform and run the model. Note that I re-scaled your predictors manually and that with listener only having 3 categories in the sample data, glmmTMB had problems with a singular fit. First transform intelligibility using Smithson & Verkulien (2006) formulation 1 - (y * (nâˆ’1) + 0.5) / n data $intel_t intelligibility * (length(data)-1)) + 0.5) / length(data) Next, I used glmmTMB() with family=beta_familiy() require(glmmTMB) fm_b1 This resulted in the following model results, note the "fixed effects" for listener: Family: beta ( logit ) Formula: intel_t ~ comp_c + accent_c + listener + (1 | participant) Data: data AIC BIC logLik deviance df.resid -237.7 -219.5 125.9 -251.7 93 Random effects: Conditional model: Groups Name Variance Std.Dev. participant (Intercept) 0.005701 0.0755 Number of obs: 100, groups: participant, 19 Overdispersion parameter for beta family (): 18.9 Conditional model: Estimate Std. Error z value Pr(>|z|) (Intercept) 1.74746 0.11807 14.801 Regression coefficients from models with a beta family link are somewhat tricky to interpret. To aid interpretation I used ggeffects for comp_c: require(ggeffects) ggpredict(fm_b1, "comp_c") %>% plot() And then also for accent_c: ggpredict(fm_b1, "accent_c") %>% plot() The question of residuals is a bit more complicated . I used DHARMa() to look at residuals, but it is not fully integrated with glmmTMB. Of note is that the qqplot does not display the same problematic pattern you saw in your lmer model: library(DHARMa) res = simulateResiduals(fm_b1) plot(res, rank=T) As a last note, you can also estimate this same model with GLMMadaptive and you could play with the beta.hurdle.fam() as suggested in the comments.
