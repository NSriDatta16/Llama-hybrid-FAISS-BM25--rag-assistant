[site]: stackoverflow
[post_id]: 2879483
[parent_id]: 2879274
[tags]: 
This may seem like overkill, but seeing that your files aren't very large, I'm tempted to leverage the following one-liner (either from the command line or via a system call). The one-liner works by slurping all the lines in one shot, then leaving the rest of the work to a regex substitution which flips the order of the lines. If you're using *nix: perl -0777 -i -ne 's/(TITLE.*?")\n(PERFORMER.*?")/$2\n$1/g' file1 file2 .. If you're using Windows, you'll need to create a backup of the existing files: perl -0777 -i.bak -ne "s/(TITLE.*?\")\n(PERFORMER.*?\")/$2\n$1/g" file1 file2 .. Explanation Command Switches (see perlrun for more info) -0777 (an octal number) enforces file-slurping behavior -i enables in-place editing (no need to splice -'n'-dice!). Windows systems require that you provide a backup extension, hence the additional .bak -n loops over all lines in your file(s) (although since you're slurping them in, Perl treats the contents of each file as one line) -e allows Perl to recognize code within the command-line Regex The substitution regex captures all occurrences of the TITLE line, the consecutive PERFORMER line, and stores it in variables $1 and $2 respectively. The substitution regex then flips the order of the two variables, separated with a newline. Filename Arguments You could use *nix to provide the filenames of the directories in question, but I'll leave that to someone else to figure out as I'm not too comfortable with Unix pipes just yet (see this John Siracusa answer for more guidance). I would create a backup of your files before you try these one-liners though.
