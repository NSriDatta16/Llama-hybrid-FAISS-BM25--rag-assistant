[site]: stackoverflow
[post_id]: 4752947
[parent_id]: 4752315
[tags]: 
The C standard doesn't have very hard rules for what you're trying to do. Here's the paragraph in question, from Section 6.3.1 Arithmetic operands (specifically Section 6.3.1.4 Real floating and integer ): When a finite value of real floating type is converted to an integer type other than _Bool , the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined. There's even a more specific footnote about the exact case you're asking about: The remaindering operation performed when a value of integer type is converted to unsigned type need not be performed when a value of real floating type is converted to unsigned type. Thus, the range of portable real floating values is (âˆ’1, Utype_MAX+1) . UtypeMAX+1 for your case is 256 . Your mismatched cases are all negative numbers. After the truncation, they're still negative and are outside the range (-1, 256), so they're firmly in the 'undefined behaviour' zone. Even some of the matching cases you've shown, where the floating point number is greater than or equal to 256 , aren't guaranteed to work - you're just getting lucky. The answers to your numbered questions, therefore: Yes, you were wrong. It's a compiler issue in the sense that your different compilers give different results, but since they're allowed to by the spec, I wouldn't really call that the compiler's fault. It depends on what you want to do - if you can explain that better, someone on SO community is almost certain to be able to help you out.
