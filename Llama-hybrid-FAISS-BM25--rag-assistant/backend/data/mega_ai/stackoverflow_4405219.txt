[site]: stackoverflow
[post_id]: 4405219
[parent_id]: 4403906
[tags]: 
It's possible to get what you're after, but it's not simple. The problem is that without an explicit type parameter, the compiler can only infer that T is Nothing . In that case, you want find to return something of type Node , not of type T (i.e. Nothing ), but in every other case you want find to return something of type T . When you want your return type to vary based on a type parameter, you can use a technique similar to the one I used in my method lifting API . object Finder { def find[T Here, the find method returns a polymorphic functor that, when applied to a name, will return an object of either type T or of type Node depending on the value of the ReturnAs argument supplied by the compiler. If T is Nothing , the compiler will supply the returnNothingAsNode object and the apply method will return a Node . Otherwise, the compiler will supply a ReturnAs[T, T] , and the apply method will return a T . Riffing off of Paul's solution on the mailing list, another possibility is to provide an implicit for each type that "works". Instead of returning a Node when the type parameter is omitted, a compile error will be issued: object Finder { def find[T : IsOk](name: String): T = doFind(name).asInstanceOf[T] class IsOk[T] object IsOk { implicit object personIsOk extends IsOk[Person] implicit object nodeIsOk extends IsOk[Node] } } Of course, this solution does not scale well.
