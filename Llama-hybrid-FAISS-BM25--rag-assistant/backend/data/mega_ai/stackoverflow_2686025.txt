[site]: stackoverflow
[post_id]: 2686025
[parent_id]: 2685391
[tags]: 
The accepted answer, whilst an elegant piece of code from a programmer's point of view, does not give the best possible price for the customer and therefore might not be an elegant solution from the customer's point of view. For example when n = 4, the accepted answer gives $1196, but a customer would obviously prefer to choose the 5 license pack and pay just $999 instead. It is possible to construct an algorithm which can calculate the minimum price possible that the customer can pay to purchase their required number of licenses. One way of doing this is to use dynamic programming. I think something like this might do the trick: int calculatePrice(int n, Dictionary prices) { int[] best = new int[n + prices.Keys.Max()]; for (int i = 1; i x prices = new Dictionary { { 1, 299 }, { 5, 999 }, { 10, 1899 }, { 20, 3499 }, { 50, 7999 } }; Console.WriteLine(calculatePrice(136, prices)); Console.WriteLine(calculatePrice(4, prices)); } Output: 22694 999 Update Producing a breakdown is a little more complicated, but I definitely think it will be beneficial for your customers. You could do it something like this (assuming printing to the console, although a real program would probably output to a web page): using System; using System.Linq; using System.Collections.Generic; class Program { static Dictionary prices = new Dictionary { { 1, 299 }, { 5, 999 }, { 10, 1899 }, { 20, 3499 }, { 50, 7999 } }; class Bundle { public int Price; public Dictionary Licenses; } Bundle getBestBundle(int n, Dictionary prices) { Bundle[] best = new Bundle[n + prices.Keys.Max()]; best[0] = new Bundle { Price = 0, Licenses = new Dictionary () }; for (int i = 1; i x (best[i - amount].Licenses) }; int count = 0; bundle.Licenses.TryGetValue(amount, out count); bundle.Licenses[amount] = count + 1; if (best[i] == null || best[i].Price > bundle.Price) { best[i] = bundle; } } } return best.Skip(n).OrderBy(x => x.Price).First(); } void printBreakdown(Bundle bundle) { foreach (var kvp in bundle.Licenses) { Console.WriteLine("{0,2} * {1,2} {2,-5} @ ${3,4} = ${4,6}", kvp.Value, kvp.Key, kvp.Key == 1 ? "user" : "users", prices[kvp.Key], kvp.Value * prices[kvp.Key]); } int totalUsers = bundle.Licenses.Sum(kvp => kvp.Key * kvp.Value); Console.WriteLine("-------------------------------"); Console.WriteLine("{0,7} {1,-5} ${2,6}", totalUsers, totalUsers == 1 ? "user" : "users", bundle.Price); } void Run() { Console.WriteLine("n = 136"); Console.WriteLine(); printBreakdown(getBestBundle(136, prices)); Console.WriteLine(); Console.WriteLine(); Console.WriteLine("n = 4"); Console.WriteLine(); printBreakdown(getBestBundle(4, prices)); } static void Main(string[] args) { new Program().Run(); } } Output: n = 136 2 * 50 users @ $7999 = $ 15998 1 * 20 users @ $3499 = $ 3499 1 * 10 users @ $1899 = $ 1899 1 * 5 users @ $ 999 = $ 999 1 * 1 user @ $ 299 = $ 299 ------------------------------- 136 users $ 22694 n = 4 1 * 5 users @ $ 999 = $ 999 ------------------------------- 5 users $ 999
