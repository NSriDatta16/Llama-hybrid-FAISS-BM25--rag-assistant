[site]: crossvalidated
[post_id]: 220281
[parent_id]: 
[tags]: 
Diebold - Mariano test for volatility forecasts problem

I am using packages {rugarch} for forecasting and {forecast} for Diebold - Mariano test. As a first step, I am specifying the first AR-GARCH model for financial time series (AAPL Nasdaq) using ugarchspec{rugarch} spec1 Then I fit it using ugarchfit{rugarch} modelfit1=ugarchfit(spec1, data=AAPL_returns, out.sample = 200) modelfit1 Then I forecast it using ugarchforecast{rugarch} modelfor1=ugarchforecast(modelfit1, n.ahead = 1, n.roll = 200, out.sample = 200) This is my first forecast to be compared in Diebold-Mariano test. The other forecast is very similar to the first one but the AR-GARCH model is enhanced by the external regressor, which is data (GGL) from Google Trends on "AAPL" keyword: spec2 Then I fit it: modelfit2=ugarchfit(spec2, data=AAPL_returns, out.sample = 200) modelfit2 And I forecast it: modelfor2=ugarchforecast(modelfit2, n.ahead = 1, n.roll = 200, out.sample = 200) So I am ending up with two formal class uGARCHforecasts - modelfor1, modelfor2 Now comes the problematic part. As Diebold-Mariano dm.test{forecast} is working with forecasting errors, I need to save them from my previous forecast which I have done this way: e1 The dm.test runs without problem, however the accuracy(e1) is unable to provide information on summary measures of the forecast accuracy, since it returns Error in accuracy(e1) : Unable to compute forecast accuracy measures I would like to raise two questions: 1) Is this model as a whole well specified, does it capture a legit comparison of two well specified forecast? 2) What is the problem with inability to return accuracy measures in accuracy(e1) ? Edit: I suggest a second model which works with squared residuals as a proxy to forecast in-sample volatility: modelsigma1 = as.data.frame(modelfit1@fit$sigma) modelsigma2 = as.data.frame(modelfit2@fit$sigma) ret.sq = AAPL_returns^2 modelsigma1.sq = modelsigma1^2 modelsigma2.sq = modelsigma2^2 dm.test((ret.sq - modelsigma1.sq), (ret.sq - modelsigma2.sq), alternative = c("two.sided"), h = 1, power = 1)
