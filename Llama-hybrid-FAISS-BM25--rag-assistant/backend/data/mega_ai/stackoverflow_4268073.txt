[site]: stackoverflow
[post_id]: 4268073
[parent_id]: 4267098
[tags]: 
IAR is right, registers are not RAM. :) It is possibly best to look how to suppress warnings looking inside examples coming with IAR (if there any). There mey be IAR's custom keyword or pragma, thich tells compiler how you're intended to do. It may also be issue in memory map, as there may need to define register region somehow. I'm working with GCC and ARM, and it does not complain on any method to access registers. I used: direct and calculated address ( *((volatile unsigned int *)0xNNNNNNNNU) |= 1 ); arrays, structs, unions and bitfields by direct address (through it is dangerous, but it makes code looking so nice); symbols defined in map file with all above (this may be mostly C compliant because of dealing with linker, not compiler). There is proposed new extension pretending to be a standard I found recently, called TR 18037: Embedded C . Section "6 BASIC I/O HARDWARE ADDRESSING" give common method to access hardware (cite from pdf): #include #include "iodriv_hw.h" /* Platform-specific designator definitions. */ // Wait until controller is no longer busy. while (iord(dev_status) & STATUS_BUSY) /* do nothing */; // Write value to controller. iowr(dev_out, ch); There are also ioand , ioor function[ like macro]s and many others. Example implementation for iohw.h is also there so you may add support for this to IAR on your own.
