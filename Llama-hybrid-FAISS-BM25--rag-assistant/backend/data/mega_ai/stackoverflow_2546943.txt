[site]: stackoverflow
[post_id]: 2546943
[parent_id]: 2545482
[tags]: 
This may be faster. You can leverage Regex Groups like this: public List Keyword_Search(HtmlNode nSearch) { var wordFound = new List (); // cache inner HTML string innerHtml = nSearch.InnerHtml; string pattern = "(\\b" + string.Join("\\b)|(\\b", _keywordList) + "\\b)"; Regex myRegex = new Regex(pattern, RegexOptions.IgnoreCase); MatchCollection myMatches = myRegex.Matches(innerHtml); foreach (Match myMatch in myMatches) { // Group 0 represents the entire match so we skip that one for (int i = 1; i This way you're only using one regular expression. And the indices of the Groups should correlate with your _keywordList by an offset of 1, hence the line wordFound.Add(_keywordList[i-1]); UPDATE: After looking at my code again I just realized that putting the matches into Groups is really unnecessary. And Regex Groups have some overhead. Instead, you could remove the parenthesis from the pattern, and then simply add the matches themselves to the wordFound list. This would produce the same effect, but it'd be faster. It'd be something like this: public List Keyword_Search(HtmlNode nSearch) { var wordFound = new List (); // cache inner HTML string innerHtml = nSearch.InnerHtml; string pattern = "\\b(?:" + string.Join("|", _keywordList) + ")\\b"; Regex myRegex = new Regex(pattern, RegexOptions.IgnoreCase); MatchCollection myMatches = myRegex.Matches(innerHtml); foreach (Match myMatch in myMatches) { wordFound.Add(myMatch.Value); } return wordFound; }
