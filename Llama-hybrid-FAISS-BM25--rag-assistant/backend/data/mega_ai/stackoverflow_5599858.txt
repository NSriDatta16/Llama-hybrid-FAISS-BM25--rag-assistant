[site]: stackoverflow
[post_id]: 5599858
[parent_id]: 5598556
[tags]: 
Your problem is that you are reusing the entry array. Look at how for all i we have fragments[i++] = entry; . In the end, every fragment will be pointing to the same place and thus will contain the same string (in this case, it will be the last string read). It seems as if you tried to work around this by using both a temp and an entry array, but in the end you might just as well have made the fscanf write directly to the entry array. Another problem that you can get is if your pointers point to an array that was automaticaly allocated on the stack (ie.: an array declared inside a function). These memory locations are reused by your program after your function returns, your pointers can start pointing to invalid data (and since this is C, using these corrupted strings can lead to all sorts of crashes and bad program behaviour). You problem is basically a memory allocation issue, so there are many solutions. Make fragments be an array of character arrays (instead of only pointers). This way you safely have a different piece of memory for each string. char fragments[2000][20]; //can hold 2000 19-character strings for(i=0; i The advantage for this solution is that it is simple, and that all memory is allocated beforehand. Use dynamic memory allocation with malloc . This allows you to choose a different size of array for each string and also allows you to choose the size of your arrays at run time instead of compile time. char* fragments[2000]; char entry[MAX_FRAGMENT_LENGTH]; //temporary buffer for strings for(i=0; i The main advantage for this method is that it is very flexible, while still being reasonably simple. The main disavantage is that you will need to free all pointers that have been malloc -ed after you are done with them (otherwise you can get a memory leak). Do "dynamic allocation" by hand, using a single large buffer to contain all the strings. char buffer[2000*20]; char* fragments[2000]; char* next_empty_location = buffer; for(i=0; i If you can't/don't want/aren't allowed to use the malloc solution, this is what comes closest. It might be harder to understand (in case you are having issues with C), but is the one that best seems to fit the vague "each char* that holds a string much be the exact length of the string" restriction.
