[site]: stackoverflow
[post_id]: 4330255
[parent_id]: 4329956
[tags]: 
As many have observed, CSV is a harder format than it first appears. There are many edge cases and ambiguities. As an example ambiguity, in your example, is ',,,' a field with a comma or two blank fields? Perl, python, Java, etc are better equipped to deal with CSV because they have well tested libraries for the same. A regex will be more fragile. With AWK, I have had some success with THIS AWK function. It works under AWK, gawk and nawk. #!/usr/bin/awk -f #************************************************************************** # # This file is in the public domain. # # For more information email LoranceStinson+csv@gmail.com. # Or see http://lorance.freeshell.org/csv/ # # Parse a CSV string into an array. # The number of fields found is returned. # In the event of an error a negative value is returned and csverr is set to # the error. See below for the error values. # # Parameters: # string = The string to parse. # csv = The array to parse the fields into. # sep = The field separator character. Normally , # quote = The string quote character. Normally " # escape = The quote escape character. Normally " # newline = Handle embedded newlines. Provide either a newline or the # string to use in place of a newline. If left empty embedded # newlines cause an error. # trim = When true spaces around the separator are removed. # This affects parsing. Without this a space between the # separator and quote result in the quote being ignored. # # These variables are private: # fields = The number of fields found thus far. # pos = Where to pull a field from the string. # strtrim = True when a string is found so we know to remove the quotes. # # Error conditions: # -1 = Unable to read the next line. # -2 = Missing end quote. # -3 = Missing separator. # # Notes: # The code assumes that every field is preceded by a separator, even the # first field. This makes the logic much simpler, but also requires a # separator be prepended to the string before parsing. #************************************************************************** function parse_csv(string,csv,sep,quote,escape,newline,trim, fields,pos,strtrim) { # Make sure there is something to parse. if (length(string) == 0) return 0; string = sep string; # The code below assumes ,FIELD. fields = 0; # The number of fields found thus far. while (length(string) > 0) { # Remove spaces after the separator if requested. if (trim && substr(string, 2, 1) == " ") { if (length(string) == 1) return fields; string = substr(string, 2); continue; } strtrim = 0; # Used to trim quotes off strings. # Handle a quoted field. if (substr(string, 2, 1) == quote) { pos = 2; do { pos++ if (pos != length(string) && substr(string, pos, 1) == escape && (substr(string, pos + 1, 1) == quote || substr(string, pos + 1, 1) == escape)) { # Remove escaped quote characters. string = substr(string, 1, pos - 1) substr(string, pos + 1); } else if (substr(string, pos, 1) == quote) { # Found the end of the string. strtrim = 1; } else if (newline && pos >= length(string)) { # Handle embedded newlines if requested. if (getline == -1) { csverr = "Unable to read the next line."; return -1; } string = string newline $0; } } while (pos %s\n", csverr, num_fields, $0; } else { printf "%s -> \n", $0; printf "%s fields\n", num_fields; for (i = 0;i Running it on your example data produces: "hello, world?",1 thousand,"oneword",,,"last one" -> 6 fields hello, world? 1 thousand oneword last one | An example Perl solution: $ echo '"hello, world?",1 thousand,"oneword",,,"last one"' | perl -lnE 'for(/(?:^|,)("(?:[^"]+|"")*"|[^,]*)/g) { s/"$//; s/""/"/g if (s/^"//); say}'
