[site]: stackoverflow
[post_id]: 871789
[parent_id]: 869744
[tags]: 
Using .NET's integrated Async I/O ( BeginRead , etc.) is a good idea if you can get all the details right. When you properly set up your socket/file handles it will use the OS's underlying IOCP implementation, allowing your operations to complete without using any threads (or, in the worst case, using a thread that I believe comes from the kernel's I/O thread pool instead of .NET's thread pool, which helps alleviate threadpool congestion.) The main gotcha is to make sure that you open your sockets/files in non-blocking mode. Most of the default convenience functions (like File.OpenRead ) don't do this, so you'll need to write your own. One of the other main concerns is error handling - properly handling errors when writing asynchronous I/O code is much, much harder than doing it in synchronous code. It's also very easy to end up with race conditions and deadlocks even though you may not be using threads directly, so you need to be aware of this. If possible, you should try and use a convenience library to ease the process of doing scalable asynchronous I/O. Microsoft's Concurrency Coordination Runtime is one example of a .NET library designed to ease the difficulty of doing this kind of programming. It looks great, but as I haven't used it, I can't comment on how well it would scale. For my personal projects that need to do asynchronous network or disk I/O, I use a set of .NET concurrency / I/O tools that I've built over the past year, called Squared.Task . It's inspired by libraries like imvu.task and twisted , and I've included some working examples in the repository that do network I/O. I also have used it in a few applications I've written - the largest publicly released one being NDexer (which uses it for threadless disk I/O). The library was written based on my experience with imvu.task and has a set of fairly comprehensive unit tests, so I strongly encourage you to try it out. If you have any issues with it, I'd be glad to offer you some assistance. In my opinion, based on my experience using asynchronous/threadless I/O instead of threads is a worthwhile endeavor on the .NET platform, as long as you're ready to deal with the learning curve. It allows you to avoid the scalability hassles imposed by the cost of Thread objects, and in many cases, you can completely avoid the use of locks and mutexes by making careful use of concurrency primitives like futures and promises .
