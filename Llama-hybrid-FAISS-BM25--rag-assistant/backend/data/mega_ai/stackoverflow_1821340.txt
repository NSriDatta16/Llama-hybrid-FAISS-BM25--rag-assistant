[site]: stackoverflow
[post_id]: 1821340
[parent_id]: 1819180
[tags]: 
If you're not sure what you're doing, always start with the most literal translation. The function prototype says it receives a pointer to a pointer to a char, so that's what you should use: type PTR_Allocate = procedure(param1: ^^Char; param2: ^LongWord); cdecl; Once you're sure it's right, then start replacing things with their more Delphi-like equivalents. If you skip this first step, you might never get it right because you'll just keep making changes to something that started out wrong. So, are you sure the above is right? Not quite. Char in Delphi can have different meanings depending on the product version. You're using Delphi 7, but you might upgrade, so you might share this code with someone else, so you should be explicit about what size Char you want. Use AnsiChar when you need a one-byte type. type PTR_Allocate = procedure(param1: ^^AnsiChar; param2: ^LongWord); cdecl; Now we can start making it look more like Delphi. One level of pointer parameter can be replaced with a "var" or "out" directive. Do that to each parameter: type PTR_Allocate = procedure(out param1: ^AnsiChar; var param2: LongWord); cdecl; Pointer-to-AnsiChar is such a common type that Delphi already has a name for it: PAnsiChar. Use the idiomatic name: type PTR_Allocate = procedure(out param1: PAnsiChar; var param2: LongWord); cdecl; And finally, you might wish to take some liberty with the whole notion that there are characters involved at all. You're clearly allocating memory for arbitrary byte buffers, so Byte is probably a better choice than any character type. Recent Delphi versions declare a pointer-to-byte type, so use that: type PTR_Allocate = procedure(out param1: PByte; var param2: LongWord); cdecl; Now on to SetAllocateFunction . It says it receives a PTR_Allocate parameter, which is a pointer to a function. Delphi's procedure types are implicitly pointers, so the type we've declared above is already exactly right for the Delphi equivalent. Don't pass it by reference with an extra "var" directive or you will have the problems you've seen, even before your program attempts to allocate any memory. This is something the other answers have overlooked. procedure SetAllocateFunction(param: PTR_Allocate); cdecl; Don't add an underscore to the start of the name, either, unless you want to make it inconvenient to call in your own code. If it's exported from the DLL using a different name, then use a "name" clause when you write the function's implementation: procedure SetAllocateFunction; extern 'foo.dll' name '_SetAllocateFunction'; Finally, how to implement the allocation function. Start with something that matches the signature for PTR_Allocate, and then go ahead and implement it using as literal a translation as possible from the original C++ code. procedure Allocate(out pbuffer: PByte; var psize: LongWord; cdecl; begin psize := psize * 2; GetMem(pbuffer, psize); end; You can set it with the function from before: SetAllocateFunction(Allocate); Notice I didn't need a separate variable and I haven't used the @ operator. If you need to use the @ operator to mention a function pointer, in most cases, you're doing it wrong. You usually don't need it. Using that operator can hide errors in your program, such as signature mismatches, because the default setting is for the @ operator to be untyped . Using it removes the type from the function pointer, and untyped pointers are compatible with everything in Delphi, so they fit with any other function-pointer type, including the ones with wrong signatures. Only use @ on a function pointer when the compiler has already indicated that it has tried to call the function, such as by mentioning how you don't have enough parameters or by mentioning the function's return type.
