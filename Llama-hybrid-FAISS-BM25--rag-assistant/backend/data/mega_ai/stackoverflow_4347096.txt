[site]: stackoverflow
[post_id]: 4347096
[parent_id]: 4346822
[tags]: 
The sequence never completes because the source (MouseDown) never completes (it is an event). It's worth pointing out that a IObservable cannot call OnComplete of a subscriber more than once, it's part of the contract ( OnNext* (OnCompleted|OnError)? ). To find out when the mouseMove.TakeUntil(mouseUp) sequence completes, you'll need to hook into the call to SelectMany : public static IDisposable TrackDrag(this UIElement element, Action dragging, Action dragComplete) { var mouseDown = Observable.FromEvent(...); var mouseMove = Observable.FromEvent(...); var mouseUp = Observable.FromEvent(...); return (from start in mouseDown from currentPosition in mouseMove.TakeUntil(mouseUp) .Do(_ => {}, () => dragComplete()) select new Rect(Math.Min(start.X, currentPosition.X), Math.Min(start.Y, currentPosition.Y), Math.Abs(start.X - currentPosition.X), Math.Abs(start.Y - currentPosition.Y)); ).Subscribe(dragging); } Then you can use it like so: element.TrackDrag( rect => { }, () => {} ); For the interest of clarity, here is the LINQ expression using the underlying extension methods: return mouseDown.SelectMany(start => { return mouseMove .TakeUntil(mouseUp) .Do(_ => {}, () => dragComplete()) .Select(currentPosition => new Rect(...)); }) .Subscribe(dragging); That is, for each value from mouseDown a new sequence will be subscribed to. When that sequence completes, call dragComplete().
