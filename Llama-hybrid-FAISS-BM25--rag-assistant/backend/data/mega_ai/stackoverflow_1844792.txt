[site]: stackoverflow
[post_id]: 1844792
[parent_id]: 1818533
[tags]: 
This is how I ended up solving this. The article provided by Kevin was a huge help. By using ReflectionClass and ReflectionMethod::getDocComment, I can walk through the phpDoc comments very easily. A small regular expression finds any @route , and is registered to the method. Reflection is not that quick (in our case, about 2,5 times as slow as having hard-coded calls to RegiserRoute in a separate function), and since we have a lot of routes, we had to cache the finished list of routes in Memcached, so reflection is unnecessary on every page load. In total we ended up going from taking 7ms to register the routes to 1,7ms on average when cached (reflection on every page load used 18ms on average. The code to do this, which can be overridden in a subclass if you need manual registration, is as follows: public static function RegisterRoutes() { $sClass = get_called_class(); // unavailable in PHP getMethods() as $rflMethod) { $sComment = $rflMethod->getDocComment(); if (preg_match_all('%^\s*\*\s*@route\s+(?P /?(?:[a-z0-9]+/?)+)\s*$%im', $sComment, $result, PREG_PATTERN_ORDER)) { foreach ($result[1] as $sRoute) { $sMethod = $rflMethod->GetName(); $oRouteManager->RegisterRoute($sRoute, array($sClass, $sMethod)); } } } } Thanks to everyone for pointing me in the right direction, there were lots of good suggestions here! We went with this approach simply because it allows us to keep the route close to the code it invokes: class CSomeRoutable extends CRoutable { /** * @route /foo/bar * @route /for/baz */ public static function SomeRoute($SomeUnsafeParameter) { // this is accessible through two different routes echo (int)$SomeUnsafeParameter; } }
