[site]: stackoverflow
[post_id]: 708639
[parent_id]: 708229
[tags]: 
NOTE: This is not an answer to the compilation errors you are getting, but rather a broader view of the persistence problem you are handling. Serialization and deserialization is not the simplest problem you can work on. My advice would be investing in learning libraries (boost::serialization) and using them. They have already worked out many of the problems you will face at one time or another. Plus they already have different output formats (binary, xml, json...) The first thing you must decide, that is if you decide to go ahead and implement your own, is what will be the file format and whether it suits all your needs. Will it always be used in the same environment? Will the platform change (32/64bits)? You can decide to make it binary as it is the simplest, or make it readable for a human being. If you decide on XML, JSON or any other more complex formats, just forget it and use a library. The simplest solution is working on a binary file and it is also the solution that will give you a smallest file. On the other hand, it is quite sensible to architecture changes (say you migrate from a 32 to a 64 bit architecture/OS) After deciding the format you will need to work on the extra information that is not part of your objects now but needs to be inserted into the file for later retrieval. Then start working (and testing) from the smallest parts to more complex elements. Another advice would be to start working with the simplest most defined part and build from there on. Start avoiding templates as much as possible, and once you have it clear and working for a given data type, work on how to generalize it for any other type. Disclaimer: I have written the code directly on the browser, so there could be some errors, typos or just about anything :) Text The first simple approach is just writting a textual representation of the text. The advantage is that it is portable and shorter in code (if not simpler) than the binary approach. The resulting files will be bigger but user readable. At this point you need to know how reading text works with iostreams. Particularly, whenever you try to read a string the system will read characters until it reaches a separator. This means that the following code: std::string str; std::cin >> str; will only read up to the first space, tab or end of line. When reading numbers (ints as an example) the system will read all valid digits up to the first non-valid digit. That is: int i; std::cin >> i; with input 12345a will consume all characters up to 'a'. You need to know this because that will influence the way you persist data for later retrieval. // input: "This is a long Description" std::string str; std::cin >> str; // Will read 'This' but ignore the rest int a = 1; int b = 2; std::cout > read; // will read 12, not 1 So you pretty much need separators to insert in the output and to parse the input. For sample purposes I will select the '|' character. It must be a character that does not appear in the text fields. It will also be a good idea to not only separate elements but also add some extra info (size of the vector). For the elements in the vector you can decide to use a different separator. If you want to be able to read the file manually you can use '\n' so that each item is in its own line namespace textual { std::ostream & operator const & v ) { o For reading, you will need to split the input by '\n' to get each element and then with '|' to parse the InventoryItem: namespace textual { template void parse( std::string const & str, T & data ) { std::istringstream st( str ); // Create a stream with the string st >> data; // use operator>>( std::istream } std::istream & operator>>( std::istream & i, InventoryItem & data ) { getline( i, data.Item, '|' ); getline( i, data.Description, '|' ); std::string tmp; getline( i, tmp, '|' ); // Quantity in text parse( tmp, data.Quantity ); getline( i, tmp, '|' ); // wholesaleCost in text parse( tmp, data. wholesaleCost ); // ... return i; } std::istream & operator>>( std::istream & i, std::vector & data ) { int size; std::string tmp; getline( i, tmp ); // size line, without last parameter getline splits by lines parse( tmp, size ); // obtain size as string for ( int i = 0; i In the vector reading function I have used getline + parse to read the integer. That is to guarantee that the next getline() will actually read the first InventoryItem and not the trailing '\n' after the size. The most important piece of code there is the 'parse' template that is able to convert from a string to any type that has the insertion operator defined. It can be used to read primitive types, library types (string, for example), and user types that have the operator defined. We use it to simplify the rest of the code quite a bit. Binary For a binary format, (ignoring architecture, this will be a pain in the ass if you migrate) the simplest way I can think of is writing the number of elemements in the vector as a size_t (whatever the size is in your implementation), followed by all the elements. Each element will printout the binary representation of each of its members. For basic types as int, it will just output the binary format of the int. For strings we will resort to writting a size_t number with the number of characters in the string followed by the contents of the string. namespace binary { void write( std::ofstream & o, std::string const & str ) { int size = str.size(); o.write( &size, sizeof(int) ); // write the size o.write( str.c_str(), size ); // write the contents } template void write_pod( std::ofstream & o, T data ) // will work only with POD data and not arrays { o.write( &data, sizeof( data ) ); } void write( std::ofstream & o, InventoryItem const & data ) { write( o, data.Item ); write( o, data.Description ); write_pod( o, data.Quantity ); write_pod( o, data. ... } void write( std::ofstream & o, std::vector const & v ) { int size = v.size(); o.write( &size, sizeof( size ) ); // could use the template: write_pod( o, size ) for ( int i = 0; i I have selected a different name for the template that writes basic types than the functions that write strings or InventoryItems. The reason is that we don't want to later on by mistake use the template to write a complex type (i.e. UserInfo containing strings) that will store an erroneous representation in disk. Retrieval from disk should be fairly similar: namespace binary { template void read_pod( std::istream & i, T& data) { i.read( &data, sizeof(data) ); } void read( std::istream & i, std::string & str ) { int size; read_pod( i, size ); char* buffer = new char[size+1]; // create a temporary buffer and read into it i.read( buffer, size ); buffer[size] = 0; str = buffer; delete [] buffer; } void read( std::istream & i, InventoryItem & data ) { read( i, data.Item ); read( i, data.Description ); read( i, data.Quantity ); read( i, ... } void read( std::istream & i, std::vector & v ) { v.clear(); // clear the vector in case it is not empty int size; read_pod( i, size ); for ( int i = 0; i For using this approach, the std::istream and std::ostream must be opened in binary mode. int main() { std::ifstream persisted( "file.bin", ios:in|ios::binary ); std::vector v; binary::read( persisted, v ); // work on data std::ofstream persist( "output.bin", ios::out|ios::binary ); binary::write( persist, v ); } All error checking is left as an exercise for the reader :) If you have any question on any part of the code, just ask.
