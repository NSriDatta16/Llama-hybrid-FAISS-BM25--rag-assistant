[site]: stackoverflow
[post_id]: 3045880
[parent_id]: 3045126
[tags]: 
Don't be surprised, what you are trying is unusual at best. ShowModal achieves the modal effect by disabling all the windows of the calling thread but the modal form. Since your parent form do not belong to the same thread, not even to the same process, it does not get disabled. See DisableTaskWindows in forms.pas to understand how the forms are disabled when 'ShowModal' is called. You have to devise your own modal procedure; test if the application is parented in a top level window that's not the desktop, disable that window if that's the case. But if I were you I would think on the design first, what if, f.i., you close the parent form, how do you end the parented form's process? edit: for 3rd comment below - you might try having the modal form "owned" by the MainApps's form. Similiar to forms being owned by the application main form while MainFormOnTaskbar is true. See owned windows on Window Features topic of msdn. var frmDialog: TfrmDialog; begin [...] frmDialog := TfrmDialog.Create(Self, dtLogout); try SetWindowLong(frmDialog.Handle, GWL_HWNDPARENT, GetAncestor(Handle, GA_ROOT)); iMsgResult := frmDialog.ShowModal; [...] I'd humbly suggest you to ask a question on a suggestion of a design for what you want to achieve, for instance, if it is about code reuse you could host your SubApps forms in a dll... This design is fragile, you may continue to run into problems with it...
