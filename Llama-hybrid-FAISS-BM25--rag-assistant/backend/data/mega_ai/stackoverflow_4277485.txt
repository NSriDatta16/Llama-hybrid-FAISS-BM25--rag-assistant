[site]: stackoverflow
[post_id]: 4277485
[parent_id]: 3479631
[tags]: 
I haven't tried this yet, but likely will soon. An approach I'm likely to take is explicitly assigning a cache key based on the relevant models and on the current user. The fragment will be cached separately for each user, but only once per user. Try some variation on this: cache ["Unique fragment label", @model.cache_key, current_user.cache_key].join do # code with and without permissioned elements end To ensure that permission changes invalidate the cache, make sure such changes touch the User model's updated_at timestamp. Assuming permissions are stored in a separate model: class Permission true end
