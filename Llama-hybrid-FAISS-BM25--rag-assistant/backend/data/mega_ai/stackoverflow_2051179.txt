[site]: stackoverflow
[post_id]: 2051179
[parent_id]: 2037556
[tags]: 
Thanks to Kevin, Mitch, and Naftoli Gugenheim and Daniel Sobral on the scale-users mailing list, I have a good answer. The two previous answers work, but lead to an exponential blowup in the number of traits, classes and constructors. However, using implicits and view bounds avoids this problem. The steps of the solution are: 1) Give Normal a type parameter representing the type of its argument. 2) Define implicits that take a Normal with the right type of argument to one that implements the appropriate algorithm. For example, makeImportance takes a Normal[Importance] and produces a NormalImportance. 3) The implicits need to be given a type bound. The reason is that without the type bound, if you try to pass a Normal[T] to makeImportance where T is a subtype of Importance, it will not work because Normal[T] is not a subtype of Normal[Importance] because Normal is not covariant. 4) These type bounds need to be view bounds to allow the implicits to chain. Here's the full solution: class Model trait Importance extends Model { def forward: Int } trait MCMC extends Model { def propose: String } class Normal[T
