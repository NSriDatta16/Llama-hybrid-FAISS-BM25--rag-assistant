[site]: crossvalidated
[post_id]: 463634
[parent_id]: 459130
[tags]: 
After posting this I went on a long tour of all the techniques to calculate SEM for autocorrelated data like timeseries. I wrote up the full version including a comparison at: https://ljmartin.github.io/technical-notes/stats/estimators-autocorrelated/ The simplest way that is also quite robust is probably to first calculate the autocorrelation (but not by using the autocorrelation function). Use the statsmodels AutoReg function to estimate that parameter, called rho . Then, using the estimated value for rho (autocorrelation), apply a correction factor to the SEM. The full code for this is: def correction_factor(rho, n): d = ((n-1)*rho - n*rho**2 + rho**(n+1)) / (1-rho)**2 k = np.sqrt( (1 + (2*d)/n) / ( 1 - (2*d)/(n*(n-1)) ) ) return k timeseries = **YOUR TIMESERIES** fit_result = AutoReg(timeseries-timeseries.mean(), lags = [1]).fit() estimated_rho = fit_result.params[1] n=len(timeseries) #actual number of samples correction = correction_factor(estimated_rho, n) #correction factor naive_sem = stats.sem(timeseries) #first calculate SEM naively sem = naive_sem*correction #now correct the naive SEM by multiplying by correction The correction factor is known analytically from the equation for an autoregressive AR(1) process (see ref below) and works well when you have sampled for at least about 10-20 multiples of the autocorrelation time. Knowing the autocorrelation time is a different question but in practice try halving your data and see if the SEM is that different - if it is then you don't have enough. Ref: Bence, James R. "Analysis of short time series: correcting for autocorrelation." Ecology 76.2 (1995): 628-639.
