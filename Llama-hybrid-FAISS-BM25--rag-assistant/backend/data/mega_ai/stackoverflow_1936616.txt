[site]: stackoverflow
[post_id]: 1936616
[parent_id]: 1934111
[tags]: 
There's a pretty serious problem with the escaping approach: what escapes are needed depends on the context the variable's going to be expanded in, and in the usual case there's no escaping that'll work. For instance, if you're going to do something simple like: touch a "b c" d files="a b\ c d" ls $files ...it won't work (ls looks for 4 files: "a", "b\", "c", and "d") because the shell doesn't pay any attention to escapes when it word-splits $files. You could use eval ls $files , but that would fail on things like tabs in the filenames. The while ... read ... done approach fgm suggested works solidly (and because of the flexibility of find's search patterns, is very powerful), but it's also a rather messy pile of workarounds for various possible problems; if you don't need find's power, it's not hard to get things done with for and * : shopt -s nullglob # In case of empty directories... for filepath in "$dir"/*; do # loop over all files in the specified directory filename="${filepath##*/}" # You just wanted the files' names? No problem. echo "$filename" done If (as you mention in the question) you're interested in comparing the two directory trees, looping through one of them isn't quite what you want; it'd be better to put their contents into arrays, like this: shopt -s nullglob pathlist1=("$dir1"/*) # Get a list of paths of files in dir1 filelist1=("${pathlist1[@]##*/}") # Parse off just the filenames pathlist2=("$dir2"/*) # Same for dir2 filelist2=("${pathlist2[@]##*/}") # now compare filelist1 with filelist2... (Note that AFAIK the "${pathlist2[@]##*/}" construct is not standard, but seems to have been supported in both bash and zsh for a while now.)
