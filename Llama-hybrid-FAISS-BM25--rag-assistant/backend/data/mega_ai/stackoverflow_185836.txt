[site]: stackoverflow
[post_id]: 185836
[parent_id]: 
[tags]: 
Equivalent of Class Loaders in .NET

Does anyone know if it possible to define the equivalent of a "java custom class loader" in .NET? To give a little background: I am in the process of developing a new programming language that targets the CLR, called "Liberty". One of the features of the language is its ability to define "type constructors", which are methods that are executed by the compiler at compile time and generate types as output. They are sort of a generalization of generics (the language does have normal generics in it), and allow code like this to be written (in "Liberty" syntax): var t as tuple ; t.i = 2; t.j = 4; t.k = 5; Where "tuple" is defined like so: public type tuple(params variables as VariableDeclaration[]) as TypeDeclaration { //... } In this particular example, the type constructor tuple provides something similar to anonymous types in VB and C#. However, unlike anonymous types, "tuples" have names and can be used inside public method signatures. This means that I need a way for the type that eventually ends up being emitted by the compiler to be shareable across multiple assemblies. For example, I want tuple defined in Assembly A to end up being the same type as tuple defined in Assembly B. The problem with this, of course, is that Assembly A and Assembly B are going to be compiled at different times, which means they would both end up emitting their own incompatible versions of the tuple type. I looked into using some sort of "type erasure" to do this, so that I would have a shared library with a bunch of types like this (this is "Liberty" syntax): class tuple { public Field1 as T; } class tuple { public Field2 as T; public Field2 as R; } and then just redirect access from the i, j, and k tuple fields to Field1 , Field2 , and Field3 . However that is not really a viable option. This would mean that at compile time tuple and tuple would end up being different types, while at runtime time they would be treated as the same type. That would cause many problems for things like equality and type identity. That is too leaky of an abstraction for my tastes. Other possible options would be to use "state bag objects". However, using a state bag would defeat the whole purpose of having support for "type constructors" in the language. The idea there is to enable "custom language extensions" to generate new types at compile time that the compiler can do static type checking with. In Java, this could be done using custom class loaders. Basically the code that uses tuple types could be emitted without actually defining the type on disk. A custom "class loader" could then be defined that would dynamically generate the tuple type at runtime. That would allow static type checking inside the compiler, and would unify the tuple types across compilation boundaries. Unfortunately, however, the CLR does not provide support for custom class loading. All loading in the CLR is done at the assembly level. It would be possible to define a separate assembly for each "constructed type", but that would very quickly lead to performance problems (having many assemblies with only one type in them would use too many resources). So, what I want to know is: Is it possible to simulate something like Java Class Loaders in .NET, where I can emit a reference to a non-existing type in and then dynamically generate a reference to that type at runtime before the code the needs to use it runs? NOTE: *I actually already know the answer to the question, which I provide as an answer below. However, it took me about 3 days of research, and quite a bit of IL hacking in order to come up with a solution. I figured it would be a good idea to document it here in case anyone else ran into the same problem. *
