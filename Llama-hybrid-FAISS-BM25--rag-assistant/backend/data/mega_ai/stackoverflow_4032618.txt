[site]: stackoverflow
[post_id]: 4032618
[parent_id]: 4032162
[tags]: 
Problems: no multiple inclusion protections cyclic inclusion type use before its declaration caused by cyclic inclusion Your foo.h being processed by C preprocessor looks like infinite empty string sequence. With multiple inclusion protection foo.h is preprocessed to: > cpp foo.h class bar{ // preprocessed from #include "bar.h" public: static const int MY_DEFINE = 10; foo::my_enum_type var; bar() {}; ~bar() {}; }; // end of #include "bar.h" class foo{ public: enum my_enum_type { ONE, TWO, THREE }; foo(); ~foo() {} }; This obviously is not a valid C++ code - foo is used in bar body without previous declaration. C++, unlike Java, requires types to be declared before use. Use multiple inclusion protection. Depending on your platform those might be #ifndef macros or #pragma once directives Remove bar.h inclusion from foo.h. Place forward declarations where needed (in your case bar might be forward declared in foo.h, your example doesn't reveal neccesity of this though). Move as much implementation as possible to *.cpp files. If the situation can't be resolved with these recommendations, use PIMPL idiom . In short - just remove #include "bar.h" directive from foo.h
