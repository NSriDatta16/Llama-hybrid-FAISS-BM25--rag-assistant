[site]: stackoverflow
[post_id]: 665572
[parent_id]: 665494
[tags]: 
Surely the actual reason for using Func instead of a specific delegate is that C# treats separately declared delegates as totally different types. Even though Func and Predicate both have identical argument and return types, they are not assignment-compatible. So if every library declared its own delegate type for each delegate pattern, those libraries would not be able to interoperate unless the user inserts "bridging" delegates to perform conversions. // declare two delegate types, completely identical but different names: public delegate void ExceptionHandler1(Exception x); public delegate void ExceptionHandler2(Exception x); // a method that is compatible with either of them: public static void MyExceptionHandler(Exception x) { Console.WriteLine(x.Message); } static void Main(string[] args) { // can assign any method having the right pattern ExceptionHandler1 x1 = MyExceptionHandler; // and yet cannot assign a delegate with identical declaration! ExceptionHandler2 x2 = x1; // error at compile time } By encouraging everyone to use Func, Microsoft is hoping that this will alleviate the problem of incompatible delegate types. Everyone's delegates will play nicely together, because they will just be matched up based on their parameter/return types. It doesn't solve all problems, because Func (and Action ) can't have out or ref parameters, but those are less commonly used. Update: in the comments Svish says: Still, switching a parameter type from Func to Predicate and back, doesn't seem to make any difference? At least it still compiles without any problems. Yes, as long as your program only assigns methods to delegates, as in the first line of my Main function. The compiler silently generates code to new a delegate object that forwards on to the method. So in my Main function, I could change x1 to be of type ExceptionHandler2 without causing a problem. However, on the second line I try to assign the first delegate to another delegate. Even thought that 2nd delegate type has exactly the same parameter and return types, the compiler gives error CS0029: Cannot implicitly convert type 'ExceptionHandler1' to 'ExceptionHandler2' . Maybe this will make it clearer: public static bool IsNegative(int x) { return x p = IsNegative; Func f = IsNegative; p = f; // Not allowed } My method IsNegative is a perfectly good thing to assign to the p and f variables, as long as I do so directly. But then I can't assign one of those variables to the other.
