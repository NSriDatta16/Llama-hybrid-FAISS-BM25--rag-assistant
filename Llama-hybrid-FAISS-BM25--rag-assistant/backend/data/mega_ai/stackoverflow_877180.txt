[site]: stackoverflow
[post_id]: 877180
[parent_id]: 875759
[tags]: 
Here's yet another solution. In my experience, when you have a list of ItemIds as a string of comma separated values, you need a split function. This is very useful to have. With a split function, you can simply do an INNER JOIN with the results of calling the split function and passing the list of ItemIds and associated delimeter as follows: DECLARE @ItemIDs varchar(100) SET @ItemIDs = '1,3,16,22,34,35' SELECT ItemID, Name, RelDate, Price, Status FROM item_k INNER JOIN dbo.UTILfn_Split(@ItemIDs,',') itemIds ON itemIds.Value = item_k.ItemID While this may look complicated at first, it is the more elegant and maintainable solution. Here's the code for creating the dbo.UTILfn_Split function. You need to run this first: IF EXISTS (SELECT * FROM sysobjects WHERE id = object_id(N'[dbo].[UTILfn_Split]') AND xtype IN (N'FN', N'IF', N'TF')) DROP FUNCTION [dbo].[UTILfn_Split] GO CREATE FUNCTION dbo.UTILfn_Split ( @String nvarchar (4000), @Delimiter nvarchar (10) ) RETURNS @ValueTable TABLE ([Value] nvarchar(4000)) BEGIN DECLARE @NextString nvarchar(4000) DECLARE @Pos int DECLARE @NextPos int DECLARE @CommaCheck nvarchar(1) --Initialize SET @NextString = '' SET @CommaCheck = RIGHT(@String,1) --Check for trailing Comma, if not exists, INSERT --if (@CommaCheck <> @Delimiter ) SET @String = @String + @Delimiter --Get position of first Comma SET @Pos = CHARINDEX(@Delimiter,@String) SET @NextPos = 1 --Loop while there is still a comma in the String of levels WHILE (@pos <> 0) BEGIN SET @NextString = SUBSTRING(@String,1,@Pos - 1) INSERT INTO @ValueTable ( [Value]) Values (@NextString) SET @String = SUBSTRING(@String,@pos +1,LEN(@String)) SET @NextPos = @Pos SET @pos = CHARINDEX(@Delimiter,@String) END RETURN END
