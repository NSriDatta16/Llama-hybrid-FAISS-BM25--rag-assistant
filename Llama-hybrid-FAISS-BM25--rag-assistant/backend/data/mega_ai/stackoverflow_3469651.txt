[site]: stackoverflow
[post_id]: 3469651
[parent_id]: 3468309
[tags]: 
Using posix functionality (so, will work on linux and any system that complies with posix standard), you can use a combination of pipe/execl/dup. In short what happens is: create 2 pipes (one to read and one to write to the child) fork the current process. This keeps open the same fd close the current stdin/stdout. Then use dup (which uses the lowest available descriptor to duplicate what you give to it) execl the child process Pay attention some flushes are needed. The code of the parent is: #include #include #include #include int main () { pid_t pid; int pipe_in[2]; /* This is the pipe with wich we write to the child process. */ int pipe_out[2]; /* This is the pipe with wich we read from the child process. */ if (pipe (pipe_in) || pipe (pipe_out)) { fprintf (stderr, "Error in creating pipes!\n"); exit (1); } /* Attempt to fork and check for errors */ if ((pid = fork ()) == -1) { fprintf (stderr, "Error in fork!\n"); exit (1); } if (pid) { /* The parent has the non-zero PID. */ char temp[100]; int result; FILE* child_in; FILE* child_out; child_in = fdopen(pipe_out[0],"r"); child_out = fdopen(pipe_in[1],"w"); close(pipe_out[1]); close(pipe_in[0]); fprintf(child_out, "something\n"); fgets(temp,100,child_in); printf(" Read from child %s \n", temp); /* Send a command to the child. */ fprintf(child_out, "quit\n"); fflush(child_out); fgets(temp,100,child_in); printf(" Read from child %s \n", temp); wait (&result); /* Wait for child to finish */ } else { /* The child has the zero pid returned by fork*/ close (1); dup (pipe_out[1]); /* dup uses the lowest numbered unused file descriptor as new descriptor. In our case this now is 1. */ close (0); /* dup uses the lowest numbered unused file descriptor as new descriptor. In our case this now is 0. */ dup (pipe_in[0]); close (pipe_out[0]); close (pipe_out[1]); close (pipe_in[0]); close (pipe_in[1]); execl ("child", "child", NULL); exit(1); /* Only reached if execl() failed */ } return 0; } A simple child is: #include #include int main () { char temp[100]; do { printf ("In child: \n"); fflush (stdout); fgets (temp, 100, stdin); printf ("Child read %s\n", temp); fflush (stdout); } while (!strstr (temp, "quit")); return 0; } You can compile them with: gcc -o parent parent.c gcc -o child child.c ./parent And you will see Read from child In child: Read from child Child read quit
