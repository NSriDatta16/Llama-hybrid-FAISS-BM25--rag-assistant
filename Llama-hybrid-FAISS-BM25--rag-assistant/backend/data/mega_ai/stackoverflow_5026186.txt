[site]: stackoverflow
[post_id]: 5026186
[parent_id]: 
[tags]: 
DAO pattern and the Open-Closed Principle

I've seen and worked with a lot of older, JDBC-based DAO code that usually start out with CRUD methods. My question relates specifically to the retrieval methods, or 'finders'. Typically what I find is that the DAOs start out with two methods: find and return ALL retrieve a specific instance based on a unique identifier More often than not, those two finders are insufficient. I usually end up seeing a DAO class repeatedly modified to add finder methods like the following: find and return ALL where {condition} What happens is that more methods are added when a new {conditions} needs to be supported or existing methods are modified to add new parameters as flags to modify the SQL query inside the method to support the additional conditions. It's an ugly approach and violates the Open-Closed Principle. It has always been a peeve of mine seeing DAO classes continuously modified whenever some new retrieval condition needs to be supported. Research on this question often points me to the Repository Pattern and encapsulating conditions for retrieval as Specifications or Query objects then passing them to a finder method. But this only seems feasible if you have an in-memory collection of the entire data set or if you are using some kind of ORM (I'm working with older JDBC code) I've considered a solution that lazy loads the entire data set a DAO manages as a collection in-memory and then using the Specification Pattern as queries for retrieval. I then implement some kind of observer on the collection that just updates the database when creates, updates or deletes methods are called. But obviously performance and scalability suffer significantly. Any thoughts on this? Thank you for the responses so far. I do have one thought -- what are your opinions on the use of the Command/Policy pattern to encapsulate data access requests? Each individual Concrete Command can represent a specific kind of access and can be passed to an Invoker. I'd end up with numerous Concrete Command classes, but each one will be focused on just one kind of access and should be very testable and isolated. public abstract class Command { public execute(); public void setArguments(CommandArguments args){ //store arguments } } //map based structure for storing and returning arguments public class CommandArguments{ public String getAsString(String key); public String getAsInt(String key); //... others } //In some business class... Command command = CommandFactory.create("SearchByName"); CommandArguments args = new CommandArguments(); args.setValue("name", name); // others command.setArguments(args); List list = command.execute();
