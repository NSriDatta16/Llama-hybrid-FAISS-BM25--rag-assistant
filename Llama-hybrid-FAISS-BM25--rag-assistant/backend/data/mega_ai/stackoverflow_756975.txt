[site]: stackoverflow
[post_id]: 756975
[parent_id]: 756954
[tags]: 
Unfortunately there is no way to constrain a generic parameter to be an integral type ( Edit: I guess "arithmetical type" might be a better word as this does not pertain to just integers). It would be nice to be able to do something like this: where T : integral // or "arithmetical" depending on how pedantic you are or where T : IArithmetic I would suggest that you read Generic Operators by our very own Marc Gravell and Jon Skeet. It explains why this is such a difficult problem and what can be done to work around it. .NET 2.0 introduced generics into the .NET world, which opened the door for many elegant solutions to existing problems. Generic constraints can be used to restrict the type-arguments to known interfaces etc, to ensure access to functionality - or for simple equality/inequality tests the Comparer.Default and EqualityComparer.Default singletons implement IComparer and IEqualityComparer respectively (allowing us to sort elements for instance, without having to know anything about the "T" in question). With all this, though, there is still a big gap when it comes to operators. Because operators are declared as static methods, there is no IMath or similar equivalent interface that all the numeric types implement; and indeed, the flexibility of operators would make this very hard to do in a meaningful way. Worse: many of the operators on primitive types don't even exist as operators; instead there are direct IL methods. [emphasis mine] To make the situation even more complex, Nullable<> demands the concept of "lifted operators", where the inner "T" describes the operators applicable to the nullable type - but this is implemented as a language feature, and is not provided by the runtime (making reflection even more fun).
