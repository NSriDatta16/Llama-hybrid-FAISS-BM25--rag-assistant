[site]: stackoverflow
[post_id]: 1947190
[parent_id]: 1946973
[tags]: 
EDIT: It seems to me now that the article on functional dependencies from the HaskellWiki provides the key information in the best form that I can find, so I'd suggest reading that instead of my answer here. I'm not removing the rest of the content, though, as it makes clear (I hope) why FDs are useful here. Apart from the grouping of definitions issue which Dave pointed out... (I realize in fact that even if x and m are both Num , they may not be the same Num . How can I specify this? If I can't figure it out with Num , using Double would be fine, but I'd rather keep it general.) This is the main problem, actually. You can't multiply an Integer by a Float , say. In effect, you need the x and the m in scale to be of the same type. Also, a similar issue arises with distance, with the additional complication that sqrt needs a Floating argument. So I guess you'd need to mention that somewhere too. (Most likely on the instance, I guess). EDIT: OK, since sqrt only works on Floating values, you could roll a typeclass for those to upcast Float s to Double s when needed. Another idea involves having a typeclass Scalable : data Vector a = Vector1D a | Vector2D a a deriving (Show) class Scalable a b | a -> b where scale :: a -> b -> a instance (Num a) => Scalable (Vector a) a where scale (Vector1D x) m = (Vector1D (x * m)) scale (Vector2D x y) m = (Vector2D (x * m) (y * m)) This uses a so-called functional dependency in the definition of Scalable . In fact, trying to remember the syntax for that, I found this link ... So I guess you should disregard my inferior attempt at being helpful and read the quality info there. ;-) I think you should be able to use this to solve your original problem.
