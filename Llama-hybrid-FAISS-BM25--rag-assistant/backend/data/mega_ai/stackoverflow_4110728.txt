[site]: stackoverflow
[post_id]: 4110728
[parent_id]: 4110292
[tags]: 
Aside from the obvious answer ("if you violate any requirement, that's undefined behavior, good night and thanks for playing"), I imagine the worst that would likely happen, is that the vector implementation can rely on the requirement that "all instances of the allocator class are interchangeable" in the obvious way: vector(const Allocator &youralloc = Allocator()) { const Allocator hawhaw; // use hawhaw and ignore youralloc. // They're interchangeable, remember? } Looking at the source, GCC's vector implementation (which I think is based eventually on SGI's original STL implementation) does sort-of store a copy of the allocator object passed into that constructor, so there's some hope that this won't happen. I'd say try it and see, and document what you've done very carefully , so that anyone attempting to use your code on an implementation that you haven't checked, knows what's going on. Implementers are encouraged in the standard to relax the restrictions on allocators, so it would be a dirty trick to make it look as though they're relaxed when really they aren't. Which doesn't mean it won't happen. If you're really lucky, there's some documentation for your container implementation that talks about allocators.
