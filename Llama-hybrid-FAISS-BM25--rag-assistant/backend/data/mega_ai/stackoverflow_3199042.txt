[site]: stackoverflow
[post_id]: 3199042
[parent_id]: 3197341
[tags]: 
I have found an answer to my original question. However it has problems and I think _NSGetCarbonMenu() is necessary to fix them. PROBLEM: how does one draw the menu item so it looks like a native menu item? PROBLEM: how does one make the custom view behave as an ordinary menuitem.. right now you have to press arrow_down two times to get the next item selected. How to fix these issues? @interface MyMenuItem : NSView { BOOL m_active; } @end @implementation MyMenuItem - (BOOL)acceptsFirstResponder { return YES; } - (BOOL)becomeFirstResponder { m_active = YES; return YES; } - (BOOL)resignFirstResponder { m_active = NO; return YES; } - (void)viewDidMoveToWindow { [[self window] makeFirstResponder:self]; } - (void)drawRect:(NSRect)rect { if(m_active) { [[NSColor blueColor] set]; } else { [[NSColor blackColor] set]; } NSRectFill(rect); } @end // this makes sure the first item gets selected when the menu popups MyMenuItem* view = [[[MyMenuItem alloc] initWithFrame:NSMakeRect(0, 0, 100, 20)] autorelease]; [view setAutoresizingMask:NSViewWidthSizable]; NSMenuItem* item = [menu itemAtIndex:0]; [item setView:view]; [NSMenu popUpContextMenu:menu withEvent:event forView:self]; SOLVED IT!!! Forget all the stuff above. I have just found an elegant solution that doesn't require Carbon at all. // simulate a key press of the arrow-down key CGKeyCode key_code = 125; // kVK_DownArrow = 125 CGEventRef event1, event2; event1 = CGEventCreateKeyboardEvent(NULL, key_code, YES); event2 = CGEventCreateKeyboardEvent(NULL, key_code, NO); CGEventPost(kCGSessionEventTap, event1); CGEventPost(kCGSessionEventTap, event2); CFRelease(event1); CFRelease(event2); [NSMenu popUpContextMenu:menu withEvent:event forView:self];
