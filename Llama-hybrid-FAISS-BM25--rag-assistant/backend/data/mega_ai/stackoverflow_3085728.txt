[site]: stackoverflow
[post_id]: 3085728
[parent_id]: 
[tags]: 
How to Create Asynchronous HttpWebRequest in Silverlight( F#)

As I mentioned, because Silverlight HttpWebRequest.Create hangs inside async block , I just created a bundle of callback functions to implement the same async block. The login process requires two steps : 1) Get request to a page that returns a cookie 2) Form Post to a second page that passes that cookie w/ it and performs the authentication The following is the src. Any suggestions and discussions are welcome and appreciated no matter about Asynchronous HttpWebRequest or about the F# code style. module File1 open System open System.IO open System.Net open System.Text open System.Security open System.Runtime.Serialization open System.Collections.Generic open JsonData open System.Net.Browser open System.Threading module rpc = let mutable BASE_DNS = "" let mutable requestId : int = 0 let getId() = requestId ///Transfer data from Security.loginToRpc to Helper.FetchCookieCallback /// type LoginRequestRecord = { Request : HttpWebRequest; UserName : string; Password : string; AuthenticationUrl : string; CallbackUI : (bool -> unit) } /// ///Transfer data from Helper.FetchCookieCallback to Helper.requestAuthenticationCallback /// type AuthenticationRecord = { Request : HttpWebRequest; UserName : string; Password : string; CallbackUI : (bool -> unit) } /// ///Transfer data from Helper.requestAuthenticationCallback to Helper.responseAuthenticationCallback /// type ResponseAuthenticationRecord = { Request : HttpWebRequest; CallbackUI : (bool -> unit) } /// ///The cookieContainer for all the requests in the session /// let mutable cookieJar = new CookieContainer() /// ///Function: Create HttpRequest ///Param: string ///Return: HttpWebRequest /// let internal createHttpRequest (queryUrl : string) = let uri = new Uri(queryUrl) let request : HttpWebRequest = downcast WebRequestCreator.ClientHttp.Create( new Uri(queryUrl, UriKind.Absolute)) request /// ///Function: set request whose method is "GET". ///Attention: no contentType for "GET" request~!!!!!!!!!!!!!!!! ///Param: HttpWebRequest ///Return: unit /// let internal requestGetSet (request : HttpWebRequest) = request.Method ///Function: set request whose method is "POST" and its contentType ///Param: HttpWebRequest and contentType string ///Return: unit /// let internal requestPostSet (request : HttpWebRequest) contentType = request.Method ///Function: Callback function inluding EndGetResponse method of request ///Param: IAsyncResult includes the information of HttpWebRequest ///Return: unit /// let internal responseAuthenticationCallback (ar : IAsyncResult) = let responseAuthentication : ResponseAuthenticationRecord = downcast ar.AsyncState try let response = responseAuthentication.Request.EndGetResponse(ar) //check whether the authentication is successful, //which may be changed later into other methods match response.ContentLength with | -1L -> responseAuthentication.CallbackUI true | _ -> responseAuthentication.CallbackUI false () with | Ex -> responseAuthentication.CallbackUI false /// ///Function: Callback function for user to log into the website ///Param: IAsyncResult includes the information of ///HttpWebRequest and user's identity ///Return: unit /// let internal requestAuthenticationCallback (ar : IAsyncResult) = let authentication : AuthenticationRecord = downcast ar.AsyncState try let requestStream = authentication.Request.EndGetRequestStream(ar) let streamWriter = new StreamWriter(requestStream) streamWriter.Write( String.Format( "j_username={0}&j_password={1}&login={2}", authentication.UserName, authentication.Password, "Login")) streamWriter.Close() let responseAuthentication = { ResponseAuthenticationRecord.Request = authentication.Request ResponseAuthenticationRecord.CallbackUI = authentication.CallbackUI } authentication.Request.BeginGetResponse( new AsyncCallback(responseAuthenticationCallback), responseAuthentication) |> ignore with | Ex -> authentication.CallbackUI false () /// ///This is a magic number to check ///whether the first request have got the cookie from the server-side, ///which should be changed later /// let countHeadersAfterGetCookie = 8 /// ///Function: Callback function to get the cookie and ///Param: IAsyncResult includes the information of ///login request, username, password and callbackUI ///Return: /// let internal FetchCookieCallback (ar : IAsyncResult) = let loginRequest : LoginRequestRecord = downcast ar.AsyncState try let response = loginRequest.Request.EndGetResponse(ar) let request : HttpWebRequest = createHttpRequest loginRequest.AuthenticationUrl requestPostSet request "application/x-www-form-urlencoded" request.CookieContainer let authentication = { AuthenticationRecord.Request = request; AuthenticationRecord.UserName = loginRequest.UserName; AuthenticationRecord.Password = loginRequest.Password; AuthenticationRecord.CallbackUI = loginRequest.CallbackUI } request.BeginGetRequestStream( new AsyncCallback(requestAuthenticationCallback), authentication) |> ignore () | _ -> loginRequest.CallbackUI false () with | Ex -> loginRequest.CallbackUI false module Security = /// ///Function: Use the async workflow around 2 we calls: /// 1. get the cookie; 2. log into the website ///Param: UserName and password ///Return: unit /// let loginToRpc (userName : string) (password : string) (callbackUI : (bool-> unit)) = let sessionIdUrl = BASE_DNS let authenticationUrl = BASE_DNS + "..................." let request : HttpWebRequest = Helper.createHttpRequest sessionIdUrl Helper.requestGetSet(request) request.CookieContainer ignore ()
