[site]: stackoverflow
[post_id]: 1405083
[parent_id]: 1405041
[tags]: 
Can be done, but not by using magic strings (e.g., "circle") like in your example. First, you should be designing your models based on existing framework elements rather than designing the model with the idea of whipping up some new UI elements or struggling to create code that interprets between them . WPF already has an ellipse (circle), rectangle (square) and a whole host of other geometric primitives for you to use. You'll want to create models that contain public bindable properties that you can bind to instances of these elements to control their shape and location. Without going into much detail (or testing), I'd do something like this public class GeometricElement : INotifyPropertyChanged { // these are simplified and don't show INPC code public double Left {get;set;} public double Top {get;set;} public Brush Fill {get;set;} // ... } // ... public class Square : GeometricElement { public double Width {get;set;} public double Height {get;set;} } // ... // bound to the window public class CadAppDataContext { public ObservableCollection Elements {get; private set;} } And in my xaml, it would look something like The ItemsControl will create a Canvas element and for every GeometricElement in my Elements collection it will add a new child UI element based on the type of object in Elements. Items controls are bound to collections and can add or remove elements based on what's happening in the collection within your code. It determines the UI element to add by looking for a DataTemplate that is designed for a particular Type. This is a common, and important, pattern and is why using magic strings will hurt you in the long run; the magic string route won't let you leverage the power of the framework already built into WPF. Now, I'm not saying this will work out of the box. You'll probably run into properties that won't bind without some heavy lifting. You might even have to extend the geometry primitives to get them to behave how you want. But this is the pattern used in WPF applications. Understanding the pattern and using it will help you avoid hours of stress and failure.
