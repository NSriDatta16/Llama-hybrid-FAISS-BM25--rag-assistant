[site]: stackoverflow
[post_id]: 2029319
[parent_id]: 2028107
[tags]: 
There are a couple of problems with the Pimpl. First of all, though not evident: if you use Pimpl, you will have to define the copy constructor / assignment operator and destructor (now known as "Dreaded 3") You can ease that by creating a nice template class with the proper semantic. The problem is that if the compiler sets on defining one of the "Dreaded 3" for you, because you had used forward declaration, it does know how to call the "Dreaded 3" of the object forward declared... Most surprising: it seems to work with std::auto_ptr most of the times, but you'll have unexpected memory leaks because the delete does not work. If you use a custom template class though, the compiler will complain that it cannot find the needed operator (at least, that's my experience with gcc 3.4.2). As a bonus, my own pimpl class: template class pimpl { public: /** * Types */ typedef const T const_value; typedef T* pointer; typedef const T* const_pointer; typedef T& reference; typedef const T& const_reference; /** * Gang of Four */ pimpl() : m_value(new T) {} explicit pimpl(const_reference v) : m_value(new T(v)) {} pimpl(const pimpl& rhs) : m_value(new T(*(rhs.m_value))) {} pimpl& operator=(const pimpl& rhs) { pimpl tmp(rhs); swap(tmp); return *this; } // operator= ~pimpl() { delete m_value; } void swap(pimpl& rhs) { pointer temp(rhs.m_value); rhs.m_value = m_value; m_value = temp; } // swap /** * Data access */ pointer get() { return m_value; } const_pointer get() const { return m_value; } reference operator*() { return *m_value; } const_reference operator*() const { return *m_value; } pointer operator->() { return m_value; } const_pointer operator->() const { return m_value; } private: pointer m_value; }; // class pimpl // Swap template void swap(pimpl & lhs, pimpl & rhs) { lhs.swap(rhs); } Not much considering boost (especially for the cast issues), but there are some niceties: proper copy semantic (ie deep) proper const propagation You still have to write the "Dreaded 3". but at least you can treat it with value semantic. EDIT : Spurred on by Frerich Raabe, here is the lazy version, when writing the Big Three (now Four) is a hassle. The idea is to "capture" information where the full type is available and use an abstract interface to make it manipulable. struct Holder { virtual ~Holder() {} virtual Holder* clone() const = 0; }; template struct HolderT: Holder { HolderT(): _value() {} HolderT(T const& t): _value(t) {} virtual HolderT* clone() const { return new HolderT(*this); } T _value; }; And using this, a true compilation firewall: template class pimpl { public: /// Types typedef T value; typedef T const const_value; typedef T* pointer; typedef T const* const_pointer; typedef T& reference; typedef T const& const_reference; /// Gang of Five (and swap) pimpl(): _holder(new HolderT ()), _p(this->from_holder()) {} pimpl(const_reference t): _holder(new HolderT (t)), _p(this->from_holder()) {} pimpl(pimpl const& other): _holder(other->_holder->clone()), _p(this->from_holder()) {} pimpl(pimpl&& other) = default; pimpl& operator=(pimpl t) { this->swap(t); return *this; } ~pimpl() = default; void swap(pimpl& other) { using std::swap; swap(_holder, other._holder); swap(_p, other._p) } /// Accessors pointer get() { return _p; } const_pointer get() const { return _p; } reference operator*() { return *_p; } const_reference operator*() const { return *_p; } pointer operator->() { return _p; } const_pointer operator->() const { return _p; } private: T* from_holder() { return &static_cast & >(*_holder)._value; } std::unique_ptr _holder; T* _p; // local cache, not strictly necessary but avoids indirections }; // class pimpl template void swap(pimpl & left, pimpl & right) { left.swap(right); }
