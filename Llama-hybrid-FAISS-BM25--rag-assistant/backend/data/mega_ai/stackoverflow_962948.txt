[site]: stackoverflow
[post_id]: 962948
[parent_id]: 960603
[tags]: 
The book that John Sanders has recommended is one of the best books I have ever read. Also, all your ORM questions can most likely be answered through a reading of it. To directly answer you question though, (and sidestep any questions of the validity of the model), there are two obvious ways I see to constrain it as is. We could use either a subset constraint or an equality constraint, depending on what it is you actually want to capture. Assigning an equality constraint (Right) between the roles, we can generate a constraint that would conceptually require that any Thing of a living Type has a date of birth and that any Thing with a date of birth be of a living Type. Assigning a Subset constraint (Left) between the roles, we can constrain the model such that any Thing of a Type with a DateOfBirth must be of a Type that is living. This, unlike the equality constraint will allow for things to be of a living type, but not have a date of birth. additions: To create these types of subset and equality constraints that will work, we need to use something called a 'Join Path' . Using a join path, we can create a Join-Subset Constraint and Join-Equality constraint that will span multiple roles on both sides of the constraint. Examples of join paths can at times be obvious and easy to follow. but can also get a little overwhelming and complex at times. Also of note, is that although NORMA does support creating join paths, in equality, subset, and exclusion constraints the verbilazation is not 100% complete for them, as explained here . This is also one of the reasons why it is easier to use Subsets at current, since it is easier to validate the correctness of the model conceptually. To create a Join Path in NORMA when assigning the roles for a Subset, Equality, or Exclusion constraint first assign all roles that are part of a path with a single click, and then double click to move on to the next path. When the constraint is capable of join paths, the Roles involved in that constraint will be labeled [#.#] instead of just [#]. So when we are creating our constraints we can say here that roles [1.1]&[1.2] are a subset/equal to roles [2.1]/[2.1]. Note that the Facts playing a part in each role must also match. So he we get a verbalization from NORMA: If some Thing has some DateOfBirth; some Thing is of some Type then that Thing is of some Type; that Type is living. Which is better stated as: If some Thing of some Type has some DateOfBirth; then that Type is living. However, there is a third (and preferable) way that we could constrain this, which would be subtyping. Since things that are alive, and things that aren't alive are very different, we probably don't want to be mapping them to the same tables anyway. Here we split our Type fact into two subtypes, OrganicTypes and NonOrganicTypes. The Exclusive Or constraint between the two subtypes tells us that every type is either Organic or NonOrganic. and the Note tells us the Derivation Rule that we use for determining which group a type belongs to. From there, we redefine our [Thing is of Type] role to [LivingThing is of OrganicType]. and since OrganicThings by deffinition are capable of life, our constraint for DOB/is living is now built into the model.
