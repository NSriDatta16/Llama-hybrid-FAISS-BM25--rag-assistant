[site]: stackoverflow
[post_id]: 2768797
[parent_id]: 2768308
[tags]: 
A UI thread has a number of characteristics that make it special: Windows has a message queue associated with the thread. This happens as soon as the very first window gets created on the thread. The thread runs a message loop, allowing Windows to dispatch messages to the windows. The message loop gets created as soon as you call Application.Run(). COM was initialized on the thread, requesting a single-threaded apartment. An STA is necessary to allow many Windows features to work properly, features that are not thread-safe by design. COM ensures that these features are always called in a thread-safe manner, marshaling the call from a worker thread to the STA thread as needed. Examples of these features are Drag+Drop, the clipboard, the shell dialogs (OpenFileDialog etc), ActiveX controls like WebBrowser, window hooks set by SetWindowsHookEx, accessibility providers such as used by a screen reader, UI automation providers. All external code, none of it thread-safe. The thread never blocks on any operation, it stays responsive so it can dispatch Windows messages as required to keep the user interface responsive and COM marshaling requests flowing. Making calls to WaitHandle.WaitAny() for example are explicitly forbidden and generate an exception. The CLR has specific support for WaitOne() and lock , pumping an internal message loop to avoid deadlock. The startup thread of a process is almost always selected as the UI thread, although that's not a hard requirement. The STA state is selected by the [STAThread] attribute on the Main() method. You can create a UI thread by ensuring that the above requirements are met. That could look like this in a Winforms app: var ui = new Thread(() => { Application.Run(new Form2()); }); ui.SetApartmentState(ApartmentState.STA); ui.Start(); That creates a second window, running on its own UI thread. One typical problem you have with this arrangement is that you've now got two separate windows, they are not associated with each other at all. The 2nd window cannot be owned by the 1st, it has its own Z-order independent of the 1st. Difficult to deal with by the user. The SystemEvents.UserPreferenceChanged event is notable, it will inevitably fire its event on the wrong thread and that is apt to cause deadlock. Lots of WinForms controls subscribe it. Except in rare circumstances, like a splash screen, this doesn't improve the user interface at all.
