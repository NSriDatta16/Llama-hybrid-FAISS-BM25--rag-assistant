[site]: stackoverflow
[post_id]: 3424207
[parent_id]: 
[tags]: 
Testing against Java EE 6 API

I write an addition to JAX-RS and included the Java EE 6 API as a Maven dependency. javax javaee-api 6.0 provided Then I have a little test case: @Test public void testIsWriteable() { class SpecialViewable extends Viewable { public SpecialViewable() { super("test"); } } FreeMarkerViewProcessor processor = new FreeMarkerViewProcessor(null); assertTrue(processor.isWriteable(SpecialViewable.class, null, null, MediaType.WILDCARD_TYPE)); } But I get an error: java.lang.ClassFormatError: Absent Code attribute in method that is not native or abstract in class file javax/ws/rs/core/MediaType ... If I include Jersey as a JAX-RS implementation instead of the Java EE API everything is fine. Thanks to BalusC's hint I know what I had guessed: Java EE 6 is only an API without method bodies: From the java.net blog You can compile you code with this jar, but of course you cannnot run your application with it since it contains only the Java EE 5 APIs and does not contain any method bodies. If you try to run, you would get this exception: Exception in thread "main" java.lang.ClassFormatError: Absent Code attribute in method that is not native or abstract in class file javax/mail/Session In order to execute a Java EE 5 application, you'll still need a Java EE 5 container, like for example the GlassFish application server. I've tried to add Jersy with test scope but it didn't work. javax javaee-api 6.0 provided com.sun.jersey jersey-server ${jersey-version} test How can I test software that depends only on the official Java EE API? Solution The provider (Jersey) needs to be placed before the API (javeee-api) in the pom.xml. com.sun.jersey jersey-server ${jersey-version} test javax javaee-api 6.0 provided
