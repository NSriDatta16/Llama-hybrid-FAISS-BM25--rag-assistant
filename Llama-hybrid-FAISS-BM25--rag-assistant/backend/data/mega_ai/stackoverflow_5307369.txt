[site]: stackoverflow
[post_id]: 5307369
[parent_id]: 
[tags]: 
What does "Tomcat Endpoint" Waiting On Object Monitor mean?

Reviewing a stack trace of a non-responsive web-app, I realized that some of the data did not match how-I-thought-tomcat-works. Context The application is getting hit in rapid succession for a slow url. These requests seem to pile up, i.e. form a traffic jam in the app server. Logging shows that the number of threads/http connectors have maxed out (number of busy threads has crept up to to the maxThreads value of 120). Jboss 4.2.2 Uses a variation of tomcat 6.0 called 'jboss-web' The question Many of the threads are "doing something"--i.e. reading from the database, writing to the output stream etc...Yet over 50 of the threads are "waiting on the connector to provide a new socket" (From the comments) What exactly does this mean to the non-socket programmer? My prior assumptions: wrong I had assumed that each http thread would 'do its own work'--get the request, do some work, and write the response -- and not need to wait for anything. so... What's going on? Could someone clarify the socket-ish stuff? What implication does such a bottleneck for the tomcat settings? (i.e. increase this setting, decrease that one, etc.) ** Stack Trace ** "http-0.0.0.0-80-90" daemon prio=6 tid=0x695e1400 nid=0x24c in Object.wait() [0x6e8cf000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on (a org.apache.tomcat.util.net.JIoEndpoint$Worker) at java.lang.Object.wait(Object.java:485) at org.apache.tomcat.util.net.JIoEndpoint$Worker.await(JIoEndpoint.java:416) - locked (a org.apache.tomcat.util.net.JIoEndpoint$Worker) at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:442) at java.lang.Thread.run(Thread.java:619) Locked ownable synchronizers: - None Code fragment from Tomcat's org.apache.tomcat.util.net.JIOEndpoint /** * Process an incoming TCP/IP connection on the specified socket. Any * exception that occurs during processing must be logged and swallowed. * NOTE : This method is called from our Connector's thread. We * must assign it to our own thread so that multiple simultaneous * requests can be handled. * * @param socket TCP socket to process */ synchronized void assign(Socket socket) { // Wait for the Processor to get the previous Socket while (available) { try { wait(); } catch (InterruptedException e) { } } // Store the newly available Socket and notify our thread this.socket = socket; available = true; notifyAll(); } thanks
