[site]: stackoverflow
[post_id]: 5609196
[parent_id]: 5608409
[tags]: 
They solve different problems . Actors are good at solving task parallel problems . While parallel collections are good at solving data parallel problems . I don't think they are mutually exclusive - you can use parallel collections in actors and parallel collections containing actors. Edit - quick test: Even something simple like a actor notification loop benefits. In the following code we register a million actors with an actor registry which has to notify them of an event. The non-parallel notification loop ( registry foreach {} ) takes an average of 2.8 seconds on my machine (4 core 2.5 GHz notebook). When the parallel collection loop ( registry.par.foreach {} ) is used it takes 1.2 seconds and uses all four cores. import actors.Actor case class Register(actor: Actor) case class Unregister(actor: Actor) case class Message( contents: String ) object ActorRegistry extends Actor{ var registry: Set[Actor] = Set.empty def act() { loop{ react{ case reg: Register => register( reg.actor ) case unreg: Unregister => unregister( unreg.actor ) case message: Message => fire( message ) } } } def register(reg: Actor) { registry += reg } def unregister(unreg: Actor) { registry -= unreg } def fire(msg: Message){ val starttime = System.currentTimeMillis() registry.par.foreach { client => client ! msg } //swap registry foreach for single th val endtime = System.currentTimeMillis() println("elapsed: " + (endtime - starttime) + " ms") } } class Client(id: Long) extends Actor{ var lastmsg = "" def act() { loop{ react{ case msg: Message => got(msg.contents) } } } def got(msg: String) { lastmsg = msg } } object Main extends App { ActorRegistry.start for (i
