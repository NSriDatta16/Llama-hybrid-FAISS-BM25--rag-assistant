[site]: stackoverflow
[post_id]: 566782
[parent_id]: 566422
[tags]: 
I'd avoid C strings. Computing the length is O(n). Sharing substrings is nearly impossible. The contiguous memory requirement leads to fragmentation. Any problem with the terminator leads to bugs and security holes. If you store it as UCS-4, you waste a lot of space for ASCII strings (and lose C compatibility, the one benefit of C strings); if you store it as UTF-8, indexing is O(n). PDP-11's ASCIZ type only really made a lot of sense when you're writing a library for ASCII on a bare PDP-11. Languages younger than the PDP-11 often use a different structure: Pascal uses a length field instead of a terminator -- their strlen() is O(1). Forth uses (address, length) doubles -- their strlen() is O(1), plus they can easily share substrings. Many modern "managed" languages like Java store the length separately, as well. In other languages (like Common Lisp), strings are simply a subtype of vector (whose elements are characters). The Excel team used C, but implemented their own Pascal strings for performance. I'd use something like ropes . Concatenation is constant-time. They don't require contiguous memory. Substring sharing is easy. All operations can be performed without locking in a multithreaded environment. Maybe allow both UCS-4 and ASCII nodes to make storage more compact in the common case, and/or have it automatically use a simpler structure internally for really short strings. ASCIZ is great if you have little memory, short strings, 7-bit chars, trusted input, and your CPU is so slow that it's worth your programmer-time to be really careful. In the modern world of Unicode, multithreading, efficient GC, fast CPUs, and big (possibly untrusted) inputs, it's no longer a great choice.
