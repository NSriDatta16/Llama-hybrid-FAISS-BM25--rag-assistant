[site]: stackoverflow
[post_id]: 741128
[parent_id]: 741050
[tags]: 
I. Elegant XSLT code One can often find examples of beautiful XSLT code, especially when XSLT is used as a functional programming language . For examples see this article on FXSL 2.0 -- the Functional Programming library for XSLT 2.0. As an FP language XSLT is also a declarative language . This, among other things means that one declares, specifies existing relationships. Such a definition often does not need any additional code to produce a result -- it itself is its own implementation, or an executable definition or executable specification . Here is a small example . This XPath 2.0 expression defines the " Maximum Prime Factor of a natural number ": if(f:isPrime($pNum)) then $pNum else for $vEnd in xs:integer(floor(f:sqrt($pNum, 0.1E0))), $vDiv1 in (2 to $vEnd)[$pNum mod . = 0][1], $vDiv2 in $pNum idiv $vDiv1 return max((f:maxPrimeFactor($vDiv1),f:maxPrimeFactor($vDiv2))) To pronounce it in English , the maximum prime factor of a number pNum is the number itself, if pNum is prime, otherwise if vDiv1 and vDiv2 are two factors of pNum , then the maximum prime factor of pNum is the bigger of the maximum prime factors of vDiv1 and vDiv2 . How do we use this to actually calculate the Maximum Prime Factor in XSLT? We simply wrap up the definition above in an and ... get the result! We can, then, calculate the MPF for any natural number , for example: f:maxPrimeFactor(600851475143) = 6857 As for efficiency, well, this transformation takes just 0.109 sec . Other examples of both ellegant and efficient XSLT code : Tim Bray 's Wide Finder , as solved here . Cascade deletions Transitive closure Finding all anagrams of a word Concordance of a text corpus (the Old Testament) Spelling checking (Shakespear's Othello) Sudoku solver II. Some rules Here are some rules for writing "quality XSLT code", as taken from Mukul Ghandi's blog . They can be checked/enforced using a tool developed by Mukul : DontUseDoubleSlashOperatorNearRoot: Avoid using the operator // near the root of a large tree. DontUseDoubleSlashOperator: Avoid using the operator // in XPath expressions. SettingValueOfVariableIncorrectly: Assign value to a variable using the 'select' syntax if assigning a string value. EmptyContentInInstructions: Don't use empty content for instructions like 'xsl:for-each' 'xsl:if' 'xsl:when' etc. DontUseNodeSetExtension: Don't use node-set extension function if using XSLT 2.0. RedundantNamespaceDeclarations: There are redundant namespace declarations in the xsl:stylesheet element. UnusedFunction: Stylesheet functions are unused. UnusedNamedTemplate: Named templates in stylesheet are unused. UnusedVariable: Variable is unused in the stylesheet. UnusedFunctionTemplateParameter: Function or template parameter is unused in the function/template body. TooManySmallTemplates: Too many low granular templates in the stylesheet (10 or more). MonolithicDesign: Using a single template/function in the stylesheet. You can modularize the code. OutputMethodXml: Using the output method 'xml' when generating HTML code. NotUsingSchemaTypes: The stylesheet is not using any of the built-in Schema types (xs:string etc.), when working in XSLT 2.0 mode. UsingNameOrLocalNameFunction: Using name() function when local-name() could be appropriate (and vice-versa). FunctionTemplateComplexity: The function or template's size/complexity is high. There is need for refactoring the code. NullOutputFromStylesheet: The stylesheet is not generating any useful output. Please relook at the stylesheet logic. UsingNamespaceAxis: Using the deprecated namespace axis, when working in XSLT 2.0 mode. CanUseAbbreviatedAxisSpecifier: Using the lengthy axis specifiers like child::, attribute:: or parent::node(). UsingDisableOutputEscaping: Have set the disable-output-escaping attribute to 'yes'. Please relook at the stylesheet logic. NotCreatingElementCorrectly: Creating an element node using the xsl:element instruction when could have been possible directly. AreYouConfusingVariableAndNode: You might be confusing a variable reference with a node reference. (contributed by, Alain Benedetti) IncorrectUseOfBooleanConstants: Incorrectly using the boolean constants as 'true' or 'false'. (contributed by, Tony Lavinio) ShortNames: Using a single character name for variable/function/template. Use meaningful names for these features. NameStartsWithNumeric: The variable/function/template name starts with a numeric character
