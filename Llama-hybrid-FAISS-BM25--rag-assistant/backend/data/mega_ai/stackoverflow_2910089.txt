[site]: stackoverflow
[post_id]: 2910089
[parent_id]: 2910008
[tags]: 
You can't just regexp match an email address against a short regexp pattern if you want to accept all validly formed email addresses and reject all non-valid one. Use a parser ( 1 , 2 ) that actually implement against the relevant RFCs to check for validity. Other things you can do is checking HTTP_REFERER to make sure the request came from within your domain as Chacha102 already mentioned. Just note that not all agent send HTTP_REFERER, and that it can be optionally turned off or faked by users. If you want to go the extra mile to make sure they are giving you a valid email address, you can check for existing DNS record for mail servers at the domain specified (A, MX, or AAAA). And on top of that, you can do callback verification. That's where you connect to the mail server, tell it you want to send to this email address and see if they say OK. For callback verification, you should note greylisting servers say OK to everything so even that is not a guarantee. Here's some code I used when I needed such a script. It's a patch onto the parser from ( 1 ). # # Email callback verification # Based on http://uk2.php.net/manual/en/function.getmxrr.php # if (strlen($bits['domain-literal'])){ $records = array($bits['domain-literal']); }elseif (!getmxrr($bits['domain'], $mx_records, $mx_weight)){ $records = array($bits['domain']); }else{ $mxs = array(); for ($i = 0; $i "); $rcpt_text = send_command($fp, "RCPT TO: "); $ms_resp .= $rcpt_text; $ms_code = intval(substr($rcpt_text, 0, 3)); if ($ms_code == 250 || $ms_code == 451){ // Accept all user account on greylisting server $user_okay = true; } $ms_resp .= send_command($fp, "QUIT"); fclose($fp); } } return $user_okay ? 1 : 0;
