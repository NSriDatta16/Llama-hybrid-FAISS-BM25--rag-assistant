[site]: stackoverflow
[post_id]: 5660416
[parent_id]: 
[tags]: 
JUNG2 layout problems: resultant graphs end up too wide

I have been working on JUNG2 for a while now, trying to visualize a pretty complicated hierarchy of a set of objects. Unfortunately, this hierarchy is not really like a tree in the sense that: some nodes will have multiple parents. Furthermore, these parents could be at different branches of the tree. some nodes might have duplicates (this is has to be allowed, I cant just ignore them) As of now I am using a SparseGraph ; put all nodes in the graph, draw sub/super relationships with directed, and duplicates as undirected edges between nodes. Then following the MinimumSpanningTreeDemo source code, I create a MinimumSpanningTreeForest2 object, and send the Forest to a TreeLayout . Long story short, I get the layouts however they are about 15000 pixels wide! Since I don't use these graphs in an interactive manner but rather as static images, this is simply not feasible for use in reports. I realized that the node labels take quite a bit of space if there are too many nodes that are side-by-side, so I figured that I could rotate the labels and have them vertical instead. This has failed miserably, I manage to rotate labels using a custom class that extends DefaultVertexLabelRenderer , but when I set rotation to Math.PI/2 then I simply see no labels! So here are my questions: Is it possible to force the layout to be slimmer? I would like to make something like a dendrogram, which is claimed to be possible using JUNG2 . Is this really possible? In that case how? Is there a miss in my thinking that it should be possible to render the node labels vertically? I tried to change the anchor point in the VertexLabelAsShapeRenderer class but still no joy. Speaking of matter; the connection between Renderer s RendererContext and the actual rendered objects is really fuzzy. There are a lot of classes and I'm having hard times figuring out which ones are actually used to render. For instance BasicVertexLabelRenderer seems like it's not used at all by default. Thus the whole positioning of labels is just mystical... I know that JUNG developers have put hours of hard work into the library and I would hate to sound bitter or unthankful, but I really think there's a long gap between this tutorial and figuring out how the demos are written and how the rendering works. In any case; here's the bit of my code where the graph is created: public void visualizeGraph(File saveFolder){ MinimumSpanningForest2 prim = new MinimumSpanningForest2 ( g, new DelegateForest (), DelegateTree. getFactory(), new ConstantTransformer(1.0)); Forest tree = prim.getForest(); Layout layout = new TreeLayout (tree); // custom visualization viewer that allows writing to disk final WritingVisualizationViewer vv = new WritingVisualizationViewer (layout,layout.getSize()); // this class extends VertexLabelAsShapeRenderer and supplies means of fiddling with label coordinates VerticalVertexLabelAsShapeRenderer vlasr = new VerticalVertexLabelAsShapeRenderer (vv.getRenderContext()); vv.getRenderContext().setVertexLabelTransformer( new ChainedTransformer (new Transformer[]{ new ToStringLabeller (),new Transformer () { public String transform(String input) { return input; }}})); // Change the background of node labels so that they appear transparent Transformer vertexPaint = new Transformer () { public Paint transform(PHGNode n) { return vv.getBackground(); } }; // extends DefaultVertexLabelRendeder to provide rotation of labels VerticalVertexLabelRenderer vvlr = new VerticalVertexLabelRenderer(); vv.getRenderContext().setVertexLabelRenderer(vvlr); vv.getRenderContext().setVertexFontTransformer(new VertexFontTransformer ()); vv.getRenderContext().setVertexShapeTransformer(vlasr); vv.getRenderContext().setVertexFillPaintTransformer(vertexPaint); vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.BentLine ()); vv.getRenderer().getVertexLabelRenderer().setPosition(Position.CNTR); //printGraphStats(tree); vv.writeToDisk(saveFolder,"hierarchyTree.png"); }
