[site]: stackoverflow
[post_id]: 4399856
[parent_id]: 
[tags]: 
Help me understand why find returns something different than end() on std::set when set is empty

why is the if-case true?! typedef std::set , HasFirstQueuedLongerTime> queued_container; queued_container::iterator itTemp = queued.find(spCall); queued_container::iterator itTempEnd = queued.end(); if(itTemp != itTempEnd ) // queued is an empty std::set and spCall is a shared pointer to an object. Since queued is empty the find function should return the iterator equal to queued.end() ... Im compiling and debugging on vs2005. I can see that itTemp and itTempEnd points to same address. Thankful for all answers! More code info, the following is declared before if-statement: queued_container queuedCalls; const boost::shared_ptr &spCall; //spCall is valid according to debug info. struct HasFirstQueuedLongerTime : std::binary_function , boost::shared_ptr , bool> { bool operator() (const boost::shared_ptr & lhs, const boost::shared_ptr & rhs) const { return lhs->CreatedTime() CreatedTime(); //returns true if lhs queued longer time than rhs } }; My real executable code: queued_container::iterator itTemp = queued.find(spCall); queued_container::iterator itTempEnd = queued.end(); if(itTemp != itTempEnd ) AS_ERROR(1, "XXX", "ERROR: Already added to queue container."); queued.insert(spCall); CCallQueue::insert(spCall); Ps. Sorry for many edits..
