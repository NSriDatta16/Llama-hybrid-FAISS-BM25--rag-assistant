[site]: stackoverflow
[post_id]: 1414874
[parent_id]: 1414360
[tags]: 
There's a good argument in your above example that since A is maintaining a reference to B, A should look after B, and not hand it out but manipulate it on your behalf. Otherwise you can argue that you're breaking encapsulation (since A reveals it has a reference to B), and ideally objects should do things for you , rather than export their contents such that you can manipulate them. Having said all that, the above is certainly not an uncommon practise and often a pragmatic choice. When you expose an object via get(), you have three options: expose the actual object make a defensive copy expose an object that wraps the original, but prohibits modification. e.g. you can wrap the original object in a restricted interface. See (for example) Collections.unmodifiableCollection() which wraps the original collection (and doesn't copy it) but provides an interface that doesn't permit modification. Whatever you do, you should document it in the interface (and hence in the Javadoc). Otherwise you're at liberty to change it later, and dependent code can easily break.
