[site]: stackoverflow
[post_id]: 2700004
[parent_id]: 2698842
[tags]: 
All reads on a TCP socket will return anywhere between 1 byte and the total amount sent depending on the buffer size of the buffer that you supply. What's likely happening is that the web server is sending the data as two separate writes and this happens to be being transmitted by the server's TCP stack as two separate blocks of data. Your read is completing because data has arrived. The read doesn't wait until all the data that you the programmer is expecting has arrived or even until your buffer is full. Network issues can further confuse matters as routers may fragment things and lost data may delay things whilst it's resent. Always when working with TCP you need to assume that your reads will always return just a single byte at a time and code accordingly; that way things will always work. You should just issue another read and you'll get the rest of the data when it has arrived. You might like to take a look at my free IOCP server framework (it does clients too) which can be found here ; it sounds like you already have things working but sometimes being able to look at a different way of doing things helps. When I need to accumulate data before processing I tend to take the following approach. Issue a read and wait for it to complete, look at what I have and, if I haven't got all I need and my buffer still has space in it, adjust the WSABUF that I'm using so that it points to the end of the current data that just arrived in the same buffer and issue another read; we then accumulate in the same buffer until either I have enough data to process it or I need to add another buffer on to get some more.
