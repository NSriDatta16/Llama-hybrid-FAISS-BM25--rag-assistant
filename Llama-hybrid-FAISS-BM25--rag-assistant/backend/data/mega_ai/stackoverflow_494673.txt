[site]: stackoverflow
[post_id]: 494673
[parent_id]: 489567
[tags]: 
(This is a continuation of the conversation from the comments to Evan's answer.) Here's what happens when your (corrected) regex is applied: First, the .+ matches the whole string. Then it backtracks, giving up most of the characters it just matched until it gets to the point where the B= can match. Then the (.+?) matches (and captures) everything it sees until the next part, the semicolon, can match. Then the final .+ gobbles up the remaining characters. All you're really interested in is the "B=" and the ";" and whatever's between them, so why match the rest of the string? The only reason you have to do that is so you can replace the whole string with the contents of the capturing group. But why bother doing that if you can access contents of the group directly? Here's a demonstration (in Java, because I can't tell what language you're using): String s = "A=abc;B=def_3%^123+-;C=123;"; Pattern p = Pattern.compile("B=(.*?);"); Matcher m = p.matcher(s); if (m.find()) { System.out.println(m.group(1)); } Why do a 'replace' when a 'find' is so much more straightforward? Probably because your API makes it easier; that's why we do it in Java. Java has several regex-oriented convenience methods in its String class: replaceAll() , replaceFirst() , split() , and matches() (which returns true iff the regex matches the whole string), but not find() . And there's no convenience method for accessing capturing groups, either. We can't match the elegance of Perl one-liners like this: print $1 if 'A=abc;B=def_3%^123+-;C=123;' =~ /B=(.*?);/; ...so we content ourselves with hacks like this: System.out.println("A=abc;B=def_3%^123+-;C=123;" .replaceFirst(".+B=(.*?);.+", "$1")); Just to be clear, I'm not saying not to use these hacks, or that there's anything wrong with Evan's answer--there isn't. I just think we should understand why we use them, and what trade-offs we're making when we do.
