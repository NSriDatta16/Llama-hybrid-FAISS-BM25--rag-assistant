[site]: stackoverflow
[post_id]: 1382380
[parent_id]: 1382322
[tags]: 
Update: read through to the end. It looks like the lookup table is faster than Math.Sin after all. I would guess that the lookup approach would be faster than Math.Sin. I would also say that it would be a lot faster, but Robert's answer made me think that I would still want to benchmark this to be sure. I do a lot of audio buffer processing, and I've noticed that a method like this: for (int i = 0; i will execute significantly faster than for (int i = 0; i If the difference between Math.Sin and a simple multiplication is substantial, I would guess that the difference between Math.Sin and a lookup would also be substantial. I don't know, though, and my computer with Visual Studio is in the basement, and I'm too tired to take the 2 minutes it would take to determine this. Update : OK, it took more than 2 minutes (more like 20) to test this, but it looks like Math.Sin is at least twice as fast as a lookup table (using a Dictionary). Here's the class that does Sin using Math.Sin or a lookup table: public class SinBuddy { private Dictionary _cachedSins = new Dictionary (); private const double _cacheStep = 0.01; private double _factor = Math.PI / 180.0; public SinBuddy() { for (double angleDegrees = 0; angleDegrees And here's the test/timing code: SinBuddy buddy = new SinBuddy(); System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch(); int loops = 200; // Math.Sin timer.Start(); for (int i = 0; i Using a step value of 0.01 degrees and looping through the full range of values 200 times (as in this code) takes about 1.4 seconds using Math.Sin, and about 3.2 seconds using a Dictionary lookup table. Lowering the step value to 0.001 or 0.0001 makes the lookup perform even worse against Math.Sin. Also, this result is even more in favor of using Math.Sin, since SinBuddy.Sin does a multiplication to turn the angle in degrees into the angle in radians on every call, while SinBuddy.SinLookup just does a straight lookup. This is on a cheap laptop (no dual cores or anything fancy). Robert, you da man! (But I still think I should get the check, coz I did the work). Update 2 : It turns out stopping and restarting the Stopwatch doesn't reset the elapsed milliseconds, so the lookup only seemed half as fast because it's time was including the time for the Math.Sin calls. Also, I reread the question and realized you were talking about caching the values in a simple array, rather than using a Dictionary. Here is my modified code (I'm leaving the old code up as a warning to future generations): public class SinBuddy { private Dictionary _cachedSins = new Dictionary (); private const double _cacheStep = 0.01; private double _factor = Math.PI / 180.0; private double[] _arrayedSins; public SinBuddy() { // set up dictionary for (double angleDegrees = 0; angleDegrees And the test/timing code: SinBuddy buddy = new SinBuddy(); System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch(); int loops = 200; // Math.Sin timer.Start(); for (int i = 0; i These results are quite different. Using Math.Sin takes about 850 milliseconds, the Dictionary lookup table takes about 1300 milliseconds, and the array-based lookup table takes about 600 milliseconds. So it appears that a (properly-written [gulp]) lookup table is actually a bit faster than using Math.Sin , but not by much. Please verify these results yourself, since I have already demonstrated my incompetence.
