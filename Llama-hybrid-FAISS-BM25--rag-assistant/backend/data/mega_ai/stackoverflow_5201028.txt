[site]: stackoverflow
[post_id]: 5201028
[parent_id]: 5200418
[tags]: 
At this point in time, the OpenMP specification doesn't give the user any ability to control when threads are destroyed. What you are saying is very interesting and hasn't been brought up during any of the OpenMP language committee meetings to discuss the specification. Can you give more information about what you are doing and what the problem is? It would be helpful in bringing this discussion to the committee. Edit added 3/7 - Okay - here is a simple example that seems to work and it might get around your problem: $> cat prog.c #include #include #include int main(void) { void (*f)(void); void *handle; handle = dlopen("./shared.so", RTLD_NOW); if (!handle) { printf("*** dlopen error - %s\n", dlerror()); abort(); } f = dlsym(handle, "foo"); if (!f) { printf("*** dlsym error - %s\n", dlerror()); abort(); } f(); if(dlclose(handle)) { printf("*** dlclose error - %s\n", dlerror()); abort(); } return 0; } $> cat shared.c #include #include void foo(void) { int i; puts("... in foo\n"); #pragma omp parallel for for (i=0; i gcc -rdynamic -fopenmp prog.c -ldl -o prog $> gcc -c -fopenmp -fPIC -o shared.o shared.c $> ld -shared -o shared.so shared.o $> ./prog ... in foo t#: 2 i: 4 t#: 2 i: 5 t#: 3 i: 6 t#: 3 i: 7 t#: 0 i: 0 t#: 0 i: 1 t#: 4 i: 8 t#: 4 i: 9 t#: 1 i: 2 t#: 1 i: 3 ... exiting foo While there is no OpenMP code in the main program (prog.c), I compiled it using the -fopenmp flag. This means that the OpenMP environment will be set up before the call to the shared library that is actually using OpenMP. This seems to get around the problem with doing a dlclose, since the environment is still there. It also allows the threads gotten by the first use of OpenMP to stay around for subsequent use. Does this work for getting around your problem (or does this only work for this simple example)?
