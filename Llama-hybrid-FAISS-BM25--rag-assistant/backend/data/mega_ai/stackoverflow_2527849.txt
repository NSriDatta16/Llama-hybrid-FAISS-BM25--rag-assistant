[site]: stackoverflow
[post_id]: 2527849
[parent_id]: 1380015
[tags]: 
I was stuck with the exact same problem. I had class Bar : IFin // IFin is interface { } Passing List to a function that expected List proved to be a headache (cannot understand why.. after all Bar is implementing all in IFin!!). I ended up using the List<>.ConvertAll with the convert function as below: public static IFin ToIFin(Bar_bar) { return (IFin)_bar; } I know I sometimes miss some very obvious things but to me jumping though that hoop looked stupid. I know this is not elegant and it does generate a complete list of IFin again but atleast the new list still holds my original Bar objects (that I did verify).
