[site]: stackoverflow
[post_id]: 2125045
[parent_id]: 2123514
[tags]: 
forward / sendRedirect / sendError do NOT exit the method! A common misunderstanding among starters is that they think that the call of a forward() , sendRedirect() , or sendError() method would magically exit and "jump" out of the method block, hereby ignoring the remnant of the code. For example in a servlet: protected void doXxx(...) { if (someCondition) { response.sendRedirect(...); } dispatcher.forward(...); // This is STILL invoked when someCondition is true! } Or in a filter: public void doFilter(...) { if (someCondition) { response.sendRedirect(...); } chain.doFilter(...); // This is STILL invoked when someCondition is true! } This is thus actually not true. They do certainly not behave differently than any other Java methods (expect of System#exit() of course). When the someCondition in above example is true and you're thus calling forward() or doFilter() after sendRedirect() or sendError() on the same request/response, then the chance is big that you will get the exception: java.lang.IllegalStateException: Cannot forward after response has been committed This also applies to the inverse condition. If the if statement calls a forward() and you're afterwards calling sendRedirect() or sendError() , then below exception can be thrown: java.lang.IllegalStateException: Cannot call sendRedirect() after the response has been committed To fix this, you need either to add a return; statement afterwards protected void doXxx(...) { if (someCondition) { response.sendRedirect(...); return; } dispatcher.forward(...); } ... or to introduce an else block. protected void doXxx(...) { if (someCondition) { response.sendRedirect(....); } else { dispatcher.forward(...); } } To naildown the root cause in your code, just search for any line which calls a forward() , sendRedirect() or sendError() without exiting the method block or skipping the remnant of the code. This can be inside the same servlet before the particular code line, but also in any servlet or filter which was been called before the particular servlet. In case of sendError() , if your sole purpose is to set the response status, use setStatus() instead. Do not write any string before forward / sendRedirect / sendError Another probable cause is that the servlet writes to the response while a forward() will be called, or has been called in the very same method. protected void doXxx() { out.write(" some html "); // ... dispatcher.forward(); // Fail! } The response buffer size defaults in most server to 2KB, so if you write more than 2KB to it, then it will be committed and forward() will fail the same way: java.lang.IllegalStateException: Cannot forward after response has been committed Solution is obvious, just don't write to the response in the servlet. That's the responsibility of the JSP. You just set a request attribute like so request.setAttribute("data", "some string") and then print it in JSP like so ${data} . See also our Servlets wiki page to learn how to use Servlets the right way. Do not write any file before forward / sendRedirect / sendError Another probable cause is that the servlet writes a file download to the response after which e.g. a forward() is called. protected void doXxx() { out.write(bytes); // ... dispatcher.forward(); // Fail! } This is technically not possible. You need to remove the forward() call. The enduser will stay on the currently opened page. If you actually intend to change the page after a file download, then you need to move the file download logic to page load of the target page. Basically: first create a temporary file on disk using the way mentioned in this answer How to save generated file temporarily in servlet based web application , then send a redirect with the file name/identifier as request param, and in the target page conditionally print based on the presence of that request param a window.location='...'; which immediately downloads the temporary file via one of the ways mentioned in this answer Simplest way to serve static data from outside the application server in a Java web application . Do not call forward / sendRedirect / sendError in JSP Yet another probable cause is that the forward() , sendRedirect() or sendError() methods are invoked via Java code embedded in a JSP file in form of old fashioned way , a practice which was officially discouraged since 2003 . For example: ... ... ... The problem here is that JSP internally immediately writes template text (i.e. HTML code) via out.write(" ... etc ...") as soon as it's encountered. This is thus essentially the same problem as explained in previous section. Solution is obvious, just don't write Java code in a JSP file. That's the responsibility of a normal Java class such as a Servlet or a Filter. See also our Servlets wiki page to learn how to use Servlets the right way. See also: What exactly does "Response already committed" mean? How to handle exceptions then? Unrelated to your concrete problem, your JDBC code is leaking resources. Fix that as well. For hints, see also How often should Connection, Statement and ResultSet be closed in JDBC?
