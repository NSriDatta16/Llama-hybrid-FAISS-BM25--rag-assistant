[site]: stackoverflow
[post_id]: 5323810
[parent_id]: 5323733
[tags]: 
It's getting around the major problem of things like: #define max(a,b) ((a) > (b) ? a : b) When you call it with expressions that have side effects beyond simple evaluation of the value, things may not act as you think. Consider the code: int x = max (a++, b--); Since macros are a simple text substitution, that results in the following translation: int x = ((a++) > (b--) ? a++ : b--); This is almost certainly not what you want, as it will either increment a or decrement b twice, depending on their relative values. However, consider the effects if we instead use: #define max(a,b) ({ \ typeof (a) _a = (a); \ typeof (b) _b = (b); \ _a > _b ? _a : _b; \ }) In that case, it uses temporary variables that effectively translate to: int x = ({ int _a = a++; int _b = b--; _a > _b ? _a : _b; }) This runs the side effects only once. But, to be honest, you should ditch that macro altogether and use an inline function, or even a non-inline function since, most of the time, the compiler can do a decent job of optimisation even without that suggestion. Two of the use-cases for macros in early C were function-like macros (such as the one in your question) and defining constants for related use (such as error codes). The former is best handled with inline functions (1) , the latter with enumerations. Nowadays, I generally limit my use of macros to very simple definitions used only by the pre-processor, such as deciding whether to include b-tree or red-black tree headers for internal storage in a library. Even things like "number of sectors per track" are often best done as a const int rather than a #define . (1) Keep in mind that inline is a suggestion whereas a function-like macro is guaranteed to be inline. However, I've found the compiler can usually make a better determination (than the developer) as to whether or not to follow that suggestion.
