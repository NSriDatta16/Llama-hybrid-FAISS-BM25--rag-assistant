[site]: stackoverflow
[post_id]: 4227279
[parent_id]: 4217078
[tags]: 
The trivial answer is to find the number of days in the month and then multiply by 86400. That will work perfectly if you are dealing with dates and times in UTC. However, if you are using a local time zone then this approach yields a slightly incorrect result if that time zone observes daylight saving time. The error is somewhat small over a one month period, but will magnify if you need to make similiar calculation over short periods like a day. I definitely recommend doing all processing and storage in UTC, but depending on the application you will have to convert your UTC times to the local time zone that the end user is expecting. And it might even be plausible that you have to calculate durations using the local time zone. Again, use UTC as much as possible so that you avoid most of the problems. I came up with this solution in C#. It is compatible with UTC and local time zones alike. You just have to tell the GetNumberOfSecondsInMonth which time zone you want the calculation to be based on. In my example I chose November of 2010 because here in Missouri we observe DST and there was one extra hour this month. Daylight saving time rules change so I used an API that pulls the DST information from the operating system so that the calculation will be correct for years prior to 2007 (that is when the United States expanded DST for most regions). I should point out that my solution does not handle leap seconds in UTC. For me that is never an issue. But it would be easy to account for that by using a lookup table if you really needed ultra high precision timing. public class Program { static void Main(string[] args) { int seconds = GetNumberOfSecondsInMonth(2010, 11, DateTimeKind.Local); } public static int GetNumberOfSecondsInMonth(int year, int month, DateTimeKind kind) { DateTime start = new DateTime(year, month, 1); DateTime end = start.AddMonths(1); int seconds = (int)(end - start).TotalSeconds; if (kind == DateTimeKind.Local) { DaylightTime dt = TimeZone.CurrentTimeZone.GetDaylightChanges(year); seconds = (dt.Start > start) ? seconds - 3600 : seconds; seconds = (dt.End
