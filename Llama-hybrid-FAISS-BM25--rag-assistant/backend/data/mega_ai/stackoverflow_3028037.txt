[site]: stackoverflow
[post_id]: 3028037
[parent_id]: 152975
[tags]: 
You can listen for a click event on document and then make sure #menucontainer is not an ancestor or the target of the clicked element by using .closest() . If it is not, then the clicked element is outside of the #menucontainer and you can safely hide it. $(document).click(function(event) { var $target = $(event.target); if(!$target.closest('#menucontainer').length && $('#menucontainer').is(":visible")) { $('#menucontainer').hide(); } }); Edit – 2017-06-23 You can also clean up after the event listener if you plan to dismiss the menu and want to stop listening for events. This function will clean up only the newly created listener, preserving any other click listeners on document . With ES2015 syntax: export function hideOnClickOutside(selector) { const outsideClickListener = (event) => { const $target = $(event.target); if (!$target.closest(selector).length && $(selector).is(':visible')) { $(selector).hide(); removeClickListener(); } } const removeClickListener = () => { document.removeEventListener('click', outsideClickListener); } document.addEventListener('click', outsideClickListener); } Edit – 2018-03-11 For those who don't want to use jQuery. Here's the above code in plain vanillaJS (ECMAScript6). function hideOnClickOutside(element) { const outsideClickListener = event => { if (!element.contains(event.target) && isVisible(element)) { // or use: event.target.closest(selector) === null element.style.display = 'none'; removeClickListener(); } } const removeClickListener = () => { document.removeEventListener('click', outsideClickListener); } document.addEventListener('click', outsideClickListener); } const isVisible = elem => !!elem && !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length ); // source (2018-03-11): https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js NOTE: This is based on Alex comment to just use !element.contains(event.target) instead of the jQuery part. But element.closest() is now also available in all major browsers (the W3C version differs a bit from the jQuery one). Polyfills can be found here: Element.closest() Edit – 2020-05-21 In the case where you want the user to be able to click-and-drag inside the element, then release the mouse outside the element, without closing the element: ... let lastMouseDownX = 0; let lastMouseDownY = 0; let lastMouseDownWasOutside = false; const mouseDownListener = (event: MouseEvent) => { lastMouseDownX = event.offsetX; lastMouseDownY = event.offsetY; lastMouseDownWasOutside = !$(event.target).closest(element).length; } document.addEventListener('mousedown', mouseDownListener); And in outsideClickListener : const outsideClickListener = event => { const deltaX = event.offsetX - lastMouseDownX; const deltaY = event.offsetY - lastMouseDownY; const distSq = (deltaX * deltaX) + (deltaY * deltaY); const isDrag = distSq > 3; const isDragException = isDrag && !lastMouseDownWasOutside; if (!element.contains(event.target) && isVisible(element) && !isDragException) { // or use: event.target.closest(selector) === null element.style.display = 'none'; removeClickListener(); document.removeEventListener('mousedown', mouseDownListener); // Or add this line to removeClickListener() } }
