[site]: stackoverflow
[post_id]: 4454305
[parent_id]: 4453112
[tags]: 
Answer updated, please scroll down public class SidTest { // 1. How to create a new Lead programatically on Force.com (in Apex) /* This method is marked as test method, meaning that you can use it to run tests but in the end no data will be saved (transaction rollback). You'll need similar code in a class that intercepts messages from Twilio. */ public static testMethod void insertLead(){ Lead l = new Lead(FirstName='Test', LastName='Lead', Email='example@example.com', Company='test', NumberofEmployees=7); insert l; // 2. How do I test the TwilioForce components, especially those I've changed to reflect my client's Twilio phone number and token? /* Not sure what do you mean, but most likely by writing test classes like this one and checking their test code coverage. See also http://stackoverflow.com/questions/4372202/how-to-unit-test-works-in-salesforce/4381941 Below sample test that checks if our insert above succeeded. You can run it from Eclipse (preferred) or Salesforce GUI in Setup->Develop->Apex classes. */ Lead[] leads = [SELECT Name, Email FROM Lead WHERE Name = 'Test Lead']; System.debug(leads); // if you want to see results in detailed debug log System.assertEquals(1, leads.size()); System.assertEquals('example@example.com', leads[0].Email); } } Here's the outcome when you'll run it in Eclipse: http://dl.dropbox.com/u/709568/stackoverflow/Sid.png As for last question: when you'll be happy with functionality tested in your Developer Edition, you should ask client to grant you access to "Sandbox" of his organisation. You can create in Eclipse a new project pointing to this sandbox and simply create all classes in it, run tests with a subset of real data etc. Finally you or somebody from client's side will perform a deployment to "production" environment where stuff like code coverage in automated tests will start to matter. Alternatively you could create a package with your code and sell it on AppExchange like a plugin to Salesforce that anybody can download to their organisation. You can charge for it of course. But this looks like a too big jump for now... Hope this can get you started. Update: Here's a quick & dirty class based on TestCallsXmlParser that's included in code package you are using: public class TestCallsXmlParser{ @isTest public static void TestCallsXmlParserMethod1(){ CallsXmlParser callxml = new CallsXmlParser(); String xmlData = ' CA42ed11f93dc08b952027ffbc406d0868 Sat, 07 Feb 2009 13:15:19 -0800 Sat, 07 Feb 2009 13:15:19 -0800 '; xmlData = xmlData + ' AC309475e5fede1b49e100272a8640f438 4159633717 4156767925 PN01234567890123456789012345678900 2 Thu, 03 Apr 2008 04:36:33 -0400 Thu, 03 Apr 2008 04:36:47 -0400 '; xmlData = xmlData + ' 14 1 '; xmlData = xmlData + ' CA751e8fa0a0105cf26a0d7a9775fb4bfb Sat, 07 Feb 2009 13:15:19 -0800 Sat, 07 Feb 2009 13:15:19 -0800 '; xmlData = xmlData + ' AC309475e5fede1b49e100272a8640f438 2064287985 4156767925 PNd59c2ba27ef48264773edb90476d1674 2 '; xmlData = xmlData + ' Thu, 03 Apr 2008 01:37:05 -0400 Thu, 03 Apr 2008 01:37:40 -0400 35 1 '; CallsXmlParser callxml1 = new CallsXmlParser(xmlData); // eyescream's modification starts here // list to store our leads and bulk save them in blocks up to 100 records at 1 insert List leads = new List (); for(CallsXmlParser.Call c : callxml1.listRecords) { System.debug('2 new Leads will be created from phone numbers: ' + c.Caller + ', ' + c.Called); leads.add(new Lead(MobilePhone = c.Caller, Company='x', LastName='x')); // Company & Last Name are mandatory fields leads.add(new Lead(MobilePhone = c.Called, Company='y', LastName='y')); // without them insert will fail. if(leads.size() == 100) { // 100 is the limit of records saved at once. Inserting in batches speeds up execution. insert leads; leads.clear(); } } // If we have any leftovers, we'll insert them too. if(leads.size() > 0) { insert leads; leads.clear(); } } } Of course you can improve it further, check for duplicates, fill with real names etc... but that's roughly how you can use parsed results. I don't think that parsing the XML yourself would be a good option... Your question suggests that more fields will come in the XML (or existing ones will be used to store different data) but probably you'll be able to expand the parser accordingly.
