[site]: stackoverflow
[post_id]: 3429996
[parent_id]: 3378508
[tags]: 
I've done code shredding before. The closest thing you could get is to write one (As far as I know). Using a static analysis API, you could parse your source code, and then based off on the code in each header file organize all files in a corresponding .c file. A company called SciTools ships a source code analyzer called 'understand 4 c++' that has a C API that makes this pretty easy. But you would probably have to write the tool yourself. As it is, I wrote a managed API that sits on top of their C API. My managed is found on codeplex here: http://understandapi.codeplex.com/ Here is how I would structure the program. First you have to create a database of all your source code. You can do this using a batch script if you want, or a powershell script, or you can manually do it yourself. It's usually as simple as pointing to a directory and in effect saying 'make a database of all the files in there'. You can determine if you want *.c, *.h, or *.cpp files in your database. Then using the API you can browse all files with the .h file extension. For each header file, you verify there is a corresponding .c file. This is done by taking a string of the filename, replacing the file extension (.NET makes this easy), and checking if the file exists. If it does exist, then on to the next step. Then the program should iterate through all defined entities in the .h file. For each entity, it then finds a reference to it's definition (not declaration), and see's if it exists in the corresponding .c file. If it's there, it finds the line numbers of the code definition, and opens the file for reading, and reads the necessary lines of code (and comments too) and writes them out to a temporary file. When completed, overwrite the .c file with the temporary file. Proceed to the rest of the files in the database. Now it's not that easy. You may run into trouble along the way in the form of: 1. Conditionally compiled code, in which case it will make it harder to parse, though it's possible. Understand 4 c++ does parse conditional compilation directives and differentiates between inactive and active code. But just handling this would make it really difficult. 2. Namespaces - This would complicate matters. However if you are only interested in organizing code between certain #pragma directives than it could simplify matters again. Let me know if you are interested more, and we an talk offline privately.
