[site]: stackoverflow
[post_id]: 5175127
[parent_id]: 5171617
[tags]: 
If you use "formatter": "InterFinalPriceFormatter" you don't set the value of "formatter" property to the function . One way to fix the problem is to loop through result.colModelList and verify that one use "formatter" property with some string value for which you has implementation as the function in the JavaScript. Then you can overwrite the property with the value of the corresponding formatter function. Another way will be use inline functions in the formatter: "formatter": "function (cellValue, opts, rowObject) { return cellValue + \"Testing price formatter\"; }" In the way you will be not has clear separation of the code and the grid parameters, but you receive some encapsulation of the formatter inside the grid. UPDATED : I hope that the next code fragment (untested) could make clear what I mean under the first implementation way var functionsMapping = { // here we define the implementations of the custom formatter which we use "CouponFormatter": function (cellValue, opts, rowObject) { return cellValue + "Testing coupon formatter"; }, "InterFinalPriceFormatter": function (cellValue, opts, rowObject) { return cellValue + "Testing price formatter"; } }; $.ajax({ type: "POST", url: "interFinalTbaAction.action", data: "", dataType: "json", success: function(result) { var i, cm, colD = result.couponStripList, colN = result.columnNames, colM = result.colModelList; for (i=0;i UPDATED 2: It would be better to register the custom formatters and unformatters as standard formatters like it's described in the old answer or in answer one . After that one can really use the syntax like "formatter": "InterFinalPriceFormatter" and the custom defined functions $.fn.fmatter.InterFinalPriceFormatter and $.fn.fmatter.InterFinalPriceFormatter.unformat will be automatically called by jqGrid.
