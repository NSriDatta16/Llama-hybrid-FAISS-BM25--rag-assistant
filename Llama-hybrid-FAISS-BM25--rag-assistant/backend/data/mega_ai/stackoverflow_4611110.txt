[site]: stackoverflow
[post_id]: 4611110
[parent_id]: 2211915
[tags]: 
@ Charles Bailey above: I could be wrong, but I think the first two algorithms above does not remove duplicates between first and mid? Maybe I am not sure how to use it. 4 choose 2 example: 12 34 12 43 (after sort) 13 24 (after next_permutation) 13 42 (after sort) 14 23 (after next_permutation) 14 32 (after sort) 21 34 (after next_permutation) So I added a check to see if the value in italics is in order before returning, but definitely wouldn't have thought of the part you wrote though (very elegant! thanks!). Not fully tested, just cursory tests.. template bool next_combination(RandIt first, RandIt mid, RandIt last) { typedef typename std::iterator_traits ::value_type value_type; std::sort(mid, last, std::greater () ); while(std::next_permutation(first, last)){ if(std::adjacent_find(first, mid, std::greater () ) == mid){ return true; } std::sort(mid, last, std::greater () ); return false; }
