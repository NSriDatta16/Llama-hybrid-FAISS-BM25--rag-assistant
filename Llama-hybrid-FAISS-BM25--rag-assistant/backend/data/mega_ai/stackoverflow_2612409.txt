[site]: stackoverflow
[post_id]: 2612409
[parent_id]: 2611699
[tags]: 
Based on your updates, your real problem is this: You want to know how to initialize the strings in your array of structs in such a way that they're editable. (The problem has nothing to do with what happens after the array of structs is created -- as you show with your example code, editing the strings is easy enough if they're initialized correctly.) The following code sample shows how to do this: // Allocate the memory for the strings, on the stack so they'll be editable, and // initialize them: char ptn1[] = "\x32\x33\x12\x13\xba\xbb\x9a\xbc"; char ptn2[] = "\x12\x34\x56\x78"; // Now, initialize the structs with their char* pointers pointing at the editable // strings: ENTRY Entries[] = { {ptn1, 44} , {ptn2, 555} }; That should work fine. However, note that the memory for the strings is on the stack, and thus will go away if you leave the current scope. That's not a problem if Entries is on the stack too (as it is in this example), of course, since it will go away at the same time. Some Q/A on this: Q: Why can't we initialize the strings in the array-of-structs initialization? A: Because the strings themselves are not in the structs, and initializing the array only allocates the memory for the array itself, not for things it points to. Q: Can we include the strings in the structs, then? A: No; the structs have to have a constant size, and the strings don't have constant size. Q: This does save memory over having a string literal and then malloc'ing storage and copying the string literal into it, thus resulting in two copies of the string, right? A: Probably not. When you write char pattern[] = "\x12\x34\x56\x78"; what happens is that that literal value gets embedded in your compiled code (just like a string literal, basically), and then when that line is executed, the memory is allocated on the stack and the value from the code is copied into that memory. So you end up with two copies regardless -- the non-editable version in the source code (which has to be there because it's where the initial value comes from), and the editable version elsewhere in memory. This is really mostly about what's simple in the source code, and a little bit about helping the compiler optimize the instructions it uses to do the copying.
