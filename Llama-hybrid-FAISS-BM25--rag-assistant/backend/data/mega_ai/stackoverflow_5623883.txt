[site]: stackoverflow
[post_id]: 5623883
[parent_id]: 5621081
[tags]: 
I think your byte-coding idea is the right direction. What I would do, regardless of language, is write a precompiler. It would walk each tree, and use print statements to translate it into source code, such as. ((word&1) && ((word&2) || ((word&4) && (word&8)))) That can be compiled on the fly whenever the trees change, and the resulting byte code / dll loaded, all of which takes under a second. The thing is, at present you are interpreting the contents of the trees. Turning them into compiled code should make them run 10-100 times faster. ADDED in response to your comments on not having the JDK. Then, if you can't generate Java byte code, I would try to write my own byte-code interpreter than would run as fast as possible. It could look something like this: while(iop The idea is to cause the compiler to turn the switch into a jump table, so it performs each operation with the smallest number of cycles. To generate the opcodes, you can just do a postfix walk of the tree. On top of that, you might be able to simplify it by some manipulation of De Morgan's laws, so you could check more than one bit at a time.
