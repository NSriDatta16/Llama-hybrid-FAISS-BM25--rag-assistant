[site]: stackoverflow
[post_id]: 2962799
[parent_id]: 2961986
[tags]: 
A few years back, I spent some time trying to optimize functional quicksort as far as I could. The following is what I came up with for vanilla List[A] : def qsort[A : Ordering](ls: List[A]) = { import Ordered._ def sort(ls: List[A])(parent: List[A]): List[A] = { if (ls.size { if (e I was able to do even better with a custom List structure. This custom structure basically tracked the ideal (or nearly ideal) pivot point for the list. Thus, I could obtain a far better pivot point in constant time, simply by accessing this special list property. In practice, this did quite a bit better than the standard functional approach of choosing the head. As it is, the above is still pretty snappy. It's "half" tail recursive (you can't do a tail-recursive quicksort without getting really ugly). More importantly, it rebuilds from the tail end first, so that results in substantially fewer intermediate lists than the conventional approach. It's important to note that this is not the most elegant or most idiomatic way to do quicksort in Scala, it just happens to work very well. You will probably have more success writing merge sort, which is usually a much faster algorithm when implemented in functional languages (not to mention much cleaner).
