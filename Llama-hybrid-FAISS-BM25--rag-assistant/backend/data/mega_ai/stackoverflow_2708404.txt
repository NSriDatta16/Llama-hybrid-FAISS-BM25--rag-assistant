[site]: stackoverflow
[post_id]: 2708404
[parent_id]: 2707923
[tags]: 
Based on the answer I got, and my initial hack, I came up with this general solution using boost::aligned_storage . Basically a void type, but for structures. class Gordian { public: int member; Gordian(int must_have_variable) : member(must_have_variable) {} }; template struct VoidWrap { boost::aligned_storage storage; T* address() { return reinterpret_cast (storage.address()); } }; class Knot { public: VoidWrap void_gordian[8]; Knot() { for (int x = 0; x != 8; x++) { new (void_gordian[x].address()) Gordian(x*x); } } }; Or, an expanded version specifically for the use case of 1) Initializing in the constructur of the object containing it. 2) Accessing. 3) Possibly re-assigning the value. 4) Proper automatic destruction. (Of course, it can blow up if it is destroyed/accessed without being initialized) template struct VoidWrap { boost::aligned_storage storage; /// Returns an address on which to construct the object. Use only once. T* construct() { return access(); } /// access should only be called on a `construct`ed object /// obj.access() is equivalent to &obj T* access() { return reinterpret_cast (this); } /// Assumes the object has been constructed. Calls the destructor on the old /// object, then returns an address on which to construct a new object. T* reconstruct() { access()->~T(); return access(); } ~VoidWrap() { access()->~T(); } }; VoidWrap void_g; new (void_g.construct()) Gordian(10); cout member
