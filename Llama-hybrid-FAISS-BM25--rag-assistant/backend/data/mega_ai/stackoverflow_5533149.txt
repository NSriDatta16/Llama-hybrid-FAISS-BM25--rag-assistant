[site]: stackoverflow
[post_id]: 5533149
[parent_id]: 5531827
[tags]: 
I think that an easier algorithm is Pick a random point inside the [-1,1]x[-1,1]x[-1,1] cube If x*x + y*y + z*z > 1 repeat from 1 Normalize dividing x , y and z by Math.sqrt(x*x + y*y + z*z) in other words just pick a random point inside the sphere and project on the sphere. Don't worry too much about the "loop" because the probability of a point being outside the sphere is about 0.4764 and on average the loop will require less than two iterations. You can see this algorithm in action on this link . Note that if you use chrome there will be some banding around an equator that in my opinion is a bug in Math.random or just a low quality random generator (works fine on Firefox or Safari, but the same problem is visible also on Android browser). The banding is much more visible with an higher number of points (e.g. 10000 instead of the 1000 points I'm using now to keep animation smooth). EDIT: This bug has now been fixed on chrome and Android. Note that if you're looking for a method to distribute points evenly over a sphere you can do something nicer by choosing ten random points as described above and then accepting only the one with the biggest 3d distance from the set of already chosen points. This is still globally random (i.e. the probablity that a disc with a prescribed radius will receive a point is the same for all discs on the sphere) but will distribute points better if you need to do a "sampling" of the sphere. This function is coded as spreadPoints() in the html file pointed by the link. You can see the difference between the two approaches here: Both spheres have 1000 random points drawn on them: the sphere on the left used uniform random points, the sphere on the right instead made the choice by picking each point among ten random candidates to maximize the distance from already chosen points.
