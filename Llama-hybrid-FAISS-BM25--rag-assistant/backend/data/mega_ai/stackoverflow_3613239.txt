[site]: stackoverflow
[post_id]: 3613239
[parent_id]: 3613120
[tags]: 
It is almost always a mistake to implement your own. Small unique numbers require a really reliable recording of the last used number. That is hard to come by, hard disks have head crashes, registries get corrupted occasionally. You'll need to organize it so there is a single point of failure. Similar to a dbase's auto-incrementing column. Make sure if there's a loss of the last number, there is also complete loss of data. That means, for one, that there shouldn't be a way for the user to copy the data without also copying the record of the last number. Or that you always have a reliable copy of all the data and can recover the last number from it. Quickly. You'll also have a hard time ensuring that the number is incremented atomically. Just starting two instances of your program is typically enough to cause mayhem. Fixing that is tricky, you'll need an independent arbiter process that stores the number. Then there's the burden of having to guess what's going to happen 10 or 20 years from now. Will your app scale to meet the demands by then? That's very rare, counting on machines getting faster is over and done with. What's a local unique number now needs to becomes a globally unique number. Very different kind of demands on that. Don't screw around with this, 16 bytes is nothing. Use a Guid.
