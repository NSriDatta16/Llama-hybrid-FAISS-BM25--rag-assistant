[site]: stackoverflow
[post_id]: 4414801
[parent_id]: 4413152
[tags]: 
This is something I threw together in a few minutes just as I was leaving work, then recreated after a glass of wine after dinner: sample = [231, 8143, 16341, 2000, -9352] new_sample = [] sample.zip([] * sample.size).each_cons(2) do |a,b| a[1] = (a[0] + b[0]).to_f / 2 # [231, 4187.0, 8143, 12242.0, 16341, 9170.5, 2000, 2000] I think it's a start but obviously not finished since the -9352 didn't propagate into the final array. I didn't bother converting floats to ints; I figure you know how to do that. :-) I'd like to find a better way to iterate over each_cons . I'd rather use a map than each* but this works OK. Here's what the loop iterates over: asdf = sample.zip([] * sample.size).each_cons(2).to_a asdf # => [[[231, nil], [8143, nil]], [[8143, nil], [16341, nil]], [[16341, nil], [2000, nil]], [[2000, nil], [-9352, nil]]] each_cons is nice because it steps through the array returning slices of it, which seemed like a useful way to build up the averages. [0,1,2,3].each_cons(2).to_a # => [[0, 1], [1, 2], [2, 3]] EDIT: I like this better: sample = [231, 8143, 16341, 2000, -9352] samples = sample.zip([] * sample.size).each_cons(2).to_a new_sample = samples.map { |a,b| a[1] = (a[0] + b[0]).to_f / 2 a }.flatten new_sample [231, 4187.0, 8143, 12242.0, 16341, 9170.5, 2000, -3676.0, -9352]
