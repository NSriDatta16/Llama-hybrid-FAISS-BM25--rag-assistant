[site]: stackoverflow
[post_id]: 612780
[parent_id]: 611296
[tags]: 
I think you'll find that using JNI is not as daunting as it seems prior to diving in. There are some important trade-offs and limitations but in general JNI works well and is reasonably easy to leverage as you intend. As other have said the best case for JNI is: Complex native code (bonus points if that code has already proven very reliable) Minimal back-and-forth between Java and native code (you want to minimize the trips across the JNI layer) Reasonably simple calling interface to the native code (or also back to Java if you're native code needs to leverage Java objects/methods) It is definitely possible to automate or pseudo-automate the creation of a JNI layer for a reasonably structured set of native components. That would be well worth it if the number of components to wrap is large. The good news with JNI is that it should be straightforward for you to build and test this interface, for example you should be able to write test cases from Java that exploit existing algorithm behavior and if there are problems they would most likely be in the JNI layer itself and not the algorithms (given your confidence in the native implementation). Rewriting a large number of C/C++ algorithms in Java seems much more risky to me than using JNI. Without knowing the details it is hard to gauge, of course, but there are subtle differences between the technologies that I could imagine impacting the actual implementation of an algorithm, not to mention just the sheer engineering effort and risk of error. A final consideration is future life of these algorithms or related components. Is the set of algorithms more or less complete, or are you continuing to add? Either way, is there a strong maintenance and/or future development reason to favor one technology over the other? For example, if everything else is in Java and all new algorithms will be in Java and almost everyone on the team is almost always coding in Java, reimplementing in Java starts to look more attractive long-term. However even with that said, working trumps consistent. For a large number of well-functioning native components I would still be inclined to start with JNI even if you were going to transition to Java long-term.
