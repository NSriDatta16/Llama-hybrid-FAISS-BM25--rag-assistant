[site]: stackoverflow
[post_id]: 2906806
[parent_id]: 2906672
[tags]: 
For a possibly 'more elegant' solution see Solution 2. Solution 1) Why don't you create all the possible 300*300/2 or (300*299/2) possible exact values of R, sort them into an array B say, and then given an R, find the closest value to R in B using binary search and then pick the corresponding X and Y. I presume that having array B (with the X&Y info) won't be a big memory hog and can easily be hardcoded (using code to write code! :-)). This will be reasonably fast: worst case ~ 17 comparisons. Solution 2) You can possibly also do the following (didn't try proving it, but seems correct): Maintain an array of the 1/X values, sorted. Now given an R, you try and find the closest sum to 1/R with two numbers in the array of 1/Xs. For this you maintain two pointers to the 1/X array, one at the smallest and one at the largest, and keep incrementing one and decrementing the other to find the one closest to 1/R. (This is a classic interview question: Find if a sorted array has two numbers which sum to X) This will be O(n) comparisons and additions in the worst case. This is also prone to precision issues. You could avoid some of the precision issues by maintaining a reverse sorted array of X's, though.
