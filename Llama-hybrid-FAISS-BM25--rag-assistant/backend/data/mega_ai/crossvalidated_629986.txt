[site]: crossvalidated
[post_id]: 629986
[parent_id]: 
[tags]: 
fitting an ARMAX model with box constraints in python

I would like to identify some parameters from real world data (actually time series). After some mathematical manipulations of some equations describing my system, I conveniently end-up having a linear prediction equation : $$y(t) = \phi^T(t) \theta + \epsilon(t)\label{eq1}\tag{1}$$ Where $\theta$ is the vector containing the parameters I would like to estimate, $y(t)$ and $\phi(t)$ (respectively scalar and vector) depend on my data. Unfortunately my system is quite disturbed, so much so that a Gaussian white noise does not model is not satisfactory to model $\epsilon(t)$ . So I had to resort to something more complex than ordinary least squares and I tried fitting $\theta$ what I guess one might call "MAX" models (Moving Average with eXogenous input). It is just fitting $\theta$ as in (\ref{eq1}), but instead of fitting $\theta$ with ordinary least squares I also try to fit the noise $\epsilon(t)$ with moving average in hope that the residual noise is white. To be explicit, my model is : $$y(t) = \phi^T(t)\theta + \sum_{k=1}^{n_{ma}}\alpha_k \epsilon(t-k) + \epsilon(t)\label{eq2}\tag{2}$$ where $n_{ma}$ is the moving average depth and $\alpha_k$ is the k-th moving average coefficient. I am now doing this in Python with statsmodels : armax_model = ARIMA( b, exog=A[:, :], order=(0, 0, noise_model_order), seasonal_order=(0, 0, 0, 0), trend=None, enforce_stationarity=False, enforce_invertibility=False, concentrate_scale=False, trend_offset=1, dates=None, freq=None, missing="none", validate_specification=True, ) fit_result = armax_model.fit(method="innovations") where $b=\begin{bmatrix}y(0)\\y(1)\\...\\y(n)\end{bmatrix}$ and $A=\begin{bmatrix}\phi^T(0)\\\phi^T(1)\\...\\\phi^T(n)\end{bmatrix}$ This gives me relatively satisfactory results, but once in a while I get a crazy model. Here is an example of what I get afterwards when I use the identified $\theta$ to simulate my model against my actual system (note that I am not using \ref{eq1} for my simulation, but rather the physical equation from which I got \ref{eq1}): Where the red curve is the simulation result. In order to counter this exponential explosion problem I would simply like to add box constraints on my parameters because for instance, I know from theory that if $\theta[1]>0$ I can't have a numerical explosion like presented above. More specifically I would like $$10\leq\theta[0]\leq 50, \quad 1.000\leq\theta[1]\leq 100.000 \quad\text{ and }\quad 1.00\leq\theta[2]\leq 10.000$$ Unfortunately I wasn't able to apply constaints using statsmodels. Does anybody know how to perform this using statsmodels? or using another Python library?
