[site]: crossvalidated
[post_id]: 210726
[parent_id]: 
[tags]: 
Neural network can only follow increasing function

I am trying to program a simple neural network using python. For some reason my code is only working on functions which are increasing. The network I am using has 1 input, 1 output, and 2 layers of 20 neurons. When I train it on the function sin(x) where 0 Here is my python code. I am using the cross entropy cost function but I also get the same result with the quadratic cost function. import numpy as np import random def sigma(z): return 1.0 / (1 + np.exp(z)) def sigma_prime(z): ez = np.exp(z) return -ez / (ez + 1)**2 class NeuralNetwork: def __init__(self, *sizes): self.w = [] self.b = [] last = sizes[0] for s in sizes[1:]: self.w.append(np.full((s, last), 1.0 / (s * last))) self.b.append(np.zeros(s)) last = s def proporgate(self, vin): a = np.array(vin).T for w, b in zip(self.w, self.b): a = np.dot(w, a) + b; a = sigma(a) return a.flatten() def randomize(self): for i in range(len(self.w)): self.w[i] = np.random.randn(self.w[i].shape[0], self.w[i].shape[1]) self.b[i] = np.random.randn(self.b[i].shape[0]) def train(self, learning_rate, vin, vout): a = [None] * len(self.w) z = [None] * len(self.w) z[0] = np.dot(self.w[0], np.array(vin).T) + self.b[0] a[0] = sigma(z[0]) for i in range(1, len(self.w)): z[i] = np.dot(self.w[i], a[i - 1]) + self.b[i] a[i] = sigma(z[i]) d = [None] * len(self.w) y = np.array(vout).T #d[-1] = (a[-1] - y) * sigma_prime(z[-1]) d[-1] = ((1 - y) / (1 - a[-1]) - y / a[-1]) * sigma_prime(z[-1]) for i in reversed(range(len(self.w) - 1)): d[i] = np.dot(self.w[i + 1].T, d[i + 1]) * sigma_prime(z[i]) for i in range(len(self.w)): self.b[i] -= learning_rate * d[i] self.w[i] -= learning_rate * np.dot(d[i], a[i].T) import matplotlib.pyplot as plt n = NeuralNetwork(1, 20, 20, 1) n.randomize() iters = 1000000 for i in range(iters): x = random.random() n.train(5 * (1.0 - i / iters), [x], [np.cos(x)]) x = np.linspace(0, 1, 1000) y = np.zeros_like(x) for i in range(y.shape[0]): y[i] = n.proporgate([x[i]]) plt.plot(x, y, x, np.cos(x)) plt.title('cos(x)') plt.show()
