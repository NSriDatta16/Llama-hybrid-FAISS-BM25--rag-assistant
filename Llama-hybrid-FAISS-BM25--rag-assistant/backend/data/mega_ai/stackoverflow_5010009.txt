[site]: stackoverflow
[post_id]: 5010009
[parent_id]: 5009082
[tags]: 
Alex, There can be a number of reasons for the large amount of reads, and I believe that @Jonathan's answer will help, or mask the problem for now. The reason for getting lots of reads will be because you are missing some critical indexes, and/or your table statistics is not up to date, or it is turned off. Now doing perf tuning on a large table like this can be complicated, if it is used by many other procedures, views and queries. Because changing any indexes can have a massive impact on other queries that are running fine now, but then again if your table is lacking any indexes, any change might just help. Things to consider when you attempt optimising something like this is: How frequently is this query ran When it run's does it impact other processes on the system What is the most frequent operation on this table, inserts or updates? If this query is ran once a day, or very infrequently, and it is not impacting other processes, I might be inclined to leave it. But if this is a process that runs very frequently and/or it is impacting other processes, then you need to fix it. Now by fixing it, it can be as simple as just adding a WITH(NOLOCK) table hint if you find it is blocking, but if it is ran very frequently, then look at indexes and statistics. If you have a lot of inserts on this table, then any extra index will impact insert performance, but it will speed up updates. Then comes index fill factor etc etc. My point is that perf tuning on a Sql box is very complicated, and requires the entire picture most of the time. SO what I would suggest is that you take a few hints here and, because nobody knows your system as well as you, you can make some decisions, and experiment, and learn from it too! Enable your Query Execution Plan and look at it, see if you see any table scans, they are bad, and indicate a lack of proper indexes, so does key lookups. But looking at your query you have given here and ignoring any other factors, here is what I would suggest. Make sure you have a NON CLUSTERED index that have employee_number and course_code in the index. If it is Sql 2008 you can add some included columns too if you have other queries filtering on these two columns, but output other columns. As far as if they should be ascending or descending in the index is up to you, but leave them both as ascending. Then for the query, use what @Jonathan (+1 for you!) proposed, with a minor change, add a WITH(NOLOCK) hint on the table. This will tell the Sql optimiser not to lock the table when it reads it, but you will be able to read dirty data. Normally not a problem, unless it is a highly transactional table, lots of updates and inserts going on the whole time. IF EXISTS(SELECT 1 FROM course_tracking WITH(NOLOCK) WHERE employee_number = @employee_number AND course_code = @course_code) BEGIN UPDATE COURSE TRACKING END ELSE BEGIN INSERT INTO COURSE TRACKING END Also, check if your statistics are updated automatically on the database, if not, create a maintenance job that will update it once a day, when the server is least active. Create a SQL Agent job with this as the query EXEC sp_MSForEachTable 'UPDATE STATISTICS ? WITH FULLSCAN'
