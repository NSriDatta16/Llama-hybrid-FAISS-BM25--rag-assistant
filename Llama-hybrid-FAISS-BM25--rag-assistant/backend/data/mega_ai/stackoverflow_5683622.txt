[site]: stackoverflow
[post_id]: 5683622
[parent_id]: 5683553
[tags]: 
Hmmm... you could try doing it this way... struct sigaction g_sigact; void panic(const char *fmt, ...){ char buf[PANICBUF_LEN]; va_list argptr; va_start(argptr, fmt); vsprintf(buf, fmt, argptr); va_end(argptr); fprintf(stderr, "%s\n", buf); exit(-1); } void init_signals(void){ g_sigact.sa_handler = signal_handler; sigemptyset(&g_sigact.sa_mask); g_sigact.sa_flags = 0; sigaction(SIGINT, &g_sigact, (struct sigaction *)NULL); sigaddset(&g_sigact.sa_mask, SIGSEGV); sigaction(SIGSEGV, &g_sigact, (struct sigaction *)NULL); sigaddset(&g_sigact.sa_mask, SIGBUS); sigaction(SIGBUS, &g_sigact, (struct sigaction *)NULL); sigaddset(&g_sigact.sa_mask, SIGQUIT); sigaction(SIGQUIT, &g_sigact, (struct sigaction *)NULL); sigaddset(&g_sigact.sa_mask, SIGHUP); sigaction(SIGHUP, &g_sigact, (struct sigaction *)NULL); sigaddset(&g_sigact.sa_mask, SIGKILL); sigaction(SIGKILL, &g_sigact, (struct sigaction *)NULL); } static void signal_handler(int sig){ if (sig == SIGHUP) g_keepRunning = 0; if (sig == SIGSEGV || sig == SIGBUS){ dumpstack(); panic("FATAL: %s Fault\n", (sig == SIGSEGV) ? "Segmentation" : ((sig == SIGBUS) ? "Bus" : "Unknown")); } if ((sig == SIGQUIT || (sig == SIGKILL) || (sig == SIGINT)) ; } static void dumpstack(void){ /* Got this routine from http://www.whitefang.com/unix/faq_toc.html ** Section 6.5. Modified to redirect to file to prevent clutter */ char dbx[160]; sprintf(dbx, "echo -ne 'detach\n' | gdb --eval-command=where --pid=%d > %d.dump", getpid(), getpid()); system(dbx); return; } When a segmentation fault is trapped, dumpstack gets invoked and prints the most recent stack-trace up to the point when it segmentation faulted and gets redirected to a file with a numeric pid of the process....
