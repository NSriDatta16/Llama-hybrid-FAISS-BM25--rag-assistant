[site]: stackoverflow
[post_id]: 3566551
[parent_id]: 3566504
[tags]: 
To be more precise, a dictionary attack , i.e. an attack where all words in an exhaustive list are tried, gets not "impossible", but it gets impractical : each bit of salt doubles the amount of storage and computation required . This is different from pre-computed dictionary attacks like attacks involving rainbow tables where it does not matter whether the salt is secret or not. Example: With a 64-bit salt (i.e. 8 bytes) you need to check 2 64 additional password combinations in your dictionary attack. With a dictionary containing 200,000 words you will have to make 200,000 * 2 64 = 3.69 * 10 24 tests in the worst case - instead of 200,000 tests without salt. An additional benefit of using salt is that an attacker cannot pre-compute the password hashes from his dictionary. It would simply take too much time and/or space. Update Your update assumes that an attacker already knows the salt (or has stolen it). This is of course a different situation. Still it is not possible for the attacker to use a pre-computed rainbow table. What matters here a lot is the speed of the hashing function. To make an attack impractical, the hashing function needs to be slow. MD5 or SHA are not good candidates here because they are designed to be fast, better candidates for hashing algorithms are Blowfish or some variations of it. Update 2 A good read on the matter of securing your password hashes in general (going much beyond the original question but still interesting): Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes Corollary of the article: Use salted hashes created with bcrypt (based on Blowfish) or Eksblowfish that allows you to use a configurable setup time to make hashing slow.
