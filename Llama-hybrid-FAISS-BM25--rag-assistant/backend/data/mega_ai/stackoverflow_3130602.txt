[site]: stackoverflow
[post_id]: 3130602
[parent_id]: 3130492
[tags]: 
1) I would implement a cache based on a hashmap rather than a list: Map cache = new HashMap (); This way you can retrieve an Employee object by a given ID very efficiently. Additionally, I wouldn't add a setter for the employee id, since it can corrupt the mapping. Consider setting the id through a constructor parameter only. --EDIT-- If you MUST use a list: 2) You may want to sort it first. This will allow performing a binary search (See Collections.binarySearch(..) methods). This requires implementing a Comparator or the Comparable interface, in order to define an ordering between the Employee objects. Also, you will have to create a dummy Employee object with the required id each time you want to perform the search. 3) If performance is not an issue, simply use List.indexOf(..) . This requires implementing the equals(..) method in the Employee class. 4) In order to do it really without loops, you can create a sparse list, containing Employee with id N at index N. This is only feasible if the Employee id value range is not too big. The benefit is an optimal retrieval time.
