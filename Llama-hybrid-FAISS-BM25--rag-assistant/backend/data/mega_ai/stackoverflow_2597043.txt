[site]: stackoverflow
[post_id]: 2597043
[parent_id]: 2596995
[tags]: 
a * returnnew() { a retval; return(&retval); } Here, retval has automatic storage duration, which means that the language will automatically destruct it when it goes out of scope. The address you've returned refers to an object that no longer exists, and trying to use the return value will be an error. When you want an object's lifetime to be controlled by you, you have to use the new operator to create it. a* returnnew() { a* retval = new a(); return retval; } Here, you now have complete control over the lifetime of this a . It will live until you explicitly delete it, or your program ends. You could also come up with meaningful copy semantics for your a class, and return it by value, in which case your caller would get his own copy, distinct from the original. Then, your caller doesn't care when the original goes away. class a { int * p; public: a(a const& rhs) { p = new int(rhs.p) } a() { p = new int; } ~a() { delete p; } }; Now, you can construct a fresh a as a copy of an existing a . So your function could then return an a by value, like so: a returnnew() { a retval; return retval; } Here retval's lifetime will end when the function returns, and it will be destructed automatically by the language, and no resources will be leaked. And your caller will have his own copy, with its own lifetime. In my experience, most classes should have sensible copy semantics, and you should not be afraid to pass and return them by value. It's just simpler that way, and you'll avoid dangling pointer problems. One of C++'s biggest strengths is the way that destructors are automatically called by the language when automatic storage duration objects go out of scope. If you ensure that every resource in your program is owned by such an object, you'll have a much harder time leaking resources.
