[site]: stackoverflow
[post_id]: 5327259
[parent_id]: 5327096
[tags]: 
No, BackgroundWorker is not the only way, but it's one way. Any other way will allso include some form of asynchronous construct with the need to use Dispatch.BeginInvoke to update the UI. You could for instance use the ThreadPool : ThreadPool.QueueUserWorkItem(state => { Dispatcher.BeginInvoke((Action)delegate() { btnRefresh.IsEnabled = false; }); foreach (var user in service.GetAllUsers()) vm.Users.Add(user); Dispatcher.BeginInvoke((Action)delegate() { btnRefresh.IsEnabled = true; }); }); If this is a recurring pattern (a button will trigger some action that should be performed asynchronously, with the button being disabled during the process) you can wrap this into a method: private void PerformAsync(Action action, Control triggeringControl) { ThreadPool.QueueUserWorkItem(state => { Dispatcher.BeginInvoke((Action)delegate() { triggeringControl.IsEnabled = false; }); action(); Dispatcher.BeginInvoke((Action)delegate() { triggeringControl.IsEnabled = true; }); }); } ...and call it: PerformAsync(() => { foreach (var user in service.GetAllUsers()) vm.Users.Add(user); }, btnRefresh); As an option to using the ThreadPool , you should also perhaps look into the Task Parallel Library . When doing this you should pay attention to how you handle UI state. For instance of you have more than one control which triggers the same action, make sure that all of them are disabled during the action. Note: these are just quick ideas. The code has not been tested so it may contain errors. It's more to be regarded as discussion material than finished solutions.
