[site]: stackoverflow
[post_id]: 3814724
[parent_id]: 3814546
[tags]: 
Lazy loading and batch loading are often in opposition to one another. The former is useful when you anticipate that accessing detail fields will be an infrequent operation - and allows you to avoid unnecessary work. However, if the cost of fetching the details for one object vs. all object is low - then it may make sense to simply batch load all of the information. You can combine these behaviors - and implement batch lazy loading. To do so, you would need to tie all data-carrying objects together, so that when one is asked for its aggregate totals you can fetch those totals for all objects. A common design for this kind of problem is to store the aggregate details in a separate helper object (often organized into a dictionary based on some primary key). Initially the helper object is not populated - but when a request comes in from one instance you load the data for all instances. Here's a skeletal example of what I mean: class CampaignInfo { public int Key { get; set; } public string Name { get; set; } public DateTime StartDate { get; set; } public DateTime EndDate { get; set; } // etc... // initialized on construction all CampaignInfo instances share reference private AggregateDetails _details; public int TotalClicks { get { return _details.TotalClicksFor( this.Key ); } } public int TotalPurchases { get { return _details.TotalPurchasesFor( this.Key ); } } } class AggregateDetails { private class AggregateInfo { public int TotalClicks; public int TotalPurchases; // etc... } private readonly Dictionary _cachedInfo; public int TotalClicksFor( int key ) { if( _cachedInfo == null ) LoadAggregateInfo(); // loads aggregates for all campaigns return _cachedInfo[key].TotalClicks; } public int TotalPurchasesFor( int key ) { if( _cachedInfo == null ) LoadAggregateInfo(); // loads aggregates for all campaigns return _cachedInfo[key].TotalPurchases; } // etc... } Obviously this code requires error and exception handling, some means to manage concurrency (so that calls to fetch data are thread safe), a means to track which campaigns keys to load data for, a mechanism to query the database, and so on. But it should give you an idea of how to structure your implementation to get the best of both worlds.
