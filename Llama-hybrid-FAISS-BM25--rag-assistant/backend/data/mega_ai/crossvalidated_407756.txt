[site]: crossvalidated
[post_id]: 407756
[parent_id]: 407737
[tags]: 
Here is example code illustrating one of the ways to do this. In this code two data sets are individually fit to polynomials and a combined data set is made and fit to a third polynomial. Note several things about this approach: the "combined" fit statistics are poor, and each of the "combined" polynomial coefficients are actually the average of the corresponding coefficients of the other two fits. This shows that you can simply take the average value for each of the individual fit parameters - however if the individual data sets have different number of data points, you must use a weighted average. That is, if data set A has 30 percent of the total number of data points, data set B has 10 percent, and data set C has the remaining 60 percent, then combined parameter B0 is a weighted average calculated as B0_combined = (0.3 * B0_A) + (0.1 * B0_B) + (0.6 * B0_C). import numpy, matplotlib import matplotlib.pyplot as plt polynomialOrder = 2 # example quadratic ### data section xData_A = numpy.array([1.1, 2.2, 3.3, 4.4, 5.0, 6.6, 7.7, 0.0]) yData_A = numpy.array([1.1, 20.2, 30.3, 40.4, 50.0, 60.6, 70.7, 0.1]) xData_B = numpy.array([1.1, 2.2, 3.3, 4.4, 5.0, 6.6, 7.7, 0.0]) yData_B = numpy.array([11.0, 120.2, 130.4, 140.6, 150.8, 160.9, 170.9, 10.1]) xData_Combo = numpy.append(xData_A, xData_B) yData_Combo = numpy.append(yData_A, yData_B) ### fitting section fittedParameters_A = numpy.polyfit(xData_A, yData_A, polynomialOrder) fittedParameters_B = numpy.polyfit(xData_B, yData_B, polynomialOrder) fittedParameters_Combo = numpy.polyfit(xData_Combo, yData_Combo, polynomialOrder) print('Fitted Parameters A:', fittedParameters_A) print('Fitted Parameters B:', fittedParameters_B) print('Fitted Parameters Combined:', fittedParameters_Combo) print() modelPredictions_A = numpy.polyval(fittedParameters_A, xData_A) modelPredictions_B = numpy.polyval(fittedParameters_B, xData_B) modelPredictions_Combo = numpy.polyval(fittedParameters_Combo, xData_Combo) absError_A = modelPredictions_A - yData_A absError_B = modelPredictions_B - yData_B absError_Combo = modelPredictions_Combo - yData_Combo ### fit statistics section SE_A = numpy.square(absError_A) # squared errors A MSE_A = numpy.mean(SE_A) # mean squared errors A RMSE_A = numpy.sqrt(MSE_A) # Root Mean Squared Error, RMSE A Rsquared_A = 1.0 - (numpy.var(absError_A) / numpy.var(yData_A)) print('RMSE A:', RMSE_A) print('R-squared A:', Rsquared_A) print() SE_B = numpy.square(absError_B) # squared errors B MSE_B = numpy.mean(SE_B) # mean squared errors B RMSE_B = numpy.sqrt(MSE_B) # Root Mean Squared Error, RMSE B Rsquared_B = 1.0 - (numpy.var(absError_B) / numpy.var(yData_B)) print('RMSE B:', RMSE_B) print('R-squared B', Rsquared_B) print() SE_Combo = numpy.square(absError_Combo) # squared errors Comb0 MSE_Combo = numpy.mean(SE_Combo) # mean squared errors Combo RMSE_Combo = numpy.sqrt(MSE_Combo) # Root Mean Squared Error, RMSE Combo Rsquared_Combo = 1.0 - (numpy.var(absError_Combo) / numpy.var(yData_Combo)) print('RMSE Combo:', RMSE_Combo) print('R-squared Combo:', Rsquared_Combo) print() ########################################################## # graphics output section def ModelsAndScatterPlots(graphWidth, graphHeight): f = plt.figure(figsize=(graphWidth/100.0, graphHeight/100.0), dpi=100) axes = f.add_subplot(111) # first the raw data as a scatter plot axes.plot(xData_A, yData_A, 'D') axes.plot(xData_B, yData_B, 'D') # combo contains these same points, no need to replot in this example # create data for the fitted equation plots xModel_A = numpy.linspace(min(xData_A), max(xData_A)) yModel_A = numpy.polyval(fittedParameters_A, xModel_A) xModel_B = numpy.linspace(min(xData_B), max(xData_B)) yModel_B = numpy.polyval(fittedParameters_B, xModel_B) xModel_Combo = numpy.linspace(min(xData_Combo), max(xData_Combo)) yModel_Combo = numpy.polyval(fittedParameters_Combo, xModel_Combo) # now the models as a line plots axes.plot(xModel_A, yModel_A) axes.plot(xModel_B, yModel_B) axes.plot(xModel_Combo, yModel_Combo) axes.set_xlabel('X Data') # X axis data label axes.set_ylabel('Y Data') # Y axis data label plt.show() plt.close('all') # clean up after using pyplot graphWidth = 800 graphHeight = 600 ModelsAndScatterPlots(graphWidth, graphHeight)
