[site]: stackoverflow
[post_id]: 1124014
[parent_id]: 1122610
[tags]: 
I can only speak from the experience of not using a full validation framework, in as much as I've simply stuck to using what WPF natively offers. In my project, I implemented the IDataError interface on my entity/data classes, as well as implemented the partial "OnValidate" method that Linq-To-Sql observes, and then as static/shared members of the entity classes, instansiated validation home-brewed helpers which provide the back-end logic for implementing IDataError.Items and OnValidation methods. Then it's simply a case of adding ValidatesOnErrors=True,ValidatesOnExceptions=True to all of the bindings described in XAML. The end result is encouraging - WPF's ability to provide visual feedback on invalid data is good, and the effort of implementing the validation is minimal. I'd advise following the trend of keeping user-input validation logic seperate from your property setter logic. Sometimes the validity of one property depends of the state of another property. Keeping the validation logic outside of the property setters allows you to construct apps where the end user is able to input the two values that result in a valid state, without either of the individual property setters rejecting the values as they are being entered in.
