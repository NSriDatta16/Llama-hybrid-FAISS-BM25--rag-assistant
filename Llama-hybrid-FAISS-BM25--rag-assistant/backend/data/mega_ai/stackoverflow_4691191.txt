[site]: stackoverflow
[post_id]: 4691191
[parent_id]: 4691166
[tags]: 
I want to address just one point in your question: A trie is not a general-purpose dictionary data structure. The reason is that a trie is a specialized search tree for (sub)string search. Generally, you will be more interested in general search trees, e.g. binary search trees or B-trees . All these implementations rely on an ordering of the dictionary elements, and all of them have a logarithmic average-case and worst-case runtime for common operations. A hash table , by contrast, does not require a relative ordering of the elements. Instead, it requires that elements are hashable and equality comparable . The worst-case characteristic of common hash table characteristics is much worse than for trees, namely linear in the number of elements. However, with a bit of care the average case for hash tables operations can be made constant (i.e. independent of the container size). Whatâ€™s more, it can be proven that slower operations are exceedingly rare. In practice, this means that except for very specialized use-cases, hash tables beat tree-based dictionaries hands down. The downside to this is that hash tables impose an arbitrary-seeming order on its elements. If you are interested in getting the items from your dictionary in sorted order, hash tables are not for you. (There are other interesting implementations of dictionaries, e.g. skip lists which rival search trees and probabilistic implementations like the Bloom filter .) A trie-based implementation can only be used if you are dealing with a dictionary of string values, in which case it is actually often a good choice, in particular if many strings in the dictionary share common prefixes and are rather short.
