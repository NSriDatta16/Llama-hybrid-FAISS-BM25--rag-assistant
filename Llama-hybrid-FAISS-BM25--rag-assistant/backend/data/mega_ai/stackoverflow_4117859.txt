[site]: stackoverflow
[post_id]: 4117859
[parent_id]: 
[tags]: 
Find in a dynamic pythonic way the minimum elements in a partially ordered set

Let Os be a partially ordered set, and given any two objects O1 and O2 in Os, F(O1,O2) will return 1 if O1 is bigger than O2, -1 if O1 is smaller than O2, 2 if they are incomparable, and 0 if O1 is equal to O2. I need to find the subset Mn of elements is Os that are the minimum. That is for each A in Mn, and for each B in Os, F(A,B) is never equal to 1. It is not hard to do, but I am convinced it could be done in a more pythonic way. The fast and dirty way is: def GetMinOs(Os): Mn=set([]) NotMn=set([]) for O1 in Os: for O2 in Os: rel=f(O1,O2) if rel==1: NotMn|=set([O1]) elif rel==-1: NotMn|=set([O2]) Mn=Os-NotMn return Mn In particular I am not happy with the fact that I am essentially going through all the elements N^2 times. I wonder if there could be a dynamic way. By "dynamic" I don't mean merely fast, but also such that once something is discovered being not a possible in the minimum, maybe it could be taken off. And doing all this in a pythonic , elegant way
