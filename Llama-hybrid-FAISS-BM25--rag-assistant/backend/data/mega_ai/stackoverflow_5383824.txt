[site]: stackoverflow
[post_id]: 5383824
[parent_id]: 5367118
[tags]: 
I was not able to get this to work using the open source data provider from here . However, I was able to get this to work using the free Standard Edition of dotConnect as follows: Create the below DLL import, so that we can enable the shared cache for SQLite. [DllImport("sqlite3.dll", CallingConvention = CallingConvention.Cdecl)] public static extern int sqlite3_enable_shared_cache(int enable); Execute the above function to enable the shared cache. Note, this only needs to be executed once for the entire process - see SQLite documentation . sqlite3_enable_shared_cache(1); Then prefix the SQL query statement used by the data reader with the pragma statement as follows: PRAGMA read_uncommitted = 1; SELECT Column1, Column2 FROM MyTable One can now freely update and insert rows while the data reader is active. Additional SQLite documentation on the shared cache can be found here . Update: A newer version of the Devart SQLite data provider now supports this in an improved manner. To enable the shared cache one can make the following call: Devart.Data.SQLite.SQLiteConnection.EnableSharedCache(); One can configure the uncommitted reads into the connection string for example as follows: Devart.Data.SQLite.SQLiteConnectionStringBuilder builder = new SQLiteConnectionStringBuilder(); builder.ReadUncommitted = true; builder.DateTimeFormat = Devart.Data.SQLite.SQLiteDateFormats.Ticks; builder.DataSource = DatabaseFilePath; builder.DefaultCommandTimeout = 300; builder.MinPoolSize = 0; builder.MaxPoolSize = 100; builder.Pooling = true; builder.FailIfMissing = false; builder.LegacyFileFormat = false; builder.JournalMode = JournalMode.Default; string connectionString = builder.ToString();
