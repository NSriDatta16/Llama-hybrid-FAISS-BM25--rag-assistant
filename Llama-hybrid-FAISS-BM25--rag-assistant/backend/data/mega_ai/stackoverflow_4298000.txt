[site]: stackoverflow
[post_id]: 4298000
[parent_id]: 4297916
[tags]: 
You posted the oneliner: @sentence = @sentence.split(' ').map!{|x| x = x[0..0].upcase But you misunderstand a couple things about Ruby. First off, saying x= in a map call doesn't affect anything outside of the map call. The new value of that array element is the value returned by the block. Secondly, you don't need to mutate the first string with -- a concatenation that creates a new string (using + ) is a much better option. Thirdly, map! makes changes directly to the array returned by split . What you want to do is leave that array untouched (even though it doesn't change program semantics), and return a new array with the mapped results, by using map . So you should have written: @sentence = @sentence.split(' ').map{|x| x[0..0].upcase + x[1..-1] }.join(' ') Now the statement x[0..0].upcase + x[1..-1] is still very obtuse. Maybe you should replace it with the capitalize method, which already changes the first letter of the string to uppercase. (Note that it also downcases all of the others, which may or may not be what you want.) @sentence = @sentence.split(' ').map{|x| x.capitalize }.join(' ') I'd probably use gsub! to change parts of the string in-place, but that's probably a little obtuse: @sentence.gsub!(/\S+/){|x| x.capitalize} One more thing. If the only purpose of a block is to call a single method on the object passed to the block, you can do the following: @sentence = @sentence.split(' ').map(&:capitalize).join(' ') or to modify my gsub! version: @sentence.gsub!(/\S+/,&:capitalize)
