[site]: stackoverflow
[post_id]: 3084613
[parent_id]: 2125126
[tags]: 
There's a serious issue with the solution posted by Brandon Bodnár (which by the time of this writing is marked as a valid solution). Issue described here: http://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/Min-and-Max.html And the (valid & secure) solution to it: http://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/Typeof.html Check it out yourself: #include #define NAIVE_MAX(a,b) (a > b ? a : b) #define NAIVE_MIN(a,b) (a __b ? __a : __b; }) #endif #if !defined MIN #define MIN(a,b) \ ({ __typeof__ (a) __a = (a); \ __typeof__ (b) __b = (b); \ __a %d\n", a, b, NAIVE_MAX(a, b)); printf("NAIVE_MIN(%d, %d) => %d\n", a, b, NAIVE_MIN(a, b)); printf("MAX(%d, %d) => %d\n", a, b, MAX(a, b)); printf("MIN(%d, %d) => %d\n", a, b, MIN(a, b)); printf("\nEverything fine so far...\n\n"); #pragma mark FATAL CASES: //cache: int _a = a; int _b = b; printf("NAIVE_MAX(%d++, %d++) => %d\n", _a, _b, NAIVE_MAX(a++, b++)); //reset: a = _a; b = _b; printf("NAIVE_MIN(%d++, %d++) => %d\n", _a, _b, NAIVE_MIN(a++, b++)); //reset: a = _a; b = _b; printf("NAIVE_MAX(++%d, ++%d) => %d\n", _a, _b, NAIVE_MAX(++a, ++b)); //reset: a = _a; b = _b; printf("NAIVE_MIN(++%d, ++%d) => %d\n", _a, _b, NAIVE_MIN(++a, ++b)); printf("\nOuch, this doesn't look right at all!\n\n"); #pragma mark NON-FATAL CASES: //reset: a = _a; b = _b; printf("MAX(%d++, %d++) => %d\n", _a, _b, MAX(a++, b++)); //reset: a = _a; b = _b; printf("MIN(%d++, %d++) => %d\n", _a, _b, MIN(a++, b++)); //reset: a = _a; b = _b; printf("MAX(++%d, ++%d) => %d\n", _a, _b, MAX(++a, ++b)); //reset: a = _a; b = _b; printf("MIN(++%d, ++%d) => %d\n", _a, _b, MIN(++a, ++b)); printf("\nAh, much better now.\n\n"); return 0; } Console log: NAIVE_MAX(3, 5) => 5 NAIVE_MIN(3, 5) => 3 MAX(3, 5) => 5 MIN(3, 5) => 3 Everything fine so far... NAIVE_MAX(3++, 5++) => 6 NAIVE_MIN(3++, 5++) => 4 NAIVE_MAX(++3, ++5) => 7 NAIVE_MIN(++3, ++5) => 5 Ouch, this doesn't look right at all! MAX(3++, 5++) => 5 MIN(3++, 5++) => 3 MAX(++3, ++5) => 6 MIN(++3, ++5) => 4 Ah, much better now. So never ever use the naive implementation as seen in the code above (and as suggested by Brandon Bodnár, sorry buddy ;) ) if you want to avoid worst cases like these.
