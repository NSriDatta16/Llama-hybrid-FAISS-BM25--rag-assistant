[site]: crossvalidated
[post_id]: 1351
[parent_id]: 1296
[tags]: 
Assuming you want to pick a distribution for $ n, p(n) $ you can apply Bayes law. You know that the probability of k events occuring given that n have actually occured is governed by a binomial distribution $$p(k|n) = {n \choose k} p^k (1-p)^{(n-k)}$$ The thing you really want to know is the probability of n events having actually occured, given that you observed k. By Bayes lay: $$p(n|k) = \frac{p(k|n)p(n)}{p(k)}$$ By applying the theorem of total probability, we can write: $$p(n|k) = \frac{p(k|n)p(n)}{\sum_{n'} p(k|n')p(n')}$$ So without further information, about the distribution of $p(n)$ you can't really go any further. However, if you want to pick a distribution for $p(n)$ for which there is a value $n$ greater than which $p(n) = 0$ , or sufficiently close to zero, then you can do a bit better. For example, assume that the distribution of $n$ is uniform in the range $[0,n_{\max}]$ . this case: $$p(n) = \frac{1}{n_{\max}}$$ The Bayesian formulation simplifies to: $$p(n|k) = \frac{p(k|n)}{\sum_{n'} p(k|n')}$$ As for the final part of the problem, I agree that the best approach is to perform a cumulative summation over $p(n|k)$ , to generate the cumulative probability distribution function, and iterate until the 0.95 limit is reached. Given that this question migrated from SO, toy sample code in python is attached below import numpy.random p = 0.8 nmax = 200 def factorial(n): if n == 0: return 1 return reduce( lambda a,b : a*b, xrange(1,n+1), 1 ) def ncr(n,r): return factorial(n) / (factorial(r) * factorial(n-r)) def binomProbability(n, k, p): p1 = ncr(n,k) p2 = p**k p3 = (1-p)**(n-k) return p1*p2*p3 def posterior( n, k, p ): def p_k_given_n( n, k ): return binomProbability(n, k, p) def p_n( n ): return 1./nmax def p_k( k ): return sum( [ p_n(nd)*p_k_given_n(nd,k) for nd in range(k,nmax) ] ) return (p_k_given_n(n,k) * p_n(n)) / p_k(k) observed_k = 80 p_n_given_k = [ posterior( n, observed_k, p ) for n in range(0,nmax) ] cp_n_given_k = numpy.cumsum(p_n_given_k) for n in xrange(0,nmax): print n, p_n_given_k[n], cp_n_given_k[n]
