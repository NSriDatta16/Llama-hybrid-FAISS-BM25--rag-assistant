[site]: stackoverflow
[post_id]: 4694934
[parent_id]: 4692384
[tags]: 
Doing this kind of thing with a worker thread is not optimal. Given that the optimal code path for painting is always via a WM_PAINT that leaves two ways to do this: Simply create a timer on the GUI thread, post WM_TIMER messages to a timerproc, or the window directly, and invoke the OnTick() part of your engine. IF any sprites move, they invalidate their area using InvalidateRect() and windows follows up by automatically posting a WM_PAINT. This has the advantage of having a very low CPU usage if the game is relatively idle. Most games want stricter timing that can be achieved using a low priority WM_TIMER based timer. In that case, you implement a game loop something like this: Message Loop: while(stillRunning) { DWORD ret = MsgWaitForMultipleObjects(0,NULL,FALSE,frameIntervalMs,QS_ALLEVENTS); if(ret == WAIT_OBJECT_0){ while(PeekMessage(&msg,0,0,0,PM_REMOVE)){ TranslateMessage(&msg); DispatchMessage(&msg); } if(TickGame()) // if TickGame indicates that enough time passed for stuff to change RedrawWindow(hwndGame,...); // Dispatch a WM_PAINT immediately. } The danger with this kind of message loop is, if the ... application goes into any kind of modal state :- the user starts to drag the window / a modal dialog box pops up, then messages are being pumped by the modal loop, so the animation stops. As a result you need to have a fallback timer if you need to mix a high performance message loop with modal operations. WRT your WM_PAINT implementation - its usually better to (re)create your backbuffer in response to WM_SIZE messages. That way its always the right size, and you don't incurr the rather large cost of recreating a large memory buffer many times per second.
