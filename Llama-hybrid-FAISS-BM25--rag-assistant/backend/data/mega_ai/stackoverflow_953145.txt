[site]: stackoverflow
[post_id]: 953145
[parent_id]: 952149
[tags]: 
Q: In Oracle, is there a function that calculates the difference between two Dates? Just subtract one date expression from another to get the difference expressed as a number of days. The integer portion is the number of whole days, the fractional portion is the fraction of a day. Simple arithmetic after that, multiply by 24 to get hours. Q: If not, is a way to display the difference between two dates in hours and minutes? It's just a matter of expressing the duration as whole hours and remainder minutes. We can go "old school" to get durations in hhhh:mi format using a combination of simple builtin functions: SELECT decode(sign(t.maxst),-1,'-','')||to_char(floor(abs(t.maxst)/60))|| decode(t.maxst,null,'',':')||to_char(mod(abs(t.maxst),60),'FM00') as MaximumScheduleTime , decode(sign(t.minst),-1,'-','')||to_char(floor(abs(t.minst)/60))|| decode(t.minst,null,'',':')||to_char(mod(abs(t.minst),60),'FM00') as MinimumScheduleTime , decode(sign(t.avgst),-1,'-','')||to_char(floor(abs(t.avgst)/60)) decode(t.avgst,null,'',':')||to_char(mod(abs(t.avgst),60),'FM00') as AverageScheduleTime FROM ( SELECT round(max((EndDate - StartDate) *1440),0) as maxst , round(min((EndDate - StartDate) *1440),0) as minst , round(avg((EndDate - StartDate) *1440),0) as avgst FROM table1 ) t Yeah, it's fugly, but it's pretty fast. Here's a simpler case, that shows better what's going on: select dur as "minutes" , abs(dur) as "unsigned_minutes" , floor(abs(dur)/60) as "unsigned_whole_hours" , to_char(floor(abs(dur)/60)) as "hhhh" , mod(abs(dur),60) as "unsigned_remainder_minutes" , to_char(mod(abs(dur),60),'FM00') as "mi" , decode(sign(dur),-1,'-','') as "leading_sign" , decode(dur,null,'',':') as "colon_separator" from (select round(( date_expr1 - date_expr2 )*24*60,0) as dur from ... ) (replace date_expr1 and date_expr2 with date expressions) let's unpack this date_expr1 - date_expr2 returns difference in number of days multiply by 1440 (24*60) to get duration in minutes round (or floor ) to resolve fractional minutes into integer minutes divide by 60, integer quotient is hours, remainder is minutes abs function to get absolute value (change negative values to positive) to_char format model FM00 give two digits (leading zeros) use decode function to format a negative sign and a colon (if needed) The SQL statement could be made less ugly using a PL/SQL function, one that takes two DATE arguments a duration in (fractional) days and returns formatted hhhh:mi ( untested ) create function hhhhmi(an_dur in number) return varchar2 deterministic is begin if an_dur is null then return null; end if; return decode(sign(an_dur),-1,'-','') || to_char(floor(abs(an_dur)*24)) ||':'||to_char(mod((abs(an_dur)*1440),60),'FM00'); end; With the function defined: SELECT hhhhmi(max(EndDate - StartDate)) as MaximumScheduleTime , hhhhmi(min(EndDate - StartDate)) as MinimumScheduleTime , hhhhmi(avg(EndDate - StartDate)) as AverageScheduleTime FROM table1
