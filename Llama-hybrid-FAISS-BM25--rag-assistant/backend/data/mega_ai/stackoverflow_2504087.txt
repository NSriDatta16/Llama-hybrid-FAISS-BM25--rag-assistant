[site]: stackoverflow
[post_id]: 2504087
[parent_id]: 2458637
[tags]: 
I also ran into this strange (to me) linker error for my build of Boost on Windows Server 2003 using VS2005. I'm using similar bjam command-line options as the OP was, but without the --layout=system option since I don't mind the version info in them (not yet). The executive summary of the verbiage that follows is: If you see LINK : fatal error LNK1104: cannot open file 'libboost_regex-vc80-mt-gd-1_42.lib' , then you need to to specify the same -D compile line options in your downstream application build as Boost's builds do when they build the Boost Regex library. The documentation does not state that AFAICT (as of 2010-03-23). The details: Things I found quite helpful debugging this problem were: Use the -d+2 option to bjam when building. This dumps out a huge amount of logging about exactly what command-line options are being used. That was how I determined that -DBOOST_ALL_NO_LIB=1 and -DBOOST_REGEX_DYN_LINK=1 were being specified on the cl.exe compile line when building the Boost Regex library. Realize that you have to also supply the same special -D flags (use either -D or /D options which VS2005 accepts as the same thing) when you compile the .cpp files in the app that uses that Boost library (true for Boost Regex, and I am guessing it is true for others, which I have not confirmed). That is why you will see a linker failure of: LINK : fatal error LNK1104: cannot open file 'libboost_regex-vc80-mt-gd-1_42.lib' , since without the -DBOOST_ALL_NO_LIB=1 and -DBOOST_REGEX_DYN_LINK=1 options, the auto-linking will kick in when the compiler parses your .cpp file and #include 's the Boost header, the latter of which #include 's the auto-linking headers, the latter of which by default uses the auto-linking logic which are compiler pragmas that tell the linker which library to use. And guess which ones that auto-linking logic chooses by default? Answer: The static ones that are of the form libblablabla.lib and not blablabla.lib which are the import libraries you expect. This pragma-based linker directive logic is what had me chasing my tail for 3 hours trying to figure out what I did wrong on my linker line, when it is under C-preprocessor control in the auto-linking logic that did it.
