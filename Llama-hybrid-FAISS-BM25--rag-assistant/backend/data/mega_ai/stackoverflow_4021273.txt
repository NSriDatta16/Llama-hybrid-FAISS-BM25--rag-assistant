[site]: stackoverflow
[post_id]: 4021273
[parent_id]: 4016357
[tags]: 
If it really is the interpolation of the radial functions that is slowing you down, you could consider hand-coding that part based on your knowledge of the sample points. As demonstrated below, this gives a significant speedup: I set things up with your notation. lookuprvals is a list of 100000 r values to look up for timing. First, look at stock interpolation as a basemark With[{interp=Interpolation[N@Transpose@{rvals,yvals}]}, Timing[interp[lookuprvals]][[1]]] Out[259]= 2.28466 Switching to 0th-order interpolation is already an order of magnitude faster (first order is almost same speed): With[{interp=Interpolation[N@Transpose@{rvals,yvals},InterpolationOrder->0]}, Timing[interp[lookuprvals]][[1]]] Out[271]= 0.146486 We can get another 1.5 order of magnitude by calculating indices directly: Module[{avg=MovingAverage[yvals,2],idxfact=N[(pts-1) /Log[Rmax/Rstep]]}, Timing[res=Part[avg,Ceiling[idxfact Log[lookuprvals]]]][[1]]] Out[272]= 0.006067 As a middle ground, do a log-linear interpolation by hand. This is slower than the above solution but still much faster than stock interpolation: Module[{diffs=Differences[yvals], idxfact=N[(pts-1) /Log[Rmax/Rstep]]}, Timing[Block[{idxraw,idxfloor,idxrel}, idxraw=1+idxfact Log[lookuprvals]; idxfloor=Floor[idxraw]; idxrel=idxraw-idxfloor; res=Part[yvals,idxfloor]+Part[diffs,idxfloor]idxrel ]][[1]]] Out[276]= 0.026557 If you have the memory for it, I would cache the spherical harmonics and radius (or even radius-index) on the full grid. Then flatten the grid caches so you can do Sum[ interpolate[yvals[lm],gridrvals] gridylmvals[lm], {lm,lmvals} ] and recreate your grid as discussed here .
