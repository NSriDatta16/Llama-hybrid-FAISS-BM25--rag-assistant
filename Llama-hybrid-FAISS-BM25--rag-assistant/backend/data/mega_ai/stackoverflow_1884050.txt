[site]: stackoverflow
[post_id]: 1884050
[parent_id]: 1883273
[tags]: 
Pyparsing might help you bridge this mix of JS and HTML. This parser looks for document.write statements containing a quoted string or a string expression of several quoted strings and identifiers, quasi-evaluates the string expression, parses it for an embedded tag, and returns the frame attributes as a pyparsing ParseResults object, which gives you access to the named attributes as if they were object attributes or dict keys (your preference). jssrc = """ . . . document.write(' '); if (anchor != "") { document.write(' '); } else { document.write(' '); } document.write(' '); // end hiding --> """ from pyparsing import * # define some basic punctuation, and quoted string LPAR,RPAR,PLUS = map(Suppress,"()+") qs = QuotedString("'") # use pyparsing helper to define an expression for opening # tags, which includes support for attributes also frameTag = makeHTMLTags("frame")[0] # some of our document.write statements contain not a sting literal, # but an expression of strings and vars added together; define # an identifier expression, and add a parse action that converts # a var name to a likely value ident = Word(alphas).setParseAction(lambda toks: evalvars[toks[0]]) evalvars = { 'cusip' : "CUSIP", 'anchor' : "ANCHOR" } # now define the string expression itself, as a quoted string, # optionally followed by identifiers and quoted strings added # together; identifiers will get translated to their defined values # as they are parsed; the first parse action on stringExpr concatenates # all the tokens; then the second parse action actually parses the # body of the string as a tag and returns the results of parsing # the tag and its attributes; if the parse fails (that is, if the # string contains something that is not a tag), the second # parse action will throw an exception, which will cause the stringExpr # expression to fail stringExpr = qs + ZeroOrMore( PLUS + (ident | qs)) stringExpr.setParseAction(lambda toks : ''.join(toks)) stringExpr.addParseAction(lambda toks: frameTag.parseString(toks[0],parseAll=True)) # finally, define the overall document.write(...) expression docWrite = "document.write" + LPAR + stringExpr + RPAR # scan through the source looking for document.write commands containing # tags using scanString; print the original source fragment, # then access some of the attributes extracted from the tag # in the quoted string, using either object-attribute notation or # dict index notation for dw,locstart,locend in docWrite.scanString(jssrc): print jssrc[locstart:locend] print dw.name print dw["src"] print Prints: document.write(' ') nav /nav/index_nav.html document.write(' ') body http://content.members.fidelity.com/mfl/summary/0,,CUSIP,00.html?ANCHOR document.write(' ') body http://content.members.fidelity.com/mfl/summary/0,,CUSIP,00.html
