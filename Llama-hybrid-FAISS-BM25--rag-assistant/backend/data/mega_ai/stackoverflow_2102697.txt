[site]: stackoverflow
[post_id]: 2102697
[parent_id]: 2102606
[tags]: 
If you only can use one vector (not specified in question), and Nodes should not contain it's own list, only some pointers (addresses in vector), then you can try this: each node holds address of its sibling first node after given (if it is not its sibling) is child, with pointer to second child and so on each of its child has it's own children So for tree like this: A | \ B E ___ |\ \ \ \ C D F G H Your vector would look like: idx: 0 1 2 3 4 5 6 7 nodes: A B C D E F G H next: _ 4 3 _ _ 6 7 _ where _ is null pointer Edit: Another approach: every node holds address of region in vector occupied by its children children are next to each other there exists null node in vector, marking end of siblings group For that approach given tree would look like: idx: 0 1 2 3 4 5 6 7 8 9 A B nodex: A _ B E _ C D _ F G H _ child: 2 5 8 _ _ _ _ _ That way you can easily find children of any randomly given node and reorganize array without moving all elements (just copy children to end of table, update pointer and add next child to end of table)
