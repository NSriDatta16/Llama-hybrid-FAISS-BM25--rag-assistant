[site]: stackoverflow
[post_id]: 2737498
[parent_id]: 2735521
[tags]: 
I also ran into that problem when trying to use frames as components. There are various possibilities to fix the obvious issues, but they all undermine the principle of information hiding (all the frame's subcomponents are exposed as published properties, which means everyone can access them). I solved it by implementing a generic "frame control" component: unit RttiBrow.Cbde.FrameControl; interface uses Classes, Controls, Forms, Messages, ExtCtrls; type TFrameClass = class of TFrame; TComponentFrame = class (TFrame) private function GetClientHeight: Integer; function GetClientWidth: Integer; procedure SetClientHeight(const Value: Integer); procedure SetClientWidth(const Value: Integer); function GetOldCreateOrder: Boolean; procedure SetOldCreateOrder(const Value: Boolean); function GetPixelsPerInch: Integer; procedure SetPixelsPerInch(const Value: Integer); function GetTextHeight: Integer; procedure SetTextHeight(const Value: Integer); published { workarounds for IDE bug } property ClientWidth: Integer read GetClientWidth write SetClientWidth stored False; property ClientHeight: Integer read GetClientHeight write SetClientHeight stored False; property OldCreateOrder: Boolean read GetOldCreateOrder write SetOldCreateOrder stored False; property PixelsPerInch: Integer read GetPixelsPerInch write SetPixelsPerInch stored False; property TextHeight: Integer read GetTextHeight write SetTextHeight stored False; end; TComponentFrame = class (TComponentFrame) private function GetController: TFrameControl; inline; protected property Controller: TFrameControl read GetController; public constructor Create (AOwner: TComponent); override; end; TFrameControl = class (TWinControl) private FFrame: T; function PlainFrame: TFrame; protected procedure CreateParams (var Params: TCreateParams); override; property Frame: T read FFrame; public constructor Create (AOwner: TComponent); override; property DockManager; published property Align; property Anchors; property BiDiMode; property Color; property Constraints; property Ctl3D; property UseDockManager default True; property DockSite; property DoubleBuffered; property DragCursor; property DragKind; property DragMode; property Enabled; property Font; property ParentBiDiMode; property ParentBackground; property ParentColor; property ParentCtl3D; property ParentDoubleBuffered; property ParentFont; property ParentShowHint; property ShowHint; property TabOrder; property TabStop; property Touch; property Visible; property OnAlignInsertBefore; property OnAlignPosition; property OnCanResize; property OnConstrainedResize; property OnDockDrop; property OnDockOver; property OnDragDrop; property OnDragOver; property OnEndDock; property OnEndDrag; property OnEnter; property OnExit; property OnGesture; property OnGetSiteInfo; property OnMouseActivate; property OnMouseDown; property OnMouseEnter; property OnMouseLeave; property OnMouseMove; property OnMouseUp; property OnResize; property OnStartDock; property OnStartDrag; property OnUnDock; end; implementation uses Windows; { TFrameControl } constructor TFrameControl .Create(AOwner: TComponent); begin inherited; FFrame := T (TFrameClass (T).Create (Self)); PlainFrame.Parent := Self; PlainFrame.Align := alClient; end; procedure TFrameControl .CreateParams(var Params: TCreateParams); begin inherited; Params.Style := Params.Style or WS_CLIPCHILDREN; Params.ExStyle := Params.ExStyle or WS_EX_CONTROLPARENT; end; function TFrameControl .PlainFrame: TFrame; begin Result := FFrame; // buggy compiler workaround end; { TComponentFrame } function TComponentFrame.GetOldCreateOrder: Boolean; begin Result := False; end; function TComponentFrame.GetPixelsPerInch: Integer; begin Result := 0; end; function TComponentFrame.GetTextHeight: Integer; begin Result := 0; end; procedure TComponentFrame.SetClientHeight(const Value: Integer); begin Height := Value; end; procedure TComponentFrame.SetClientWidth(const Value: Integer); begin Width := Value; end; procedure TComponentFrame.SetOldCreateOrder(const Value: Boolean); begin end; procedure TComponentFrame.SetPixelsPerInch(const Value: Integer); begin end; procedure TComponentFrame.SetTextHeight(const Value: Integer); begin end; function TComponentFrame.GetClientHeight: Integer; begin Result := Height; end; function TComponentFrame.GetClientWidth: Integer; begin Result := Width; end; { TComponentFrame } constructor TComponentFrame .Create(AOwner: TComponent); begin inherited; Assert (AOwner <> nil); Assert (AOwner.InheritsFrom (TFrameControl)); end; function TComponentFrame .GetController: TFrameControl; begin Result := TFrameControl (Owner); end; end. With this class, adding a frame as a component becomes a two-stage process: // frame unit type TFilteredList = class; TFrmFilteredList = class (TComponentFrame ) // lots of published sub-components and event methods like this one: procedure BtnFooClick(Sender: TObject); end; TFilteredList = class (TFrameControl ) private procedure Foo; public // the component's public interface published // the component's published properties end; procedure Register; ... procedure Register; begin RegisterComponents ('CBDE Components', [TFilteredList]); end; procedure TFrmFilteredList.BtnFooClick(Sender: TObject); begin Controller.Foo; end; procedure TFilteredList.Foo; begin end; ... When using this approach, the user of your component won't see your sub-components.
