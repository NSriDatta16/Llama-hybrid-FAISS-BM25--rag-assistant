[site]: stackoverflow
[post_id]: 2589432
[parent_id]: 2575188
[tags]: 
After some research and deliberation I've decided to go with trie/finite state machine approach. The string is parsed starting from the last character going backwards using a TRIE as long as the portion of suffix that was parsed so far can correspond to multiple suffixes. At some point we either hit the first character of one of the possible suffixes which means that we have a match, hit a dead end, which means there are no more possible matches or get into situation where there is only one suffix candidate. In this case we just do compare remainder of the suffix. Since trie lookups are constant time, worst case complexity is o(maximum suffix length). The function turned out to be pretty fast. On 2.8Ghz Core i5 it can check 33,000,000 strings per second for 2K possible suffixes. 2K suffixes totaling 18 kilobytes, expanded to 320kb trie/state machine table. I guess that I could have stored it more efficiently but this solution seems to work good enough for the time being. Since suffix list was so large, I didn't want to code it all by hand so I ended up writing C# application that generated C code for the suffix checking function: public static uint GetFourBytes(string s, int index) { byte[] bytes = new byte[4] { 0, 0, 0, 0}; int len = Math.Min(s.Length - index, 4); Encoding.ASCII.GetBytes(s, index, len, bytes, 0); return BitConverter.ToUInt32(bytes, 0); } public static string ReverseString(string s) { char[] chars = s.ToCharArray(); Array.Reverse(chars); return new string(chars); } static StringBuilder trieArray = new StringBuilder(); static int trieArraySize = 0; static void Main(string[] args) { // read all non-empty lines from input file var suffixes = File .ReadAllLines(@"suffixes.txt") .Where(l => !string.IsNullOrEmpty(l)); var reversedSuffixes = suffixes .Select(s => ReverseString(s)); int start = CreateTrieNode(reversedSuffixes, ""); string outFName = @"checkStringSuffix.debug.h"; if (args.Length != 0 && args[0] == "--release") { outFName = @"checkStringSuffix.h"; } using (StreamWriter wrt = new StreamWriter(outFName)) { wrt.WriteLine( "#pragma once\n\n" + "#define TRIE_NONE -1000000\n"+ "#define TRIE_DONE -2000000\n\n" ); wrt.WriteLine("const int trieArray[] = {{{0}\n}};", trieArray); wrt.WriteLine( "inline bool checkSingleSuffix(const char* str, const char* curr, const int* trie) {\n"+ " int len = trie[0];\n"+ " if (curr - str 0) {\n"+ " if (*--curr != *cmp++) return false;\n"+ " }\n"+ " return true;\n"+ "}\n\n"+ "bool checkStringSuffix(const char* str, int len) {\n" + " if (len s.Length).Min().ToString() + ") return false;\n" + " const char* curr = (str + len - 1);\n"+ " int currTrie = " + start.ToString() + ";\n"+ " while (curr >= str) {\n" + " assert(*curr >= 0x20 && *curr suffixes, string prefix) { int retVal = trieArraySize; if (suffixes.Count() == 1) { string theSuffix = suffixes.Single(); trieArray.AppendFormat("\n\t/* {1} - {2} */ {0}, ", theSuffix.Length, trieArraySize, prefix); ++trieArraySize; for (int i = 0; i s == string.Empty)) { trieIndexes[g.Key - 0x20] = "TRIE_DONE"; continue; } trieIndexes[g.Key - 0x20] = CreateTrieNode(g, g.Key + prefix).ToString(); } trieArray.AppendFormat("\n\t/* {1} - {2} */ {0},", string.Join(", ", trieIndexes), trieArraySize, prefix); retVal = trieArraySize; trieArraySize += 0x60; } return retVal; } So it generates code like this: inline bool checkSingleSuffix(const char* str, const char* curr, const int* trie) { int len = trie[0]; if (curr - str 0) { if (*--curr != *cmp++) return false; } return true; } bool checkStringSuffix(const char* str, int len) { if (len = str) { assert(*curr >= 0x20 && *curr Since for my particular set of data len in checkSingleSuffix was never more than 9, I tried to replace the comparison loop with switch (len) and hardcoded comparison routines that compared up to 8 bytes of data at a time but it didn't affect overall performance at all either way. Thanks for everyone who contributed their ideas!
