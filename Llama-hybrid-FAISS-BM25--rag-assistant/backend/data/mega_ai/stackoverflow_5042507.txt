[site]: stackoverflow
[post_id]: 5042507
[parent_id]: 5007516
[tags]: 
To map this use case you could leverage the following XmlAdapters: AnimalAdapter Since AnimalExtension is a super set of Animal we will use it to produce/consume XML. Then we will leverage the value of the animalId property to determine if an instance of Animal or AnimalExtension will be returned to AnimalList. import javax.xml.bind.annotation.adapters.XmlAdapter; public class AnimalAdapter extends XmlAdapter { @Override public Animal unmarshal(AnimalExtension animalExtension) throws Exception { if(0 != animalExtension.getAnimalId()) { return animalExtension; } Animal animal = new Animal(); animal.setName(animalExtension.getName()); return animal; } @Override public AnimalExtension marshal(Animal animal) throws Exception { if(animal.getClass() == AnimalExtension.class) { return (AnimalExtension) animal; } AnimalExtension animalExtension = new AnimalExtension(); animalExtension.setName(animal.getName()); return animalExtension; } } IdAdapter We will need a second XmlAdapter to suppress animalId if its value is 0: import javax.xml.bind.annotation.adapters.XmlAdapter; public class IdAdapter extends XmlAdapter { @Override public Integer unmarshal(String string) throws Exception { return Integer.valueOf(string); } @Override public String marshal(Integer integer) throws Exception { if(integer == 0) { return null; } return String.valueOf(integer); } } Your model classes will be annotated as follows: AnimalList import java.util.ArrayList; import java.util.List; import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlRootElement; import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter; @XmlRootElement(name="AnimalList") public class AnimalList { private List animalList = new ArrayList (); @XmlElement(name="Animal") @XmlJavaTypeAdapter(AnimalAdapter.class) public List getEntries() { return animalList; } } Animal import javax.xml.bind.annotation.XmlAttribute; public class Animal { private String name; @XmlAttribute public String getName() { return name; } public void setName(String name) { this.name = name; } } AnimalExtension import javax.xml.bind.annotation.XmlAttribute; import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter; public class AnimalExtension extends Animal { private int animalId; @XmlAttribute(name="id") @XmlJavaTypeAdapter(IdAdapter.class) public int getAnimalId() { return animalId; } public void setAnimalId(int animalId) { this.animalId = animalId; } } Demo Code The following demo code can be used to demonstrate this solution: import java.io.File; import javax.xml.bind.JAXBContext; import javax.xml.bind.Marshaller; import javax.xml.bind.Unmarshaller; public class Demo { public static void main(String[] args) throws Exception { JAXBContext jc = JAXBContext.newInstance(AnimalList.class); Unmarshaller unmarshaller = jc.createUnmarshaller(); File xml = new File("input.xml"); AnimalList animalList = (AnimalList) unmarshaller.unmarshal(xml); for(Animal animal : animalList.getEntries()) { System.out.println(animal.getClass()); } Marshaller marshaller = jc.createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); marshaller.marshal(animalList, System.out); } } The following output will be produced: class AnimalExtension class Animal Related Information You may find the following information useful: http://bdoughan.blogspot.com/2010/07/xmladapter-jaxbs-secret-weapon.html http://bdoughan.blogspot.com/2010/07/xmladapter-jaxbs-secret-weapon.html http://bdoughan.blogspot.com/2010/11/jaxb-and-inheritance-using-substitution.html
