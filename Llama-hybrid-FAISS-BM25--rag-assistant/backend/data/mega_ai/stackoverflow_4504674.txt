[site]: stackoverflow
[post_id]: 4504674
[parent_id]: 4502115
[tags]: 
I would strongly recommend using a preprocessor. I like c2hs, but hsc2hs is very common because it's included with ghc. Greencard appears to be abandoned. To answer your questions: 1) Yes, through the definition of the Storable instance. Using Storable is the only safe mechanism to pass data through the FFI. The Storable instance defines how to marshal data between a Haskell type and raw memory (either a Haskell Ptr, ForeignPtr, or StablePtr, or a C pointer). Here's an example: data PlateC = PlateC { numX :: Int, numY :: Int, v1 :: Double, v2 :: Double } deriving (Eq, Show) instance Storable PlateC where alignment _ = alignment (undefined :: CDouble) sizeOf _ = {#sizeof PlateC#} peek p = PlateC fmap fI ({#get PlateC.numX #} p) fmap fI ({#get PlateC.numY #} p) fmap realToFrac ({#get PlateC.v1 #} p) fmap realToFrac ({#get PlateC.v2 #} p) poke p (PlateC xv yv v1v v2v) = do {#set PlateC.numX #} p (fI xv) {#set PlateC.numY #} p (fI yv) {#set PlateC.v1 #} p (realToFrac v1v) {#set PlateC.v2 #} p (realToFrac v2v) The {# ... #} fragments are c2hs code. fI is fromIntegral . The values in the get and set fragments refer to the following struct from an included header, not the Haskell type of the same name: struct PlateCTag ; typedef struct PlateCTag { int numX; int numY; double v1; double v2; } PlateC ; c2hs converts this to the following plain Haskell: instance Storable PlateC where alignment _ = alignment (undefined :: CDouble) sizeOf _ = 24 peek p = PlateC fmap fI ((\ptr -> do {peekByteOff ptr 0 ::IO CInt}) p) fmap fI ((\ptr -> do {peekByteOff ptr 4 ::IO CInt}) p) fmap realToFrac ((\ptr -> do {peekByteOff ptr 8 ::IO CDouble}) p) fmap realToFrac ((\ptr -> do {peekByteOff ptr 16 ::IO CDouble}) p) poke p (PlateC xv yv v1v v2v) = do (\ptr val -> do {pokeByteOff ptr 0 (val::CInt)}) p (fI xv) (\ptr val -> do {pokeByteOff ptr 4 (val::CInt)}) p (fI yv) (\ptr val -> do {pokeByteOff ptr 8 (val::CDouble)}) p (realToFrac v1v) (\ptr val -> do {pokeByteOff ptr 16 (val::CDouble)}) p (realToFrac v2v) The offsets are of course architecture-dependent, so using a pre-processer allows you to write portable code. You use this by allocating space for your data type ( new , malloc , etc.) and poke ing the data into the Ptr (or ForeignPtr). 2) This is the real memory layout. 3) There is a penalty for reading/writing with peek / poke . If you have a lot of data, it's better to convert only what you need, e.g. reading just one element from a C array instead of marshalling the entire array to a Haskell list. 4) Syntax depends upon the preprocessor you choose. c2hs docs . hsc2hs docs . Confusingly, hsc2hs uses the syntax #stuff or #{stuff} , while c2hs uses {#stuff #} . 5) @sclv's suggestion is what I would do as well. Write a Storable instance and keep a pointer to the data. You can either write C functions to do all the work and call them through the FFI, or (less good) write low-level Haskell using peek and poke to operate on just the parts of the data you need. Marshalling the whole thing back and forth (i.e. calling peek or poke on the entire data structure) will be expensive, but if you only pass pointers around the cost will be minimal. Calling imported functions through the FFI has a significant penalty unless they're marked "unsafe". Declaring an import "unsafe" means that the function should not call back into Haskell or undefined behavior results. If you're using concurrency or parallelism, it also means that all Haskell threads on the same capability (i.e. CPU) will block until the call returns, so it should return fairly quickly. If those conditions are acceptable an "unsafe" call is relatively fast. There are a lot of packages on Hackage that deal with this sort of thing. I can recommend hsndfile and hCsound as exhibiting good practice with c2hs. It's probably easier if you look at a binding to a small C library you're familiar with though.
