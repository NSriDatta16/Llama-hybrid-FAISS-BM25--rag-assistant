[site]: stackoverflow
[post_id]: 220869
[parent_id]: 220752
[tags]: 
In a nutshell, the C++ memory model consists of... A stack that grows downward -- that is, when you push a stack frame the stack pointer has a value less that it was A heap that grows upward, that is the end address of the newly allocated memory is greater it was before the memory. You allocate memory in the heap using malloc() or new. If there is not enough memory available in the heap then malloc (or new) calls the system function brk() sbrk() to increase the size of the heap. If the call to brk() or sbrk() fails then malloc or new fails with an out of memory exception. You should never need to care whether the stack or heap grow down or up and in some systems these may operate the other way around. Just consider that the stack and heap grow inwards from the ends of the address space. A memory allocator, malloc, which allocates memory in terms of 8-bit bytes. New also allocates memory, but the amount of memory that it allocates is based on the size of the object being newed. Text space which contains the executable code. Text resides below the heap. You cannot alter the text space during execution A program may have other special purpose sections below text. You can see how a program is organized statically (before it's loaded) using objdump on linux systems. I noticed that although you didn't mention it in your question, "concurrency" is one of the keywords you assigned to this question. Threading systems allcoate additional thread space on the heap for each thread and then manage the stack pointer to switch between threads. There are a lot more details, many of which are specific to particluar hardware, OSes, or threading system, but that's the essential idea.
