[site]: stackoverflow
[post_id]: 2803049
[parent_id]: 2801879
[tags]: 
There is no need to replicate any of TextField 's functionality in your own component, instead you should create a component mixin. Mixins are designed to add behaviour to existing components. From the Tapestry 5 docs : Tapestry 5 includes a radical feature, component mixins. Component mixins are a tricky concept; it basically allows a true component to be mixed together with special limited components called mixins. The component plus its mixins are represented as just a single tag in the component template, but all the behavior of all the elements. You would use the mixin like this: A mixin stub: @IncludeJavaScriptLibrary("MyMixin.js") public class MyMixin { /** * Some string param. */ @Parameter(required = true, defaultPrefix = BindingConstants.LITERAL) private String someParam; @Environmental private RenderSupport renderSupport; @InjectContainer private AbstractTextField field; @AfterRender void addScript() { this.renderSupport.addScript("new MyJavascriptClass('%s', '%s');", this.field.getClientId(), this.someParam); } } Note the @InjectContainer annotation, which injects the containing TextField into your Mixin. In this case, we want the TextField's clientId. Also note the @IncludeJavaScriptLibrary("MyMixin.js") annotation, which includes the required Javascript file. The Javascript could look like this: MyJavascriptClass = Class.create({ initialize: function(textField, someParam) { this.textField = $(textField); this.someParam = someParam; this.textField.observe('focus', this.onFocus.bindAsEventListener(this)); }, onFocus: function(event) { //do something } } The key difference to your approach is that this involves defining your own JS class and using Tapestry's built-in facilities to load and initialize the JS. The use of mixins is also relatively light-weight and elegant in comparison to creating your own components.
