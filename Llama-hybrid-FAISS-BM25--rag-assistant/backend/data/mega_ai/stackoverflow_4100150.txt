[site]: stackoverflow
[post_id]: 4100150
[parent_id]: 4089225
[tags]: 
Rob, thank you for offering to help and pointing out the difference in the MD5 hashes. Your answer got me thinking in the right direction. I spent another whole day digging into this but luckily (and thanks to your remark :)) I finally managed to resolve the problem. It turned out there were actually two issues in my case: 1) The MD5 hash : I noticed the hash you pasted in your answer is shorter than the one I was getting but it took me a while to see yours was exactly twice shorter. After some experimentation I found out that the GetMD5HashFromStream() method from your test application is converting the 16-byte hash generated by the MD5CryptoServiceProvider to a 32-character string. And it was this 32-character string that was causing the problem because it was converted to Base64 and passed to the PutBlock() method, hence the twice longer and thus invalid hash that the blob storage service was complaining about. Here is the code I ended up with: Original: public static string GetMD5HashFromStream(byte[] data) { MD5 md5 = new MD5CryptoServiceProvider(); byte[] retVal = md5.ComputeHash(data); StringBuilder sb = new StringBuilder(); for (int i = 0; i and the call to PutBlock(): // calculate the block-level hash string blockHash = Helpers.GetMD5HashFromStream(buff); blob.PutBlock(transferDetails[j].BlockId, new MemoryStream(buff), blockHash, options); Final: MD5 md5 = new MD5CryptoServiceProvider(); byte[] blockHash = md5.ComputeHash(buff); string convertedHash = Convert.ToBase64String(blockHash, 0, 16); blob.PutBlock(transferDetails[j].BlockId, new MemoryStream(buff), convertedHash, options); Rob, I'm really curious how your code worked in your case and why it didn't in mine - is it something specific to the setup on my machine, or perhaps a differing version of the Azure tools (I'm using v1.2)... Please let me know if you have any idea. 2) A bug in the development storage : lots of combing through the web led me to this page that mentions an obscure but apparently known bug in the development storage: If two requests attempt to upload a block to a blob that does not yet exist in development storage, one request will create the blob, and the other may return status code 409 (Conflict), with storage services error code BlobAlreadyExists. Here is what I came up with to work around it: public static bool IsDevelopmentStorageRunning() { return new Microsoft.ServiceHosting.Tools.DevelopmentStorage.DevStore().IsRunning(); } You will need to add a reference to Microsoft.ServiceHosting.Tools.dll , which was located in " C:\Program Files\Windows Azure SDK\v1.2\bin " on my machine. Then, I use this method before the Parallel.For loop that processes the file chunks as follows: bool isDevStorageRunning = StorageProxy.IsDevelopmentStorageRunning(); ParallelOptions parallelOptions = new ParallelOptions(); parallelOptions.MaxDegreeOfParallelism = isDevStorageRunning ? 1 : 4; Parallel.For(0, transferDetails.Length, parallelOptions, j => { ... }); I hope this will save someone all the hassles I went through. Rob, thank you once again for helping out :)
