[site]: stackoverflow
[post_id]: 3650075
[parent_id]: 3650037
[tags]: 
You implement this in COM with aggregation. Basically, you create an object that implements some interfaces, and wraps access to an inner object. The inner object you create by calling CoCreateInstance and passing your own objects IUnknown in as the pUnkOuter parameter. If the inner object supports it (properly) it will defer all interface calls to the outer object, giving your object the first chance to provide any interfaces. Note that tragically few COM objects actually support aggregation - because implementing support is (a) hard to get right, and (b) hard to justify in any development model where code is written to meet some immediate need (which covers most of the current buzzword laden development methodologies) - I sadly expect that most com objects would (in the best case) respond with E_NOTSUPPORTED, or (in the worst case) have some half tested attempt as aggregation support that mostly results in infinite recursion as soon as its used in a non trivial way. If you do find a com object with working out-the-box aggregation support - you should have used that luck on a lottery ticket. :P
