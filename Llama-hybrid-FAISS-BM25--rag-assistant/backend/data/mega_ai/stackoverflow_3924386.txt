[site]: stackoverflow
[post_id]: 3924386
[parent_id]: 3924135
[tags]: 
My quick answers without double checking (its been awhile since I've developed in C++) are: arraytotal has not been initialized I suspect that your compiler flags this as an error to make sure you do it. If you don't, you can't be sure what it will be initialized to. Traditionally for debug builds, C/C++ initialized memory to some debug value to help identify uninitialized variables. Set arrayTotal = 0 when it is initialized and that should go away. (Best practice) e.g. double arrayTotal = 0; external reference in main I suspect this is because your prototype for averageN does not match the method defined later. A prototype needs to include the types of the parameters as well as the return type. Change the prototype from double averageN(); to double averageN(double []); and I believe that will fix that problem. does an arraySize have to be const always? is it so it doesnt channge after the array has been created? Since you are using it to define the size of the array passed into averageN, yes. Setting the size of the array like this requires a constant value. This array is being created in the function averageN() but why? cant i just create it up top and reference it in? It is not being created in averageN. It is a formal parameter to averageN. The caller of averageN needs to provide the appropriate variable and pass it in. Then from within the method, you access it through decimals. why do you have to write the name of the function up here before you even create it? This is the function prototype. It is necessary if the function is referenced in code before the function is defined. This could be resolved in other ways as well, such as moving the definition of averageN before all uses of it.
