[site]: stackoverflow
[post_id]: 5132524
[parent_id]: 5131981
[tags]: 
If Marc Gravell's detailed answer does not meet your needs, the only way I can think of accomplishing what you desire is via reflection. State that is captured in a lambda closure become public fields (conveniently named the same as the captured variables) of a compiler-generated class. This class defines a method containing the contents of the lambda itself and will be the method for the Action delegate. An instance of this class will be the delegate's target. For simplicity's sake, I'll use C# 4.0's dynamic keyword for this example. For your needs, you'd probably want to use "proper" reflection to discover the fields so you don't have to know their names in advance (plus the fact that some of the fields would be optional). void Foo(Action action) { dynamic o = action.Target; o.data = "ick"; action(); } //... string data = "ugh"; Foo(() => Console.WriteLine(data)); The result is that "ick" is written to the console. This is how I feel about this solution. Besides the feeling this just oozes hack, the fact the type we're using here has [CompilerGenerated] slapped on it should give you pause: there is no contract between you and the compiler. Later versions of the compiler are free to change how this all works behind the scenes. Ultimately, this solution is fragile at best.
