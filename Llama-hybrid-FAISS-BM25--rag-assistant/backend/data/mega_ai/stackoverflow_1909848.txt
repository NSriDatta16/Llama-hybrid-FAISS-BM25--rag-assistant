[site]: stackoverflow
[post_id]: 1909848
[parent_id]: 1909677
[tags]: 
Hmm, IMHO DDD is not so much about 'layering'. It's more about modelling the problem you're trying to tackle in a good way, so that your model (entities, value objects, repositories, services, specifications) reflect the real world problem-domain. However, there is indeed some kind of 'separation' between the classes you write, but I really wouldn't go so far as calling it 'layering', since IMHO it is perfectly OK that your presentation classes and domain classes access the infrastructure for instance. However, the domain classes should have no dependency on the presentation classes for instance, but the opposite can be true ofcourse. I mostly organize my projects in this way: a have an assembly which contains the presentation related stuff. (Forms, etc...) I have an assembly which contains the 'domain'. This includes entities, repository- interfaces, specification classes, etc... another assembly which contains the repository implementations. a set of infrastructure assemblies: a general 'framework' dll which contains utils that I can use in my presentation, in my domain classes, etc... a dll which contains helpers for DB access (in my case, a thin wrapper around NHibernate). In contrary to what Nathan Hughes says, I think it is perfectly OK that your presentation layer has access to the infrastructure, as I sometimes omit an 'application service layer'. In such case, my presentation layer is my application. I use NHibernate as well, and for me, it is ok that my presentation layer accesses the NHibernate helpers. Since, my application (which is my presentation layer in some cases), is the only 'thing' that has knowledge of the context of the application. So that's the one who'se responsible for starting and committing transactions for instance. (As Evans says -in chapter 5 I think: Context is King).
