[site]: stackoverflow
[post_id]: 4440734
[parent_id]: 4440651
[tags]: 
This won't work: In your example application.getClass().getName() will always return "java.lang.String" , as you are getting the type of the "application" parameter. Moreover, in Java, the invoked method can not find out the type from where it's being invoked, so perhaps, you should check your design, implementing some other kind of access control. EDIT : let me add an example, based on your code, on how you could try to check the type of the invoker, and how it would not avoid invocations from other sources: //Change the String for an Object, to allow the invoker pass a //reference to itself public byte[] getStoragePrivateKey(Object application) { if (application.getClass().getName().equals("correctClass") { // Allow access to Private Key. } else { // Access denied } } From the referencing type A, the invoking could be: B b=new B(); byte[] key=b.getStoragePrivateKey(this); Calling it from a C "impersonator" class, would fail, as this is a C.class instance: B b=new B(); byte[] key=b.getStoragePrivateKey(this); But, avoiding the validation it's as easy as: B b=new B(); A a=new A(); byte[] key=b.getStoragePrivateKey(a);
