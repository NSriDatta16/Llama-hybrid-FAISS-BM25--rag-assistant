[site]: stackoverflow
[post_id]: 2517746
[parent_id]: 2517663
[tags]: 
It really depends on what you consider a "good idea". This works, and it works in a fairly elegant manner. It has some advantages and some disadvantages to other approaches. On the advantage side: It's concise, and easy to extend The code is fairly simple For the disadvantages: Error checking is potentially more difficult than a classic visitor implementation, since all error checking must be done at runtime. For example, if you pass visitorTest.DynamicVisit(4.2); , you'll get an exception at runtime, but no compile time complaints. The code may be less obvious, and have a higher maintenance cost. Personally, I think this is a reasonable approach. The visitor pattern, in a classic implementation, has a fairly high maintenance cost and is often difficult to test cleanly. This potentially makes the cost slightly higher, but makes the implementation much simpler. With good error checking, I don't have a problem with using dynamic as an approach here. Personally, I'd probably use an approach like this, since the alternatives that perform in a reasonable manner get pretty nasty otherwise. However, there are a couple of changes I would make here. First, as I mentioned, you really need to include error checking. Second, I would actually make DynamicVisit take a dynamic directly, which might make it (slightly) more obvious what's happening: class VistorTest { public string DynamicVisit(dynamic obj) { try { return Visit(obj); } catch (RuntimeBinderException e) { // Handle the exception here! Console.WriteLine("Invalid type specified"); } return string.Empty; } // ...Rest of code
