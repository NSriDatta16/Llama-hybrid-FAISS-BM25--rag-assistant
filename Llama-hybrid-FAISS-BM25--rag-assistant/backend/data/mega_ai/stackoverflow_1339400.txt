[site]: stackoverflow
[post_id]: 1339400
[parent_id]: 1339293
[tags]: 
Have you tried gc.set_debug() ? You need to ask yourself simple questions: Am I using objects with __del__ methods? Do I absolutely, unequivocally, need them? Can I get reference cycles in my code? Can't we break these circles before getting rid of the objects? See, the main issue would be a cycle of objects containing __del__ methods: import gc class A(object): def __del__(self): print 'a deleted' if hasattr(self, 'b'): delattr(self, 'b') class B(object): def __init__(self, a): self.a = a def __del__(self): print 'b deleted' del self.a def createcycle(): a = A() b = B(a) a.b = b return a, b gc.set_debug(gc.DEBUG_LEAK) a, b = createcycle() # remove references del a, b # prints: ## gc: uncollectable ## gc: uncollectable ## gc: uncollectable ## gc: uncollectable gc.collect() # to solve this we break explicitely the cycles: a, b = createcycle() del a.b del a, b # objects are removed correctly: ## a deleted ## b deleted gc.collect() I would really encourage you to flag objects / concepts that are cycling in your application and focus on their lifetime: when you don't need them anymore, do we have anything referencing it? Even for cycles without __del__ methods, we can have an issue: import gc # class without destructor class A(object): pass def createcycle(): # a -> b -> c # ^ | # ^ ##gc: collectable ##gc: collectable ##gc: collectable ##gc: collectable ##gc: collectable gc.collect() a, b, c = createcycle() # but as long as we keep an exterior ref to the cycle...: seen = dict() seen[a] = True # delete the cycle del a, b, c # nothing is collected gc.collect() If you have to use "seen"-like dictionaries, or history, be careful that you keep only the actual data you need, and no external references to it. I'm a bit disappointed now by set_debug , I wish it could be configured to output data somewhere else than to stderr, but hopefully that should change soon .
