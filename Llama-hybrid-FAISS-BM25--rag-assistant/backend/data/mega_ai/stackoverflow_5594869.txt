[site]: stackoverflow
[post_id]: 5594869
[parent_id]: 5594763
[tags]: 
The marshaller helps you with converting between .NET structs and raw bytes. In this answer , I posted a simple solution, which boils down to Marshal.StructureToPtr and Marshal.PtrToStructure . In contrast to the more advanced solutions provided by Johann du Toit, this is in my opinion the best thing you can do if all you want to do is to push some structures through a byte stream. If you do this, you can safely cast to the C++ struct if the length is correct, and your C++ struct is declared with the same packing as the C# struct (i.e. #pragma pack in VC++ or __attribute__((packed)) in GCC). Note that this also works with fixed length C strings, but will not take care of the endianness of larger values. I found it a simple solution to provide getters and setters for the latter problem which just swap the bytes accordingly (with BitConverter ). Some elaboration on the packing: Take the following structure: struct MyStruct { uint8_t a; float b; }; With the C# declaration with StructLayout, Pack = 1, this struct will have a size of five bytes. The C++ struct, however, may have eight bytes (or even more), depending on the default packing of the compiler, who may happily insert some padding bytes to align the float value on a 32-bit boundary (just an example). Because of this, you have to apply the very same packing to both the C# and C++ struct. In Visual C++: #pragma pack(push, 1) // ... struct declarations... #pragma pack(pop) This means all structs declared between the two pragmas will have a packing of one. In GCC: struct x { // ... } __attribute__((packed)); This will do the same. You can #define __attribute__(x) on Windows platforms and #ifdef _WIN32 around the pragmas to make the code compatible with both worlds.
