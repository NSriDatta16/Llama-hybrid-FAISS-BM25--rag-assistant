[site]: stackoverflow
[post_id]: 1877241
[parent_id]: 1876708
[tags]: 
I suggest using a modification of GMan's solution, and create a class containing member functions that are trig function wrappers, and which operate in degrees of radians depending on a mode variable. class cTrig { enum eTrigMode { DEGREES, RADIANS } cTrig( eTrigMode mode = DEGREES ) : m_mode(mode) {} void setMode( eTrigMode mode ) { m_mode = mode } double sin( double theta ) { return std::sin( m_mode == DEGREES ? deg_to_rad(theta) : theta ) ; } // ... etc for all other trig functions } ; That way you can create either two cTrig objects with different modes, or one object and change mode as necessary. I'd go for the former: cTrig degrees( cTrig::DEGREES ) ; cTrig radians( cTrig::RADIANS ) ; double a = degrees.sin( 90 ) ; double b = ragians.sin( M_PI ) ; I'd also include deg_to_rad and rad_to_deg as member functions of cTrig. You could alternatively create cRadian and cDegree types and overload the functions for those types.
