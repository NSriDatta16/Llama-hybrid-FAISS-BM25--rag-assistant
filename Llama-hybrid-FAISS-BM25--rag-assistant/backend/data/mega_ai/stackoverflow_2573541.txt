[site]: stackoverflow
[post_id]: 2573541
[parent_id]: 
[tags]: 
Stack overflow error after creating a instance using 'new'

EDIT - The code looks strange here, so I suggest viewing the files directly in the link given. While working on my engine, I came across a issue that I'm unable to resolve. Hoping to fix this without any heavy modification, the code is below. void Block::DoCollision(GameObject* obj){ obj->DoCollision(this); } That is where the stack overflow occurs. This application works perfectly fine until I create two instances of the class using the new keyword. If I only had 1 instance of the class, it worked fine. Block* a = new Block(0, 0, 0, 5); AddGameObject(a); a = new Block(30, 0, 0, 5); AddGameObject(a); Those parameters are just x,y,z and size. The code is checked before hand. Only a object with a matching Collisonflag and collision type will trigger the DoCollision(); function. ((*list1)->m_collisionFlag & (*list2)->m_type) Maybe my check is messed up though. I attached the files concerned here http://celestialcoding.com/index.php?topic=1465.msg9913;topicseen#new . You can download them without having to sign up. The main suspects, I also pasted the code for below. From GameManager.cpp void GameManager::Update(float dt){ GameList::iterator list1; for(list1=m_gameObjectList.begin(); list1 != m_gameObjectList.end(); ++list1){ GameObject* temp = *list1; // Update logic and positions if((*list1)->m_active){ (*list1)->Update(dt); // Clip((*list1)->m_position); // Modify for bounce affect } else continue; // Check for collisions if((*list1)->m_collisionFlag != GameObject::TYPE_NONE){ GameList::iterator list2; for(list2=m_gameObjectList.begin(); list2 != m_gameObjectList.end(); ++list2){ if(!(*list2)->m_active) continue; if(list1 == list2) continue; if( (*list2)->m_active && ((*list1)->m_collisionFlag & (*list2)->m_type) && (*list1)->IsColliding(*list2)){ (*list1)->DoCollision((*list2)); } } } if(list1==m_gameObjectList.end()) break; } GameList::iterator end = m_gameObjectList.end(); GameList::iterator newEnd = remove_if(m_gameObjectList.begin(),m_gameObjectList.end(),RemoveNotActive); if(newEnd != end) m_gameObjectList.erase(newEnd,end); } void GameManager::LoadAllFiles(){ LoadSkin(m_gameTextureList, "Models/Skybox/Images/Top.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Models/Skybox/Images/Right.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Models/Skybox/Images/Back.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Models/Skybox/Images/Left.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Models/Skybox/Images/Front.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Models/Skybox/Images/Bottom.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Terrain/Textures/Terrain1.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Terrain/Textures/Terrain2.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Terrain/Details/TerrainDetails.bmp", GetNextFreeID()); LoadSkin(m_gameTextureList, "Terrain/Textures/Water1.bmp", GetNextFreeID()); Block* a = new Block(0, 0, 0, 5); AddGameObject(a); a = new Block(30, 0, 0, 5); AddGameObject(a); Player* d = new Player(0, 100,0); AddGameObject(d); } void Block::Draw(){ glPushMatrix(); glTranslatef(m_position.x(), m_position.y(), m_position.z()); glRotatef(m_facingAngle, 0, 1, 0); glScalef(m_size, m_size, m_size); glBegin(GL_LINES); glColor3f(255, 255, 255); glVertex3f(m_boundingRect.left, m_boundingRect.top, m_position.z()); glVertex3f(m_boundingRect.right, m_boundingRect.top, m_position.z()); glVertex3f(m_boundingRect.left, m_boundingRect.bottom, m_position.z()); glVertex3f(m_boundingRect.right, m_boundingRect.bottom, m_position.z()); glVertex3f(m_boundingRect.left, m_boundingRect.top, m_position.z()); glVertex3f(m_boundingRect.left, m_boundingRect.bottom, m_position.z()); glVertex3f(m_boundingRect.right, m_boundingRect.top, m_position.z()); glVertex3f(m_boundingRect.right, m_boundingRect.bottom, m_position.z()); glEnd(); // DrawBox(m_position.x(), m_position.y(), m_position.z(), m_size, m_size, m_size, 8); glPopMatrix(); } void Block::DoCollision(GameObject* obj){ GameObject* t = this; // I modified this to see for sure that it was causing the mistake. // obj->DoCollision(NULL); // Just revert it back to /* void Block::DoCollision(GameObject* obj){ obj->DoCollision(this); } */ }
