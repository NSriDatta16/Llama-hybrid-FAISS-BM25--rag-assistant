[site]: stackoverflow
[post_id]: 5698079
[parent_id]: 
[tags]: 
Using pipe system call in a mini shell

Although my program works correctly in all cases, it doesn't use a pipe to connect the output of the first of two commands to the second when they're separated by a pipe symbol. I wrote the output of the first command to a file, then redirected the standard input of the second command to the file when the process to run that command was run. I need to use a pipe system call to create the pipe and obtain the file descriptors for the pipe, and then run the two processes at the same time. It is a homework question and I have done 99% of the work but somehow am not able to get the pipe system call working... what I've been trying is that for an input like: Command 1 | Command 2 inside the child process for command 2 I close FD[0] then dup FD[1] and for command 1 close FD[1] then dup FD[1] and close FD[0]. I am hell confused with the file descriptors when using pipe.... I have to use a pipe Any sort of help is appreciated. Execute function is where I am forking the processes. Here's my code... #include #include #include #include #include #include #include #include #include /* Global Variables */ extern char **environ; /* Environmental Variables */ char *pathList[10]; /* List of paths from the $PATH */ int pathCount; /* Count of the # of paths in $PATH */ char *pathSet; /* Variable through which $PATH is retrieved */ int hasPipe = 0; int cmdNo = 0; /* This function takes the 'finalPath', the full path to executable,argList[],the full command-line input arguments and argCount, the number of arguments from command-line as input. It the creates a child process, in turn invokes the execve() that finally executes the executable in 'finalPath' with the arguments in 'argText' all stored into the args[] appropriately. Child process also handles input and output file re-direction. */ void execute(char *finalPath, char *argList[], int argCount) { int k,fd,ofound,pos,i; /* flags and temporary variables */ pid_t pid; /* process ID */ int status, which; char msg[100]; char *args[4]; /* argument list for execve() */ int spCase = 0; ofound = 0; pos=0; pid = fork(); /* Creating a new process using fork() */ if (pid == -1) /* Checking for errors in process creation */ { write(1,"Fork failed.\n",12); exit(1); } /************************** Checking for parent process ***************************/ if (pid != 0) { which = wait(&status); if (which == -1) { write(1,"Wait failed.\n",12); exit(1); } if (status & 0xff) { /* Case of abnormal termination */ sprintf(msg,"ERROR: # process %d terminated abnormally for reason %d\n",which, status & 0xff); write(1,msg,strlen(msg)); } else { /* Case of normal termination */ sprintf(msg,"process %d terminated normally with status %d\n",which, (status >> 8) & 0xff); write(1,msg,strlen(msg)); } } /************************* Checking for child process **************************/ if (pid == 0) { char argText[50]; argText[0] = '\0'; int std_fd; if(cmdNo==0 && hasPipe) { close(1); std_fd = open("temp.out", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU); dup(std_fd); } else if(cmdNo==1 && hasPipe) { close(0); std_fd = open("temp.out", O_RDONLY); dup(std_fd); } /* Finding the first re-direction operator */ for( i = 0; i ") == 0) { fd = open(argList[i+1],O_CREAT | O_WRONLY, 0777); pos = i; ofound = 2; strcpy(argText,"\0"); if (fd ") == 0 ) { fd = open(argList[k+1],O_CREAT | O_WRONLY , 0777); spCase = 1; ofound = 2; strcpy(argText,"\0"); if (fd ") == 0 ) { command = argList[2]; } else command = argList[0]; /* In case of no redirection, storing the commands and arguments into a array */ if(strcmp(command,"#") == 0) /* Checking for comment statements */ { write(1,"ERROR: No command(s) found. Only comment present/n",48); } else { if(strstr(command,"/")) /* Checking if the entire path is given as a part of the command */ { exepath = command; found = checkPath(exepath,argList,argCount,0); } else /* building the path and storing it in 'com' */ { for(i = 0; i 1 ) hasPipe = 1; else hasPipe = 0; for( i=0; i # "); /* Storing the personalized shell prompt into 'prompt' */ /* Reading the input from command line and passing it to tokenize() */ while(1) { char inputStr[100]; /* String into which inputs are read into */ chCount = 0; flag = 0; hasPipe = 1; write(1,prompt,strlen(prompt)); /* Printing out the personalized shell prompt */ /* This will read a character 1 by 1 until it reaches the end of file */ entry = read(0,&ch,1); if(!entry) exit(0); /* Reading the input and storing it in inputStr as long as newline is not encountered */ while( entry != 0 && flag == 0 ) { /* A newline has been found so a new command will need to be executed */ /* The inputStr till this point is sent to tokenize() */ if( ch == '\n' ) { inputStr[chCount] = '\0'; flag = 1; if(chCount > 0) { if(strcmp(inputStr,"exit") == 0) exit(3); else tokenize(inputStr); } } inputStr[chCount] = ch; chCount++; if(flag == 0) entry = read( 0, &ch, 1 ); } } }
