[site]: stackoverflow
[post_id]: 1963016
[parent_id]: 1962659
[tags]: 
I found the answer. The child windows of the main window must be subclassed so that the WM_COMMAND messages generated by the keyboard accelerators can be intercepted and passed to the parent window. This involves changing the window procedure of the control to a different one. The alternate procedure handles the messages that should be intercepted by sending them to the parent window. A pointer to the original window procedure must also be stored somewhere so that the control can function correctly. The window procedure can be altered using SetWindowLongPtr with GWLP_WNDPROC. Here is a simple example of how to do this by storing a pointer to the original window procedure in the control's user data value (GWLP_USERDATA): The code to change the window procedure and store the original procedure in GWLP_USERDATA: SetWindowLongPtr( hWnd, GWLP_USERDATA, ( LONG_PTR )SetWindowLongPtr( hWnd, GWLP_WNDPROC, ( LONG_PTR )WndProc ) ); The intercepting window procedure: static LRESULT CALLBACK WndProc( const HWND hWnd, const UINT message, const WPARAM wParam, const LPARAM lParam ) { switch( message ) { case WM_COMMAND: SendMessage( GetParent( hWnd ), message, wParam, lParam ); return 0; default: //Assume that GWLP_USERDATA has been set to the original window procedure. return CallWindowProc( ( WNDPROC )GetWindowLongPtr( hWnd, GWLP_USERDATA ), hWnd, message, wParam, lParam ); } }
