[site]: stackoverflow
[post_id]: 4799242
[parent_id]: 4799136
[tags]: 
Does the sample HTML file use namespaces? If so, your XML parser may be attempting to retrieve contents (a schema, perhaps) from the namespace URIs. This is likely if each run takes exactly two minutes -- it's likely one or more TCP timeouts. You can verify this by timing how long it takes to instantiate your InputSource object (where the WordPress XML is actually parsed), as this is likely the line which is causing the delay. After reviewing the sample file you posted, it does include a declared namespace ( xmlns="http://www.w3.org/1999/xhtml" ). To work around this, you can implement your own EntityResolver which essentially disables the URL-based resolution. You may need to use a DOM -- see DocumentBuilder 's setEntityResolver method. Here's a sample using DOM and disabling resolution (note -- this is untested): try { DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbFactory.newDocumentBuilder(); db.setEntityResolver(new EntityResolver() { @Override public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException { return null; // Never resolve any IDs } }); System.out.println("BUILDING DOM"); Document doc = db.parse(new FileInputStream("/home/pd/XSLT/wordpress.xml")); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); TransformerFactory tFactory = TransformerFactory.newInstance(); Transformer transformer = tFactory.newTransformer( new StreamSource("/home/pd/XSLT/transf.xslt")); System.out.println("RUNNING TRANSFORM"); transformer.transform( new DOMSource(doc.getDocumentElement()), new StreamResult(outputStream)); System.out.println("TRANSFORMED CONTENTS BELOW"); System.out.println(outputStream.toString()); } catch (Exception e) { e.printStackTrace(); } If you want to use SAX, you would have to use a SAXSource with an XMLReader which uses your custom resolver.
