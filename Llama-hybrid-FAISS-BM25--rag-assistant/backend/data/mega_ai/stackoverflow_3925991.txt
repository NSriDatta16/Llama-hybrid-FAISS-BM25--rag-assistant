[site]: stackoverflow
[post_id]: 3925991
[parent_id]: 3921904
[tags]: 
Design is the management and balance of trade-offs. YAGNI and SOLID aren't conflicting: the former says when to add features, the latter says how, but they both guide the design process. My responses, below, to each of your specific quotes use principles from both YAGNI and SOLID. It is three times as difficult to build reusable components as single use components. A reusable component should be tried out in three different applications before it will be sufficiently general to accept into a reuse library. — Robert Glass' Rules of Three , Facts and Fallacies of Software Engineering Refactoring into reusable components has the key element of first finding the same purpose in multiple places, and then moving it. In this context, YAGNI applies by inlining that purpose where needed, without worrying about possible duplication, instead of adding generic or reusable features (classes and functions). The best way, in the initial design, to show when YAGNI doesn't apply is to identify concrete requirements. In other words, do some refactoring before writing code to show that duplication is not merely possible, but already exists: this justifies the extra effort. Yes, I can put all my business logic directly into the GUI code it is much easier and quicker. This will always be the only GUI and it is highly unlikely that signifcant new requirements will ever come in. Is it really the only user interface? Is there a background batch mode planned? Will there ever be a web interface? What is your testing plan, and will you be testing back-end functionality without a GUI? What will make the GUI easy for you to test, since you usually don't want to be testing outside code (such as platform-generic GUI controls) and instead concentrate on your project. It is OK that I put both feature X and feature Y into the same class. It is so simple why bother adding a new class (i.e. complexity). Can you point out a common mistake that needs to be avoided? Some things are simple enough, such as squaring a number ( x * x vs squared(x) ) for an overly-simple example, but if you can point out a concrete mistake someone made—especially in your project or by those on your team—you can show how a common class or function will avoid that in the future. If, in the unlikely case of new requirements, my code gets too cluttered I still can refactor for the new requirement. So your "What if you later need to..." argument doesn't count. The problem here is the assumption of "unlikely". Do you agree it's unlikely? If so, you're in agreement with this person. If not, your idea of the design doesn't agree with this person's—resolving that discrepancy will solve the problem, or at least show you where to go next. :)
