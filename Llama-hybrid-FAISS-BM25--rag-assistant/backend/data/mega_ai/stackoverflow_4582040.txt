[site]: stackoverflow
[post_id]: 4582040
[parent_id]: 4581945
[tags]: 
I believe that you are on the right track. One solution to your problem is saving the parameters in variables. def smartcopy(filestocopy, dest_path, show_progress = False): """Determines what buffer size to use with copy() Setting show_progress to True calls back display_progress()""" #filestocopy is a list of dictionaries for the files needed to be copied #dictionaries are used as the fullpath, st_mtime, and size are needed if len(filestocopy.keys()) == 0: return None #Determines average file size for which buffer to use average_size = 0 for key in filestocopy.keys(): average_size += int(filestocopy[key]['size']) average_size = average_size/len(filestocopy.keys()) #Smaller buffer for smaller files if show_progress: progress_callback = lambda pos, total: display_progress(pos, total, key) else: progress_callback = None #Bigger buffer for bigger files if average_size Or another solution if you want to keep the normal default arguments: def smartcopy(filestocopy, dest_path, show_progress = False): """Determines what buffer size to use with copy() Setting show_progress to True calls back display_progress()""" #filestocopy is a list of dictionaries for the files needed to be copied #dictionaries are used as the fullpath, st_mtime, and size are needed if len(filestocopy.keys()) == 0: return None #Determines average file size for which buffer to use average_size = 0 for key in filestocopy.keys(): average_size += int(filestocopy[key]['size']) average_size = average_size/len(filestocopy.keys()) #Smaller buffer for smaller files kwargs = {} if show_progress: kwargs['callback'] = lambda pos, total: display_progress(pos, total, key) #Bigger buffer for bigger files if average_size >= 1024*10000: #Buffer sizes determined by informal tests on my laptop kwargs['buffer'] = 1024 * 2600 for key, value in filestocopy.iteritems(): #dest_path+key is the destination path, as the key is the relative path #and the dest_path is the top level folder copy(value['fullpath'], dest_path+key, **kwargs) A little extra note, something like this: if len(filestocopy.keys()) == 0: return None Could also be written like this: if not filestocopy: return The loop itself could be simplified to this: for key, value in filestocopy.iteritems(): #dest_path+key is the destination path, as the key is the relative path #and the dest_path is the top level folder copy(value['fullpath'], dest_path+key, **kwargs) And the keys() is never really needed when iterating dictionaries as that's the default behaviour :) So, the following lines will all get the same results: keys = list(some_dict) keys = some_dict.keys() keys = list(some_dict.keys()) keys = list(some_dict.iterkeys())
