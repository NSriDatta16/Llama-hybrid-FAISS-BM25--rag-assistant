[site]: stackoverflow
[post_id]: 1508836
[parent_id]: 
[tags]: 
What is the best way to hold an Entity Framework object graph in memory?

I have a long running process that integrates over a collection of incoming Entities to work out if the incoming entity is different from the entity in persistent storage. When I first wrote this I retrieved each entity from the database that matched the entity I was comparing against, I also had some includes to pull in referenced entities that I also needed to compare. This was incredibly slow because each compare involved a database query and then Entity Framework 'fix up'. I am now using a query to pull in all the entities I need for my comparisons before I start the process. This lets me take the speed hit up front so I can significantly speed up my process. However the intial query still takes at least a minute or two to execute. Dictionary someEntities = new SomeEntitiesInclude().ApplyTo(context.SomeEntities) .Where(se => se.SomeRelatedEntity.ID == relatedEntityID) .Where(se => se.SCDCurrent == true) .OrderBy (se => se.SomeRelatedEntity.ID) .ToDictionary (se => se.SomeRelatedEntity.ID); The actual sql query produced from this only takes a couple of seconds to execute so I think most of the time is spent doing 'fix up' so the context can track changes. The SomeEntitiesInclude object lets me use strongly typed include statements and is a sub class of the IncludeStratergy class developed by Alex James : http://blogs.msdn.com/alexj/archive/2009/07/25/tip-28-how-to-implement-include-strategies.aspx Does any one have tips to speed up the execution of this? Apologies for the long question. James
