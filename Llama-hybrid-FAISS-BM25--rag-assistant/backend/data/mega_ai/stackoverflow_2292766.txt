[site]: stackoverflow
[post_id]: 2292766
[parent_id]: 2292647
[tags]: 
Well, an array of Derived is not an array of Base . If you need to upcast a Derived* to a Base* , you should allocate an array of pointers to Base or, preferably, a vector vector data(100); // Initialize the elements for (vector ::iterator it = data.begin(); it != data.end(); ++it) { *it = new Derived; } doStuff(data); // Destroy the elements for (vector ::iterator it = data.begin(); it != data.end(); ++it) { delete *it; } And your doStuff function becomes: void doStuff(const vector & data) { // Copy the objects, not the pointers vector newdata; for (vector ::const_iterator it = data.begin(); it != data.end(); ++it) { newdata.push_back((*it)->clone()); } // Do stuff // Destroy the copies for (vector ::iterator it = newdata.begin(); it != newdata.end(); ++it) { delete *it; } } Note that, to copy the objects without knowing whether they are Base or Derived , we need to use the virtual constructor idiom . It requires modifying Base and Derived like this: struct Base{ ... virtual Base* clone() const { return new Base(*this); } virtual ~Base() {} }; struct Derived : public Base { ... Derived* clone() const { return new Derived(*this); } };
