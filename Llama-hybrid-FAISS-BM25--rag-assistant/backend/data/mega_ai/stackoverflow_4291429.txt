[site]: stackoverflow
[post_id]: 4291429
[parent_id]: 4291288
[tags]: 
In Java, arrays are reference types, not value types. This means that array variables only store references to the actual array. For example, consider this code: int[] numbers = new int[3]; In this example, numbers is a reference to an array of 3 int s. This can be illustrated as follows: Java Stack | Java Heap | | Array of ints: +---------+ | +---+---+---+ | numbers |-------------->| 0 | 0 | 0 | +---------+ | +---+---+---+ | 0 1 2 Now suppose you have a method like this: public void compute(int[] someValues) { someValues[2] = 78; } And suppose you call this method with your numbers variable as the argument: int[] numbers = new int[3]; compure(numbers); In this case the numbers reference is passed by value to compute . Therefore, someValues is a copy of the numbers reference (not a copy of the array that numbers refers to). Therefore, it looks something like this: Java Stack | Java Heap | | Array of ints: +---------+ | +---+---+---+ | numbers |-------------->| 0 | 0 | 0 | +---------+ | --> +---+---+---+ | / 0 1 2 +------------+ | / | someValues |-----/ +------------+ | After compute returns, it will look like this: Java Stack | Java Heap | | Array of ints: +---------+ | +---+---+----+ | numbers |-------------->| 0 | 0 | 78 | +---------+ | --> +---+---+----+ | / 0 1 2 +------------+ | / | someValues |-----/ +------------+ | numbers[2] will be equal to someValues[2] because numbers and someValues reference the same array. Sigh , it appears this has been answered similarly since I began writing my answer. Hopefully the ASCII diagrams make it worth keeping!
