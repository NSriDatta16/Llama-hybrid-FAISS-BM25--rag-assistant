[site]: stackoverflow
[post_id]: 608700
[parent_id]: 393395
[tags]: 
This is quite easy to do. You can implement Orion's suggestion, but you can also implement the broader technique illustrated below, which gives you access to the current controller from any model and for whichever purpose you decided to break MVC separation for (e.g. messing with the fragment cache, accessing current_user , generating paths/URLs, etc.) In order to gain access to the current request's controller (if any) from any model , add the following to environment.rb or, much preferably, to a new plugin (e.g. create vendor/plugins/controller_from_model/init.rb containing the code below): module ActiveRecord class Base protected def self.thread_safe_current_controller #:nodoc: Thread.current[:current_controller] end def self.thread_safe_current_controller=(controller) #:nodoc: Thread.current[:current_controller] = controller end # pick up the correct current_controller version # from @@allow_concurrency if @@allow_concurrency alias_method :current_controller, :thread_safe_current_controller alias_method :current_controller=, :thread_safe_current_controller= else cattr_accessor :current_controller end end end Then, in app/controllers/application.rb , class ApplicationController Then, from any model , if controller = ActiveRecord::Base.current_controller # called from within a user request else # no controller is available, didn't get here from a request - maybe irb? fi Anyhow, in your particular case you might want to inject code into your various ActiveRecord::Base descendants when the relevant controller classes load, so that the actual controller-aware code still resides in app/controllers/*.rb , but it is not mandatory to do so in order to get something functional (though ugly and hard to maintain.) Have fun!
