[site]: stackoverflow
[post_id]: 3707039
[parent_id]: 3706264
[tags]: 
If you are multiplying two values that you don't know in advance, it is effectively impossible to beat the multiply instruction in x86 assembler. If you know the value of one of the operands in advance, you may be able beat the multiply instruction by using a small number of adds. This works particularly well when the known operand is small, and only has a few bits in its binary representation. To multiply an unknown value x by a known value consisting 2^p+2^q+...2^r you simply add x*2^p+x*2^q+..x*2*r if bits p,q, ... and r are set. This is easily accomplished in assembler by left shifting and adding: ; x in EDX ; product to EAX xor eax,eax shl edx,r ; x*2^r add eax,edx shl edx,q-r ; x*2^q add eax,edx shl edx,p-q ; x*2^p add eax,edx The key problem with this is that it takes at least 4 clocks to do this, assuming a superscalar CPU constrained by register dependencies. Multiply typically takes 10 or fewer clocks on modern CPUs, and if this sequence gets longer than that in time you might as well do a multiply. To multiply by 9: mov eax,edx ; same effect as xor eax,eax/shl edx 1/add eax,edx shl edx,3 ; x*2^3 add eax,edx This beats multiply; should only take 2 clocks. What is less well known is the use of the LEA (load effective address) instruction, to accomplish fast multiply-by-small-constant. LEA which takes only a single clock worst case its execution time can often by overlapped with other instructions by superscalar CPUs. LEA is essentially "add two values with small constant multipliers". It computes t=2^k*x+y for k=1,2,3 (see the Intel reference manual) for t, x and y being any register. If x==y, you can get 1,2,3,4,5,8,9 times x, but using x and y as seperate registers allows for intermediate results to be combined and moved to other registers (e.g., to t), and this turns out to be remarkably handy. Using it, you can accomplish a multiply by 9 using a single instruction: lea eax,[edx*8+edx] ; takes 1 clock Using LEA carefully, you can multiply by a variety of peculiar constants in a small number of cycles: lea eax,[edx*4+edx] ; 5 * edx lea eax,[eax*2+edx] ; 11 * edx lea eax,[eax*4] ; 44 * edx To do this, you have to decompose your constant multiplier into various factors/sums involving 1,2,3,4,5,8 and 9. It is remarkable how many small constants you can do this for, and still only use 3-4 instructions. If you allow the use other typically single-clock instructions (e.g, SHL/SUB/NEG/MOV) you can multiply by some constant values that pure LEA can't do as efficiently by itself. To multiply by 31: lea eax,[4*edx] lea eax,[8*eax] ; 32*edx sub eax,edx; 31*edx ; 3 clocks The corresponding LEA sequence is longer: lea eax,[edx*4+edx] lea eax,[edx*2+eax] ; eax*7 lea eax,[eax*2+edx] ; eax*15 lea eax,[eax*2+edx] ; eax*31 ; 4 clocks Figuring out these sequences is a bit tricky, but you can set up an organized attack. Since LEA, SHL, SUB, NEG, MOV are all single-clock instructions worst case, and zero clocks if they have no dependences on other instructions, you can compute the exeuction cost of any such sequence. This means you can implement a dynamic programmming algorithm to generate the best possible sequence of such instructions. This is only useful if the clock count is smaller than the integer multiply for your particular CPU (I use 5 clocks as rule of thumb), and it doesn't use up all the registers, or at least it doesn't use up registers that are already busy (avoiding any spills). I've actually built this into our PARLANSE compiler, and it is very effective for computing offsets into arrays of structures A[i], where the size of the structure element in A is the known constant. A clever person would possibly cache the answer so it doesn't have to be recomputed each time multiplying the same constant occurs; I didn't actually do that because the time to generate such sequences is less than you'd expect. Its is mildly interesting to print out the sequences of instructions needed to multiply by all constants from 1 to 10000. Most of them can be done in 5-6 instructions worst case. As a consequence, the PARLANSE compiler hardly ever uses an actual multiply when indexing even the nastiest arrays of nested structures.
