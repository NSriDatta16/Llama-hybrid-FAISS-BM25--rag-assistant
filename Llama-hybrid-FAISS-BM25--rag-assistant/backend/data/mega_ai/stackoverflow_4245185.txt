[site]: stackoverflow
[post_id]: 4245185
[parent_id]: 4240889
[tags]: 
The following is a typical loop you'll see in simple games. It's not good practice but a good basis to build upon: while(!quit) { while(evt = events_left_for_processing) { react_to_event(evt); } draw_frame(); } Pay special attention to the second "while", it is better to do it like this than to do an "if", you'll be able to process combined events more accurately. After a while you may need time-based physics and it becomes more complicated (using accumulators).. A sample from a rather simple game I was writing: /* Time-based animation loop. * Accumulator idea picked from an article by Glenn Fiedler on gafferongames.com */ while(!done) { /* Input */ while(SDL_PollEvent(&evt)) { window_event(evt, &done); } /* Physics */ newTime = time(); deltaTime = newTime - currentTime; if(deltaTime > 0.0f) { currentTime = newTime; accumulator += deltaTime; while(accumulator >= dt) { window_update(t, dt); accumulator -= dt; t += dt; } } #ifdef FPS_CAPPED drawTime = newTime - currentDrawTime; /* Draw */ if(drawTime >= FPS_CAPPED) { currentDrawTime = newTime; #endif window_draw(); SDL_GL_SwapBuffers(); #ifdef FPS_CAPPED } #endif } window_update etc are generalized functions (they execute a function in the game state, using function pointers). In your case, the transformation of the square would be changed in the event handler, which catches mouse_move events and has a state for catching mouse_press/release events. In the update you would change the square's position/etc data. In the draw routine you would blit the square. (unless you use other frameworks like OpenGL which use matrix transforms in the render pipeline)
