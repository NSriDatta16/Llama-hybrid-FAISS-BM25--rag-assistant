[site]: stackoverflow
[post_id]: 3581120
[parent_id]: 3576024
[tags]: 
Well nobody seems to have hit on it, here's my linker suggestions: Interpose libc, provide your own write() , and filter output to file descriptors 1 and 2 . Statically link your own code against libc, and then interpose the shared version to squelch write() as above. Interpose libc, providing a my_write() function that bypasses write() using dlsym() . Wrap write when linking the shared libraries by passing -Wl,--wrap=write . Then squelch any output to file descriptors 1 and 2 in a function called __wrap_write . Other file descriptors should call through to __real_write . Note that for those that aren't aware, file descriptors 1 and 2 correspond to stdout and stderr , which are eventually written to in the cout / cerr machinery. Often this is implemented cout calls fwrite which calls write , with varying levels of buffering and shenanigans at the different levels. Your best bet is option 4, the downside is you must tweak the final link for the shared libraries. Next best is option 2 above, the downside is your final executable is much bigger, but don't have to use silly functions in your own code. Links Interposing http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html http://www.jayconrod.com/cgi/view_post.py?23 http://dictionary.die.net/interposing http://developers.sun.com/solaris/articles/lib_interposers.html Wrapping http://www.jayconrod.com/cgi/view_post.py?23 http://okmij.org/ftp/syscall-interpose.html Function interposition in Linux without dlsym http://sourceware.org/ml/binutils/2000-09/msg00083.html
