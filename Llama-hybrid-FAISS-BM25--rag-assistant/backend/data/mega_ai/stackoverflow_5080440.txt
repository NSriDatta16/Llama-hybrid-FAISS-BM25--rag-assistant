[site]: stackoverflow
[post_id]: 5080440
[parent_id]: 5075290
[tags]: 
Ok. The facebook docs say it quite clearly: Because the access token is passed in an URI fragment, only client-side code (such as JavaScript executing in the browser or desktop code hosting a web control) can retrieve the token. App authentication is handled by verifying that the redirect_uri is in the same domain as the Site URL configured in the Developer App from http://developers.facebook.com/docs/authentication/ ---> Client-side Flow Section. So I'm sending the token back to my server to complete the authentication.. Update: The sending back to the server I do using Javascript something like this: var appId = " "; if (window.location.hash.length > 0) { accessToken = window.location.hash.substring(1); var url = window.location.href.replace(/#/, '?'); window.location = url; } On the server then I have the following action. Not very nice but it works.. public ActionResult FBAuthorize() { FacebookOAuthResult result = null; string url = Request.Url.OriginalString; /// hack to make FacebookOuthResult accept the token.. url = url.Replace("FBAuthorize?", "FBAuthorize#"); if (FacebookOAuthResult.TryParse(url, out result)) { if (result.IsSuccess) { string[] extendedPermissions = new[] { "user_about_me", "offline_access" }; var fb = new FacebookClient(result.AccessToken); dynamic resultGet = fb.Get("/me"); var name = resultGet.name; RegisterModel rm = new Models.RegisterModel(); rm.UserName = name; rm.Password = "something"; rm.Email = "somethig"; rm.ConfirmPassword = "23213"; //Label1.Text = name; //Response.Write(name); //return RedirectToAction("register", "Account", rm); ViewData["Register"] = rm; return RedirectToAction("Register"); } else { var errorDescription = result.ErrorDescription; var errorReason = result.ErrorReason; } } return View(); }
