[site]: stackoverflow
[post_id]: 3376000
[parent_id]: 3375637
[tags]: 
Update: I should have mentioned that there's actually a much nicer way to do this that doesn't require State or monads at all: takeStep :: (Double, StdGen) -> (Double, StdGen) takeStep (p, g) = let (d, g') = random g in (p + d, g') takeSteps n = take n . tail . map fst $ iterate takeStep (0, mkStdGen 0) It works as desired: *Main> takeSteps 5 [0.9872770354820595,0.9882724161698186,1.9620425108498993,2.0923229488759123,2.296045158010918] If you're not committed to the idea of "composing" two separate stateful computations, you can accomplish the same thing much more straightforwardly: takeStep :: State (Double, StdGen) Double takeStep = do (pos, gen) This produces the same output as your example: *Main> takeSteps 5 [0.9872770354820595,0.9882724161698186,1.9620425108498993,2.0923229488759123,2.296045158010918] This approach (doing all the state manipulation in a single monad instead of trying to compose a State A and State B ) seems to me like the most elegant solution. Update: To answer your question about using monad transformers to stack State monads: it's certainly possible. We can write the following, for example: update' :: (Monad m) => Double -> StateT Double m Double update' x = StateT $ \y -> let z = x + y in return (z, z) generate' :: (Monad m) => StateT StdGen m Double generate' = StateT $ return . random takeStep' :: StateT Double (State StdGen) Double takeStep' = update' = We could also do the stacking in the opposite order. This version again produces the same output, but in my opinion the non- StateT version is a bit clearer.
