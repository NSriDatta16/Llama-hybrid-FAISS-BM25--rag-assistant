[site]: stackoverflow
[post_id]: 1201201
[parent_id]: 1201081
[tags]: 
The purpose of encapsulation is to hide the implementation details: A highly contrived example: public class Person { private int age; public boolean canBuyBeer() { return age >= 21; } } you might later change this to: public class Person { private int age; private boolean isInUSA public boolean canBuyBeer() { if( isInUSA ) return age >= 21; else return age >= 18; } } The rules regarding age and origin can change but the caller doesn't need to know. Interfaces can be used to abstract out different types. Consider this: public interface Beverage { public boolean containsAlchohol; } public class Soda implements Beverage { public boolean containsAlchohol { return false; } } public class Beer implements Beverage { public boolean containsAlchohol { return true; } } You might update Person like: public class Person { private int age; private boolean isInUSA public boolean canBuyBeverage(Beverage b) { if( b.containsAlchohol() ) { if( isInUSA ) return age >= 21; else return age >= 18; } else { return true; } } } So Person is encapsulating the logic if when a Person can buy a certain type of beverage. The Beverage Interface abstracts out the logic associated with a Beverage. Better examples can be had, but that is the general idea.
