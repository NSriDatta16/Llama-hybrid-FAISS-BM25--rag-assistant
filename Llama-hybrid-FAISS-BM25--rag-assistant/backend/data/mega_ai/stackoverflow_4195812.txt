[site]: stackoverflow
[post_id]: 4195812
[parent_id]: 4195138
[tags]: 
As others have pointed out, all you need in order to call Abort is a reference to the thread (just like any other object in .NET). However You should seriously consider rethinking this approach. In general, calling Abort is discouraged, as it does not give the target thread sufficient opportunity to reach a stopping point. While it's sometimes appropriate (or the only option), it's almost always a better idea to ask the target thread to stop (usually through a volatile bool rather than forcing it like this. For example, public class ThreadClass { private volatile bool stopRequested; private Thread thread; public void Start() { stopRequested = false; thread = new Thread(ThreadMethod); thread.Start(); } public void Stop() { stopRequested = true; if(!thread.Join(5000)) thread.Abort(); // forcefully abort if not // completed within 5 seconds } private void ThreadMethod() { } } Your code then goes into ThreadMethod . Within the method, periodically check the value of stopRequested . If it's true, perform whatever cleanup is necessary (if any) and gracefully return out of the thread. If the content is a loop, the general practice is to place the check at the start of the loop (assuming that the loop is sufficiently tight) and exit early if the value is true . The exact placement is really dependent upon the code, but the general idea is that it should be checked often enough to make the thread exit fairly quickly after it gets set, regardless of when that happens.
