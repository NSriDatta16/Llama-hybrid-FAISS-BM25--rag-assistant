[site]: stackoverflow
[post_id]: 5684662
[parent_id]: 
[tags]: 
Why is std::tr1::unordered_map slower than a homegrown hash map?

I wrote a basic program that takes strings and counts the incidences of unique ones by inserting them into a string->integer hash map. I use std::tr1::unordered_map for the storage, templated for a custom hash function and a custom equality function. The key type is actually char* rather than the too-slow std::string . I then changed the same code to use a very, very simple hash table (really an array of {key, value} structures indexed by hash) with a power-of-two size and linear probing for collisions. The program got 33% faster. Given that when I was using tr1::unordered_map I presized the hash table so it never had to grow, and that I was using exactly the same hash and comparison routines, what is tr1::unordered_map doing that slows it down by 50% as compared to the most basic hash map imaginable? Code for the hash map type I'm talking about as "simple" here: typedef struct dataitem { char* item; size_t count; } dataitem_t; dataitem_t hashtable[HASHTABLE_SIZE] = {{NULL,0}}; // Start off with empty table void insert(char* item) { size_t hash = generate_hash(item); size_t firsthash = hash; while (true) { hash &= HASHTABLE_SIZE_MASK; // Bitmasking effect is hash %= HASHTABLE_SIZE if (hashtable[hash].item == NULL) { // Free bucket hashtable[hash].item = item; hashtable[hash].count = 1; break; } if (strcmp(hashtable[hash].item, item) == 0) { // Not hash collision; same item hashtable[hash].count += 1; break; } hash++; // Hash collision. Move to next bucket (linear probing) if (hash == firsthash) { // Table is full. This does not happen because the presizing is correct. exit(1); } } }
