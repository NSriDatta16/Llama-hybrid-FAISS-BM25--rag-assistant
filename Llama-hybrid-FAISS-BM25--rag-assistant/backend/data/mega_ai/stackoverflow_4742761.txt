[site]: stackoverflow
[post_id]: 4742761
[parent_id]: 4742692
[tags]: 
There is an easy explanation for why that is: == in Ruby is an operator, which performs a specific function. Operators have rules for determining what order they're applied in â€” so, for example, a + 2 == 3 evaluates the addition before the equality check. But only one operator at a time is evaluated. It doesn't make sense to have two equality checks next to each other, because an equality check evaluates to true or false . Some languages allow this, but it still doesn't work right, because then you'd be evaluating true == c if a and b were equal, which is obviously not true even if a == b == c in mathematical terms. As for a more elegant solution: case [a,b,c].uniq.size when 1 then :equilateral when 2 then :isosceles else :scalene end Or, even briefer (but less readable): [:equilateral, :isosceles, :scalene].fetch([a,b,c].uniq.size - 1)
