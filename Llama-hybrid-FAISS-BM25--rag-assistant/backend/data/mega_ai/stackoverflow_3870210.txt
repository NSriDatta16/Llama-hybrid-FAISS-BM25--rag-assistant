[site]: stackoverflow
[post_id]: 3870210
[parent_id]: 3870064
[tags]: 
First of all, this depends entirely on which type of Map you're using. But since the JavaRanch thread talks about HashMap , I'll assume that that's the implementation you're referring to. And let's assume also that you're talking about the standard API implementation from Sun/Oracle. Secondly, if you're concerned about performance when iterating through your hash map, I suggest you have a look at LinkedHashMap . From the docs: Iteration over the collection-views of a LinkedHashMap requires time proportional to the size of the map, regardless of its capacity. Iteration over a HashMap is likely to be more expensive, requiring time proportional to its capacity. HashMap.entrySet() The source-code for this implementation is available. The implementation basically just returns a new HashMap.EntrySet . A class which looks like this: private final class EntrySet extends AbstractSet > { public Iterator > iterator() { return newEntryIterator(); // returns a HashIterator... } // ... } and a HashIterator looks like private abstract class HashIterator implements Iterator { Entry next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot Entry current; // current entry HashIterator() { expectedModCount = modCount; if (size > 0) { // advance to first entry Entry[] t = table; while (index nextEntry() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) { Entry[] t = table; while (index So there you have it... That's the code dictating what will happen when you iterate through an entrySet . It walks through the entire array, which is as long as the map's capacity. HashMap.keySet() and .get() Here you first need to get hold of the set of keys. This takes time proportional to the capacity of the map (as opposed to size for the LinkedHashMap ). After this is done, you call get() once for each key. Sure, in the average case, with a good hashCode-implementation this takes constant time. However, it will inevitably require lots of hashCode() and equals() calls, which will obviously take more time than just doing a entry.value() call.
