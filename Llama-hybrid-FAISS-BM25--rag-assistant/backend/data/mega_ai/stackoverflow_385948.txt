[site]: stackoverflow
[post_id]: 385948
[parent_id]: 385681
[tags]: 
The issue you'd have with an HttpHandler is that it will generally only kick in for requests that are being handled by the ASP.Net engine - the image requests will normally be handled by IIS without going through the handler. Your web logs should be able to tell you who the referers for any given item on your servers are - assuming that you have them, and you hve something to process them - this will be more accurate than using Google. Going forward, one of the ways I've done this in the past is to have the image generated by an HttpHandler (implementing IHttpHandler). This will return the image as a stream (setting the content type to "image/jpeg"), and you can add further processing (such as logging where the request (referer) came from, etc). The limitation I found with the HttpHandler, is that some services (PBBS for example) require an image link to have an image extension - I got around this by processing all 404's with an ASP.Net page that checks for the .jpg extension in the request. If it finds one, instead of returning the usual 404 page, it returns the requeted image. You'll need to configure the 404 handler in IIS though, as the web.config error handler only kicks in for ASP.Net requests (web services and .aspx type pages). Example handler: // Sample from the ASP.Net Personal Web Site Starter Kit public class Handler : IHttpHandler { public bool IsReusable { get { return true; } } public void ProcessRequest(HttpContext context) { // Set up the response settings context.Response.ContentType = "image/jpeg"; context.Response.Cache.SetCacheability(HttpCacheability.Public); context.Response.BufferOutput = false; // QueryString parameters are available here: // context.Request.QueryString["QueryStringKey"] // You can also access the Referrer object, and log the requests here. Stream stream; // Read your image into the stream, either from file system or DB if (stream == null) { stream = PhotoManager.GetPhoto(); } // Write image stream to the response stream const int buffersize = 1024 * 16; var buffer = new byte[buffersize]; int count = stream.Read(buffer, 0, buffersize); while (count > 0) { context.Response.OutputStream.Write(buffer, 0, count); count = stream.Read(buffer, 0, buffersize); } } } You can have similar code (or better yet, refactor the main image streaming code into a shared class) in the 404 page, that checks for the existence of the image extension, and renders the image out that way (again, setting the content type, etc).
