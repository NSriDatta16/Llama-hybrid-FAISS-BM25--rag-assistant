[site]: stackoverflow
[post_id]: 2372009
[parent_id]: 327573
[tags]: 
Assuming we are not concerned with const correctness (or more, you mean to allow the functions to be able to modify or share ownership of the data being passed in), passing a boost::shared_ptr by value is safer than passing it by reference as we allow the original boost::shared_ptr to control it's own lifetime. Consider the results of the following code... void FooTakesReference( boost::shared_ptr & ptr ) { ptr.reset(); // We reset, and so does sharedA, memory is deleted. } void FooTakesValue( boost::shared_ptr ptr ) { ptr.reset(); // Our temporary is reset, however sharedB hasn't. } void main() { boost::shared_ptr sharedA( new int( 13 ) ); boost::shared_ptr sharedB( new int( 14 ) ); FooTakesReference( sharedA ); FooTakesValue( sharedB ); } From the example above we see that passing sharedA by reference allows FooTakesReference to reset the original pointer, which reduces it's use count to 0, destroying it's data. FooTakesValue , however, can't reset the original pointer, guaranteeing sharedB's data is still usable. When another developer inevitably comes along and attempts to piggyback on sharedA's fragile existence, chaos ensues. The lucky sharedB developer, however, goes home early as all is right in his world. The code safety, in this case, far outweighs any speed improvement copying creates. At the same time, the boost::shared_ptr is meant to improve code safety. It will be far easier to go from a copy to a reference, if something requires this kind of niche optimization.
