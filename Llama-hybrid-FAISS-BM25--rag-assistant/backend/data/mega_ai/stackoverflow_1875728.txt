[site]: stackoverflow
[post_id]: 1875728
[parent_id]: 1875609
[tags]: 
You can get rid of the first for loop by simply deleting it. It accomplishes nothing useful. When/if the subscript into the map creates a new item, that item will have the chosen key, and your associated int will be initialized to zero automatically. Personally, I'd probably do things a bit differently, using a stringstream instead of your SplitString() . I'm hesitant about posting code, but I guess I'll trust you... typedef vector > count_vec; count_vec GetFreqCounts(string const &input) { istringstream in(input); string line; map counts; while (getline(in, line)) if (line != "#") ++counts[line]; return count_vec(counts.begin(), counts.end()); } Edit: I honestly didn't pay a whole lot of attention to efficiency as I was writing this, but I think Steve Jessop's comment on it is pretty accurate. As long as the input is small, it won't make any real difference. If the input is really big, the fact that this only uses an extra copy of one word at a time could save enough memory to be meaningful. The solution Steve gave in his reply looks pretty nice too though. Since it also processes words as they're produced, I'd expect it to have characteristics similar to the code above. If you can break the string into words faster than stringstream does, it'll undoubtedly be faster. Given the number of virtual functions that get in the way with iostreams, there's a pretty good chance of that -- but unless you're dealing with a lot of text there's not much chance of it making a significant difference. Of course, exactly what qualifies as significant is open to question. To put it in perspective, I ran some similar code across a word list I had handy. Using code pretty close to what's above, it processes text at a little over 10 megabytes a second.
