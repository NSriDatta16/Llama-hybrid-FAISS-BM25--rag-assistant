[site]: stackoverflow
[post_id]: 4937564
[parent_id]: 4937243
[tags]: 
Another clean (and elegant) way is to build some sort of connection between the table view datasource, which is normally the UIViewController that contains the table, and the detail view: this can be done using the Delegate pattern, typical of Cocoa framework. In such case you can define a DetailViewDataDelegate protocol with two methods only: -(id)nextTableObjectFrom:(id)referenceObject; -(id)prevTableObject;(id)referenceObject; where referenceObject is the calling object, that is the object detailed in the DetailView. So DetailView will be defined in this way: @interface DetailViewController:UIViewController { } @property (nonatomic,assign) id currentDetailedObject; @property (nonatomic,assign) id dataDelegate; and of course when you call the controller, typical from the tableView:didSelectElementWithIndexPath:animated: method, you will do something like this: DetailViewController *dv = [[[DetailViewController alloc] initWithNibName:nil bundle:nil] autorelease]; dv.dataDelegate=self; dv.currentDetailedObject=[mySourceArray objectAtIndexPath:indexPath.row]; [self.navigationController pushViewController:dv animated:YES]; Finally in the DetailViewController when you need the next (or prev) element from the table you will simply call: -(IBAction)nextButtonPressed { self.currentDetailedObject = [self.dataDelegate nextTableObjectFrom:self.currentDetailedObject]; } Of course the implementation details may change, and in particular the delegate methods, to be implemented in the table's UIViewController, will depend on the data structure. The advantage of this approach, which can be at first sight complicated, is quite elegant and avoids to pass objects along controllers, which is often a source of memory issues. Besides with the delegate approach you can implement any complicated feature (e.g.: you can even manipulate table view objects directly from the DetailViewController, at your own risk of course!)
