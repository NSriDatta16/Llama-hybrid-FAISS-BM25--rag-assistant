[site]: stackoverflow
[post_id]: 908993
[parent_id]: 894165
[tags]: 
I would suggest something similar to Jason's solution, but using a wrapper that implements IDataReader instead, so: sealed public class PeekDataReader : IDataReader { private IDataReader wrappedReader; private bool wasPeeked; private bool lastResult; public PeekDataReader(IDataReader wrappedReader) { this.wrappedReader = wrappedReader; } public bool Peek() { // If the previous operation was a peek, do not move... if (this.wasPeeked) return this.lastResult; // This is the first peek for the current position, so read and tag bool result = Read(); this.wasPeeked = true; return result; } public bool Read() { // If last operation was a peek, do not actually read if (this.wasPeeked) { this.wasPeeked = false; return this.lastResult; } // Remember the result for any subsequent peeks this.lastResult = this.wrappedReader.Read(); return this.lastResult; } public bool NextResult() { this.wasPeeked = false; return this.wrappedReader.NextResult(); } // Add pass-through operations for all other IDataReader methods // that simply call on 'this.wrappedReader' } Note that this does require quite a bit of pass-through code for all the unaffected properties, but the benefit is that it is a generic abstraction that can 'peek' at any position in the result set without moving forward on the subsequent 'read' operation. To use: using (IDataReader reader = new PeekDataReader(/* actual reader */)) { if (reader.Peek()) { // perform some operations on the first row if it exists... } while (reader.Read()) { // re-use the first row, and then read the remainder... } } Note though that every 'Peek()' call will actually move to the next record if the previous operation was not also a 'Peek()'. Keeping this symmetry with the 'Read()' operation provides a simpler implementation and a more elegant API.
