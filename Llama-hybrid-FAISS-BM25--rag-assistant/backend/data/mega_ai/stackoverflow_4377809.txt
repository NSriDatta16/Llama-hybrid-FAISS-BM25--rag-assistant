[site]: stackoverflow
[post_id]: 4377809
[parent_id]: 4377578
[tags]: 
I have metadata defined in c# like this: public class Meta { public class Client { public class Name { public const bool Required = true; public const DataType Type = DataType.Text; public const int MaxLength = 30; public const int MinLength = 1; public const string Regex = @"^[\w\d\.-_]{1,30}$"; } public class Email { public const bool Required = false; public const DataType Type = DataType.EmailAddress; public const int MaxLength = 256; public const int MinLength = 4; public const string Regex = @"^.+@.+$"; } } } declaring them as constants allows you to utilize DataAnnotations on both BL entities and UI models: [DataContract] [Serializable] public class ClientInfo { [DataMember] [Required(AllowEmptyStrings = !Meta.Client.Name.Required)] [StringLength(Meta.Client.Name.MaxLength, MinimumLength = Meta.Client.Name.MinLength)] [RegularExpression(Meta.Client.Name.Regex)] public string Name { get; set; } ... } well, yes, you duplicate the attributes but not metadata! In addtition i have a trivial preprocessor to generate sql-scripts from a template (special processing for *.Required, etc): create table dbo.Client( Name nvarchar({#Client.Name.MaxLength}) {#Client.Name.Required}, Email nvarchar({#Client.Email.MaxLength}) {#Client.Email.Required}, .... On UI, you can use inheritance to not duplicate properties. For example, if you have a model with 10 properties, but need to edit only 2 of them, create EditModel and inherit ViewModel from it. The key here is to have metadata in a single storage and use it as much as possible. Hope you get the idea.
