[site]: crossvalidated
[post_id]: 398390
[parent_id]: 398383
[tags]: 
I've worked with similar curves some time ago. Fitting $y=a(1-e^{-bx})$ and $y=a\ln x +b$ separately and averaging them yielded very good fits in my case. Since the curves cannot be cast to linear model, you need to use some sort of nonlinear curve fitting tool. curve_fit in scipy.optimize can be useful if you're using Python. Instead of trying to fit a complex model, averaging two/or more basic models provides good convergence rates. Since these curve-fitting libraries apply some sort of gradient-descent approach, local minima might occasionally bother you. In such cases, resorting to the differenced version of the above curve (i.e. $x_n-x_{n-1}$ ), fitting exponential decay, or inverse-polynomial decay (or again averaging them) and applying cumsum in the end might also be a good approach (only if you can't fit with nonlinear fitting tool). EDIT: Applying the methodology to this data: (first save the data to a text file having a whitespace between the columns as separator): from scipy.optimize import curve_fit import numpy as np import pandas as pd from matplotlib import pyplot as plt tmp = pd.read_csv(" ", sep = " ", header = None) tmp.columns = ["ind", "data"] def f1(x,a,b): return a*(1-np.exp(-b*x)) def f2(x,a,b): return a*np.log(x) + b x, y = tmp.ind.values, tmp.data.values popt1,_ = curve_fit(f1, x, y, p0 = np.random.random(2)) popt2,_ = curve_fit(f2, x, y, p0 = np.random.random(2)) f1v = f1(x,*popt1) f2v = f2(x,*popt2) fig, ax = plt.subplots(2,2,figsize=(18,9)) ax[0][0].plot(x,y); ax[0][0].legend(["real"]); ax[0][0].grid() ax[0][1].plot(x,f1v,x,y); ax[0][1].legend(["exp","real"]); ax[0][1].grid() ax[1][0].plot(x,f2v,x,y); ax[1][0].legend(["log","real"]); ax[1][0].grid() ax[1][1].plot(x,(f1v+f2v)/2,x,y); ax[1][1].legend(["avg","real"]); ax[1][1].grid() plt.show() Here, $y=a(1-e^{-bx})$ fit best to the data. In my cases, the right end of the curve was having a small trend (instead of complete saturation as in here) and fitting a logarithmic curve and averaging was a useful step. Logarithmic curve doesn't fit well to the initial sections of the data, however this model has been a good predictor for me for estimating the LTV of customers. By the way, the best parameters for the exponential curve is ( $a$ and $b$ in order): array([22.58256696, 0.0256301 ])
