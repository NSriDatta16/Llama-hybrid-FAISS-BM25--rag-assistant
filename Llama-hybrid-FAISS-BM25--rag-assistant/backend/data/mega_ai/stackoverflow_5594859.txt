[site]: stackoverflow
[post_id]: 5594859
[parent_id]: 5588361
[tags]: 
In your definition, MapCreator is really constraining IV and V to be the same type. By contract the V returned in Map[K,V] has to be the same type as the type returned by valueCreator . For instance, if I called: MapCreator((rs:ResultSet) => rs.getString("KEY"), (rs:ResultSet) => rs.getString("VALUE"))(resultSet) I would expect to get a Map[String,String] . You cannot change that relation if you extend MapCreator . If you want a Map[String,List[String]] you need to supply a valueCreator of type (ResultSet) => List[String] . With that in mind you can change the definition and implementation like this: class MapCreator[K,IV](keyCreator: ResultSet => K, valueCreator: ResultSet => IV) extends CollectionCreator[Map[K, IV]] { val intermediateMap = new HashMap[K, IV] def append(rs: ResultSet) { appendToMap(keyCreator(rs), valueCreator(rs)) } def appendToMap(key: K, value: IV) { intermediateMap(key) = value } def returnCollection(): Map[K, IV] = intermediateMap.toMap } class ListMultiMapCreator[K,IV](keyCreator: ResultSet => K, elemCreator: ResultSet => IV) extends MapCreator[K, List[IV]](keyCreator, (rs:ResultSet) => List(elemCreator(rs))) { override def appendToMap(key: K, value: List[IV]) { intermediateMap(key) = intermediateMap.get(key) match { case Some(values) => values.:::(value) case None => value } } } I feel that because CollectionCreator uses a type parameter, that it will be cumbersome to use abstract types. Overall, there seems to be much boiler plate. I would leverage more of the scala libraries: def mapCreate[K, IV](rs: ResultSet, keyCreator: ResultSet => K, valueCreator: ResultSet => IV) = { Iterator.continually(rs).takeWhile(_.next).map{rs => keyCreator(rs) -> valueCreator(rs)}.toMap } def listMultiMapCreate[K, IV](rs: ResultSet, keyCreator: ResultSet => K, valueCreator: ResultSet => IV) = { Iterator.continually(rs).takeWhile(_.next).map{rs => keyCreator(rs) -> valueCreator(rs)}.toList.groupBy(_._1) } Also in your do { append(rs) } while (rs.next) what if the result set is empty?
