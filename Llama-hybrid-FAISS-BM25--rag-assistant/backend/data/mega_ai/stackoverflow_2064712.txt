[site]: stackoverflow
[post_id]: 2064712
[parent_id]: 2064088
[tags]: 
The concept of a closure is fairly consistent across languages, although in imperative languages there's some disagreement about how constructs such as continue , break , and return within a closure should be handled (e.g. some of the proposals for adding closures to Java behave differently in this respect than C# does). The main subtlety which catches people is that in non-pure languages, closures "close over" variable bindings rather than values, which means that things like variable scoping are very important (and this is where unexpected difficulties arise in the for-loop examples, since the scope of the loop variable is not always what people expect). F#'s behavior is quite similar to C#'s, but there are a few things that make closures slightly nicer to work with in F#. For one, although F# is impure, mutation is discouraged, so it's harder to write a closure which inadvertently closes over a variable which is later modified in a way that breaks expectations. In particular, the F# compiler will not allow a normal mutable binding to be used inside of a closure - the compiler's error message suggests that you either make the binding immutable or use an explicit reference cell (type 'a ref in F#) if you actually intend to close over a binding which can be mutated. This forces the user to think carefully about what is trying to be achieved.
