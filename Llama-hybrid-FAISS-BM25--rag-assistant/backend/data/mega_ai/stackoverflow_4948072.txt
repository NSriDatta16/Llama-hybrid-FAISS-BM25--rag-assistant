[site]: stackoverflow
[post_id]: 4948072
[parent_id]: 2118936
[tags]: 
OK, so the short answer from Oracle is: "can't be done!" The short answer from me is: "Yeah - like Oracle is gonna stop me! So yes you can....but you need to be sneaky ... oh yes, and there is a 'but' or two....in fact...ugh!" So, how can you pass your explicit cursor by reference? By nesting it into another cursor using the CURSOR() construct! e.g.) CREATE OR REPLACE package CFSDBA_APP.test_Cursor as function get_cursor(ed_id number) return sys_refcursor; end; / CREATE OR REPLACE package body CFSDBA_APP.test_Cursor as function get_cursor(ed_id number) return sys_refcursor is test_Cur sys_refcursor; cursor gettest is select CURSOR( -pass our actual query back as a nested CURSOR type select ELCTRL_EVNT_ELCTRL_DISTRCT_ID, ELECTORAL_DISTRICT_ID, ELECTORAL_EVENT_ID from ELCTRL_EVNT_ELCTRL_DISTRCT where electoral_District_id = ed_id) from dual; begin open gettest; fetch gettest into test_Cur; return test_Cur; end; end; / So what is the problem with this solution? It has a leak! The outer gettest cursor is never closed, because we don't close it and the client will only close the reference to the nested cursor that was selected for them - not the main cursor. And we can't close it automatically because closign the parent would force closing the nested cursor that you have returned by reference - and it is entirely likely that the client has not done using it. So we have to leave a cursor open in order to return the nested cursor. And if the user tried calling get_Cursor again with a new value of ed_id, they would discover that the session persistence in the package meant that the cursor handle is still in use and an error would be raised. Now, we could fix that by first checking and closing the explicit cursor: if gettest%isopen then close gettest; end if; open gettest; fetch gettest into test_Cur; return test_Cur; But still - what if the user never calls this again? How long 'til Oracle garbage-collects the cursor? And how many users running how many sessions calling how many functions that use this construct will be leaving cursors open after they are done with them? Better count on a huuuuuge overhead to leave all those open cursors layin' about! No, you would need to have the users do a callback to explicitely close it or you would be clogging the database. But doing this would require changing the scope of the explicit cursor so that both functions can access it: So we need to make it at package scope, not function scope CREATE OR REPLACE package CFSDBA_APP.test_Cursor as function get_cursor(ed_id number) return sys_refcursor; function close_cursor return sys_refcursor; end; / CREATE OR REPLACE package body CFSDBA_APP.test_Cursor as cursor l_gettest(p_ed_id in number) is select CURSOR( select ELCTRL_EVNT_ELCTRL_DISTRCT_ID, ELECTORAL_DISTRICT_ID, ELECTORAL_EVENT_ID from ELCTRL_EVNT_ELCTRL_DISTRCT where electoral_District_id = p_ed_id) from dual; function get_cursor(ed_id number) return sys_refcursor is l_get_Cursor sys_refcursor; begin open l_gettest (ed_id); fetch l_gettest into l_get_Cursor; return l_get_cursor; end; function close_cursor return sys_refcursor is begin if l_gettest%isopen then close l_gettest; end if; return pkg_common.generic_success_cursor; end; end; / OK, plugged the leak. Except it cost us a network round trip instead of the hard parse,...oh wait - and also except embedding a bind variable into an explicit cursor declared at this level is probably going to cause scoping issues of its own which was the reason we wanted to do this in the first place! Oh, and in a session-pooling environment can two users step on each other's cursors? IF they aren't very carefull about doing an open-fetch-close before returning the session to the pool - we could wind up with some really interesting (and impossible to debug) results! And how much do you trust the maintainers of the client code to be extra-diligent on this? YEah - me too. So the short answer is: Yes, with a bit of sneakiness it could be done despite Oracle saying it can't. The better answer is: But please don't! The extra round trip and potential for memory leaks and client code errors causing data problems makes this a very scary proposition.
