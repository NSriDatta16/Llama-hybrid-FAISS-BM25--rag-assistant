[site]: stackoverflow
[post_id]: 5123443
[parent_id]: 5121159
[tags]: 
I'd avoid having redundant data in the database. This leaves open the possibility of the database data getting internally inconsistent and messing up everything. Use a single entry per match, as in your second example. If you plan ahead, you can accomplish the two sets of logic pretty easily. Take a look at proxy models . There might be an elegant way to do this -- have all of your logic refer to the data fields through accessors like get_my_score and get_opponent_score . Then build a Proxy Model class which swaps home and away. class match(models.Model): def get_my_score(self): return self.home_player_score def get_opponent_score(self): return self.away_player_score def did_i_win(self): return self.get_my_score() > self.get_opponent_score() class home_player_match(match): class Meta: proxy = True def get_my_score(self): return self.away_player_score def get_opponent_score(self): return self.home_player_score Or maybe you want two Proxy models, and have the names in the base model class be neutral. The problem with this approach is that I don't know how to convert a class from one proxy model to another without reloading from the database. You want a "rebless" as in perl. You could do this by using containment rather than inheritance. Or maybe just a flag in the wrapper class (not stored in the database) saying whether or not to swap fields. But I'd recommend some solution like that -- solve the tricky stuff in code and don't let the database get inconsistent.
