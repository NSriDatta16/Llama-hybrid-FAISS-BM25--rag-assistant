[site]: stackoverflow
[post_id]: 2438003
[parent_id]: 2437270
[tags]: 
For the implementation with a map, you could use pointers-to-members. Then you won't need a deep copy of the map (when you copy it, the pointers in the map still point into the original Node), and it will also allow you to make the whole thing static (this map is unnecessary at per-instance basis). For example: class Node { //... static std::map initVarMap(); static float Node::* varFromName(const std::string& name); }; std::map Node::initVarMap() { std::map varMap; varMap["x"] = &Node::x; varMap["y"] = &Node::y; varMap["z"] = &Node::z; return varMap; } float Node::* Node::varFromName(const std::string& name) { static std::map varMap = initVarMap(); std::map ::const_iterator it = varMap.find(name); return it != varMap.end() ? it->second : NULL; } Usage: float Node::* member(varFromName(s)); if (member) this->*member = xyz; This isn't any more flexible, though. To support different types of members, you might modify the above to use a map of string to "variant of all supported member types". For example so. The member setter visitor should be reusable, and the only change to the code, to add or change member types, should be done to the typedef. #include #include #include #include template struct MemberSetter: boost::static_visitor { Obj* obj; const T* value; public: MemberSetter(Obj* obj, const T* value): obj(obj), value(value) {} void operator()(T Obj::*member) const { obj->*member = *value; } template void operator()(U Obj::*) const { //type mismatch: handle error (or attempt conversion?) } }; class Node { public: Node() : i(0), f(0.0f), d(0.0f) { } template void set(const std::string& s, T value) { std::map ::const_iterator it = varMap.find(s); if (it != varMap.end()) { boost::apply_visitor(MemberSetter (this, &value), it->second); } //else handle error } void report() const { std::cout MemberTypes; static std::map initVarMap(); static std::map varMap; }; int main() { Node a; a.set("i", 3); a.set("d", 4.5); a.set("f", 1.5f); a.report(); } std::map Node::initVarMap() { std::map varMap; varMap["i"] = &Node::i; varMap["f"] = &Node::f; varMap["d"] = &Node::d; return varMap; } std::map Node::varMap = Node::initVarMap(); This is naturally just an example of what you can do. You can write a static_visitor to do what you want. E.g storing a stream and attempting to extract a value of the right type for the given member.
