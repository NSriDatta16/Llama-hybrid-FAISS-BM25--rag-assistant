[site]: stackoverflow
[post_id]: 5046355
[parent_id]: 5019859
[tags]: 
It depends on what computer vision / image processor library are you using. For example, OpenCV has builtin SVM functionality: http://opencv.willowgarage.com/documentation/cpp/support_vector_machines.html so you don't even have to export the features. But LIBSVM ( http://www.csie.ntu.edu.tw/~cjlin/libsvm/ ) has many more bindings, also for Matlab, for example. As for how to give the features to the SVM... the input of most categorizers (including SVMs) is a multi-dimensional vector, so you could get one for example concatenating the first 10 x-y-width-height tuples. However, this naive solution is unlikely to work, because if you change the order of the tuples (or you rotate the coin so that the x-y coordinates change), you will get totally different vectors. So try to make up a coin image -> feature vector mapping that doesn't change when the coin is rotated / moved / noise is added. (second idea: features ordered by size, first 5-10, with some shape descriptors instead of simple width / height maybe?) Coin names are mostly irrelevant at this phase, use 1-of-N encoding for the SVM output.
