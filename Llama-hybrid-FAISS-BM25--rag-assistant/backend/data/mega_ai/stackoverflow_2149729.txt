[site]: stackoverflow
[post_id]: 2149729
[parent_id]: 2149688
[tags]: 
My advice is: don't make your life harder, make it easier. Just create a table with one row for each calendar day, having as many rows as you think you reasonably need to last. In datawarehousing, this is the common solution, and it is so widely implemented this way that a dwh that doesn't have it, has a code smell. Many people used to dealing with more traditional oltp/data entry apps feel a natural revulsion against this idea, because the feel the can generate the data anyway, and therefore it shouldn't be stored. But if you do create a table like that, you can adorn it with many useful attributes, such as whether it's a holdiday or a weekend, and you can store many common date representations (iso, european, us format etc) inside it, which can save you a ton of time when creating reports (since you don't have to bother figuring out how the date formatting works in each reporting tool you come by. Or you can go a step further and update your date table everyday to mark flags for the current day, current week, current month, current year, etc - all kinds of useful tools that make it much, much easier to build reports that need to work against some date range. MySQL sample code as per request in comment: delimiter // DROP PROCEDURE IF EXISTS p_load_dim_date // CREATE PROCEDURE p_load_dim_date ( p_from_date DATE , p_to_date DATE ) BEGIN DECLARE v_date DATE DEFAULT p_from_date; DECLARE v_month tinyint; CREATE TABLE IF NOT EXISTS dim_date ( date_key int primary key , date_value date , date_iso char(10) , year smallint , quarter tinyint , quarter_name char(2) , month tinyint , month_name varchar(10) , month_abbreviation varchar(10) , week char(2) , day_of_month tinyint , day_of_year smallint , day_of_week smallint , day_name varchar(10) , day_abbreviation varchar(10) , is_weekend tinyint , is_weekday tinyint , is_today tinyint , is_yesterday tinyint , is_this_week tinyint , is_last_week tinyint , is_this_month tinyint , is_last_month tinyint , is_this_year tinyint , is_last_year tinyint ); WHILE v_date Using p_load_dim_date you uinitially load the dim_date table with say 25 years of data. And daily, prefereabluy round midnight, you run p_update_dim_date . Then you can use the flag fields is_today, is_yesterday, is_this_week, is_last_week and so on to select common ranges. Of course, you should amend this code to suit your particular needs but this is the idea. So no generaging ranges on the fly, you just preload for a long enough period of time ahead. For the time of day, a similar design can be set up - you should be able to manage that yourself going by this code. For even fancier date dimensions that take care of holidays, and localized names for month and days, you can take a look at: http://rpbouman.blogspot.com/2007/04/kettle-tip-using-java-locales-for-date.html and http://rpbouman.blogspot.com/2010/01/easter-eggs-for-mysql-and-kettle.html
