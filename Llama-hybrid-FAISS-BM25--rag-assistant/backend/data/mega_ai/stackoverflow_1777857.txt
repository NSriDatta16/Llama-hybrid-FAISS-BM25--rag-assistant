[site]: stackoverflow
[post_id]: 1777857
[parent_id]: 1777843
[tags]: 
As Don suggested, memmove() will allow moving part of this array, in order to make room for the new element. Depending on the size of the elements in the array, you may also consider storing only pointers, in the array, allowing easier/faster re-shuffling of the array, at the cost of a extra indirection when accessing individual elements. (and also at the cost of having to manage individual element-sized memory blocks). Deciding on this type of approach depends on the amount of reorganization of the array elements, as well as their size. Alert : in view of the added "picture" in the question, memmove(), or indeed any operation, may be impossible, if the memory move implies writing past the size of memory originally allocated! If this is really what is desired, the idea of an array of pointers may be more appropriate as this allows allocating an over-sized memory block initially (for the array proper) and to allocate (or dispose of) individual elements as needed. Edit : "We're not allowed to use memmove()" indicates some form of homework. (BTW do tag it as such !!!) To better help you we need to understand the particular premise of the question. Here's what appears to be the situtation: 1) we readily have an array, containing say N elements. 2) the array on the heap, i.e. it was allocated using malloc() (or related functions) 3) the effective size of the malloc-ated block of memory is bigger than that of the array. Is #3 true ? 4) Depending on #3 we need to either allocate a new memory block (a bigger one) and copy the array. We expect this copy would be done in 3 steps - copy the elements that precede the new element - copy the new element - copy the elements that are after the new element or... (if we have enough room), we'd require two steps - "shift" the elements that are supposed to be after the new element This can be done one element at a time, if we wish to avoid memcopy - copy the new element.
