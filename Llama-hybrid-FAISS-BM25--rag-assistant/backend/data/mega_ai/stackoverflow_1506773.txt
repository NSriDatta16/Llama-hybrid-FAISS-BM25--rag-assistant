[site]: stackoverflow
[post_id]: 1506773
[parent_id]: 1506727
[tags]: 
EDIT1: I think I miss understood the question first time. The standard says: 3.10 Lvalues and rvalues The result of calling a function that does not return a reference is an rvalue. User defined operators are functions, and whether such operators expect or yield lvalues is determined by their parameter and return types. The standard says nothing in this paragraph, except that user-defined types and primitive types are the same. If the return of a function is not a reference, then it is not an l-value. There is however an interesting commentary on the same page: 47) Expressions such as invocations of constructors and of functions that return a class type refer to objects, and the implementation can invoke a member function upon such objects, but the expressions are not lvalues. So basically in your example: AMethod() = YourClass(); AMethod returns a user-defined type on which the function: AMethod().operator=(YourClass()); is executed. Still, it is not an l-value. In fact, you could have empty statements in C++, or statement that consist of an r-value only!: 5;;; // correct C++ code! EDIT2: Consider this example: if( &(YourClass() + YourClass()) == &YourClass() ) { .... } The expression &(YourClass() + YourClass()) must yield an l-value so the whole expression becomes correct. It compiles fine on VC but it gives this little warning: warning C4238: nonstandard extension used : class rvalue used as lvalue Obviously the above line was wrong by C++ standards but VC just allows it! Because you asked it so. First, a fresh instance of YourClass is returned by AMethod . Then, it is assigned another fresh instance. Of course in C++ you can say what ever you want. So, to prevent the assignment statement, just return const YourClass . In this case, the object becomes " readable " only: const YourClass AMethod(){ return YourClass();} This is the same in case you are overloading binary operators. For example, if you overload operator+ for a class, then you can do with const or without it. // '+' operator is defined as a friend operator not a member. friend YourClass operator+(const YourClass& lhs, const YourClass& rhs) { ... } If you did it that way, you could have meaningless statement like the following: (a + b) = c; Where the expression (a + b) is not useful because it represents only a value, not a variable we control, it produces a temp variable.
