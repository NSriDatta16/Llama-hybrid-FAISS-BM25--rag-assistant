[site]: stackoverflow
[post_id]: 3413850
[parent_id]: 3413599
[tags]: 
Ok, this is clear now. You're storing data in associative arry. AND you're redefining this array in subclass. Of course, it won't have values form superclass that way. Move array definition to class constructor instead. Then you should have '', //done 'displayName' => '', //done 'active' => '', //done 'billingMethod' => '', //done 'debitorNumber' => null, //done 'bankAccount' => null, //done 'bankAccountTown' => null, //done 'resellerOrganisationId'=> null, 'account' => null, //done 'phonenumbers' => null, //done 'calls' => null, 'tickets' => null, 'comments' => null, 'addresses' => null, 'emailaddresses' => null, //done 'actionevents' => null ); $this->_data = $newData; } } class Crm_CustomerEntity extends Crm_Entity { //foobar not done yet public function __construct() { parent::__construct(); } } class Crm_Person extends Crm_CustomerEntity { public function __construct() { parent::__construct(); $newData = array( 'customerId' => null, 'firstName' => '', 'middleName' => '', 'lastName' => '', 'initials' => '', 'title' => '', 'openingWord' => '' ); $this->_data = array_merge($this->_data, $newData); } } Of course the actual design depends - if you want those mappings before you create class you should put them in some static function instead. Something like class Crm_Person extends Crm_CustomerEntity { public static function getData() { $data = Crm_Entity::getData() $newData = (...) return array_merge($data, $newData); } }
