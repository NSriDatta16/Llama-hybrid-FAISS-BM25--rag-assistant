[site]: stackoverflow
[post_id]: 1291038
[parent_id]: 1291002
[tags]: 
This is untested, but is an elegant way to do this with the .net based primitives: class Processor { Action action; Queue queue = new Queue (); public Processor(Action action) { this.action = action; new Thread(new ThreadStart(ThreadProc)).Start(); } public void Queue(T data) { lock (queue) { queue.Enqueue(data); Monitor.Pulse(queue); } } void ThreadProc() { Monitor.Enter(queue); Queue copy; while (true) { if (queue.Count == 0) { Monitor.Wait(queue); } copy = new Queue (queue); queue.Clear(); Monitor.Exit(queue); foreach (var item in copy) { action(item); } Monitor.Enter(queue); } } } Example program: class Program { static void Main(string[] args) { Processor p = new Processor ((data) => { Console.WriteLine(data); }); p.Queue(1); p.Queue(2); Console.Read(); p.Queue(3); } } This is a non-queue version, a queue version may be preferred: object sync = new object(); AutoResetEvent e = new AutoResetEvent(false); bool pending = false; public SetData(MyData d) { lock(sync) { if (pending) throw(new CanNotSetDataException()); this.d=d; pending = true; } e.Set(); // notify that new data is available } void Runner() // this runs in separate thread and waits for d to be set to a new value { while (true) { e.WaitOne(); // waits for new data to process DoLongOperationWith_d(d); lock(sync) { pending = false; } } }
