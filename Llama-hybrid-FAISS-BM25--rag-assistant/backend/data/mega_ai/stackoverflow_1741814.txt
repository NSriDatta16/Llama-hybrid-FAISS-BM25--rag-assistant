[site]: stackoverflow
[post_id]: 1741814
[parent_id]: 1723796
[tags]: 
I solved this problem with the following code. I made the classes F,G,H,N non-pure abstract just to simplify the exposition but this can be easly changed (use F as tag, Feature for the interface). Features: class F { public: virtual double f( double x ) { return 10.0; }; virtual double sample( const F& t , double x ) { return f( x ); }; }; class G { public: virtual double g( double x ) { return 10.0; }; virtual double sample( const G& t , double x ) { return g( x ); }; }; class H { public: virtual double h( double x ) { return 10.0; }; virtual double sample( const H& t , double x ) { return h( x ); }; }; class N {}; I use the boost::fusion map class, but with some effort this can be re-written to avoid this. The Impl class allows to define functions that simplify the user interface. This is needed because I am using composition/aggregation instead of inheritance and thus the class which implements the required feature must be "selected manually". template class Impl { template double sample( const S2& x ) { return boost::fusion::at_key ( static_cast (this)->container )->sample( S1() , x ); } }; template class Impl { public: double f( double x ) { return boost::fusion::at_key ( static_cast ( this )->container )->f( x ); } }; This is the key class that "aggregates" features T1,T2,T3. Below same class for features T1,T2. Class for T1 only left as user exercise :) template class Rvg : public Impl ,T1>, public Impl ,T2>, public Impl ,T3> { public: typedef typename boost::fusion::map , boost::fusion::pair , boost::fusion::pair > container_type; container_type container; public: Rvg() {} template Rvg( S1* s1Ptr ) : container( static_cast ( s1Ptr ), static_cast ( s1Ptr ), static_cast ( s1Ptr ) ) {} template Rvg & operator = ( const Rvg & rhs ) { container = rhs.container; return *this; } template S& operator() ( S& s ) { return *boost::fusion::at_key ( container ); } }; template class Rvg : public Impl ,T1>, public Impl ,T2> { public: typedef typename boost::fusion::map , boost::fusion::pair > container_type; container_type container; public: Rvg() {} template Rvg( S1* s1Ptr ) : container( static_cast ( s1Ptr ), static_cast ( s1Ptr ) ) {} template Rvg& operator = ( const Rvg & rhs ) { container = rhs.container; return *this; } template S& operator() ( S& s ) { return *boost::fusion::at_key ( container ); } }; //Rvg defined according to the same pattern. Examples of class that supports features F,G,H. class SuppFandGandH : public F , public G , public H { public: double f( double x ) { return 14.0; } double g( double x ) { return 15.0; } double h( double x ) { return 16.0; } double sample( const F& f , double x ) { return 17.0; } double sample( const G& g , double x ) { return 18.0; } double sample( const H& h , double x ) { return 19.0; } }; Example of user use: int main() { SuppFandGandH suppFandGandH; Rvg myRvgFGH( &suppFandGandH ); //Automatic construction myRvgFGH( F() ).f( 0.0 ); //Base calling myRvgFGH.sample ( 0.0 ); //Fwded calling myRvgFGH.f( 0.0 ); //Specific fwded calling myRvgFGH.sample ( 0.0 ); myRvgFGH.sample ( 0.0 ); myRvgFGH.sample ( 0.0 ); Rvg myRvgFG; myRvgFG = myRvgFGH; //Less from More Rvg myRvgFG2( &suppFandGandH ); //Again automatic construction Rvg myRvgFH( &suppFandGandH ); //The same } This should satisfy all the four requirements.
