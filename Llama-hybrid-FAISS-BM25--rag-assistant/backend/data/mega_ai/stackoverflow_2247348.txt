[site]: stackoverflow
[post_id]: 2247348
[parent_id]: 2247289
[tags]: 
Just considering one word, here is an O(n log n) destructive algorithm: std::string::iterator unq_end = std::unique( word.begin(), word.end() ); std::sort( word.begin(), unq_end ); return std::unique( word.begin(), unq_end ) == unq_end; Edit: The first call to unique reduces runs of consecutive letters to single letters. The call to sort groups identical letters together. The second call to unique checks whether sort formed any new groups of consecutive letters. If it did, then the word must not be grouped. Advantage over the others posted is that it doesn't require storage â€” although that's not much of an advantage. Here's a simple version of the alternative algo, also requiring only O(1) storage (and yes, also tested): if ( word.empty() ) return true; bitset symbols; for ( string::const_iterator it = word.begin() + 1; it != word.end(); ++ it ) { if ( it[0] == it[-1] ) continue; if ( symbols[ it[0] ] ) return false; symbols[ it[-1] ] = true; } return ! symbols[ * word.rbegin() ]; Note that you would need minor modifications to work with characters outside ASCII. bitset comes from the header .
