[site]: stackoverflow
[post_id]: 1582101
[parent_id]: 1581814
[tags]: 
I'm not aware of any specific design patterns regarding security of information on your .NET server application, however, ultimately, you can only do so much to secure any information that you request from the user, and specifically, store . If you are storing any user passwords that will be used for authentication that your own application will perform, the best way of storing this is with a salted one-way hash function. This way, the user is going to provide the password, manually, in plain text every time they authenticate with your application, and you will immediately hash that plain text password and compare that with the hashed password that you have stored. Any attacker, even one with access to the raw database, would have to brute-force reverse engineer all of your salted hashes. Not impossible (given enough computing power), but certainly improbable in all reality. If you're storing usernames/passwords that the user is providing to you, such that your application can then use these credentials to automatically "log into"/"authenticate with" another application or service on the user's behalf, well, I would suggest that you don't do this if security of that data is paramount. Put simply, even if you encrypt these credentials (whether that be symmetric or asymmetric encryption) ultimately, that data has to be used somewhere and for that to happen, it needs to be decrypted. This is the "weak link" in the security chain so to speak. Reduce the risk of user's sensitive information getting compromised if the .Net server's host operating system, in this case Window's Data Center Edition, is compromised. If this were to happen, all bets are off. Having the data stored in an encrypted form no longer means anything, as if Windows can decrypt that data, so can an attacker once he has access to the machine/OS. He wouldn't even need to attempt to "export" the private key from the Windows certificate store, as he could inject his malicious code further down the decryption chain and simply intercept the decrypted data as it comes out of the decryption process. Of course, the finest way of protecting your user's sensitive data is to never store it at all. Request it from the user each and every time, use it for whatever purpose you need it for, then dispose of it immediately. In the UK, the PCI (Payment Card Industry) Data Standards adopt this policy with regard to the CVV codes on credit cards. Merchants can store the credit card numbers, but never the CVV codes in their databases. If you must store the data, then by all means encrypt it, but be aware that encrypting it doesn't necessarily "secure" the data, it just adds another layer of what is effectively obfuscation for an attacker who can potentially compromise your physical machine or Operating System. If you are storing the data, you'll have to have as strong perimeter security (ie. Network security ) as you can possibly get, precisely to prevent the potential for an attacker to gain access to the server's OS. Export the certificate and key and store them on a USB key which will be locked in a treasure chest and guarded by dragons, As well as a solid firewall and perhaps IDS system, you might want to get one of those dragons to guard your server, too! :)
