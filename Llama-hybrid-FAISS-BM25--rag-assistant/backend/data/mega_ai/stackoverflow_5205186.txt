[site]: stackoverflow
[post_id]: 5205186
[parent_id]: 5202187
[tags]: 
My answers are quite like those of @Flack : Having this XML document (corrected the provided one in closing numerous unclosed s and in wrapping everything in a single top element): ANT101H5 Introduction to Biological Anthropology and Archaeology (SCI) Anthropology is the global and holistic study of human biology and behaviour, and includes four subfields: biological anthropology, archaeology, sociocultural anthropology and linguistics. The material covered is directed to answering the question: What makes us human? This course is a survey of biological anthropology and archaeology. [ 24L , 12T ] Exclusion: ANT100Y5 Prerequisite: ANT102H5 This XPath expression : normalize-space(/*/p/text()[1]) when evaluated produces the wanted string (the surrounding quotes are not in the result. I added them to show the exact string produced): "ANT101H5 Introduction to Biological Anthropology and Archaeology" This XPath expression : concat((//span[@class='title2'])[1], (//span[@class='title2'])[1] /following-sibling::a[1] ) when evaluated produces the following wanted result: "Exclusion: ANT100Y5" This XPath expression : concat((//span[@class='title2'])[2], (//span[@class='title2'])[2] /following-sibling::a[1] ) when evaluated produces the following wanted result: "Prerequisite: ANT102H5" Note : In this particular case the abbreviation // is not needed and in fact this abbreviation should always when possible be avoided, because it leads to slower evaluation of the expression, causing in many cases a complete (sub) tree traversal. I am using '//' intentionally, because the provided XML fragment doesn't give us the full structure of the XML document. Also, This demonstrates how to correctly index the results of using // (note the surrounding brackets) -- helping to prevent a very frequent mistake in trying to do so UPDATE : The OP has requested a single XPath expression that selects all the required text nodes -- here it is: /*/p/text()[1] | (//span[@class='title2'])[1]/text() | (//span[@class='title2'])[1]/following-sibling::a[1]/text() | (//span[@class='title2'])[2]/text() | (//span[@class='title2'])[2]/following-sibling::a[1]/text() When applied on the same XML document as above, the concatenation of the text nodes is exactly what is required: ANT101H5 Introduction to Biological Anthropology and Archaeology Exclusion: ANT100Y5Prerequisite: ANT102H5 This result can be confirmed by running the following XSLT transformation: when this transformation is applied on the same XML document (specified previously in this answer), the wanted, correct result is produced : ANT101H5 Introduction to Biological Anthropology and Archaeology Exclusion: ANT100Y5Prerequisite: ANT102H5 Finally : The following single XPath expression selects exactly all wanted text node in the HTML page, with the provided link (after tidying it to become well-formed XML): (//p[@class='titlestyle'])[2]/text()[1] | (//span[@class='title2'])[2]/text() | (//span[@class='title2'])[2]/following-sibling::a[1]/text() | (//span[@class='title2'])[3]/text() | (//span[@class='title2'])[3]/following-sibling::a[1]/text()
