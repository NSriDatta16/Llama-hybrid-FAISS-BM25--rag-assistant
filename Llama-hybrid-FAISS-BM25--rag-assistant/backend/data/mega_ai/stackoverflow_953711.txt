[site]: stackoverflow
[post_id]: 953711
[parent_id]: 949271
[tags]: 
Even if your solution is not fort-knox, you should be diligent and implement salting. Because many people reuse their passwords elsewhere, and the break-in will do additional damage outside your organization, should the attackers choose to use the cracked password database for other purposes. Salting makes dictionary attacks more expensive. By deciding what salt size to use you can fine tune your chances. Here's the quote from Bruce Schneier's "Applied Cryptography": "Salt isn't a panacea; increasing the number of salt bits won't solve everything. Salt only protects against general dictionary attacks on a password file, not a concerted attack on a single password. It protects people who have the same password on multiple machines, but doesn't make poorly chosen passwords any better." Here's a sample in C#. It ain't that hard. And you can choose what salt size and hash function to use. Disclaimer: use something like bcrypt if you really care about password integrity. using System; using System.IO; using System.Reflection; using System.Security.Cryptography; using System.Text; public class PassHash { private static readonly RandomNumberGenerator rng = RandomNumberGenerator.Create(); public static readonly int DefaultSaltSize = 8; // 64-bit salt public readonly byte[] Salt; public readonly byte[] Passhash; internal PassHash(byte[] salt, byte[] passhash) { Salt = salt; Passhash = passhash; } public override String ToString() { return String.Format("{{'salt': '{0}', 'passhash': '{1}'}}", Convert.ToBase64String(Salt), Convert.ToBase64String(Passhash)); } public static PassHash Encode (String password) where HA : HashAlgorithm { return Encode (password, DefaultSaltSize); } public static PassHash Encode (String password, int saltSize) where HA : HashAlgorithm { return Encode (password, GenerateSalt(saltSize)); } private static PassHash Encode (string password, byte[] salt) where HA : HashAlgorithm { BindingFlags publicStatic = BindingFlags.Public | BindingFlags.Static; MethodInfo hasher_factory = typeof (HA).GetMethod("Create", publicStatic, Type.DefaultBinder, Type.EmptyTypes, null); using (HashAlgorithm hasher = (HashAlgorithm) hasher_factory.Invoke(null, null)) { using (MemoryStream hashInput = new MemoryStream()) { hashInput.Write(salt, 0, salt.Length); byte[] passwordBytes = Encoding.UTF8.GetBytes(password); hashInput.Write(passwordBytes, 0, passwordBytes.Length); hashInput.Seek(0, SeekOrigin.Begin); byte[] passhash = hasher.ComputeHash(hashInput); return new PassHash(salt, passhash); } } } private static byte[] GenerateSalt(int saltSize) { // This generates salt. // Rephrasing Schneier: // "salt" is a random string of bytes that is // combined with password bytes before being // operated by the one-way function. byte[] salt = new byte[saltSize]; rng.GetBytes(salt); return salt; } public static bool Verify (string password, byte[] salt, byte[] passhash) where HA : HashAlgorithm { // OMG: I don't know how to compare byte arrays in C#. return Encode (password, salt).ToString() == new PassHash(salt, passhash).ToString(); } } Usage: New user submits their credentials. PassHash ph = PassHash.Encode (new_user_password); Store ph.Salt & ph.Passhash somewhere ... Later, when user logs in again, you look up the user record that has salt & passhash, and then you do this: PassHash.Verify (user_login_password, user_rec.salt, user_rec.passhash) }
