[site]: stackoverflow
[post_id]: 4230509
[parent_id]: 4230365
[tags]: 
Generally I've had a pretty positive experience working from xsd. On the few occasions it has failed, I've found a pragmatic approach (if you have sample xml available) is to use the xsd.exe tool to generate something that even if not ideally typed , at least matches the xml. Of course, you might need to live with a few more string members that you like, or tweak them manually. Tweaking the xsd (to account for any changes not in your copy, or to hack away xsd options not supported by your tooling) might be a sensible option, but it is hard to gauge how long you might need to spend on that route. Re the value: well, when it works it is a pretty fair way of getting an object-model that can serve as a DTO layer. And usually it does work. But not quite always. It sounds like your scenario has large/complex/multiple xsd, so doing all that translation code by hand (either via xml querying, or writing your own DTO model from scratch) can be a lot of work. Xsd can (and should) also be used as a tool to validate that the xml you are passing around continues to adhere to a published definition. When dealing with xml data-imports I have, on multiple occasions, made the first step a scan through an xsd validator (fortunately XmlReader will do that in .NET).
