[site]: stackoverflow
[post_id]: 5490952
[parent_id]: 
[tags]: 
How to merge array of hashes to get hash of arrays of values

This is the opposite of Turning a Hash of Arrays into an Array of Hashes in Ruby . Elegantly and/or efficiently turn an array of hashes into a hash where the values are arrays of all values: hs = [ { a:1, b:2 }, { a:3, c:4 }, { b:5, d:6 } ] collect_values( hs ) #=> { :a=>[1,3], :b=>[2,5], :c=>[4], :d=>[6] } This terse code almost works, but fails to create an array when there are no duplicates: def collect_values( hashes ) hashes.inject({}){ |a,b| a.merge(b){ |_,x,y| [*x,*y] } } end collect_values( hs ) #=> { :a=>[1,3], :b=>[2,5], :c=>4, :d=>6 } This code works, but can you write a better version? def collect_values( hashes ) # Requires Ruby 1.8.7+ for Object#tap Hash.new{ |h,k| h[k]=[] }.tap do |result| hashes.each{ |h| h.each{ |k,v| result[k] Solutions that only work in Ruby 1.9 are acceptable, but should be noted as such. Here are the results of benchmarking the various answers below (and a few more of my own), using three different arrays of hashes: one where each hash has distinct keys, so no merging ever occurs: [{:a=>1}, {:b=>2}, {:c=>3}, {:d=>4}, {:e=>5}, {:f=>6}, {:g=>7}, ...] one where every hash has the same key, so maximum merging occurs: [{:a=>1}, {:a=>2}, {:a=>3}, {:a=>4}, {:a=>5}, {:a=>6}, {:a=>7}, ...] and one that is a mix of unique and shared keys: [{:c=>1}, {:d=>1}, {:c=>2}, {:f=>1}, {:c=>1, :d=>1}, {:h=>1}, {:c=>3}, ...] user system total real Phrogz 2a 0.577000 0.000000 0.577000 ( 0.576000) Phrogz 2b 0.624000 0.000000 0.624000 ( 0.620000) Glenn 1 0.640000 0.000000 0.640000 ( 0.641000) Phrogz 1 0.671000 0.000000 0.671000 ( 0.668000) Michael 1 0.702000 0.000000 0.702000 ( 0.700000) Michael 2 0.717000 0.000000 0.717000 ( 0.726000) Glenn 2 0.765000 0.000000 0.765000 ( 0.764000) fl00r 0.827000 0.000000 0.827000 ( 0.836000) sawa 0.874000 0.000000 0.874000 ( 0.868000) Tokland 1 0.873000 0.000000 0.873000 ( 0.876000) Tokland 2 1.077000 0.000000 1.077000 ( 1.073000) Phrogz 3 2.106000 0.093000 2.199000 ( 2.209000) The fastest code is this method that I added: def collect_values(hashes) {}.tap{ |r| hashes.each{ |h| h.each{ |k,v| (r[k]||=[]) I've accepted " glenn mcdonald's answer " as it was competitive in terms of speed, reasonably terse, but (most importantly) because it pointed out the danger of using a Hash with a self-modifying default proc for convenient construction, as this may introduce bad changes when the user is indexing it later on. Finally, here's the benchmark code, in case you want to run your own comparisons: require 'prime' # To generate the third hash require 'facets' # For tokland1's map_by AZSYMBOLS = (:a..:z).to_a TESTS = { '26 Distinct Hashes' => AZSYMBOLS.zip(1..26).map{|a| Hash[*a] }, '26 Same-Key Hashes' => ([:a]*26).zip(1..26).map{|a| Hash[*a] }, '26 Mixed-Keys Hashes' => (2..27).map do |i| factors = i.prime_division.transpose Hash[AZSYMBOLS.values_at(*factors.first).zip(factors.last)] end } def phrogz1(hashes) Hash.new{ |h,k| h[k]=[] }.tap do |result| hashes.each{ |h| h.each{ |k,v| result[k]
