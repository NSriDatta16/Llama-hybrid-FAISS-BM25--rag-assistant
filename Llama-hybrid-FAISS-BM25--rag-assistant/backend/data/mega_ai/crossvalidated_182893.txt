[site]: crossvalidated
[post_id]: 182893
[parent_id]: 57685
[tags]: 
One way to do this would be to check the point "verticality", regress a line through (X,Y) inverted points, and then invert the regressed line back. Check point "verticality" by comparing the standard deviations of X and Y values. stDevX = StandardDeviation(xValues) stDevY = StandardDeviation(yValues) verticality = stDevY/stDevX #Handle div/0 cases If vertical, regress a line through inverted Y and X points. isVertical = verticality > 1.5 #adjust based on situation (could be 2.0 or more) if(isVertical) invertedLine = RegressLine(yValues,xValues) #Note reversed x,y order Obtain non-inverted slope and intercept from inverted line slope = 1/invertedLine.Slope intercept = -invertedLine.Intercept / invertedLine.Slope Notes: This will fail if the points are perfectly vertical (ie. stDevX is =0). If this is the case, the line equation is just x=Average(xValues). For nearly-vertical lines, the slope will be large, but finite. The stDevY/stDevX ratio will be approximately equal to the regressed line |slope|. When the points become vertical, the regressed line slope will start to deviate from the ratio. In my case, whenever the ratio exceeded 1.5, the regressed slope became inaccurate, and flipping the axes improved accuracy. You should experiment with your data to find the best verticality threshold.
