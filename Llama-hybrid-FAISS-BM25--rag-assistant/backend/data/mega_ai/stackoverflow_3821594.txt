[site]: stackoverflow
[post_id]: 3821594
[parent_id]: 3820996
[tags]: 
The problem with saving a record containing dynamic array or real strings (or other "managed" types for that matter) is, it's not an big blob of memory containing everything, it's more like a tree. Someone or something needs to go over everything and save it to storage, somehow. Other languages (Python for example) include all sorts of facilities to transform most objects to text (serialize it), save it to disk and reload it (deserialize it). Even though a Embarcadero-provided solution doesn't exist for Delphi, one can be implemented using the extended RTTI available in Delphi 2010. A ready-made implementation is available in the DeHL library (here's a blog post about it) - but I can't say much about the implementation, I never used DeHL. An other option is the one you want to avoid: manually serialize the record to an TStream; It's actually not half difficult. Here's the kind of code I usually use to read/write objects to a file stream: procedure SaveToFile(FileName:string); var F:TFileStream; W:TWriter; i:Integer; begin F := TFileStream.Create(FileName, fmCreate); try W := TWriter.Create(F, 128); try // For every field that needs saving: W.WriteString(SomeStr); W.WriteInteger(TheNumber); // Dynamic arrays? Save the length first, then save // every item. The length is needed when reading. W.WriteInteger(Length(DArray)); for i:=0 to High(DArray) do W.WriteString(DArray[i]); finally W.Free; end; finally F.Free; end; end; procedure ReadFromFile(FileName:string); var F:TFileStream; R:TReader; i,n:Integer; begin F := TFileStream.Create(FileName, fmOpenRead); try R := TReader.Create(F, 128); try SomeStr := R.ReadString; TheNumber := R.ReadInteger; // Reading the dynamic-array. We first get the length: n := R.ReadInteger; SetLength(DArray, n); // And item-by-item for i:=0 to n-1 do DArray[i] := R.ReadString; finally R.Free; end; finally F.Free; end; end;
