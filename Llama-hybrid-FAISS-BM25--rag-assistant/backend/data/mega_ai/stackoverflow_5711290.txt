[site]: stackoverflow
[post_id]: 5711290
[parent_id]: 5711114
[tags]: 
Implicit conversions, such as the one provided by JavaConversions, work at the instance level rather than the type level. So, while the outermost map can be converted, the inner maps will not be. There isn't a way to directly have the nested case implicitly converted. And, unfortunately, it appears that the most specific implicit is not being correctly selected in the following examples: scala> val storage = new ConcurrentHashMap[String,ConcurrentHashMap[Int,ConcurrentHashMap[String,Double]]] storage: java.util.concurrent.ConcurrentHashMap[String,java.util.concurrent.ConcurrentHashMap[Int,java.util.concurrent.ConcurrentHashMap[String,Double]]] = {} scala> import scala.collection.JavaConverters._ scala> for ((i, m) (k, l)) res0: scala.collection.mutable.Map[(String, Int),(String, Double)] = Map() scala> import scala.collection.JavaConversions._ scala> for ((i, m) (k, l)) res3: scala.collection.mutable.Map[(String, Int),(String, Double)] = Map() So, in final analysis, I predict a lot of type annotations in your future (the for comprehensions above would probably work with explicit type ascription, but I'm too sleepy to type it all out.)
