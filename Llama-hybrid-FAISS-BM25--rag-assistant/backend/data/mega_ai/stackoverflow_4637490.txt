[site]: stackoverflow
[post_id]: 4637490
[parent_id]: 4637215
[tags]: 
I think you premonition is right, you need to adhere to Swing threading rules. So what to do? First, I am not sure how your app is designed exactly. You say that you have a main frame with a bunch of rows, and potentially each could potentially call one of 9 classes, and they all look like the one above. It seems that these classes will generate their own JFrame . I guess that this new frame is solely used for the progress bar. I will assume that this is the design and will suggest accordingly. I suggest that you perform a couple actions in instances of Runnable , and you drop those Runnable instances into SwingUtilities.invokeLater to have them run on the EDT. At the same time, I would take the time to reorganize your code for ease if reading. move the creation of your GUI bits into a method: public void createComponents () { SwingUtilities.invokeLater(new Runnable() { public void run() { //Create all components progressFrame = new JFrame("Calculation Progress"); progressFrame.setSize(300, 100); pane = progressFrame.getContentPane(); pane.setLayout(null); progressFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); progressBar = new JProgressBar(0, iterations); //Add components to pane pane.add(progressBar); //Position controls (X, Y, width, height) progressBar.setBounds(10, 10, 280, 20); //Make frame visible progressFrame.setResizable(false); //No resize progressFrame.setVisible(true); } }); } Then I would methodize the two GUI actions that you have in your calc: private void updateProgressBar(final int i) { SwingUtilities.invokeLater(new Runnable() { public void run() { progressBar.setValue(i); //no need for the following //progressBar.repaint(); } }); } private void killDialog() { SwingUtilities.invokeLater(new Runnable() { public void run() { progressFrame.setVisible(false); } }); } Finally, replace where the code contained in these new methods with calls to the methods.
