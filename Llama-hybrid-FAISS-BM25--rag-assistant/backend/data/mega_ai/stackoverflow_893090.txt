[site]: stackoverflow
[post_id]: 893090
[parent_id]: 886094
[tags]: 
I asked this question another way here: Using AssemblyBuilder, how can I make all or any of the referenced assemblies embedded instead of linked in the saved assembly? Patching the existing dll with the dynamically generated code would result in the same thing as embedding the original dll in the dynamically generated code -- a single assembly with the contents of both. It seems that one way or another, to eliminate dependencies and pack the contents of multiple assemblies into one, the ILMerge utility is the most elegant solution. The only problem with it is that the types generated in the merged dll are incompatible with the same types in both of the original dlls. If the original DLL, for example, emits a new assembly, merges it with itself, and loads the new assembly... it cannot use its own types to refer to things in the new assembly which correspond to the same type in either of the original assemblies. In other words: Class A in [dll_generator] references [dll_1]. Class A generates [dll_2], which is based on and of course also references [dll_1]. Class A calls ILMerge to combine [dll_2] with its dependency [dll_1] to produce [dll_merged]. None of the types in [dll_merged] are compatible with any of their original types in [dll_1] and [dll_2], so if class A loads [dll_merged] and tries to do anything with it involving literal type names from its original reference to [dll_1], it fails, because the types are incompatible. The only way class A can work with types in [dll_merged] is to load them by name and work entirely with 'Type' objects and reflection -- or dynamically compile source code against the new [dll_merged].
