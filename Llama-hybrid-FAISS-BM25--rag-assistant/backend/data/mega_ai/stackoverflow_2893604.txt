[site]: stackoverflow
[post_id]: 2893604
[parent_id]: 2893097
[tags]: 
In principal when a module goes out-of-scope, the variables of that module become undefined -- unless they are declared with the SAVE attribute, or a SAVE statement is used. "Undefined" means that you are not allowed to rely on the variable having the previous value if you again use the module -- it might have the previous value when you re-access the module, or it might not -- there is no guarantee. But many compilers don't do this for module variables -- the variables probably retain their values -- it isn't worth the effort for the compiler to figure out whether a module remains in scope or not and probably module variables are treated as global variables -- but don't rely on that! To be safe, either use "save" or "use" the module from the main program so that it never goes out of scope. "save" is also important in procedures, to store "state" across invocations of the subroutine or function (as written by @ire_and_curses) -- "first invocation" initializations, counters, etc. subroutine my_sub (y) integer :: var integer, save :: counter = 0 logical, save :: FirstCall = .TRUE. counter = counter + 1 write (*, *) counter if (FirstCall) then FirstCall = .FALSE. .... end if var = .... etc. In this code fragment, "counter" will report the number of invocations of subroutine x. Though actually in Fortran >=90 one can omit the "save" because the initialization in the declaration implies "save". In contrast to the module case, with modern compilers, without the save attribute or initialization-on-a-declaration, it is normal for local variables of procedures to lose their values across invocations. So if you attempt to use "var" on an later call before redefining it in that call, the value is undefined and probably won't be the value calculated on a previous invocation of the procedure. This is different from the behavior of many FORTRAN 77 compilers, some of which retained the values of all local variables, even though this wasn't required by the language standard. Some old programs were written relying on this non-standard behavior -- these programs will fail on the newer compilers. Many compilers have an option to use the non-standard behavior and "save" all local variables. LATER EDIT: update with a code example that shows incorrect usage of a local variable that should have the save attribute but doesn't: module subs contains subroutine asub (i, control) implicit none integer, intent (in) :: i logical, intent (in) :: control integer, save :: j = 0 integer :: k j = j + i if ( control ) k = 0 k = k + i write (*, *) 'i, j, k=', i, j, k end subroutine asub end module subs program test_saves use subs implicit none call asub ( 3, .TRUE. ) call asub ( 4, .FALSE. ) end program test_saves Local variable k of the subroutine is intentionally misused -- in this program it is initialized in the first call since control is TRUE, but on the second call control is FALSE, so k is not redefined. But without the save attribute k is undefined, so the using its value is illegal. Compiling the program with gfortran, I found that k retained its value anyway: i, j, k= 3 3 3 i, j, k= 4 7 7 Compiling the program with ifort and aggressive optimization options, k lost its value: i, j, k= 3 3 3 i, j, k= 4 7 4 Using ifort with debugging options, the problems was detected at runtime! i, j, k= 3 3 3 forrtl: severe (193): Run-Time Check Failure. The variable 'subs_mp_asub_$K' is being used without being defined
