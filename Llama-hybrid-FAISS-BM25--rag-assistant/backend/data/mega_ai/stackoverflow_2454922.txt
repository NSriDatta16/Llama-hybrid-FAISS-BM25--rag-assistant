[site]: stackoverflow
[post_id]: 2454922
[parent_id]: 2454333
[tags]: 
Below is a header of my CDialog based window generated by MFC wizard #pragma once #include "threatgrid.h" #define COLUMN_COUNT 4 // CThreatSelection dialog class CThreatSelection : public CDialog { DECLARE_DYNAMIC(CThreatSelection) public: CThreatSelection(CWnd* pParent = NULL); // standard constructor virtual ~CThreatSelection(); // Dialog Data enum { IDD = IDD_THSELECT }; protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support DECLARE_MESSAGE_MAP() public: virtual BOOL OnInitDialog(); private: public: // My custom cotrol field CThreatGrid threatGrid; afx_msg void OnSize(UINT nType, int cx, int cy); }; Here is te body: // ThreatSelection.cpp : implementation file // #include "stdafx.h" #include "SpeedNotifyNative.h" #include "ThreatSelection.h" // CThreatSelection dialog IMPLEMENT_DYNAMIC(CThreatSelection, CDialog) CThreatSelection::CThreatSelection(CWnd* pParent /*=NULL*/) : CDialog(CThreatSelection::IDD, pParent) , threatGrid(theApp.imaging, 3) { } CThreatSelection::~CThreatSelection() { } void CThreatSelection::DoDataExchange(CDataExchange* pDX) { CDialog::DoDataExchange(pDX); DDX_Control(pDX, IDC_THGRID, threatGrid); } BEGIN_MESSAGE_MAP(CThreatSelection, CDialog) ON_WM_SIZE() END_MESSAGE_MAP() // CThreatSelection message handlers BOOL CThreatSelection::OnInitDialog() { CDialog::OnInitDialog(); // TODO: Add extra initialization here return TRUE; // return TRUE unless you set the focus to a control // EXCEPTION: OCX Property Pages should return FALSE } void CThreatSelection::OnSize(UINT nType, int cx, int cy) { threatGrid.MoveWindow(0,0, cx, cy, FALSE); //threatGrid.SizeChanged(cx,cy); I use it normally because no WM_SIZE is sent to threatGrid CDialog::OnSize(nType, cx, cy); // TODO: Add your message handler code here } ...And my custom control header: #pragma once #include "atltypes.h" #include "GridIcon.h" // CThreatGrid class ImagingSystem; class CThreatGrid : public CStatic { DECLARE_DYNAMIC(CThreatGrid) public: CThreatGrid(ImagingSystem* imaging, int cols); virtual ~CThreatGrid(); protected: DECLARE_MESSAGE_MAP() private: // Obiekt podsystemu obrazowania ImagingSystem* imaging; // Ilość kolumn w siatce int columns; // Spacing elementów int spacing; public: // Informuje kontrolkę o zmianie rozmiaru - dotychczas nie udało mi się znaleźć rozwiązania dlaczego WM_SIZE nie ejst wysyłane void SizeChanged(int cx, int cy); private: // Aktualny rozmiar - śledzony niezależnie aby uniknąć niepotrzebnych przeładowań obrazków CSize currSize; // Lista ikon std::vector icons; public: afx_msg void OnSize(UINT nType, int cx, int cy); }; ...and my custom control body: // ThreatGrid.cpp : implementation file // #include "stdafx.h" #include "SpeedNotifyNative.h" #include "ThreatGrid.h" // CThreatGrid IMPLEMENT_DYNAMIC(CThreatGrid, CStatic) CThreatGrid::CThreatGrid(ImagingSystem* imaging, int cols) : imaging(imaging) , columns(cols) { } CThreatGrid::~CThreatGrid() { } BEGIN_MESSAGE_MAP(CThreatGrid, CStatic) ON_WM_SIZE() END_MESSAGE_MAP() // Informuje kontrolkę o zmianie rozmiaru - dotychczas nie udało mi się znaleźć rozwiązania dlaczego WM_SIZE nie ejst wysyłane void CThreatGrid::SizeChanged(int cx, int cy) { CSize nSize(cx,cy); if(nSize != currSize) { currSize = nSize; int wspc = (int)(0.015 * cx); int hspc = (int)(0.015 * cy); spacing = (wspc 0 ) { int rows = (icons.size() + columns - 1) / columns; int width = (currSize.cx - spacing * (2 + columns - 1)) / columns; int height = (currSize.cy - spacing * (2 + rows - 1)) / rows; CSize size; if ( width Calculate(i / columns, i % columns, abspoint, size, spacing); } } } } void CThreatGrid::OnSize(UINT nType, int cx, int cy) { CStatic::OnSize(nType, cx, cy); // NEVER CALLED BY SYSTEM }
