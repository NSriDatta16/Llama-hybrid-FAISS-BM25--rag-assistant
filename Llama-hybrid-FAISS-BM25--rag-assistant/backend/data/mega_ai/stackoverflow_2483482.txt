[site]: stackoverflow
[post_id]: 2483482
[parent_id]: 2483412
[tags]: 
Basically we're talking about two intervals that are adjacent [a..b-1] and [b..n] (bounds are inclusive), and you're asking why it's presented as (a, b, n) instead of (a, b-1, b, n) ? You said it yourself: it's "such a little detail". It doesn't affect correctness, and any performance gained in not recomputing b-1 may be offset by the cost of passing it as an additional parameter. Is it worth the effort of profiling to investigate one way or another? No. It has no effect on the algorithm's asymptotic behavior, and any difference in performance is negligible; it's not worth fussing about little things like this. By the way, it is worth noting that the way of computing average of two number as above is now considered broken (see: Google Research blog: Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken ). Josh Bloch recommends: int mid = (low + high) >>> 1; Going back to the original question, generally speaking, if a parameter can be derived from another, then often it's best to omit them; it simplifies calling it, and it also simplifies analysis due to obviously smaller domain. A function that takes 10 parameters, 5 them of derivable, is much harder to analyze than one that simply takes 5. Of course, if the derivable parameters are expensive and/or non-trivial to compute, and you've already computed their values before you call the function, then you may consider passing them on. In fact, in the merge sort example, (a, n) suffices, since b is derivable from both. That computation is not trivial, however (the bug Bloch mentions escapes detection for 2 decades), so it's decided to simply pass it on. b-1 , by contrast, is way too trivial and is best omitted.
