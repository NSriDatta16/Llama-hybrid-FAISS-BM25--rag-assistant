[site]: stackoverflow
[post_id]: 2299810
[parent_id]: 2270134
[tags]: 
A: An all-lazy implementation will suffice if you just iterate through the results in a nested foreach: using System; using System.Collections.Generic; public static class Splitter { public static IEnumerable > Split (this IEnumerable source, Predicate match) { using (IEnumerator enumerator = source.GetEnumerator()) { while (enumerator.MoveNext()) { yield return Split(enumerator, match); } } } static IEnumerable Split (IEnumerator enumerator, Predicate match) { do { if (match(enumerator.Current)) { yield break; } else { yield return enumerator.Current; } } while (enumerator.MoveNext()); } } Use it like this: using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace MyTokenizer { class Program { enum TokenTypes { SimpleToken, UberToken } class Token { public TokenTypes TokenType = TokenTypes.SimpleToken; } class MyUberToken : Token { public MyUberToken() { TokenType = TokenTypes.UberToken; } } static void Main(string[] args) { List objects = new List (new object[] { "A", Guid.NewGuid(), "C", new MyUberToken(), "D", new MyUberToken(), "E", new MyUberToken() }); var splitOn = TokenTypes.UberToken; foreach (var list in objects.Split(x => x is Token && ((Token)x).TokenType == splitOn)) { foreach (var item in list) { Console.WriteLine(item); } Console.WriteLine("=============="); } Console.ReadKey(); } } } B: If you need to process the results some time later and you wish to do it out-of-order, or you partition on one thread and then possibly dispatch the segments to multiple threads, then this would probably provide a good starting point: using System; using System.Collections.Generic; using System.Linq; public static class Splitter2 { public static IEnumerable > SplitToSegments (this IEnumerable source, Predicate match) { T[] items = source.ToArray(); for (int startIndex = 0; startIndex EnumerateArraySegment (T[] array, int startIndex, int endIndex) { for (; startIndex C: If you really must return a collection of List -s - which I doubt, unless you explicitly want to mutate them some time later on -, then try to initialize them to a given capacity before copying: public static List > SplitToLists (this IEnumerable source, Predicate match) { List > lists = new List >(); T[] items = source.ToArray(); for (int startIndex = 0; startIndex list = new List (endIndex - startIndex); list.AddRange(EnumerateArraySegment(items, startIndex, endIndex - 1)); lists.Add(list); startIndex = endIndex; } return lists; } D: If this is still not enough, I suggest you roll your own lightweight List implementation that can copy a range directly to its internal array from another instance.
