[site]: stackoverflow
[post_id]: 4835884
[parent_id]: 4835608
[tags]: 
I'm not sure if you're going to be able to do it like that if you want to keep the s:close only at the end of the whole program. You might succeed by moving it up into before os.execute , since you're break ing anyway (but you're probably not doing this in your real program). Edit for clarity : The actual problem is that the only place you're spawning a subprocess in this case, is by using os.execute() , and you have no control over the child environment of sleep, in which everything is inherited from the main program, including socket and file descriptors. So, the canonical way to do this on POSIX is to use fork(); close(s); exec(); , instead of system() (aka, os.execute ) as system() / os.execute will hang on to the current process state during execution, and you won't be able to close it while blocked in the sub-process. So, a suggestion would be to grab luaposix , and use its posix.fork() and posix.exec() functionality, and calling s:close() in the fork ed child process. Shouldn't be so bad, since you're already using an external package by relying upon luasocket . EDIT : Here's heavily commented code to do it with luaposix: require('socket') require('posix') print('listening') s = socket.bind("*", 9999) s:settimeout(1) while true do print('accepting connection') local c = s:accept() if c then c:settimeout(1) local rec = c:receive() print('received ' .. rec) c:close() if rec == "quit" then break end if rec == "exec" then local pid = posix.fork() if pid == 0 then print('child: running ping in background') s:close() -- exec() replaces current process, doesn't return. -- execp has PATH resolution rc = posix.execp('sleep','60s'); -- exec has no PATH resolution, probably "more secure" --rc = posix.exec('/usr/bin/sleep','60s'); print('exec failed with rc: ' .. rc); else -- if you want to catch the SIGCHLD: --print('parent: waiting for ping to return') --posix.wait( pid ) print('parent: exiting loop') end break; end end end print('closing server') s:close() This closes the socket in the child process before calling exec , and the netstat -nlp output shows the system is correctly no longer listening on port 9999 when the parent exits. P.S. The line print('exec failed with rc: ' .. rc); complained about a type problem once when exec failed. I don't actually know lua, so you'll have to fix that. :) Furthermore, fork() can fail, returning -1. Probably should check for that in your main code, too, for completeness.
