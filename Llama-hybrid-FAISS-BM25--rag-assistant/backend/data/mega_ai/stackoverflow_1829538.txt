[site]: stackoverflow
[post_id]: 1829538
[parent_id]: 1829271
[tags]: 
Compilers are very good at optimizing switch/case constructs; the CLR will likely turn it into a lookup table or something similarly fast, so hand-rolling your own version such as Henk Holterman suggests is not what I would recommend. The CLR can do a better job than you can at choosing the best algorithm. If it's an issue of elegance or maintainability, and you have several switch/cases strewn about the same class performing similar functions, then one way to improve it is to encapsulate all of the functionality related to a single "case" into its own class instance, like so: class MyOption { public static readonly MyOption Alpha = new MyOption(1, 10, "Alpha Text"); public static readonly MyOption Bravo = new MyOption(2, 100, "Bravo Text"); public static readonly MyOption Charlie = new MyOption(3, 1000, "Charlie Text"); // ... Other options ... public static readonly MyOption Default = new MyOption(0, 0, null); public MyOption(int id, int value, string text) { this.ID = id; this.Value = value; this.Text = text; } public int ID { get; private set; } public int Value { get; private set; } public string Text { get; private set; } } Then in your class/control/page: static MyOption GetOption(string optionName) { switch (optionName) { case "ALPHA": return MyOption.Alpha; case "BRAVO": return MyOption.Bravo; case "CHARLIE": return MyOption.Charlie; // ... Other options ... default: return MyOption.Default; } } private MyOption GetOptionFromDropDown() { string optionName = GetOptionNameFromDropDown(); return GetOption(optionName); } private string GetOptionNameFromDropDown() { // ... Your code ... } After that you can start churning out events and other methods: private void control1_SomeEvent(object sender, EventArgs e) { MyOption option = GetOptionFromDropDown(); DoSomething(option.ID); } private void control2_SomeEvent(object sender, EventArgs e) { MyOption option = GetOptionFromDropDown(); DoSomethingElse(option.Value); } Of course, this is only a useful pattern if you have several of these switch/cases that you want to refactor into one. If you've only got one switch/case, you're just going to end up with a lot more code this way, so leave it alone! Other possibilities to improve maintainability include: Changing the string to an Enum type (convert optionName using Enum.Parse); Moving all the MyOption/GetOption stuff into its own class (if you have several classes/controls/pages that all need to operate on the same set of choices); Add a method delegate to the MyOption class if you actually need to call a different method for each; Have your DropDownList or other control store a direct reference to the MyOption instance, if possible. That's about it. It's simple to write, it's easy to understand, it's easy to maintain, it will save you time if you have a lot of switch/case constructs, and it still allows the CLR to perform the best possible optimizations. The only cost is the small amount of memory required to hold those readonly fields.
