[site]: stackoverflow
[post_id]: 5081150
[parent_id]: 5080477
[tags]: 
An instance variable would probably be the way to do what you want. You could make it static to persist the same value for the life of the program (or thread depending on your static memory model), or make it an ordinary instance var to control it over the life of an object instance. If that instance is a singleton, they'll behave the same way. #if DEBUG private /*static*/ bool s_bDoDebugOnlyCode = false; #endif void foo() { // ... #if DEBUG if (s_bDoDebugOnlyCode) { // Code here gets executed only when compiled with the DEBUG constant, // and when the person debugging manually sets the bool above to true. // It then stays for the rest of the session until they set it to false. } #endif // ... } Just to be complete, pragmas (preprocessor directives) are considered a bit of a kludge to use to control program flow. .NET has a built-in answer for half of this problem, using the "Conditional" attribute. private /*static*/ bool doDebugOnlyCode = false; [Conditional("DEBUG")] void foo() { // ... if (doDebugOnlyCode) { // Code here gets executed only when compiled with the DEBUG constant, // and when the person debugging manually sets the bool above to true. // It then stays for the rest of the session until they set it to false. } // ... } No pragmas, much cleaner. The downside is that Conditional can only be applied to methods, so you'll have to deal with a boolean variable that doesn't do anything in a release build. As the variable exists solely to be toggled from the VS execution host, and in a release build its value doesn't matter, it's pretty harmless.
