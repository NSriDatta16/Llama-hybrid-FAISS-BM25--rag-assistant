[site]: stackoverflow
[post_id]: 4144465
[parent_id]: 4123178
[tags]: 
Just for completeness here is an alterantive (more compact) version of the Drain() method suggested by Richard: public static IObservable SelectManySequential ( this IObservable source, Func > selector ) { return source .Select(x => Observable.Defer (() => selector(x))) .Concat(); } See the thread Drain + SelectMany = ? in the Rx forum. Update: I realized that the Concat() overload that I used was one of my personal Rx extensions that are (not yet) part of the framework. I am sorry for this mistake .. Of course this makes my solution less elegant than I thought. Nevertheless for completeness I post here my Conact() extension method overload: public static IObservable Concat (this IObservable > source) { return Observable.CreateWithDisposable (o => { var lockCookie = new Object(); bool completed = false; bool subscribed = false; var waiting = new Queue >(); var pendingSubscription = new MutableDisposable(); Action errorHandler = e => { o.OnError(e); pendingSubscription.Dispose(); }; Func , IDisposable> subscribe = null; subscribe = (ob) => { subscribed = true; return ob.Subscribe( o.OnNext, errorHandler, () => { lock (lockCookie) { if (waiting.Count > 0) pendingSubscription.Disposable = subscribe(waiting.Dequeue()); else if (completed) o.OnCompleted(); else subscribed = false; } } ); }; return new CompositeDisposable(pendingSubscription, source.Subscribe( n => { lock (lockCookie) { if (!subscribed) pendingSubscription.Disposable = subscribe(n); else waiting.Enqueue(n); } }, errorHandler , () => { lock (lockCookie) { completed = true; if (!subscribed) o.OnCompleted(); } } ) ); }); } And now beating myself with my own weapons: The same Concat() method could be written much more elegant in Richard Szalay's brilliant way: public static IObservable Concat (this IObservable > source) { return Observable.Defer(() => { BehaviorSubject queue = new BehaviorSubject (new Unit()); return source .Zip(queue, (v, q) => v) .SelectMany(v => v.Do(_ => { }, () => queue.OnNext(new Unit())) ); }); } So credit belongs to Richard. :-)
