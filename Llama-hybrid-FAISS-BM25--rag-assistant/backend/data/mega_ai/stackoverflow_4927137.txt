[site]: stackoverflow
[post_id]: 4927137
[parent_id]: 4924034
[tags]: 
JAX-RS dispatches to methods annotated with @Produces via the Accept header. So, if you want JAX-RS to do your dispatching, you'll need to leverage this mechanism. Without any extra work, you would have to create a method (and Provider) for every media type you wish to support. There's nothing stopping you from having several methods based on media type that all call a common method to do that work, but you'd have to update that and add code every time you added a new media type. One idea is to add a filter that "normalizes" your Accept header specifically for dispatch. That is, perhaps, taking your: Accept: application/vnd.COMPANY.systeminfo-v1+json And converting that to, simply: Accept: application/vnd.COMPANY.systeminfo+json At the same time, you extract the version information for later use (perhaps in the request, or some other ad hoc mechanism). Then, JAX-RS will dispatch to the single method that handles "application/vnd.COMPANY.systeminfo+json". THAT method then takes the "out of band" versioning information to handle details in processing (such as selecting the proper class to load via OSGi). Next, you then create a Provider with an appropriate MessageBodyWriter. The provider will be selected by JAX-RS for the application/vnd.COMPANY.systeminfo+json media type. It will be up to your MBW to figure out the actual media type (based again on that version information) and to create the proper output format (again, perhaps dispatching to the correct OSGi loaded class). I don't know if an MBW can overwrite the Content-Type header or not. If not, then you can delegate the earlier filter to rewrite that part for you on the way out. It's a little convoluted, but if you want to leverage JAX-RS dispatch, and not create methods for every version of your media type, then this is a possible path to do that. Edit in response to comment: Yea, essentially, you want JAX-RS to dispatch to the proper class based on both Path and Accept type. It is unlikely that JAX-RS will do this out of the box, as it's a bit of an edge case. I have not looked at any of the JAX-RS implementations, but you may be able to do what you want by tweaking one of the at the infrastructure level. Possibly another less invasive option is to use an age old trick from the Apache world, and simply create a filter that rewrites your path based on the Accept header. So, when the system gets: GET /resource Accept: application/vnd.COMPANY.systeminfo-v1+json You rewrite it to: GET /resource-v1 Accept: application/vnd.COMPANY.systeminfo-v1+json Then, in your JAX-RS class: @Path("resource-v1") @Produces("application/vnd.COMPANY.systeminfo-v1+json") public class ResourceV1 { ... } So, your clients get the correct view, but your classes get dispatched properly by JAX-RS. The only other issue is that your classes, if they look, will see the modified Path, not the original path (but your filter can stuff that in the request as a reference if you like). It's not ideal, but it's (mostly) free. This is an existing filter that might do what you want to do, if not it perhaps can act as an inspiration for you to do it yourself.
