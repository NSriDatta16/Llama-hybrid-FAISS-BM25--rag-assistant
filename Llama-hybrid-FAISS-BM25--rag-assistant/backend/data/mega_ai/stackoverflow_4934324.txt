[site]: stackoverflow
[post_id]: 4934324
[parent_id]: 
[tags]: 
Exposing 3rd Party C++ Functions and Classes

I'm writing a C++ application that makes heavy use of OpenCV. Unfortunately, some of the OpenCV code I'd like to make use of hasn't been exposed by their API. In particular, there is a struct LBPEvaluator::Feature in cascadedetect.cpp (quoted below) that I'd like to make use of. I know I can't simply "#include cascadedetect.cpp" as it will confuse the linker with multiply defined symbols. I assume there is a more elegant solution than copying, pasting, and renaming the code into one of my source files? What is the general strategy for accessing 3rd party C++ functions and classes that aren't exposed by the 3rd party's API? Many thanks in advance. Specific code I'm trying to use: class LBPEvaluator : public FeatureEvaluator { public: struct Feature { Feature(); Feature( int x, int y, int _block_w, int _block_h ) : rect(x, y, _block_w, _block_h) {} int calc( int offset ) const; void updatePtrs( const Mat& sum ); bool read(const FileNode& node ); Rect rect; // weight and height for block const int* p[16]; // fast }; LBPEvaluator(); virtual ~LBPEvaluator(); virtual bool read( const FileNode& node ); virtual Ptr clone() const; virtual int getFeatureType() const { return FeatureEvaluator::LBP; } virtual bool setImage(const Mat& image, Size _origWinSize); virtual bool setWindow(Point pt); int operator()(int featureIdx) const { return featuresPtr[featureIdx].calc(offset); } virtual int calcCat(int featureIdx) const { return (*this)(featureIdx); } private: Size origWinSize; Ptr > features; Feature* featuresPtr; // optimization Mat sum0, sum; Rect normrect; int offset; }; inline LBPEvaluator::Feature :: Feature() { rect = Rect(); for( int i = 0; i = cval ? 128 : 0) | // 0 (CALC_SUM_( p[1], p[2], p[5], p[6], offset ) >= cval ? 64 : 0) | // 1 (CALC_SUM_( p[2], p[3], p[6], p[7], offset ) >= cval ? 32 : 0) | // 2 (CALC_SUM_( p[6], p[7], p[10], p[11], offset ) >= cval ? 16 : 0) | // 5 (CALC_SUM_( p[10], p[11], p[14], p[15], offset ) >= cval ? 8 : 0)| // 8 (CALC_SUM_( p[9], p[10], p[13], p[14], offset ) >= cval ? 4 : 0)| // 7 (CALC_SUM_( p[8], p[9], p[12], p[13], offset ) >= cval ? 2 : 0)| // 6 (CALC_SUM_( p[4], p[5], p[8], p[9], offset ) >= cval ? 1 : 0); } inline void LBPEvaluator::Feature :: updatePtrs( const Mat& sum ) { const int* ptr = (const int*)sum.data; size_t step = sum.step/sizeof(ptr[0]); Rect tr = rect; CV_SUM_PTRS( p[0], p[1], p[4], p[5], ptr, tr, step ); tr.x += 2*rect.width; CV_SUM_PTRS( p[2], p[3], p[6], p[7], ptr, tr, step ); tr.y += 2*rect.height; CV_SUM_PTRS( p[10], p[11], p[14], p[15], ptr, tr, step ); tr.x -= 2*rect.width; CV_SUM_PTRS( p[8], p[9], p[12], p[13], ptr, tr, step ); } bool LBPEvaluator::Feature :: read(const FileNode& node ) { FileNode rnode = node[CC_RECT]; FileNodeIterator it = rnode.begin(); it >> rect.x >> rect.y >> rect.width >> rect.height; return true; } LBPEvaluator::LBPEvaluator() { features = new vector (); } LBPEvaluator::~LBPEvaluator() { } bool LBPEvaluator::read( const FileNode& node ) { features->resize(node.size()); featuresPtr = &(*features)[0]; FileNodeIterator it = node.begin(), it_end = node.end(); for(int i = 0; it != it_end; ++it, i++) { if(!featuresPtr[i].read(*it)) return false; } return true; } Ptr LBPEvaluator::clone() const { LBPEvaluator* ret = new LBPEvaluator; ret->origWinSize = origWinSize; ret->features = features; ret->featuresPtr = &(*ret->features)[0]; ret->sum0 = sum0, ret->sum = sum; ret->normrect = normrect; ret->offset = offset; return ret; } bool LBPEvaluator::setImage( const Mat& image, Size _origWinSize ) { int rn = image.rows+1, cn = image.cols+1; origWinSize = _origWinSize; if( image.cols size(); for( fi = 0; fi = sum.cols-2 || pt.y + origWinSize.height >= sum.rows-2 ) return false; offset = pt.y * ((int)sum.step/sizeof(int)) + pt.x; return true; } Ptr FeatureEvaluator::create(int featureType) { return featureType == HAAR ? Ptr (new HaarEvaluator) : featureType == LBP ? Ptr (new LBPEvaluator) : Ptr (); }
