[site]: stackoverflow
[post_id]: 4614213
[parent_id]: 4612830
[tags]: 
Perhaps you could augment your polynomial type with an index or tag? If I understand correctly, your normal module would be something like: data Poly r = Poly r class Ring r where plus :: r -> r -> r times :: r -> r -> r instance Ring (Poly Integer) where plus (Poly x) (Poly y) = Poly (x + y) times (Poly x) (Poly y) = Poly (x * y) gauss :: Poly Integer gauss = Poly 1 eins :: Poly Integer eins = Poly 2 And you want to be able to safely differential between the two "sub-types" of the rings. Perhaps you could tag them as so: newtype PolyI i r = PolyI r instance Show r => Show (PolyI i r) where show (PolyI p) = show p instance Ring (PolyI i Integer) where plus (PolyI x) (PolyI y) = PolyI (x + y) times (PolyI x) (PolyI y) = PolyI (x * y) Our instances of the Ring now require an extra type-argument i , which we can create by having simple no-constructor types. data Gauss data Eins Then we just create the specific polynomials with the index as an argument: gaussI :: PolyI Gauss Integer gaussI = PolyI 11 einsI :: PolyI Eins Integer einsI = PolyI 20 With the Show instance above, we get the following output: *Poly> plus einsI einsI 40 and then *Poly> plus einsI gaussI Couldn't match expected type `Eins' with actual type `Gauss' Expected type: PolyI Eins Integer Actual type: PolyI Gauss Integer In the second argument of `plus', namely `gaussI' Is that something like what you were looking for? Edit: after a comment to the question about newtype , I think this may also an elegant solution if you use NewtypeDeriving to ease the burden of re-implementing the Poly Integer instance. I think in the end it would be similar, if slightly more elegant than this approach.
