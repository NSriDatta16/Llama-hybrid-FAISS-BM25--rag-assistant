[site]: stackoverflow
[post_id]: 1296865
[parent_id]: 1296843
[tags]: 
Note: This answer applies to the C language, not C++. Null Pointers The integer constant literal 0 has different meanings depending upon the context in which it's used. In all cases, it is still an integer constant with the value 0 , it is just described in different ways. If a pointer is being compared to the constant literal 0 , then this is a check to see if the pointer is a null pointer. This 0 is then referred to as a null pointer constant. The C standard defines that 0 cast to the type void * is both a null pointer and a null pointer constant. Additionally, to help readability, the macro NULL is provided in the header file stddef.h . Depending upon your compiler it might be possible to #undef NULL and redefine it to something wacky. Therefore, here are some valid ways to check for a null pointer: if (pointer == NULL) NULL is defined to compare equal to a null pointer. It is implementation defined what the actual definition of NULL is, as long as it is a valid null pointer constant. if (pointer == 0) 0 is another representation of the null pointer constant. if (!pointer) This if statement implicitly checks "is not 0", so we reverse that to mean "is 0". The following are INVALID ways to check for a null pointer: int mynull = 0; if (pointer == mynull) To the compiler this is not a check for a null pointer, but an equality check on two variables. This might work if mynull never changes in the code and the compiler optimizations constant fold the 0 into the if statement, but this is not guaranteed and the compiler has to produce at least one diagnostic message (warning or error) according to the C Standard. Note that the value of a null pointer in the C language does not matter on the underlying architecture. If the underlying architecture has a null pointer value defined as address 0xDEADBEEF, then it is up to the compiler to sort this mess out. As such, even on this funny architecture, the following ways are still valid ways to check for a null pointer: if (!pointer) if (pointer == NULL) if (pointer == 0) The following are INVALID ways to check for a null pointer: #define MYNULL (void *) 0xDEADBEEF if (pointer == MYNULL) if (pointer == 0xDEADBEEF) as these are seen by a compiler as normal comparisons. Null Characters '\0' is defined to be a null character - that is a character with all bits set to zero. '\0' is (like all character literals) an integer constant, in this case with the value zero. So '\0' is completely equivalent to an unadorned 0 integer constant - the only difference is in the intent that it conveys to a human reader ("I'm using this as a null character."). '\0' has nothing to do with pointers. However, you may see something similar to this code: if (!*char_pointer) checks if the char pointer is pointing at a null character. if (*char_pointer) checks if the char pointer is pointing at a non-null character. Don't get these confused with null pointers. Just because the bit representation is the same, and this allows for some convenient cross over cases, they are not really the same thing. References See Question 5.3 of the comp.lang.c FAQ for more. See this pdf for the C standard. Check out sections 6.3.2.3 Pointers, paragraph 3.
