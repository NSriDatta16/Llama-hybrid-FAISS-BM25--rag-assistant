[site]: stackoverflow
[post_id]: 1648527
[parent_id]: 1645846
[tags]: 
OK, I have a parallel select but not on the table variable I've anonymised it and: BigParallelTable is 900k rows and wide For legacy reasons, BigParallelTable is partially denormalised (I'll fix it, later, promise) BigParallelTable often generates parallel plans because it's not ideal and is "expensive" SQL Server 2005 x64, SP3, build 4035, 16 cores Query + plan: DECLARE @FilterList TABLE (bar varchar(100) NOT NULL) INSERT @FilterList (bar) SELECT 'val1' UNION ALL 'val2' UNION ALL 'val3' --snipped SELECT * FROM dbo.BigParallelTable BPT JOIN @FilterList FL ON BPT.Thing = FL.Bar StmtText |--Parallelism(Gather Streams) |--Hash Match(Inner Join, HASH:([FL].[bar])=([BPT].[Thing]), RESIDUAL:(@FilterList.[bar] as [FL].[bar]=[MyDB].[dbo].[BigParallelTable].[Thing] as [BPT].[Thing])) |--Parallelism(Distribute Streams, Broadcast Partitioning) | |--Table Scan(OBJECT:(@FilterList AS [FL])) |--Clustered Index Scan(OBJECT:([MyDB].[dbo].[BigParallelTable].[PK_BigParallelTable] AS [BPT])) Now, thinking about it, a table variable is almost always a table scan, has no stats and is assumed one row "Estimated number of rows = 1", "Actual.. = 3". Can we declare that table variables are not used in parallel, but the containing plan can use parallelism elsewhere? So BOL is correct and the SQL Storage article is wrong
