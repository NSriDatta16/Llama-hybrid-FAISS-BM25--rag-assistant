[site]: stackoverflow
[post_id]: 4623665
[parent_id]: 4620294
[tags]: 
I had a very similar problem and solved it in the way suggested by Remou and co. Here is the code I used which is a modified version of some Microsoft code. All you need is a table called “tblNon_working_days” containing all the days that should not count Option Compare Database Option Explicit ' ********* Code Start ************** ' ' Modified from code in ' "Visual Basic Language Developer's Handbook" ' by Ken Getz and Mike Gilbert ' Copyright 2000; Sybex, Inc. All rights reserved. ' Public Function dhAddWorkDaysA(lngDays As Long, Optional dtmDate As Date = 0) 'Optional adtmDates As Variant) As Date ' Add the specified number of work days to the ' specified date. ' Modified from code in ' "Visual Basic Language Developer's Handbook" ' by Ken Getz and Mike Gilbert ' Copyright 2000; Sybex, Inc. All rights reserved. ' In: ' lngDays: ' Number of work days to add to the start date. ' dtmDate: ' date on which to start looking. ' Use the current date, if none was specified. ' adtmDates (Optional): ' Array containing holiday dates. Can also be a single ' date value, if that's what you want. ' Out: ' Return Value: ' The date of the working day lngDays from the start, taking ' into account weekends and holidays. ' Example: ' dhAddWorkDaysA(10, #2/9/2000#, Array(#2/16/2000#, #2/17/2000#)) ' returns #2/25/2000#, which is the date 10 work days ' after 2/9/2000, if you treat 2/16 and 2/17 as holidays ' (just made-up holidays, for example purposes only). ' Did the caller pass in a date? If not, use ' the current date. Dim lngCount As Long Dim dtmTemp As Date Dim adtmDates() As Variant 'loadup the adtmDates with all the records from the table tblNon_working_days Dim rst As DAO.Recordset Dim i As Long Set rst = DBEngine(0)(0).OpenRecordset("SELECT Date FROM tblNon_working_days", dbOpenForwardOnly) With rst If .RecordCount > 0 Then i = 1 Do Until .EOF ReDim Preserve adtmDates(i) adtmDates(i) = !Date .MoveNext i = i + 1 Loop End If End With rst.Close Set rst = Nothing If dtmDate = 0 Then dtmDate = Date End If dtmTemp = dtmDate For lngCount = 1 To lngDays dtmTemp = dhNextWorkdayA(dtmTemp, adtmDates) Next lngCount dhAddWorkDaysA = dtmTemp End Function Public Function dhNextWorkdayA( _ Optional dtmDate As Date = 0, _ Optional adtmDates As Variant = Empty) As Date ' Return the next working day after the specified date. ' Modified from code in ' "Visual Basic Language Developer's Handbook" ' by Ken Getz and Mike Gilbert ' Copyright 2000; Sybex, Inc. All rights reserved. ' Requires: ' SkipHolidays ' IsWeekend ' In: ' dtmDate: ' date on which to start looking. ' Use the current date, if none was specified. ' adtmDates (Optional): ' Array containing holiday dates. Can also be a single ' date value. ' Out: ' Return Value: ' The date of the next working day, taking ' into account weekends and holidays. ' Example: ' ' Find the next working date after 5/30/97 ' dtmDate = dhNextWorkdayA(#5/23/1997#, #5/26/97#) ' ' dtmDate should be 5/27/97, because 5/26/97 is Memorial day. ' Did the caller pass in a date? If not, use ' the current date. If dtmDate = 0 Then dtmDate = Date End If dhNextWorkdayA = SkipHolidaysA(adtmDates, dtmDate + 1, 1) End Function Public Function dhPreviousWorkdayA( _ Optional dtmDate As Date = 0, _ Optional adtmDates As Variant = Empty) As Date ' Return the previous working day before the specified date. ' Modified from code in ' "Visual Basic Language Developer's Handbook" ' by Ken Getz and Mike Gilbert ' Copyright 2000; Sybex, Inc. All rights reserved. ' Requires: ' SkipHolidays ' IsWeekend ' In: ' dtmDate: ' date on which to start looking. ' Use the current date, if none was specified. ' adtmDates (Optional): ' Array containing holiday dates. Can also be a single ' date value. ' Out: ' Return Value: ' The date of the previous working day, taking ' into account weekends and holidays. ' Example: ' ' Find the next working date before 1/1/2000 ' dtmDate = dhPreviousWorkdayA(#1/1/2000#, Array(#12/31/1999#, #1/1/2000#)) ' ' dtmDate should be 12/30/1999, because of the New Year's holidays. ' Did the caller pass in a date? If not, use ' the current date. If dtmDate = 0 Then dtmDate = Date End If dhPreviousWorkdayA = SkipHolidaysA(adtmDates, dtmDate - 1, -1) End Function Public Function dhFirstWorkdayInMonthA( _ Optional dtmDate As Date = 0, _ Optional adtmDates As Variant = Empty) As Date ' Return the first working day in the month specified. ' Modified from code in ' "Visual Basic Language Developer's Handbook" ' by Ken Getz and Mike Gilbert ' Copyright 2000; Sybex, Inc. All rights reserved. ' Requires: ' SkipHolidays ' IsWeekend ' In: ' dtmDate: ' date within the month of interest. ' Use the current date, if none was specified. ' adtmDates (Optional): ' Array containing holiday dates. Can also be a single ' date value. ' Out: ' Return Value: ' The date of the first working day in the month, taking ' into account weekends and holidays. ' Example: ' ' Find the first working day in 1999 ' dtmDate = dhFirstWorkdayInMonthA(#1/1/1999#, #1/1/1999#) Dim dtmTemp As Date ' Did the caller pass in a date? If not, use ' the current date. If dtmDate = 0 Then dtmDate = Date End If dtmTemp = DateSerial(Year(dtmDate), Month(dtmDate), 1) dhFirstWorkdayInMonthA = SkipHolidaysA(adtmDates, dtmTemp, 1) End Function Public Function dhLastWorkdayInMonthA( _ Optional dtmDate As Date = 0, _ Optional adtmDates As Variant = Empty) As Date ' Return the last working day in the month specified. ' Modified from code in ' "Visual Basic Language Developer's Handbook" ' by Ken Getz and Mike Gilbert ' Copyright 2000; Sybex, Inc. All rights reserved. ' Requires: ' SkipHolidays ' IsWeekend ' In: ' dtmDate: ' date within the month of interest. ' Use the current date, if none was specified. ' adtmDates (Optional): ' Array containing holiday dates. Can also be a single ' date value. ' Out: ' Return Value: ' The date of the last working day in the month, taking ' into account weekends and holidays. ' Example: ' ' Find the last working day in 1999 ' dtmDate = dhLastWorkdayInMonthA(#12/1/1999#, #12/31/1999#) Dim dtmTemp As Date ' Did the caller pass in a date? If not, use ' the current date. If dtmDate = 0 Then dtmDate = Date End If dtmTemp = DateSerial(Year(dtmDate), Month(dtmDate) + 1, 0) dhLastWorkdayInMonthA = SkipHolidaysA(adtmDates, dtmTemp, -1) End Function Public Function dhCountWorkdaysA(ByVal dtmStart As Date, ByVal dtmEnd As Date, _ Optional adtmDates As Variant = Empty) _ As Integer ' Count the business days (not counting weekends/holidays) in ' a given date range. ' Modified from code in ' "Visual Basic Language Developer's Handbook" ' by Ken Getz and Mike Gilbert ' Copyright 2000; Sybex, Inc. All rights reserved. ' Requires: ' SkipHolidays ' CountHolidays ' IsWeekend ' In: ' dtmStart: ' Date specifying the start of the range (inclusive) ' dtmEnd: ' Date specifying the end of the range (inclusive) ' (dates will be swapped if out of order) ' adtmDates (Optional): ' Array containing holiday dates. Can also be a single ' date value. ' Out: ' Return Value: ' Number of working days (not counting weekends and optionally, holidays) ' in the specified range. ' Example: ' Debug.Print dhCountWorkdaysA(#7/2/2000#, #7/5/2000#, _ ' Array(#1/1/2000#, #7/4/2000#)) ' ' returns 2, because 7/2/2000 is Sunday, 7/4/2000 is a holiday, ' leaving 7/3 and 7/5 as workdays. Dim intDays As Integer Dim dtmTemp As Date Dim intSubtract As Integer ' Swap the dates if necessary.> If dtmEnd dtmEnd Then ' Sorry, no Workdays to be had. Just return 0. dhCountWorkdaysA = 0 Else intDays = dtmEnd - dtmStart + 1 ' Subtract off weekend days. Do this by figuring out how ' many calendar weeks there are between the dates, and ' multiplying the difference by two (because there are two ' weekend days for each week). That is, if the difference ' is 0, the two days are in the same week. If the ' difference is 1, then we have two weekend days. intSubtract = (DateDiff("ww", dtmStart, dtmEnd) * 2) ' The answer to our quest is all the weekdays, minus any ' holidays found in the table. intSubtract = intSubtract + _ CountHolidaysA(adtmDates, dtmStart, dtmEnd) dhCountWorkdaysA = intDays - intSubtract End If End Function Private Function CountHolidaysA( _ adtmDates As Variant, _ dtmStart As Date, dtmEnd As Date) As Long ' Count holidays between two end dates. ' ' Modified from code in ' "Visual Basic Language Developer's Handbook" ' by Ken Getz and Mike Gilbert ' Copyright 2000; Sybex, Inc. All rights reserved. ' Required by: ' dhCountWorkdays ' Requires: ' IsWeekend Dim lngItem As Long Dim lngCount As Long Dim blnFound As Long Dim dtmTemp As Date On Error GoTo HandleErr lngCount = 0 Select Case VarType(adtmDates) Case vbArray + vbDate, vbArray + vbVariant ' You got an array of variants, or of dates. ' Loop through, looking for non-weekend values ' between the two endpoints. For lngItem = LBound(adtmDates) To UBound(adtmDates) dtmTemp = adtmDates(lngItem) If dtmTemp >= dtmStart And dtmTemp = dtmStart And adtmDates
