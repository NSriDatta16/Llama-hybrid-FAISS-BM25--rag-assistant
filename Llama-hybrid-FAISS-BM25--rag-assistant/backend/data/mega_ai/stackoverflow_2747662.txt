[site]: stackoverflow
[post_id]: 2747662
[parent_id]: 2747586
[tags]: 
The STL is a C++ specific library, so you cant directly get it across as one object to C#. The one thing that is guaranteed about std::vector is that &v[0] points to the first element and all the elements lie linearly in memory (in other words, its just like a C array in terms of memory layout) So marshal as array of int... which shouldn't be hard - There are lot of examples on the web. Added Assuming you only pass the data from C++ to C# : C# cannot handle a C++ vector object, so do not try passing it by reference : Instead your C++ code must return a pointer to an array of ints... If you are not going to be using this function from multiple threads, you can use static storage : int *getRects(bool bClear) { static vector v; // This variable persists across invocations if(bClear) { v.swap(vector ()); } else { v.clear(); // Fill v with data as you wish } return v.size() ? &v[0] : NULL; } call getRects(true) if the returned data is significant in size, so you release the memory in v. For simplicity, instead of passing out the size of the vector data too, just put a sentinel value at the end (like say -1) so the C# code can detect where the data ends.
