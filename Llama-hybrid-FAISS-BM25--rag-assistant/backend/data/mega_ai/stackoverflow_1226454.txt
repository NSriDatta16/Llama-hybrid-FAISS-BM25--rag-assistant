[site]: stackoverflow
[post_id]: 1226454
[parent_id]: 1226427
[tags]: 
Load the XAML dynamically by using the following code/process: System.Windows.Application.LoadComponent(this, new System.Uri("/SilverlightApplication1;component/MyPage.xaml", System.UriKind.Relative)); where "SilverlightApplication1" is the project name & "MyPage.xaml" is the XAML page you want to load dynamically. Then you have to do FindName() to get the inner controls: Grid LayoutRoot = ((Grid)(FindName("LayoutRoot"))); TextBlock testTextBlock = ((TextBlock)(FindName("testTextBlock"))); also see http://silverlight.net/learn/learnvideo.aspx?video=56933 EDIT: Expanded explaination First of all, the string containing the XAML fragment must contain only one root element. And that node must include a namespace reference to http://schemas.microsoft.com/client/2007 . If you forget to reference that namespace, you'll get a XamlParseException when you attempt to load the XAML. As an example, look at the following C# code which creates a TextBlock object: string xamlText=" "; TextBlock txt = System.Windows.Markup.XamlReader.Load(xamlText) as TextBlock; In this code, the XAML text fragment contains the necessary namespace reference and an attribute setting the Text property to "Hello world!" The XamlReader class in the System.Windows.Markup namespace is then used to load up the XAML text using the Load method which returns a System.Object. Since the root node of the XAML text was a TextBlock, the resultant object is actually an instance of the System.Windows.Controls.TextBlock type. So the cast to that type succeeds, yielding a disconnected TextBlock. I say that the new TextBlock is "disconnected" because just after it is created, it is not associated with any other UIElement. Controls are not really usable until they are connected to a canvas and ultimately to an application. Most XAML controls have a property called Children which is a UIElementCollection. That collection's Add method can be use to attach the new TextBlock and render it. Of course, casting the result of the Load method to a TextBlock isn't necessary. But to be attached via the UIElementCollection.Add method, you'll have to cast the Load result to the UIElement base class at a minimum.
