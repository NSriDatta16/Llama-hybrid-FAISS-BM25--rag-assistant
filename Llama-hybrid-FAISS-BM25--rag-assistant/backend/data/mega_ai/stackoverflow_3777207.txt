[site]: stackoverflow
[post_id]: 3777207
[parent_id]: 3776035
[tags]: 
As the people above have written, recursion is not always the optimal solution (function calls may be expensive and they consume the stack unless the compiler can optimize tail recursion away). However, it's particularly suited to such problems as yours. While theoretically it's possible to express each recursive algorithm in terms of iteration (ex. by manually simulating the call stack with an array), sometimes the equivalent iterative solution is less elegant. Here is a sample: text = 'carbon' n = len(text) for permutation_i in range(factorial(n)): free_letters = list(text) divisor = 1 for character_i in range(n, 0, -1): letter = free_letters.pop(permutation_i//divisor%character_i) print(letter, end='') divisor *= character_i print()
