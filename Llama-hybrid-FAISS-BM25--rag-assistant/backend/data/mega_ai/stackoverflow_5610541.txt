[site]: stackoverflow
[post_id]: 5610541
[parent_id]: 5610497
[tags]: 
There is no API mechanism that allows you to read the peer address of a potential connection before you accept(2) that connection. It doesn't exist at the sockets level, so it's not going to be in Python, either. If you want to build way too much knowledge of your operating environment into your application, you can always use libpcap or winpcap or similar tools to sniff the wire for incoming traffic, but (a) this requires elevated privileges, which is often a horrible idea (b) is really unrelated to most communication server tasks. What the tcp_wrappers mechanism does is accept(2) the incoming connection, call getpeername(2) on the socket, and then close(2) the socket if the program using the tcp_wrappers shouldn't be talking with that remote peer. (See /etc/hosts.allow , /etc/hosts.deny , and /etc/hosts.options , hosts.allow(5) manpage.) This might be rude to the clients, but the sysadmin decided to forbid talking with them anyway, so being friendly isn't a very high priority. So, is it acceptable to simply close(2) connections after you have already accept(2) ed the connection? If so, you can use socket.getpeername() to find the IP of the remote peer, do what you need, and then call socket.close() on the socket if you shouldn't have accepted the connection in the first place.
