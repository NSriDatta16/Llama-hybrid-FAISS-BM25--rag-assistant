[site]: stackoverflow
[post_id]: 5073048
[parent_id]: 5071335
[tags]: 
While vector<> is great for handling your data that you are sampling (because of its support for dynamically resizing underlying storage), you may find that straight C arrays are sufficient (even better) for data that is already stored. This does add a level of complexity but it avoids a copy for data arrays that are already of a known and static size. NSData's -bytes returns a pointer to the raw data within an NSData object. Core Data supports NSData as one its attribute types. If you know the size of each item in data, then you can use -length to calculate the number of elements, etc. On the sampling side, I would suggest using vector<> as you collect data and, intermittently, copy data to an NSData attribute and save. Note: I ran into a bit of problem with this approach ( Truncated Core Data NSData objects ) that I attribute to Core Data not recognizing changes made to NSData attribute when it is backed by an NSMutableData object and that mutable object's data is changed. As for MVC question. I would suggest that data (model) is managed in by Model. Views and Controllers can ask Model for data (or subsets of data) in order to display. But ownership of data is with the Model. In my case, which may be similar to yours, there were times when the Model returns abridged data sets (using Douglas-Peucker algorithm). The views and controllers were none the wiser that points were being dropped - even though their requests to the Model may have played in a role in that (graph scaling factors, etc.). Update Here is a snippet of code from my Data class which extends NSManagedObject. For a filesystem solution, NSFileHandle's -writeData: and methods for monitoring file offset might allow similar (better) management controls. // Exposed interface for adding data point to stored data - (void) addDatum:(double_t)datum { [self addToCache:datum]; } - (void) addToCache:(double_t)datum { if (cache == nil) { // This is temporary. Ideally, cache is separate from main store, but // is appended to main store periodically - and then cleared for reuse. cache = [NSMutableData dataWithData:[self dataSet]]; [cache retain]; } [cache appendBytes:&datum length:sizeof(double_t)]; // Periodic copying of cache to dataSet could happen here... } // Called at end of sampling. - (void) wrapup { [self setDataSet:[NSData dataWithData:cache]]; // force a copy to alert Core Data of change [cache release]; cache = nil; }
