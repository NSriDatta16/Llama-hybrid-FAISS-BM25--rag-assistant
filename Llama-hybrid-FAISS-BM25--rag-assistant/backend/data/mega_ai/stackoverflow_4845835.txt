[site]: stackoverflow
[post_id]: 4845835
[parent_id]: 4845644
[tags]: 
This is very subjective and each approach have its cons and pros. Returning NULL Good: Fast and straightforward Good: Probably the most natural thing to do Bad: Requires additional checking for not-NULL-ness Throwing an exception Good: Clearly communicates out about error Bad: Not the best way to provide feedback Bad: Usually very slow Returning empty instance (stub) Good: Fulfills the expectation for an object Good: Allows reusing returned object when not found Bad: Some programmers will go like "WTF?" Bad: Slower than returning NULL I personally tend to use approach #3. It has the advantage of being super strict with expectations set by method name: if it says it returns object of class Foo by primary key, than it should return that object no matter what - be it primary key not found, database down, or server on fire. It also allows using nice shortcuts and reuse of returned object (example in PHP): $foo = Foo::getByPrimaryKey(12345); if (!$foo->exists()) { // no need for checking for NULL $foo->name = 'bar'; $foo->colour = 'baz'; $foo->save(); // create it on the spot } echo $foo->name; // use it like it was always there Also, $foo->exists() is more conversational in style. One may downplay the importance of keeping the code close to natural language, or even call it childish. My take is that the farther you stay from manipulating ones, zeros, data types, exceptions, and all that computer related nonsense, the better for your program. As per your question in relation to rows count - keep it safe in the input, so you don't have to worry about it at point of retrieval. Use database constraints to make it impossible to enter duplicate rows. And again, keep it consistent with the promise you made by naming your method "getByPrimaryKey" - primary key by definition is unique, hence returning multiple rows/objects would be an offence to common sense.
