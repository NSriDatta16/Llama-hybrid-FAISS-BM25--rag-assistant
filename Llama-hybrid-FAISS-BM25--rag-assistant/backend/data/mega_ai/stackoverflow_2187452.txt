[site]: stackoverflow
[post_id]: 2187452
[parent_id]: 2186459
[tags]: 
If you're trying to debug a parser to troubleshoot, it's probably simpler to use error , Debug.Trace , or whatnot. On the other hand, if you need to terminate the parsing on some inputs as part of your actual program, but it's not doing so because of a try (...) construct, then you have a bug in your logic and you should stop and rethink your grammar, rather than hack around it with error handling. If you want the parser to terminate on a given input some of the time, but not others, then either something is missing from your input stream (and should be added) or a parser is not the solution to your problem. If you want the parser to recover gracefully from non-fatal errors and keep trying when possible, but terminate with an error when it can't continue, then you... may want to consider something other than Parsec, because it's really not designed for that. I believe Utrecht University's Haskell parser combinator library supports that sort of logic much more easily. Edit : As far as Parsec being itself an instance of MonadError goes--yes, and its own error handling subsumes that functionality. What you're trying to do is stack a second error monad on top of Parsec, and you're probably having trouble because it's generally awkward to distinguish between monad transformers that are "redundant" in that manner. Dealing with multiple State monads is more famously awkward, which is why Parsec (a State monad as well) provides functionality to hold custom state. In other words, Parsec being an error monad doesn't help you at all, and in fact is relevant mostly in the sense of making your problem more difficult.
