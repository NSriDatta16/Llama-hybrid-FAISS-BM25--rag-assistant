[site]: stackoverflow
[post_id]: 5382050
[parent_id]: 5031480
[tags]: 
I have come upon two solutions, one devised by someone I work with and then another more elegant solution by me! The first solution was to specify a class that extends MVcRouteHandler for the specified route. This route handler could examine the route in Form of the HttpContext , read the Form data and then update the RouteData in the RequestContext. MapRoute(routes, "Book", "{locale}/book", new { controller = "Reservation", action = "Index" }).RouteHandler = new ReservationRouteHandler(); The ReservationRouteHandler looks like this: public class ReservationRouteHandler: MvcRouteHandler { protected override IHttpHandler GetHttpHandler(RequestContext requestContext) { var request = requestContext.HttpContext.Request; // First attempt to match one of the posted tab types var action = ReservationNavigationHandler.GetActionFromPostData(request); requestContext.RouteData.Values["action"] = action.ActionName; requestContext.RouteData.Values["viewStage"] = action.ViewStage; return base.GetHttpHandler(requestContext); } The NavigationHandler actually does the job of looking in the form data but you get the idea. This solution works, however, it feels a bit clunky and from looking at the controller class you would never know this was happening and wouldn't realise why en-gb/book would point to different methods, not to mention that this doesn't really feel that reusable. A better solution is to have overloaded methods on the controller i.e. they are all called book in this case and then define your own custome ActionMethodSelectorAttribute. This is what the HttpPost Attribute derives from. public class FormPostFilterAttribute : ActionMethodSelectorAttribute { private readonly string _elementId; private readonly string _requiredValue; public FormPostFilterAttribute(string elementId, string requiredValue) { _elementId = elementId; _requiredValue = requiredValue; } public override bool IsValidForRequest(ControllerContext controllerContext, System.Reflection.MethodInfo methodInfo) { if (string.IsNullOrEmpty(controllerContext.HttpContext.Request.Form[_elementId])) { return false; } if (controllerContext.HttpContext.Request.Form[_elementId] != _requiredValue) { return false; } return true; } } MVC calls this class when it tries to resolve the correct action method on a controller given a URL. We then declare the action methods as follows: public ActionResult Book(HotelSummaryPostData hotelSummary) { return View("CustomerDetails"); } [FormFieldFilter("stepID", "1")] public ActionResult Book(YourDetailsPostData yourDetails, RequestedViewPostData requestedView) { return View(requestedView.RequestedView); } [FormFieldFilter("stepID", "2")] public ActionResult Book(RoomDetailsPostData roomDetails, RequestedViewPostData requestedView) { return View(requestedView.RequestedView); } [HttpGet] public ActionResult Book() { return View(); } We have to define the hidden field stepID on the different pages so that when the forms on these pages post back to the common URL the SelectorAttributes correctly determines which action method to invoke. I was suprised that it correctly selects an action method when an identically named method exists with not attribute set, but also glad. I haven't looked into whether you can stack these method selectors, i imagine that you can though which would make this a pretty damn cool feature in MVC. I hope this answer is of some use to somebody other than me. :)
