[site]: stackoverflow
[post_id]: 4250305
[parent_id]: 
[tags]: 
How are instances resolved when child containers are used?

in the code fragment below, we have a root container and one child container. The child container holds a registration for Person which depends on INameProvider , defined in the root container . INameProvider on its turn depends on IInfoProvider which has a registration in both containers. When the child container is asked to resolve an instance of Person , the mechanism uses the root container to resolve an instance of INameProvider (as expected), but also to resolve an instance of IInfoProvider . I would expect that the registration for IInfoProvider in the child container would override the one in the root container. WindsorContainer rootContainer = new WindsorContainer(); // register components for root container rootContainer.Register( Castle.MicroKernel.Registration.Component.For (). ImplementedBy (). LifeStyle.Transient); rootContainer.Register( Castle.MicroKernel.Registration.Component.For (). ImplementedBy (). LifeStyle.Transient); // create child container WindsorContainer childContainer = new WindsorContainer(); rootContainer.AddChildContainer(childContainer); // register components for child container childContainer.Register( Castle.MicroKernel.Registration.Component.For (). LifeStyle.Transient); childContainer.Register( Castle.MicroKernel.Registration.Component.For (). ImplementedBy (). LifeStyle.Transient); var person = childContainer.Resolve (); Debug.Assert(person.ToString() == "Jim"); // Moreover, if we use the child container to resolve an instance of INameProvider (as in the fragment below) the child container is used to get an instance of IInfoProvider . This is what I expect. var np = childContainer.Resolve (); np.ToString() // Can anybody explain why the first example uses the root container to resolve an IInfoProvider instead of the child container? Is there maybe a better pattern to handle various levels of component registration that can be overridden? Update #1 The actual situation we are dealing with is the following. We are developing a multi-tenant MVC web application where common application functionality is stored in the root container and every tenant has its own child container in which certain things are overridden. For example, the configuration for the datastore is stored in each child container (every tenant has its own database) and some MVC controllers are different. When a controller is created, we lookup the child container using Container.GetChildContainer and try to resolve the objects we need. Our controller has an indirect dependency on the data store configuration, but the one defined in the child container is never used.
