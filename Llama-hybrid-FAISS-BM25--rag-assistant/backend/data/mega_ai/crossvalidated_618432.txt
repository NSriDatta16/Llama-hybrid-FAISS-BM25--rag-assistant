[site]: crossvalidated
[post_id]: 618432
[parent_id]: 618380
[tags]: 
I am not familiar with the packages you're using, but I know that brms is capable of implementing non-linear models. See this vignette for a detailed explanation of the syntax and other considerations. If I understood your model correctly, this is how I would implement it: library(brms) library(gamlss) init Family: beta #> Links: mu = identity; phi = identity #> Formula: y ~ init * rate^x #> init ~ 1 #> rate ~ 1 #> Data: data (Number of observations: 60) #> Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1; #> total post-warmup draws = 4000 #> #> Population-Level Effects: #> Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS #> init_Intercept 0.73 0.02 0.68 0.77 1.00 2549 2669 #> rate_Intercept 0.68 0.01 0.65 0.71 1.00 2510 2618 #> #> Family Specific Parameters: #> Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS #> phi 26.72 4.90 18.03 36.89 1.00 2437 2549 #> #> Draws were sampled using sample(hmc). For each parameter, Bulk_ESS #> and Tail_ESS are effective sample size measures, and Rhat is the potential #> scale reduction factor on split chains (at convergence, Rhat = 1). Created on 2023-06-10 with reprex v2.0.2 The phi parameter shown in the summary is related to the sigma from gamlss::rBE as $\sigma = \phi^{-1/2}$ . So as you can see, all the parameters are recovered quite effectively. To be clear, this library uses Bayesian inference, hence the need to set priors. The choice I made here was just based on intuition, so you may want to be more careful there for your particular application. Also note that the CIs are credible intervals rather than frequentist confidence intervals, but you might be able to ignore the difference for practical purposes when you have enough data (see the Bernsteinâ€“von Mises theorem ).
