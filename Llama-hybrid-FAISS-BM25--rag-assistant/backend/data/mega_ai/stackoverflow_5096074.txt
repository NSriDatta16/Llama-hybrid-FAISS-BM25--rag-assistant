[site]: stackoverflow
[post_id]: 5096074
[parent_id]: 5095833
[tags]: 
Hogan already answered that you need to use join: For example like this: var daysForSymbolS1 = from s in database.Cast () join t in database.Cast () on s equals t.SymbolGlobal where (s.SymbolGlobal == "IBM" && t.Date == new DateTime(2010, 10, 20)) select new { s.SymbolGlobal, t.Date, t.Meta }; Now to the db4o-parts. You just can use the reference itself to do the join. You don't need any ID (as shown above) However there not the big issue. Currently the LINQ to db4o implementation doesn't support the LINQ-Operator at all (You can actually see that by using Go To Declaration on the join). This means it falls back to LINQ to Objects. That means that all objects are loaded into memory and then the LINQ to Object is executed on those objects. Thats extremely slow. Currently the query cannot be executed efficiently on db4o. The way you do such stuff usually with db4o is to have a Day-collection on a Symbol. That collection contains always all days of that symbol. Then you can query for the symbol and then get the data. Another method would be to split the query: var ibmSymbols = from Symbol s in database where s.SymbolGlobal == "IBM" select s; // run the TradingDay selection with the optimized LINQ to db4o implementation // do the rest with LINQ to objects var allSymbols = ibmSymbols.SelectMany(s => from TradingDay t in database where t.SymbolGlobal==s && t.Date == new DateTime(2010, 10, 20) select t); Edit: I just want to add the case when the Symbol has the TradingDays in a list other collection. Then you can do this: var ibmSymbols = from Symbol s in database where s.SymbolGlobal == "IBM" select s; var tradingDays = from symbol in ibmSymbols from day in symbol.TradingDays where day.Date == new DateTime(2010, 10, 20) select day;
