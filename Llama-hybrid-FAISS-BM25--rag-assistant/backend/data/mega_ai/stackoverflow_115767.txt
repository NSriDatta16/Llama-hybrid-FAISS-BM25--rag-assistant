[site]: stackoverflow
[post_id]: 115767
[parent_id]: 113385
[tags]: 
There's an elegant solution using templates. template class BaseTemplate {}; typedef BaseTemplate A; typedef BaseTemplate B; // A template<> class BaseTemplate { public: BaseTemplate() {} // A constructor B getB(); } // B template<> class BaseTemplate { public: BaseTemplate() {} // B constructor A getA(); } inline B A::getB() { return A(); } inline A B::getA() { return B(); } This code will work! So, why does it work? The reason has to do with how templates are compiled. Templates delay the creation of function signatures until you actually use the template somewhere. This means that neither getA() nor getB() will have their signatures analyzed until after both classes A and B have already been fully declared. That's the magic of this method.
