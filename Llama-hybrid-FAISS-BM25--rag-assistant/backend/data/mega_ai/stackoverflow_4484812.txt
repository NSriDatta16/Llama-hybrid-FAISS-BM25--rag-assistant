[site]: stackoverflow
[post_id]: 4484812
[parent_id]: 4483614
[tags]: 
I threw together an example, and only get a warning that nothing is known about A. The extension still builds fine and can call B's foo() without knowing about A's bar(). Here's my example generating a Python extension for Windows: Build output C:\example>nmake /las b.cpp a.cpp Generating Code... Creating library b.lib and object b.exp B.h(12) : Warning 401: Nothing known about base class 'A'. Ignored. b_wrap.cxx Creating library _b.lib and object _b.exp Example use Python 2.6.6 (r266:84297, Aug 24 2010, 18:46:32) [MSC v.1500 32 bit (Intel)] on win32 Type "help", "copyright", "credits" or "license" for more information. >>> import b >>> b.B().bar() In B::bar() >>> b.B().foo() Traceback (most recent call last): File " ", line 1, in File "b.py", line 73, in __getattr__ = lambda self, name: _swig_getattr(self, B, name) File "b.py", line 54, in _swig_getattr raise AttributeError(name) AttributeError: foo Files a.h #pragma once #ifdef DLL_EXPORTS #define DLL_API __declspec(dllexport) #else #define DLL_API __declspec(dllimport) #endif class DLL_API A { public: void foo(); }; b.h #pragma once #ifdef DLL_EXPORTS #define DLL_API __declspec(dllexport) #else #define DLL_API __declspec(dllimport) #endif #include "a.h" class DLL_API B : public A { public: void bar(); }; a.cpp #include #define DLL_EXPORTS #include "a.h" void A::foo() { printf("In A::foo()\n"); } b.cpp #include #define DLL_EXPORTS #include "b.h" void B::bar() { printf("In B::bar()\n"); } b.i %module b %begin %{ #pragma warning(disable:4100 4127 4706) %} %{ #include "B.h" %} %include %include "B.h" makefile _b.pyd: b.dll b_wrap.cxx cl /nologo /EHsc /LD /W4 b_wrap.cxx /I c:\Python26\include /Fe_b.pyd -link /nologo /libpath:c:\Python26\libs b.lib b_wrap.cxx: b.i swig -c++ -python b.i b.dll: a.cpp b.cpp cl /nologo /LD /W4 b.cpp a.cpp
