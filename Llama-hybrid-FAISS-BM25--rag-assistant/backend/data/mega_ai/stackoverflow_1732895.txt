[site]: stackoverflow
[post_id]: 1732895
[parent_id]: 
[tags]: 
error: ISO C++ forbids declaration of ‘iterator’ with no type

I am trying to build/run an old C++ system. I've already been able to built it in Ubuntu 9.10 with g++4.4 Now I'm trying to build in Ubuntu 8.04 with g++4.2. And I am getting the following errors: stringmap.h:353: erro: ISO C++ forbids declaration of ‘iterator’ with no type stringmap.h:353: erro: extra qualification ‘stringmap ::’ on member ‘iterator’ stringmap.h:353: erro: expected ‘;’ before ‘begin’ stringmap.h:354: erro: ISO C++ forbids declaration of ‘iterator’ with no type stringmap.h:354: erro: extra qualification ‘stringmap ::’ on member ‘iterator’ stringmap.h:354: erro: expected ‘;’ before ‘end’ stringmap.h:386: erro: no ‘typename stringmap ::iterator stringmap ::begin()’ member function declared in class ‘stringmap ’ stringmap.h:386: erro: template definition of non-template ‘typename stringmap ::iterator stringmap ::begin()’ stringmap.h:398: erro: no ‘typename stringmap ::iterator stringmap ::end()’ member function declared in class ‘stringmap ’ stringmap.h:398: erro: template definition of non-template ‘typename stringmap ::iterator stringmap ::end()’ In file included from Ccolumn.h:7, from Ccolumn.cpp:1: intmap.h:395: erro: ISO C++ forbids declaration of ‘iterator’ with no type intmap.h:395: erro: extra qualification ‘intmap ::’ on member ‘iterator’ intmap.h:395: erro: expected ‘;’ before ‘begin’ intmap.h:396: erro: ISO C++ forbids declaration of ‘iterator’ with no type intmap.h:396: erro: extra qualification ‘intmap ::’ on member ‘iterator’ intmap.h:396: erro: expected ‘;’ before ‘end’ intmap.h:429: erro: no ‘typename intmap ::iterator intmap ::begin()’ member function declared in class ‘intmap ’ intmap.h:429: erro: template definition of non-template ‘typename intmap ::iterator intmap ::begin()’ intmap.h:441: erro: no ‘typename intmap ::iterator intmap ::end()’ member function declared in class ‘intmap ’ intmap.h:441: erro: template definition of non-template ‘typename intmap ::iterator intmap ::end()’ Ccolumn.cpp: In static member function ‘static void Ccolumn::finish_vector_norm()’: Ccolumn.cpp:427: erro: ‘class intmap ’ has no member named ‘begin’ Ccolumn.cpp:427: erro: ‘class intmap ’ has no member named ‘end’ Ccolumn.cpp: In static member function ‘static void Ccolumn::updateCommonColumnNameList(std::string, int)’: Ccolumn.cpp:461: erro: ‘class intmap ’ has no member named ‘begin’ Ccolumn.cpp:461: erro: ‘class intmap ’ has no member named ‘end’ Both stringmap and intmap seems to be having the same problem. The lines the are giving the error are: stringmap ::iterator begin(); stringmap ::iterator end(); Here is the code for stringmap.h (its long): /****************************************************************************** A hashed associative array. This version is string-keyed. Features: - values are templated and hence generic - smart sizing and linear probing, based on optimal primes as described at http://planetmath.org/encyclopedia/GoodHashTablePrimes.html - comes with iterator - exists() and defined() calls, a-la perl - resizing, both upwards and downwards ******************************************************************************/ #ifndef _STRINGMAP_H__ #define _STRINGMAP_H__ #include #include #include #include #include "hash.h" using namespace std; // string key special values // #define VACATED "???" #define EMPTY "!!!" // the following expects a string argument x // #define OCCUPIED(x) ((x != EMPTY) && (x != VACATED)) // the stringmap class // template class stringmap { protected: vector _keys; vector _values; unsigned int probe; // linear probing increment unsigned int size; // array size allocated for storage unsigned int size_idx; // index of current size in hash primes table unsigned int minsize; // min and max array size unsigned int maxsize; unsigned int filled; // used cells in the array _Tp undef_val; // value of template type to return for undefined // index value. unsigned int total_lookups; unsigned int total_attempts; unsigned int hash_func( string ); // the hash function // hash table position getter (w/probing). _set = 1 if the goal is to // set a value (changes behavior for vacated tombstones). basically // all of this fanciness enables us to avoid scanning the entire table // when looking for a non-stored key. // unsigned int index_of( string _key, int _set); void grow(); // grow the table up to the next level void shrink(); // shrink the table down to the next level public: unsigned int index_of( string ); // this version assumes _set = 0 // an iterator // class iterator { protected: // container we are connected to stringmap * parent; int index; // index into the stringmap // increment index to next populated hash entry (or end) void increment() { if (!parent) return; if (index == parent->last_index()) index++; else for (string key = EMPTY; index last_index() && !OCCUPIED(key); ++index, key = parent->key_real(index)); } // decrement index to next populated hash entry (stops at begin) void decrement () { if (!parent) return; int i = index; for (string key = EMPTY; i > 0 && !OCCUPIED(key); --i, key = parent->key_real(i)); // only change index if stopping point is populated. if (OCCUPIED(key_real(i))) { index = i; } } public: // constructors iterator() : parent(NULL), index(0) {} iterator(int _index) : parent(NULL), index(_index) {} iterator(stringmap * _parent) : parent(_parent), index(0) {} iterator(stringmap * _parent, int _index) : parent(_parent), index(_index) {} // iterator scan operations void operator+=(int _n) { for (int i = 0; i ::iterator& a) { return index == a.index; } int operator!=(const stringmap ::iterator& a) { return index != a.index; } int operator ::iterator& a) { return index (const stringmap ::iterator& a) { return index > a.index; } int operator ::iterator& a) { return index =(const stringmap ::iterator& a) { return index >= a.index; } int operator==(int _index) { return index == _index; } int operator!=(int _index) { return index != _index; } int operator (int _index) { return index > _index; } int operator =(int _index) { return index >= _index; } // value reference (retrieve value from parent class at this pos) _Tp& operator*() { return parent->value_real(index); } // get the key of the current index (or EMPTY) string get_key() { string key = parent->key_real(index); if (OCCUPIED(key)) return key; return EMPTY; } // copy void operator=(const stringmap ::iterator& a) { index = a.index; parent = a.parent; } // misc void set_parent(stringmap * _parent) { parent = _parent; } }; /* iterator ENDS */ friend class iterator; // iterators can see our privates // copy constructor // stringmap(const stringmap & from) { _keys = from._keys; _values = from._values; probe = from.probe; size = from.size; size_idx = from.size_idx; minsize = from.minsize; maxsize = from.maxsize; filled = from.filled; undef_val = from.undef_val; // start efficiency off anew total_lookups = 0; total_attempts = 0; } // almost do-nothing constructor. just init to sane defaults. stringmap(_Tp _undef_val) : _keys(PRIMES[0], EMPTY), _values(PRIMES[0], _undef_val), size_idx(0), minsize(PRIMES[0]), maxsize(PRIMES[MAX_PRIME_IDX]), undef_val(_undef_val), filled(0), total_attempts(0), total_lookups(0) { // init size stuff // size = PRIMES[size_idx]; // initialize probe interval // probe = int(size/4) + 1; } // constructor without max or min size stringmap(int _startsize, _Tp _undef_val) : _keys(0, EMPTY), _values(0 , _undef_val), minsize(PRIMES[0]), maxsize(PRIMES[MAX_PRIME_IDX]), undef_val(_undef_val), filled(0) { // init size stuff // size_idx = nearest_prime_index(_startsize); size = PRIMES[size_idx]; // init vectors // _keys.resize(size, EMPTY); _values.resize(size, _undef_val); // initialize probe interval // probe = int(size/4) + 1; // init statistics stuff // total_attempts = 0; total_lookups = 0; } // full constructor stringmap(int _minsize, int _maxsize, int _startsize, _Tp _undef_val) : _keys(0, EMPTY), _values(0 , _undef_val), minsize(_minsize), maxsize(_maxsize), undef_val(_undef_val), filled(0) { // init size stuff // size_idx = nearest_prime_index(_startsize); size = PRIMES[size_idx]; // init vectors // _keys.resize(size, EMPTY); _values.resize(size, _undef_val); // initialize probe interval // probe = int(size/4) + 1; // init statistics stuff // total_attempts = 0; total_lookups = 0; } _Tp& get( string ); // get the value at a string key index _Tp& set( string, _Tp ); // set the value at a string key index // remove an element by its id, and return it (or undef) _Tp remove( string ); // remove an element pointed to by iterator. _Tp remove( stringmap ::iterator ); // remove an element given by real array location _Tp remove_real ( int ); // "real" array accessors for key and value. // string key_real( int idx ) { assert(idx = 0); return _keys[idx]; } _Tp& value_real( int idx ) { assert(idx = 0); return _values[idx]; } // see if a key exists // int exists( string key ) { return ( OCCUPIED(_keys[index_of(key)])); } // see if a value exists // int defined( string key ) { return (exists(key) && (_values[index_of(key)] != undef_val)); } // get the value at a string key index. actually, this gets a value // ref, and even more importantly, if you try to get a non-existant // location, it will be created and set to undef_val! this allows you to // do things like map[new_key] = blah instead of calling set() !! // _Tp& operator[]( string ); // takes key, returns template object type (ref) // the only thing "tricky" this has to do is copy the vectors. all other // variables carry straight over. stringmap & operator=(stringmap from) { _keys = from._keys; _values = from._values; probe = from.probe; size = from.size; size_idx = from.size_idx; minsize = from.minsize; maxsize = from.maxsize; filled = from.filled; undef_val = from.undef_val; // start efficiency off anew total_lookups = 0; total_attempts = 0; return *this; } // some useful accessors // int get_size() { return size; } int get_filled() { return filled; } // get the capacity of the underlying vectors // int get_capacity() { return _keys.capacity(); } // first and last occupied indices. the iterator makes use of this. // int first_index(); int last_index(); // see how efficient this stringmap is. optimal return value is 1. if you // have properly initialized the size, then you should get a value // somehere around 1.7. // float get_efficiency() { if (total_lookups) { return ((float)total_attempts/(float)total_lookups); } return 1; } /* iterator accessors */ stringmap ::iterator begin(); stringmap ::iterator end(); }; // find the first occupied index (or 0 if none) // template int stringmap ::first_index( ) { if (filled > 0) { for (int i = 0; i int stringmap ::last_index( ) { if (filled > 0) { for (int i = size - 1; i > 0; i--) if (OCCUPIED(_keys[i])) return i; } return 0; } // return a begin iterator // template typename stringmap ::iterator stringmap ::begin( ) { if (filled == 0) { return stringmap ::iterator(this, -1); } else { return stringmap ::iterator(this, first_index()); } } // return an end iterator // template typename stringmap ::iterator stringmap ::end( ) { if (filled == 0) { return stringmap ::iterator(this, -1); } else { return stringmap ::iterator(this, last_index() + 1); } } // the string hash function. stolen from Kevin's code. // template unsigned int stringmap ::hash_func( string k) { unsigned long h = 0; char const *p = k.c_str(); while( *p ) { h = (h > 24; h &= ~g; } return h % size; } // get the index of a key in the hash table, taking into account // collisions. performs linear probing. // template unsigned int stringmap ::index_of ( string _key ) { return index_of(_key, 0); // this is only a "get" lookup } // actual implementation of above, with the following addition: // if we are setting, we stop at vacated tombstones (-2) in addition to just // tombstones (-1) // template unsigned int stringmap ::index_of ( string _key, int set ) { // run the key through the hash function to get the starting index // unsigned int index = hash_func(_key); // increment while the current index is not free or does not have // the given key stored at it // int attempts = 1; // our chaining depends on whether or not we are seeking to add a new // element to the hash. // if (set) { int vacated = -1; while (_keys[index] != _key && _keys[index] != EMPTY && attempts _Tp& stringmap ::get ( string _key ) { unsigned int index = index_of(_key); return _values[index]; } // []-style get, which also does a set for accessing un-defined "indices" // template _Tp& stringmap ::operator[]( string _key ) { unsigned int index = index_of(_key); if (!OCCUPIED(_keys[index])) { // have to return this, as set could be setting at a different index // and we need a ref to the value at the correct index // return set(_key, undef_val); } return _values[index]; } // remove an entry from the hash vector // template _Tp stringmap ::remove ( string _key ) { unsigned int index = index_of(_key); return remove_real(index); } // remove an entry from the hash vector by table index, rather than key // template _Tp stringmap ::remove_real( int index ) { string key = _keys[index]; _Tp value = undef_val; // make sure something is here if (OCCUPIED(key)) { // grab the value value = _values[index]; // clear the spot // _values[index] = undef_val; _keys[index] = VACATED; // "vacated" tombstone // decrease filled count filled--; // check for table resize if (((float)filled/(float)size) _Tp& stringmap ::set ( string _key, _Tp _val ) { unsigned int index = index_of(_key, 1); string key = _keys[index]; // overwrite old value // _values[index] = _val; // if new spot, see if we should grow. (EMPTY or VACATED) // if ( !OCCUPIED(key) ) { // first mark this spot with our key _keys[index] = _key; // increase filled count filled++; // check for table resize // if (((float)filled/(float)size) > 0.75) { grow(); // calculate a new index for returning ref index = index_of(_key); } } return _values[index]; } // grow the hash vector // template void stringmap ::grow() { // do nothing if there is no larger prime // if (PRIMES[size_idx+1] == 0) return; unsigned int nextsize = PRIMES[size_idx+1]; // do nothing if we've hit our size limit if (nextsize > maxsize) return; // otherwise do the resize // size_idx++; unsigned int old_size = size; size = nextsize; // copy the old vectors // vector old_keys = _keys; vector old_values = _values; // resize keys and vals; set new half to defaults // _keys.resize(size, EMPTY); _values.resize(size, undef_val); // clear out old portion (~ 1st half) // unsigned int i; for (i = 0; i void stringmap ::shrink () { // do nothing if there is no smaller prime // if (size_idx == 0) return; unsigned int nextsize = PRIMES[size_idx-1]; // do nothing if we've hit our size limit if (nextsize old_keys = _keys; vector old_values = _values; // resize keys and vals // _keys.resize(size, EMPTY); _values.resize(size, undef_val); // set to defaults // unsigned int i; for (i = 0; i
