[site]: stackoverflow
[post_id]: 229695
[parent_id]: 229656
[tags]: 
To reason why this isn't appropriate, picture instead of an Enumerator , a List . Both use generics - the compiler doesn't handle either one in a special way in relation to generic arguments. void doStuff() { List list = getList(); list.add(new ChildThing2()); } List getList() { return new List (); //ERROR! } This first method is fine - a list of IParentThing s should be able to recieve a ChildThing2 . But a list of ChildThing1 s cannot handle a ChildThing2 , or indeed any implementor of IParentThing other than ChildThing1 - in other words, if the List&lt;ChildThing1> was allowed to cast as a List&lt;IParent> , it would have to be able to deal with all subclasses of IParentThing , not just IParentThing and ChildThing1 . Note that Java generics have a way to say that "I want a list of anything that inherits from this" in addition to "I want a list of anything that this inherits," which allows for more interesting (and in my opinion elegant) solutions to some problems.
