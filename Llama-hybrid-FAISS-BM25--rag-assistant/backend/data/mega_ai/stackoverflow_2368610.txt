[site]: stackoverflow
[post_id]: 2368610
[parent_id]: 2241759
[tags]: 
You're misunderstanding the purpose of mock objects. Mocks (in the Mockist sense) are used to test behavioral interactions with dependencies of the system under test. So, for instance, you might have something like this: interface IMailOrder { void OrderExplosives(); } class Coyote { public Coyote(IMailOrder mailOrder) {} public void CatchDinner() {} } Coyote depends on IMailOrder. In production code, an instance of Coyote would be passed an instance of Acme, which implements IMailOrder. (This might be done through manual Dependency Injection or via a DI framework.) You want to test method CatchDinner and verify that it calls OrderExplosives. To do so, you: Create a mock object that implements IMailOrder and create an instance of Coyote (the system under test) by passing the mock object to its constructor. (Arrange) Call CatchDinner. (Act) Ask the mock object to verify that a given expectation (OrderExplosives called) was met. (Assert) When you setup the expectations on the mock object may depend on your mocking (isolation) framework. If the class or method you're testing has no external dependencies, you don't need (or want) to use mock objects for that set of tests. It doesn't matter if the method is recursive or not. You generally want to test boundary conditions, so you might test a call that should not be recursive, a call with a single recursive call, and a deeply-recursive call. (miaubiz has a good point about recursion being an implementation detail, though.) EDIT: By "call" in the last paragraph I meant a call with parameters or object state that would trigger a given recursion depth. I'd also recommend reading The Art of Unit Testing . EDIT 2: Example test code using Moq : var mockMailOrder = new Mock (); var wily = new Coyote(mockMailOrder.Object); wily.CatchDinner(); mockMailOrder.Verify(x => x.OrderExplosives());
