[site]: stackoverflow
[post_id]: 3562886
[parent_id]: 
[tags]: 
What detectable differences are there between a class and its base-class?

Given the following template: template class wrapper : public T {}; What visible differences in interface or behaviour are there between an object of type Foo and an object of type wrapper ? I'm already aware of one: wrapper only has a nullary constructor, copy constructor and assignment operator (and it only has those if those operations are valid on Foo ). This difference may be mitigated by having a set of templated constructors in wrapper that pass values through to the T constructor. But I'm not sure what other detectable differences there might be, or if there are ways of hiding them. (Edit) Concrete Example Some people seem to be asking for some context for this question, so here's a (somewhat simplified) explanation of my situation. I frequently write code which has values which can be tuned to adjust the precise performance and operation of the system. I would like to have an easy (low code overhead) way of exposing such values through a config file or the user interface. I am currently writing a library to allow me to do this. The intended design allows usage something like this: class ComplexDataProcessor { hotvar epochs; hotvar learning_rate; public: ComplexDataProcessor(): epochs("Epochs", 50), learning_rate("LearningRate", 0.01) {} void process_some_data(const Data& data) { int n = *epochs; double alpha = *learning_rate; for (int i = 0; i a("FastLearner"); hotobject b("SlowLearner"); while (source.has_data()) { a.process_some_data(source.row()); b.process_some_data(source.row()); source.next_row(); } } When run, this would set up or read the following configuration values: FastLearner.Epochs FastLearner.LearningRate SlowLearner.Epochs SlowLearner.LearningRate This is made up code (as it happens my use case isn't even machine learning), but it shows a couple of important aspects of the design. Tweakable values are all named, and may be organised into a hierarchy. Values may be grouped by a couple of methods, but in the above example I just show one method: Wrapping an object in a hotobject class. In practice, the hotobject wrapper has a fairly simple job -- it has to push the object/group name onto a thread-local context stack, then allow the T object to be constructed (at which point the hotvar values are constructed and check the context stack to see what group they should be in), then pop the context stack. This is done as follows: struct hotobject_stack_helper { hotobject_stack_helper(const char* name) { // push onto the thread-local context stack } }; template struct hotobject : private hotobject_stack_helper, public T { hotobject(const char* name): hotobject_stack_helper(name) { // pop from the context stack } }; As far as I can tell, construction order in this scenario is quite well-defined: hotobject_stack_helper is constructed (pushing the name onto the context stack) T is constructed -- including constructing each of T 's members (the hotvars) The body of the hotobject constructor is run, which pops the context stack. So, I have working code to do this. There is however a question remaining, which is: What problems might I cause for myself further down the line by using this structure. That question largely reduces to the question that I'm actually asking: How will hotobject behave differently from T itself?
