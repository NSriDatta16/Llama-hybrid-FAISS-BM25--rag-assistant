[site]: stackoverflow
[post_id]: 4209334
[parent_id]: 4204378
[tags]: 
This can be accomplished with relatively simple code in a little more than O(n log n) time using a version of radix sort that performs a stable sort on each of the 7 important bits, from least significant to most significant. The advantage of this technique relative to a stable in-place merge-sort is that the code is much simpler if you are writing it all yourself. Here is the function to perform an in-place stable sort by one specified bit. Here, it is written recursively for simplicity using O(lg n) stack space (this stack space usage can be eliminated if you want by using a for loop to organize the divide and conquer approach): // sort array x from i to j by bit b sort(x, i, j, b) { if (i >= j - 1) return; mid = (i + j) / 2; sort(x, i, mid, b); sort(x, mid, j, b); first1 = -1; last0 = -1; for (k = i; k The function isSet tests whether a bit is set and reverse performs in-place array reversal. The above sorting subroutine is called on each bit as follows (as in radix sort): sort(x) { for (b = 1; b The total running time is "O(7 * n log n)". The extra factor of 7 could be variable if this algorithm were generalized.
