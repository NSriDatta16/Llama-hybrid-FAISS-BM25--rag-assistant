[site]: stackoverflow
[post_id]: 2697034
[parent_id]: 2696339
[tags]: 
Classes are designed with the intent of being extended or without the intent of being extended. If your class has no intent of being a parent it should be stated as final. A class designed to be extended has the responsibility to lay the framework from which the child will work from. Any methods that define the rules of the framework should be stated as final. This description is as vague as the question. I like the accounting example from Anurag and I wish to show how the correct usage. abstract class Account { // obtained by some magical source private $balance = 100.00; final public function getBalance() { return $this->balance; } final private function setBalance($new_balance) { $this->balance = $new_balance; } final public function debit(Amount $amount) { if ($this->canDebit($amount)) { $amount = $amount + $this->getDebitTransactionFee(); $this->setBalance($this->getBalance() - $amount); } } abstract protected function canDebit(); abstract protected function getDebitTransactionFee(); } final class CheckingAccount extends Account { final protected function canDebit() { return true; } final protected function getDebitTransactionFee() { // obtained by some magical source return 1.50; } } The responsibility of Account is to keep track of the balance, allow the public to debit, and allow the public to check the current balance. The responsibility of CheckingAccount is to answer if it can be debited and report on the respective transaction fee. Obviously the accounting here is extremely simplified. This example is one of likely infinite situations. Abstract classes are quite common for classes meant to be extended. Sometimes, however, a class can define its own non-final methods with a default function and have an operational instance. Of course, being non-final, these default methods are then free to be overridden by a child class.
