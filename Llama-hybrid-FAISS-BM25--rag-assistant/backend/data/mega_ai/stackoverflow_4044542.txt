[site]: stackoverflow
[post_id]: 4044542
[parent_id]: 4041939
[tags]: 
Initially I looked at the joinTable mapping to see if it would support a unique key, but it won't. The best solution I can think of is the following combination: Manually run the SQL statement to add the unique constraint. If you have some sort of database management tool (e.g. Liquibase), that would be the ideal place. Explicitly declare the association as a Set . This should avoid Hibernate ever running into the unique constraint, anyway. class Article { static hasMany = [tags: String] Set tags = new HashSet () } An alternate solution would be to explicitly declare your child domain ( Tag ) and set up a many-to-many relationship, adding the unique key to the join table there using constraints . But that's not really a great solution, either. Here's a primitive example: class Article { static hasMany = [articleTags: ArticleTag] } class Tag { static hasMany = [articleTags: ArticleTag] } class ArticleTag { Article article Tag tag static constraints = { tag(unique: article) } } With this, though, you have to explicitly manage the many-to-many relationship in your code. It's a bit inconvenient, but it gives you full control over the relationship as a whole. You can find out the nitty gritty details here (the Membership class in the linked example is akin to the ArticleTag in mine). Perhaps one of the gurus more familiar with GORM will chime in with a more elegant solution, but I can't find anything in the docs.
