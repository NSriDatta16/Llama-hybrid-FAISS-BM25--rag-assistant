[site]: stackoverflow
[post_id]: 5209230
[parent_id]: 2581817
[tags]: 
I was inspired by Daniel G. answer and implemented a very simple use case - in my work I often need to make repeated calls to the same (external) process with different arguments. I had hacked a way to determine when each specific call was done, but now I have a much cleaner way to issue callbacks. I like this implementation because it is very simple, yet it allows me to issue asynchronous calls to multiple processors (notice I use multiprocessing instead of threading ) and receive notification upon completion. I tested the sample program and works great. Please edit at will and provide feedback. import multiprocessing import subprocess class Process(object): """This class spawns a subprocess asynchronously and calls a `callback` upon completion; it is not meant to be instantiated directly (derived classes are called instead)""" def __call__(self, *args): # store the arguments for later retrieval self.args = args # define the target function to be called by # `multiprocessing.Process` def target(): cmd = [self.command] + [str(arg) for arg in self.args] process = subprocess.Popen(cmd) # the `multiprocessing.Process` process will wait until # the call to the `subprocess.Popen` object is completed process.wait() # upon completion, call `callback` return self.callback() mp_process = multiprocessing.Process(target=target) # this call issues the call to `target`, but returns immediately mp_process.start() return mp_process if __name__ == "__main__": def squeal(who): """this serves as the callback function; its argument is the instance of a subclass of Process making the call""" print "finished %s calling %s with arguments %s" % ( who.__class__.__name__, who.command, who.args) class Sleeper(Process): """Sample implementation of an asynchronous process - define the command name (available in the system path) and a callback function (previously defined)""" command = "./sleeper" callback = squeal # create an instance to Sleeper - this is the Process object that # can be called repeatedly in an asynchronous manner sleeper_run = Sleeper() # spawn three sleeper runs with different arguments sleeper_run(5) sleeper_run(2) sleeper_run(1) # the user should see the following message immediately (even # though the Sleeper calls are not done yet) print "program continued" Sample output: program continued finished Sleeper calling ./sleeper with arguments (1,) finished Sleeper calling ./sleeper with arguments (2,) finished Sleeper calling ./sleeper with arguments (5,) Below is the source code of sleeper.c - my sample "time consuming" external process #include #include int main(int argc, char *argv[]){ unsigned int t = atoi(argv[1]); sleep(t); return EXIT_SUCCESS; } compile as: gcc -o sleeper sleeper.c
