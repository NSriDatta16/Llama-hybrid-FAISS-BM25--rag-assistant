[site]: stackoverflow
[post_id]: 643029
[parent_id]: 642958
[tags]: 
What has worked well for me is large level grouping by type of code, but more macro-level than the logical units you were splitting up by. For instance, Engine - anything non visual. Support classes, base infrastructure code. Everything refers to this. EngineUI - Relies on Engine, and obviously used for UI, but nothing specific to any one app. EngineServer - Relies on engine, used by the (usually web) server build. AppCore - App specific core functionality, no UI. AppUI - App specific UI AppClient - Uses AppUI, AppCore, EngineUI, Engine. The actual client app. AppServer - Uses AppServer, EngineServer, Engine. The server app. Each project has a hierarchy of namespaces and once in a while I find its useful to fork out a large body of code into another assembly but usually these keep things reasonably organized and manageable, even when there are many hundreds of files involved. Too many projects is definitely something I try to avoid. One bonus of keeping these projects to a minimum is that it makes it a lot easier to actually reuse these libraries in subsequent projects (such as automated testing builds). I don't worry too much about unused code being deployed from these libraries because I can use a utility that strips out unused functions for the final build, keeping file size down to a minimum.
