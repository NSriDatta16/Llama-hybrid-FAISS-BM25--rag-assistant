[site]: stackoverflow
[post_id]: 2209169
[parent_id]: 
[tags]: 
Using Postgres in a web app: "transaction aborted" errors

Recently I moved a web app I'm developing from MySQL to PostgreSQL for performance reasons (I need functionality PostGIS provides). Now quite often encounter the following error: current transaction is aborted, commands ignored until end of transaction block The server application uses mod_python. The error occurs in the hailing function (i.e. the one that creates a new session for this specific client). Here goes the appropriate piece of code (the exception occurs on the line where sessionAppId is invoked: def hello(req): req.content_type = "text/json" req.headers_out.add('Cache-Control', "no-store, no-cache, must-revalidate") req.headers_out.add('Pragma', "no-cache") req.headers_out.add('Expires', "-1") instance = req.hostname.split(".")[0] cookieSecret = '....' # whatever :-) receivedCookies = Cookie.get_cookies(req, Cookie.SignedCookie, secret = cookieSecret) sessionList = receivedCookies.get('sessions', None) sessionId = str(uuid.uuid4()) if sessionList: if type(sessionList) is not Cookie.SignedCookie: return "{status: 'error', errno:1, errmsg:'Permission denied.'}" else: sessionList = sessionList.value.split(",") for x in sessionList[:]: revisionCookie = receivedCookies.get('rev_' + str(sessionAppId(x, instance)), None) # more processing here.... # ..... cursors[instance].execute("lock revision, app, timeout IN SHARE MODE") cursors[instance].execute("insert into app (type, active, active_revision, contents, z) values ('session', true, %s, %s, 0) returning id", (cRevision, sessionId)) sAppId = cursors[instance].fetchone()[0] cursors[instance].execute("insert into revision (app_id, type) values (%s, 'active')", (sAppId,)) cursors[instance].execute("insert into timeout (app_id, last_seen) values (%s, now())", (sAppId,)) connections[instance].commit() # ..... And here is sessionAppId itself: def sessionAppId(sessionId, instance): cursors[instance].execute("select id from app where type='session' and contents = %s", (sessionId, )) row = cursors[instance].fetchone() if row == None: return 0 else: return row[0] Some clarifications and additional questions: cursors[instance] and connections[instance] are the database connection and the cursor for the web app instance served on this domain name. I.e. the same server serves example1.com and example2.com, and uses these dictionaries to call the appropriate database depending on the server name the request came for. Do I really need to lock the tables in the hello() function? Most of the code in hello() is needed to maintain one separate session per browser tab. I couldn't find a way to do with cookies only, since browser tabs opening a website share the pool of cookies. Is there a better way to do it?
