[site]: stackoverflow
[post_id]: 228232
[parent_id]: 228134
[tags]: 
Doesn't it depend how you actually implement the inheritance in your system? For example, in a JavaScript version of what you describe, the prototype for AwesomeDragonImmuneToFire would normally be an instance of an AwesomeDragon , and since you'd always be working with instances, it wouldn't matter what you do to any particular AwesomeDragon : function Dragon() { this.position = "starting point"; } function AwesomeDragon() { this.awesome = true; } AwesomeDragon.prototype = new Dragon(); function AwesomeDragonImmuneToFire() { this.immuneToFire = true; } AwesomeDragonImmuneToFire.prototype = new AwesomeDragon(); >>> var awesome = new AwesomeDragon(); >>> var immune = new AwesomeDragonImmuneToFire(); >>> awesome.position = "flying above village"; >>> immune.position; "starting point" >>> immune.awesome true In this example, there are no classes and all instances are just instances of Object which happen to know which function was used to construct them. new is just a bit of syntactic sugar and using StudlyCaps for constructor functions is just a convention for functions which are intended to be used with new . The key thing is that each object has a chain of prototype objects, which is examined if you try to access an attribute which the object itself doesn't hold, as per Yegge's description of what the "Properties Pattern" is. https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Details_of_the_Object_Model
