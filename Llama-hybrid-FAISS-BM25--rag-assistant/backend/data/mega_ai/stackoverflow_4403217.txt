[site]: stackoverflow
[post_id]: 4403217
[parent_id]: 
[tags]: 
Another Fluent NH Joining question

I have a Site. this Site resides in a particular TimeZone and has a specified type of Internet connection. Both of these properties are stored in the Site table of the DB as foreign keys to records in a seperate lookup table. I would never have done it that way, but I understand why (enforces a common set of names, gives a SLIGHTLY smaller DB size, allows normalized additional information in some cases, and allows for easy retrieval of the list of values for use as a DDL). I'm building a mapping that must include retrieval of this information. I would like to avoid having to build a domain object and mapping for one field (which, in some cases other than the ID of the lookup table, that's all there is), so instead I'd like to denormalize the relationship and just have the string value on the object. Simple goal. The problem is that the Join I'm attempting to use assumes that the Site table's primary key is referenced somewhere on the lookup table; in effect, we're assuming the Site is on the "one" side of the relationship, which is inaccurate. Here are the relevant mapping lines: Id(x=>x.Id).Column("SiteID"); ... Join("lu_TimeZone", j => { j.KeyColumn("TimeZoneID"); j.Map(x => x.TimeZone).Column("TimeZone"); }); The SQL generated includes the join: FROM Site this_0_ inner join lu_TimeZone this_0_1_ on this_0_.SiteID=this_0_1_.TimeZoneID *buzzer* Sorry, that's incorrect, thanks for playing. The join should be: FROM Site this_0_ inner join lu_TimeZone this_0_1_ on this_0_.TimeZoneID=this_0_1_.TimeZoneID However there seems to be no way to tell Fluent to use the KeyColumn as the column name on both sides of the join. Reversing the mapping to join TimeZone to Site is infeasible as there are multiple joins from Site to other lookup tables.
