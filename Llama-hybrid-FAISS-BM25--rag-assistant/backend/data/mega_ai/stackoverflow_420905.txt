[site]: stackoverflow
[post_id]: 420905
[parent_id]: 420538
[tags]: 
If you're brave enough to take a big architectural shift you could consider CompositeWPF (previously codenamed Prism) from the Patterns & Practices guys at Microsoft. Of interest to you would be the ability to define "regions" in a shell (i.e. window) and then using views to fill the regions. It uses the Model-View-Presenter pattern to allow independent development of "views" from the model than can be easily be relocated over time as the shell only defines regions and is not coupled directly to what is placed in to it. Principally this helps decouple the shell from the views and the views from each other and make it easier to unit-test ... blah, blah blah. It is a big jump and something that will slow you down to begin with, although your situation is one of the types of applications that CompositeWPF is meant to address. As part of CompositeWPF you will need to take on board various patterns that can confuse newcomers, e.g. The UnityContainer, inversion-of-control, MVP (or Model/view/view-model) and dependency injection. I can remember when I first started with the sample apps being puzzled because it is not obvious how on earth the some of the views were even being created! The unity container will instantiate objects and call parameterised constructors magically. CompositeWPF is an elegant solution to your question but not a simple or straightforward one. Having used CompositeWPF in my last project I intend to use it again for the next appropriate application.
