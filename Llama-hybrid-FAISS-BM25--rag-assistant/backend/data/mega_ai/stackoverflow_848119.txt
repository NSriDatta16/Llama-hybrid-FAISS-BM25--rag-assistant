[site]: stackoverflow
[post_id]: 848119
[parent_id]: 848025
[tags]: 
Yes, there are faster ways to do this. Your simple loop spends most of the time in cache misses. This happends because you touch a lot of data at very different places in a tight loop. Even worse: Your memory locations are exactly a power of two apart. That's a size where the cache performs worst. You can improve this rotation algorithm if you improve the locality of your memory accesses. A simple way to do this would be to rotate each 8x8 pixel block on it's own using the same code you've used for your whole bitmap, and wrap another loop that splits the image rotation into chunks of 8x8 pixels each. E.g. something like this (not checked, and sorry for the C-code. My Delphi skills aren't up to date): // this is the outer-loop that breaks your image rotation // into chunks of 8x8 pixels each: for (int block_x = 0; block_x There are other ways as well. You could process the data in Hilbert-Order or Morton-Order. That would be in theory even a bit faster, but the code will be much more complex. Btw - Since you've mentioned that SSE is an option for you. Note that you can rotate a 8x8 byte block within the SSE-registers. It's a bit tricky to get it working, but looking at SSE matrix transpose code should get you started as it's the same thing. EDIT: Just checked: With a block-size of 8x8 pixels the code runs ca. 5 times faster on my machine. With a block-size of 16x16 it runs 10 times faster. Seems like it's a good idea to experiment with different block-sizes. Here is the (very simple) test-program I've used: #include #include char temp1[2048*2048]; char temp2[2048*2048]; void rotate1 (void) { int x,y; for (y=0; y
