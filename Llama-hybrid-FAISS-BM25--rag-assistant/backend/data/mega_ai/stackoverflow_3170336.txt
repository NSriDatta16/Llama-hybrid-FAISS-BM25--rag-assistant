[site]: stackoverflow
[post_id]: 3170336
[parent_id]: 3149209
[tags]: 
It depends what you looking to do with the return vale. If your going to bind it in the UI you can just rerun IEnumerable or IQueryable . If your going to use reflection on the return value just return type object If your using c# 4.0 you can return a dynamic type If your using EF or Linq to SQL to further join a query comprised of your anonymous type you can make a concrete class instead and use the concrete placeholder technique. For more details on this technique I can give some assistance. As others have mentioned though, you should really question whether returning an anonymous type form a method is the best way to solve the problem at hand. In general there is usually a better more pattern based approach that may require a bit more coding up front but may resulting in a more elegant design. This being said, I do believe there are legitimate cases such as with data binding where returning anonymous type instances can be perfectly acceptable. UPDATE : Just an interested tidbit I wanted to share in case those reading are not aware. Anonymous types are unique per their property names and types so lets say you have method A and method B in in both you create an anonymous type that has a single string typed property called Name by doing something like be code below. public object A() { return new { Name = "Cid" } } public object B() { return new { Name = "Galuf" } } public void Test() { System.Diagnostics.Trace.Assert(A().GetType() == B().GetType()); } Now even though this type is defined in two separate places the compiler only creates only creates a single shared type because they both have the same set of properties as defined by the property types and property names. In this respect the properties can be thought of as sort of a signature for the anonymous type. Using this knowledge there are different techniques that can be used for introspection into anonymous type instances that have been cast to object or deferred using the dynamic keyword. There are also nifty ways to work with anonymous types by using generic methods just as Linq does with methods in the static Enumerable and Queryable classes. This way you can do things like create a new instance of any given anonymous type and without using reflection. The trick is though that you have to use an instance of the anonymous type to pass to methods in order to have the type be inferred by the generic method. If anybody is interested in these topics further as they apply to the original posters question, leave a comment and I can try to clarify some of these techniques.
