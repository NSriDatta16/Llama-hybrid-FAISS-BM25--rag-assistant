[site]: stackoverflow
[post_id]: 2006249
[parent_id]: 1995329
[tags]: 
I think your find method is parameterized incorrectly. In particular, you almost certainly don't mean to use extends in the declaration R extends T . You seem to accept that with the wildcarded generic parameter , you are not going to be able to insert anything, because the compiler cannot assert that any particular object you pass in conforms to the bounds (with the single exception of the null literal). Remember that this is not because of any specials semantics of an insert-type method, but solely because of the interface. Your find method cannot be called for the exact same reason. Bear in mind that declaring and then declaring a parameter as type R , is exactly the same as declaring the parameter of type T . (Think about it the allowed values in both cases). And as you've seen above, no non-null objects can be accepted as an instance of T in your wildcarded case. I think you may have intended to write your find method as . In this case, the compiler can know for sure that no matter actual type of T is, it's Item or a subtype - and so Item or any of its superclasses (including Object) will always be valid for R and thus can be passed in. However, in this case, since Object is a valid substitution for the bounds, and all objects can be accepted for an Object parameter, this method is then equivalent to public int find(Object r) { return r.hashCode(); } This is fact is entirely the semantics you're trying to capture - you don't need the generic bounding as they don't provide any bounds. Typically it's only ever worth using super in generic bounds when it's a nested generic parameter, e.g. you're accepting a collection as a parameter that you want to add objects of type T to (in which case you'd want a Collection ). Alternatively, reading through your own answer to the question, my assessment in the above paragraph may be slightly incorrect. There are, then, three different restrictions you could try to apply to the type of the argument to the find method: Anything is allowed (i.e. Object ). The argument must be an instance of the highest possible bound for the contained types (so if Container is defined as Container , you declare the method to take a parameter of type Item ). The types must match exactly (i.e. T ). Generally speaking I would recommend to go as general as is possible - if you need to call methods that are defined in the Item class in order to test the match, then your hands are tied and you'll have to go with the second option. However, if you don't need to do this, then accept arguments of type Object to give callers the most flexibility. Along those lines, there is essentially no possible argument for ever taking option 3 - you won't get any extra functionality in your method (since you can't call any more specific methods than you could in the second case), and you're simply restricting clients. Consider the following: MyItem a = new MyItem(); Container c = new Container (); c.insert(a); // Much later, possibly passing through various layers of the stack/maps/etc. Item i = a; c.find(i); // Will not compile if the find method takes an argument of type T There is no benefit at all in forcing callers to downcast their Item reference to T specifically, when by definition you will be able to make the required method calls within find on an Item object, and can return an appropriate response based on the actual state of the object rather than the reference it is currently held in.
