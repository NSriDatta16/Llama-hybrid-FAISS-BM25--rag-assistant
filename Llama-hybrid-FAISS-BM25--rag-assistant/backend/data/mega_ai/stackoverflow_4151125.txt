[site]: stackoverflow
[post_id]: 4151125
[parent_id]: 4142536
[tags]: 
Basically don't. Forget about class hierarchies, storage models, and anything that is specific to your app and your particular app language. Unless you want to use the RDb as a mere storage location for your files, a dependent slave. If you want the power and flexibility (specifically extensibility) of the relational Database, then you need to model it independent of any app, and using RDb principles, not app language requirements. Leave your app context behind for a while and design the database as a database. Learn about them. Normalise (eliminate all duplication). Learn about the structures and rules, and implement them. When you do that, your queries and your "mapping", will be effortless. There will be no "impedance". Use the correct datatypes and there will be no mismatch. The structure you require is an ordinary subtype-supertype. Those are Relational Database terms that have been in existence for over 30 years in the RM, and over 23 years in Relational Database products. No need to call them funny new names. Wikipedia is not an academic reference. Given your tables, which are quite correct as a starting point (you've Normalised automatically), you need: Rename Card.Id as Card.CardId Remove the ids for the subtypes, they are 100% redundant; the CardId is both the PK and the FK. Add a discriminator Card.CardType CHAR(1) or TINYINT. This will identify which subtype to join with, when the CardType is not known. It appears you do not fully understand the concept of Foreign Keys, so that would be good to gear up on first. It is implemented here in its simple, ordinary form: ALTER TABLE MtgCard ADD CONSTRAINT Card_MtgCard_fk FOREIGN KEY (CardId) REFERENCES Card(CardId) The relation between Card and MtgCard or PokemonCard is always 1::1. The supertype is complete only when there is a Card plus { MtgCard | PokemonCard } with the same CardId. In your case there can be only one subtype, easy to enforce with a simple CHECK constraint. In other cases , more than one subtype is quite legal. The subtypes there are Person Is a Teacher or Person Is a Student In Relational Databases there is no concept of joining "from" or "to" (or up/down or left/right), those notions are only there to assist us humans; you can start with any table/key you have, and go to any table you need. The tables in-between are demanded only in the absence of Relational Identifiers (ie. where additional Surrogates, ID columns, are used as PKs instead of meaningful natural keys). In the example, using your terms, you can go straight from Enrollment to Person (eg, to grab the LastName) or to Course (to grab the Name) without having to visit the intermediate tables; the relation lines are solid. . Now, class hierarchies ("Is" or "Is a") and anything else, are simple and effortless. Quick Reference to Standard Relational Database Diagrams.
