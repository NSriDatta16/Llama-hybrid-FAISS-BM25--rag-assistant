[site]: stackoverflow
[post_id]: 2501677
[parent_id]: 2500851
[tags]: 
If I understand correctly, variables defined in a method are stored on the stack and are not affected by garbage collection. It depends on what you mean by "affected". The variables on the stack are the roots of the garbage collector, so they surely affect garbage collection. Since the location of t is on the stack, then that memory cannot be garbage collected or compacted and the reference variable in Increment() will always point to the proper contents of t. "Cannot" is a strange word to use here. The point of using the stack in the first place is because the stack is only used for data which never needs to be compacted and whose lifetime is always known so it never needs to be garbage collected. That why we use the stack in the first place. You seem to be putting the cart before the horse here. Let me repeat that to make sure it is clear: the reason we store this stuff on the stack is because it does not need to be collected or compacted because its lifetime is known. If its lifetime were not known then it would go on the heap. For example, local variables in iterator blocks go on the heap for that reason. Now, t is stored on the heap as it is a value of a specific instance of my class. Correct. Isn't this possibly a problem if I pass this value as a reference parameter? Nope. That's fine. If I pass t as a reference parameter, p will point to the current location of t. Yep. Though the way I prefer to think of it is that p is an alias for the variable t. However, if the garbage collector moves this object during a compact, won't that mess up the reference to t in Increment()? Nope. The garbage collector knows about managed references; that's why they're called managed references. If the gc moves the thing around, the managed reference is still valid. If you had passed an actual pointer to t using unsafe code then you would be required to pin the container of t in place so that the garbage collector would know to not move it. You can do that using the fixed statement in C#, or by creating a GCHandle to the object you want to pin. does the garbage collector update even references created by passing reference parameters? Yep. It would be rather fragile if it didn't. Do I have to worry about this at all? Nope. You're thinking about this like an unmanaged C++ programmer -- C++ makes you do this work, but C# does not. Remember, the whole point of the managed memory model is to free you from having to think about this stuff. Of course, if you enjoy worrying about this stuff you can always use the "unsafe" feature to turn these safety systems off, and then you can write heap and stack corrupting bugs to your heart's content.
