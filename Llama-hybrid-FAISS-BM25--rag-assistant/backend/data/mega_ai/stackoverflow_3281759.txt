[site]: stackoverflow
[post_id]: 3281759
[parent_id]: 2776381
[tags]: 
The term "operating system" when applied to a PC, normally refers to a modern "protected memory" operating system that provides not only a basic set of system services but also a complete user interface: the combination of a kernel, device drivers, and system services that provide memory protection, tasks that can not interfere with each other's memory, and threads which are units of execution within a process, as well as ways for threads and tasks to talk to each other and to access shared resources like file-systems that contain files, on storage devices like your PC's hard disk, are in fact, the core of the operating system. the "shell" on top of that operating system might be as simple as the "command.com" text command prompt on DOS (remember " C:> _ "?) or as complex as the Windows Shell, including its control panel, etc. Sometimes, a "linux distribution" contains far more than an operating system, but is informally referred to by a single name (such as Ubuntu) and so the line between what the operating system is (the linux kernel and standard libraries perhaps) and the applications that merely ship with that operating system (the Gnome and KDE environments on Linux) is pretty gray. A great way to learn what an operating system really is, is to read one of Tannenbaum's books on Operating Systems. I believe he shows the implementation in detail of his "minix" kernel. Another book is "Linux Kernel Internals". If you can handle the technical detail in this kind of book, then you can really understand what an operating system "kernel" is, and then begin to make sense of the layers around that kernel. I am not aware of one commercial or open source operating system that is written primarily in C++. Such system-level programming is most commonly carried out in a mix of pure ANSI C, and Assembly/Machine language. The low level assembly bits often are involved in tasks like handling interrupts, initializing hardware and booting the system up. Before you have a heap, and a stack, and a working virtual memory system, you wouldn't want to be using C++ objects, or even certain C features like malloc. Your resources and your design must be constrained by performance criteria, and any kind of extra overhead, even a semantic overhead, is to be deplored. Recently Linus Torvalds famously insulted C++ and described on a mailing list why he would never use it for a Linux kernel. I believe however, that C++ is making inroads in areas that have typically been havens of "pure C". The Gnu GCC team for example is willing to allow C++ into the GCC codebase now, at last.
