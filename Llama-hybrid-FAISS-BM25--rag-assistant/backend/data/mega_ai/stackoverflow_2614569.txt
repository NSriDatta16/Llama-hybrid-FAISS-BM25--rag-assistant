[site]: stackoverflow
[post_id]: 2614569
[parent_id]: 2613163
[tags]: 
Here's a sketch of how to improve on JÃ¼rgen's solution: it's just double-buffering, so while you are analyzing one file you have already started recording the next. My guess it that this trick will reduce gaps to the order of 100 milliseconds, but you would have to do some experiments to find out. Completely untested! #!/bin/bash record_interval=5 noise_threshold=3 storage_folder=~/recordings exec 2>/dev/null # no default error output function maybe_save { # out.wav date max_level="$(sox "$1" -n stats -s 16 2>&1| awk '/^Max\ level/ {print int($3)}')" if [ $max_level -gt $noise_threshold ]; then mv "$1" ${storage_folder}/recording-"$2" else rm "$1" fi } i=0 while true; do this=out$i.wav rec $this & pid=$? if [ $i -gt 9 ]; then i=0; else i=$(expr $i + 1); fi archive=$(date +%FT%T).wav; sleep $record_interval kill -TERM $pid maybe_save $this $archive & done The key is that the moment you kill the recording process, you launch analysis in the background and then take another trip around the loop to record the next fragment. Really you should launch the next recording process first, then the analysis, but that will make the control flow a bit uglier. I'd measure first to see what kinds of skips you're getting.
