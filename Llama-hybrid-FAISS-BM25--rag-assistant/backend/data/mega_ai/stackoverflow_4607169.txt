[site]: stackoverflow
[post_id]: 4607169
[parent_id]: 4606948
[tags]: 
Unfortunately, neither the DataSet nor the TextWriter/XmlWriter you can use with the WriteXml() method allow you to subscribe to any "ValueWritten" event, which would be the cleanest way to do it. If you ABSOLUTELY MUST HAVE a working progress bar that will show the user how much XML you've written, I would suggest you derive your own XmlWriter implementation that will expose and fire a subscribable event that you can use to bump your progress bar with each write. You can contain an XmlTextWriter in your implementation to actually do the writing (and I highly recommend doing so), but you cannot derive from XmlTextWriter directly. This is because the methods you will be extending from XmlTextWriter are not virtual, so you would have to hide XmlTextWriter's implementation with the new keyword. The DataSet.WriteXml(XmlWriter) overload will then treat your class as the base XmlWriter, so the methods you wrote that hide XmlTextWriter's implementations would be ignored. Other considerations you'll need to weigh: You won't know the exact size of the written file until your XmlWriter is told to Close() its stream by WriteXml(). Thus, each "bump" will need to be some sort of educated guess. If all your files are expected to be roughly the same size, you can come up with an average "chunk to percent" ratio that will become your "step". You can also try setting the progress percentage directly, moving the progress bar by some fixed percentage of the remaining progress on each read, which will move it asymptotically towards 100% but not reach it until your writer is closed (and fires an event saying you're done). As with all events, make sure you properly release all subscriptions to the event when either the publisher or subscriber is disposed. As with all UI elements, make sure you're not trying to call the handlers that work with the progress bar outside of the UI thread. This limits your multithreading options, as calling WriteXml from another thread will cause the handlers to be run in that thread. But, you must allow the UI thread some processor time to redraw the bar, so a flat single-threaded option won't work either. Consider using asychronous writes behind the scenes, and/or performing a Thread.Yield() after updating the progress bar. EDIT: Actually, because XmlWriter declares abstract methods which XmlTextWriter must implement, you CAN further override them in your custom class, so you can inherit directly from XmlTextWriter. Some sample code: public class ObservableXmlTextWriter: XmlTextWriter { public delegate void XmlWriteHandler(object sender, XmlWriteEventArgs e); public event XmlWriteHandler XmlWritten; public event EventHandler XmlWriteComplete; public class XmlWriteEventArgs:EventArgs { public object Value{get; private set;} public XmlWriteEventArgs(object value) {Value = value;} } public override WriteValue(string value) { base.WriteValue(value); if(XmlWritten != null) XmlWritten(this, new XmlWriteEventArgs(value)); } public override WriteValue(int value) { base.WriteValue(value); if(XmlWritten != null) XmlWritten(this, new XmlWriteEventArgs(value)); } ... //override ALL Write methods to fire XmlWritten as above //Dispose will call Close(), so just make sure to do one or the other public override Close() { base.Close(value); if(XmlWriteComplete!= null) XmlWriteComplete(this, new EventArgs())); } } ... public void XmlWriteHandler(object sender, XmlWriteEventArgs e) { //Feel free to come up with your own algorithm for approaching 100%; //the number of times this event fires will be proportional to the //number of data elements (rows * columns) in the DataSet. MyProgressBar.Increment((MyProgressBar.Maximum - MyProgressBar.Value) * .05) } public void XmlWriteCompleteHandler(object sender, EventArgs e) { MyProgressBar.Value = MyProgressBar.Maximum; }
