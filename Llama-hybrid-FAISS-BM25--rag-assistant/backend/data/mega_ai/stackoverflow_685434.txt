[site]: stackoverflow
[post_id]: 685434
[parent_id]: 
[tags]: 
Best way to set the selection of a flex control that hasn't initialized yet

To illustrate the Q. I'll really over-simplify the example (in reality the code is much more convoluted). Say you have a flex control, which underneath contains a datagrid. Something like Where document is a Model object, containing some data. You provide a selection setter on the control, as the clients don't want to know anything about the underlying datamodel : public function set selectedItem(title:String):Allocation { grid.selectedItem = null; for each(var o:Object in grid.dataProvider) { var t:String = o.@title; if( t == title ) { grid.selectedItem = o; return; } } } So far, so good. Provided document.items is prepopulated, the selection will work correctly. However. What to do if you already know, at the startup of the application, what the selection ought to be - it's been passed (for example) on the URL? So, in the flex you might have something like // Initialising now... mycontrol.document = this.document; // give the control the document // Fetch titles new FetchTitlesEvent().dispatch(); // cairngorm-style event // Set the selection mycontrol.selectedItem = Application.application.parameters.title; OOps . Because FetchTitlesEvent operates asynchronously, at the time mycontrol.selectedItem is unable to work. Somehow we need to (re)trigger that code to set the selection on the control. Now, there's several ways I can think to do this, but all have code smell stenches: 1) Do it in the FetchTitlesCommand, after the fetch has been completed - This pollutes the command with knowledge of the view (or view s ) that need to know this. Feels like a maintenance nightmare waiting to happen, and means the views are totally bound to commands, and those commands aren't re-usable. Blech. 2) Have a callback from the event when it's complete that does it (either make some composite command that starts in FetchTitlesEvent and ends in a new command to do the set). Seems fragile to me - how does the maintainer know which callbacks are neccesarily required? And it's still binding UI control knowledge into commands. Badness. 3) Have some kind of timer, waiting for the event queue to have been quiescent for a number of seconds. Hackity hackhack. 4) Do it in the control. Bind to the collectionevents in mycontrol on document.items, monitor for changes. Once the row arrives that matches the selection, select it, and stop monitoring for changes. - Control feels the right place to do it - collection events sometimes throw exciting CHANGE or REFRESH events though - seems an expensive monitor to have lying around I'm pretty much leaning to (4). Are there any other options that flex-ers have used before to trap this issue - particularly are there any codified into libraries that I might use, as it must be a fairly general-purpose problem?
