[site]: stackoverflow
[post_id]: 1395728
[parent_id]: 1395156
[tags]: 
You might want to change your getNumberInfo function to return a list rather than a vector, so that the values can have different types. As it is, they're all being cast to strings, which probably isn't what you want for logX . getNumberInfo 0) positivity = "Positive" else positivity = "NonPositive" if (positivity == "Positive") logX = log(x) else logX=NA list(evenness,positivity,logX) } Furthermore, you can use the names to a somewhat better effect so that you don't have to repeat them: getNumberInfo 0) "Positive" else "NonPositive", logX = if(x > 0) log(x) else NA) } Then the solution becomes simple: > cbind(myDF, t(sapply(myDF$Value, getNumberInfo))) Value evenness positivity logX 1 -2 Even NonPositive NA 2 -1 Odd NonPositive NA 3 0 Even NonPositive NA 4 1 Odd Positive 0 5 2 Even Positive 0.6931472 Finally, if you use ifelse (which can work on vectors) instead of if , it gets even simpler because you don't have to call apply : getNumberInfo 0, "Positive", "NonPositive"), logX = ifelse(x > 0, log(x), NA)) } > cbind(myDF, getNumberInfo(myDF$Value)) Value evenness positivity logX 1 -2 Even NonPositive NA 2 -1 Odd NonPositive NA 3 0 Even NonPositive NA 4 1 Odd Positive 0.0000000 5 2 Even Positive 0.6931472 That last solution emits a warning, because it's actually computing the log of every element, not just those with x>0 . Not sure the most elegant way to deal with that.
