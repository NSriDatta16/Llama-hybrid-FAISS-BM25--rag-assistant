[site]: stackoverflow
[post_id]: 4547203
[parent_id]: 4283933
[tags]: 
There are several ways you could tackle this but they're all ugly since unit tests are supposed to be isolated but files are all about durable changes. My unit tests don't run on a system with production data so it's been easy to simply reset the upload directory after each run with something like git reset --hard . This approach is in some ways the best simply because it involves no code changes and is guaranteed to work as long as you start with good test data. If you don't actually need to do anything with that file after testing your model's save method, I'd recommend using python's excellent Mock library to completely fake the File instance (i.e. something like mock_file = Mock(spec=django.core.files.File); mock_file.read.return_value = "fake file contents" ) so you can completely avoid changes to your file handling logic. The Mock library has a couple of ways to globally patch Django's File class within a test method which is about as easy as this will get. If you need to have a real file (i.e. for serving as part of a test, processing with an external script, etc.) you can use something similar to Mirko's example and create a File object after making sure it'll be stored somewhere appropriate - here are three ways to do that: Have your test settings.MEDIA_ROOT point to a temporary directory (see the Python tempfile module's mkdtemp function). This works fine as long as you have something like a separate STATIC_ROOT which you use for the media files which are part of your source code. Use a custom storage manager Set the file path manually on each File instance or have a custom upload_to function to point somewhere which your test setup/teardown process purges such as a test subdirectory under MEDIA_ROOT . Edit: mock object library is new in python version 3.3. For older python versions check Michael Foord's version
