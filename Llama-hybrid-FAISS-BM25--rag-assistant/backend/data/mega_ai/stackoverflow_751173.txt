[site]: stackoverflow
[post_id]: 751173
[parent_id]: 745850
[tags]: 
The rant, IMHO, is very misleading and it seems to me that the author does understand the finer details, it's just that he appears to want to mislead. IMHO, the key point that shows the flaw in argument is the following: void* operator new(std::size_t size, void* ptr) throw(); The standard defines that the above function has the following properties: Returns : ptr. Notes : Intentionally performs no other action. To restate that - this function intentionally performs no other action . This is very important, as it is the key to what placement new does: It is used to call the constructor for the object, and that's all it does. Notice explicitly that the size parameter is not even mentioned. For those without time, to summarise my point: everything that 'malloc' does in C can be done in C++ using "::operator new". The only difference is that if you have non aggregate types, ie. types that need to have their destructors and constructors called, then you need to call those constructor and destructors. Such types do not explicitly exist in C, and so using the argument that "malloc does it better" is not valid. If you have a struct in 'C' that has a special "initializeMe" function which must be called with a corresponding "destroyMe" then all points made by the author apply equally to that struct as they do to a non-aggregate C++ struct. Taking some of his points explicitly: To implement multiple inheritance, the compiler must actually change the values of pointers during some casts. It can't know which value you eventually want when converting to a void * ... Thus, no ordinary function can perform the role of malloc in C++--there is no suitable return type. This is not correct, again ::operator new performs the role of malloc : class A1 { }; class A2 { }; class B : public A1, public A2 { }; void foo () { void * v = ::operator new (sizeof (B)); B * b = new (v) B(); // Placement new calls the constructor for B. delete v; v = ::operator new (sizeof(int)); int * i = reinterpret_cast (v); delete v' } As I mention above, we need placement new to call the constructor for B. In the case of 'i' we can cast from void* to int* without a problem, although again using placement new would improve type checking. Another point he makes is about alignment requirements: Memory returned by new char[...] will not necessarily meet the alignment requirements of a struct intlist. The standard under 3.7.3.1/2 says: The pointer returned shall be suitably aligned so that it can be converted to a pointer of any complete object type and then used to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to a corresponding deallocation function). That to me appears pretty clear. Under specialized allocators the author describes potential problems that you might have, eg. you need to use the allocator as an argument to any types which allocate memory themselves and the constructed objects will need to have their destructors called explicitly. Again, how is this different to passing the allocator object through to an "initalizeMe" call for a C struct? Regarding calling the destructor, in C++ you can easily create a special kind of smart pointer, let's call it "placement_pointer" which we can define to call the destructor explicitly when it goes out of scope. As a result we could have: template class placement_pointer { // ... ~placement_pointer() { if (*count == 0) { m_b->~T(); } } // ... T * m_b; }; void f () { arena a; // ... foo *fp = new (a) foo; // must be destroyed // ... fp->~foo (); placement_pointer pfp = new (a) foo; // automatically !!destructed!! // ... } The last point I want to comment on is the following: g++ comes with a "placement" operator new[] defined as follows: inline void * operator new[](size_t, void *place) { return place; } As noted above, not just implemented this way - but it is required to be so by the standard. Let obj be a class with a destructor. Suppose you have sizeof (obj[10]) bytes of memory somewhere and would like to construct 10 objects of type obj at that location. (C++ defines sizeof (obj[10]) to be 10 * sizeof (obj).) Can you do so with this placement operator new[]? For example, the following code would seem to do so: obj * f () { void *p = special_malloc (sizeof (obj[10])); return new (p) obj[10]; // Serious trouble... } Unfortunately, this code is incorrect. In general, there is no guarantee that the size_t argument passed to operator new[] really corresponds to the size of the array being allocated. But as he highlights by supplying the definition, the size argument is not used in the allocation function. The allocation function does nothing - and so the only affect of the above placement expression is to call the constructor for the 10 array elements as you would expect. There are other issues with this code, but not the one the author listed.
