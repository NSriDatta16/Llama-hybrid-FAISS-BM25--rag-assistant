[site]: stackoverflow
[post_id]: 4839163
[parent_id]: 4837465
[tags]: 
Okay, so having thought about this a bit longer, I've got a suggestion that seems like it's too simple to be efficient... I'd appreciate some feedback on whether it seems sensible! 1) Since I can easily determine whether each ridge_t ridge segment at is connected to zero, one or two adjacent segments, I could colour each one appropriately ( LINE_NONE , LINE_END or LINE_MID ). This can easily be done in parallel, since there is no chance of a race condition. 2) Once colouring is complete: for each `LINE_END` ridge segment X found: traverse line until another `LINE_END` ridge segment Y found if X is earlier in memory than Y: change X to `LINE_START` else: change Y to `LINE_START` This is also free of race conditions, since even if two threads are simultaneously traversing the same line, they will make the same change. 3) Now every line in the image will have exactly one end flagged as LINE_START . The lines can be located and packed into a more convenient structure in a single thread, without having to do any look-ups to see if the line has already been visited. It's possible that I should consider whether statistics such as line length should be gathered in step 2), to help with the final re-packing... Are there any pitfalls that I've missed? Edit: The obvious problem is that I end up walking the lines twice, once to locate RIDGE_START s and once to do the final re-packing, leading to a computational inefficiency. It's still appears to be O(N) in terms of storage and computation time, though, which is a good sign...
