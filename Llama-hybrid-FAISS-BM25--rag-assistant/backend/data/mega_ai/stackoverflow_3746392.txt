[site]: stackoverflow
[post_id]: 3746392
[parent_id]: 
[tags]: 
How to change implementation of returned object base class's function when object is returned C++

I have an existing application in C++ with a custom ArrayBase class that manages storage and access to a contiguously allocated region of memory. I have a separate ItrBase class that is used to access data in that ArrayBase . ArrayBase has a createItr() function that currently returns an ItrBase object. I need to extend ArrayBase to use multiple memory allocations instead of one contiguous one. I have created an EnhancedArray class to do that. For this EnhancedArray to be compatible with the existing application, it's createItr() function must return something that works with the new multiple memory allocations. So, I have created a derived EnhanceItr class to do this. My problem is I can't figure out a way for hundreds of code occurrences like this: ItrBase anIterator = anArray.createItr(); ... double x = anIterator.getData(); to use the EhancedItr 's getData() function when anArray is an EnhancedArray . Here is a simple application illustrating my basic arrangement. #include using namespace std; class ItrBase { public: ItrBase() { cout Both calls to vfunc() above return 1, when I want the second call to return 0. In main() , I know that if I change the ItrBase types to ItrBase & 's, I do get the desired return types, but then I am modifying my 'existing' code in hundreds of areas, and the destructors for the Iterators are not called. Is there another strategy that I am not seeing? Thanks.
