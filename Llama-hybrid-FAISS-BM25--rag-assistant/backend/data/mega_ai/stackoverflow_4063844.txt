[site]: stackoverflow
[post_id]: 4063844
[parent_id]: 44101
[tags]: 
If you're talking about steganography , here's an old not too-fancy module I did for a friend once (Python 2.x code): the code from __future__ import division import math, os, array, random import itertools as it import Image as I import sys def encode(txtfn, imgfn): with open(txtfn, "rb") as ifp: txtdata= ifp.read() txtdata= txtdata.encode('zip') img= I.open(imgfn).convert("RGB") pixelcount= img.size[0]*img.size[1] ## sys.stderr.write("image %dx%d\n" % img.size) factor= len(txtdata) / pixelcount width= int(math.ceil(img.size[0]*factor**.5)) height= int(math.ceil(img.size[1]*factor**.5)) pixelcount= width * height if pixelcount >5, g & 0xfc |(c & 0x18)>>3, b & 0xf8 |(c & 0x07), ) for (r, g, b), c in it.izip(img.getdata(), txtarr)]) newimg.save(os.path.splitext(imgfn)[0]+'.png', optimize=1, compression=9) def decode(imgfn, txtfn): img= I.open(imgfn) with open(txtfn, 'wb') as ofp: arrdata= array.array('B', ((r & 0x7) the algorithm It stores a byte of data per image pixel using: the 3 least-significant bits of the blue band, the 2 LSB of the green one and the 3 LSB of the red one. encode function: An input text file is compressed by zlib, and the input image is resized (keeping proportions) to ensure that there are at least as many pixels as compressed bytes. A PNG image with the same name as the input image (so don't use a ".png" filename as input if you leave the code as-is :) is saved containing the steganographic data. decode function: The previously stored zlib-compressed data are extracted from the input image, and saved uncompressed under the provided filename. I verified the old code still runs, so here's an example image containing steganographic data: You'll notice that the noise added is barely visible.
