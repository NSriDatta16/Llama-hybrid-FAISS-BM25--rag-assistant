A* thus behaves in the same manner as A*, expanding the same nodes in the same order. Cost changes When the cost of an edge changes, LPA* examines all nodes affected by the change, i.e. all nodes at which one of the changed edges terminates (if an edge can be traversed in both directions and the change affects both directions, both nodes connected by the edge are examined): The rhs-values of the nodes are updated. Nodes which have become locally consistent are removed from the queue. Nodes which have become locally inconsistent are added to the queue. Nodes which remain locally inconsistent have their keys updated. After that, node expansion resumes until the end condition has been reached. Finding the shortest path Once node expansion has finished (i.e. the exit conditions are met), the shortest path is evaluated. If the cost for the goal equals infinity, there is no finite-cost path from start to goal. Otherwise, the shortest path can be determined by moving backwards: Start at the goal. Move to the predecessor n' of the current node n for which g(n' ) + d(n' , n) is lowest (if the lowest score is shared by multiple nodes, each is a valid solution and any of them can be chosen arbitrarily). Repeat the previous step until you have reached the start. Pseudocode This code assumes a priority queue queue, which supports the following operations: topKey() returns the (numerically) lowest priority of any node in the queue (or infinity if the queue is empty) pop() removes the node with the lowest priority from the queue and returns it insert(node, priority) inserts a node with a given priority into the queue remove(node) removes a node from the queue contains(node) returns true if the queue contains the specified node, false if not Properties Being algorithmically similar to A*, LPA* shares many of its properties. Each node is expanded (visited) at most twice for each run of LPA*. Locally overconsistent nodes are expanded at most once per LPA* run, thus its initial run (in which every node enters the overconsistent state) has similar performance to A*, which visits each node at most once. The keys of the nodes expanded for each run are monotonically nondecreasing over time, as is the case with A*. The more informed (and thus larger) the heuristics are (while still satisfying the admissibility criteria), the fewer nodes need to be expanded. The priority queue implementation has a significant impact on performance, as in A*. Using a Fibonacci heap can lead to a significant performance increase over less efficient implementations. For an A* implementation which breaks ties between two nodes with equal f-values in favor of the node with the smaller g-value (which is not well-defined in A*), the following statements are also true: The order in which locally overconsistent nodes are expanded is identical to A*. Of all locally overconsistent nodes, only those whose cost does not exceed that of the goal need to be expanded, as is the case in A*. LPA* additionally has the following properties: When edge costs change, LPA* outperforms A* (assuming the latter is run from scratch) as only a fraction of nodes need to be expanded again. Variants D* Lite, a reimplementation of the D* algorithm based on LPA* == References ==