[site]: stackoverflow
[post_id]: 5209603
[parent_id]: 5207506
[tags]: 
You could use following P/Invoke calls to achieve this. Below sample works only with Admin Rights [DllImport("wtsapi32.dll", SetLastError = true)] static extern bool WTSLogoffSession(IntPtr hServer, int SessionId, bool bWait); [DllImport("Wtsapi32.dll")] static extern bool WTSQuerySessionInformation( System.IntPtr hServer, int sessionId, WTS_INFO_CLASS wtsInfoClass, out System.IntPtr ppBuffer, out uint pBytesReturned); [DllImport("wtsapi32.dll", SetLastError = true)] static extern IntPtr WTSOpenServer([MarshalAs(UnmanagedType.LPStr)] String pServerName); [DllImport("wtsapi32.dll")] static extern void WTSCloseServer(IntPtr hServer); [DllImport("wtsapi32.dll", SetLastError = true)] static extern Int32 WTSEnumerateSessions(IntPtr hServer, [MarshalAs(UnmanagedType.U4)] Int32 Reserved, [MarshalAs(UnmanagedType.U4)] Int32 Version, ref IntPtr ppSessionInfo, [MarshalAs(UnmanagedType.U4)] ref Int32 pCount); [DllImport("wtsapi32.dll")] static extern void WTSFreeMemory(IntPtr pMemory); Here is a sample implementation to lookup all the users and their sessions, and then logging off one of the user. using System; using System.Collections.Generic; using System.Runtime.InteropServices; namespace ConsoleApplication1 { [StructLayout(LayoutKind.Sequential)] internal struct WTS_SESSION_INFO { public Int32 SessionID; [MarshalAs(UnmanagedType.LPStr)] public String pWinStationName; public WTS_CONNECTSTATE_CLASS State; } internal enum WTS_CONNECTSTATE_CLASS { WTSActive, WTSConnected, WTSConnectQuery, WTSShadow, WTSDisconnected, WTSIdle, WTSListen, WTSReset, WTSDown, WTSInit } internal enum WTS_INFO_CLASS { WTSInitialProgram, WTSApplicationName, WTSWorkingDirectory, WTSOEMId, WTSSessionId, WTSUserName, WTSWinStationName, WTSDomainName, WTSConnectState, WTSClientBuildNumber, WTSClientName, WTSClientDirectory, WTSClientProductId, WTSClientHardwareId, WTSClientAddress, WTSClientDisplay, WTSClientProtocolType, WTSIdleTime, WTSLogonTime, WTSIncomingBytes, WTSOutgoingBytes, WTSIncomingFrames, WTSOutgoingFrames, WTSClientInfo, WTSSessionInfo } class Program { [DllImport("wtsapi32.dll", SetLastError = true)] static extern bool WTSLogoffSession(IntPtr hServer, int SessionId, bool bWait); [DllImport("Wtsapi32.dll")] static extern bool WTSQuerySessionInformation( System.IntPtr hServer, int sessionId, WTS_INFO_CLASS wtsInfoClass, out System.IntPtr ppBuffer, out uint pBytesReturned); [DllImport("wtsapi32.dll", SetLastError = true)] static extern IntPtr WTSOpenServer([MarshalAs(UnmanagedType.LPStr)] String pServerName); [DllImport("wtsapi32.dll")] static extern void WTSCloseServer(IntPtr hServer); [DllImport("wtsapi32.dll", SetLastError = true)] static extern Int32 WTSEnumerateSessions(IntPtr hServer, [MarshalAs(UnmanagedType.U4)] Int32 Reserved, [MarshalAs(UnmanagedType.U4)] Int32 Version, ref IntPtr ppSessionInfo, [MarshalAs(UnmanagedType.U4)] ref Int32 pCount); [DllImport("wtsapi32.dll")] static extern void WTSFreeMemory(IntPtr pMemory); internal static List GetSessionIDs(IntPtr server) { List sessionIds = new List (); IntPtr buffer = IntPtr.Zero; int count = 0; int retval = WTSEnumerateSessions(server, 0, 1, ref buffer, ref count); int dataSize = Marshal.SizeOf(typeof(WTS_SESSION_INFO)); Int64 current = (int)buffer; if (retval != 0) { for (int i = 0; i sessions = GetSessionIDs(server); Dictionary userSessionDictionary = GetUserSessionDictionary(server, sessions); if (userSessionDictionary.ContainsKey(userName)) return WTSLogoffSession(server, userSessionDictionary[userName], true); else return false; } private static Dictionary GetUserSessionDictionary(IntPtr server, List sessions) { Dictionary userSession = new Dictionary (); foreach (var sessionId in sessions) { string uName = GetUserName(sessionId, server); if (!string.IsNullOrWhiteSpace(uName)) userSession.Add(uName, sessionId); } return userSession; } internal static string GetUserName(int sessionId, IntPtr server) { IntPtr buffer = IntPtr.Zero; uint count = 0; string userName = string.Empty; try { WTSQuerySessionInformation(server, sessionId, WTS_INFO_CLASS.WTSUserName, out buffer, out count); userName = Marshal.PtrToStringAnsi(buffer).ToUpper().Trim(); } finally { WTSFreeMemory(buffer); } return userName; } static void Main(string[] args) { string input = string.Empty; Console.Write("Enter ServerName :"); input = Console.ReadLine(); IntPtr server = WTSOpenServer(input.Trim()[0] == '0' ? Environment.MachineName : input.Trim()); try { do { Console.WriteLine("Please Enter L => list sessions, G => Logoff a user, END => exit."); input = Console.ReadLine(); if (string.IsNullOrWhiteSpace(input)) continue; else if (input.ToUpper().Trim()[0] == 'L') { Dictionary userSessionDict = GetUserSessionDictionary(server, GetSessionIDs(server)); foreach (var userSession in userSessionDict) { Console.WriteLine(string.Format("{0} is logged in {1} session", userSession.Key, userSession.Value)); } } else if (input.ToUpper().Trim()[0] == 'G') { Console.Write("Enter UserName:"); input = Console.ReadLine(); LogOffUser(input, server); } } while (input.ToUpper() != "END"); } finally { WTSCloseServer(server); } } } }
