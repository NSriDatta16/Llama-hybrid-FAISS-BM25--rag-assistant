[site]: stackoverflow
[post_id]: 4700702
[parent_id]: 4699942
[tags]: 
If you want to use the array as an array of UInt16 while in-memory, and then convert it to a packed byte array for storage, then you'll want a function to do one-shot conversion of the two array types. public byte[] PackUInt12(ushort[] input) { byte[] result = new byte[(input.Length * 3 + 1) / 2]; // the +1 leaves space if we have an odd number of UInt12s. It's the unused half byte at the end of the array. for(int i = 0; i > 8 | input[i * 2 + 1] > 4); } if(input.Length % 2 == 1) { result[i * 3 + 0] = (byte)input[i * 2 + 0]; result[i * 3 + 1] = (byte)(input[i * 2 + 0] >> 8); } return result; } public ushort[] UnpackUInt12(byte[] input) { ushort[] result = new ushort[input.Length * 2 / 3]; for(int i = 0; i > 4;) } if(result.Length % 2 == 1) { result[i * 2 + 0] = (ushort)(((ushort)input[i * 3 + 1]) If, however, you want to be efficient about memory usage while the application is running, and access this packed array as an array, then you'll want to have a class that returns ushort s, but stores them in byte[] . public class UInt12Array { // TODO: Constructors, etc. private byte[] storage; public ushort this[int index] { get { // TODO: throw exceptions if the index is off the array. int i = index * 2 / 3; if(index % 2 == 0) return (ushort)(((ushort)storage[i * 3 + 1]) > 4;) } set { // TODO: throw exceptions if the index is off the array. int i = index * 2 / 3; if(index % 2 == 0) storage[i * 3 + 0] = (byte)value; storage[i * 3 + 1] = (byte)(value >> 8 | storage[i * 3 + 1] & 0xF0); else storage[i * 3 + 1] = (byte)(storage[i * 3 + 1] & 0x0F | value > 4); } } }
