[site]: stackoverflow
[post_id]: 5154405
[parent_id]: 5152367
[tags]: 
I have had a look at the execution plans of similar queries in my own database and can see a difference but I cannot fully explain it; I just thought my findings might be useful. The difference seems to be due to the use of parameters on the compiled query. In the examples below I am using a table called [Resource] from a database I have, you will have to change the names for your queries. As you have found executing the query directly in management studio results in an index seek Using the version with parameters gives a scan If you fully prepare the statement and then pass it to the datbase, e.g. exec('select id from [Resource] where id in (1,5,7,9,10)') you get an index seek again What is interesting is to look at the cached plans SELECT cp.objtype,cp.usecounts,q.TEXT FROM sys.dm_exec_cached_plans cp cross apply sys.dm_exec_query_plan(cp.plan_handle) p cross apply sys.dm_exec_sql_text(cp.plan_handle) AS q WHERE cp.cacheobjtype = 'Compiled Plan' Which for the three statements executed I get objtype usecounts text ------- --------- ---- Adhoc 1 select id from [Resource] where id in (1,5,7,9,10) Prepared 1 (@p1 int, @p2 int, @p3 int, @p4 int, @p5 int)select id from [Resource] where id in (@p1, @p2, @p3, @p4, @p5) Adhoc 1 select id from [Resource] where id in (1,5,7,9,10) As you can see the SQL is quite different. Unfortunately that is as far as I can get to explain the difference in index selection you are seeing. Perhaps someone else can take this further? EDIT 1: I have read some more it comes down to the optimiser having to create a plan to satisfy all possible parameter values (as Kragen has said in his answer). I found the same information in this article: Dynamic Search Conditions in T-SQL EDIT 2: In response to Martin's comment, here is the execution plan of his SQL statement
