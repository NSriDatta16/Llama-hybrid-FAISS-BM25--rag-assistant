[site]: stackoverflow
[post_id]: 981420
[parent_id]: 981330
[tags]: 
Creating an instance of a run-time determined Type is easy, using Activator.CreateInstance , as others have mentioned. However, casting it, as you do in your example on the Marshal.PtrToStructure line is not possible, as the type has to be known at compile time for casting. Also, note that Activator.CreateInstance can not be used in conjunction with an IntPtr. If your types have a common base class (other than Object ), you can cast it to said base type and call functions on that. Otherwise, calling functions will only be possible using reflection. So either: static void castTest(myEnum val) { //Call a native function that returns a pointer to a structure IntPtr val = someNativeFunction(..params..); //determine the type of the structure based on the enum value Type structType = getTypeFromEnum(val); BaseClass myStruct = (BaseClass)Marshal.PtrToStructure(IntPtr, structType); myStruct.SomeFunctionDeclaredInBaseClass(); } Or: static void castTest(myEnum val) { //Call a native function that returns a pointer to a structure IntPtr val = someNativeFunction(..params..); //determine the type of the structure based on the enum value Type structType = getTypeFromEnum(val); object myStruct = Marshal.PtrToStructure(IntPtr, structType); MemberInfo[] function = FindMembers(MemberTypes.Method, BindingFlags.Public | BindingFlags.Instance, (MemberFilter)delegate(MemberInfo info, object filter) { return info.Name == filter.ToString(); }, "SomeFunction"); if (mi.Length > 0 && mi[0] is MethodInfo) ((MethodInfo)mi[0]).Invoke(myStruct, ..params..); }
