[site]: stackoverflow
[post_id]: 1627622
[parent_id]: 1627314
[tags]: 
The COBOL language was designed in the 1950s to match the capabilities of the slow, RAM-limited machines available at the time. Not to mention the lack of interactive terminals. Many aspects of the design are made to be easy to compile into straightforward machine code with no optimization needed. For instance, there are no variables. Only a single block of working storage, with names that refer to byte arrays of a specific fixed length starting at a fixed location. COBOL programs compile to efficient machine code by design. As CPUs got faster and RAM got more plentiful, COBOL compilers did add new features like key-indexed file I/O and built-in MERGE algorithm, and support for interactive text terminals. Noawadays there is even object-oriented COBOL. So part of the reason is that the code was portable to new CPU architectures since it was a high-level language, yet very efficient since it was designed to not use fancy features like those found in ALGOL-60, an ancestor of C. And part of the reason is that COBOL evolved to fit into newer OSes and capabilities. For instance, SQL databases are just more sophisticated forms of the simple table-oriented files that COBOL was designed to handle. Overlay linkers allowed huge COBOL programs to be written as long as the execution flow was roughly sequential. Any feature that was better done in Assembler or PL/1 or FORTRAN, could be accessed via PROCEDURE calls. The closest modern language to COBOL is Python, because you can write clean programs that almost read like English without extraneous punctuation everywhere, but you can leverage a large and sophisticated library of features rather than having to code your own all the time. Of course Python has adopted all of the features of ALGOL-60 and more, because it was designed in the modern era when you don't have to fit everything into 16k of RAM.
