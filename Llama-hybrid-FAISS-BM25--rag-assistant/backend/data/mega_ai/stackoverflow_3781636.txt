[site]: stackoverflow
[post_id]: 3781636
[parent_id]: 
[tags]: 
(Relatively) Size-Safe Wrapped STL Container in C++

Bear with me because I'm self taught in C++ and am spending my limited extra time on the job to try to learn more about it (I'm a chemical engineering researcher by day). I have a pretty simple objective: 1. Make a size-safe container to store a long list of floats. 2. Make a specialized version of that container that acts as a matrix. What I've come up with thus far, based on some feedback on various questions I've posed here is: template class VectorDeque { public: void resize_index(unsigned int index) { if ( my_container == VECTOR ) { try { my_vector.resize(index); my_container = VECTOR; } catch(std::bad_alloc &e) { my_deque.resize(index); my_container = DEQUE; } } else if ( my_container == DEQUE ) { my_deque.resize(index); } } T operator[](unsigned int index) { T ret_val; if ( STORAGE_CONTAINER == VECTOR ) { ret_val = my_vector[index]; } else if ( STORAGE_CONTAINER == DEQUE ) { ret_val = my_deque[index]; } } private: enum STORAGE_CONTAINER { NONE, DEQUE, VECTOR }; std::vector my_vector; std::deque my_deque; STORAGE_CONTAINER my_container; T& get(int index) { T temp_val; if(my_container == VECTOR) { temp_val = my_vector[index]; } else if(my_container == DEQUE) { temp_val = my_deque[index]; } return temp_val; } }; template class VectorDeque2D: public VectorDeque { public: template class VectorDeque2D_Inner_Set { VectorDeque2D& parent; int first_index; public: // Just init the temp object VectorDeque2D_Inner_Set(My2D& p, int first_Index) : parent(p), first_Index(first_index) {} // Here we get the value. T& operator[](int second_index) const { return parent.get(first_index,second_index);} }; // Return an object that defines its own operator[] that will access the data. // The temp object is very trivial and just allows access to the data via // operator[] VectorDeque2D_Inner_Set operator[](unsigned int first_index) { return VectorDeque2D_Inner_Set (*this, first_index); } void resize_index_second(unsigned int second_index) { if ( my_container == VECTOR ) { try { for (unsigned int couter=0;couter > my_vector; std::deque > my_deque; STORAGE_CONTAINER my_container; T& get(int first_index,int second_index) { T temp_val; if(my_container == VECTOR) { temp_val = my_vector[first_index][second_index]; } else if(my_container == DEQUE) { temp_val = my_deque[first_index][second_index]; } return temp_val; } }; With this implementation I tried to: 1. Present the user of the wrapper with two options for access (".get(x,y)" and "[x][y]") 2. Maximize reuse by having a based wrapped class and then inheriting it to make the matrix. 3. Solve the problem of transitioning from a vector to a deque if the continuous memory limit is hit. Does this seem like a decent solution? Suggestions?
