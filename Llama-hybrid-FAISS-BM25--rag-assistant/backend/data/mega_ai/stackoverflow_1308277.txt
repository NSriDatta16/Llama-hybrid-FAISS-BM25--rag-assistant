[site]: stackoverflow
[post_id]: 1308277
[parent_id]: 1302141
[tags]: 
I think you will find it difficult to ensure that the entire development team follows these guidelines accurately enough. Especially when the guidelines may be interpreted one way or another. Moreover, it will be a major pain if somebody improves a piece of code by adding tests and suddenly it has to move to a different project. More likely than not, such code will stay in the project it was originally placed into, and over time the maturity levels will become meaningless. One approach I saw working fine in a large company is this: All third party libraries are committed to a special directory and always include a version number. Our own common libraries are divided based on the references they have to other things. E.g. if the utility code references the Infragistics library then this bit of utility code goes into an InfragisticsUtils library. Our own common libraries that form clearly identifiable "units" go into separate libraries. For example, a library of code that deals with pricing securities is a separate project. All reusable code that doesn't satisfy any of the above goes into a catch-all Utilities project. Our own libraries are compiled and released to a shared location where projects can reference them. It is up to the projects' development team to decide whether they want to reference a compiled binary or just include the utility project into their solution. Obviously the quality of the code you find in the catch-all Utilities library can vary significantly. To alleviate this we simply ensured that two people from different development teams reviewed all checkins to Utilities . This weeds out a lot of stuff that has no place there!
