[site]: stackoverflow
[post_id]: 2581586
[parent_id]: 
[tags]: 
Making two Windows using CreateWindowsEx()

I have a windows form that has a simple menu and performs a simple operation, I want to be able to create another windows form with all the functionality of a menu bar, message pump etc.. as a separate thread so I can then share the results of the operation to the second window. I.E. 1) Form A opens Form B opens as a separate thread 2)Form A performs operation 3)Form A passes results via memory to Form B 4)Form B display results I'm confused as to how to go about it, the main app runs fine but i'm not sure how to add a second window if the first one already exists. I think that using CreateWindow will allow me to make another window but again i'm not sure how to access the message pump so I can respond to certain events like WM_CREATE on the second window. I hope it makes sense. Thanks! Edit: I've attempted to make a second window and although this does compile, no windows show atall on build. ////////////////////// // WINDOWS FUNCTION // ////////////////////// LRESULT CALLBACK WindowFunc(HWND hMainWindow, UINT message, WPARAM wParam, LPARAM lParam) { //Fields WCHAR buffer[256]; struct DiceData storage; HWND hwnd; // Act on current message switch(message) { case WM_CREATE: AddMenus(hMainWindow); hwnd = CreateWindowEx( 0, "ChildWClass", (LPCTSTR) NULL, WS_CHILD | WS_BORDER | WS_VISIBLE, 0, 0, 0, 0, hMainWindow, NULL, NULL, NULL); ShowWindow(hwnd, SW_SHOW); break; Any suggestions as to why this happens? Edit 2: This is everything there is, I've no idea if I'm implementing this right but I've tried to be consistent with the other window creation. ////////////////// // WINDOWS MAIN // ////////////////// int WINAPI WinMain(HINSTANCE hThisInst, HINSTANCE hPrevInst, LPSTR lpszArgs, int nWinMode) { // Declaration of window class (used to register program), // handle to window (returned by CreateWindow) // and windows message (holds messages received from windows) WNDCLASS wcl; WNDCLASS scl; HWND hwnd; MSG msg; // Name of window and window class LPCWSTR szWinName = L"DiceRoller - Producer"; LPCWSTR szClassName = L"DiceRollProd"; LPCWSTR szCWinName = L"Dice - Consumer"; LPCWSTR szCClassName = L"DiceRollCon"; // Set up the windows class struct wcl.hInstance = hThisInst; wcl.lpszClassName = szClassName; wcl.lpfnWndProc = WindowFunc; wcl.style = 0; wcl.hIcon = LoadIcon(NULL, IDI_APPLICATION); wcl.hCursor = LoadCursor(NULL, IDC_ARROW); wcl.lpszMenuName = NULL; wcl.cbClsExtra = 0; wcl.cbWndExtra = 0; wcl.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // Set up the windows class struct scl.hInstance = hThisInst; scl.lpszClassName = szCClassName; scl.lpfnWndProc = WindowFunc; scl.style = 0; scl.hIcon = LoadIcon(NULL, IDI_APPLICATION); scl.hCursor = LoadCursor(NULL, IDC_ARROW); scl.lpszMenuName = NULL; scl.cbClsExtra = 0; scl.cbWndExtra = 0; scl.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // Register the windows class if(!RegisterClass(&wcl)) { return 0; } if(!RegisterClass(&scl)) { return 0; } // Create the main window hwnd = CreateWindowEx(0, szClassName, szWinName, WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN, 100, 100, 400, 400, HWND_DESKTOP, NULL, hThisInst, NULL ); // Show the main window ShowWindow(hwnd, nWinMode); UpdateWindow(hwnd); // Main message processing loop while(GetMessage(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessage(&msg); } return (int)msg.wParam; } ////////////////////// // WINDOWS FUNCTION // ////////////////////// LRESULT CALLBACK WindowFunc(HWND hMainWindow, UINT message, WPARAM wParam, LPARAM lParam) { //Fields WCHAR buffer[256]; struct DiceData storage; HWND hwnd; // Act on current message switch(message) { case WM_CREATE: AddMenus(hMainWindow); hwnd = CreateWindowEx( 0, "ChildWClass", (LPCTSTR) NULL, WS_CHILD | WS_BORDER | WS_VISIBLE, CW_USEDEFAULT, // x location CW_USEDEFAULT, // y location 400, // width 300, // height hMainWindow, NULL, NULL, NULL); ShowWindow(hwnd, SW_SHOW); UpdateWindow(hwnd); break;
