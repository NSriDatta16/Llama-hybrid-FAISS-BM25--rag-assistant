[site]: stackoverflow
[post_id]: 1156685
[parent_id]: 1156608
[tags]: 
What I have see from quick look: Streams should be wrapped in using(...) pattern, in your case if exception occurs during processing, then Dispose() won't be called. using (FileStream fs = new FileStream(FilePath, FileMode.Open)) { // Another small optimization, removed unnecessary variable byte[] iba = new byte[(int)fs.Length]; fs.Read(iba, 0, iba.Length); } You should catch only exceptions you expect. For example in SerializeImage this will be IOException . Catching all exceptions is very bad practice. } catch (IOException ex) { Image.FromStream method depends on stream, so if you close underlying stream and return Image you can receive unpredictable behavior (well, in most cases this will work, but sometimes error occurs). So you need to create image copy and return it. using (MemoryStream ms = new MemoryStream(ImageByteArray)) { using (Image img = Image.FromStream(ms)) { return new Bitmap(img); } } You are not disposed tg graphics object and img object in SaveImage method (but disposed ImageObject, see next paragraph). And in general I do not see necessity in such logic, simply call ImageObject.Save(..., ImageFormat.Png) if you want to save image preserving quality. In the same method (SaveImage) you are disposed ImageObject parameter. This is also bad practice in most cases, consider disposing this image outside worker method by using using(...) pattern.
