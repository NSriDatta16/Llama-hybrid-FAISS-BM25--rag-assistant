[site]: stackoverflow
[post_id]: 3974096
[parent_id]: 3973881
[tags]: 
One of the core principles of Spring is dependency injection . Spring is based around a belief that injecting the components that a class uses into that class leads to easier-to-read, easier-to-test, and easier-to-maintain code over having classes/code (such as your get() method) responsible for finding their own dependencies. As an example of what this means in more concrete terms: your get() method depends on at least two other classes: 1) the "connection pool" and 2) the connection itself. The get() method has intimate knowledge of how it needs to obtain these instances. As an alternative to your style of coding here, with the DI approach the class that owns your get() method would have the Connection (or Datasource ) injected into it (via a setter or constructor injection). Now, why does this simple change make code easier and better? Because the get() method no longer needs to be concerned with details which are not it's core responsibility. The core responsibility of the get() method is to know how to get an Agent given an Integer id . Why does this method also need to know 1) where to get connections from and 2) that you want to pool connections? What happens when you want to change this connection logic? You need to touch the code of each and every data access method in your application. This would be a far, far harder change than it needs to be. This is the power of dependency injection: it allows you to change the details (such as where a JDBC connection comes from) without having to also change the code that happens to use these details. As for your actual connection pool code, it seems like you are misunderstanding two concepts: 1) Your ConnectionPool claims to want to be a Singleton but you expose a public constructor, allowing collaborators to completely default the purpose of having a single instance of ConnectionPool . 2) Your connection pool is not actually a pool of connections! The idea of a connection pool is to open up N connections to a database, and then hand out each of these N connections to code that needs a connection on-demand. The core idea here is that you can recycle connections and avoid the expensive costs of opening a new connection for each request. In a connection pool, when the code using a connection is done with it's connection, the physical connection is not actually terminated - instead, the connection handle is simply returned to the pool to be used again by another request/thread/method. Most importantly, in applications that use a connection pool the code responsible for data access typically doesn't even know it's connections are being pooled - instead, the DAO simply has a reference to a DataSource interface and the DAO has no idea what actually happens when it asks the DataSource for a connection or what happens when the connection is released. Thus, you can abstract away the details of "how do I connect" from the code responsible for higher-order logic such as "how do I get an Agent from this integer?". This abstraction is what allows you to change one layer of your application without rewriting all of the other layers - you've decoupled the layers and each is only concerned with what it is actually responsible for. I would strongly, strongly suggest you do some more reading on not just the idea of a connection pool but also Dependency Injection . Why in the world would you use Spring without the DI components? As for connection pools, why spend time re-inventing the wheel by writing your own instead of using a number of already-existing and popular libraries like commons-dbcp or c3p0 ? Instead of re-inventing the wheel, use an existing library (which is less likely to have bugs than your home-brewed solution) and focus on building your actual application.
