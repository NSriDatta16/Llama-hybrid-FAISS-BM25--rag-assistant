[site]: stackoverflow
[post_id]: 2471959
[parent_id]: 2471678
[tags]: 
You didn't say what language you're using, so here's some Python: >>> import re >>> REGEX = re.compile(r'(?:[^[(]+|\(([^)]*)\)|\[[^]]*])') >>> s="""My name is (Richard) and I cannot do [whatever (Jack) can't do] and (Robert) is the same way [unlike (Betty)] thanks (Jill)""" >>> filter(None, REGEX.findall(s)) The output is: ['Richard', 'Robert', 'Jill'] One caveat is that this does not work with arbitrary nesting. The only nesting it's really designed to work with is one level of parens in square brackets as mentioned in the question. Arbitrary nesting can't be done with just regular expressions. (This is a consequence of the pumping lemma for regular languages .) The regex looks for chunks of text without brackets or parens, chunks of text enclosed in parens, and chunks of text enclosed in brackets. Only text in parens (not in square brackets) is captured. Python's findall finds all matches of the regex in sequence. In some languages you may need to write a loop to repeatedly match. For non-paren matches, findall inserts an empty string in the result list, so the call to filter removes those.
