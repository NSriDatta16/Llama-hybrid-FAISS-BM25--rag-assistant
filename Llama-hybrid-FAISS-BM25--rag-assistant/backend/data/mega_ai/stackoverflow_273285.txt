[site]: stackoverflow
[post_id]: 273285
[parent_id]: 269989
[tags]: 
This: will set $matches to a node-set containing every node in $set1 whose text value starts with the text value of a node in $set2. That's what you're looking for, right? Edit: Well, I'm just wrong about this. Here's why. starts-with expects its two arguments to both be strings. If they're not, it will convert them to strings before evaluating the function. If you give it a node-set as one of its arguments, it uses the string value of the node-set, which is the text value of the first node in the set. So in the above, $set2 never gets searched; only the first node in the list ever gets examined, and so the predicate will only find nodes in $set1 that start with the value of the first node in $set2 . I was misled because this pattern (which I've been using a lot in the last few days) does work: But that predicate is using an comparison between node-sets, not between text values. The ideal way to do this would be by nesting predicates. That is, "I want to find every node in $set1 for which there's a node in $set2 whose value starts with..." and here's where XPath breaks down. Starts with what? What you'd like to write is something like: only there's no expression you can write for the ? that will return the node currently being tested by the outer predicate. (Unless I'm missing something blindingly obvious.) To get what you want, you have to test each node individually: That's not a very satisfying solution because it evaluates to a result tree fragment, not a node-set. You'll have to use an extension function (like msxsl:node-set ) to convert the RTF to a node-set if you want to use the variable in an XPath expression.
