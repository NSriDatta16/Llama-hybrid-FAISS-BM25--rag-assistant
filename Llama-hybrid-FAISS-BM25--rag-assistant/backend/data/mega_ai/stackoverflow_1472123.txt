[site]: stackoverflow
[post_id]: 1472123
[parent_id]: 
[tags]: 
Qt signals and slots, threads, app.exec(), and related queries

[related to this question ] I wrote this piece of code to understand how qt signals and slots work. I need someone to explain the behaviour, and to tell me if I'm right about my own conclusions. My program: connectionhandler.h #ifndef CONNECTIONHANDLER_H #define CONNECTIONHANDLER_H #include class ConnectionHandler : public QObject { Q_OBJECT public: ConnectionHandler(); public slots: void newConn(); private: QTcpServer *server; }; #endif // CONNECTIONHANDLER_H connectionhandler.cpp #include "connectionhandler.h" #include ConnectionHandler::ConnectionHandler() { server = new QTcpServer; server->listen(QHostAddress::LocalHost, 8080); QObject::connect(server, SIGNAL(newConnection()),this, SLOT(newConn())); } void ConnectionHandler::newConn() { QTextStream out(stdout); out main.cpp #include #include "connectionhandler.h" int main(int argc, char* argv[]) { QCoreApplication app(argc,argv); ConnectionHandler handler; return app.exec(); } Now, running this program sends it into an infinite loop looking for new connections. Observation: if I don't call app.exec() , the program returns immediately (as it should). Question: why? Question: if I had connected the slot as a queued connection, when would the slot invocation be performed? Question: if app.exec() is an infinite loop of sorts, how does the newConnection() signal ever get emitted? Big Question: Is their any "second thread" involved here? (I expect a no, and a stunningly elegant explanation :) ) Thanks, jrh PS: who else has this nested parenthesis syndrome? like "(.. :))" or "(.. (..))"?
