[site]: crossvalidated
[post_id]: 409590
[parent_id]: 
[tags]: 
training a nn with f1 as loss on keras doesn't work?

I have no problem to train my neural network with categorical_crossentropy as loss but when I do the same with f1, it just doesn't progress : Epoch 1/9 1029/1029 [==============================] - 4384s 4s/step - loss: 0.9470 - f1: 0.9470 Epoch 3/9 1029/1029 [==============================] - 1401s 1s/step - loss: 0.9413 - f1: 0.9413 - val_loss: 0.9938 - val_f1: 0.9938 Epoch 7/9 1029/1029 [==============================] - 1405s 1s/step - loss: 0.9270 - f1: 0.9270 - val_loss: 0.9932 - val_f1: 0.9932 Here's my implementation of f1: def f1(y_true, y_pred): def recall(y_true, y_pred): """Recall metric. Only computes a batch-wise average of recall. Computes the recall, a metric for multi-label classification of how many relevant items are selected. """ true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1))) possible_positives = K.sum(K.round(K.clip(y_true, 0, 1))) recall = true_positives / (possible_positives + K.epsilon()) return recall def precision(y_true, y_pred): """Precision metric. Only computes a batch-wise average of precision. Computes the precision, a metric for multi-label classification of how many selected items are relevant. """ true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1))) predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1))) precision = true_positives / (predicted_positives + K.epsilon()) return precision precision = precision(y_true, y_pred) recall = recall(y_true, y_pred) return 2*((precision*recall)/(precision+recall+K.epsilon())) Do you have an idea of what might be the problem ?
