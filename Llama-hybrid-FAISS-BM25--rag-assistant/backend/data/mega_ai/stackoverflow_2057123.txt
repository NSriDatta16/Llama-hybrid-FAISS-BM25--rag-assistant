[site]: stackoverflow
[post_id]: 2057123
[parent_id]: 
[tags]: 
Architectures - Domain Driven Design vs strict business logic enforcement

My business objects are coded with the following architecture: validation of any incoming data throws an exception in the setter if it doesn't fit business logic. property can not be corrupt/inconsistent state unless the existing default/null is invalid business objects can only be created by the business module via a static factory type method that accepts an interface implementation that is shared with the business object for copying into the business object. Enforces that the dependency container, ui, and persistence layers can not create an invalid Model object or pass it anywhere. This factory method catches all the different validation exceptions in a validation dictionary so that when the validation attempts are complete, the dictionary the caller provided is filled with field names and messages, and an exception is thrown if any of the validations did not pass. easily maps back to UI fields with appropriate error messages No database/persistence type methods are on the business objects needed persistence behaviors are defined via repository interfaces in the business module Sample Business object interface: public interface IAmARegistration { string Nbk { get; set; } //Primary key? string Name { get; set; } string Email { get; set; } string MailCode { get; set; } string TelephoneNumber { get; set; } int? OrganizationId { get; set; } int? OrganizationSponsorId { get; set; } } business object repository interface: /// /// Handles registration persistance or an in-memory repository for testing /// requires a business object instead of interface type to enforce validation /// public interface IAmARegistrationRepository { /// /// Checks if a registration record exists in the persistance mechanism /// /// Takes a bare NBK /// bool IsRegistered(string user); //Cache the result if so /// /// Returns null if none exist /// /// Takes a bare NBK /// IAmARegistration GetRegistration(string user); void EditRegistration(string user,ModelRegistration registration); void CreateRegistration(ModelRegistration registration); } Then an actual business object looks as follows: public class ModelRegistration : IAmARegistration//,IDataErrorInfo { internal ModelRegistration() { } public string Nbk { get { return _nbk; } set { if (String.IsNullOrEmpty(value)) throw new ArgumentException("Nbk is required"); _nbk = value; } } ... //other properties omitted public static ModelRegistration CreateModelAssessment(IValidationDictionary validation, IAmARegistration source) { var result = CopyData(() => new ModelRegistration(), source, false, null); //Any other complex validation goes here return result; } /// /// This is validated in a unit test to ensure accuracy and that it is not out of sync with /// the number of members the interface has /// public static Dictionary GenerateActionDictionary (T dest, IAmARegistration source, bool includeIdentifier) where T : IAmARegistration { var result = new Dictionary { {Member.Name (x=>x.Email), ()=>dest.Email=source.Email}, {Member.Name (x=>x.MailCode), ()=>dest.MailCode=source.MailCode}, {Member.Name (x=>x.Name), ()=>dest.Name=source.Name}, {Member.Name (x=>x.Nbk), ()=>dest.Nbk=source.Nbk}, {Member.Name (x=>x.OrganizationId), ()=>dest.OrganizationId=source.OrganizationId}, {Member.Name (x=>x.OrganizationSponsorId), ()=>dest.OrganizationSponsorId=source.OrganizationSponsorId}, {Member.Name (x=>x.TelephoneNumber), ()=>dest.TelephoneNumber=source.TelephoneNumber}, }; return result; } /// /// Designed for copying the model to the db persistence object or ui display object /// public static T CopyData (Func creator, IAmARegistration source, bool includeIdentifier, ICollection excludeList) where T : IAmARegistration { return CopyDictionary .CopyData( GenerateActionDictionary, creator, source, includeIdentifier, excludeList); } /// /// Designed for copying the ui to the model /// public static T CopyData (IValidationDictionary validation, Func creator, IAmARegistration source, bool includeIdentifier, ICollection excludeList) where T : IAmARegistration { return CopyDictionary .CopyData( GenerateActionDictionary, validation, creator, source, includeIdentifier, excludeList); } Sample repository method that I'm having trouble writing isolated tests for: public void CreateRegistration(ModelRegistration registration) { var dbRegistration = ModelRegistration.CopyData(()=>new Registration(), registration, false, null); using (var dc=new LQDev202DataContext()) { dc.Registrations.InsertOnSubmit(dbRegistration); dc.SubmitChanges(); } } Issues: When a new member is added there are a minimum of 8 places a change must be made (db, linq-to-sql designer, model Interface, model property, model copy dictionary, ui, ui DTO, unit test Testability testing the db methods that are hard coded to depend on an exact type that has no public default constructor, and needs to pass through another method, makes testing in isolation either impossible, or will need to intrude on the business object to make it more testable. Using InternalsVisibleTo so that the BusinessModel.Tests has access to the internal contructor, but I would need to add that for any other persistence layer testing module, making it scale very poorly to make the copy functionality generic the business objects were required to have public setters I'd prefer if the model objects were immutable DTOs are required for the UI to attempt any data validation I'm shooting for complete reusability of this business layer with other persistence mechanisms and ui mechanisms (windows forms, asp.net, asp.net mvc 1, etc...). Also that team members can develop against this business layer/architecture with a minimum of difficulty. Is there a way to enforce immutable validated model objects, or enforce that neither the ui or persistance layer can get a hold of an invalid one without these headaches?
