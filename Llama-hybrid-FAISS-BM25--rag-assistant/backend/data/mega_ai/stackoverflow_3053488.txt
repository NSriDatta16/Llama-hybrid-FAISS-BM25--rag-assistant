[site]: stackoverflow
[post_id]: 3053488
[parent_id]: 2730866
[tags]: 
According to git's Object Model if you only change the meta-data of a commit (i.e. commit message) but not the underlying data ("tree(s)") contained within it then it's Tree hash will remain unchanged. Aside from editing a commit message, you are also performing a rebase, which will change the Tree hashes of each commit in your history, because any changes pulled from origin/master will affect the files in your re-written history: which means some of the files (blobs) that your commit points to have changed. So there is no bullet-proof way to do what you want. That said, editing a commit with rebase -i does not usually alter the commit's timestamp and author, so you could use this to uniquely identify your commits before and after a rebase operation. You would have to write a script which records all the branch start-points against these "timestamp:author" identifier before doing a rebase, and then find the rewritten commits with the same "timestamp:author" ID and rebase the branch on it. Sadly, I don't have time to try writing this script myself now, so I can only wish you the best of luck! Edit : You can obtain the author email address and timestamp using: $ git log --graph --all --pretty=format:"%h %ae:%ci" * 53ca31a robert.meerman@gmail.com:2010-06-16 13:50:12 +0100 * 03dda75 robert.meerman@gmail.com:2010-06-16 13:50:11 +0100 | * a8bb03a robert.meerman@gmail.com:2010-06-16 13:49:46 +0100 | * b93e59d robert.meerman@gmail.com:2010-06-16 13:49:44 +0100 |/ * d4214a2 robert.meerman@gmail.com:2010-06-16 13:49:41 +0100 And you can obtain a list of branches for each of these based on their commit hash: $ git branch --contains 03dda75 * testbranch Watch out for multiple branches per commit, the common ancestor d4214a2 belongs to both branches!
