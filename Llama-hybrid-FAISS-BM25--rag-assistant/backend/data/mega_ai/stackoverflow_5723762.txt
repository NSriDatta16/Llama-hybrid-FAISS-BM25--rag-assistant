[site]: stackoverflow
[post_id]: 5723762
[parent_id]: 5017434
[tags]: 
To answer the question, JS is garbage collected, so there's no need to release memory. If you have a really gigantic string that you're only referencing from one place, setting that reference to null will release that string in the garbage collection pass. Since you asked about new String() specifically, it's worth mentioning that it's generally considered bad because of two problems: The string created can't be compared with the equals operator typeof yields 'object' instead of 'string' Here's some code you can run to see the behavior var a = new String('hello'), b = new String('hello'); var strA = String('hello'), strB = String('hello'); var literalA = 'hello', literalB = 'hello'; // Outputs false, because the string is wrapped by an object, // it's not the primitive console.log( a == b ); // Proof that it's not the primitive string, outputs 'object' console.log(typeof a); // Using String() and the literal yield consistent results console.log( strA == strB); //outputs true conole.log( literalA == literalB); // outputs true console.log( typeof strA); // outputs 'string' console.log( typeof literalA ); // outputs 'string' // You can compare literal and string from String(xxxx) console.log( strA == literalA) If you're stuck with a string that you don't know how it was created, you can always use valueOf() to compare them. That is console.log(a.valueOf() == b.valueOf()); // outputs true; To properly detect that an object is a string, you can check the constructor property. console.log(a.constructor == String); // outputs true Just beware that if you're working with frames, popups, iframes, there is a different String constructor for each window object, that is, // outputs false console.log( window.frames.frameA.String == window.frames.frameB.String)
