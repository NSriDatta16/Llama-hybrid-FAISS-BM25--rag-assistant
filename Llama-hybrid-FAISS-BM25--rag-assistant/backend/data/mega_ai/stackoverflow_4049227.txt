[site]: stackoverflow
[post_id]: 4049227
[parent_id]: 4048720
[tags]: 
As you've realized there are a variety of ways to accomplish your goal. While the MVC design pattern encourages certain application organizations how you organize your models, views and controllers is ultimately a matter of preference. Scott Allen discusses his preference for dealing with ASP.NET MVC drop down lists in a blog post. Scott uses an extension method to convert an enumerable of a complex type into an IEnumerable on his model. He then describes that upon post back ASP.NET MVC will not be returning the IEnumerable he sent to the view, but only the value the user selected. He then suggests that utilizing two models can simplify things. This is a reasonable description of what I refer to as ViewModels and FormModels. A ViewModel carries the display data to the view and a FormModel is used for carrying collected data back to a controller action. To explain further: ViewModels contain data that help render views. By organizing my ViewModels this way I can place all necessary information to render a particular view into an associated model. This prevents me from having to use ViewData for anything that's not truly temporary. FormModels are used to gather user input. FormModels (almost) never contain references to other complex types and are made up of primitives, DateTimes, and strings. In either case I have a hard rule to never reuse a model for a different view . Having your models closely aligned with the views used to render them makes your views easier to write. You don't have to worry about things like static methods because your models should be carrying data to their associated views in a form that is easy for them to render. Tools like AutoMapper can help "flatten" domain objects into models for display purposes. For additional reading checkout: ASP.NET MVC terminology is tripping me up - why 'ViewModel'?
