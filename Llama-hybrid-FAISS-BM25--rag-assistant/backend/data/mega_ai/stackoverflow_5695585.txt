[site]: stackoverflow
[post_id]: 5695585
[parent_id]: 5695548
[tags]: 
That code is equivalent (in almost every way) to: class dumb_array { public: // ... friend void swap(dumb_array& first, dumb_array& second); // ... }; inline void swap(dumb_array& first, dumb_array& second) // nothrow { using std::swap; swap(first.mSize, second.mSize); swap(first.mArray, second.mArray); } A friend function defined inside a class is: placed in the enclosing namespace automatically inline able to refer to static members of the class without further qualification The exact rules are in section [class.friend] (I quote paragraphs 6 and 7 of the C++0x draft): A function can be defined in a friend declaration of a class if and only if the class is a non-local class (9.8), the function name is unqualified, and the function has namespace scope. Such a function is implicitly inline. A friend function defined in a class is in the (lexical) scope of the class in which it is defined. A friend function defined outside the class is not.
