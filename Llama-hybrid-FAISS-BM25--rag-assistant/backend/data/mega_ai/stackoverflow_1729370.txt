[site]: stackoverflow
[post_id]: 1729370
[parent_id]: 
[tags]: 
C#: Range intersection when endpoints are null (infinity)

Ok, I have these intersection methods to work with ranges, and they work well as long as the range endpoints are not null: public static bool Intersects (this Range first, Range second, IComparer comparer) { return comparer.Compare(first.Start, second.End) = 0; } public static Range GetIntersectionWith (this Range first, Range second, IComparer comparer) { // Return null, if any range is null or if they don't intersect at all if (first == null || second == null || !Intersects(first, second, comparer)) return null; var start = comparer.Compare(first.Start, second.Start) 0 ? second.End : first.End; return Range.Create(start, end); } My problem now is that I would like them to support exactly that, null endpoints. A null endpoint would mean that the range goes to infinity in that direction. Two tests that I would like to pass, that doesn't, are for example these: [Test] public void Intersects_Intersecting_OneEndsWithNull() { var a = Range.Create("a", "k"); var b = Range.Create("c", null); Assert.That(a.Intersects(b), Is.True); Assert.That(b.Intersects(a), Is.True); } [Test] public void GetIntersectionWith_Intersecting_OneStartingAndOneEndingWithNull() { var a = Range.Create(null, "k"); var b = Range.Create("f", null); var expected = Range.Create("f", "k"); Assert.That(a.GetIntersectionWith(b), Is.EqualTo(expected)); Assert.That(b.GetIntersectionWith(a), Is.EqualTo(expected)); } The reason it doesn't work right away is that null is considered less than everything. But here null have to be sometimes considered to be greater than everything. Any idea how this may be solved in a good way? I'm thinking I will either have to check for null first and do something special or to make some sort of IComparer wrapper... but I am not able to figure out which or how they would have to work. Have to remember that it could be given any kind of comparer too, so technically the ranges could be in the opposite direction, as long as the given comparer takes that into account of course (In the real code I throw an exception if the start comes after the end according to the given comparer). Anyways, I'm a bit lost here :P
