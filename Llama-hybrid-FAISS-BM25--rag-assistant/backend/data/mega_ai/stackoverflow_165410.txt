[site]: stackoverflow
[post_id]: 165410
[parent_id]: 96196
[tags]: 
If you have a list of fields that get used for a bunch of things, e.g. defining a structure, serializing that structure to/from some binary format, doing database inserts, etc, then you can (recursively!) use the preprocessor to avoid ever repeating your field list. This is admittedly hideous. But maybe sometimes better than updating a long list of fields in multiple places? I've used this technique exactly once, and it was quite helpful that one time. Of course the same general idea is used extensively in languages with proper reflection -- just instrospect the class and operate on each field in turn. Doing it in the C preprocessor is fragile, illegible, and not always portable. So I mention it with some trepidation. Nonetheless, here it is... (EDIT: I see now that this is similar to what @Andrew Johnson said on 9/18; however the idea of recursively including the same file takes the idea a bit further.) // file foo.h, defines class Foo and various members on it without ever repeating the // list of fields. #if defined( FIELD_LIST ) // here's the actual list of fields in the class. If FIELD_LIST is defined, we're at // the 3rd level of inclusion and somebody wants to actually use the field list. In order // to do so, they will have defined the macros STRING and INT before including us. STRING( fooString ) INT( barInt ) #else // defined( FIELD_LIST ) #if !defined(FOO_H) #define FOO_H #define DEFINE_STRUCT // recursively include this same file to define class Foo #include "foo.h" #undef DEFINE_STRUCT #define DEFINE_CLEAR // recursively include this same file to define method Foo::clear #include "foo.h" #undef DEFINE_CLEAR // etc ... many more interesting examples like serialization #else // defined(FOO_H) // from here on, we know that FOO_H was defined, in other words we're at the second level of // recursive inclusion, and the file is being used to make some particular // use of the field list, for example defining the class or a single method of it #if defined( DEFINE_STRUCT ) #define STRING(a) std::string a; #define INT(a) long a; class Foo { public: #define FIELD_LIST // recursively include the same file (for the third time!) to get fields // This is going to translate into: // std::string fooString; // int barInt; #include "foo.h" #endif void clear(); }; #undef STRING #undef INT #endif // defined(DEFINE_STRUCT) #if defined( DEFINE_ZERO ) #define STRING(a) a = ""; #define INT(a) a = 0; #define FIELD_LIST void Foo::clear() { // recursively include the same file (for the third time!) to get fields. // This is going to translate into: // fooString=""; // barInt=0; #include "foo.h" #undef STRING #undef int } #endif // defined( DEFINE_ZERO ) // etc... #endif // end else clause for defined( FOO_H ) #endif // end else clause for defined( FIELD_LIST )
