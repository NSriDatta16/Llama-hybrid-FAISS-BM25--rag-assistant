[site]: stackoverflow
[post_id]: 5602229
[parent_id]: 
[tags]: 
Javascript library development scopes and namespaces

we currently learn some Javascript stuff in a course at the university. For that we implement a library for common tasks like show(), hide(), write and such things. Currently im running with an implementation like: var myLib_maker = function () { /* private scope */ var debuggingMode=true; var currentElement=null; /* end private scope */ return { getElement: function (id) { var o; if (typeof id === 'string') { o = document.getElementById(id); } if (!!(o && o.nodeType !== 1)) { throw { name: 'Type Error', message: 'Wrong node type at id: '+id } } currentElement=o; return this; }, getCurrentElement: function() { console.log(currentElement) return currentElement; }, isVisible: function () { return this.getCurrentElement().style.display.toLowerCase() === "block"; }, show: function () { this.debug("show "+this.getCurrentElement()) this.getCurrentElement().style.display = "block"; return this; }, hide: function () { this.debug("hide "+this.getCurrentElement()) this.getCurrentElement().style.display = "none"; return this; }, toggle: function() { this.debug("toggle "+this.getCurrentElement()) this.isVisible() ? this.hide(): this.show(); return this; }, write: function (content){ this.debug("write to"+this.getCurrentElement().id); var tg = this.getCurrentElement().tagName.toLowerCase(); if (tg === 'input' || tg === 'textarea') { currentElement.value = content; } else { currentElement.innerHTML = content; } return this }, debug: function (what) { if (debuggingMode===true){ console.log("[DEBUG] "+what); } return this; } }; } var myLib=myLib_maker(); Than I have an external function (for testing) to switch 2 textareas contents. function switchEditors(id1, id2){ c1=myLib.getElement(id1).getCurrentElement().value; c2=myLib.getElement(id2).getCurrentElement().value; myLib.getElement(id1).write(c2) myLib.getElement(id2).write(c1) } I first tried with the following code, which obviously does not work, cause I overwrite my private currentElement and so I write always to id2 function switchEditors(id1, id2){ tmp=myLib.getElement(id1).getCurrentElement().value myLib.getElement(id1).write(myLib.getElement(id2).getCurrentElement().value) myLib.getElement(id2).write(tmp) } But what I really wanted initially was not using a private currentElement variable. The first implementation of the write method extended the Element Object Element.prototype.write= function (content){ var tg = this.tagName.toLowerCase(); if (tg === 'input' || tg === 'textarea') { this.value = content; } else { this.innerHTML = content; } return this; } and such the getElement function returned document.getElementById(id) I want cascading (I hope this is the right word -> I mean the myLib.getElement("myid").show().hide() concatenation thing) and getting direct access to all Element attributes but we must not use global scope for our library, so I have to encapsulate my library in any way. So is there an elegant way to use the cascading thing and be able to get a direct access to all attributes on an element object without implementing each method within the global element scope? Or is my lib desing completely wrong and has to be done totally different. If so, just tell me, I appreciate any help. (I tried to figure out how jQuery actually implement these things, but didn't get a real clue how it is done ... too much code ... :) ) I hope I described my wishes and requirements. If not please ask for more specific details.
