[site]: stackoverflow
[post_id]: 5365235
[parent_id]: 
[tags]: 
Qt SQL Threaded Database Queries

I'm building a Qt based application to monitor and capture data streaming from a serial port. The data is plotted real-time, sent out via TCP, and stored into an SQLite database. Unfortunately, I've found that the SQLite insertions causes the GUI to become unresponsive, as I am performing serial data handling, plotting, TCP transmission, and database insertion all in the context of the main loop. I researched seperating the database insertions onto another thread and came up with the following code. #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include "mMessage.h" // The class that does all the work with the database. This class will // be instantiated in the thread object's run() method. class Worker : public QObject { Q_OBJECT public: Worker( QObject* parent = 0); ~Worker(); bool insertADC(mMessage* insertMessage); public slots: void slotExecute( mMessage* insertMessage ); signals: void queryResult(bool); private: QSqlDatabase m_database; bool m_databaseOpen; void prepareQueries(); QSqlQuery *m_accelerometerQuery; QSqlQuery *m_adcQuery; QSqlQuery *m_metricsQuery; QSqlQuery *m_rssiQuery; }; class mDatabaseThread : public QThread { Q_OBJECT public: mDatabaseThread(QObject *parent = 0); ~mDatabaseThread(); void executeInsertion( mMessage* insertMessage ); signals: void progress( const QString& msg ); void ready(bool); protected: void run(); signals: void executefwd( mMessage* insertMessage ); private: Worker* m_worker; }; CPP FILE #include "mDatabaseThread.h" // Worker::Worker( QObject* parent ) : QObject( parent ) { // thread-specific connection, see db.h m_database = QSqlDatabase::addDatabase( "QSQLITE", "WorkerDatabase" ); // named connection m_database.setDatabaseName("trainingX.db3"); if ( !m_database.open() ) { qWarning() prepare("INSERT INTO accelerometer (key, timestamp, nickname, unitid," "sectorid, acc_x, acc_y, acc_z) " "VALUES (NULL, :timestamp, :nickname, :unitid, :sectorid," ":acc_x, :acc_y, :acc_z)"); m_adcQuery->prepare("INSERT INTO adc (key, timestamp, nickname, unitid, sectorid," "adc0, adc1, adc2, adc3, adc4, adc5, adc6, adc7) " "VALUES (NULL, :timestamp, :nickname, :unitid, :sectorid," ":adc0, :adc1, :adc2, :adc3, :adc4, :adc5, :adc6, :adc7)"); m_metricsQuery->prepare("INSERT INTO metrics (key, timestamp, nickname, unitid, sectorid, " "acc_temp, unit_temp, unit_pressure, bpm_instant, bpm_average, base_pressure, base_temp) " "VALUES (NULL, :timestamp, :nickname, :unitid, :sectorid," ":acc_temp, :unit_temp, :unit_pressure, :bpm_instant, :bpm_average, :base_pressure, :base_temp)"); m_rssiQuery->prepare("INSERT INTO rssi (key, timestamp, nickname, unitid, sectorid, " "rssi_1, rssi_2, rssi_3, rssi_4, rssi_avg) " "VALUES (NULL, :timestamp, :nickname, :unitid, :sectorid," ":rssi_1, :rssi_2, :rssi_3, :rssi_4, :rssi_avg)"); } } void Worker::slotExecute( mMessage* insertMessage ) { m_accelerometerQuery = new QSqlQuery("WorkerDatabase"); m_adcQuery = new QSqlQuery("WorkerDatabase"); m_metricsQuery = new QSqlQuery("WorkerDatabase"); m_rssiQuery = new QSqlQuery("WorkerDatabase"); prepareQueries(); insertADC(insertMessage); //insertRSSI(insertMessage); //insertAccelerometer(insertMessage); //insertMetrics(insertMessage); emit queryResult( true ); } bool Worker::insertADC(mMessage *insertMessage) { if (m_databaseOpen) { // m_adcQuery->bindValue(":key",0); m_adcQuery->bindValue(":timestamp",insertMessage->m_timestamp); m_adcQuery->bindValue(":nickname",insertMessage->m_nickname); m_adcQuery->bindValue(":unitid",insertMessage->m_unitId.toInt()); m_adcQuery->bindValue(":sectorid",insertMessage->m_sectorId.toInt()); m_adcQuery->bindValue(":adc0",insertMessage->m_adc0.toInt()); m_adcQuery->bindValue(":adc1",insertMessage->m_adc1.toInt()); m_adcQuery->bindValue(":adc2",insertMessage->m_adc2.toInt()); m_adcQuery->bindValue(":adc3",insertMessage->m_adc3.toInt()); m_adcQuery->bindValue(":adc4",insertMessage->m_adc4.toInt()); m_adcQuery->bindValue(":adc5",insertMessage->m_adc5.toInt()); m_adcQuery->bindValue(":adc6",insertMessage->m_adc6.toInt()); m_adcQuery->bindValue(":adc7",insertMessage->m_adc7.toInt()); if (m_adcQuery->exec()) { return true; } else { qDebug() lastError(); return false; } } else { //database isn't open return false; } } ////database thread mDatabaseThread::mDatabaseThread(QObject *parent) : QThread(parent) { } mDatabaseThread::~mDatabaseThread() { delete m_worker; } void mDatabaseThread::executeInsertion( mMessage* insertMessage ) { emit executefwd( insertMessage ); // forwards to the worker } void mDatabaseThread::run() { emit ready(false); // Create worker object within the context of the new thread m_worker = new Worker(); connect( this, SIGNAL( executefwd( mMessage* ) ), m_worker, SLOT( slotExecute( mMessage* ) ) ); connect( m_worker, SIGNAL(queryResult(bool)), this, SIGNAL(ready(bool))); emit ready(true); exec(); // our event loop } The mDatabaseThread class has a worker object which it sends the database work to. The signals and slots are all functioning and get fired correctly. However, the actual QSqlQuery fails complaining that the database is not open - but when I attempt to debug it, I see m_database is actually set to the right file/parameters. It is based on a solution here http://www.linuxjournal.com/article/9602 . The mMessage class is a qObject which also gets passed to the m_worker object correctly. From the main class, I call m_databaseThread->start() in the constructor and then I call the executeInsertion(mMessage*) function. I've tried to change the way m_database is initialized as well as the QSqlQueries but it seems no matter what I do, it complains that the QSqlQuery cannot find the database connection.
