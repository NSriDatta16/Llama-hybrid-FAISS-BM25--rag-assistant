[site]: stackoverflow
[post_id]: 2686133
[parent_id]: 2685046
[tags]: 
Making a class static doesn't add any functionality - it's just a convenient check if you intend to use a class without instantiating it. And there are several uses for that... You can use static generic classes to work around a limitation: C# doesn't permit partial specialization. That means you must either specify all type parameters or none. However, that can be needlessly verbose. For example: static class Converter { public TOut Convert (TIn x) {...} } the previous class doesn't permit type inference since inference doesn't work on return values. However, you also can't specify the return value type without also specifying the input type since you can't partially specialize. Using a (possibly static) generic class, you can specify only one of the two types: static class ConvertTo { public TOut Convert (TIn x) {...} } That way you can let type inference work on the parameter type and specify only the return type. (Although the above case is conceivable, it doesn't require the generic class to be static, of course). Secondly, (as Steven first pointed out ) a separate static fields exists for each constructed type, and that makes static classes great places to store extra information about types or type combinations. In essence, it's a semi-static hashtable that keys on types. A semi-static lookup table keying on types sounds a little arcance, but it's actually a very, very useful structure because it allows you to store expensive reflection and code-generation results where they're almost free to look up (cheaper than a dictionary because it gets JIT-ed in and you avoid a call to .GetType() ). If you're doing metaprogramming, this is great! For example, I use this in ValueUtils to store generated hash functions: //Hash any object: FieldwiseHasher.Hash(myCustomStructOrClass); //implementation: public static class FieldwiseHasher { public static int Hash (T val) { return FieldwiseHasher .Instance(val); } } public static class FieldwiseHasher { public static readonly Func Instance = CreateLambda().Compile(); //... } Static generic methods allow type-inference to make usage really easy; static fields on generic classes allow virtually overhead-free storage of (meta)data . It wouldn't surprise me at all if ORM's like Dapper and PetaPoco use techniques like this; but it's also great for (de)serializers. A limitation is that you're getting the low overhead because you're binding to the compile-time type; if the object that's passed is actually an instance of a subclass, you're probably binding to the wrong type - and adding checks to avoid that kind of undermines the benefit of being low-overhead.
