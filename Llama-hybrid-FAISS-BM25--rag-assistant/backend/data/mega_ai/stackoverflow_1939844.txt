[site]: stackoverflow
[post_id]: 1939844
[parent_id]: 1938038
[tags]: 
Have you picked a tough nut to crack as a beginner to Scala! :-) Ok, brief tour, don't expect to fully understand it right now. First, note that the problem happens at the method ++ . Searching for its definition, we find it at the trait MapLike , receiving either an Iterator or a Traversable . Since y is a SortedMap , then it is the Traversable version being used. Note in its extensive type signature that there is a CanBuildFrom being passed. It is being passed implicitly, so you don't normally need to worry about it. However, to understand what is going on, this time you do. You can locate CanBuildFrom by either clicking on it where it appears in the definition of ++ , or by filtering. As mentioned by Randall on the comments, there's an unmarked blank field on the upper left of the scaladoc page. You just have to click there and type, and it will return matches for whatever it is you typed. So, look up the trait CanBuildFrom on ScalaDoc and select it. It has a large number of subclasses, each one responsible for building a specific type of collection. Search for and click on the subclass SortedMapCanBuildFrom . This is the class of the object you need to produce a SortedMap from a Traversable . Note on the instance constructor (the constructor for the class) that it receives an implicit Ordering parameter. Now we are getting closer. This time, use the filter filter to search for Ordering . Its companion object (click on the small "o" the name) hosts an implicit that will generate Ordering s, as companion objects are examined for implicits generating instances or conversions for that class. It is defined inside the trait LowPriorityOrderingImplicits , which object Ordering extends, and looking at it you'll see the method ordered[A , which will produce the Ordering required... or would produce it, if only there wasn't a problem. One might assume the implicit conversion from X to Ordered[X] would be enough, just as I had before looking more carefully into this. That, however, is a conversion of objects , and ordered expects to receive a type which is a subtype of Ordered[X] . While one can convert an object of type X to an object of type Ordered[X] , X , itself, is not a subtype of Ordered[X] , so it can't be passed as a parameter to ordered . On the other hand, you can create an implicit val Ordering[X] , instead of the def Ordered[X] , and you'll get around the problem. Specifically: object ViewBoundExample { class X def combine[Y](a: SortedMap[X, Y], b: SortedMap[X, Y]): SortedMap[X, Y] = { a ++ b } implicit val orderingX = new Ordering[X] { def compare(x: X, y: X) = 0 } } I think most people initial reaction to Ordered / Ordering must be one of perplexity: why have classes for the same thing? The former extends java.lang.Comparable , whereas the latter extends java.util.Comparator . Alas, the type signature for compare pretty much sums the main difference: def compare(that: A): Int // Ordered def compare(x: T, y: T): Int // Ordering The use of an Ordered[A] requires for either A to extend Ordered[A] , which would require one to be able to modify A 's definition, or to pass along a method which can convert an A into an Ordered[A] . Scala is perfectly capable of doing the latter easily, but then you have to convert each instance before comparing. On the other hand, the use of Ordering[A] requires the creation of a single object, such as demonstrated above. When you use it, you just pass two objects of type A to compare -- no objects get created in the process. So there are some performance gains to be had, but there is a much more important reason for Scala's preference for Ordering over Ordered . Look again on the companion object to Ordering . You'll note that there are several implicits for many of Scala classes defined in there. You may recall I mentioned earlier that an implicit for class T will be searched for inside the companion object of T , and that's exactly what is going on. This could be done for Ordered as well. However, and this is the sticking point, that means every method supporting both Ordering and Ordered would fail! That's because Scala would look for an implicit to make it work, and would find two: one for Ordering , one for Ordered . Being unable to decide which is it you wanted, Scala gives up with an error message. So, a choice had to be made, and Ordering had more going on for it. Duh, I forgot to explain why the signature isn't defined as ordered[A , instead of ordered[A . I suspect doing so would cause the double implicits failure I have mentioned before, but I'll ask the guy who actually did this stuff and had the double implicit problems whether this particular method is problematic.
