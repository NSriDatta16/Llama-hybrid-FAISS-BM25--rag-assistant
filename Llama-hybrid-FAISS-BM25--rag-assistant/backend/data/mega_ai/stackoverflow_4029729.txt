[site]: stackoverflow
[post_id]: 4029729
[parent_id]: 4029705
[tags]: 
Here's the thing for me, I don't get why it's not a problem to just use the type Gadget and ConsoleLogger concrete methods. Why in this top layer does it still need to be a var of type ILogger and IGadget? I mean at this point I'm not seeing any need for polymorphism..but I"m missing the boat I guess here in my learning process. The whole idea of inversion of control is to get the dependencies out of the classes, that uses them. Accodring the code you've pasted - the Program is highly coupled to specific classes. I even say - it is coupled to implementation ! So, when you rewrite that Program on using of interfaces - you are free in the future to use any interface impementation you want. Let's suppose you wanted to change ConsoleLogger to SyslogLogger , or even to CompositeLogger which writes to several storages. With dependencies inverted (moved outside the class) - you can do that very simple and without any modifications. As usual - dependency container configuration is some of human-readable format, xml, for example. So for changing of your program behaviour (move from one - to another logger) - only thing you need is just to change one line in config file. http://en.wikipedia.org/wiki/Inversion_of_control - this article describes the same thing but in correct english )) UPD : in that sample - Program depends on ConsoleLogger class. This means that the dependency is "inside" the class program. So when you move this dependency outside (for example - by passing the ConsoleLogger by function parameter) - it called inversion . And now that dependency is outside. Outside == Program now depends on some ConsoleLogger interface, not the class itself, and now Program does not take care how to instantiate that class object. And dependency container is just a software that helps you to organize the relations/dependencies in a handy manner (as usual it is tree, dependency tree).
