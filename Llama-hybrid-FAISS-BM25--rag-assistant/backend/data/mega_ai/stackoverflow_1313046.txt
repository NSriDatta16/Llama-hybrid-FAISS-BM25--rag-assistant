[site]: stackoverflow
[post_id]: 1313046
[parent_id]: 1312425
[tags]: 
Though the answers which point out that the "this" reference is essentially passed as a magic "hidden parameter" to the call are essentially correct, the full story is actually quite a bit more complicated in C# than one might think at first glance. Reference types are straightforward; the referenced object is checked for null and then conceptually passed as an unnamed, non-variable parameter called "this". The story is complicated by value types. Remember, value types are, by definition, passed by value -- that is, passed by making a copy of the data. Hence their name. But clearly mutable value types -- which are pure evil and should be avoided -- cannot be passed by value as the "this", because if you called a mutator, the "this" in the mutator method would be mutating the copy, not the original! Therefore, in a value type's method call, "this" is not the value of the receiver, it is an alias to the variable representing the storage location of the receiver . We implement this by passing "this" as the managed address of the receiver, not the value of the receiver. Now we can raise another difficulty. What if the variable storing the value being mutated is a read-only variable ? Now what do we do? If you're curious, read my article on the subject and see if you can correctly answer the puzzle presented: http://blogs.msdn.com/ericlippert/archive/2008/05/14/mutating-readonly-structs.aspx
