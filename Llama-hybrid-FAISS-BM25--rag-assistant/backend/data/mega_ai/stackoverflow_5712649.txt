[site]: stackoverflow
[post_id]: 5712649
[parent_id]: 2592305
[tags]: 
The code in this answer fails to differentiate the examples in: javascript: function sameRAs(newArray,entry){ return newArray.length == entry.length && newArray.join('/') == entry.join('/')}; alert( sameRAs( [1,'2/3',4], [1,2,'3/4'] ) ? 'same' : 'different' ); alert( sameRAs( [null], [,] ) ? 'same' : 'different' ); To see that [null] and [,] are indeed different, consider: javascript: alert( [null][0] ); alert( [,][0] ); which display null and undefined respectively. A composited array can check array identity! with == for identical arrays! javascript: ra=[1,2,3]; ar=[4]; r=[]; composite=[ar,r,ra,ar,ra]; for(i in composite) if(composite[i]==ra) alert( JSON.stringify(composite) +' at ['+ i +']'+' == ['+ ra +']') displays: [[4],[],[1,2,3],[4],[1,2,3]] at [2] == [1,2,3] and [[4],[],[1,2,3],[4],[1,2,3]] at [4] == [1,2,3] While my vote is with .toSource() (& Mozilla), simple valued arrays can be compared via JSON. javascript: ra=[1,2,3]; ar=[1,2,3]; alert([ ra==ar, JSON.stringify(ra)==JSON.stringify(ar) ]); displays false,true . Another wrinkle: circular arrays. Comparing these is difficult, which is where .toSource() shines. javascript: ra = [0,1,2]; ra[3] = ra; r2d2 = #2= [0,1,2,#2#]; alert([ ra==r2d2, ra.toSource() == r2d2.toSource() ]) displays false,true (in FireFox). Regarding machine efficiency: the computational expense is marginal compared to the cost invested in human time. Computers are here to reduce human labour, not the other way around. Truly computationally expensive and extensively deployed computations may warrant a large investment in human labour to realize efficiencies. This is not one of those times. The simplicity of .toSource() might payoff by installing FF as a pragmatic approach to solving problems such as this. The scale of a problem often means coercing the environment and machinery to get a solution rather than using human labour.
