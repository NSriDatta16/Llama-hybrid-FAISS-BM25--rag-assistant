[site]: stackoverflow
[post_id]: 5396501
[parent_id]: 5396413
[tags]: 
If I were doing it, I think I'd do the job quite a bit differently. If you can afford to ignore IBM mainframes, I'd do something like this: unsigned long bitset = 0; char *arr = "saaangeetha"; char *pos; for (pos=arr; *pos; ++pos) if (isalpha(*pos)) bitset |= 1 This associates one bit in bitset with each possible letter. It then walks through the string and for each letter in the string, sets the associated bit in bitset . To print out the letters once you're done, you'd walk through bitset and print out the associated letter if that bit was set. If you do care about IBM mainframes, you can add a small lookup table: static char const *letters = "abcdefghijklkmnopqrstuvwxyz"; and use strchr to find the correct position for each letter. Edit: If you're using C++ rather than C (as the tag said when I wrote what's above), you can simplify the code a bit at the expense of using some extra storage (and probably being minutely slower): std::string arr = "saaangeetha"; std::set letters((arr.begin()), arr.end()); std::copy(letters.begin(), letters.end(), std::ostream_iterator (std::cout, " ")); Note, however, that while these appear the same for the test input, they can behave differently -- the previous version screens out anything but letters (and converts them all to lower case), but this distinguishes upper from lower case, and shows all non-alphabetic characters in the output as well.
