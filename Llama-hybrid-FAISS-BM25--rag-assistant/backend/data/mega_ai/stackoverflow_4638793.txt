[site]: stackoverflow
[post_id]: 4638793
[parent_id]: 4637978
[tags]: 
The reason you are getting that error is that you are setting the content of the ScrollViewer to be a UserControl. By doing so you are setting the parent of UserCtrl1 (UserControl) to be the ScrollViewer. If you can't set two children to a ScrollViewer which is what is happening when you try to set UserCtrl2 as ActiveFunction. What you should really be doing is too leverage the power of ViewModels and DataTemplates within WPF. From the code you have posted I changed it to use a more MVVM approach. Using ViewModels and DataTemplates. It is better to use viewmodels because it is pure code you don't need to mess around with this parent/child UI relationship anymore. You just set things as you would normal objects. By specifying the datatemplate for a certain class, you have the visual display done for you. This is the whole separation between code and visual aspects. Commands. I am using a Command to handle the button click. This is how you should be doing it too if you want to go down the MVVM route. On top of just help separating logic and view, you can also do unit tests against the commands too with the need of a UI. Here is the MainWindow. Change UserControl Here is the code behind for the MainWindow.xaml.cs. Basically what I am doing here is I am setting the DataContext of this view to be the viewmodel. This is not the best way to do it because you are hardcoding things. Better way would be to leverage data templates and let WPF handle it. using System.Windows; namespace LogicalChildException { /// /// Interaction logic for MainWindow.xaml /// public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); DataContext = new MainViewModel(); } } } Here is the code for the ViewModels. I have used the idea of a DelegateCommand which I found from here http://www.wpftutorial.net/DelegateCommand.html . UserControl1ViewModel and UserControl2ViewModel are just dummy objects but you could make them implement INotifyPropertyChanged and then use that for binding in your datatemplate. using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.ComponentModel; using System.Windows.Input; namespace LogicalChildException { public class DelegateCommand : ICommand { private readonly Predicate _canExecute; private readonly Action _execute; public event EventHandler CanExecuteChanged; public DelegateCommand(Action execute) : this(execute, null) { } public DelegateCommand(Action execute, Predicate canExecute) { _execute = execute; _canExecute = canExecute; } public bool CanExecute(object parameter) { if (_canExecute == null) { return true; } return _canExecute(parameter); } public void Execute(object parameter) { _execute(parameter); } public void RaiseCanExecuteChanged() { if (CanExecuteChanged != null) { CanExecuteChanged(this, EventArgs.Empty); } } } public class MainViewModel : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; private ICommand _switchCommand; private object _activeFunction; private object _userControl1; private object _userControl2; public MainViewModel() { _switchCommand = new DelegateCommand(OnSwitch); _userControl1 = new UserControl1ViewModel(); _userControl2 = new UserControl2ViewModel(); ActiveFunction = _userControl1; } public ICommand SwitchCommand { get { return _switchCommand; } } public object ActiveFunction { get { return _activeFunction; } set { if (_activeFunction != value) { _activeFunction = value; OnPropertyChanged("ActiveFunction"); } } } private void OnSwitch(object obj) { // do logic for switching "usercontrols" here if (ActiveFunction == null) { // if null, just set it to control 1 ActiveFunction = _userControl1; } else { ActiveFunction = (ActiveFunction is UserControl1ViewModel) ? _userControl2 : _userControl1; } } private void OnPropertyChanged(string propertyName) { if (PropertyChanged != null) { PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); } } } public class UserControl1ViewModel { } public class UserControl2ViewModel { } } There are many areas here that you could improve upon to make cleaner in the MVVM world but this should help you resolve your issue that you are currently having.
