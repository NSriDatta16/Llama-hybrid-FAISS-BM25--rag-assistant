[site]: stackoverflow
[post_id]: 4885987
[parent_id]: 4863308
[tags]: 
Since it's tagged homework, I won't give you the C++ code since you should do some of the work :-) You can break it down into two problems, the first one being how to tell if a given number contains a one. This has an elegant recursive solution: def containsOne (n): if n This will return 0 for any number zero or less and return 1 if it contains a 1 . It does this by recursively checking the least significant digit for a 1 . If it is, it returns 1 otherwise it divides the number by 10 (integer division like 472 becoming 47 ) and continues. Then you have a simple iterative function for counting: def countOfOneNumbersOneTo(n): count = 0 for i = 1 to n: count = count + containsOne(i) return count That's about the simplest code that'll do the trick. You can see it in action in the following Python code (which is about as close to pseudo-code as a language gets): import sys def containsOne (n): if n and transcript: $ python qq.py -10 0 $ python qq.py 0 0 $ python qq.py 1 1 $ python qq.py 9 1 $ python qq.py 10 2 $ python qq.py 29 12 $ python qq.py 100 20 A C version follows: #include #include static int containsOne (int n) { if (n If you want raw speed, one option is to pre-calculate all values and write the results to a file. The initial process will be a little slow but, once you have the values written to a fixed-length-record file, the lookup is a simple, relatively fast, seek/read operation. For the number 10 9 , this takes a little over 8 minutes to do on my old clunker laptop and you need to remember that you don't need to do this for every number since, once you've established that 100 has 20 results, you just have to check 101 and add 1 (since 101 has a 1) to the 20. Similarly, knowing that 1999999 has 1468559 results, check 2000000 and add 0 (since it has no 1's). I've actually used this trick before with a file containing millions and millions of primes. Turning this into a bitmask in a file, I have an isPrime() method that blows most any calculating variant out of the water :-)
