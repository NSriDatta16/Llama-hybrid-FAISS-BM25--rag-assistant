[site]: stackoverflow
[post_id]: 2192749
[parent_id]: 2192175
[tags]: 
The DLR is several different things, some of which have direct equivalents in Java, some of which exist in different forms and some of which have no equivalent. Some of those which do have an equivalent are already part of the platform, some will be part of Java 7 and some are available from third parties. Runtime Binder and Caching Infrastructure The DLR has a runtime binding and caching infrastructure, which makes dynamic dispatch fast and efficient. How to make dynamic dispatch as fast as static dispatch and much faster than C++-style virtual table dispatch, has been known for more than 20 years, but most dynamic execution engines don't employ those technologies such as Polymorphic Inline Caching, Dynamic Type Inference, Type Feedback Optimization and so on. The DLR tries to provide a single implementation, which can be shared by all DLR-based languages (including the C# runtime binder used for the dynamic keyword in C# 4). The Java equivalent to this is JSR-292 , which extends the JVM with a runtime binding and caching infrastructure. The main difference between the DLR and JSR-292 is that JSR-292 is implemented at the VM level, which means that in order to use it, you need a new VM. JSR-292 is going to be part of the next JVM specification, which in turn is going to be part of the Java 7 platform specification, but that is still a year or so away. (It is already available, in current JDK7 Early Access releases, though, and has been for quite some time.) The DLR, OTOH is just a library, and you can install it on the CLR 2.0, if you want to. Indeed, you don't even need the CLR, any CLI-compliant VES will do, such as Novell's Mono . And since the DLR is Open Source, Novell can just download the source code from the Microsoft website, and ship it as part of Mono, without writing a single of code ... which is exactly what they are doing. Sun's implementation of JSR-292 is also Open Source, but that doesn't help IBM, Oracle, Apache, RedHat, GNU and so on, because it is very VM-specific, so every JVM vendor has to implement it themselves. (And there is a lot of those, Sun alone has four different JVMs.) [Note: there is a RÃ©mi Forax's JSR-292 backport , which implements JSR-292 for older JVMs via bytecode rewriting. It is 100% compatible, but pretty slow.] Meta-Object Protocol for Interoperability The DLR contains a MOP (the IDynamicObject interface), which allows all DLR-based languages to interoperate with each other and with CLI-based languages on a much higher level and with much tighter integration than having to go through the CTS. In the Java space, the equivalent is Attila Szegedi's (the maintainer of the Rhino JavaScript compiler for the JVM) dynalang project, which is inspired by the CommonLisp MOP. It is however, not finished, not widely used (yet) and a third-party library, not part of the standard platform. All three of those are probably going to change sometime, but at least the last one is probably not going to happen for Java 7. Standardized Embedding API The DLR provides a standardized embedding API for DLR-based languages, which allows you to embed a language runtime in your application without having to learn a different API for every different runtime. Indeed, you don't even have to know what the runtime is! The equivalent to this is the JSR-223 Java Scripting API which has been part of the Java platform since Java 6 and lives in the javax.script package . Code Representation and Compiler The DLR contains a standard representation for code (DLR trees, Expression trees) and both an interpreter and a highly optimizing compiler for those trees, which allows langage implementors to concentrate on their language-specific compiler frontends and have the DLR deal with the nitty-gritty of code generation behind the scenes. There is no equivalent in Java. Dynamic capabilities for static languages C# 4 and VB.NET 10 add dynamic typing for easier integration with dynamic languages. While this has technically nothing to do with the DLR, it uses the DLR for some of its work. There is no equivalent in Java.
