[site]: stackoverflow
[post_id]: 4741020
[parent_id]: 4740737
[tags]: 
To the best of my knowledge there isn't an STL "one-liner" that can generate this sequence. You could use a combination of algorithms to try to delineate all the ranges of adjacent consecutive values, perhaps using std::adjacent_difference , but I honestly think the hand-written loop will be more elegant. On an unrelated note, I'm not sure I support your decision to design look_n_say as you have. As you've written the class, you have an object whose only purpose is to write values to an ostream . You can't query for individual values out of the series, nor can you change the number of values that you get back after you've created the object. You also eagerly recompute the first n numbers every time you call operator , which can be extremely inefficient. I would advise changing the class to: Cache the previously-generated values so that you can retrieve them later. Allow the user to query any look-and-say number that they want, not just retrieve the first n of them. One possible design might be like this: class LookAndSaySeries { public: string getTerm(size_t index) const; // Get the appropriate term of the series. private: /* Previously-retrieved values, marked mutable since getTerm() will modify even * though it's a semantically-const operation. */ mutable vector cachedValues; // Values you've handed back before. void generateNext() const; }; string LookAndSaySeries::getTerm(size_t index) const { /* Keep generating values until you have enough to satisfy the request. */ while (index >= cachedValues.size()) generateNext(); return cachedValues[index]; } void LookAndSaySeries::generateNext() const { /* ... insert logic here to generate next term ... */ cachedValues.push_back(/* ... that value ... */); } This allows you to easily query individual numbers without recomputing them on each iteration. You can still print the values to a stream, as you did before, but now have a finer-grained control over how the numbers are produced.
