[site]: stackoverflow
[post_id]: 1301139
[parent_id]: 1300793
[tags]: 
If you don't want to pass parameters to B (which would have been the cleanest solution), you can use thread-local storage. Looking at your code in general though, you'll probably be shooting yourself in the foot by trying this strict 1-to-1 mapping from Java to C++. In C++, you should almost never call new . Allocate on the stack whenever possible. new in C++ is obviously error-prone (no garbage collection), but it's also extremely slow compared to managed languages like Java. Functors can be used as a more powerful alternative to function pointers (for example when creating your thread), or just to replace generic exec() or run() functions. Name them operator() instead, and the class can be used as a functor. And in your constructors you should use the initializer list as much as possible. The following applies the above suggestions to your code. Of course I passed an argument to the B constructor. If that's not an option, use thread local storage instead. class B { public: explicit B(int value) : value(value) void operator()(); private: int value; }; class X { public: int value; X(int x) :value(x) { }// use the initializer list to initialize members void operator()() { B b(value); // allocate B on the stack if possible b(); } }; void B::operator()() { std::cout Of course in this simple example, you don't really need two classes in the first place. You could just as easily have removed X entirely and done: class B { public: explicit B(int value) : value(value) void operator()(); private: int value; }; void B::operator()() { std::cout
