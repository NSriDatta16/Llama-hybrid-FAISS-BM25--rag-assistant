[site]: stackoverflow
[post_id]: 5103365
[parent_id]: 5102870
[tags]: 
It looks like you want an outer loop and an inner loop, and for each char in the array, you want to compare to each that follows with int j = 1 . In that case, you want int j = i + 1 in the inner loop: for (int i = 0; i But your return statement exits the function right in the middle of things. You need to let the loops complete, so you want to remove that return . Your Console.WriteLine executes on every iteration of the inner loop, but you really only want it to iterate on the outer loop -- once for each character of the string and not once for every combination of i and j. So you need to push that to the outer loop, outside of the inner loop. Also, you need to reset the count every time you begin another iteration of the outer loop, because you are counting again, and, you want to start counting at 1 not zero when you find a character because it just appeared once as you first reach it. And as Lasse points out, you'll get strange output when you hit the same character as you move along the outer loop. An easy way to prevent that is to set the further (rightwards) char[j] to '\0' (null character) on every match, and then in the outer loop, ignore null characters in your counting for example by using continue , effectively culling them as you go along: for(int i = 0; i My first thought would be to use a Dictionary as Daniel suggests, like this: var dict = new Dictionary (); string s = "This is a test, with multiple characters"; foreach (var c in s) { if (dict.ContainsKey(c)) { dict[c]++; } else { dict[c] = 1; } } foreach (var k in dict.Keys) { Console.WriteLine("{0}: {1}", k, dict[k]); } But I like the elegant LINQ solutions.
