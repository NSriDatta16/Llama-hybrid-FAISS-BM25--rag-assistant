[site]: stackoverflow
[post_id]: 3643977
[parent_id]: 3643436
[tags]: 
Not very elegant - and there are problems because of greedy matching - but this more or less works: data="abcdefADDNAME25abcdefgHELLOabcdefgADDNAME25abcdefgHELLOabcdefg" for word in $data \ "ADDNAME25abcdefgHELLOabcdefgADDNAME25abcdefgHELLOabcdefg" \ "ADDNAME25abcdefgHELLOabcdefgADDNAME25abcdefgHELLO" do echo $word done | sed -e '/ADDNAME[0-9][0-9][a-z]*HELLO/{ s/\(ADDNAME[0-9][0-9][a-z]*HELLO\)/ \1 /g }' | while read line do set -- $line for arg in "$@" do echo $arg done done | grep "ADDNAME[0-9][0-9][a-z]*HELLO" The first loop echoes three lines of data - you'd probably replace that with cat or I/O redirection. The sed script uses a modified regex to put spaces around the patterns. The last loop breaks up the 'space separated words' into one 'word' per line. The final grep selects the lines you want. The regex is modified with [a-z]* in place of the original .* because the pattern matching is greedy. If the data between ADDNAME and HELLO is unconstrained, then you need to think about using non-greedy regexes, which are available in Perl and probably Python and other modern scripting languages: #!/bin/perl -w while (<>) { while (/(ADDNAME\d\d.*?HELLO)/g) { print "$1\n"; } } This is a good demonstration of using the right too for the job.
