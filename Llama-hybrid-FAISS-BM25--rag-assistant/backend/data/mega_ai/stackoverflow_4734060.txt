[site]: stackoverflow
[post_id]: 4734060
[parent_id]: 4729686
[tags]: 
Just to be clear - you can not generically get a list of modules that the app depends on by code analysis alone. E.g. if your apps does eval { require $module; $module->import() } , where $module is passed via command line, then this can ONLY be detected by actually running the specific command line version with ALL the module values. If you do wish to do this, you can figure out every module used by a combination of runs via: Devel::Cover . Coverage reports would list 100% of modules used. But you don't get version #s. Print %INC at every single possible exit point in the code as slu's answer said. This should probably be done in END{} block as well as __DIE__ handler to cover all possible exit points, and even then may be not fully 100% covering in generic case if somewhere within the program your __DIE__ handler gets overwritten. Devel::Modlist (also mentioned by slu's answer) - the downside compared to Devel::Cover is that it does NOT seem to be able to aggregate a database across multiple sample runs like Devel::Cover does. On the plus side, it's purpose-built, so has a lot of very useful options (CPAN paths, versions). Please note that the other module ( Module::ScanDeps ) does NOT seem to allow you to do runtime analysis based on arbitrary command line arguments (e.g. it seems at first glance to only allow you to execute the program with no arguments) and if that's true, is inferior to all the above 3 methods for any code that may possibly load modules dynamically.
