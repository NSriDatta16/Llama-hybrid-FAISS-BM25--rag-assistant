[site]: stackoverflow
[post_id]: 695463
[parent_id]: 695419
[tags]: 
Arrays in C and C++ are passed as pointers. Semantics for arrays in C# include an additional layer of indirection. Your C# program is (probably) passing the address of a variable that holds the address of the data. I recently wrestled with passing an array of bytes from C# to a C function and had to marshal the data in both directions. It's not obvious to me that your code is doing that. Better than an explanation, I'll provide a concrete example: //extern "C" LIBEXIFWRAPPER_API void findEXIFtagValue( void * load, unsigned int tagID, char* buf, int bufLen ); [DllImport("libexif-wrapper.dll")] unsafe public static extern IntPtr findEXIFtagValue([MarshalAs(UnmanagedType.SysUInt)]IntPtr load, int tagID, [MarshalAs(UnmanagedType.SysUInt)]IntPtr buf, int bufLen); This function accepts a pointer to opaque data, an int and a byte array in which it stores a text string. The following snippet shows how the byte array is declared, passed to the C function and the results extracted: const int tagBuffer = 1024; IntPtr buf = Marshal.AllocHGlobal(tagBuffer); findEXIFtagValue(loader, (int)ExifTag.EXIF_TAG_DATE_TIME, buf, tagBuffer); string s = Marshal.PtrToStringAnsi(buf); Note that the argument is marshaled in the prototype and marshaled again to retrieve the result. None of this was particularly obvious to me. It seems that IntPtr is the C# equivalent of void* except I had to use a SysUInt to manage a (C) void*. The pointer to the byte array is marshaled in as SysUInt. (from a C# noob) HTH
