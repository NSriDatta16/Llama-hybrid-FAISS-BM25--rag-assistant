[site]: stackoverflow
[post_id]: 4020256
[parent_id]: 4018867
[tags]: 
The only thing that would absolutely entice me to try a new language would be a language that's at least as high-level as what I have now, and at least as flexible (e.g., w.r.t. metaprogramming). The good news is that I'm willing to try anything once, especially if it has crazy new ideas, so this isn't a rule set in stone. :-) Things that would tend to turn me away from trying a new language, again not absolutes: if it didn't have a repl, I'd probably be much less inclined to try it if its syntax is complex, I'd probably avoid it entirely, because life is too short to become a language lawyer in yet another arcane syntax For example, Ruby syntax, if you took out some of the crufty old corner cases, is about the right level -- adding complexity beyond that, like Perl or C++, just means that I'm going to spend more time thinking about the syntax than the program, and that my text editor is never going to work quite right with it -- you don't need complex syntax for good language features. (If you grok Perl and C++, cool, more power to you. I mean no disrespect to you or your language. I personally can't figure them out, so any language with that level of syntactic complexity is not for me .) complete lack of tools You don't need everything right away, but if all you've got is an interpreter, especially one written in C, it's certainly going to seem like a language not built for metaprogramming, and so I'll not have much interest in it. (Extra bonus points for being self-hosted!) being called "pragmatic"! Ouch ... sorry. But that sounds to me like a language aimed at solving one kind of problem, and I want general-purpose tools. (I don't think their creators ever called C or Lisp or Smalltalk "pragmatic", and I want to learn the next C or Lisp, not the next PHP or Java.) if it depends on some very different platform for key functionality (like C or the JVM, if the language isn't otherwise much like C or Java), I'm less interested This one is admittedly in stark contrast to what other people have already written. For example, I'm less inclined to try Clojure because it's on the JVM. They seem to have less incentive to build good new native libraries, and if I just wanted to glue existing Java-language libraries together, Java itself is pretty good at that. The kinds of metaprogramming I do today would be impossible in Clojure-using-Java-libraries, because they're black boxes. Also, over the years I've used native libraries, and "just wrap a C library" libraries for HLLs, and the "wrap a C library" solution is always much more complex, which means it's harder to set up, and when (not if) I run into trouble, much harder to debug. So if you say you've got a new system that can use all my existing libraries, I just hear "cross-language function call debugging nightmare". A powerful and flexible language needs far fewer libraries than weaker languages. If I had to write a C program that needed a linked list, I'd probably look for a library (maybe Glib). If I had to do it in Python, I could probably write one in less time than it took to find a library. And that's not even the easiest language for writing a linked list! If I'm moving up in the abstraction spectrum, it means I'll need fewer libraries than I'm using now, which is already "not very many". So make a great language, and we'll figure out libraries if we need them, using the new metaphors for this language. Any time spent wrapping or java.lang is a waste of time, to me. I guess a few of my remarks are the opposite of what other people have said. The possible interpretations are either: they're right, I'm wrong I'm right, they're wrong none of us know what the heck we're talking about, and you should just make something cool for yourself, like Dennis and Ken did :-) Good luck, and I look forward to seeing what you make. I think 5 years of design time is a lot more than a lot of successful programming languages get!
