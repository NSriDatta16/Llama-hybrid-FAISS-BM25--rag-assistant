[site]: stackoverflow
[post_id]: 1446607
[parent_id]: 1446509
[tags]: 
There's a note in section 10.3.2 of RFC 2616 about this behaviour: Note: When automatically redirecting a POST request after receiving a 301 status code, some existing HTTP/1.0 user agents will erroneously change it into a GET request. So this behaviour seems to be non-standard but historical. That GET request is not a POST , and it'll be missing the payload. Interestingly enough, this is also in the same section: If the 301 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued. That's pretty clear and seems to indicate we can't fix this, but I think ignoring this for the purpose of our own web service clients for services we pick (or control) is probably the least bad alternative. So how do we solve this? Instead of the willSendResponse: in the original question, I'm using this: - (NSURLRequest *)connection: (NSURLConnection *)connection willSendRequest: (NSURLRequest *)request redirectResponse: (NSURLResponse *)redirectResponse; { if (redirectResponse) { // we don't use the new request built for us, except for the URL NSURL *newURL = [request URL]; // Previously, store the original request in _originalRequest. // We rely on that here! NSMutableURLRequest *newRequest = [_originalRequest mutableCopy]; [newRequest setURL: newURL]; return newRequest; } else { return request; } } The idea here is that instead of cloning the new request and trying to shape it the same as the one Cocoa Touch sends me, I create a clone of the original request and change just the URL to match the request Cocoa Touch sent me. That original request is still a POST with the payload attached. If you control the server, it's worth reading RFC 2616, section 10.3 in its entirety to see if there's a better code you can use (while checking, of course, that iOS handles the better code as it should). You could also make a mutable copy of the redirected request and replace its HTTP method with the HTTP method of the original request. Same general principle, though that would favour keeping things from the new request rather than the old. In some circumstances that might work better, but I haven't tested this yet.
