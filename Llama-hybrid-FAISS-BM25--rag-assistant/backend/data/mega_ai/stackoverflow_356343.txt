[site]: stackoverflow
[post_id]: 356343
[parent_id]: 355848
[tags]: 
For general understanding of OOP in JavaScript you can't do better than read Douglas Crockford : Classical Inheritance in JavaScript Prototypal Inheritance in JavaScript Private Members in JavaScript For Dojo fans (and for general techniques) Neil Roberts has good articles: Color by numbers: dojo.delegate JavaScript Metaclass Programming Plain vanilla dojo.declare() is probably the most advanced OOP foundation in mainstream libraries around. I am biased, but don't take my word for it. Here are examples on how to use it. A plain vanilla object: // Let's define a super simple class (doesn't inherit anything). dojo.declare("Person", null, { // Class-level property answer: 42, // Class-level object property name: {first: "Ford", last: "Prefect"}, // The constructor, duh! constructor: function(age){ this.age = age; // instance-level property }, // A method saySomething: function(verb){ console.log("I " + verb + " " + this.name.first + " " + this.name.last + "!" + " -- " + this.answer); }, // Another method passportControl: function(){ console.log("I am " + this.age); } }); Example of use: // A fan of Ford Perfect var fan = new Person(18); fan.saySomething("love"); // I love Ford Perfect! -- 42 fan.passportControl(); // I am 18 Single inheritance is easy: // Let's create a derived class inheriting Person dojo.declare("SuperAgent", Person, { // Redefine class-level property answer: "shaken, not stirred", // Redefine class-level object property name: {first: "James", last: "Bond"}, // The constructor constructor: function(age, drink){ // We don't need to call the super class because // it would be done automatically for us passing // all arguments to it. // At this point "age" is already assigned. this.drink = drink; // Instance-level property }, // Let's redefine the method saySomething: function(verb){ // Let's call the super class first this.inherited(arguments); // Pay attention: no need for extra parameters, or any extra code, // we don't even name the class we call --- it is all automatic. // We can call it any time in the body of redefined method console.log("Yeah, baby!"); }, shoot: function(){ console.log("BAM!!!"); } }); Example of use: // Let's create a James Bond-wannabe var jb007 = new SuperAgent(45, "Martini"); jb007.saySomething("dig"); // I dig James Bond! -- shaken, not stirred // Yeah, baby! jb007.passportControl(); // I am 45 jb007.shoot(); // BAM!!! // Constructors were called in this order: Person, SuperAgent // saySomething() came from SuperAgent, which called Person // passportControl() came from Person // shoot() came from SuperAgent. Mixins: // Let's define one more super simple class dojo.define("SharpShooter", null, { // For simplicity no constructor // One method to clash with SuperAgent shoot: function(){ console.log("It's jammed! Shoot!"); } }); Mixin-based multiple inheritance: // Multiple inheritance dojo.declare("FakeAgent", ["SuperAgent", "SharpShooter"], { // Let's do it with no constructor // Redefine the method saySomething: function(verb){ // We don't call super here --- a complete redefinition console.log("What is " + verb "? I want my " + this.drink + "!"); }, }); Example of use: // A fake agent coming up var ap = new FakeAgent(40, "Kool-Aid"); ap.saySomething("hate"); // What is hate? I want my Kool-Aid! ap.passportControl(); // I am 40 ap.shoot(); // It's jammed! Shoot! // Constructors were called in this order: Person, SuperAgent // saySomething() came from FakeAgent // passportControl() came from Person // shoot() came from SharpShooter. As you can see, dojo.declare() gives all necessities with a simple to use API: straight single inheritance, mixin-based multiple inheritance, automatic chaining of constructors, and no-hassle super methods.
