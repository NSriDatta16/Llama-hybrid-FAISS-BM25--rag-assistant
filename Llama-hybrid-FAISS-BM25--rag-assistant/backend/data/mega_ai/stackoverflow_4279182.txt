[site]: stackoverflow
[post_id]: 4279182
[parent_id]: 4274386
[tags]: 
Yes your code is invalid ! This is an interesting show of how templates can change meaning of code in subtle ways. The following code is valid: class List { public: class a { typedef int type; friend class b; // that's fine! }; template class b; }; class b { List::a::type an_int; // allowed to access private member }; Standard says at 7.3.1.2/3 If a friend declaration in a non-local class first declares a class or function83) the friend class or function is a member of the innermost enclosing namespace. When is it a "first declared class"? It says that too there When looking for a prior declaration of a class or a function declared as a friend, and when the name of the friend class or function is neither a qualified name nor a template-id, scopes outside the innermost enclosing namespace scope are not considered. The lookup for "class b" is delegated from 7.1.5.3/2 to 3.4.4 which in turn delegates to unqualified name lookup at 3.4/7. All the question now is whether the template-name "b" is visible in the friend declaration class a. If it isn't, the name is not found and the friend declaration will refer to a new declared class at global scope. 3.3.6/1 about the scope of it says The potential scope of a name declared in a class consists not only of the declarative region following the nameâ€™s declarator, but also of all function bodies, default arguments, and constructor ctor- initializers in that class (including such things in nested classes). Ignoring a few pedantic points that would make this wording not apply to here (which were a defect but are fixed in the C++0x version of that paragraph which also makes this easier to read), this list does not include the friend declaration as an area where that template name is visible. However , the friend was declared in a member class of a class template. When the member class is instantiated different lookup applies - the lookup for friend names declared in a class template! The Standard says Friend classes or functions can be declared within a class template. When a template is instantiated, the names of its friends are treated as if the specialization had been explicitly declared at its point of instantiation. So the following code is invalid: template class List { public: class a { typedef int type; friend class b; // that's fine! }; template class b; }; // POI List ::a x; When that causes List ::a to be implicitly instantiated, the name a is looked up at "// POI" as if there would have been an explicit specialization declared. In that case, the template List::b has already been declared, and this lookup will hit it and emit an error because it's a template and not a non-template class.
