[site]: stackoverflow
[post_id]: 5571909
[parent_id]: 5571857
[tags]: 
Not at all. Instance variables work fine, and are subject to the same memory management rules as anything else: retain it before saving it to the instance var, and make sure you release it when you don't need it anymore (typically in the dealloc ). Some history here might be helpful: In the beginning, there were only instance variables. "Properties" existed only in an informal way, by convention, for objects outside your class to access "public" data that the class exposed. You'd write your own -(Foo *)foo and -(void)setFoo:(Foo *)f methods for each of these. Those often were like boilerplate code, trivially returning the ivar in the first case, and doing the right retain/release/set dance in the latter. So Objective-C 2.0 came along and gave us the ability to declare properties with the language syntax, and even generate the accessors for us-- lots of time and boilerplate code was saved. As time went on, some people began to think about all ivars as "properties", public or private. The public ones appear in the .h file as @properties , but you can also create a private interface to your object in the .m file that declare your "private" @properties , so you can use the accessors inside your class. This might or might not be overkill, depending on your philosophy to it, but this I think has to the situation you see now, where naked ivars look suspicious. They shouldn't. Instance variables happily exist without any of the other machinery. Just get your retain/release right (in non-GC runtimes). As you get more advanced, see @bbum's answer to this question: Must every ivar be a property? for some more varsity things to think about around the benefits of properties around KVO and subclassing.
