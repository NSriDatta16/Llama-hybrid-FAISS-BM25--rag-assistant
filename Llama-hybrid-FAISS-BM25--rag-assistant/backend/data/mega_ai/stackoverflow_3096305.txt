[site]: stackoverflow
[post_id]: 3096305
[parent_id]: 3096142
[tags]: 
We embed the unmanaged dlls into an assembly and then copy them out to the executing dll location (for web apps the shadow copy bin folder). This guarantees that the correct version is being run for a particular version of our app. Unfortunately this may not be doable (legal) depending on licensing terms for your various applications. In these cases, your best option is likely to use LoadLibrary to verify that the library is found, but beware of loading the wrong version (see also: DLL hell ); this may or may not be a problem you can even solve (for us, the only solution was embedding the dlls and extracting them from the assemblies where needed). Here is our code in question for the Sybase ASE ADO drivers: public static class SybaseResourceExtractor { public static void ExtractSybaseDependencies() { ExtractSybaseDependency("QueryLibrary.Unmanaged.sybdrvado20.dll", "sybdrvado20.dll"); ExtractSybaseDependency("QueryLibrary.Unmanaged.msvcr80.dll", "msvcr80.dll"); ExtractSybaseDependency("QueryLibrary.Unmanaged.sybcsi_certicom_fips26.dll", "sybcsi_certicom_fips26.dll"); ExtractSybaseDependency("QueryLibrary.Unmanaged.sybcsi_core26.dll", "sybcsi_core26.dll"); ExtractSybaseDependency("QueryLibrary.Unmanaged.sbgse2.dll", "sbgse2.dll"); } /// /// Extracts a resource to a file. /// /// Name of the resource. /// The filename including absolute path. static void ExtractSybaseDependency(string resourceName, string filename) { try { var assembly = Assembly.GetAssembly(typeof(AseConnection)); var executingAssembly = Assembly.GetExecutingAssembly(); filename = Path.GetDirectoryName(assembly.Location) + "\\" + filename; if (File.Exists(filename)) { File.Delete(filename); } if (!File.Exists(filename)) { using (Stream s = executingAssembly.GetManifestResourceStream(resourceName)) { using (var fs = new FileStream(filename, FileMode.Create)) { if (s == null) { throw new Exception("Failed to get resource stream for " + resourceName); } var b = new byte[s.Length]; s.Read(b, 0, b.Length); fs.Write(b, 0, b.Length); } } } } catch { //Doing nothing } }
