[site]: stackoverflow
[post_id]: 5482014
[parent_id]: 5481025
[tags]: 
If a regex solution is desired, here is a tested function which handles the anchor tags as you requested (with notable caveats noted below.) The regex is presented in verbose mode with comments: function process_markup($content) { return preg_replace( array( // Regex patterns '% ]*>%i', // Open tags. '% ]*>\s*%i', // Close tags. '% # Match A element (with no "<>" in attributes!) ]+? # anything up to HREF attribute. href\s*=\s* # HREF attribute name and "=" (["\']?) # $1: Optional quote delimiter ([^>\s]+) # $2: HREF attribute value. (?(1)\1) # If open quote, match close quote. [^>]*> # Remainder of start tag (.*?) # $3: A element contents. # A element end tag. %ix' ), array( // Replacement strings "", # Simply strip P, UL, and LI open tags. "\r\n", # Replace close tags with line endings. "$2 $3" # Keep A element HREF value and contents. ), $content); } I took the liberty of modifying the other regexes as well. Adjust as necessary. CAVEATS: This regex solution assumes: All A , P , UL and LI elements have no angle brackets <> in their attributes. There are no A , P , UL or LI element start or end tags within any CDATA sections such as SCRIPT or STYLE elements, or HTML comments, or inside other start tag attributes. Otherwise, this should work pretty well for a lot of HTML markup. I realize that many wince when they hear the words: HTML and REGEX spoken in the same breath, but in this particular case, I think a regex solution will work quite well (within the above limitations). The A tag is one of those which is not nested , so a regex can easily match the start tag, contents and end tag all in one whack. Same thing with the individual start and end tags for the other elements (which can be nested) when considered independently.
