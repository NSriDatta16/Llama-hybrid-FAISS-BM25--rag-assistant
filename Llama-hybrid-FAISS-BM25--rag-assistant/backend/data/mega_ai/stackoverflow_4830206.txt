[site]: stackoverflow
[post_id]: 4830206
[parent_id]: 4829341
[tags]: 
The problem I see is in this loop: cout ()); other_stacked_vector.back().reserve(9); other_stacked_vector.back().resize(5,0); write_container_addresses (other_stacked_vector[i]); } cout you are writing the addresses after each sub-vector has been added to the stacked vector. The problem is that upon the next iteration and push_back() call, the addresses that were displayed for the previous iteration may no longer be valid. This is caused by the fact that the push_back operation may have to reallocate memory, causing all vectors in the vector stack to be moved. A more simple demonstration is this: vector vec; vec.push_back(1); int* p = &vec[0]; vec.push_back(2); cout After a push_back call when the space has not been reserved in a vector, all pointers/references/iterators to internal memory within the vector are possibly invalidated because it may have to reallocate and move memory around to add the new item and maintain contiguous storage. What I would guess is happening in your multi-threaded case is that you are passing a reference to a sub-vector to a thread and then you are adding other sub-vectors to the stacked vector in the original thread, which could invalidate the reference to the sub-vector in the 2nd thread.
