[site]: crossvalidated
[post_id]: 236798
[parent_id]: 
[tags]: 
Spurious factor of 2 in Salakhutdinov's MatLab RBM code

I'm trying to pick apart http://www.cs.toronto.edu/~rsalakhu/DBM.html Specifically http://www.cs.toronto.edu/~rsalakhu/code_DBM/rbm.m That file troubles me, because there is a 2* factor appearing for no good reason that I can see. It seems to be doubling up the pre-activation energy for the hidden layer. I've pulled up https://www.cs.toronto.edu/~hinton/absps/guideTR.pdf alongside and there is no mention of such a factor. The only possible 2* I can think of might come from calculating the overall energy of a particular vis-hid configuration: $-E(v,h) = \sum a_i v_i + \sum b_j h_j + \sum_{i So my question is: what is the purpose of this factor of 2? PS No tag for RBM! PPS The code is really tricky to follow, I've rewritten it here (how to fix wonky syntax highlighting?): function rbm(maxepoch, numhid, batchdata, restart) binarySampleFrom = @(T) T > rand(size(T)); % T is a tensor activationFunc = @(E) 1 ./ (1 + exp(-E)); if restart == 1, %restart=0; eps_w = 0.05; % Learning rate for weights eps_vb = 0.05; % Learning rate for biases of visible units eps_hb = 0.05; % Learning rate for biases of hidden units %CD=1; weightCost = 0.001; momInitial = 0.5; momFinal = 0.9; [itemsPerBatch, nPixels, nBatches] = size(batchdata); N = itemsPerBatch; epoch=1; % Initializing symmetric weights and biases. vishid = 0.001*randn(nPixels, numhid); hidbiases = zeros(1,numhid); visbiases = zeros(1,nPixels); vishidinc = zeros(nPixels,numhid); hidbiasinc = zeros(1,numhid); visbiasinc = zeros(1,nPixels); end tic for epoch = epoch:maxepoch fprintf(1,'epoch %d\r',epoch); errsum=0; for batch = 1:nBatches, if mod(batch,10) == 9, fprintf(1,'.'); end data = batchdata(:,:,batch); [avSynapseExcitation, visBias, hidBias, av_err] = getState( data ); % keep a tally of average divergence of reconstructions from % original sampled vis-vector. errsum = av_err + errsum; % Update weights & biases momentum = (epoch 5)*momFinal; vishidinc = momentum*vishidinc + eps_w * ( avSynapseExcitation - weightCost*vishid); visbiasinc = momentum*visbiasinc + eps_vb * visBias; hidbiasinc = momentum*hidbiasinc + eps_hb * hidBias; vishid = vishid + vishidinc; visbiases = visbiases + visbiasinc; hidbiases = hidbiases + hidbiasinc; end fprintf(1, ' error %4.2f \n', errsum / nBatches); end toc save data/out/1_fullmnistvh.mat vishid visbiases hidbiases epoch function [avSynapseExcitation, visBias, hidBias, av_err] = getState( data ) visbias = repmat( visbiases, N, 1 ); hidbias = repmat( 2*hidbiases, N, 1 ); % - - - - - POSITIVE PHASE - - - - - % Consider data (28*28 greyscale pixels ranging 0.0 to 1.0) as probabilities visPD = data; % convert each pixel to 0 or 1 accordingly to get VIS outputs. sampleFromVis = binarySampleFrom( visPD ); % Clamping VIS, get HID layer activations, i.e. POSTERIOR dist. for HID % 100x784 * 784*10 = 100*10 hidPD = activationFunc( sampleFromVis*(2*vishid) + hidbias ); % Eq. 7 % 784 vis/inputs going to 10 hiddens = a 784x10 v_i h_j matrix. % Sum over all batch items: 784x100 * 100x10 -> 784x10 avSynapseStrength_clampingV = sampleFromVis' * hidPD / N; % Get expected activations for each visible and hidden neuron avVisAct = mean( sampleFromVis ); % _data in Eq. 5 avHidAct = mean( hidPD ); % - - - - - NEGATIVE PHASE - - - - - % Sample from our posterior dist. for HID sampleFromHid = binarySampleFrom( hidPD ); % Clamping HID to this sample, get a POSTERIOR dist. for VIS ... visReconPD = activationFunc( sampleFromHid*vishid' + visbias ); % Eq. 8 % ... from which we sample a 'Reconstruction' vis/data-vector ... visRecon = binarySampleFrom( visReconPD ); % ... and throw it back thru hidden units to get a 'neg' HID dist. newHidPD = activationFunc( visRecon*(2*vishid) + hidbias ); avSynapseStrength_threshold = visRecon' * newHidPD / N; avVisAct_neg = mean( visRecon ); %
