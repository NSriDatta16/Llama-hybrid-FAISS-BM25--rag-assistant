[site]: stackoverflow
[post_id]: 5715856
[parent_id]: 3880961
[tags]: 
I've written a custom NSValueTransformer to map between the bound NSManagedObject/Tag NSSet and the NSString NSArray of the token field. Here are the 2 methods: - (id)transformedValue:(id)value { if ([value isKindOfClass:[NSSet class]]) { NSSet *set = (NSSet *)value; NSMutableArray *ary = [NSMutableArray arrayWithCapacity:[set count]]; for (Tag *tag in [set allObjects]) { [ary addObject:tag.name]; } return ary; } return nil; } - (id)reverseTransformedValue:(id)value { if ([value isKindOfClass:[NSArray class]]) { NSArray *ary = (NSArray *)value; // Check each NSString in the array representing a Tag name if a corresponding // tag managed object already exists NSMutableSet *tagSet = [NSMutableSet setWithCapacity:[ary count]]; for (NSString *tagName in ary) { NSManagedObjectContext *context = [[NSApp delegate] managedObjectContext]; NSFetchRequest *request = [[NSFetchRequest alloc] init]; NSPredicate *searchFilter = [NSPredicate predicateWithFormat:@"name = %@", tagName]; NSEntityDescription *entity = [NSEntityDescription entityForName:[Tag className] inManagedObjectContext:context]; [request setEntity:entity]; [request setPredicate:searchFilter]; NSError *error = nil; NSArray *results = [context executeFetchRequest:request error:&error]; if ([results count] > 0) { [tagSet addObjectsFromArray:results]; } else { Tag *tag = [[Tag alloc] initWithEntity:entity insertIntoManagedObjectContext:context]; tag.name = tagName; [tagSet addObject:tag]; [tag release]; } } return tagSet; } return nil; } CoreData seems to automatically establish the object relationships on return (but I have not completely verified this yet) Hope it helps.
