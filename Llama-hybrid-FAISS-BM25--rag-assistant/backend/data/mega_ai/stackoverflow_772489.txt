[site]: stackoverflow
[post_id]: 772489
[parent_id]: 772377
[tags]: 
For reports its usually easier to use plain values or special DTO's. Of course you can query for the entity that references all the information, but to put it into the list (eg. using databinding) it's handier to have a single class that contains all the values plain. To get more specific solutions as the few bellow you need to tell us a little about your domain model. How does the class model look like? generally, you have at least three options to get "plain" values form the database using NHibernate. Write HQL that returns an array of values For instance: select e1.Style, e1.Color, e1.Size, e2.LAQty, e2.MTLQty from entity1 inner join entity2 where (some condition) the result will be a list of object[]. Every item in the list is a row, every item in the object[] is a column. This is quite like sql, but on a higher level (you describe the query on entity level) and is database independent. Or you create a DTO (data transfer object) only to hold one row of the result: select new ReportDto(e1.Style, e1.Color, e1.Size, e2.LAQty, e2.MTLQty) from entity1 inner join entity2 where (some condition) ReportDto need to implement a constructor that has all this arguments. The result is a list of ReportDto. Or you use CriteriaAPI (recommended) session.CreateCriteria(typeof(Entity1), "e1") .CreateCriteria(typeof(Entity2), "e2") .Add( /* some condition */ ) .Add(Projections.Property("e1.Style", "Style")) .Add(Projections.Property("e1.Color", "Color")) .Add(Projections.Property("e1.Size", "Size")) .Add(Projections.Property("e2.LAQty", "LAQty")) .Add(Projections.Property("e2.MTLQty", "MTLQty")) .SetResultTransformer(AliasToBean(typeof(ReportDto))) .List (); The ReportDto needs to have a proeprty with the name of each alias "Style", "Color" etc. The output is a list of ReportDto.
