[site]: stackoverflow
[post_id]: 2990083
[parent_id]: 2989979
[tags]: 
You can use sys.dm_db_index_physical_stats to get pretty detailed information on how data is stored in a given table. It's not the clearest thing to use, here's the template I built up over time for my first pass on troubleshooting: -- SQL 2005 - fragmentation & air bubbles SELECT ob.name [Table], ind.name [Index], ind.type_desc IndexType ,xx.partition_number PartitionNo ,xx.alloc_unit_type_desc AllocationTyp ,xx.index_level ,xx.page_count Pages ,xx.page_count / 128 Pages_MB ,xx.avg_fragmentation_in_percent AvgPctFrag ,xx.fragment_count ,xx.avg_fragment_size_in_pages AvgFragSize ,xx.record_count [Rows] ,xx.forwarded_record_count [ForwardedRows] ,xx.min_record_size_in_bytes MinRowBytes ,xx.avg_record_size_in_bytes AvgRowBytes ,xx.max_record_size_in_bytes MaxRowBytes ,case xx.page_count when 0 then 0.0 else xx.record_count / xx.page_count end AvgRowsPerPage ,xx.avg_page_space_used_in_percent AvgPctUsed ,xx.ghost_record_count ,xx.version_ghost_record_count from sys.dm_db_index_physical_stats ( db_id('MyDatabase') ,object_id('MyTable') ,null ,null ,'Detailed' ) xx inner join sys.objects ob on ob.object_id = xx.object_id inner join sys.indexes ind on ind.object_id = xx.object_id and ind.index_id = xx.index_id Use this to check if SQL thinks the row is as long as you think it is, or if there's extra space being used/wasted somewhere.
