[site]: datascience
[post_id]: 9975
[parent_id]: 6107
[tags]: 
I think one way to get a really basic level intuition behind convolution is that you are sliding K filters, which you can think of as K stencils, over the input image and produce K activations - each one representing a degree of match with a particular stencil. The inverse operation of that would be to take K activations and expand them into a preimage of the convolution operation. The intuitive explanation of the inverse operation is therefore, roughly, image reconstruction given the stencils (filters) and activations (the degree of the match for each stencil) and therefore at the basic intuitive level we want to blow up each activation by the stencil's mask and add them up. Another way to approach understanding deconv would be to examine the deconvolution layer implementation in Caffe, see the following relevant bits of code: DeconvolutionLayer ::Forward_gpu ConvolutionLayer ::Backward_gpu CuDNNConvolutionLayer ::Backward_gpu BaseConvolutionLayer ::backward_cpu_gemm You can see that it's implemented in Caffe exactly as backprop for a regular forward convolutional layer (to me it was more obvious after i compared the implementation of backprop in cuDNN conv layer vs ConvolutionLayer::Backward_gpu implemented using GEMM). So if you work through how backpropagation is done for regular convolution you will understand what happens on a mechanical computation level. The way this computation works matches the intuition described in the first paragraph of this blurb. However, I don't know how the learning of convolutional layers works. (I understand how simple MLPs learn with gradient descent, if that helps). To answer your other question inside your first question, there are two main differences between MLP backpropagation (fully connected layer) and convolutional nets: 1) the influence of weights is localized, so first figure out how to do backprop for, say a 3x3 filter convolved with a small 3x3 area of an input image, mapping to a single point in the result image. 2) the weights of convolutional filters are shared for spatial invariance. What this means in practice is that in the forward pass the same 3x3 filter with the same weights is dragged through the entire image with the same weights for forward computation to yield the output image (for that particular filter). What this means for backprop is that the backprop gradients for each point in the source image are summed over the entire range that we dragged that filter during the forward pass. Note that there are also different gradients of loss wrt x, w and bias since dLoss/dx needs to be backpropagated, and dLoss/dw is how we update the weights. w and bias are independent inputs in the computation DAG (there are no prior inputs), so there's no need to do backpropagation on those. (my notation here assumes that convolution is y = x*w+b where '*' is the convolution operation)
