[site]: stackoverflow
[post_id]: 496917
[parent_id]: 488033
[tags]: 
There are a few steps that you must take in order to successfully leverage WMI connectivity. The basics are you must allow remote management on the target box of course. If you can’t RDP into it, chances are, you can’t remote manage anything else. This can also include Windows firewall issues too. Make sure your request can even get in at all. Next, start simple. Can you even poll for the running processes on that box? Try to output all the running processes on the target box with System.Diagnostics.Process currentProcess = System.Diagnostics.Process.GetProcesses("machine-name"). If you can at least get some information on the box then the RPC message you are getting has to do with incorrect arguments being passed in, perhaps? Anyways, I recently wrote a web application that allowed the users to find a server on the LAN and kill a target process there or start a new one. I did it in C# so the code snippet below is just what I used. It's not the best but its working in production right now: public static class RemoteProcessAccess { public static void KillProcessByProcessID(string NameOfServer, string DomainName, string LogIn, string Password, int processID) { //#1 The vars for this static method #region /// ... string userName; string password; string machineName; string myDomain; Hashtable hs = new Hashtable(); ManagementScope mScope; ConnectionOptions cnOptions; ManagementObjectSearcher objSearcher; ManagementOperationObserver opsObserver; ManagementClass manageClass; DirectoryEntry entry; DirectorySearcher searcher; DirectorySearcher userSearcher; #endregion //#2 Set the basics sent into the method machineName = NameOfServer; myDomain = DomainName; userName = LogIn; password = Password; cnOptions = new ConnectionOptions(); cnOptions.Impersonation = ImpersonationLevel.Impersonate; cnOptions.EnablePrivileges = true; cnOptions.Username = myDomain + "\\" + userName; cnOptions.Password = password; mScope = new ManagementScope(@"\\" + machineName + @"\ROOT\CIMV2", cnOptions); //#3 Begin Connection to Remote Box mScope.Connect(); objSearcher = new ManagementObjectSearcher(String.Format("Select * from Win32_Process Where ProcessID = {0}", processID)); opsObserver = new ManagementOperationObserver(); objSearcher.Scope = mScope; string[] sep = { "\n", "\t" }; //#4 Loop through foreach (ManagementObject obj in objSearcher.Get()) { string caption = obj.GetText(TextFormat.Mof); string[] split = caption.Split(sep, StringSplitOptions.RemoveEmptyEntries); // Iterate through the splitter for (int i = 0; i 1) { string[] procDetails = split[i].Split('='); procDetails[1] = procDetails[1].Replace(@"""", ""); procDetails[1] = procDetails[1].Replace(';', ' '); switch (procDetails[0].Trim().ToLower()) { //You could look for any of the properties here and do something else, case "processid": int tmpProc = Convert.ToInt32(procDetails[1].ToString()); //if the process id equals the one passed in.... //(this is redundant since we should have limited the return //by the query where above, but we're paranoid here if (tmpProc.Equals(processID)) { obj.InvokeMethod(opsObserver, "Terminate", null); } break; }//end process ID switch... }//end our if statement... }//end our for loop... }//end our for each loop... }//end static method }
