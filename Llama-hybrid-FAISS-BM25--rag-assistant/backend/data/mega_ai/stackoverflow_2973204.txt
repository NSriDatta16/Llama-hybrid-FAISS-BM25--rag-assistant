[site]: stackoverflow
[post_id]: 2973204
[parent_id]: 2964357
[tags]: 
Ok, so here's what I did in the end: Leaving all scrolling and zooming up to UIScrollView, and handling page turning in the UIScrollViewDelegate's scrollViewDidEndDragging:willDecelerate: is almost a solution, except that this function is never called if the whole content is on-screen, so dragging / scrolling is not possible. Swipes in this case are handled in a ViewController's touchesBegan / touchesEnded functions, but for this to work, we need to make sure that the UIScrollView does not cancel these events. However, in other cases the UIScrollView should be able to cancel touches so that it can do zooming and scrolling. The UIScrollView should be able to cancel touches if: Scrolling is possible (and needed) because the whole content doesn't fit on screen (zoomScale > 1 in my case), OR The user touched the screen with two fingers, so that zooming in and out works. When scrolling is not possible, and the user single-touched the screen, then touches should not be cancelled, and touch events should be forwarded to the view controller. So I created a UIScrollView subclass. This subclass has a property pointing to the ViewController. Using the touchesXXX methods I keep track of the current touch count. I forward all touch events to the ViewController. And finally, I've overridden touchesShouldCancelInContentView:, and return NO when zoomScale
