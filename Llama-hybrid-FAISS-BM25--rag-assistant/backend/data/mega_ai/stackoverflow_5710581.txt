[site]: stackoverflow
[post_id]: 5710581
[parent_id]: 5658349
[tags]: 
For now I've worked around the issue by creating an EventSubscriber which delays persisted nested embedded documents, it looks like this: getDocument(); if($document instanceof Post){ $dm = $eventArgs->getDocumentManager(); $meta = $dm->getClassMetadata(get_class($document)); $this->addVersion($meta, $document); $this->clearVersions($meta, $document); } } /** * Move the temporary versions back onto the Posts and flush * * @param \Doctrine\ODM\MongoDB\Event\LifecycleEventArgs $eventArgs * @return void */ public function postPersist(LifecycleEventArgs $eventArgs) { $dm = $eventArgs->getDocumentManager(); $hasChanges = count($this->versions) > 0; foreach($this->versions as $oid => $value){ $post = $value['document']; $versions = $value['versions']; $meta = $dm->getClassMetadata(get_class($post)); $meta->setFieldValue($post, 'versions', $versions); unset($this->versions[$oid]); } if($hasChanges){ $dm->flush(); } } /** * Add versions to temporary storage * * @param \Doctrine\ODM\MongoDB\Mapping\ClassMetadata $meta * @param \Application\Blog\Domain\Document\Post $post * @return void */ private function addVersion(ClassMetadata $meta, Post $post) { $this->versions[spl_object_hash($post)] = array( 'document' => $post, 'versions' => $meta->getFieldValue($post, 'versions') ); } /** * Remove versions from a Post * * @param \Doctrine\ODM\MongoDB\Mapping\ClassMetadata $meta * @param \Application\Blog\Domain\Document\Post $post * @return void */ private function clearVersions(ClassMetadata $meta, Post $post) { $meta->setFieldValue($post, 'versions', null); } }
