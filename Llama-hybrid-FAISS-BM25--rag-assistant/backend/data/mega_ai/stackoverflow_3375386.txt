[site]: stackoverflow
[post_id]: 3375386
[parent_id]: 3372012
[tags]: 
Hey Alec, thanks for the reply. I've hacked a bit of a solution - it aint pretty but it does smoke test dodgy mappings across multiple db's In the set up I add the following: private List sessionKeys; [SetUp] public virtual void SetUp() { string[] mappingAssemblies = RepositoryTestsHelper.GetMappingAssemblies(); configuration = NHibernateSession.Init(new SimpleSessionStorage(), mappingAssemblies, new AutoPersistenceModelGenerator().Generate(), "../../../../app/Humanities.IBusiness.Web/NHibernate.config"); /*NEW CODE */ var configuration2 = NHibernateSession.AddConfiguration(DataGlobals.ROLES_DB_FACTORY_KEY, mappingAssemblies, new AutoPersistenceModelGenerator().Generate(), "../../../../app/Humanities.IBusiness.Web/NHibernateForRolesDb.config",null,null, null); sessionKeys = new List (); sessionKeys.Add(DataGlobals.DEFAULT_DB_KEY); sessionKeys.Add(DataGlobals.ROLES_DB_FACTORY_KEY); Then in the CanConfirmDatabaseMatchesMappings foreach (var entry in allClassMetadata) { bool found = false; foreach (string key in sessionKeys) { ISession session = NHibernateSession.CurrentFor(key); try { session.CreateCriteria(entry.Value.GetMappedClass(EntityMode.Poco)) .SetMaxResults(0).List(); found = true; } catch (Exception ex) { } } if (found == false) throw new MappingException("Mapping not found for " + entry.Key.ToString()); } Not sure if it's a full answer but better than nothing :) Any thoughts?
