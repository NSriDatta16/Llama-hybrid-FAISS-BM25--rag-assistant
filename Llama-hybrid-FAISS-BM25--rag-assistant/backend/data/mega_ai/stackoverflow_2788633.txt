[site]: stackoverflow
[post_id]: 2788633
[parent_id]: 2788473
[tags]: 
I can think of a few reasons - its far more common for the setter to be simple, but setters can be very useful in more complex situations: The underlying storage type is different from the exposed type This might be the case when you are creating a wrapper around some other object and want to hide the complexity Sometimes the conversion might be simple (double to int etc...) and sometimes it might be more complex (Xml to some strongly typed object). class ThingWrapper { public Thing Thing {get; set;} public int SomeProperty { get { return int.Parse(this.Thing.SomeProperty); } set { Thing.SomeProperty = value.ToString(); } } } You want to prevent a property from changing Perhaps you have some sort of object exposing a long-running background task which is run in another thread, and you wish to prevent the user from changing properties while that task is running. You need to detach from events You might have some object which exposes events that you subscribe to, and you also want to be able to set that object (for some reason). In this case you need to make sure that you detach your event handlers from the old object and reattach to the new object.
