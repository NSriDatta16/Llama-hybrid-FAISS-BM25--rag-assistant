[site]: stackoverflow
[post_id]: 3036859
[parent_id]: 3035656
[tags]: 
Depends. If those webapplications runs at physically the same webserver in the same servletcontainer, then just set it as a request attribute and forward the request to the other context: request.setAttribute("name", object); ServletContext app2 = getServletContext().getContext("app2"); app2.getRequestDispacher("servletUrl").forward(request, response); The other context will be able to obtain the object as follows: Object object = request.getAttribute("name"); This only requires a server setting that the contexts are accessible by each other. How to do this depends on the servletcontainer. In Tomcat for example, you just need to set crossContext attribute of the webapp's element to true . Then it will be available to other contexts. For other servers, consult its documentation. If those webapplications runs at physically different webserver, then there are several options: Convert to String and send as parameter. On retrieval, convert back from String. JSON is a nice format for this. Google Gson offers possibilities to convert between fullworthy Java objects and JSON and vice versa. If you're using GET and the request URI gets pretty long, over 2KB, then consider using POST instead of GET, else the URI may be truncated by the server. Pros: better reuseable service. Cons: hard to send binary data. See also: Converting JSON to Java . Send a multipart/form-data HTTP POST request using URLConnection or Apache HttpComponents Client as per RFC2388 and process it on the other side using Apache Commons FileUpload . Pros: standard specification, possible to send binary data. Cons: more code. See also: How to use URLConnection . Serialize the Java object, write it raw to the URLConnection#getOutputStream() using ObjectOutputStream and retrieve it raw from the HttpServletRequest#getInputStream() and unserialize it using ObjectInputStream . Pros: easy. Cons: not reuseable, tight coupled. See also: Object Streams and Lesson: Serialization .
