[site]: stackoverflow
[post_id]: 4308110
[parent_id]: 4307526
[tags]: 
You should look into Futures I think. In fact, you probably need a threadpool which simply queues threads when a max number of threads has been reached. Here is a small example involving futures: http://blog.tackley.net/2010/01/scala-futures.html I would also suggest that you don't pay too much attention to the context switching since you really can't do anything but rely on the underlying implementation. Of course a rule of thumb would be to keep the active threads around the number of physical cores, but as I noted above this could be handled by a threadpool with a fifo-queue. NOTE that I don't know if Actors in general or futures are implemented with this kind of pool. For thread pools, look at this: http://www.scala-lang.org/api/current/scala/concurrent/ThreadPoolRunner.html and maybe this: http://www.scala-lang.org/api/current/scala/actors/scheduler/ResizableThreadPoolScheduler.html Good luck EDIT Check out this piece of code using futures: import scala.actors.Futures._ object FibFut { def fib(i: Int): Int = if (i It showcases a very good point about futures, namely that you decide in which order to receive the results (as opposed to the normal mailbox-system which employs a fifo-system i.e. the fastest actor sends his result first).
