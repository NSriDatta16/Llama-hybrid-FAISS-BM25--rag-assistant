[site]: stackoverflow
[post_id]: 177885
[parent_id]: 
[tags]: 
Looking for something similar to offsetof() for non-POD types

I'm looking for a way to obtain offsets of data members of a C++ class which is of non-POD nature. Here's why: I'd like to store data in HDF5 format, which seems most suited for my kind of material (numerical simulation output), but it is perhaps a rather C-oriented library. I want to use it through the C++ interface, which would require me to declare storage types like so (following documentation from here and here (section 4.3.2.1.1)): class example { public: double member_a; int member_b; } //class example H5::CompType func_that_creates_example_CompType() { H5::CompType ct; ct.insertMember("a", HOFFSET(example, member_a), H5::PredType::NATIVE_DOUBLE); ct.insertMember("b", HOFFSET(example, member_b), H5::PredType::NATIVE_INT); return ct; } //func_that_creates_example_CompType where HOFFSET is a HDF-specific macro that uses offsetof. The problem is of course, that as soon as the example-class becomes it little bit more featureful, it is no longer of POD-type, and so using offsetof will give undefined results. The only workaround I can think of is to first export the data I want to store to a simpler struct, then pass that to HDF. That does however involve data copying, which is exactly what HDF is trying to avoid (and why they have this CompType which enables the library to reach into your objects to save their data to file). So I was hoping you'd have better ideas. Ideally I'd be looking for a portable workaround for this problem, but if short of that you could give me an idea that works on x86 and x86_64 with GCC I'd already be immensely grateful. ----- appended later: ----- Greg Hewgill suggested below to store the data in a simple struct, then build the actual class by inheriting from that. For HDF specifically, I think that may not practically work. A more elaborate usage scenario than above: class base_pod { public: double member_a; int member_b; }; //class base_pod class derived_non_pod : private base_pod { public: //the following method is only virtual to illustrate the problem virtual double get_member_a() {return member_a; } }; //class derived_non_pod class that_uses_derived_non_pod { public: void whatever(); private: derived_non_pod member_c; }; //class that_uses_derived_non_pod Now, when we're storing instances of the class that_uses_derived_non_pod, we cannot describe its memory layout as if it had a base_pod as member_c. This would get the offsets wrong because derived_non_pod adds funky stuff (like a virtual function table, I guess?).
