[site]: stackoverflow
[post_id]: 893323
[parent_id]: 893196
[tags]: 
I don't think you can do it. The only approach that has even a remote chance of working would be to create some kind of factory method that created the type and returned it. Basically your generic type becomes a base class and IL is dynamically written creating a concrete class that inherits from the generic but with the new property added in. Of course the object that is returned would be really anonymous and you'd only be able to access it through reflection since you wouldn't have a type to actually cast to: public static class CrazyFactory { public static object CreateTypedComboList () { //magic happens return object; } } Using it would then require object userCombo = CrazyFactory.CreateTypedComboList (); PropertyInfo selectedUserProperty = userCombo.GetType().GetProperty("SelectedUser"); selectedUserProperty.SetValue(userCombo, user); Which is hardly a step up from a simple T SelectedItem property. From a brief look it appears that this type of thing will be easier when c# 4.0 brings us dynamic types. By implementing the IDynamicObject interface it will be possible to catch all calls to undefined properties and handle them so you could use logic like the following: public override MetaObject GetMember(GetMemberAction action, MetaObject[] args) { //not sure on the real property name here... string actionName = action.Name; if (actionName = "Selected" + typeof(T).Name) { return SelectedItem; //in some MetaObject wrapper } } I've been following this article and haven't touched dynamics myself yet, but it certainly appears like what you want is possible. I still wouldn't do it though - you won't get Intellisense and it seems like a fragile and complicated method for defining functionality.
