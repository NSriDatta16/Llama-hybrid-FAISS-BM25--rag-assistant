[site]: stackoverflow
[post_id]: 1262465
[parent_id]: 
[tags]: 
Hibernate - How to cascade delete on detached objects

I have a hibernate object that gets detached and transferred to a thick java swing client using EJBs. The object is then modified in some way and returned to the server where the server then updates the modified object to the database. Everything works well for properties that change, but I am having a problem on how to delete a many-to-one mapping. For instance, given the following mapping: patient_id_seq ... Say I have a patient object that is sent to the client. The user has previously added an address. There can only be one address per patient. On the client if the user removes the address, I call setAddress(null) on the patient object before returning to the server. When I get to the server it saves the address_id field as null, but leaves the address record in the database. I understand why it is doing that. I am only breaking one end of the relationship. Preferably I would use delete-orphan . However, according to the Hibernate documentation, delete-orphan is not available for many-to-one mappings. The proper procedure is to call on the server (pseudocode): Address address = patient.getAddress(); session.delete(address); patient.setAddress(null); The problem with this pattern is that if I want to stick to a process of simply passing back the Patient object I want saved, I have no way of knowing if it had an address that needs to be deleted. I have to do some less-than-elegant workarounds to solve this problem, such as querying the database to see if there was an Address and removing it if it is null in the passed object, or creating setDeleteAddress(boolean) , getDeleteAddress() methods in Patient class and setting those on the client side if the user wants to remove the address. Another alternative would be to make the association a one-to-many between Patient and Address. Then I could use delete-orphan . However, since it is really a one-to-one relationship, I would need to put some crazy getter/setter in the Patient class like this so I don't litter my code with collection references when there isn't really a collection: public Address getAddress() { if(addresses != null && addresses.size() > 0) return addresses.get(0); else return null; } Is there a better way to address this issue? How have you handled removing an entity on detached objects?
