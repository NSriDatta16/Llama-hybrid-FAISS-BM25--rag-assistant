[site]: stackoverflow
[post_id]: 579500
[parent_id]: 578729
[tags]: 
Robert Rossney's post made me think it's probably less work than I thought. So here's a very rough attempt. It handles the following: If it is unable to read a property, it prints the exception as the value Cyclic references and multiple occurrences. It associates an ID with each element; if an element appears twice, it just points the ref ID. The Ref ID is unique to the object graph (I should probably use a GUID, but this suits my purposes). It has no problems with derived types It requires no attributes or specific constructors or other nonsense It can handle read-only properties Here's an example of the output (in my test objects, the "Currency" product on the Order throws an exception). Paul Stovell Paul Stovell Apples 27.30 Something bad happened Pears 17.85 Something bad happened Here's the sample object model and usage: static void Main(string[] args) { var customer = new Customer(); customer.FirstName = "Paul"; customer.LastName = "Stovell"; customer.Orders.Add(new Order(customer) { Price = 27.30M, SKU = "Apples"}); customer.Orders.Add(new Order(customer) { Price = 17.85M, SKU = "Pears"}); customer.Orders.Add(customer.Orders[0]); var output = new StringWriter(); var writer = new XmlTextWriter(output); writer.Formatting = Formatting.Indented; WriteComplexObject("Customer", customer, writer); Console.WriteLine(output.ToString()); Console.ReadKey(); } class Customer { private readonly List _orders = new List (); public Customer() { } public string FirstName { get; set; } public string LastName { get; set; } public string FullName { // Read-only property test get { return FirstName + " " + LastName; } } public List Orders { // Collections test get { return _orders; } } } class Order { private readonly Customer _customer; public Order(Customer customer) { _customer = customer; } public string SKU { get; set; } public decimal Price { get; set; } public string Currency { // A proprty that, for some reason, can't be read get { throw new Exception("Something bad happened"); } } public Customer Customer { get { return _customer; } } } Here's the implementation: public static void WriteObject(string name, object target, XmlWriter writer) { WriteObject(name, target, writer, new List (), 0, 10, -1); } private static void WriteObject(string name, object target, XmlWriter writer, List recurringObjects, int depth, int maxDepth, int maxListLength) { var formatted = TryToFormatPropertyValueAsString(target); if (formatted != null) { WriteSimpleProperty(name, formatted, writer); } else if (target is IEnumerable) { WriteCollectionProperty(name, (IEnumerable)target, writer, depth, maxDepth, recurringObjects, maxListLength); } else { WriteComplexObject(name, target, writer, recurringObjects, depth, maxDepth, maxListLength); } } private static void WriteComplexObject(string name, object target, XmlWriter writer, List recurringObjects, int depth, int maxDepth, int maxListLength) { if (target == null || depth >= maxDepth) return; if (recurringObjects.Contains(target)) { writer.WriteStartElement(name); writer.WriteAttributeString("Ref", (recurringObjects.IndexOf(target) + 1).ToString()); writer.WriteEndElement(); return; } recurringObjects.Add(target); writer.WriteStartElement(name); writer.WriteAttributeString("Ref", (recurringObjects.IndexOf(target) + 1).ToString()); foreach (var property in target.GetType().GetProperties()) { var propertyValue = ReadPropertyValue(target, property); WriteObject(property.Name, propertyValue, writer, recurringObjects, depth + 1, maxDepth, maxListLength); } writer.WriteEndElement(); } private static object ReadPropertyValue(object target, PropertyInfo property) { try { return property.GetValue(target, null); } catch (Exception ex) { return ReadExceptionMessage(ex); } } private static string ReadExceptionMessage(Exception ex) { if (ex is TargetInvocationException && ex.InnerException != null) return ReadExceptionMessage(ex.InnerException); return ex.Message; } private static string TryToFormatPropertyValueAsString(object propertyValue) { var formattedPropertyValue = null as string; if (propertyValue == null) { formattedPropertyValue = string.Empty; } else if (propertyValue is string || propertyValue is IFormattable || propertyValue.GetType().IsPrimitive) { formattedPropertyValue = propertyValue.ToString(); } return formattedPropertyValue; } private static void WriteSimpleProperty(string name, string formattedPropertyValue, XmlWriter writer) { writer.WriteStartElement(name); writer.WriteValue(formattedPropertyValue); writer.WriteEndElement(); } private static void WriteCollectionProperty(string name, IEnumerable collection, XmlWriter writer, int depth, int maxDepth, List recurringObjects, int maxListLength) { writer.WriteStartElement(name); var enumerator = null as IEnumerator; try { enumerator = collection.GetEnumerator(); for (var i = 0; enumerator.MoveNext() && (i I would still be interested to know if there are more tried and tested solutions.
