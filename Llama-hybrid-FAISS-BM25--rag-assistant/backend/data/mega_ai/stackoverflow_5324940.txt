[site]: stackoverflow
[post_id]: 5324940
[parent_id]: 5324758
[tags]: 
The problem is not in your code-behind, but in your XAML. Somewhere you do this: DragCompleted="{Binding AudioSliderChangedCommand}" This instructs the XAML deserializer to attach the AudioSliderChangedCommand handler to the DragCompleted event. However, AudioSliderChangedCommand is not a method with the appropriate signature (which can be attached as a handler) and it is not in your View class. And finally, you can't use Binding for event handlers. To solve this, the simplest solution is to do this in your View : private void DragCompletedEventHandler(object sender, DragCompletedEventArgs e) { var viewModel = (YourViewModelType)this.DataContext; viewModel.OnAudioSliderChanged(this, e); } and also change DragCompleted="{Binding AudioSliderChangedCommand}" to DragCompleted="DragCompletedEventHandler" in your XAML. This is how the above will work: In your View, when DragCompleted is raised, the method View.DragCompletedEventHandler will be called This method will get hold of the AudioSliderChangedCommand event (see note below) from the ViewModel and raise it, passing the original event args Important note You seem to be confused about events, event handlers and commands. Your code as it stands is misleading. AudioSliderChangedCommand is an event , but the name suggests it's an ICommand . The appropriate name would be AudioSliderChanged . Also, the appropriate MVVM way of doing this is by using some flavor of DelegateCommand (all decent MVVM frameworks have one; I used the class name for the implementation in Prism). Then, assuming that AudioSliderChangedCommand is indeed a command, the code-behind in your View would be: private void DragCompletedEventHandler(object sender, DragCompletedEventArgs e) { var viewModel = (YourViewModelType)this.DataContext; viewModel.AudioSliderChangedCommand.Execute(); } It would also be possible to do without any code-behind at all by using some flavor of "event to command" attached behavior.
