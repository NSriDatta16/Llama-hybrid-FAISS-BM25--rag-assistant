[site]: stackoverflow
[post_id]: 659447
[parent_id]: 659231
[tags]: 
The reason for the compiler error is a circular dependency. Each of your operator=() functions require knowledge of the operator=() function inside the other class, so no matter which order you define your classes in, there will always be an error. Here is one way to sort it out. It isn't very elegant, but it will do what you want: class A; class B; A & set_equal(A & a, const B & b); B & set_equal(B & a, const A & a); class A { private: int x; public: A & operator=(const B & b) { return set_equal(*this, b); } friend B & set_equal(B & b, const A & a); friend A & set_equal(A & a, const B & b); }; class B { private: int y; public: B & operator=(const A & a) { return set_equal(*this, a); } friend A & set_equal(A & a, const B & b); friend B & set_equal(B & b, const A & a); }; A & set_equal(A & a, const B & b) { a.x = b.y; return a; } B & set_equal(B & b, const A & a) { b.y = a.x; return b; } You may also be able to solve this problem with inheritance. edit: here is an example using inheritance. This will work if the copying procedure only needs access to some common data shared by both A and B, which would seem likely if the = operator is to have any meaning at all. class A; class B; class common { protected: int x; void copyFrom(const common & c) { x = c.x; } }; class A : public common { public: A & operator=(const common & c) { copyFrom(c); return *this; } }; class B : public common { public: B & operator=(const common & c) { copyFrom(c); return *this; } };
