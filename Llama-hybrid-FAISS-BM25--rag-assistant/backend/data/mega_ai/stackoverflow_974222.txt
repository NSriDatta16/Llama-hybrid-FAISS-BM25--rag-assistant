[site]: stackoverflow
[post_id]: 974222
[parent_id]: 974142
[tags]: 
In .NET terms, I think what you are describing is the Delegate - and it exists in all of .NET, not just C#. I'm not sure that a "closure" would a "type" in the same was as a comparer/predicate/transformer, since in C# terms a closure is simply an implementation detail but can be any of those three. In .NET, delegates are used in two main ways: as the eventing mechanism to provide functional-style programming The first is important, but it sounds like you are more interested in the second. In reality, they operate much like single-method interfaces... consider: List vals = new List { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; List evenVals = vals.FindAll(i => i % 2 == 0); // predicate List valsAsStrings = vals.ConvertAll(i => i.ToString()); // transformer // sort descending vals.Sort((x, y) => y.CompareTo(x)); // comparer A closure is more where we bring additional scope from outside the delegate into the delegate: int max = int.Parse(Console.ReadLine()); // perhaps 6 List limited = vals.FindAll(i => i here the max is captured into the delegate as a closure. Re "Are classes within the framework prepaired for this?" - many are, and LINQ goes a long way to allowing this even wider. LINQ provides extension methods over (for example) all of IEnumerable - meaning that collections without delegate-based access aquire them for free: int[] data = { 1,2,3,4,5,6,7,8,9 }; var oddData = data.Where( i => i % 2 == 1 ); var descending = data.OrderBy(i => -i); var asStrings = data.Select(i => i.ToString()); Here the Where and OrderBy methods are LINQ extension methods that take delegates.
