[site]: stackoverflow
[post_id]: 4013289
[parent_id]: 4013261
[tags]: 
std::vector can dynamically resize. The way it does this is to hold more space than is required. Once you hit the reserved capacity a larger block of data needs to be reserved (depends on implementation, but often the capacity of the new block is double the previous size). The data is then copied across to the new location, which is why the address of the first element changes. Provided you don't add more data to your vector you don't have to worry about a pointer to data in the vector being invalidated. You can anticipate when a further push_back() will trigger a resize by checking if vint.capacity()==vint.size(). You can also avoid using an invalidated pointer by always using the up-to-date one via &vint[0] (or &vint.at() to get the range checking) rather than copying it. If you know that you are going to insert a number of new items, you can ensure you will have enough capacity by using reserve() to preallocate the space (if the current capacity is less than what's requested). But be aware that you don't want to do this piecemeal - for instance vint.reserve(vint.size() + 2000); for(int i=0; i would be fine, but for(int i=0; i would be a performance drag since you're repeatedly asking the OS for more memory and incurring an ever-larger copy operation with each iteration.
