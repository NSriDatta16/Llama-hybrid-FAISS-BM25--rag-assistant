[site]: stackoverflow
[post_id]: 2824067
[parent_id]: 2823485
[tags]: 
Doesn't a typedef help? e.g. class A : public B { typedef B Base; friend Base::Base(); int x; }; EDIT: The Final Committee Draft for C++0x includes the following language in section 3.4.3.1 [ class.qual ]: In a lookup in which the constructor is an acceptable lookup result and the nested-name-specifier nominates a class C : if the name specified after the nested-name-specifier , when looked up in C , is the injected-class-name of C (Clause 9), or if the name specified after the nested-name-specifier is the same as the identifier or the simple-template-id ’s template-name in the last component of the nested-name-specifier , the name is instead considered to name the constructor of class C . Sounds like the name ( Base ) specified after the nested-name-specifier ( Base:: ) is the same as the identifier in the last component of the nested-name-specifier , so this code does name a constructor. But I can't reconcile this with section 12.1 [ class.ctor ]: Because constructors do not have names, they are never found during name lookup Oh really? How's that language in 3.4.3.1 work again? A typedef-name shall not be used as the class-name in the declarator-id for a constructor declaration. This seems pretty clear, except that section 12.1 appears to discuss only the introducing declaration of a constructor as paragraph 1 excludes the nested-name-specifier , friend , and using . If it does apply to friend declarations, it also appears to forbid friend Base::B(); A special declarator syntax using an optional sequence of function-specifiers (7.1.2) followed by the constructor’s class name followed by a parameter list is used to declare or define the constructor. Those function-specifiers are inline , virtual , explicit , and constructors can't be virtual anyway.
