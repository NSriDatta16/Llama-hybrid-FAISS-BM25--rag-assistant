[site]: stackoverflow
[post_id]: 2907938
[parent_id]: 2906940
[tags]: 
I deal with this by not doing it the way you describe. If I need to present a Foo object and its related Bar objects in the view, the FooViewModel will generally implement a Bars property of type ObservableCollection . Note that this is irrespective of whether or not the underlying Foo class has a Bars property of type IEnumerable . The Foo class might not. The application might not even need to be able to iterate over all of the Bar objects for a Foo , except in the UI. Edit When my view is a simple representation of the application's object model, I pretty much do things as you do in your sample. The code in my constructor is generally a bit more compact: _Bars = new ObservableCollection ( _Foo.Bars.Select(x => new BarViewModel(x))); but it's essentially the same thing. But this assumes that Foo actually exposes a Bars property. It might not. Or maybe only some Bar objects should appear in the view. Or maybe they should appear intermingled with other objects, and the FooViewModel should expose a CompositeCollection of some kind. The point I'm making is that the view model is a model of the view . This doesn't necessarily have a direct correspondence to the underlying object model. To pick a simple example: My program may give the user a way of putting items into five different categories by dragging and dropping them into five different ListBox controls. Ultimately, doing this sets a Category property on the Item object. My view model is going to have a collection of CategoryViewModel objects, each with a property of type ObservableCollection , so that dragging items back and forth between collections is simple to implement. The thing is, there may not even be a Category class in the application's object model, let alone a collection of Category objects. Item.Category might just be a property of type string . The CategoryViewModel isn't mirroring the application's object model. It only exists to support the view in the UI.
