[site]: stackoverflow
[post_id]: 1692438
[parent_id]: 1248815
[tags]: 
I've once published a blog post on this topic. The blog is now defunct but the article is included in full below. The basic idea is to reduce the requirement for an exact calculation in favor of "95% percent of responses take 500ms-600ms or less" (for all exact percentiles of 500ms-600ms). As we’ve recently started feeling that response times of one of our webapps got worse, we decided to spend some time tweaking the apps’ performance. As a first step, we wanted to get a thorough understanding of current response times. For performance evaluations, using minimum, maximum or average response times is a bad idea: “The ‘average’ is the evil of performance optimization and often as helpful as ‘average patient temperature in the hospital'” ( MySQL Performance Blog ). Instead, performance tuners should be looking at the percentile : “A percentile is the value of a variable below which a certain percent of observations fall” (Wikipedia). In other words: the 95th percentile is the time in which 95% of requests finished. Therefore, a performance goals related to the percentile could be similar to “The 95th percentile should be lower than 800 ms”. Setting such performance goals is one thing, but efficiently tracking them for a live system is another one. I’ve spent quite some time looking for existing implementations of percentile calculations (e.g. here or here ). All of them required storing response times for each and every request and calculate the percentile on demand or adding new response times in order. This was not what I wanted. I was hoping for a solution that would allow memory and CPU efficient live statistics for hundreds of thousands of requests. Storing response times for hundreds of thousands of requests and calculating the percentile on demand does neither sound CPU nor memory efficient. Such a solution as I was hoping for simply seems not to exist. On second thought, I came up with another idea: For the type of performance evaluation I was looking for, it’s not necessary to get the exact percentile. An approximate answer like “the 95th percentile is between 850ms and 900ms” would totally suffice. Lowering the requirements this way makes an implementation extremely easy, especially if upper and lower borders for the possible results are known. For example, I’m not interested in response times higher than several seconds – they are extremely bad anyway, regardless of being 10 seconds or 15 seconds. So here is the idea behind the implementation: Define any random number of response time buckets (e.g. 0-100ms , 100-200ms , 200-400ms , 400-800ms , 800-1200ms , …) Count number of responses and number of response each bucket (For a response time of 360ms, increment the counter for the 200ms – 400ms bucket) Estimate the n-th percentile by summing counter for buckets until the sum exceeds n percent of the total It’s that simple. And here is the code . Some highlights: public void increment(final int millis) { final int i = index(millis); if (i 100.0) { throw new IllegalArgumentException("percentile must be between 0.0 and 100.0, was " + percentile); } for (final Percentile p : this) { if (percentile - p.getPercentage() This approach only requires two int values (= 8 byte) per bucket, allowing to track 128 buckets with 1K of memory. More than sufficient for analysing response times of a web application using a granularity of 50ms). Additionally, for the sake of performance, I’ve intentionally implemented this without any synchronization(e.g. using AtomicIntegers), knowing that some increments might get lost. By the way, using Google Charts and 60 percentile counters, I was able to create a nice graph out of one hour of collected response times:
