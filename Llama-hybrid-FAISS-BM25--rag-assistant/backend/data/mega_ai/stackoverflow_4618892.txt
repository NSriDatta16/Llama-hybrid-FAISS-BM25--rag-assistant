[site]: stackoverflow
[post_id]: 4618892
[parent_id]: 
[tags]: 
basic openGL, vertex buffers and pyglet

Edit: rotoglup found the problems in my code, adding the shaders I had removed completed the solution. See my answer below for the correct code (with shaders). Hi all ! I'm trying to learn some basics of modern OpenGL from this tutorial . I'd like to do it with python/pyglet instead of C++ though. I know pyglet can abstract much of the low level OpenGL away; I want to understand some of the basics before moving on to hiding them behind layers of abstraction though. My problem is extremely simple: the code below only draws a single point instead of the 3 I am expecting. My code is, as far as I can tell, identical to the C++ in the tutorial, except for the removal of vertex and fragment shaders (done via gletools in python), which appears to make no difference to my problem. Simplifying things to a single point shows behaviour I do not understand (the first coordinate appears to be the only one that affects anything), leading me back to my belief that I've simply failed to understand something very basic about either pyglet, OpenGL, or even 3D in general :p Here's the relevant code: import pyglet from pyglet.gl import * window = pyglet.window.Window() positionBufferObject = GLuint() vao = GLuint() vertexPositions = [0.0, 0.0, 0.0, 0.25, 0.0, 0.0, 1.75, 1.75, 0.0] vertexPositionsGl = (GLfloat * len(vertexPositions))(*vertexPositions) @window.event def on_draw(): glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject) glEnableVertexAttribArray(0) glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0) glDrawArrays(GL_POINTS, 0, 3) glDisableVertexAttribArray(0) glGenBuffers(1, positionBufferObject) glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject) glBufferData(GL_ARRAY_BUFFER, len(vertexPositionsGl)*4, vertexPositionsGl, GL_STATIC_DRAW) glBindBuffer(GL_ARRAY_BUFFER, 0) glClearColor(0.0, 0.0, 0.0, 0.0) pyglet.app.run()
