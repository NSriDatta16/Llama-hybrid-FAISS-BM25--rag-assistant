[site]: stackoverflow
[post_id]: 2153014
[parent_id]: 2152845
[tags]: 
You fist variant is the correct one as long as the specific matter of taking the address is considered. There are no restrictions on taking the address of member functions of local classes. The proper syntax is the usual &NestedClass::someFunction ans that's it. You can try saving it in an intermediate pointer in your code void (NestedClass::*ptr)() = &NestedClass::someFunction; and I'm sure your compiler will accept it. However, the problem I suspect exists in your code has absolutely nothing to do with the proper way of taking the address of a member function. It is rather about the way the first parameter of setupCallback is declared. Since you say it works with &SomeClass::someFunction as the first argument, I'd expect setupCallback to be declared as void setupCallback(void (SomeClass::*cb)(), SomeClass *p); // one possibility i.e. it is hardcoded to expect a pointer to a member of SomeClass specifically. You cannot supply a pointer to a member of NestedClass instead. NestedClass is completely unrelated to SomeClass and pointers to members of NestedClass are completely incompatible with pointers to members of SomeClass . This is why it won't compile. Unless there's something you are not showing us (like setupCallback being a function template maybe? Or overloaded for different parameter types?), what you are trying to do is simply impossible to achieve regardless of how you take the member address, as long as NestedClass remains unrelated to SomeClass . Function setupCallback is designed to work with SomeClass and SomeClass only. Provide more information about setupCallback . How is it declared? Note that if the setupCallback is declared as a function template parametrized by class type, as in template void setupCallback(void (T::*cb)(), T* p); then you won't be able to use the local class NestedClass as template argument for parameter T . In this case the fact that your NestedClass has no linkage does indeed come into play. But, again, it has nothing to do with taking the member address, but rather caused by the fact that classes with no linkage cannot be used as template arguments in C++.
