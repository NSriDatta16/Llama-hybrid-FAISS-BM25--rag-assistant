[site]: stackoverflow
[post_id]: 1707290
[parent_id]: 9033
[tags]: 
C# + CLR: Thread.MemoryBarrier : Most people wouldn't have used it and there is some inaccurate information on MSDN. But if you know intricacies then you can do nifty lock-free synchronization. volatile, Thread.VolatileRead, Thread.VolatileWrite : There are very very few people who gets the use of these and even fewer who understands all the risks they avoid and introduce :). ThreadStatic variables: There was only one situation in past few years I've found that ThreadStatic variables were absolutely god send and indispensable. When you want to do something for entire call chain, for example, they are very useful. fixed keyword: It's a hidden weapon when you want to make access to elements of large array almost as fast as C++ (by default C# enforces bound checks that slows down things). default(typeName) keyword can be used outside of generic class as well. It's useful to create empty copy of struct. One of the handy feature I use is DataRow[columnName].ToString() always returns non-null value. If value in database was NULL, you get empty string. Use Debugger object to break automatically when you want developer's attention even if s/he hasn't enabled automatic break on exception: #if DEBUG if (Debugger.IsAttached) Debugger.Break(); #endif You can alias complicated ugly looking generic types so you don't have to copy paste them again and again. Also you can make changes to that type in one place. For example, using ComplicatedDictionary = Dictionary >; ComplicatedDictionary myDictionary = new ComplicatedDictionary();
