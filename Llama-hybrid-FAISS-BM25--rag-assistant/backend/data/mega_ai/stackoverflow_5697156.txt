[site]: stackoverflow
[post_id]: 5697156
[parent_id]: 5696027
[tags]: 
As Jamie noted, a pan gesture recognizer is probably the way to go. The code would look something like what follows. The button's view controller might add a gesture recognizer to the button (possibly in viewDidLoad ) as follows: UIPanGestureRecognizer *pangr = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)]; [myButton addGestureRecognizer:pangr]; [pangr release]; And, the view controller would have the following target method to handle the gesture: - (void)pan:(UIPanGestureRecognizer *)recognizer { if (recognizer.state == UIGestureRecognizerStateChanged || recognizer.state == UIGestureRecognizerStateEnded) { UIView *draggedButton = recognizer.view; CGPoint translation = [recognizer translationInView:self.view]; CGRect newButtonFrame = draggedButton.frame; newButtonFrame.origin.x += translation.x; newButtonFrame.origin.y += translation.y; draggedButton.frame = newButtonFrame; [recognizer setTranslation:CGPointZero inView:self.view]; } } CORRECTED as per rohan-patel's comment. In the previously posted code , the x and y coordinate's of the origin of the button's frame were set directly. It was incorrect as: draggedButton.frame.origin.x += translation.x . A view's frame can be changed, but the frame's components cannot be changed directly.
