[site]: stackoverflow
[post_id]: 1204901
[parent_id]: 1204529
[tags]: 
The BackgroundWorker class will issue it's callbacks on the creating thread, this is extremely handy for UI tasks as you don't need to do the extra check on InvokeRequired followed by Invoke() or BeginInvoke(). The downside is that if your creating code is blocking or in a tight loop your callbacks are queued up. The solution is to manage your threads yourself. You've already shown that you know how to create a thread manually, although you might want to look at the ThreadPool topic for more information on doing it. UPDATE: here's a working sample based on feedback that uses a Queue and a custom SingletonWorker thread. public partial class Form1 : Form { public Form1() { InitializeComponent(); SingletonWorker.ProgressHandler = Progress; SingletonWorker.CompleteHandler = Completed; } private void button1_Click( object sender, EventArgs e ) { // this is based on an app requirement, seems odd but I'm sure there's a reason :) Thread thread = new Thread( AddTasks ); thread.Start(); } private void AddTasks() { for ( int i = 0; i ( AddToLog ), message ); return; } textBox1.Text += DateTime.Now + " " + message + System.Environment.NewLine; textBox1.Select( textBox1.Text.Length, 0 ); textBox1.ScrollToCaret(); } private void Progress( string message, int percentComplete ) { AddToLog( String.Format( "{0}%, {1}", percentComplete, message ) ); } private void Completed( string message ) { AddToLog( message ); } } public class Task { public int NumberToWorkOn { get; set; } } public static class SingletonWorker { private static readonly Thread Worker; private static readonly Queue Tasks; // assume params are 'message' and 'percent complete' // also assume only one listener, otherwise use events public static Action ProgressHandler; public static Action CompleteHandler; static SingletonWorker() { Worker = new Thread( Start ); Tasks = new Queue (); Worker.Start(); } private static Task GetNextTask() { lock( Tasks ) { if ( Tasks.Count > 0 ) return Tasks.Dequeue(); return null; } } public static void AddTask( Task task ) { lock( Tasks ) { Tasks.Enqueue( task ); } } private static void Start() { while( true ) { Task task = GetNextTask(); if( task == null ) { // sleep for 500ms waiting for another item to be enqueued Thread.Sleep( 500 ); } else { // work on it ProgressHandler( "Starting on " + task.NumberToWorkOn, 0 ); Thread.Sleep( 1000 ); ProgressHandler( "Almost done with " + task.NumberToWorkOn, 50 ); Thread.Sleep( 1000 ); CompleteHandler( "Finished with " + task.NumberToWorkOn ); } } } }
