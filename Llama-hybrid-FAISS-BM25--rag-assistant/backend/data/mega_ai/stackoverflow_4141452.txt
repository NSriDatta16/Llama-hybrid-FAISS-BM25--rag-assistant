[site]: stackoverflow
[post_id]: 4141452
[parent_id]: 
[tags]: 
Efficient way of determining minimum field size required to store variances in user input

Sorry about the clumsy title; I couldn't find a bit way of expressing what I'm trying to do. I am getting an input from the user of multiple 32-bit integers. For example, the user may enter the following values (showing in hex for ease of explanation): 0x00001234 0x00005678 0x0000abcd In this particular case, the first 2 bytes of each input is constant, and the last 2 bytes are variable. For efficiency purposes, I could store 0x0000 as a single constant, and create a vector of uint16_t values to store the variable portion of the input ( 0x1234 , 0x5678 , 0xabcd ). Now let's say the user enters the following: 0x00000234 0x56780000 0x00001000 In this case I would need a vector of uint32_t values to store the variable portion of the input as each value affects different bytes. My current thought is to do the following: uint32_t myVal = 0; myVal |= input1; myVal |= input2; // ... And then at the end find the distance between the first and last "toggled" (i.e. 1 ) bit in myVal . The distance will give me required field size for the variable portion of all of the inputs. However, this doesn't sound like it would scale well for a large number of user inputs. Any recommendations about an elegant and efficient way of determining this? Update: I simplified the problem in my above explanation. Just to be clear, I am not doing this to save memory (I have better things to do than to try and conserve a few bytes and this isn't for optimization purposes). In summary, component A provides component B in my system with values. Sometimes these values are 128-bit, but component B only supports 32-bit values. If the variable portion of the 128-bit value can be expressed with a 32-bit value, I can accept it. Otherwise I will need to reject it with an error. I'm not in a position to modify component B to allow 128-bit values, or modify component A to prevent its use of 128-bit values (there are hardware limitations here too).
