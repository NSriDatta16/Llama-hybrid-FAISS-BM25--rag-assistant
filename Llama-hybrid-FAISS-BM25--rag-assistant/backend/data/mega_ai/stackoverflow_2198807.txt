[site]: stackoverflow
[post_id]: 2198807
[parent_id]: 
[tags]: 
Table View Populating all cells with last xml entry iphone

Im trying to parse XML (which seems ok) and populate a Table View on Iphone. I'm working from apples siesmec examples. My XML looks something like this and has about 10 entries going from artist1 to artist10 42 artist1 http://address.com/avatar_42.jpg If I put in breakpoints I can see all of the correct names but when the parsing is finished all 10 cells in my table say "artist10: The Code for the xml is in the file as the table view controller. Can you see anything thats glaring a stupid mistake? #pragma mark Parser constants // Limit the number of parsed earthquakes to 50. static const const NSUInteger kMaximumNumberOfEarthquakesToParse = 50; static NSUInteger const kSizeOfEarthquakeBatch = 10; // Reduce potential parsing errors by using string constants declared in a single place. static NSString * const kArtistName = @"artistname"; static NSString * const kEntryElementName = @"promo"; static NSString *const kEntryElementID =@"id"; static NSString *const kEntryElementImg=@"img"; - (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict { if (parsedPromoListCounter >= kMaximumNumberOfEarthquakesToParse) { // Use the flag didAbortParsing = YES; [parser abortParsing]; } if ([elementName isEqualToString:kEntryElementName]) { PromoListItem *promoitem = [[PromoListItem alloc] init]; self.currentPromoListObject = promoitem; [promoitem release]; } else if ([elementName isEqualToString:kEntryElementImg]) { //nothing for now } else if ([elementName isEqualToString:kArtistName] || [elementName isEqualToString:kEntryElementImg] || [elementName isEqualToString:kEntryElementID]) { accumulatingParsedCharacterData = YES; // The mutable string needs to be reset to empty. [currentParsedCharacterData setString:@""]; } } - (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName { if ([elementName isEqualToString:kEntryElementName]) { [self.currentParseBatch addObject:self.currentPromoListObject]; parsedPromoListCounter++; if (parsedPromoListCounter % kSizeOfEarthquakeBatch == 0) { [self performSelectorOnMainThread:@selector(addPromosToList:) withObject:self.currentParseBatch waitUntilDone:NO]; self.currentParseBatch = [NSMutableArray array]; } } else if ([elementName isEqualToString:kArtistName]) { self.currentPromoListObject.artistName=self.currentParsedCharacterData; } else if ([elementName isEqualToString: kEntryElementID]) { self.currentPromoListObject.artistID = self.currentParsedCharacterData; } else if ([elementName isEqualToString:kEntryElementImg]) { self.currentPromoListObject.imgLink=self.currentParsedCharacterData; } // Stop accumulating parsed character data. We won't start again until specific elements begin. accumulatingParsedCharacterData = NO; } - (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string { if (accumulatingParsedCharacterData) { // If the current element is one whose content we care about, append 'string' // to the property that holds the content of the current element. [self.currentParsedCharacterData appendString:string]; } }` And this is how I populate my table view #pragma mark Table View Methods // The number of rows is equal to the number of earthquakes in the array. - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return [self.promoList count]; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { // Each subview in the cell will be identified by a unique tag. static NSUInteger const kartistNameLabelTag = 2; // Declare references to the subviews which will display the earthquake data. UILabel *artistNameLabel = nil; static NSString *kpromoCellID = @"promoCellID"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:kpromoCellID]; if (cell == nil) { // No reusable cell was available, so we create a new cell and configure its subviews. cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:kpromoCellID] autorelease]; artistNameLabel = [[[UILabel alloc] initWithFrame:CGRectMake(10, 3, 190, 20)] autorelease]; artistNameLabel.tag = kartistNameLabelTag; artistNameLabel.font = [UIFont boldSystemFontOfSize:14]; [cell.contentView addSubview: artistNameLabel]; } else { // A reusable cell was available, so we just need to get a reference to the subviews using their tags. artistNameLabel = (UILabel *)[cell.contentView viewWithTag:kartistNameLabelTag]; } // Get the specific promo for this row. PromoListItem *promo = [promoList objectAtIndex:indexPath.row]; // Set the relevant data for each subview in the cell. artistNameLabel.text =promo.artistName; return cell; }
