[site]: stackoverflow
[post_id]: 4175543
[parent_id]: 4174639
[tags]: 
Technically, you might be running on a color-map device, which means you need to go through X11 color management for all of this. You need to query the XColor for your two input colors, compute the average, then look up the closest representable color: // Query XColor for both input colors XColor xcol1, xcol2, outcol; xcol1.pixel = color1; xcol2.pixel = color2; XQueryColor(display, colormap, &xcol1); XQueryColor(display, colormap, &xcol2); // Average red/green/blue and look up nearest representable color outcol.red = (xcol1.red + xcol2.red) / 2; outcol.green = (xcol1.green + xcol2.green) / 2; outcol.blue = (xcol1.blue + xcol2.blue) / 2; XAllocColor(display, colormap, &outcol); // outcol.pixel is now the color to use On a paletted device, you also need to free the color afterwards etc. - it's a mess, basically. But in all likelihood you're on a 32-bit truecolor device, which means the integer is just a bitfield of r, g, b and a (not necessarily in that order). You can compute their average like this: UInt out_color = 0; for (int i=0; i > (i*8)) & 0xff; UInt in2 = (color2 >> (i*8)) & 0xff; // Compute the average and or it into the output color out_color |= ((in1 + in2) / 2)
