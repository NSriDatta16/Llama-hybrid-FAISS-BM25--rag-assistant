[site]: crossvalidated
[post_id]: 90345
[parent_id]: 87237
[tags]: 
So here's my approach so far... which could definitely be improved upon. Here is some fake data that represents something like one of the time series signals in my data data = jitter(c(rep(0, 100), c(1:100, rep(100, 100))), factor=3) plot(data, type="l") The correct answer to this simulated dataset should be that the signal changed at point 101 and then settled back out again at 200. What we are going to do is fit two lines to the data. One line is a linear line that starts at 101 and goes to x. The next line is a flat line (y = ?) that goes from x to 300. Here is the function we will use to represent a line fn.line = function(x1,y1,x2,y2,x) { # uses point-slope formula for a line y1 + (y2-y1)*(x-x1)/(x2-x1) } What we want to do is pick x (our response time to a steady state) by minimizing the sum of squared errors sse = function(actual, fitted) { sum((actual - fitted)^2) } We are going to use some optimization magic in R that tries to minimize fitting those two lines data = data[101:300] obj.fn = function(response.time) { line.selection = 1:response.time # fit a linear line line.fnc = function(x) { fn.line(1,data[1],response.time,data[response.time], x) } linear.actual = data[line.selection] linear.fitted = line.fnc(line.selection) # Assume a flat line flat.actual = data[(response.time + 1):length(data)] flat.fitted = line.fnc(line.selection[length(line.selection)] + 1) mean(c(sse(linear.actual, linear.fitted), sse(flat.actual, flat.fitted))) } which almost gives me the right answer: round(optimize(obj.fn, c(0, 300-101))$minimum)
