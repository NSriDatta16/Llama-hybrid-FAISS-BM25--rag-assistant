[site]: stackoverflow
[post_id]: 959123
[parent_id]: 959096
[tags]: 
I would spontaneously want to disconnect the database dependency from the objects a bit. You could start by creating an interface that defines the storage methods for your TestData object (in my example there is only the Add method, but this can of course be extended): public interface ITestDataRepository { void Add(TestData data); } Next step is to create your TestData class. One feature of that class could be to accept an ITestDataRepository as a parameter in the constructor, and to expose an Add method: public class TestData { public TestData(ITestDataRepository repository) { Repository = repository; } public ITestDataRepository Repository { get; private set; } public string SomeData { get; set; } public void Add() { if (Repository != null) { Repository.Add(this); } } } Last thing to do is to implement the data mechanism that you want to use. In this case OleDb, but it could just as well be Xml, SqlServer or any other form of data storage: public class DbTestDataRepository : ITestDataRepository { const string InsertionQuery = @"INSERT INTO TEST (TESTDATA) VALUES (?)"; public void Add(TestData data) { using (OleDbConnection conn = DbUtil.GetConnection()) using (OleDbCommand command = new OleDbCommand(InsertionQuery, conn)) { command.Parameters.Add("@p1", OleDbType.BSTR).Value = data.SomeData; using (OleDbDataReader reader = command.ExecuteReader()) { // perhaps log something? } } } } The above design provides a couple of different advantages over the design in your question: There is no hard relation between your object model and the concrete storage implementation; you can change storage mechanism without altering the TestData object for instance. It is testable; since the only requirement on the data storage mechanism is that it implements the repository interface, the data storage can easily be mocked, which makes unit testing easier. In this concrete database code, the connection object lives only for a very short moment, which is usually the recommended way of doing it (the DbUtil.GetConnection method is something that I "invented"; it does not exist, but I usually like to centralize the code for setting up the connection, so I don't multiply it all over my code). These are just some quick ideas (for instance, I did not test the code other than compiling it).
