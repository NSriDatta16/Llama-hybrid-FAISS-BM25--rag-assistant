[site]: stackoverflow
[post_id]: 4458311
[parent_id]: 4455687
[tags]: 
If you want to have the best possible performance, you'd have to use sockets in non blocking mode, or using completion ports . IPWorks is implemented like that, as well as iocp . As far as I can tell, Indy or Synapse don't implement them (at least officially). We used completion ports and a thread pool in our open source SynCrtSock unit, used in our Synopse SQLite3 framework . Here are some benchmarks of this solution, working from Delphi 6 up to Delphi XE. I don't tell this is the "best component", but it's a working and speedy one (every request is about 4 KB of JSON data): Http client keep alive (i.e. one HTTP/1.1 client connection kept alive during requests): first in 7.87ms, done in 153.37ms i.e. 6520/s, average 153us Http client multi connect (i.e. one new HTTP/1.0 client connection created for each request - this one uses completion ports and a thread pool): first in 151us, done in 305.98ms i.e. 3268/s, average 305us For speed comparison, here are other communication protocols available in our framework: Named pipe access: first in 78.67ms, done in 187.15ms i.e. 5343/s, average 187us Local window messages: first in 148us, done in 112.90ms i.e. 8857/s, average 112us Direct in process access: first in 44us, done in 41.69ms i.e. 23981/s, average 41us We use HTTP/1.1 protocol over TCP/IP, because there is very little overhead over plain TCP/IP, and this is a well handled protocol for firewalls and such, and allows our framework to be used by an AJAX application, whereas its main purpose is to serve Delphi clients. IMHO there is no "best Server Socket alternative component for Delphi", it depends what is the purpose of your server application. The main bottleneck will be in the Windows kernel itself. Perhaps direct access to the HTTP Kernel-Mode Driver (Http.sys) of Windows could help. Consider using a dedicated optimized Server instead of a Delphi server, like lighttpd or Cherokee using FastCGI to handle the requests via a Free Pascal (or CrossKylix) application, under Linux. I guess this will be the best performance possible.
