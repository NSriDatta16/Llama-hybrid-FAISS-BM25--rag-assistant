[site]: stackoverflow
[post_id]: 1467294
[parent_id]: 1466940
[tags]: 
Personally I use a mutex to serialize access to the list, and wake up the consumer by sending a byte over a socket (produced by socketpair()). That may be somewhat less efficient than a semaphore or condition variable, but it has the advantage of allowing the consumer to block in select()/poll(). That way the consumer can also wait on other things besides the data queue, if it wants to. It also lets you use the exact same queueing code on almost all OS's, since practically every OS supports the BSD sockets API. Psuedocode follows: // Called by the producer. Adds a data item to the queue, and sends a byte // on the socket to notify the consumer, if necessary void PushToQueue(const DataItem & di) { mutex.Lock(); bool sendSignal = (queue.size() == 0); queue.push_back(di); mutex.Unlock(); if (sendSignal) producerSocket.SendAByteNonBlocking(); } // Called by consumer after consumerSocket selects as ready-for-read // Returns true if (di) was written to, or false if there wasn't anything to read after all // Consumer should call this in a loop until it returns false, and then // go back to sleep inside select() to wait for further data from the producer bool PopFromQueue(DataItem & di) { consumerSocket.ReadAsManyBytesAsPossibleWithoutBlockingAndThrowThemAway(); mutex.Lock(); bool ret = (queue.size() > 0); if (ret) queue.pop_front(di); mutex.Unlock(); return ret; }
