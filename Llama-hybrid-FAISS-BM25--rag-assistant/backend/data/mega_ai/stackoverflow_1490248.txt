[site]: stackoverflow
[post_id]: 1490248
[parent_id]: 1490225
[tags]: 
EDIT: Answering the edited question :) this is simple contrived example to discuss using getters/setters vs variables If you have a simple collection of variables, that don't need any kind of validation, nor additional processing then you might consider using a POD instead. From Stroustrup's FAQ : A well-designed class presents a clean and simple interface to its users, hiding its representation and saving its users from having to know about that representation. If the representation shouldn't be hidden - say, because users should be able to change any data member any way they like - you can think of that class as "just a plain old data structure" In short, this is not JAVA. you shouldn't write plain getters/setters because they are as bad as exposing the variables them selves. initializer lists or private validator functions are not really part of this question. I'm wondering if either design will make the code easier to maintain and expand. If you are copying another object's variables, then the source object should be in a valid state. How did the ill formed source object got constructed in the first place?! Shouldn't constructors do the job of validation? aren't the modifying member functions responsible of maintaining the class invariant by validating input? Why would you validate a "valid" object in a copy constructor? I'm not concerned about performance. we're not programming on the PDP-11 This is about the most elegant style, though in C++ the most elegant code has the best performance characteristics usually. You should use an initializer list . In your code, m_str1 is default constructed then assigned a new value. Your code could be something like this: class Container { public: Container() {} Container(const Container& cont) : m_str1(cont.m_str1) { } string GetMyString() { return m_str1;} void SetMyString(string str) { m_str1 = str;} private: string m_str1; }; @cbrulak You shouldn't IMO validate cont.m_str1 in the copy constructor . What I do, is to validate things in constructors . Validation in copy constructor means you you are copying an ill formed object in the first place, for example: Container(const string& str) : m_str1(str) { if(!valid(m_str1)) // valid() is a function to check your input { // throw an exception! } }
