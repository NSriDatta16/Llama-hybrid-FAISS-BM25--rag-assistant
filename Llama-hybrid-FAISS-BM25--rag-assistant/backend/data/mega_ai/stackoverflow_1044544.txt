[site]: stackoverflow
[post_id]: 1044544
[parent_id]: 1038790
[tags]: 
By doing the new in the getter, you're committing to a concrete implementation of ResultState. In your current case, that means the implementation that is opaque about its state. Imagine for a moment that instead of new'ing up ResultState in place, you obtained it from a factory, and that the factory provided some way to substitute a mock ResultState, so that you could verify that getResultState() was doing with the ResultState object between creating it and returning it. A simple way to get that effect is to break out the creation of ResultState into on overridable method. For example, public ResultState getResultState() { ResultState resultState = createResultState(); ... protected ResultState createResultState() { return new ResultState(); } Then, assuming your Test class is in the same package, you can create an in-line subclass that overrides getResultState() to return a mock. While that works, it's a fragile way to write tests. An alternate approach is to head towards something like public ResultState getResultState() { ResultState resultState = _resultStateFactory.newResultState(); ... This requires that you figure out an appropriate way of injecting a ResultStateFactory into the object, which is something a dependency injection framework is great for. For tests, inject a factory that returns a mock ResultState that's been primed with appropriate expectations. This reduces the testing problem to "is getResultState() manipulating the ResultState object correctly before returning it?"
