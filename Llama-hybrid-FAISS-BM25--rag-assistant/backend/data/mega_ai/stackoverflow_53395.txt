[site]: stackoverflow
[post_id]: 53395
[parent_id]: 
[tags]: 
Suggestions wanted with Lists or Enumerators of T when inheriting from generic classes

I know the answer is not going to be simple, and I already use a couple of (I think ugly) cludges. I am simply looking for some elegant answers. Abstract class: public interface IOtherObjects; public abstract class MyObjects where T : IOtherObjects { ... public List ToList() { ... } } Children: public class MyObjectsA : MyObjects //(where OtherObjectA implements IOtherObjects) { } public class MyObjectsB : MyObjects //(where OtherObjectB implements IOtherObjects) { } Is it possible, looping through a collection of MyObjects (or other similar grouping, generic or otherwise) to then utilise to ToList method of the MyObjects base class, as we do not specifically know the type of T at this point. EDIT As for specific examples, whenever this has come up, I've thought about it for a while, and done something different instead, so there is no current requirement. but as it has come up quite frequently, I thought I would float it. EDIT @Sara, it's not the specific type of the collection I care about, it could be a List, but still the ToList method of each instance is relatively unusable, without an anonymous type) @aku, true, and this question may be relatively hypothetical, however being able to retrieve, and work with a list of T of objects, knowing only their base type would be very useful. Having the ToList returning a List Of BaseType has been one of my workarounds EDIT @ all: So far, this has been the sort of discussion I was hoping for, though it largely confirms all I suspected. Thanks all so far, but anyone else, feel free to input. EDIT @Rob, Yes it works for a defined type, but not when the type is only known as a List of IOtherObjects. @Rob Again Thanks. That has usually been my cludgy workaround (no disrespect :) ). Either that or using the ConvertAll function to Downcast through a delegate. Thanks for taking the time to understand the problem. QUALIFYING EDIT in case I have been a little confusing To be more precise, (I may have let my latest implementation of this get it too complex): lets say I have 2 object types, B and C inheriting from object A. Many scenarios have presented themselves where, from a List of B or a List of C, or in other cases a List of either - but I don't know which if I am at a base class, I have needed a less specific List of A. The above example was a watered-down example of the List Of Less Specific problem's latest incarnation. Usually it has presented itself, as I think through possible scenarios that limit the amount of code that needs writing and seems a little more elegant than other options. I really wanted a discussion of possibilities and other points of view, which I have more or less got. I am surprised no one has mentioned ConvertAll() so far, as that is another workaround I have used, but a little too verbose for the scenarios at hand @Rob Yet Again and Sara Thanks, however I do feel I understand generics in all their static contexted glory, and did understand the issues at play here. The actual design of our system and usage of generics it (and I can say this without only a touch of bias, as I was only one of the players in the design), has been done well. It is when I have been working with the core API, I have found situations when I have been in the wrong scope for doing something simply, instead I had to deal with them with a little less elegant than I like (trying either to be clever or perhaps lazy - I'll accept either of those labels). My distaste for what I termed a cludge is largely that we require to do a loop through our record set simply to convert the objects to their base value which may be a performance hit. I guess I was wondering if anyone else had come across this in their coding before, and if anyone had been cleverer, or at least more elegant, than me in dealing with it.
