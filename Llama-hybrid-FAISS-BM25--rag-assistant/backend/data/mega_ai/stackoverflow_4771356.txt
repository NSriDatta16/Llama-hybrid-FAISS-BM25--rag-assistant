[site]: stackoverflow
[post_id]: 4771356
[parent_id]: 4768029
[tags]: 
I'll show how to build a WPF application with MVVM pattern for 2D-Poliline with draggable vertexes. PointViewModel.cs public class PointViewModel: ViewModelBase { public PointViewModel(double x, double y) { this.Point = new Point(x, y); } private Point point; public Point Point { get { return point; } set { point = value; OnPropertyChanged("Point"); } } } The class ViewModelBase contains only an implementation of interface INotifyPropertyChanged . This is necessary for reflecting changes of the clr-property on the visual representation. LineViewModel.cs public class LineViewModel { public LineViewModel(PointViewModel start, PointViewModel end) { this.StartPoint = start; this.EndPoint = end; } public PointViewModel StartPoint { get; set; } public PointViewModel EndPoint { get; set; } } It has references to Points, so the changes will be received automatically. MainViewModel.cs public class MainViewModel { public MainViewModel() { this.Points = new List { new PointViewModel(30, 30), new PointViewModel(60, 100), new PointViewModel(50, 120) }; this.Lines = this.Points.Zip(this.Points.Skip(1).Concat(this.Points.Take(1)), (p1, p2) => new LineViewModel(p1, p2)).ToList(); } public List Points { get; set; } public List Lines { get; set; } } It contains a sample data of points and lines MainVindow.xaml Here is a lot of tricks. First of all, these ItemsControls are based not on vertical StackPanel , but on Canvas . The ItemsControl of points applies a special container template with a goal to place items on necessary coordinates. But the ItemsControl of lines don't require such templates, and it is strange at some point. Two last DataTemplates are obvious. PointView.xaml Left and Top margins are equal to a half of the Width and the Height . We have a transparent Fill because this property doesn't have a default value and the events of mouse don't work. That's almost all. Only drag-n-drop functionality remains. PointView.xaml.cs public partial class PointView : UserControl { public PointView() { InitializeComponent(); this.MouseLeftButtonDown += DragSource_MouseLeftButtonDown; this.MouseMove += DragSource_MouseMove; } private bool isDraggingStarted; private void DragSource_MouseLeftButtonDown(object sender, MouseButtonEventArgs e) { this.isDraggingStarted = true; } private void DragSource_MouseMove(object sender, MouseEventArgs e) { if (isDraggingStarted == true) { var vm = this.DataContext as PointViewModel; var oldPoint = vm.Point; DataObject data = new DataObject("Point", this.DataContext); DragDropEffects effects = DragDrop.DoDragDrop(this, data, DragDropEffects.Move); if (effects == DragDropEffects.None) //Drag cancelled vm.Point = oldPoint; this.isDraggingStarted = false; } } MainVindow.xaml.cs public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); this.DataContext = new MainViewModel(); this.AllowDrop = true; this.DragOver += DropTarget_DragOver; } private void DropTarget_DragOver(object sender, DragEventArgs e) { var vm = e.Data.GetData("Point") as PointViewModel; if (vm != null) vm.Point = e.GetPosition(this); } } So your sample is done using 2 xaml files and 3 viewmodels.
