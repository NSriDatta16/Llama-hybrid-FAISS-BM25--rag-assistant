[site]: stackoverflow
[post_id]: 1445525
[parent_id]: 1441469
[tags]: 
Your solution is certainly awkward in its use (and abuse) of monads: It is usual to build monads piecemeal by stacking several transformers It is less usual, but still happens sometimes, to stack several states It is very unusual to stack several Maybe transformers It is even more unusual to use MaybeT to interrupt a loop Your code is a bit too pointless : (`when` mzero) . isJust = instead of the easier to read let isHappy = isJust $ runMaybeT (mapM_ f bases) when isHappy mzero Focusing now on function solve1, let us simplify it. An easy way to do so is to remove the inner MaybeT monad. Instead of a forever loop which breaks when a happy number is found, you can go the other way around and recurse only if the number is not happy. Moreover, you don't really need the State monad either, do you ? One can always replace the state with an explicit argument. Applying these ideas solve1 now looks much better: solve1 :: [Integer] -> IsHappyMemo Integer solve1 bases = go 2 where go i = do happyBases isHappy Set.empty b i) bases if and happyBases then return i else go (i+1) I would be more han happy with that code. The rest of your solution is fine. One thing that bothers me is that you throw away the memo cache for every subproblem. Is there a reason for that? solve :: [String] -> String solve = concat . (`evalState` Map.empty) . mapM f . zip [1 :: Integer ..] where f (idx, prob) = do s Wouldn't your solution be more efficient if you reused it instead ? solve :: [String] -> String solve cases = (`evalState` Map.empty) $ do solutions
