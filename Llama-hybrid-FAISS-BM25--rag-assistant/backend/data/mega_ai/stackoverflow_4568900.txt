[site]: stackoverflow
[post_id]: 4568900
[parent_id]: 4568091
[tags]: 
It's common to declare a class 'abstract' to prevent creation of generic objects - based on your usage-code at the bottom you seem not to want that and that's fine. Just remember that you can declare declare a class abstract. The best way to use class hierarchy is to ensure that (buzzword alert) any class in a useful hierarchy should be declarable as anythin in the hierarchy (i.e. you should be able to access any methods in your concrete object from the base-class (person in this case). Your financial_person object extends person, but the ideal is to have a class that you can declare at a high level and call methods polymorphically. Consider for a minute that all people are able to draw and deposit money (different from your classes, but bear with me for a minute). drawMoney method would exist in person, but be marked abstract - forcing the subclasses financial_person and regular_person to implement draw_money, deposit_money etc. each class would have an implementation that suits their reality (financial person would have access to all kinds of special accounts, discounts etc., and regular_person would have a simpler set of - but still the same external behavior). Then you could declare like this: Person finPerson = new FinancialPerson(... etc.); Person regPerson = new RegularPerson(....etc); note now that you are able to do this code below: finPerson.drawCash(12300.0); regperson.drawCase(100.0); The identical behavior. You could have a List of thousands of people, and would not have to do if-then-else or switch statements to execute the finer-tuned behaviors of each. The acid-test for class-hierarchy is this: "my (sub-class) really 'a kind of' (superclass)?" In other words, "does my subclass have behaviors of the superclass?" If not, you should think carefully about class hierarchy. There's a buzzword for this : Liskov Substitution Principle, and I cannot do a better job of this than Robert. C. Martin - one of the software-design gurus: http://www.objectmentor.com/resources/articles/lsp.pdf In this article he shows what happens when you have inadvisable hierarchy, using the "a square is a kind-of rectangle" example. Google "template method pattern" for a summary of another aspect of effectively using inheritance. You will see that it is much more powerful than the simple inheritance that most people dismiss it as being. Also remember that no single pattern is a silver-bullet for everything. Some people will call class-hierarchy evil and tell you to use interfaces only; others will say the reverse. There are choices to make, and sometimes they will not be obvious. There are many pitfalls, and missing LSP is just one of them. Others are (examples only) overriding concrete methods, having concrete classes not marked final, enabling mutability of "identifying" fields (eg fields used in equals/hashcode, etc.) Imagine if "customer" objects at bank allowed resetting of first-name, or account-number at runtime, once these fields were already set). My answer is more generally related to OO design, inheritance etc. than specific coding questions - hope it's of some use to you.
