[site]: stackoverflow
[post_id]: 120679
[parent_id]: 120648
[tags]: 
For this scenario, rather than calling Assert.Fail, I do the following (in C# / NUnit) [Test] public void MyClassDoesSomething() { throw new NotImplementedException(); } It is more explicit than an Assert.Fail. There seems to be general agreement that it is preferable to use more explicit assertions than Assert.Fail(). Most frameworks have to include it though because they don't offer a better alternative. For example, NUnit (and others) provide an ExpectedExceptionAttribute to test that some code throws a particular class of exception. However in order to test that a property on the exception is set to a particular value, one cannot use it. Instead you have to resort to Assert.Fail: [Test] public void ThrowsExceptionCorrectly() { const string BAD_INPUT = "bad input"; try { new MyClass().DoSomething(BAD_INPUT); Assert.Fail("No exception was thrown"); } catch (MyCustomException ex) { Assert.AreEqual(BAD_INPUT, ex.InputString); } } The xUnit.Net method Assert.Throws (or variances ThrowsAsync, ThrowsAny) makes this a lot neater without requiring an Assert.Fail method. By not including an Assert.Fail() method xUnit.Net encourages developers to find and use more explicit alternatives, and to support the creation of new assertions where necessary.
