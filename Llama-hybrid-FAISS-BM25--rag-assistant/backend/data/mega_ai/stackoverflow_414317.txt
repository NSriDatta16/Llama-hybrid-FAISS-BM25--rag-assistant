[site]: stackoverflow
[post_id]: 414317
[parent_id]: 401741
[tags]: 
Finally figured this out. This code will determine which references are generated and which aren't in Specman 6 via the reflection interface: 1000 and not str_match(wf.name,"/___/"){ if not str_match(wf.name,"/___|driver_trans/"){ an_e_path = append(u.e_path(),".",wf.name); an_e_path = append(an_e_path, " - marked_as_reachable=",wf.fgi.marked_as_reachable); if wf.base_type is a struct_descriptor (s){ an_e_path = append(an_e_path, " - instantiated == ", s.instantiated); }; if wf.base_type is a struct_descriptor (s) and not s is a list_descriptor and not s is a long_descriptor { sys.is_a_unit = FALSE; if not my_specman(append("sys.is_a_unit = ( ",u.e_path(),".",wf.name, " != NULL)")) { sys.is_a_unit = FALSE; }; if sys.is_a_unit { if not my_specman(append(" sys.is_a_unit = (",u.e_path(),".",wf.name, ".as_a(any_struct) == ",u.e_path(),".",wf.name,".get_enclosing_unit(any_unit).as_a(any_struct))")) { sys.is_a_unit = FALSE; }; }; if sys.is_a_unit and str_match(wf.name,"/([\w_]+'+[\w_']*)[\w_]+/") { if not my_specman( append( "sys.is_a_unit = ( ",u.e_path(), " is a ", $1, " ", rf_manager.get_struct_of_instance(u).as_a(rf_like_struct).sd_.name, ")")) { sys.is_a_unit = FALSE; }; }; if is_a_unit { sys.a_unit = NULL; if not my_specman(append("sys.a_unit = (",u.e_path(),".",wf.name, ".as_a(any_unit))")) { sys.a_unit = NULL; }; if sys.a_unit != NULL { sys.an_e_path = NULL; var printout := append(":: ",u.e_path(), ".", wf.name); compute my_specman(append( "sys.an_e_path = ",u.e_path(),".",wf.name, ".my_e_path")); if append(u.e_path(),".",wf.name) != sys.an_e_path { printout = append(printout, " -> "); printout = append(printout, sys.an_e_path); if wf.fgi != NULL and wf.fgi.gcs.size() > 0 and ( wf.fgi.gcs[0].last_reduction != UNDEF or wf.fgi.gcs[0].gcois.size() > 0 ) { printout = append(printout, " GENERATED POINTER"); }; }; out(printout); }; }; }; --out( " ",an_e_path); --specman(append("print ",u.e_path(),".",wf.name)); }; }; --for each ( m ) in rf_manager.get_struct_of_instance(u).as_a(rf_like_struct).sd_.methods { -- if m != NULL { -- out(m.md.name); -- }; --}; --print u.get_all_attribute_names(); --print u.get_attribute("agent"); --print u.agent_kind(); -- for each (m) in rf_manager.get_struct_of_instance(u).get_declared_methods() { -- print m; -- }; -- out("fields at '",u.e_path(),"'s struct level:"); -- for each (f) in rf_manager.get_struct_of_instance(u).get_declared_fields() { -- out( " ",u.e_path()," -> ",f.f_.short_name); -- }; -- out("fields at '",u.e_path(),"'s exact sub-type level:"); -- for each (f) in rf_manager.get_exact_subtype_of_instance(u).get_declared_fields() { -- out( " ",u.e_path()," -> ",f.f_.short_name); -- }; -- out(""); }; -- out("\nPRINT OUT UNIT INSTANCES"); -- for each any_unit(u) in {sys;foo;bar} { -- for each (i) in rf_manager.get_all_unit_instances(u) { -- if i != u { -- out(u.e_path(), " has unit ", i.e_path()); -- }; -- }; -- }; }; }; '> Running with: specman -c 'load rf_test.e; gen' Produces: Generating the test using seed 1... PRINT OUT FIELDS :: sys.bar.B'sub_typiness'foo_ptr -> sys.foo :: sys.bar.b -> sys.foo.b :: sys.bar.b2 -> sys.foo.b GENERATED POINTER :: sys.foo.A'sub_typiness'bar_ptr -> sys.bar :: sys.foo.b :: sys.logger.base_unit -> sys :: sys.logger :: sys.foo :: sys.bar Starting the test ... Running the test ...
