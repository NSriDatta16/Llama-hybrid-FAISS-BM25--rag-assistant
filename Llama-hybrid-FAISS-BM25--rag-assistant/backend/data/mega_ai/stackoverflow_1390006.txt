[site]: stackoverflow
[post_id]: 1390006
[parent_id]: 1381845
[tags]: 
Summary : This is a common way to write compilers, and its just fine here. A very common way to handle this in other languages is by "pattern matching", which is exactly what you've described. I expect that's the name for that case statement in Scala. Its a very common idiom for writing programming language implementations and tools: compilers, interpreters etc. Why is it so good? Because the implementation is completely separated from the data (which is often bad, but generally desirable in compilers). The problem then is that this common idiom for programming language implementation is an anti-pattern in Python. Uh oh. As you can probably tell, this is more a political issue than a language issue. If other Pythonistas saw the code they would scream; if other language implementers saw it, they would understand it immediately. The reason this is an anti-pattern in Python is because Python encourages duck-typed interfaces: you shouldn't have behaviour based on type, but rather they should be defined by the methods that an object has available at run-time. S. Lott's answer works fine if you want it to be idiomatic Python, but it adds little. I suspect that your design isn't really duck-typed - its a compiler after all, and classes defined using a name, with a static structure, are pretty common. If you prefer, you could think of your objects as having a "type" field, and isinstance is used to pattern-match based on that type. Addenum: Pattern-matching is probably the number one reason that people love writing compilers etc in functional languages.
