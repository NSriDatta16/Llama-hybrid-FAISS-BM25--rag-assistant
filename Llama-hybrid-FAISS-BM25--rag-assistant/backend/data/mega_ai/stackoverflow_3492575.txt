[site]: stackoverflow
[post_id]: 3492575
[parent_id]: 3492368
[tags]: 
The base class constructor is always called when you instantiate a derived class. If the base class has a default constructor this will be call if you ommit an explicit call to a base class constructor. E.g. class Base { int x; int y; //default constructor public Base() { x = -1; y = -1; } public Base(int x, int y) { this.x = x; this.y = y; } } class Derived { public Derived() { } } this will compile and set the instance fields of derived to -1 when a Derived object is created. However if you omit the default constructor you will get a compile error like the one you describe. Now the compiler is not capable of autogenerating the call to the base constructor. I would know which parameters to call it with base(x=??,y=??) In general you should have public fields/properties with the same name declared multiple times this is almost always a strong design smell. If the base class has a protected,internal or public field/property so does the derived class (the internal has some odd cases). For methods you can hide the base class implementation of a mthod or override it. The latter is the more common and that requires the base definition to be either abstract or virtual e.g. //this requires Base to be declared abstract as well public abstract void AbstractMethod(); public virtual void VirtualMethod(){} that enables you to write as follows in the DErived class public override void AbstractMethod(){} public override void VirtualMethod(){} If you need to hide a method you can do that though it's generally discourage (see below for why) if you just redeclare the method the compiler will give you a warning but you can use new to tell the compiler you actually want to hide the method it will look like this: public new void SomeHiddenMethod(){} how ever this has a (potentially) hugh impact on the use of objects of that type public void SomeMEthod(Derived d) { //this calls the implementation in Derived d.SomeHiddenMethod(); Base b = d; //this calls the implementation in Base b.SomeHiddenMethod(); } hiding methods thus makes it incredibly hard to reason about the code since calling the same method on the same object might has differing result even though the object hasn't changed state in between the two calls but simply because the declared type of the variable changed. And a final note on inheritance you should avoid inheriting for functionality, in short that is just because you need the same functionality in two (unrelated) classes you shouldn't create a base class to hold that functionality, rather you should create a third class and inject and instance of that class (or similar approaches) and you should think a lot about Liskov substitutional principle when designing the public interface of a class when it's not sealed.
