[site]: stackoverflow
[post_id]: 5024368
[parent_id]: 5024183
[tags]: 
Place use warnings; use strict; at the top of every program you write. Those two pragmas will catch many errors for you. You can't access an array with a (...) postfix. That construct is used to call functions mysub(...) or $mysubref->(...) . To access array elements, you use a postfix [ index ] . And in Perl, multi-dimensional arrays require a pair of [...] for each level. This is because a 2D array is simply an array where each element is also an array. my @array = ([1, 2, 3], [4, 5, 6], [7, 8, 9]); my $top_left = $array[0][0]; # 1 my $bottom_right = $array[2][2]; # 9 print "@$_\n" for @array; 1 2 3 4 5 6 7 8 9 You can learn more about Perl's data structures and the rest of Perl at perldoc.perl.org . Here are a few direct links: arrays of arrays: perllol complex data structures: perldsc general language reference Finally, @language.length does not do what you think it does. It is taking @language in scalar context, which is its length as a number and then concatenating it with length($_) . The resulting expression is something like (scalar @language) . length($_) . Since the operator imposes scalar context on its arguments, you could simply write $id . However, Perl provides you with a more natural way of writing this type of loop: for my $id (0 .. @language) {...} or for my $id (0 .. $#language) {...} if you really meant $id since $language[scalar @language] is one element past the end of the array.
