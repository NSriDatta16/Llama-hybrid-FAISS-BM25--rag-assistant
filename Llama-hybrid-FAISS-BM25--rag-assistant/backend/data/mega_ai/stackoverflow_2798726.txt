[site]: stackoverflow
[post_id]: 2798726
[parent_id]: 2794582
[tags]: 
I would use ' area under triangle ' formula... like cletus(!?) Im really gonna have to start paying more attention to things... Anyway, i think this solution is pretty elegant now, it applies the desired minimum spacing between all elements, evenly, scales the gaps (distribution) evenly to maintain the original sum and does the job non-recursively (except for the sort): Given an array a() of random numbers of length n Generate a sort index s() and work on the sorted intervals a(s(0))-a(s(1)), a(s(1))-a(s(2)) etc increase each interval by the desired minimum separation size eg 1 (this necessarily warps their 'randomness') decrease each interval by a factor calculated to restore the series sum to what it is without the added spacing. If we add 1 to each of a series we increase the series sum by 1 * len 1 added to each of series intervals increases sum by: len*(len+1)/2 //( ?pascal's triangle ) Draft code: $series($length); //the input sequence $seriesum=sum($series); //its sum $minsepa=1; //minimum separation $sorti=sort_index_of($series) //sorted index - php haz function? $sepsum=$minsepa*($length*($length+1))/2; //sum of extra separation $unsepfactor100=($seriesum*100)/($seriesum+sepsum); //scale factor for original separation to maintain size //(*100~ for integer arithmetic) $px=series($sorti(0)); //for loop needs the value of prev serie for($x=1 ; $x all intervals are reduced by a constant (non-random-warping-factor) separation can be set to values other than one implementantions need to be carefuly tweaked (i usualy test&'calibrate') to accomodate rounding errors. Probably scale everything up by ~15 then back down after. Intervals should survive if done right. After sort index is generated, shuffle the order of indexes to duplicate values to avoid runs in the sequence of collided series. ( or just shuffle final output if order never mattered ) Shuffle indexes of dupes: for($x=1; $x A kind of minimal disturbance can be done to a 'random sequence' by just parting dupes by the minimum required, rather than moving them more than minimum -some 'random' amount that was sought by the question. The code here separates every element by the min separation, whether duplicate or not, that should be kindof evenhanded, but overdone maybe. The code could be modified to only separate the dupes by looking through the series(sorti(n0:n1..len)) for them and calculating sepsum as +=minsep*(len-n) for each dupe. Then the adjustment loop just has to test again for dupe before applying adjustment.
