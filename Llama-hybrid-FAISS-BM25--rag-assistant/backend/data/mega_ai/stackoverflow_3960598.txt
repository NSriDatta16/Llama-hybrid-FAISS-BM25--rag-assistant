[site]: stackoverflow
[post_id]: 3960598
[parent_id]: 3959121
[tags]: 
Would be prettier with a stored proc to extract MIN(datetime) first, but here's a sketch: WITH quarters(q) AS ( SELECT DISTINCT 15*CAST(DATEDIFF("n",'2000/01/01',dataora) / 15 as Int) AS primo FROM Prezzi ) SELECT simbolo, DATEADD("n",q,'2000/01/01') AS tick, MIN(minimo) AS minimo, MAX(massimo) AS massimo, (SELECT TOP 1 apertura FROM Prezzi P WHERE P.simbolo = simbolo AND P.dataora >= DATEADD("n",q,'2000/01/01') ORDER BY P.dataora ASC ) as primaapertura, (SELECT TOP 1 chiusura FROM Prezzi P WHERE P.simbolo = simbolo AND P.dataora The WITH clause gets a list of 15 minute intervals, rounded down, in your dataset (let's assume nothing before 2000). Then use those intervals to group by 14:59 interval. For the volume, you'll have to decide if you want average or the total. The syntax might be a tad off, but you should get the idea. EDIT: Adjusted MIN(open), MIN(close) to pick up FIRST and LAST. In reality this won't change much, as the concept of Open and Close depend on knowing the time difference between the exchange where the quote originated and the clock of the computer collecting the data. In addition, unless the OP has the privilege of a real-time feed from all the exchanges, all the quotes are delayed by 20 minutes anyway. EDIT(2): Quite right, FIRST and LAST are carry-overs from my IBM days >;-) Solution now selects first and last quotes during the interval using TOP with ASC/DESC.
