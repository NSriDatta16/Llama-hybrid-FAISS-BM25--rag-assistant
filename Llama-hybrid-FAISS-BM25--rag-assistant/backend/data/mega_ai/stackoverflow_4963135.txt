[site]: stackoverflow
[post_id]: 4963135
[parent_id]: 
[tags]: 
WPF inactivity and activity

I'm trying to handle user inactivity and activity in a WPF application to fade some stuff in and out. After a lot of research, I decided to go with the (at least in my opinion) very elegant solution Hans Passant posted here . There's only one downside: As long as the cursor stays on top of the window, the PreProcessInput event gets continously fired. I'm having a full-screen application, so this kills it. Any ideas how I can bypass this behaviour would be most appreciated. public partial class MainWindow : Window { readonly DispatcherTimer activityTimer; public MainWindow() { InitializeComponent(); InputManager.Current.PreProcessInput += Activity; activityTimer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(10), IsEnabled = true }; activityTimer.Tick += Inactivity; } void Inactivity(object sender, EventArgs e) { rectangle1.Visibility = Visibility.Hidden; // Update // Console.WriteLine("INACTIVE " + DateTime.Now.Ticks); } void Activity(object sender, PreProcessInputEventArgs e) { rectangle1.Visibility = Visibility.Visible; // Update // Console.WriteLine("ACTIVE " + DateTime.Now.Ticks); activityTimer.Stop(); activityTimer.Start(); } } Update I could narrow down the described behaviour better (see the rectangle1.Visibility update in the above code). As long as the cursor rests on top of the window and for example the Visibility of a control is changed, the PreProcessInput is raised. Maybe I'm misunderstanding the purpose of the PreProcessInput event and when it fires. MSDN wasn't very helpful here.
