[site]: stackoverflow
[post_id]: 2018921
[parent_id]: 1938298
[tags]: 
Unfortunately my original plan to populate the IsLoaded properties on the self-tracking entities in the HandleObjectMaterialized method (called from the ObjectMaterialized event) didn't work as desired since the many to many collections are only populated after the event (see this post). And I wanted to iterate through the relationships in the context for each entity that it's tracking, test the IsLoaded property and set the corresponding IsLoaded property on my Self-tracking entity. So instead I create extension methods for First() and ToList() called FirstWithLoaded() and ToListWithLoaded() to use reflection for this as: public static T FirstOrDefaultWithLoaded (this IQueryable source) where T : new() { T result = default(T); if (source != null) { //Call the base FirstOrDefault result = source.FirstOrDefault(); var querySource = source as ObjectQuery ; if (querySource != null) { PopulateIsLoaded(result, querySource.Context); } } return result; } private static void PopulateIsLoaded(object inputEntity, ObjectContext dataContext) { var entry = dataContext.ObjectStateManager.GetObjectStateEntry(inputEntity); //var relationShipManagerProperty = entryType.GetProperty("RelationshipManager");//.GetValue(entityType, null); var relationShipManager = GetPropertyValue(entry, "RelationshipManager");// relationShipManagerProperty.GetValue(entry, null); if (relationShipManager != null) { //get the relationships (this is a sealed property) var relationships = GetPropertyValue(relationShipManager, "Relationships") as IEnumerable ; if (relationships != null) { foreach (RelatedEnd relationship in relationships) { //check to see whether the relationship is loaded var isLoaded = GetRelatedEndPropertyValue(relationship, "IsLoaded"); if (isLoaded != null && (bool)isLoaded) { //if the relationship is loaded then set the // IsLoaded on entry to true var navigationProperty = GetRelatedEndPropertyValue(relationship, "NavigationProperty"); var identity = GetPropertyValue(navigationProperty, "Identity"); //get the IsLoaded property on entry var isLoadedProperty = entry.Entity.GetType().GetProperty(identity + "IsLoaded"); if (isLoadedProperty != null) { isLoadedProperty.SetValue(entry.Entity, true, null); } } } } } } private static object GetPropertyValue(object inputObject, string propertyName) { object result = null; if (inputObject != null) { var property = inputObject.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); if (property != null) { result = property.GetValue(inputObject, null); } } return result; } private static object GetRelatedEndPropertyValue(RelatedEnd inputObject, string propertyName) { object result = null; if (inputObject != null) { PropertyInfo property = null; property = inputObject.GetType().GetProperty(propertyName, BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); if (property != null) { result = property.GetValue(inputObject, null); } } return result; } This solution is slightly dissapointing in that I had to access the sealed property "NavigationProperty" and then NavigationProperty.Identity in order to get the correct navigation (eg Person.Addresses instead of Person.Address). Hopefully something more elegant will present itself in the future. Note in order for this to work I updated my Types T4 template to create the IsLoaded properties for me eg on Person I created an AddressesIsLoaded property for Addresses as: //The IsLoaded property for use on the client side when including collections [DataMember] bool IsLoaded { get; set; }
