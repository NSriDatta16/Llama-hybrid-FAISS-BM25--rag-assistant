[site]: stackoverflow
[post_id]: 5739300
[parent_id]: 5739233
[tags]: 
That works fine for me, it stops and lets me enter either 1 or 2 . See the following transcript: pax$ cat qq.sh echo "Did you see a display?" select YN in "yes" "no" ; do case $YN in yes) echo YES break ;; no) echo NO break ;; esac done pax$ ./qq.sh Did you see a display? 1) yes 2) no #? 1 YES pax$ ./qq.sh Did you see a display? 1) yes 2) no #? 2 NO pax$ _ Are you sure that the standard input is connected to your terminal at that point? Since you've confirmed my suspicions that your standard input isn't connected to the terminal, there is a somewhat tricky way to fix it by fiddling with file handles. Consider the following code which does what you indicated in your comment (calling a function accepting standard input from within a loop that has redirected standard input): fn() { echo "Did you see a display?" select YN in "yes" "no" ; do case $YN in yes) echo YES $YN $REPLY break ;; no) echo NO $YN $REPLY break ;; esac done } echo 'A B C D' | while read ; do echo $REPLY fn echo ==== done If you run this code, you'll see: A Did you see a display? 1) yes 2) no #? #? #? #? ===== This indicates that the input was intermixed among the two readers, while read and select . The trick to solving this is to disassociate the two readers by changing the code as follows: (echo 'A B C D' | while read ; do echo $REPLY fn The output for this is: A Did you see a display? 1) yes 2) no #? 1 What this does (in its own hideous fashion) is start a subshell to run your whole thing, with the trick being that the subshell first connects the current standard input (terminal, probably) to file handle 4 for later use. Inside the subshell, you run your normal while read loop which changes the standard input (file handler 0) to read from the echo statement. But here's the trick: when you call your function, you tell it to take its standard input from file handle 4 rather than the current file handle 0. Since this is connected to the saved, original, standard input, it won't get anything from the while read standard input (the output of echo ). This may take some time to wrap your head around (and I recall having to pick my brains off the floor the first time I saw this, since my head exploded). But, once you understand how it works, you'll see its elegance :-) The output for this is: A Did you see a display? 1) yes 2) no #? 1 YES yes 1 ===== B Did you see a display? 1) yes 2) no #? 2 NO no 2 ===== C Did you see a display? 1) yes 2) no #? 1 YES yes 1 ===== D Did you see a display? 1) yes 2) no #? 2 NO no 2 ===== And, based on your code, probably a good starting point is to surround the whole lot to preserve standard input, something like: (FILE=res.log BAKIFS=$IFS IFS=$(echo -en "\n\b") exec 3 I'm assuming here that your function is fnUseResolution . However, in looking at that code, it may be simpler to use a different file handle for the read rather than the select since you have more control over that than I thought. Try out: FILE=res.log BAKIFS=$IFS IFS=$(echo -en "\n\b") #exec 3 The -u 4 option to read tels it to use file handle 4 rather than 0 and I've changed the exec to match that. I haven't tested it but it should work okay. By doing it that way, you never change standard input so it should be okay within the function. Additionally, there's no reason to save/restore it in file handle 3 in that case, hence I've commented those exec calls out.
