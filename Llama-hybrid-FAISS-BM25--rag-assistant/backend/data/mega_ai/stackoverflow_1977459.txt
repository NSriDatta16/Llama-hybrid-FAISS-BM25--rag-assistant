[site]: stackoverflow
[post_id]: 1977459
[parent_id]: 1485669
[tags]: 
I know this answer probably comes too late, but I'll take a stab anyway for the benefit of those (such as myself) who've also come across this problem as well. The MKMapView class's touch events are all handled by a UIScrollView internally. You can capture the events of this scroll view by making the MKMapView a subview of a custom UIView, and providing your custom touches methods in the custom view. The trick is to keep track of the UIScrollView used by the MKMapView. To do this, I overrode the "hitTest" method, which returns "self", which I believe means this custom view should handle the touch events. Also, the hitTest method gets the UIScrollView of the MKMapView. In my custom UIView I called it "echo_to" because the events are then echoed to the UIScrollView to make the map work as it does normally. - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { // Get the UIView (in this case, a UIScrollView) that // would ordinarily handle the events echo_to = [super hitTest:point withEvent:event]; // But let it be known we'll handle them instead. return self; } - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { NSLog(@"Touches Began"); // add your custom annotation behavior here [echo_to touchesBegan:touches withEvent:event]; } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { NSLog(@"Touches moved"); // add your custom annotation behavior here [echo_to touchesMoved:touches withEvent:event]; } Best of luck.
