[site]: stackoverflow
[post_id]: 1739990
[parent_id]: 1739800
[tags]: 
Remember that when you supply a callback function, the point of that is to defer the execution of that callback until later and immediately continue execution of whatever is next. This is necessary because of the single-threaded execution model of JavaScript in the browser. Forcing synchronous execution is possible, but it hangs the browser for the entire duration of the operation. In the case of something like $.getJSON, that is a prohibitively long time for the browser to stop responding. In other words, you're trying to find a way to use this procedural paradigm: var foo = {}; $.getJSON("url", function(data) { foo = data.property; }); // Use foo here. When you need to refactor your code so that it flows more like this: $.getJSON("url", function(data) { // Do something with data.property here. }); "Do something" could be a call to another function if you want to keep the callback function simple. The important part is that you're waiting until $.getJSON finishes before executing the code. You could even use custom events so that the code you had placed after $.getJSON subscribes to an IssuesReceived event and you raise that event in the $.getJSON callback: $(document).ready(function() { $(document).bind('IssuesReceived', IssuesReceived) $.getJSON("url", function(data) { $(document).trigger('IssuesReceived', data); }); }); function IssuesReceived(evt, data) { // Do something with data here. } Update: Or, you could store the data globally and just use the custom event for notification that the data had been received and the global variable updated. $(document).ready(function() { $(document).bind('IssuesReceived', IssuesReceived) $.getJSON("url", function(data) { // I prefer the window.data syntax so that it's obvious // that the variable is global. window.data = data; $(document).trigger('IssuesReceived'); }); }); function IssuesReceived(evt) { // Do something with window.data here. // (e.g. create the drag 'n drop interface) } // Wired up as the "drop" callback handler on // your drag 'n drop UI. function OnDrop(evt) { // Modify window.data accordingly. } // Maybe wired up as the click handler for a // "Save changes" button. function SaveChanges() { $.post("SaveUrl", window.data); } Update 2: In response to this: Does anyone have an idea how I should be blocking user interaction while this is going on? Why is it such a concern? Thanks again for all the responses. The reason that you should avoid blocking the browser with synchronous AJAX calls is that a blocked JavaScript thread blocks everything else in the browser too , including other tabs and even other windows. That means no scrolling, no navigation, no nothing. For all intents and purposes, it appears as though the browser has crashed. As you can imagine, a page that behaves this way is a significant nuisance to its users.
