[site]: stackoverflow
[post_id]: 1976189
[parent_id]: 1975856
[tags]: 
Simplest way to get the first index satisfying the condition (in Python 2.6 or better: next((i for i, d in enumerate(hugelist) if 735 in d['ids']), None) this gives None if no item satisfies the condition; more generally you could put as the second argument to the next built-in whatever you require in that case, or omit the second arg (and in that case you can remove one set of parentheses) if you're OK with getting a StopIteration exception when no item satisfies the condition (e.g., you know that situation is impossible). If you need to do this kind of operation more than very few times between changes to the hugelist or its contents, then, as you indicate in the second edit to your question, building an auxiliary dict (from integer to index of first dict containing it) is preferable. Since you want the first applicable index, you want to iterate backwards (so hits that are closer to the start of hugelist will override ones that are further on) -- for example: auxdict = {} L = len(hugelist) - 1 for i, d in enumerate(reversed(hugelist)): auxdict.update(dict.fromkeys(d['ids'], L-i)) [[You cannot use reversed(enumerate(... because enumerate returns an iterator, not a list, and reversed is optimized to only work on a sequence argument -- whence the need for L-i ]]. You can build auxdict in other ways, including without the reversal, for example: auxdict = {} for i, d in enumerate(hugelist): for item in d['ids']: if item not in auxdict: auxdict[item] =i but this is likely to be substantially slower due to the huge number of if that execute in the inner loop. The direct dict constructor (taking a sequence of key, value pairs) is also likely to be slower due to the need of inner loops: L = len(hugelist) - 1 auxdict = dict((item, L-i) for i, d in enumerate(reversed(hugelist)) for item in d['ids']) However, these are just qualitative considerations -- consider running benchmarks over a few "typical / representative" examples of values you could have in hugelist (using timeit at the command line prompt, as I've often recommended) to measure the relative speeds of these approaches (as well as, how their runtimes compare to that of an unaided lookup as I showed at the start of this answer -- this ratio, plus the average number of lookups you expect to perform between successive hugelist changes, will help you select the overall strategy).
