[site]: stackoverflow
[post_id]: 4194266
[parent_id]: 4194191
[tags]: 
Standard 18.5.1 (Class type_info) : The class type_info describes type information generated by the implementation. Objects of this class effectively store a pointer to a name for the type, and an encoded value suitable for comparing two types for equality or collating order. The names, encoding rule, and collating sequence for types are all unspecified and may differ between programs . From my understanding : You don't have this guarantee regarding std:type_info::name . The standard only states that name returns an implementation-defined NTBS , and I believe a conforming implementation could very well return the same string for every type. I don't know, and the standard isn't clear on this point, so I wouldn't rely on such behavior. That one should be a definite 'Yes' for me That one should be a definite 'Yes' for me Regarding the second set of questions : No, you cannot store a type_info . Andrei Alexandrescu proposes a TypeInfo wrapper in its Modern C++ Design book. Note that the objects returned by typeid have static storage so you can safely store pointers without worrying about object lifetime I believe you can assume that type_info comparison are extremely efficient (there really isn't much to compare).
