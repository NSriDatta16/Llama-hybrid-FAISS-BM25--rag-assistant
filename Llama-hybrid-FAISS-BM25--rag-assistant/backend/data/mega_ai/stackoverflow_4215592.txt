[site]: stackoverflow
[post_id]: 4215592
[parent_id]: 4214859
[tags]: 
You really should just code it and try it - you learn a lot that way. ( Edit: I certainly am ... ) I believe the original code fails for hasPathSum(tree, 7) because node 2 is not a leaf. Edit: Original code withdrawn due to obvious mistakes - obvious at least to everyone but me :-) Edit: My new solution is below. Note that the included optimization ( if (sum ) assumes the tree is made up of all positive data values . It should be removed or tweaked if the tree has zero or negative data values. (thanks @Mark Peters). Also note the discussion in the answer comments about handling hasPathSum(null, 0) . static boolean hasPathSumBert(final Node node, final int sum) { // return true if we run out of tree and sum==0 if (node == null) { // empty tree // choose one: return (sum == 0); //return false; } else if (node.left == null && node.right == null) { // leaf return (sum == node.data); } else if (sum Full code: public class TreeTest { static class Node { int data; Node left; Node right; Node(final int data, final Node left, final Node right) { this.data = data; this.left = left; this.right = right; } } public static void main(final String[] args) { final Node three = new Node(3, null, null); final Node two = new Node(2, three, null); final Node one = new Node(1, null, null); final Node five = new Node(5, two, one); final Node tree = five; for (int i = 0; i Sample run: (Note case 7) 0 original = false bert = false mark = false 1 original = false bert = false mark = false 2 original = false bert = false mark = false 3 original = false bert = false mark = false 4 original = false bert = false mark = false 5 original = false bert = false mark = false 6 original = true bert = true mark = true 7 original = true bert = false mark = false 8 original = false bert = false mark = false 9 original = false bert = false mark = false 10 original = true bert = true mark = true hasPathSumBert(null, 0): true hasPathSumBert(null, 1): false
