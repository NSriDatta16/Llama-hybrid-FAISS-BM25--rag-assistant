[site]: stackoverflow
[post_id]: 4656867
[parent_id]: 4656665
[tags]: 
The bad news is that you can't do this in SQLite, at least with this data structure, since SQLite doesn't support recursive SQL or window functions. If select performance is important, you can try to organize the data like this: http://articles.sitepoint.com/article/hierarchical-data-database/2 Another option is to add the root id to each row at input time. Basically, at some point you will have to use multiple selects and determine the root id at the application level. Update: Ok, this is very much pseudo-code, but it should get you there. You need a language that has some sort of hashmap or named array datatype. hashmap results, parent, nodes, nodes_new; # variables foreach (res in sql_execute("SELECT id, parent_id FROM product_group;") ) { parent[res.id] = res.parent_id; } # get groups with products foreach (res in sql_execute("SELECT pg.id FROM product_group AS pg INNER JOIN product AS p ON pg.id = p.group_id WHERE p.quick_select = 1 GROUP BY pg.id ") ) { nodes[res.id] = res.id; } while (length(nodes) > 0) { foreach (i in nodes) { if (i = 0) { results[i] = i; } # if its a root node, add to results else { nodes_new[parent[i]] = parent[i]; } # otherwise, add parent to the next round } nodes = nodes_new; # prepare for next round } print results;
