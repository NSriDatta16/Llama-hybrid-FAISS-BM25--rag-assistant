[site]: stackoverflow
[post_id]: 4146872
[parent_id]: 4145370
[tags]: 
This is very much a fine use case. I actually recommend this when scope determines the parameter to use. It provides an elegant way to pass some sort of context into a Plugin class so that utility functions will use the context. For example: trait Context object UtilityLib { def performHandyFunction(implicit x : Context) : SomeResult = ... } trait Plugin { def doYourThing(implicit ctx : Context) : Unit } class MyPlugin extends Plugin { def doYourThing(implicit ctx : Context) : Unit = { UtilityLib.performHandyFunction } } SomePluginAPI.register(new MyPlugin) You can see an example in a database migration system I was toying . Check out the Migration class and its MigrationContext.
