[site]: stackoverflow
[post_id]: 2828772
[parent_id]: 2828648
[tags]: 
Here's a version which is both working, but theoretically invalid (see below) C90 and C++98: #include static void print(int *arr, size_t s1, size_t s2) { size_t i, j; printf("\n"); for(i = 0; i A C++ version using templates (adapted from Notinlist's answer ) could look like this: #include #include using namespace std; template struct IntMatrix { int data[N][M]; IntMatrix() { memset(data, 0, sizeof data); } }; template ostream& operator & m) { out a; cout Alternatively, you could use nested STL containers - ie vector > - instead of a plain array. With C99, you could do static void print(size_t s1, size_t s2, int arr[s1][s2]) { printf("\n"); for(size_t i = 0; i and call it as print(4, 4, a); As Robert pointed out in the comments, the first snippet actually involves undefined behaviour. However, assuming that pointer arithmetics will always result in a pointer even when undefined behaviour is involved (and not blow up your computer), there is only a single possible result because of other restrictions within the standard, ie this is an instance of where the standard leaves something unnecessarily undefined. As far as I can tell, substituting print(a[0], 4, 4); with union m2f { int multi[4][4]; int flat[16]; } *foo = (union m2f *)&a; print(foo->flat, 4, 4); will make it legal C.
