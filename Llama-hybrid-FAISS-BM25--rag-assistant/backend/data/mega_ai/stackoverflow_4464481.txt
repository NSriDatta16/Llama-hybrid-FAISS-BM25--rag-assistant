[site]: stackoverflow
[post_id]: 4464481
[parent_id]: 4464300
[tags]: 
I guess explicit specialization is not the case there. You may write the similar code without templates: struct A { static const char* const str; }; typedef A C; const char* const C::str = "B"; This code is absolutely correct even if you use C instead of A. C is just an alias. Just imagine how C++ code is processed. Typedefs are obviously expanded by compiler before template instantiation process is even started. The same as all comments are expanded before macros. As all macros are expanded by preprocessor before actual C++ parsing is even started. This simplifies everything. Concerning C++03 standard, take a look at that 7.1.3/1 A name declared with the typedef specifier becomes a typedef-name. Within the scope of its declaration, a typedef-name is syntactically equivalent to a keyword and names the type associated with the identifier in the way described in clause 8. A typedef-name is thus a synonym for another type. A typedef-name does not introduce a new type the way a class declaration (9.1) or enum declaration does. I guess this paragraph explains clearly that C in your code is actually a template-id.
