[site]: stackoverflow
[post_id]: 2119919
[parent_id]: 2117536
[tags]: 
You should prefer the namespace over your class with static methods: namespace offer you the possibility to be shared among several files, one per logical group of methods namespace may be omitted: either because ADL kicks in or with using myNamespace::MyFunc; (note: it's bad practice to write using myNamespace; , and you should shun the practice) Now, let's speak of organization: it's good practice to have your file hierarchy shadowing the namespace hierarchy [1] it's good practice to split your methods by logical groups, so that the user does not have to include the whole world just because he wanted Hello, World! to be printed, commodity headers can help though (ie, headers that do a bunch of includes for lazy programmers to use) [1] Here is what I mean: #include "lib/string/manip.hpp" // Okay, this files come from "lib" int main(int argc, char* argv[]) { std::string s; lib::string::manip(s); // Same hierarchy, easy to remember the header return 0; } A motivating example ? Boost does it (with commodity headers). And what's more this does not cost much: just replace class by namespace and remove the static keywords, that's all folks. For the linker problem: all methods that are not templated should be either declared as inline (try to avoid it unless they're one-liners) or be defined outside of the header (in a separate .cpp file). UPDATE: The problem of template specialization is that you end up defining a now "normal" method: there is nothing template about it any longer once you've fixed each and every parameter. The solution is thus to do like you did for normal functions: declaration in a header file and definition in a source file (and thus only once). To be a bit more specific about this strange error: the problem of C++ is that each source files is compiled in isolation: the preprocessor will take the include and actually create a single text file that will contain every single included file (in order) and then your source at the end. The compiler takes this file and produces a ".o" file (for gcc). Then the linker kicks in and try to actually make a library (or binary) out of all these ".o" files, and it checks that each method is only defined once because otherwise how would it choose between the multiple definitions (unfortunately does not check if they are equivalent or not...) ? There is a special allowance for template methods and classes though, and it picks up one (at random) among all of the instantiations (one instantiation for each combination of template parameters). Of course, this assumes that all of them are identical and you might end up with quite a headache for something like: // foo.h template int foo(T) { return 10; } // foo.cpp #include "foo.h" char a; std::cout int foo (char) { return 20; } char b; std::cout Both lines will print the same output, whether it is 10 or 20 is unknown though, and could change between the builds!!!
