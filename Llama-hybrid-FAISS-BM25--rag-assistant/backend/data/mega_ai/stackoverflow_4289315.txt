[site]: stackoverflow
[post_id]: 4289315
[parent_id]: 
[tags]: 
Preventing Event Bubble Up: WPF & Rx

I have a little WPF app that draws some dots in a canvas and then tracks mouse moves AFTER a mouseDown happens inside any dot UNTIL a mouseUp on the canvas. My problem is how to prevent the mouseDowns inside the dots from bubbling up to the canvas. I want canvas mouseDown observers to fire when and only when mouseDowns happen outside the dots, and for dot mouseDown observers to fire when and only when mouseDowns happen inside the dots. Here's my technique for building the observable chain, showing that I set the EventArgs.Handled property in the triggering mouseDown event if the third argument of DownInAndTrackWrtObservable is true: private IObservable DownInAndTrackWrtObservable( UIElement hitTestElement, UIElement trackWrtElement, bool handleItP = false) { var hitObs = hitTestElement.GetLeftMouseDownObservable(); var trackObs = from mDown in hitObs let mDownP = mDown.EventArgs.GetPosition(hitTestElement) from mMove in trackWrtElement.GetMouseMoveObservable(). TakeUntil(trackWrtElement.GetLeftMouseUpObservable()) select new {D = mDown, P = mDownP, M = mMove}; if (handleItP) trackObs.Subscribe(e => e.D.EventArgs.Handled = true); return from obs in trackObs select new BasedVector ( tail: obs.P, head: obs.M.EventArgs.GetPosition(trackWrtElement) ); } Then, I set up handlers in two places, one that tracks hits and dots and drags in the canvas DownInAndTrackWrtObservable(ellipse, canvas1, handleItP:true).Subscribe(bv => { PointMouseDownTextBox.Text = String.Format("Point {2} MouseDown({0:G}, {1:G})", bv.Tail.X, bv.Tail.Y, ellipse.Uid); CanvasMouseMoveTextBox.Text = String.Format("Canvas MouseMove({0:G}, {1:G})", bv.Head.X, bv.Head.Y); }); and DownInAndTrackWrtObservable(canvas1, canvas1).Subscribe(bv => { CanvasMouseDownTextBox.Text = String.Format("Canvas MouseDown({0:G}, {1:G})", bv.Tail.X, bv.Tail.Y); CanvasMouseMoveTextBox.Text = String.Format("Canvas MouseMove({0:G}, {1:G})", bv.Head.X, bv.Head.Y); }); Trouble is, when a mouseDown happens in the dot, the Canvas mouseDown is still detected, as shown by the second handler. But I don't expect that to happen because of setting the Event.Handled property. BTW, if I set the Event.Handled on the hitObs instead of on the trackObs, then hits are NOT DETECTED AT ALL inside the dots. Here's the complete app, with its XAML (please "Add References" to System.coreex, System.Reactive, and System.Interactive) using System; using System.Collections.Generic; using System.Diagnostics; using System.Linq; using System.Windows; using System.Windows.Controls; using System.Windows.Input; using System.Windows.Shapes; namespace WpfTest { public static partial class UIElementExtensions { public static IObservable > GetLeftMouseDownObservable(this UIElement uiElement) { return Observable.FromEvent ( h => new MouseButtonEventHandler(h), h => uiElement.MouseLeftButtonDown += h, h => uiElement.MouseLeftButtonDown -= h); } public static IObservable > GetLeftMouseUpObservable(this UIElement uiElement) { return Observable.FromEvent ( h => new MouseButtonEventHandler(h), h => uiElement.MouseLeftButtonUp += h, h => uiElement.MouseLeftButtonUp -= h); } public static IObservable > GetMouseMoveObservable(this UIElement uiElement) { return Observable.FromEvent ( h => new MouseEventHandler(h), h => uiElement.MouseMove += h, h => uiElement.MouseMove -= h); } } public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); Draw(); } private static double scaleCanvasPerWorld = 150D; private static Point offsetInCanvas = new Point(15D, 15D); private static Point worldOrigin = new Point(); private static Point WorldToCanvas(Point worldPoint) { // Difference of two points gives a System.Drawing.Vector, which has operator overloads. var result = ((worldPoint - worldOrigin) * scaleCanvasPerWorld + offsetInCanvas); return result; } private static Point CanvasToWorld(Point canvasPoint) { var result = ((canvasPoint - offsetInCanvas) / scaleCanvasPerWorld); return (Point)result; } private void DrawPoint(Point worldPoint) { var ellipse = new Ellipse(); ellipse.Stroke = System.Windows.Media.Brushes.Black; ellipse.Fill = System.Windows.Media.Brushes.Black; ellipse.HorizontalAlignment = HorizontalAlignment.Center; ellipse.VerticalAlignment = VerticalAlignment.Center; ellipse.Width = 12; ellipse.Height = 12; var canvasPoint = WorldToCanvas(worldPoint); ellipse.SetValue(Canvas.LeftProperty, canvasPoint.X); ellipse.SetValue(Canvas.TopProperty, canvasPoint.Y); DownInAndTrackWrtObservable(ellipse, canvas1, handleItP: true).Subscribe(bv => { PointMouseDownTextBox.Text = String.Format("Point {2} MouseDown({0:G}, {1:G})", bv.Tail.X, bv.Tail.Y, ellipse.Uid); CanvasMouseMoveTextBox.Text = String.Format("Canvas MouseMove({0:G}, {1:G})", bv.Head.X, bv.Head.Y); }); canvas1.Children.Add(ellipse); } private class BasedVector { public Point Tail { get; set; } public Point Head { get; set; } public Vector Vector { get; set; } public BasedVector(Point tail, Point head) { Debug.Assert(tail != null); Debug.Assert(head != null); this.Tail = tail; this.Head = head; this.Vector = head - tail; } } private IObservable DownInAndTrackWrtObservable( UIElement hitTestElement, UIElement trackWrtElement, bool handleItP = false) { var hitObs = hitTestElement.GetLeftMouseDownObservable(); var trackObs = from mDown in hitObs let mDownP = mDown.EventArgs.GetPosition(hitTestElement) from mMove in trackWrtElement.GetMouseMoveObservable(). TakeUntil(trackWrtElement.GetLeftMouseUpObservable()) select new { D = mDown, P = mDownP, M = mMove }; if (handleItP) trackObs.Subscribe(e => e.D.EventArgs.Handled = true); return from obs in trackObs select new BasedVector ( tail: obs.P, head: obs.M.EventArgs.GetPosition(trackWrtElement) ); } private void Draw() { var controlPoints = new Point[] { new Point(0D, 0D), new Point(0D, 1D), new Point(0.5D, 1D), new Point(1.5D, 0D), new Point(2D, 0D), new Point(2D, 1D), }; controlPoints.Run(DrawPoint); DownInAndTrackWrtObservable(canvas1, canvas1).Subscribe(bv => { CanvasMouseDownTextBox.Text = String.Format("Canvas MouseDown({0:G}, {1:G})", bv.Tail.X, bv.Tail.Y); CanvasMouseMoveTextBox.Text = String.Format("Canvas MouseMove({0:G}, {1:G})", bv.Head.X, bv.Head.Y); }); } } } and the XAML Will be grateful for any advice
