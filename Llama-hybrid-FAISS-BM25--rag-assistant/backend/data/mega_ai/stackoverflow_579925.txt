[site]: stackoverflow
[post_id]: 579925
[parent_id]: 
[tags]: 
Nonblocking algorithm to generate unique negative numbers

I recently refactored a piece of code used to generate unique negative numbers. edit: Multiple threads obtain these ids and add as keys to a DB; numbers need to be negative to be easily identifiable -at the end of a test session they're removed from the DB. My Java algorithm looks like this: private final Set seen = Collections.synchronizedSet(new HashSet ()); public Integer generateUniqueNegativeIds() { int result = 0; do { result = random.nextInt(); if (result > 0) { result *= -1; } } while (!seen.add(result)); return result; } The code structure above, with its speculative addition to the set and "retry" loop, makes me think there's an equivalent nonblocking algorithm that replaces the synchronized set with any of the atomic variables . I made a few attempts to re-write using atomic variables but all failed the multithread attack test. Is there an elegant nonblocking equivalent? edit: for curiosity's sake here's a flawed attempt using an atomic integer as a guard private final AtomicInteger atomi = new AtomicInteger(0); public Integer generateUniqueNegativeIdsWithAtomicAlgo() { boolean added = false; int result = 0; do { result = random.nextInt(); if (result > 0) { result *= -1; } if (atomi.compareAndSet(0, result)) { added = cache.add(result); } } while (!added); return atomi.getAndSet(0); } edit: test harness below: public static void main(String[] args) { final int NUMBER_OF_THREADS = 10000; final Set uniques = Collections.synchronizedSet(new HashSet ()); final List positives = Collections.synchronizedList(new ArrayList ()); final NegativeUniqueIdGenerator nuig = new NegativeUniqueIdGenerator(); Thread[] workers = new Thread[NUMBER_OF_THREADS]; long start = System.nanoTime(); for (int i = 0; i 0) { positives.add(number); } uniques.add(number); } }; workers[i] = new Thread(runnable); workers[i].start(); } for (int i = 0; i
