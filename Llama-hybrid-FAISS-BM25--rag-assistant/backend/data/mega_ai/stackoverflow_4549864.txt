[site]: stackoverflow
[post_id]: 4549864
[parent_id]: 
[tags]: 
Bogus “variable may be clobbered” warning for Objective-C native exception syntax

When compiling Objective-C code with @try blocks using the -Wextra warning flag, I sometimes get warnings of the form “ variable 'foo' might be clobbered by 'longjmp' or 'vfork' ”. (Despite the specific nature of the text, this applies to all functions which have the returns_twice attribute, including the exception-handling runtime functions.) The warning pertains to this text in the C specification: All accessible objects have values, and all other components of the abstract machine have state, as of the time the longjmp function was called, except that the values of objects of automatic storage duration that are local to the function containing the invocation of the corresponding setjmp macro that do not have volatile-qualified type and have been changed between the setjmp invocation and longjmp call are indeterminate. Generally I can work around this by marking affected variables volatile or putting code in an out-of-line function. However, I’m now seeing it for inline functions in a library. Here’s a condensed test case: static inline uint64_t Foo(void) { union { int32_t a; uint64_t b; } l; l.a = 1; // warning: variable 'l' might be clobbered by 'longjmp' or 'vfork' return l.b; } void Test(uint64_t *value) { @try { *value = Foo(); } @catch (...) {} } The warning occurs when building for i386 using apple-gcc 4.0 or 4.2 (not llvm-gcc) with -Wextra and optimizations enabled. Note that this isn’t a real problem since the value won’t be used if an exception is caught. The man page suggests this warning is controlled by -Wuninitialized , but this is not the case. Using -Wuninitialized does not trigger it, but using -Wextra -Wno-uninitialized does. So the question is, is there any way of suppressing this warning other than disabling -Wextra or switching compiler? (As a warnings masochist, I am of course using -Werror .)
