[site]: stackoverflow
[post_id]: 4233089
[parent_id]: 4232843
[tags]: 
It depends. If the clients of the class need a vector of Cars , eg. they assume the cars are stored contiguously in memory for whatever reason (I don't see another reason though), then you should provide a member function returning a constant reference to a vector. Don't bother with passing by value and the inherent exception-safety problems associated with with object creation. If the vector has to outlive the Garage object, the client will make a copy. Now, in any other case, the least coupling principle suggest that we return a pair of iterators. After all, a pair of iterators is the generic expression of a collection . If the client of the class require complexity assumptions, then return the right kind of iterators (and document it). For convenience, and only when it makes sense , you can overload operator[] . A garage is a collection of cars. If the parking slots inside the garage are numbered and you want to access cars by slots, it can be a good solution. Nonetheless, you're right in saying that C++ iterators are designed in a way which forces you to write a lot of boilerplate code. Then, when you first write the class, return a const reference to a vector, and then refactor.
