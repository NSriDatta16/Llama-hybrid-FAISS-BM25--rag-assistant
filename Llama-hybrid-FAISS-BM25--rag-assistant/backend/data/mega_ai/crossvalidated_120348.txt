[site]: crossvalidated
[post_id]: 120348
[parent_id]: 120028
[tags]: 
The problem is caused by the way that PyMC draws samples for this model. As explained in section 5.8.1 of the PyMC documentation, all elements of an array variable are updated together. For small arrays like center this is not a problem, but for a large array like category it leads to a low acceptance rate. You can see the acceptance rate via print mcmc.step_method_dict[category][0].ratio The solution suggested in the documentation is to use an array of scalar-valued variables. In addition, you need to configure some of the proposal distributions since the default choices are bad. Here is the code that works for me: import pymc as pm sigmas = pm.Normal('sigmas', mu=0.1, tau=1000, size=2) centers = pm.Normal('centers', [0.3, 0.7], [1/(0.1)**2, 1/(0.1)**2], size=2) alpha = pm.Beta('alpha', alpha=2, beta=3) category = pm.Container([pm.Categorical("category%i" % i, [alpha, 1 - alpha]) for i in range(nsamples)]) observations = pm.Container([pm.Normal('samples_model%i' % i, mu=centers[category[i]], tau=1/(sigmas[category[i]]**2), value=samples[i], observed=True) for i in range(nsamples)]) model = pm.Model([observations, category, alpha, sigmas, centers]) mcmc = pm.MCMC(model) # initialize in a good place to reduce the number of steps required centers.value = [mu1_true, mu2_true] # set a custom proposal for centers, since the default is bad mcmc.use_step_method(pm.Metropolis, centers, proposal_sd=sig1_true/np.sqrt(nsamples)) # set a custom proposal for category, since the default is bad for i in range(nsamples): mcmc.use_step_method(pm.DiscreteMetropolis, category[i], proposal_distribution='Prior') mcmc.sample(100) # beware sampling takes much longer now # check the acceptance rates print mcmc.step_method_dict[category[0]][0].ratio print mcmc.step_method_dict[centers][0].ratio print mcmc.step_method_dict[alpha][0].ratio The proposal_sd and proposal_distribution options are explained in section 5.7.1 . For the centers, I set the proposal to roughly match the standard deviation of the posterior, which is much smaller than the default due to the amount of data. PyMC does attempt to tune the width of the proposal, but this only works if your acceptance rate is sufficiently high to begin with. For category , the default proposal_distribution = 'Poisson' which gives poor results (I don't know why this is, but it certainly doesn't sound like a sensible proposal for a binary variable).
