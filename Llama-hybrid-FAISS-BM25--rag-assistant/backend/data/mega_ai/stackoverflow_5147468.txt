[site]: stackoverflow
[post_id]: 5147468
[parent_id]: 5142329
[tags]: 
Displaying one DataSource at runtime, and other at DesignTime is not ugly at all. I think what you are fighting with is fairly common when using DataTables, DataSets, and DataGridViews and the designer. Its a great tool if are working with very simple Master/Detail forms and don't want step outside of standard behaviors. In the scenario you have described, you want to alter the normal usage of these items so that you can pre-load the data when the application starts. As you've found out, this causes a few issue that you now have to handle on your own. Part of handling that issue is resetting the DataSource to a new value at runtime. That's not inelegant or bad practice at all. However, when you start talking about fakes, and caching due to performance concerns, I wonder if you really want a database at all. It seems like you are looking to develop a model (using C# objects) that you can bind to, update, and serialize as needed. While I'm not sure thats true for your design, if it were my design (with my limited understanding of your problem) thats what I would be doing. A database would not be a big part of my project at this point, if at all. I would build C# objects that represent my tables, a model class to manage those items, and a factory to instantiate the model and manage its lifetime. If, at some point, I had to serialize/interact to/with a database, I would build that into the model. A bigger question for me in regards to elegance, is how would I test all of this? If I'm binding at design time, and relying on a static to load at run time, then my design has blocked me from performing any sort of unit, or class-based integration tests. If I had separated out the database stuff into a model, then I would have separated the concern of data management into a class that I could stick an interface into, which gives me something to fake or mock and stub.
