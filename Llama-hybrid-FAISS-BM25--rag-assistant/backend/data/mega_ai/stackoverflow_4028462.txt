[site]: stackoverflow
[post_id]: 4028462
[parent_id]: 4028413
[tags]: 
When you use a reference, it looks the same as a value. Only if you really aren't paying attention to what you are doing. Ok, sometimes that happens, but really... no amount of coding standards can correct for people not paying attention or not knowing what they are doing. The caller may be surprised that his value has been changed after calling the function. If you are surprised by what happens when you call a function, then the function is poorly documented. Given a function's name, its parameter list, and perhaps some very brief and descriptive documentation, it should be eminently clear what the function does and what its observable side effects are (including whether any arguments are modified). The callee may innocently modify the value without meaning to affect the caller's value. If the function is const correct, then this isn't a problem. If the function isn't const correct, then it should be made const correct, if you can (retroactively making code const correct can be an absolute beating). This rationale doesn't make much sense, though: when you are actually writing the code for a function, you should be able to see the declarations of the parameters. If the function is so long that you can't, it's time for refactoring. By using a pointer, it is clear to both the caller and callee that the value can be changed. This is not entirely correct. A function can take a pointer to const object, in which case the object cannot be changed. Using references can be particularly misleading in code reviews. Only if the people doing the code reviews don't know what they are doing. All of that is well and good, but why should pass-by-reference be used instead of pass-by-pointer? The most obvious reason is that a reference cannot be null . In a function that takes a pointer, you have to check that the pointer is not null before you use it, at least with a debug assertion. During a proper code review you have to analyze more code to be sure that you don't accidentally pass a null pointer to a function that doesn't expect one. I've found that it takes much longer to review functions that take pointer arguments for this very reason; it's so much easier to get it wrong when using pointers.
