[site]: stackoverflow
[post_id]: 3957729
[parent_id]: 3957348
[tags]: 
In my opinion, member function pointers do are not terribly useful to the average programmer in their raw form. OTOH, constructs like ::std::tr1::function that wrap member function pointers together with a pointer to the object they're supposed to operate on are extremely useful. Of course ::std::tr1::function is very complex. So I will give you a simple example that you wouldn't actually use in practice if you had ::std::tr1::function available: // Button.hpp #include class Button { public: Button(/* stuff */) : hdlr_(0), myhandler_(false) { } ~Button() { // stuff if (myhandler_) { delete hdlr_; } } class PressedHandler { public: virtual ~PressedHandler() = 0; virtual void buttonPushed(Button *button) = 0; }; // ... lots of stuff // This stores a pointer to the handler, but will not manage the // storage. You are responsible for making sure the handler stays // around as long as the Button object. void setHandler(const PressedHandler &hdlr) { hdlr_ = &hdlr; myhandler_ = false; } // This stores a pointer to an object that Button does not manage. You // are responsible for making sure this object stays around until Button // goes away. template inline void setHandlerFunc(T &dest, void (T::*pushed)(Button *)); private: const PressedHandler *hdlr_; bool myhandler_; template class PressedHandlerT : public Button::PressedHandler { public: typedef void (T::*hdlrfuncptr_t)(Button *); PressedHandlerT(T *ob, hdlrfuncptr_t hdlr) : ob_(ob), func_(hdlr) { } virtual ~PressedHandlerT() {} virtual void buttonPushed(Button *button) { (ob_->*func_)(button); } private: T * const ob_; const hdlrfuncptr_t func_; }; }; template inline void Button::setHandlerFunc(T &dest, void (T::*pushed)(Button *)) { PressedHandler *newhandler = new PressedHandlerT (&dest, pushed); if (myhandler_) { delete hdlr_; } hdlr_ = newhandler; myhandler_ = true; } // UseButton.cpp #include "Button.hpp" #include class NoiseMaker { public: NoiseMaker(); void squee(Button *b); void hiss(Button *b); void boo(Button *b); private: typedef ::std::auto_ptr buttonptr_t; const buttonptr_t squeebutton_, hissbutton_, boobutton_; }; NoiseMaker::NoiseMaker() : squeebutton_(new Button), hissbutton_(new Button), boobutton_(new Button) { squeebutton_->setHandlerFunc(*this, &NoiseMaker::squee); hissbutton_->setHandlerFunc(*this, &NoiseMaker::hiss); boobutton_->setHandlerFunc(*this, &NoiseMaker::boo); } Assuming Button is in a library and not alterable by you, I would enjoy seeing you implement that cleanly using a virtual base class without resorting to a switch or if else if construct somewhere.
