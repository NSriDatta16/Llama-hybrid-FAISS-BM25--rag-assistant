beat, a penalty can be added for deviating from equal weights. Or, if cross-validation is applied to assign individual weights to observations, then one can penalize deviations from equal weights to avoid wasting potentially relevant information. Hoornweg (2018) shows how a tuning parameter γ {\displaystyle \gamma } can be defined so that a user can intuitively balance between the accuracy of cross-validation and the simplicity of sticking to a reference parameter λ R {\displaystyle \lambda _{R}} that is defined by the user. If λ i {\displaystyle \lambda _{i}} denotes the i t h {\displaystyle i^{th}} candidate configuration that might be selected, then the loss function that is to be minimized can be defined as L λ i = ( 1 − γ ) Relative Accuracy i + γ Relative Simplicity i . {\displaystyle L_{\lambda _{i}}=(1-\gamma ){\mbox{ Relative Accuracy}}_{i}+\gamma {\mbox{ Relative Simplicity}}_{i}.} Relative accuracy can be quantified as MSE ( λ i ) / MSE ( λ R ) {\displaystyle {\mbox{MSE}}(\lambda _{i})/{\mbox{MSE}}(\lambda _{R})} , so that the mean squared error of a candidate λ i {\displaystyle \lambda _{i}} is made relative to that of a user-specified λ R {\displaystyle \lambda _{R}} . The relative simplicity term measures the amount that λ i {\displaystyle \lambda _{i}} deviates from λ R {\displaystyle \lambda _{R}} relative to the maximum amount of deviation from λ R {\displaystyle \lambda _{R}} . Accordingly, relative simplicity can be specified as ( λ i − λ R ) 2 ( λ max − λ R ) 2 {\displaystyle {\frac {(\lambda _{i}-\lambda _{R})^{2}}{(\lambda _{\max }-\lambda _{R})^{2}}}} , where λ max {\displaystyle \lambda _{\max }} corresponds to the λ {\displaystyle \lambda } value with the highest permissible deviation from λ R {\displaystyle \lambda _{R}} . With γ ∈ [ 0 , 1 ] {\displaystyle \gamma \in [0,1]} , the user determines how high the influence of the reference parameter is relative to cross-validation. One can add relative simplicity terms for multiple configurations c = 1 , 2 , . . . , C {\displaystyle c=1,2,...,C} by specifying the loss function as L λ i = Relative Accuracy i + ∑ c = 1 C γ c 1 − γ c Relative Simplicity i , c . {\displaystyle L_{\lambda _{i}}={\mbox{ Relative Accuracy}}_{i}+\sum _{c=1}^{C}{\frac {\gamma _{c}}{1-\gamma _{c}}}{\mbox{ Relative Simplicity}}_{i,c}.} Hoornweg (2018) shows that a loss function with such an accuracy-simplicity tradeoff can also be used to intuitively define shrinkage estimators like the (adaptive) lasso and Bayesian / ridge regression. Click on the lasso for an example. Statistical properties Suppose we choose a measure of fit F, and use cross-validation to produce an estimate F* of the expected fit EF of a model to an independent data set drawn from the same population as the training data. If we imagine sampling multiple independent training sets following the same distribution, the resulting values for F* will vary. The statistical properties of F* result from this variation. The variance of F* can be large. For this reason, if two statistical procedures are compared based on the results of cross-validation, the procedure with the better estimated performance may not actually be the better of the two procedures (i.e. it may not have the better value of EF). Some progress has been made on constructing confidence intervals around cross-validation estimates, but this is considered a difficult problem. Computational issues Most forms of cross-validation are straightforward to implement as long as an implementation of the prediction method being studied is available. In particular, the prediction method can be a "black box" – there is no need to have access to the internals of its implementation. If the prediction method is expensive to train, cross-validation can be very slow since the training must be carried out repeatedly. In some cases such as least squares and kernel regression, cross-validation can be sped up significantly by pre-computing certain values that are needed repeated