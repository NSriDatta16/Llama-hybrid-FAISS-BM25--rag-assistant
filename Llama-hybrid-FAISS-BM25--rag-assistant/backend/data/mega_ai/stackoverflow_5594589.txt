[site]: stackoverflow
[post_id]: 5594589
[parent_id]: 5594102
[tags]: 
The :active pseudo-class applies while an element is being activated by the user. For example, between the times the user presses the mouse button and releases it. See W3 documentation . But you are applying your :active selector to your element, which cannot have an active state since it never really gets activated - only hovered. You should apply :active state to UPDATE: Here's a test sample at jsFiddle as you can see it works ok on element but not ok on Interesting info I found here The :active pseudo-class applies while a link is being selected by the user. CSS1 was a little ambiguous on this behavior: "An 'active' link is one that is currently being selected (e.g. by a mouse button press) by the reader." Also, in CSS1, :active was mutually exclusive from :link and :visited. (And there was no :hover pseudo-class.) CSS2 changed things so that rules for :active can apply at the same time as :visited or :link. And the behavior was explained a little better: "The :active pseudo-class applies while an element is being activated by the user. For example, between the times the user presses the mouse button and releases it." IMO, FF et al comply with CSS2 better than IE. But since a link is supposed to load a new page, IE could legitimately say the link is still "active" while the new page is loading, which is what happens. You can see a similar counter-intuitive behavior in FF by clicking the link, but moving your mouse off of the link while holding the mouse-button down. The link is not activated (a new page is not loaded), but the link remains in the :active state. On the other hand, Chrome and Opera de-activate the link, but at different times; Chrome as soon as the mouse leaves the link area, Opera not till the mouse button is released. IE behaves the same as FF in this example. (Hit enter after dragging your mouse off the link, and you will see more differences in behavior.) I would not call any of these differences "bugs", because of ambiguities in the spec. The only work-around I can offer is to accept that you can't control every aspect of browser behavior. Users of different browsers have differing expectations of behavior, and if you start messing with user expectation, you're on the wrong path.
