[site]: stackoverflow
[post_id]: 3294270
[parent_id]: 3294042
[tags]: 
Well, there's no easy answer to this question. As @Redlab asked, are the preferences frequently changing? If so, then the DB seems like the "better" alternative. But there is a lot more to it than that... Are there a lot of these preferences? If so, then storing it in the filesystem may make sense with namespaced files and hiearchial storage. So for example: In site.php return array( 'title' => 'This is my page title', 'meta' => array( 'description' => 'My Meta Description', 'keywords' => 'key1, key2, key3', ), ); Basically, create a file for each "namespace" to group things together. The advantage to doing it this way is performance and managability. You can lazy-load the config on a per-namespace basis as needed. You could mimic the effect in the database by adding a field called namespace, and then lazy-loading those fields, but it's going to be significantly slower since every access requires a query. If you have a lot of settings, then loading it from the db on every page hit (even once) is not going to be optimal either... What I do is use dot notation. So from the above example, to get the meta keywords would be site.meta.keywords . It's actually reasonably easy to do: class Config { protected $data = array(); public function get($name, $default = null) { $parts = explode('.', $name); $ns = array_shift($parts); if (!isset($this->data[$ns])) { $this->loadNS($ns); } $search = $this->data[$ns]; foreach ($parts as $part) { if (is_array($search) && isset($search[$part])) { $search = $search[$part]; } else { return $default; } } return $search; } protected loadNS($name) { $path = PATH_TO_CONFIG . $name . '.php'; if (is_file($path)) { $this->data[$name] = include($path); } else { $this->data[$name] = array(); } } } You can add a set and a save method just as easy. To save the files: public function saveToFile($ns) { if (!isset($this->data[$ns])) { $this->loadNS($ns); } $out = ' data[$ns], true).';'; $path = PATH_TO_CONFIG . $ns . '.php' file_put_contents($path, $out); } What results is a very easy to maintain (since it's only ever writing to the filesystem) and easy to modify by hand (since it's all just php code) system for storing and retrieving information. And best of all, since it can take advantage of opcode caches, it's VERY efficient and won't slow your page down at all...
