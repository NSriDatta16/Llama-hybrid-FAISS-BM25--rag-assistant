[site]: stackoverflow
[post_id]: 2203502
[parent_id]: 2203143
[tags]: 
There are various methods to accomplish the parts you ask are asking about. Passing Values There are dozens of ways to do this. Here are a few ideas to get you started: Pass in a string of identifiers and parse it into a table, then join. SQL 2008: Join to a table-valued parameter Expect data to exist in a predefined temp table and join to it Use a session-keyed permanent table Put the code in a trigger and join to the INSERTED and DELETED tables in it. Erland Sommarskog provides a wonderful comprehensive discussion of lists in sql server . In my opinion, the table-valued parameter in SQL 2008 is the most elegant solution for this. Upsert/Merge Perform a separate UPDATE and INSERT (two queries, one for each set, not row-by-row). SQL 2008: MERGE. An Important Gotcha However, one thing that no one else has mentioned is that almost all upsert code, including SQL 2008 MERGE , suffers from race condition problems when there is high concurrency. Unless you use HOLDLOCK and other locking hints depending on what's being done, you will eventually run into conflicts. So you either need to lock, or respond to errors appropriately (some systems with huge transactions per second have used the error-response method successfully, instead of using locks). One thing to realize is that different combinations of lock hints implicitly change the transaction isolation level, which affects what type of locks are acquired. This changes everything: which other locks are granted (such as a simple read), the timing of when a lock is escalated to update from update intent, and so on. I strongly encourage you to read more detail on these race condition problems. You need to get this right. Conditional Insert/Update Race Condition “UPSERT” Race Condition With MERGE Example Code CREATE PROCEDURE dbo.PermitStatusUpdate @PermitIDs varchar(8000), -- or (max) @Status int AS SET NOCOUNT, XACT_ABORT ON -- see note below BEGIN TRAN DECLARE @Permits TABLE ( PermitID int NOT NULL PRIMARY KEY CLUSTERED ) INSERT @Permits SELECT Value FROM dbo.Split(@PermitIDs) -- split function of your choice UPDATE S SET UpdatedOn = GETUTCDATE(), Status = @Status FROM PermitStatus S WITH (UPDLOCK, HOLDLOCK) INNER JOIN @Permits P ON S.PermitID = P.PermitID INSERT PermitStatus ( PermitID, UpdatedOn, Status ) SELECT P.PermitID, GetUTCDate(), @Status FROM @Permits P WHERE NOT EXISTS ( SELECT 1 FROM PermitStatus S WHERE P.PermitID = S.PermitID ) COMMIT TRAN RETURN @@ERROR; Note: XACT_ABORT helps guarantee the explicit transaction is closed following a timeout or unexpected error. To confirm that this handles the locking problem, open several query windows and execute an identical batch like so: WAITFOR TIME '11:00:00' -- use a time in the near future EXEC dbo.PermitStatusUpdate @PermitIDs = '123,124,125,126', 1 All of these different sessions will execute the stored procedure in nearly the same instant. Check each session for errors. If none exist, try the same test a few times more (since it's possible to not always have the race condition occur, especially with MERGE). The writeups at the links I gave above give even more detail than I did here, and also describe what to do for the SQL 2008 MERGE statement as well. Please read those thoroughly to truly understand the issue. Briefly, with MERGE, no explicit transaction is needed, but you do need to use SET XACT_ABORT ON and use a locking hint: SET NOCOUNT, XACT_ABORT ON; MERGE dbo.Table WITH (HOLDLOCK) AS TableAlias ... This will prevent concurrency race conditions causing errors. I also recommend that you do error handling after each data modification statement.
