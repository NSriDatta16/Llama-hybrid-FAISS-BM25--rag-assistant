[site]: stackoverflow
[post_id]: 4229809
[parent_id]: 
[tags]: 
Do i need to rewrite my async methods/class to implement the features I want?

I have a class that proccesses n number of http requests / repsonses asynchronously and recursively. I was pretty happy with my class until I realised that I may have coded myself into a bit of a hole. Essentially I would like to raise an event after each response is read to comfirm if the application has proceeded to the next or finished early for whatever reason. I will admit I am really new to asynchronous programming so I am using the Async Enumerator class to help me out. I don't mind having to rewrite this method or indeed the entire class as long as the base functionality remains the same, that is it takes n number of requests and reads through them sequencially. using System; using System.Net; using System.Windows; using System.Windows.Controls; using System.Windows.Documents; using System.Windows.Ink; using System.Windows.Input; using System.Windows.Media; using System.Windows.Media.Animation; using System.Windows.Shapes; using Webtext.Implementations; using Webtext.Interfaces; using Wintellect.Threading.AsyncProgModel; using System.Collections.Generic; using System.IO; using System.Text; namespace Webtext.Implementations { public class SMSSender : Interfaces.IOperator { private HttpWebRequest httpRequester; private HttpWebResponse httpResponse; private IOperatorRequestCollection requestCollection; private IUrlBuilder urlBuilder; private AsyncEnumerator asyncEnum; private CookieContainer cookieContainer; CookieCollection cookieCollection; public SMSSender() { cookieContainer = new CookieContainer(); cookieCollection = new CookieCollection(); } public void Send(string UserName, string Password, string MessageRecipient, string Message, OperatorList Operator) { urlBuilder = new UrlBuilder(); requestCollection = new OperatorRequestCollection { OperatorRequestList = urlBuilder.GetUrlRequests(UserName, Password, MessageRecipient, Message, Operator) }; ProcessRequests(); } private void ProcessRequests() { asyncEnum = new AsyncEnumerator(); asyncEnum.BeginExecute(GetData(asyncEnum, requestCollection.GetCurrentRequest()), asyncEnum.EndExecute); } private IEnumerator GetData(AsyncEnumerator asyncEnum, IOperatorRequest request) { httpRequester = (HttpWebRequest)WebRequest.Create(request.RequestUrl); httpRequester.AllowAutoRedirect = true; httpRequester.UserAgent = "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6"; if (httpRequester.CookieContainer == null) httpRequester.CookieContainer = cookieContainer; httpRequester.BeginGetResponse(asyncEnum.End(), null); yield return 1; httpResponse = (HttpWebResponse)httpRequester.EndGetResponse(asyncEnum.DequeueAsyncResult()); if (httpResponse.StatusCode == HttpStatusCode.OK) { // Create the stream, encoder and reader. Stream responseStream = httpResponse.GetResponseStream(); Encoding streamEncoder = Encoding.UTF8; StreamReader responseReader = new StreamReader(responseStream, streamEncoder); CheckRequest(request, responseReader.ReadToEnd()); } } private void CheckRequest(IOperatorRequest Request, string Response) { if (Response.Contains(Request.SuccessMessage)) { AddCookiesToRequest(); bool lastCallFinished = false; if (requestCollection.GetCurrentRequest() != requestCollection.GetLastRequest()) { requestCollection.MoveNextToCurrent(); ProcessRequests(); } else { if (lastCallFinished == false) { ProcessRequests(); lastCallFinished = true; } } } } private void AddCookiesToRequest() { // This method is O2 specific at the moment. I do not know if this sort of methods // will be needed for the others so for the moment it stays as is. cookieCollection.Add(httpResponse.Cookies); foreach (Cookie cookie in cookieCollection) { cookie.Path = "/"; cookie.Domain = "o2online.ie"; } cookieContainer.Add(httpResponse.ResponseUri, cookieCollection); } } } EDIT: This edit is to explain what I am looking to do: I am essentially making 5 (This could be n number) requests using HttpWebRequest. I am doing this recursively as each new request depends on the response gotten from the previous request. This functionality works currently. The issue I am having is, as the responses are coming back asynchronously I have no way of getting back to the UI thread to let the UI know how far along I am. If any of the response fails the collection of requests fails as a whole so it would be nice to know which request failed as well as why. I would also like to have another async operation working that can take in this data and display it with an indeterminate progress bar. That way the user is getting real time data from the UI as to how far along the operation is and if it failed why. I tried a backround worker here but because the first request is asyncrhonous and DO_WORK is a synchronous method the WORK_Completed event of a backround worker is called before the work is actually finished. As for the AsyncEnumerator. It essentially uses an enumerator to specify what to do after yield (It calls move next when HttpEndGetResponse is ready). This eleviates some of the issues in that I can marshal an event back to the UI thread to talk to the progress worker but it is still messy so I have not yet implemented it. What I would like to do is fire off a SEND method on a SENDER object, then fire off a SHOW_PROGRESS method on a different async call using a PROGRESSDISPLAY object. As each iteration of the Send method yields send data back to the UI which sends it off the PROGRESSDISPLAY object and allow it to update until the final call which would tell PROGRESSDISPLAY to close.
