[site]: stackoverflow
[post_id]: 2347718
[parent_id]: 2312978
[tags]: 
I would suggest the super-type Author for Person and Organization sub-types. Note that AuthorID serves as the primary and the foreign key at the same time for Person and Organization tables. So first let's create tables: CREATE TABLE Author( AuthorID integer IDENTITY NOT NULL ,AuthorType char(1) ,Phone varchar(20) ,Email varchar(128) NOT NULL ); ALTER TABLE Author ADD CONSTRAINT pk_Author PRIMARY KEY (AuthorID); CREATE TABLE Article ( ArticleID integer IDENTITY NOT NULL ,AuthorID integer NOT NULL ,DatePublished date ,Headline varchar(100) ,Content varchar(max) ); ALTER TABLE Article ADD CONSTRAINT pk_Article PRIMARY KEY (ArticleID) ,CONSTRAINT fk1_Article FOREIGN KEY (AuthorID) REFERENCES Author(AuthorID) ; CREATE TABLE Person ( AuthorID integer NOT NULL ,FirstName varchar(50) ,LastName varchar(50) ); ALTER TABLE Person ADD CONSTRAINT pk_Person PRIMARY KEY (AuthorID) ,CONSTRAINT fk1_Person FOREIGN KEY (AuthorID) REFERENCES Author(AuthorID); CREATE TABLE Organization ( AuthorID integer NOT NULL ,OrgName varchar(40) ,OrgPassword varchar(128) ,OrgCountry varchar(40) ,OrgState varchar(40) ,OrgZIP varchar(16) ,OrgContactName varchar(100) ); ALTER TABLE Organization ADD CONSTRAINT pk_Organization PRIMARY KEY (AuthorID) ,CONSTRAINT fk1_Organization FOREIGN KEY (AuthorID) REFERENCES Author(AuthorID); When inserting into Author you have to capture the auto-incremented id and then use it to insert the rest of data into person or organization, depending on AuthorType . Each row in Author has only one matching row in Person or Organization , not in both. Here is an example of how to capture the AuthorID . -- Insert into table and return the auto-incremented AuthorID INSERT INTO Author ( AuthorType, Phone, Email ) OUTPUT INSERTED.AuthorID VALUES ( 'P', '789-789-7899', 'dudete@mmahoo.com' ); Here are a few examples of how to query authors: -- Return all authors (org and person) SELECT * FROM dbo.Author AS a LEFT JOIN dbo.Person AS p ON a.AuthorID = p.AuthorID LEFT JOIN dbo.Organization AS c ON c.AuthorID = a.AuthorID ; -- Return all-organization authors SELECT * FROM dbo.Author AS a JOIN dbo.Organization AS c ON c.AuthorID = a.AuthorID ; -- Return all person-authors SELECT * FROM dbo.Author AS a JOIN dbo.Person AS p ON a.AuthorID = p.AuthorID And now all articles with authors. -- Return all articles with author information SELECT * FROM dbo.Article AS x JOIN dbo.Author AS a ON a.AuthorID = x.AuthorID LEFT JOIN dbo.Person AS p ON a.AuthorID = p.AuthorID LEFT JOIN dbo.Organization AS c ON c.AuthorID = a.AuthorID ; There are two ways to return all articles belonging to organizations. The first example returns only columns from the Organization table, while the second one has columns from the Person table too, with NULL values. -- (1) Return all articles belonging to organizations SELECT * FROM dbo.Article AS x JOIN dbo.Author AS a ON a.AuthorID = x.AuthorID JOIN dbo.Organization AS c ON c.AuthorID = a.AuthorID; -- (2) Return all articles belonging to organizations SELECT * FROM dbo.Article AS x JOIN dbo.Author AS a ON a.AuthorID = x.AuthorID LEFT JOIN dbo.Person AS p ON a.AuthorID = p.AuthorID LEFT JOIN dbo.Organization AS c ON c.AuthorID = a.AuthorID WHERE AuthorType = 'O'; And to return all articles belonging to a specific organization, again two methods. -- (1) Return all articles belonging to a specific organization SELECT * FROM dbo.Article AS x JOIN dbo.Author AS a ON a.AuthorID = x.AuthorID JOIN dbo.Organization AS c ON c.AuthorID = a.AuthorID WHERE c.OrgName = 'somecorp'; -- (2) Return all articles belonging to a specific organization SELECT * FROM dbo.Article AS x JOIN dbo.Author AS a ON a.AuthorID = x.AuthorID LEFT JOIN dbo.Person AS p ON a.AuthorID = p.AuthorID LEFT JOIN dbo.Organization AS c ON c.AuthorID = a.AuthorID WHERE c.OrgName = 'somecorp'; To make queries simpler, you could package some of this into a view or two. Just as a reminder, it is common for an article to have several authors, so a many-to-many table Article_Author would be in order.
