[site]: stackoverflow
[post_id]: 2373033
[parent_id]: 
[tags]: 
Persistance JDO - How to query a property of a collection with JDOQL?

I want to build an application where a user identified by an email address can have several application accounts. Each account can have one or more users. I am trying to use the JDO Storage capabilities with Google App Engine Java. Here is my attempt: @PersistenceCapable @Inheritance(strategy = InheritanceStrategy.NEW_TABLE) public class AppAccount { @PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY) private Long id; @Persistent private String companyName; @Persistent List invoices = new ArrayList (); @Persistent List users = new ArrayList (); // Getter Setters and Other Fields } @PersistenceCapable @EmbeddedOnly public class AppUser { @Persistent private String username; @Persistent private String firstName; @Persistent private String lastName; // Getter Setters and Other Fields } When a user logs in, I want to check how many accounts he belongs to. If he or she belongs to more than one then he or she will be presented with a dashboard where he/she can click which account he/she wants to load. This is my code to retrieve a list of app accounts where he/she is registered. public static List getUserAppAccounts(String username) { PersistenceManager pm = JdoUtil.getPm(); Query q = pm.newQuery(AppAccount.class); q.setFilter("users.username == usernameParam"); q.declareParameters("String usernameParam"); return (List ) q.execute(username); } But I get the next error: SELECT FROM invoices.server.AppAccount WHERE users.username == usernameParam PARAMETERS String usernameParam: Encountered a variable expression that isn't part of a join. Maybe you're referencing a non-existent field of an embedded class. org.datanucleus.store.appengine.FatalNucleusUserException: SELECT FROM com.softamo.pelicamo.invoices.server.AppAccount WHERE users.username == usernameParam PARAMETERS String usernameParam: Encountered a variable expression that isn't part of a join. Maybe you're referencing a non-existent field of an embedded class. at org.datanucleus.store.appengine.query.DatastoreQuery.getJoinClassMetaData(DatastoreQuery.java:1154) at org.datanucleus.store.appengine.query.DatastoreQuery.addLeftPrimaryExpression(DatastoreQuery.java:1066) at org.datanucleus.store.appengine.query.DatastoreQuery.addExpression(DatastoreQuery.java:846) at org.datanucleus.store.appengine.query.DatastoreQuery.addFilters(DatastoreQuery.java:807) at org.datanucleus.store.appengine.query.DatastoreQuery.performExecute(DatastoreQuery.java:226) at org.datanucleus.store.appengine.query.JDOQLQuery.performExecute(JDOQLQuery.java:85) at org.datanucleus.store.query.Query.executeQuery(Query.java:1489) at org.datanucleus.store.query.Query.executeWithArray(Query.java:1371) at org.datanucleus.jdo.JDOQuery.execute(JDOQuery.java:243) at com.softamo.pelicamo.invoices.server.Store.getUserAppAccounts(Store.java:82) at com.softamo.pelicamo.invoices.test.server.StoreTest.testgetUserAppAccounts(StoreTest.java:39) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:46) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197) Any ideas? Am I getting JDO persistance totally wrong?
