[site]: crossvalidated
[post_id]: 616637
[parent_id]: 616618
[tags]: 
Given that you only have summary data (not the full dataset) then the scikit-learn metrics package will not work as expected. I found this useful blog that I think may help you understand how that function works. The blog uses an example very similar to your question. Also, I need 50 creds to write comments on posts, so I wasn't able to ask for clarification. However, based on your data, it seems that you are trying to calculate the fpr and tpr of a good/bad borrower classifier. My interpretation is that the "No. Borrowers" column is the number of borrowers classified as good borrowers by the model given that you use a threshold of selecting the top $i^{th}$ decile, while the other two columns are the true number of good and bad borrowers at that decile. If that is the case, then we must make a few corrections to the code. Remember that $FPR = \frac{FP}{FP + TN}$ therefore at a given threshold we must divide the total number of accepted bad borrowers (the cumulative sum until the $i^{th}$ threshold) and divide by the total number of bad borrowers. similarly, the tpr may be computed using the formula: $TPR = \frac{TP}{TP + FN}$ Your accuracy can be calculated with the following formula $Acc = \frac{TP + TN}{Total\_population}$ . In other words, your accepted positives (cumulative sum of good borrowers until $i^{th}$ threshold), plus your denied negatives (sum of bad borrowers beyond $i^{th}$ threshold), divided by you total number of borrowers. Here is my implementation of your code. I will ignore code #1 since I believe code #2 is closer to a good answer. I have also taken the liberty to make the code a bit cleaner by using more built-in tools from numpy and pandas. import pandas as pd import numpy as np import matplotlib.pyplot as plt # Create a data frame to store the number of borrowers, good borrowers, and bad borrowers in each decile. data = { "Decile": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "No. Borrowers": [100, 300, 200, 300, 600, 200, 700, 800, 900, 1000], "Good Borrowers": [80, 160, 140, 220, 500, 100, 560, 640, 150, 800], "Bad Borrowers": [20, 140, 60, 80, 100, 100, 140, 160, 750, 200] } df = pd.DataFrame(data) total_population = df['No. Borrowers'].sum() df['TP'] = df['Good Borrowers'].cumsum() df['FN'] = df['Good Borrowers'].sum() - df['Good Borrowers'].cumsum() df['FP'] = df['Bad Borrowers'].cumsum() df['TN'] = df['Bad Borrowers'].sum() - df['Bad Borrowers'].cumsum() df['fpr'] = df.FP / (df.FP + df.TN) df['tpr'] = df.TP / (df.TP + df.FN) df['acc'] = (df.TP + df.TN) / total_population # Calculate the AUC. auc = np.trapz(df.tpr,df.fpr) print("AUC:", auc) # Calculate the Gini coefficient. gini = 2*auc - 1 print("Gini coefficient:", gini) # Plot the ROC curve. plt.plot(df.fpr, df.tpr) plt.xlabel("False Positive Rate") plt.ylabel("True Positive Rate") plt.title("ROC Curve") plt.fill_between(df.fpr, df.tpr, alpha = 0.1) plt.text(0.6, 0.4, f'AUC = {auc:0.3}\n Gini = {gini:0.3}') plt.show() Please let me know if you need any clarification. I am pretty new to StackExchange so I'm still getting used to this type of communication skill :)
