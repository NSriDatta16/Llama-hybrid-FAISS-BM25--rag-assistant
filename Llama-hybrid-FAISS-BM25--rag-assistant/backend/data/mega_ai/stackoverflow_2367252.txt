[site]: stackoverflow
[post_id]: 2367252
[parent_id]: 2367153
[tags]: 
I did something "similar" where I had 4 scrollViews incased inside a parent view. I placed a scrollView inside a UIView, this UIView was passed a delegate from its parentView, that was the view who kept track of all the scrollViews. The UIView containing a scrollVIew implemented the UIScrollViewDelegate and this method; - (void)scrollViewDidScroll:(UIScrollView *) theScrollView { [self.delegate scrolling:[self.scrollView contentOffSet]]; } Now the parent view did this on all the scrollViews: - (void) scrolling:(CGFloat) offset { for(UIScrollView *s in self) { [s setContentOffset:offset animated:YES]; } } It is of course a bit of a strain on the CPU, but scrolling several views will be that under any circumstances :/ Hope this was something in the direction of what you needed, and that it made any sense. Added: I took me 8 different paths and a lot of mass chaos before I made it work. I dropped the touchedBegan approach early, there is just no way to write something that comes close to Apples swipe, flick, scroll algorithms. I don't know if the tableview and scrollview will "steal" each others touch events, but as I can read from your description you made that part work. A follow up idea to ease the CPU usage. add each scrollview to a cell, set its tag=14, now when scrolling asked for all visible cells only, ask for viewWithTag=14, set the contentOffset on this. Save the content offset globally so you can assign it to cells being scrolled onto the screen in cellForRowAtIndexPath . So set the offSet to a global property, in cellForRowAtIndexPath find the view with tag = 14, set its offset. This way you don't even need a reference to the scrollViews only the delegate.
