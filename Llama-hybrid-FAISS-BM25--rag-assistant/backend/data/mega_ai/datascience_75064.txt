[site]: datascience
[post_id]: 75064
[parent_id]: 74948
[tags]: 
Since you want to save the training min/max and use those to replace inf's in the test set, you need a custom transformer . To build a robust transformer, you should use some of sklearn's validation functions. And it's best to work in numpy, since as you point out an earlier transformer in a pipeline will have already converted an input dataframe to an nparray. (You could stick with dataframes, and either convert in your transformer (losing some efficiency), or make sure your transformer always comes first in a pipeline (alright if you're the only one using your code).) Then, here's a simple version. I'm opting not to have the numeric_features as input; you're probably better off using a ColumnTransformer to do that kind of selection for you. from sklearn.utils import check_array from sklearn.utils.validation import check_is_fitted from sklearn.base import TransformerMixin, BaseEstimator class ReplaceInf(TransformerMixin, BaseEstimator): '''Replace +-np.inf with the max/min finite values in each column. Attributes ---------- mins_ : np.ndarray Per-column minimum finite values. maxs_ : np.ndarray Per-column maximum finite values. ''' def fit(self, X, y=None): # validate and convert if possible: X = check_array(X, force_all_finite=False) # using `where=np.isfinite(X)`, nan's won't affect the min/max calculation, # and using `clip` to transform will preserve nan's as well. self.mins_ = np.amin(X, axis=0, where=np.isfinite(X), initial=np.inf) self.maxs_ = np.amax(X, axis=0, where=np.isfinite(X), initial=-np.inf) return self def transform(self, X): X = check_array(X, force_all_finite=False) return np.clip(X, self.mins_, self.maxs_)
