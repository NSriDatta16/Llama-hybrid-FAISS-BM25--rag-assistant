[site]: stackoverflow
[post_id]: 1695940
[parent_id]: 1695759
[tags]: 
You can express your assertion as a property to check with a static analyzer and let the analyzer do the check. This has some of the properties of what you want to do: the property is written in the source code, it doesn't pollute the generated binary code. However, it is different from a compile-time assertion because it needs a separate tool to be run on the program for checking. And perhaps it's a sanity check on the compiler you were trying to do, in which case this doesn't help because the static analyzer doesn't check what the compiler does, only what it should do. ADDED: if it's for QA, then writing "formal" assertions that can be verified statically is all the rage nowadays. The approach below is very similar to .NET contracts that you may have heard about, but it is for C. You may not think much of static analyzers, but it is loops and function calls that cause them to become imprecise. It's easier for them to get a clear picture of what is going on at initialization time, before any of these have happened. Some analyzers advertise themselves as "correct", that is, they do not remain silent if the property you write is outside of their capabilities. In this case they complain that they can't prove it. If this happens, after you have convinced yourself that the problem is with the analyzer and not with your array, you'll be left where you are now, looking for another way. Taking the example of the analyzer I am familiar with: const int t[3] = {1, 2, 3}; int x; int main(){ //@ assert t[2] == 3 ; /* more code doing stuff */ } Run the analyzer: $ frama-c -val t.i ... t.i:7: Warning: Assertion got status valid. Values of globals at initialization t[0] ∈ {1; } [1] ∈ {2; } [2] ∈ {3; } x ∈ {0; } ... In the logs of the analyzer, you get: its version of what it thinks the initial values of globals are, and its interpretation of the assertion you wrote in the //@ comment. Here it goes through the assertion a single time and finds it valid. People who use this kind of tool build scripts to extract the information they're interested in from the logs automatically. However, as a negative note, I have to point out that if you are afraid a test could eventually be forgotten, you should also worry about the mandatory static analyzer pass being forgotten after code modifications.
