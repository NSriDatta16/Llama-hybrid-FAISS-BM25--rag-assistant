[site]: stackoverflow
[post_id]: 3215033
[parent_id]: 519788
[tags]: 
Providing a default implementation of compareTo that uses the source-code ordering is fine; making it final was a misstep on Sun's part. The ordinal already accounts for declaration order. I agree that in most situations a developer can just logically order their elements, but sometimes one wants the source code organized in a way that makes readability and maintenance to be paramount. For example: //===== SI BYTES (10^n) =====// /** 1,000 bytes. */ KILOBYTE (false, true, 3, "kB"), /** 10 6 bytes. */ MEGABYTE (false, true, 6, "MB"), /** 10 9 bytes. */ GIGABYTE (false, true, 9, "GB"), /** 10 12 bytes. */ TERABYTE (false, true, 12, "TB"), /** 10 15 bytes. */ PETABYTE (false, true, 15, "PB"), /** 10 18 bytes. */ EXABYTE (false, true, 18, "EB"), /** 10 21 bytes. */ ZETTABYTE(false, true, 21, "ZB"), /** 10 24 bytes. */ YOTTABYTE(false, true, 24, "YB"), //===== IEC BYTES (2^n) =====// /** 1,024 bytes. */ KIBIBYTE(false, false, 10, "KiB"), /** 2 20 bytes. */ MEBIBYTE(false, false, 20, "MiB"), /** 2 30 bytes. */ GIBIBYTE(false, false, 30, "GiB"), /** 2 40 bytes. */ TEBIBYTE(false, false, 40, "TiB"), /** 2 50 bytes. */ PEBIBYTE(false, false, 50, "PiB"), /** 2 60 bytes. */ EXBIBYTE(false, false, 60, "EiB"), /** 2 70 bytes. */ ZEBIBYTE(false, false, 70, "ZiB"), /** 2 80 bytes. */ YOBIBYTE(false, false, 80, "YiB"); The above ordering looks good in source code, but is not how the author believes the compareTo should work. The desired compareTo behavior is to have ordering be by number of bytes. The source-code ordering that would make that happen degrades the organization of the code. As a client of an enumeration i could not care less how the author organized their source code. I do want their comparison algorithm to make some kind of sense, though. Sun has unnecessarily put source code writers in a bind.
