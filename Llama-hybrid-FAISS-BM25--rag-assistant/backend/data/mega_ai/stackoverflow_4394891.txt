[site]: stackoverflow
[post_id]: 4394891
[parent_id]: 4394442
[tags]: 
Ok, here's my solution in Java with a unit test to prove it (sorry about the length). This is also not really a divide an conquer algorithm but it is more efficient than the other answer as it doesn't check if guy1 is the roommate of guy2 and check if guy2 is the roommate of guy1. The equals() and hashCode() methods were generated by Eclipse and needed for my HashSet to work correctly. Guy.java : import java.util.ArrayList; import java.util.List; public class Guy { String name; List roommates; public Guy(String name) { this.name = name; this.roommates = new ArrayList (); } public boolean addRoommate(Guy roommate) { return this.roommates.add(roommate) && roommate.roommates.add(this); } public List getRoommates() { return this.roommates; } public String getName() { return this.name; } public String toString() { return this.getName(); } public boolean livesWith(Guy potentialRoommate) { return this.roommates.contains(potentialRoommate); } /* (non-Javadoc) * @see java.lang.Object#hashCode() */ @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } /* (non-Javadoc) * @see java.lang.Object#equals(java.lang.Object) */ @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (!(obj instanceof Guy)) { return false; } Guy other = (Guy) obj; if (name == null) { if (other.name != null) { return false; } } else if (!name.equals(other.name)) { return false; } return true; } } Roommates.java : public class Roommates { private Guy guy1; private Guy guy2; public Roommates(Guy guy1, Guy guy2) { this.guy1 = guy1; this.guy2 = guy2; } public Guy getGuy1() { return this.guy1; } public Guy getGuy2() { return this.guy2; } public String toString() { return guy1 + " lives with " + guy2; } /* (non-Javadoc) * @see java.lang.Object#hashCode() */ @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((guy1 == null) ? 0 : guy1.hashCode()); result = prime * result + ((guy2 == null) ? 0 : guy2.hashCode()); return result; } /* (non-Javadoc) * @see java.lang.Object#equals(java.lang.Object) */ @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (!(obj instanceof Roommates)) { return false; } Roommates other = (Roommates) obj; if (guy1 == null) { if (other.guy1 != null) { return false; } } else if (!guy1.equals(other.guy1)) { return false; } if (guy2 == null) { if (other.guy2 != null) { return false; } } else if (!guy2.equals(other.guy2)) { return false; } return true; } } RoommateFinder.java : import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Set; public class RoommateFinder { List roommates; List guys; public RoommateFinder(List guys) { this.roommates = new ArrayList (); this.guys = guys; // clone the guys List because findRoommates is going to modify it List cloneOfGuys = new ArrayList (); for (Guy guy : guys) { cloneOfGuys.add(guy); } this.findRoommates(cloneOfGuys); } private void findRoommates(List guys) { Iterator iter = guys.iterator(); if (!iter.hasNext()) { return; } Guy firstGuy = iter.next(); while (iter.hasNext()) { Guy potentialRoommate = iter.next(); if (firstGuy.livesWith(potentialRoommate)) { Roommates roommates = new Roommates(firstGuy, potentialRoommate); this.roommates.add(roommates); } } guys.remove(firstGuy); this.findRoommates(guys); } public List getRoommates() { return this.roommates; } public List getGuys() { return this.guys; } public int getUniqueGuyCount() { Set uniqueGuys = new HashSet (); for (Roommates roommates : this.roommates) { uniqueGuys.add(roommates.getGuy1()); uniqueGuys.add(roommates.getGuy2()); } return uniqueGuys.size(); } public boolean atLeastHalfLivingTogether() { return this.getUniqueGuyCount() * 2 >= this.guys.size(); } } RoommateFinderTest.java : import static org.junit.Assert.*; import java.util.ArrayList; import java.util.List; import org.junit.After; import org.junit.Before; import org.junit.Test; public class RoommateFinderTest { private List guys; private Guy harry, larry, terry, barry, herbert; @Before public void setUp() throws Exception { harry = new Guy("Harry"); larry = new Guy("Larry"); terry = new Guy("Terry"); barry = new Guy("Barry"); herbert = new Guy("Herbert"); harry.addRoommate(larry); terry.addRoommate(barry); guys = new ArrayList (); guys.add(harry); guys.add(larry); guys.add(terry); guys.add(barry); guys.add(herbert); } @After public void tearDown() throws Exception { harry = null; larry = null; terry = null; barry = null; herbert = null; guys = null; } @Test public void testFindRoommates() { RoommateFinder roommateFinder = new RoommateFinder(guys); List roommatesList = roommateFinder.getRoommates(); Roommates[] expectedRoommates = new Roommates[] { new Roommates(harry, larry), new Roommates(terry, barry) }; assertArrayEquals(expectedRoommates, roommatesList.toArray()); assertTrue(roommateFinder.atLeastHalfLivingTogether()); } }
