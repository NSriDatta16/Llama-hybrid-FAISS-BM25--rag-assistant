[site]: stackoverflow
[post_id]: 1263298
[parent_id]: 1263160
[tags]: 
Monkey-patching metaprogramming - maybe it can be made more elegant, this is only a quick draft, and I haven't done metaprogramming for a little while... # inject the convenience method into the definition of the Object class class Object def Object::bool_attr(attrname) class_eval { define_method(attrname.to_s, lambda { instance_variable_get('@' + attrname.to_s.chop) }) } class_eval { define_method(attrname.to_s.chop+"=", lambda { |x| instance_variable_set('@'+attrname.to_s.chop, x) }) } end end ### somewhere later class MyClass bool_attr :my_boolean_attribute? def initialize @my_boolean_attribute = true end end # yet even more later foo = MyClass.new bar = MyClass.new foo.my_boolean_attribute = 1 puts foo.my_boolean_attribute? puts bar.my_boolean_attribute? With this approach, you can be DRY and get the nice questionmark too. You just might need to pick a better name than " bool_attr ", like, " bool_attr_accessor " or something similar. The definitions that I made are a bit cranky, in a sense that the question mark is present in the original symbol. Probably a cleaner approach would be to avoid the questionmark in the symbol name and append it during the definition of the method - should be less confusing. Oh, and almost forgot to include the obligatory link: Seeing metaclasses clearly
