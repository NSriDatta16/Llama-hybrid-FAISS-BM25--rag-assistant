[site]: stackoverflow
[post_id]: 1244571
[parent_id]: 652788
[tags]: 
I once put together this horrifying C++ code which used macros to help hook functions into the import table of DLLs. #define ARGLIST(...) __VA_ARGS__ #define CPPTYPELESSARG(typelessParams) thisptr, typelessParams #define CPPTYPEDARG(typedParams) void* thisptr, typedParams #define CPPTYPELESSNOARG thisptr #define CPPTYPEDNOARG void* thisptr #define CPPHOOKBODY(hookName, params) void *thisptr; \ __asm { mov thisptr, ecx } \ return On##hookName ( params ); #define CHOOKBODY(hookName, typelessParams) return On##hookName( typelessParams ); #define CPPHOOK(InjectHookRef, importLib, importFunc, hookName, returnType, typedParams, typelessParams) \ HOOKIMPL(InjectHookRef, importLib, importFunc, hookName, returnType, CPPTYPEDARG(typedParams), typelessParams, \ typedParams, __thiscall, __stdcall, CPPHOOKBODY(hookName, CPPTYPELESSARG(typelessParams))) #define CPPHOOKNOARG(InjectHookRef, importLib, importFunc, hookName, returnType, typedParams, typelessParams) \ HOOKIMPL(InjectHookRef, importLib, importFunc, hookName, returnType, CPPTYPEDNOARG, typelessParams, \ typedParams, __thiscall, __stdcall, CPPHOOKBODY(hookName, CPPTYPELESSNOARG)) #define CDECLHOOK(InjectHookRef, importLib, importFunc, hookName, returnType, typedParams, typelessParams) \ HOOKIMPL(InjectHookRef, importLib, importFunc, hookName, returnType, typedParams, typelessParams, \ typedParams, __cdecl, __cdecl, CHOOKBODY(hookName, typelessParams)) #define CDECLFUNC(name, address, returnType, args) \ typedef returnType (__cdecl *name##Ptr)(args); \ name##Ptr name = (name##Ptr) address; #define CPPFUNC(name, address, returnType, args) \ typedef returnType (__thiscall *name##Ptr)(void* thisptr, args); \ name##Ptr name = (name##Ptr) address; #define STDFUNC(name, address, returnType, args) \ typedef returnType (__stdcall *name##Ptr)(args); \ name##Ptr name = (name##Ptr) address; #define STDHOOK(InjectHookRef, importLib, importFunc, hookName, returnType, typedParams, typelessParams) \ HOOKIMPL(InjectHookRef, importLib, importFunc, hookName, returnType, typedParams, typelessParams, \ typedParams, __stdcall, __stdcall, CHOOKBODY(hookName, ARGLIST(typelessParams))) #define HOOKIMPL(InjectHookRef, importLib, importFunc, hookName, returnType, typedParams, typelessParams, hookParams, fnPtrCall, hookCall, hookBody) \ typedef returnType (fnPtrCall *##hookName##OrigPtr )( typedParams ); \ class hookName : public IHook \ { \ public: \ typedef hookName##OrigPtr func_type; \ private: \ static void* m_origFunction; \ static bool m_bModifyImport; \ static std::string m_lib; \ static std::string m_importFunc; \ static std::string m_sHookName; \ static returnType hookCall hookName##FnHook ( hookParams ) \ { \ hookBody \ } \ static bool ImplIsModifyImport() { return hookName::m_bModifyImport; } \ static void ImplSetModifyImport(bool bModify) { hookName::m_bModifyImport = bModify; } \ static const std::string& ImplGetLibName() { return hookName::m_lib; } \ static const std::string& ImplGetImportFunctionName() { return hookName::m_importFunc; } \ static void ImplSetOriginalAddress(void* fn) { hookName::m_origFunction = fn; } \ static void* ImplGetOriginalAddress() { return hookName::m_origFunction; } \ static returnType On##hookName ( typedParams ); \ static void* ImplGetNewAddress() { return hookName::##hookName##FnHook; } \ static const std::string& ImplGetHookName() { return hookName::m_sHookName; } \ public: \ hookName() \ { \ InjectHookRef.AddHook((IHook*)this); \ hookName::m_lib = importLib; \ hookName::m_importFunc = importFunc; \ hookName::m_sHookName = #hookName; \ hookName::m_origFunction = NULL; \ hookName::m_bModifyImport = true; \ } \ virtual bool IsModifyImport() const { return hookName::ImplIsModifyImport(); } \ virtual void SetModifyImport(bool bModify) { hookName::ImplSetModifyImport(bModify); } \ virtual const std::string& GetHookName() const { return hookName::ImplGetHookName(); } \ virtual const std::string& GetLibName() const { return hookName::ImplGetLibName(); } \ virtual const std::string& GetImportFunctionName() const { return hookName::ImplGetImportFunctionName(); } \ virtual void* GetOriginalAddress() const { return hookName::ImplGetOriginalAddress(); } \ virtual void* GetNewAddress() const { return hookName::ImplGetNewAddress(); } \ virtual void SetOriginalAddress(void* fn) { hookName::m_origFunction = fn; } \ static func_type GetTypedOriginalAddress() { return reinterpret_cast(hookName::m_origFunction); } \ }; \ void* hookName::m_origFunction = NULL; \ bool hookName::m_bModifyImport = false; \ std::string hookName::m_lib; \ std::string hookName::m_importFunc; \ std::string hookName::m_sHookName; \ static hookName g##hookName##Inst; Which in turn allowed me to do this: CPPHOOK(gIH, "SimEngine.dll", "?AddEntity@Player@@UAEXPAVEntity@@@Z", PlayerAddEntity, void, void* ent, ent); /* Called when the engine calls Player::AddEntity(entity) */ void PlayerAddEntity::OnPlayerAddEntity(void *thisptr, void *ent) { unsigned int id = getPlayerID(thisptr); gIH.GetLog()->Info("Player %d adding entity %s.", getPlayerID(thisptr), getEntityName(ent)); gPlayers[id] = thisptr; /*if( id == 2 && gPlayers[1] && gPlayers[2] ) EntitySetOwner::GetTypedOriginalAddress() (ent, gPlayers[1]);*/ //gEnts[ent] = Entity(ent, Vector3f()); PlayerAddEntity::GetTypedOriginalAddress() (thisptr, ent); }
