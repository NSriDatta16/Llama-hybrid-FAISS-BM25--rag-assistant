[site]: stackoverflow
[post_id]: 495511
[parent_id]: 495021
[tags]: 
Actually, prior to C++11 the standard defined the export keyword that would make it possible to declare templates in a header file and implement them elsewhere. In a manner of speaking. Not really, as the only ones who ever implemented that feature pointed out : Phantom advantage #1: Hiding source code. Many users, have said that they expect that by using export they will no longer have to ship definitions for member/nonmember function templates and member functions of class templates. This is not true. With export, library writers still have to ship full template source code or its direct equivalent (e.g., a system-specific parse tree) because the full information is required for instantiation. [...] Phantom advantage #2: Fast builds, reduced dependencies. Many users expect that export will allow true separate compilation of templates to object code which they expect would allow faster builds. It doesnâ€™t because the compilation of exported templates is indeed separate but not to object code. Instead, export almost always makes builds slower, because at least the same amount of compilation work must still be done at prelink time. Export does not even reduce dependencies between template definitions because the dependencies are intrinsic, independent of file organization. None of the popular compilers implemented this keyword. The only implementation of the feature was in the frontend written by the Edison Design Group, which is used by the Comeau C++ compiler. All others required you to write templates in header files, because the compiler needs the template definition for proper instantiation (as others pointed out already). As a result, the ISO C++ standard committee decided to remove the export feature of templates with C++11.
