[site]: stackoverflow
[post_id]: 5639444
[parent_id]: 5639386
[tags]: 
Is string actually std::string ? And path a boost::filesystem::path ? In that case, you should know that C library functions (like sprintf and printf ) don't support C++ classes like std::string . That's only natural. What you need to do is: sprintf(filebuf, "%s%s", current.c_str(), _UserDir.c_str()); But a more elegant solution, if you're already using C++, is to either use std::stringstream or boost::format . As a bonus won't have to mess with allocating buffers on the stack and worrying that the result might be longer than the buffer (which may lead to buffer overruns and security exploits - sprintf() is probably the culprit behind many of those...). std::stringstream std::stringstream filebuf; filebuf boost::format std::string filename = "%s%s" % current_path().c_str() % _UserDir; By the way, if you just want to concatenate directories, the 'proper' way to do that with boost::filesystem::path would be: boost::filesystem::path fullPath = current_path() / _UserDir; Yes, the / operator is used for adding path components. They are separated by slashes after all, aren't they? That being said, if you still choose, against all good advice, to use the old C library functions, please, for all that's good in the world, don't use sprintf() . Use the slightly-safer snprintf() , which takes the maximum buffer size as an argument.
