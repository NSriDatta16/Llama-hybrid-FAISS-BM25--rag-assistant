[site]: stackoverflow
[post_id]: 684735
[parent_id]: 684713
[tags]: 
Look at the MessageDigest class. Essentially, you create an instance of it, then pass it a series of bytes. The bytes could be the bytes directly loaded from the URL if you know that two images that are the "same" will be the selfsame file/stream of bytes. Or if necessary, you could create a BufferedImage from the stream, then pull out pixel values, something like: MessageDigest md = MessageDigest.getInstance("MD5"); ByteBuffer bb = ByteBuffer.allocate(4 * bimg.getWidth()); for (int y = bimg.getHeight()-1; y >= 0; y--) { bb.clear(); for (int x = bimg.getWidth()-1; x >= 0; x--) { bb.putInt(bimg.getRGB(x, y)); } md.update(bb.array()); } byte[] digBytes = md.digest(); Either way, MessageDigest.digest() eventually gives you a byte array which is the "signature" of the image. You could convert this to a hex string if it's helpful, e.g. for putting in a HashMap or database table, e.g.: StringBuilder sb = new StringBuilder(); for (byte b : digBytes) { sb.append(String.format("%02X", b & 0xff)); } String signature = sb.toString(); If the content/image from two URLs gives you the same signature, then they're the same image. Edit: I forgot to mention that if you were hashing pixel values, you'd probably want to include the dimensions of the image in the hash too. (Just to a similar thing-- write two ints to an 8-byte ByteBuffer, then update the MessageDigest with the corresponding 8-byte array.) The other thing is that somebody mentioned is that MD5 is not collision-resistent . In other words, there is a technique for constructing multiple byte sequences with the same MD5 hash without having to use the "brute force" method of trial and error (where on average, you'd expect to have to try about 2^64 or 16 billion billion files before hitting on a collision). That makes MD5 unsuitable where you're trying to protect against this threat model . If you're not concerned about the case where somebody might deliberately try to fool your duplicate identification, and you're just worried about the chances of a duplicate hash "by chance", then MD5 is absolutely fine. Actually, it's not only fine, it's actually a bit over the top-- as I say, on average, you'd expect one "false duplicate" after about 16 billion billion files. Or put another way, you could have, say, a billion files and the chance of a collision be extremely close to zero. If you are worried about the threat model outlined (i.e. you think somebody could be deliberately dedicating processor time to constructing files to fool your system), then the solution is to use a stronger hash. Java supports SHA1 out of the box (just replace "MD5" with "SHA1"). This will now give you longer hashes (160 bits instead of 128 bits), but with current knowledge makes finding a collision infeasible. Personally for this purpose, I would even consider just using a decent 64-bit hash function. That'll still allow tens of millions of images to be compared with close-to-zero chance of a false positive.
