[site]: stackoverflow
[post_id]: 1411455
[parent_id]: 1411199
[tags]: 
Well, depending on how complex you want to make it, you could have ratings additionally be weighted based on how many ratings the person has made, and what those ratings are. If the person has only made one rating, it could be a shill rating, and might count for less. Or if the person has rated many things in category a, but few in category b, and has an average rating of 1.3 out of 5 stars, it sounds like category a may be artificially weighed down by the low average score of this user, and should be adjusted. But enough of making it complex. Let’s make it simple. Assuming we’re working with just two values, ReviewCount and AverageRating, for a particular item, it would make sense to me to look ReviewCount as essentially being the “reliability” value. But we don’t just want to bring scores down for low ReviewCount items: a single one-star rating is probably as unreliable as a single 5 star rating. So what we want to do is probably average towards the middle: 3. So, basically, I’m thinking of an equation something like X * AverageRating + Y * 3 = the-rating-we-want. In order to make this value come out right we need X+Y to equal 1. Also we need X to increase in value as ReviewCount increases...with a review count of 0, x should be 0 (giving us an equation of “3”), and with an infinite review count X should be 1 (which makes the equation = AverageRating). So what are X and Y equations? For the X equation want the dependent variable to asymptotically approach 1 as the independent variable approaches infinity. A good set of equations is something like: Y = 1/(factor^RatingCount) and (utilizing the fact that X must be equal to 1-Y) X = 1 – (1/(factor^RatingCount) Then we can adjust "factor" to fit the range that we're looking for. I used this simple C# program to try a few factors: // We can adjust this factor to adjust our curve. double factor = 1.5; // Here's some sample data double RatingAverage1 = 5; double RatingCount1 = 1; double RatingAverage2 = 4.5; double RatingCount2 = 5; double RatingAverage3 = 3.5; double RatingCount3 = 50000; // 50000 is not infinite, but it's probably plenty to closely simulate it. // Do the calculations double modfactor = Math.Pow(factor, RatingCount1); double modRating1 = (3 / modfactor) + (RatingAverage1 * (1 - 1 / modfactor)); double modfactor2 = Math.Pow(factor, RatingCount2); double modRating2 = (3 / modfactor2) + (RatingAverage2 * (1 - 1 / modfactor2)); double modfactor3 = Math.Pow(factor, RatingCount3); double modRating3 = (3 / modfactor3) + (RatingAverage3 * (1 - 1 / modfactor3)); Console.WriteLine(String.Format("RatingAverage: {0}, RatingCount: {1}, Adjusted Rating: {2:0.00}", RatingAverage1, RatingCount1, modRating1)); Console.WriteLine(String.Format("RatingAverage: {0}, RatingCount: {1}, Adjusted Rating: {2:0.00}", RatingAverage2, RatingCount2, modRating2)); Console.WriteLine(String.Format("RatingAverage: {0}, RatingCount: {1}, Adjusted Rating: {2:0.00}", RatingAverage3, RatingCount3, modRating3)); // Hold up for the user to read the data. Console.ReadLine(); So you don’t bother copying it in, it gives this output: RatingAverage: 5, RatingCount: 1, Adjusted Rating: 3.67 RatingAverage: 4.5, RatingCount: 5, Adjusted Rating: 4.30 RatingAverage: 3.5, RatingCount: 50000, Adjusted Rating: 3.50 Something like that? You could obviously adjust the "factor" value as needed to get the kind of weighting you want.
