[site]: stackoverflow
[post_id]: 5736957
[parent_id]: 
[tags]: 
Strange behavior with instance variables in Shoes

Hey, all. I'm working on making a GUI for a Ruby project using Shoes. I've got a class called Manager (as in memory manager) that loads a 'process list' from a file, splits it up and assigns things to different 'pages' in memory when a certain execution call is made. I really don't think this part matters too much, though. It all works as a terminal application just fine. However, Shoes is just baffling me. Here's what I've got so far: Shoes.app(:title => "Paging Simulator", :width => 800, :height => 450) do @manager = Manager.new stack(:width => 200) do @exec_list = stack { title "Execution Queue", :size => 14 @exec_lines = para "click button to load", :size => 9 @file_button = button "Load Process List" @file_button.click { filename = ask_open_file # @manager.set_exec_list filename # alert "this makes no sense" @exec_lines.text = @manager.exec_list.join "\n" # exec_lines.text = File.read filename } } end end What happens when I run this: The program view loads as expected. I get a header, a paragraph that says "click button....", and a button. I click the button and I select the file. But this is where things get weird. If I run the last commented line exec_lines.text = File.read filename it does as I would like, but my manager doesn't get any of the information it needs. If I run the @manager.set_exec_list filename line, nothing from that line on in the block gets run, including the alert , or any other code I try to put in there. if I run as shown above, however, I get the output I expect, but I don't get to set my data from the file that I select. I've tried to figure this out from the Shoes Rules page, but this doesn't seem to be an issue that they address, and their "it changes/doesn't change self" I think I grasp, but it's confusing and I don't think it's exactly related to this problem. Does anyone have any idea how to get this to work? I'm kind of down to crunch time on this project and I can't seem to get any other Ruby GUI toolkit to even run, so I think I'm pretty stuck with Shoes. Thanks. Update I've tried running ruby-debug on the code when I make the call to @manager.set_exec_list filename , and stepping through it shows that this call is made, but the code never actually (from what I can tell) jumps into that method, and acts like it's the last line of code in the block. Do I need to include these classes inside the Shoes.app block? Update Nope. That does nothing different. update fullsource code follows: #!/usr/bin/env shoes require 'rubygems' require 'ruby-debug' class MemSegment attr_accessor :filled, :pid, :seg, :seg_id def initialize(filled=false, pid=nil, seg=nil, seg_id=0) @filled = filled @pid = pid.to_i @seg = seg.to_s @seg_id = seg_id.to_i self end def fill(pid, seg, seg_id) @filled = true; @pid = pid; @seg = seg; @seg_id = seg_id; self end def clear self.filled = false; self.pid = nil; self.seg = nil; self end def filled? @filled end def to_s filled? ? "#{seg} #{seg_id} for pid #{pid}" : "Free" end end class SimProc include Enumerable attr_accessor :pid, :code, :data def initialize(pid, code, data) @pid = pid.to_i @code = code.to_i @data = data.to_i end def each yield :code, code yield :data, data end def to_s "[SimProc :pid => #{pid}, :code => #{code}, :data => #{data}]" end def to_a [@pid, @code, @data] end end class Manager attr_reader :segments, :processes, :exec_list, :exec_object def initialize @exec_list = [[1, 2], [3, 4], [5, 6]] @processes = {} @segments = Array.new(8) { MemSegment.new } end def print_activity @segments.each_with_index {|s, index| puts "Seg #{index} => #{s}" } @processes.each_value {|s| puts s } end def load_process(pcb, exec_index) if pcb.size == 3 p = SimProc.new(*pcb) bad_load = false @processes.store p.pid, p @processes[p.pid].each do |proc_seg, bsize| (bsize / 512.0).ceil.times do |seg_id| @segments.each_with_index do |s, index| if !s.filled #find the first empty memory segment s.fill p.pid, proc_seg, seg_id break # if all slots are filled and we couldn't place a proc block elsif index == @segments.size - 1 bad_load = true puts "Cannot find a place for #{proc_seg} segment of size #{bsize}. Requeueing..." break; end end break if bad_load end end # recover pages and queue the process for later if bad_load @segments.each_with_index do |seg, seg_index| # clear any segments that didn't get loaded properly if seg.pid == p.pid seg.clear puts "Seg #{seg_index} => segment cleared: #{seg}" end end # reinsert this process after the next in the execution list # it will attempt to load and run after the next process is performed @exec_list.insert(exec_index + 2, p.to_a) end print_activity elsif pcb.size == 2 and pcb[1] == -1 # a process is exiting puts "removing pid #{pcb[0]}" @segments.each { |s| s.clear if s.pid == pcb[0] } @processes.delete pcb[0] print_activity end end def set_exec_list(filename) file = File.open filename file.each { |pcb| @exec_list "Paging Simulator", :width => 800, :height => 450) do @manager = Manager.new stack(:width => 200) do @exec_list = stack { title "Execution Queue", :size => 14 @exec_lines = para "click button to load", :size => 9 @file_button = button "Load Process List" debugger @file_button.click { filename = ask_open_file @manager.set_exec_list filename # alert "this makes no sense" # @exec_lines.text = @manager.exec_list # @exec_lines.text = File.read filename @exec_lines.text = @manager.exec_list.join "\n" } } end end #=end
