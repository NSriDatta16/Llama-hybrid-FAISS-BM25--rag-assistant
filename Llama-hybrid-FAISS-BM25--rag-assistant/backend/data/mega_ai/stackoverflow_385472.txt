[site]: stackoverflow
[post_id]: 385472
[parent_id]: 382576
[tags]: 
You DO need to release it. See "As it rebuilds the object hierarchy, however, UIKit reestablishes connections between the objects using the setValue:forKey: method, which uses the available setter method or retains the object by default if no setter method is available." in Nib Object Retention In other words, because you haven't specified these entries as @property (which implicitly declares a setter), or provided a setter directly, there is no available setter method, and the final part of this paragraph applies - the object is retained by default. You should, in your dealloc() method, set all IBOutlets to nil using self.outletName = nil; If no setter is defined, then setValue will autorelease the old value (make sure you have an NSAutoreleasePool if running in a thread). If a setter is defined, it will perform whatever behaviour you defined. Either way, the set to nil will do exactly the right thing, and ensure you get no memory leaks. Do NOT do this outletName = nil; This will directly set the member variable, and bypass calling setValue. See the documentation of NSObject setValue:forKey for more details. Running the Performance Tool (Leaks) will not show a leak, but you can verify that there is actually a leak by looking at the current running total of allocated memory. cf The Airsource - Memory Management and NIBs
