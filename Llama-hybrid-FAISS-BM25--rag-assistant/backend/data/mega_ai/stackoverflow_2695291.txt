[site]: stackoverflow
[post_id]: 2695291
[parent_id]: 2695153
[tags]: 
Yes, with the stored-token approach you'd have to keep all generated tokens just in case they came back in at any point. A single stored-token fails not just for multiple browser tabs/windows but also for back/forward navigation. You generally want to manage the potential storage explosion by expiring old tokens (by age and/or number of tokens issued since). Another approach that avoids token storage altogether is to issue a signed token generated using a server-side secret. Then when you get the token back you can check the signature and if it matches you know you signed it. For example: // Only the server knows this string. Make it up randomly and keep it in deployment-specific // settings, in an include file safely outside the webroot // $secret= 'qw9pDr$wEyq%^ynrUi2cNi3'; ... // Issue a signed token // $token= dechex(mt_rand()); $hash= hash_hmac('sha1', $token, $secret); $signed= $token.'-'.$hash; "> ... // Check a token was signed by us, on the way back in // $isok= FALSE; $parts= explode('-', $_POST['formkey']); if (count($parts)===2) { list($token, $hash)= $parts; if ($hash===hash_hmac('sha1', $token, $secret)) $isok= TRUE; } With this, if you get a token with a matching signature you know you generated it. That's not much help in itself, but then you can put extra things in the token other than the randomness, for example user id: $token= dechex($user->id).'.'.dechex(mt_rand()) ... if ($hash===hash_hmac('sha1', $token, $secret)) { $userid= hexdec(explode('.', $token)[0]); if ($userid===$user->id) $isok= TRUE Now each form submission has to be authorised by the same user who picked up the form, which pretty much defeats CSRF. Another thing it's a good idea to put in a token is an expiry time, so that a momentary client compromise or MitM attack doesn't leak a token that'll work for that user forever, and a value that is changes on password resets, so that changing password invalidates existing tokens.
