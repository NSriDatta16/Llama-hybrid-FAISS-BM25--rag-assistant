[site]: stackoverflow
[post_id]: 3768619
[parent_id]: 3768554
[tags]: 
This might give you a good insight ConcurrentHashMap achieves higher concurrency by slightly relaxing the promises it makes to callers. A retrieval operation will return the value inserted by the most recent completed insert operation, and may also return a value added by an insertion operation that is concurrently in progress (but in no case will it return a nonsense result). Iterators returned by ConcurrentHashMap.iterator() will return each element once at most and will not ever throw ConcurrentModificationException, but may or may not reflect insertions or removals that occurred since the iterator was constructed . No table-wide locking is needed (or even possible) to provide thread-safety when iterating the collection. ConcurrentHashMap may be used as a replacement for synchronizedMap or Hashtable in any application that does not rely on the ability to lock the entire table to prevent updates. Regarding this: However, iterators are designed to be used by only one thread at a time. It means, while using iterators produced by ConcurrentHashMap in two threads are safe, it may cause an unexpected result in the application.
