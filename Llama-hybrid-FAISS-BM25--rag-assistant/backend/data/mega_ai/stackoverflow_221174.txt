[site]: stackoverflow
[post_id]: 221174
[parent_id]: 221154
[tags]: 
I guess one option would be to keep taking chunks off it, and converting individual chunks? A bit of mod/division etc, converting individual fragments... So: what hex value do you expect? Here's two approaches... one uses the binary structure of decimal; one does it manually. In reality, you might want to have a test: if bits[3] is zero, do it the quick way, otherwise do it manually. decimal d = 588063595292424954445828M; int[] bits = decimal.GetBits(d); if (bits[3] != 0) throw new InvalidOperationException("Only +ve integers supported!"); string s = Convert.ToString(bits[2], 16).PadLeft(8,'0') // high + Convert.ToString(bits[1], 16).PadLeft(8, '0') // middle + Convert.ToString(bits[0], 16).PadLeft(8, '0'); // low Console.WriteLine(s); /* or Jon's much tidier: string.Format("{0:x8}{1:x8}{2:x8}", (uint)bits[2], (uint)bits[1], (uint)bits[0]); */ const decimal chunk = (decimal)(1 0) { int fragment = (int) (d % chunk); sb.Insert(0, Convert.ToString(fragment, 16).PadLeft(4, '0')); d -= fragment; d /= chunk; } Console.WriteLine(sb);
