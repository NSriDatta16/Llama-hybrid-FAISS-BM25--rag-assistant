[site]: stackoverflow
[post_id]: 5189245
[parent_id]: 5188286
[tags]: 
Chris Okasaki has a design for a queue that addresses this issue. See page 15 of his thesis http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf You may need to adapt code slightly, but some use of reverse and keeping two pieces of the list lets you work more efficiently on average . Also, someone put up some list code in the monad reader with efficient operations. I admit, I didn't really follow it, but I thought I could figure it out if I concentrated. It turns out it was Douglas M. Auclair in Monad Reader issue 17 http://themonadreader.files.wordpress.com/2011/01/issue17.pdf I realized the above answer does not directly address the question. So, for giggles, here is my recursive answer. Feel free to tear it apart -- it is not pretty. import Data.List ptri = [1] : mkptri ptri mkptri :: [[Int]] -> [[Int]] mkptri (xs:ys) = mkptri' xs : mkptri ys mkptri' :: [Int] -> [Int] mkptri' xs = 1 : mkptri'' xs mkptri'' :: [Int] -> [Int] mkptri'' [x] = [x] mkptri'' (x:y:rest) = (x + y):mkptri'' (y:rest)
