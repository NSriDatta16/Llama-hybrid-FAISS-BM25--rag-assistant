[site]: stackoverflow
[post_id]: 821304
[parent_id]: 821235
[tags]: 
Based on the code you've posted, the expected value is an anonymous delegate/method. The CLR does some magic behind the scene to add a method on the fly. In case the anon. method uses certain local variables, the CLR creates a new class with fields set to these values, with the new anon method inside it (so that the method can access the local var values). So that's your ..c_DisplayClass13, with a compiler given weird name so that it doesn't clash with user-defined methods. The actual value returned by your method is an Expression . And hence.. the equality check between these two fails. You need to compare the elements of the collection returned by both of them. So I'd suggest.. convert both the expected and actual values to Lists (or a better data structure) and then invoke one of NUnit's asserts that take collection parameters. Update : You got me to read up on Expression Trees. +1 for that. I'm going to change my answer - Comparing the Expression trees via hack-and-assert would lead to a fragile test (e.g. if MS changes the internal structure of an expression tree in the future) Expression trees are just code blocks (as I found out now) that evaluate to a result similar to a Func - so my test would be to give the expected and actual code blocks the same input and see if they deliver the same output. So my assert for your test would be Assert.AreEqual(expected.Compile().Invoke(inputEntity), actual.Compile().Invoke(inputEntity));
