[site]: stackoverflow
[post_id]: 5362933
[parent_id]: 5288260
[tags]: 
You're able to take the closure of the grammar? Technically, the closure function is defined on sets of items (which are sets of productions with a position associated with each production). Now, you ask for how to display the valid LR(0) items of a grammar. You either mean displaying all the items, as defined in the paragraph above, or displaying all states of the LR(0) automaton. The first is trivial because all possible items are valid, so I'm guessing you want all states. This is what you do (straight from the dragon book). SetOfItems getValidStates(Grammar G) { // S' -> S is the "first" production of G (which must be augmented) SetOfItems C = {[S' -> *S]}; do { bool added = false; for (Item I : C) { for (Symbol X : G) { L = GOTO(I, X); if (L.size() > 0 && !C.contains(L)) { added = true; C.add(L); } } } } while (added); return C; } The only question is how to implement GOTO(SetOfItems, Symbol). So, SetOfItems GOTO(SetOfItems S, Symbol X) { SetOfItems ret = {} for (Item I : S) if (I.nextSymbol().equals(X)) ret.add(I.moveDotByOne()) return closure(ret); } Each item in the set has the form [A -> a*Yb], where A is the head of some production and aXb is the body of the production (a and b are just a string of grammar symbols, Y is a single symbol). The '*' is just the position I mentioned - it's not in the grammar, and [A->a*Yb].nextSymbol() is Y. Basically, Item.nextSymbol() just returns whatever symbol is to the right of the dot. [A->a*Yb].moveDotByOne() returns [A->aY*b]. Now, I just finished the parsing chapter in the compiler book, and I'm not completely happy with my understanding, so be careful with what I've written. As for a link to real code: http://ftp.gnu.org/gnu/bison/ is where you'll find bison's source, but that's a LALR parser generator, and I don't think it implements LR(0).
