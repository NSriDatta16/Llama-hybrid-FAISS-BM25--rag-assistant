[site]: stackoverflow
[post_id]: 3153063
[parent_id]: 3148071
[tags]: 
I somehow think that, this is not the correct way because strlen has to iterate over the characters to get the length. So this operation will have a O(n) complexity. You are right read Joel Spolsky on why C-strings suck . There are few ways around it. The ways include either not using C strings (for example use Pascal strings and create your own library to handle them), or not use C (use say C++ which has a string class - which is slow for different reasons, but you could also write your own to handle Pascal strings more easily than in C for example) Regarding adding a char to a C string; a C string is simply a char array with a nul terminator, so long as you preserve the terminator it is a string, there's no magic. char* straddch( char* str, char ch ) { char* end = &str[strlen(str)] ; *end = ch ; end++ ; *end = 0 ; return str ; } Just like strcat(), you have to know that the array that str is created in is long enough to accommodate the longer string, the compiler will not help you. It is both inelegant and unsafe. If I am concatenating two null terminated strings, will strcat append two null terminating characters to the resultant string? No, just one, but what ever follows that may just happen to be nul, or whatever happened to be in memory. Consider the following equivalent: char* my_strcat( char* s1, const char* s2 ) { strcpy( &str[strlen(str)], s2 ) ; } the first character of s2 overwrites the terminator in s1. In the above code,delimiter is a local variable which gets destroyed after foo returned. Is it OK to append it to variable output? In your example delimiter is not a string, and initialising a pointer with a char makes no sense. However if it were a string, the code would be fine, strcat() copies the data from the second string, so the lifetime of the second argument is irrelevant. Of course you could in your example use a char (not a char*) and the straddch() function suggested above.
