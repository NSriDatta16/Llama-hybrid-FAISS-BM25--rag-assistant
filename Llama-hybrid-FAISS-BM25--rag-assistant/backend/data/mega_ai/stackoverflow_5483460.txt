[site]: stackoverflow
[post_id]: 5483460
[parent_id]: 5465399
[tags]: 
Here's what I have so far. A version of cycle sort which uses a bit array to hold the result of the partition tests and calculates the destinations on the fly. It performs a stable binary partition with N compares, bits of allocated storage. int getDest(int i, BitArray p, int nz) { bool b=BitArrayGet(p,i); int below = BitArrayCount1sBelow(p,i); //1s below return (b)?(nz+below):i-below; } int BinaryCycleSort(Item* a, int n, BitArray p) { int i, numZeros = n-BitArrayCount1sBelow(p,n); BitArray final = BitArrayNew(n); for (i=0;i using these helpers: typedef uint32_t BitStore; typedef BitStore* BitArray; BitArray BitArrayNew(int N); //returns array of N bits, all cleared void BitArraySet(BitArray ba, int i); //sets ba[i] to 1 bool BitArrayGet(BitArray ba, int i); //returns ba[i] int BitArrayCount1sBelow(BitArray ba, int i) //counts 1s in ba[0..i) Obviously this is not constant space. But I think this might be used as a building block to the ultimate goal. The whole array can be partitioned into N/B blocks using a fixed-size BitArray of B bits. Is there some way to re-use those same bits while performing a stable merge?
