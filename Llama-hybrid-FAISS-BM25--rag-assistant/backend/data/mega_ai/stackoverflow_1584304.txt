[site]: stackoverflow
[post_id]: 1584304
[parent_id]: 1580156
[tags]: 
IOTs are great for a number of purposes, including this case where you're gonna have an index on all (or most) of the columns anyway - but the benefit only materialises if you don't have the extra index - the idea is that the table itself is an index, so put the columns in the order that you want the index to be in. In your case, you're accessing category by id, so it makes sense for that to be the first column. So effectively you've got an index on (id, group, category). I don't know why you'd want an additional index on (group, category, id). Your query: SELECT e.id, e.time, e.title FROM entries e, categories c WHERE e.id=c.id AND e.group=? AND c.category=? ORDER by e.time You're joining the tables by ID, but you have no index on entries.id - so the query is probably doing a hash or sort merge join. I wouldn't mind seeing a plan for what your system is doing now to confirm. If you're doing a pagination query (i.e. only interested in a small number of rows) you want to get the first rows back as quick as possible; for this to happen you'll probably want a nested loop on entries, e.g.: NESTED LOOPS ACCESS TABLE BY ROWID - ENTRIES INDEX RANGE SCAN - (index on ENTRIES.group,time) ACCESS TABLE BY ROWID - CATEGORIES INDEX RANGE SCAN - (index on CATEGORIES.ID) Since the join to CATEGORIES is on ID, you'll want an index on ID; if you make it an IOT, and make ID the leading column, that might be sufficient. The performance of the plan I've shown above will be dependent on how many rows match the given "group" - i.e. how selective an average "group" is.
