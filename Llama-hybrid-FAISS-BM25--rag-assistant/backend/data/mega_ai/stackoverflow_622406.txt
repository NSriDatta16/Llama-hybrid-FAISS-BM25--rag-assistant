[site]: stackoverflow
[post_id]: 622406
[parent_id]: 622265
[tags]: 
There is no 1:1 equivalent in MVC for a reason, let's just recapitulate how to think about it the MVC way: Model : "Pages of this site are always requested in a certain context, let's call it the tenant (or user, topic or whatever your sub domains represent). The domain model has a property representing the tenant of the current request." View : "Render the page title depending on the tenant set in the model." Controller : "Set the tenant in the model depending on the host header". Keep in mind that what we want to avoid is mixing controller, view and business logic. Having controller logic in more then one place or a place, that is not called "controller" is not a problem, as long as it remains separated. And now the good thing: You could do this "MVC style" even with Web Forms , and the solution still works with ASP.NET MVC! You still have the request lifecycle (not the page lifecycle), so you could implement a custom HttpModule that contains this part of the controller logic for all requests. It handles the BeginRequest event, checks for the host header, and stores the tenant to something like HttpContext.Current.Items["tenant"]. (Of course you could have a static, typed wrapper for this dictionary entry.) Then all your model objects (or a model base class, or whatever is appropriate for your solution) can access the HttpContext to provide access to this information like this: public string Tenant { get { return HttpContext.Current.Items["tenant"]; } } Advantages: You have separated cause (host header) and effect (rendering page title), improving maintainability and testability Therefore you could easily add additional behavior to your domain model based on this state, like loading content from the database depending on the current tenant. You could easily make more parts of the view depend on the tenant, like CSS file you include, a logo image etc. You could later change the controller logic to set the tenant in the model not only based on the sub domain, but maybe based on a cookie, a referrer, search term, user agent's language, or whatever you can think about, without modifying any of your code depending on the model. Update re your edit : I don't like the idea of holding the state in the session, especially if your session cookie might apply not only to each sub domain, but to all domains. In this case you might serve inconsistent content if users visted another sub domain before. Probably the information in the database that is mapping host headers to tenants won't change very often, so you can cache it and don't need a database lookup for every request.
