[site]: stackoverflow
[post_id]: 4509636
[parent_id]: 715332
[tags]: 
I did not want to get into the nuts and bolts of what was going on so I just delegated the methods I wasn't interested to the old TransferHandler. tree.setDragEnabled(true); tree.setDropMode(DropMode.XXXX); tree.setTransferHandler(new MyTransferHandler(tree.getTransferHandler()); Start with a standard setup but pass the old TransferHandler into your custom TransferHandler. private class MyTransferHandler extends TransferHandler { private TransferHandler delegate; public MyTransferHandler(TransferHandler delegate) { this.delegate = delegate; } public boolean canImport(JComponent comp, DataFlavor[] transferFlavors) { return delegate.canImport(comp, transferFlavors); } public boolean canImport(TransferSupport support) { return true; } protected Transferable createTransferable(JComponent c) { try { Method method = delegate.getClass().getDeclaredMethod("createTransferable", JComponent.class); method.setAccessible(true); return (Transferable) method.invoke(delegate, c); } catch (Exception e) { return super.createTransferable(c); } } public void exportAsDrag(JComponent comp, InputEvent event, int action) { delegate.exportAsDrag(comp, event, action); } protected void exportDone(JComponent source, Transferable data, int action) { try { Method method = delegate.getClass().getDeclaredMethod("exportDone", JComponent.class, Transferable.class, int.class); method.setAccessible(true); method.invoke(delegate, source, data, action); } catch (Exception e) { super.exportDone(source, data, action); } } public int getSourceActions(JComponent c) { return delegate.getSourceActions(c); } public Icon getVisualRepresentation(Transferable t) { return delegate.getVisualRepresentation(t); } public boolean importData(JComponent comp, Transferable t) { return delegate.importData(comp, t); } public boolean importData(TransferHandler.TransferSupport support) { return delegate.importData(support); } } One gotcha is that createTransferable(JComponent) and exportDone(JComponent, Transferable, int) methods are protected so you need to do reflection in order to delegate to those methods. When I didn't do this reflection delegation the strategy did not work. Once I did this delegation drag and drop worked as expected without changing the DragSource or having to write a new Transferable.
