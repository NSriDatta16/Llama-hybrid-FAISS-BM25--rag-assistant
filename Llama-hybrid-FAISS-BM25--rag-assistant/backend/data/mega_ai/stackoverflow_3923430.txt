[site]: stackoverflow
[post_id]: 3923430
[parent_id]: 3923118
[tags]: 
If you don't care about dividing the file exactly evenly, and the distribution of line lengths is somewhat even over the entire file, you can avoid reading the entire file in the parent once. Get the file size. chunk_size = file_size / number_of_children When you spawn each child do in the parent: seek to (child_num+1) * chunk_size Read forward until you find a newline. Spawn the child, telling it to start at the end of the previous chunk (or 0 for the first child), and the actual length of the chunk. Each child seeks to start and reads chunk_size bytes. That's a rough sketch of the strategy. Edited to simplify things a bit. Edit : here's some untested code for step 3, and step 4 below. This is all untested, and I haven't been careful about off-by-one errors, but it gives you an idea of the usage of fseek and ftell , which sounds like what you are looking for. // Assume FILE* f is open to the file, chunk_size is the average expected size, // child_num is the id of the current child, spawn_child() is a function that // handles the logic of spawning a child and telling it where to start reading, // and how much to read. child_chunks[] is an array of structs to keep track of // where the chunks start and how big they are. if(fseek(f, child_num * chunk_size, SEEK_SET) Then in your child (step 4), assume the child has access to child_chunks[] and knows its child_num : void this_is_the_child(int child_num) { /* ... */ fseek(f, child_chunks[child_num].start, SEEK_SET); // FIXME: handle error while(fgets(...) && ftell(f)
