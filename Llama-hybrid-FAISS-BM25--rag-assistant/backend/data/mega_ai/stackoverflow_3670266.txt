[site]: stackoverflow
[post_id]: 3670266
[parent_id]: 
[tags]: 
Object under mouse?

My little game engine basically has a 3D array Cubes[x][y][z] (its actually a big 1D array but I'v done some overloading). I know which cube in X Y Z that the player is standing on. The player will be able to shoot a cube to destroy it which is why I need to figure out how to find the Cube that the mouse is under. I found some OpenGL documentation on picking, but this method was slow. Since my cubes are organized and I know which cube the player is on, and the camera's angle in X and Y (camera does not rotate on Z), and that the mouse is always at screenwidth / 2, screenheight / 2 I'm sure theres a faster way than the gl picking technique. Here is how the camera is set up: void CCubeGame::SetCameraMatrix() { glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glRotatef(Camera.rotx,1,0,0); glRotatef(Camera.roty,0,1,0); glRotatef(Camera.rotz,0,0,1); glTranslatef(-Camera.x , -Camera.y,-Camera.z ); } void CCubeGame::MouseMove(int x, int y) { if(!isTrapped) return; int diffx = x-lastMouse.x; int diffy = y-lastMouse.y; lastMouse.x = x; lastMouse.y = y; Camera.rotx += (float) diffy * 0.2; Camera.roty += (float) diffx * 0.2; if(Camera.rotx > 90) { Camera.rotx = 90; } if(Camera.rotx 1 || fabs(ScreenDimensions.y/2 - y) > 1) { resetPointer(); } } Vertex3f CCubeGame::MoveCamera( int direction, float amount ) { float xrotrad, yrotrad; Vertex3f result(0,0,0); switch(direction) { case CAM_FORWARD: yrotrad = (Camera.roty / 180 * 3.141592654f); xrotrad = (Camera.rotx / 180 * 3.141592654f); result.x = float(sin(yrotrad)) * amount; result.z = -(float(cos(yrotrad)) * amount); result.y = 0; //Camera.y -= float(sin(xrotrad)) * amount; break; case CAM_BACKWARD: yrotrad = (Camera.roty / 180 * 3.141592654f); xrotrad = (Camera.rotx / 180 * 3.141592654f); result.x = -(float(sin(yrotrad)) * amount); result.z = float(cos(yrotrad)) * amount; result.y = 0; //Camera.y += float(sin(xrotrad)) * amount; break; case CAM_RIGHT: yrotrad = (Camera.roty / 180 * 3.141592654f); result.x = float(cos(yrotrad)) * amount; result.z += float(sin(yrotrad)) * amount; result.y = 0; break; case CAM_LEFT: yrotrad = (Camera.roty / 180 * 3.141592654f); result.x = -(float(cos(yrotrad)) * amount); result.z = -(float(sin(yrotrad)) * amount); result.y = 0; break; default: break; } Camera.x += result.x; Camera.y += result.y; Camera.z += result.z; return result; } Thanks
