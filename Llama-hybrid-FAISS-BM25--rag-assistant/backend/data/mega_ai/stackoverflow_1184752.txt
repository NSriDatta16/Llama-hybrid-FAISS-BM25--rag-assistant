[site]: stackoverflow
[post_id]: 1184752
[parent_id]: 1177181
[tags]: 
Let me first address an assumption in your question. The assumption is that embedded software engineers (ESE) do not know or are not aware of modern software engineering practices and need to learn new practices. This assumption should be tossed out right away. I believe you would find the same statistical distribution of ESEs who keep their skills and techniques up-to-date as non-embedded SEs. So, maybe your question becomes an array of questions like: Why do ESEs use a separate code editor and a command line compiler and not an IDE? Why is C preferred over C++ in the majority of embedded projects? Why isn't there as much experimentation in programming practices in the embedded world? The following paragraphs answer these questions. ESEs usually use a specific code editor because it is a personal preference or it is what is used by his/her company. IDEs are not as common because ESEs work very closely to the silicon and not all chip manufacturers develop an IDE for their line of chips. Only the chips that achieve highest market penetration, such as ARM, have enough momentum to warrant the development of IDE-based tools. Furthermore, an IDE doesn't provide as much of an assistance to the ESE as it does to, say, a desktop developer. IDEs provide help with making the glue to the GUI or code-completion for large APIs; neither of which is commonly found or as standard as in the embedded world. I'm sure there are better write-ups as to why C is preferred over C++ in embedded systems than I can make up on the spot. The short of it is that you use what works. C works and is more common (more programmers know C than C++). The other reason might be that the OO methodology was devised to help programmers solve large problems by abstracting the solution into manageable conceptual objects. In the embedded world, the problems are usually whittled down to as small a problem (and solution) as possible so that the embedded system becomes more reliable by having a smaller code base. There is less experimentation by ESEs because an embedded product, in general, must be far less prone to error and have higher reliability than a desktop program. This means a rigid application of well-proven practices and more time spent in testing. Why? Because often there is no feasible path to upgrade the firmware of an embedded device; it's either impossible due to the system being deployed beyond reach or implausible because of the cost of updating millions of devices. In conclusion, ESEs use tools and practices that best suit their needs just as non-embedded SEs do. As a practicing ESE, I believe the embedded software discipline is far more different than my non-ESE friends believe it is. So the apparent disparity of programming practices is not a matter of ESEs needing to learn modern practices, but non-ESEs needing to understand how different embedded programming is.
