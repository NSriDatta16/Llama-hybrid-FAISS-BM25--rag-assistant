[site]: stackoverflow
[post_id]: 476965
[parent_id]: 476942
[tags]: 
Note first, the event declaration that you are using is a short-hand notation in C#: public event EventHandler Event; public void RaiseEvent() { this.Event(this, new EventArgs()); } Is equivalent to: private EventHandler backEndStorage; public event EventHandler Event { add { this.backEndStorage += value; } remove { this.backEndStorage -= value; } } public void RaiseEvent() { this.backEndStorage(this, new EventArgs()); } Where backEndStorage is a multi-cast delegate. Now you can rewrite your code: public interface IFoo { event EventHandler FooValueChanged; void RaiseFooValueChanged(IFooView sender, FooEventArgs e); } [TypeDescriptionProvider(typeof(FooBaseImplementor))] public abstract class FooBase : Control, IFoo { protected event EventHandler backEndStorage; public event EventHandler FooValueChanged { add { this.backEndStorage += value; } remove { this.backEndStorage -= value; } } public void RaiseFooValueChanged(IFooView sender, FooEventArgs e) { this.backEndStorage(sender, e); } } public class FooDerived : FooBase { public event EventHandler AnotherFooValueChanged { add { this.backEndStorage += value; } remove { this.backEndStorage -= value; } } } So now when events are added on the derived class, they will actually be added to the backEndStorage of the base class, hence allowing the base class to call the delegates registered in the derived class.
