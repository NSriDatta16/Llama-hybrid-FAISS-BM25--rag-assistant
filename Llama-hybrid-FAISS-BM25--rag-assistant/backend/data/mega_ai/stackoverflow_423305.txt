[site]: stackoverflow
[post_id]: 423305
[parent_id]: 422594
[tags]: 
It would certainly be easier to leverage an existing package than to write your own, but if you're determined to write your own, and you are prepared to spend some time learning about some dark corners of C++, you can use the Boost.Proto from Boost to engineer your own library. Basically, Boost.Proto allows you to convert any valid C++ expression, such as x * x + y * y to an expression template -- basically a representation of the parse tree of that expression using nested struct s -- and then perform any arbitrary computation over that parse tree at a later time by calling proto::eval() on it. By default, proto::eval() is used to evaluate the tree as though it had been run directly, though there's no reason why you couldn't modify the behaviour of each function or operator to take a symbolic derivative instead. Although this would be an extremely complex solution to your problem, it would nevertheless be much easier than trying to roll your own expression templates using C++ template metaprogramming techniques.
