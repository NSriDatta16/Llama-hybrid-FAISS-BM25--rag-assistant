[site]: stackoverflow
[post_id]: 3619553
[parent_id]: 
[tags]: 
Const incorrectness

Why am I getting this error: Error 1 error C2662: 'Allocator::Allocate' : cannot convert 'this' pointer from 'const Allocator' to 'Allocator &' ? Thats code: /*Allocator.h*/ /*Not finished yet but working*/ #pragma once template class Allocator { public: //typedef T value_type; typedef T* pointer; pointer Allocate(std::size_t count); pointer Construct(void* address, const pointer obj); template void Destroy_(FwdIter first,FwdIter last); void Deallocate_(void* where); Allocator(); ~Allocator(); private: void Destroy_(const T* obj); }; /*Allocator_impl.hpp*/ #pragma once #include "StdAfx.h" #include "Allocator.h" template Allocator ::Allocator() { } template Allocator ::~Allocator() { /*Destroy(); Deallocate();*/ } template typename Allocator ::pointer Allocator ::Allocate(std::size_t count) { return static_cast (::operator new(sizeof(value_type) * count)); } template typename Allocator ::pointer Allocator ::Construct(void* address, const pointer obj) { return new (address) T(*obj); } //template //void Allocator ::Destroy() //{ // //Destroy_(addressBegin_, addressBegin_ + size_); //} template void Allocator ::Destroy_(const T* obj) { obj->~T(); } template template void Allocator ::Destroy_(FwdIter first,FwdIter last) { while (first != last) { Destroy_(&*first); ++first; } } template void Allocator ::Deallocate_(void* address) { ::operator delete(address); } //template //void Allocator ::Deallocate() //{ // //Deallocate_(addressBegin_); //} /*Toy.h*/ #pragma once #include "Allocator_impl.hpp" /*As a base to managed memory*/ template > class ToyBase { typedef T* pointer; private: A alloc_; protected: //--------------------------------------COMMENT HERE pointer Allocate(const std::size_t)const; ToyBase ::ToyBase() {} template ToyBase ::~ToyBase() {} //--------------------------------------AND COMMENT HERE template typename ToyBase ::pointer ToyBase ::Allocate(const std::size_t count)const { return alloc_.Allocate(count); class ToyRepresentation : private ToyBase { public: typedef T value_type; typedef T* pointer; ToyRepresentation(const std::size_t = 0); void Push(T*); void Pop(); void GetSize()const; void GetCapacity()const; void SetCapacity(const std::size_t); void Reset(); private: pointer data_; std::size_t size_; std::size_t capacity_; static unsigned TOTAL_; //total number of created objects }; template unsigned ToyRepresentation ::TOTAL_ = 0; template ToyRepresentation ::ToyRepresentation(const std::size_t count = 0): ToyBase (), data_(Allocate(count)), size_(0), capacity_(count) { } /*tmain*/ #include "stdafx.h" #include "Toy.h" int _tmain(int argc, _TCHAR* argv[]) { try { ToyRepresentation t; } catch(const std::exception&) { } return 0; } Comments to interesting lines are marked in code. Thanks.
