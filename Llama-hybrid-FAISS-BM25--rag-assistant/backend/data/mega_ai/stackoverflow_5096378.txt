[site]: stackoverflow
[post_id]: 5096378
[parent_id]: 5057072
[tags]: 
There is actually no solution to the squares in the image. I made it work by changing the green/blue bottom on the right side of the last piece to a red/white bottom (like the piece above it has on the right). Randomizing is a bad idea, it is better to do an exhaustive search where you try every possibility like Petar Minchev answered. You may be able to speed it up by pre-processing. Except for the first piece, you will always know either one or two of the sides you need to match. Each type has only between 3 and 6 instances among all 9 pieces. Imagine you have these spaces: 0 1 2 3 4 5 6 7 8 Originally I did this by filling position 4, then 1, 3, 5, 7, and finally the corners. This found 4 solutions in 3.5 milliseconds with 2371 recursive calls. By altering the order to 4, 1, 5, 2, 7, 8, 3, 0, 6 it dropped to 1.2 milliseconds with only 813 recursive calls because there were fewer options to put in the corners. Thinking about it now, going in order would be somewhere in-between, but a modified order would just as fast (0, 1, 3, 4, 2, 5, 6, 7, 8). The important thing is that having to check two matches narrows down the number of times you will make the expensive recursive call. Step[] Steps = { new Step() { Type = 0, Position = 4 }, new Step() { Type = 1, Position = 1, MatchP1 = 4, MatchO1 = 0 }, new Step() { Type = 1, Position = 5, MatchP1 = 4, MatchO1 = 1 }, new Step() { Type = 2, Position = 2, MatchP1 = 5, MatchO1 = 0, MatchP2 = 1, MatchO2 = 1 }, new Step() { Type = 1, Position = 7, MatchP1 = 4, MatchO1 = 2 }, new Step() { Type = 2, Position = 8, MatchP1 = 7, MatchO1 = 1, MatchP2 = 5, MatchO2 = 2 }, new Step() { Type = 1, Position = 3, MatchP1 = 4, MatchO1 = 3 }, new Step() { Type = 2, Position = 0, MatchP1 = 1, MatchO1 = 3, MatchP2 = 3, MatchO2 = 0 }, new Step() { Type = 2, Position = 6, MatchP1 = 3, MatchO1 = 2, MatchP2 = 7, MatchO2 = 3 }, }; Here are how my cards are setup, notice I changed one of the sides on the last card to get a solution. 1 is red, 2 is fat, 3 is blue/green and 4 is yellow. I xor with 0x10 to signify that it is the bottom of the same color. That way you can xor 2 types and compare with 0x10 to see if they match or you can xor a type with 0x10 to find the type you are looking for. Card[] cards = { new Card(0x01, 0x03, 0x14, 0x12), new Card(0x02, 0x14, 0x13, 0x01), new Card(0x03, 0x11, 0x12, 0x04), new Card(0x01, 0x13, 0x12, 0x04), new Card(0x11, 0x13, 0x04, 0x03), new Card(0x04, 0x11, 0x12, 0x01), new Card(0x04, 0x02, 0x14, 0x13), new Card(0x02, 0x14, 0x13, 0x01), // new Card(0x01, 0x13, 0x12, 0x04) // no solution new Card(0x01, 0x11, 0x12, 0x04) // 4 solutions }; When pre-processing, I want to have an array indexed by type I am looking for which will give me all the cards that have that type and which orientation the type is on. I also throw the NextType (clockwise) in there to make comparing the corners easier: public CardImageOrientation[][] Orientations { get; set; } public struct CardImageOrientation { public int CardIndex; public int TypePosition; public int NextType; } // Orientations[1] is an array of CardImageOrientation structs // that tell me what cards contain a side with type 1, what position // it is in, and what the next type clockwise is Here's my main recursive method: public bool Method1Step(int stepIndex) { StepCalls++; if (stepIndex > 8) // found a match { FindCount++; return !Exhaustive; // false return value will keep going if exhaustive flag is true } Step step = Steps[stepIndex]; switch (step.Type) { case 0: // step 0 we just loop through all cards and try them in position 4 with orientation 0 for (int i = 0; i Interesting note: I wrote code to randomize the cards using the existing modified deck with 4 solutions and 9999 other decks created with random seeds between 1 and 9999. I found 3,465 solutions spread over 1,555 starting layouts in 7.2 seconds so it averaged to about .72 milliseconds per run. It made a total of 4.16 million calls to Method1Step().
