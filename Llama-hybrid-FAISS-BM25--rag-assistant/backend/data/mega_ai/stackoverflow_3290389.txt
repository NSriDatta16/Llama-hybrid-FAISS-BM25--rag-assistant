[site]: stackoverflow
[post_id]: 3290389
[parent_id]: 
[tags]: 
Is there an alternative for boost::phoenix::at_c in combination with boost::spirit::qi::grammar

I have created a test application to illustrate my problem. It parses a list of integers preceded by "a=" or "b=" and is separated by "\r\n". The list contains multiple occurrences of those fields in any order. #include #include #include #include #include #include typedef std::vector uint_vector_t; std::ostream& operator struct MyParser : public boost::spirit::qi::grammar { MyParser() : MyParser::base_type(Parser, "Parser") { using boost::spirit::qi::uint_; using boost::spirit::qi::_val; using boost::spirit::qi::_1; using boost::phoenix::at_c; using boost::phoenix::push_back; Parser = *( aParser [push_back(at_c (_val), _1)] | bParser [push_back(at_c (_val), _1)] ); aParser = "a=" >> uint_ >> "\r\n"; bParser = "b=" >> uint_ >> "\r\n"; } boost::spirit::qi::rule Parser; boost::spirit::qi::rule aParser, bParser; }; int main() { using boost::spirit::qi::phrase_parse; std::string input("a=0\r\nb=7531\r\na=2\r\na=3\r\nb=246\r\n"); std::string::const_iterator begin = input.begin(); std::string::const_iterator end = input.end(); MyParser parser; MyStruct result; bool succes = phrase_parse(begin, end, parser, "", result); assert(succes); std::cout In practice there are more fields with different types which need to be parsed. My objection with this approach lies in the following expression: [push_back(at_c (_val), _1)] Here is a 'hidden dependency' between the assignment and the first element of MyStruct. This makes the code fragile to changes. If the struct is changed it might still compile, but no longer do what is expected. I'm hoping for a construction like: [push_back(at_c bind(&MyStruct::aList, arg1)(_val), _1)] See this. So that it is really bound by name. Is something like this possible? Or should I take a total different approach?
