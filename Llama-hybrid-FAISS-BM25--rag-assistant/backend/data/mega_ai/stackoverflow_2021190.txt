[site]: stackoverflow
[post_id]: 2021190
[parent_id]: 2021114
[tags]: 
Your calls to getJSON are asynchronous. Hence all the calls to the inner getJSON will still be outstanding by the time the console.debug line is reached. Hence the array length is still 0. You need to run some extra code once the final getJSON call has completed. $(function(){ var apiKey = [myapikey]; var tags = ''; var tagsArr = new Array(); $.getJSON('http://api.flickr.com/services/rest/?&method=flickr.people.getPublicPhotos&api_key=' + apiKey + '&user_id=46206266@N05&extras=date_taken,tags&format=json&jsoncallback=?', function(data){ var totalExpected = data.photos.total; var totalFetched = 0; $.each(data.photos.photo, function(i, item) { var photoID = item.id; $.getJSON('http://api.flickr.com/services/rest/?&method=flickr.photos.getInfo&api_key=' + apiKey + '&photo_id=' + photoID + '&format=json&jsoncallback=?', function(data){ if (data.photo.tags.tag != '') { $.each(data.photo.tags.tag, function(j, item) { tagsArr.push(item.raw); totalFetched += 1; if (totalFetched == totalExpected) fetchComplete(); }); } }); function fetchComplete() { tags = tagsArr.join(' '); console.debug(tagsArr.length); } }); $('#total-dragged').append(data.photos.total); $('#types-dragged').append(tags); }); }); This works assuming the total number of photos doesn't excede the default 100 per page, other wise you would need to tweak it. That said I don't think using .each to fire off loads of getJSON requests makes a great deal of sense. I would refactor it so that only one call to getJSON is outstanding at any one time. Have the callback of one issue the next getJSON for the next photo until all have been pulled then do your completed code.
