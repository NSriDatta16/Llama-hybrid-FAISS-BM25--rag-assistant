[site]: stackoverflow
[post_id]: 3263347
[parent_id]: 3222096
[tags]: 
Some Time ago, i had The same question you have posted in mind. I studied a lot of articles, Tutorials, books and so on... Although These resources give me a good starting point, i still was insecure about how To apply efficiently Unit Testing code. After coming across xUnit Test Patterns: Refactoring Test Code and put it in my shelf for about one year (You know, we have a lot of stuffs To study), it gives me what i need To apply efficiently Unit Testing code. With a lot of useful patterns (and advices), you will see how you can become an Unit Testing coder. Topics as Test strategy patterns Basic patterns Fixture setup patterns Result verification patterns Test double patterns Test organization patterns Database patterns Value patterns And so on... I will show you, for instance, derived value pattern A derived input is often employed when we need to test a method that takes a complex object as an argument . For example, thorough input validation testing requires we exercise the method with each of the attributes of the object set to one or more possible invalid values . Because The first rejected value could cause Termination of The method, we must verify each bad attribute in a separate call . We can instantiate The invalid object easily by first creating a valid object and then replacing one of its attributes with a invalid value . A Test organization pattern which is related To your question (Testcase class per feature ) As The number of Test methods grows, we need To decide on which Testcase class To put each Test method... Using a Testcase class per feature gives us a systematic way To break up a large Testcase class into several smaller ones without having To change out Test methods. But before reading (source: xunitpatterns.com ) My advice: read carefully
