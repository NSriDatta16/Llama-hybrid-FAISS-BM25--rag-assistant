[site]: stackoverflow
[post_id]: 3179208
[parent_id]: 3178706
[tags]: 
Did I get this right that you sequentially run methods that are at the same nesting level? If so, why not just implement your computation methods as java.lang.Runnable instances, organize them into lists and start them in the loop? Then you would have only one place with Thread.interrupted() check. You might consider using java.util.concurrent.ExecutorService to facilitate the control over computation tasks. Updated with an example: import java.util.ArrayList; import java.util.List; public class Test { public static void main(String[] args) { List subProcesses1 = new ArrayList (); subProcesses1.add(new CompoundProcess() { public void run() { System.out.println("Process 1.1"); } }); subProcesses1.add(new CompoundProcess() { public void run() { System.out.println("Process 1.2"); } }); List subProcesses2 = new ArrayList (); subProcesses2.add(new CompoundProcess() { public void run() { System.out.println("Process 2.1"); } }); subProcesses2.add(new CompoundProcess() { public void run() { System.out.println("Process 2.2"); } }); List processes1 = new ArrayList () {}; processes1.add(new CompoundProcess(subProcesses1)); processes1.add(new CompoundProcess(subProcesses2)); CompoundProcess process = new CompoundProcess(processes1); process.run(); } static class CompoundProcess implements Runnable { private List processes = new ArrayList (); public CompoundProcess() { } public CompoundProcess(List processes) { this.processes = processes; } public void run() { for (Runnable process : processes) { if (Thread.interrupted()) { throw new RuntimeException("The processing was interrupted"); } else { process.run(); } } } } }
