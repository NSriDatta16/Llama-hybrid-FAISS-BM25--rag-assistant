[site]: stackoverflow
[post_id]: 3065429
[parent_id]: 3064062
[tags]: 
In your C++ code: I've always needed the extern "C". C++ mangles function names if you don't (the mangling is needed to support function overloading). The extern "C" tells it not to do this. I also will declare the functions as __stdcall. I believe you can tell C# which type of calling convention to use, but I think __stdcall is the default. As far as passing a string object, I'm not sure about that, I stick to only using primitives for parameter passing, so I would use const char * and adjust accordingly in my C++ code. Also, I try to avoid passing by reference. Rather, if I need to return several values, I'll set up a series of getters to handle this (a const char * returns as an IntPtr). In your C# code: I use String for the const char *, int for int, and so on. I believe Microsoft has a chart somewhere to tell you what should sub in for what. When dealing with a returned string, you need to convert it to ANSI. This can be done with a call to Marshal.PtrToStringAnsi(). For Example: In my C++ code: extern "C" __declspec(dllexport) const char* __stdcall GetCompany(const char *In) { return MyGetCompany(In); // Calls the real implementation } In my C# code: [DllImport("TheDLL.dll", EntryPoint = "GetCompany")] private static extern IntPtr privGetCompany(String In); // Call this one, not the one above: public String GetProvince(String In) { return Marshal.PtrToStringAnsi(privGetCompany(In)); } One final note, if you're running on a 64-bit machine, the 'Any CPU' configuration will make a 64-bit C# executable, which will need a 64-bit DLL. If you only have a 32-bit DLL, you'll need to add a configuration (x86). The error message you got indicates that your C# program is probably finding the DLL correctly and the function as well, so name mangling is not likely the problem. It sounds like calling convention issue or a problem with the parameter passing.
