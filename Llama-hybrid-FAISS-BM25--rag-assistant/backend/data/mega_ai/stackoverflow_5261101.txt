[site]: stackoverflow
[post_id]: 5261101
[parent_id]: 5261052
[tags]: 
My solution works with divide-and-conquer to melt all overlapping timespans in order to get a sorted list of non-overlapping timespans: module Test where type Time = Int type Start = Time type Stop = Time type Span = (Start, Stop) timespans :: [Span] timespans = [ (1200, 1210) , (1202, 1209) , (1505, 1900) , (1300, 1500) , (1400, 1430) , (500,1200) , (20,100) ] flattentime :: [Span] -> [Span] flattentime [] = [] flattentime [x] = [x] flattentime (s:ss) = combine (flattentime [ times | times = (fst s) ]) combine [] s [] = [s] combine [] s ss2 = melt s (head ss2) ++ tail ss2 combine ss1 s [] = firsts ss1 ++ melt (last ss1) s combine ss1 s ss2 = (firsts ss1) ++ melt3 (last ss1) s (head ss2) ++ (tail ss2) melt (x1,x2) (x3,x4) | x2 1) then (head ss):(melt y (x5,x6)) else melt y (x5,x6) where ss = melt (x1,x2) (x3,x4) y = last ss firsts [x] = [] firsts [] = [] firsts (x:xs) = x:(firsts xs) Its not that clean and elegant I wished it would be ... anyone has a shorter solution to that?
