[site]: stackoverflow
[post_id]: 4467515
[parent_id]: 
[tags]: 
Is there a faster version of SynchronousQueue for synchronizing only 2 threads?

I have a case in my application where I need to launch an asynchronous task and then block for it to complete. (Yes, yes, I know that it not optimal, but it's an artifact of the libraries we're using.) Specifically, I need to call a function and pass a callback object, and the actual callback will occur on a separate thread. But I want to wait for the callback to occur, essentially building a synchronous mechanism on top of an asynchronous one. So my code looks something like this: private static class MethodCallback implements RpcCallback { private Message message = null; private boolean done = false; private long started = System.currentTimeMillis(); public synchronized void run(Message parameter) { long elapsed = System.currentTimeMillis() - started; log.debug("Got callback after {} millis", elapsed); this.message = parameter; this.done = true; notifyAll(); } public synchronized void await() throws ServiceException { while(!done && (System.currentTimeMillis() - started Now, this code works perfectly well, and the application performs acceptably quickly. But profiling has determined that MessageCallback.run is a performance bottleneck, presumably due to synchronization. So as an experiment, I modified the code to use a SynchronousQueue instead, expecting that this would improve the performance. But to my surprise it made it run about twice as slowly (approximately 15ms per call on average versus approximately 7ms per call for the do-it-the-hard-way version). I could presumably hack up an alternative mechanism using either a Semaphore or something like AtomicBoolean , but should I expect either of those would perform any better? Given that I only have two threads, and I simply want one of them to wait until the other has produced a single result, is there any mechanism that will be better than what I'm doing now?
