[site]: stackoverflow
[post_id]: 4625730
[parent_id]: 4625212
[tags]: 
You are touching on one of the sticky corners of C++. The initialization of POD values in objects is sticky and depends on a few things. Even I am not sure I can get all the rules correct but I believe @Steve Jessop once wrote an article about here on SO (though I can currently find it). But some examples: This class will always be initialized b == false and value = 0. class A { A() : b(), value() {} B b; int value; }; Without an explicit default constructor it is more complex: Here the compiler will generate a default constructor for you. But how the compiler generated default constructor works depends on the situation. The compiler generated default constructor can do two different forms of initialization and which is used depends on context: Zero Initialization (All POD members are zero'ed out) Value Initialization (All POD members are left undefined) Example: class B { B b; int value; }; // Variables of static storage duration (notably globals) // Will be zero initialized and thus b == false and value = 0 B global; // Initialized int main() { // Object of automatic storage duration or dynamic storage duration // These will depend on how they are declared. // Value Initialization (POD re-mains undefined) B bo1; // b/value undefined B* bp1 = new B; // b.balue undefined // Zero Initialization B bo2 = B(); // b = false, value = 0 B* bp2 = new B(); // b = false, value = 0 // Note: The most obvious syntax for zero initializing a local object // does not work as it is actually interpreted as a forward // declaration of a function; B bo3(); }
