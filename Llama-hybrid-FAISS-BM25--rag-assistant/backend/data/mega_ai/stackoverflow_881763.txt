[site]: stackoverflow
[post_id]: 881763
[parent_id]: 843114
[tags]: 
Automated unit-testing often gets left by the wayside as managers push for quick releases rather than increasing project scope and budget to emphasis stability. The fact is, unit-test takes time. In my experience, the benefits far outweigh any drawbacks. In cases where stored procedures are being called by external systems unit-testing has been invaluable in eliminating unforeseen problems and guaranteeing stability prior to integration testing. Regarding your concerns: If you place any data required to unit test your stored procedure(s) in XML files which can be read prior to running the unit test(s), you can read the data using the standard API routines for reading XML data and potentially re-use the data for multiple tests. Run each test in the context of a transaction which is rolled back at the end of the test to allow the overall environment to be configured once at the beginning of a test run rather than having to perform lots of steps for each individual test. Unit-tests can be bundled with automated nightly build processes to further bullet-proof your code. There will be some overhead initially, but this will decrease over time as you and your team become more familiar with the unit-test concepts and how to leverage reusability. You shouldn't need to re-write your query to compare the results. A standard scenario might be something like the following: load test data and prepare environment begin transaction run stored procedure using test data compare actual output to expected output using Assert statements if actual and expected output don't match, test fails if actual and expected output match, test passes rollback transaction /... repeat steps 2 thru 7 for any additional tests .../ Cleanup test environment Keep in mind, you are testing a specific set of conditions looking for pass/fail so it's Ok to hard code the expected values within your test routines. Hope this helps, Bill
