[site]: stackoverflow
[post_id]: 2096295
[parent_id]: 2096203
[tags]: 
Here's the corrected code that should do it. #include #define MAX_BUF 150 void main() { int i; FILE *fin,*fop;char* str; str = malloc((MAX_BUF * sizeof(char)) + 1); if (str == NULL){ printf("Out of memory\n"); exit(-1); } fin=fopen("atk561011.txt","r"); if(fin == NULL){ printf("ip err"); exit(-2); } fop=fopen("svmip.txt","w"); if(fop == NULL){ printf("op err"); exit(-3); } for(i=1;i 300&&i 600&&i I have added logic checking to ensure if the file exists, to continue processing. Failure to do so will cause the code to blow up. Since in the original code, you were printing "ip err" if the input failed or in the case of output failure, yet continue on into the for loop which will render the execution to fail in that case as it would still be attempting to read from an non-existant file handle on failure. Edit: Please see the comment above in the code. Are you trying to output 1/0's based on the conditional value of i between the ranges of 300-360 and 600-660 inclusively, into the output file. Can you clarify? Should that be fputs(str[7], fop); Hope this helps, Best regards, Tom.
