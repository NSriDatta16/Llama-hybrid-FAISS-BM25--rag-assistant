[site]: stackoverflow
[post_id]: 4093927
[parent_id]: 4093847
[tags]: 
Over and above the correctly diagnosed issue with strcat() taking two strings -- why did you ignore the compiler warnings, or if there were no warnings, why don't you have warnings turned on? As I was saying, over and above that problem, you also need to consider what happens if you get EOF, and you also need to worry about the initial value of 'c' (which could accidentally be '\n' though it probably isn't). That leads to code like this: int c; char pass[20] = ""; char *end = pass + sizeof(pass) - 1; char *dst = pass; while ((c = getchar()) != EOF && c != '\n' && dst I switched from 'mygetch()' to 'getchar()' - primarily because what I say applies to that and might not apply to your 'mygetch()' function; we don't have a specification of what that function does on EOF. Alternatively, if you must use strcat() , you still need to keep a track on the length of the string, but you can do: char c[2] = ""; char pass[20] = ""; char *end = pass + sizeof(pass) - 1; char *dst = pass; while (c[0] != '\n' && dst Not as elegant as all that - using strcat() in context is overkill. You could, I suppose, do simple counting and repeatedly use strcat(pass, c) , but that has quadratic behaviour as strcat() has to skip of 0, 1, 2, 3, ... characters on the subsequent iterations. By contrast, the solution where dst points to the NUL at the end of the string means that strcat() doesn't have to skip anything. With a fixed size addition of 1 character, though, you're probably better off with the first loop.
