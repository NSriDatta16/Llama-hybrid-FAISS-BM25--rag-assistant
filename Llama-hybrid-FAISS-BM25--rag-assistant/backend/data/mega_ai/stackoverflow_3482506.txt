[site]: stackoverflow
[post_id]: 3482506
[parent_id]: 3477978
[tags]: 
You can reinterpret your ByteArray as containing only shorts. This lets you read two bytes at a time and get a single number value representing them both. Next, you can take these numbers and reinterpret them as being character codes. Finally, create a String from these character codes and you're done. public static function encode(ba:ByteArray):String { var origPos:uint = ba.position; var result:Array = new Array(); for (ba.position = 0; ba.position There is one special circumstance to pay attention to. If you try reading a short from a ByteArray when there is only one byte remaining in it, an exception will be thrown. In this case, you should call readByte with the value shifted 8 bits instead. This is the same as if the original ByteArray had an extra 0 byte at the end. (making it even in length) Now, as for decoding this String... Get the character code of each character, and place them into a new ByteArray as shorts. It will be identical to the original, except if the original had an odd number of bytes, in which case the decoded ByteArray will have an extra 0 byte at the end. public static function decode(str:String):ByteArray { var result:ByteArray = new ByteArray(); for (var i:int = 0; i In action: var ba:ByteArray = new ByteArray(); ba.writeInt(47); ba.writeUTF("Goodbye, cruel world!"); var str:String = encode(ba); ba = decode(str); trace(ba.readInt()); trace(ba.readUTF());
