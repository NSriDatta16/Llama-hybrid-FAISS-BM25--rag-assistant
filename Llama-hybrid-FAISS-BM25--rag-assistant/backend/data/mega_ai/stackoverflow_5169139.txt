[site]: stackoverflow
[post_id]: 5169139
[parent_id]: 5169091
[tags]: 
Here is a simple recursive function that does the same thing: let rec subStringIndices (haystack:string) (needle:string) (from:int) = let index = haystack.IndexOf(needle, from) if index >= 0 then let rest = subStringIndices haystack needle (index + 1) index::rest else [] printfn "%A" (subStringIndices "abaabababaaab" "ab" 0) The function takes an additional parameter from that represents the starting index (where you want to start searching in the string). Initially, this is set to zero. In the function, we first get the next index. If we find something, we recursively process the rest of the string (starting from index + 1 ) and return a list containing the index and all recursively obtained indices. A slightly more elegant and more efficient version that uses tail-recursion can be written using the accumulator parameter trick and nested function: let subStringIndices (haystack:string) (needle:string) = let rec loop (from:int) acc = let index = haystack.IndexOf(needle, from) if index >= 0 then loop (index + 1) (index::acc) else List.rev acc loop 0 [] The recursive looping is now implemented by the loop function. It gets haystack and needle as parameters from the outside, so these don't need to be copied on the stack. We accumulate the indices in the acc list passed as parameter and when we reach the end, we return the list (reversed, because we were adding new items to the front).
