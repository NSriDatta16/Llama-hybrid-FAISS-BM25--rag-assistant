[site]: stackoverflow
[post_id]: 5728364
[parent_id]: 5679387
[tags]: 
I truly don't think you should use filters in your case. Filters are temporary conditions to your data list. Here's a more elegant solution. We will reuse the functionality of sfGuardUser index action, and set its table_method "on the fly" (based on url). //exetent the configuration class to override getTable method class sfGuardUserGeneratorConfiguration extends BaseSfGuardUserGeneratorConfiguration { protected $tableMethod = null; public function setTableMethod($name) { $this->tableMethod = $name; } public function getTableMethod() { return null !== $this->tableMethod ? $this->tableMethod : parent::getTableMethod(); } } //now we need to set the tableMethod based on a route param (list): class sfGuardUserActions extends autoSfGuardUserActions { public function executeIndex(sfWebRequest $request) { //create a mapping between an url and table method $map = array( 'clients' => 'getClientsList', 'suppliers' => 'getSuppliersList', 'manufacturers' => 'getManufacturersList', ); $list = $request->getParameter('list'); $table_method = isset($map[$list]) ? $map[$list] : null; $this->configuration->setTableMethod($table_method); parent::executeIndex($request); } } //create a custom url for your lists: sf_guard_user_list: url: /guard/users/:list param: { module: sfGuardUser, action: index} requirements: list: clients|suppliers|manufacturers //and model methods for each of your lists: class sfGuardUserTable extends PluginsfGuardUserTable { /** * List of clients query * */ public function getClientsList() { $q = $this->createQuery('u') ->leftJoin('u.Groups g') ->where('g.name = ?', 'client'); return $q; } //and others } That's it. Now you can add links to your dashboard like this: 'clients')) ?> P.S. this approach now allows you to use filters (for their true reasons) on top of these lists. But, you will also have to adjust the appropriate links.
