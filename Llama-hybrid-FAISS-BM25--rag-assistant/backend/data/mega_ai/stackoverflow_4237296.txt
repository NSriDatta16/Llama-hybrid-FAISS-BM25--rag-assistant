[site]: stackoverflow
[post_id]: 4237296
[parent_id]: 4237284
[tags]: 
In C, returning NULL for an error condition is standard practice for functions returning pointers, so you're in good shape there. (For functions that don't return pointers, the usual convention is to return 0 on success and a non-zero error code on error.) Separately, and perhaps a bit off-topic: mode can't be NULL , though, can it? app_config can certainly be NULL , it's a pointer to a structure, but your mode is defined as an array, an intrinsic part of the struct, not as a pointer. You'll either have the struct, or not, but you won't have only part of the struct. Simply allocating the memory for the struct will allocate the LINE_SIZE chars for mode ; in fact, sizeof(struct Config_t) == LINE_SIZE + LINE_SIZE , the structure is an array of characters followed by another array of characters. There are no pointers involved (other than app_config , because you've defined it as a pointer to the structure). Consequently, to fully allocate your struct Config_t , just do this: app_config = malloc(sizeof(*app_config)); (or app_config = malloc(sizeof(struct Config_t)); if your platform won't allow the above.) That allocates mode , nothing else required. If mode were defined as a char * , that would be different: static struct Config_t { char *protocol; char *mode; } *app_config = NULL; Now sizeof(struct Config_t) == 2 * sizeof(void*) (see below), the structure itself consists only of two pointers, not any data that they may point to. Allocating the structure does not allocate any storage for them. #include #define LINE_SIZE (200) struct Config_t { char protocol[LINE_SIZE]; char mode[LINE_SIZE]; }; struct Config_t_with_pointers { char *protocol; char *mode; }; int main(int argc, char* argv[]) { printf("sizeof(struct Config_t) = %zu\n", sizeof(struct Config_t)); printf("sizeof(struct Config_t_with_pointers) = %zu\n", sizeof(struct Config_t_with_pointers)); return 0; } (Given your compiler, I felt free to use the z format specifier for size_t arguments, as any recent gcc has it [and it's in the C99 standard, Matthew tells us].) Output (on my 64-bit Linux system): sizeof(struct Config_t) = 400 sizeof(struct Config_t_with_pointers) = 16
