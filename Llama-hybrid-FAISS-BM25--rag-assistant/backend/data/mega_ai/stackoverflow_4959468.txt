[site]: stackoverflow
[post_id]: 4959468
[parent_id]: 4953491
[tags]: 
If you create a new Windows Phone project and use the Windows Phone Databound Template you will have most of the work done for you. What you will want to do is set up the ViewModel to contain all the data for your app. You can serialize and deserialize this data using IsolatedStorage so that it's saved across application sessions and when Tombstoning. In the template you will notice MailViewModel and ItemViewModel . MainViewModel stores all the data your application needs including an ObservableCollection of ItemViewModel, and ItemViewModel represents the individual data type for your application. On the DetailsPage.xaml page you'll want to DataBind each textbox to the App.MainViewModel Items. Set the binding to TwoWay if you want the ViewModel to get updated as soon as the user manipulates the data on DetailsPage.xaml. You can optionally set the Binding to OneWay and then have an OK button that writes the changes back to the ViewModel and saves to IsolatedStorage. Here is an example of what a Binding looks like: In this case LineOne is a property in ItemViewModel and the page gets this data from the query string when the user selects an item from the MainPage.xaml. The DataContext for the page determs where the databound information comes from. Here is the snippet where the MainPage passes the selected item from the ViewModel to the DetailsPage. // Handle selection changed on ListBox private void MainListBox_SelectionChanged(object sender, SelectionChangedEventArgs e) { // If selected index is -1 (no selection) do nothing if (MainListBox.SelectedIndex == -1) return; // Navigate to the new page NavigationService.Navigate(new Uri("/DetailsPage.xaml?selectedItem=" + MainListBox.SelectedIndex, UriKind.Relative)); // Reset selected index to -1 (no selection) MainListBox.SelectedIndex = -1; } Here is how the DetailsPage gets the selected item. protected override void OnNavigatedTo(NavigationEventArgs e) { string selectedIndex = ""; if (NavigationContext.QueryString.TryGetValue("selectedItem", out selectedIndex)) { int index = int.Parse(selectedIndex); DataContext = App.ViewModel.Items[index]; } } Play around with the default template above and ask any additional questions. The beauty of databinding and the ObservableCollection is that you can just update the data and the UX will reflect those changes immediatley. This is because any changes to the data fires off an event: public string LineOne { get { return _lineOne; } set { if (value != _lineOne) { _lineOne = value; NotifyPropertyChanged("LineOne"); } } } NotifyPropertyChanged() that broadcasts this information to the View.
