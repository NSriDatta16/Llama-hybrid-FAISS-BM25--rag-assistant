[site]: stackoverflow
[post_id]: 4121856
[parent_id]: 4121790
[tags]: 
You might want to crank up the optimisation level of your C compiler. With gcc -O3 , that makes a big difference, a drop from 2.015 seconds to 0.766 seconds, a reduction of about 62%. Beyond that, you need to ensure you've tested correctly. You should run each program ten times, remove the outliers (fastest and slowest), then average the other eight. In addition, make sure you're measuring CPU time rather than clock time. Anything less than that, I would not consider a decent statistical analysis and it may well be subject to noise, rendering your results useless. For what it's worth, those C timings above were for seven runs with the outliers taken out before averaging. In fact, this question shows how important algorithm selection is when aiming for high performance. Although recursive solutions are usually elegant, this one suffers from the fault that you duplicate a lot of calculations. The iterative version: int fib(unsigned int n) { int t, a, b; if (n = 2) { t = a + b; a = b; b = t; } return b; } further drops the time taken, from 0.766 seconds to 0.078 seconds, a further reduction of 89% and a whopping reduction of 96% from the original code. And, as a final attempt, you should try out the following, which combines a lookup table with calculations beyond a certain point: static int fib(unsigned int n) { static int lookup[] = { 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141 }; int t, a, b; if (n = sizeof(lookup)/sizeof(*lookup)) { t = a + b; a = b; b = t; } return b; } That reduces the time yet again but I suspect we're hitting the point of diminishing returns here.
