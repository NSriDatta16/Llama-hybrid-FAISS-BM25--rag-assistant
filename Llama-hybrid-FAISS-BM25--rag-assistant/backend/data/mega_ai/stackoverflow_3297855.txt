[site]: stackoverflow
[post_id]: 3297855
[parent_id]: 3290981
[tags]: 
Chapter 3 of David Allen’s book ‘Getting Things Done’ outlines a great approach to project planning. It’s not specific to software projects, and it’s very light on methodology, but I’ve found it really useful when planning projects. At that middle stage when you’re getting lost, it’s useful to look back to this planning process to see where your problem is, and thus how to solve it. I’d urge you to read the chapter (and chapter 10, which has practical suggestions on how to implement the approach), but if you want a slightly shorter and less well-written summary: “Projects” are desired outcomes that require more than one step to achieve them. The “natural” (i.e. best suited to our brains) way to plan projects is: Define purpose and principles What’s the project trying to achieve? (Purpose.) What standards and policies should we satisfy whilst trying to achieve the objective? (Principles.) With client work, it’s usually up to the client to decide the purpose, and at least some of the principles. However, they may not have though about it themselves, so you may well need to listen to them carefully from the outset, read between the lines, and figure out what will help them. Thinking about the purpose of a project can stop you getting stuck on a particular task — you may realise the task isn’t even necessary to achieve the purpose. You may well have some principles that you like to adhere to (e.g. your idea of “clean code”), but remember the client probably has theirs too (e.g. getting IT projects done quickly), and they’re the ones writing the cheques. Envision the outcome What would success look like? This can involve high-level outcomes (e.g. the client’s staff enter 20% more orders per day thanks to your OrderTron.NET Enterprise Edition CX) and more specific definitions like a spec — which is where I imagine your static designs come in. All of this lets you know what you’re aiming for, and thus helps you figure out how long it will be before you’re done. Brainstorm How can we achieve the outcome? Once you’ve got a clear idea of what success would look like, your brain will, almost without your control, start generating ideas about how to get there. Allen suggests noting all these down, without judging whether they’re good ideas or not, to take advantage of your brain’s creativity. Organize Right, how can we actually achieve the outcome? Now that you’ve got ideas about how to achieve the outcome, you organise them into a plan. Split the project up into components (e.g. database, validation, user interface), figure out priorities (e.g. the user interface has to support IE 6), and map out sequences (e.g. the data model will need to be fleshed out before we can start design the interface). You’ll be doing this repeatedly throughout the project. Identify next actions What can I do? Now that you’ve got an organised project plan, what’s the next physical action that can be done to move the project forward? There will probably be lots, and they’ll probably be tiny, e.g. create a folder for the project in our source control repository, do a first draft of the data model, Google ASP.NET validation). Once you’ve got some next actions, that’s enough planning for now. Do them. You’ve now got a plan to come back to when things need reorganising. Although I’ve listed these in order, you’ll move through all the stages lots of times during a project. For example, nitty gritty implementation details (5) can force you to redefine the successful outcome of the project (2) given the principle of keeping costs limited (1), or brainstorm new implementation approaches (3), which leads to you reorganising who works on which modules (4). Also, this process applies to really large projects (e.g. implement an order entry system for a client) and really small “projects” that are part of a large project (e.g. implement the validation layer for the order entry page of the order entry system). Whenever you’re lost in the middle of a project, check that for whatever bit you’re working on that you know what the purpose is, and what the outcome should look like. If you’re vague on the outcome, figure it out in more detail. Refer to the spec. Ask colleagues. Google. Etc. Take heart. None of this is easy. An approach like Allen’s is good to help stop you getting lost, but the skills you use at each stage of the approach can only be learned by years of hard work, mistakes and experience. If you’re having trouble figuring out whether to do the database first or not, you might just need more actual programming practice. But the fact that you’re thinking and asking about how to do projects better means you’re already doing more than lots of people ever do. Good on you, and best of luck.
