[site]: stackoverflow
[post_id]: 2678233
[parent_id]: 2676007
[tags]: 
Ruby doesn't have metaclasses. There are some constructs in Ruby which some people sometimes wrongly call metaclasses but they aren't (which is a source of endless confusion). However, there's a lot of ways to achieve the same results in Ruby that you would do with metaclasses. But without telling us what exactly you want to do, there's no telling what those mechanisms might be. In short: Ruby doesn't have metaclasses Ruby doesn't have any one construct that corresponds to Python's metaclasses Everything that Python can do with metaclasses can also be done in Ruby But there is no single construct, you will use different constructs depending on what exactly you want to do Any one of those constructs probably has other features as well that do not correspond to metaclasses (although they probably correspond to something else in Python) While you can do anything in Ruby that you can do with metaclasses in Python, it might not necessarily be straightforward Although often there will be a more Rubyish solution that is elegant Last but not least: while you can do anything in Ruby that you can do with metaclasses in Python, doing it might not necessarily be The Ruby Way So, what are metaclasses exactly? Well, they are classes of classes. So, let's take a step back: what are classes exactly? Classes … are factories for objects define the behavior of objects define on a metaphysical level what it means to be an instance of the class For example, the Array class produces array objects, defines the behavior of arrays and defines what "array-ness" means. Back to metaclasses. Metaclasses … are factories for classes define the behavior of classes define on a metaphysical level what it means to be a class In Ruby, those three responsibilities are split across three different places: the Class class creates classes and defines a little bit of the behavior the individual class's eigenclass defines a little bit of the behavior of the class the concept of "classness" is hardwired into the interpreter, which also implements the bulk of the behavior (for example, you cannot inherit from Class to create a new kind of class that looks up methods differently, or something like that – the method lookup algorithm is hardwired into the interpreter) So, those three things together play the role of metaclasses, but neither one of those is a metaclass (each one only implements a small part of what a metaclass does), nor is the sum of those the metaclass (because they do much more than that). Unfortunately, some people call eigenclasses of classes metaclasses. (Until recently, I was one of those misguided souls, until I finally saw the light.) Other people call all eigenclasses metaclasses. (Unfortunately, one of those people is the author of one the most popular tutorials on Ruby metaprogramming and the Ruby object model.) Some popular libraries add a metaclass method to Object that returns the object's eigenclass (e.g. ActiveSupport, Facets, metaid). Some people call all virtual classes (i.e. eigenclasses and include classes) metaclasses. Some people call Class the metaclass. Even within the Ruby source code itself, the word "metaclass" is used to refer to things that are not metaclasses.
