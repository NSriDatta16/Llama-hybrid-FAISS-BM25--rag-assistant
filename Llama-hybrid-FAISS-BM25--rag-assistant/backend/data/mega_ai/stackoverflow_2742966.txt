[site]: stackoverflow
[post_id]: 2742966
[parent_id]: 2742898
[tags]: 
I suspect it's the layout-management of textPane that is the issue. From what I can see, the listForSuggestions should not occupy more space than it needs to display those items, if it's preferred size is respected. So the JTextPane is a Container , that is, you can add subcomponents to it. But how are those subcomponents layed out? That is up to the layout manager currently in use. If the layout manager respects the preferred dimension of the listForSuggestios I think you should be ok. Not sure though. From what I can see, you get the "null-layout" by just instantiating a JTextPane , which means that unless you set another layout manager explicitly, you would need to take care of placement / resizing of the subcomponents yourself. You could try to do something like Dimension dim = listForSuggestions.getPreferredSize(); listForSuggestions.setBounds(xPos, yPos, dim.getWidth(), dim.getHeight()); Here is a complete example import java.awt.*; import java.awt.event.*; import java.util.ArrayList; import javax.swing.*; public class FrameTest { public static void main(String[] args) { JFrame f = new JFrame("Frame Test"); ArrayList str = new ArrayList (); for (int i = 0; i = 0) { Object o = theList.getModel().getElementAt(index); System.out.println("Double-clicked on: " + o.toString()); } } } }; listForSuggestion.setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, Color.BLACK)); listForSuggestion.addMouseListener(mouseListener); Dimension dim = listForSuggestion.getPreferredSize(); listForSuggestion.setBounds(20, 20, (int) dim.getWidth(), (int) dim.getHeight()); tp.add(listForSuggestion); f.add(tp); f.setSize(400, 400); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); } } I think the most elegant way of doing this is to roll your own layout-manager. (It's actually quite simple.) And then, instead of doing textPane.add(list) , you do textPane.add(list, YourLayoutManager.POPUP_LIST) . The layout-manager then remembers the fact that list was supposed to be layed out according to it's preferred size, and layes it out accordingly in its layoutContainer -method. (If you give the YourLayoutManager a reference to the JTextPane that it is attached to, you could probably even make it layout the list right beside the current caret location.)
