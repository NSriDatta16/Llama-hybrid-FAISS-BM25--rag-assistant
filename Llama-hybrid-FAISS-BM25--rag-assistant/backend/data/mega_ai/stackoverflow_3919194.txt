[site]: stackoverflow
[post_id]: 3919194
[parent_id]: 
[tags]: 
What is VC++ doing when packing bitfields?

To clarify my question, let's start off with an example program: #include #pragma pack(push,1) struct cc { unsigned int a : 3; unsigned int b : 16; unsigned int c : 1; unsigned int d : 1; unsigned int e : 1; unsigned int f : 1; unsigned int g : 1; unsigned int h : 1; unsigned int i : 6; unsigned int j : 6; unsigned int k : 4; unsigned int l : 15; }; #pragma pack(pop) struct cc c; int main(int argc, char **argv) { printf("%d\n",sizeof(c)); } The output is "8", meaning that the 56 bits (7 bytes) I want to pack are being packed into 8 bytes, seemingly wasting a whole byte. Curious about how the compiler was laying these bits out in memory, I tried writing specific values to &c , e.g.: int main(int argc, char **argv) { unsigned long long int* pint = &c; *pint = 0xFFFFFFFF; printf("c.a = %d", c.a); ... printf("c.l = %d", c.l); } Predictably, on x86_64 using Visual Studio 2010, the following happens: *pint = 0x00000000 000000FF : c[0].a = 7 c[0].b = 1 c[0].c = 1 c[0].d = 1 c[0].e = 1 c[0].f = 1 c[0].g = 0 c[0].h = 0 c[0].i = 0 c[0].j = 0 c[0].k = 0 c[0].l = 0 *pint = 0x00000000 0000FF00 : c[0].a = 0 c[0].b = 0 c[0].c = 0 c[0].d = 0 c[0].e = 0 c[0].f = 0 c[0].g = 1 c[0].h = 127 c[0].i = 0 c[0].j = 0 c[0].k = 0 c[0].l = 0 *pint = 0x00000000 00FF0000 : c[0].a = 0 c[0].b = 0 c[0].c = 0 c[0].d = 0 c[0].e = 0 c[0].f = 0 c[0].g = 0 c[0].h = 32640 c[0].i = 0 c[0].j = 0 c[0].k = 0 c[0].l = 0 etc. Forget portability for a moment and assume you care about one CPU, one compiler, and one runtime environment. Why can't VC++ pack this structure into 7 bytes? Is it a word-length thing? The MSDN docs on #pragma pack says "the alignment of a member will be on a boundary that is either a multiple of n [1 in my case] or a multiple of the size of the member, whichever is smaller." Can anyone give me some idea of why I get a sizeof 8 and not 7?
