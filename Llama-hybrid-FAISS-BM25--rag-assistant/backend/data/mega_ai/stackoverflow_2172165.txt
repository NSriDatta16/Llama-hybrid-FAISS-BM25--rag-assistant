[site]: stackoverflow
[post_id]: 2172165
[parent_id]: 2172053
[tags]: 
With pre-C++0x, the closest thing you can get is by not using containers designed for runtime usage (and limiting yourself to fundamental types and aggregates) : struct pair { int first; char second; }; pair arr[] = {{1,'a'}, {2,'b'}}; // assuming arr has static storage This could then be accessed using some kind of map view , or you could implement a wrapper that allows for aggregate initialization similar to what Boost.Array does. Of course the question is wether the benefits justify the time put into implementing this. If my reading is correct here, C++0x initializer-lists may give you static initialization of non-aggregates like std::map and std::pair , but only if that doesn't change semantics compared to dynamic initialization. Thus, it seems to me you can only get what you asked for if your implementation can verify via static analysis that the behaviour doesn't change if the map is statically initialized, but no guarantees that it happens.
