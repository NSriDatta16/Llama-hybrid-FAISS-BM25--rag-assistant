[site]: stackoverflow
[post_id]: 1070881
[parent_id]: 1070738
[tags]: 
There are two ideas you might want to consider: Don't create the BitmapSource inside Dispatcher.Invoke. That would practically create it inside the UI thread, slowing things down. Instead, create it in the background thread, freeze it, and then pass the frozen BitmapSource to the foreground thread. Depending on your application, perhaps the StackPanel doesn't need the full 3000x2000 resolution? If that is the case, consider resizing down the images in the background thread, just before you freeze them. The following code does #1 above: Window1.xaml Window1.xaml.cs using System; using System.IO; using System.Net; using System.Threading; using System.Windows; using System.Windows.Media.Imaging; using System.Windows.Threading; namespace BitmapFrameDemo { public partial class Window1 : Window { private Thread thread = null; private Dispatcher dispatcher = null; private void ThreadMain() { // obtain the image memory stream WebRequest request = WebRequest.Create("http://stackoverflow.com/content/img/so/logo.png"); WebResponse response = request.GetResponse(); Stream stream = response.GetResponseStream(); // create a bitmap source while still in the background thread PngBitmapDecoder decoder = new PngBitmapDecoder(stream, BitmapCreateOptions.None, BitmapCacheOption.OnLoad); BitmapFrame frame = decoder.Frames[0]; // freeze the bitmap source, so that we can pass it to the foreground thread BitmapFrame frozen = (BitmapFrame) frame.GetAsFrozen(); dispatcher.Invoke(new Action(() => { image.Source = frozen; }), new object[] { }); } public Window1() { InitializeComponent(); dispatcher = Dispatcher.CurrentDispatcher; thread = new Thread(new ThreadStart(this.ThreadMain)); thread.Start(); } } } alt text http://www.freeimagehosting.net/uploads/66bdbce78a.png
