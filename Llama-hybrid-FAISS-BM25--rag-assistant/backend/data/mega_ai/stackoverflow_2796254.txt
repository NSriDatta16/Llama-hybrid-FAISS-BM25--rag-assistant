[site]: stackoverflow
[post_id]: 2796254
[parent_id]: 2795798
[tags]: 
You can promise the data to the pasteboard without actually having the data yet. One way is to declare the type of the data on the pasteboard, passing yourself as the pasteboard's owner, and respond to a pasteboard:provideDataForType: message by providing the data (blocking, if necessary, until the data either arrives or fails to arrive). This means that you'll need to remember which objects were copied (by stashing them in an array, for example) so you can extract/generate the data from them when the promise comes due. The other way, referenced in Harald Scheirich's answer, is to make your model objects conform to the NSPasteboardWriting protocol , ideally in a category (to separate interface-independent logic from Mac-specific logic). This is much cleaner than the old way, but requires Mac OS X 10.6 and later. With NSPasteboardWriting, you'll implement promises by having the model objects' writingOptionsForType:pasteboard: method return the NSPasteboardWritingPromised option . Their pasteboardPropertyListForType: method will return the data, or at least try to—as before, this method should block until the data either arrives or fails to arrive. Oh, and to answer the question in the title (“Is NSPasteboard thread-safe?”): There's no specific answer in the Thread Safety Summary , but there is this general statement: … mutable objects are generally not thread-safe. To use mutable objects in a threaded application, the application must synchronize appropriately. I would consider an NSPasteboard to be a mutable object, so no. In practice, this isn't a problem: You typically only work with NSPasteboard in response to an action message (e.g., copy: ), a drag, or a service invocation, and those all only happen on the main thread anyway. For them to happen on a secondary thread, you would have to explicitly send such messages yourself from code running on a secondary thread, in which case you are already doing something very wrong.
