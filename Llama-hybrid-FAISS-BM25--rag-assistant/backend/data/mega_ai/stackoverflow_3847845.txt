[site]: stackoverflow
[post_id]: 3847845
[parent_id]: 3847621
[tags]: 
Well, it derives from UIView so it seems possible in theory, but it may not behave properly if its superview isn't a MKMapView. I would try it and see what happens (and let the rest of us know). Alternatively, it wouldn't be too hard to create your own UIView subclass that behaves very similarly to the MKPinAnnotationView. (I would probably subclass UIControl since you probably want to be able to respond to user events.) EDIT: I just tried a very basic implementation and it seems to work fine. Here's the code I used in my view controller. MyAnnotation is a very simple class that implements the MKAnnotation protocol. - (void)viewDidLoad { [super viewDidLoad]; MyAnnotation *annotation = [[[MyAnnotation alloc] init] autorelease]; MKPinAnnotationView *pinView = [[[MKPinAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:nil] autorelease]; pinView.center = self.view.center; [self.view addSubview:pinView]; } Another update: Well, the pin displays, but it's not draggable even if draggable = YES , and the callout doesn't appear even if canShowCallout = YES . This makes sense given that these behaviors are actually controlled by the map view, and not the actual pin view. So if you just want to display a pin with a shadow on your view, it works great. If you want some of the functionality you get when the pin is displayed in a map view, you have to implment it yourself in your view or view controller.
