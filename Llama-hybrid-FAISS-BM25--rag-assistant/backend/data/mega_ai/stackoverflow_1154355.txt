[site]: stackoverflow
[post_id]: 1154355
[parent_id]: 1152400
[tags]: 
I'll answer seriously. I do not know of any program to translate a shell script into Perl, and I doubt any interpreter module would provide the performance benefits. So I'll give an outline of how I would go about it. Now, you want to reuse your code as much as possible. In that case, I suggest selecting pieces of that code, write a Perl version of that, and then call the Perl script from the main script. That will enable you to do the conversion in small steps, assert that the converted part is working, and improve gradually your Perl knowledge. As you can call outside programs from a Perl script, you can even replace some bigger logic with Perl, and call smaller shell scripts (or other commands) from Perl to do something you don't feel comfortable yet to convert. So you'll have a shell script calling a perl script calling another shell script. And, in fact, I did exactly that with my own very first Perl script. Of course, it's important to select well what to convert. I'll explain, below, how many patterns common in shell scripts are written in Perl, so that you can identify them inside your script, and create replacements by as much cut&paste as possible. First, both Perl scripts and Shell scripts are code+functions. Ie, anything which is not a function declaration is executed in the order it is encountered. You don't need to declare functions before use, though. That means the general layout of the script can be preserved, though the ability to keep things in memory (like a whole file, or a processed form of it) makes it possible to simplify tasks. A Perl script, in Unix, starts with something like this: #!/usr/bin/perl use strict; use warnings; use Data::Dumper; #other libraries (rest of the code) The first line, obviously, points to the commands to be used to run the script, just like normal shells do. The following two "use" lines make then language more strict, which should decrease the amount of bugs you encounter because you don't know the language well (or plain did something wrong). The third use line imports the "Dumper" function of the "Data" module. It's useful for debugging purposes. If you want to know the value of an array or hash table, just print Dumper(whatever). Note also that comments are just like shell's, lines starting with "#". Now, you call external programs and pipe to or pipe from them. For example: open THIS, "cat $ARGV[0] |"; That will run cat, passing " $ARGV[0] ", which would be $1 on shell -- the first argument passed to it. The result of that will be piped into your Perl script through "THIS", which you can use to read that from it, as I'll show later. You can use "|" at the beginning or end of line, to indicate the mode "pipe to" or "pipe from", and specify a command to be run, and you can also use ">" or ">>" at the beginning, to open a file for writing with or without truncation, " " for read and write. Notice that the later will truncate the file first. Another syntax for "open", which will avoid problems with files with such characters in their names, is having the opening mode as a second argument: open THIS, "-|", "cat $ARGV[0]"; This will do the same thing. The mode "-|" stands for "pipe from" and "|-" stands for "pipe to". The rest of the modes can be used as they were ( >, >>, , + ). While there is more than this to open, it should suffice for most things. But you should avoid calling external programs as much as possible. You could open the file directly, by doing open THIS, "$ARGV[0]"; , for example, and have much better performance. So, what external programs you could cut out? Well, almost everything. But let's stay with the basics: cat, grep, cut, head, tail, uniq, wc, sort. CAT Well, there isn't much to be said about this one. Just remember that, if possible, read the file only once and keep it in memory. If the file is huge you won't do that, of course, but there are almost always ways to avoid reading a file more than once. Anyway, the basic syntax for cat would be: my $filename = "whatever"; open FILE, "$filename" or die "Could not open $filename!\n"; while( ) { print $_; } close FILE; This opens a file, and prints all it's contents (" while( ) " will loop until EOF, assigning each line to " $_ "), and close it again. If I wanted to direct the output to another file, I could do this: my $filename = "whatever"; my $anotherfile = "another"; open (FILE, "$filename") || die "Could not open $filename!\n"; open OUT, ">", "$anotherfile" or die "Could not open $anotherfile for writing!\n"; while( ) { print OUT $_; } close FILE; This will print the line to the file indicated by " OUT ". You can use STDIN , STDOUT and STDERR in the appropriate places as well, without having to open them first. In fact, " print " defaults to STDOUT , and " die " defaults to " STDERR ". Notice also the " or die ... " and " || die ... ". The operators or and || means it will only execute the following command if the first returns false (which means empty string, null reference, 0, and the like). The die command stops the script with an error message. The main difference between " or " and " || " is priority. If " or " was replaced by " || " in the examples above, it would not work as expected, because the line would be interpreted as: open FILE, ("$filename" || die "Could not open $filename!\n"); Which is not at all what is expected. As " or " has a lower priority, it works. In the line where " || " is used, the parameters to open are passed between parenthesis, making it possible to use " || ". Alas, there is something which is pretty much what cat does: while(<>) { print $_; } That will print all files in the command line, or anything passed through STDIN. GREP So, how would our "grep" script work? I'll assume "grep -E", because that's easier in Perl than simple grep. Anyway: my $pattern = $ARGV[0]; shift @ARGV; while(<>) { print $_ if /$pattern/o; } The "o" passed to $patttern instructs Perl to compile that pattern only once, thus gaining you speed. Not the style "something if cond". It means it will only execute "something" if the condition is true. Finally, " /$pattern/ ", alone, is the same as " $_ =~ m/$pattern/ ", which means compare $_ with the regex pattern indicated. If you want standard grep behavior, ie, just substring matching, you could write: print $_ if $_ =~ "$pattern"; CUT Usually, you do better using regex groups to get the exact string than cut. What you would do with "sed", for instance. Anyway, here are two ways of reproducing cut: while(<>) { my @array = split ","; print $array[3], "\n"; } That will get you the fourth column of every line, using "," as separator. Note @array and $array[3] . The @ sigil means "array" should be treated as an, well, array. It will receive an array composed of each column in the currently processed line. Next, the $ sigil means array[3] is a scalar value. It will return the column you are asking for. This is not a good implementation, though, as "split" will scan the whole string. I once reduced a process from 30 minutes to 2 seconds just by not using split -- the lines where rather large, though. Anyway, the following has a superior performance if the lines are expected to be big, and the columns you want are low: while(<>) { my ($column) = /^(?:[^,]*,){3}([^,]*),/; print $column, "\n"; } This leverages regular expressions to get the desired information, and only that. If you want positional columns, you can use: while(<>) { print substr($_, 5, 10), "\n"; } Which will print 10 characters starting from the sixth (again, 0 means the first character). HEAD This one is pretty simple: my $printlines = abs(shift); my $lines = 0; my $current; while(<>) { if($ARGV ne $current) { $lines = 0; $current = $ARGV; } print "$_" if $lines Things to note here. I use "ne" to compare strings. Now, $ARGV will always point to the current file, being read, so I keep track of them to restart my counting once I'm reading a new file. Also note the more traditional syntax for "if", right along with the post-fixed one. I also use a simplified syntax to get the number of lines to be printed. When you use "shift" by itself it will assume "shift @ARGV". Also, note that shift, besides modifying @ARGV, will return the element that was shifted out of it. As with a shell, there is no distinction between a number and a string -- you just use it. Even things like "2"+"2" will work. In fact, Perl is even more lenient, cheerfully treating anything non-number as a 0, so you might want to be careful there. This script is very inefficient, though, as it reads ALL file, not only the required lines. Let's improve it, and see a couple of important keywords in the process: my $printlines = abs(shift); my @files; if(scalar(@ARGV) == 0) { @files = ("-"); } else { @files = @ARGV; } for my $file (@files) { next unless -f $file && -r $file; open FILE, " ) { last if $lines == $printlines; print "$_"; $lines++; } close FILE; } The keywords "next" and "last" are very useful. First, "next" will tell Perl to go back to the loop condition, getting the next element if applicable. Here we use it to skip a file unless it is truly a file (not a directory) and readable. It will also skip if we couldn't open the file even then. Then "last" is used to immediately jump out of a loop. We use it to stop reading the file once we have reached the required number of lines. It's true we read one line too many, but having "last" in that position shows clearly that the lines after it won't be executed. There is also "redo", which will go back to the beginning of the loop, but without reevaluating the condition nor getting the next element. TAIL I'll do a little trick here. my $skiplines = abs(shift); my @lines; my $current = ""; while(<>) { if($ARGV ne $current) { print @lines; undef @lines; $current = $ARGV; } push @lines, $_; shift @lines if $#lines == $skiplines; } print @lines; Ok, I'm combining "push", which appends a value to an array, with "shift", which takes something from the beginning of an array. If you want a stack, you can use push/pop or shift/unshift. Mix them, and you have a queue. I keep my queue with at most 10 elements with $#lines which will give me the index of the last element in the array. You could also get the number of elements in @lines with scalar(@lines) . UNIQ Now, uniq only eliminates repeated consecutive lines, which should be easy with what you have seen so far. So I'll eliminate all of them: my $current = ""; my %lines; while(<>) { if($ARGV ne $current) { undef %lines; $current = $ARGV; } print $_ unless defined($lines{$_}); $lines{$_} = ""; } Now here I'm keeping the whole file in memory, inside %lines . The use of the % sigil indicates this is a hash table. I'm using the lines as keys, and storing nothing as value -- as I have no interest in the values. I check where the key exist with "defined($lines{$_})", which will test if the value associated with that key is defined or not; the keyword "unless" works just like "if", but with the opposite effect, so it only prints a line if the line is NOT defined. Note, too, the syntax $lines{$_} = "" as a way to store something in a hash table. Note the use of {} for hash table, as opposed to [] for arrays. WC This will actually use a lot of stuff we have seen: my $current; my %lines; my %words; my %chars; while(<>) { $lines{"$ARGV"}++; $chars{"$ARGV"} += length($_); $words{"$ARGV"} += scalar(grep {$_ ne ""} split /\s/); } for my $file (keys %lines) { print "$lines{$file} $words{$file} $chars{$file} $file\n"; } Three new things. Two are the "+=" operator, which should be obvious, and the "for" expression. Basically, a "for" will assign each element of the array to the variable indicated. The "my" is there to declare the variable, though it's unneeded if declared previously. I could have an @array variable inside those parenthesis. The "keys %lines" expression will return as an array they keys (the filenames) which exist for the hash table "%lines". The rest should be obvious. The third thing, which I actually added only revising the answer, is the "grep". The format here is: grep { code } array It will run "code" for each element of the array, passing the element as "$_". Then grep will return all elements for which the code evaluates to "true" (not 0, not "", etc). This avoids counting empty strings resulting from consecutive spaces. Similar to "grep" there is "map", which I won't demonstrate here. Instead of filtering, it will return an array formed by the results of "code" for each element. SORT Finally, sort. This one is easy too: my @lines; my $current = ""; while(<>) { if($ARGV ne $current) { print sort @lines; undef @lines; $current = $ARGV; } push @lines, $_; } print sort @lines; Here, "sort" will sort the array. Note that sort can receive a function to define the sorting criteria. For instance, if I wanted to sort numbers I could do this: my @lines; my $current = ""; while(<>) { if($ARGV ne $current) { print sort @lines; undef @lines; $current = $ARGV; } push @lines, $_; } print sort {$a $b} @lines; Here " $a " and " $b " receive the elements to be compared. " " returns -1, 0 or 1 depending on whether the number is less than, equal to or greater than the other. For strings, "cmp" does the same thing. HANDLING FILES, DIRECTORIES & OTHER STUFF As for the rest, basic mathematical expressions should be easy to understand. You can test certain conditions about files this way: for my $file (@ARGV) { print "$file is a file\n" if -f "$file"; print "$file is a directory\n" if -d "$file"; print "I can read $file\n" if -r "$file"; print "I can write to $file\n" if -w "$file"; } I'm not trying to be exaustive here, there are many other such tests. I can also do "glob" patterns, like shell's "*" and "?", like this: for my $file (glob("*")) { print $file; print "*" if -x "$file" && ! -d "$file"; print "/" if -d "$file"; print "\t"; } If you combined that with "chdir", you can emulate "find" as well: sub list_dir($$) { my ($dir, $prefix) = @_; my $newprefix = $prefix; if ($prefix eq "") { $newprefix = $dir; } else { $newprefix .= "/$dir"; } chdir $dir; for my $file (glob("*")) { print "$prefix/" if $prefix ne ""; print "$dir/$file\n"; list_dir($file, $newprefix) if -d "$file"; } chdir ".."; } list_dir(".", ""); Here we see, finally, a function. A function is declared with the syntax: sub name (params) { code } Strictly speakings, "(params)" is optional. The declared parameter I used, " ($$) ", means I'm receiving two scalar parameters. I could have " @ " or " % " in there as well. The array " @_ " has all the parameters passed. The line " my ($dir, $prefix) = @_ " is just a simple way of assigning the first two elements of that array to the variables $dir and $prefix . This function does not return anything (it's a procedure, really), but you can have functions which return values just by adding " return something; " to it, and have it return "something". The rest of it should be pretty obvious. MIXING EVERYTHING Now I'll present a more involved example. I'll show some bad code to explain what's wrong with it, and then show better code. For this first example, I have two files, the names.txt file, which names and phone numbers, the systems.txt, with systems and the name of the responsible for them. Here they are: names.txt John Doe, (555) 1234-4321 Jane Doe, (555) 5555-5555 The Boss, (666) 5555-5555 systems.txt Sales, Jane Doe Inventory, John Doe Payment, That Guy I want, then, to print the first file, with the system appended to the name of the person, if that person is responsible for that system. The first version might look like this: #!/usr/bin/perl use strict; use warnings; open FILE, "names.txt"; while( ) { my ($name) = /^([^,]*),/; my $system = get_system($name); print $_ . ", $system\n"; } close FILE; sub get_system($) { my ($name) = @_; my $system = ""; open FILE, "systems.txt"; while( ) { next unless /$name/o; ($system) = /([^,]*)/; } close FILE; return $system; } This code won't work, though. Perl will complain that the function was used too early for the prototype to be checked, but that's just a warning. It will give an error on line 8 (the first while loop), complaining about a readline on a closed filehandle. What happened here is that " FILE " is global, so the function get_system is changing it. Let's rewrite it, fixing both things: #!/usr/bin/perl use strict; use warnings; sub get_system($) { my ($name) = @_; my $system = ""; open my $filehandle, "systems.txt"; while( ) { next unless /$name/o; ($system) = /([^,]*)/; } close $filehandle; return $system; } open FILE, "names.txt"; while( ) { my ($name) = /^([^,]*),/; my $system = get_system($name); print $_ . ", $system\n"; } close FILE; This won't give any error or warnings, nor will it work. It returns just the sysems, but not the names and phone numbers! What happened? Well, what happened is that we are making a reference to " $_ " after calling get_system , but, by reading the file, get_system is overwriting the value of $_ ! To avoid that, we'll make $_ local inside get_system . This will give it a local scope, and the original value will then be restored once returned from get_system : #!/usr/bin/perl use strict; use warnings; sub get_system($) { my ($name) = @_; my $system = ""; local $_; open my $filehandle, "systems.txt"; while( ) { next unless /$name/o; ($system) = /([^,]*)/; } close $filehandle; return $system; } open FILE, "names.txt"; while( ) { my ($name) = /^([^,]*),/; my $system = get_system($name); print $_ . ", $system\n"; } close FILE; And that still doesn't work! It prints a newline between the name and the system. Well, Perl reads the line including any newline it might have. There is a neat command which will remove newlines from strings, " chomp ", which we'll use to fix this problem. And since not every name has a system, we might, as well, avoid printing the comma when that happens: #!/usr/bin/perl use strict; use warnings; sub get_system($) { my ($name) = @_; my $system = ""; local $_; open my $filehandle, "systems.txt"; while( ) { next unless /$name/o; ($system) = /([^,]*)/; } close $filehandle; return $system; } open FILE, "names.txt"; while( ) { my ($name) = /^([^,]*),/; my $system = get_system($name); chomp; print $_; print ", $system" if $system ne ""; print "\n"; } close FILE; That works, but it also happens to be horribly inefficient. We read the whole systems file for every line in the names file. To avoid that, we'll read all data from systems once, and then use that to process names. Now, sometimes a file is so big you can't read it into memory. When that happens, you should try to read into memory any other file needed to process it, so that you can do everything in a single pass for each file. Anyway, here is the first optimized version of it: #!/usr/bin/perl use strict; use warnings; our %systems; open SYSTEMS, "systems.txt"; while( ) { my ($system, $name) = /([^,]*),(.*)/; $systems{$name} = $system; } close SYSTEMS; open NAMES, "names.txt"; while( ) { my ($name) = /^([^,]*),/; chomp; print $_; print ", $systems{$name}" if defined $systems{$name}; print "\n"; } close NAMES; Unfortunately, it doesn't work. No system ever appears! What has happened? Well, let's look into what " %systems " contains, by using Data::Dumper : #!/usr/bin/perl use strict; use warnings; use Data::Dumper; our %systems; open SYSTEMS, "systems.txt"; while( ) { my ($system, $name) = /([^,]*),(.*)/; $systems{$name} = $system; } close SYSTEMS; print Dumper(%systems); open NAMES, "names.txt"; while( ) { my ($name) = /^([^,]*),/; chomp; print $_; print ", $systems{$name}" if defined $systems{$name}; print "\n"; } close NAMES; The output will be something like this: $VAR1 = ' Jane Doe'; $VAR2 = 'Sales'; $VAR3 = ' That Guy'; $VAR4 = 'Payment'; $VAR5 = ' John Doe'; $VAR6 = 'Inventory'; John Doe, (555) 1234-4321 Jane Doe, (555) 5555-5555 The Boss, (666) 5555-5555 Those $VAR1/$VAR2/etc is how Dumper displays a hash table. The odd numbers are the keys, and the succeeding even numbers are the values. Now we can see that each name in %systems has a preceeding space! Silly regex mistake, let's fix it: #!/usr/bin/perl use strict; use warnings; our %systems; open SYSTEMS, "systems.txt"; while( ) { my ($system, $name) = /^\s*([^,]*?)\s*,\s*(.*?)\s*$/; $systems{$name} = $system; } close SYSTEMS; open NAMES, "names.txt"; while( ) { my ($name) = /^\s*([^,]*?)\s*,/; chomp; print $_; print ", $systems{$name}" if defined $systems{$name}; print "\n"; } close NAMES; So, here, we are aggressively removing any spaces from the beginning or end of name and system. There are other ways to form that regex, but that's beside the point. There is still one problem with this script, which you'll have seen if your "names.txt" and/or "systems.txt" files have an empty line at the end. The warnings look like this: Use of uninitialized value in hash element at ./exemplo3e.pl line 10, line 4. Use of uninitialized value in hash element at ./exemplo3e.pl line 10, line 4. John Doe, (555) 1234-4321, Inventory Jane Doe, (555) 5555-5555, Sales The Boss, (666) 5555-5555 Use of uninitialized value in hash element at ./exemplo3e.pl line 19, line 4. What happened here is that nothing went into the " $name " variable when the empty line was processed. There are many ways around that, but I choose the following: #!/usr/bin/perl use strict; use warnings; our %systems; open SYSTEMS, "systems.txt" or die "Could not open systems.txt!"; while( ) { my ($system, $name) = /^\s*([^,]+?)\s*,\s*(.+?)\s*$/; $systems{$name} = $system if defined $name; } close SYSTEMS; open NAMES, "names.txt" or die "Could not open names.txt!"; while( ) { my ($name) = /^\s*([^,]+?)\s*,/; chomp; print $_; print ", $systems{$name}" if defined($name) && defined($systems{$name}); print "\n"; } close NAMES; The regular expressions now require at least one character for name and system, and we test to see if " $name " is defined before we use it. CONCLUSION Well, then, these are the basic tools to translate a shell script. You can do MUCH more with Perl, but that was not your question, and it wouldn't fit here anyway. Just as a basic overview of some important topics, A Perl script that might be attacked by hackers need to be run with the -T option, so that Perl will complain about any vulnerable input which has not been properly handled. There are libraries, called modules, for database accesses, XML&cia handling, Telnet, HTTP & other protocols. In fact, there are miriads of modules which can be found at CPAN . As mentioned by someone else, if you make use of AWK or SED, you can translate those into Perl with A2P and S2P . Perl can be written in an Object Oriented way. There are multiple versions of Perl. As of this writing, the stable one is 5.8.8 and there is a 5.10.0 available. There is also a Perl 6 in development, but experience has taught everyone not to wait too eagerly for it. There is a free, good, hands-on, hard & fast book about Perl called Learning Perl The Hard Way . It's style is similar to this very answer. It might be a good place to go from here. I hope this helped. DISCLAIMER I'm NOT trying to teach Perl, and you will need to have at least some reference material. There are guidelines to good Perl habits, such as using " use strict; " and " use warnings; " at the beginning of the script, to make it less lenient of badly written code, or using STDOUT and STDERR on the print lines, to indicate the correct output pipe. This is stuff I agree with, but I decided it would detract from the basic goal of showing patterns for common shell script utilities.
