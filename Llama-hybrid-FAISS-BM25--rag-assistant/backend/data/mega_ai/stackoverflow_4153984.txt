[site]: stackoverflow
[post_id]: 4153984
[parent_id]: 4068681
[tags]: 
Paul's answer gives a corecursive definition of level-order traversal - an unfold to lists. (Exercise: write makeLayer using Data.List.unfoldr .) That's my favourite way too; see The Underappreciated Unfold . But it can also be done recursively - as a fold on trees. These are defined by analogy with foldr on lists as follows: foldt :: (Integer->a) -> (Integer->a->a->a) -> Tree -> a foldt f g (Leaf n) = f n foldt f g (Node n t u) = g n (foldt f g t) (foldt f g u) Then level-order traversal is given by a straightforward tree fold, with a possible reverse : wLayer :: Tree -> Order -> [Layer] wLayer t o = (if o==BottomUp then reverse else id) (foldt single glue t) I took the liberty of renaming your flag type Order to a void a name clash, and making it an instance of Eq : data Order = BottomUp | TopDown deriving Eq The function single makes the level-order traversal of a leaf: single :: Integer -> [Layer] single n = [[n]] whereas glue combines a label and the traversals of two children into the traversal of a node: glue :: Integer -> [Layer] -> [Layer] -> [Layer] glue n x y = [n] : longzipwith (++) x y The crucial ingredient is a function longzipwith , which is like zipWith except that (i) the length of the result is the length of the longer argument, not the shorter, and hence (ii) the binary operator has to be a->a->a : longzipwith :: (a->a->a) -> [a] -> [a] -> [a] longzipwith f (a:x) (b:y) = f a b : longzipwith f x y longzipwith f x [] = x longzipwith f [] y = y
