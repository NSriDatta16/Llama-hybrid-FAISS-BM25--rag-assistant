[site]: stackoverflow
[post_id]: 1953545
[parent_id]: 1953544
[tags]: 
There's several ways of doing this. In bash >= 3, you have regex matching like you describe, e.g. $ foo=foobar $ if [[ $foo =~ f.ob.r ]]; then echo "ok"; fi ok Note that this syntax uses regex patterns, so it uses . instead of ? to match a single character. If what you want to do is just test that the string contains a substring, there's more classic ways of doing that, e.g. # ${foo/b?r/} replaces "b?r" with the empty string in $foo # So we're testing if $foo does not contain "b?r" one time $ if [[ ${foo/b?r/} = $foo ]]; then echo "ok"; fi You can also test if a string begins or ends with an expression this way: # ${foo%b?r} removes "bar" in the end of $foo # So we're testing if $foo does not end with "b?r" $ if [[ ${foo%b?r} = $foo ]]; then echo "ok"; fi # ${foo#b?r} removes "b?r" in the beginning of $foo # So we're testing if $foo does not begin with "b?r" $ if [[ ${foo#b?r} = $foo ]]; then echo "ok"; fi ok See the Parameter Expansion paragraph of man bash for more info on these syntaxes. Using ## or %% instead of # and % respectively will achieve a longest matching instead of a simple matching. Another very classic way of dealing with wildcards is to use case: case $foo in *bar) echo "Foo matches *bar" ;; bar?) echo "Foo matches bar?" ;; *) echo "Foo didn't match any known rule" ;; esac
