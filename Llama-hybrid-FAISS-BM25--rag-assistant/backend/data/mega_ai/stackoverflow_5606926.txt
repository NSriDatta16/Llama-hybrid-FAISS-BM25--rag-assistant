[site]: stackoverflow
[post_id]: 5606926
[parent_id]: 5606589
[tags]: 
The documentation says this about the "s" format specifier to PyArg_ParseTuple : s (string or Unicode) [const char *] Convert a Python string or Unicode object to a C pointer to a character string. You must not provide storage for the string itself; a pointer to an existing string is stored into the character pointer variable whose address you pass. That means that the pointer is pointing to memory that Python itself is managing. If you dig into the Python source (I'm using version 3.2) you'll find PyArg_ParseTuple in Python/getargs.c . If you trace the execution (a mark-I eyeball should be sufficient if you already know C) you'll get to convertsimple which handles some simple data type format strings (such as "s"). Then have a look at the 's' branch of the switch and you'll see this: char **p = va_arg(*p_va, char **); /* ... */ *p = PyBytes_AS_STRING(uarg); And a little grepping will yield the definition of PyBytes_AS_STRING : #define PyBytes_AS_STRING(op) (assert(PyBytes_Check(op)), \ (((PyBytesObject *)(op))->ob_sval)) So all this is really doing is handing you a pointer to a field, ob_sval , inside the Python object; Python is managing the memory for its internal objects. So, you shouldn't free your command string because it ends up pointing into some of Python's internal data and Python itself is responsible for that memory. Hence the "hands off" warning in the documentation.
