[site]: stackoverflow
[post_id]: 2503739
[parent_id]: 
[tags]: 
How do determine what is *really* causing your compiler error

I am porting a very large code base and I am having more difficulty with old code. For example, this causes a compiler error: inline CP_M_ReferenceCounted * FrAssignRef(CP_M_ReferenceCounted * & to, CP_M_ReferenceCounted * from) { if (from) from->AddReference(); if (to) to->RemoveReference(); to = from; return to; } The error is: error: expected initializer before '*' token. How do I know what this is. I looked up inline member functions to be sure I understood and I dont think the inlining is the cause but I am not sure what is. Another example: template eachClass FrReferenceIfClass(FxRC * ptr) { eachClass getObject = dynamic_cast (ptr); if (getObject) getObject->AddReference(); return getObject; } The error is: error: template declaration of 'eachClass FrReferenceIfClass' That is all. How do I decide what this is?. I am admittedly rusty with templates. UPDATE: Here is CP_M_ReferenceCounted: #pragma once #ifndef _H_CP_M_RefCounted #define _H_CP_M_RefCounted // CPLAT_Framework #include "CP_Types.h" CPLAT_Begin_Namespace_CPLAT /*! * @class CP_M_RefCounted * @brief Mix-in class for objects that are reference counted. */ class CP_EXPORT CP_M_RefCounted { public: //! @name Reference //@{ UInt32 AddReference() const; UInt32 RemoveReference() const; //@} //! @name Autorelease //@{ void Autorelease() const; //@} //! @name Getters //@{ /*! * Returns the current ref count. * * @exception none * * @return UInt32 The current referencce count. */ UInt32 GetRefCount() const { return( fRefCount ); } //@} //! @name operators //@{ CP_M_RefCounted& operator = ( const CP_M_RefCounted& inRefCounted ); //@} protected: //! @name Constructor / Destructor //@{ //! Constructor. CP_M_RefCounted(); CP_M_RefCounted( CP_M_RefCounted& inRefCounted ); //! Destructor. virtual ~CP_M_RefCounted(); //@} // class data private: mutable UInt32 fRefCount; /*! The number of references to this object. */ //======================================================================== // Platform specific routines //======================================================================== #if TARGET_OS_MAC #endif #if TARGET_OS_WIN32 #endif #if TARGET_OS_LINUX #endif }; template inline const T* CP_Autorelease(const T* inObj) { if( inObj ) inObj->Autorelease(); return( inObj ); } template inline T* CP_Autorelease(T* inObj) { if( inObj ) inObj->Autorelease(); return( inObj ); } /*! * @class CP_SmartRef * @brief Template class representing a smart pointer for reference counted objects. */ template class CP_SmartRef { public: //! @name Constructor / Destructor //@{ //! Constructor. CP_SmartRef() : fObj(NULL) {} CP_SmartRef( T *inObj, bool inTransferOwnership=false ) : fObj(inObj) { if( !inTransferOwnership && fObj ) fObj->AddReference(); } CP_SmartRef( const CP_SmartRef & inRef ) : fObj(inRef.fObj) { if( fObj ) fObj->AddReference(); } template CP_SmartRef( const CP_SmartRef & inRef ) : fObj(NULL) { T* other = inRef.Get(); this->Reset( other ); } // assignment to local variable should prevent upcasts and cross-casts //! Destructor. ~CP_SmartRef() { if( fObj ) fObj->RemoveReference(); } //@} //! @name operators //@{ T& operator *() const { return( *fObj ); } T* operator->() const { return( fObj ); } operator T *() const { return( fObj ); } CP_SmartRef & operator = ( const CP_SmartRef & inRef ) { this->Reset( inRef.fObj ); return *this; } template CP_SmartRef & operator = ( const CP_SmartRef & inRef ) { this->Reset( inRef.Get() ); return *this; } CP_SmartRef & operator = ( T* inObj ) { this->Reset( inObj ); return *this; } template CP_SmartRef & operator = ( Other* inObj ) { this->Reset( inObj ); return *this; } //@} //! @name Object management //@{ T *Get() const { return( fObj ); } T *Reset( T *inObj, bool inTransferOwnership = false ); T *Release(); //@} // class data protected: T *fObj; //======================================================================== // Platform specific routines //======================================================================== #if TARGET_OS_MAC #endif #if TARGET_OS_WIN32 #endif #if TARGET_OS_LINUX #endif }; template T* CP_SmartRef ::Reset( T *inObj, bool inTransferOwnership ) { if ( inObj != fObj ) { if( fObj ) fObj->RemoveReference(); fObj = inObj; if( inObj && !inTransferOwnership ) inObj->AddReference(); } else if( inObj && inTransferOwnership ) { inObj->RemoveReference(); } return( fObj ); } template T* CP_SmartRef ::Release() { T *tmp = fObj; fObj = NULL; return( tmp ); } CPLAT_End_Namespace_CPLAT #endif // _H_CP_M_RefCounted
