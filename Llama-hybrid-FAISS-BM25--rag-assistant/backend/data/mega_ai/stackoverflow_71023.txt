[site]: stackoverflow
[post_id]: 71023
[parent_id]: 68578
[tags]: 
.NET Framework 3.5 has got ranges: Enumerable.Range from MSDN you can use it with "contains" and the IF statement, since like someone said the SWITCH statement uses the "==" operator. Here an example: int c = 2; if(Enumerable.Range(0,10).Contains(c)) DoThing(); else if(Enumerable.Range(11,20).Contains(c)) DoAnotherThing(); But I think we can have more fun: since you won't need the return values and this action doesn't take parameters, you can easily use actions! public static void MySwitchWithEnumerable(int switchcase, int startNumber, int endNumber, Action action) { if(Enumerable.Range(startNumber, endNumber).Contains(switchcase)) action(); } The old example with this new method: MySwitchWithEnumerable(c, 0, 10, DoThing); MySwitchWithEnumerable(c, 10, 20, DoAnotherThing); Since you are passing actions, not values, you should omit the parenthesis, it's very important. If you need function with arguments, just change the type of Action to Action . If you need return values, use Func . In C# 3.0 there is no easy Partial Application to encapsulate the fact the the case parameter is the same, but you create a little helper method (a bit verbose, tho). public static void MySwitchWithEnumerable(int startNumber, int endNumber, Action action){ MySwitchWithEnumerable(3, startNumber, endNumber, action); } Here an example of how new functional imported statement are IMHO more powerful and elegant than the old imperative one.
