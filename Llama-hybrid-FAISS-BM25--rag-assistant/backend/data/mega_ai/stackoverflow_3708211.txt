[site]: stackoverflow
[post_id]: 3708211
[parent_id]: 3708117
[tags]: 
You do not need to cache objects, however you might want to do so to save memory, I/O and CPU resources etc. Memory The JVM for example might cache Integer objects, whenever you ask to create a new object, it might simply return a reference to an already existing object with the same value. Read more on the Flyweight pattern. CPU You can save on CPU resources by storing results that take lots of CPU to calculate, in a cache. Related technique: Memoization . I/O By caching some data in the application, you can save on I/O instead of hitting the database, hard drive, or network with each access. Requested Example: Suppose you're building a website where you need to display quotes of stocks, you will be reading them through a web API (network I/O) . You are only required to have prices updated only once a minute (infrequent changes) . Your website is being used by many users at once (concurrency/multithreading) . A caching solution can be to read the stock price once a minute, then keeping it in a thread-safe object. Each thread (represents requests from your concurrent users) will be reading from that object, instead of hitting the web API each time (network I/O savings) . The object is thread-safe, so the threads will not be reading that cached value in an inconsistent state while it is being updated each minute. So each of the clients needs to wait for the other client to finish their task? Sidenote: this is a concurrency issue and not so much a caching issue. No, not necessarily, since there are thread-safe structures that will not block on reads . Further more in this example, there is only one thread that will update the object (the periodic one minute price update). To elaborate, say we will cache those stock prices in a ConcurrentHashMap where the string represents the stock symbol, "GOOG", "ORCL", "MSFT" etc, and the BigDecimal represents the price/quote of the stock. To serve your users you will be reading values from that map like this : price = quotesMap.get("GOOG"); // get Google stocks quote The ConcurrentHashMap.get() call is a thread-safe non-blocking (does not entail locking) call, and your multiple threads can do retrievals from the map concurrently. The safety is insured by the fact that, all your get() calls will receive the latest completed update (done by your price updating thread when it calls ConcurrentHashMap.put() to update the prices cache).
