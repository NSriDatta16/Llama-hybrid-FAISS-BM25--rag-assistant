[site]: stackoverflow
[post_id]: 676461
[parent_id]: 
[tags]: 
setjmp/signal crash exception handling

I am trying to install a "crash handler" for a C OSX Carbon multithreaded application. On Windows, I can easily use the simple and efficient __try{} __except{} SEH of Windows which works great. (Note these are unrelated to C++ exceptions, these are lower level C constructs!) This is very related to a question I asked on SO previously : and also to an older SO question . The answer seems to be to use a setjmp() before each region of code, then use a signal handler to longjmp() back if there was a crash. But implementation of this is nontrivial.. because of multithreading! The __try{} __except{} idiom in Windows is thread-safe and Just Works. But apparently setjmp is not thread safe. So what would an implementation look like? I keep thinking I will have to implement some thread-local storage. At the start I initialize setjmp, storing the environment state into a thread-local buffer, then the signal handler would have to find the environment data again by looking into the thread-local region. However, neither Google nor SO shows any evidence that this is the proper strategy, especially since setjmp() is documented as being thread unsafe. And wouldn't thread local storage need every thread to register itself and allocate memory (to hold that environment data) , and free it on thread destruction? I am hoping I can make a macro that will wrap all of this so on OSX, my __try __except code will just work. So, how do I make an OSX multithread-safe crash recovery handler using signals and setjmp?
