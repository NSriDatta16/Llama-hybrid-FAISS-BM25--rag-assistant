[site]: stackoverflow
[post_id]: 5630031
[parent_id]: 4664002
[tags]: 
It sounds like you're really asking for the inverse of the old nohup command; that is to say some way to ensure that the remote command responds to the HUP (hang-up) signal that's generated by the TTY (PTY or psuedo-tty) driver when the underlying connection to it is closed. Personally I suspect that Paramiko is going to be far better than trying to manage this with the subprocess module. You can have Paramiko open the connection, allocate the pty and execute your commands without any cruft; and the code to use your existing known_hosts and identity files (private keys) is relatively straightforward. This recipe Copy files over SSH using paramiko at ActiveState shows the basics of loading ssh known_hosts, using identity files and interacting with any ssh agent you might be running. From there what you're asking for should simply be a matter of: creating a session , creating a channel , getting a pty and executing your remote command or invoking a shell and sending the your command to that shell using the stdin file like object it returns. You could also use the TwistedConch implementation of the SSH protocols. However, wrapping your head around the Twisted programming framework might be rather more difficult. Here's an example of a simple ssh server in Twisted, with pty support: Twisted Conch in 60 Seconds: PTY Requests Here's an SO thread from only a week before yours was posted Best way to run remote commands thru ssh in Twisted? but that didn't cover pty related issues at all. Looking at the docs for twisted.conch.ssh.session suggests that it has pty support; but lists it as "Undocumented." Of course you could even go with Pexpect , spawn a shell to your local ssh client and send your remote command through that. This would most closely emulate the way that you'd run the command from your own shell.
