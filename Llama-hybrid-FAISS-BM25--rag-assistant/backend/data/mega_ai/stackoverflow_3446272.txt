[site]: stackoverflow
[post_id]: 3446272
[parent_id]: 3446257
[tags]: 
It's almost certainly because you haven't allocated space for your string. The reason myargv[1]="123"; works is because you set the pointer to point to a string that already exists (the compiler generally puts that "123" into pre-initialised memory and it just gets loaded). By using something like: char *myargv[10]; strcpy (myargv[1], "anything"); you'll generally run into problems because there's no allocated backing storage for the myargv[1] pointer. What you can do is to simply set myargv[1] directly to the buffer where you sprintf -ed the string: char sprintf_buffer[whatever]; sprintf (sprintf_buffer, "%d", myInteger); myargv[1] = sprintf_buffer; Or, if you're re-using that buffer (so that the value gets overwritten for multiple integer arguments), use strdup . char sprintf_buffer[whatever]; sprintf (sprintf_buffer, "%d", myInteger1); myargv[1] = strdup (sprintf_buffer); sprintf (sprintf_buffer, "%d", myInteger2); myargv[2] = strdup (sprintf_buffer); And if, for some reason, your platform doesn't have a strdup , here's one for you: char *strdup (const char *s) { char *d = (char *)(malloc (strlen (s) + 1)); if (d != NULL) strcpy (d,s); return d; } Keep in mind you should always check the return value from strdup to make sure the memory allocation worked. I've left it out here since it's not relevant to the question at hand. You can avoid memory allocation with multiple buffers (provided you know the absolute number of buffers you'll need in advance): char sprintf_buffer1[whatever]; char sprintf_buffer2[whatever]; sprintf (sprintf_buffer1, "%d", myInteger1); myargv[1] = sprintf_buffer1; sprintf (sprintf_buffer2, "%d", myInteger2); myargv[2] = sprintf_buffer2;
