[site]: stackoverflow
[post_id]: 166116
[parent_id]: 166113
[tags]: 
Normally it returns a copy of the returned vector . However this highly depends on the optimization done by the compiler. See the following discussion. Debug Build vector Foo(){ 004118D0 push ebp 004118D1 mov ebp,esp 004118D3 push 0FFFFFFFFh 004118D5 push offset __ehhandler$?Foo@@YA?AV?$vector@HV?$allocator@H@std@@@std@@XZ (419207h) 004118DA mov eax,dword ptr fs:[00000000h] 004118E0 push eax 004118E1 sub esp,0F4h 004118E7 push ebx 004118E8 push esi 004118E9 push edi 004118EA lea edi,[ebp-100h] 004118F0 mov ecx,3Dh 004118F5 mov eax,0CCCCCCCCh 004118FA rep stos dword ptr es:[edi] 004118FC mov eax,dword ptr [___security_cookie (41E098h)] 00411901 xor eax,ebp 00411903 push eax 00411904 lea eax,[ebp-0Ch] 00411907 mov dword ptr fs:[00000000h],eax 0041190D mov dword ptr [ebp-0F0h],0 vector result; 00411917 lea ecx,[ebp-24h] 0041191A call std::vector >::vector > (411050h) 0041191F mov dword ptr [ebp-4],1 result.push_back(1); 00411926 mov dword ptr [ebp-0FCh],1 00411930 lea eax,[ebp-0FCh] 00411936 push eax 00411937 lea ecx,[ebp-24h] 0041193A call std::vector >::push_back (41144Ch) return result; 0041193F lea eax,[ebp-24h] 00411942 push eax 00411943 mov ecx,dword ptr [ebp+8] 00411946 call std::vector >::vector > (41104Bh) 0041194B mov ecx,dword ptr [ebp-0F0h] 00411951 or ecx,1 00411954 mov dword ptr [ebp-0F0h],ecx 0041195A mov byte ptr [ebp-4],0 0041195E lea ecx,[ebp-24h] 00411961 call std::vector >::~vector > (411415h) 00411966 mov eax,dword ptr [ebp+8] } Here we can see that for vector result; a new object is created on the stack at [ebp-24h] 00411917 lea ecx,[ebp-24h] 0041191A call std::vector >::vector > (411050h) When we get to return result; a new copy is created in storage allocated by the caller at [ebp+8] 00411943 mov ecx,dword ptr [ebp+8] 00411946 call std::vector >::vector > (41104Bh) And the destructor is called for the local parameter vector result at [ebp-24h] 0041195E lea ecx,[ebp-24h] 00411961 call std::vector >::~vector > (411415h) Release Build vector Foo(){ 00401110 push 0FFFFFFFFh 00401112 push offset __ehhandler$?Foo@@YA?AV?$vector@HV?$allocator@H@std@@@std@@XZ (401F89h) 00401117 mov eax,dword ptr fs:[00000000h] 0040111D push eax 0040111E sub esp,14h 00401121 push esi 00401122 mov eax,dword ptr [___security_cookie (403018h)] 00401127 xor eax,esp 00401129 push eax 0040112A lea eax,[esp+1Ch] 0040112E mov dword ptr fs:[00000000h],eax 00401134 mov esi,dword ptr [esp+2Ch] 00401138 xor eax,eax 0040113A mov dword ptr [esp+8],eax vector result; 0040113E mov dword ptr [esi+4],eax 00401141 mov dword ptr [esi+8],eax 00401144 mov dword ptr [esi+0Ch],eax result.push_back(1); return result; 00401147 push eax 00401148 mov dword ptr [esp+28h],eax 0040114C mov ecx,1 00401151 push esi 00401152 lea eax,[esp+14h] 00401156 mov dword ptr [esp+10h],ecx 0040115A mov dword ptr [esp+14h],ecx 0040115E push eax 0040115F lea ecx,[esp+1Ch] 00401163 push ecx 00401164 mov eax,esi 00401166 call std::vector >::insert (401200h) 0040116B mov eax,esi } 0040116D mov ecx,dword ptr [esp+1Ch] 00401171 mov dword ptr fs:[0],ecx 00401178 pop ecx 00401179 pop esi 0040117A add esp,20h 0040117D ret The line vector result does not call the vector allocator because it is done at call site in Bar . The optimization makes no copy of the result from Foo.
