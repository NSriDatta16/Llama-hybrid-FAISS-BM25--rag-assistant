[site]: stackoverflow
[post_id]: 4258300
[parent_id]: 4258218
[tags]: 
I'd use a properly normalized database schema, your Buildings table is not useful like this. After splitting it up I believe that getting your answer will be pretty easy. Edit (and updated): Here's a CTE which will take this strange table structure and split it into a more normalized form, displaying the user id, building name, move in and move out dates. By grouping on the ones you want (and using DATEPART() etc.) you should be able to get the data you need with that. WITH User_Stays AS ( SELECT ID_U, Building_A Building, Move_in_Date_Building_A Move_In, COALESCE(Move_out_Date_Building_A, CASE WHEN ((Move_in_Date_Building_B IS NULL) OR (Move_in_Date_Building_C Move_in_Date_Building_A) THEN Move_in_Date_Building_C WHEN Move_in_Date_Building_B>=Move_in_Date_Building_A THEN Move_in_Date_Building_B END, GETDATE()) Move_Out FROM dbo.Buildings WHERE Move_in_Date_Building_A IS NOT NULL UNION ALL SELECT ID_U, Building_B, Move_in_Date_Building_B, COALESCE(Move_out_Date_Building_B, CASE WHEN ((Move_in_Date_Building_A IS NULL) OR (Move_in_Date_Building_C Move_in_Date_Building_B) THEN Move_in_Date_Building_C WHEN Move_in_Date_Building_A>=Move_in_Date_Building_B THEN Move_in_Date_Building_A END, GETDATE()) FROM dbo.Buildings WHERE Move_in_Date_Building_B IS NOT NULL UNION ALL SELECT ID_U, Building_C, Move_in_Date_Building_C, COALESCE(Move_out_Date_Building_C, CASE WHEN ((Move_in_Date_Building_B IS NULL) OR (Move_in_Date_Building_A Move_in_Date_Building_C) THEN Move_in_Date_Building_A WHEN Move_in_Date_Building_B>=Move_in_Date_Building_C THEN Move_in_Date_Building_B END, GETDATE()) FROM dbo.Buildings WHERE Move_in_Date_Building_C IS NOT NULL ) SELECT * FROM User_Stays ORDER BY ID_U, Move_In This query run on your sample data produces he following output: ID_U Building Move_In Move_Out -------- ----------- ----------------------- ----------------------- A1398 Kalgan 2010-10-06 00:00:00.000 2010-11-23 18:35:59.050 A2938 Kalgan 2010-09-12 00:00:00.000 2010-11-03 00:00:00.000 A2938 Rufus 2010-11-03 00:00:00.000 2010-11-15 00:00:00.000 A2938 Waylon 2010-11-15 00:00:00.000 2010-11-23 18:35:59.050 (4 row(s) affected) As you can see, from here on it will be much easier to isolate the days per patient or building, and also to find the records for specific months and calculate the correct stay duration in that case. Note that the CTE displays the current date for patients which are still in a building. Edit (again): In order to get all months including their start and end dates for all relevant years, you can use a CTE like this: WITH User_Stays AS ( [...see above...] ) , Months AS ( SELECT m.IX, y.[Year], dateadd(month,(12*y.[Year])-22801+m.ix,0) StartDate, dateadd(second, -1, dateadd(month,(12*y.[Year])-22800+m.ix,0)) EndDate FROM ( SELECT 1 IX UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9 UNION ALL SELECT 10 UNION ALL SELECT 11 UNION ALL SELECT 12 ) m CROSS JOIN ( SELECT Datepart(YEAR, us.Move_In) [Year] FROM User_Stays us UNION SELECT Datepart(YEAR, us.Move_Out) FROM User_Stays us ) y ) SELECT * FROM months; So since we now have a tabular representation of all date ranges which can be of interest, we simply join this together: WITH User_Stays AS ([...]), Months AS ([...]) SELECT m.[Year], DATENAME(MONTH, m.StartDate) [Month], us.ID_U, us.Building, DATEDIFF(DAY, CASE WHEN us.Move_In>m.StartDate THEN us.Move_In ELSE m.StartDate END, CASE WHEN us.Move_Out = m.StartDate) ORDER BY m.[Year], us.ID_U, m.Ix, us.Move_In Which finally produces this output: Year Month ID_U Building Days ----------- ------------ -------- ---------- ----------- 2010 October A1398 Kalgan 25 2010 November A1398 Kalgan 22 2010 September A2938 Kalgan 18 2010 October A2938 Kalgan 30 2010 November A2938 Kalgan 2 2010 November A2938 Rufus 12 2010 November A2938 Waylon 8
