[site]: stackoverflow
[post_id]: 2142719
[parent_id]: 2142566
[tags]: 
There are lots of way to do this, we would need a lot more information to be more specific about what would be best for you. However, here are the two SOP ways: Either a separate table for each matrix: CREATE TABLE YourMatrixName( RowNo smallint NOT NULL, ColNo smallint NOT NULL, CellValue varchar](50) NULL, CONSTRAINT [PK_Matrices] PRIMARY KEY CLUSTERED ([RowNo] ASC, [ColNo] ASC) ) ON [PRIMARY]; GO CREATE UNIQUE NONCLUSTERED INDEX IX_YourMatrixName ON dbo.YourMatrixName (ColNo, RowNo); GO Or, all of the matrices in one table: CREATE TABLE Matrices( MatrixName varchar(24) NOT NULL, RowNo smallint NOT NULL, ColNo smallint NOT NULL, CellValue varchar(50) NULL, CONSTRAINT [PK_Matrices] PRIMARY KEY CLUSTERED ([MatrixName] ASC, [RowNo] ASC, [ColNo] ASC) ) ON [PRIMARY]; GO CREATE UNIQUE NONCLUSTERED INDEX IX_Matrices ON dbo.Matrices (ColNo, RowNo); GO These are standard normal form, virtually all other ways of doing it are not well normalized. Some advantages of these approaches: You do not have to fill in every cell, only the ones you are using. Or have a default value (0 or "") and skip those. This is easily the most flexible approach, even in the "all in one" model, there is no need to restrict them to the same size in any way, and it is very easy to resize them. You can easily query the contents of the matrix, something that is increasingly difficult in more compact storage methods. "Hit"s or any other aspect of the matrix cells are easy to implement as additional fields in the rows. Make them Null-able if you're worried about the additional space, and index them if you want to query/report on these attributes separately. Its also just as easy to retrofit features like this with this model also. The primary disadvantage is that there is typically a high space to data overhead. Many assume that there is also high overhead to Insert or retrieve new matrices but in fact there are several documented techniques that can make it quite fast.
