[site]: stackoverflow
[post_id]: 1918534
[parent_id]: 1918456
[tags]: 
Build your own b-tree in RAM. Memory use: (4 bytes) comparison hash value (4 bytes) index of next leaf if hash (4 bytes) index of next leaf if hash > comparison OR if negative index of value 12 bytes per b-tree node for the b-tree. More overhead for the values (see below). How you structure this in Python - aren't there "native arrays" of 32bit integers upported with almost no extra memory overhead...? what are they called... anyway those. Separate ordered array of subarrays each containing one or more values. The "indexes of value" above are indexes into this big array, allowing retrieval of all values matching the hash. This assumes a 32bit hash. You will need more bytes per b-tree node if you have greater than 2^31-1 entries or a larger hash. BUT Spanner in the works perhaps: Note that you will not be able, if you are not storing the key values, to verify that a hash value looked up corresponds only to your key unless through some algorithmic or organisational mechanism you have guaranteed that no two keys will have the same hash. Quite a serious issue here. Have you considered it? :)
