[site]: stackoverflow
[post_id]: 1740756
[parent_id]: 1740277
[tags]: 
Regarding point 1 , the hash_password() function is used both to generate the password hash (against the salt and including the salt) that is stored in the database (e.g. at signup-time), as well as to recreate that hash when the password needs to be verified (e.g. at login-time). The hash_password() function will encode any salt that is given (or uniqid() if none is given) in the password-hash itself; that's a form of encryption where the salt_pattern is the key; if the salt_pattern can be kept secret, then that provides additional security since an adversary will not be able to do offline brute-forcing of the hash since the method of hashing is not reproducible ( if the salt_pattern can be kept secret): // Signup time; forget about uniqid(); you can use any salt that // you please; once the password hash is stored in the database there // is no need to know where your salt came from since it will be // included in the password hash. $password_hash = hash_password($password, FALSE); // Login time; note that the salt is taken from the password hash itself. $reproduced = hash_password($password, find_salt($password_hash)); $verifies = $password_hash == $reproduced; The hash_password() function will first hash the password against the salt, and then insert each char of the salt into the password hash at the corresponding salt_pattern offset. find_salt() will extract these salt chars so that the hash can be reproduced. You can see it as hash_password() encrypting the salt and find_salt() decrypting it. Although you can also see it has hash_password() hiding the salt and find_salt() finding it, this method of encryption can't be called steganography , I think, because it is clear from the code that there is a salt stored with the password hash (the existence of the salt is not secret). Regarding point 2 , using your own salt is straightforward and fully compatible with the Auth module and an already existing database. Regarding point 3 , using a per user salt ( uniqid() by default) is not overkill. Especially with MD5 which is broken for security purposes and where finding collisions is already practical with today's technology. Even better would be to use bcrypt() which uses a purposefully slower hashing algorithm to thwart brute-forcing attempts. Regarding point 4 , I haven't used the Kohana framework before, but reproducing or porting the Auth module is straightforward. Care must be taken that the salt_pattern is not forgotten or lost since it is an essential part of the hashing algorithm. The salt_pattern should also be kept secret since it is the only thing that keeps a determined adversary from brute-forcing the password hashes. uniqid() is just a reasonable default and can be replaced with whatever you want (as long as it is per-user and not a constant site-wide value.) Also, there is a very good answer here on stackoverflow regarding portable bcrypt() and PHP . Naturally that will not be compatible with the Auth module, but I'd like to mention it anyway since it's just best practice to use a slow hash and not to rely on secrets that are difficult to keep, like the salt_patten .
