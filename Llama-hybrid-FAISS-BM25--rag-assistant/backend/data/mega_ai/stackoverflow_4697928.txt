[site]: stackoverflow
[post_id]: 4697928
[parent_id]: 4697371
[tags]: 
The exact operations used should determine what is used. However, since the container is largely an abstract type, write it so it works -- reliably -- then profile, ensure functional requirements, optimize as needed, blah blah :) Normally, my main use for a "concurrent collection" is a Queue that is used to transfer objects between threads. In this case I start with ConcurrentLinkedQueue if for no other reason than liking the "lock-free" algorithm (this doesn't mean it will be faster though :-). Generally a Queue and/or LinkedList is a good data-structure to append to the end. Depending upon the circumstances including specific usage patterns including: thread contention, number of items removed, how items are removed, etc , a "fast-kill" of all but the start/end might be accomplished faster with a clear (part of AbstractQueue) and item re-addition -- ConcurrentLinkedQueue allows both head and tail inspection/manipulation. However, I would urge "keeping it simpler", writing to a "specific interface contract" and "just use the current approach" until there is strong evidence that a functional-requirement is not met. As far as the performance, it really depends upon the particular use-case/operations data-structure characteristics and data-structure implementation. ArrayList may very will be slower than Vector in some cases, and is indeed documented to be. If this performance makes the difference though, something sounds fishy. The article at Java Best Practices â€“ Vector vs ArrayList vs HashSet contains a nice read. Pay attention to the comments as well. Edit: Remember that a "concurrent" data-structure generally only implies that a single operation (method call) is atomic (and perhaps not all operations in odd cases!). It may still be required to implement a large-scoped synchronization or other approach to achieve the required level of thread-safety. That is, a h.putIfAbsent(k,v) (from ConcurrentHashMap) is not the same as a if (!h.containsKey(k)) { h.put(k, v); } -- as a case-in-point, an issue like this applies to the "clear then add" approach mentioned above. Happy coding.
