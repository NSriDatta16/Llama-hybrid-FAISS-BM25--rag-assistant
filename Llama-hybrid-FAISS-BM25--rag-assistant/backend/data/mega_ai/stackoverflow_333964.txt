[site]: stackoverflow
[post_id]: 333964
[parent_id]: 333889
[tags]: 
C++ compilation A compilation in C++ is done in 2 major phases: The first is the compilation of "source" text files into binary "object" files: The CPP file is the compiled file and is compiled without any knowledge about the other CPP files (or even libraries), unless fed to it through raw declaration or header inclusion. The CPP file is usually compiled into a .OBJ or a .O "object" file. The second is the linking together of all the "object" files, and thus, the creation of the final binary file (either a library or an executable). Where does the HPP fit in all this process? A poor lonesome CPP file... The compilation of each CPP file is independent from all other CPP files, which means that if A.CPP needs a symbol defined in B.CPP, like: // A.CPP void doSomething() { doSomethingElse(); // Defined in B.CPP } // B.CPP void doSomethingElse() { // Etc. } It won't compile because A.CPP has no way to know "doSomethingElse" exists... Unless there is a declaration in A.CPP, like: // A.CPP void doSomethingElse() ; // From B.CPP void doSomething() { doSomethingElse() ; // Defined in B.CPP } Then, if you have C.CPP which uses the same symbol, you then copy/paste the declaration... COPY/PASTE ALERT! Yes, there is a problem. Copy/pastes are dangerous, and difficult to maintain. Which means that it would be cool if we had some way to NOT copy/paste, and still declare the symbol... How can we do it? By the include of some text file, which is commonly suffixed by .h, .hxx, .h++ or, my preferred for C++ files, .hpp: // B.HPP (here, we decided to declare every symbol defined in B.CPP) void doSomethingElse() ; // A.CPP #include "B.HPP" void doSomething() { doSomethingElse() ; // Defined in B.CPP } // B.CPP #include "B.HPP" void doSomethingElse() { // Etc. } // C.CPP #include "B.HPP" void doSomethingAgain() { doSomethingElse() ; // Defined in B.CPP } How does include work? Including a file will, in essence, parse and then copy-paste its content in the CPP file. For example, in the following code, with the A.HPP header: // A.HPP void someFunction(); void someOtherFunction(); ... the source B.CPP: // B.CPP #include "A.HPP" void doSomething() { // Etc. } ... will become after inclusion: // B.CPP void someFunction(); void someOtherFunction(); void doSomething() { // Etc. } One small thing - why include B.HPP in B.CPP? In the current case, this is not needed, and B.HPP has the doSomethingElse function declaration, and B.CPP has the doSomethingElse function definition (which is, by itself a declaration). But in a more general case, where B.HPP is used for declarations (and inline code), there could be no corresponding definition (for example, enums, plain structs, etc.), so the include could be needed if B.CPP uses those declaration from B.HPP. All in all, it is "good taste" for a source to include by default its header. Conclusion The header file is thus necessary, because the C++ compiler is unable to search for symbol declarations alone, and thus, you must help it by including those declarations. One last word: You should put header guards around the content of your HPP files, to be sure multiple inclusions won't break anything, but all in all, I believe the main reason for existence of HPP files is explained above. #ifndef B_HPP_ #define B_HPP_ // The declarations in the B.hpp file #endif // B_HPP_ or even simpler (although not standard) #pragma once // The declarations in the B.hpp file
