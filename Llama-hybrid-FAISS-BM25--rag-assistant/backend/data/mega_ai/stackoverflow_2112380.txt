[site]: stackoverflow
[post_id]: 2112380
[parent_id]: 2112026
[tags]: 
There are varios user interaction patterns that you can use, depending on the application domain, working style and preferences of your users. In my experience, some people prefer to be free to enter data anywhere on screen without any validation or check mechanism locking them, and having these occur only when they finally hit "Enter" or "Save". In this model, status messages signalling potential issues with just entered information are helpful (e.g. "End date cannot be after start date."), but they must be only informational and never modal. This approach allows for a very fluid interaction and long "dialogue times" with the machine. Alternatively, you can use a "act & lock" approach like the one you describe, where the system prevents all further interaction after each action that the user carries out. This is useful if there is a clear sequence of actions to be performed (not like filling in a form, where you can start anywhere), if they take a relative long time (longer than typing a few characters in a textbox!), and if the dependencies between one action and the next are crucial (i.e. one action cannot be performed if the previous one has not been validated). In this case, the "act & lock" pattern is advisable. It is robust and potentially decreases mistake rates if well implemented. In modern GUIs where multi-thread support is easy to afford, you can just lock the window where the actions are being carried out; alternatively, you can lock the entire application. It is not as elegant but usually easier to develop. In any case, an information message is necessary, and a progress bar of some kind is highly advisable. Edit. On imlpementation issues, I would create a ModalInteractor class in my presentation (GUI) layer and instantiate an object of this class whenever I want to begin a new modal interaction with the user. This class has the following resposibility areas: (a) locking and unlocking the relevant user interface elements, (b) signalling progress and (c) cancellation management. You can easily work out what properties methods you'll need for each of these areas. Semantically, ModalInteractor is part of the logic that manages or drives your GUI (a "controller", some would say). Whenever the user clicks on the button that initiates the lengthy process, create a new ModalInteractor object and pass a reference to the current window in the constructor. Configure the object with a few delegates so that it knows what method to invoke to begin the lengthy process, what methods in the window to call for progress notification, and what event to respond to when the user clicks Cancel . Hope this helps.
