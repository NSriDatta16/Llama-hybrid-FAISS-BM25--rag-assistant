[site]: stackoverflow
[post_id]: 4672850
[parent_id]: 
[tags]: 
Spotlight not working

I'm trying to get a spotlight working but it's not showing up could someone have a look and see where I've went wrong? package water3; import Common.TextureReader; import com.sun.opengl.util.BufferUtil; import java.io.IOException; import javax.media.opengl.glu.GLUquadric; import javax.media.opengl.GL; import javax.media.opengl.GLAutoDrawable; import javax.media.opengl.GLEventListener; import java.nio.FloatBuffer; import java.nio.IntBuffer; import javax.media.opengl.glu.GLU; class Renderer implements GLEventListener { private GLUquadric quadric; private Object3D object3D; private float[] LightPos = {0.0f, 5.0f, -4.0f, 1.0f}; // Light Position private boolean LightUp, LightDown, LightLeft, LightRight, LightForward, LightBackward; private int[] textures = new int[3]; // Storage For 3 Textures double aNum = 1; private boolean aDown =false; private boolean up =false; private GLU glu = new GLU(); public void init(GLAutoDrawable drawable) { GL gl = drawable.getGL(); try { loadGLTextures(drawable); } catch (IOException e) { System.out.println("Couldn't load model/Texture"); throw new RuntimeException(e); } /* gl.glShadeModel(GL.GL_SMOOTH); // Enable Smooth Shading gl.glClearColor(0.0f, 0.0f, 0.0f, 0.5f); // Black Background gl.glClearDepth(1.0f); // Depth Buffer Setup gl.glClearStencil(0); // Stencil Buffer Setup gl.glEnable(GL.GL_DEPTH_TEST); // Enables Depth Testing gl.glDepthFunc(GL.GL_LEQUAL); // The Type Of Depth Testing To Do gl.glHint(GL.GL_PERSPECTIVE_CORRECTION_HINT, GL.GL_NICEST); // Really Nice Perspective Calculations /* gl.glLightfv(GL.GL_LIGHT1, GL.GL_POSITION, LightPos, 0); // Set Light1 Position gl.glLightfv(GL.GL_LIGHT1, GL.GL_AMBIENT, LightAmb, 0); // Set Light1 Ambience gl.glLightfv(GL.GL_LIGHT1, GL.GL_DIFFUSE, LightDif, 0); // Set Light1 Diffuse gl.glLightfv(GL.GL_LIGHT1, GL.GL_SPECULAR, LightSpc, 0); // Set Light1 Specular gl.glEnable(GL.GL_LIGHT1); */// Enable Light1 // Enable Lighting /* gl.glMaterialfv(GL.GL_FRONT, GL.GL_AMBIENT, MatAmb, 0); // Set Material Ambience gl.glMaterialfv(GL.GL_FRONT, GL.GL_DIFFUSE, MatDif, 0); // Set Material Diffuse gl.glMaterialfv(GL.GL_FRONT, GL.GL_SPECULAR, MatSpc, 0); // Set Material Specular gl.glMaterialfv(GL.GL_FRONT, GL.GL_SHININESS, MatShn, 0); // Set Material Shininess */ gl.glClearColor(0,0,0,1); gl.glEnable(GL.GL_LIGHT0); gl.glEnable(GL.GL_DEPTH_TEST); gl.glShadeModel(GL.GL_SMOOTH); gl.glLightModeli(GL.GL_LIGHT_MODEL_TWO_SIDE, GL.GL_TRUE); gl.glCullFace(GL.GL_BACK); // Set Culling Face To Back Face gl.glEnable(GL.GL_CULL_FACE); // Enable Culling gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Set Clear Color (Greenish Color) quadric = glu.gluNewQuadric(); // Initialize Quadratic glu.gluQuadricNormals(quadric, GL.GL_SMOOTH); // Enable Smooth Normal Generation glu.gluQuadricTexture(quadric, false); } public void display(GLAutoDrawable drawable) { GL gl = drawable.getGL(); // Clear Color Buffer, Depth Buffer, Stencil Buffer gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT | GL.GL_STENCIL_BUFFER_BIT); gl.glLoadIdentity(); SetSpotlight(gl); SetFloorMaterial(gl); gl.glPushMatrix(); // Reset Modelview Matrix gl.glTranslatef(0.0f, 0.0f, -20.0f); // Zoom Into The Screen 20 Units gl.glEnable(GL.GL_TEXTURE_2D); // Enable Texture Mapping ( NEW ) drawRoom(gl); // Draw The Room gl.glPopMatrix(); gl.glFlush(); // Flush The OpenGL Pipeline } private void drawRoom(GL gl) { // Draw The Room (Box) gl.glBegin(GL.GL_QUADS); // Begin Drawing Quads // Floor gl.glNormal3f(0.0f, 1.0f, 0.0f); // Normal Pointing Up gl.glVertex3f(-20.0f, -20.0f, -40.0f); // Back Left gl.glVertex3f(-20.0f, -20.0f, 40.0f); // Front Left gl.glVertex3f(20.0f, -20.0f, 40.0f); // Front Right gl.glVertex3f(20.0f, -20.0f, -40.0f); // Back Right // Ceiling gl.glNormal3f(0.0f, -1.0f, 0.0f); // Normal Point Down gl.glVertex3f(-10.0f, 10.0f, 20.0f); // Front Left gl.glVertex3f(-10.0f, 10.0f, -20.0f); // Back Left gl.glVertex3f(10.0f, 10.0f, -20.0f); // Back Right gl.glVertex3f(10.0f, 10.0f, 20.0f); // Front Right // Back Wall gl.glNormal3f(0.0f, 0.0f, -1.0f); // Normal Pointing Towards Viewer gl.glVertex3f(20.0f, 20.0f, 30.0f); // Top Right gl.glVertex3f(20.0f, -20.0f, 30.0f); // Bottom Right gl.glVertex3f(-20.0f, -20.0f, 30.0f); // Bottom Left gl.glVertex3f(-20.0f, 20.0f, 30.0f); // Top Left // Left Wall gl.glNormal3f(1.0f, 0.0f, 0.0f); // Normal Pointing Right gl.glVertex3f(-20.0f, 20.0f, 30.0f); // Top Front gl.glVertex3f(-20.0f, -20.0f, 30.0f); // Bottom Front gl.glVertex3f(-20.0f, -20.0f, -30.0f); // Bottom Back gl.glVertex3f(-20.0f, 20.0f, -30.0f); // Top Back // Right Wall gl.glNormal3f(-1.0f, 0.0f, 0.0f); // Normal Pointing Left gl.glVertex3f(20.0f, 20.0f, -30.0f); // Top Back gl.glVertex3f(20.0f, -20.0f, -30.0f); // Bottom Back gl.glVertex3f(20.0f, -20.0f, 30.0f); // Bottom Front gl.glVertex3f(20.0f, 20.0f, 30.0f); // Top Front gl.glPushMatrix(); // Front Wall gl.glNormal3f(0.0f, 0.0f, 1.0f); // Normal Pointing Away From Viewer gl.glTexCoord2f(1,1); gl.glVertex3f(-20.0f, 20.0f, -30.0f); // Top Left gl.glTexCoord2f(1,0); gl.glVertex3f(-20.0f, -20.0f, -30.0f); // Bottom Left gl.glTexCoord2f(0,0); gl.glVertex3f(20.0f, -20.0f, -30.0f); // Bottom Right gl.glTexCoord2f(0,1); gl.glVertex3f(20.0f, 20.0f, -30.0f); // Top Right gl.glPopMatrix(); gl.glEnd(); // Done Drawing Quads } public void reshape(GLAutoDrawable drawable,int xstart,int ystart,int width,int height) { GL gl = drawable.getGL(); height = (height == 0) ? 1 : height; gl.glViewport(0, 0, width, height); gl.glMatrixMode(GL.GL_PROJECTION); gl.glLoadIdentity(); gl.glRotatef(90, 0.0f, 0.0f, 1.0f); glu.gluPerspective(60, (float) width / height, 1, 1000); glu.gluLookAt(1.0f,0.0f,25.0f, 0.0f,0.0f,0.0f, 0.0f,0.0f,1.0f); gl.glMatrixMode(GL.GL_MODELVIEW); gl.glLoadIdentity(); } public void displayChanged(GLAutoDrawable drawable, boolean modeChanged,boolean deviceChanged) { } private void loadGLTextures(GLAutoDrawable gldrawable) throws IOException { TextureReader.Texture texture = null; texture = TextureReader.readTexture("data/images/04.bmp"); GL gl = gldrawable.getGL(); //Create Nearest Filtered Texture gl.glGenTextures(1, textures, 0); gl.glBindTexture(GL.GL_TEXTURE_2D, textures[0]); gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR); gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR); gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, 3, texture.getWidth(), texture.getHeight(), 0, GL.GL_RGB, GL.GL_UNSIGNED_BYTE, texture.getPixels()); } public void SetSpotlight(GL gl){ gl.glDisable(GL.GL_LIGHTING); // prepare spotlight float spot_ambient[] = {50.2f,0.0f,0.0f,1.0f };//white ={10.2f,10.2f,10.2f,1.0f }; float spot_diffuse[] = {50.8f,0.0f,0.0f,1.0f }; float spot_specular[] = {50.8f,0.0f,0.0f,1.0f }; // set colors here and do the geometry in draw gl.glLightfv(GL.GL_LIGHT0, GL.GL_AMBIENT, spot_ambient,0); gl.glLightfv(GL.GL_LIGHT0, GL.GL_DIFFUSE, spot_diffuse,0); gl.glLightfv(GL.GL_LIGHT0, GL.GL_SPECULAR, spot_specular,0); gl.glEnable(GL.GL_LIGHTING); gl.glEnable(GL.GL_LIGHT0); // set light position // since ligth follows the model when mousing // spotlight as it moves with the scene float spot_position[] = {0.0f,60.0f,-30.0f,1.0f}; float spot_direction[] = {0.0f,0.0f,-1.0f}; float spot_angle = 10.0f; gl.glLightfv(GL.GL_LIGHT0, GL.GL_POSITION, spot_position,0); gl.glLightfv(GL.GL_LIGHT0, GL.GL_SPOT_DIRECTION,spot_direction,0); gl.glLightf(GL.GL_LIGHT0, GL.GL_SPOT_CUTOFF,(float)spot_angle); // "smoothing" the border of the lightcone // change this for effect gl.glMaterialfv(GL.GL_FRONT, GL.GL_AMBIENT_AND_DIFFUSE, new float[] {0.7f,0.7f,1}, 0 ); gl.glLighti(GL.GL_LIGHT0, GL.GL_SPOT_EXPONENT, 20); gl.glEnable(GL.GL_LIGHTING); } public void SetFloorMaterial(GL gl){ float amb[]={0.3f,0.3f,0.0f,1.0f}; float diff[]={1.0f,1.0f,0.5f,1.0f}; float spec[]={0.6f,0.6f,0.5f,1.0f}; float shine=0.25f; gl.glMaterialfv(GL.GL_FRONT,GL.GL_AMBIENT,amb,0); gl.glMaterialfv(GL.GL_FRONT,GL.GL_DIFFUSE,diff,0); gl.glMaterialfv(GL.GL_FRONT,GL.GL_SPECULAR,spec,0); gl.glMaterialf(GL.GL_FRONT,GL.GL_SHININESS,shine*128.0f); } }
