[site]: stackoverflow
[post_id]: 641075
[parent_id]: 640004
[tags]: 
What you are proposing with your query class is that you still embed SQL directly in the application code. What you get with the LINQ + ORM solution is that the application code never contains SQL. You still have a mismatch and a distraction from working on the code. You mention it in your post: We can test it out in a SQL window and then just cut and paste into our code, breaking it up as appropriate to enter our parameters. It couldn't be easier. What the LINQ syntax is trying to give us is queries as first class citizens in the code. Yep some stuff is clumsy, some stuff might not be quite right yet, but the stated goal of LINQ is to integrate query and application code to the point where there isn't a disjoint. It sounds like that isn't what you are after, so maybe embedding SQL as string literals that are opaque to the compiler and runtime will work better for you. We know it can be made to work, we've done it for years. The other benefit is that the LINQ statement will not be subject to vendor specific variations (that's the LINQ provider's problem). You could end up with the SQL string that you pass to qry.Command() being tied to a particular database.
