[site]: stackoverflow
[post_id]: 1376872
[parent_id]: 
[tags]: 
C - Pthreads mutex and general headaches

Hey guys I was wondering if someone could provide a little help. I've been trying to teach myself pthreads and with that, mutex locks to get threads running together and using the same structure, whilst not reading and writing to bad data. My problem at the moment is, From my thread function, if i call a helper function that might look something similar to the following: void foo(void *arg) { Bar *bar = arg; pthread_mutex_lock(&mutex); bar->something = 1; pthread_mutex_unlock(&mutex); } This above helper method doesn't seem to "update" the structure. But if I run the same code in the thread function, the exact same 4 lines, than this seems to work. What am I doing wrong? Or how do I fix this? If anyone could provide some reading as well that would be perfect. EDIT: Sorry guys that was a typo in my code. Here is the actual code I'm using for the structure. typedef struct { char *buffer[CAR_PARK_SIZE]; char *arrival_time[CAR_PARK_SIZE]; int keep_running; int size; int index; } CarStorage; typedef struct { CarStorage parks; CarStorage queue; int busy; } CarPark; pthread_mutex_t mutex; void addCar(char *car, void *arg) { CarPark *_cp = arg; pthread_mutex_lock(&mutex); printf("Trying to increase size\n"); _cp->parks.size = _cp->parks.size+1; pthread_mutex_unlock(&mutex); } If the same lines in addCar are in the thread function, it will increase the size, if its in this helper function, it won't. Here is the calling code void *carpark_t(void *arg) { CarPark *_cp = arg; while (_cp->parks.keep_running) { if (_cp->queue.size > 0) { addCar(_cp->queue.buffer[_cp->queue.index % MAX_QUEUE], &_cp); sleep(1); } else { printf("[C] no cars in queue\n"); sleep(5); } } }
