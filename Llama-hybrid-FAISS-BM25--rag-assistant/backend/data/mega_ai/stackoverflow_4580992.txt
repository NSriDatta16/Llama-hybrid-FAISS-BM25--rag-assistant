[site]: stackoverflow
[post_id]: 4580992
[parent_id]: 
[tags]: 
STL find performs better than hand-crafted loop

I have some question. Given the following C++ code fragment: #include #include #include #include #include struct incrementor { incrementor() : curr_() {} unsigned int operator()() { return curr_++; } private: unsigned int curr_; }; template char const* value_found(Vec const& v, typename Vec::const_iterator i) { return i==v.end() ? "no" : "yes"; } template typename Vec::const_iterator find1(Vec const& v, typename Vec::value_type val) { return find(v.begin(), v.end(), val); } template typename Vec::const_iterator find2(Vec const& v, typename Vec::value_type val) { for(typename Vec::const_iterator i=v.begin(), end=v.end(); i ::const_iterator iter; vector vec; vec.reserve(10000000); boost::progress_timer pt; generate_n(back_inserter(vec), vec.capacity(), incrementor()); //added this line, to avoid any doubts, that compiler is able to // guess the data is sorted random_shuffle(vec.begin(), vec.end()); cout On my machine (Intel i7, Windows Vista) STL find (call via find1) runs about 10 times faster than the hand-crafted loop (call via find2). I first thought that Visual C++ performs some kind of vectorization (may be I am mistaken here), but as far as I can see assembly does not look the way it uses vectorization. Why is STL loop faster? Hand-crafted loop is identical to the loop from the STL-find body. I was asked to post program's output. Without shuffle: value generation required: 0.078 first search required: 0.008 first search found value: no second search required: 0.098 second search found value: no With shuffle (caching effects): value generation required: 1.454 first search required: 0.009 first search found value: no second search required: 0.044 second search found value: no Many thanks, dusha. P.S. I return the iterator and write out the result (found or not), because I would like to prevent compiler optimization, that it thinks the loop is not required at all. The searched value is obviously not in the vector. P.P.S. I was asked to post assembly generated for the find functions. Here it is: found=find1(vec, vec.capacity()); 001811D0 lea eax,[esp+5Ch] 001811D4 call std::vector >::capacity (1814D0h) 001811D9 mov esi,dword ptr [esp+60h] 001811DD mov ecx,dword ptr [esp+64h] 001811E1 cmp esi,ecx 001811E3 je wmain+180h (1811F0h) 001811E5 cmp dword ptr [esi],eax 001811E7 je wmain+180h (1811F0h) 001811E9 add esi,4 001811EC cmp esi,ecx 001811EE jne wmain+175h (1811E5h) found=find2(vec, vec.capacity()); 001812AE lea eax,[esp+5Ch] 001812B2 call std::vector >::capacity (1814D0h) 001812B7 mov ecx,dword ptr [esp+60h] 001812BB mov edx,dword ptr [esp+64h] 001812BF cmp ecx,edx 001812C1 je wmain+262h (1812D2h) 001812C3 cmp dword ptr [ecx],eax 001812C5 je wmain+34Fh (1813BFh) 001812CB add ecx,4 001812CE cmp ecx,edx 001812D0 jne wmain+253h (1812C3h) find2 uses ecx-register instead of esi. What is the difference between these two registers? Can it be that esi assumes the pointer to be properly aligned and therefore brings additional performance? Read some assembly reference ecx is just a counter, whereas esi is the memory source. So I think STL algorithm knows that Random Access Iterator is properly aligned and therefore uses memory pointers. Where in the non-STL version there is no speculation how the alignment is. Am I right?
