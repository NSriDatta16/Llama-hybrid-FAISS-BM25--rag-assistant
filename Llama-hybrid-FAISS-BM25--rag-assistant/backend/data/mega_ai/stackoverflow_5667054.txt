[site]: stackoverflow
[post_id]: 5667054
[parent_id]: 5132874
[tags]: 
It seems that you can’t change the elements of the cvseq object using the Python bindings (notice here that list of Python methods for manipulating cvseq objects only has methods for removing sequence elements and changing their order.) The Python bindings do nonetheless provide the tools to achieve your stated aim of rotating the contours in an image. Since the cv.DrawContours() method requires a cvseq as input, we have to find some other way of drawing contours after storing and manipulating them in Python. One way to do this is by using the cv.FillPoly() or cv.DrawPoly() methods (which take a list of lists of tuples as input) depending whether the thickness parameter that would have been passed to cv.DrawContours() is -1 or > 0 respectively. So, one way to find contours and draw their rotated counterparts, would be as follows (where the centre of mass of each contour is found by redrawing in filled form and using OpenCV’s moment functions): import cv import numpy as np # Draw contour from list of tuples. def draw_contour( im , contour , color , thickness = 1 , linetype = 8 , shift = 0 ) : if thickness == -1 : cv.FillPoly( im , [contour] , color , linetype , shift ) else : cv.PolyLine( im , [contour] , True , color , thickness , linetype , shift ) # Rotate contour around centre point using numpy. def rotate_contour( contour , centre_point , theta ) : rotation = np.array( [ [ np.cos( theta ) , -np.sin( theta ) ] , [ np.sin( theta ) , np.cos( theta ) ] ] ) centre = np.vstack( [ centre_point ] * len( contour ) ) contour = np.vstack( contour ) - centre contour = np.dot( contour , rotation ) + centre return [ tuple ( each_row ) for each_row in contour ] # Find centre of mass by drawing contour in closed form and using moments. def find_centre_of_mass( contour ) : bottom_right = np.max( contour , axis = 0 ) blank = cv.CreateImage( tuple ( bottom_right ) , 8 , 1 ) cv.Set( blank , 0 ) draw_contour( blank , contour , 1, -1 ) moments = cv.Moments( blank , 1 ) sM00 = float ( cv.GetSpatialMoment( moments , 0 , 0 ) ) sM01 = float ( cv.GetSpatialMoment( moments , 0 , 1 ) ) sM10 = float ( cv.GetSpatialMoment( moments , 1 , 0 ) ) return ( sM10 / sM00 , sM01 / sM00 ) THETA = np.pi / 3.0 COLOR = cv.CV_RGB( 200 , 200 , 200 ) input_image = cv.LoadImage( ‘filename.png’ , cv.CV_LOAD_IMAGE_GRAYSCALE ) output_image = cv.CreateImage( ( input_image.width , input_image.height ) , input_image.depth , input_image.nChannels ) cv.Set( output_image , 0 ) storage = cv.CreateMemStorage( 0 ) contour_pointer = cv.FindContours( input_image , storage , cv.CV_RETR_EXTERNAL , cv.CV_CHAIN_APPROX_SIMPLE ) while contour_pointer is not None : contour = contour_pointer [ : ] centre_of_mass = find_centre_of_mass( contour ) rotated_contour = rotate_contour( contour , centre_of_mass , THETA ) draw_contour( output_image , rotated_contour , COLOR , -1 ) contour_pointer = contour_pointer.h_next() cv.SaveImage( ‘outputfile.png’ , output_image)
