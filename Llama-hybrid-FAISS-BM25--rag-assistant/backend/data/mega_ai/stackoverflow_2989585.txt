[site]: stackoverflow
[post_id]: 2989585
[parent_id]: 2989560
[tags]: 
You can use Class#getDeclaredFields() to get all declared fields of the class. You can use Field#get() to get the value. In short: Object someObject = getItSomehow(); for (Field field : someObject.getClass().getDeclaredFields()) { field.setAccessible(true); // You might want to set modifier to public first. Object value = field.get(someObject); if (value != null) { System.out.println(field.getName() + "=" + value); } } To learn more about reflection, check the Oracle tutorial on the subject . That said, if that VO is a fullworthy Javabean, then the fields do not necessarily represent real properties of a VO. You would rather like to determine the public methods starting with get or is and then invoke it to grab the real property values. for (Method method : someObject.getClass().getDeclaredMethods()) { if (Modifier.isPublic(method.getModifiers()) && method.getParameterTypes().length == 0 && method.getReturnType() != void.class && (method.getName().startsWith("get") || method.getName().startsWith("is")) ) { Object value = method.invoke(someObject); if (value != null) { System.out.println(method.getName() + "=" + value); } } } That in turn said, there may be more elegant ways to solve your actual problem. If you elaborate a bit more about the functional requirement for which you think that this is the right solution, then we may be able to suggest the right solution. There are many, many tools available to massage javabeans. There's even a built-in one provided by Java SE in the java.beans package. BeanInfo beanInfo = Introspector.getBeanInfo(someObject.getClass()); for (PropertyDescriptor property : beanInfo.getPropertyDescriptors()) { Method getter = property.getReadMethod(); if (getter != null) { Object value = getter.invoke(someObject); if (value != null) { System.out.println(property.getName() + "=" + value); } } }
