[site]: stackoverflow
[post_id]: 4516302
[parent_id]: 2358575
[tags]: 
A bit easier solution would be to implement the ICloneable interface on the entity you would like to work like that. Then, all you need to do is call Clone() into 'original' entity you pulled from the DB. Example : class Product : ICloneable { public virtual int Id { get; private set; } public virtual string Name { get; set; } public object Clone() { return new Product() { Id=this.Id, Name=this.Name }; } } And then all you need to do is : Datacontext db = new Datacontext(); // replace with your DataContext Product originalProduct = db.Products.Single(p => p.Id == 2); // get product with Id 2 db.originalProduct = p.Clone() db.SubmitChanges(); Edit : I ran into the same problem at work, so far the most elegant solution I found was to build an extension method that recieves the newly created entity, in your case Product , and copies it's properties (except for the Identifier) to the entity you pulled from the DataContext. I copied all the properties via Reflection, this way, if I update the entity, then my extension method will still work. Hope this helps you too. If you find a more elegant solution to this problem, I would like to hear :)
