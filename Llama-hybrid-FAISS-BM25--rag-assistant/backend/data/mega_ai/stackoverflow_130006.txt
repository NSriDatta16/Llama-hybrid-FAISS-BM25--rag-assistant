[site]: stackoverflow
[post_id]: 130006
[parent_id]: 129877
[tags]: 
Update : Commenters have pointed out that memoization is a good way to optimize recursion. Admittedly, I hadn't considered this before, since I generally work in a language (C#) where generalized memoization isn't so trivial to build. Take the post below with that grain of salt in mind. I think Luke likely has the most appropriate solution to this problem, but memoization is not generally the solution to any issue of stack overflow. Stack overflow usually is caused by recursion going deeper than the platform can handle. Languages sometimes support " tail recursion ", which re-uses the context of the current call, rather than creating a new context for the recursive call. But a lot of mainstream languages/platforms don't support this. C# has no inherent support for tail-recursion, for example. The 64-bit version of the .NET JITter can apply it as an optimization at the IL level, which is all but useless if you need to support 32-bit platforms. If your language doesn't support tail recursion, your best option for avoiding stack overflows is either to convert to an explicit loop (much less elegant, but sometimes necessary), or find a non-iterative algorithm such as Luke provided for this problem.
