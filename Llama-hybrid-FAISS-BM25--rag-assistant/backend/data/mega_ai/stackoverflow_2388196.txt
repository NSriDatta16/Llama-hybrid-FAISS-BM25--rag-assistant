[site]: stackoverflow
[post_id]: 2388196
[parent_id]: 
[tags]: 
How to speed up my sparse matrix solver?

I'm writing a sparse matrix solver using the Gauss-Seidel method. By profiling, I've determined that about half of my program's time is spent inside the solver. The performance-critical part is as follows: size_t ic = d_ny + 1, iw = d_ny, ie = d_ny + 2, is = 1, in = 2 * d_ny + 1; for (size_t y = 1; y All arrays involved are of float type. Actually, they are not arrays but objects with an overloaded [] operator, which (I think) should be optimized away, but is defined as follows: inline float &operator[](size_t i) { return d_cells[i]; } inline float const &operator[](size_t i) const { return d_cells[i]; } For d_nx = d_ny = 128 , this can be run about 3500 times per second on an Intel i7 920. This means that the inner loop body runs 3500 * 128 * 128 = 57 million times per second. Since only some simple arithmetic is involved, that strikes me as a low number for a 2.66 GHz processor. Maybe it's not limited by CPU power, but by memory bandwidth? Well, one 128 * 128 float array eats 65 kB, so all 6 arrays should easily fit into the CPU's L3 cache (which is 8 MB). Assuming that nothing is cached in registers, I count 15 memory accesses in the inner loop body. On a 64-bits system this is 120 bytes per iteration, so 57 million * 120 bytes = 6.8 GB/s. The L3 cache runs at 2.66 GHz, so it's the same order of magnitude. My guess is that memory is indeed the bottleneck. To speed this up, I've attempted the following: Compile with g++ -O3 . (Well, I'd been doing this from the beginning.) Parallelizing over 4 cores using OpenMP pragmas. I have to change to the Jacobi algorithm to avoid reads from and writes to the same array. This requires that I do twice as many iterations, leading to a net result of about the same speed. Fiddling with implementation details of the loop body, such as using pointers instead of indices. No effect. What's the best approach to speed this guy up? Would it help to rewrite the inner body in assembly (I'd have to learn that first)? Should I run this on the GPU instead (which I know how to do, but it's such a hassle)? Any other bright ideas? (N.B. I do take "no" for an answer, as in: "it can't be done significantly faster, because...") Update : as requested, here's a full program: #include #include #include using namespace std; size_t d_nx = 128, d_ny = 128; float *d_x, *d_b, *d_w, *d_e, *d_s, *d_n; void step() { size_t ic = d_ny + 1, iw = d_ny, ie = d_ny + 2, is = 1, in = 2 * d_ny + 1; for (size_t y = 1; y I compile and run it as follows: $ g++ -o gstest -O3 gstest.cpp $ time ./gstest 8000 0 real 0m1.052s user 0m1.050s sys 0m0.010s (It does 8000 instead of 3500 iterations per second because my "real" program does a lot of other stuff too. But it's representative.) Update 2 : I've been told that unititialized values may not be representative because NaN and Inf values may slow things down. Now clearing the memory in the example code. It makes no difference for me in execution speed, though.
