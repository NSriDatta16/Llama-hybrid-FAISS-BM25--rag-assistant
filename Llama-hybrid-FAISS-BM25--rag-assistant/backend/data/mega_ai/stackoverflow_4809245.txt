[site]: stackoverflow
[post_id]: 4809245
[parent_id]: 4799472
[tags]: 
Whenever you do an orientation change, the app is reloaded entirely except for static properties. (read here : http://developer.android.com/reference/android/app/Activity.html ) This means that all the bitmap you allocated if they were not static will be reloaded. Since the memory allowed for one app is 16 MB(24 on some devices i hear) and that bitmap are stored in memory as raw bitmap(read not compressed) this create a spike in the memory usage that can lead to OOM Add to that the fact that the memory used for bitmaps are allocated outside of your heap memory but counted as if part of it so that you can't actually trace that problem even using ddms or MAT. Be sure to recycle all your bitmaps in your onDestroy method so that they can be garbage collected. The one thing that finally got me out of this one are these three lines of code(hack) : System.gc(); System.runFinalization(); System.gc(); Beware though, it impacts performance(about 500 to 750 ms) so it is not suitable for a game with FPS concern but for an app it is perfectly reasonable. Put them at the very beginning of your createScaledBitmap call. It worked for me Edit : Depending on what you are doing with the bitmap in question you can ask android to open it downsampled, taking less memory. I wrote this function while dealing with this problem. It tries to open the bitmap as big as possible : private Bitmap getDownsampledBitmapFromFile(String fileName, int sampleSize) { //Try to free up some memory System.gc(); System.runFinalization(); System.gc(); BitmapFactory.Options options=new BitmapFactory.Options();//reset object byte[] tempBuffer=new byte[8000]; options.inTempStorage = tempBuffer; options.inSampleSize=sampleSize; Bitmap downsampledBitmap = null; try { downsampledBitmap = BitmapFactory.decodeFile(fileNameToUpload, options); } catch (OutOfMemoryError e) { sampleSize ++; } return(downsampledBitmap); }
