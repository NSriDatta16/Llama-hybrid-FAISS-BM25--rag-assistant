[site]: stackoverflow
[post_id]: 2703888
[parent_id]: 2656704
[tags]: 
The approach may not be the most elegant one but it does work around the limits of multi bindings and the fact that ConverterParameter is not a DependencyProperty . Make your converter derive from FrameworkContentElement . Define a number of DependencyProperty proprerties. You will need as many of them as there are values that you need on both ends of conversion. Since your converter normally sits in XAML resources, DataContext and ElementName bindings won't work without some help from DataContextSpy and/or ElementSpy , depending on your particular binding needs. The oddity of this approach is that you will have two identical bindings, one in section of XAML and the other one in Resources where you define your converter. The former one is needed to trigger the MultiBinding while the latter one actually provides the value in ConvertBack direction. A downside is that resources are shared and thus if you need the same functional converter somewhere else on the page, you might need to declare a second one in your resources. This is only if two MultiBinding s need different parameters. If parameters are shared, you may as well use the same resource. You might also try x:Shared="False" on the converter resource but I am not sure if that would work.
