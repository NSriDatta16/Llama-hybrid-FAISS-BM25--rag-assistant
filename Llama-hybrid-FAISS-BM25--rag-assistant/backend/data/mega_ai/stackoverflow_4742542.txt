[site]: stackoverflow
[post_id]: 4742542
[parent_id]: 4729906
[tags]: 
This is a case of "Use after free() ". What happens is "undefined behavior". Your example is really no different than: char *stringPtr = NULL; stringPtr = malloc(1024); // Example code, assumes this returns non-NULL. strcpy(stringPtr, "Zippers!"); free(stringPtr); printf("Pants: %s\n", stringPtr); What happens at the printf line? Who knows. Anything from Pants: Zippers! to Pants: (...garbage...) Core Dump . All the Objective-C specific stuff is actually irrelevant- it's the fact that you're using a pointer to memory which is no longer valid is the only thing that matters. You're better off throwing darts at the wall than trying to explain "why" it's not crashing and printing static: static . For performance reasons, most malloc implementations don't bother "reaping" free() 'd allocations until they have to. IMHO, this is probably why your example isn't crashing in the way you were expecting it to. If you really want to see this particular program crash, you can do one of the following: Set the environment variable CFZombieLevel to 17 (scribble + don't free). Set the environment variable NSZombieEnabled to YES . Set the environment variable DYLD_INSERT_LIBRARIES to /usr/lib/libgmalloc.dylib (see man libgmalloc ).
