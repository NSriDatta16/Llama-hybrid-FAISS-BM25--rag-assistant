[site]: stackoverflow
[post_id]: 3444169
[parent_id]: 3443875
[tags]: 
A MailboxProcessor for enemy simulation might look like this: MailboxProcessor.Start(fun inbox -> async { while true do let! message = inbox.Receive() processMessage(message) }) It does not consume a thread while it waits for a message to arrive ( let! message = line). However, once message arrives it will consume a thread (on a thread pool). If you have a 100 mailbox processors that all receive a message simultaneously, they will all attempt to wake up and consume a thread. Since here message processing is CPU bound, 100s of mailbox processors will all wake up and start spawning (thread pool) threads. This is not a great performance. One situation mailbox processors excel in is the situation where there is a lot of concurrent clients all sending messages to one processor (imagine several parallel web crawlers all downloading pages and sinking results to a queue). On-screen enemies case appears different - it is many entities responding to a single source of messages (player movement/time ticks). Another example where thousands of MailboxProcessors is a great solution is I/O bound MailboxProcessor: MailboxProcessor.Start(fun inbox -> async { while true do let! message = inbox.Receive() match message with | -> do! AsyncWrite("something") let! response = AsyncResponse() ... }) Here after receiving a message the agent very quickly yields a thread but still needs to maintain state across asynchronous operations. This will scale very very well in practice - you can run thousands and thousands of such agents: this is a great way to write a web server.
