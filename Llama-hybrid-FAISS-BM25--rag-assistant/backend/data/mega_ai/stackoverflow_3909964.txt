[site]: stackoverflow
[post_id]: 3909964
[parent_id]: 
[tags]: 
Python Servers fighting each others with sockets

I try to make two servers in a file, but they are fighting each other visibly have anyone an idea to make them peace ? here is my code : # -*- coding: utf-8 -*- import socket import sys import re import base64 import binascii import time import zlib import sys import StringIO import contextlib import smtplib from threading import Thread """ Thanks to : People from irc : Flox,Luyt People from stack Overflow : Philippe Leybaert,Platinum Azure,methodin,Suresh Kumar,S.Lott,MatTheCat, kevpie,Ignacio Vazquez-Abrams,adamk,Frédéric Hamidi,THC4k,THC4k,Blam """ def sendmail(exp,dest,msg): server = dest.split("@")[1] s = smtplib.SMTP("localhost") s.sendmail(exp,dest,msg) @contextlib.contextmanager def stdoutIO(stdout=None): old = sys.stdout if stdout is None: stdout = StringIO.StringIO() sys.stdout = stdout yield stdout sys.stdout = old class Serversmtp(Thread): def __init__self(self): Thread.__init__(self) def run(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = ('localhost', 25) print >>sys.stderr, 'starting up on %s port %s' % server_address self.sock.bind(server_address) # Listen for incoming connections self.sock.listen(1) self.message = "" while True: # Wait for a connection print >>sys.stderr, 'waiting for a connection' connection, client_address = self.sock.accept() try: print >>sys.stderr, 'connection from', client_address # Receive the data in small chunks and retransmit it while True: data = connection.recv(1024) print >>sys.stderr, 'received "%s"' % data if data: self.message = self.traitement(data) connection.sendall(self.message) connection.close() connection, client_address = self.sock.accept() else: print >>sys.stderr, 'no more data from', client_address break finally: # Clean up the connection connection.close() self.sock.close() class Pages : def root(self,cgi=None): return """eNqtVV1zqkgQfedX3MrrbNVREBnu5ubWCCoajPiRaHyTxEGNiAKC8uu3B7Nb+7JvO1QNNAOnT5/u 6Xnc5vHhSXsMk8/bk5bv7tdjmNK7XRz9yNKPXw+f63z9cxevow12H8mf4TrbtFt/CCE6QnRFl2Z1 H4hOoh57EU2OmsRETQPx9/p/D+3fhhXMLRhVrw07yC/ANPSuaOi6BTavihB2UZiwrW1D2sNNp8KL lwhUNheFLaRwoQVeJtDotUXAa0AUlYUmMwzw0YlV6KVeievixiUPM8zhndMrOexaBWhYyPn5hKqn C3BLi0oPQWvgojJtAmSbyMXE+BLEIOMFD5N8j65/NFDeTAIMcunDtXxycKnsgBdnJsFxVMCWZhf2 83ZqYPz+Tgz7PVFwvlWAA+GgaloiQINhj5d2OELpNCxw5yotOFlgoYyZXXBxvqSYpW6oESKDokxr b6vuAdVsSAyt/cRFUDsYdzqSMznx6CMDsN0TB29lIwJMXUkOmi1ykF58aM/n4wL2MeOKLYG2xvsl KtZ3JTe/SNRgUJIE+pAYs61ykHRJAsc6FSTEpRaOwV6WrGClZmz2OGTYgKWVjftgqNrQ9Xgm+XlP jMbDEWXtMiHG5q70yUFE9q0nAjaezXwc31otWEOmvRUQX30LVp4GKjuQsNW9DT+FfkmmBc8VYDB8 V4BzJcFXqSTgZOvPZNtbiiA5fB01tKdvXsA2s2iPuBtNAS8xFLnCgjmutmj210MCPNAP49UHJeWy pJBbtW0OyNYDIbmtGGvjAZVBe7voSfYxv7o4xbYDq73bBncNmYqbH9cFuPykH15WVJfVZkWMjJiy HgwnHQr5lQBb2r6mnNGLtickk8udRDNtZxSqktDktBOMlEVgxk4vFLaBONz1cLs5KuQ4CjA+EWq1 WWhK1AM9j09dAmSkie1sqZCtjRfW2Sigc0pSvigTEvaVRDeXE5JgxMz7Oguz1REDT3xqhPimRDwo D6bK2nroSJ6v5inc2+W5ri2gTnTjHJMEB3KI55WYo3iLHPDdZCHvjKlo98AtOl3B+/0PH93Z+opr N8oL3uuOKgjhb1GKTlMSGlU+UJECJh8D/eXEx63/ToDTtSgw1vYHeRe5Hvbk1TbQEW5DAZDyrggM AvQqsoUpyc7T728L2jpMD505AVJE3I5JM3QWVNmNM3PxnTy1taZfYYSyK5ikbkJsxMQzUY4EV91l Q8UpXFm3jeDePS6Dl4lGGiwJcPROaS/6A2Lvx8Z3WTQ/5zrKZGSCABTD0mM1Y+VAhiqCjGyn9d2+ SDPqX8wPq4DFyxtV8mvZhd3PtlRYSlQLxKhKUCrAzyVE5LdVyATofEugK9ui7lF32oja8f8x/mnb d8Bfvx6e7kfHb+2U7o75j4c8yZMH9qDePmi/nzTtEfej5hH1yfMXx7rT9A==""" def favico(self): return """eNqdk39MVWUYx99zDrZkJJc/dGtqsVZKFmttFhcuF0wXC1bTZmq0qVuWa8t+/NXPW1MQCk3FMBKs LNauoq6AAr2zsFLLHAN1YQXJryzJewXuhV29HO759JyX//uj9933vOe8e7/f5/k+73OUMmR6PEqe meq5FKXmKKWyBLIlO9P7/zUiEzaB02GWt43ycHOUx2St6YwTtxP0DZ6n+LV5LH5DURgwWRJQ5L+p eEi+Xa4zZbP+aD9pByLMaR5jdkuUuV9NcNuhKIFTI4DD0bON3P+Kha/coLDMouAtRYHwl72u6IvE mNvwG57QddJCUdJbY6S3jGmN+w5fYTwhCnackor55FZK3AqTfFmXbDbxSx4T9g1ygh2or0cxTzuk nrSZ2R5HHbpKSVMvjuPAlMOq3XexuErh26HwC3/ZlhmShwFJOPfPON6mTlKb+lGtf2J+McSixov8 Hom6VAaGf6Ww8hZyq8X7exb+KpOCCvGwRXHueJDkSFj77B6bpOnSMLVdfVwdv4477KlJXggWs2iH gbdG4otG7nbx8K5oicbO4jv4eJ2XlrdX8131i4z0dIlSUqZDOBbm+YNFZAs3v1a4NdPw7xJsE2xV NJQu5PNV8/ik5Gb2PpJBdLhfe74cGeTx+gVk75F4H5r4BF55970vddtl4JccvFKPg6tn89FyD8GX ltLesFX7tSXvn3tOcPurJg/sU+TUCeol3z2GhteNv92g4B2D/esWcrH9CI7UMREbpe/Ep1wb6tEe 6o5VcG+ZxKy3yNtrkSMecgV5u6UPxMdS4V8b7NW1i0eHad2UxfEnFKG1s7jcFdL7+5rryHx5Pjkf SMxaS/t/sGom2c/mkX7PNvf6NC40lhFaqTj7TArfPmlyprpU58ANyLr7J2669QcyFjSTkdnGDI/0 izmIMrqF7PYHtAd8/LhWeBtNTj1l0rlzja6DO1asvESKmpDzYKmkrOPS+39hmT3Td2zbtG26kzMb FF0bFd+XKi58We6mr3uvqGgAQyVQ1hSGkRCNMdEIi0a/2yDa57HyFYTWKDo2mHzz9Cxif/+h76L7 lzipaVfkbBLLcITnxo9LPhHxMKD/QeQfHOrtILg+k88eTeH8kUqxlGQ0miCv8KT2aZqTWsNU03yl RjR3s6H+93C5/wIoQoi6""" class Serverhttp(Thread): def __init__(self): Thread.__init__(self) self.Pages = Pages() self.GET = re.compile("GET.*?HTTP") self.POST = re.compile("POST.*?HTTP") self.balisep = re.compile(" ",re.DOTALL) def run(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = ('localhost', 41000) print >>sys.stderr, 'starting up on %s port %s' % server_address self.sock.bind(server_address) # Listen for incoming connections self.sock.listen(1) self.message = "" while True: # Wait for a connection print >>sys.stderr, 'waiting for a connection' connection, client_address = self.sock.accept() try: print >>sys.stderr, 'connection from', client_address # Receive the data in small chunks and retransmit it while True: data = connection.recv(1024) print >>sys.stderr, 'received "%s"' % data if data: self.message = self.traitement(data) connection.sendall(self.message) connection.close() connection, client_address = self.sock.accept() else: print >>sys.stderr, 'no more data from', client_address break finally: # Clean up the connection connection.close() self.sock.close() def decompress_img(self,img): img = zlib.decompress(base64.decodestring(img)) return img def decompress_html(self,html) : page = "HTTP/1.0 200 OK\r\nContent-type:text/html;charset=utf8\r\n\r\n" page+=zlib.decompress(base64.decodestring(html)) commands = self.balisep.findall(page) print commands for c in commands : command = c.replace(" ","") command = command.replace("?>","") print command with stdoutIO() as s: exec(command) page = page.replace(c,s.getvalue()) return page def traitement(self,data): url = self.POST.findall(data) print url print len(url) url = self.GET.findall(data) print url url = url[0].replace("GET","") url = url.replace("POST","") url = url.replace("HTTP","") url = url.replace(" ","") print url if url == "/favicon.ico": return self.decompress_img(self.Pages.favico()) else : return self.decompress_html(self.Pages.root()) if __name__ == "__main__": swww = Serverhttp() swww.start() ssmtp = Serversmtp() ssmtp.start() sendmail("test@test.com","b@gmail.com","hello") print "toto" Regards and thanks all people
