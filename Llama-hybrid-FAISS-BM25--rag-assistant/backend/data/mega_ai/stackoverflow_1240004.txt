[site]: stackoverflow
[post_id]: 1240004
[parent_id]: 1237854
[tags]: 
I did not see any issues when I transformed B before A on the Sun 1.6.0_15 and 1.5.0_17 JREs (I used ASM ). I would double-check the transformation code by running it externally and inspecting the resultant classes (e.g. with javap). I'd also check your classpath configuration to ensure A isn't loaded before your agent for some reason (perhaps check in your premain with getAllLoadedClasses ). EDIT: If you load class A in your agent like this: Class.forName("A"); ...then an exception is thrown: Exception in thread "main" java.lang.NoSuchMethodError: B.print()V This makes sense - A becomes a dependency of the agent and it would not make sense for the agent to instrument its own code. You'd get an infinite loop that resulted in a stack overflow. Therefore, A is not processed by the ClassFileTransformer . For completeness, here is my test code that works without problem. As mentioned, it depends on the ASM library. The agent: public class ClassModifierAgent implements ClassFileTransformer { public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { System.out.println("transform: " + className); if ("A".equals(className)) { return new AModifier().modify(classfileBuffer); } if ("B".equals(className)) { return new BModifier().modify(classfileBuffer); } return classfileBuffer; } /** Agent "main" equivalent */ public static void premain(String agentArguments, Instrumentation instrumentation) { instrumentation.addTransformer(new ClassModifierAgent()); } } Method injector for A : public class AModifier extends Modifier { @Override protected ClassVisitor createVisitor(ClassVisitor cv) { return new AVisitor(cv); } private static class AVisitor extends ClassAdapter { public AVisitor(ClassVisitor cv) { super(cv); } @Override public void visitEnd() { MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, "print", "()V", null, null); mv.visitCode(); mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mv.visitLdcInsn("X"); mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V"); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(2, 1); mv.visitEnd(); super.visitEnd(); } } } Method replacer for B : public class BModifier extends Modifier { @Override protected ClassVisitor createVisitor(ClassVisitor cv) { return new BVisitor(cv); } class BVisitor extends ClassAdapter { public BVisitor(ClassVisitor cv) { super(cv); } @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { if ("foo".equals(name)) { MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, "foo", "()V", null, null); mv.visitCode(); mv.visitVarInsn(Opcodes.ALOAD, 0); mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "B", "print", "()V"); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); return new EmptyVisitor(); } else { return super.visitMethod(access, name, desc, signature, exceptions); } } } } Common base code: public abstract class Modifier { protected abstract ClassVisitor createVisitor(ClassVisitor cv); public byte[] modify(byte[] data) { ClassReader reader = new ClassReader(data); ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_FRAMES); ClassVisitor visitor = writer; visitor = new CheckClassAdapter(visitor); visitor = createVisitor(visitor); reader.accept(visitor, 0); return writer.toByteArray(); } } For some visible results, I added a System.out.println('X'); to A.print() . When run on this code: public class MainInstrumented { public static void main(String[] args) { new B().foo(); } } ...it produces this output: transform: MainInstrumented transform: B transform: A X
