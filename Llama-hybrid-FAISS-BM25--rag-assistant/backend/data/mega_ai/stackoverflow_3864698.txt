[site]: stackoverflow
[post_id]: 3864698
[parent_id]: 3862954
[tags]: 
Haskell itself doesn't do anything to enable systems-level coding. Through the foreign function interface (FFI) you can make calls into C/assembly routines, but here you're really just outsourcing the problem to another language. The central challenge -- and the use of the FFI is a harbinger of this -- is in making sure that you are supporting (and not hindering) the runtime. The Haskell runtime is (by necessity) very complex, owing to both automatic memory management and the management of lazy code. Interrupt handling is classic kernel/Haskell problem. If an interrupt comes in when your Haskell code is deep in the runtime system, you won't be able to handle the interrupt in a timely manner. On many architectures, if too many interrupts queue up before being handled, the hardware will fault and either halt or reboot. This issue seems to be the central crux in using Haskell at the kernel level. Edit: On further reflection, monads can be a very useful idiom in systems level code. Think about the way in which IO is used in regular Haskell code: it is a type-level contaminant that infects functions which, well, do IO-things. Since systems programming is all about resource management, it is desirable to track which code interacts with which resources. One could imagine a monad transformer for each resource in question, with resource-specific functions abstracted in a type class. For instance, we might have class Monad m => MonadNetwork m where ... class Monad m => MonadDiskDrive m where ... Code which needs to use both the network and disk drive would carry constraints like downloadToFile :: (MonadNetwork m, MonadDiskDrive m) => URL -> FilePath -> m () This is clearly a high-level example (one wouldn't expect to find this in a kernel), but I think it illustrates the idea. It certainly would be a reasonable way to expose your OS API to user-land, if you didn't mind breaking tradition and having a (gasp) non-C API. Such an API would definitely make me feel safer about running code from untrusted sources, as the types then document (with fine granularity) what sorts of IO-ish things the code intends to do. So yes, I believe that monads are useful in systems level programming, not for efficiency reasons, but simply because when you are running code which isn't in a sandbox, you want to know the code's intentions.
