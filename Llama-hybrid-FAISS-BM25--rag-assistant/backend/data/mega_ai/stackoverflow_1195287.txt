[site]: stackoverflow
[post_id]: 1195287
[parent_id]: 1195198
[tags]: 
If you mean that the parameter can be either an implementation of I1 OR an implementation of I2, and they are unrelated types, then you cannot write one method group (i.e. overloads with the same method name) to handle both types. You can't even say (borrowing from nader!): interface I1 { int NumberOne { get; set; } } interface I2 { int NumberTwo { get; set; } } static void DoSomething (T item) where T : I1 { Console.WriteLine(item.NumberOne); } static void DoSomething (T item) where T : I2 { Console.WriteLine(item.NumberTwo); } static void DoSomething (T item) where T : I1, I2 { Console.WriteLine(item.NumberOne); Console.WriteLine(item.NumberTwo); } This would give the compiler a way to deal with every possibility without ambiguity. But to help with versioning, C# tries to avoid situations where adding/removing a method will change the applicability of another method. You need to write two methods with different names to handle the two interfaces.
