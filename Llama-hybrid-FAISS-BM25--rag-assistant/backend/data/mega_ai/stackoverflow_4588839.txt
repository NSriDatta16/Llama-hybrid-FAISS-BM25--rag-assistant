[site]: stackoverflow
[post_id]: 4588839
[parent_id]: 4587996
[tags]: 
Your question is quite vaste :) This is just one of the way your requirement can be achieved and I am sure there are better than mine. I am going to start from your second question: How can you have the view parse values in the model if the (ModelState.IsValid == false) such that if you enter 3 addresses and post an invalid model, it re-populates the number addresses and with their appropriate values? If I correctly understand your request it looks very simple to me. The answer is simply code your view to render a Model class content and return the invalid model to the client exactly as you are doing in your Create action. If your form (and its fields) have been decorated with the ValidationSummary/ValidationMessage html helpers, you are going to see also validation messages. How can you allow the view to have the ability to add multiple Address classes per Organization dynamically on the client, and bound strongly to the model on post? You can have a main view showing Organization attributes and then have another view showing related addresses. Here you can place a hyperlink or a button that open a dialog for adding a new address object and then refresh the address list when done. At the same way you can have edit and delete buttons as icons on the list. The address list is a piece of markup completely handled at client side that, to be correctly binded to the server side Model class should adhere to some simple naming rules for it's input attributes. To make the Default Model Binder class bind correctly your form use the following snippet for your Organization class @using (Html.BeginForm()) { @Html.HiddenFor(o => o.Id) @Html.ValidationSummary( true ) My Organization @Html.LabelFor( model => model.Name ) @Html.EditorFor( model => model.Name ) @Html.ValidationMessageFor( model => model.Name ) Address List @foreach (Address a in Model.Addresses ) { Html.EditorFor(a); } } To be automatically bindable the resultant code for the form should look as the following ... and so on... having it's properties named as Addresses[index].PropertyName . If you add new addresses on the client it does'nt matter so much: as long as your code respect this rule you can have the default Model Binder do the job for you. Hope this helps
