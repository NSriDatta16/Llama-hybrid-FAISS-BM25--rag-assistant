[site]: stackoverflow
[post_id]: 724206
[parent_id]: 724199
[tags]: 
You cannot truly return multiple values, but you can pass objects into a method and have the method mutate those values. That is perfectly legal. Note that you cannot pass an object in and have the object itself become a different object. That is: private void myFunc(Object a) { a = new Object(); } will result in temporarily and locally changing the value of a , but this will not change the value of the caller, for example, from: Object test = new Object(); myFunc(test); After myFunc returns, you will have the old Object and not the new one. Legal (and often discouraged) is something like this: private void changeDate(final Date date) { date.setTime(1234567890L); } I picked Date for a reason. This is a class that people widely agree should never have been mutable. The the method above will change the internal value of any Date object that you pass to it. This kind of code is legal when it is very clear that the method will mutate or configure or modify what is being passed in. NOTE: Generally, it's said that a method should do one these things: Return void and mutate its incoming objects (like Collections.sort() ), or Return some computation and don't mutate incoming objects at all (like Collections.min() ), or Return a "view" of the incoming object but do not modify the incoming object (like Collections.checkedList() or Collections.singleton() ) Mutate one incoming object and return it ( Collections doesn't have an example, but StringBuilder.append() is a good example). Methods that mutate incoming objects and return a separate return value are often doing too many things.
