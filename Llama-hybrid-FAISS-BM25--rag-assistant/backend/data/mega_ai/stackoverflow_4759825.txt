[site]: stackoverflow
[post_id]: 4759825
[parent_id]: 4752253
[tags]: 
I don’t think there’s anything you can do to make UIPinchGestureRecognizer tell you about a finger touching down or up, but you can make your own gesture recognizer subclass. Below is a scale gesture recognizer that is similar to pinch, and it distinguishes between a one touch and a two touch gesture (the handleOneTouchGesture selector is empty in this example but you could do something like compute a move distance). // // RSScaleGestureRecognizer.h // Created by Jeff Argast // #import @interface RSScaleGestureRecognizer : UIGestureRecognizer { } @property (nonatomic, readonly) float scale; @end And the implementation: // // RSScaleGestureRecognizer.m // Created by Jeff Argast // #import "RSScaleGestureRecognizer.h" #import // // Distance function // static CGFloat RSGetPointDistance (CGPoint p0, CGPoint p1); // // RSScaleGestureRecognizer private selectors // @interface RSScaleGestureRecognizer () - (void) handleTouchDown: (NSSet*) touches withEvent: (UIEvent*) event; - (void) handleTouchMoved: (NSSet*) touches withEvent: (UIEvent*) event; - (void) handleTouchUp: (NSSet*) touches withEvent: (UIEvent*) event; - (void) handleOneTouchGesture: (NSSet*) allTouches; - (void) handleTwoTouchGesture: (NSSet*) allTouches touchesMoved: (NSSet*) movedTouches; @end // // UIView helper category // @interface UIView (RSScaleGestureRecognizer) - (CGFloat) computeScaleFrom: (UITouch*) t0 to: (UITouch*) t1; @end // // RSScaleGestureRecognizer Implementation // @implementation RSScaleGestureRecognizer @synthesize scale; - (id) initWithTarget:(id)target action:(SEL)action { self = [super initWithTarget: target action: action]; if ( self ) { scale = 1.0f; } return self; } - (void)reset { [super reset]; scale = 1.0f; } - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesBegan: touches withEvent: event]; [self handleTouchDown: touches withEvent: event]; } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesMoved: touches withEvent: event]; [self handleTouchMoved: touches withEvent: event]; } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesEnded: touches withEvent: event]; [self handleTouchUp: touches withEvent: event]; } - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesCancelled: touches withEvent: event]; [self handleTouchUp: touches withEvent: event]; } - (void) handleTouchDown: (NSSet*) touches withEvent: (UIEvent*) event { switch ( self. state ) { case UIGestureRecognizerStateBegan: case UIGestureRecognizerStateChanged: break; case UIGestureRecognizerStatePossible: { NSSet* allTouches = [event touchesForGestureRecognizer: self]; if ( allTouches.count > 2 ) { self.state = UIGestureRecognizerStateFailed; return; } } break; default: self.state = UIGestureRecognizerStateFailed; } } - (void) handleTouchMoved: (NSSet*) movedTouches withEvent: (UIEvent*) event { NSSet* allTouches = [event touchesForGestureRecognizer: self]; switch ( allTouches.count ) { case 1: { [self handleOneTouchGesture: allTouches]; } break; case 2: { [self handleTwoTouchGesture: allTouches touchesMoved: movedTouches]; } break; } } - (void) handleTouchUp: (NSSet*) touches withEvent: (UIEvent*) event { NSSet* allTouches = [event touchesForGestureRecognizer: self]; int touchesRemaining = allTouches.count - touches.count; if ( touchesRemaining > 0 ) return; switch ( self.state ) { case UIGestureRecognizerStateBegan: case UIGestureRecognizerStateChanged: self.state = UIGestureRecognizerStateEnded; break; default: self.state = UIGestureRecognizerStateFailed; } } - (void) handleOneTouchGesture: (NSSet*) allTouches { // Do something special here if desired when only one finger is touching return; } - (void) handleTwoTouchGesture: (NSSet*) allTouches touchesMoved: (NSSet*) movedTouches { UIGestureRecognizerState currentState = self.state; switch ( currentState ) { case UIGestureRecognizerStatePossible: case UIGestureRecognizerStateBegan: case UIGestureRecognizerStateChanged: { UIView* selfView = self.view; NSEnumerator* touchEnum = [allTouches objectEnumerator]; UITouch* firstTouch = [touchEnum nextObject]; UITouch* secondTouch = [touchEnum nextObject]; scale = scale * [selfView computeScaleFrom: firstTouch to: secondTouch]; if ( currentState == UIGestureRecognizerStatePossible ) { self.state = UIGestureRecognizerStateBegan; } else { self.state = UIGestureRecognizerStateChanged; } } break; default: self.state = UIGestureRecognizerStateFailed; } } @end // // UIVIew category implementation // @implementation UIView (RSScaleGestureRecognizer) - (CGFloat) computeScaleFrom: (UITouch*) t0 to: (UITouch*) t1 { UITouchPhase t0Phase = t0.phase; if ( (t0Phase == UITouchPhaseEnded) || (t0Phase == UITouchPhaseCancelled) || (t0Phase == UITouchPhaseBegan) ) return 1.0; UITouchPhase t1Phase = t1.phase; if ( (t1Phase == UITouchPhaseEnded) || (t1Phase == UITouchPhaseCancelled) || (t1Phase == UITouchPhaseBegan) ) return 1.0; CGPoint oldFirstPoint = [t0 previousLocationInView:self]; CGPoint oldSecondPoint = [t1 previousLocationInView:self]; CGFloat oldLength = RSGetPointDistance (oldFirstPoint, oldSecondPoint); CGPoint currentFirstPoint = [t0 locationInView:self]; CGPoint currentSecondPoint = [t1 locationInView:self ]; CGFloat currentLength = RSGetPointDistance (currentFirstPoint, currentSecondPoint); // Avoid divide by zero if ( oldLength
