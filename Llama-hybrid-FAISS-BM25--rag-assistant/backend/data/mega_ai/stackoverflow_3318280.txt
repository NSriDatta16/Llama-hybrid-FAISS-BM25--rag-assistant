[site]: stackoverflow
[post_id]: 3318280
[parent_id]: 3317699
[tags]: 
I have a pretty similar structure to yours, and here's how I solve your question: 1) To specify my container on each method, I have a separate class (" SessionManager ") which I then invoke via a static property. By doing so, here's an example using my Save implementation: private static ISession NHibernateSession { get { return SessionManager.Instance.GetSession(); } } public T Save(T entity) { using (var transaction = NHibernateSession.BeginTransaction()) { ValidateEntityValues(entity); NHibernateSession.Save(entity); transaction.Commit(); } return entity; } 2) My container is not created on each ASPX page. I instantiate all of my NHibernate goodness on the global.asax page. ** A few more things spring up ** 3) You don't need to have a helper to instantiate the Load. You might as well use Get instead of Load. More information @ Difference between Load and Get . 4) Using your current code, you would have to repeat pretty much the same code for each domain object you need (StoredWillRepository, PersonRepository, CategoryRepository, etc..?), which seems like a drag. You could very well use a generic class to operate over NHibernate, like: public class Dao : IDao { public T SaveOrUpdate(T entity) { using (var transaction = NHibernateSession.BeginTransaction()) { NHibernateSession.SaveOrUpdate(entity); transaction.Commit(); } return entity; } } In my implementation, I could then use something like : Service .Instance.SaveOrUpdate(will);
