[site]: stackoverflow
[post_id]: 4934510
[parent_id]: 4931120
[tags]: 
There are other issues with the code beyond what mrcrowl mentioned about now needing to "alloc-init" the outlets. In particular, this line: cell = [[[NSBundle mainBundle] loadNibNamed:@"CustomCell" owner:self options:nil] lastObject]; This is not the typical idiom used to load a custom tableview cell from a .xib. First of all, you pass "owner:self", which means you want to hook up the outlet objects in the .xib file with outlet members in your tableviewcontroller object, probably not what you intended. Second, you're relying on the order of objects returned from loadNibNamed:owner:options:, which while it may work today, may not work tomorrow, or on a new release of iOS. Instead, the usual idiom is to declare an outlet for the entire tableviewcell in your tableviewcontroller: (in the .h file): ... UITableViewCell *tvCell; ... @property (nonatomic, retain) IBOutlet UITableViewCell *tvCell; Then in place of your line, you have this: [[NSBundle mainBundle] loadNibNamed:@"NewsArchiveTitleTvCell" owner:self options:nil]; cell = tvCell; self.tvCell = nil; Normally this isn't done with subclassing, notice how I didn't declare the class as CustomCell, but as a vanilla UITableViewCell. So how to you get at those pesky subviews so you can configure them? Using tags is the normal way: ... #define kMyKewlLabelTag 1 ... UILabel *kewlLabel = (UILabel *) [cell viewWithTag:kMyKewlLabelTag]; kewlLabel.text = [NSString stringWithFormat:@"Hi there from row %d!", indexPath.row]; ... EDIT: edit: here's a bit more detail, comments are too short to address the "what's going on here?" question. Here's an excerpt from one of my apps that loads the UITableViewCell from a .xib: - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @"MyShoppingCartTvCell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { [[NSBundle mainBundle] loadNibNamed:@"ShoppingCartTvCell" owner:self options:nil]; cell = tvCell; self.tvCell = nil; } ... // (insert code to grab model data for this row) ... UILabel *nameLabel = (UILabel *) [cell viewWithTag:1]; nameLabel.text = itemNameStr; UILabel *countLabel = (UILabel *) [cell viewWithTag:2]; countLabel.text = [NSString stringWithFormat:@"%d", itemCount]; UIImageView *iv = (UIImageView *) [cell viewWithTag:3]; ... Here's what's going on here: There is no custom UITableViewCell subclass, there is only a .xib file named "ShoppingCartTvCell.xib" containing a UITableViewCell, and UI elements placed inside the UITableViewCell. UI elements whose data must change per row are assigned a unique tag (the tag field is in the CMD-1 Attributes Inspector in IB) so that your code can get a handle to those objects to change them (customize labels, images, etc). Make sure you don't use "0" since all elements by default have a 0 tag. Also, make sure the Identifier field of the UITableViewCell in CMD-1 Attributes Inspector is the CellIdentifier string. The File's Owner of the .xib file is your table view controller where you want to display the cell. More precisely, it can be any class containing a IBOutlet UITableViewCell *tvCell; member. It is an instance of this class that you pass in as owner to loadNibNamed:owner:options:. As long as the value of the linked outlet is nil in the owner, when you call loadNibNamed:owner:options, the outlet of the owner is filled in with the object from the .xib (as long as the connection was made in the .xib in IB). Understanding that is a magic moment in Apple programming that opens whole new vistas to you :). You must set self.tvCell = nil; to prepare for the next cellForRowAtIndexPath that needs to load from the .xib. I also sometimes set to nil before loadNibNamed:owner:options:, I think that's a bit safer actually. Here's how you go about loading your UITableViewCells from a .xib: In xcode, add an IBOutlet UITableViewCell *tvCell; to your UITableViewController class (including property declaration if you like) In your xcode project, create a New File, User Interface, Empty Xib. Open this .xib in IB In IB, drag a TableViewCell from the Library into your empty .xib file under First Responder Click File's Owner, CMD-4 (Identify Inspector), and under Class select the class containing the IBOutlet UITableViewCell *tvCell that you added (probably your UITableViewController subclass, the class where you're manipulating your table). Control-drag from File's owner to the UITableViewCell, and select the outlet you want to hook up. This is the field that will hold the newly-loaded-from-xib UITableViewCell when you call loadNibNamed:owner:options with an instance of File's Owner as the "owner" parameter. Add UI elements into the UITableViewCell (make sure they're inside the UITableViewCell hierarchy). Any elements that you want to customize per-row require a unique tag value. follow the recipe I gave above in cellForRowAtIndexPath Have a magic moment where you start to understand how .xib files and File's Owner objects really work together, and start creating lots of cool UITableViewCells and other custom view objects in IB because it's really easy and way better than creating them in code (IMNSHO).
