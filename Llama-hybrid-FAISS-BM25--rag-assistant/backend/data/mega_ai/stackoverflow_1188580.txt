[site]: stackoverflow
[post_id]: 1188580
[parent_id]: 1173157
[tags]: 
1) Definetely yes, id's should be auto-autoincremented unless you provide a different means of a primary key which is unique. You get the id of the insert either with mysql_insert_id() or LAST_INSERT_ID() from mysql directly, so to post some connected info you can do either mysql_query("INSERT INTO table1 ...") $foreign_key=mysql_insert_id(); //this gives you the last auto-increment for YOUR connection or, but only if you're absolutely sure no one else writes to the table in the mean time or have control over the transaction, after insert do: $foreign_key=mysql_query("SELECT LAST_INSERT_ID()") INSERT INTO table2 message_id=$foreign_key or, without pulling the FK to php, all in one transaction (I also advice to wrap the SQL as a transaction too) with something like: "INSERT INTO table1...; INSERT INTO table2 (message_id,...) VALUES(LAST_INSERT_ID(),...)" Depending on your language and mysql libraries, you might not be able to issue the multi-query approach, so you're better off with using the first approach. 2) This can have so many approaches, depending on if you need to reply to all the recepients too (e.g. conference), reply in a thread/forum-like manner, whether the client-side can store the last retrieved message/id (e.g. in a cookie; also affecting whether you really need the "read" field). The "private chat" approach is the easiest one, you then are probably better off either storing the message in one table and the from-to relationships into an other (and use JOINs on them), or simply re-populate the message in one table (since storage is cheap nowadays). So, the simplistic model would be one table: table: message_body,from,to $recepients=array(1,2,3..); foreach($recepients as $recepient) mysql_query("INSERT INTO table (...,message_body,from,to) VALUES(...,$from,$recepient)"); (duplicate the message etc, only the recepient changes) or message_table: id,when,message_body to-from-table: id,msg_id,from,to $recepients=array(1,2,3,...); mysql_insert("INSERT INTO message_table (when,message_body) VALUES(NOW(),$body)"); $msg_id=mysql_insert_id(); foreach($recepients as $recepient) mysql_query("INSERT INTO to-from-table (msg_id,from,to) VALUES($msg_id,$from,$recepient)"); (message inserted once, store the relations and FK for all recepients) Each client then stores the last message_id he/she received (default to 0), and assume all previous messages already read): "SELECT * FROM message WHERE from=$user_id OR to=$user_id WHERE $msg_id>$last_msg_id" or we just take note of the last input time from the user and query any new messages from then on: "SELECT * FROM message WHERE from=$user_id OR to=$user_id WHERE when>='".date('Y-m-d H:i:s',$last_input_time)."' " If you need a more conference- or forum-tread-like approach, and need to keep track of who read the message or not, you may need to keep track of all the users involved. Assuming there won't be hundred-something people in one "multi-user conference" I'd go with one table for messages and the "comma-separated and wrapped list" trick I use a lot for storing tags. id autoincrement (again, no need for a separate message id) your usual: sent_at, title (if you need one), content sender (int) recepients (I'd go with varchar or shorter versions of TEXT; whereas TEXT or BLOB gives you unlimited number of users but may have impact on performance) readers (same as above) The secret for recepients/readers field is to populate them comma-separated id list and wrap it in commas again (I'll dulge into why later). So you'd have to collect ids of recepients into an array again, e.g. $recepients=array(2,3,5) and modify your insert: "INSERT INTO table (sent_at,title,content,sender,recepients) VALUES(NOW(),'$title','$content',$sender_id,',".implode(',', $recepients).",')" you get table rows like ... sender | recepients ... 1 | ,2, //single user message ... 1 | ,3,5, //multi user message to select all messages for a user with the id of $user_id=2 you go with SELECT * FROM table WHERE sender=$user_id OR INSTR(recepients, ',$user_id,') Previously we wrapped the imploded list of recepients, e.g. '5,2,3' becomes ',5,2,3,' and INSTR here tells if ',2,' is contained somewhere as a substring - since seeking for just '2',',2' or '2,' could give you false positives on e.g. ' 2 34,56','1**,2 34','9,45 2,**89' accordingly - that's why we had to wrap the list in the first place. When the user reads/receives his/her message, you append their id to the readers list like: UPDATE table SET readers=CONCAT(',',TRIM(TRAILING ',' FROM readers),',$user_id,') WHERE id=${initial message_id here} which results in: ... sender | recepients | readers ... 1 | ,2, | ,2, ... 1 | ,3,5, | ,3,5,2, Or we now can modify the initial query adding a column "is_read" to state whether the user previously read the message or not: SELECT * FROM table WHERE INSTR(recepients, ',$user_id,'),INSTR(readers, ',$user_id,') AS is_read collect the message-ids from the result and update the "recepients" fields with one go "UPDATE table SET readers=CONCAT(',',TRIM(TRAILING ',' FROM readers),',$user_id,') WHERE id IN (".implode(',' ,$received_msg_ids).")"
