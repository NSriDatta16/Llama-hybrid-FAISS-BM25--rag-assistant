[site]: stackoverflow
[post_id]: 2729534
[parent_id]: 2729460
[tags]: 
atoi() converts a string representation of an integer into its value. It will not convert arbitrary characters into their decimal value. For instance: int main(void) { const char *string="12345"; printf("The value of %s is %d\n", string, atoi(string)); return 0; } There's nothing in the standard C library that will convert "A" to 65 or "Z" to 90, you'd need to write that yourself, specifically for whatever charset you're expecting as input. Now that you know what atoi() does, please don't use it to deal with numeric input in whatever you come up with. You really should deal with input not being what you expect. Hmm, what happens when I enter 65 instead of A? Teachers love to break things. atoi() doesn't do any error checking whatsoever, which makes anything relying on it to convert arbitrary input fragile, at best. Instead, use strtol() (POSIX centric example): #include #include #include int main(void) { static const char *input ="123abc"; char *garbage = NULL; long value = 0; errno = 0; value = strtol(input, &garbage, 0); switch (errno) { case ERANGE: printf("The data could not be represented.\n"); return 1; // host-specific (GNU/Linux in my case) case EINVAL: printf("Unsupported base / radix.\n"); return 1; } printf("The value is %ld, leftover garbage in the string is %s\n", // Again, host-specific, avoid trying to print NULL. value, garbage == NULL ? "N/A" : garbage); return 0; } When run, this gives: The value is 123, leftover garbage in the string is abc If you don't care about saving / examining the garbage, you can set the second argument to NULL . There is no need to free(garbage) . Also note, if you pass 0 as the third argument, it's assumed the input is the desired value of a decimal, hex or octal representation. If you need a radix of 10, use 10 - it will fail if the input is not as you expect. You'd also check the return value for the maximum and minimum value a long int can handle. However, if either are returned to indicate an error, errno is set. An exercise for the reader is to change *input from 123abc to abc123 . It's important to check the return, as your example shows what happens if you don't. AbcDeFg is not a string representation of an integer, and you need to deal with that in your function. For your implementation, the most basic advice I can give you would be a series of switches, something like: // signed, since a return value of 0 is acceptable (NULL), -1 // means failure int ascii_to_ascii_val(const char *in) { switch(in) { // 64 other cases before 'A' case 'A': return 65; // keep going from here default: return -1; // failure } .. then just run that in a loop. Or, pre-populate a dictionary that a lookup function could scope (better). You wouldn't need hashes, just a key -> value store since you know what it's going to contain in advance, where the standard ASCII characters are keys, and their corresponding identifiers are values.
