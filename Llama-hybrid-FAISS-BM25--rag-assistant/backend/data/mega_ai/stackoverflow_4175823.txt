[site]: stackoverflow
[post_id]: 4175823
[parent_id]: 4175770
[tags]: 
Explicitly storing and comparing to the solutions isnt the most efficient if you were playing generalized N X N tic-tac-toe, but since it's such as small board and there are only 8 such combos there is nothing wrong with explicitly storing solutions like this. The bigger issue is that depending on storage style, spaces that aren't relevant to the solution might be an issue. O - - - O - X X X vs. X X X O - O O - O comparing 3x3 state arrays these are different and as such this method would require well over 8 end states I presume you keep something like a gameState 3x3 array with blank=0, X=1, O=2 ? Besides those explicit comparisons, you can do something like win = false // rows/columns for i in 0,1,2 if (state[i][0] != BLANK && state[i][0] == state[i][1] == state[i][2]) win = true #extensible to NxN - all(j == state[i][0] for j in state[i]) if (state[0][i] != BLANK && state[0][i] == state[1][i] == state[2][i]) win = true #extensible to NxN - all(j == state[0][i] for j in zip(*state)[i]) //diagonals if (state[0][0] != BLANK && state[0][0] == state[1][1] == state[2][2]) win = true #extensible to NxN - all(state[j][j] == state[0][0] for j in range(len(state)) if (state [2][0] != BLANK && state[2][0] == state[1][1] == state[0][2]) win = true If you want win to store the winner rather than flag, then make win = BLANK up top, and set to the value of any of the involved squares. Shouldn't be necessary tho, winner is obviously the most recent move! I think the part of writing tic-tac-toe that you may find most challenging, but not too hard, would the AI. It is not too difficult, but not exactly trivial, to write an AI that wont lose (can always at least force a tie). If you want a relatively good AI that is capable of losing occasionally, youll need to add some randomness or something.
