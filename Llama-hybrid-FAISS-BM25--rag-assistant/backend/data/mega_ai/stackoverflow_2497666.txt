[site]: stackoverflow
[post_id]: 2497666
[parent_id]: 2497113
[tags]: 
A few random thoughts. First, as others have noted, the C# compiler does not do this sort of optimization, though the jitter is free to do so. Second, the best way to answer a performance question is to try it and see. The Stopwatch class is your friend. Try it a billion times both ways and see which one is faster; then you'll know. Third, of course it makes no sense to spend time optimizing something that is already fast enough. Before you spend a lot of time benchmarking, spend some time profiling and looking for hot spots. This is unlikely to be one. And fourth, another answer suggested storing intermediate results in a local variable. Note that doing so can in some situations make things considerably faster, and in others, can make it slower. Sometimes it is faster to recompute a result unnecessarily than to store it and look it up again when you need it. How can that be? Chip architectures with a small number of registers -- I'm looking at you, x86 -- require the jitter to be very judicious about which locals get to be in registers and which get to be stack accesses. Encouraging the jitter to put something that is used infrequently in one register sometimes means forcing something else out of that register, something that would provide more benefit from being in a register than your infrequently used value. In short: do not try to second-guess the jitter from your comfortable armchair; the behaviour of real-world code can be deeply counterintuitive. Make performance decisions based on realistic empirical measurements.
