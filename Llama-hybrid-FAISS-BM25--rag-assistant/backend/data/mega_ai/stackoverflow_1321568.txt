[site]: stackoverflow
[post_id]: 1321568
[parent_id]: 1319891
[tags]: 
This solution is in Haskell, which is more familiar to me: slidingSums :: Num t => Int -> [t] -> [t] slidingSums n list = case (splitAt (n - 1) list) of (window, []) -> [] -- list contains less than n elements (window, rest) -> slidingSums' list rest (sum window) where slidingSums' _ [] _ = [] slidingSums' (hl : tl) (hr : tr) sumLastNm1 = sumLastN : slidingSums' tl tr (sumLastN - hl) where sumLastN = sumLastNm1 + hr movingAverage :: Fractional t => Int -> [t] -> [t] movingAverage n list = map (/ (fromIntegral n)) (slidingSums n list) paddedMovingAverage :: Fractional t => Int -> [t] -> [t] paddedMovingAverage n list = replicate (n - 1) 0 ++ movingAverage n list Scala translation: def slidingSums1(list: List[Double], rest: List[Double], n: Int, sumLastNm1: Double): List[Double] = rest match { case Nil => Nil case hr :: tr => { val sumLastN = sumLastNm1 + hr sumLastN :: slidingSums1(list.tail, tr, n, sumLastN - list.head) } } def slidingSums(list: List[Double], n: Int): List[Double] = list.splitAt(n - 1) match { case (_, Nil) => Nil case (firstNm1, rest) => slidingSums1(list, rest, n, firstNm1.reduceLeft(_ + _)) } def movingAverage(list: List[Double], n: Int): List[Double] = slidingSums(list, n).map(_ / n) def paddedMovingAverage(list: List[Double], n: Int): List[Double] = List.make(n - 1, 0.0) ++ movingAverage(list, n)
