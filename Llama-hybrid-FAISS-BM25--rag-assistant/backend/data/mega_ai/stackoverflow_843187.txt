[site]: stackoverflow
[post_id]: 843187
[parent_id]: 843154
[tags]: 
You can only get a definitive answer by scanning the entire file looking for newline characters. There's no way around that. However, there are a couple of possibilities which you may want to consider. 1/ If you're using a simplistic loop, reading one character at a time checking for newlines, don't. Even though the I/O may be buffered, function calls themselves are expensive, time-wise. A better option is to read large chunks of the file (say 5M) into memory with a single I/O operation, then process that. You probably don't need to worry too much about special assembly instruction since the C runtime library will be optimized anyway - a simple strchr() should do it. 2/ If you're saying that the general line length is about 40-50 characters and you don't need an exact line count, just grab the file size and divide by 45 (or whatever average you deem to use). 3/ If this is something like a log file and you don't have to keep it in one file (may require rework on other parts of the system), consider splitting the file periodically. For example, when it gets to 5M, move it (e.g., x.log ) to a dated file name (e.g., x_20090101_1022.log ) and work out how many lines there are at that point (storing it in x_20090101_1022.count , then start a new x.log log file. Characteristics of log files mean that this dated section that was created will never change so you will never have to recalculate the number of lines. To process the log "file", you'd just cat x_*.log through some process pipe rather than cat x.log . To get the line count of the "file", do a wc -l on the current x.log (relatively fast) and add it to the sum of all the values in the x_*.count files.
