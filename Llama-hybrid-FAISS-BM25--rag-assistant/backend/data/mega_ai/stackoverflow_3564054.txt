[site]: stackoverflow
[post_id]: 3564054
[parent_id]: 3563941
[tags]: 
Three VMs is the right way in your scenario. I suggest you to build a Parent/Child relation between you VMs. Since the the MainVM holds the ItemList, this is the place, where FilterChanges are applied. The FilterEditVM only receives the filter changes and than calls the MainVM, that it has to re-apply the filters. The structure would be something like this: public class WelcomePageVM { public WelcomePageVM() { this.FilterEditPageVM = new FilterEditPageVM(this); this.MainItemsVM = new MainItemsVM(this); } public FilterEditPageVM FilterEditPageVM { get; private set; } public MainItemsVM MainItemsVM { get; private set; } public void SetInitialFilter1(object filter) { // the initial filter this.FilterEditPageVM.Filter1Value = filter; this.MainItemsVM.ApplyFilters(); } } public class FilterEditPageVM : ChildViewModelBase { public FilterEditPageVM(WelcomePageVM parent) : base(parent) { } public object Filter1Value { get; set; } public object Filter2Value { get; set; } public object Filter3Value { get; set; } public object Filter4Value { get; set; } public void FinishFilterChange() { this.Parent.MainItemsVM.ApplyFilters(); } } public class MainItemsVM : ChildViewModelBase { public MainItemsVM(WelcomePageVM parent) : base(parent) { } public List ItemList { get; set; } public void ApplyFilters() { // filter apply logic } } public abstract class ChildViewModelBase { T _parent; public ChildViewModelBase(T parent) { this._parent = parent; } public T Parent { get { return _parent; } } } Here you can access all viewmodels, which is okay because you stay in the "controller" level.
