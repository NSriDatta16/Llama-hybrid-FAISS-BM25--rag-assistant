[site]: stackoverflow
[post_id]: 599564
[parent_id]: 598148
[tags]: 
++Kristo! The C++ standard 1.9.16 makes a lot of sense with respect to how one implements operator++(postfix) for a class. When that operator++(int) method is called, it increments itself and returns a copy of the original value. Exactly as the C++ spec says. It's nice to see standards improving! However, I distinctly remember using older (pre-ANSI) C compilers wherein: foo -> bar(i++) -> charlie(i++); Did not do what you think! Instead it compiled equivalent to: foo -> bar(i) -> charlie(i); ++i; ++i; And this behavior was compiler-implementation dependent. (Making porting fun.) It's easy enough to test and verify that modern compilers now behave correctly: #define SHOW(S,X) cout Responding to comment in thread... ...And building on pretty much EVERYONE's answers... (Thanks guys!) I think we need spell this out a bit better: Given: baz(g(),h()); Then we don't know whether g() will be invoked before or after h() . It is "unspecified" . But we do know that both g() and h() will be invoked before baz() . Given: bar(i++,i++); Again, we don't know which i++ will be evaluated first, and perhaps not even whether i will be incremented once or twice before bar() is called. The results are undefined! (Given i=0 , this could be bar(0,0) or bar(1,0) or bar(0,1) or something really weird!) Given: foo(i++); We now know that i will be incremented before foo() is invoked. As Kristo pointed out from the C++ standard section 1.9.16: When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [ Note: Value computations and side effects associated with different argument expressions are unsequenced. -- end note ] Though I think section 5.2.6 says it better: The value of a postfix ++ expression is the value of its operand. [ Note: the value obtained is a copy of the original value -- end note ] The operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to a complete effective object type. The value of the operand object is modified by adding 1 to it, unless the object is of type bool, in which case it is set to true. [ Note: this use is deprecated, see Annex D. -- end note ] The value computation of the ++ expression is sequenced before the modification of the operand object. With respect to an indeterminately-sequenced function call, the operation of postfix ++ is a single evaluation. [ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue conversion and the side effect associated with any single postfix ++ operator. -- end note ] The result is an rvalue. The type of the result is the cv-unqualified version of the type of the operand. See also 5.7 and 5.17. The standard, in section 1.9.16, also lists (as part of its examples): i = 7, i++, i++; // i becomes 9 (valid) f(i = -1, i = -1); // the behavior is undefined And we can trivially demonstrate this with: #define SHOW(X) cout So, yes, i is incremented before foo() is invoked. All this makes a lot of sense from the perspective of: class Foo { public: Foo operator++(int) {...} /* Postfix variant */ } int main() { Foo f; delta( f++ ); } Here Foo::operator++(int) must be invoked prior to delta() . And the increment operation must be completed during that invocation. In my (perhaps overly complex) example: f . bar("A",i) . bar("B",i++) . bar("C",i) . bar("D",i); f.bar("A",i) must be executed to obtain the object used for object.bar("B",i++) , and so on for "C" and "D" . So we know that i++ increments i prior to calling bar("B",i++) (even though bar("B",...) is invoked with the old value of i ), and therefore i is incremented prior to bar("C",i) and bar("D",i) . Getting back to j_random_hacker 's comment: j_random_hacker writes: +1, but I had to read the standard carefully to convince myself that this was OK. Am I right in thinking that, if bar() was instead a global function returning say int, f was an int, and those invocations were connected by say "^" instead of ".", then any of A, C and D could report "0"? This question is a lot more complicated than you might think... Rewriting your question as code... int bar(const char * theString, int theI) { SHOW(...); return i; } bar("A",i) ^ bar("B",i++) ^ bar("C",i) ^ bar("D",i); Now we have only ONE expression. According to the standard (section 1.9, page 8, pdf page 20): Note: operators can be regrouped according to the usual mathematical rules only where the operators really are associative or commutative.(7) For example, in the following fragment: a=a+32760+b+5; the expression statement behaves exactly the same as: a=(((a+32760)+b)+5); due to the associativity and precedence of these operators. Thus, the result of the sum (a+32760) is next added to b, and that result is then added to 5 which results in the value assigned to a. On a machine in which overflows produce an exception and in which the range of values representable by an int is [-32768,+32767], the implementation cannot rewrite this expression as a=((a+b)+32765); since if the values for a and b were, respectively, -32754 and -15, the sum a+b would produce an exception while the original expression would not; nor can the expression be rewritten either as a=((a+32765)+b); or a=(a+(b+32765)); since the values for a and b might have been, respectively, 4 and -8 or -17 and 12. However on a machine in which overflows do not produce an exception and in which the results of overflows are reversible, the above expression statement can be rewritten by the implementation in any of the above ways because the same result will occur. -- end note ] So we might think that, due to precedence, that our expression would be the same as: ( ( ( bar("A",i) ^ bar("B",i++) ) ^ bar("C",i) ) ^ bar("D",i) ); But, because (a^b)^c==a^(b^c) without any possible overflow situations, it could be rewritten in any order... But, because bar() is being invoked, and could hypothetically involve side effects, this expression cannot be rewritten in just any order. Rules of precedence still apply. Which nicely determines the order of evaluation of the bar()'s . Now, when does that i+=1 occur? Well it still has to occur before bar("B",...) is invoked. (Even though bar("B",....) is invoked with the old value.) So it's deterministically occurring before bar(C) and bar(D) , and after bar(A) . Answer: NO . We will always have "A=0, B=0, C=1, D=1", if the compiler is standards-compliant. But consider another problem: i = 0; int & j = i; R = i ^ i++ ^ j; What is the value of R? If the i+=1 occurred before j , we'd have 0^0^1=1. But if the i+=1 occurred after the whole expression, we'd have 0^0^0=0. In fact, R is zero. The i+=1 does not occur until after the expression has been evaluated. Which I reckon is why: i = 7, i++, i++; // i becomes 9 (valid) Is legal... It has three expressions: i = 7 i++ i++ And in each case, the value of i is changed at the conclusion of each expression. (Before any subsequent expressions are evaluated.) PS: Consider: int foo(int theI) { SHOW(theI); SHOW(i); return theI; } i = 0; int & j = i; R = i ^ i++ ^ foo(j); In this case, i+=1 has to be evaluated before foo(j) . theI is 1. And R is 0^0^1=1.
