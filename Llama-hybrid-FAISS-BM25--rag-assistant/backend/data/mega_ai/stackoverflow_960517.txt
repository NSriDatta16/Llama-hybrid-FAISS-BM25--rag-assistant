[site]: stackoverflow
[post_id]: 960517
[parent_id]: 
[tags]: 
IEnumerable evaluation and unit testing

After reading another SO thread ( Should parameters/returns of collections be IEnumerable or T[]? ), I am of the opinion that a unit testing 'issue' I'm having is probably related to what the thread refers to as "late evaluation". I am passing three different but related flavors IEnumerables from a presenter class to my UI. The best news is that it works, but I can't seem to find a way to make a unit test that definitively proves that the right IEnumerable is being passed at the right time. I have a facade with the following method: public IEnumerable NonProjectDtos { get { var activities = LeaveTimeActivities.Cast () .Concat(AdministrativeActivities.Cast ()); return _assembler.ToActivityDtoCollection(activities, _timeSheet); } } In a presenter, I load a widget: private ITimeSheetMatrixWidget _nonProjectActivityMatrix; public ITimeSheetMatrixWidget NonProjectActivityMatrix { set { .. // load the activities _nonProjectActivityMatrix.Load(Facade.NonProjectDtos); ... } } Then the test on a mocked matrix (using Rhino Mocks): [Test] public void SettingTheWidget_TriggersLoad_NonProjectActivities() { var f = _getFacade(); ... // inject the mocked widget & trigger the Load var widget = MockRepository.GenerateMock (); timeSheetPresenter.ActivityMatrix = widget; widget.AssertWasCalled(x => x.Load(f.NonProjectDtos), mo =>mo.IgnoreArguments()); x.Load(f.NonProjectDtos)); If I look in the debugger, I can see that the IEnumerable load arg is evaluating to Domain.TransferObjects.TimeSheetDtoAssembler +d__1, which is also the part of Rhino's message that the method call failed. Is this is related to late evaluation? Is there a reasonably elegant way to test this more rigorously? I would also like to fully understand the intermediate evaluation better, which looks a lot like the method that assembled it (in the facade code above).
