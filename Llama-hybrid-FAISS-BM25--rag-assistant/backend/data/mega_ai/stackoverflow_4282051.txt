[site]: stackoverflow
[post_id]: 4282051
[parent_id]: 4282003
[tags]: 
Set cover is NP-hard, so it's unlikely that there'll be an algorithm much more efficient than looking at all possible combinations of sets, and checking if each combination is a cover. Basically, look at all combinations of 1 set, then 2 sets, etc. until they form a cover. EDIT This is an example pseudocode. Note that I do not claim that this is efficient. I simply claim that there isn't a much more efficient algorithm (algorithms will be worse than polynomial time unless something really cool is discovered) for size in 1..|S|: for C in combination(S, size): if (union(C) == U) return C where combination(K, n) returns all possible sets of size n whose elements come from K . EDIT However, I'm not too sure why you need an algorithm to find the minimum. In the question you state that you want to show that the greedy algorithm for set covering sometimes finds more sets. But this is easily achieved via a counterexample (and a counterexample is shown in the wikipedia entry for set cover). So I am quite puzzled. EDIT A possible implementation of combination(K, n) is: if n == 0: return [{}] //a list containing an empty set r = [] for k in K: K = K \ {k} // remove k from K. for s in combination(K, n-1): r.append(union({k}, s)) return r But in combination with the cover problem, one probably wants to perform the test of coverage from the base case n == 0 instead. Well.
