[site]: stackoverflow
[post_id]: 4317454
[parent_id]: 3449615
[tags]: 
iPhoneDev: here is what I am doing. I have a custom UIWindow object. In this object, there is a NSTimer that is reset whenever there is a touch. To get this touch you have to override the sendEvent method of UIWindow. this is what the sendEvent method looks like in my custom window class: - (void)sendEvent:(UIEvent *)event { if([super respondsToSelector: @selector(sendEvent:)]) { [super sendEvent:event]; } else { NSLog(@"%@", @"CUSTOM_Window super does NOT respond to selector sendEvent:!"); ASSERT(false); } // Only want to reset the timer on a Began touch or an Ended touch, to reduce the number of timer resets. NSSet *allTouches = [event allTouches]; if ([allTouches count] > 0) { // anyObject works here. UITouchPhase phase = ((UITouch *)[allTouches anyObject]).phase; if (phase == UITouchPhaseBegan || phase == UITouchPhaseEnded) { [self resetIdleTimer]; } } } here is the resetIdleTimer: - (void)resetIdleTimer { if (self.idleTimer) { [self.idleTimer invalidate]; } self.idleTimer = [NSTimer scheduledTimerWithTimeInterval:PASSWORD_TIMEOUT_INTERVAL target:self selector:@selector(idleTimerExceeded) userInfo:nil repeats:NO]; } after this, in the idleTimerExceeded, I send a message to the window delegates, (in this case, the appDelegate). - (void)idleTimerExceeded { [MY_CUSTOM_WINDOW_Delegate idleTimeLimitExceeded]; } When I create this custom window object in the appDelegate, I set the appDelegate as the delegate for this window. And in the appDelegate definition of idleTimeLimitExceeded is where I do what I have to when the timer expires. They key thing is the create the custom window and override the sendEvent function. Combine this with the two keyboard notification shown above I added in the init method of the custom window class and you should be able to get 99% of all touch events on screen anywhere in the application.
