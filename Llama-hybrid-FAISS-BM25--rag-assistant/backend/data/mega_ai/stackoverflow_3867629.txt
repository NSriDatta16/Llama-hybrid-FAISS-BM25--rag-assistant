[site]: stackoverflow
[post_id]: 3867629
[parent_id]: 920904
[tags]: 
Hi I also had this problem at work (so won't post resulting the code). The most elegant solution that I could think of, and which works pretty nicely imo, is as follows Create a class for example DocumentSplittingInputStream which extends InputStream and takes the underlying inputstream in its constructor (or gets set after construction...). Add a field with a byte array closeTag containing the bytes of the closing root node you are looking for. Add a field int called matchCount or something, initialised to zero. Add a field boolean called underlyingInputStreamNotFinished, initialised to true On the read() implementation: Check if matchCount == closeTag.length, if it does, set matchCount to -1, return -1 If matchCount == -1, set matchCount = 0, call read() on the underlying inputstream until you get -1 or ' Otherwise read an int from the underlying inputstream (if it equals closeTag[matchCount] then increment matchCount, if it doesn't then reset matchCount to zero) and return the newly read byte Add a method which returns the boolean on whether the underlying stream has closed. All reads on the underlying input stream should go through a separate method where it checks if the value read is -1 and if so, sets the field "underlyingInputStreamNotFinished" to false. I may have missed some minor points but i'm sure you get the picture. Then in the using code you do something like, if you are using xstream: DocumentSplittingInputStream dsis = new DocumentSplittingInputStream(underlyingInputStream); while (dsis.underlyingInputStreamNotFinished()) { MyObject mo = xstream.fromXML(dsis); mo.doSomething(); // or something.doSomething(mo); } David
