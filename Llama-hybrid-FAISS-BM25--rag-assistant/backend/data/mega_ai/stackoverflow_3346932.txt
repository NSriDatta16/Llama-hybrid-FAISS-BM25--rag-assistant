[site]: stackoverflow
[post_id]: 3346932
[parent_id]: 
[tags]: 
php: efficiently running functions with one-time loaded classes multiple times in optional files

after reading the responses I have rewritten my question. Let's say I have a theoretical php application that uses objects that do different things. For every page that gets loaded by the application, different scripts will be run. now I made a simple php script that creates a simple object. (this is all made up, I'm just trying to understand this before I code it) $user = new userClass($db); $user->login($credentials); all is fine, and I can even repeat the procedure several times after creating the user class $user = new userClass($db); $user->login($credentials); ... $user->login($credentials2); now imagine if these 2 parts are split in 2 different php files. file1: $user = new userClass($db); $user->login($credentials); file2: $user->login($credentials2); include file1 include file2 if they are run in order all is fine, but if they are not, or if file1 is not included at all... file2: $user->login($credentials); file1: $user = new userClass($db); $user->login($credentials2); include file2 include file1 then it won't work... they have to maintain order, so lets make a main php file that gets loaded no matter what. main file: $user = new userClass($db); file1: $user->login($credentials); file2: $user->login($credentials2); (included files with autoloading for example) include main include file1 include file2 or include main include file2 include file1 or include main include file2 now file1 and 2 can be loaded in any order, and one does not depend on the other, but what if both file1 or file2 are unnecessary? main file: $user = new userClass($db); //nothing else gets loaded then the main file is also unnecessary, and will prove to be a resource hog, sure if its one class it's no problem, but what if the main file loads hundreds of classes that never get used? not elegant at all. Then let's try to do it another way, let's scrap the main file completely and do it like this (below is the bare bone example of what I want to achieve): file1: if(!is_object($user)){ $user = new userClass($db); } $user->login($credentials); file2: if(!is_object($user)){ $user = new userClass($db); } $user->login($credentials2); sure, it works, but it's not elegant, now is it? let's try it with method overloading... class loader { private $objects; private $db; function __construct($db){ $this->objects = array(); $this->db = $db; } function __get($name){ if(!isset($this->objects[$name])){ return $this->objects[$name] = new $name($this->db); } } } main file: $loader = new loader($db); file1: $loader->user->login($credentials); file3: $loader->user->login($credentials3); file2: $loader->user->login($credentials2); file4: $loader->user->login($credentials4); seems to work, until you realize that you can no longer give any of the objects that are created this way any other variable except $db. This means that loader class is limited to use with user class only (for example) because using loader class with any other class will require editing of the loader class and a simple script like this: $user = new userClass($this->db); $user->login($credentials); $form = new formClass($_POST); $form->process($info); will require 2 separate loader classes or at least 2 methods in the loader class class loader { private $objects; private $db; function __construct($db){ $this->objects = array(); $this->db = $db; } function getuserclass($name){ if(!isset($this->objects[$name])){ return $this->objects[$name] = new $name($this->db); } } function getformclass($name){ if(!isset($this->objects[$name])){ return $this->objects[$name] = new $name($_POST);//just an unrealistic example. } } } main file: $loader = new loader($db); file1: $loader->getuserclass('user')->login($credentials); file3: $loader->getformclass('form')->process($info); but this is not elegant either. How is this really supposed to be done?
