[site]: stackoverflow
[post_id]: 1411555
[parent_id]: 1410645
[tags]: 
Your test isn't really being fair to the property-based versions. The JIT is smart enough to inline simple properties so that they have a runtime performance equivalent to that of direct field access, but it doesn't seem smart enough (today) to detect when the properties access constant values. In your example, the entire loop body of the field access version is optimized away, becoming just: for (int i = 0; i whereas the second version, is actually performing the floating point division on each iteration: for (int i = 0; i Making just two small changes to your application to make it more realistic makes the two operations practically identical in performance. First, randomize the input values so that they aren't constants and the JIT isn't smart enough to remove the division entirely. Change from: Point point = new Point(12.0, 123.5, 0.123); to: Random r = new Random(); Point point = new Point(r.NextDouble(), r.NextDouble(), r.NextDouble()); Secondly, ensure that the results of each loop iteration are used somewhere: Before each loop, set calculatedValue = 0 so they both start at the same point. After each loop call Console.WriteLine(calculatedValue.ToString()) to make sure that the result is "used" so the compiler doesn't optimize it away. Finally, change the body of the loop from "calculatedValue = ..." to "calculatedValue += ..." so that each iteration is used. On my machine, these changes (with a release build) yield the following results: Direct field access: 133 Property access: 133 Total difference: 0 Average difference: 0 Just as we expect, the x86 for each of these modified loops is identical (except for the loop address) 000000dd xor eax,eax 000000df fld qword ptr [esp+20h] 000000e3 fmul qword ptr [esp+28h] 000000e7 fdiv qword ptr [esp+30h] 000000eb fstp st(0) 000000ed inc eax 000000ee cmp eax,989680h 000000f3 jl 000000DF (This loop address is the only difference)
