[site]: stackoverflow
[post_id]: 2316626
[parent_id]: 259240
[tags]: 
Continuing David's answer, there's another possibility to put the boile by creating a derived class from boost::transform_iterator. I'm using this solution in my projects: namespace detail { template struct add_cv_if_c { typedef T type; }; template struct add_cv_if_c { typedef const T type; }; template struct add_cv_if_c { typedef volatile T type; }; template struct add_cv_if_c { typedef const volatile T type; }; template struct add_cv_if: public add_cv_if_c {}; } // namespace detail /** An unary function that accesses the member of class T specified in the MemberPtr template parameter. The cv-qualification of T is preserved for MemberType */ template struct access_member_f { // preserve cv-qualification of T for T::second_type typedef typename detail::add_cv_if , std::tr1::is_volatile , MemberType >::type& result_type; result_type operator ()(T& t) const { return t.*MemberPtr; } }; /** @short An iterator adaptor accessing the member called 'second' of the class the iterator is pointing to. */ template class accessing_second_iterator: public boost::transform_iterator but std::pair<>::second_type isn't automatically // const just because the pair is const - access_member_f is // preserving the cv-qualification, otherwise compiler errors will // be the result typename std::tr1::remove_reference ::reference >::type, typename std::iterator_traits ::value_type::second_type, &std::iterator_traits ::value_type::second >, Iterator > { typedef boost::transform_iterator ::reference >::type, typename std::iterator_traits ::value_type::second_type, &std::iterator_traits ::value_type::second >, Iterator > baseclass; public: accessing_second_iterator(): baseclass() {} // note: allow implicit conversion from Iterator accessing_second_iterator(Iterator it): baseclass(it) {} }; This leads to even cleaner code: void run_map_value() { typedef map a_map_t; a_map_t a_map; a_map[0] = "zero"; a_map[1] = "one"; a_map[2] = "two"; typedef accessing_second_iterator ia_t; // note: specify the iterator adaptor type explicitly as template type, enabling // implicit conversion from begin()/end() copy (a_map.begin(), a_map.end(), ostream_iterator (cout, "\n") ); }
