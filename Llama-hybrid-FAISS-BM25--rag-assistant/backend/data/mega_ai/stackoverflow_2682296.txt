[site]: stackoverflow
[post_id]: 2682296
[parent_id]: 2682170
[tags]: 
Inside each area's folder you'll see a *AreaName*AreaRegistration.cs file. This is where the area routeing rules are stored. By default, as they are generated, they will contain the area name ahead of everything else.. The problem is: if you remove the area name "folder" from the route, the route will catch all "standard" {controller}/{action}/{id} requests. Which is obviously not what you want.. To overcome this you can add the regex filters on the routes, based on the controller names present in that route. The drawback? You won't be able to have two controllers with the same name within the app (at least not using the standard route.. You can always think of a different route to access them :) ) In the end.. Having this structure: /Areas /Areas/Blog/Controllers/BlogController.cs /Areas/Blog/Controllers/FeedController.cs /Areas/User/Controllers/UserController.cs /Controllers/PageController.cs What you should have is sth like this: In BlogAreaRegistration.cs: context.MapRoute( "Blog_default", "{controller}/{action}/{id}", new { action = "Index", id = UrlParameter.Optional }, new { controller = "(Blog|Feed)" } ); In UserAreaRegistration.cs: context.MapRoute( "User_default", "{controller}/{action}/{id}", new { action = "Index", id = UrlParameter.Optional }, new { controller = "(User)" } ); In Global.asax.cs: public static void RegisterRoutes(RouteCollection routes) { context.MapRoute( "Default", "{controller}/{action}/{id}", new { controller = "Home", action = "Index", id = UrlParameter.Optional } ); } protected void Application_Start() { AreaRegistration.RegisterAllAreas(); RegisterRoutes(RouteTable.Routes); } Note that in global.asax area registrations come first! :) UPD: Based on your question update: There us one major thing that you'll have to take into consideration if you will use areas: If you have a inter-area link, you'll also have to provide the area name in the link. E.g. You get the idea. Regarding the multiple models/views, at the moment I'm following a structure like this /Code/ // helper, extension classes that aren't moved to libraries /Models/Data/ // The EF classes + validation classes are here /Models/ViewModels/{controller}/ // view models stored per controller So far it works fine, and I managed to keep the solution relatively organised. As I stated, the only area that I created so far is the Admin area because it's that much different from the rest of the website :)
