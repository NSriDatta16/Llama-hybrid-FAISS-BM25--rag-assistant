[site]: stackoverflow
[post_id]: 2221014
[parent_id]: 2220987
[tags]: 
Interfaces allow you to sort of use multiple inheritance. In your example, it woulda allow you to put an instance of Employee or Manager into the same variable, and then call DoSomething on that variable, with the method call being dispatched to the instance that is currently referenced by that variable. For example: public interface IEmployee { void DoSomething(); } // assume Manager and Employee both implement IEmployee IEmployee ie = new Manager(); ie.DoSomething(); // calls Manager.DoSomething() ie = new Employee(); ie.DoSomething(); // calls Employee.DoSomething() If you didn't use interfaces, you would have to do: object o; // assign Manager or Employee (or something else!) to o if (o is Manager) ((Manager)o).DoSomething(); else if (o is Employee) ((Employee)o).DoSomething(); An interface defines a contract , and as long as an instance implements that interface you don't care what it actually is at runtime. You can have the same class implement multiple interfaces, and then use instances of that class in all variables of those interfaces. You couldn't use the same for abstract classes, as a class can only inherit off one class at a time. One example where I'm using interfaces now is to define an object model - I've got interfaces for various properties ( IHasStorage , IHasPrivileges , IHasCheezburger ), then the classes representing the concrete objects implement whichever and however many interfaces are appropriate for that class' properties
