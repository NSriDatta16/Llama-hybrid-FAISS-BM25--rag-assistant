[site]: stackoverflow
[post_id]: 4362061
[parent_id]: 2090121
[tags]: 
Here's a simplified version of Colin's solution. The biggest difference is that this solution does not store the entire html of the sortable elements, but only the currently dragged item. It is then inserted into it's original position if the item is dropped on the droppable area. Anyway, here's the code: $(document).ready(function() { var dropped = false; var draggable_sibling; $("#sortable").sortable({ start: function(event, ui) { draggable_sibling = $(ui.item).prev(); }, stop: function(event, ui) { if (dropped) { if (draggable_sibling.length == 0) $('#sortable').prepend(ui.item); draggable_sibling.after(ui.item); dropped = false; } } }); $(".droppable").droppable({ activeClass: 'active', hoverClass:'hovered', drop:function(event,ui){ dropped = true; $(event.target).addClass('dropped'); } }); }); #sortable li{ clear:both; float:left; } .droppable { clear:both; height:300px; width:400px; background-color:#CCC; } .droppable.active { background: #CFC; } .droppable.hovered { background: #CCF; } .dropped { background: #f52; } One Two Three Four Five Six Drop Here Drop Here It still suffers the same problem as Colin's solution if an item is dragged into a new position in the list and then dropped outside both the and the droppable . The item will then not reset but take the last position in the list (tested in Google Chrome). Anyway, this is easily solved with some mouse over detection or it may even be desirable behaviour.
