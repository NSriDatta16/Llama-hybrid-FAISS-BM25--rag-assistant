[site]: stackoverflow
[post_id]: 3376250
[parent_id]: 3376124
[tags]: 
If your code is segfaulting then that's a correctness issue, not an efficiency issue. To achieve "u[i] = u[i] + v[i] for all i", I would do basically what you did: assert(u.size() == v.size()); // will fail with your initialization code, since // your "result" has size 0, not size 10. // perhaps do u.resize(v.size()); for (size_t i = 0; i If you really care about performance of your program (that is, you've written a basic version and it's so slow that your program is failing some requirement, and you've proved that this is the code where much of the time is taken), then you could try: switching on lots of optimization in your compiler (actually, I usually do this by default even when there isn't a performance problem), using iterators instead of indexes (rarely makes much difference, but it's easy enough to compare the two), unrolling the loop a bit (can make a worthwhile speed difference, but that's quite sensitive to the particular case, and it encourages coding errors). looking at platform-specific SIMD instructions rather than C++. Then use embedded assembler or compiler intrinsics for those instructions. Nevertheless, you have no business worrying about performance before your code is correct ;-). "Make it work, make it right, make it fast" is a reasonable motto, although often you don't need to go as far as step 3. std::valarray actually has exactly the operator+= you want. Before you replace all your vectors with valarrays, be aware that doesn't necessarily mean it's any "more efficient" than a simple loop - I don't know how seriously implementers take valarray . You can always look at the source in your implementation. I also don't know why the multiple-data arithmetic functionality of valarray wasn't defined as part of vector , but there's usually a reason.
