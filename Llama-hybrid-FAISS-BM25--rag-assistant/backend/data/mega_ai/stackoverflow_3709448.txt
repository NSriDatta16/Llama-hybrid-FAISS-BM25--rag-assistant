[site]: stackoverflow
[post_id]: 3709448
[parent_id]: 3709298
[tags]: 
public static List map( List xs, Func1 transformer ) { List ys = new ArrayList (); map(xy, transformer, ys); return ys; } public static Set map( Set xs, Func1 transformer ) { Set ys = new HashSet (); map(xy, transformer, ys); return ys; } private static map( Collection xs, Func1 transformer, Iterable ys ) { for(A a : xs) { ys.add(transformer.apply(a)); } } Job done. Note, it's typical of Java APIs, to pass the mutable the collection in, rather than create a new one in the method. Personally, I'm not a fan of mutability at the collection level, but it's what we have to work with (in Java). (I'm not keen on A and B as generic parameters with this sort of stuff.) Or you could use a factory: public static List map( List xs, Func1 transformer ) { return map(xs, transformer, new CollectionFactory >() { public List create() { return new ArrayList (); } }); } public static Set map( Set xs, Func1 transformer ) { return map(xs, transformer, new CollectionFactory >() { public Set create() { return new HashSet (); } }); } private interface CollectionFactory > { C create(); } private static > C map( Iterable xs, Func1 transformer, CollectionFactory factory ) { C ys = factory.create(); for(A a : xs) { ys.add(transformer.apply(a)); } return ys; } (If you can put up with the pointless verbosity of anonymous inner classes.) If it wasn't for Collection then you'd need to put some (ugly) adapter in. For completeness (though not tested, could do with a few tweaks), an unpleasant solution using inheritance: Set strs = hashSets().map(things, formatter); ... public static Functions > hashSets() { return new Functions >() { protected Set createCollections() { return new HashSet (); } }; } public abstract class Functions > { protected abstract C createCollection(); public C map( Set xs, Func1 transformer ) { C ys = createCollection(); for(S a : xs) { ys.add(transformer.apply(a)); } return ys; } public C filter( List xs, Func1 predicate // Predicate might be nicer!! ) { C ys = createCollection(); for(A a : xs) { if(predicate.apply(a)) { ys.add(a); } } return ys; } }
