[site]: stackoverflow
[post_id]: 4821255
[parent_id]: 3684151
[tags]: 
Twisted has #2 as twisted/python/reflect.py . You need something like it for making a string-based configuration system, like with Django's urls.py configuration. Take a look at the code and the version control log to see what they had to do to make it work - and fail! - the right way. The other things you are looking for place enough restrictions on the Python environment that there is no such thing as a general purpose solution. Here's something which somewhat implements your #1 >>> import pickle >>> def identify(f): ... name = f.__name__ ... module_name = pickle.whichmodule(f, name) ... return module_name + "." + name ... >>> identify(math.cos) 'math.cos' >>> from xml.sax.saxutils import handler >>> identify(handler) '__main__.xml.sax.handler' >>> Your #3 is underdefined. If I do __builtin__.step = path.to.your.stap then should the search code find it as "step"? The simplest implementation I can think of simply searches all modules and looks for top-level elements which are exactly what you want >>> import sys >>> def _find_paths(x): ... for module_name, module in sys.modules.items(): ... if module is None: ... continue ... for (member_name, obj) in module.__dict__.items(): ... if obj is x: ... yield module_name + "." + member_name ... >>> def find_shortest_name_to_object(x): ... return min( (len(name), name) for name in _find_paths(x) )[1] ... >>> find_shortest_name_to_object(handler) '__builtin__._' >>> 5 5 >>> find_shortest_name_to_object(handler) 'xml.sax.handler' >>> Here you can see that 'handler' was actually in _ from the previous expression return, making it the shortest name. If you want something else, like recursively searching all members of all modules, then just code it up. But as the "_" example shows, there will be surprises. Plus, this isn't stable, since importing another module might make another object path available and shorter. That's why people say over and over again that what you want isn't actually useful for anything, and that's why there's no modules for it. And as for your #4, how in the world will any general package cater to those naming needs? In any case, you wrote Please, don't try to show me a quick implementation of these things. It's more complicated than it seems, there are plenty of gotchas, and any quick-n-dirty code will probably fail for many important cases. These kind of tasks call for battle-tested code. so don't think of my examples as solutions but as examples of why what you're asking for makes little sense. It's such a fragile solution space adn the few who venture there (mostly for curiosity) have such different concerns that a one-off custom solution is the best thing. A module for most of these makes no sense, and if it did make sense the explanation of what the module does would probably be longer than the code. And hence the answer to your question is "no, there are no such modules." What makes your question even more confusing is that the C implementation of Python already defines an "object address". The docs for id() say: CPython implementation detail: This is the address of the object. What you're looking for is the name, or the path to the object. Not the "Python object address."
