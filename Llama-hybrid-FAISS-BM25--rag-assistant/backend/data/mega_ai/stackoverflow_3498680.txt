[site]: stackoverflow
[post_id]: 3498680
[parent_id]: 3496291
[tags]: 
The most important thing to realize is that a class is nothing special. It's just an object. Per convention, classes are assigned to constants, but there is nothing that says they have to be. And since classes are just objects like any other object, you make them private the same way that you make any other object private. Here are the possibilities I can think of, in the order of increasing privateness: Just nest them inside a namespace (i.e. module). In Ruby, it is generally expected that all of a library's modules and classes live inside a namespace with the same name as the library (i.e. my_awesome_library â†’ MyAwesomeLibrary ), but in general, everything which is nested below that namespace, is considered private. In fact, besides Test::Unit::TestCase , I cannot think of a single example of a three-level deep namespace that is actually expected to be used by client code. same as 1., but name it something obvious, like MyAwesomeLibrary::Internal::FfiStruct same as 1. or 2., and mark it with the :nodoc: RDoc tag. similar to 3., but use a more modern documentation system like YARD, which actually lets you explicitly mark up private APIs. Use a method instead of a constant. Methods can be made private. (For consistency's sake, you can have the method name start with an uppercase letter, to make it resemble a constant. There's nothing to prevent that, the snake_case convention is just that: a convention.) Use an instance variable. They are always private. Note that both private methods and instance variables can be trivially accessed using reflection. send seems to be in more widespread use than instance_variable_get , though, which is why I consider instance variables to have a higher level of privacy than methods. Really the only way to get actual privacy or encapsulation is using local variables and closures, though. Note however that this might preclude you from using Ruby's module, class or method definition syntax, because those create new scopes. In all cases where you need access to the class, you need to use Module.new , Class.new or Module#define_method . Ex.: module MyAwesomeLibrary struct = Class.new(FFI::Struct) do # ... end PublicInterface = Class.new do define_method(:initialize) do |bar| @foo = struct.new(bar) end end end And yes, this is the only way of achieving true 100% information hiding and encapsulation in Ruby. However, the normal Ruby way would be to simply document the stuff as being private (maybe push it down a level of namespacing) and trust your fellow developers. In the Ruby community, this is sometimes summarized under the Python slogan "We are all consenting adults".
