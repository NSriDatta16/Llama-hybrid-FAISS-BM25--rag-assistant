[site]: stackoverflow
[post_id]: 731069
[parent_id]: 731012
[tags]: 
I agree with Mitchel and casperOne -- an Exception makes the most sense. As far as unit testing is concerned, JUnit4 allows you to exceptions directly: http://www.ibm.com/developerworks/java/library/j-junit4.html You would need only to pass parameters which are guaranteed to cause the exception, and add the correct annotation ( @Test(expected=IllegalArgumentException.class) ) to the JUnit test method. Edit : As Tom Martin mentioned, JUnit 4 is a decent-sized step away from JUnit 3. It is, however, possible to also test exceptions using JUnit 3. It's just not as easy. One of the ways I've tested exceptions is by using a try/catch block within the class itself, and embedding Assert statements within it. Here's a simple example -- it's not complete (e.g. regionModel is assumed to be instantiated), but it should get the idea across: public void testRemoveRegionsInvalidInputs() { int originalSize = regionModel.length(); int index = 0; int numberOfRegionsToRemove = 1,000; // > than regionModel's current size try { regionModel.removeRegions(index, numberOfRegionsToRemove); // Since the exception will immediately go into the 'catch' block this code will only run if the IllegalArgumentException wasn't thrown Assert.assertTrue("Exception not Thrown!", false); } catch (IllegalArgumentException e) { Assert.assertTrue("Exception thrown, but regionModel was modified", regionModel.length() == originalSize); } catch (Exception e) { Assert.assertTrue("Incorrect exception thrown", false); } }
