[site]: stackoverflow
[post_id]: 3128095
[parent_id]: 
[tags]: 
Best way to test code speed in C++ without profiler, or does it not make sense to try?

On SO, there are quite a few questions about performance profiling, but I don't seem to find the whole picture. There are quite a few issues involved and most Q & A ignore all but a few at a time, or don't justify their proposals. What Im wondering about. If I have two functions that do the same thing, and Im curious about the difference in speed, does it make sense to test this without external tools, with timers, or will this compiled in testing affect the results to much? I ask this because if it is sensible, as a C++ programmer, I want to know how it should best be done, as they are much simpler than using external tools. If it makes sense, lets proceed with all the possible pitfalls: Consider this example. The following code shows 2 ways of doing the same thing: #include #include #include typedef unsigned char byte; inline void swapBytes( void* in, size_t n ) { for( size_t lo=0, hi=n-1; hi>lo; ++lo, --hi ) in[lo] ^= in[hi] , in[hi] ^= in[lo] , in[lo] ^= in[hi] ; } int main() { byte arr[9] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' }; const int iterations = 100000000; clock_t begin = clock(); for( int i=iterations; i!=0; --i ) swapBytes( arr, 8 ); clock_t middle = clock(); for( int i=iterations; i!=0; --i ) std::reverse( arr, arr+8 ); clock_t end = clock(); double secSwap = (double) ( middle-begin ) / CLOCKS_PER_SEC; double secReve = (double) ( end-middle ) / CLOCKS_PER_SEC; std::cout The issues: Which timers to use and how get the cpu time actually consumed by the code under question? What are the effects of compiler optimization (since these functions just swap bytes back and forth, the most efficient thing is obviously to do nothing at all)? Considering the results presented here, do you think they are accurate (I can assure you that multiple runs give very similar results)? If yes, can you explain how std::reverse gets to be so fast, considering the simplicity of the custom function. I don't have the source code from the vc++ version that I used for this test, but here is the implementation from GNU. It boils down to the function iter_swap , which is completely incomprehensible for me. Would this also be expected to run twice as fast as that custom function, and if so, why? Contemplations: It seems two high precision timers are being proposed: clock() and QueryPerformanceCounter (on windows). Obviously we would like to measure the cpu time of our code and not the real time, but as far as I understand, these functions don't give that functionality, so other processes on the system would interfere with measurements. This page on the gnu c library seems to contradict that, but when I put a breakpoint in vc++, the debugged process gets a lot of clock ticks even though it was suspended (I have not tested under gnu). Am I missing alternative counters for this, or do we need at least special libraries or classes for this? If not, is clock good enough in this example or would there be a reason to use the QueryPerformanceCounter? What can we know for certain without debugging, dissassembling and profiling tools? Is anything actually happening? Is the function call being inlined or not? When checking in the debugger, the bytes do actually get swapped, but I'd rather know from theory why, than from testing. Thanks for any directions. update Thanks to a hint from tojas the swapBytes function now runs as fast as the std::reverse. I had failed to realize that the temporary copy in case of a byte must be only a register, and thus is very fast. Elegance can blind you. inline void swapBytes( byte* in, size_t n ) { byte t; for( int i=0; i Thanks to a tip from ChrisW I have found that on windows you can get the actual cpu time consumed by a (read:your) process trough Windows Management Instrumentation . This definitely looks more interesting than the high precision counter.
