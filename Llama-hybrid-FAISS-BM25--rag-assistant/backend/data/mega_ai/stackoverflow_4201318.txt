[site]: stackoverflow
[post_id]: 4201318
[parent_id]: 4200829
[tags]: 
If it is about about building the expression tree itself, then you could leverage C# compiler abilities. It is legal to pass a lambda expression to a function acception an Expression>, as long as type arguments of Func are known. For example private static void PrintExpression(Expression > lambda) { Console.WriteLine(lambda.ToString()); } can be called as PrintExpression(a=> a > 0 && a You can improvise with generics as private static void PrintExpression (Expression > lambda) { Console.WriteLine(lambda.ToString()); } and calling it with PrintExpression (a=> a > 0 && a For custom printing of the expression part, you can write a simple recursive function that prints an expression or any other logic that suits you. Remember, the lambda expression is compiled into an Expression at compile time - so can't subsititute it with already compiled Func. As an alternative to this, you can always build a custom query provider, but that would be slightly deviating from the purpose - as you'd need to bind it some sort of queryable (custom again).
