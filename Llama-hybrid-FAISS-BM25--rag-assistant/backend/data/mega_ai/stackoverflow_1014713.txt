[site]: stackoverflow
[post_id]: 1014713
[parent_id]: 1013582
[tags]: 
I was having the same problem a few years ago, then I gave up on responseXML and began always using responseText. This parsing function has always worked for me: function parseXml(xmlText){ try{ var text = xmlText; //text = replaceAll(text,"&lt;"," "); //text = replaceAll(text,"&quot;","\""); //alert(text); //var myWin = window.open('','win','resize=yes,scrollbars=yes'); //myWin.document.getElementsByTagName('body')[0].innerHTML = text; if (typeof DOMParser != "undefined") { // Mozilla, Firefox, and related browsers var parser=new DOMParser(); var doc=parser.parseFromString(text,"text/xml"); //alert(text); return doc; }else if (typeof ActiveXObject != "undefined") { // Internet Explorer. var doc = new ActiveXObject("Microsoft.XMLDOM"); // Create an empty document doc.loadXML(text); // Parse text into it return doc; // Return it }else{ // As a last resort, try loading the document from a data: URL // This is supposed to work in Safari. Thanks to Manos Batsis and // his Sarissa library (sarissa.sourceforge.net) for this technique. var url = "data:text/xml;charset=utf-8," + encodeURIComponent(text); var request = new XMLHttpRequest(); request.open("GET", url, false); request.send(null); return request.responseXML; } }catch(err){ alert("There was a problem parsing the xml:\n" + err.message); } } With this XMLHttpRequest Object: // The XMLHttpRequest class object debug = false; function Request (url,oFunction,type) { this.funct = ""; // this.req = ""; this.url = url; this.oFunction = oFunction; this.type = type; this.doXmlhttp = doXmlhttp; this.loadXMLDoc = loadXMLDoc; } function doXmlhttp() { //var funct = ""; if (this.type == 'text') { this.funct = this.oFunction + '(req.responseText)'; } else { this.funct = this.oFunction + '(req.responseXML)'; } this.loadXMLDoc(); return false; } function loadXMLDoc() { //alert(url); var functionA = this.funct; var req; req = false; function processReqChange() { // alert('reqChange is being called'); // only if req shows "loaded" if (req.readyState == 4) { // only if "OK" if (req.status == 200) { // ...processing statements go here... eval(functionA); if(debug){ var debugWin = window.open('','aWindow','width=600,height=600,scrollbars=yes'); debugWin.document.body.innerHTML = req.responseText; } } else { alert("There was a problem retrieving the data:\n" + req.statusText + '\nstatus: ' + req.status); if(debug){ var debugWin = window.open('','aWindow','width=600,height=600,scrollbars=yes'); debugWin.document.body.innerHTML = req.responseText; } } } } // branch for native XMLHttpRequest object if(window.XMLHttpRequest) { try { req = new XMLHttpRequest(); } catch(e) { req = false; } // branch for IE/Windows ActiveX version } else if(window.ActiveXObject) { try { req = new ActiveXObject("Msxml2.XMLHTTP"); } catch(e) { try { req = new ActiveXObject("Microsoft.XMLHTTP"); } catch(e) { req = false; } } } if(req) { req.onreadystatechange = processReqChange; if(this.url.length > 2000){ var urlSpl = this.url.split('?'); req.open("POST",urlSpl[0],true); req.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); req.send(urlSpl[1]); } else { req.open("GET", this.url, true); req.send(""); } } } function browserSniffer(){ if(navigator.userAgent.toLowerCase().indexOf("msie") != -1){ if(navigator.userAgent.toLowerCase().indexOf("6")){ return 8; }else{ return 1; } } if(navigator.userAgent.toLowerCase().indexOf("firefox") != -1){ return 2; } if(navigator.userAgent.toLowerCase().indexOf("opera") != -1){ return 3; } if(navigator.userAgent.toLowerCase().indexOf("safari") != -1){ return 4; } return 5; } Granted, this is very old code, but it is still working for me on a site I built a few years ago. I agree with everyone else though I typically use a framework nowadays so I don't have to use this code or anything like it anymore. You can ignore some of the particulars with the split, etc... in the Request onreadystate function. It was supposed to convert the request to a post if it was longer than a certain length, but I just decided it was always better to do a post.
