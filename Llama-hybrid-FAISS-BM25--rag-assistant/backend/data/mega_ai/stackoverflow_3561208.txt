[site]: stackoverflow
[post_id]: 3561208
[parent_id]: 3187222
[tags]: 
Under Unix, command line programs have a lot of control over what happens when you try to interrupt them with ^C . The default effect of typing ^C at a terminal is to make the kernel send the SIGINT signal to the foreground process group, and the default behavior of SIGINT is to kill the process it's sent to, but both of those things can be changed. The most likely cause of your problem is that your Java program is intercepting SIGINT in order to do some cleanup before exiting, but the signal handler is buggy so the process doesn't ever actually exit. The second most likely cause is that the program is ignoring SIGINT altogether. And the least likely cause is that it's put the terminal into "raw mode" so that ^C just delivers a byte with value 0x03 to its standard input (if it had done that ^Z probably wouldn't work either). If you have access to the source code of your program, you can try to fix the buggy signal handler and/or make it stop ignoring the signal. Otherwise, you're kinda up a creek. You can try ^\ (control-backslash), which sends a different normally-lethal signal ( SIGQUIT ), but this is not guaranteed to work either, and if it does work, it may leave you with a gigantic "core dump" file to get rid of. The only 100% for sure way to get rid of a malfunctioning process is to send it signal 9 ( SIGKILL ). Unlike the other lethal signals, it's impossible to intercept, block, or ignore that one. There is no control key to send signal 9; you have to suspend the process with ^Z , or open a new terminal window / ssh session, find the process ID with ps , and use the kill command. Always try kill PID before kill -9 PID .
