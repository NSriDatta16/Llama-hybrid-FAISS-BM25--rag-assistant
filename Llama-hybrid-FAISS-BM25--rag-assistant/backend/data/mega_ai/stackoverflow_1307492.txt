[site]: stackoverflow
[post_id]: 1307492
[parent_id]: 1307353
[tags]: 
I'm a bit confused by your use of cp3.Phone.Phone in addition to your join against CUS_Phone , so I'm going to assume the former means you don't need the latter. Otherwise, just switch in p3 for cp3 in the join and adjust the g.Select() accordingly. That said, you should be able to simply group on the contact ID: var q = from c in CUS_Contact join cp in CUS_Phone_JCT on c.Id equals cp.Contact_Id into cp2 from cp3 in cp2.DefaultIfEmpty() group new { c, cp3.Phone.Phone } by c.Id into g let c = g.First().c select new { c.Id, c.Cus_Id, c.Namefirst, c.Namemiddle, c.Namelast, Phones = g.Select(x => x.Phone) c.Title, c.Dept, c.Des, c.Datecreate, c.Dateupdate, c.Usr_idcreate, c.Usr_idupdate }; foreach(var v in q) { Console.WriteLine(v.Id + "-" + v.Namefirst); foreach(var p in v.Phones) { Console.WriteLine(" -" + p); } } A few shots in the dark to improve performance: var q = from c in CUS_Contact join cp in CUS_Phone_JCT on c.Id equals cp.Contact_Id into cp2 from cp3 in cp2.DefaultIfEmpty() group new { c, cp3.Phone.Phone } by c.Id into g let c = g.First().c select new { c.Id, c.Cus_Id, c.Namefirst, c.Namemiddle, c.Namelast, Phones = g.Select(x => x.Phone) c.Title, c.Dept, c.Des, c.Datecreate, c.Dateupdate, c.Usr_idcreate, c.Usr_idupdate }; You might also try grouping by a composite key (with all your c fields) instead of c.Id: group cp3.Phone.Phone by new { c.Id, c.Cus_Id, c.Namefirst, ETC } into g let c = g.Key select new { ... Phones = g.Select(p => p), ... } Update: Tweaked the composite key example to only group the Phone value, since everything else you need should be in the key. Update 2: You might be able to simplify things quite a bit by embedding a subquery: var q = from c in CUS_Contact select new { c.Id, c.Cus_Id, c.Namefirst, c.Namemiddle, c.Namelast, Phones = (from cp in CUS_Phone_JCT where c.Id == cp.Contact_Id select cp.Phone.Phone), c.Title, c.Dept, c.Des, c.Datecreate, c.Dateupdate, c.Usr_idcreate, c.Usr_idupdate };
