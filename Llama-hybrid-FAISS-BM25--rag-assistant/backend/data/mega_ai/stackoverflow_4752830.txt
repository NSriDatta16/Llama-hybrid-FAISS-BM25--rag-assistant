[site]: stackoverflow
[post_id]: 4752830
[parent_id]: 4752315
[tags]: 
The specific issue you're dealing with looks like endianness to me. Try replacing one or the other implementation with c = *((char *)&f + sizeof(float) - 1); or something similar to get the last byte of the float, and see if it matches the result for the other platform. In general, the behavior will depend on endianness, word length and floating point capabilities of the processor, and how the compiler targets that. ARM is bi-endian, so it might or might not match IA byte ordering. It seems there's also no general guarantee that one C implementation supports the same floating point format as another: Fixed-size floating point types . Are you using this in production code? I'd look very hard at why this needs to be done. One or the other type is probably not being used as intended. Workarounds are not going to be elegant.
