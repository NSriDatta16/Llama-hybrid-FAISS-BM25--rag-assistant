[site]: stackoverflow
[post_id]: 700943
[parent_id]: 700629
[tags]: 
The way I use a ViewModel is somewhat different. In my case it actually wraps the Model class passing most of the data on to the model. That way all standard business rules in the model still work the way they are supposed to right away. The ViewModel only exposes those properties actually needed for data binding or other UI purposes. Additionally the ViewModel might contain other properties/methods used for data binding. So using your customer example: namespace TestMvvm345 { public class CustomerViewModel : INotifyPropertyChanged { private Customer _model; public Customer Model { get { return _model; } set { if (_model != null) Model.PropertyChanged -= Model_PropertyChanged; _model = value; if (_model != null) Model.PropertyChanged += Model_PropertyChanged; } } void Model_PropertyChanged(object sender, PropertyChangedEventArgs e) { RaisePropertyChanged(e.PropertyName); if (e.PropertyName == "FirstName" || e.PropertyName == "LastName") RaisePropertyChanged("FullName"); } public string FirstName { get { return Model.FirstName; } set { Model.FirstName = value; } } public string LastName { get { return Model.LastName; } set { Model.LastName = value; } } public string FullName { get { return FirstName + " " + LastName; } } public static IList GetCustomers() { var result = new List (); var customers = Customer.GetCustomers(); foreach (var customer in customers) { result.Add(new CustomerViewModel() { Model = customer }); } return result; } public event PropertyChangedEventHandler PropertyChanged; private void RaisePropertyChanged(string property) { if (PropertyChanged != null) { PropertyChanged(this, new PropertyChangedEventArgs(property)); } } } public class Customer : INotifyPropertyChanged { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public int NumberOfContracts { get; set; } public static List GetCustomers() { List customers = new List (); customers = new List (); customers.Add(new Customer { FirstName = "Jim", LastName = "Smith", NumberOfContracts = 23 }); customers.Add(new Customer { FirstName = "Jane", LastName = "Smith", NumberOfContracts = 22 }); customers.Add(new Customer { FirstName = "John", LastName = "Tester", NumberOfContracts = 33 }); customers.Add(new Customer { FirstName = "Robert", LastName = "Smith", NumberOfContracts = 2 }); customers.Add(new Customer { FirstName = "Hank", LastName = "Jobs", NumberOfContracts = 5 }); return customers; } #region INotifyPropertyChanged Members public event PropertyChangedEventHandler PropertyChanged; #endregion } } Now in your UI you bind using the following code: customerHeaderView.DataContext = CustomerViewModel.GetCustomers(); The code in the ViewModel does become somewhat large but a lot can be put in a base class and all properties that go to the Model are exactly the same (think T4 template).
