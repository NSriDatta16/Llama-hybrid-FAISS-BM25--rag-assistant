[site]: stackoverflow
[post_id]: 2458703
[parent_id]: 2457780
[tags]: 
Debilski's post is definitely a solid way to do it, although the \say is not necessary. Here's a shorter way that makes use of some LaTeX internal shortcuts ( \@gobble and \@ifnextchar ): \makeatletter \def\hyphenatestring#1{\xHyphen@te#1$\unskip} \def\xHyphen@te{\@ifnextchar${\@gobble}{\sw@p{\hskip 0pt plus 1pt\xHyphen@te}}} \def\sw@p#1#2{#2#1} \makeatother Note the use of \hskip 0pt plus 1pt instead of \discretionary - when I tried your example I ended up with a ragged margin because there's no stretchability. The \hskip adds some stretchable glue in between each character (and the \unskip afterwards cancels the extra one we added). Also note the LaTeX style convention that "end user" macros are all lowercase, while internal macros have an @ in them somewhere so that users don't accidentally call them. If you want to figure out how this works, \@gobble just eats whatever's in front of it (in this case the $ , since that branch is only run when a $ is the next char). The main point is that \sw@p is only given one argument in the "else" branch, so it swaps that argument with the next char (that isn't a $ ). We could just as well have written \def\hyphenate#next#1{#1\hskip...\xHyphen@te} and put that with no args in the "else" branch, but (in my opinion) \sw@p is more general (and I'm surprised it's not in standard LaTeX already).
