[site]: stackoverflow
[post_id]: 242687
[parent_id]: 242665
[tags]: 
It looks as though nothing is allocating an engine, so the first use of e is segfaulting. I think you need to call ENGINE *ENGINE_new(void) first. (Note that I've used OpenSSL, but I haven't used the ENGINE functions before.) Update : I'm not really happy with my own answer (I had to dash off to tea, before). So my further notes are: I've had a bit of a look at the (long) man page for the ENGINE functions, and I'm not quite sure that calling ENGINE_new is sufficient. I didn't notice that the calls to the HMAC_CTX_* functions were taking an uninitialized pointer, rather than a pointer to an allocated structure. HMAC_CTX_init will try to write to the memory pointed to by its ctx parameter, which will segfault. You need to declare and use ctx like this: HMAC_CTX ctx; HMAC_CTX_init(&ctx); HMAC_Init_ex(&ctx, key, 40, EVP_sha256(), e); ... That way you're allocating the structure on the stack, and then passing a pointer to it. The HMAC function doesn't take a pointer to a CTX at all, so apart from global or thread-local storage, I'm not sure what it's connection to the CTX is. I think you can bypass that by calling HMAC_Update one-or-more times, followed by HMAC_Final to get the result. You'd need to allocate space for that result, so something like the following would work for that: unsigned int len; HMAC_Final(&ctx, result, &len);
