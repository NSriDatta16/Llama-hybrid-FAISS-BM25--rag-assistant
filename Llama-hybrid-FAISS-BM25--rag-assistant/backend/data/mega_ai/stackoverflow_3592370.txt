[site]: stackoverflow
[post_id]: 3592370
[parent_id]: 3587380
[tags]: 
The individual classes should be as free from infrastructure as possible - constructs like IAppSettings , IMyClassXAppSettings , and [AppSetting] bleed composition details to classes which, at their simplest, really only depend on raw values such as executablePath . The art of Dependency Injection is in the factoring of concerns. I have implemented this exact pattern using Autofac , which has modules similar to Ninject and should result in similar code (I realize the question doesn't mention Ninject, but the OP does in a comment). Modules organize applications by subsystem. A module exposes a subsystem's configurable elements: public class BrowserModule : Module { private readonly string _executablePath; public BrowserModule(string executablePath) { _executablePath = executablePath; } public override void Load(ContainerBuilder builder) { builder .Register(c => new InternetExplorerBrowser(_executablePath)) .As () .InstancePerDependency(); } } This leaves the composition root with the same problem: it must supply the value of executablePath . To avoid the configuration soup, we can write a self-contained module which reads configuration settings and passes them to BrowserModule : public class ConfiguredBrowserModule : Module { public override void Load(ContainerBuilder builder) { var executablePath = ConfigurationManager.AppSettings["ExecutablePath"]; builder.RegisterModule(new BrowserModule(executablePath)); } } You could consider using a custom configuration section instead of AppSettings ; the changes would be localized to the module: public class BrowserSection : ConfigurationSection { [ConfigurationProperty("executablePath")] public string ExecutablePath { get { return (string) this["executablePath"]; } set { this["executablePath"] = value; } } } public class ConfiguredBrowserModule : Module { public override void Load(ContainerBuilder builder) { var section = (BrowserSection) ConfigurationManager.GetSection("myApp.browser"); if(section == null) { section = new BrowserSection(); } builder.RegisterModule(new BrowserModule(section.ExecutablePath)); } } This is a nice pattern because each subsystem has an independent configuration which gets read in a single place. The only benefit here is a more obvious intent. For non- string values or complex schemas, though, we can let System.Configuration do the heavy lifting.
