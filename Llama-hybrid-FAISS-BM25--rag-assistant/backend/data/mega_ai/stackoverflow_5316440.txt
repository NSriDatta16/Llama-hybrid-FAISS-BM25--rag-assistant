[site]: stackoverflow
[post_id]: 5316440
[parent_id]: 
[tags]: 
Copying templated vector

I currently have a vector using my template as its type: vector myTable; hashData is a class: class hashData{ public: // constructor for hashData hashData(hashType data){ this->data = data; this->isActive = true; this->deleted = false; } hashData(){ this->isActive = false; this->deleted = false; } // internal data for hashTable hashType data; bool deleted; bool isActive; }; When I attempt to perform an operation such as the following: vector oldTable = myTable; I receive this error message: error C2440: 'initializing' : cannot convert from 'std::vector ' to 'std::vector ' hashtable.h(211): error C2440: 'initializing' : cannot convert from 'std::vector ' to> 'std::vector ' with [_Ty=hashTable::hashData] and [_Ty=unsigned long] No constructor could take the source type, or constructor overload resolution was ambiguous Any ideas as to why this is occurring? My reference materials seem to think this is possible, so I'm not sure where my mistake is. EDIT: Here is the complete header file of the hashTable implementation. I apologize for the length of the code, but I wanted to include everything since my initial "fragment" appears to be insufficient. // Driver file #include "hashTable.h" int main(void){ // hash table creation hashTable newTable(3); // hash table insertion newTable.addRecord(5); newTable.addRecord(6); newTable.addRecord(7); newTable.addRecord(8); } // hashTable header file // BEGIN HEADER FILE #ifndef HASHTABLE_H #define HASHTABLE_H // Includes (system libraries) #include #include // Includes (custom libraries) // Namespace using namespace std; // hashTable class template class hashTable{ public: // constructor hashTable(int tableSize, string collisionMode = "Linear"){ this->myTable.resize(optimizeTableSize(tableSize)); this->collisionMode = collisionMode; this->activeRecords = 0; } // hashTable operations void addRecord(hashType); void deleteRecord(hashType); pair locateRecordPosition(hashType); bool searchRecord(hashType); hashType returnRecord(hashType); // hashTable mainteance void considerRehash(); void rehashTable(); int optimizeTableSize(int); // hashTable math bool isPrime(int); int nextPrime(int); // collision monitoring void collisionLogUpdate(int, string); int collisionLogAverage(); // hash table internal class class hashData{ public: // constructor for hashData hashData(hashType data){ this->data = data; this->isActive = true; this->deleted = false; } hashData(){ this->isActive = false; this->deleted = false; } // internal data for hashTable hashType data; bool deleted; bool isActive; }; private: // hashing function int calculateHash(hashType, int); // hashTable data structure vector myTable; int activeRecords; // collision information deque > collisionLog; string collisionMode; }; // hashTable implementation // insert a record into the hash table template void hashTable ::addRecord(hashType toAdd){ // search for the record pair recordPos = locateRecordPosition(toAdd); // analyze the results if (recordPos.first == true) // the record already exists and is active return; // otherwise, go ahead and insert the record at this location myTable[recordPos.second] = hashData(toAdd); // update our count of active records activeRecords++; // consider a rehash of the hashTable considerRehash(); } // delete a record from the hash table template void hashTable ::deleteRecord(hashType toDelete){ // search for the record pair recordPos = locateRecordPosition(toDelete); // analyze the results if (recordPos.first == false) // the record does not exist -- there is nothing to delete here! return; // otherwise, go ahead and perform a shallow deletion at this area myTable[recordPos.second].deleted = true; // update our count of active records activeRecords--; // consider a rehash of the hashTable considerRehash(); } // find position of record within hash table (if such position exists) template pair hashTable ::locateRecordPosition(hashType toFind){ // setup data structures int collisionNum = 0; unsigned int currentPos; // search for the entry within the table currentPos = calculateHash(toFind, myTable.size()); // enter a while loop for checking if we've found the item while(myTable.at(currentPos).isActive && !myTable.at(currentPos).deleted){ // check to see if the entry found at the expected position matches if(myTable.at(currentPos).data == toFind){ // update the collisionLog collisionLogUpdate(collisionNum,"locateRecord"); // return the position of the item return pair (true,currentPos); // we've successfully found the item } // otherwise, we need to look for the correct location if (collisionMode == "Quadratic"){ currentPos += 2 * ++collisionNum - 1; if(currentPos >= myTable.size()) currentPos -= myTable.size(); } else if (collisionMode == "Linear"){ currentPos += 2 * ++collisionNum - 1; if(currentPos >= myTable.size()) currentPos -= myTable.size(); } // reloop and search again } // update the collisionLog collisionLogUpdate(collisionNum,"locateRecord"); // if we escaped the loop, we were unable to find the item in the table -- return the first open location return pair (false,currentPos); // we didn't find the item } // return whether a record exists within hash table template bool hashTable ::searchRecord(hashType toFind){ return locateRecordPosition(toFind).first; // we didn't find the item } // return the contents of a record from the hash table template hashType hashTable ::returnRecord(hashType toReturn){ if (locateRecordPosition(toReturn).first) // if the record actually exists return myTable[locateRecordPosition(toReturn).second].data; else return hashType(); } // calculate hash value template int hashTable ::calculateHash(hashType toHash, int tableSize){ if (toHash void hashTable ::considerRehash(){ // check if we have used up more then half of the table, if we have, rehash if((activeRecords + 1) > ((signed) myTable.size() / 2)) rehashTable(); // check the current average of collisions // if the average number of collisions is greater then 20% of the table size (meaning it had to search through 20% of table), rehash else if((collisionLogAverage() > (myTable.size() * .20)) && (myTable.size() >= 100)) rehashTable(); // check the last operations number of collisions // if the number of collisions encounter is greater then 30% of the table size (meaning it had to search through 30% of table), rehash else if((collisionLog.back().first > (myTable.size() * .30)) && (myTable.size() >= 100)) rehashTable(); } // rehash the table template void hashTable ::rehashTable(){ // make a copy of the existing vector vector oldTable = myTable; // reallocate myTable myTable.resize(optimizeTableSize(myTable.size() * 2)); // double the size of the current table // clear myTable myTable.clear(); // copy the existing table over for (unsigned int i = 0; i int hashTable ::optimizeTableSize(int tableSize){ // if we are performing quadratic probing, we need to optimize the table size to be a prime number, to prevent loops if (!isPrime(tableSize)){ return nextPrime(tableSize); } // we only need to bother with optimizing the table size IF we are performing quadratic probing else return tableSize; } // determine if prime number template bool hashTable ::isPrime(int numberToEvaluate){ if(numberToEvaluate == 0) return true; numberToEvaluate = abs(numberToEvaluate); if(numberToEvaluate % 2 == 0) return true; for(int i = 3; i int hashTable ::nextPrime(int numberToEvaluate){ if (numberToEvaluate % 2 == 0) numberToEvaluate++; for (; !isPrime(numberToEvaluate); numberToEvaluate+=2) ; return numberToEvaluate; } // update collision log with a new entry template void hashTable ::collisionLogUpdate(int numberOfCollisions, string operationPerformed){ // add an entry to the log collisionLog.push_back(pair (numberOfCollisions, operationPerformed)); // verify we don't have more then 5 entires, if so, remove them while(collisionLog.size() > 5) collisionLog.pop_front(); } template int hashTable ::collisionLogAverage(){ // add the last five entries, then take their average // the log should be maxed at five entries.. so just add them all // average holder int average; // loop through log for (unsigned int i = 0; i
