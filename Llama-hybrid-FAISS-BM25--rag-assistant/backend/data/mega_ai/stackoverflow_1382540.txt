[site]: stackoverflow
[post_id]: 1382540
[parent_id]: 
[tags]: 
Static cast vs. dymamic cast for traversing inheritance hierarchies

I saw one book on C++ mentioning that navigating inheritance hierarchies using static cast is more efficient than using dynamic cast. Example: #include #include using namespace std; class Shape { public: virtual ~Shape() {}; }; class Circle : public Shape {}; class Square : public Shape {}; class Other {}; int main() { Circle c; Shape* s = &c; // Upcast: normal and OK // More explicit but unnecessary: s = static_cast (&c); // (Since upcasting is such a safe and common // operation, the cast becomes cluttering) Circle* cp = 0; Square* sp = 0; // Static Navigation of class hierarchies // requires extra type information: if(typeid(s) == typeid(cp)) // C++ RTTI cp = static_cast (s); if(typeid(s) == typeid(sp)) sp = static_cast (s); if(cp != 0) cout (s); // Conveniently gives an error message, while Other* op2 = (Other*)s; // does not } ///:~ However, both dynamic cast and static cast (as implemented above) need RTTI enabled for such navigation to work. It's just that dynamic cast requires the class hierarchy to be polymorphic (i.e. base class having at least one virtual function). Where does this efficiency gain for static cast come from? The book does mention that dynamic cast is the preferred way for doing type-safe downcasting.
