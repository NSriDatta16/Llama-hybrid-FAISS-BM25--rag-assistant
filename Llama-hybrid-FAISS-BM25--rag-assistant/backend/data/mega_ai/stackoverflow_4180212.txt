[site]: stackoverflow
[post_id]: 4180212
[parent_id]: 4180125
[tags]: 
Here is another possibility (using a Decorator object to add additional functionality to an existing repository): public sealed class Auditor : IRepository { private readonly IRepository _repository; public Auditor(IRepository repository) { _repository = repository; } public void Create(T entity) { //Auditing here... _repository.Create(entity); } //And so on for other methods... } The advantage to using a Decorator to add additional features is that it avoids the combinatorial explosion you began to see when you considered some repositories with auditing, some without, some using EF, some not. This gets progressively worse with every new feature that may or may not apply, often eventually devolving into configuration flags and messy internal branching.
