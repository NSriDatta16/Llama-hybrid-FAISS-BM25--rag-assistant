[site]: stackoverflow
[post_id]: 1032289
[parent_id]: 1000844
[tags]: 
Will try to answer my own question, since I haven't got any answer so far. My solution is to divide the problem in to two queries: first get the IDs of the items belonging to the customer in question: IQuery query = mySession.CreateQuery("select item.Id from Item as item " + "join item.Categories as category " + "join category.Customer customer " + "where customer.id=:id") .SetInt32("id", c.Id); IList itemIds = query.List(); I then fetch the actual items without involving any restriction on customer, just using the IDs. This way NHibernate knows it can get all categories from a single join, avoiding the N+1 selects mentioned in the questions: ICriteria criteria = mySession.CreateCriteria(typeof(MapItem)) .SetFetchMode("Categories", FetchMode.Eager) .SetResultTransformer(new DistinctRootEntityResultTransformer()) .Add(Expression.In("Id", itemIds)); IList items = criteria.List(); I couldn't come up with any solution that reduced this to a working, single query. Also, this approach forces the programmer to know a little too much about NHibernate's inner workings, and it's really easy to miss when you're writing a new query or criteria. A more general solution would be preferable.
