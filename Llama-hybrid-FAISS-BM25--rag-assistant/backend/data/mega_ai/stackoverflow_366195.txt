[site]: stackoverflow
[post_id]: 366195
[parent_id]: 366160
[tags]: 
I would recommend an object-oriented solution to this. Presumably your database is designed with tables that represent logical groupings of data. Each of these tables can likely be mapped onto a class in your system, although in some cases, it may be more than one table that makes up an object or there might be multiple classes that a table maps onto using subclassing. If you need to display data from multiple tables -- say a list of orders with some data from the customer associated with the order -- then you can either use views, joins, or stored procedures to construct an object of a view class that represents the selected data in the view/join/sp. Essentially what I am describing is an N-tier data architecture where you have a low-level data access layer that deals with data from a SQL orientation -- tables, views, stored procedures. Above this may be a generic object layer that deals with generic data objects and interfaces with the data access layer to store/retrieve objects from the database. Finally, above this you have a strongly-typed business object layer where your application works with classes that semantically linked to your application -- orders, customers, invoices, etc. There are many different patterns for implementing this type of general architecture and you should investigate several to see which fits your application needs the best. You might want to directly use an object-relational mapping like LINQ or nHibernate or you might want to layer a repository on top of an ORM. Personally, I think that structuring your application to deal with objects within the context of your domain, rather than simply as table data, will improve your code. It should improve understandability and maintainability. You will be able to encapsulate behavior within your domain classes rather than have it spread throughout your application. Of course, this assumes that you follow good design practices, but using OO design will encourage this. Separating out the business and data logic from your display logic will also make your application much more testable, as will breaking down monolithic classes into smaller, more focused classes that are interrelated.
