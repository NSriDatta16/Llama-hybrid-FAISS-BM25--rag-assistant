[site]: stackoverflow
[post_id]: 2765912
[parent_id]: 3021
[tags]: 
Consider an old, well known problem : In mathematics, the greatest common divisor (gcd) â€¦ of two or more non-zero integers, is the largest positive integer that divides the numbers without a remainder. The definition of gcd is surprisingly simple: where mod is the modulo operator (that is, the remainder after integer division). In English, this definition says the greatest common divisor of any number and zero is that number, and the greatest common divisor of two numbers m and n is the greatest common divisor of n and the remainder after dividing m by n . If you'd like to know why this works, see the Wikipedia article on the Euclidean algorithm . Let's compute gcd(10, 8) as an example. Each step is equal to the one just before it: gcd(10, 8) gcd(10, 10 mod 8) gcd(8, 2) gcd(8, 8 mod 2) gcd(2, 0) 2 In the first step, 8 does not equal zero, so the second part of the definition applies. 10 mod 8 = 2 because 8 goes into 10 once with a remainder of 2. At step 3, the second part applies again, but this time 8 mod 2 = 0 because 2 divides 8 with no remainder. At step 5, the second argument is 0, so the answer is 2. Did you notice that gcd appears on both the left and right sides of the equals sign? A mathematician would say this definition is recursive because the expression you're defining recurs inside its definition. Recursive definitions tend to be elegant. For example, a recursive definition for the sum of a list is sum l = if empty(l) return 0 else return head(l) + sum(tail(l)) where head is the first element in a list and tail is the rest of the list. Note that sum recurs inside its definition at the end. Maybe you'd prefer the maximum value in a list instead: max l = if empty(l) error elsif length(l) = 1 return head(l) else tailmax = max(tail(l)) if head(l) > tailmax return head(l) else return tailmax You might define multiplication of non-negative integers recursively to turn it into a series of additions: a * b = if b = 0 return 0 else return a + (a * (b - 1)) If that bit about transforming multiplication into a series of additions doesn't make sense, try expanding a few simple examples to see how it works. Merge sort has a lovely recursive definition: sort(l) = if empty(l) or length(l) = 1 return l else (left,right) = split l return merge(sort(left), sort(right)) Recursive definitions are all around if you know what to look for. Notice how all of these definitions have very simple base cases, e.g. , gcd(m, 0) = m. The recursive cases whittle away at the problem to get down to the easy answers. With this understanding, you can now appreciate the other algorithms in Wikipedia's article on recursion !
