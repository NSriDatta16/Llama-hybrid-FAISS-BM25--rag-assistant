[site]: stackoverflow
[post_id]: 4153443
[parent_id]: 2558021
[tags]: 
When your ResolveUri method gets a request for a "public" form of the URI like -//W3C//ELEMENTS XHTML Images 1.0//EN then does your method throw and wait for the subsequent web-like URI which begins with http:// ? Instead of throwing, I resolve the public URI to the corresponding http:// URI (and then in my GetEntity method I intercept requests to the http:// URIs). I therefore never have to throw, which I think is the right solution. That's a smart way to do it. How big is your dictionary? The library I pointed you to handles only XHTML 1.0, and there is just one public URI base that would need to be mapped. I'm using XHTML 1.1 which is 'modular' so I have to map about 40 files. Beware that the Framework's behaviour may have changed! I have a library (including my XhtmlUrlResolver class) which is built with the .NET Framework 2, but it's invoked differently depending on whether the application (which uses the library) is build for .NET 2 or .NET 4. With .NET 2, when my ResolveUri method always only delegated transparently to a XmlUrlResolver, then it would: Ask to ResolveUri the public of the DTD. Try to GetEntity the DTD from disk (throws one DirectoryNotFoundException) Try to GetEntity the DTD from http (which I'd serve from local resources) Try to GetEntity every other file from http (which I'd serve from local resources) With .NET 4 there was an extra call for every resource: Ask to ResolveUri the public of the sub-resource (e.g. the *.mod file), which my implementation just delegated to XmlUrlResolver Ask to GetEntity the 'resolved' public of the sub-resource, which wasn't really resolved at all, it just had an http-like prefix added (throws WebException) Throwing all those WebExceptions slowed down processing a lot, which is why I revisited this to look for a fix. Your suggestion, that I throw from ResolveUri, solved that problem, for which I thank you; but instead of throwing, returning something from ResolveUri is more elegant (and a bit faster: 40 fewer exceptions). Here's my current source code. using System; using System.Collections.Generic; using System.Text; using System.Reflection; using System.IO; using System.Xml; //don't obfuscate the file names of the embedded resources, //which are contained in a "Files" subfolder of the project [assembly: Obfuscation(Feature = "Apply to ModelText.ModelXml.Files.*: all", Exclude = true, ApplyToMembers = true)] namespace ModelText.ModelXml { /// /// This class provides local (i.e. faster) access to the XHTML DTD. /// /// /// Another way to implement this class is described in MSDN "Customizing the XmlUrlResolver Class" /// which shows as an example a "class XmlCachingResolver" /// and which is implemented using WebRequest and HttpRequestCachePolicy /// [System.Reflection.ObfuscationAttribute(Feature = "renaming", ApplyToMembers = true)] public class XhtmlUrlResolver : XmlResolver { XmlUrlResolver m_xmlUrlResolver = new XmlUrlResolver(); Assembly m_assembly = Assembly.GetExecutingAssembly(); public override object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn) { string uriString = absoluteUri.ToString(); if (s_resources.uriExists(uriString)) { //Console.WriteLine("XhtmlUrlResolver Found {0} -- {1}", uriString, DateTime.Now); //to get the filename of the embedded resource, remove the http: directory //this is OK because the filenames are unique and map 1-to-1 with resource names string filename = uriString.Substring(uriString.LastIndexOf('/') + 1); Stream stream = m_assembly.GetManifestResourceStream(typeof(XhtmlUrlResolver), "Files." + filename); return stream; } //Console.WriteLine("XhtmlUrlResolver Throwing {0} -- {1}", uriString, DateTime.Now); throw new ArgumentException(); //Console.WriteLine("XhtmlUrlResolver Getting {0} -- {1}", uriString, DateTime.Now); //object o = m_xmlUrlResolver.GetEntity(absoluteUri, role, ofObjectToReturn); //Console.WriteLine("XhtmlUrlResolver Got {0} -- {1}", uriString, DateTime.Now); //return o; } public override Uri ResolveUri(Uri baseUri, string relativeUri) { string resolved = s_resources.resolve(relativeUri); if (resolved != null) { //Console.WriteLine("ResolveUri resolving {0}, {1} -- {2}", baseUri, relativeUri, DateTime.Now); return new Uri(resolved); } //Console.WriteLine("ResolveUri passing {0}, {1} -- {2}", baseUri, relativeUri, DateTime.Now); return m_xmlUrlResolver.ResolveUri(baseUri, relativeUri); } public override System.Net.ICredentials Credentials { set { m_xmlUrlResolver.Credentials = value; } } static Resources s_resources = new Resources(); class Resources { Dictionary m_publicToUri = new Dictionary (); internal Resources() { for (int i = 0, n = array.GetLength(0); i
