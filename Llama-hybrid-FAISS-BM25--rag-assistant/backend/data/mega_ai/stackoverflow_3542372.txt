[site]: stackoverflow
[post_id]: 3542372
[parent_id]: 3542083
[tags]: 
I may be a somewhat useful abstraction to have a mental image of what's going on behind the scenes. But neither is true in any currently shipping version of the JIT compilers. Which perhaps is the crux of the issue, actual allocation location is a JIT compiler implementation detail. There are at least six places where a value type value can live with mainstream (x86 and x64) jitters: in a stack frame, put there by a local variable declaration or a method call in a CPU register, a very common optimization performed by the JIT in the Release build. And used to pass arguments to a method, the first two x86, four for x64. And local variables when possible on the FPU stack, used by the x86 jitter for floating point values on the GC heap, when the value is part of a reference type on the loader heap of the AppDomain, when the variable is declared static in thread-local storage when the variable has the [ThreadStatic] attribute. Reference type objects are commonly allocated on the GC heap. But I know of one specific exception, interned strings produced from literals in the source code are allocated in the AppDomain's loader heap. This completely behaves like an object at runtime, except that it isn't linked in to the GC heap, the collector simply cannot see it. Addressing your code snippet: yes, "a" is likely to be stored on the GG heap "x" is always passed in a CPU register on x86 and x64. "y" will be in a CPU register on x64, the stack on x86. "c" is likely to not exist at all, removed by the JIT compiler because the code has no effect.
