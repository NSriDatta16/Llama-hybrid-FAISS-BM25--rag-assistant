[site]: stackoverflow
[post_id]: 2344904
[parent_id]: 2344019
[tags]: 
You have asked this question before and were given the answer: fix your schema and your code . In that post the lock conflict was an IX lock, and a conflict on intent locks indicates high granularity locks, which in turn indicate table scans. You don't need lock hints, you just need an index and decent queries. Take for instance your other question, Why does row level locking not appear to work correctly in SQL server? where answer is trivial: Locks table needs to be organized by a clustered index on LockName: CREATE TABLE [dbo].[Locks]( [LockName] [varchar](50) NOT NULL, [Locked] [bit] NOT NULL, CONSTRAINT [PK_Locks] PRIMARY KEY CLUSTERED ([LockName])); GO insert into Locks (LockName, Locked) values ('A', 0); insert into Locks (LockName, Locked) values ('B', 0); GO On one session do this: begin transaction update Locks set Locked=1 output inserted.* where LockName = 'A'; On the other session do this: begin transaction update Locks set Locked=1 output inserted.* where LockName = 'B'; There is no update conflict, no blocking, no need for (wrong) hints, nothing. Just good ole' correct schema and query design. As a side note, the lock you describe here already exists and are called key-locks. They are the default, implicit mode SQL Server operates. Just how in the world do you imagine SQL Server can publish TPC-C benchmark numbers of 16000 tpc transaction per second? You have all the parallelism capacity you need in the server, you just need to read a book or two to understand how to use it. There is plenty of literature on the subject, you can start with Transaction Processing: Concepts and Techniques . Updated begin transaction select lockname from locks where lockname='A' update Locks Set locked=1 where lockname='A' This will never work, no matter how many/diverse lock hints you try. This is why you have the update with output syntax: begin transaction update Locks Set locked=1 output inserted.* where lockname='A' this ensures that you first update, then return what you've updated. This technique is fairly common in databases for exactly the semantics you seek: resource acquisition. In fact this technique is the cornerstone of the resource acquisition poster child: queue processing. See Queues paragraph in OUTPUT Clause . In queues you have a table of resources to be processed, and each thread grabs one, locks it and start processing: create table Resources ( id int identity(1,1) not null, enqueue_time datetime not null default getutcdate(), is_processing bit not null default 0, payload xml); create clustered index cdxResources on Resources (is_processing, enqueue_time); go -- enqueue: insert into Resources (payload) values (' This '); insert into Resources (payload) values (' That '); insert into Resources (payload) values (' Something '); insert into Resources (payload) values (' Anything '); Now from separate sessions, run this: --dequeue begin transaction; with cte as ( select top(1) * from Resources with(readpast) where is_processing = 0 order by enqueue_time) update cte set is_processing = 1 output inserted.*; You'll see each session grabs it's own resource, locks it and skipps everything locked by everybody else. It so happens I have in production a system that runs exactly like this, with over 5M resources int he table (they are web service payment processing requests), and dequeueing and processing around 50 per second, from 100 concurent processors (takes about 2sec. per call to process). On a piece of junk hardware. So it absolutely is possible.
