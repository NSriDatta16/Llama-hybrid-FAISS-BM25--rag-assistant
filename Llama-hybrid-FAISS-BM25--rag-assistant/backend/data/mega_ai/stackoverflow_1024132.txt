[site]: stackoverflow
[post_id]: 1024132
[parent_id]: 1022808
[tags]: 
Without knowing more about your specific application (ie how long messages take to process etc..) there will be lots of handwaving: Is this managed or unmanaged C++? Which ThreadPool are you using? QueueUserWorkItem? Your own pool via CreateIoCompletionPort? Or Vista's SubmitThreadpoolWork? I think platform is somewhat relevant as the nature of the Thread Pool is important. For example: If you use ( Completion Ports ) for your thread pool (ie CreateIoCompletionPort). You have some control on how many threads run concurrently (and hence on how many total threads are ultimately created). If you set the maximum number of concurrent threads to say 4. Windows will will attempt to only allow 4 threads to run concurrently. If all 4 threads are busy processing and you queue a 5th item then windows will not allow that item to run until one of the 4 if finished (reusing the thread). The only time this rule is broken is when threads are blocked (ie waiting on I/O), then more threads are allowed to run. This is the important thing to understand about Completion Ports, and why platform is relevant. It is very difficult to implement something like this without involving the Kernel. Knowing the difference between busy threads and blocked threads requires access to Thread states. Completion ports are very efficient with respect to number of context switches into the Kernel too. Back to your question: It would seem that you should have one thread to process/dispatch the messages and the message processing is all handled by pushing workers onto a thread pool. Let Completion ports handle the load balancing and concurrency. You message processing loop will never block and can continue to process messages. If the rate of incoming messages far exceeds your ability to process them then you will probably have to pay attention to your queue size and block when it grows too large.
