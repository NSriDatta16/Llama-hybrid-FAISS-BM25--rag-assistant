[site]: stackoverflow
[post_id]: 1131697
[parent_id]: 1100819
[tags]: 
I am afraid that this is not an answer people like to hear . Anyway, let me state my opinion. OOP should be viewed as one of the paradigms, not as the superior paradigm. OOP is good for solving certain kind of problems, like developing a GUI library. It also fits into the style of software development usually followed by large software companies - an elite team of designers or architects lays down the software design in UML diagrams or some other similar medium and a less enlightened team of developers translate that design into source code. OOP offer little benefit if you are working alone or with a small team of highly talented programmers. Then, it is better to use a language that supports multiple paradigms and will help you to come up with a prototype fast. Python, Ruby, Lisp/Scheme etc are good choices. The prototype is your design. Then you improve on that. Use the paradigm that is best to solve the problem at hand. If needed, optimize hot spots with extensions written in C or some other systems language. By using one of these languages, you also get extensibility for free, not just at the programmer level but also at the user level. Languages like Lisp can dynamically generate and execute code, which means your users can extend the application by writing small code snippets, in the language that the software itself is coded! Or if you choose to write the program in C or C++, consider embedding an interpreter for a small language like Lua. Expose functionalities as plugins written in that language. I think that, most of the time OOP and OOD create software that are victims of over design. To summarize, my preferred way to write software is: Use a dynamic language. Write the design (prototype) in that language itself. If necessary, optimize certain areas using C/C++. Provide extensibility by way of the interpreter of the implementation language itself. The last feature enables the software to easily adapt to specific user (including myself!) requirements.
