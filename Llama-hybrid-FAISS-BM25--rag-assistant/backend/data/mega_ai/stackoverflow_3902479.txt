[site]: stackoverflow
[post_id]: 3902479
[parent_id]: 
[tags]: 
OpenGL: Render to FBO using multiple textures

I'm experimenting with a renderer. What I want is to write a color buffer and a normal buffer to two separate textures. I got that part figured out. However, the color buffer is supposed to be a combination of two textures. This should do the trick: glActiveTexture(GL_TEXTURE0_ARB); glEnable(GL_TEXTURE_2D); g_Tex->Bind(); glActiveTexture(GL_TEXTURE1_ARB); glEnable(GL_TEXTURE_2D); g_TexNormal->Bind(); g_Shader->Enable(); RenderScene(); g_Shader->Disable(); glActiveTexture(GL_TEXTURE1_ARB); glDisable(GL_TEXTURE_2D); glActiveTexture(GL_TEXTURE0_ARB); glDisable(GL_TEXTURE_2D); And this is the fragment shader: (GLSL) uniform sampler2D tex_diffuse; uniform sampler2D tex_normal; void main() { gl_FragColor = texture2D(tex_diffuse, gl_TexCoord[0].st); //gl_FragColor = texture2D(tex_normal, gl_TexCoord[0].st); } However, the second texture is the same as the first! Whichever texture is attached to GL_TEXTURE0 is the one used for both samplers. Initializing the FBO: glGenFramebuffersEXT(1, &g_FBOColor); glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, g_FBOColor); glGenTextures(1, &g_FBOTexColor); glBindTexture(GL_TEXTURE_2D, g_FBOTexColor); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0); glBindTexture(GL_TEXTURE_2D, 0); glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, g_FBOTexColor, 0); glGenTextures(1, &g_FBOTexNormal); glBindTexture(GL_TEXTURE_2D, g_FBOTexNormal); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0); glBindTexture(GL_TEXTURE_2D, 0); glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, g_FBOTexNormal, 0); glGenTextures(1, &g_FBOTexDepth); glBindTexture(GL_TEXTURE_2D, g_FBOTexDepth); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24, w, h, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL); glBindTexture(GL_TEXTURE_2D, 0); glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_TEXTURE_2D, g_FBOTexDepth, 0); glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0); Complete render section: glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, g_FBOColor); glPushAttrib(GL_VIEWPORT_BIT | GL_COLOR_BUFFER_BIT); glViewport( 0, 0, Window::GetSingleton()->GetWidth(), Window::GetSingleton()->GetHeight() ); GLenum buffers[] = { GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT1_EXT }; glDrawBuffers(2, buffers); //glReadBuffer(GL_COLOR_ATTACHMENT0_EXT | GL_COLOR_ATTACHMENT1_EXT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glActiveTexture(GL_TEXTURE0_ARB); glEnable(GL_TEXTURE_2D); g_Tex->Bind(); glActiveTexture(GL_TEXTURE1_ARB); glEnable(GL_TEXTURE_2D); g_TexNormal->Bind(); g_Shader->Enable(); RenderScene(); g_Shader->Disable(); glActiveTexture(GL_TEXTURE1_ARB); glDisable(GL_TEXTURE_2D); glActiveTexture(GL_TEXTURE0_ARB); glDisable(GL_TEXTURE_2D); glPopAttrib(); glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0); Thanks in advance.
