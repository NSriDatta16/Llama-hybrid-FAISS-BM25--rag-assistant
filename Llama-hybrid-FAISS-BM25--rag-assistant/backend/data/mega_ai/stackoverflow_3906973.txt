[site]: stackoverflow
[post_id]: 3906973
[parent_id]: 3891888
[tags]: 
Taking these one at a time: What are the security considerations of rebuilding .Net's session handling: .Net's session handling only offers very limited security for most situations and none for others. If the goal is to prevent the data from going to the browser, that it does. However, if the goal is to ensure only the authorized user can leverage that data.. well, it doesn't. Rebuilding this as is is trivial and leads us to your other questions. Does encrypting the token actually offer real security? No. It doesn't. Anything you send to the browser can be compromised. If that data can be intercepted and replayed then it doesn't matter. There are solutions though... Is generating a long random token as secure as signing a smaller token? Considering neither offer any level of security, then yes they are equivalent. If I was to go about rebuilding asp.net's session handling then I'd add one thing: A randomly changing value indicating the next accepted "request token". This should be as non-guessable as possible. This key would be sent to the browser on each response, and sent back by each request. The site would validate that the key was valid for this request and generate a new one for the response. This would ensure that even if the data stream between the browser and server was recorded, it couldn't be replayed. For example: Browser makes initial request to server. Server responds with session ID ABC and Request Token 1 Browser makes second request to server passing ABC and 1. Server validates the combination, performs the request and responds with Token 453. Browser makes third request to server passing ABC and 453. Server validates the combination, performs the request and responds with Token 23 Bad guy replays step 2, passing ABC and 1. Server sees invalid request, alerts site owner and responds with a security violation error. In this scenario the ONLY way for the bad guys to replay is if they send a brand new request with the last token received. However, as soon as the real browser sends a new request they'll receive a nice security violation notice and you'll be notified. There are many other things you can do from here to lock it down further. This was only one idea to mitigate a particular type of attack. UPDATE One question in the comments was about concurrent requests. Generally speaking, a browser will issue multiple GET requests for artifacts like CSS, Images, Javascript, etc. These should be not be included in the security test. However, every POST request, which a browser will only make one of at a time, should trigger the validation and have a new value sent back to the browser.
