[site]: stackoverflow
[post_id]: 5040637
[parent_id]: 5040467
[tags]: 
With the edit, it sounds like the data is pretty simple flat records. Since the volume is high, I would probably look at file-based storage - so it then becomes a matter of format. CSV/TSV is pretty easy to write, and with suitable streaming readers (like this one ) you won't have to buffer all the data in memory first. Of course, if your displays need all the data in memory, that goes out the window. For large volume, sheer bandwidth becomes the main bottleneck, plus processing time. CSV and friends typically compress (gzip etc) very nicely, but take CPU. Personally, I'm a long-time fan of "protocol buffers", and it would seem a nice fit here - it is well-suited to streaming access, is low bandwidth, and is binary - you get the benefits of smaller IO costs without the CPU overhead of compression. Plus it is more object-based, so it is easier to apply to your existing data without any extra interpretation steps. I'm not entirely sure if I'm answering the same question you're asking - so I'll stop there - but please feel free to clarify anything I've got horribly wrong. Here's a basic test rig to show some typical usages of the two methods discussed above: using System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Text; using ProtoBuf; static class Program { static void Main() { var rand = new Random(123456); var timeOrigin = new DateTime(2010,1,1); Serializer.PrepareSerializer (); Console.WriteLine("Writing .proto ..."); const int LOOP = 500000; using (var file = File.Create("raw.data")) { var watch = Stopwatch.StartNew(); double total = 0; for (int i = 0; i (file, PrefixStyle.Base128, Serializer.ListItemTag)) { total += obj.Value; } watch.Stop(); Console.WriteLine(total + " (check again)"); Console.WriteLine(watch.ElapsedMilliseconds + "ms"); } Console.WriteLine(); Console.WriteLine("Reading tsv ..."); using (var file = File.OpenRead("raw.tsv")) using (var reader = new StreamReader(file)) { var watch = Stopwatch.StartNew(); double total = 0; foreach (var obj in Read(reader)) { total += obj.Value; } watch.Stop(); Console.WriteLine(total + " (check again)"); Console.WriteLine(watch.ElapsedMilliseconds + "ms"); } } private static void Write(TextWriter writer, MyFunRecord obj) { writer.Write(obj.Id); writer.Write('\t'); writer.Write(obj.Name); writer.Write('\t'); writer.Write(obj.When); writer.Write('\t'); writer.Write(obj.Value); writer.Write('\t'); writer.Write(obj.Count); writer.WriteLine(); } private static IEnumerable Read(TextReader reader) { string line; char[] delim = new[] { '\t' }; while ((line = reader.ReadLine()) != null) { string[] parts = line.Split(delim); var obj = new MyFunRecord(); obj.Id = int.Parse(parts[0]); obj.Name = parts[1]; obj.When = DateTime.Parse(parts[2]); obj.Value = double.Parse(parts[3]); obj.Count = int.Parse(parts[4]); yield return obj; } } static string RandomString(Random rand) { int len = rand.Next(1, 20); var sb = new StringBuilder(len); for (int i = 0; i
