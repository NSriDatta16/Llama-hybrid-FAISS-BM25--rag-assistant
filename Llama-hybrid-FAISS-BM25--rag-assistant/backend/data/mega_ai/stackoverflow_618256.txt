[site]: stackoverflow
[post_id]: 618256
[parent_id]: 614215
[tags]: 
Generally, if I'm having a one-size-fits-all table (and I'm not arguing they're not useful), I tend to allow a range of datatypes for storage, and enfore the types. E.g. CREATE TABLE MetaDataType ( MetaDataID int IDENTITY(1,1) not null, MetaDataType varchar(10) not null, constraint PK_MetaDataType PRIMARY KEY (MetaDataID), constraint UQ_MetaDataType_TypeCheck UNIQUE (MetaDataID,MetaDataType), constraint CK_MetaDataType CHECK (MetaDataType in ('INT','CHAR','FLOAT')) ) And then the meta data table would look like: CREATE TABLE MetaData ( FileID int not null, MetaDataID int not null, MetaDataType varchar(10) not null, IntValue int null, CharValue varchar(max) null, FloatValue float null, constraint PK_MetaData PRIMARY KEY (FileID,MetaDataID), constraint FK_MetaData_Files FORIEGN KEY (FileID) references /* File table */, constraint FK_MetaData_Types FOREIGN KEY (MetaDataID,MetaDataType) references MetaDataTypes (MetaDataID,MetaDataType), constraint CK_MetaData_ValidTypes ((MetaDataType = 'INT' or IntValue is null) and (MetaDataType = 'CHAR' or CharValue is null) and (MetaDataType = 'FLOAT' or FloatValue is null)) ) The whole point being that 1) You store for each Meta data item the expected type, and 2) You enforce that in the MetaData table.
