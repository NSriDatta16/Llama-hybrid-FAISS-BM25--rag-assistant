[site]: stackoverflow
[post_id]: 3192152
[parent_id]: 3185511
[tags]: 
Let’s start by defining the type of blending you’re looking for. It sounds like you want your buffer to start out white and have your color mixing obey a subtractive color model . The easiest way to do that is to define the result of mixing C brush over C dst as: C = C brush × C dst Notice that using this equation, the result of mixing yellow (1, 1, 0) and cyan (0, 1, 1) is green (0, 1, 0), which is what you’d expect. Having a brush that fades at the edges complicates things slightly. Let’s say you now have a brush opacity value A brush —where A brush is 1, you want your brush color to blend at full strength, and where A brush is 0, you want the original color to remain. Now what you're looking for is: C = ( C brush × C dst ) × A brush + C dst × (1 - A brush ) Since blending in OpenGL ES results computes C = C src × S + C dst × D , we can get exactly what we want if we make the following substitutions: C src = C brush × A brush A src = A brush S = C dst D = (1 - A brush ) Now let’s look at what it takes to set this up in OpenGL ES. There are 4 steps here: Change the background color to white. Change the brush texture to an alpha texture. By default, GLPaint creates its brush texture as an RGBA texture with the brush shape drawn in the RGB channels, which is somewhat unintuitive. For reasons you’ll see later, it’s useful to have the brush shape in the alpha channel instead. The best way to do this is by drawing the brush shape in grayscale with CG and creating the texture as GL_ALPHA instead: CGColorSpaceRef brushColorSpace = CGColorSpaceCreateDeviceGray(); brushData = (GLubyte *) calloc(width * height, sizeof(GLubyte)); brushContext = CGBitmapContextCreate(brushData, width, width, 8, width, brushColorSpace, kCGImageAlphaNone); CGColorSpaceRelease(brushColorSpace); glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, width, height, 0, GL_ALPHA, GL_UNSIGNED_BYTE, brushData); Set up C src , A src , S and D . After switching to an alpha texture, assuming that your brush color is still being specified via glColor4f , you’ll find that the default OpenGL ES texture environment will give you this: C src = C brush A src = A brush In order to obtain the extra multiplication by A brush for C src , you’ll need to set up a custom combiner function in the texture environment as follows (you can do this in the initialization function for PaintingView ): glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE); glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_ALPHA); Changing GL_TEXTURE_ENV_MODE to GL_COMBINE gives you C brush × 0 (to see why this is the case, read section 3.7.12 in the OpenGL ES 1.1 specification ). Changing GL_OPERAND0_RGB to GL_SRC_ALPHA changes the second term in the multiplication to what we want. To set up S and D , all you need to do is change the blending factors (this can be done where the blending factors were set up before): glBlendFunc(GL_DST_COLOR, GL_ONE_MINUS_SRC_ALPHA); Ensure that any modifications to A brush outside of the brush texture are reflected across other channels. The above modifications to the texture environment only take into account the part of the brush opacity that come from the brush texture. If you modify the brush opacity in the alpha channel elsewhere (i.e. by scaling it, as in AppController ), you must make sure that you make the same modifications to the other three channels: glColor4f(components[0] * kBrushOpacity, components[1] * kBrushOpacity, components[2] * kBrushOpacity, kBrushOpacity); Note that the downsides to implementing your brushes with a subtractive color model are that colors can only get darker, and repeatedly drawing the same color over itself can eventually result in a color shift if it’s not one of the primary subtractive colors (cyan, magenta, or yellow). If, after implementing this, you find that the color shifts are unacceptable, try changing the brush texture to an alpha texture as in step 2 and changing the blend factors as follows: glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); This will give you simple painting of your brush color over white, but no actual mixing of colors (the brush colors will eventually overwrite the background).
