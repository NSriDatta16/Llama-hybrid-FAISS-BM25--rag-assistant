[site]: stackoverflow
[post_id]: 5527368
[parent_id]: 5522320
[tags]: 
All these examples have an atrocious level a complexity for something so simple as: create table gastropod( average_length numeric ); create table slug( like gastropod, id serial primary key, is_mantle_visible boolean ); create table snail( like gastropod, id serial primary key, average_shell_volume numeric ); \d snail; Column | Type | Modifiers ----------------------+---------+---------------------------------------------------- average_length | numeric | id | integer | not null default nextval('snail_id_seq'::regclass) average_shell_volume | numeric | Indexes: "snail_pkey" PRIMARY KEY, btree (id) Before you say this is not an answer think about the requirements. every row in 'gastropod' has exactly one corresponding row in 'snail' or 'slug' (but not both) every row in 'slug' has exactly one corresponding row in 'gastropod' every row in 'snail' has exactly one corresponding row in 'gastropod' Having the column in the table is an equivalence of data integrity without all the nonsense. Note: LIKE in the DDL can copy all the columns (even constraints and indexes in 9.0) into the new table. So you can sort of fake inheritance.
