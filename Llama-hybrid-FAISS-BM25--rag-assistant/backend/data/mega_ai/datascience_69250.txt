[site]: datascience
[post_id]: 69250
[parent_id]: 
[tags]: 
UNet Model accuracy is stuck at exact 0.5 (neither more or less) (No class imbalance, tried tuning learning rate)

This is using PyTorch I have been trying to implement UNet model on my images, however, my model accuracy is always exact 0.5. Loss does decrease. I have also checked for class imbalance. I have also tried playing with learning rate. Learning rate affects loss but not the accuracy. My architecture below ( from here ) """ `UNet` class is based on https://arxiv.org/abs/1505.04597 The U-Net is a convolutional encoder-decoder neural network. Contextual spatial information (from the decoding, expansive pathway) about an input tensor is merged with information representing the localization of details (from the encoding, compressive pathway). Modifications to the original paper: (1) padding is used in 3x3 convolutions to prevent loss of border pixels (2) merging outputs does not require cropping due to (1) (3) residual connections can be used by specifying UNet(merge_mode='add') (4) if non-parametric upsampling is used in the decoder pathway (specified by upmode='upsample'), then an additional 1x1 2d convolution occurs after upsampling to reduce channel dimensionality by a factor of 2. This channel halving happens with the convolution in the tranpose convolution (specified by upmode='transpose') Arguments: in_channels: int, number of channels in the input tensor. Default is 3 for RGB images. Our SPARCS dataset is 13 channel. depth: int, number of MaxPools in the U-Net. During training, input size needs to be (depth-1) times divisible by 2 start_filts: int, number of convolutional filters for the first conv. up_mode: string, type of upconvolution. Choices: 'transpose' for transpose convolution """ class UNet(nn.Module): def __init__(self, num_classes, depth, in_channels, start_filts=16, up_mode='transpose', merge_mode='concat'): super(UNet, self).__init__() if up_mode in ('transpose', 'upsample'): self.up_mode = up_mode else: raise ValueError("\"{}\" is not a valid mode for upsampling. Only \"transpose\" and \"upsample\" are allowed.".format(up_mode)) if merge_mode in ('concat', 'add'): self.merge_mode = merge_mode else: raise ValueError("\"{}\" is not a valid mode for merging up and down paths.Only \"concat\" and \"add\" are allowed.".format(up_mode)) # NOTE: up_mode 'upsample' is incompatible with merge_mode 'add' if self.up_mode == 'upsample' and self.merge_mode == 'add': raise ValueError("up_mode \"upsample\" is incompatible with merge_mode \"add\" at the moment " "because it doesn't make sense to use nearest neighbour to reduce depth channels (by half).") self.num_classes = num_classes self.in_channels = in_channels self.start_filts = start_filts self.depth = depth self.down_convs = [] self.up_convs = [] # create the encoder pathway and add to a list for i in range(depth): ins = self.in_channels if i == 0 else outs outs = self.start_filts*(2**i) pooling = True if i Parameters are : device = torch.device('cuda' if torch.cuda.is_available() else 'cpu') x,y = train_sequence[0] ; batch_size = x.shape[0] model = UNet(num_classes = 2, depth=10, in_channels=5, merge_mode='concat').to(device) optim = torch.optim.Adam(model.parameters(),lr=0.01, weight_decay=1e-3) criterion = nn.BCEWithLogitsLoss() #has sigmoid internally epochs = 1000 My function for calculating loss and accuracy is below: def get_loss_train(model, train_sequence): """ Calculate loss over train set """ model.eval() total_acc = 0 total_loss = 0 for idx in range(len(train_sequence)): with torch.no_grad(): X, y = train_sequence[idx] images = Variable(torch.from_numpy(X)).to(device) # [batch, channel, H, W] masks = Variable(torch.from_numpy(y)).to(device) outputs = model(images) loss = criterion(outputs, masks) preds = torch.argmax(outputs, dim=1).float() acc = accuracy_check_for_batch(masks.cpu(), preds.cpu(), images.size()[0]) total_acc = total_acc + acc total_loss = total_loss + loss.cpu().item() return total_acc/(len(train_sequence)), total_loss/(len(train_sequence)) This is my first post on this forum so pardon me if I am missing out on any details. Can someone help me identify as why is accuracy always exact 0.5?
