[site]: stackoverflow
[post_id]: 2105796
[parent_id]: 2105716
[tags]: 
Why does this happen if I have the guards in place? I thought that they prevented the header from being read in after the first access. Include guards make sure that a header is included only once in one file (translation unit). For multiple files including the header, you want the header to be included in each file. By defining , as opposed to declaring variables with external linkage (global variables) in your header file, you can only include the header in once source file. If you include the header in multiple source files, there will be multiple definitions of a variable, which is not allowed in C++. So, as you have found out, it is a bad idea to define variables in a header file for precisely the reason above. Why do the numerous enums in this header not also give the LNK4006 warnings? Because, they don't define "global variables", they're only declarations about types, etc. They don't reserve any storage. If I add static before the signature, I don't get the warning. What are the implications of doing it this way. When you make a variable static , it has static scope . The object is not visible outside of the translation unit (file) in which it is defined. So, in simple terms, if you have: static int i; in your header, each source file in which you include the header will get a separate int variable i , which is invisible outside of the source file. This is known as internal linkage . Is there a better way to do this that avoids the error, but lets me declare the array in the header. I would really hate to have a cpp file just for an array definition. If you want the array to be one object visible from all your C++ files, you should do: extern int array[SIZE]; in your header file, and then include the header file in all the C++ source files that need the variable array . In one of the source ( .cpp ) files, you need to define array : int array[SIZE]; You should include the header in the above source file as well, to allow for catching mistakes due to a difference in the header and the source file. Basically, extern tells the compiler that " array is defined somewhere, and has the type int , and size SIZE ". Then, you actually define array only once. At link stage, everything resolves nicely.
