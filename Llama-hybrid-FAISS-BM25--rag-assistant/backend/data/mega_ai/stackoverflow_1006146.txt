[site]: stackoverflow
[post_id]: 1006146
[parent_id]: 1005685
[tags]: 
Indeed, this does work. Regrettably, you have to write globalObject().MemberFunction(), instead of globalObject.MemberFunction(), resulting in somewhat confusing and inelegant client code. But the most important thing is that it works, and that it is failure proof, ie. it is not easy to bypass the correct usage. Program correctness should be your first priority. Also, IMHO, the () above is purely stylistic - ie. completely unimportant. Depending on your platform, be careful of too much dynamic initialization. There is a relatively small amount of clean up that can take place for dynamic initializers (see here ). You can solve this problem using a global object container that contains members different global objects. You therefore have: Globals & getGlobals () { static Globals cache; return cache; } There is only one call to ~Globals() in order to clean up for all global objects in your program. In order to access a global you still have something like: getGlobals().configuration.memberFunction (); If you really wanted you could wrap this in a macro to save a tiny bit of typing using a macro: #define GLOBAL(X) getGlobals().#X GLOBAL(object).memberFunction (); Although, this is just syntactic sugar on your initial solution.
