[site]: stackoverflow
[post_id]: 4497984
[parent_id]: 4497787
[tags]: 
Updated Answer ...after tobyodavies pointed out (in the nicest of ways) that I was being thick. If you explicitly retrieve the attribute , rather than the reflected property, we'll get back the string from the DOM, not a function, and so don't have to worry about function decompilation (see notes below). The remainder of the below is a bit paranoid (because I originally was working from function decompilation), but still: jQuery(function($) { var link, onclick, url, index; link = $('#theLink')[0]; // IMPORTANT: Getting the *attribute* here, not the reflected property. // jQuery's `attr` function will give you the property, so go direct. onclick = link.getAttribute("onclick"); display("onclick = " + onclick); index = onclick.indexOf("load('"); if (index 0) { url = url.substring(0, index); } } display("url = " + url); function display(msg) { $(" ").html(msg).appendTo(document.body); } });​ Live example Original Answer Note that here there be dragons . The value of the onclick reflected property by the time you're accessing it in the DOM is a function object on most browsers, and so you'll have to use Function#toString , which has never been standardized and some mobile browsers are known to just return "[object Function]". Most desktop browsers return a decompiled version of the event handler, but that can change at any time. But now you're aware of the dragons, you can get it that way. Here's a somewhat paranoid approach: jQuery(function($) { var link, onclick, url, index; link = $('#theLink')[0]; onclick = "" + link.onclick; display("onclick = " + onclick); index = onclick.indexOf("load('"); if (index 0) { url = url.substring(0, index); } } display("url = " + url); function display(msg) { $(" ").html(msg).appendTo(document.body); } });​ Live example
