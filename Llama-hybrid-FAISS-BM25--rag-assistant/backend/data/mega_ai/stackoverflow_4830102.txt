[site]: stackoverflow
[post_id]: 4830102
[parent_id]: 4829738
[tags]: 
You should consider using SciPy's convolution filter or the generic_filter . This is still computationally intensive, but way faster than looping. Normally, when doing this type of averaging, the central element is also included. Note that these solutions also apply to multi-dimensional arrays. from scipy import ndimage footprint = scipy.array([[0,0.25,0],[0.25,0,0.25],[0,0.25,0]]) filtered_array = scipy.convolve(array, footprint) OR from scipy import ndimage def myfunction(window): return (window[0,1] + window[1,0] + window[1,2] + window[2,1]) / 4 filtered_array = scipy.generic_filter(array, myfunction, size=3)
