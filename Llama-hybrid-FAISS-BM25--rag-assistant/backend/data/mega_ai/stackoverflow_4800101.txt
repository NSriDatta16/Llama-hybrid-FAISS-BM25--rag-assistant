[site]: stackoverflow
[post_id]: 4800101
[parent_id]: 4799890
[tags]: 
First off, let me just say that you are not competent to implement this system securely. I'm not either. Almost no one is . You need a security professional to do this work; if you try to roll your own security you will get it wrong and you will produce a system that can be compromised by attackers. That out of the way: you have clearly identified the weakness of your system. You are storing a password equivalent ; if an attacker obtains the password equivalent then it does not matter whether they have the password or not; they have information sufficient to impersonate the user. The solution is clear. If it hurts when you do that, don't do that. Do not store a password equivalent if the system which stores it cannot be trusted to be robust against attack. If you are hell bent on storing a password equivalent then store it in a storage which is more difficult for attackers to obtain access to than the file system. If you are really determined to store dangerous stuff on behalf of the user then you can use the Windows data protection API to store it in an encrypted storage that is encrypted with the user's credentials: http://msdn.microsoft.com/en-us/library/ms995355.aspx But better to not store the password equivalent in the first place. Suppose you do not store the password equivalent. You are not done yet. You still need to consider replay attacks. Suppose the attacker eavesdrops upon the unsecured channel. The user types in their password, it is hashed and sent to the server. The eavesdropper records the hashed password, and now they have it. To solve this, the server sends a random number to the client. The number will never be used again; it is one-time-only. The client xors the hashed password with the random number and then encrypts the result with the public key of the server. The encrypted xor'd message is sent to the server. The server decrypts the hash using its private key, xors it with the random number it sent previously, and determines that the decrypted hash matches the password equivalent it is storing. Now the eavesdropper cannot replay the captured password equivalent because they will never see the same random number again. Now, this is vulnerable to the man-in-the-middle attack if the client does not know the public key of the server! If the server sends the public key to the client then the man-in-the-middle can intercept the server's public key and replace it with his public key. Now the man-in-the-middle can provide the public key and the "random" challenge, and the client will give up the password equivalent. Like I said, this is hard stuff. Don't try to do it yourself. Get a professional.
