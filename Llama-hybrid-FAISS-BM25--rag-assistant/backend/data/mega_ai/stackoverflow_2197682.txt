[site]: stackoverflow
[post_id]: 2197682
[parent_id]: 2197141
[tags]: 
I cannot think of an example, and I've been trying nearly since you asked. As pointed out by Jagannath , it's been long-standing advice not to specialize functions, but instead overload them or use a traits class (which can be specialized, even partially specialized). For example, if you need to swap two items, then relying on overloads is better (more predictable and more extensible): template void f() { T a, b; using std::swap; // brings std::swap into scope as "fallback" swap(a, b); // unqualified call (no "std::") so ADL kicks in // also look at boost::swap } And how you write a swap for your types: // the cleanest way to do it for a class template: template struct Ex1 { friend void swap(Ex1& a, Ex1& b) { /* do stuff */ } }; // you can certainly place it outside of the class instead---but in the // same namespace as the class---if you have some coding convention // against friends (which is common, but misguided, IMHO): struct Ex2 {}; void swap(Ex2& a, Ex2& b) { /* do stuff */ } Both of which allow Argument Dependent Lookup (ADL). Other functions, such as a stringify/str or a repr (representation) can similarly be non-members and take advantage of ADL through overloading: struct Ex3 { friend std::string repr(Ex3 const&) { return " "; } }; std::string repr(bool b) { return b ? "true" : "false"; } // possible fallback: template std::string repr(T const& v) { std::ostringstream out; out To look at it another way, it would be nice if function templates could serve as a registry for specific implementations, but due to limits (in current C++, not sure exactly what C++0x brings here) they don't work as well as either overloading or class templates for that registry purpose. There is one use that is convenient but not important : easily defining certain specializations to be in a separate library, possibly a shared library (.so or .dll). This is convenient because it requires minimal changes to the generic template, but not important because it seems rare to me (in the wild, and certainly is rare in my experience) and implementors can still use either overloading or forwarding to a fully-specialized class template's unspecialized method.
