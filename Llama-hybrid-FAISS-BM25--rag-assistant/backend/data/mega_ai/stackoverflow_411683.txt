[site]: stackoverflow
[post_id]: 411683
[parent_id]: 411422
[tags]: 
Building off my prior posting... ATTENTION: All memory addresses here are fictional. I'm just making them up to illustrate a point. Given: int data[] = {10,11,12}; We now have: 0xffff0000-0xffff0003 with a value of (int)(10) 0xffff0004-0xffff0007 with a value of (int)(11) 0xffff0008-0xffff000b with a value of (int)(12) (I'm not going to get into big-endian vs little-endian byte ordering here.) If we have: int * p = data; We now have another memory location somewhere else, say: 0xaaaa0000-0xaaaa0003 with a value of (int*)0xffff0000 We can use p[1] [or *(p + 1)] to refer to *(int*)(0xffff0004) [=11] as sizeof(int)=4 and 0xffff0000+sizeof(int) = 0xffff0004. If we have: void * v = data; We now have another memory location somewhere else, say: 0xbbbb0000-0xbbbb0003 with a value of (void*)0xffff0000. However, void doesn't have any associated sizeof() information. We can't increment or decrement the pointer. We can't dereference to access the data stored in 0xffff0000. We can only utilize the value as a raw memory address. If we want to use the data stored in (void*)0xffff0000, we first need to cast it to an appropriate type. That said, (void *) is still quite useful as a means of passing addresses to arbitrary data structures around. For instance, memset(). It doesn't matter whether I'm zero'ing out a struct tm or a struct sockaddr . We just need a pointer to the struct and its size. (This should go without saying, but... Beware using memset to zero out a class instance and, in doing so, overwriting the virtual pointer table.)
