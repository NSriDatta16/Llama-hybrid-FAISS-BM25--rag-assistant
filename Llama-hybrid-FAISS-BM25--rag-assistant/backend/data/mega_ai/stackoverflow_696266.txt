[site]: stackoverflow
[post_id]: 696266
[parent_id]: 386484
[tags]: 
You can always handle the WM_WINDOWPOSCHANGING message, this let's you control the window size and position during the resizing process (as opposed to fixing things after the user finished resizing). Here is how you do it in WPF, I combined this code from several sources, so there could be some syntax errors in it. internal enum WM { WINDOWPOSCHANGING = 0x0046, } [StructLayout(LayoutKind.Sequential)] internal struct WINDOWPOS { public IntPtr hwnd; public IntPtr hwndInsertAfter; public int x; public int y; public int cx; public int cy; public int flags; } private void Window_SourceInitialized(object sender, EventArgs ea) { HwndSource hwndSource = (HwndSource)HwndSource.FromVisual((Window)sender); hwndSource.AddHook(DragHook); } private static IntPtr DragHook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handeled) { switch ((WM)msg) { case WM.WINDOWPOSCHANGING: { WINDOWPOS pos = (WINDOWPOS)Marshal.PtrToStructure(lParam, typeof(WINDOWPOS)); if ((pos.flags & (int)SWP.NOMOVE) != 0) { return IntPtr.Zero; } Window wnd = (Window)HwndSource.FromHwnd(hwnd).RootVisual; if (wnd == null) { return IntPtr.Zero; } bool changedPos = false; // *********************** // Here you check the values inside the pos structure // if you want to override tehm just change the pos // structure and set changedPos to true // *********************** if (!changedPos) { return IntPtr.Zero; } Marshal.StructureToPtr(pos, lParam, true); handeled = true; } break; } return IntPtr.Zero; }
