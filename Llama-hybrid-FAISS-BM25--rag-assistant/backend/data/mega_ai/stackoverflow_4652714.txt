[site]: stackoverflow
[post_id]: 4652714
[parent_id]: 4651687
[tags]: 
Since you haven't provided any debug info I can only guess as to what's wrong, so I'll ask you some questions. Does it in fact instantiate the firstviewCell property with the nib. If the cell is not connected to the firstviewCell property of the File Owner (in the nib) it won't work. Otherwise if the fetchedResultsController doesn't have anything in it you'll get an error if you try to access the data. If the nslog fires then you probably didn't get an error, which means that your Cars objects are being fetched theres just nothing in them. to see whats in the fetchedResultsController call NSLog(@"Fetched Objects: %@",[[fetchedResultsController fetchedObjects] description]); Keep in mind though, that fetchedObjects is only updated when you call performFetch. Since you say carresults gets filled when you restart the app it may be possible that you need to call saveContext for the results to get loaded. The only reason for this is if you create the data at runtime, before the table view gets loaded. Otherwise I would assume you have the table view set as the fetched results controller's delegate so that it gets informed of any changes and responds appropriately. The app delegate usually does this on applicationWillResign active or applicationWillTerminate (applicationWillTerminate doesn't seem to get called by iOS4 during normal closing).The only other thing I could think of is that maybe your SectionInfo object might contain the wrong information, try debugging that too. Good Luck, Rich Edit: I appologize, the save context method is a method added to your appdelegate when you create an app based on core data. a good way to make a core data stack is to wrap it in an NSObject, it can be useful to make it a singleton ,unless of course you need concurrency in which case it gets really complicated. This is the implementation including the save context function: // CoreDataStack.h // do not call alloc, retain, release, copy or especially copyWithZone: (because I didn't bother to override it since you shouldn't try to create this in anything but the main thread, and definatly don't dispatchasync this object's methods) #import #import #define kYourAppName @"This should be replaced by the name of your datamodel" @interface CoreDataStack : NSObject { @private NSManagedObjectContext *managedObjectContext_; NSManagedObjectModel *managedObjectModel_; NSPersistentStoreCoordinator *persistentStoreCoordinator_; } @property (nonatomic, retain, readonly) NSManagedObjectContext *managedObjectContext; @property (nonatomic, retain, readonly) NSManagedObjectModel *managedObjectModel; @property (nonatomic, retain, readonly) NSPersistentStoreCoordinator *persistentStoreCoordinator; + (CoreDataStack *)sharedManager; + (void)sharedManagerDestroy; // call this in your app delegate in applicationWillTerminate and applicationWillResignActive - (void)saveContext; - (NSURL *)applicationLibraryDirectory; @end // CoreDataStack.m #import "CoreDataStack.h" @interface CoreDataStack () - (oneway void)priv_release; @end @implementation CoreDataStack static CoreDataStack *sharedManager = nil; + (CoreDataStack *)sharedManager { if (sharedManager != nil) { return sharedManager; } sharedManager = [[CoreDataStack alloc] init]; return sharedManager; } + (void)sharedManagerDestroy { if (sharedManager) { [sharedManager priv_release]; sharedManager = nil; } } - (id)retain { return self; } - (id)copy {return self;} - (oneway void)release{} - (oneway void)priv_release { [super release]; } - (void)saveContext { NSError *error = nil; if (managedObjectContext_ != nil) { if ([managedObjectContext_ hasChanges] && ![managedObjectContext_ save:&error]) { /* Replace this implementation with code to handle the error appropriately. abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. If it is not possible to recover from the error, display an alert panel that instructs the user to quit the application by pressing the Home button. */ //abort(); NSLog(@"Unresolved error %@, %@", error, [error userInfo]); UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Error" message:@"The app has run into an error trying to save, please exit the App and contact the developers. Exit the program by double-clicking the home button, then tap and hold the iMean icon in the task manager until the icons wiggle, then tap iMean again to terminate it" delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil]; [alert show]; [alert release]; } } } #pragma mark - #pragma mark Core Data stack /** Returns the managed object context for the application. If the context doesn't already exist, it is created and bound to the persistent store coordinator for the application. */ - (NSManagedObjectContext *)managedObjectContext { if (managedObjectContext_ != nil) { return managedObjectContext_; } NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator]; if (coordinator != nil) { managedObjectContext_ = [[NSManagedObjectContext alloc] init]; [managedObjectContext_ setPersistentStoreCoordinator:coordinator]; } return managedObjectContext_; } /** Returns the managed object model for the application. If the model doesn't already exist, it is created from the application's model. */ - (NSManagedObjectModel *)managedObjectModel { if (managedObjectModel_ != nil) { return managedObjectModel_; } NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"kYourAppName" withExtension:@"momd"]; managedObjectModel_ = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; return managedObjectModel_; } /** Returns the persistent store coordinator for the application. If the coordinator doesn't already exist, it is created and the application's store added to it. */ - (NSPersistentStoreCoordinator *)persistentStoreCoordinator { if (persistentStoreCoordinator_ != nil) { return persistentStoreCoordinator_; } NSString *yourAppName = [[NSString stringWithFormat:@"%@.sqlite",kYourAppName] autorelease]; NSURL *storeURL = [[self applicationLibraryDirectory] URLByAppendingPathComponent:yourAppName]; NSError *error = nil; persistentStoreCoordinator_ = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]]; if (![persistentStoreCoordinator_ addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&error]) { /* Replace this implementation with code to handle the error appropriately. abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. If it is not possible to recover from the error, display an alert panel that instructs the user to quit the application by pressing the Home button. Typical reasons for an error here include: * The persistent store is not accessible; * The schema for the persistent store is incompatible with current managed object model. Check the error message to determine what the actual problem was. If the persistent store is not accessible, there is typically something wrong with the file path. Often, a file URL is pointing into the application's resources directory instead of a writeable directory. If you encounter schema incompatibility errors during development, you can reduce their frequency by: * Simply deleting the existing store: [[NSFileManager defaultManager] removeItemAtURL:storeURL error:nil] * Performing automatic lightweight migration by passing the following dictionary as the options parameter: [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],NSMigratePersistentStoresAutomaticallyOption, [NSNumber numberWithBool:YES], NSInferMappingModelAutomaticallyOption, nil]; Lightweight migration will only work for a limited set of schema changes; consult "Core Data Model Versioning and Data Migration Programming Guide" for details. */ NSLog(@"Unresolved error %@, %@", error, [error userInfo]); // abort(); UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Error" message:@"The app has run into an error trying to load it's data model, please exit the App and contact the developers. Exit the program by double-clicking the home button, then tap and hold the iMean icon in the task manager until the icons wiggle, then tap iMean again to terminate it" delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil]; [alert show]; [alert release]; } return persistentStoreCoordinator_; } #pragma mark - #pragma mark Application's Library directory /** Returns the URL to the application's Documents directory. */ // returns the url of the application's Library directory. - (NSURL *)applicationLibraryDirectory { return [[[NSFileManager defaultManager] URLsForDirectory:NSLibraryDirectory inDomains:NSUserDomainMask] lastObject]; } #pragma mark - #pragma mark Memory management - (void)dealloc { // release and set all pointers to nil to avoid static issues [managedObjectContext_ release]; managedObjectContext_ = nil; [managedObjectModel_ release]; managedObjectModel_ = nil; [persistentStoreCoordinator_ release]; persistentStoreCoordinator_ = nil; [super dealloc]; } @end
