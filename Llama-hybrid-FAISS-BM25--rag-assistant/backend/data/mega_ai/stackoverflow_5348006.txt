[site]: stackoverflow
[post_id]: 5348006
[parent_id]: 
[tags]: 
Elastic Beanstalk -> RDS connection error using Grails

I'm deploying a Grails application to Amazon Web Services Elastic Beanstalk and leveraging RDS. I'm using Grails, Spring-Security (RDS tables). The application appears to work fine (login and data in RDS being pulled back). However, from time to time the first time I login I get a database connection error. The second time it (immediately) works fine. The only thing I'm doing slightly different is trying to use Java system properties for the connection string, username and password to externalize the connection properties: production { dataSource { url = System.getProperty("JDBC_CONNECTION_STRING") driverClassName = "com.mysql.jdbc.Driver" dbCreate = "validate" dialect = org.hibernate.dialect.MySQL5InnoDBDialect username = System.getProperty("PARAM1") password = System.getProperty("PARAM2") } } Stack trace: Caused by: org.hibernate.TransactionException: JDBC begin failed: at org.hibernate.transaction.JDBCTransaction.begin(JDBCTransaction.java:96) at org.hibernate.impl.SessionImpl.beginTransaction(SessionImpl.java:1353) at org.springframework.orm.hibernate3.HibernateTransactionManager.doBegin(HibernateTransactionManager.java:555) ... 80 more Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: The last packet successfully received from the server was 41,541,715 milliseconds ago. The last packet sent successfully to the server was 41,541,716 milliseconds ago. is longer than the server configured value of 'wait_timeout'. You should consider either expiring and/or testing connection validity before use in your application, increasing the server configured values for client timeouts, or using the Connector/J connection property 'autoReconnect=true' to avoid this problem. at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:532) at com.mysql.jdbc.Util.handleNewInstance(Util.java:407) at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:1116) at com.mysql.jdbc.MysqlIO.send(MysqlIO.java:3358) at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1970) at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2150) at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2620) at com.mysql.jdbc.ConnectionImpl.setAutoCommit(ConnectionImpl.java:5022) at org.apache.commons.dbcp.DelegatingConnection.setAutoCommit(DelegatingConnection.java:371) at org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.setAutoCommit(PoolingDataSource.java:328) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:616) at org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy$TransactionAwareInvocationHandler.invoke(TransactionAwareDataSourceProxy.java:239) at $Proxy11.setAutoCommit(Unknown Source) at org.hibernate.transaction.JDBCTransaction.begin(JDBCTransaction.java:91) ... 82 more Caused by: java.net.SocketException: Connection timed out at java.net.SocketOutputStream.socketWrite0(Native Method) at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:109) at java.net.SocketOutputStream.write(SocketOutputStream.java:153) at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82) at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140) at com.mysql.jdbc.MysqlIO.send(MysqlIO.java:3339) ... 95 more What I've tried: I appended ?autoReconnect=true to the JDBC_CONNECTION_STRING I've added this to conf/spring/resources.groovy: beans = { dataSource(BasicDataSource) { minEvictableIdleTimeMillis=1800000 timeBetweenEvictionRunsMillis=1800000 numTestsPerEvictionRun=3 testOnBorrow=true testWhileIdle=true testOnReturn=true validationQuery="SELECT 1" } } However is that the right place or can/should it be added to the datasource.groovy file per env configuration? Also, the above only seems to be valid if I add the URL/driverClassName, username, and password which now means that is in multiple places. I haven't confirmed if it solves the problem, but is there a way to have all this in one place per env?
