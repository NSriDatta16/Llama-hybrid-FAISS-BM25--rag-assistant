[site]: stackoverflow
[post_id]: 2609498
[parent_id]: 2609229
[tags]: 
Some comments on your code: MyString1() { //no arg constructor Perhaps your instruction requires it, but in general this is the kind of comment that's worse than useless. Comments should tell the reader things that aren't obvious from the first glance at the code. char *string; string = new char[0]; string[0] ='\0'; This invokes undefined behavior. Calling new with zero elements is allowed, but you can't dereference what it returns (it may return a null pointer, or it may return a non-null pointer that doesn't refer to any storage). In most cases, you're better off just setting the pointer to NULL. std::cout What's the point of writing out an empty string? size = 1; The string is empty so by normal figuring, the size is zero. //constructor receives pointer to character array Still useless. MyString1(char* chars) Since you aren't (or shouldn't be anyway) planning to modify the input data, this parameter should be char const * . { int index = 0; //Determine the length of the array while (chars[index] != NULL) index++; While this works, "NULL" should really be reserved for use as a pointer, at least IMO. I'd write it something like: while (chars[index] != '\0') ++index; Unless you're using the previous value, prefer pre-increment to post-increment. //Allocate dynamic memory on the heap As opposed to allocating static memory on the heap? MyString1 MyString2; Using the same naming convention for types and variables is confusing. while (string[index] != NULL) Same comment about NULL as previously applies here. MyString1 append(MyString1 s) IMO, the whole idea of this function is just plain wrong -- if you have a string, and ask this to append something to your string, it destroys your original string, and (worse) leaves it in an unusable state -- when you get around to adding a destructor that frees the memory owned by the string, it's going to cause double-deletion of the storage of a string that was the subject (victim?) of having append called on it. I'd consider writing a private "copy" function, and using that in the implementations of some (most?) of what you've shown here. As a bit of more general advice, I'd consider a couple more possibilities: first of all, instead of always allocating exactly the amount of space necessary for a string, I'd consider rounding the allocation to (say) a power of two. Second, if you want your string class to work well, you might consider implementing the "short string optimization". This consists of allocating space for a short string (e.g. 20 characters) in the body of the string object itself. Since many strings tend to be relatively short, this can improve speed (and reduce heap fragmentation and such) considerably by avoiding doing a heap allocation if the string is short.
