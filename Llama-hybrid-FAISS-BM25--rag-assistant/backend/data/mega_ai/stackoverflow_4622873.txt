[site]: stackoverflow
[post_id]: 4622873
[parent_id]: 4622684
[tags]: 
Assuming you're just dealing with one thread in your application, what you described is perfectly expected. By default, NSTimer 's are added to the current NSRunLoop which, in your case, is also responsible for dealing with UI interaction. When it gets tied up with handling UI interaction, it can't check your timer and "fire" it. A solution is to use multi-threading so as to avoid this tie-up. Here's a nice blog post on this very subject: http://blog.narent.com/?p=21 EDIT: See Dave's post for an alternative (and more elegant IMO) solution Also see: NSTimer doc NSRunLoop doc Threading programming guide
