[site]: stackoverflow
[post_id]: 2859870
[parent_id]: 2859305
[tags]: 
A lot of what avoiding explicit recursion is about is composing built-in recursive combinators, which usually work on very generic unlifted values. Doing the same thing in a Functor, Monad, or other lifted type sometimes works using basic lifting operations like fmap , , >>= , and so on. In some cases a pre-lifted version is already present, as with mapM , zipWithM , and so on. Other times, as with takeWhile , lifting is not trivial and no built-in version is provided. Your function indeed has characteristics of something that should be a lifted version of standard combinators. So first, let's strip out the monad to reconstruct the function you're implicitly lifting: lastJust :: (a -> Maybe a) -> a -> a The word "last" here gives us a hint; non-explicit recursion often uses temporary lists as control structures. So what you want is last applied to the list generated by iterating the function until getting Nothing . With a slight generalization of the type, we find the generator: unfoldr :: (b -> Maybe (a, b)) -> b -> [a] So we have something like this: dup x = (x, x) lastJust f x = last $ unfoldr (fmap dup . f) x Unfortunately at this point we're kind of stuck, because (to my knowledge) there's no monadic unfold and lifting it is, like takeWhile , not trivial. Another thing that could make sense is a more general unfold with a signature like (MonadMaybe m) => (b -> m (a, b)) -> b -> m [a] and an accompanying MaybeT transformer, but that doesn't exist in the standard libraries either, and monad transformers are kind of a Pit of Despair anyway. A third approach might be to find some way to generalize both Maybe and the unknown monad out as MonadPlus or something similar. Of course, there may be other approaches with a different structure, but I suspect you're likely to find similar awkwardness with any function that needs to be recursive going "into" a monad, e.g., each step conceptually introduces another layer that must be eliminated with >>= , join , etc. In summary: At first inspection your function as written is best expressed without explicit recursion, using a recursive combinator (some flavor of unfoldM ) that doesn't exist. You can either write the combinator yourself (as people have done with takeWhileM ), go digging around on Hackage for monadic recursive combinators, or just leave your code as is.
