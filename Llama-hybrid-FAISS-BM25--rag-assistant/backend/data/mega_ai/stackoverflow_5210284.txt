[site]: stackoverflow
[post_id]: 5210284
[parent_id]: 
[tags]: 
Inheritance and Many-to-Many Relationship

I have the following business role that I need to model: A bidder could rate a seller as long as they've interacted with this person A bidder could rate an item only if he had won the auction The final rating for the seller though, is the average taken from the item rating and the others' ratings on himself. The rating itself (whether for the item or the user) is the average of scores on several questions. Accordingly, I thought I should create a Ratings class, then inherit it with UserRating and ItemRating. Both of those should have an ICollection of RatingQuestion (which will eventually be a static table). The questions for the UserRating are different from those of the ItemRating, but I thought it's not really worth creating separate tables/entities for the questions (or maybe I should do a TPH inheritance?). So, here's what I got so far: public abstract class Rating { public int Id { get; set; } public virtual User By { get; set; } } public class UserRating : Rating { public virtual User For { get; set; } public virtual ICollection Questions { get; set; } } public class ItemRating : Rating { public virtual Item For { get; set; } public virtual ICollection Questions { get; set; } } public class RatingQuestion { public int Id { get; set; } public string Text { get; set; } public virtual ICollection Rating { get; set; } } The reason why I am putting the ICollection inside the sub-classes rather than the Rating base class is because the RatingQuestion for both is different, but I'm not sure that's the way I should be doing it, correct me if I'm wrong please. One thing I need some help with is deciding whether to go for a TPH or a TPT inheritance. I want to keep things simple, but I would also want to keep my database normalized. Moreover, performance is a factor that needs to be taken into account. Now the last thing I need to know how to do is: how to map the many-to-many relationship between the rating classes (the base class or sub-classes, not sure about which one I should be using) and the RatingQuestion class using the Fluent API AND add an attribute (score) which is a property of the relationship itself so I could record the score on every separate RatingQuestion. I hope that was clear enough. All suggestions are most welcome. Thanks in advance! UPDATE: (after Ladislav Mrnka's answer) public abstract class Rating { public int Id { get; set; } public virtual User By { get; set; } public virtual ICollection RatingQuestions { get; set; } } public class UserRating : Rating { public virtual User For { get; set; } public virtual ICollection Questions { get; set; } } public class ItemRating : Rating { public virtual Item For { get; set; } public virtual ICollection Questions { get; set; } } public class User { public int Id { get; set; } //more properties public virtual ICollection OwnRatings { get; set; } public virtual ICollection RatingsForOthers { get; set; } public virtual ICollection ItemRatings { get; set; } } public class Item { public int Id { get; set; } //more properties public virtual ItemRating Rating { get; set; } //because an Item will have only one rating } public class UserRatingConfiguration : EntityTypeConfiguration { public UserRatingConfiguration() { HasOptional(p => p.By) .WithMany(u => u.RatingsForOthers) .IsIndependent() .Map(m => m.MapKey(c => c.Id, "RatingSubmitter")); HasRequired(p => p.For) .WithMany(u => u.OwnRatings) .IsIndependent() .Map(m=>m.MapKey(c => c.Id, "RatedSeller")); } } public class ItemRatingConfiguration : EntityTypeConfiguration { public ItemRatingConfiguration() { HasRequired(p => p.By) .WithMany(u => u.ItemRatings) .IsIndependent() .Map(m=>m.MapKey(c => c.Id, "ItemRatingSubmitter")); } } I'm getting a very messed up model in SQL Server, which is obviously caused by my messed up mapping. Any suggestions or should I just forget about inheritance and the DRY principle all together in the case at hand?
