[site]: stackoverflow
[post_id]: 1057266
[parent_id]: 1057178
[tags]: 
Maybe. I write C pretty much exclusively for now, because I'm working from the bottom up. I have a bunch of time to kill before I go to college so I thought: I might as well be (at least somewhat) well versed in the architecture of software before I start. It makes (in some instances) the higher level concepts easier to learn, increases your ability to problem solve, etc. When I was a lot younger I learned PHP and VB6. When I moved down to C and assembly, the HARDEST thing for me to grasp that a "string" wasn't a single value, but an array of single values--and I couldn't just compare one to the other--I had to traverse each array of characters and find the difference--etc. Small things like that made me re-think and re-learn how computers actually worked. I mean, before I found that thing about strings out--I thought processor registers were utterly useless (how could you put anything useful in 32 bits!?). That being said, I can babble about potential benefits of learning lower-level programming, despite the fact that you will never use it. But for me, no matter what reason I come up with--it's mostly for general interest. I think C is fun, and the more I accomplish with it, the better I feel about my skill. If you don't find a lot of interest in learning things like what a stack overflow is, computational math, low-level memory management (invalid or null pointers, heap corruption and fragmentation, etc), etc--then there's no guarantee you'll really benefit from it. But you might. If you do learn C to learn about the architecture--and how stuff actually works under the hood--maybe try what I do. I frequently compile down to assembly code to see how the computer actually handles what I ask it to do. To see each individual step that is taken for each task. Actually, that's how I figured out the difference between char *a = "a string" and char a[] = "a string" . However the best benefit for you will be realizing how painless higher level languages really are :P. For the record--each process is given a call stack. It is a block of memory which is of a pre-determined size. It is used for local variables, mainly. Every time you make a local variable, the contents of it is added to the end of the stack--and when a function returns (and those variables go out of scope), that data is taken back off. A stack overflow is when too much stuff is added to the end of the stack, and you overrun that pre-allotted memory space. It is usually as a result of putting HUGE objects on the stack, or too much recursion (a function calling itself). Also I guess if you just get too tangled up in functions calls inside of function calls, which is basically the same (in this case) as the recursion issue.
