[site]: stackoverflow
[post_id]: 3027785
[parent_id]: 3027718
[tags]: 
A character consumed is consumed, you should not ask the regex engine to go back. From your examples the verse part (e.g. :1 ) seems not optional. Removing that will match the last bit. ref_regex = re.compile(''' (? \() # or stuff between (...) )\s*(\w+) (?(lbrace)\)) )? ''', re.X | re.U) (If you're going to write a gigantic RegEx like this, please use the /x flag.) If you really need overlapping matches, you could use a lookahead. A simple example is >>> rx = re.compile('(.)(?=(.))') >>> x = rx.finditer("abcdefgh") >>> [y.groups() for y in x] [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f'), ('f', 'g'), ('g', 'h')] You may extend this idea to your RegEx.
