[site]: stackoverflow
[post_id]: 3741182
[parent_id]: 
[tags]: 
Processing - Line Implementation Help

I jumped into Processing (the language) today. I've been trying to implement a line without the line() function. In other words, I'm trying to replicate the line() function with my own code. I'm almost there, but not. (There's a screen, and you can click around, and this function connects those clicks with lines.) There are four different line slopes I'm dealing with (m>1, 0 If you could just glance at the following code, and tell me where I've gone wrong, I'd be grateful. int xStart = -1; // Starting x and y are negative. int yStart = -1; // No lines are drawn when mouseReleased() and x/y are negative. boolean isReset = false; // Turns true when 'r' is pressed to reset polygon chain. int clickCounter = 0; // Changes background color every 10 clicks (after c is pressed). color backgroundColor = 0; // Starting background color. Changed occasionally. color lineColor = 255; int weight = 1; void setup() { size(800, 800); // Initial size is 800x800 background(backgroundColor); // ...background is black. smooth(); stroke(lineColor); //... lines/points are white. strokeWeight(weight); } void draw() { } void mousePressed(){ clickCounter++; } void mouseReleased(){ // mouseReleased used instead of mousePressed to avoid dragged clicks. point(mouseX, mouseY); // Draws white point at clicked coordinates. if((xStart Exit program. exit(); else if(key == 'c'){ // EXTRA CREDIT ADDITTION: If c pressed -> Set background black to clear all lines/points on screen. if(clickCounter > 10){ backgroundColor = color(random(255), random(255), random(255)); // EXTRA CREDIT ADDITION: If cleared and clickCounter is greater clickCounter = 0; // ...than 10, background changes to random color. } background(backgroundColor); xStart = -1; // Must set points negative so line is not drawn after next new point is made (since there will only be one point on the screen). yStart = -1; } else if(key == 'r'){ // If r pressed -> Reset: Next click will create new point that isn't connected with line to current points. isReset = true; lineColor = color(random(255), random(255), random(255)); // EXTRA CREDIT ADDITION: When dot chain is "reset", line changes color. weight = (int)random(10); strokeWeight(weight); // EXTRA CREDIT ADDITION: ...and line/dot thickness changes. stroke(lineColor); } else return; } // createLine(): Function which draws line from (x0,y0) to (x1,y1). void createLine(int x0, int y0, int x1, int y1){ // 1) Line function draws from left to right. (Does not work right to left.) Check and swap points if ending point is left of starting point. if(x1 1; 0 Paint by incrementing/decrementing y until points connect. if(y1 > y0){ // If new point is above -> Draw upwards. y0 = y0 + 1; point(x0, y0); } else{ // It new point below -> Draw downwards. y0 = y0 - 1; point(x0, y0); } } while(x1 != x0){ // If horizontal -> Paint by incrementing x until points connect (will be left to right line always). x0 = x0 + 1; point(x0, y0); } return; } // Handle slanted lines... double tempDX = x1 - x0; double tempDY = y1 - y0; // Had to create dx and dy as doubles because typecasting dy/dx to a double data type wasn't working. double m = (-tempDY / tempDX); // m = line slope. (Note - The dy value is negative because positive y is downwards on the screen.) print("SLOPE CALCULATED: " + m + "\n"); int deltaN = (2 * -dx); // deltaX is the amount to increment d after choosing the next pixel on the line. int deltaNE = (2 * (-dy - dx)); // ...where X is the direction moved for that next pixel. int deltaE = (2 * -dy); // deltaX variables are used below to plot line. int deltaSE = (2 * (dy + dx)); int deltaS = (2 * dx); int x = x0; int y = y0; int d = 0; // d = Amount d-value changes from pixel to pixel. Depends on slope. int region = 0; // region = Variable to store slope region. Different regions require different formulas. if(m > 1){ // if-statement: Initializes d, depending on the slope of the line. d = -dy - (2 * dx); // If slope is 1-Infiniti. -> Use NE/N initialization for d. region = 1; } else if(m == 1) region = 2; else if(m > 0 && m Use NE/E initialization for d. region = 3; } else if(m -1){ d = (2 * dy) + dx; // If slope is 0-(-1) -> Use E/SE initliazation for d. region = 4; } else if(m == -1) region = 5; else if(m Use SE/S initialization for d. region = 6; } while(x 0 -> Add deltaN, and increment y. y = y - 1; } } else if(region == 2){ x = x + 1; y = y - 1; } else if(region == 3){ if(d
