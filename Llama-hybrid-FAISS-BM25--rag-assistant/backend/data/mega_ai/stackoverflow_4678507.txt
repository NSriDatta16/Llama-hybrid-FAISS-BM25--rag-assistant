[site]: stackoverflow
[post_id]: 4678507
[parent_id]: 
[tags]: 
Carefully deleting N items from a "circular" vector (or perhaps just an NSMutableArray)

Imagine a std:vector, say, with 100 things on it (0 to 99) currently. You are treating it as a loop. So the 105th item is index 4; forward 7 from index 98 is 5. You want to delete N items after index position P. So, delete 5 items after index 50; easy. Or 5 items after index 99: as you delete 0 five times, or 4 through 0, noting that position at 99 will be erased from existence. Worst, 5 items after index 97 - you have to deal with both modes of deletion. What's the elegant and solid approach? Here's a boring routine I wrote -(void)knotRemovalHelper:(NSMutableArray*)original after:(NSInteger)nn howManyToDelete:(NSInteger)desired { #define ORCO ((NSInteger)[original count]) static NSInteger kount, howManyUntilLoop, howManyExtraAferLoop; if ( ... our array is NOT a loop ... ) // trivial, if messy... { for ( kount = 1; kount = ORCO ) return; [original removeObjectAtIndex:( nn+1 )]; } return; } else // our array is a loop // messy, confusing and inelegant. how to improve? // here we go... { howManyUntilLoop = (ORCO-1) - nn; if ( howManyUntilLoop > desired ) { for ( kount = 1; kount Update! InVariant's second answer leads to the following excellent solution. "starting with" is much better than "starting after". So the routine now uses "start with". Invariant's second answer leads to this very simple solution... N times do if P -(void)removeLoopilyFrom:(NSMutableArray*)ra startingWithThisOne:(NSInteger)removeThisOneFirst howManyToDelete:(NSInteger)countToDelete { // exception if removeThisOneFirst > ra highestIndex // exception if countToDelete is > ra size // so easy thanks to Invariant: for ( do this countToDelete times ) { if ( removeThisOneFirst Update! Toolbox has pointed out the excellent idea of working to a new array - super KISS.
