[site]: stackoverflow
[post_id]: 3851601
[parent_id]: 3850665
[tags]: 
It makes no sense because what you are trying to do does not optimise the resulting process!!! Hey, I did not read anywhere in your question that you had intention to optimise. Electrical Engg people never stop being curious regardless of "usefulness". We are like compulsive obsessive hoarders of items of whom you read in the news where they stack their attics, cellars, bedrooms and living rooms up with junk which they believe would come in handy one day. At least that was the case when I was in Engg school a little less than 30 years ago. I encourage you to continue in your quest to hoard up "useless" knowledge that appears to have little possibilities of optimising your life or life-style. Why depend on the compiler when you can do it by hand-coded algorithm?! Yah? Be a little adventurous, you know. Ok enuf dissing people who express disdain at your pursuit of knowledge. Recall in your middle-school, the way you were taught to do your division? 437/24, e.g. _____ 24|437 018 ----- 24|437 24 ----- 197 24 ----- 5 The number which is subject to division, 437, is called the dividend. 24 is the divisor, the result 18 is the quotient, and 5 is the remainder. Like when you file your taxes, you need to fill in profits you had gained from stock "dividends", which is a misnomer. What you fill into the tax form is a multiple of the quotient of a single huge chunk of dividend. You did not receive the dividend, but portions of dividend - otherwise, it would mean you owned 100% of the stock. ___________ 11000|110110101 000010010 ----------- 11000|110110101 11000 ---------- 000110101 remainder=subtract divisor from dividend 11000000 shift divisor right and append 0 to quotient until 1100000 divisor is not greater than remainder. 110000 Yihaa! ---------- 000101 remainder=subtract shifted divisor from remainder 11000 shift divisor right and append 0 to quotient until 1100 divisor is not greater than remainder. ---------- oops, cannot shift anymore. The above, as you might already know, is TRUE division. Which is achieved by subtracting by a shifted divisor. What you want is to achieve the same thing by simply shifting the dividend. That, unfortunately cannot be done unless the divisor is a exponential power of 2 (2,4,8,16). Which is an obvious fact of binary arithmetic. Or, at least I am not aware of any method that can do it without approximation and intrapolative techniques. Therefore, you have to use a combination of dividend shift and true division. e.g. 24 = 2 x 2 x 2 x 3 First, divide 437 by 8 using binary shift to get 010010 and then use true division to divide by 3: 010010 -------- 11|110110 11 ------- 011 11 ----- 0 which works out to 010010 = 18. Voila. How do you determine 24 = 2^8 x 3? By shifting 11000 rightwards until you hit a 1. Which means, you could shift the dividend the same number of times as you would shift the divisor until the divisor hits a 1. Therefore, obviously, this method would not work if a divisor is odd. e.g., it will not work for divisor 25, but it will work a little for divisor 50. May be, there are predictive methods that could interpolate a divisor like 13 to be between 2^3=8 and 2^4=16. If there are, I am not familiar with them. What you need to explore is using a number series. For example dividing by 25: 1 1 1 1 1 __ = __ - ___ - ___ + ___ - ... until the precision you require. 25 16 64 128 256 where the general form of the series is 1 1 b1 bn _ = ___ + _______ + ... + ______ D 2^k 2^(k+1) 2^(k+n) where bn is either -1, 0 or +1. I hoping my binary manipulation above would not have errors or typos. If so, thousands apologies.
