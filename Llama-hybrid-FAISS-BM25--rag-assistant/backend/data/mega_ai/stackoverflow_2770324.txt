[site]: stackoverflow
[post_id]: 2770324
[parent_id]: 2770111
[tags]: 
private static final int AVERAGE_STRING_LENGTH = 10; // Using 10 is arbitrary public static final String concatStrings(final Collection strings) { if (strings == null) return null; final int size = strings.size(); if (size == 0) return ""; if (size == 1) return strings.get(0); final StringBuilder returnValue = new StringBuilder(AVERAGE_STRING_LENGTH * size); for (String s : strings) { returnValue.append(s); } return returnValue.toString(); } Perhaps going a little overboard, here's every optimization I could think of for concatStrings() - demonstrated above - some of which may not be applicable to your environment: Use StringBuilder - its far more efficient for these successive concatenations Use StringBuilder(int capacity) to specify the likely necessary capacity, if there's any way to anticipate it (used average size above, but other methods may be more convenient) Use the Collection parameter type to allow for a more efficient data structure than Vector , which is synchronized - plus the caller has far greater flexibility (e.g. no need to copy a Set to a Vector just to call this method) Hardcode simple cases, if they are likely (e.g. null , size 0 , and size 1 cases above) Use final to facilitate JIT inlining and optimization Cache the size of strings , if its used multiple times. (e.g. used 3 times in the above code.) Finally, if this operation is done very often over a large number of strings, look into Ropes for Java . Ropes for Java article - http://www.ibm.com/developerworks/java/library/j-ropes Ropes of Java implementation - http://ahmadsoft.org/ropes/ Ropes (Wikipedia) - http://en.wikipedia.org/wiki/Rope_(computer_science)
