[site]: stackoverflow
[post_id]: 3256565
[parent_id]: 3255671
[tags]: 
Use placement new. std::vector memory(sizeof(Myclass)); void* place = &memory[0]; Myclass* f = new(place) Myclass(); Don't use the method defined by the FAQ: char memory[sizeof(Myclass)]; // No alignment guarantees on this. As noted in the FAQ it is dangerous as the standard provides no grantees about the alignment of this memory. Using a standard vector does give you guarantees about the alignment because the data section of vector is dynamically allocated and the standard does provide guarantees about the alignment of dynamically allocated memory. From: n2521 (the copy I have on my desktop) Section: 3.7.3.1 The pointer returned shall be suitably aligned so that it can be converted to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to a corresponding deallocation function). Which points us at 3.11 3.11 Alignment [basic.align] 5 Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment requirement. Don't forget to manually call the destructor: f->~Myclass()
