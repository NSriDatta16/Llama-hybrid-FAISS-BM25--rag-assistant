[site]: datascience
[post_id]: 26933
[parent_id]: 26742
[tags]: 
Attempt at a Conceptual Approach I will attempt to answer this question focusing primarily on the concept itself, rather than the mathematics which have little explicit relevance. Therefore, correct me if I am wrong, but I believe that when you state "Localized Filter" you are referring to what is also, commonly known as a "Convolution Layer" or "Neuron" even occasionally a "Kernel" . In a manner, of which I hope will be suitable to your application, I would have one visualize this as a sort of mask, who's depth MUST equal that of the source image depth, that is to be masking the source input data, centered at some point (x,y,z), then sequentially shifted one position at a time in a manner such that, the area covered by the filter in the second position will be overlapping the first all but one column. To better understand this concept, imagine the way the data input to a CNN would be "seen" by the machine, the following images attached to this guide, show the general concept; although the picture above this paragraph is AN ACTUAL GRAPHICAL REPRESENTATION OF A NEURON , the same principle applies to both: Some array -> N 1 x N 2 x N 3 of numbers. After successfully shifting, the algorithm will then perform an element wise multiplication across the values in the original matrix( X 0 ) that the "conv layer" currently Filters and its own numeric values( X 1 ) then stored in some other array ( A ), referred to as the "Activation Map" , that becomes some degree smaller than the original data in relation to the filter size: np.multiply( X 0 , X 1 ) Of which the result is stored in some Matrix, of numerals, Pt , position total. Upon completion of the sequence of the entire original input data, the algorithm then computes the sum of all elements and stores them, so to gain the ability to pass to the next layer of the CNN: Pt final = sum( Pt ) The filter itself, being representative of some pattern, for example a circle, would then result in the outcome of a large number after completing the second step if there was another circle within its area as the pixels that have any data within them will result in an element of the original array having some positive number. As an example reference the below picture's and notice the difference in the resulting Integers for both instance's: Where as the opposite is true, of an area's values of which do not match those of the "conv layer" . This scenario will result in a very low number, relative to a confirmed match, or even a zero if the element happens to be empty of data other than zero. This method is what comprises the "secret layer" in a CNN, which generally alternates in a sequence between different variants, "Convolution" , "ReLU" as well as "Pool" layers. I hope that this explained better what is going on in the localized filters that you came upon in your research! If I was to ambiguous on any part of the explanation, please feel free to espouse and I will try to extrapolate.
