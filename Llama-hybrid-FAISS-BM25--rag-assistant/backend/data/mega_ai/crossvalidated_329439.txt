[site]: crossvalidated
[post_id]: 329439
[parent_id]: 329433
[tags]: 
The seasonal parameter expects a simple Boolean input (see ?auto.arima ). What you are providing is c(0,1,1)[4] , which happens to be a well-formed R expression, namely the fourth entry in the vector c(0,1,1) of length three, or c(0,1,1)[4] # NA And this NA is then coerced to a Boolean value, namely isTRUE(NA) # FALSE So what you did was an elaborate way of specifying a non-seasonal model. Try seasonal=TRUE instead. (And don't be surprised if the automatic model selection decides to use a non-seasonal model, anyway. If you want to force seasonality, this may be helpful: Seasonality not taken account of in auto.arima() .) EDIT: with the data you posted, the first thing to notice is that x and y are vectors, not time series objects with an associated seasonal frequency. As above, auto.arima does not derive the seasonal period from the seasonal parameter (which is supposed to be, and will be coerced to, a simple Boolean), but from the frequency of the focal time series. So the first thing to do is to identify your quarterly data as such: y Next, even if your y is seasonal, this does not necessarily matter. auto.arima() with an xreg parameter fits a regression with ARIMA errors ( not ARIMAX ), so what matters is the seasonality of the residuals of this regression of y on x . Fortunately, these residuals are also clearly seasonal, as are their first differences (note how we again need to convert the residuals to ts objects): library(forecast) seasonplot(ts(residuals(lm(y~x)),frequency=4)) seasonplot(ts(diff(residuals(lm(y~x))),frequency=4)) Interestingly enough, auto.arima() fits a non-seasonal model, as you noticed, even if we don't specify seasonal=FALSE . Then again, if we call auto.arima() on the residuals from the regression y~x , we get a seasonal model, and so do we if we run auto.arima(y,xreg=x,D=1) with enforced seasonality as per this thread - but the seasonal models are different. > auto.arima(y,xreg=x) Series: y Regression with ARIMA(0,1,0) errors Coefficients: xreg 0e+00 s.e. 3e-04 sigma^2 estimated as 24.53: log likelihood=-41.75 AIC=87.49 AICc=88.58 BIC=88.77 > auto.arima(ts(residuals(lm(y~x)),frequency=4)) Series: ts(residuals(lm(y ~ x)), frequency = 4) ARIMA(0,1,0)(1,0,0)[4] Coefficients: sar1 0.9074 s.e. 0.0694 sigma^2 estimated as 12.65: log likelihood=-40.58 AIC=85.16 AICc=86.25 BIC=86.44 > auto.arima(y,xreg=x,D=1) Series: y Regression with ARIMA(0,0,0)(0,1,0)[4] errors Coefficients: xreg 0e+00 s.e. 3e-04 sigma^2 estimated as 12.29: log likelihood=-28.88 AIC=61.76 AICc=63.26 BIC=62.56 Overall, it looks like there is something undocumented going on here - auto.arima() may by default not use seasonal models if there is an xreg present. You may want to ping the author Rob Hyndman about this (best to point him to this thread, he may chime in). Similarly, that the last two calls resulted in different ARIMA models may be due to internals of auto.arima() . It looks like your best bet may be to run the regression outside auto.arima() and then subject the residuals to ARIMA modeling, as I did here. Alternatively, if you can identify whether your residual series is seasonal or not , you can enforce seasonality using D as above.
