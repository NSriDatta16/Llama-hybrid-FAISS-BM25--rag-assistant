[site]: stackoverflow
[post_id]: 1021832
[parent_id]: 1021737
[tags]: 
I wouldn't read too much into this - this isn't good profiling code for the following reasons 1. DateTime isn't meant for profiling. You should use QueryPerformanceCounter or StopWatch which use the CPU hardware profile counters 2. Console.WriteLine is a device method so there may be subtle effects such as buffering to take into account 3. Running one iteration of each code block will never give you accurate results because your CPU does a lot of funky on the fly optimisation such as out of order execution and instruction scheduling 4. Chances are the code that gets JITed for both code blocks is fairly similar so is likely to be in the instruction cache for the second code block To get a better idea of timing, I did the following Replaced the Console.WriteLine with a math expression ( e^num) I used QueryPerformanceCounter/QueryPerformanceTimer through P/Invoke I ran each code block 1 million times then averaged the results When I did that I got the following results: The for loop took 0.000676 milliseconds The foreach loop took 0.000653 milliseconds So foreach was very slightly faster but not by much I then did some further experiments and ran the foreach block first and the for block second When I did that I got the following results: The foreach loop took 0.000702 milliseconds The for loop took 0.000691 milliseconds Finally I ran both loops together twice i.e for + foreach then for + foreach again When I did that I got the following results: The foreach loop took 0.00140 milliseconds The for loop took 0.001385 milliseconds So basically it looks to me that whatever code you run second, runs very slightly faster but not enough to be of any significance. --Edit-- Here are a couple of useful links How to time managed code using QueryPerformanceCounter The instruction cache Out of order execution
