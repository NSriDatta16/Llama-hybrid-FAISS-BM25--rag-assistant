[site]: stackoverflow
[post_id]: 4025216
[parent_id]: 
[tags]: 
Passing more than one variable to ExecMethod

I am trying to call wmisetbrightness, but it takes two inputs. How do I pass more than one input to ExecMethod? Code snippet below is obviously wrong. // set up to call the WmiSetBrightness Method BSTR MethodName = SysAllocString(L"WmiSetBrightness"); BSTR ClassName = SysAllocString(L"WmiMonitorBrightnessMethods"); IWbemClassObject* pClass = NULL; hres = pSvc->GetObject(ClassName, 0, NULL, &pClass, NULL); IWbemClassObject* pInParamsDefinition = NULL; hres = pClass->GetMethod(MethodName, 0, &pInParamsDefinition, NULL); IWbemClassObject* pClassInstance = NULL; hres = pInParamsDefinition->SpawnInstance(0, &pClassInstance); // Create the values for the in parameters VARIANT varCommand; varCommand.vt = VT_UI8; varCommand.ullVal = 30; //// Store the value for the in parameters hres = pClassInstance->Put(L"CommandLine", 0, &varCommand, 0); // Execute Method IWbemClassObject* pOutParams = NULL; hres = pSvc->ExecMethod(ClassName, MethodName, 0, NULL, pClassInstance, &pOutParams, NULL); edit: WmiSetBrightness takes two variables: uint32 WmiSetBrightness( uint64 Timeout, uint8 Brightness ); the above code only passes the first input parameter, and I dont know how to modify it to pass both parameters. Full code here: #define _WIN32_DCOM #include using namespace std; #include #include # pragma comment(lib, "wbemuuid.lib") int main(int iArgCnt, char ** argv) { HRESULT hres; // Step 1: -------------------------------------------------- // Initialize COM. ------------------------------------------ hres = CoInitializeEx(0, COINIT_MULTITHREADED); if (FAILED(hres)) { cout ConnectServer( _bstr_t(L"ROOT\\wmi"), NULL, NULL, 0, NULL, 0, 0, &pSvc ); if (FAILED(hres)) { cout Release(); CoUninitialize(); return 1; // Program has failed. } cout Release(); pLoc->Release(); CoUninitialize(); return 1; // Program has failed. } /////////////////////////////////////////////////////////////////////////////////////////////////////////////// // set up to call the WmiSetBrightness Method BSTR MethodName = SysAllocString(L"WmiSetBrightness"); BSTR ClassName = SysAllocString(L"WmiMonitorBrightnessMethods"); IWbemClassObject* pClass = NULL; hres = pSvc->GetObject(ClassName, 0, NULL, &pClass, NULL); IWbemClassObject* pInParamsDefinition = NULL; hres = pClass->GetMethod(MethodName, 0, &pInParamsDefinition, NULL); IWbemClassObject* pClassInstance = NULL; hres = pInParamsDefinition->SpawnInstance(0, &pClassInstance); VARIANT var1; VariantInit(&var1); V_VT(&var1) = VT_BSTR; V_BSTR(&var1) = SysAllocString(L"0"); hres = pClassInstance->Put(L"Timeout", 0, &var1, CIM_UINT32); //CIM_UINT64 VARIANT var2; VariantInit(&var2); V_VT(&var2) = VT_BSTR; V_BSTR(&var2) = SysAllocString(L"30"); hres = pClassInstance->Put(L"Brightness", 0, &var2, CIM_UINT8); // Execute Method IWbemClassObject* pOutParams = NULL; hres = pSvc->ExecMethod(ClassName, MethodName, 0, NULL, pClassInstance, &pOutParams, NULL); if (FAILED(hres)) { cout Release(); pInParamsDefinition->Release(); pOutParams->Release(); pSvc->Release(); pLoc->Release(); CoUninitialize(); return 1; // Program has failed. } // To see what the method returned, // use the following code. The return value will // be in &varReturnValue VARIANT varReturnValue; hres = pOutParams->Get(_bstr_t(L"ReturnValue"), 0, &varReturnValue, NULL, 0); // Clean up //-------------------------- // VariantClear(&varCommand); VariantClear(&varReturnValue); SysFreeString(ClassName); SysFreeString(MethodName); pClass->Release(); pInParamsDefinition->Release(); pOutParams->Release(); pLoc->Release(); pSvc->Release(); CoUninitialize(); return 0; }
