[site]: stackoverflow
[post_id]: 2377130
[parent_id]: 2376981
[tags]: 
Yeah, Haskell's type system is very picky. The problem here is the type of fromIntegral: Prelude> :t fromIntegral fromIntegral :: (Integral a, Num b) => a -> b fromIntegral will only accept an Integral as a, not any other kind of Num. (/), on the other hand only accepts fractional. How do you go about making the two work together? Well, the sum function is a good start: Prelude> :t sum sum :: (Num a) => [a] -> a Sum takes a list of any Num and returns a Num. Your next problem is the length of the list. The length is an Int: Prelude> :t length length :: [a] -> Int You need to convert that Int into a Num as well. That's what fromIntegral does. So now you've got a function that returns a Num and another function that returns a Num. There are some rules for type promotion of numbers you can look up , but basically at this point you're good to go: Prelude> let average xs = (sum xs) / (fromIntegral (length xs)) Prelude> :t average average :: (Fractional a) => [a] -> a Let's give it a trial run: Prelude> average [1,2,3,4,5] 3.0 Prelude> average [1.2,3.4,5.6,7.8,9.0] 5.4 Prelude> average [1.2,3,4.5,6,7.8,9] 5.25
