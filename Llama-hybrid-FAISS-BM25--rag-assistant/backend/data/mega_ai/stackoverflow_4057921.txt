[site]: stackoverflow
[post_id]: 4057921
[parent_id]: 4057681
[tags]: 
The clustered index (and not non-clustered indices) can be used for range queries. Do you know what that is ? Horizontal traversal of the B-Tree enhances the speed of navigating the CI when determining qualified rows during range queries. In a more general sense, if the server cache is too small, and the CI pages get paged out, when any query (not only the range queries) need to get the next page when walking down, or sideways, through a CI, it can get the page with a single disk access, because the pages are linked by a pointer; ie. it avoids walking back up one level to find the next page). Just one of the many reasons CIs are much faster than NCIs; they are far more enhanced because the NCI depends on them (your other question today). The diagram has mistakes (contains false info), or to put it more precisely, it is a descriptive, non-technical diagram, from a non-technical corporation: The intermediate levels have a single pointer to the page at the next level (not multiple pointers). The leaf level IS the data row. There are no pointers to rows (at the intermediate OR leaf level). The Index Pages do not resemble a page of text and images. Each Index Page contains hundreds of index B-Tree entries. The Root page is different only in that the first entry is the single root to the index ; it contains hundreds of entries which are of course second level, and may be third level, etc. There is a reason technicians draw, and use, technical drawings: among others, it avoids misunderstandings and confusion. No questions re the Diagram I Made for You ? Response to Martin Smith's Post a. Me: The clustered index (and not non-clustered indices) can be used for range queries MS: Incorrect: Non-clustered indices can be used perfectly well for range queries as long as the Non Clustered Index is covering. It appears you understand a Covered Query, but you do not understand a Range Query. Please read up on it. It is unfortunately named "query", but actually it is a performance technique that all the SQL vendors provide. Say you have a real Relational table, which means a composite key, eg. Invoice PK is (CustomerId, InvoiceNo) [not InvoiceId]. Then a query such as: SELECT * FROM Invoice WHERE CustomerId = @CustomerId will navigate the B-Tree of the ClusteredIndex once , to find the fist Invoice for the CustomerId. It will then follow the PageChain of the LeafLevel (data rows) to obtain the second and subsequent Invoice for the CustomerId. There is no further use of the B-Tree for the query. The Range Query ends when the first Invoice with CustomerId > 1 is encountered. That is only possible with a ClusteredIndex, where the B-Tree is married to the Data, in a single physical structure. That is physically impossible with a NonClusteredIndex-plus-Data (which is a Heap or a ClusteredIndex). Which is why Range Queries cannot be supported for NCIs. Even if you had an NCI with (CustomerId, InvoiceNo), the data rows will not be in that order; they will be in chronological order in the Heap; so the query that uses that NCI will extract one-row-per-NCI-entry. b. Me: CIs are much faster than NCIs; they are far more enhanced because the NCI depends on them MS: The B tree structure of a clustered index is no different from a non clustered index. CIs are not enhanced or somehow have a different and superior structure ... No dispute there. You have simply misunderstood me, re speed , I was talking about the table overall (NonClusteredIndices cannot exist on their own). Let me clarify: Given the same Key, a ClusteredIndex (which includes data) is always much faster than a NonClusteredIndex-plus-Heap. Navigating, maintaining, creating, deleting from, a single data-storage structure (the CI), is obviously much faster than doing the same to two data-storage structures (NCI+Heap). It is not physically possible to make two DSs faster than one DS (assuming with the same key.) c. Not worth a response. It appears you do not realise that my comments pertain to the incorrect diagrams. Put another way, your comments (and proof) are also quite correct.
