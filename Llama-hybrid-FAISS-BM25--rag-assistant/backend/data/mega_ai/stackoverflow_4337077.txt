[site]: stackoverflow
[post_id]: 4337077
[parent_id]: 4334647
[tags]: 
Of course the rows don't exists in the INSERTED pseudo-table when you update rows that don't exists in the table to start with: you issue UPDATE statement on Trade for rows that are in TradePending ! Besides, your INSTEAD OF INSERT trigger is broken. It only works for single row inserts, and even for those it will fail under concurrency. Use a set based MERGE. Ultimately you are designing a hack around a data model that is disconnected from what the application does. Creating INSTEAD OF triggers to completely change the shape of a table used by legacy code only works so far, this problem you encountered is just one of the many issues down the road. Ultimately, your client code has to insert/update/delete the right table. As a workaround you could try moving all data into a table that holds both Trade and TradePending and uses a state column to distinguish the two, expose the old Trade and TradePending tables as views and use triggers to capture the DML on the views to redirect them to the proper table. Not sure if would work though, I cannot test it right now. Update: Here is an example how this would work with updateable views: CREATE TABLE [Holding] ( [HoldingID] INTEGER NOT NULL, [InstrumentID] INTEGER, CONSTRAINT [PK_Holding] PRIMARY KEY ([HoldingID]) ) GO CREATE TABLE [TradeStorage] ( [TradeID] INTEGER IDENTITY(1,1) NOT NULL, [HoldingID] INTEGER NOT NULL, [BuySell] CHAR(1) NOT NULL, CONSTRAINT [PK_TradeSummary] PRIMARY KEY ([TradeID]) , CONSTRAINT [CC_Trade_BuySell] CHECK (BuySell IN ('B','S')) ) GO create view Trade with schemabinding as select TradeID, HoldingID, BuySell from dbo.TradeStorage where exists ( select HoldingID from dbo.Holding where Holding.HoldingID = TradeStorage.HoldingID); go create view TradePending with schemabinding as select TradeID, HoldingID, BuySell from dbo.TradeStorage where not exists ( select HoldingID from dbo.Holding where HoldingID = TradeStorage.HoldingID); go -- Create a Holding and a Trade, this will be inserted as normal. INSERT Holding VALUES(1,100) INSERT Trade VALUES(1,'B') -- Create a Trade where the Holding does not exists, -- row redirected to TradePending table. INSERT Trade values(2,'B') go select * from Trade; select * from TradePending; go -- Update the first trade to be a Buy, updates the `Trade` table UPDATE Trade SET BuySell = 'S' WHERE HoldingID = 1 go -- Insert a holding with ID 2, -- this will automatically move the pending trade to Trade INSERT Holding VALUES(2,100) select * from Trade; select * from TradePending; go UPDATE Trade SET BuySell = 'S' WHERE HoldingID = 2 go select * from Trade; select * from TradePending; go Note that is still no possible to update Trade for records that are in TradePending. No trigger, view or similar mechanism can do such.
