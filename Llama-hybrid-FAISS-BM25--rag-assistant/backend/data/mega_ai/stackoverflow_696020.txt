[site]: stackoverflow
[post_id]: 696020
[parent_id]: 695917
[tags]: 
Yes you can do this with criteria queries by using projections. Simply project only the properties you wish to use and only those will be included in the select clause of the compiled query. http://nhibernate.info/doc/nh/en/index.html#querycriteria-projection Update to edit There are several ways to accomplish this, with some limitations however. 1) The NHibernate way. var list = session.CreateCriteria(typeof (Task)) .SetProjection(Projections.ProjectionList() .Add(Projections.Property("Name"), "Name") .Add(Projections.Property("ID"), "ID") ) .SetResultTransformer(Transformers.AliasToBean(typeof (Task))) .List(); Simply assign the property name as an alias to your projection and the AliasToBean transformer will map those projections to an actual class. The limitation to this method is that any properties that you map must have a setter in the POCO class, this can be a protected setter but it must have a setter. You can also do this with linq as well in an a slightly different fashion var list = session.CreateCriteria(typeof (Task)) .SetProjection(Projections.ProjectionList() .Add(Projections.Property("Name")) .Add(Projections.Property("ID")) ) .List () .Select(l => new Task() {Name = (string) l[0], ID = (Guid) l[1]}); This is simply using linq to map the indexed list that is ouput into a new instance of the Task class. The same limitation as above applies except that this is a bit more severe in that all the properties mapped must have a public setter because that is what linq uses to do fill in the object. I hope this helps you.
