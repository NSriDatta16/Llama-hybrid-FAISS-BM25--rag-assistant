[site]: stackoverflow
[post_id]: 753761
[parent_id]: 753440
[tags]: 
We use packed structures that are overlaid directly over the binary packet in memory today and I am rueing the day that I decided to do that. The only way that we have gotten this to work is by: carefully defining bit-width specific types based on the compilation environment ( typedef unsigned int uint32_t ) inserting the appropriate compiler-specific pragmas in to specify tight packing of structure members requiring that everything is in one byte order (use network or big-endian ordering) carefully writing both the server and client code If you are just starting out, I would advise you to skip the whole mess of trying to represent what's on the wire with structures. Just serialize each primitive element separately. If you choose not to use an existing library like Boost Serialize or a middleware like TibCo, then save yourself a lot of headache by writing an abstraction around a binary buffer that hides the details of your serialization method. Aim for an interface like: class ByteBuffer { public: ByteBuffer(uint8_t *bytes, size_t numBytes) { buffer_.assign(&bytes[0], &bytes[numBytes]); } void encode8Bits(uint8_t n); void encode16Bits(uint16_t n); //... void overwrite8BitsAt(unsigned offset, uint8_t n); void overwrite16BitsAt(unsigned offset, uint16_t n); //... void encodeString(std::string const& s); void encodeString(std::wstring const& s); uint8_t decode8BitsFrom(unsigned offset) const; uint16_t decode16BitsFrom(unsigned offset) const; //... private: std::vector buffer_; }; The each of your packet classes would have a method to serialize to a ByteBuffer or be deserialized from a ByteBuffer and offset. This is one of those things that I absolutely wish that I could go back in time and correct. I cannot count the number of times that I have spent time debugging an issue that was caused by forgetting to swap bytes or not packing a struct . The other trap to avoid is using a union to represent bytes or memcpy ing to an unsigned char buffer to extract bytes. If you always use Big-Endian on the wire, then you can use simple code to write the bytes to the buffer and not worry about the htonl stuff: void ByteBuffer::encode8Bits(uint8_t n) { buffer_.push_back(n); } void ByteBuffer::encode16Bits(uint16_t n) { encode8Bits(uint8_t((n & 0xff00) >> 8)); encode8Bits(uint8_t((n & 0x00ff) )); } void ByteBuffer::encode32Bits(uint32_t n) { encode16Bits(uint16_t((n & 0xffff0000) >> 16)); encode16Bits(uint16_t((n & 0x0000ffff) )); } void ByteBuffer::encode64Bits(uint64_t n) { encode32Bits(uint32_t((n & 0xffffffff00000000) >> 32)); encode32Bits(uint32_t((n & 0x00000000ffffffff) )); } This remains nicely platform agnostic since the numerical representation is always logically Big-Endian. This code also lends itself very nicely to using templates based on the size of the primitive type (think encode ((unsigned char const*)&val) )... not so pretty, but very, very easy to write and maintain.
