[site]: stackoverflow
[post_id]: 3818582
[parent_id]: 3817706
[tags]: 
1.Does it matter that there is no clear distinction between BLL and the DAL?. It sure does matter! Any programmer that uses your Table property needs to understand the ramifications (database roundtrip, query translation, object tracking). That goes for programmers reading the business logic classes as well. 2.Is queryability considered data access or business logic when behind a Repository layer that acts like an InMemory abstraction? Abstraction is a blanket that we hide our problems under. If your abstraction is perfect, then the queries could be abstractly considered as operating against in-memory collections and therefore they are not data access. However, abstractions leak. If you want queries that make sense in the data world, there must be effort to work above and beyond the abstraction. That extra effort (which defeats abstraction) produces data access code. Some examples: output = work.GetRepository ().Table.ToArray(); This is code is (abstractly) fine. But in the data world it results in scanning an entire table and is (at least generally) dumb! badquery = work.GetRepository ().Table.Where(c => c.Name.Contains("Bob")).ToArray(); goodquery = work.GetRepository ().Table.Where(c => c.Name.StartsWith("Bob")).ToArray(); Goodquery is better than bad query when there's an index on Customer.Name . But that fact is not available to us unless we lift the abstraction. badquery = work.GetRepository ().Table .GroupBy(c => c.Orders.Count()) .Select(g => new { TheCount = g.Key, TheCustomers = g.ToList() }).ToArray(); goodquery = work.GetRepository ().Table .Select(c => new {Customer = c, theCount = c.Orders.Count()) .ToArray() .GroupBy(x => x.theCount) .Select(g => new { TheCount = g.Key, TheCustomers = g.Select(x => x.Customer).ToList() }) .ToArray(); goodquery is better than bad query since badquery will requery the database by group key, for each group (and worse, it is highly unlikely there is an index to help with filtering customers by c.Orders.Count() ). Testability is built into the Repository design. We can leverage the InMemory implementation to assert results with expectations. Be under no illusions that your queries are being tested if you actually run them against in-memory collections. Those queries are untestable unless a database is involved.
