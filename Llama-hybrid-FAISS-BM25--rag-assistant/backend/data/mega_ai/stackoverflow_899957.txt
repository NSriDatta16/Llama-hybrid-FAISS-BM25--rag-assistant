[site]: stackoverflow
[post_id]: 899957
[parent_id]: 897930
[tags]: 
From the question as asked and the sample code supplied, I don't see any need for using loadstring() when functions and closures are first-class values in the language. I would consider doing it like this: -- test.lua local f = function() print"local function f in test.lua" end f_generate = function() local fun = function() return f() end return fun end f_generate()() -- end of test.lua The motivation is clearer if there is a parameter to f_generate: -- test.lua local f = function(y) print("local function f("..y..") in test.lua") end f_generate = function(name) local fun = function() return f(name) end return fun end f_generate("foo")() f_generate("bar")() -- end of test.lua Going through the parser with loadstring() explicitly takes the code outside the scope of the call to loadstring() . Local variables are not stored in any environment table. They are implemented much the same way they would be in any other language: storage for them is allocated by the code generator and is not accessible outside that compilation. Of course, the debug module (and API) has the ability to peek at them, but that is never recommended for use outside of a debugger. The correct way to preserve a reference to a local for use outside the scope is as a true upvalue to a closure. That is what is achieved by fun = function() return f() end . In that case, the value f is retained as an upvalue to the function stored in fun . Note that in practice, this wrapping as an upvalue is quite efficient. No name lookup is needed to find the value, and since I used a tail-call, no extra stack frames are required either.
