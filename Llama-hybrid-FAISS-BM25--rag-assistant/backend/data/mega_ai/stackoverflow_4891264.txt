[site]: stackoverflow
[post_id]: 4891264
[parent_id]: 4885127
[tags]: 
Not to totally throw off the direction you were going with this, but your handler may be better implemented and consumed as a WebMethod (i.e. either using a web service if you reuse the result generation method on multiple pages or as a page method on a single page if it's only used there). A complete how-to for web services is here: http://encosia.com/2008/03/27/using-jquery-to-consume-aspnet-json-web-services/ To consume the exact same service as a page method, check out: http://encosia.com/2008/05/29/using-jquery-to-directly-call-aspnet-ajax-page-methods/ I have used and abused those articles several times. You could frame your service or page method (declare this function static if you go with page method) as follows: [WebMethod] public string[] GetSearchResults(int authorityTypeId, string searchTerms) { if (authorityTypeId > 0 && searchTerms != string.Empty) { var authorities = from a in BusinessLayer.SearchAuthorities(authorityTypeId, searchTerms) select a.Name; return authorities.ToArray(); } else { return null; } } You can bind the data source update to the search event as follows: $(function() { $("# ").autocomplete({ minLength: 2, delay: 0, dataType: "json", search: function(e, ui) { var $input = this; $.ajax({ type: "POST", contentType: "application/json; charset=utf-8", url: "/Path/To/Service/Or/page.aspx/GetSearchResults", data: "{authorityTypeId:"+ $("# ").val() + ",searchTerms:'" + $("# ").val() + "'}", dataType: "json", success: function (result) { $input.autocomplete("option", "source", result.d); } }); } }); }); As an alternative to manually building the data member's JSON string for your $.ajax() call, you could instead build a data object and have the browser's JSON object stringify for you. var data = {}; data.authorityTypeId = parseInt($("# ").val()); data.searchTerms = $("# ").val(); $.ajax({ ... data: JSON.stringify(data) }); Keep in mind that support for native JSON objects in IE only began as recently as IE8 so you'd have to include a script to build it for older browsers like IE7. I haven't used AutoComplete's search event binding, but I have bound the data source on page load through asynch postback so page rendering isn't blocked by downloading a database of over a thousand searchable names. That being said, I'm not certain what behavior would be produced binding data source updates to that event. My first instinct would be binding the data once during $(document).ready() to get all names and letting the autocomplete object do the filtration for you.
