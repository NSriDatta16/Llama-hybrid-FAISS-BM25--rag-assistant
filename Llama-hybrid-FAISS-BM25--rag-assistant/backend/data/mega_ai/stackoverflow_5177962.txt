[site]: stackoverflow
[post_id]: 5177962
[parent_id]: 5177446
[tags]: 
Adding > paramters.CompilerOptions /t:winexe seemed to work for me: CodeDomProvider codeProvider = CodeDomProvider.CreateProvider("CSharp"); string output = "Out.exe"; var parameters = new CompilerParameters(); parameters.GenerateExecutable = true; parameters.OutputAssembly = output; parameters.ReferencedAssemblies.Add("System.dll"); parameters.ReferencedAssemblies.Add("System.Drawing.Dll"); parameters.ReferencedAssemblies.Add("System.Windows.Forms.Dll"); parameters.CompilerOptions = "/t:winexe"; var results = codeProvider.CompileAssemblyFromSource(parameters, "namespace Bah { static class Program { static void Main() { System.Threading.Thread.Sleep(100000); } } }"); But I also added this (for good measure): var psi = new ProcessStartInfo(output) {CreateNoWindow = true}; Process.Start(output); Without the /t:winexe I got a command window, which would show up if done your way, or flicker if the ProcessStartInfo was added. With the /t:winexe option the window went away for me, but I left the ProcessStartInfo set to NoWindow also. I'd like to pontificate that compiling a form like that is really rigid and fragile and there doesn't seem to be any reason to do it. When I've dealt with the CodeDom, we compiled dynamic user imput that represented calculations and formulas that the user had created. It was difficult to manage, and slow for large packages. An embedded scripting engine would have been a better choice, but there was no cost-effective way to rip it out and replace it, and so we were technically committed to that approach
