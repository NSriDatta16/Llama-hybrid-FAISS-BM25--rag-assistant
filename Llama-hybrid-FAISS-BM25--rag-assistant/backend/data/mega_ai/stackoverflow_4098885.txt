[site]: stackoverflow
[post_id]: 4098885
[parent_id]: 4098248
[tags]: 
Better This is broken for the k=0 case, because I think it'll return a set containing the empty set, which isn't quite right. Anyway. There's also an iteration in here, you could probably replace that with recursion if the goal is being PURELY recursive. This is a fairly straightforward modification of the algorithm given at wikipedia: powerset . I'll leave fixing the corner cases (k=0) to the reader. This is not properly tail-recursive, not that it matters in most JVMs. (I guess the IBM JVM does this...) class RecursivePowerKSet { static public Set > computeKPowerSet(final Set source, final int k) { if (k==0 || source.size() > set = new HashSet >(); set.add(Collections.EMPTY_SET); return set; } if (source.size() == k) { Set > set = new HashSet >(); set.add(source); return set; } Set > toReturn = new HashSet >(); // distinguish an element for(E element : source) { // compute source - element Set relativeComplement = new HashSet (source); relativeComplement.remove(element); // add the powerset of the complement Set > completementPowerSet = computeKPowerSet(relativeComplement,k-1); toReturn.addAll(withElement(completementPowerSet,element)); } return toReturn; } /** Given a set of sets S_i and element k, return the set of sets {S_i U {k}} */ static private Set > withElement(final Set > source, E element) { Set > toReturn = new HashSet >(); for (Set setElement : source) { Set withElementSet = new HashSet (setElement); withElementSet.add(element); toReturn.add(withElementSet); } return toReturn; } public static void main(String[] args) { Set source = new HashSet (); source.add("one"); source.add("two"); source.add("three"); source.add("four"); source.add("five"); Set > powerset = computeKPowerSet(source,3); for (Set set : powerset) { for (String item : set) { System.out.print(item+" "); } System.out.println(); } } } Power Set Only This doesn't probably quite get there, and isn't really elegant, but it computes the full powerset recursively, then trims it (iteratively) for size. class RecursivePowerSet { static public Set > computeConstrainedSets(final Set > source, final SizeConstraint > constraint) { Set > constrained = new HashSet >(); for (Set candidate : source) { if (constraint.meetsConstraint(candidate)) { constrained.add(candidate); } } return constrained; } static public Set > computePowerSet(final Set source) { if (source.isEmpty()) { Set > setOfEmptySet = new HashSet >(); setOfEmptySet.add(Collections.EMPTY_SET); return setOfEmptySet; } Set > toReturn = new HashSet >(); // distinguish an element E element = source.iterator().next(); // compute source - element Set relativeComplement = new HashSet (source); relativeComplement.remove(element); // add the powerset of the complement Set > completementPowerSet = computePowerSet(relativeComplement); toReturn.addAll(completementPowerSet); toReturn.addAll(withElement(completementPowerSet,element)); return toReturn; } static private Set > withElement(final Set > source, E element) { Set > toReturn = new HashSet >(); for (Set setElement : source) { Set withElementSet = new HashSet (setElement); withElementSet.add(element); toReturn.add(withElementSet); } return toReturn; } public static void main(String[] args) { Set source = new HashSet (); source.add("one"); source.add("two"); source.add("three"); source.add("four"); source.add("five"); SizeConstraint > constraint = new SizeConstraint >(3); Set > powerset = computePowerSet(source); Set > constrained = computeConstrainedSets(powerset, constraint); for (Set set : constrained) { for (String item : set) { System.out.print(item+" "); } System.out.println(); } } static class SizeConstraint { final int size; public SizeConstraint(final int size) { this.size = size; } public boolean meetsConstraint(V set) { return set.size() == size; } } }
