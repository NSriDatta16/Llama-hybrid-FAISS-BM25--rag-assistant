[site]: crossvalidated
[post_id]: 457226
[parent_id]: 
[tags]: 
Forecast regular values of differenced series

I have read How to “undifference” a time series variable but since it's been many years since it's been answered, maybe there's another solution. I have non-stationary series and I need to provide multiple forecasting methods. Some of them, like mean, naive, MA and SES require the data to be stationary, so I would run: train_diff But obviously this returns the forecast for the differenced data and not the regular level data. This plot explains it pretty well, on the first one the red line is the regular test data, and on the second one is the differenced test data. I tried the diffinv() function and this is the result: > diffinv(mean_seasdiff$mean) Time Series: Start = c(2017, 296) End = c(2017, 303) Frequency = 365 [1] 0.0000000 0.1122047 0.2244094 0.3366142 0.4488189 0.5610236 0.6732283 0.7854331 Which is according to the question I referenced before. I am using test data here because later in my analysis I need to forecast 7 days, without any test set to compare. So I would like to know if this is possible from differenced data. EDIT: The naive case is simpler to solve, but let's say with a Mean model. I did one for the regular data and one for the differenced one. mean_reg mean_diff$mean Time Series: Start = c(2017, 297) End = c(2017, 303) Frequency = 365 [1] 0.005870841 0.005870841 0.005870841 0.005870841 0.005870841 0.005870841 0.005870841 > tail(train_data) Time Series: Start = c(2017, 291) End = c(2017, 296) Frequency = 365 [1] 84 51 76 65 50 55 > tail(train_diff) Time Series: Start = c(2017, 291) End = c(2017, 296) Frequency = 365 [1] 8 -33 25 -11 -15 5 And the plots would be: According to the first comment on my original post, is grab the last value in the train_data and add the first forecast over the differenced data. That would be: 55 + 0.00587 Does that make sense? Same thing for SES, STL and ETS then?
