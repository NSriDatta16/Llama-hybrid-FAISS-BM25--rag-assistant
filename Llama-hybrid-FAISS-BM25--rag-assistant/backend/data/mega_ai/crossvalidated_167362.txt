[site]: crossvalidated
[post_id]: 167362
[parent_id]: 
[tags]: 
Factored sparse coding: how to differentiate coordinate transform?

I'm trying to implement a sparse coding technique described by Bergstra et al in this paper . The encoding process there includes the following computation: $translate(rotate(scale(\mathbf{u}, \alpha, \beta), \theta), \delta), \eta)$ where $\mathbf{u}$ is generic Gabor filter. Considering that $\mathbf{u}$ is constant, sparse coding dictionary is parametrized by transformation parameters $\{\alpha, \beta, \theta, \delta, \eta\}$. The thing I don't get is how do you compute the gradient of the transformation with respect to $\mathbf{u}$? Cosidering that the objective function is $\sum_{i}(z_{i}-u^{tr}_{i}x^{*})$, where $\mathbf{z}$ is original image and $x^{*}$ is the code (scalar, in the simple case of only one code component), is it even possible to compute such a derivative? Or am I getting something wrong here? UPDATE I guess my problem is that the error between an image and a rotated image seems non-differentiable to me (is it?). I'll try to illustrate it with a simpler example: suppose there's an image, that we try to approximate by another image, rotating the latter by some angle. The parameter we're trying to find is the angle, say $a$. Then, we can plot the error function $J(a)$ by rotating the original image by different angles, and it looks like this: (0 point corresponds to rotating the original by 0 angle, which gives zero error, unsurprisingly) But that function doesn't even look smooth (meaning it's non-differentiable), so there's no way we can find the correct $a$ value by gradient descent. The code for that simple demonstration: import numpy as np import matplotlib.pyplot as plt import mdp from skimage.transform import rotate def get_gabor(): g = mdp.utils.gabor( (20, 20), 0, np.pi / 2., 0.5, (4., .5) ) return g if __name__ == '__main__': orig = get_gabor() errs = [] angles = [] for a in np.linspace(-90, 90, 200): angles.append(a) rot = rotate(orig, a) err = np.sum((orig - rot) ** 2) errs.append(err) plt.plot(angles, errs) plt.show() Still, I must me missing something here...
