[site]: stackoverflow
[post_id]: 1970467
[parent_id]: 1967726
[tags]: 
If you know that your library will only ever be used from a single synchronization context, then I see no reason why you can't capture the synchronization context using a static member (your option A). Why do you see a need to make this dependency 'explicit'? Where option A could potentially be problematic is if your library may be used from multiple synchronization contexts at the same time. (For example multiple UI windows running on their own thread and message pump). This is fairly unusual though - mostly you have a single UI thread and a single synchronization context. Also, if an application wishes to handle some events without forcing serialization to the UI thread (via the sync context) it cannot do so. If these issues are not a problem for your library, then option A should be viable. Edit - in response to comment: Joel, I'm not sure if this is helpful given what you describe, but one thing you might want to consider if you sometimes want to use an explicit synchronization context would be to use thread-local storage to store the parameter without needing to create overrides of the method to take the parameter. For example, I have in the past myself needed to allow callers to my APIs to both use the default synchronization context for the current calling thread but also to explicitly set a different synchronization context. One approach I could have taken would have been to provide overloads of my API methods that allow passing a synchronization context parameter. In my case, this would have been pretty ugly since it would have meant creating a lot of method overloads for a fairly infrequent use case. So, what I did instead was create a class that handled creating a 'scope' during which the current sync context gets overridden (thereby effectively passing it to the called methods). The class takes care of (in order) 1) caching the current sync context, 2) setting the current context to a sync context specified by the caller, and 3) resetting the sync context at the end of the 'scope'. Here's what it looks like: public class SyncContextScope : IDisposable { SynchronizationContext m_contextOnEntry; /// /// Constructor /// /// public SyncContextScope(SynchronizationContext useContext) { m_contextOnEntry = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(useContext); } #region IDisposable Members void IDisposable.Dispose() { SynchronizationContext.SetSynchronizationContext(m_contextOnEntry); } #endregion } And you use it like so: using(new SyncContextScope(yourSyncContext)) { yourApi.CallSomeMethod(); } Your API's method (in the above example CallSomeMethod) can now make use of the SynchronizationContext.Current (which uses TLS to store a sync context). All without having to resort to providing a sychronizationcontext parameter.
