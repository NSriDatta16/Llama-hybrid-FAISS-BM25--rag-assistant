[site]: stackoverflow
[post_id]: 2518096
[parent_id]: 2517944
[tags]: 
There's nothing to be gained from spawning a thread if your goal is to get the splash screen up as quickly as possible. There are several ways to do splash screens, and a more sophisticated one is mentioned here , but this is an easy method I have used with complete success: Just ensure you load and show the splash form first , and then continue to load your app while the user is looking at the pretty splash screen. When the mainform is done loading, it can close the splash right before it shows itself (a simple way to do this is pass the splash form to the mainform in its constructor): static void Main() { Application.SetCompatibleTextRenderingDefault(false); SplashForm splash = new SplashForm(); splash.Show(); splash.Refresh(); // make sure the splash draws itself properly Application.EnableVisualStyles(); Application.Run(new MainForm(splash)); } public partial class MainForm : Form { SplashForm _splash; public MainForm(SplashForm splash) { _splash = splash; InitializeComponent(); } protected override void OnLoad(EventArgs e) { base.OnLoad(e); // or do all expensive loading here (or in the constructor if you prefer) _splash.Close(); } } Alternative: If you prefer not to pass the splash to the MainForm (maybe it seems inelegant), then subscribe to the MainForm's Load event, and close the splash screen there: static class Program { static SplashForm _splash; [STAThread] static void Main() { Application.SetCompatibleTextRenderingDefault(false); _splash = new SplashForm(); _splash.Show(); _splash.Refresh(); Application.EnableVisualStyles(); MainForm mainForm = new MainForm(); mainForm.Load += new EventHandler(mainForm_Load); Application.Run(mainForm); } static void mainForm_Load(object sender, EventArgs e) { _splash.Dispose(); } } As mentioned in this thread , the potential downside to this solution is that the user won't be able to interact with the splash screen. However, that usually isn't required.
