[site]: stackoverflow
[post_id]: 5442583
[parent_id]: 
[tags]: 
wait for a method to finish before starting another

assume that i have two sequential methods, methodA and methodB ( methodB is called at the end of methodA ) and i need to finish completely with the process of methodA before starting methodB : -(void)methodA { //do some very heavy computation here [self methodB]; } -(void)methodB { //this method performs some animation } methodA requires alot of processing power and takes time to finish while methodB has animations. The animations are starting laggy at first and im guessing this has to do with the overhead of method A. So how can i make the second method start only after the first has finished completely? this is the actual code: the code is very messy and unorganized. there is alot of code that has been commented out so please ingore that. I test some things sometimes and then comment them out incase i need them later. here is what is happening: it starts with (void)checkMoves method. This method calls either one of two similar methods which are -(void)getMovesForJourney:(int)journey withRolls:(NSArray *)rolls or -(void) getEntryMovesForJourney:(int)journey withRolls:(NSArray *)rolls these methods are wrappers for a long recursive process (which is most probably where the multithreading is happening). at the end of (void)checkMoves another method -(void)analyseMoves is called. This is also a heavy process. and finally, at the end of -(void)analyseMoves the animation method -(void)move: is called. this last method is starting with a lag. finally at the end of -(void)move: the process will start again until no more 'moves' are available. the methods below are not in order so please refer to the description above to know whats going on. -(void) checkMoves { GameScene *game = [GameScene sharedGameScene]; CCLOG(@"start"); for (Stone *stone in stones) { if (!stone.onBoard) { if ([game EntryAvailable]) { [self getEntryMovesForJourney:stone.journey withRolls:[game rollsAsIntegers]]; } } else { [self getMovesForJourney:stone.journey withRolls:[game rollsAsIntegers]]; } } CCLOG(@"finish"); [self analyseMoves]; } -(NSMutableArray *) otherPlayerLocations { GameScene *game = [GameScene sharedGameScene]; Board *board = [game board]; Player *otherPlayer = [game playerOne]; NSMutableArray *locations = [[[NSMutableArray alloc] init] autorelease]; for (Stone *stone in otherPlayer.stones) { if (stone.journey 0) { NSMutableArray *killMoves = [[[NSMutableArray alloc] init] autorelease]; NSMutableArray *safeMoves = [[[NSMutableArray alloc] init] autorelease]; int mostThreatened; float highestThreat = -1.0; float lowestThreat = 100.0; AIMove *safestMove; //get kill and safe moves in seperate arrays for (AIMove *move in moves) { if (move.moveType == killMoveType) [killMoves addObject:move]; else if (move.moveType == safeMoveType) [safeMoves addObject:move]; // get highest threatened stone //if (move.potThreat > highestThreat) { // mostThreatened = move.journey; // highestThreat = move.potThreat; if (move.initThreat 0) { //leave one move in killMoves with highest journey killJourney = [[killMoves objectAtIndex:0] tileTag]; for (AIMove *killMove in killMoves) { if (killMove.tileTag 0) { [self move:[killMoves objectAtIndex:0]]; CCLOG(@"Kill move chosen"); } else { CCLOG(@"this is called!!!!"); CCLOG(@"safest move with initThreat: %i, potThreat: %i",safestMove.journey, safestMove.tileTag); [self move:safestMove]; CCLOG(@"Success"); } /* else if (safeMoves.count > 0) { [self move:[safeMoves objectAtIndex:0]]; CCLOG(@"safe move chosen"); } else { //temp random move generation randomMove = CCRANDOM_0_1()*[moves count]; AIMove *move = [moves objectAtIndex:randomMove]; [self move:move]; CCLOG(@"Random move chosen"); } */ } } -(void) assignThreatLevel:(AIMove *)move { NSArray *otherPlayerStones = [self otherPlayerLocations]; NSMutableArray *initThreats = [[NSMutableArray alloc] init]; NSMutableArray *potThreats = [[NSMutableArray alloc] initWithCapacity:4]; for (NSNumber *location in otherPlayerStones) { //get threat levels for potential moves if (move.tileTag > [location intValue]) { int dif = move.tileTag - [location intValue]; CCLOG(@"dif: %i",dif); //threat level conditions: // 1 >> 5 = 70% of journey // 6 >> 9 = 40% of journey // 10 & 11 = 50% of journey // 12 >> 24 = 20% of journey // 25 && 26 = 50% of journey // 27+ = 20% of journey if (move.tileTag = 1 && dif = 6 && dif = 12 && dif 26) { [initThreats addObject:[NSNumber numberWithFloat:k27plus]]; } //------------------------------------- } //get Threat levels for current positions if (move.tileTag > [location intValue]) { int dif = move.tileTag - [location intValue]; //threat level conditions: // 1 >> 5 = 70% of journey // 6 >> 9 = 40% of journey // 10 & 11 = 50% of journey // 12 >> 24 = 20% of journey // 25 && 26 = 50% of journey // 27+ = 20% of journey if (move.journey 75) [potThreats addObject:[NSNumber numberWithFloat:0.0f]]; else if (dif >= 1 && dif = 6 && dif = 12 && dif 26) [potThreats addObject:[NSNumber numberWithFloat:k27plus]]; //------------------------------------- } } float initThreat = 0.0f; float potThreat = 0.0f; for (NSNumber *number in initThreats) { if ([number floatValue] > initThreat) initThreat = [number floatValue]; } for (NSNumber *number in potThreats) { if ([number floatValue] > potThreat) potThreat = [number floatValue]; } move.initThreat = initThreat; move.potThreat = potThreat; [initThreats release]; } -(void) move:(AIMove *)move { CCLOG(@"Moves count: %i",[moves count]); if ([moves count] > 0) { BOOL isOtherStoneOnPreviousTile = NO; int total; if (move.tileTag > 8) total = move.tileTag - move.journey; else if (move.tileTag 8) total = ((9-move.tileTag)+75) - move.journey; else if (move.tileTag 0) { for (int i = 1; i 8 && !stone.crossedEntry) stone.crossedEntry = YES; //============================================ if (stone.journey 0 && [self convertJourneyToTileTag:journey] == tile.bTag) { CCLOG(@"blue stone killed"); [self returnStoneToOrigin:stone]; } } if (tileTag == tile.bTag) { if (journey > 0 && [self convertJourneyToTileTag:journey] == tile.aTag) { CCLOG(@"gold stone killed"); [self returnStoneToOrigin:stone]; } } } } } -(void)removeRollTypes:(NSArray *)theRollTypes { GameScene *game = [GameScene sharedGameScene]; NSMutableArray *rolls = [game rolls]; for (NSNumber *roll in theRollTypes) { NSUInteger index = [rolls indexOfObject:[game convertIntToRoll:roll]]; CCLOG(@"rolltypes count: %i",[theRollTypes count]); CCLOG(@"roll integer: %i",[roll intValue]); [rolls removeObjectAtIndex:index]; } } #pragma mark - #pragma mark enumerations - (NSArray*)getSums:(NSArray*)numbers { NSMutableArray *result = [self getSumsHelper:numbers startingFrom:0]; [result removeObjectAtIndex:0]; return result; } - (NSMutableArray*)getSumsHelper:(NSArray*)numbers startingFrom:(NSUInteger)index { /* (1) */ if (index >= [numbers count]) return [NSMutableArray arrayWithObject:[NSNumber numberWithFloat:0]]; /* (2) Generate all the subsets where the `index`th element is not included */ NSMutableArray* result = [self getSumsHelper:numbers startingFrom:index+1]; // NSSortDescriptor *mySorter = [[NSSortDescriptor alloc] initWithKey:@"floatValue" ascending:YES]; // [result sortUsingDescriptors:[NSArray arrayWithObject:mySorter]]; /* (3) Add all the cases where the `index`th element is included */ NSUInteger i, n = [result count]; float element = [[numbers objectAtIndex:index] floatValue]; for (i = 0; i = target) { return results; } for (int i = 0; i
