[site]: datascience
[post_id]: 128020
[parent_id]: 
[tags]: 
kernal failure on data science ICA algorithm for independent component analysis

ICA algorithm Problem Statement The goal is to have the ICA algorithm for independent component analysis custom python code perform convergence on many independent audio wave files, e.g., 10, 15, 20, 25, 30) to build the numpy cov(wave file (aggregated from the )) fuction on a transformed wave file. Then get the eigen decomposition on the numpy linalg.eigh() using the librosa to create a input audio wave file that has has the shape (3, 76800), e.g., reading 3 wave files. Then performing whitening transformations. Then centers and normalizes the wave data and provide input for the weights. My algorithm for center and normalization is to compute the not product for weights (transformed with the wave audio data) the get the sum of the dot product and subtract the weights My algorithm for compute eigenvector whiten is to first get the engenvectors (linalg), then create a diagnal inverse matrix on the eignvectors. The compute the matricx with the diagonal matricx and compute the dot product on the diagnal inverse matrix ('diag_inverse_sqrt_Eigen') with transposing the eigenvectors. Returning the dot product matrix + audio wave data. So this is all created in the eigenvector whiten For my algorithm for the ICA, I perform the centering of the data, retrive the whiten data, just described, then iteratate until data audio converges with the provided weights 3, 1), not with shape (3, 76800) (below question). Then precede to compute new weigghts to update weights, and invoke the get_center_normalize() fuction. Apply a contract function on the derivative of g prime (get_g_prime, and get_derivative_g_prime). Then noramlize the weight vector with square root. Then update weights matrix by columns. Question on my algorithms So I am making any algorithm logic on the ICA functions (above)? Because when I run the code in juptyer the kernal continually hands, so I was intersted if any one has coded an ICA algorthim that had any logical issues because when run, the kernal which never finishes. Raising this informative question algorithm logic or the weights, I assign the numpy random.rand() to match the shape, but not using the (3, 76800), but the (3, 1) shape. Perhaps my eigen_decomposition, eigens = np.linalg.eigh(cov) cannot handle such a large (3, 76800) shape? My Attempt to Fix the Problem The only area that I attempted to fix was the reshaped weights with np.random.rand(3, 1), not with shape of the audio: (3, 76800) Data Here is the sample of the audio file read in (3, 76800) array([[ 0.00073242, -0.01550293, -0.00012207, ..., -0.02679443, -0.0149231 , -0.01263428], [ 0.00125122, -0.03317261, -0.02246094, ..., -0.01159668, -0.00915527, -0.01535034], [ 0.00228882, -0.03683472, 0.03234863, ..., -0.0730896 , -0.06356812, -0.07080078]], dtype=float32) Code def get_center(X): mean = np.mean(X, axis=1, keepdims=True) return X - mean def get_eigen_whiten(X): cov = np.cov(X.T) eigen_decomposition, eigens = np.linalg.eigh(cov) diag_inverse_sqrt_Eigen = np.diag(1.0 / np.sqrt(eigen_decomposition)) whiten_matrix = np.dot(diag_inverse_sqrt_Eigen, np.transpose(eigens)) X_white = np.dot(whiten_matrix, X) return X_white, whiten_matrix def get_g_prime(x): return np.tanh(x) def get_derivative_g_prime(x): return 1 - get_g_prime(x)**2 def get_center_normalize(weights, X): weights = weights.reshape(-1, 1) dot_product = np.dot(weights.T, X) return weights - np.sum(dot_product * X, axis=1, keepdims=True) * X def fast_ica(X, max_iter=1000, tol=1e-5): X = np.array(X) n_features, n_samples = X.shape X = get_center(X) X_white, _ = get_engen_whiten(X) W = np.random.rand(n_features, n_features) for _ in range(max_iter): W_prev = W.copy() for i in range(n_features): w = get_center_normalize(W[i, :], X_white) w_new = (X_white * g(np.dot(w.T, X_white))).mean(axis=1) - g_prime(np.dot(w.T, X_white)).mean() * w w_new /= np.sqrt((w_new ** 2).sum()) W[:, i] = w_new if np.max(np.abs(np.abs((W * W_prev).sum(axis=1) - 1)))
