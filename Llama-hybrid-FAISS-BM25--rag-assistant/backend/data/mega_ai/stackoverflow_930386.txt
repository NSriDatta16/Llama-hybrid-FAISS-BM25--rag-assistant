[site]: stackoverflow
[post_id]: 930386
[parent_id]: 929976
[tags]: 
Data structures which do not contain a contiguous set of values are known as sparse or compressed data structures. It seems that this is what you are looking for. If this is case, you want a sparse vector . There is one implemented in boost, see link text Sparse structures are typically used to conserve memory. It is possible from your problem description that you don't actually care about memory use, but about addressing elements that don't yet exist (you want an auto-resizing container). In this case a simple solution with no external dependencies is as follows: Create a template class that holds a vector and forwards all vector methods to it. Change your operator[] to resize the vector if the index is out of bounds. // A vector that resizes on dereference if the index is out of bounds. template struct resize_vector { typedef typename std::vector ::size_type size_type; // ... Repeat for iterator/value_type typedefs etc size_type size() const { return m_impl.size() } // ... Repeat for all other vector methods you want value_type& operator[](size_type i) { if (i >= size()) resize(i + 1); // Resize return m_impl[i]; } // You may want a const overload of operator[] that throws // instead of resizing (or make m_impl mutable, but thats ugly). private: std::vector m_impl; }; As noted in other answers, elements aren't cleared when a vector is resized. Instead, when new elements are added by a resize, their default constructor is called. You therefore need to know when using this class that operator[] may return you a default constructed object reference. Your default constructor for should therefore set the object to a sensible value for this purpose. You may use a sentinel value for example, if you need to know whether the element has previously been assigned a value. The suggestion to use a std::map also has merit as a solution, provided you don't mind the extra memory use, non-contiguous element storage and O(logN) lookup rather than O(1) for the vector. This all boils down to whether you want a sparse representation or automatic resizing; hopefully this answer covers both.
