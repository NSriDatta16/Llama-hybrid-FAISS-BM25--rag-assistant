[site]: stackoverflow
[post_id]: 653338
[parent_id]: 653289
[tags]: 
The outcome is implementation dependent. However, in practice, every single x86, PPC, and MIPS compiler I have ever worked with has followed this rule for shifting right: If the operand is a signed integer, the vacant bit is filled with the sign bit (really the most significant bit) If the operand is an unsigned integer, the vacant bit is filled with zero. As RBerteig says, this is so that for signed integers, n >> 1 = n/2 (rounded down ) for both positive and negative n, and for unsigned integers, n >> 1 = n/2 even for n > 2^31 (on a 32-bit architecture). The corresponding hardware instructions are arithmetic (sign-extending) and logical (not sign-extending) shift; the compiler chooses between them based on whether the operand is signed or unsigned.
