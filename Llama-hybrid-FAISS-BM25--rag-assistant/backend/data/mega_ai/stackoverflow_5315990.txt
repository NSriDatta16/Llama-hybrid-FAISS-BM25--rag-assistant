[site]: stackoverflow
[post_id]: 5315990
[parent_id]: 
[tags]: 
How to copy cells between tables as the pulse app

I need to copy cells between 2 table views . I have a more-or-less working solution. However, it is not smooth, and I would love to do something similar to the pulse app reorder feeds option... Something special in the way that pulse works, is that the reorder animation is the same as in a normal reorder of cells, but still the cell can move between tables. This is what I have now: - (BoardColumnView *) addColumn:(NSString *)title type:(ColumnType)type{ BoardColumnView *col = [BoardColumnView createColumn:title]; [self.columns addObject:col]; // Add a pinch gesture recognizer to the table view. UILongPressGestureRecognizer* draggingRecognizer = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(moveActionGestureRecognizerStateChanged:) ]; draggingRecognizer.minimumPressDuration = 0.5; draggingRecognizer.delegate = self; [col.tableView addGestureRecognizer:draggingRecognizer]; [draggingRecognizer release]; return col; } #pragma mark - #pragma mark UIGestureRecognizer Delegate/Actions - (BOOL) gestureRecognizerShouldBegin: (UIGestureRecognizer *) gestureRecognizer { ALog(@"Drag detected"); return YES; } - (void) moveActionGestureRecognizerStateChanged: (UIGestureRecognizer *) recognizer { switch ( recognizer.state ) { default: case UIGestureRecognizerStateFailed: // do nothing break; case UIGestureRecognizerStatePossible: case UIGestureRecognizerStateCancelled: { ALog(@"Canceled"); [UIView beginAnimations: @"SnapBack" context: NULL]; [UIView setAnimationCurve: UIViewAnimationCurveEaseOut]; [UIView setAnimationDuration: 0.5]; [UIView setAnimationDelegate: self]; [UIView setAnimationDidStopSelector: @selector(finishedSnap:finished:context:)]; CGRect f = self.dragView.frame; f.origin = _dragOriginCellOrigin; self.dragView.frame = f; [UIView commitAnimations]; break; } case UIGestureRecognizerStateEnded: { // move the real cell into place [UIView beginAnimations: @"SnapToPlace" context: NULL]; [UIView setAnimationCurve: UIViewAnimationCurveEaseOut]; [UIView setAnimationDuration: 0.5]; [UIView setAnimationDelegate: self]; [UIView setAnimationDidStopSelector: @selector(finishedSnap:finished:context:)]; CGRect r = self.dragView.frame;//[self.content rectForItemAtIndex: _emptyCellIndex]; CGRect f = self.dragView.frame; f.origin.x = r.origin.x + floorf((r.size.width - f.size.width) * 0.5); f.origin.y = r.origin.y + floorf((r.size.height - f.size.height) * 0.5); NSLog( @"Gesture ended-- moving to %@", NSStringFromCGRect(f) ); self.dragView.frame = f; self.dragView.transform = CGAffineTransformIdentity; self.dragView.alpha = 1.0; [UIView commitAnimations]; break; } case UIGestureRecognizerStateBegan: { ALog(@"Start move.."); // find the cell at the current point and copy it into our main view, applying some transforms _lastColumn = (BoardColumnView *)[(UITableView *)recognizer.view superview]; _targetColumn = _lastColumn; if (_lastIndexPath) { [_lastIndexPath release]; _lastIndexPath = nil; } _lastIndexPath = [_lastColumn.tableView indexPathForRowAtPoint:[recognizer locationInView: _lastColumn]]; UITableViewCell *sourceCell = [_lastColumn.tableView cellForRowAtIndexPath:_lastIndexPath]; CGRect frame = [_lastColumn convertRect: sourceCell.frame fromView: self.content]; self.dragView = [[[UIImageView alloc] initWithImage:[sourceCell screenshot]] autorelease]; self.dragView.opaque = YES; self.dragView.backgroundColor = _lastColumn.backgroundColor; self.dragView.center = [recognizer locationInView: self.view]; //self.dragView.cornerRadius = 8; // if you like rounded corners self.dragView.layer.shadowOffset = CGSizeMake(-5, 2); self.dragView.layer.shadowRadius = 5; self.dragView.layer.shadowOpacity = 0.5; [content addSubview: self.dragView]; [content bringSubviewToFront:self.dragView]; // grab some info about the origin of this cell _dragOriginCellOrigin = frame.origin; [UIView beginAnimations: @"" context: NULL]; [UIView setAnimationDuration: 0.2]; [UIView setAnimationCurve: UIViewAnimationCurveEaseOut]; // transformation-- larger, slightly transparent self.dragView.transform = CGAffineTransformMakeScale( 1.2, 1.2 ); self.dragView.alpha = 0.7; [UIView commitAnimations]; /* // reload the grid underneath to get the empty cell in place [self.content reloadItemsAtIndices: [NSIndexSet indexSetWithIndex: index] withAnimation: AQGridViewItemAnimationNone]; */ break; } case UIGestureRecognizerStateChanged: { // update draging cell location self.dragView.center = [recognizer locationInView: self.view]; //Determinar sobre que columna esta flotando.. CGRect global; if (_targetColumn) { _targetColumn = nil; } for (BoardColumnView *col in self.columns) { UITableView *table = col.tableView; global = [table convertRect:self.dragView.frame fromView:content]; if ([table pointInside:global.origin withEvent:nil]) { ALog([NSString stringWithFormat: @"Esta sobre la tabla %@", col.column.name]); _targetColumn = col; break; } } if ( !_targetColumn ) { ALog(@"Esta en zona muerta"); } break; } } } - (void) finishedSnap: (NSString *) animationID finished: (NSNumber *) finished context: (void *) context { if (_targetColumn && _lastIndexPath) { ALog(@"Moviendo a nuevo destino"); CGRect frame = [_targetColumn convertRect: self.dragView.frame fromView: self.content]; NSIndexPath *destPath = [_targetColumn.tableView indexPathForRowAtPoint: frame.origin]; [UIView beginAnimations: @"" context: NULL]; [UIView setAnimationDelegate:self]; [UIView setAnimationDidStopSelector:@selector(animationDidStop:finished:context:)]; self.dragView.backgroundColor = _targetColumn.backgroundColor; //Si inserta entre tareas en destino... _lastColumn.totalRows -= 1; _targetColumn.totalRows += 1; [_lastColumn.tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:_lastIndexPath] withRowAnimation:UITableViewRowAnimationTop]; if (destPath) { [_targetColumn.tableView insertRowsAtIndexPaths:[NSArray arrayWithObject:destPath] withRowAnimation:UITableViewRowAnimationBottom]; } else { [_targetColumn.tableView reloadData]; } [UIView commitAnimations]; } else { ALog(@"Cancelado el moviento, regresar a home"); UITableViewCell * sourceCell = [_lastColumn.tableView cellForRowAtIndexPath:_lastIndexPath]; if (sourceCell) { [UIView beginAnimations: @"Back" context: NULL]; [UIView setAnimationCurve: UIViewAnimationCurveEaseOut]; [UIView setAnimationDuration: 0.5]; [UIView setAnimationDelegate:self]; [UIView setAnimationDidStopSelector:@selector(animationDidStop:finished:context:)]; //self.dragView.transform = CGAffineTransformIdentity; self.dragView.frame = [self.content convertRect: sourceCell.frame fromView: _lastColumn]; //self.dragView.alpha = 0.0; [UIView commitAnimations]; } } } - (void)animationDidStop:(id)animationID finished:(BOOL)flag context:(id)context { // dismiss our copy of the cell ALog(@"Eliminando drag view"); [self.dragView removeFromSuperview]; self.dragView = nil; _lastColumn = nil; _targetColumn = nil; if (_lastIndexPath) { _lastIndexPath = nil; } } UPDATE: I've created an open source project to show my progress so far: https://bitbucket.org/elmalabarista/dragdroptableviews
