[site]: stackoverflow
[post_id]: 1848740
[parent_id]: 1848268
[tags]: 
Edit : as the OP has now mentioned that the issue is one of relative import being preferred to absolute, the simplest solution for the OP's specific problem is to add at the start of the module from __future__ import absolute_import which changes that "preference"/ordering. The following still applies to the ticklish issue of two clashing absolute imports (which doesn't appear to be what the OP is currently facing...): Once you've imported a module named x , that module's recorded in sys.modules['x'] -- changing sys.path as you're doing won't alter sys.modules. You'll also need to alter sys.modules directly. E.g., consider: $ cat a/foo.py print __file__; import sys; sys.path.insert(0, "b"); del sys.modules["foo"]; import foo $ cat b/foo.py print __file__ $ python2.5 -c'import sys; sys.path.insert(0, "a"); import foo' a/foo.py b/foo.py (running again will use and show the .pyc files instead of the .py ones of course). Not the cleanest approach, and of course this way the original foo module is, inevitably, not accessible from the outside any more (since its sys.modules entry has been displaced), but you could play further fragile tricks as needed (stash sys.modules["foo"] somewhere before deleting it, after you import the other foo put that module somewhere else and reinstate the original sys.modules["foo"] -- etc, etc), depending on your exact needs. (Of course, avoiding the name clashes in the first place would almost invariably be simpler than waltzing all around them in this way;-).
