[site]: stackoverflow
[post_id]: 3860372
[parent_id]: 3860051
[tags]: 
As has already been noted, you've almost implemented a Monad here. Your code is a bit inelegant in that the lambdas have side-effects. Monads solve this more elegantly. So, why not turn your code into a proper Monad? Bonus: you can use LINQ syntax! I present: LINQ to Results Example: var result = from a in SomeThingHappensHere() let someData = a.Data from b in SomeOtherThingHappensHere(someData) from c in AndYetAnotherThing() from d in AndOneMoreThing(someData) select d; HandleTheFinalResultHere(result.Value); With LINQ to Results , this first executes SomeThingHappensHere . If that succeeds, it gets the value of the Data property of the result and executes SomeOtherThingHappensHere . If that succeeds, it executes AndYetAnotherThing , and so on. As you can see, you can easily chain operations and refer to results of previous operations. Each operation will be executed one after another, and execution will stop when an error is encountered. The from x in bit each line is a bit noisy, but IMO nothing of comparable complexity will get more readable than this! How do we make this work? Monads in C# consist of three parts: a type Something-of-T , Select / SelectMany extension methods for it, and a method to convert a T into a Something-of-T . All you need to do is create something that looks like a Monad, feels like a Monad and smells like a Monad, and everything will work automagically. The types and methods for LINQ to Results are as follows. Result type: A straightforward class that represents a result. A result is either a value of type T , or an error. A result can be constructed from a T or from an Exception . class Result { private readonly Exception error; private readonly T value; public Result(Exception error) { if (error == null) throw new ArgumentNullException("error"); this.error = error; } public Result(T value) { this.value = value; } public Exception Error { get { return this.error; } } public bool IsError { get { return this.error != null; } } public T Value { get { if (this.error != null) throw this.error; return this.value; } } } Extension methods: Implementations for the Select and SelectMany methods. The method signatures are given in the C# spec, so all you have to worry about is their implementations. These come quite naturally if you try to combine all method arguments in a meaningful way. static class ResultExtensions { public static Result Select (this Result source, Func selector) { if (source.IsError) return new Result (source.Error); return new Result (selector(source.Value)); } public static Result SelectMany (this Result source, Func > selector) { if (source.IsError) return new Result (source.Error); return selector(source.Value); } public static Result SelectMany (this Result source, Func > intermediateSelector, Func resultSelector) { if (source.IsError) return new Result (source.Error); var intermediate = intermediateSelector(source.Value); if (intermediate.IsError) return new Result (intermediate.Error); return new Result (resultSelector(source.Value, intermediate.Value)); } } You can freely modify the Result class and the extension methods, for example, to implement more complex rules. Only the signatures of the extension methods must be exactly as stated.
