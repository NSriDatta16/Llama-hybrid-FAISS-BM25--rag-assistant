[site]: stackoverflow
[post_id]: 4177182
[parent_id]: 4176582
[tags]: 
The tests you've written are a pretty good start! Trying it out, practicing and working out what works and what doesn't is how anyone who is a 'guru' becomes one in the first place. (I've not met any 'gurus' yet; just people with years of practice). There are a few questions so I'm going to answer them in turn. Integration Testing is really slow, yes. I normally do this for the whole application, from the Gui or web page, for certain key scenarios across the entire system, because performing the same tests manually is time consuming. As the application grows, so does the amount of regression testing which the testers will have to do. You can help them by writing these automated tests. Developers hardly ever see the benefit of the automated tests, because it's the testers who really need them and use them. Think of it from their perspective and you may see more value. Actually deriving the scenarios in the first place can be valuable because it helps developers, testers and analysts find and address differences in their understanding of the system. Testing private methods should be unnecessary. However... If your method is complex, you can always split it out into a different class, and make your class collaborate with that one. If your private methods are the important ones then you probably should do this. Also, don't test methods. Describe each aspect of the behaviour of your class, show why it's valuable and give some examples of using it. Behaviour may involve more than one method. For instance, list.isEmpty requires us to work with list.add too; it's the interaction between them which is important for things using list . This is also why we don't test private methods - because they're of no benefit to the class using them on their own. The names of your tests could help to reflect this. Think "My view model should..." and then consider how it provides the valuable behaviour which it does. For instance, I would phrase your first test as "My View Model should notify listeners that the description changed", so ShouldNotifyListenersThatTheDescriptionChanged . Instead of setting up an expectation , consider that your class has some collaborating classes. Some of them provide the class with information - contexts which change its behaviour, producing different outcomes. Some of them do jobs for the class. The first are "stubs", the second "mocks" (terminology here is mixed across the business). Rather than setting up expectations, you're providing an example which shows how the class behaves within that context. Rather than verifying an outcome, you're showing that the class delegates its responsibilities appropriately. Mocks are just a useful way to do that. The typical tests I write are those which help me describe the behaviour of the code, ensure its responsibilities are appropriate and show why the code is valuable. That's most of the code, but I won't write examples for trivial classes - for instance, custom exceptions, objects which are just data or properties, etc. You can show the behaviour of a stored procedure by writing examples of using it in the different contexts which show the different aspects of behaviour. You may need to set up some data for this to work. Most teams I work with avoid stored procedures just because of the difficulty of testing them, or they simply rely on the full-stack scenarios to provide coverage. Hope this helps, and best of luck!
