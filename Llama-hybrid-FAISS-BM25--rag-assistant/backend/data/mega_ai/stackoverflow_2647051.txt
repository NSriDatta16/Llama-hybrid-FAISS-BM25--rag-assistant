[site]: stackoverflow
[post_id]: 2647051
[parent_id]: 
[tags]: 
Error using CreateFileMapping - C

I am using the tutorial on this MSDN link to implement a way of transferring data from one process to another. Although I was advised in an earlier question to use the Pipe methods, due to certain constraints I have no choice but to use the CreateFileMapping method. Now, i've succesfully managed to make two seperate window form projects within the same solution and by editing some properties both of the forms load at the same time. Furthermore I have managed to implement the code given in the MSDN sample into the first (Producer) and second (Consumer) program without any compilation errors. The problem I am having now is when I run the first program and try to create the handle to the mapped file, I am given an error saying it was unsuccesful and I do not understand why this is happening. I have added both the Producer and Consumer code files to demonstrate what I am trying to do. Producer : #include #include #include //File header definitions #define IDM_FILE_ROLLDICE 1 #define IDM_FILE_QUIT 2 #define BUF_SIZE 256 TCHAR szName[]=TEXT("Global\\MyFileMappingObject"); TCHAR szMsg[]=TEXT("Message from first process!"); void AddMenus(HWND); LRESULT CALLBACK WindowFunc(HWND, UINT, WPARAM, LPARAM); ////Standard windows stuff - omitted to save space. ////////////////////// // WINDOWS FUNCTION // ////////////////////// LRESULT CALLBACK WindowFunc(HWND hMainWindow, UINT message, WPARAM wParam, LPARAM lParam) { WCHAR buffer[256]; LPCTSTR pBuf; struct DiceData storage; HANDLE hMapFile; switch(message) { case WM_CREATE: { // Create Menus AddMenus(hMainWindow); } break; case WM_COMMAND: // Intercept menu choices switch(LOWORD(wParam)) { case IDM_FILE_ROLLDICE: { //Roll dice and store results in variable //storage = RollDice(); ////Copy results to buffer //swprintf(buffer,255,L"Dice 1: %d, Dice 2: %d",storage.dice1,storage.dice2); ////Show via message box //MessageBox(hMainWindow,buffer,L"Dice Result",MB_OK); hMapFile = CreateFileMapping( (HANDLE)0xFFFFFFFF, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BUF_SIZE, // maximum object size (low-order DWORD) szName); // name of mapping object if (hMapFile == NULL) { MessageBox(hMainWindow,L"Could not create file mapping object",L"Error",NULL); return 1; } pBuf = (LPTSTR) MapViewOfFile(hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BUF_SIZE); if (pBuf == NULL) { MessageBox(hMainWindow,L"Could not map view of file",L"Error",NULL); CloseHandle(hMapFile); return 1; } CopyMemory((PVOID)pBuf, szMsg, (_tcslen(szMsg) * sizeof(TCHAR))); _getch(); UnmapViewOfFile(pBuf); CloseHandle(hMapFile); } break; case IDM_FILE_QUIT: SendMessage(hMainWindow, WM_CLOSE, 0, 0); break; } break; case WM_DESTROY: PostQuitMessage(0); break; } return DefWindowProc(hMainWindow, message, wParam, lParam); } // //Setup menus // Consumer : #include #include #include //File header definitions #define IDM_FILE_QUIT 1 #define IDM_FILE_POLL 2 #define BUF_SIZE 256 TCHAR szName[]=TEXT("Global\\MyFileMappingObject"); //Prototypes void AddMenus(HWND); LRESULT CALLBACK WindowFunc(HWND, UINT, WPARAM, LPARAM); //More standard windows creation, again omitted. ////////////////////// // WINDOWS FUNCTION // ////////////////////// LRESULT CALLBACK WindowFunc(HWND hMainWindow, UINT message, WPARAM wParam, LPARAM lParam) { HANDLE hMapFile; LPCTSTR pBuf; switch(message) { case WM_CREATE: { // Create Menus AddMenus(hMainWindow); break; } case WM_COMMAND: { // Intercept menu choices switch(LOWORD(wParam)) { case IDM_FILE_POLL: { hMapFile = OpenFileMapping( FILE_MAP_ALL_ACCESS, // read/write access FALSE, // do not inherit the name szName); // name of mapping object if (hMapFile == NULL) { MessageBox(hMainWindow,L"Could not open file mapping object",L"Error",NULL); return 1; } pBuf = (LPTSTR) MapViewOfFile(hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BUF_SIZE); if (pBuf == NULL) { MessageBox(hMainWindow,L"Could not map view of file",L"Error",NULL); CloseHandle(hMapFile); return 1; } MessageBox(NULL, pBuf, TEXT("Process2"), MB_OK); UnmapViewOfFile(pBuf); CloseHandle(hMapFile); break; } case IDM_FILE_QUIT: SendMessage(hMainWindow, WM_CLOSE, 0, 0); break; } break; } case WM_DESTROY: { PostQuitMessage(0); break; } } return DefWindowProc(hMainWindow, message, wParam, lParam); } // //Setup menus // It's by no means tidy and final but it's just a start, thanks for any help. Edit: Error Edit2: Output
