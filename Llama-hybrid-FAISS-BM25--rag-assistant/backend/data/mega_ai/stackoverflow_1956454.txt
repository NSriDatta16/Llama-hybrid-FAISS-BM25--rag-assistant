[site]: stackoverflow
[post_id]: 1956454
[parent_id]: 1956307
[tags]: 
A straight SQL-92 solution, avoiding both recursion (not universally implemented) and vendor-specific features (for the usual reasons): select theAnswer.* from salesmen s0 join salesmen s1 on s0.id in (s1.id, s1.agentId) join salesmen theAnswer on s1.id = theAnswer.agentId where 0 = s0.agentId and 1011 in (s0.id, s1.id) The assumption here is that the salesperson of interest ( id = 1011 in this case) may be either A-tier or B-tier. To restrict the query to searches starting at A-tier only, replace the last line with: 1011 = s0.id Another assumption is that there is exactly one row for each salesperson ( id is UNIQUE ), which implies that any given salesperson has a single agentId . If this is not so, replace the first line with: select distinct I should point out that there are four tiers in the sample data, not three as per the problem statement. A-tier: bob B-tier: jim , tim , sam C-tier: dav , kim D-tier: sal , vin That being the case, the original query becomes: select theAnswer.* from salesmen s0 join salesmen s1 on s0.id in (s1.id, s1.agentId) join salesmen s2 on s1.id in (s2.id, s2.agentId) join salesmen theAnswer on s2.id = theAnswer.agentId where 0 = s1.agentId and 1011 in (s0.id, s1.id, s2.id) and (s0.id = s1.id or s1.id <> s2.id) This last line's purpose is to avoid having to turn the query into a select distinct and is a simply a reduction of: ( s0.id = s1.id and s1.id = s2.id or s0.id = s1.id and s1.id <> s2.id or s0.id <> s1.id and s1.id <> s2.id ) To get to a 5-level hierarchy, one need only compare the first and second queries to see the pattern emerge. The FROM clause gets an extra JOIN . The final JOIN must compare against this new JOIN . The second part of the WHERE clause gets an extra item. The last part of the WHERE clause builds on the unsimplified snippet above by adding an extra OR condition to handle doing the extra compares against the new JOIN , following the pattern made by the = and <> operators.
