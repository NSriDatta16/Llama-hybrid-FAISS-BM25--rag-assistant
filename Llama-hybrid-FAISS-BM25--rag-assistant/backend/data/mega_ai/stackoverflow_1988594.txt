[site]: stackoverflow
[post_id]: 1988594
[parent_id]: 1988484
[tags]: 
Python STL (in hope of leveraging my years of STL experience) - Start with the collections ABC's to learn what Python has. http://docs.python.org/library/collections.html Python linked lists. Python lists have all the features you would want from a linked list. Python advanced list usage. What does this mean? Python list optimization. What does this mean? Python ordered sets. You have several choices here; you could invent your own "ordered set" as a list that discards duplicates. You can subclass the heapq and add methods that discard duplicates: http://docs.python.org/library/heapq.html . In many cases, however, the cost of maintaing an ordered set is actually excessive because it must only be ordered once at the end of the algorithm. In other cases, the "ordered set" really is a heapq -- you never needed the set-like features and only needed the ordering. Non-Trivial . (I'm guessing at what you meant by "non-trivial"). All Python objects are equivalent. There's no "trivial" vs. "non-trivial" objects. They're all first-class objects and can all have "non-trivial" complexity without any real work. This is not C++ where there are primitive (non-object) values floating around. Everything's an object in Python. Management Expectations . For the most part the C++ brain-cramping doesn't exist in Python. Use the obvious Python classes the obvious way and you'll have much less code. The reduction in code volume is the big win. Often, the management reason for converting C++ to Python is to get rid of the C++ complexity. Python code will be much simpler, making it much more reliable and much easier to maintain. While it's generally true that Python is slower than C++, it's also true that picking the right algorithm and data structure can have dramatic improvements on performance. In one benchmark, someone found that Python was actually faster than C because the C program had such a poorly chosen data structure. It's possible that your C++ has a really poor algorithm and you will see comparable performance from Python. It's also possible that your C++ program is I/O bound, or has other limitations that will leave the Python running at a comparable speed.
