[site]: stackoverflow
[post_id]: 576296
[parent_id]: 576176
[tags]: 
C5 Generic Collection Library The best implementations I have found in C# and C++ are these -- for C#/CLI: http://www.itu.dk/research/c5/Release1.1/ITU-TR-2006-76.pdf http://www.itu.dk/research/c5/ It's well researched, has extensible unit tests, and since February they also have implemented the common interfaces in .Net which makes it a lot easier to work with the collections. They were featured on Channel9 and they've done extensive performance testing on the collections. If you are using data-structures anyway these researchers have a red-black-tree implementation in their library, similar to what you find if you fire up LÃ¼tz reflector and have a look in System.Data's internal structures :p. Insert-complexity: O(log(n)). Lock-free C++ collections Then, if you can allow for some C++ interop and you absolutely need the speed and want as little overhead as possible, then these lock-free ADTs from Dmitriy V'jukov are probably the best you can get in this world, outperforming Intel's concurrent library of ADTs. http://groups.google.com/group/lock-free I've read some of the code and it's really the makings of someone well versed in how these things are put together. VC++ can do native C++ interop without annoying boundaries. http://www.swig.org/ can otherwise help you wrap C++ interfaces for consumption in .Net, or you can do it yourself through P/Invoke. Microsoft's Take They have written tutorials, this one implementing a rather unpolished skip-list in C# , and discussing other types of data-structures. (There's a better SkipList at CodeProject , which is very polished and implement the interfaces in a well-behaved manner.) They also have a few data-structures bundled with .Net, namely the HashTable/Dictionary and HashSet . Of course there's the "ResizeArray"/List type as well together with a stack and queue, but they are all "linear" on search. Google's perf-tools If you wish to speed up the time it takes for memory-allocation you can use google's perf-tools. They are available at google code and they contain a very interesting multi-threaded malloc-implementation (TCMalloc) which shows much more consistent timing than the normal malloc does. You could use this together with the lock-free structures above to really go crazy with performance. Improving response times with memoization You can also use memoization on functions to improve performance through caching, something interesting if you're using e.g. F# . F# also allows C++ interop, so you're OK there. O(k) There's also the possibility of doing something on your own using the research which has been done on bloom-filters , which allow O(k) lookup complexity where k is a constant that depends on the number of hash-functions you have implemented. This is how google's BigTable has been implemented. These filter will get you the element if it's in the set or possibly with a very low likeliness an element which is not the one you're looking for (see the graph at wikipedia -- it's approaching P(wrong_key) -> 0.01 as size is around 10000 elements, but you can go around this by implementing further hash-functions/reducing the set. I haven't searched for .Net implementations of this, but since the hashing calculations are independent you can use MS's performance team's implementation of Tasks to speed that up. "My" take -- randomize to reach average O(log n) As it happens I just did a coursework involving data-structures. In this case we used C++, but it's very easy to translate to C#. We built three different data-structures; a bloom-filter, a skip-list and random binary search tree . See the code and analysis after the last paragraph. Hardware-based "collections" Finally, to make my answer "complete", if you truly need speed you can use something like Routing-tables or Content-addressable memory . This allows you to very quickly O(1) in principle get a "hash"-to-value lookup of your data. Random Binary Search Tree/Bloom Filter C++ code I would really appreciate feedback if you find mistakes in the code, or just pointers on how I can do it better (or with better usage of templates). Note that the bloom filter isn't like it would be in real life; normally you don't have to be able to delete from it and then it much much more space efficient than the hack I did to allow the delete to be tested. DataStructure.h #ifndef DATASTRUCTURE_H_ #define DATASTRUCTURE_H_ class DataStructure { public: DataStructure() {countAdd=0; countDelete=0;countFind=0;} virtual ~DataStructure() {} void resetCountAdd() {countAdd=0;} void resetCountFind() {countFind=0;} void resetCountDelete() {countDelete=0;} unsigned int getCountAdd(){return countAdd;} unsigned int getCountDelete(){return countDelete;} unsigned int getCountFind(){return countFind;} protected: unsigned int countAdd; unsigned int countDelete; unsigned int countFind; }; #endif /*DATASTRUCTURE_H_*/ Key.h #ifndef KEY_H_ #define KEY_H_ #include using namespace std; const int keyLength = 128; class Key : public string { public: Key():string(keyLength, ' ') {} Key(const char in[]): string(in){} Key(const string& in): string(in){} bool operator (const string& other); bool operator==(const string& other); virtual ~Key() {} }; #endif /*KEY_H_*/ Key.cpp #include "Key.h" bool Key::operator (const string& other) { return compare(other) > 0; }; bool Key::operator==(const string& other) { return compare(other) == 0; } BloomFilter.h #ifndef BLOOMFILTER_H_ #define BLOOMFILTER_H_ #include #include #include #include #include "Key.h" #include "DataStructure.h" #define LONG_BIT 32 #define bitmask(val) (unsigned long)(1 m_tickBook; vector m_useCounts; unsigned long m_length; // number of bits in the bloom filter unsigned long m_pockets; //the number of pockets static const unsigned long m_pocketSize; //bits in each pocket }; #endif /*BLOOMFILTER_H_*/ BloomFilter.cpp #include "BloomFilter.h" const unsigned long BloomFilter::m_pocketSize = LONG_BIT; void BloomFilter::init(unsigned long length) { //m_length = length; m_length = (unsigned long)((2.0*length)/log(2))+1; m_pockets = (unsigned long)(ceil(double(m_length)/m_pocketSize)); m_tickBook.resize(m_pockets); // my own (allocate nr bits possible to store in the other vector) m_useCounts.resize(m_pockets * m_pocketSize); unsigned long i; for(i=0; i 0) && ((m_tickBook[i2] & bitmask(h2)) > 0); } /* * Gets the values of the indicies for two hashes and places them in * the passed parameters. The index is into m_tickBook. */ void BloomFilter::getHashAndIndicies(unsigned long& h1, unsigned long& h2, int& i1, int& i2, const Key& key) { h1 = hash1(key); h2 = hash2(key); i1 = (int) h1/m_pocketSize; i2 = (int) h2/m_pocketSize; } /* * Gets the values of the indicies into the count vector, which keeps * track of how many times a specific bit-position has been used. */ void BloomFilter::getCountIndicies(const int i1, const unsigned long h1, const int i2, const unsigned long h2, int& i1_c, int& i2_c) { i1_c = i1*m_pocketSize + h1%m_pocketSize; i2_c = i2*m_pocketSize + h2%m_pocketSize; } ** RBST.h ** #ifndef RBST_H_ #define RBST_H_ #include #include #include #include #include "Key.h" #include "DataStructure.h" #define BUG(str) printf("%s:%d FAILED SIZE INVARIANT: %s\n", __FILE__, __LINE__, str); using namespace std; class RBSTNode; class RBSTNode: public Key { public: RBSTNode(const Key& key):Key(key) { m_left =NULL; m_right = NULL; m_size = 1U; // the size of one node is 1. } virtual ~RBSTNode(){} string setKey(const Key& key){return Key(key);} RBSTNode* left(){return m_left; } RBSTNode* right(){return m_right;} RBSTNode* setLeft(RBSTNode* left) { m_left = left; return this; } RBSTNode* setRight(RBSTNode* right) { m_right =right; return this; } #ifdef DEBUG ostream& print(ostream& out) { out print(cout); cout print(cout); cout print(cout); cout ** RBST.cpp ** #include "RBST.h" bool RBST::add(const Key& key, bool v){ unsigned int oldSize = m_size; m_head = randomAdd(m_head, key); if (m_size > oldSize){ if(v) cout left(), sep); cout right(), sep); return ret; }; #endif /** * Rotates the tree around target, so that target's left * is the new root of the tree/subtree and updates the subtree sizes. * *(target) b (l) a * / \ right / \ * a ? ----> ? b * / \ / \ * ? x x ? * */ RBSTNode* RBST::rightRotate(RBSTNode* target) // private { if (target == NULL) throw "Invariant failure, target is null"; // Note: may be removed once tested. if (target->left() == NULL) throw "You cannot rotate right around a target whose left node is NULL!"; #ifdef DEBUG cout print(cout); cout left()->print(cout); cout left(); int as0 = l->size(); // re-order the sizes l->setSize( l->size() + (target->right() == NULL ? 0 : target->right()->size()) + 1); // a.size += b.right.size + 1; where b.right may be null. target->setSize( target->size() -as0 + (l->right() == NULL ? 0 : l->right()->size()) ); // b.size += -a_0_size + x.size where x may be null. // swap b's left (for a) target->setLeft(l->right()); // and a's right (for b's left) l->setRight(target); #ifdef DEBUG cout size() size() right() == NULL) throw "You cannot rotate left around a target whose right node is NULL!"; #ifdef DEBUG cout print(cout); cout right()->print(cout); cout right(); int bs0 = r->size(); // re-roder the sizes r->setSize(r->size() + (target->left() == NULL ? 0 : target->left()->size()) + 1); target->setSize(target->size() -bs0 + (r->left() == NULL ? 0 : r->left()->size())); // swap a's right (for b's left) target->setRight(r->left()); // swap b's left (for a) r->setLeft(target); #ifdef DEBUG cout size() size() print(cout) setRight( addRoot(target->right(), key) ); target->incSize(); // Should I? RBSTNode* res = leftRotate(target); #ifdef DEBUG if (target->size() != size(target)) BUG("in addRoot 1"); #endif return res; } target->setLeft( addRoot(target->left(), key) ); target->incSize(); // Should I? RBSTNode* res = rightRotate(target); #ifdef DEBUG if (target->size() != size(target)) BUG("in addRoot 2"); #endif return res; }; /** * This function is called from the public add(key) function, * and returns the new root node. */ RBSTNode* RBST::randomAdd(RBSTNode* target, const Key& key) { countAdd++; if (target == NULL) { m_size++; return new RBSTNode(key); } #ifdef DEBUG cout print(cout) size()) + 1; // here is where we add the target as root! if (r == 1) { m_size++; // TODO: Need to lock. return addRoot(target, key); } #ifdef DEBUG printf("randomAdd recursion part, "); #endif // otherwise, continue recursing! if (*target setRight( randomAdd(target->right(), key) ); target->incSize(); // TODO: Need to lock. #ifdef DEBUG if (target->right()->size() != size(target->right())) BUG("in randomAdd 1"); #endif } else { #ifdef DEBUG printf("target > key\n"); #endif target->setLeft( randomAdd(target->left(), key) ); target->incSize(); // TODO: Need to lock. #ifdef DEBUG if (target->left()->size() != size(target->left())) BUG("in randomAdd 2"); #endif } #ifdef DEBUG printf("randomAdd return part\n"); #endif m_size++; // TODO: Need to lock. return target; }; ///////////////////////////////////////////////////////////// ///////////////////// DEL FUNCTIONS //////////////////////// ///////////////////////////////////////////////////////////// /** * Deletes a node with the passed key. * Returns the root node. * Decrements m_size if something was deleted. */ RBSTNode* RBST::del(RBSTNode* target, const Key& key) { countDelete++; if (target == NULL) return NULL; #ifdef DEBUG cout print(cout) left(), target->right()); m_size--; delete target; return ret; // return the newly built joined subtree! } // store a temporary size before recursive deletion. unsigned int size = m_size; if (*target setRight( del(target->right(), key) ); else target->setLeft( del(target->left(), key) ); // if the previous recursion changed the size, we need to decrement the size of this target too. if (m_size decrSize(); #ifdef DEBUG if (RBST::size(target) != target->size()) BUG("in del"); #endif return target; }; /** * Joins the two subtrees represented by left and right * by randomly choosing which to make the root, weighted on the * size of the sub-tree. */ RBSTNode* RBST::join(RBSTNode* left, RBSTNode* right) { if (left == NULL) return right; if (right == NULL) return left; #ifdef DEBUG cout print(cout); cout print(cout) size()/(float)(left->size() + right->size()) * 1000.0)); RBSTNode* subtree = NULL; if (useLeft) { subtree = join(left->right(), right); left->setRight(subtree) ->setSize((left->left() == NULL ? 0 : left->left()->size()) + subtree->size() + 1 ); #ifdef DEBUG if (size(left) != left->size()) BUG("in join 1"); #endif return left; } subtree = join(right->left(), left); right->setLeft(subtree) ->setSize((right->right() == NULL ? 0 : right->right()->size()) + subtree->size() + 1); #ifdef DEBUG if (size(right) != right->size()) BUG("in join 2"); #endif return right; }; ///////////////////////////////////////////////////////////// ///////////////////// FIND FUNCTIONS /////////////////////// ///////////////////////////////////////////////////////////// /** * Tries to find the key in the tree starting * search from target. * * Returns NULL if it was not found. */ RBSTNode* RBST::find(RBSTNode* target, const Key& key) { countFind++; // Could use private method only counting the first call. if (target == NULL) return NULL; // not found. if (*target == key) return target; // found (does string override ==?) if (*target right(), key); // search for gt to the right. return find(target->left(), key); // search for lt to the left. }; #ifdef DEBUG unsigned int RBST::size(RBSTNode* x) { if (x == NULL) return 0; return 1 + size(x->left()) + size(x->right()); } #endif I'll save the SkipList for another time since it's already possible to find good implementations of a SkipList from the links and my version wasn't much different. The graphs generated from the test-file are as follows: Graph showing time taken to add new items for BloomFilter, RBST and SkipList. graph http://haf.se/content/dl/addtimer.png Graph showing time taken to find items for BloomFilter, RBST and SkipList graph http://haf.se/content/dl/findtimer.png Graph showing time taken to delete items for BloomFilter, RBST and SkipList graph http://haf.se/content/dl/deltimer.png So as you can see, the random binary search tree was rather a lot better than the SkipList. The bloom filter lives up to its O(k).
