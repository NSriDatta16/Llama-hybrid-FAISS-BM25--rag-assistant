[site]: stackoverflow
[post_id]: 2005142
[parent_id]: 2004820
[tags]: 
This problem doesn't come up very often. The solution I'm familiar with was designed by Doug McIlroy and appears in Bjarne Stroustrup's books (presented in both Design & Evolution of C++ section 12.8 and The C++ Programming Language section 25.6). According to the discussion in Design & Evolution , there was a proposal to handle this specific case elegantly, but it was rejected because "such name clashes were unlikely to become common enough to warrant a separate language feature," and "not likely to become everyday work for novices." Not only do you need to call Name() through pointers to base classes, you need a way to say which Name() you want when operating on the derived class. The solution adds some indirection: class Interface1{ public: virtual void Name() = 0; }; class Interface2{ public: virtual void Name() = 0; }; class Interface1_helper : public Interface1{ public: virtual void I1_Name() = 0; void Name() override { I1_Name(); } }; class Interface2_helper : public Interface2{ public: virtual void I2_Name() = 0; void Name() override { I2_Name(); } }; class RealClass: public Interface1_helper, public Interface2_helper{ public: void I1_Name() override { printf("Interface1 OK?\n"); } void I2_Name() override { printf("Interface2 OK?\n"); } }; int main() { RealClass rc; Interface1* i1 = &rc; Interface2* i2 = &rc; i1->Name(); i2->Name(); rc.I1_Name(); rc.I2_Name(); } Not pretty, but the decision was it's not needed often.
