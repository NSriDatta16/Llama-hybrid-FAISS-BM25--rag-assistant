[site]: stackoverflow
[post_id]: 1726943
[parent_id]: 
[tags]: 
Is functional Clojure or imperative Groovy more readable?

OK, no cheating now. No, really, take a minute or two and try this out. What does "positions" do? Edit: simplified according to cgrand's suggestion. (defn redux [[current next] flag] [(if flag current next) (inc next)]) (defn positions [coll] (map first (reductions redux [1 2] (map = coll (rest coll))))) Now, how about this version? def positions(coll) { def (current, next) = [1, 1] def previous = coll[0] coll.collect { current = (it == previous) ? current : next next++ previous = it current } } I'm learning Clojure and I'm loving it, because I've always enjoyed functional programming. It took me longer to come up with the Clojure solution, but I enjoyed having to think of an elegant solution. The Groovy solution is alright, but I'm at the point where I find this type of imperative programming boring and mechanical. After 12 years of Java, I feel in a rut and functional programming with Clojure is the boost I needed. Right, get to the point. Well, I have to be honest and say that I wonder if I'll understand the Clojure code when I go back to it months later. Sure I could comment the heck out of it, but I don't need to comment my Java code to understand it. So my question is: is it a question of getting more used to functional programming patterns? Are functional programming gurus reading this code and finding it a breeze to understand? Which version did you find easier to understand? Edit: what this code does is calculate the positions of players according to their points, while keep track of those who are tied. For example: Pos Points 1. 36 1. 36 1. 36 4. 34 5. 32 5. 32 5. 32 8. 30
