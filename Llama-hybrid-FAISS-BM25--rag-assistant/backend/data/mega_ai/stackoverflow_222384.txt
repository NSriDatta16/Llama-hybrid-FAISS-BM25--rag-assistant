[site]: stackoverflow
[post_id]: 222384
[parent_id]: 222266
[tags]: 
Edit: Removed comments regarding how to effectively store data always big endian and swapping to machine endianess, as questioner hasn't mentioned another program writes his data (which is important information). Still if the data needs conversion from any endian to big and from big to host endian, ntohs/ntohl/htons/htonl are the best methods, most elegant and unbeatable in speed (as they will perform task in hardware if CPU supports that, you can't beat that). Regarding double/float, just store them to ints by memory casting: double d = 3.1234; printf("Double %f\n", d); int64_t i = *(int64_t *)&d; // Now i contains the double value as int double d2 = *(double *)&i; printf("Double2 %f\n", d2); Wrap it into a function int64_t doubleToInt64(double d) { return *(int64_t *)&d; } double int64ToDouble(int64_t i) { return *(double *)&i; } Questioner provided this link: http://cocoawithlove.com/2008/04/using-pointers-to-recast-in-c-is-bad.html as a prove that casting is bad... unfortunately I can only strongly disagree with most of this page. Quotes and comments: As common as casting through a pointer is, it is actually bad practice and potentially risky code. Casting through a pointer has the potential to create bugs because of type punning. It is not risky at all and it is also not bad practice. It has only a potential to cause bugs if you do it incorrectly, just like programming in C has the potential to cause bugs if you do it incorrectly, so does any programming in any language. By that argument you must stop programming altogether. Type punning A form of pointer aliasing where two pointers and refer to the same location in memory but represent that location as different types. The compiler will treat both "puns" as unrelated pointers. Type punning has the potential to cause dependency problems for any data accessed through both pointers. This is true, but unfortunately totally unrelated to my code . What he refers to is code like this: int64_t * intPointer; : // Init intPointer somehow : double * doublePointer = (double *)intPointer; Now doublePointer and intPointer both point to the same memory location, but treating this as the same type. This is the situation you should solve with a union indeed, anything else is pretty bad. Bad that is not what my code does! My code copies by value , not by reference . I cast a double to int64 pointer (or the other way round) and immediately deference it. Once the functions return, there is no pointer held to anything. There is a int64 and a double and these are totally unrelated to the input parameter of the functions. I never copy any pointer to a pointer of a different type (if you saw this in my code sample, you strongly misread the C code I wrote), I just transfer the value to a variable of different type (in an own memory location). So the definition of type punning does not apply at all, as it says "refer to the same location in memory" and nothing here refers to the same memory location. int64_t intValue = 12345; double doubleValue = int64ToDouble(intValue); // The statement below will not change the value of doubleValue! // Both are not pointing to the same memory location, both have their // own storage space on stack and are totally unreleated. intValue = 5678; My code is nothing more than a memory copy, just written in C without an external function. int64_t doubleToInt64(double d) { return *(int64_t *)&d; } Could be written as int64_t doubleToInt64(double d) { int64_t result; memcpy(&result, &d, sizeof(d)); return result; } It's nothing more than that, so there is no type punning even in sight anywhere. And this operation is also totally safe, as safe as an operation can be in C. A double is defined to always be 64 Bit (unlike int it does not vary in size, it is fixed at 64 bit), hence it will always fit into a int64_t sized variable.
