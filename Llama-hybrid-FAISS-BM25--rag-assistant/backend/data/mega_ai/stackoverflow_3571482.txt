[site]: stackoverflow
[post_id]: 3571482
[parent_id]: 3571410
[tags]: 
First, you could simplify this by using or . This avoids repeating the //* multiple times although you till specify the @id= part multiple times: //*[@id='apple' or @id='orange' or @id='banana'] A more elegant solution is to check against a list of acceptable ids. Now if you're using XPath 1.x then you'll have to do a bit of gymnastics to get contains() to do your bidding. Specifically, notice that I've got spaces on both ends of the first string, and then concatenate spaces to each end of @id before looking for a match. This is to prevent an @id of "range" from matching, for example. //*[contains(' apple orange banana ', concat(' ', @id, ' '))] If you have are using XPath 2.0 then the way forward is simpler thanks to the addition of sequences to the language: //*[exists(index-of(('apple', 'orange', 'banana'), @id))]
