[site]: stackoverflow
[post_id]: 5169908
[parent_id]: 5169197
[tags]: 
I will offer some counterpoints to @druttka's answer. But mostly, you have to decide which trade off you want to make. If you use a model for your view, you are now forcing 2 things: Every view must be strongly typed Every action must call the function to populate all levels of nav included in your view model The first point isn't so bad, because there are very few pages in a typical non-static site which wouldn't derive from a model anyway, and its easy enough to create an empty model for those pages. The second point is much more annoying however. Each function has to instantiate it's own model, and then populate the nav properties for every level of nav provided by the model. This can be quite cumbersome, but can be fairly elegantly handled in OnActionExecuted for at least nav which is not specific to a given action. The alternative is to add the nav to the ViewBag . This can be done whenever and does not force you to specify a model for every view, which is great for the flexibility in those cases where you do not need to specify a model. It should be noted however that the ViewBag in asp.net mvc 3 is of type dynamic, which you cannot use as a parameter in a lambda function, thus preventing you from doing something like @Html.DisplayFor(viewBag => viewBag.MainNav) in your layout, which is a real drag. You can still render partial and specify the appropriate DisplayTemplate however.
