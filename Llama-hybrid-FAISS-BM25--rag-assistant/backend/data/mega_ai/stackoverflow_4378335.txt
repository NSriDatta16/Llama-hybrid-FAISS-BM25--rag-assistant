[site]: stackoverflow
[post_id]: 4378335
[parent_id]: 4378182
[tags]: 
I don't see where you bind your color renderbuffer to the to the CAEAGLLayer it is to be displayed on (although that may happen later), and I don't see you enabling depth testing. Also, if I'm not mistaken you need to bind the color renderbuffer, call glFramebufferRenderbuffer() for that, then bind the depth renderbuffer and call it again. The following is code that I've used to set up a similar display on OpenGL ES 2.0: glEnable(GL_DEPTH_TEST); glGenFramebuffers(1, &viewFramebuffer); glBindFramebuffer(GL_FRAMEBUFFER, viewFramebuffer); glGenRenderbuffers(1, &viewRenderbuffer); glBindRenderbuffer(GL_RENDERBUFFER, viewRenderbuffer); [context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer]; glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &backingWidth); glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &backingHeight); glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, viewRenderbuffer); glGenRenderbuffers(1, &depthRenderbuffer); glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, backingWidth, backingHeight); glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer); if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) { NSLog(@"Failure with framebuffer generation"); return NO; } The full code of this application is available here .
