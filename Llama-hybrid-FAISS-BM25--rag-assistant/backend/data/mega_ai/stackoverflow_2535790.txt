[site]: stackoverflow
[post_id]: 2535790
[parent_id]: 2535458
[tags]: 
It is a false economy to try to run a long running Java-based application in the minimal possible memory. The garbage collector, and hence the application will run much more efficiently if it has plenty of regular heap memory. Give an application too little heap and it will spend too much time garbage collecting. (This may seem a bit counter-intuitive, but trust me: the effect is predictable in theory and observable in practice.) EDIT In practical terms, I'd suggest the following approach: Start by running Tomcat + Grails with as much memory as you can possibly give it so that you have something that runs. (Set the permgen size to the default ... unless you have clear evidence that Tomcat + Grails are exhausting permgen.) Run the app for a bit to get it to a steady state and figure out what its average working set is. You should be able to figure that out from a memory profiler, or by examining the GC logging. Then set the Java heap size to be (say) twice the measured working set size or more. (This is the point I was trying to make above.) Actually, there is another possible cause for your problems. Even though you are telling Java to use heaps of a given size, it may be that it is unable to do this. When the JVM requests memory from the OS, there are a couple of situations where the OS will refuse. If the machine (real or virtual) that you are running the OS does not have any more unallocated "real" memory, and the OS's swap space is fully allocated, it will have to refuse requests for more memory. It is also possible (though unlikely) that per-process memory limits are in force. That would cause the OS to refuse requests beyond that limit. Finally, note that Java uses more virtual memory that can be accounted for by simply adding the stack, heap and permgen numbers together. There is the memory used by the executable + DLLs, memory used for I/O buffers, and possibly other stuff.
