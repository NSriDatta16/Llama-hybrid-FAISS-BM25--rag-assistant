[site]: stackoverflow
[post_id]: 4318036
[parent_id]: 4317694
[tags]: 
Regarding Generics, Java doesn't have "real" generics, which can be both beneficial and detrimental in this case. Using generics is tricky when you don't know at compile time exactly what type of object you're dealing with. If the code consuming this information actually knows which type of object it's supposed to expect from a call to ValueTransformer.ValueA.createVo, then it should honestly be expected to cast the returned value. I would expect the call to look more like this: MyTypeA myType = (MyTypeA)ValueTransformer.ValueA.createVo(sourceObject); If I'm getting the wrong type out of this method, I would rather see a Cast exception on this line (where the problem really happened) than a null pointer exception later on. This is correct "fail-fast" practice. If you really don't like the explicit casting, I've seen a cool trick that lets you cast these things implicitly. I think it goes something like this: public abstract T createVo (Object obj) {...} MyTypeA myType = ValueTransformer.ValueA.createVo(sourceObject); However, I don't really recommend this approach because it still performs the cast at runtime, but nobody would suspect that by looking at your usage code. I can see a few goals that you may be hoping to achieve: Have a single "source of truth" to go to for all objects of the given Base class. Allow the creation of an instance of a given object every time you request one. Have type-safety and avoid casting at runtime. Unless you have other requirements I'm not thinking of, it seems like a factory would be preferable: public class ValueFactory { public ValueA getValueA(Object obj) {return new ValueA();} public ValueB getValueB(Object obj) {return new ValueB();} } This satisfies all the requirements mentioned above. Furthermore, if you know what type of object is required to produce a ValueA object, you can use a more explicit type on the input value.
