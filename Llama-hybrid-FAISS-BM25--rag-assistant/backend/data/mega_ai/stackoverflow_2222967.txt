[site]: stackoverflow
[post_id]: 2222967
[parent_id]: 2222935
[tags]: 
I would optimize by using a different algorithm. Searching linearly like you are doing is super-slow. It's a fact that the least common mulitple of two natural numbers is the quotient of their product divided by their greatest common divisor. You can compute the greatest common divisor quickly using the Euclidean algorithm . Thus: int lcm(int a, int b) { int p = a * b; return p / gcd(a, b); } where you need to implement gcd(int, int) . As the average number of steps in the Euclidean algorithm is O(log n) , we beat the naive linear search hands down. There are other approaches to this problem. If you had an algorithm that could quickly factor integers (say a quantum computer ) then you can also solve this problem like so. If you write each of a and b into its canonical prime factorization a = p_a0^e_a0 * p_a1^e_a1 * ... * p_am^e_am b = p_b0^e_b0 * p_b1^e_b1 * ... * p_bn^e_bn then the least common multiple of a and b is the obtained by taking for each prime factor appearing in at least one of the factorizations of a and b , taking it with the maximum exponent that it appears in the factorization of a or b . For example: 28 = 2^2 * 7 312 = 2^3 * 39 so that lcm(28, 312) = 2^3 * 7 * 39 = 2184 All of this is to point out that naive approaches are admirable in their simplicity but you can spend all day optimizing every last nanosecond out of them and still not beat a superior algorithm.
