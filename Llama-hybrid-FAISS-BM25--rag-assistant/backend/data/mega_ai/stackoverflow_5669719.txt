[site]: stackoverflow
[post_id]: 5669719
[parent_id]: 5662215
[tags]: 
How about iterative pathfinding? Run a path-finding algorithm, ignoring issues with overlap. This will find the shortest path. Simulate the creep movement. This simulation should run with tile-based movement so that it will be fast. Select half (fiddle with this) of the creeps that are waiting in a line and thus not moving. Rerun the algorithm for those creeps, but add extra weight penalty at this position they were waiting. This weight will ONLY be applied to the creeps which had the extra weight. Repeat steps 2-3 until some condition is met, paying some (fiddle with this) attention to the previous extra weights. This algorithm will require fiddling to fully coalesce into something useful. However, it has the advantage of using preplanned paths, so it won't have any loops or creeps moving backwards. It also allows you to ignore things like timing, so it's conceptually simpler. But also probably less efficient.
