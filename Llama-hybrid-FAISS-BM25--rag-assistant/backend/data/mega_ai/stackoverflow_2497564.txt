[site]: stackoverflow
[post_id]: 2497564
[parent_id]: 2497541
[tags]: 
Option 1 is defective. When you declare an object QList ret; it only lives in the local scope. It is destroyed when the function exits. However, you can make this work with return ret; // no "&" Now, although ret is destroyed, a copy is made first and passed back to the caller. This is the generally preferred methodology. In fact, the copy-and-destroy operation (which accomplishes nothing, really) is usually elided, or optimized out and you get a fast, elegant program. Option 2 works, but then you have a pointer to the heap. One way of looking at C++ is that the purpose of the language is to avoid manual memory management such as that. Sometimes you do want to manage objects on the heap, but option 1 still allows that: QList *myList = new QList ( getWeights() ); where getWeights is your example function. (In this case, you may have to define a copy constructor QList::QList( QList const & ) , but like the previous example, it will probably not get called.) Likewise, you probably should avoid having a list of pointers. The list should store the objects directly. Try using std::list â€¦ practice with the language features is more important than practice implementing data structures.
