[site]: stackoverflow
[post_id]: 1455811
[parent_id]: 1440147
[tags]: 
The way 'traditional' shells deal with things like variable substitution is difficult to handle with lex/yacc. What they do is more like macro expansion, where AFTER expanding a variable, they then re-tokenize the input, without expanding further variables. So for example, an input like "xx${$foo}" where 'foo' is defined as 'bar' and 'bar' is defined as '$y' will expand to 'xx$y' which will be treated as a single word (and $y will NOT be expanded). You CAN deal with this in flex, but you need a lot of supporting code. You need to use flex's yy_buffer_state stuff to sometimes redirect the output into a buffer that you'll then rescan from, and use start states carefully to control when variables can and can't be expanded. Its probably easier to use a very simple lexer that returns tokens like ALPHA (one or more alphabetic chars), NUMERIC (one or more digits), or WHITESPACE (one or more space or tab), and have the parser assemble them appropriately, and you end up with rules like: simple_command: wordlist NEWLINE ; wordlist: word | wordlist WHITESPACE word ; word: word_frag | word word_frag { $$ = concat_string($1, $2); } ; word_frag: single_quote_string | double_quote_string | variable | ALPHA | NUMERIC ...more options... ; variable: '$' name { $$ = lookup($2); } | '$' '{' word '}' { $$ = lookup($3); } | '$' '{' word ':' .... as you can see, this get complex quite fast.
