[site]: stackoverflow
[post_id]: 2231450
[parent_id]: 2231302
[tags]: 
You're attempting to build an expression tree that represents this: c => true && c.ClientFName == searchForClientFName You are actually building an expression tree that represents this: c => c=> true && c => c.ClientFName == searchForClientFName which makes no sense at all. Now, you might naively think that this will work: public static Expression AndAlso (this Expression left, Expression right) { // NOTICE: Combining BODIES: return Expression.Lambda (Expression.AndAlso(left.Body, right.Body), left.Parameters); } That would produce in your case something representing c => true && c.ClientFName == searchForClientFName Which looks right. But in fact this is fragile. Suppose you had ... d => d.City == "London" ... ... c => c.ClientName == "Fred Smith" ... and you used this method to combine them. You'd get an object representing c => d.City == "London" && c.ClientName == "Fred Smith" What the heck is d doing in there? Furthermore, parameters are matched by object identity , not by parameter name . If you do this ... c => c.City == "London" ... ... c => c.ClientName == "Fred Smith" ... and combine them into c => c.City == "London" && c.ClientName == "Fred Smith" you're in the same boat; the "c" in "c.City" is a different c than the other two. What you actually need to do is make a third parameter object, substitute it in the bodies of both lambdas for every occurence of their parameters, and then build up a new lambda expression tree from the resulting substituted bodies. You can build a substitution engine by writing a visitor that passes over the expression tree body, rewriting it as it goes.
