[site]: stackoverflow
[post_id]: 1498466
[parent_id]: 1471479
[tags]: 
I separated your answers by topic. My problem is, if I want to persist a C , should it persist it's B ? What about if I want to persist a D? Should it persist all A, B, C? This is entirely dependent upon the domain constraints you choose to enforce. For example, is C an entity and B a value object? In other words, does C have a unique identity and life of its own? Is B mainly identified by its value and its life cycle tightly coupled to that of its parent C ? Asking these types of questions should help guide your decisions on what to persist, when, and by whom. For example, if both C and B are entities sharing only a relationship, you might decide to persist them independantly, since each could conceivably have a meaningful life and identity of its own. If B is a value object, you'd probably choose to have its parent entity C control its life, including the creation/retrieval/updating/deleting of the object. This might very well include C persisting B . Or should it be persisted before hand? To answer this you could have to map out your object dependencies. These dependencies are frequently represented by foreign key constraints when an object graph is persisted to a RDBMS. If C could not function without a reference to B , then you would probably want to persist them both inside a transaction, with B being done first to comply with the database's foreign key constraints. Following the line of thought above, if B was a child entity or value object of C , you might even have C responsible for persisting B . What about if I want a reasonable default B? The creation of B instances could be delegated to the B -Factory. Whether you implement this factory logic as a class (not instance) method, constructor, or separate it out as its own unit doesn't matter. The point is you have one place where the creation and configuration of new B s takes place. It is in this place that you would have a default configuration of the newly instantiated object take place. An excellent resource covering these types of questions is Domain-Driven Design by Eric Evans
