[site]: stackoverflow
[post_id]: 2762610
[parent_id]: 2762424
[tags]: 
A note on your Clone approach: I doubt you will be able to beat it, in terms of performance. However, it could be a breaking change considering that after the first initialization, it disregards the Size parameter and just returns an array of the same size on every call . Depending on whether that actually matters in your scenario, you could either: Stick with it, because it doesn't matter. Create a Dictionary (I believe Size would behave properly as a key -- haven't tested) to pre-initialize an array every time a unique Size is requested. The overhead of this I am not sure of. Abandon the Clone idea. In case you end up having to go with 3 above, here are a few borderline ridiculous suggestions: 1. Cache your Width and Height properties locally, rather than accessing them from the Size struct on each iteration . static int[,] CreateArray(Size size) { int w = size.Width; int h = size.Height; int[,] array = new int[w, h]; for (int x = 0; x To create a 1000x1000 array, on my machine, this resulted in an average execution time of about 120000 ticks versus about 140000 ticks. 2. Leverage multiple cores if you have them and initialize the array in parallel. static int[,] CreateArray(Size size) { int w = size.Width; int h = size.Height; int[,] array = new int[w, h]; Action fillFirstHalf = FillArray; Action fillSecondHalf = FillArray; var firstResult = fillFirstHalf.BeginInvoke(array, 0, h / 2, null, null); var secondResult = fillSecondHalf.BeginInvoke(array, h / 2, h, null, null); fillFirstHalf.EndInvoke(firstResult); fillSecondHalf.EndInvoke(secondResult); return array; } static void FillArray(int[,] array, int ystart, int yend) { int w = array.GetLength(0); for (int x = 0; x This one probably isn't a very realistic suggestion in your scenario, since it seems that you're only creating 100x100 arrays, in which case the overhead of the parallelization exceeds the performance gain. However, for creating a 1000x1000 array, I found that this approach reduced my execution times down to about 70k ticks on average (compared to the ~120k ticks I got from the first optimization I suggested). Also, if you are creating many arrays this way, I would highly recommend parallelizing that (i.e., if you need to create a thousand arrays, create 500 each from two threads), assuming you have multiple processors to do the work for you. Without multiple processors, forget it; adding threads will only hurt your performance. 3. Get enhanced performance by using an unsafe pointer. Now here's an interesting discovery: it appears that a two-dimensional array in .NET is allocated in a predictable way*: basically as a one-dimensional block of memory, where each "row" is offset from the starting point by an amount equivalent to the length of all previous rows. In other words, a 10x2 array can be accessed using pointer just like a 20x1 array; a 10x10 array can be accessed like a 100x1 array, etc. I have no idea if this is documented behavior or not. It may be an unspecified implementation detail that you don't want to depend on. Either way, it's worth looking into. * It's possible that most other .NET developers already knew this and I'm just stating the obvious, in which case, I rescind my comment about this being "interesting". In any case, knowledge of this allows you to exploit the fixed keyword in an unsafe context for a significant performance gain: static int[,] CreateArray(Size size) { int w = size.Width; int h = size.Height; int[,] array = new int[w, h]; unsafe { fixed (int* ptr = array) { for (int i = 0; i For initializing arrays of a signifcant size, I would even recommend combining the above approach (parallelization) with this one -- so, keep the same CreateArray from suggestion #2, and then rewrite FillArray as: static void FillArray(int[,] array, int ystart, int yend) { int w = array.GetLength(0); unsafe { fixed (int* p = array) { for (int i = w * ystart; i It actually seems that you already figured out this last part before I posted this, but I thought I'd include it anyway mainly for the point about combining unsafe with parallelization. A note on stackalloc : I think you may be chasing after the leprechaun at the end of the rainbow with this one. According to the documentation on stackalloc : A block of memory of sufficient size to contain expr elements of type type is allocated on the stack, not the heap; the address of the block is stored in pointer ptr . This memory is not subject to garbage collection and therefore does not have to be pinned (via fixed ). The lifetime of the memory block is limited to the lifetime of the method in which it is defined. (emphasis mine) This leads me to believe that you cannot return an object whose data is stored in memory allocated by stackalloc from a function, because that memory is only allocated for the lifetime of the function.
