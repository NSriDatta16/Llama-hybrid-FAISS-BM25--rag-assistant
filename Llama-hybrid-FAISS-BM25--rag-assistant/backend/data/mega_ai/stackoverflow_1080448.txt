[site]: stackoverflow
[post_id]: 1080448
[parent_id]: 
[tags]: 
Best Practice For List of Polymorphic Objects in C++

What is a common practice for the storage of a list of base class pointers each of which can describe a polymorphic derived class? To elaborate and in the interest of a simple example lets assume that I have a set of classes with the following goals: An abstract base class whose purpose is to enforce a common functionality on its derived classes. A set of derived classes which: can perform a common functionality, are inherently copyable (this is important), and are serializable. Now alongside this required functionality I want to address the following key points: I want the use of this system to be safe; I don't want a user to have undefined errors when he/she erroneously casts a base class pointer to the wrong derived type. Additionally I want as much as possible the work for copying/serializing this list to be taken care of automatically. The reason for this is, as a new derived type is added I don't want to have to search through many source files and make sure everything will be compatible. The following code demonstrates a simple case of this, and my proposed (again I am looking for a common well thought out method of doing this, mine may not be so good) solution. class Shape { public: virtual void draw() const = 0; virtual void serialize(); protected: int shapeType; }; class Square : public Shape { public: void draw const; // draw code here. void serialize(); // serialization here. private: // square member variables. }; class Circle : public Shape { public: void draw const; // draw code here. void serialize(); // serialization here. private: // circle member variables. }; // The proposed solution: rather than store list , store a generic shape type which // takes care of copying, saving, loading and throws errors when erroneous casting is done. class GenericShape { public: GenericShape( const Square& shape ); GenericShape( const Circle& shape ); ~GenericShape(); operator const Square& (); // Throw error here if a circle tries to get a square! operator const Circle& (); // Throw error here if a square tries to get a circle! private: Shape* copyShape( const Shape* otherShape ); Shape* m_pShape; // The internally stored pointer to a base type. }; The above code is certainly missing some items, firstly the base class would have a single constructor requiring the type, the derived classes would internally call this during their construction. Additionally in the GenericShape class, copy/assignment constructor/operator would be present. Sorry for the long post, trying to explain my intents fully. On that note, and to re-iterate: above is my solution, but this likely has some serious flaws and I would be happy to hear about them, and the other solutions out there! Thank you
