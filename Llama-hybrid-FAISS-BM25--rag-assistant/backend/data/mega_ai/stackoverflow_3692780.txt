[site]: stackoverflow
[post_id]: 3692780
[parent_id]: 3685747
[tags]: 
I evaluate dependencies' points of use through the intent/mechanism lens: is this code clearly communicating its intent, or do I have to extract that from a pile of implementation details? If the code indeed looks like a pile of implementation details, I determine the inputs and outputs and create an entirely new dependency to represent the why behind all the how . I then push the complexity into the new dependency, making the original code simpler and clearer. When I read the code in this question, I clearly see the retrieval of a file path based on a date, followed by an opaque set of statements which don't clearly communicate the goal of reading an entity of a certain type at a certain path. I can work my way through it but that breaks my stride. I suggest you raise the level of abstraction of the second half of the calculation, after you get the path. I would start by defining a dependency which implements the code's inputs/outputs: public interface IEntityReader { IEnumerable ReadEntities (string path); } Then, rewrite the original class using this intention-revealing interface: public sealed class CompanyDetailProvider : ICompanyDetailProvider { private readonly IFilePathProvider _filePathProvider; private readonly IEntityReader _entityReader; public CompanyDetailProvider(IFilePathProvider filePathProvider, IEntityReader entityReader) { _filePathProvider = filePathProvider; _entityReader = entityReader; } public IEnumerable GetCompanyDetailsForDate(DateTime date) { var path = _filePathProvider.GetCompanyDetailsFilePathForDate(date); return _entityReader.ReadEntities (path); } } Now you can sandbox the gory details, which become quite cohesive in isolation: public sealed class EntityReader : IEntityReader { private readonly IDataReaderFactory _dataReaderFactory; public EntityReader(IDataReaderFactory dataReaderFactory) { _dataReaderFactory = dataReaderFactory; } public IEnumerable ReadEntities (string path) { Func sourceProvider = () => _dataReaderFactory.CreateReader(DataFileType.FlatFile, path); return new Hydrator (sourceProvider); } } As shown in this example, I think you should abstract the data reader factory away and directly instantiate the hydrator. The distinction is that EntityReader uses the data reader factory, while it only creates the hydrator. It isn't actually dependent on the instance at all; instead, it serves as a hydrator factory.
