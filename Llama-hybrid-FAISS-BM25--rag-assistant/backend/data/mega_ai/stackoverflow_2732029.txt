[site]: stackoverflow
[post_id]: 2732029
[parent_id]: 2731663
[tags]: 
It's hard to wrap my head around your exact issue, but from what it got it might make sense to attack this a little differently using some design patterns. One that comes to mind that might make sense is the Strategy pattern. Basically, this is a way of encapsulating the algorithm (logic) from its host. Wikipedia has an entry on the Strategy pattern here: http://en.wikipedia.org/wiki/Strategy_pattern I'm thinking about a flow somewhat like this: You have an interface called IDataInputTransformer with 2 methods: bool AcceptsInput(bigDataInput i) and FieldObject[] TransformInput(bigDataInput i) The calling class has an IEnumerable of IDataInputTransformers that is set somehow -- either manually on instantiation or using dependency injection or something Upon being passed a bigDataInput, the calling class iterates over each IDataInputTransformer and calls AcceptsInput with the bigDataInput. If the input is not accepted it just tries the next & the next (if none accept the input perhaps an exception is thrown or something). If it the IDataInputTransformer does accept the input then you can call TransformInput and get the FieldObject[] that will be passed to AddControls You could take this further, but this is the basic idea. The benefits here are: Readability -- it's really easy to read FinanceDepartmentInputTransformer.TransformInput(), it's really hard to read a huge switch Able to change -- you can add new InputTransformers easily (and it won't ruin the readability or functionality) Rules are isolated -- you can easily check the business rules in the AcceptsInput methods Portability -- you could use this elsewhere too Testability -- you can easily unit test this to make sure it works right
