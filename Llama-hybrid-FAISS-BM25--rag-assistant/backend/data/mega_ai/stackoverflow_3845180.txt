[site]: stackoverflow
[post_id]: 3845180
[parent_id]: 3845022
[tags]: 
I've investigated this topic couple of years ago: I want to use log4net and Npgsql libraries from native code that compiles even withour /clr key. The main idea behind this technique described by Paul DiLascia in his two remarkable articles: Managed Code in Visual Studio 2005 Use Our ManWrap Library to Get the Best of .NET in Native C++ Code For example, here some code snippets that uses log4net library from native code (this code resides in simple non-managed dll, but you should compile this with /clr, but it's not nessary to compile with /clr key code that would use this dll from native code): // Log4NetWrapper.h #pragma once using namespace System; //facade for log4net library (you may create something like this too) ref class Log4NetWrapper { public: //I intentionally remove additional methods, because //I'm trying to show the main principle static void ReportDebugMessage(char* msg); private: static property log4net::ILog^ Logger { log4net::ILog^ get(); } static Object^ syncObject_ = gcnew Object(); static String^ loggerName_ = ""; }; //C-interface that could be accessed from native code extern "C" { _declspec(dllexport) void ReportDebugMessage(char* msg) { Log4NetWrapper::ReportDebugMessage(msg); } } // This is the main DLL file. #include "stdafx.h" #include "Log4NetWrapper.h" void Log4NetWrapper::ReportDebugMessage(char* msg) { String^ data = gcnew String(msg); Logger->Debug(data); } log4net::ILog^ Log4NetWrapper::Logger::get() { if ( loggerName_ == nullptr ) return log4net::LogManager::GetLogger(""); return log4net::LogManager::GetLogger(loggerName_); } Compile this code as native dll, than add this dll to your native project, add something like this to that project: #pragma once #pragma comment(lib, "Log4NetWrapper") extern "C" { _declspec(dllimport) void ReportDebugMessage(char* msg); } And use ReportDebugMessage to access managed code from native code.
