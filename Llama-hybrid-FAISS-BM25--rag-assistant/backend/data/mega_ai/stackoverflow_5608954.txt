[site]: stackoverflow
[post_id]: 5608954
[parent_id]: 5608440
[tags]: 
init... methods should only be called once, immediately after a call to alloc or allocWithZone: . When framework code creates and returns an object or graph of objects, their init... methods have already been called, so sending another init... message would have undefined results. Don't do that. Interestingly, in spite of what the documentation appears to say (and admittedly I probably missed a key sentence or paragraph somewhere), when you create an instance of a mutable collection by reading a plist, any nested collections are also mutable. I ran the following little experiment in a test harness just to be sure: NSMutableDictionary *pets = [NSMutableDictionary dictionaryWithContentsOfFile:@"/tmp/Pets.plist"]; NSMutableArray *cats = [pets objectForKey:@"cats"]; [cats addObject:@"Foo"]; // EDIT: Added line I accidentally omitted earlier NSLog(@"%@", cats); So again, the nested collections created when you read in the plist are fully initialized, and mutable to boot, so you can simply use them, as you've been doing. EDIT However, after doing some further reading of the docs, I think the OP is right to feel uneasy about relying on what is apparently an undocumented feature of the current version of the SDK. For example, the Property List Programming Guide states: If you load the property list with this call: NSMutableArray * ma = [NSMutableArray arrayWithContentsOfFile:xmlFile]; ma is a mutable array with immutable dictionaries in each element. Each key and each value in each dictionary are immutable. So, to be on the safe side, if you need a nested collection to be mutable, you should create it yourself. For example, I'd recommend rewriting the code in the example above as follows: NSMutableDictionary *pets = [NSMutableDictionary dictionaryWithContentsOfFile:@"/tmp/Pets.plist"]; NSArray *cats = [pets objectForKey:@"cats"]; NSMutableArray *mutableCats = [cats mutableCopy]; [pets setObject:mutableCats forKey:cats]; [mutableCats release]; You can then safely make changes to the nested mutable collection: [mutableCats addObject:@"Foo"];
