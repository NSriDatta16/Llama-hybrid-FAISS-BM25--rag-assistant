[site]: stackoverflow
[post_id]: 4030027
[parent_id]: 4029494
[tags]: 
Since the question was tagged "C++" I tidied up your code by using C++ techniques for failure checking and cleanup. It turned out that you've forgotten to check for failure in several places. The code below reports first failure at GetObject(className, ...) . #define _WIN32_DCOM #pragma comment(lib, "wbemuuid.lib") #include #include #include #include // EXIT_FAILURE, EXIT_SUCCESS using namespace std; #include #include #define DEF_SMARTPTR_TYPE( Interface ) \ _COM_SMARTPTR_TYPEDEF( Interface, __uuidof( Interface ) ) DEF_SMARTPTR_TYPE( IWbemLocator ); DEF_SMARTPTR_TYPE( IWbemServices ); DEF_SMARTPTR_TYPE( IWbemClassObject ); bool throwX( string const& s ) { throw std::runtime_error( s ); } string hexFrom( unsigned long v ) { char buf[40]; sprintf( buf, "%08lx", v ); return buf; } struct Fail { string message; explicit Fail( string const& aMessage ): message( aMessage ) {} }; void operator ||( HRESULT hr, Fail const& failure ) { SUCCEEDED( hr ) || throwX( failure.message + " (Error code 0x" + hexFrom( hr ) + ")" ); } struct ComLibUsage { struct Threading { enum Enum { singleThreaded = COINIT_APARTMENTTHREADED, multiThreaded = COINIT_MULTITHREADED }; }; ComLibUsage( Threading::Enum threading = Threading::multiThreaded ) { ::CoInitializeEx( 0, threading ) || Fail( "Failed to initialize COM library." ); } ~ComLibUsage() { ::CoUninitialize(); } }; void cppMain() { // Step 1: -------------------------------------------------- // Initialize COM. ------------------------------------------ ComLibUsage comLibUsage( ComLibUsage::Threading::multiThreaded ); // Step 2: -------------------------------------------------- // Set general COM security levels -------------------------- // Note: If you are using Windows 2000, you must specify - // the default authentication credentials for a user by using // a SOLE_AUTHENTICATION_LIST structure in the pAuthList ---- // parameter of CoInitializeSecurity ------------------------ CoInitializeSecurity( NULL, -1, // COM negotiates service NULL, // Authentication services NULL, // Reserved RPC_C_AUTHN_LEVEL_DEFAULT, // Default authentication RPC_C_IMP_LEVEL_IMPERSONATE, // Default Impersonation NULL, // Authentication info EOAC_NONE, // Additional capabilities NULL // Reserved ) || Fail( "Failed to initialize security" ); // Step 3: --------------------------------------------------- // Obtain the initial locator to WMI ------------------------- IWbemLocatorPtr pLoc; CoCreateInstance( CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLoc ) || Fail( "Failed to create IWbemLocator object." ); // Step 4: --------------------------------------------------- // Connect to WMI through the IWbemLocator::ConnectServer method // Connect to the local root\cimv2 namespace // and obtain pointer pSvc to make IWbemServices calls. IWbemServicesPtr pSvc; pLoc->ConnectServer( _bstr_t(L"ROOT\\wmi"), NULL, NULL, 0, NULL, 0, 0, &pSvc ) || Fail( "Could not connect." ); cout GetObject(className, 0, NULL, &pClass, NULL) || Fail( "GetObject(className, ...) failed" ); IWbemClassObjectPtr pInParamsDefinition; pClass->GetMethod(methodName, 0, &pInParamsDefinition, NULL) || Fail( "GetMethod(methodName, ...) failed" ); IWbemClassObjectPtr pClassInstance; pInParamsDefinition->SpawnInstance(0, &pClassInstance) || Fail( "SpawnInstance failed" ); _variant_t var1( L"1000" ); pClassInstance->Put(L"Timeout", 0, &var1, CIM_UINT32) //CIM_UINT64 || Fail( "Put failed for 'Timeout'" ); _variant_t var2( L"30" ); pClassInstance->Put(L"Brightness", 0, &var2, CIM_UINT8) || Fail( "Put failed for 'Brightness'" ); // Execute Method IWbemClassObject* pOutParams = NULL; //hres = pSvc->ExecMethod(className, methodName, 0, //NULL, pClassInstance, &pOutParams, NULL) //|| Fail( "Could not execute method" ); // To see what the method returned, // use the following code. The return value will // be in &varReturnValue _variant_t varReturnValue; pOutParams->Get(_bstr_t(L"ReturnValue"), 0, &varReturnValue, NULL, 0) || Fail( "Get failed" ); } int main() { try { cppMain(); return EXIT_SUCCESS; } catch( exception const& x ) { cerr Cheers & hth. (even if it's a bit on the side of your question!),
