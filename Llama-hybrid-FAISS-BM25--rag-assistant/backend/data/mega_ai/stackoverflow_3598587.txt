[site]: stackoverflow
[post_id]: 3598587
[parent_id]: 3524048
[tags]: 
In Python, you don't create an additional variable in the sort of situation you described. for i in range(10): Creates a range object, over which the loop iterates. The range object holds it's current value at any given time. i is merely a name that's created and bound to this value. The variable exists whether it has a name or not, since the range object must know it's current value. If you think about a loop in terms of cpu instructions, you see why there must be a variable: push x loop: do something increment x jump if x > y goto loop There is a facility in some JIT compiled languages that sometimes detects a loop being just a small amount of repetitions of the same code and optimises the code to be a series of the same instructions. But, as far as I know, python does no such thing. Here's a for-loop in bytecode: 4 0 SETUP_LOOP 20 (to 23) 3 LOAD_GLOBAL 0 (range) 6 LOAD_FAST 0 (x) 9 CALL_FUNCTION 1 12 GET_ITER >> 13 FOR_ITER 6 (to 22) 16 STORE_FAST 1 (i) 5 19 JUMP_ABSOLUTE 13 >> 22 POP_BLOCK Notice that there's no comparison. The loop is quit by the iteration object raising StopIteration, the interpreter then looks up the loop setup and jumps to the end of the loop (23 in this case). Of course you could avoid all of this by just repeating your code x number of times. As soon as this number may vary, there needs to be some sort of facility to provide next() and StopIteration for the for loop to work.Remember, python's for-loop is if anything comparable to a for-each loop in Java. There really isn't a traditional for-loop available at all. Just as an aside: I always use i, j and k for iterating variables. Using the underscore somehow seems inelegant to me.
