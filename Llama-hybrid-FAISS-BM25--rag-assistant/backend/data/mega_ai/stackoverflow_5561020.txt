[site]: stackoverflow
[post_id]: 5561020
[parent_id]: 5557019
[tags]: 
Update : Your problem is not related to the yield keyword specifically. It has to do with type variance . Your AcceptChangesAndYield method returns an object of a type implementing IEnumerable (in fact it is a compiler-generated type, but that's not really important). In your method call you are trying to downcast this to an IEnumerable , which is more specific . The IEnumerable interface is covariant which would allow you to upcast to a less specific type; e.g., you could cast from a List to an IEnumerable (in .NET 4.0, anyway). The type generated by the compiler to supply the return value of your AcceptChangesAndYield method only implements IEnumerable , so you could cast the result to an IEnumerable (for instance), but not to an IEnumerable . Fortunately, the solution is pretty simple. Redefine your AcceptChangesAndYield method as follows: // Note: We are using a generic type constraint on T. public static IEnumerable AcceptChangesAndYield (this IEnumerable obj) where T : MyModels.Interfaces.ILookup { if (obj.IsNull()) yield break; foreach (var m in obj) { // Did you mean to put m.AcceptChanges() here? yield return m; } } This will in turn allow your GetAll method to be implemented as follows: public IEnumerable GetAll() { var results = Database.Current.pStatusLookupLoadAll() .ExecuteTypedList (); // Note: no need for a cast, as the return value is now // already strongly typed as IEnumerable . return results.AcceptChangesAndYield(); } Original Answer : It seems like you just want this? IEnumerable EnumerateResults (IEnumerable results) { if (results.IsNull()) yield break; foreach (T result in results) { // ..Common logic lines... yield return result; } } Then in your code where you want to remove duplication, you'd just have: // Specific stuff var results = BlahBlahBlah(); // Common stuff return EnumerateResults(results); Right? Or am I misunderstanding your problem?
