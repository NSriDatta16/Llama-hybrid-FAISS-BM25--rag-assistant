[site]: crossvalidated
[post_id]: 457884
[parent_id]: 
[tags]: 
Bilinear interpolation concept: Error in PyTorch implementation?

I am studying the ROIAlign concept. This is a submodule of an object detection CNN architecture like Faster-RCNN. Basically it is about the following: Given a 'region of interest' of a varying size in the original image we need to send this through a classifier (that predicts what class of object is contained in the box), i.e. a fully connected layer. The FCN has a fixed input size so the task of ROIAlign is to 'extract information of equal size' from all of the boxes of variable size. Basically they do it as follows: They move the box onto the feature layer (i.e. the output of the base network like VGG16). Then they divide the box into corresponding bins and then in each bin they put a certain number of points and do something called bilinear interpolation. Bilinear interpolation works as follows: Given some point (x,y) in the bin and some values of the feature layer of the 'integer' indices around it we try to produce a value at (x,y): In this case x=0.75 and y=0.8, say. The feature layer is like FL[0,0]=V1, FL[1,0]=V3, FL[0,1]=V2, FL[1,1]=V4. What I understand and what makes sense is to take the values top left, top right, bottom left and bottom right of the integer cell (x,y) lies in and weight them by the size of the squares like so: I.e. the bilinear interpolation would be However, what they implemented in PyTorch seems to be kind of the opposite: In ROIAlign_cpu.cpp they implemented T ly = y - y_low; T lx = x - x_low; T hy = 1. - ly, hx = 1. - lx; T w1 = hy * hx, w2 = hy * lx, w3 = ly * hx, w4 = ly * lx; // save weights and indeces PreCalc pc; pc.pos1 = y_low * width + x_low; pc.pos2 = y_low * width + x_high; pc.pos3 = y_high * width + x_low; pc.pos4 = y_high * width + x_high; pc.w1 = w1; pc.w2 = w2; pc.w3 = w3; pc.w4 = w4; pre_calc[pre_calc_index] = pc; and then output_val += pc.w1 * offset_input[pc.pos1] + pc.w2 * offset_input[pc.pos2] + pc.w3 * offset_input[pc.pos3] + pc.w4 * offset_input[pc.pos4]; You see, they are multiplying w1 (= hy * hx , i.e. the size of the green square to the bottom right) with the value at pos1 (= [x_low, y_low] , i.e. with the value of the cell on the top left)... So: Am I totally blind or did they implement it in a wrong/unnatural way???
