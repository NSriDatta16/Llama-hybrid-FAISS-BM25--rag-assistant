[site]: stackoverflow
[post_id]: 2191570
[parent_id]: 2191489
[tags]: 
My biggest gripe would be the name, T ; Add might be more illusrative of the usage. I'd also add where T : class to the generic method, but the "fluent API" seems usable. I'd also be inclined to flatten the code a bit. I can also see some ways of using the Expression API to walk an entire tree and capture all the intermediate steps, but it wouldn't be trivial - but imagine: using(var com = new SomeWrapper()) { var baz = com.Add(() => new MyComObject().Foo.Bar.Baz); } where that is an expression tree and we get the intermediaries automatically. (also, you could Clear() or null the list in Dispose() ) Like so: static class ComExample { static void Main() { using (var wrapper = new ReleaseWrapper()) { var baz = wrapper.Add( () => new Foo().Bar.Baz); Console.WriteLine(baz.Name); } } } class ReleaseWrapper : IDisposable { List objects = new List (); public T Add (Expression > func) { return (T)Walk(func.Body); } object Walk(Expression expr) { object obj = WalkImpl(expr); if (obj != null && Marshal.IsComObject(obj) && !objects.Contains(obj)) { objects.Add(obj); } return obj; } object[] Walk(IEnumerable args) { if (args == null) return null; return args.Select(arg => Walk(arg)).ToArray(); } object WalkImpl(Expression expr) { switch (expr.NodeType) { case ExpressionType.Constant: return ((ConstantExpression)expr).Value; case ExpressionType.New: NewExpression ne = (NewExpression)expr; return ne.Constructor.Invoke(Walk(ne.Arguments)); case ExpressionType.MemberAccess: MemberExpression me = (MemberExpression)expr; object target = Walk(me.Expression); switch (me.Member.MemberType) { case MemberTypes.Field: return ((FieldInfo)me.Member).GetValue(target); case MemberTypes.Property: return ((PropertyInfo)me.Member).GetValue(target, null); default: throw new NotSupportedException(); } case ExpressionType.Call: MethodCallExpression mce = (MethodCallExpression)expr; return mce.Method.Invoke(Walk(mce.Object), Walk(mce.Arguments)); default: throw new NotSupportedException(); } } public void Dispose() { foreach(object obj in objects) { Marshal.ReleaseComObject(obj); Debug.WriteLine("Released: " + obj); } objects.Clear(); } }
