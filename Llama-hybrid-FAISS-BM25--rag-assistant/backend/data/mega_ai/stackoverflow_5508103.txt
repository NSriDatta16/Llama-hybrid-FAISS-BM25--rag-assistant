[site]: stackoverflow
[post_id]: 5508103
[parent_id]: 5507000
[tags]: 
Great to see other folks with interest in writing .NET debugging tools! I think the short answer is that there is no supported solution from Microsoft that nails what you want to accomplish. While we are trending in that direction we haven't gotten there yet. Of three criteria: supported, non-intrusive, version-independent, you would need to sacrifice at least one of them to some degree. These are some of the options which come to mind for each of your requests: 1) .NET loads some modules in the stealth mode, without LOAD_DLL_DEBUG_EVENT , and frequently even without the possibility to get the name of the executable. I need a notification; a) Registering a profiler via our profiling API can provide this notification. You would be slightly sacrificing the non-intrusive goal as this requires loading your own module inside the debuggee. However for lightweight notifications such as this you probably aren't disturbing state much. b) Attach using the ICorDebug API (as you noticed) can provide this notification from out of process. However the debugger starting in version 4 of CLR spins up its own native debug event loop which tends not to mesh well with existing native debugging infrastructure. There is support for mixed-mode debugging as seen in Visual Studio, however it is fragile, quite complex, and we generally don't recommend that anyone uses it for their own debugging tools ( http://blogs.msdn.com/b/jmstall/archive/2007/01/10/dont-write-an-interop-debugger.aspx ). Even if you did design a complete solution around it you would find a number of native debugging capabilities are no longer available to you, the debugging model is considerably more invasive, and your perf numbers would probably fall. I think you already recognized it wouldn't be viable for you, but just including the info in case others are making a similar consideration. c) Use an unsupported technique such as finding a place in CLR to install breakpoints, or matching the behavior of windbg+sos. Of course if you did this your solution might not be version resilient, and nobody could formally provide any instruction as to how it works, but some tool writers do it anyways. 2) I'd also like to get a notification each time JIT compiler compiles a method; a) Again as you noticed the profiling API can provide this callback to you. This option sacrifices a small amount of non-invasiveness. b) Using an unsupported technique (breakpoints or matching behavior with windbg/sos) you could likely extract this information. All the same caveats as before. c) Just for completeness, the ICorDebug API isn't an option here - there is no callback when code is Jitted. 3) For the given CIL method, I need the addresses of the corresponding native CPU commands; a) The profiler API provides a suitable method, http://msdn.microsoft.com/en-us/library/ms231070.aspx , at the cost of having to load your own DLL inside the debuggee process. b) As of version 4.0 of the CLR, ICorDebug does provide a non-invasive debugging option that can achieve this. It is the same support that is used for dump debugging in Visual Studio. This new model is very different from previous ICorDebug support in that it completely relinquishes control over debuggee execution and does not even need a live process to work with. To use this you would implement the ICorDebugDataTarget interface which is a simple wrapper over Read/WriteProcessMemory and Get/SetThreadContext . Implementing the WriteProcessMemory and SetThreadContext are optional if you want a completely non-invasive debugging model. At high level you use this model by: CLRCreateInstance ( http://msdn.microsoft.com/en-us/library/dd537633.aspx ) gives you an ICLRDebugging interface ICLRDebugging::OpenVirtualProcess ( http://msdn.microsoft.com/en-us/library/dd537649.aspx ) transforms ICorDebugDataTarget -> ICorDebugProcess You can use the ICorDebugProcess interface similar to how you would use this interface if you had gotten it from ICorDebug::CreateProcess , however none of the callbacks fire and none of the invasive operations such as creating breakpoints, stepping, function-evaluation, etc. will work. All of the inspection APIs such as getting the native code for a CIL method will work as before. For more insight into how this works the source code to mdbg version 4.0 is available and includes dump debugging ( http://www.microsoft.com/downloads/en/details.aspx?FamilyID=ce94e626-c43d-419c-8538-173f6a042ef5 ). Overall this method is supported and non-invasive, however it only works on .NET v4.0. c) Same as before, unsupported techniques could extract the data similar to what sos does internally. 4) Stack walk (decoding of managed stack frames) would be also appreciated. For brevity this one plays out similar to #3. Both profiler and debug APIs provide stack walking functionality. All in all I think your best back compatible answer would be to load a very lightweight profiler with most events disabled (or head into unsupported debugger hacking territory). For the future, the non-invasive debug APIs you can get through `OpenVirtualProcess` are probably where you want to end up. While there is no support for notifications yet (and I can't make any promises of future features) that is where I see it going. Hope that helped and if you need further drill down into specific options we can do that. I know I skimmed a lot here.
