[site]: stackoverflow
[post_id]: 4093050
[parent_id]: 4092624
[tags]: 
For some unknown reason, instead of going to bed, I went to work on this. Here's some code that solves this with minimal storage requirements. void Main() { var filePath=@"path\to\my.jpg"; var bytes=File.ReadAllBytes(filePath); var dimensions=GetJpegDimensions(bytes); //or //var dimensions=GetJpegDimensions(filePath); Console.WriteLine(dimensions); } public static Dimensions GetJpegDimensions(byte[] bytes) { using(var ms=new MemoryStream(bytes)) { return GetJpegDimensions(ms); } } public static Dimensions GetJpegDimensions(string filePath) { using(var fs=File.OpenRead(filePath)) { return GetJpegDimensions(fs); } } public static Dimensions GetJpegDimensions(Stream fs) { if(!fs.CanSeek) throw new ArgumentException("Stream must be seekable"); long blockStart; var buf = new byte[4]; fs.Read(buf, 0, 4); if(buf.SequenceEqual(new byte[]{0xff, 0xd8, 0xff, 0xe0})) { blockStart = fs.Position; fs.Read(buf, 0, 2); var blockLength = ((buf[0] = 7 && buf[0] == 0xff && buf[1] == 0xc0) { fs.Position += 1; fs.Read(buf, 0, 4); var height = (buf[0]
