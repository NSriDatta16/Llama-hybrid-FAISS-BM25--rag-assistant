[site]: stackoverflow
[post_id]: 342055
[parent_id]: 26098
[tags]: 
I had a similar issue so I wanted to post on this as well. Usually using extern "C" __declspec(dllexport) void Foo(); to export a function name is fine. It will usually export the name unmangled without the need for a .def file. There are, however, some exceptions like __stdcall functions and overloaded function names. If you declare a function to use the __stdcall convention (as is done for many API functions) then extern "C" __declspec(dllexport) void __stdcall Foo(); will export a mangled name like _Foo@4. In this case you may need to explicitly map the exported name to an internal mangled name. A. How to export an unmangled name. In a .def file add ---- EXPORTS ; Explicit exports can go here Foo ----- This will try to find a "best match" for an internal function Foo and export it. In the case above where there is only one foo this will create the mapping Foo = _Foo@4 as can be see via dumpbin /EXPORTS If you have overloaded a function name then you may need to explicitly say which function you want in the .def file by specifying a mangled name using the entryname[=internalname] syntax. e.g. ---- EXPORTS ; Explicit exports can go here Foo=_Foo@4 ----- B. An alternative to .def files is that you can export names "in place" using a #pragma. #pragma comment(linker, "/export:Foo=_Foo@4") C. A third alternative is to declare just one version of Foo as extern "C" to be exported unmangled. See here for details.
