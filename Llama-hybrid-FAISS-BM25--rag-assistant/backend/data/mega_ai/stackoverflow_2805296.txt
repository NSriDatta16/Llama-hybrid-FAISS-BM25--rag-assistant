[site]: stackoverflow
[post_id]: 2805296
[parent_id]: 2805224
[tags]: 
This question didn't mention a language so I'm going to choose 'C' based arrays for my answer. Arrays are allocated as a single chunk of memory. Growing an array is problematic because the only way to do it properly is to grow it at the end. For a growth of size N there must be at least N free bytes at the end of the array before the next allocated address. Supporting this type of allocation necessitates that allocations be spread across the virtual address space. This both removes the benefits of having memory allocations closer to each other and serves to increase fragmentation. This flies in the face of most memory managers which try to pack memory together and reduce fragmentation. Allocating a new array at a place in memory with sufficient space and copying the array there is simply not an option as a general solution. The reason why is that the previous location of the array is visible to consumers through pointers. int* array = malloc(int*someSize); int* pointer1 = &(arr[2]); growArray(&array, 12); // Can't move because pointer1 knows the address of the array
