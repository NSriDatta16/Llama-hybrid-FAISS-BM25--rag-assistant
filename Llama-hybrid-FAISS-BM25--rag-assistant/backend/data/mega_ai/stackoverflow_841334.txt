[site]: stackoverflow
[post_id]: 841334
[parent_id]: 784155
[tags]: 
You could write an extension method that would allow you to return any controls on the form that implement an interface. public static class FormExtensions { public static IDictionary GetControlsOf (this Form form) where T: class { var result = new Dictionary (); foreach (var control in form.Controls) { if ((control as T) != null) result.Add((control as T).Tag, control as T); } return result; } } Then in your form you could call it whereever you want by: this.GetControlsOf ()["NameOfControlHere"]; In the event that it returns more than one user control you would need to handle that some how, perhaps by adding Tag property to the interface to uniquely keep track of each user control or something, like so public partial class UserControl1 : UserControl, ICustomerName { public string Tag { get { return this.Name; } } } You can then drag and drop the user controls onto your form from the designer. Tag will always return the name of your control, which will allow you to directly access the control through the IDictionary's interface. You're developers could put whatever unique identifier they want in the name of the control, and it would carry through to the interface. Also, it should be noted that this approach will ALSO allow you to use this on ALL forms in your solution. The only other thing you would need to do is set your GenerateMember to false.
