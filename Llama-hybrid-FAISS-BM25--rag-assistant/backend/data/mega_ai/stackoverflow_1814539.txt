[site]: stackoverflow
[post_id]: 1814539
[parent_id]: 1814463
[tags]: 
In your code: person * setName() { person * array; array = malloc (2 * sizeof(person)); array->name = strdup("Robert"); array++; array->name = strdup("Jose"); return array; } you allocate space for two elements in the array and set array to point to the first: +-------+ +----------+ | array | ---> | array[0] | +-------+ +----------+ | array[1] | +----------+ You then increment the element pointer with array++ and that is what gets returned to the calling function at the end. That pointer points to the second array element which is why it seems to be wrong (and why you will almost certainly crash when you try to free that memory later by the way): +-------+ +----------+ | array | -+ | array[0] | +-------+ | +----------+ +-> | array[1] | +----------+ What you need is: person * setName() { person * array; array = malloc (2 * sizeof(person)); array[0].name = strdup("Robert"); array[1].name = strdup("Jose"); return array; } as you've already pointed out. This solution does not change the array pointer at all. But, if you really want to use pointers, you can just reverse the actions of the array++ with an array-- before returning so that array is set back to the right value: person * setName() { person * array; array = malloc (2 * sizeof(person)); array->name = strdup("Robert"); array++; array->name = strdup("Jose"); array--; return array; } Or, another way, which doesn't change the original pointer, doesn't use array indexing and doesn't use a second pointer is to use pointer arithmetic. The compiler knows what type the pointer points to so can adjust the pointer correctly to find the next element (you already know that it knows how to do this since array++ is shorthand for array = array + 1 and that statement adjusts the value by the correct amount also): person * setName() { person * array; array = malloc (2 * sizeof(person)); (array+0)->name = strdup("Robert"); (array+1)->name = strdup("Jose"); return array; }
