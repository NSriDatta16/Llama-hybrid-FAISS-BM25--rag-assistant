[site]: stackoverflow
[post_id]: 1797948
[parent_id]: 1797241
[tags]: 
In order of preference and general programming style, I will write code as follows: Map/fold if its available let x = [1 .. 10] |> List.map ((*) 2) Its just convenient and easy to use. Non-tail recursive function > let rec map f = function | x::xs -> f x::map f xs | [] -> [];; val map : ('a -> 'b) -> 'a list -> 'b list > [1 .. 10] |> map ((*) 2);; val it : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20] Most algorithms are easiest to read and express without tail-recursion. This works particularly well when you don't need to recurse too deeply, making it suitable for many sorting algorithms and most operations on balanced data structures. Remember, log 2 (1,000,000,000,000,000) ~= 50, so log(n) operation without tail-recursion isn't scary at all. Tail-recursive with accumulator > let rev l = let rec loop acc = function | [] -> acc | x::xs -> loop (x::acc) xs loop [] l let map f l = let rec loop acc = function | [] -> rev acc | x::xs -> loop (f x::acc) xs loop [] l;; val rev : 'a list -> 'a list val map : ('a -> 'b) -> 'a list -> 'b list > [1 .. 10] |> map ((*) 2);; val it : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20] It works, but the code is clumsy and elegance of the algorithm is slightly obscured. The example above isn't too bad to read, but once you get into tree-like data structures, it really starts to become a nightmare. Tail-recursive with continuation passing > let rec map cont f = function | [] -> cont [] | x::xs -> map (fun l -> cont 'b) -> ('c -> 'a) -> 'c list -> 'b > [1 .. 10] |> map id ((*) 2);; val it : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20] Whenever I see code like this, I say to myself "now that's a neat trick!". At the cost of readability, it maintains the shape of the non-recursive function, and found it really interesting for tail-recursive inserts into binary trees . Its probably my monad-phobia speaking here, or maybe my inherent lack of familiarity with Lisp's call/cc, but I think those occasions when CSP actually simplifies algorithms are few and far between. Counter-examples are welcome in the comments. While loops / for loops It occurs to me that, aside from sequence comprehensions, I've never used while or for loops in my F# code. In any case... > let map f l = let l' = ref l let acc = ref [] while not List.hd |> f)::!acc l' := !l' |> List.tl !acc |> List.rev;; val map : ('a -> 'b) -> 'a list -> 'b list > [1 .. 10] |> map ((*) 2);; val it : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20] Its practically a parody of imperative programming. You might be able to maintain a little sanity by declaring let mutable l' = l instead, but any non-trivial function will require the use of ref .
