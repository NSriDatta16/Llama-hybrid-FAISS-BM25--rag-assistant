[site]: stackoverflow
[post_id]: 1926581
[parent_id]: 1915185
[tags]: 
What you've discovered is that parentheses are not word! s. They are built-in to Rebol, and the parser makes sure they match up for you—just like block! does. This is a good thing—otherwise all around the system would be code handling the ()))() mismatches. You've been saved from that pain! But if you want then you can reinvent this pain in your own dialects, and use words like BEGIN and END instead of leveraging the ever-helpful paren! . :P Here's a minimalist patch to your code: args: [a b] block: copy [] foreach arg args [ p: to-paren [] append/only block p append p 'ask append p rejoin [arg ": "] ] set args reduce block Note that you cannot write copy () . Generally speaking, parentheses are a little trickier to work with in the do dialect than blocks—they are serving double-duty for precedence! The interpreter thinks copy () means you're trying to parenthesize an expression whose results you want to copy. :( You can save yourself some headaches by building things up as blocks, and then converting them only at the last minute: >> to-paren [ask "a: "] == (ask "a: ") P.S. I didn't want to distract from your question by pointing out that the parentheses weren't actually necessary: >> SET [a b] reduce [ask "a: " ask "b: "] But the good news about that is that if you're willing to let parens serve a "higher purpose" in this case, there's always compose args: [a b] block: copy [] foreach arg args [ append block compose [ask (rejoin [arg ": "])] ] set args reduce block Composing is like using a "templating dialect", which only reduces the expressions contained in parens, leaving everything else as-is. It's a good way to create code by example, but definitely does run into trouble if your generated code uses parentheses already for precedence! Still...goes to show that your dialects can use parentheses for any purpose, just like they can give meaning to words.
