[site]: stackoverflow
[post_id]: 5409175
[parent_id]: 5250277
[tags]: 
With Zookeeper it turns out there is a hack you can perform in order to allow a session to continue while interrupted in gdb. This hack leverages a few properties of Zookeeper and gdb: You can have multiple Zookeeper clients with same session ID gdb doesn't stop child processes at parent breakpoints You can ignore gdb signals in a child process without affecting the parent Based on this, the solution becomes spawning a child process which connects to Zookeeper with the same client id as the parent and does nothing else. Zookeeper clients however have the notion of session moving, where every so often the client will switch which server they are connected to. If you have two clients with same session ID, one of them could move leaving the other connected to a server that doesn't hold their session. To prevent this, the child must only connect to the server the parent is currently connected to. The parent and child thus look like the following: Parent(zh): host = zookeeper_get_connected_host(zh) client_id = zoo_client_id(zh) if fork == 0 exec child host client_id end Child(host, client_id): ignore SIGINT zh = zookeeper_init(host, client_id) while(true) sleep end I tested this using libzookeeper_mt-0.3.3 and it works as described. Some nastiness starts spewing out of the Zookeeper logs when you do this hack which can be frustrating. If you can't ignore the logs, you can turn them off as follows: zoo_set_debug_level((ZooLogLevel)0); It's an undocumented way in Zookeeper of disabling logging.
