[site]: stackoverflow
[post_id]: 5131367
[parent_id]: 5131158
[tags]: 
The test in your first RewriteCond will always succeed because the value of %{REQUEST_URI} always begins with a leading forward slash, and therefore can never begin with just "ipad". Try modifying it as follows: RewriteCond %{REQUEST_URI} !^/ipad RewriteCond %{HTTP_USER_AGENT} .*Mobile.*Safari RewriteRule ^(.*)$ /ipad [R=301,L] It's also a good idea to put a forward slash before "ipad" on account of your external redirection, as I've done there. If you've set RewriteBase, this won't be an issue, but you'll probably run into trouble otherwise due to how mod_rewrite generates the new request. Edit : The problem you're facing with your complete rule set stems from the fact that the value of the %{REQUEST_URI} will change after your second block of rules, causing the first condition to pass again when the rule set is reprocessed. This reprocessing step is part of how mod_rewrite works in a per-directory context , so you have to take it into consideration. Luckily, that's not hard to do: RewriteEngine On RewriteBase / # iOS redirection. # Make sure the URL hasn't already been rewritten internally RewriteCond %{ENV:REDIRECT_STATUS} ="" RewriteCond %{REQUEST_URI} !^/ipad RewriteCond %{HTTP_USER_AGENT} .*Mobile.*Safari RewriteRule ^(.*)$ /ipad [R=301,L] # If the requested URL does not exist (it's likely an agavi route), # pass it as path info to index.php, the Agavi dispatch script. RewriteRule ^$ index.php?/ [QSA,L] RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_URI} !^/favicon.ico RewriteRule (.*) index.php?/$1 [QSA,L]
