[site]: stackoverflow
[post_id]: 2878252
[parent_id]: 
[tags]: 
Multiple inheritance from template class

I'm having issues with multiple inheritance from different instantiations of the same template class. Specifically, I'm trying to do this: template class Base { public: Base() : obj(NULL) { } virtual ~Base() { if( obj != NULL ) delete obj; } template T* createBase() { obj = new T(); return obj; } protected: T* obj; }; class Something { // ... }; class SomethingElse { // ... }; class Derived : public Base , public Base { }; int main() { Derived* d = new Derived(); Something* smth1 = d->createBase (); SomethingElse* smth2 = d->createBase (); delete d; return 0; } When I try to compile the above code, I get the following errors: 1>[...](41) : error C2440: '=' : cannot convert from 'SomethingElse *' to 'Something *' 1> Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast 1> [...](71) : see reference to function template instantiation 'T *Base ::createBase (void)' being compiled 1> with 1> [ 1> T=SomethingElse 1> ] 1>[...](43) : error C2440: 'return' : cannot convert from 'Something *' to 'SomethingElse *' 1> Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast The issue seems to be ambiguity due to member obj being inherited from both Base and Base , and I can work around it by disambiguating my calls to createBase: Something* smth1 = d->Base ::createBase (); SomethingElse* smth2 = d->Base ::createBase (); However, this solution is dreadfully impractical, syntactically speaking, and I'd prefer something more elegant. Moreover, I'm puzzled by the first error message. It seems to imply that there is an instantiation createBase in Base , but how is that even possible? Any information or advice regarding this issue would be much appreciated.
