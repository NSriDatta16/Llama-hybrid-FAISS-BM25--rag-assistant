[site]: stackoverflow
[post_id]: 1916658
[parent_id]: 1916121
[tags]: 
I suggest: Start by setting up a polygon with four vertices to be eaten in varying size (up to maxside) rectangle lumps: public double[] fillBoard(double width, double height, double maxside) { double[] dest = new int[0]; double[] poly = new int[10]; poly[0] = 0; poly[1] = 0; poly[2] = width; poly[3] = 0; poly[4] = width; poly[5] = height; poly[6] = 0; poly[7] = height; poly[8] = 0; poly[9] = 0; ... return dest; /* x,y pairs */ } Then choose a random vertex, find polygon lines within (inclusive) 2 X maxside of the line. Find x values of all vertical lines and y values of all horizontal lines. Create ratings for the "goodness" of choosing each x and y value, and equations to generate ratings for values in between the values. Goodness is measured as reducing number of lines in remaining polygon. Generate three options for each range of values between two x coordinates or two y coordinates, using pseudo-random generator. Rate and choose pairs of x and pair of y values on weighted average basis leaning towards good options. Apply new rectangle to list by cutting its shape from the poly array and adding rectangle coordinates to the dest array. Question does not state a minimum side parameter. But if one is needed, algorithm should (upon hitting a hitch with a gap being too small) not include too small candidates in selection lists (whic will occasionally make them empty) and deselect a number of the surrounding rectangles in a certain radius of the problem with size and perform new regeneration attempts of that area, and hopefully the problem area, until the criteria are met. Recursion can remove progressively larger areas if a smaller relaying of tiles fails. EDIT Do some hit testing to eliminate potential overlaps. And eat some spinach before starting the typing. ;)
