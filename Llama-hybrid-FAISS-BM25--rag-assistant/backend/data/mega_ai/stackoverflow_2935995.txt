[site]: stackoverflow
[post_id]: 2935995
[parent_id]: 2933758
[tags]: 
Array based heaps seem ideal for your purpose. I am not sure why you rejected them. You use a max-heap. Say you have an N element heap (implemented as an array) which contains the N smallest elements seen so far. When an element comes in you check against the max (O(1) time), and reject if it is greater. If the value coming in is lower, you modify the root to be the new value and sift-down this changed value - worst case O(log N) time. The sift-down process is simple: Starting at root, at each step you exchange this value with it's larger child until the max-heap property is restored. So, you will not have to do any deletes which you probably will have to, if you use std::priority_queue. Depending on the implementation of std::priority_queue, this could cause memory allocation/deallocation. So you can have the code as follows: Allocated Array of size N. Fill it up with the first N elements you see. heapify (you should find this in standard text books, it uses sift-down). This is O(N). Now any new element you get, you either reject it in O(1) time or insert by sifting-down in worst case O(logN) time. On an average, though, you probably will not have to sift-down the new value all the way down and might get better than O(logn) average insert time (though I haven't tried proving it). You only allocate size N array once and any insertion is done by exchanging elements of the array, so there is no dynamic memory allocation after that. Check out the wiki page which has pseudo code for heapify and sift-down: http://en.wikipedia.org/wiki/Heapsort
