[site]: stackoverflow
[post_id]: 3851018
[parent_id]: 3770134
[tags]: 
After doing some research, I have found that there isn't a way to do this. The test rake tasks will always drop the database, even when providing the TEST= option as Bohdan suggests. By using the --trace option, this can be proven. Here is the output: $ rake test:units TEST=test/unit/post_test.rb --trace (in /Users/johnnyicon/Development/ror/test-app) ** Invoke test:units (first_time) ** Invoke test:prepare (first_time) ** Invoke db:test:prepare (first_time) ** Invoke db:abort_if_pending_migrations (first_time) ** Invoke environment (first_time) ** Execute environment ** Execute db:abort_if_pending_migrations ** Execute db:test:prepare ** Invoke db:test:load (first_time) ** Invoke db:test:purge (first_time) ** Invoke environment ** Execute db:test:purge ** Execute db:test:load ** Invoke db:schema:load (first_time) ** Invoke environment ** Execute db:schema:load ** Execute test:prepare ** Execute test:units Reading through the Ruby on Rails Guides for Testing , it describes what some of these rake tasks mean. The one to pay particular attention to is the db:test:load task, which you see on the 7th line from the bottom of the output as ** Execute db:test:load . The guides say the following about this task: Recreate the test database from the current schema.rb So even if I were to execute the unit tests one by one as Bohdan suggests, the rake task would still recreate the database. Not the answer I was hoping for, but it isn't a problem anymore. The reason I was asking to begin with was because I did not have access to another database to use for testing, so I was using my development database for testing as well. But since then, I've been able to get another database dedicated for testing. Thanks anyway Bohdan! I appreciate the help!
