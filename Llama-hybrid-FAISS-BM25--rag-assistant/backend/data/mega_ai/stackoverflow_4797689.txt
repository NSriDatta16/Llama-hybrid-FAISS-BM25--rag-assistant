[site]: stackoverflow
[post_id]: 4797689
[parent_id]: 4773162
[tags]: 
You will have to write a tokenizer-(chain). class Token { static Token Parse(string program); void Execute(CurrentProgramState state); } First have a Program token that tries to parse the entire text, by passing it by multiple smaller tokens that create tokens from it. Each successfull token passed consumes a little bit of the string, so in the end the string is empty. (And in the end a Program Token has an ordered list of tokens). Then when Program.Execute() is called it keeps track of the CurrentProgramState and passes that state in order to its own tokens which modify the game state according to its parameters. A small example. Say we have a language that has only two types of tokens s (for straight) number (for how far) class StraightToken { public StraightToken(NumberToken howFar) { this.howFar = howFar; } private NumberToken howFar; static Token Parse(string program) { if(program.StartsWith("s ") { NumberToken number = NumberToken.Parse(program.substring(2)); if(howFar != null) { return new StraightToken(number); } } return null; } public void Execute(ProgramState state) { state.Position += this.howFar.value; } } class NumberToken { public int value; public NumberToken(int value;) { this.value = value; } static Token Parse(string program) { if(IsDigit(program[0])) { program = program.SubString(1); return new NumberToken((int)program[0]) } } }
