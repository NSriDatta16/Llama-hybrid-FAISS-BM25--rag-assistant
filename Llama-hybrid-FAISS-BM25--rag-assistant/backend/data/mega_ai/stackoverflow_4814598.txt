[site]: stackoverflow
[post_id]: 4814598
[parent_id]: 4814487
[tags]: 
Separate the list of blocks into a list for each color, and sort all of those lists by the starting offset of the block. (Actually, you'll probably want to do an insertion sort as you're filtering based on color, or sort by offset and then do a stable sort by color and work with partitions of your array.) Once you have the per-color lists, you'll iterate over each one: Starting with the first block, check if the offset of the next block is close enough to the end of your current block, and if so, merge them. Then continue to the end of the list. Now, you've combined all the blocks you can of each color, so you can just concatenate your lists to get the final list of all blocks of all colors. The most expensive step (asymptotically) will be the sorting, so this is probably efficient enough. You might be able to come up with something that is faster on average using more advanced data structures than arrays and linked lists, but won't be worth the trouble until you measure the performance of this simpler approach. Note that because the rules for whether a two blocks can be merged depend only on the end point of one block and the start point of the other, and do not depend on the size of the blocks, any solution that can identify any potential merges will probably identify all merges, and it won't matter what order the merges are done in (that is, merging is an associative operation).
