[site]: stackoverflow
[post_id]: 4144975
[parent_id]: 4144659
[tags]: 
My suggestion is NOT to do it. This is not needed in WPF. Simply change the Window template and you'll get what you ask. Edit: Here is an example. --> You need the 3 images for the min / max / normal / close buttons (referenced in the images as Images/min.png, Images/max.png, Images/normal.png, Images/close.png). Compiling the resource dictionary gives a MyNamespace.StyleWindow class which you can complement with event handlers: using System; using System.Collections.Generic; using System.Text; using System.Windows; using System.Runtime.InteropServices; using System.Windows.Interop; using System.Windows.Input; using System.Windows.Media.Imaging; using System.Windows.Controls; namespace MyNamespace { public partial class StyleWindow { private void m_btnClose_Click(object sender, RoutedEventArgs e) { Window window = ((FrameworkElement)sender).TemplatedParent as Window; if (window != null) { window.Close(); } } private void m_btnMaximine_Click(object sender, RoutedEventArgs e) { Window window = ((FrameworkElement)sender).TemplatedParent as Window; if (window != null) { BitmapImage bitmap = new BitmapImage(); if (window.WindowState == WindowState.Maximized) { window.WindowState = WindowState.Normal; bitmap.BeginInit(); bitmap.UriSource = new Uri(@"Images/max.PNG", UriKind.Relative); bitmap.EndInit(); ((sender as Button).Content as Image).Source = bitmap; } else { window.WindowState = WindowState.Maximized; bitmap.BeginInit(); bitmap.UriSource = new Uri(@"Images/normal.PNG", UriKind.Relative); bitmap.EndInit(); ((sender as Button).Content as Image).Source = bitmap; } } } private void m_btnMinimine_Click(object sender, RoutedEventArgs e) { Window window = ((FrameworkElement)sender).TemplatedParent as Window; if (window != null) { window.WindowState = WindowState.Minimized; } } private void OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e) { Window window = ((FrameworkElement)sender).TemplatedParent as Window; if (window != null) { window.DragMove(); } } #region sizing event handlers void OnSizeSouth(object sender, System.Windows.Input.MouseButtonEventArgs e) { Window wnd = ((FrameworkElement) sender).TemplatedParent as Window; if (wnd != null) { WindowInteropHelper helper = new WindowInteropHelper(wnd); DragSize(helper.Handle, SizingAction.South); } } void OnSizeNorth(object sender, System.Windows.Input.MouseButtonEventArgs e) { Window wnd = ((FrameworkElement) sender).TemplatedParent as Window; if (wnd != null) { WindowInteropHelper helper = new WindowInteropHelper(wnd); DragSize(helper.Handle, SizingAction.North); } } void OnSizeEast(object sender, System.Windows.Input.MouseButtonEventArgs e) { Window wnd = ((FrameworkElement) sender).TemplatedParent as Window; if (wnd != null) { WindowInteropHelper helper = new WindowInteropHelper(wnd); DragSize(helper.Handle, SizingAction.East); } } void OnSizeWest(object sender, System.Windows.Input.MouseButtonEventArgs e) { Window wnd = ((FrameworkElement) sender).TemplatedParent as Window; if (wnd != null) { WindowInteropHelper helper = new WindowInteropHelper(wnd); DragSize(helper.Handle, SizingAction.West); } } void OnSizeNorthWest(object sender, System.Windows.Input.MouseButtonEventArgs e) { Window wnd = ((FrameworkElement) sender).TemplatedParent as Window; if (wnd != null) { WindowInteropHelper helper = new WindowInteropHelper(wnd); DragSize(helper.Handle, SizingAction.NorthWest); } } void OnSizeNorthEast(object sender, System.Windows.Input.MouseButtonEventArgs e) { Window wnd = ((FrameworkElement) sender).TemplatedParent as Window; if (wnd != null) { WindowInteropHelper helper = new WindowInteropHelper(wnd); DragSize(helper.Handle, SizingAction.NorthEast); } } void OnSizeSouthEast(object sender, System.Windows.Input.MouseButtonEventArgs e) { Window wnd = ((FrameworkElement) sender).TemplatedParent as Window; if (wnd != null) { WindowInteropHelper helper = new WindowInteropHelper(wnd); DragSize(helper.Handle, SizingAction.SouthEast); } } void OnSizeSouthWest(object sender, System.Windows.Input.MouseButtonEventArgs e) { Window wnd = ((FrameworkElement) sender).TemplatedParent as Window; if (wnd != null) { WindowInteropHelper helper = new WindowInteropHelper(wnd); DragSize(helper.Handle, SizingAction.SouthWest); } } #endregion #region P/Invoke and helper method const int WM_SYSCOMMAND = 0x112; const int SC_SIZE = 0xF000; [DllImport("user32.dll", CharSet = CharSet.Auto)] static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam); void DragSize(IntPtr handle, SizingAction sizingAction) { if (System.Windows.Input.Mouse.LeftButton == System.Windows.Input.MouseButtonState.Pressed) { SendMessage(handle, WM_SYSCOMMAND, (IntPtr) (SC_SIZE + sizingAction), IntPtr.Zero); SendMessage(handle, 514, IntPtr.Zero, IntPtr.Zero); } } #endregion #region helper enum public enum SizingAction { North = 3, South = 6, East = 2, West = 1, NorthEast = 5, NorthWest = 4, SouthEast = 8, SouthWest = 7 } } #endregion } This resource should be globally available. You can reference it in XAML like this: ... In my project, the designer tended to choke on this reference (maybe because it was a WinForms project with a main body made up of WPF elements). Because of this, we had to set the style programmatically, in the code-behind, in the window constructor: Style = (Style) FindResource(Constants.DEFAULT_WINDOW_STYLE); with a constant declaration with the value "WindowStyle". Here is the result (I apologize for the empty content, but it is confidential): I did not say it was pretty...
