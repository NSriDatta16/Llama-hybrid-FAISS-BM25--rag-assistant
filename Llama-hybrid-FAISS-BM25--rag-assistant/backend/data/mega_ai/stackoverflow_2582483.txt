[site]: stackoverflow
[post_id]: 2582483
[parent_id]: 2582383
[tags]: 
It's possible that the difference in timings is due to a change in when assemblies required for your operation are loaded. In release mode, the runtime may not need to immediately load an assembly that is only later required by your operation (because of various optimizations performed for release builds). Consequently, in debug mode an assembly may get loaded before you start timing your operation, and in release mode that assembly may get loaded after you start timing your operation. The time to load the assembly could be significant depending on how large the assembly is. Of course the assembly has to be loaded in both cases, and only has to be loaded once, so subsequent runs in release mode may be faster. Try performing your operation several times within a loop and ignoring the first execution to find the average less start up overhead. Update: Interesting that the timings in release mode vary a lot compared to those in debug mode (the std dev is 100x higher for release mode). On the lower end, the release mode timings are comparable to those in debug mode. You mention in your question that loading an account is intensive because of all of the child elements that have to load. Another difference could be the point at which the runtime decides to perform garbage collection. To test, you could try performing System.GC.Collect() after each operation (outside of your timer) and see if that changes things. Update: If you suspect there may be a change in behavior with respect to locking, you might consider using the Windows Performance Monitor to monitor the various .NET CLR LocksAndThreads counters for your application's process(es) while you run your tests in both debug and release modes. Perhaps you are not properly releasing a lock somewhere and execution is delayed until some timeout lapses? If so, I would expect to see an increase in contention rate reported by the performance counters. I'm not sure why this would only be a problem for release builds (unless you're actually using the debugger when running debug builds).
