[site]: stackoverflow
[post_id]: 4109329
[parent_id]: 4063547
[tags]: 
I couldn't resist doing it. It's your code with added timers and implemented a fade in / fade out. Also I changed to use mid grey rather than black for the obscuring block. You can tweak the constants that control the fade to make it smoother by increasing the duration or the increasing the rate. Experiment shows me that a rate of 10hz is smooth for me, but YMMV // DimWnd.h : header file #pragma once class CDimWnd : public CFrameWnd { public: CDimWnd(class CWnd * pParent); virtual ~CDimWnd(); BOOL OnEraseBkgnd(CDC* pDC); int opacity, opacity_increment; protected: DECLARE_MESSAGE_MAP() public: afx_msg void OnTimer(UINT_PTR nIDEvent); void fadeOut(); }; // DimWnd.cpp : implementation file // #include "stdafx.h" #include "dimmer.h" #include "DimWnd.h" #include "MainFrm.h" #include const int TIMER_ID = 111; // For preventing two dimmer windows ever appearing bool is_dimmer_active = false; // constants to control the fade. int ticks_per_second = 1000; // ms int start_opacity = 44; // 20% int max_opacity = 220; // 0->255 double fade_in_duration = 4; // seconds to fade in (appear) double fade_out_duration = 0.2; // seconds to fade out (disappear) int rate = 100; // Timer rate (ms CDimWnd::CDimWnd(CWnd * pParent) { // Don't do anything if the main frame doesn't appear to be there, // or if there is already dimming happening. if (pParent != NULL && !is_dimmer_active) { // Get the client area of the window to dim. CRect rc; pParent->GetClientRect(&rc); pParent->ClientToScreen(&rc); // convert to screen coordinates // Do some fudging to fit the client area exactly. // Other applications may not need this if the above client area fits already. rc.top += GetSystemMetrics(SM_CYFRAME); rc.top += GetSystemMetrics(SM_CYCAPTION); // MFC feature pack seems to include caption in client area rc.left -= GetSystemMetrics(SM_CXBORDER); rc.right += GetSystemMetrics(SM_CXBORDER) + 1; rc.bottom += GetSystemMetrics(SM_CYBORDER) + 1; // Create a layered window for transparency, with no caption/border. CreateEx(WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOOLWINDOW, NULL, TEXT(""), WS_POPUP, rc.left, rc.top, rc.Width(), rc.Height(), pParent->GetSafeHwnd(), NULL); // Bring in front of main window. BringWindowToTop(); // Show the dimmer window ShowWindow(SW_SHOW); double increment_per_second = ((max_opacity - start_opacity) / fade_in_duration); opacity_increment = ceil( increment_per_second / (ticks_per_second / rate) ) ; is_dimmer_active = true; opacity = start_opacity; SetLayeredWindowAttributes(RGB(0,0,0), opacity, LWA_ALPHA); SetTimer(TIMER_ID, rate,NULL); } } CDimWnd::~CDimWnd() { fadeOut(); // fade the window out rather than just disappearing. is_dimmer_active = false; } void CDimWnd::fadeOut() { // can't use timers as may be in the process of being destroyed so make it quick.. double increment_per_second = ((opacity - start_opacity) / fade_out_duration); opacity_increment = ceil( increment_per_second / (ticks_per_second / rate) ) ; while(opacity > start_opacity) { opacity -= opacity_increment; SetLayeredWindowAttributes(RGB(0,0,0), opacity, LWA_ALPHA); Sleep(100); } } BOOL CDimWnd::OnEraseBkgnd(CDC* pDC) { // Fill with midgray CBrush backBrush(RGB(128,128,128)); CBrush* pOldBrush = pDC->SelectObject(&backBrush); CRect rect; pDC->GetClipBox(&rect); // Erase the area needed pDC->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATCOPY); pDC->SelectObject(pOldBrush); return TRUE; } BEGIN_MESSAGE_MAP(CDimWnd, CFrameWnd) ON_WM_ERASEBKGND() ON_WM_TIMER() END_MESSAGE_MAP() void CDimWnd::OnTimer(UINT_PTR nIDEvent) { if (opacity >= max_opacity) { // stop the timer when fade in finished. KillTimer(TIMER_ID); return; } opacity += opacity_increment; SetLayeredWindowAttributes(RGB(0,0,0), opacity, LWA_ALPHA); CFrameWnd::OnTimer(nIDEvent); }
