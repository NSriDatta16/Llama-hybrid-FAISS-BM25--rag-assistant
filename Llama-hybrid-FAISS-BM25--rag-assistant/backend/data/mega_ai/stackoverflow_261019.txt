[site]: stackoverflow
[post_id]: 261019
[parent_id]: 260915
[tags]: 
This looks like an academic exercise which unfortunately makes it harder since you can't use C++. Basically you have to manage some of the overhead for the allocation and keep track how much memory has been allocated if you need to resize it later. This is where the C++ standard library shines. For your example, the following code allocates the memory and later resizes it: // initial size int count = 100; words *testWords = (words*) malloc(count * sizeof(words)); // resize the array count = 76; testWords = (words*) realloc(testWords, count* sizeof(words)); Keep in mind, in your example you are just allocating a pointer to a char and you still need to allocate the string itself and more importantly to free it at the end. So this code allocates 100 pointers to char and then resizes it to 76, but does not allocate the strings themselves. I have a suspicion that you actually want to allocate the number of characters in a string which is very similar to the above, but change word to char. EDIT: Also keep in mind it makes a lot of sense to create functions to perform common tasks and enforce consistency so you don't copy code everywhere. For example, you might have a) allocate the struct, b) assign values to the struct, and c) free the struct. So you might have: // Allocate a words struct words* CreateWords(int size); // Assign a value void AssignWord(word* dest, char* str); // Clear a words structs (and possibly internal storage) void FreeWords(words* w); EDIT: As far as resizing the structs, it is identical to resizing the char array. However the difference is if you make the struct array bigger, you should probably initialize the new array items to NULL. Likewise, if you make the struct array smaller, you need to cleanup before removing the items -- that is free items that have been allocated (and only the allocated items) before you resize the struct array. This is the primary reason I suggested creating helper functions to help manage this. // Resize words (must know original and new size if shrinking // if you need to free internal storage first) void ResizeWords(words* w, size_t oldsize, size_t newsize);
