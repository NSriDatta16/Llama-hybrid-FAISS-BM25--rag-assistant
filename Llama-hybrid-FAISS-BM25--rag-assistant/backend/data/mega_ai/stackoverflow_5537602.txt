[site]: stackoverflow
[post_id]: 5537602
[parent_id]: 5537549
[tags]: 
You may still get gaps if data gets deleted from the table. But if data only goes in and not out, then with proper use of transactions on an external sequence table, it should be possible to do this nicely. Don't use MAX()+1 because it can have timing issues, or you may have to lock more of the table (page/table) than required. Have a sequential table that has only one single record and column. Retrieve numbers from the table atomically, wrapping the retrieval and usage in a single transaction. begin tran declare @next int update seqn_for_invoice set @next=next=next+1 insert invoice (invoicenumber,...) value (@next, ....) commit The UPDATE statement is atomic and cannot be interrupted, and the double assignment make the value of @next atomic. It is equivalent to using an OUTPUT clause in SQL Server 2005+ to return the updated value. If you need a range of numbers in one go, it is easier to use the PRE-update value rather than the POST-update value, i.e. begin tran declare @next int update seqn_for_invoice set @next=next, next=next+3 -- 3 in one go insert invoice (invoicenumber,...) value (@next, ....) insert invoice (invoicenumber,...) value (@next+1, ....) insert invoice (invoicenumber,...) value (@next+2, ....) commit Reference for SQL Server UPDATE statement SET @variable = column = expression sets the variable to the same value as the column. This differs from SET @variable = column, column = expression, which sets the variable to the pre-update value of the column.
