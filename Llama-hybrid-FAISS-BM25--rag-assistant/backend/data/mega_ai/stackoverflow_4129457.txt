[site]: stackoverflow
[post_id]: 4129457
[parent_id]: 4126849
[tags]: 
Based on the revised question: I'm thinking the WorldState class needs a delegate... And Plan would set a method that should be called to test if an item is in use. Sortof like: delegate bool IsUsedDelegate(Item Item); public class WorldState { public IsUsedDelegate CheckIsUsed; public bool RemoveItem(Item item) { if (CheckIsUsed != null) { foreach (IsUsedDelegate checkDelegate in CheckIsUsed.GetInvocationList()) { if (checkDelegate(item)) { return false; // or throw exception } } } // Remove the item return true; } } Then, in the plan's constructor, set the delegate to be called public class plan { public plan(WorldState state) { state.IsUsedDelegate += CheckForItemUse; } public bool CheckForItemUse(Item item) { // Am I using it? } } This is very rough, of course, I'll try to add more after lunch : ) But you get the general idea. (Post-Lunch :) The downside is that you have to rely on the Plan to set the delegate... but there's simply no way to avoid that. There's no way for an Item to tell how many references there are to it, or to control its own usage. The best you can have is an understood contract... WorldState agrees not to remove an item if a Plan is using it, and Plan agrees to tell WorldState that it's using an item. If a Plan doesn't hold up its end of the contract, then it may end up in an invalid state. Tough luck, Plan , that's what you get for not following the rules. The reason you don't use events is because you need a return value. An alternative would be to have WorldState expose a method to add 'listeners' of type IPlan, where IPlan defines CheckItemForUse(Item item) . But you'd still have to rely that a Plan notifies WorldState to ask before removing an item. One huge gap that I'm seeing: In your example, the Plan you create is not tied to the WorldState stuffAtMyHouse. You could create a Plan to take your dog to the beach, for example, and Plan would be perfectly happy (you'd have to create a dog Item , of course). Edit: do you mean to pass stuffAtMyHouse to the Plan constructor, instead of myHouse ? Because they're not tied, you currently don't care if you remove bicycle from stuffAtMyHouse... because what you're currently saying is "I don't care where the bicycle starts, and I don't care where it belongs, just take it to the beach". But what you mean (I believe) is "Take my bicycle from my house and go to the beach." The Plan needs to have a starting WorldState context. TLDR: The best decoupling you can hope for is to let Plan choose what method WorldState should query before removing an item. HTH, James Original Answer It's not 100% clear to me what your goal is, and maybe it's just the forced example. Some possibilities: I. Enforcing the maximum ship size on methods such as SpaceBase.Dock(myShip) Pretty straight-forward... the SpaceBase tracks the size when called and throws a TooBigToDockException to the ship attempting to dock if it's too big. In this case, there's not really any coupling... you wouldn't notify the ship of the new max ship size, because managing the max ship size isn't the ship's responsibility. If the max ship size decreases, you would force the ship to undock... again, the ship doesn't need to know the new max size (though an event or interface to tell it that it's now floating in space might be appropriate). The ship would have no say or veto on the decision... The base has decided it's too big and has booted it. Your suspicions are correct... God objects are usually bad; clearly-delineated responsibilities make them vanish from the design in puffs of smoke. II. A queryable property of the SpaceBase If you want to let a ship ask you if it's too big to dock, you can expose this property. Again, you're not really coupled... you're just letting the ship make a decision to dock or not dock based on this property. But the base doesn't trust the ship to not-dock if it's too big... the base will still check on a call to Dock() and throw an exception. The responsibility for checking dock-related constraints lies firmly with the base. III. As true coupling, when the information is necessary to both parties In order to dock, the base may need to control the ship. Here an interface is appropriate, ISpaceShip , which might have methods such as Rotate() , MoveLeft() , and MoveRight() . Here you avoid coupling by the virtue of the interface itself... Every ship will implement Rotate() differently... the base doesn't care, so long as it can call Rotate() and have the ship turn in place. A NoSuchManeuverException might be thrown by the ship if it doesn't know how to rotate, in which case the base makes a decision to try something different or reject the dock. The objects communicate, but they are not coupled beyond the Interface (contract), and the base still has the responsibility of docking. IV. Validation on the MaxShipSize setter You talk about throwing an exception to the caller if it tries to set the MaxShipSize to smaller than the docked ships. I have to ask, though, who is trying to set the MaxShipSize, and why? Either the MaxShipSize should have been set in the constructor and be immutable, or setting the size should follow natural rules, e.g. you can't set the ship size smaller than its current size, because in the real world you would expand a SpaceBase, but never shrink it. By preventing illogical changes, you render the forced undocking and the communication that goes along with it moot. The point I'm trying to make is that when you feel like your code is getting unnecessarily complicated, you're almost always right, and your first consideration should be the underlying design. And that in code, less is always more. When you talk about writing Veto() and Error(), and additional methods to 'collect ships that are too large', I become concerned that the code will turn into a Rube Goldberg machine. And I think that separated responsibilities and encapsulation will whittle away much of the unnecessary complication you're experiencing. It's like a sink with plumbing issues... you can put in all sorts of bends and pipes, but the right solution is usually simple, straight-forward, and elegant. HTH, James
