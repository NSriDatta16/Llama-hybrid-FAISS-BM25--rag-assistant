[site]: stackoverflow
[post_id]: 3511249
[parent_id]: 3510682
[tags]: 
First you can read this comparison between ClearCase and Git As explained in Middle-ground between submodules and branches? , the one concept which is likely to trick you when coming from ClearCase is the notion of composition (configuration inheritance): see Flexible vs static branching (GIT vs Clearcase/Accurev) . ClearCase works file by file (or activity by activity, each activity being a group of files). Git works blob delta by blob delta (each blob representing a content : if two files have the same content, only one "blob" will be stored) That means what you are trying to do in ClearCase through branch/streams and activities (if you are using UCM), will more likely be achieved through: commit reordering (rebase --interactive, which is the "git" way, and not recommended in mercurial) and/or publication (which is an orthogonal dimension to branching, specific to DVCS) reordering + merge (only for commits not yet "published", ie not pushed): You are reordering the modifications deltas applied to your code, in order to merge only what you want. trunk => trunk' QA => QA' stable A B' | | B D' | | C A'----A' C'' | | | | D C' C' A''-- A'' (--: merge to branch) | | | | | E E E E E reordering + publication (push): You can also represent each code promotion by a git repo of its own. Once the commits are in the proper order, you push the relevant branches to a QA repo, or a stable repo. The reordering (history rewriting) is: not encouraged in Mercurial , while being technically possible problematic when a developer pull a branch someone else has rebased (reordered): see the RECOVERING FROM UPSTREAM REBASE section of the git rebase man page. See also: A successful Git branching model Using Mercurial in a Large Organization
