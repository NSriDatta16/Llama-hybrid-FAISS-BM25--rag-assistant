thit {terminates}}(opendoor,closed,T).} i n i t i a t e s ( c l o s e d o o r , c l o s e d , T ) . {\displaystyle {\mathit {initiates}}(closedoor,closed,T).} t e r m i n a t e s ( c l o s e d d o o r , o p e n , T ) . {\displaystyle {\mathit {terminates}}(closeddoor,open,T).} To apply the event calculus to a particular problem in the domain, it is necessary to specify the events that happen in the context of the problem. For example: h a p p e n s A t ( o p e n d o o r , 0 ) {\displaystyle {\mathit {happensAt}}(opendoor,0)} . h a p p e n s A t ( c l o s e d o o r , 3 ) {\displaystyle {\mathit {happensAt}}(closedoor,3)} . To solve a problem, such as which fluents hold at time 5?, it is necessary to pose the problem as a goal, such as: ∃ F l u e n t [ h o l d s A t ( F l u e n t , 5 ) ] . {\displaystyle \exists Fluent[{\mathit {holdsAt(Fluent,5)}}].} In this case, obtaining the unique solution: F l u e n t = c l o s e d . {\displaystyle Fluent=closed.} The event calculus solves the frame problem, eliminating undesired solutions, by using a non-monotonic logic, such as first-order logic with circumscription or by treating the event calculus as a logic program using negation as failure. Default logic solution The frame problem can be thought of as the problem of formalizing the principle that, by default, "everything is presumed to remain in the state in which it is" (Leibniz, "An Introduction to a Secret Encyclopædia", c. 1679). This default, sometimes called the commonsense law of inertia, was expressed by Raymond Reiter in default logic: R ( x , s ) : R ( x , d o ( a , s ) ) R ( x , d o ( a , s ) ) {\displaystyle {\frac {R(x,s)\;:\ R(x,\mathrm {do} (a,s))}{R(x,\mathrm {do} (a,s))}}} (if R ( x ) {\displaystyle R(x)} is true in situation s {\displaystyle s} , and it can be assumed that R ( x ) {\displaystyle R(x)} remains true after executing action a {\displaystyle a} , then we can conclude that R ( x ) {\displaystyle R(x)} remains true). Steve Hanks and Drew McDermott argued, on the basis of their Yale shooting example, that this solution to the frame problem is unsatisfactory. Hudson Turner showed, however, that it works correctly in the presence of appropriate additional postulates. Answer set programming solution The counterpart of the default logic solution in the language of answer set programming is a rule with strong negation: r ( X , T + 1 ) ← r ( X , T ) , not ∼ r ( X , T + 1 ) {\displaystyle r(X,T+1)\leftarrow r(X,T),\ {\hbox{not }}\sim r(X,T+1)} (if r ( X ) {\displaystyle r(X)} is true at time T {\displaystyle T} , and it can be assumed that r ( X ) {\displaystyle r(X)} remains true at time T + 1 {\displaystyle T+1} , then we can conclude that r ( X ) {\displaystyle r(X)} remains true). Separation logic solution Separation logic is a formalism for reasoning about computer programs using pre/post specifications of the form { p r e c o n d i t i o n } c o d e { p o s t c o n d i t i o n } {\displaystyle \{\mathrm {precondition} \}\ \mathrm {code} \ \{\mathrm {postcondition} \}} . Separation logic is an extension of Hoare logic oriented to reasoning about mutable data structures in computer memory and other dynamic resources, and it has a special connective *, pronounced "and separately", to support independent reasoning about disjoint memory regions. Separation logic employs a tight interpretation of pre/post specs, which say that the code can only access memory locations guaranteed to exist by the precondition. This leads to the soundness of the most important inference rule of the logic, the frame rule { p r e c o n d i t i o n } c o d e { p o s t c o n d i t i o n } { p r e c o n d i t i o n ∗ f r a m e } c o d e { p o s t c o n d i t i o n ∗ f r a m e } {\displaystyle {\frac {\{\mathrm {precondition} \}\ \mathrm {code} \ \{\mathrm {postcondition} \}}{\{\mathrm {precondition} \ast \mathrm {frame} \}\ \mathrm {code} \ \{\mathrm {postcondition} \ast \mathrm {frame} \}}}} The frame rule allows descriptions of arbitrar