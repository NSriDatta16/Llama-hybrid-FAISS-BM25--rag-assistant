[site]: stackoverflow
[post_id]: 1648565
[parent_id]: 1648551
[tags]: 
Well, it does mean that every object has to potentially have a monitor associated with it. The same monitor is used for synchronized . If you agree with the decision to be able to synchronize on any object, then wait() and notify() don't add any more per-object state. The JVM may allocate the actual monitor lazily (I know .NET does) but there has to be some storage space available to say which monitor is associated with the object. Admittedly it's possible that this is a very small amount (e.g. 3 bytes) which wouldn't actually save any memory anyway due to padding of the rest of the object overhead - you'd have to look at how each individual JVM handled memory to say for sure. Note that just having extra methods doesn't affect performance (other than very slightly due to the code obvious being present somewhere ). It's not like each object or even each type has its own copy of the code for wait() and notify() . Depending on how the vtables work, each type may end up with an extra vtable entry for each inherited method - but that's still only on a per type basis, not a per object basis. That's basically going to get lost in the noise compared with the bulk of the storage which is for the actual objects themselves. Personally, I feel that both .NET and Java made a mistake by associating a monitor with every object - I'd rather have explicit synchronization objects instead. I wrote a bit more on this in a blog post about redesigning java.lang.Object/System.Object .
