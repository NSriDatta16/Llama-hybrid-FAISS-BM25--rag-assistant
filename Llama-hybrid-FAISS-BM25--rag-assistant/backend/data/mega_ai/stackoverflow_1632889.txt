[site]: stackoverflow
[post_id]: 1632889
[parent_id]: 1632429
[tags]: 
Platform specific configuration headers I'd have a system to generate the platform-specific configuration into a header that is used in all builds. The AutoConf name is 'config.h'; you can see 'platform.h' or 'porting.h' or 'port.h' or other variations on the theme. This file contains the information needed for the platform being built. You can generate the file by copying a version-controlled platform-specific variant to the standard name. You can use a link instead of copying. Or you can run configuration scripts to determine its contents based on what the script finds on the machine. Default values for configuration parameters The code: #if (DAN==YES) char MasterSkipFile[MAXSTR] = "/home/dp120728/tools/testarea/MasterSkipFile"; #endif #if (UNIX==YES) char MasterSkipFile[MAXSTR] = "/home/tregrp/tre1/tretools/MasterSkipFile"; #endif #if (LINUX==YES) char MasterSkipFile[MAXSTR] = "/ptehome/tregrp/tre1/tretools/MasterSkipFile"; #endif Would be better replaced by: #ifndef MASTER_SKIP_FILE_PATH #define MASTER_SKIP_FILE_PATH "/opt/tretools/MasterSkipFile" #endif const char MasterSkipFile[] = MASTER_SKIP_FILE_PATH; Those who want the build in a different location can set the location via: -DMASTER_SKIP_FILE_PATH='"/ptehome/tregtp/tre1/tretools/PinkElephant"' Note the use of single and double quotes; try to avoid doing this on the command line with backslashes in the path. You can use a similar default mechanism for all sorts of things: #ifndef DEFAULTABLE_PARAMETER #define DEFAULTABLE_PARAMETER default_value #endif If you choose your defaults well, this can save a lot of energy. Relocatable software I'm not sure about the design of the software that can only be installed in one location. In my book, you need to be able to have the old version 1.12 of the product installed on the machine at the same time as the new 2.1 version, and they should be able to operate independently. A hard-coded path name defeats that. Parameterize by feature not platform The key difference between the AutoConf tools and the average alternative system is that the configuration is done based on features, not on platforms. You parameterize your code to identify a feature that you want to use. This is crucial because features tend to appear on platforms other than the original. I look after code where there are lines like: #if defined(SUN4) || defined(SOLARIS_2) || defined(HP_UX) || \ defined(LINUX) || defined(PYRAMID) || defined(SEQUENT) || \ defined(SEQUENT40) || defined(NCR) ... #include #endif It would be much, much better to have: #ifdef INCLUDE_SYS_TYPES_H #include #endif And then on the platforms where it is needed, generate: #define INCLUDE_SYS_TYPES_H (Don't take this example header too literally; it is the concept I am trying to get over.) Treat platform as a bundle of features As a corollary to the previous point, you do need to detect platform and define the features that are applicable to that platform. This is where you have the platform-specific configuration header which defines the configuration features. Product features should be enabled in a header ( Elaborating on a comment I made to another answer. ) Suppose you have a bunch of features in the product that need to be included or excluded conditionally. For example: KVLOCKING B1SECURITY C2SECURITY DYNAMICLOCKS The relevant code is included when the appropriate define is set: #ifdef KVLOCKING ...KVLOCKING stuff... #else ...non-KVLOCKING stuff... #endif If you use a source code analysis tool like cscope , then it is helpful if it can show you when KVLOCKING is defined. If the only place where it is defined is in some random Makefiles scattered around the build system (let's assume there are a hundred sub-directories that are used in this), it is hard to tell whether the code is still in use on any of your platforms. If the defines are in a header somewhere - the platform specific header, or maybe a product release header (so version 1.x can have KVLOCKING and version 2.x can include C2SECURITY but 2.5 includes B1SECURITY, etc), then you can see that KVLOCKING code is still in use. Believe me, after twenty years of development and staff turnover, people don't know whether features are still in use or not (because it is stable and never causes problems - possibly because it is never used). And if the only place to find whether KVLOCKING is still defined is in the Makefiles, then tools like cscope are less helpful - which makes modifying the code more error prone when trying to clean up later.
