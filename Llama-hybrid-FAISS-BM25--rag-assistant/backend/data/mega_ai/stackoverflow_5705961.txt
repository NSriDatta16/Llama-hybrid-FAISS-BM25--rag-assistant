[site]: stackoverflow
[post_id]: 5705961
[parent_id]: 5705152
[tags]: 
I ran into the same problem learning from the MSDN article. I don't know that my solution is "the best", but this is how I updated the Pizza grammar and handled the default selections. First, this is how I create the pizza grammar: private Grammar CreatePizzaGrammar() { //create the pizza grammar GrammarBuilder pizzaRequest = CreatePizzaGrammarBuilder(); Grammar pizzaGrammar = new Grammar(pizzaRequest); return pizzaGrammar; } private GrammarBuilder CreatePizzaGrammarBuilder() { // this is adapted from the sample in http://msdn.microsoft.com/en-us/magazine/cc163663.aspx // but the API changed before Vista was released so some changes were made. //[I'd like] a [ ] [ ] [ ] pizza [please] //build the core set of choices // size Choices sizes = new Choices(); SemanticResultValue sizeSRV; sizeSRV = new SemanticResultValue("small", "small"); sizes.Add(sizeSRV); sizeSRV = new SemanticResultValue("regular", "regular"); sizes.Add(sizeSRV); sizeSRV = new SemanticResultValue("medium", "regular"); sizes.Add(sizeSRV); sizeSRV = new SemanticResultValue("large", "large"); sizes.Add(sizeSRV); SemanticResultKey sizeSemKey = new SemanticResultKey("size", sizes); // crust Choices crusts = new Choices(); SemanticResultValue crustSRV; crustSRV = new SemanticResultValue("thin crust", "thin crust"); crusts.Add(crustSRV); crustSRV = new SemanticResultValue("thin", "thin crust"); crusts.Add(crustSRV); crustSRV = new SemanticResultValue("thick crust", "thick crust"); crusts.Add(crustSRV); crustSRV = new SemanticResultValue("thick", "thick crust"); crusts.Add(crustSRV); SemanticResultKey crustSemKey = new SemanticResultKey("crust", crusts); // toppings Choices toppings = new Choices(); SemanticResultValue toppingSRV; toppingSRV = new SemanticResultValue("vegetarian", "vegetarian"); toppings.Add(toppingSRV); toppingSRV = new SemanticResultValue("veggie", "vegetarian"); toppings.Add(toppingSRV); toppingSRV = new SemanticResultValue("pepperoni", "pepperoni"); toppings.Add(toppingSRV); toppingSRV = new SemanticResultValue("cheese", "cheese"); toppings.Add(toppingSRV); toppingSRV = new SemanticResultValue("plain", "cheese"); toppings.Add(toppingSRV); SemanticResultKey toppingSemKey = new SemanticResultKey("topping", toppings); //build the permutations of choices... // 1. choose all three GrammarBuilder sizeCrustTopping = new GrammarBuilder(); sizeCrustTopping.Append(sizeSemKey); sizeCrustTopping.Append(crustSemKey); sizeCrustTopping.Append(toppingSemKey); // 2. choose size and topping GrammarBuilder sizeAndTopping = new GrammarBuilder(); sizeAndTopping.Append(sizeSemKey); sizeAndTopping.Append(toppingSemKey); // sizeAndTopping.Append(new SemanticResultKey("crust", "thick crust")); // sizeAndTopping.AppendResultKeyValue("crust", "thick crust"); // 3. choose size and crust, and assume cheese GrammarBuilder sizeAndCrust = new GrammarBuilder(); sizeAndCrust.Append(sizeSemKey); sizeAndCrust.Append(crustSemKey); // 4. choose topping and crust, and assume cheese GrammarBuilder toppingAndCrust = new GrammarBuilder(); toppingAndCrust.Append(crustSemKey); toppingAndCrust.Append(toppingSemKey); // 5. choose topping only, and assume the rest GrammarBuilder toppingOnly = new GrammarBuilder(); toppingOnly.Append(toppingSemKey); //, "topping"); // 6. choose size only, and assume the rest GrammarBuilder sizeOnly = new GrammarBuilder(); sizeOnly.Append(sizeSemKey); // 7. choose crust only, and assume the rest GrammarBuilder crustOnly = new GrammarBuilder(); crustOnly.Append(crustSemKey); //assemble the permutations Choices permutations = new Choices(); permutations.Add(sizeCrustTopping); permutations.Add(sizeAndTopping); permutations.Add(sizeAndCrust); permutations.Add(toppingAndCrust); permutations.Add(toppingOnly); permutations.Add(sizeOnly); permutations.Add(crustOnly); GrammarBuilder permutationList = new GrammarBuilder(); permutationList.Append(permutations); //now build the complete pattern... GrammarBuilder pizzaRequest = new GrammarBuilder(); //pre-amble "[I'd like] a" pizzaRequest.Append(new Choices("I'd like a", "a", "I need a", "I want a")); //permutations "[ ] [ ] [ ]" pizzaRequest.Append(permutationList, 0, 1); //post-amble "pizza [please]" pizzaRequest.Append(new Choices("pizza", "pizza please", "pie", "pizza pie")); return pizzaRequest; } Then I set up an event handler for the SpeechRecognized event as: void recognizer_SpeechRecognizedPizza(object sender, SpeechRecognizedEventArgs e) { // set the default semantic key values if the result does not include these string size = "regular"; string crust = "thick crust"; string topping = "cheese"; if (e.Result.Semantics != null && e.Result.Semantics.Count != 0) { if (e.Result.Semantics.ContainsKey("size")) { size = e.Result.Semantics["size"].Value.ToString(); AppendTextOuput(String.Format("\r\n Size = {0}.", size)); } if (e.Result.Semantics.ContainsKey("crust")) { crust = e.Result.Semantics["crust"].Value.ToString(); AppendTextOuput(String.Format("\r\n Crust = {0}.", crust)); } if (e.Result.Semantics.ContainsKey("topping")) { topping = e.Result.Semantics["topping"].Value.ToString(); AppendTextOuput(String.Format("\r\n Topping = {0}.", topping)); } } String sOutput = String.Format("\r\nRecognized: You have orderd a {0}, {1}, {2} pizza.", size, crust, topping); AppendTextOuput(sOutput); } AppendTextOuput is just my own little output string method. This seemed like a lot of work to explicitly layout all the possible permutations in the grammar. But, it works really well. As you can see, I ended up avoiding the issue of having the grammar provide the default and simply built it into the event handler. There is probably a better way. One other step to learn more is to use the SrgsDocument.WriteSrgs() method and write out an SRGS XML document that represents the grammar. The rule and semantic tags are much easier to visualize in XML.
