[site]: stackoverflow
[post_id]: 1255357
[parent_id]: 1255334
[tags]: 
It looks like you've written a very nice little ORM (object relational mapper) with an implementation of the Repository (or close to) pattern. You also took advantage of the design pattern called Fluent Interfaces which is what is allowing you to do .Table .Fields cascading from each other. All 3 of these patterns are very good to be included in modern software system design as you already notice they greatly reduce the LOC, enhance maintainability and greatly improve test ability. I also like that you constructed your functionality to be able to return strongly typed objects using generics correctly. Edit: The only possible area I could see for improvement would to be change the fact every call is a new Query and perhaps change your code to use a dependency injection framework that will inject the correct provider and when the object is called that it will initiated a database transaction for the query. If your code already pretty much does that internally in the Query class that could be called "Poor man's dependency injection" or atleast it's very similar (depending on your implementation) which if it's already working for you and you don't intend to really grow out your types of database support the Poor man's DI should be just fine. I'm just not a fan of the new keyword in any usage anymore since it usually causes high levels of code coupling that a DI framework alleviates (or it's for method hiding with is a bad bad design decision). In response to Mark's answer , I'm usually never a fan of code generation it always seems to become a point of failure however he does have a very good point to reduce the amount of magic strings involved. I would instead choose to use the Lambda operator and expressions to handle this though, so you could achieve this: public static OrdersDataTable GetByOrderId( int id ) { return new Query(connection) .Table(x => Inflector.Pluralize(x.GetType()) .Fields(x=> { x.OrderID, x.CustomerID, x.Description, x.Amount }) .Equals(x=>x.OrderID, id) .Execute (); } This will remove all of the magic string refactoring issues allowing you to leverage Microsoft's built in refactoring tools much easier or Resharper's (of course resharper can find magic strings during refactoring). Inflector is a free library (can't remember if it's OSS or not) that includes functionality for dealing with text, the Pluralize method will take a word and make it... plural if you couldn't guess. Where this is useful is when you have like Story where you can't just go GetType() + "s" since Storys isn't correct and Inflector will correctly return you "Stories".
