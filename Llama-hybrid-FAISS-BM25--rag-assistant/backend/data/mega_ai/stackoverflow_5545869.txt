[site]: stackoverflow
[post_id]: 5545869
[parent_id]: 5534927
[tags]: 
What you want to do will work fine. But you made a left turn on this: CREATE TABLE child_view( id integer, p_data integer, c_data integer ); CREATE RULE "_RETURN" AS ON SELECT TO child_view DO INSTEAD SELECT child.id, p_data, c_data FROM parent JOIN child ON (parent_id=parent.id); You want a real life view here not a table. That is why delete will not work. CREATE VIEW child_view AS SELECT child.id, p_data, c_data FROM parent JOIN child ON (parent_id=parent.id) ; Replace the top with the bottom and it will work perfectly (It did when I tested it). The reason delete does not work is it trying to delete id from the TABLE child view which is of course empty! It does not execute the 'select do instead' rule so it is working on the real table child view. People may poo-poo using rules but if they cannot see such an obvious mistake I wonder how much they know? I have used rules successfully in defining interfaces to enforce business rules. They can lead elegant solutions in ways triggers could not. Note: I only recommend this to make writable views for an interface. You could do clever things like checking constraints across tables - and you may be asking for it . That kind stuff really should be used with triggers. Edit: script per request -- set this as you may have had an error if you running -- from a script and not noticed it with all the NOTICES \set ON_ERROR_STOP drop table if exists parent cascade; drop table if exists child cascade; CREATE TABLE parent( id serial PRIMARY KEY, p_data integer NOT NULL UNIQUE ); CREATE TABLE child( id serial PRIMARY KEY, parent_id integer NOT NULL UNIQUE REFERENCES parent(id), c_data integer NOT NULL ); CREATE VIEW child_view AS SELECT child.id, p_data, c_data FROM parent JOIN child ON (parent_id=parent.id) ; CREATE RULE child_delete AS ON DELETE TO child_view DO INSTEAD( DELETE FROM child WHERE id=OLD.id; DELETE FROM parent WHERE p_data=OLD.p_data; ); insert into parent (p_data) values (1), (2), (3); insert into child (parent_id, c_data) values (1, 1), (2, 2), (3, 3); select * from child_view; id | p_data | c_data ----+--------+-------- 1 | 1 | 1 2 | 2 | 2 3 | 3 | 3 (3 rows) delete from child_view where id=3; DELETE 0 select * from child_view; id | p_data | c_data ----+--------+-------- 1 | 1 | 1 2 | 2 | 2 (2 rows)
