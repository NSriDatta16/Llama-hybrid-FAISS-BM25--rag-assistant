[site]: stackoverflow
[post_id]: 1456673
[parent_id]: 1456629
[tags]: 
Based on the description and example, you are using inheritance inappropriately. It looks like you are creating many classes where you should be using a single class and many object instances. If this is true, you also don't need a design pattern to solve the problem. Without further clarification of the problem, this should suffice: class Car { private int manufactureYear; private Color color; private int numCylinders; public int getManufactureYear() { return manufactureYear; } public void setManufactureYear(int manufactureYear) { this.manufactureYear = manufactureYear; } public Color getColor() { return color; } public void setColor(Color color) { this.color = color; } public int getNumCylinders() { return numCylinders; } public void setNumCylinders(int numCylinders) { this.numCylinders = numCylinders; } } Example usages: // make a blue 6-cylinder: Car blue6 = new Car(); blue6.setColor(BLUE); blue6.setCylinders(6); // make a red 4-cylinder: Car red4 = new Car(); red4.setColor(RED); red4.setCylinders(4); // Uh-oh, they painted my red car! red4.setColor(YELLOW); If you want to minimize changes, you could use my refactored Car class from above, and then clean up the child classes so they leverage it. Something like: class CarOne extends Car { // extends my version of Car... private static Color COLOR = Color.Red; private static int CYLINDERS = 4; public CarOne() { setColor(COLOR); setNumCylinders(CYLINDERS ); } // getters deleted, base class has them now } Since there is in fact a base class, my guess is that 99% of the code does not reference the concrete car classes (only the base class), so you should be able to change things fairly easily. Of course, hard to say without seeing the real code.
