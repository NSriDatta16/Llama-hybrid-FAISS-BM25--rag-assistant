[site]: stackoverflow
[post_id]: 5544197
[parent_id]: 5541054
[tags]: 
Previous answers that point out that calling epoll_wait() from multiple threads is a bad idea are almost certainly right, but I was intrigued enough by the question to try and work out what does happen when it is called from multiple threads on the same handle, waiting for the same socket. I wrote the following test code: #include #include #include #include #include #include #include #include #include struct thread_info { int number; int socket; int epoll; }; void * thread(struct thread_info * arg) { struct epoll_event events[10]; int s; char buf[512]; sleep(5 * arg->number); printf("Thread %d start\n", arg->number); do { s = epoll_wait(arg->epoll, events, 10, -1); if (s number); exit(1); } if (recv(arg->socket, buf, 512, 0) number); } while (s == 1); printf("Thread %d end\n", arg->number); return 0; } int main() { pthread_attr_t attr; pthread_t threads[2]; struct thread_info thread_data[2]; int s; int listener, client, epollfd; struct sockaddr_in listen_address; struct sockaddr_storage client_address; socklen_t client_address_len; struct epoll_event ev; listener = socket(AF_INET, SOCK_STREAM, 0); if (listener When data arrives, and both threads are waiting on epoll_wait(), only one will return, but as subsequent data arrives, the thread that wakes up to handle the data is effectively random between the two threads. I wasn't able to to find a way to affect which thread was woken. It seems likely that a single thread calling epoll_wait makes most sense, with events passed to worker threads to pump the IO.
