[site]: stackoverflow
[post_id]: 5249530
[parent_id]: 
[tags]: 
Correct syntax for mutiple wildcard generic method?

I'm having trouble getting the syntax correct for a generic method with multiple wildcards First off I need two different wildcards because (while I've seen that '?' can be used to denote two different types) how will the compiler know when I use '?' ambiguously in the method. So below I have my very illegal version where I use '*' as the second wildcard (is there some other wildcard character I can use???) It may seem there is a programming error in the method but I can construct a type 'T' from a type '*' (I have constructors for that- basically taking a Google protocol buffer in and making a "full fledged object" out of it) private , * extends GeneratedMessage> T getItem(String key, ? db, Hashtable table, String message) throws GadsDataException { T returnValue = table.get(key); if (returnValue == null) { * temp = null; try { temp = db.get(key); } catch (InvalidProtocolBufferException e) { throw new GadsDataException( message + key + " and hit: ", e); } if (temp != null) { returnValue = new T(temp); table.put(key, returnValue); } } return returnValue; } In desperation I tried a version without any wildcards (I don't like it as it does not preserve the type relations as the first did). But the compiler isn't too keen about it either. I guess I should look at the "Transformer" thing another poster mentioned. private T getItem(String key, D db, Hashtable table, String message) throws GadsDataException { T returnValue = table.get(key); if (returnValue == null) { G temp = null; try { temp = db.get(key); } catch (InvalidProtocolBufferException e) { throw new GadsDataException( message + key + " and hit: ", e); } if (temp != null) { returnValue = new T(temp); table.put(key, returnValue); } } return returnValue; } So I'm still stuck on the constructor (as other posters have indicated I would be). I tried making the compiler happy by making an 'artifical' base class /** * This is created as a base class for all objects that can * construct themselves from a Google Protocol Buffer with one * parameter. * * This is just done for the sake of templatizing the methods * inside of the GadsLite API * */ public class ConstructorOneParameter { ConstructorOneParameter(GeneratedMessage G) { // don't actually do anything... the derived // class does all the work // We're doing this just to templatize the GadsLite methods } } Then what I did was use that to identify the type in the template method. Still the compiler wasn't happy. private , G extends GeneratedMessage> T getItem(String key, D db, Hashtable table, String message) throws GadsDataException { T returnValue = table.get(key); if (returnValue == null) { G temp = null; try { temp = db.get(key); } catch (InvalidProtocolBufferException e) { throw new GadsDataException( message + key + " and hit: ", e); } if (temp != null) { returnValue = new T(temp); table.put(key, returnValue); } } return returnValue; } Several people have suggested a factory so I changed the line "returnValue = new T(temp);" into "returnValue = MessageObjectFactory create(temp);" Then for the factory I have: public class MessageObjectFactory { public static R create(G message) { R returnValue = null; if (message instanceof ArtccData.Artcc) { returnValue = new Artcc((ArtccData.Artcc)message); } return returnValue; } } I'm just doing one type right now as a proof of concept. Unfortunately even though everything is a subclass of Object the compiler isn't happy with the "returnValue = new Artcc(..." line complaining "cannot convert from Artcc to R". Is there a specific example of a "Transformer Factory"?
