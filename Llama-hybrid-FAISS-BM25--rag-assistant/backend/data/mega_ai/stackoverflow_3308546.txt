[site]: stackoverflow
[post_id]: 3308546
[parent_id]: 3304226
[tags]: 
After searching high and low, I came to the conclusion that something must be missing from the core Three20 library. I did a little snooping around and found that the UISearchDisplayDelegate methods are in TTSearchDisplayController.m and unfortunately don't incorporate the scope when they hand things off to the datasource. Here are the modifications I made: /////////////////////////////////////////////////////////////////////////////////////////////////// - (void)searchAfterPause { _pauseTimer=nil; // HOWIE MOD if([self.searchBar.scopeButtonTitlescount]) { NSString*scope = [[self.searchBarscopeButtonTitles]objectAtIndex:[self.searchBarselectedScopeButtonIndex]]; //NSLog(@"sending text: %@ for scope: %@", self.searchBar.text, scope); [_searchResultsViewController.dataSource search:self.searchBar.textwithinScope:scope]; }else { [_searchResultsViewController.dataSource search:self.searchBar.text]; } /* // Original [_searchResultsViewController.dataSource search:self.searchBar.text]; */ // /HOWIE MOD } and /////////////////////////////////////////////////////////////////////////////////////////////////// - (BOOL)searchDisplayController:(UISearchDisplayController*)controller shouldReloadTableForSearchString:(NSString*)searchString { if(_pausesBeforeSearching) { [selfrestartPauseTimer]; } else{ // HOWIE MOD if([self.searchBar.scopeButtonTitlescount]) { NSString*scope = [[self.searchBarscopeButtonTitles]objectAtIndex:[self.searchBarselectedScopeButtonIndex]]; [_searchResultsViewController.dataSource search:searchString withinScope:scope]; returnYES; } else { [_searchResultsViewController.dataSource search:searchString]; } /* // Original [_searchResultsViewController.dataSource search:searchString]; */ // / HOWIE MOD } returnNO; } and /////////////////////////////////////////////////////////////////////////////////////////////////// - (BOOL)searchDisplayController:(UISearchDisplayController*)controller shouldReloadTableForSearchScope:(NSInteger)searchOption { // HOWIE MOD if([self.searchBar.scopeButtonTitlescount]) { NSString*scope = [[self.searchBarscopeButtonTitles] objectAtIndex:searchOption]; [_searchResultsViewController.dataSource search:self.searchBar.textwithinScope:scope]; returnYES; }else { [_searchResultsViewControllerinvalidateModel]; [_searchResultsViewController.dataSource search:self.searchBar.text]; } /* // Original [_searchResultsViewController invalidateModel]; [_searchResultsViewController.dataSource search:self.searchBar.text]; */ // / HOWIE MOD returnNO; } Then I added the following to TTTableViewDataSource.h // HOWIE MOD - (void)search:(NSString*)text withinScope:(NSString*)scope; // /HOWIE MOD And the following to TTTableViewDataSource.m // HOWIE MOD /////////////////////////////////////////////////////////////////////////////////////////////////// - (void)search:(NSString*)text withinScope:(NSString*)scope { } // /HOWIE MOD Now I can create the method - (void)search:(NSString*)text withinScope:(NSString*)scope in my datasource and it will respond accordingly as a search with scope is performed. I also enabled pausesBeforeSearching when I instantiate the search controller in my tableview controller so that it waits a couple of seconds before performing the search as a user types. This is helpful since my search is querying a server and rather than send each character as the user types, it makes more sense to let them type a few characters first. Hope this helps. Howie
