[site]: stackoverflow
[post_id]: 1334821
[parent_id]: 1334170
[tags]: 
There are several ways to solve this problem, but none are exceedingly elegant. A few options: Option 1: Use let to capture the subqueries and filter out the empty values: XElement xml = new XElement("States", from s in LinqUtils.GetTable () let counties = from cy in s.Counties let cities = from c in cy.Cities where c.Name.StartsWith("Y") orderby c.Name select new XElement("City", new XAttribute("Name", c.Name) ) where cities.Any() orderby cy.Name select new XElement("County", new XAttribute("Name", cy.Name), cities ) where counties.Any() orderby s.Code select new XElement("State", new XAttribute("Code", s.Code), new XAttribute("Name", s.Name), counties ) ); Option 2: Use your inner join approach with group by instead of distinct: XElement xml = new XElement("States", from s in LinqUtils.GetTable () from cy in s.Counties from c in cy.Cities where c.Name.StartsWith("Y") group new { cy, c } by s into gs let s = gs.Key orderby s.Code select new XElement("State", new XAttribute("Code", s.Code), new XAttribute("Name", s.Name), from g in gs group g.c by g.cy into gcy let cy = gcy.Key orderby cy.Name select new XElement("County", new XAttribute("Name", cy.Name), from c in gcy orderby c.Name select new XElement("City", new XAttribute("Name", c.Name) ) ) ) );
