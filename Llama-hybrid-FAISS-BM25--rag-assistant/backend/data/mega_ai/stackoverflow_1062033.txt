[site]: stackoverflow
[post_id]: 1062033
[parent_id]: 1061889
[tags]: 
Ok hopefully, I have the book, For others that may provides answers, the point is to implement this class : class AtomicReference { public: void set(T *ref, int stamp){ ... } T *get(int *stamp){ ... } private: T *_ref; int _stamp; }; in a lock-free way so that : set() updates the reference and the stamp, atomicly. get() returns the reference and set *stamp to the stamp corresponding to the reference. JDonner please, correct me if I am wrong. Now my answer : I don't think you can do it without a lock somewhere (a lock can be while(test_and_set() != ..)). Therefore there is no lockfree algorithm for this. This would mean that it is possible to build an N-bythe register a lock-free way for any N. If you look at the book pragma 9.8.1, The AtomicMarkableReference wich is the same with a single bit insteam of an integer stamp. The author suggest to "steal" a bit from a pointer to extract the mark and the pointer from a single word (alsmost quoted) This obviously mean that they want to use a single atomic register to do it. However, there may be a way to bluid a wait-free memory reclamation without it. I don't know.
