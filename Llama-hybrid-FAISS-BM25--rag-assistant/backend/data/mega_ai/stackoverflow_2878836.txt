[site]: stackoverflow
[post_id]: 2878836
[parent_id]: 2878717
[tags]: 
I typically find myself having multiple asserts in a method, but they're usually all related to the test at hand. I sometimes chuck in an assert to verify a precondition that I know will break the test because I don't want the test to succeed by accident. [Test] // NUnit style test. public void SearchTypeAndInventory() { var specification = new WidgetSearchSpecification { WidgetType = Widget.Screw, MinimumInventory = 10 }; var widgets = WidgetRepository.GetWidgets(specification); if( !widgets.Any() ) Assert.Inconclusive("No widgets were returned."); Assert.IsTrue( widgets.All( o => o.WidgetType == Widget.Screw), "Not all returned widgets had correct type"); Assert.IsTrue( widgets.All( o => o.InventoryCount >= 10), "Not all returned widgets had correct inventory count."); * While I could have combined the Asserts, I find it's more useful to separate what went wrong. I don't think sticking to a hard rule of 1-assert-per-test is very useful. What's more important is that a test is only testing 1 thing. I've seen many uber-tests that are one enormous method that tests everything about a class. These uber-tests are fragile and hard to maintain. You should think of your tests as being as important and well-written as the code they are testing. E.g. apply the same refactoring techniques to ensure that a test does one thing and does it well, and isn't a stovepipe that tests everything in sight.
