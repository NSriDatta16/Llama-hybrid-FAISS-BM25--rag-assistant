[site]: stackoverflow
[post_id]: 797452
[parent_id]: 730791
[tags]: 
I use the following ObjectPool ( the code is not mine I just added couple of methods ) ( if you do not use log4net replace logger.Info with Console.WriteLine ; ) using System; using System.Collections.Generic; using System.Text; using System.Collections.Specialized; using System.Reflection; using log4net; using log4net.Config; namespace DH { //DH - DataHolders /// /// This class models a storage structure for objects queriable by id /// public class ObjectPool { #region Props private int totalCount; public int TotalCount { get { return totalCount; } } public int ID { get; set; } #endregion Props public ObjectPool () { m_pool = new Dictionary > (); } private Dictionary > m_pool; public void AddItem ( Int32 pID, T value ) { Type myType = typeof ( T ); if (!m_pool.ContainsKey ( myType )) { m_pool.Add ( myType, new Dictionary () ); m_pool[myType].Add ( pID, value ); totalCount++; return; } if (!m_pool[myType].ContainsKey ( pID )) { m_pool[myType].Add ( pID, value ); totalCount++; return; } m_pool[myType][pID] = value; totalCount++; //Utils.Debugger.WriteIf("Adding 1 to pool count , pool count is " + this.totalCount); } public void AddItem ( T value ) { Int32 pID = totalCount ; Type myType = typeof ( T ); if (!m_pool.ContainsKey ( myType )) { m_pool.Add ( myType, new Dictionary () ); m_pool[myType].Add ( pID, value ); totalCount++; return; } if (!m_pool[myType].ContainsKey ( pID )) { m_pool[myType].Add ( pID, value ); totalCount++; return; } m_pool[myType][pID] = value; totalCount++; //Utils.Debugger.WriteIf("Adding 1 to pool count , pool count is " + this.totalCount); } public bool RemoveItem ( Int32 pID ) { Type myType = typeof ( T ); if (!m_pool.ContainsKey ( myType )) return false; if (!m_pool[myType].ContainsKey ( pID )) return false; totalCount--; return m_pool[myType].Remove ( pID ); } public bool ContainsKey ( Int32 pID ) { Type myType = typeof ( T ); if (!m_pool.ContainsKey ( myType )) return false; if (!m_pool[myType].ContainsKey ( pID )) return false; return m_pool[myType].ContainsKey ( pID ); } public IEnumerable GetItems () { Type myType = typeof ( T ); if (!m_pool.ContainsKey ( myType )) return new T[0]; return m_pool[myType].Values as IEnumerable ; } /// /// Gets the item. /// /// /// The p ID. /// /// public T GetItem ( Int32 pID ) { // will throw KeyNotFoundException if either of the dictionaries // does not hold the required key return (T)m_pool[typeof ( T )][pID]; } /// /// /// /// /// the string representation of the /// /// public T GetItemByPropertyValue ( String strPropMetaName , String strPropValue) { Type myType = typeof ( T ); for (int i = 0; i ( i )) { //get an item object having the same type T item = this.GetItem ( i ); //if the object has the same property -- check its value MemberInfo[] members = myType.GetMembers (); for (int j = 0; j (dog.ID, dog); //pool.AddItem (carrot.Identifier, carrot); //pool.AddItem ( carbon ); //pool.AddItem ( 1, hfs ); //logger.Info("Dog is in the pool -- this statement is " + pool.ContainsKey (dog.ID)); //logger.Info("hfs is in the pool -- this statement is " + pool.ContainsKey (hfs.ID)); //logger.Info("The hfs value is from the poos is " + pool.GetItem (4).Value); //logger.Info("poo.GetItems is " + pool.GetItems ()); #region while //for (int i = 0; i ( i )) { logger.Info ( " I see animal which is " + pool.GetItem ( i ).Name ); } if (pool.ContainsKey ( i )) { logger.Info ( " I see Vegetable which is " + pool.GetItem ( i ).Color ); } if (pool.ContainsKey ( i )) { logger.Info ( " I see Mineral which is " + pool.GetItem ( i ).IsPoisonousToAnimal ); } if (pool.ContainsKey ( i )) { logger.Info ( " I see string which is " + pool.GetItem ( i ).Value ); } //logger.Info("pool.GetItem (4).Value); is " + pool.GetItem (i).ToString()); i = i + 1; } catch (KeyNotFoundException e) { continue; } } //eof for while (i (holdVerifier.ID, holdVerifier); //ListDictionary lidMetaName = pool.LidMetaName; ////this is the message //HoldString holdMsg = new HoldString( ref lidMetaName) //{ // ID=1, // MetaName = "msg", // Value = msg, // Title = "title" //}; //pool.AddItem (holdMsg.ID, holdMsg); //HoldString holdmmsg = new HoldString(ref lidMetaName) //{ // ID=2, // MetaName = "mmsg", // Value = "mmsg" , // Title = "title" //}; #endregion AddHolders //Utils.Debugger.DebugListDictionary(ref msg, "domainName", ref lidMetaName); //get the value be metaName logger.Info ( "I queried the pool by property with meta Value and value user_name " ); HolderForStrings HolderForStrings = pool.GetItemByPropertyValue ( "MetaName", "hfs1" ); //logger.Info ( "object dump" + Utils.Log.ObjDumper.DumpObject ( HolderForStrings ) ); logger.Info ( "I found the following value for property with the name \"Name\" " ); logger.Info ( HolderForStrings.MetaName); Console.ReadLine (); } //eof Main } //eof class public class Animal { public Int32 ID { get; set; } public String Name { get; set; } } public class HolderForStrings { public Int32 ID { get; set; } public String Value { get; set; } public String MetaName { get; set; } Type ObjType = typeof ( string ); public Int32 Size { get; set; } public bool IsOptional { get; set; } public bool IsPrimaryKey { get; set; } } //eof class public class Vegetable { public Int32 Identifier { get; set; } public String Color { get; set; } public Boolean IsTasty { get; set; } } public class Mineral { public Int32 UniqueID { get; set; } public Boolean IsPoisonousToAnimal { get; set; } public String Name { get; set; } } #region classObjectPool //public class ObjectPool //{ // public int Count // { // get { return m_pool.Count; } // } // public ObjectPool () // { // m_pool = new Dictionary > (); // } // private Dictionary > m_pool; // public void AddItem ( Int32 pID, T value ) // { // Type myType = typeof ( T ); // if (!m_pool.ContainsKey ( myType )) // { // m_pool.Add ( myType, new Dictionary () ); // m_pool[myType].Add ( pID, value ); // return; // } // if (!m_pool[myType].ContainsKey ( pID )) // { // m_pool[myType].Add ( pID, value ); // return; // } // m_pool[myType][pID] = value; // } // public bool RemoveItem ( Int32 pID ) // { // Type myType = typeof ( T ); // if (!m_pool.ContainsKey ( myType )) // return false; // if (!m_pool[myType].ContainsKey ( pID )) // return false; // return m_pool[myType].Remove ( pID ); // } // public bool ContainsKey ( Int32 pID ) // { // Type myType = typeof ( T ); // if (!m_pool.ContainsKey ( myType )) // return false; // if (!m_pool[myType].ContainsKey ( pID )) // return false; // return m_pool[myType].ContainsKey ( pID ); // } // public IEnumerable GetItems () // { // Type myType = typeof ( T ); // if (!m_pool.ContainsKey ( myType )) // return new T[0]; // return m_pool[myType].Values as IEnumerable ; // } // /// // /// Gets the item. // /// // /// // /// The p ID. // /// // /// // public T GetItem ( Int32 pID ) // { // // will throw KeyNotFoundException if either of the dictionaries // // does not hold the required key // return (T)m_pool[typeof ( T )][pID]; // } //} //eof pool #endregion public enum EnumType : byte { String, Int32, Boolean } } //eof program
