[site]: stackoverflow
[post_id]: 2688085
[parent_id]: 2688054
[tags]: 
I see at least four potential refcount leaks in your code: OLE32.IStorage storage; // ref counted from OLE32.StgCreateStorageEx( IntPtr unknownFromOle = Marshal.GetIUnknownForObject(pOle); // ref counted IntPtr unknownForDataObj; // re counted from Marshal.QueryInterface(unknownFromOle var pdo = Marshal.GetObjectForIUnknown(unknownForDataObj) as IDataObject; // ref counted Note that all these are pointers to COM objects. COM objects are not collected by GC unless the .Net type that holds the reference points to an RCW wrapper and will properly release its reference count in its finalizer. IntPtr is not such type and your var also is IntPtr (from the return type of the Marshal.GetObjectForIUnknown call), so that makes three. You should call Marshal.Release on all your IntPtr variables. I am not sure about OLE32.IStorage . This one might need either Marshal.Release or Marshal.ReleaseComPointer . Update: I just noticed that I missed at least one ref count. The var is not an IntPtr , it's an IDataObject . The as cast will do an implicit QueryInterface and add another ref count. Although GetObjectForIUnknown returns an RCW, this one is delayed until the GC kicks in. You might want to do this in using block to activate the IDisposable on it. Meanwhile, the STGMEDIUM struct also has one IUnknown pointer you are not releasing. You should call ReleaseStgMedium to properly dispose of the whole struct, including that pointer. I am too tired to continue looking through the code right now. I'll come back tomorrow and try to find other possible ref count leaks. Meanwhile, you check the MSDN docs for all interfaces, structs and APIs you are calling and try to figure out any other ref counts you might have missed.
