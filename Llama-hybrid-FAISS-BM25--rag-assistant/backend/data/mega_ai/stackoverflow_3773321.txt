[site]: stackoverflow
[post_id]: 3773321
[parent_id]: 3773064
[tags]: 
There are any number of reasons a particular code generator may emit the instruction sequence you list. The most likely is that the code generator you're using just isn't trying very hard to emit optimum code. This pattern of emitted code suggests to me that your code generator doesn't know that the x86 has "mov immediate" instructions that embed the constant value into the instruction stream directly. The x86 encoding for opcodes with immediate values can get a little complicated (variable length R/M bytes) but this is already required if you want to use many of the x86 instructions. This emitted code also suggests that the code generator doesn't know that EAX is not modified by the EBX instructions. This feels like the codegen is template driven rather than discrete logic. This kind of codegen happens when the compiler's internal intermediate representation of operations is not detailed enough to represent all the facets of the target architecture. This is particularly true if the code generator architecture was originally designed for a RISC instruction set but has been repurposed to emit x86 instructions. RISC architecture tend to have very few and very simple load, store, and operate reg/reg instructions, whereas the x86 instruction set has evolved organically over decades to include a wide variety of opcodes that operate directly on memory, inline constants into the instructions, and a whole mess of other stuff. If the compiler's intermediate representation (expression graph) is wired for RISC, it will be difficult to make it grok the wide variety and subtleties of x86.
