[site]: stackoverflow
[post_id]: 3824771
[parent_id]: 3824200
[tags]: 
I'm not 100% sure I understand what your code is doing (I don't know Matlab) but this might be one approach for building a multi-dimensional vector: (defn conj-in "Based on clojure.core/assoc-in, but with vectors instead of maps." [coll [k & ks] v] (if ks (assoc coll k (conj-in (get coll k []) ks v)) (assoc coll k v))) (defn foo [] (let [w 5, h 4, d 3 indices (for [i (range w) j (range h) k (range d)] [i j k])] (reduce (fn [acc [i j k :as index]] (conj-in acc index ;; do real work here (str i j k))) [] indices))) user> (pprint (foo)) [[["000" "001" "002"] ["010" "011" "012"] ["020" "021" "022"] ["030" "031" "032"]] [["100" "101" "102"] ["110" "111" "112"] ["120" "121" "122"] ["130" "131" "132"]] [["200" "201" "202"] ["210" "211" "212"] ["220" "221" "222"] ["230" "231" "232"]] [["300" "301" "302"] ["310" "311" "312"] ["320" "321" "322"] ["330" "331" "332"]] [["400" "401" "402"] ["410" "411" "412"] ["420" "421" "422"] ["430" "431" "432"]]] This only works if indices go in the proper order (increasing), because you can't conj or assoc onto a vector anywhere other than one-past-the-end. I also think it would be acceptable to use make-array and build your array via aset . This is why Clojure offers access to Java mutable arrays; some algorithms are much more elegant that way, and sometimes you need them for performance. You can always dump the data into Clojure vectors after you're done if you want to avoid leaking side-effects. (I don't know which of this or the other version performs better.) (defn bar [] (let [w 5, h 4, d 3 arr (make-array String w h d)] (doseq [i (range w) j (range h) k (range d)] (aset arr i j k (str i j k))) (vec (map #(vec (map vec %)) arr)))) ;yikes?
