[site]: stackoverflow
[post_id]: 2478364
[parent_id]: 2478143
[tags]: 
I have never used adjacency_list so this is just an idea which although works with STL containers. So using adjacency_list says BGL uses containers from the STL such as std::vector, std::list, and std::set to represent the set of vertices and the adjacency structure . OK, then you just have to give your adjacent list std::vector, std::list, and std::set which have their own allocator type. Adding your own allocator to STL containers is an easy task . Having done all this you just have to get from your allocators the size of memory that has been allocated while filling the adjacency_list. So the idea is to build the adjacent list out of STL containers (which seems possible after a quick look at the BGL documentaiton) which have own allocator types. Update 1 Actually you haven't told why you need to know how much bytes your graph consumes. If you just need to get this number only once you probably have to write you program with and without filling the graph. Then run for example UNIX95= ps -u $USER -o vsz,args and find out the difference. Roughly you will get the size of you graph. If you need to get this values regularly in your application and if you are not able to implement the whole solution using allocators you need to start with a few small steps. Read about allocators: C++ Standard Allocator, An Introduction and Implementation Allocators(STL) Try to implement std::vector with your own allocator as an exercise Try to add counting bytes to your allocator Try to build the Boost graph with allocator Customizing the Adjacency List Storage Do something to count bytes in std::string members of your containers. By default they will not use the allocator of their container. So either instead use fixed-size strings or manage somehow insert a container's allocator in this string members. Again, take a look at Adding your own allocator to STL containers By the way if you don't want to reinvent the C++ allocator you can just use something like that: template class your_allocator { public: // here you need to put everything that is required by C++ standard // and calls finally send to std_allocator_ private: std::allocator std_allocator_; };
