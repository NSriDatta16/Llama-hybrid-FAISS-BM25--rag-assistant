[site]: stackoverflow
[post_id]: 5584150
[parent_id]: 4301405
[tags]: 
I ran into this problem myself with an ASP.NET web forms site that uses Response.Redirect(url, false) following a post on many of its pages. From reading the HTTP/1.1 specification it sounds like a 303 response code would be correct for implementing the Request: POST, Response: Redirect behavior. Unfortunately changing the status code does not make browser caching work in Chrome. I implemented the workaround described in the post above by creating a custom module for non-static content. I'm also deleting the response content from 302's to avoid the appearance of a blink of "object moved to here". This is probably only relevant for the refresh headers. Comments are welcome! public class WebKitHTTPHeaderFixModule : IHttpModule { public void Init(HttpApplication httpApp) { // Attach application event handlers. httpApp.PreSendRequestHeaders += new EventHandler(httpApp_PreSendRequestHeaders); } void httpApp_PreSendRequestHeaders(object sender, EventArgs e) { HttpContext context = HttpContext.Current; if (context.Response.StatusCode == 302) { context.Response.ClearContent(); // If Request is POST and Response is 302 and browser is Webkit use a refresh header if (context.Request.HttpMethod.Equals("POST", StringComparison.OrdinalIgnoreCase) && context.Request.Headers["User-Agent"].ToLower().Contains("webkit")) { string location = context.Response.Headers["Location"]; context.Response.StatusCode = 200; context.Response.AppendHeader("Refresh", "0; url=" + location); } } } public void Dispose() {} } Note: I don't think this will work with the non-overloaded version of Response.Redirect since it calls Response.End().
