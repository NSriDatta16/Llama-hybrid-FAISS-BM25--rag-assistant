[site]: stackoverflow
[post_id]: 2119727
[parent_id]: 2117160
[tags]: 
Your second monkeypatch works since you are re-opening the Symbol class. The first one doesn't because all the include does is add the module in the list of included modules. These get called only if the class itself doesn't define a specific method, or if that method calls super. So your code never gets called. If you want to use a module, you must use the included callback: module CamelcasedJsonSymbol def self.included(base) base.class_eval do alias_method_chain :to_s, :camelcase_json end end def to_s_with_camelcase_json(*args) to_s_without_camelcase_json(*args).extend(CamelcasedJsonString) end end I've used active_record alias_method_chain , which you should always do when monkey patching. It encourages you to use the right names and thus avoid collisions, among other things. That was the technical answer. On a more pragmatic approach, you should rethink this. Repeatedly extending strings like this is not nice, will be a huge performance drain on most implementations (it clears the whole method cache on MRI, for instance) and is a big code smell. I don't know enough about the problem to be sure, or suggest other solutions (maybe a Delegate class could be the right thing to return?) but I have a feeling this is not the right way to arrive to your goals. Since you want to convert the keys of a hash, you could pass an option to #to_json and monkeypatch that instead of #to_s , like: { :chunky_bacon => "good" }.to_json(:camelize => true) My first idea was to monkeypatch Symbol#to_json but that won't work as you point out because Hash will force the keys to strings before calling to_json, because javascript keys must be strings. So you can monkeypatch Hash instead: module CamelizeKeys def self.included(base) base.class_eval do alias_method_chain :to_json, :camelize_option end end def to_json_with_camelize_option(*args) if args.empty? || !args.first[:camelize] to_json_without_camelize_option(*args) else pairs = map do |key, value| "#{key.to_s.camelize.to_json(*args)}: #{value.to_json(*args)}" end "{"
