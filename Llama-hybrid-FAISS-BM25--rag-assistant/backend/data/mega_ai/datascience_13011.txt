[site]: datascience
[post_id]: 13011
[parent_id]: 
[tags]: 
Non-brute force approach to finding permissible English word anagrams

I am interested in proposed base R/Python solutions (i.e. without relying on external packages/libraries) to the following problem: You have a large dictionary containing millions of valid English words. You are given an input “word”, which may or may not be an anagram of one or more words in the dictionary. Find all possible valid words in the dictionary of which the input may be an anagram. Note, the input “word” may be meaningless. For example, input: lloeh output: hello input: cksli output: slick, licks Rather than use a brute force technique that computes all possible character combinations for each input target and compares them to a dictionary, you want to use a more efficient technique. The approach I was considering was to pre-compute impossible string onsets in the target language. For example, in English, the onset sequences ^ck and ^ng are not permissable because they violate the orthographic and phonotactic constraints of the language. Given an off-line list of impossible_sequences at run time you would incrementally build possible "words" from the target. During each iteration the possible word is checked against the impossible_sequences list and if it matches the search down that search branch is terminated. The following pseudo-code in R uses for loops to illustrate my idea. target (1) Are there any issues with the underlying logic of my proposal? (2) Obviously nested for loops are inelegant - Could one do this recursively and if so, how? (3) What other approaches should be considered?
