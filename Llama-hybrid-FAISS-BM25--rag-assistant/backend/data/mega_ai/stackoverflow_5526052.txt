[site]: stackoverflow
[post_id]: 5526052
[parent_id]: 5526019
[tags]: 
but that mean I won't be able to enforce const-correctness in my code I think you may be wrong there. As long it is a smart pointer to a const object, you may only manipulate the pointers in the set, not the objects referred to. This is kind of the whole point, because a set cannot organize itself if it cannot touch the values. It's the classical difference between const char* x; // pointer to const char const char* const x; // constant pointer to const char char* const x; // constant pointer, to non-const char Only this time with smartpointers. You can also verify for yourself that this simple test will fail for const items: #include int main() { std::set a; a.insert(1); return 1; } Once you remove 'const' it will work. OT: If you want some container that has some kind of 'key' protection, you should perhaps look at map since in the value_type (std::pair) the key (.first) is always const - IIRC. I still think the point is moot with regard to const correctness of the container's elements.
