[site]: stackoverflow
[post_id]: 4715888
[parent_id]: 4715740
[tags]: 
It's considered safer because a lot of people have "heard" that it's safer and then told others, who now have also "heard" that it's safer. Not a single person who understands references will tell you that they're any safer than pointers, they have the same flaws and potential to become invalid. e.g. #include int main(void) { std::vector v; v.resize(1); int& r = v[0]; r = 5; // ok, reference is valid v.resize(1000); r = 6; // BOOM!; return 0; } EDIT: Since there seems to be some confusion about whether a reference is an alias for an object or bound to a memory location, here's the paragraph from the standard (draft 3225, section [basic.life] ) which clearly states that a reference binds to storage and can outlive the object which existed when the reference was created: If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if: the storage for the new object exactly overlays the storage location which the original object occupied, and the new object is of the same type as the original object (ignoring the top-level cv-qualiﬁers), and the type of the original object is not const-qualiﬁed, and, if a class type, does not contain any non-static data member whose type is const-qualiﬁed or a reference type, and the original object was a most derived object of type T and the new object is a most derived object of type T (that is, they are not base class subobjects).
