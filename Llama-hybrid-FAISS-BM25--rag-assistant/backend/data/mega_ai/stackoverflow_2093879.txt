[site]: stackoverflow
[post_id]: 2093879
[parent_id]: 2091788
[tags]: 
Instead of using P/Invoke, if you are controlling the native library yourself, you can write a set of C++/CLI classes that wrap the native calls. In many cases, this will perform better than using platform invoke, and you get the added benefit of type correctness. For example, if you have some sort of C API like the following (it doesn't do anything useful, I just added pointers and structs to reinforce the fact that it is native code): struct SomeStruct { int a, b; int* somePtr; }; int foo(struct SomeStruct* a, int b) { *a->somePtr = a->a + a->b; return a->b * *a->somePtr + b; } You can create a C++/CLI class to wrap it: public ref class MyNativeAPI { private: SomeStruct* x; public: MyNativeAPI() { x = new SomeStruct; } ~MyNativeAPI() { delete x; } int Foo(int a) { pin_ptr ptr = this->x; return foo(ptr, a); } } Then, you can call this in C#: MyNativeAPI a = new MyNativeAPI(); if(a.Foo(5) > 5) { ... }; You'll have to read more on C++/CLI to understand the new controls you have over both the managed heap and the native heap, and the caveats to mixing the two (like the pin_ptr I used above), but overall it's a much more elegant solution to accomplishing native interop in .NET.
