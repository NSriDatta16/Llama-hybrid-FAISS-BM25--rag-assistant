[site]: stackoverflow
[post_id]: 1577500
[parent_id]: 1574776
[tags]: 
Here's a script comparing two ways of doing it: Your original compare() and a new_compare(). The new_compare uses more of the built in Enumerable methods. Since they are implemented in C, they'll be faster. I created a constant called Test::SIZE to try out the benchmarks with different hash sizes. Results at the bottom. The difference is huge. require 'benchmark' class Test SIZE = 20000 attr_accessor :storage def initialize file1 = [] SIZE.times { |x| file1 x, :foo => x } } @storage = file1 @opts = {} @opts[:field] = :field end def compare(x) x.each do |row| @storage.each_index do |y| if row[@opts[:field]] == @storage[y][@opts[:field]] @storage.delete_at(y) end end end end def new_compare(other) other_keys = other.map { |x| x[@opts[:field]] } @storage.reject! { |s| other_keys.include? s[@opts[:field]] } end end storage2 = [] # We'll make 10 of them match 10.times { |x| storage2 x, :foo => x } } # And the rest wont (Test::SIZE-10).times { |x| storage2 x+100000000, :foo => x} } Benchmark.bm do |b| b.report("original compare") do t1 = Test.new t1.compare(storage2) end end Benchmark.bm do |b| b.report("new compare") do t1 = Test.new t1.new_compare(storage2) end end Results: Test::SIZE = 500 user system total real original compare 0.280000 0.000000 0.280000 ( 0.285366) user system total real new compare 0.020000 0.000000 0.020000 ( 0.020458) Test::SIZE = 1000 user system total real original compare 28.140000 0.110000 28.250000 ( 28.618907) user system total real new compare 1.930000 0.010000 1.940000 ( 1.956868) Test::SIZE = 5000 ruby test.rb user system total real original compare113.100000 0.440000 113.540000 (115.041267) user system total real new compare 7.680000 0.020000 7.700000 ( 7.739120) Test::SIZE = 10000 user system total real original compare453.320000 1.760000 455.080000 (460.549246) user system total real new compare 30.840000 0.110000 30.950000 ( 31.226218)
