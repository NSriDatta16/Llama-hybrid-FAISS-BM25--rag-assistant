[site]: stackoverflow
[post_id]: 286820
[parent_id]: 286402
[tags]: 
Indeed, like many answered, there is a need to separate the parsing problem from the object construction problem. The Factory pattern is suited well for that. The Boost.Spirit library also solves the parse->function problem in a very elegant way (uses EBNF notation). I always like to separate the 'business logic' from the framework code. You can achieve this by start writing "what you want to do" in a very convenient way and work to "how do you do it" from there. const CMemberSetter * setters[] = #define SETTER( tag, type, member ) new TSetter ( #tag, &predict_cache_key::##member ) { SETTER( "av", int, av_id ) , SETTER( "sz", int, sz_id ) , SETTER( "cr", int, cr_id ) , SETTER( "cp", int, cp_id ) , SETTER( "cv", int, cv_id ) , SETTER( "ct", int, ct_id ) , SETTER( "fc", int, fc ) , SETTER( "gnd", char, gnd ) , SETTER( "ag", int, ag ) , SETTER( "pc", int, pc ) , SETTER( "prl", long, prl_id ) }; PCKFactory factory ( setters ); predict_cache_key a = factory.factor( a_strs ); predict_cache_key b = factory.factor( b_strs ); And the framework to achieve this: // conversion from key=value pair to "set the value of a member" // this class merely recognises a key and extracts the value part of the key=value string // template struct CMemberSetter { const std::string key; CMemberSetter( const string& aKey ): key( aKey ){} bool try_set_value( BaseClass& p, const string& key_value ) const { if( key_value.find( key ) == 0 ) { size_t value_pos = key_value.find( "=" ) + 1; action( p, key_value.substr( value_pos ) ); return true; } else return false; } virtual void action( BaseClass& p, const string& value ) const = 0; }; // implementation of the action method // template struct TSetter : public CMemberSetter { typedef T BaseClass::*TMember; TMember member; TSetter( const string& aKey, const TMember t ): CMemberSetter( aKey ), member(t){} virtual void action( BaseClass& p, const std::string& valuestring ) const { // get value T value (); stringstream ( valuestring ) >> value; (p.*member) = value; } }; template struct PCKFactory { std::vector *> aSetters; template PCKFactory( const CMemberSetter * (&setters)[N] ) : aSetters( setters, setters+N ) {} template BaseClass factor( const string (&key_value_pairs) [N] ) const { BaseClass pck; // process each key=value pair for( const string* pair = key_value_pairs; pair != key_value_pairs + _countof( key_value_pairs); ++pair ) { std::vector *>::const_iterator itSetter = aSetters.begin(); while( itSetter != aSetters.end() ) { // optimalization possible if( (*itSetter)->try_set_value( pck, *pair ) ) break; ++itSetter; } } return pck; } };
