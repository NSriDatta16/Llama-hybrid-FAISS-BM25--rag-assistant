[site]: stackoverflow
[post_id]: 5178593
[parent_id]: 5178339
[tags]: 
The simplest option is something like this: @Override public int getColumnCount() { return 5; } ... @Override public Object getValueAt(int rowIndex, int columnIndex) { Game game = games.get(rowIndex); switch (columnIndex) { case 0: return game.getId(); case 1: return game.getTitle(); case 2: return game.getPublisher(); case 3: return game.getGenre(); case 4: return game.getReleaseDate(); } return null; } That can be prone to maintenance problems due to all the magic numbers - a solution would be to use an enumeration for the columns: enum GameTableColumn { ID, TITLE, PUBLISHER, GENRE, RELEASE_DATE; } And then get the enumeration instance for a column using GameTableColumn.values()[columnIndex]. A few style notes - tblGamesModel is a non-standard name for a Java class, class names always start with an upper case letter. A more Java name would be GamesTableModel. Hungarian notation prefixes (such as "tbl") are generally discouraged. Also having a database fetch in a constructor is generally a bad idea. In a Swing application you want all fetches to be explicit so you can ensure they do not block the UI. Rather than getGames() I would suggest retrieveGames(). It may be best to construct the GamesRepository outside the table model and pass it in to the constructor. You could then perform the JPA query first in a different thread. This would prevent the UI thread from freezing while the database access is in progress.
