[site]: stackoverflow
[post_id]: 4359698
[parent_id]: 4355570
[tags]: 
This computation is trivially parallelizable; just add #pragma omp parallel_for reduction(+:size,+:sum) schedule(static) immediately above the loop if you have OpenMP support (-fopenmp in GCC.) However, I would not expect much speedup on a typical multicore desktop machine; you're doing so little computation per item fetched that you're almost certainly going to be constrained by memory bandwidth. If you need to perform the summation several times for a given id mapping (i.e. the value[] array changes more often than id[]), you can halve your memory bandwidth requirements by pre-sorting the value[] elements into id order and eliminating the per-element fetch from id[]: for (i = 0, j = 0, k = 0; j for (k += size[j], tmp = 0; i tmp += value[i];
