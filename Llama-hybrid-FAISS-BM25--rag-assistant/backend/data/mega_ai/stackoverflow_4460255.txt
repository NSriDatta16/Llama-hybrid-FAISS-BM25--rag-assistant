[site]: stackoverflow
[post_id]: 4460255
[parent_id]: 4459998
[tags]: 
pls consider this suggestion: Used LinqToSQL to map a table 'dbo.Groups', generating following class Group [Table(Name = "dbo.Groups")] public partial class Group { [Column(Storage = "_Id", AutoSync = AutoSync.OnInsert, DbType = "Int NOT NULL IDENTITY", IsPrimaryKey = true, IsDbGenerated = true)] public int Id { get { return this._Id; } set { this._Id = value; } } [Column(Storage = "_ParentId", DbType = "Int")] public System.Nullable ParentId { get { return this._ParentId; } set { this._ParentId = value; } } [Association(Name = "Group_Group", Storage = "_Children", ThisKey = "Id", OtherKey = "ParentId")] public EntitySet Children { get { return this._Children; } set { this._Children.Assign(value); } } } Then added following LinqExtension (courtesy of how-to-get-a-tree-structured-table-data-by-linq ) public static class LinqExtensions { static public IEnumerable Descendants (this IEnumerable source, Func > DescendBy) { foreach (T value in source) { yield return value; foreach (T child in DescendBy(value).Descendants (DescendBy)) { yield return child; } } } } at last, added following methods to my Group Class: public partial class Group { public IEnumerable Descendants() { return LinqExtensions.Descendants(Children, c => c.Children); } public IEnumerable Genealogy() { Group[] ancestor = new Group[] { this }; return ancestor.Concat(LinqExtensions.Descendants(Children, c => c.Children)); } } If I understood your question, the Genealogy method may help you.
