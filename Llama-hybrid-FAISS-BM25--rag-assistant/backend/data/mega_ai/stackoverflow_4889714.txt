[site]: stackoverflow
[post_id]: 4889714
[parent_id]: 
[tags]: 
XP0006 error in XQuery transformation

I am getting an XP0006 error when trying to run an XQuery transformation (OSB's XQuery implementation if that makes any difference) and I am having a hard time resolving it. The error given is Error occurred while executing XQuery: {err}XP0006: "element {http://www.websitename.com/claims/client/UpdateClient.xsd}updateClient { {http://www.w3.org/2004/07/xpath-datatypes}untypedAny }": bad value for type element {http://www.websitename.com/claims/client/UpdateClient}updateClient { {http://www.w3.org/2001/XMLSchema}anyType } As far as I can tell the source of this error is the fact that my source XML files contain multiple namespaces. A separate transformation that is running on XML files with only one namespace is running fine. Here is the transformation that is giving me trouble: (:: pragma bea:global-element-parameter parameter="$updateClient1" element="ns0:updateClient" location="../xsd/claims/client/UpdateClient.xsd" ::) (:: pragma bea:global-element-return element="ns3:TemplateUpdateClient-WrkFrm" location="../xsd/claims/templates/wc/UpdateClient.xsd" ::) declare namespace ns2 = "http://www.websitename.com/common/customDataTypes"; declare namespace ns1 = "http://www.websitename.com/document/production/common/customDataTypes"; declare namespace ns3 = "http://www.websitename.com/document/production/template/templateupdateclient"; declare namespace ns0 = "http://www.websitename.com/claims/client/UpdateClient"; declare namespace xf = "http://tempuri.org/DocumentSubmissionConversionOSB/XQuery/WCtest/"; (:~ : This function converts a set of strings describing : an address into the new address format : : @param $recipient the addressee : @param $line1 address Line#1 : @param $line2 address Line#2 : @param $lnie3 address Line#3 : @param $city the city : @param $provinceOrState the province (if CA) or state (if US) : @param $country the country (CA, US, or something else) : @param $postalOrZIP the postal code (if CA or other) or zip code (if US) : @return either a , a , or an depending on the country :) declare function local:to-address( $recipient as xs:string, $line1 as xs:string, $line2 as xs:string, $line3 as xs:string, $city as xs:string, $provinceOrState as xs:string, $country as xs:string, $postalOrZIP as xs:string ) as element() { if (fn:upper-case($country) = 'CA') then { $city } { $country } { $postalOrZIP } { $provinceOrState } { $recipient } { $line1 } { $line2 } { $line3 } else if (fn:upper-case($country) = 'US') then { $city } { $country } { $postalOrZIP } { $provinceOrState } { $recipient } { $line1 } { $line2 } { $line3 } else { $city } { $country } { $postalOrZIP } { $recipient } { $line1 } { $line2 } { $line3 } (:endif:) (:endif:) }; declare function xf:WCtest($updateClient1 as element(ns0:updateClient)) as element(ns3:TemplateUpdateClient-WrkFrm) { { let $Client := $updateClient1/ns0:Client return { data($Client/ns0:claimNumber) } { data($Client/ns0:gender) } { data($Client/ns0:maritalStatus)} { let $fullName := $Client/ns0:fullName return { data($fullName/ns0:firstName) } { data($fullName/ns0:lastName) } { data($fullName/ns0:middleName) } } { data($Client/ns0:SIN) } { let $currentAddress := $Client/ns0:currentAddress return { local:to-address( data($currentAddress/ns2:line1), data($currentAddress/ns2:line2), data($currentAddress/ns2:line3), data($currentAddress/ns2:city), data($currentAddress/ns2:provinceOrState), data($currentAddress/ns2:country), data($currentAddress/ns2:postalOrZipCode) ) } } } }; declare variable $updateClient1 as element(ns0:updateClient) external; xf:WCtest($updateClient1) Here is a sample of the data I am trying to run through it: 00000 000000000 First Middle Last male married line1 city province H0H 0H0 CA Here is a transformation that is working: (:: pragma bea:global-element-parameter parameter="$workerAppeal1" element="ns0:workerAppeal" location="../../xsd/claims/worker/appeal/WorkerAppeal.xsd" ::) (:: pragma bea:global-element-return element="ns2:TemplateWorkerAppeal-WrkFrm" location="../../xsd/claims/templates/ais/WorkerAppeal.xsd" ::) declare namespace ns2 = "http://www.website.com/document/production/template/templateworkerappeal"; declare namespace ns1 = "http://www.website.com/document/production/common/customDataTypes"; declare namespace ns3 = "http://www.website.com/document/production/templatebase"; declare namespace ns0 = "http://www.website.com/claims/worker/appeal/WorkerAppeal.xsd"; declare namespace xf = "http://tempuri.org/DocumentSubmissionConversionOSB/XQuery/AIS/AIStest/"; (:~ : This function converts a set of strings describing : an address into the new address format : : @param $recipient the addressee : @param $line1 address Line#1 : @param $line2 address Line#2 : @param $lnie3 address Line#3 : @param $city the city : @param $provinceOrState the province (if CA) or state (if US) : @param $country the country (CA, US, or something else) : @param $postalOrZIP the postal code (if CA or other) or zip code (if US) : @return either a , a , or an depending on the country :) declare function local:to-address( $recipient as xs:string, $line1 as xs:string, $line2 as xs:string, $line3 as xs:string, $city as xs:string, $provinceOrState as xs:string, $country as xs:string, $postalOrZIP as xs:string ) as element() { if (fn:upper-case($country) = 'CA') then { $city } { $country } { $postalOrZIP } { $provinceOrState } { $recipient } { $line1 } { $line2 } { $line3 } else if (fn:upper-case($country) = 'US') then { $city } { $country } { $postalOrZIP } { $provinceOrState } { $recipient } { $line1 } { $line2 } { $line3 } else { $city } { $country } { $postalOrZIP } { $recipient } { $line1 } { $line2 } { $line3 } (:endif:) (:endif:) }; declare function xf:AIStest($workerAppeal1 as element(ns0:workerAppeal)) as element(ns2:TemplateWorkerAppeal-WrkFrm) { { data($workerAppeal1/ns0:appealDate) } { data($workerAppeal1/ns0:decisionAppealled) } { data($workerAppeal1/ns0:decisionWrong) } { data($workerAppeal1/ns0:expectations) } { let $Appellant := $workerAppeal1/ns0:Appellant return { let $claimantName := $Appellant/ns0:claimantName return { data($claimantName/ns0:firstName) } { data($claimantName/ns0:lastName) } } { data($Appellant/ns0:claimNumber) } { data($Appellant/ns0:areYouTheClaimant) } } { let $Representative := $workerAppeal1/ns0:Representative return { let $phoneNumber := $Representative/ns0:phoneNumber return { data($phoneNumber/ns0:areaCode) } { data($phoneNumber/ns0:numeric) } } { data($Representative/ns0:relationshiptoAppellant) } { let $representativeAddress := $Representative/ns0:representativeAddress return { local:to-address( concat( data($Representative/ns0:representativeName/ns0:firstName), ' ', data($Representative/ns0:representativeName/ns0:lastName) ), data($representativeAddress/ns0:addressLine1), data($representativeAddress/ns0:addressLine2), data($representativeAddress/ns0:addressLine3), data($representativeAddress/ns0:city), data($representativeAddress/ns0:province), data($representativeAddress/ns0:country), data($representativeAddress/ns0:postalCode) ) } } { let $representativeName := $Representative/ns0:representativeName return { data($representativeName/ns0:firstName) } { data($representativeName/ns0:lastName) } } { data($Representative/ns0:emailAddress) } } }; declare variable $workerAppeal1 as element(ns0:workerAppeal) external; xf:AIStest($workerAppeal1) And here is sample data for it: 2011-02-03-11:00 00000 First Last true city province H0H 0H0 CA 111 1111111 email@email.com decisionAppealled decisionWrong expectations The transformation files are mainly auto-generated by the mapper except for the custom address function. The only major difference I can see between the two transformations is these lines in the sample files - the working one has only one namespace, and the one with the error has two. Any help would by hugely appreciated, because XQuery is still a fairly foreign thing to me and this is driving me nuts. (Yes, the code has been anonymized somewhat - the URLs aren't really www.website.com for example. Hopefully this hasn't caused any issues) Thanks in advance!
