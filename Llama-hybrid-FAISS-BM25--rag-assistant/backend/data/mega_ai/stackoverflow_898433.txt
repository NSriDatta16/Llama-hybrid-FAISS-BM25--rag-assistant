[site]: stackoverflow
[post_id]: 898433
[parent_id]: 898387
[tags]: 
What you have marked as "// Initialization" is actually a creating and initializing a second variable with the same name, in a different scope. The static_double_variable variable created inside the constructor is a local variable in the constructor, and does not refer to the class-level static variable with the same name. What you need to do to avoid this is to simply remove the type information so that it's a normal statement rather than an initialization, like so: // Initialization: static_double_variable = 20.0; But of course this won't actually work because it's an assignment to a const variable, and you still have a second problem, which is what I think is actually causing the error you see. When you write: // Private member variable: static const double static_double_variable; You are declaring that such a variable will exist. However you are not actually defining that variable (i.e. instructing the compiler to create storage for it). In order to do that, and fix both your issues outside of your class { } construct, you would write: const double TestStaticVariables::static_double_variable = 20.0; This both defines the variable and gives it an initial, constant value. In case that was unclear, this issue is also described succinctly in the C++ FAQ: http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.10
