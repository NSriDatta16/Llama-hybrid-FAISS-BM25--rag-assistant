[site]: stackoverflow
[post_id]: 2657795
[parent_id]: 2656769
[tags]: 
@dreeves, you're correct in that Ordering is the key to the fastest implementation of ArgMax over a finite domain: ArgMax[f_, dom_List] := dom[[Ordering[f /@ dom, -1]]] Part of the problem with your original implementation using Fold is that you end up evaluating f twice as much as necessary, which is inefficient, especially when computing f is slow. Here we only evaluate f once for each member of the domain. When the domain has many duplicated elements, we can further optimize by memoizing the values of f : ArgMax[f_, dom_List] := Module[{g}, g[e___] := g[e] = f[e]; (* memoize *) dom[[Ordering[g /@ dom, -1]]] ] This was about 30% faster in some basic tests for a list of 100,000 random integers between 0 and 100. For a posmax function, this somewhat non-elegant approach is the fastest thing I can come up with: PosMax[f_, dom_List] := Module[{y = f/@dom}, Flatten@Position[y, Max[y]] ] Of course, we can apply memoization again: PosMax[f_, dom_List] := Module[{g, y}, g[e___] := g[e] = f[e]; y = g /@ dom; Flatten@Position[y, Max[y]] ] To get all the maximal elements, you could now just implement ArgMax in terms of PosMax : ArgMax[f_, dom_List] := dom[[PosMax[f, dom]]]
