[site]: stackoverflow
[post_id]: 4523021
[parent_id]: 4487754
[tags]: 
This is going to be an opinion-driven question. But I'll throw in my $.02. tl/dr: don't worry too much about this. JavaScript is pretty flexible and can support a lot of ways of doing things. Well-organized is well-organized. You're probably fine. More detailed answer: 1) Use classes where they make sense: where the problem domain fits class-ish / class hierarchy modeling. A problem domain where you've got a variety of shape objects that have common methods inherited from a base class and other polymorphic methods... well, that's (literally) a textbook example of a case where the class hierarchy is obvious and probably useful, and class-focused code is going to make sense there and there's nothing wrong with it. 2) You don't even have to use closures/module patterns/whatever. When you're writing classes, most of the time there's nothing wrong with making use of the native class-ish functionality available in JavaScript -- just define the constructor, and then define the prototype object for the constructor and put your methods on it. When you want to inherit from that class, assign the prototype object of the subclass to an instance of the class from which you're deriving. (For example: Drawing.Node = (function() { var Node = function (context,position) { this.context = context; this.position = position; } Node.prototype = { draw: function() { throw Exception.MethodNotOverridden; }, getContext: function() { return this.context; }, getPosition: function() { return this.position; }, setPosition: function(newPosition) { this.position = newPosition; } }; return Node; })(); Shape.Circle = (function () { var Circle = // Circle constructor function Circle.prototype = new Draw.Node; Circle.prototype.overriddenmethod1 = function () { } Circle.prototype.overriddenmethod2 = function () { } return Circle; })() ) What about private members/methods? This is an opinion, but most of the time, I think privacy as a runtime-enforced mechanism is overused and even abused. Developers have a lot to do; they'd probably rather not pay attention to the internals of any given abstraction unless it leaks something noxious. If your classes don't cause problems, throw/return useful errors, provide genuinely useful methods, and are documented well enough, you won't need any kind of privacy enforcement mechanism because everyone will be so happy with the work your classes are saving them they won't ever peer inside. If your classes don't meet that standard, well, the lack of a privacy enforcement mechanism is not your real problem. There is an exception to this, and that's when you have JavaScript code from different (and often untrusted) sources mixing within a page/app. At that point, for security reasons, you sometimes have to carefully think about isolating some crucial functions/methods within a given scope that your code and your code alone has access to. Edit/Addendum In answer to the question about why I've got those immediately evaluated functions, consider this alternate way of writing the Drawing.Node definition: Drawing.Node = function (context,position) { this.context = context; this.position = position; } Drawing.Node.prototype = { draw: function() { throw Exception.MethodNotOverridden; }, getContext: function() { return this.context; }, getPosition: function() { return this.position; }, setPosition: function(newPosition) { this.position = newPosition; } }; This does exactly the same thing as the code above. It's also, IMHO, totally acceptable, and possibly a little clearer and less tricksy. On the other hand, I find that putting all that inside the scope of an immediately executed anonymous function gives me at least two advantages: If I do decide I need to define any private methods or otherwise do some setup work that's only relevant to that specific class definition, it gives me a nice private scope to work in. If I decide I need to move Node 's location in the namespacing object hierarchy somewhere else, it's kindof convenient if everything related to its definition is all tied up in one convenient spot. Sometimes these advantages are small. Sometimes they're a little more compelling. YMMV.
