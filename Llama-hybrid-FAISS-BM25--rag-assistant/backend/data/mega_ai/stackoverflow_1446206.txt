[site]: stackoverflow
[post_id]: 1446206
[parent_id]: 1445967
[tags]: 
It's useful to have the rects you want as final targets set up as subviews as a larger UIView (or subclass) where you expect all these related hits to occur. For example, if you're building your own keyboard, you could add a bunch of UIButton objects as subviews and hit test those. So, the easy and traditional way of hit testing a bunch of subviews is to simply have code triggered by someone hitting those buttons. For example, you could add the subviews as UIControl objects (which is a subclass of UIView that adds some useful methods for catching user touch events), and call addTarget:action:forControlEvents: to specify some method to be triggered when the user does something in the rect of that UIControl . For example, you can catch things like UIControlEventTouchDown or UIControlEventTouchDragEnter . You can read the complete list in the UIControl class reference . Now, it sounds like you might be going for something even more customized. If you really want to start with a random (x,y) coordinate and know which rect it's in, you can also use the hitTest:withEvent: method of UIView . This method takes a point in a view, and finds the most detailed (lowest in the hierarchy) subview which contains that point. If you want to use these subviews purely for hit testing and not for displaying, then you can set their background color to [UIColor clearColor] , but don't hide them (i.e. set the hidden property to YES ), disable user interaction with them (via the userInteractionEnabled BOOL property), or set the alpha below 0.1, since any of those things will cause the hitTest:withEvent: method to skip over that subview. But you can still use an invisible subview with this method call, as long as it meets these criteria.
