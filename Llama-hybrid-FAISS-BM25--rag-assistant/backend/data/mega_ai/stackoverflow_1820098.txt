[site]: stackoverflow
[post_id]: 1820098
[parent_id]: 
[tags]: 
C# WPF convert BitmapImage pasted in richtextbox to binary

I've got a richtextbox, that I plan on saving to a database, which can be loaded back into the same richtextbox. I've got it working so that I can save the flowdocument as DataFormats.XamlPackage, which saves the images, but the issue is that the text isn't searchable. With DataFormats.Xaml, I've got the text of course, but no images. The images will be pasted in by the end user, not images included with the application. I tried using XamlWriter to get the text into XML, and then grab the images from the document separately and insert them as binary into the XML, but I can't seem to find a way to get the images to binary... Does anyone have ideas on how to get the images into binary, separate from the text? Thanks in advance! GetImageByteArray() is where the issue is. Code: private void SaveXML() { TextRange documentTextRange = new TextRange(richTextBox.Document.ContentStart, richTextBox.Document.ContentEnd); FlowDocument flowDocument = richTextBox.Document; using (StringWriter stringwriter = new StringWriter()) { using (System.Xml.XmlWriter writer = System.Xml.XmlWriter.Create(stringwriter)) { XamlWriter.Save(flowDocument, writer ); } testRTF t = new testRTF(); t.RtfText = new byte[0]; t.RtfXML = GetImagesXML(flowDocument); t.RtfFullText = stringwriter.ToString(); //save t to database } richTextBox.Document.Blocks.Clear(); } private string GetImagesXML(FlowDocument flowDocument) { using (StringWriter stringwriter = new StringWriter()) { using (System.Xml.XmlWriter writer = System.Xml.XmlWriter.Create(stringwriter)) { Type inlineType; InlineUIContainer uic; System.Windows.Controls.Image replacementImage; byte[] bytes; System.Text.ASCIIEncoding enc; //loop through replacing images in the flowdoc with the byte versions foreach (Block b in flowDocument.Blocks) { foreach (Inline i in ((Paragraph)b).Inlines) { inlineType = i.GetType(); if (inlineType == typeof(Run)) { //The inline is TEXT!!! } else if (inlineType == typeof(InlineUIContainer)) { //The inline has an object, likely an IMAGE!!! uic = ((InlineUIContainer)i); //if it is an image if (uic.Child.GetType() == typeof(System.Windows.Controls.Image)) { //grab the image replacementImage = (System.Windows.Controls.Image)uic.Child; //get its byte array bytes = GetImageByteArray((BitmapImage)replacementImage.Source); //write the element writer.WriteStartElement("Image"); //put the bytes into the tag enc = new System.Text.ASCIIEncoding(); writer.WriteString(enc.GetString(bytes)); //close the element writer.WriteEndElement(); } } } } } return stringwriter.ToString(); } } //This function is where the problem is, i need a way to get the byte array private byte[] GetImageByteArray(BitmapImage bi) { byte[] result = new byte[0]; using (MemoryStream ms = new MemoryStream()) { XamlWriter.Save(bi, ms); //result = new byte[ms.Length]; result = ms.ToArray(); } return result; } UPDATE I think I may have finally found a solution, which I will post below. It uses BmpBitmapEncoder and BmpBitmapDecoder. This allows me to get binary from the bitmap image, store it to the database, and load it back up and display it right back into the FlowDocument. Initial tests have proven successful. For testing purposes I'm bypassing my database step and basically duplicating the image by creating binary, then taking the binary and turning it into a new image and adding it to the FlowDocument. The only issue is that when I try and take the modified FlowDocument and use the XamlWriter.Save function, it errors on the newly created Image with "Cannot serialize a non-public type 'System.Windows.Media.Imaging.BitmapFrameDecode". This will take some further investigation. I'll have to leave it alone for now though. private void SaveXML() { TextRange documentTextRange = new TextRange(richTextBox.Document.ContentStart, richTextBox.Document.ContentEnd); FlowDocument flowDocument = richTextBox.Document; string s = GetImagesXML(flowDocument);//temp LoadImagesIntoXML(s); using (StringWriter stringwriter = new StringWriter()) { using (System.Xml.XmlWriter writer = System.Xml.XmlWriter.Create(stringwriter)) { XamlWriter.Save(flowDocument, writer );//Throws error here } } } private string GetImagesXML(FlowDocument flowDocument) { string s= ""; using (StringWriter stringwriter = new StringWriter()) { Type inlineType; InlineUIContainer uic; System.Windows.Controls.Image replacementImage; byte[] bytes; BitmapImage bi; //loop through replacing images in the flowdoc with the byte versions foreach (Block b in flowDocument.Blocks) { foreach (Inline i in ((Paragraph)b).Inlines) { inlineType = i.GetType(); if (inlineType == typeof(Run)) { //The inline is TEXT!!! } else if (inlineType == typeof(InlineUIContainer)) { //The inline has an object, likely an IMAGE!!! uic = ((InlineUIContainer)i); //if it is an image if (uic.Child.GetType() == typeof(System.Windows.Controls.Image)) { //grab the image replacementImage = (System.Windows.Controls.Image)uic.Child; bi = (BitmapImage)replacementImage.Source; //get its byte array bytes = GetImageByteArray(bi); s = Convert.ToBase64String(bytes);//temp } } } } return s; } } private byte[] GetImageByteArray(BitmapImage src) { MemoryStream stream = new MemoryStream(); BmpBitmapEncoder encoder = new BmpBitmapEncoder(); encoder.Frames.Add(BitmapFrame.Create((BitmapSource)src)); encoder.Save(stream); stream.Flush(); return stream.ToArray(); } private void LoadImagesIntoXML(string xml) { byte[] imageArr = Convert.FromBase64String(xml); System.Windows.Controls.Image img = new System.Windows.Controls.Image() MemoryStream stream = new MemoryStream(imageArr); BmpBitmapDecoder decoder = new BmpBitmapDecoder(stream, BitmapCreateOptions.None, BitmapCacheOption.Default); img.Source = decoder.Frames[0]; img.Stretch = Stretch.None; Paragraph p = new Paragraph(); p.Inlines.Add(img); richTextBox.Document.Blocks.Add(p); }
