[site]: stackoverflow
[post_id]: 438204
[parent_id]: 435098
[tags]: 
After a couple of projects with the validation logics I came to the the third option. Generic rule is defined as: /// /// Typed delegate for holding the validation logics /// /// Object to validate /// Scope that will hold all validation results /// type of the item to validate public delegate void Rule (T obj, IScope scope); where IScope is /// /// Concept from the xLim2. That's simple nesting logger that is used by /// the validation rules. /// public interface IScope : IDisposable { /// /// Creates the nested scope with the specified name. /// /// New name for the nested scope. /// Nested (and linked) scope instance IScope Create(string name); /// /// Writes with the specified /// to the /// /// The level. /// The message. void Write(RuleLevel level, string message); /// /// Gets the current of this scope /// /// The level. RuleLevel Level { get; } } and rule levels are: /// /// Levels leveraged by the implementations /// public enum RuleLevel { /// Default value for the purposes of good citizenship None = 0, /// The rule raises a warning Warn, /// The rule raises an error Error } With that you can define new rules even without declaring new classes: public static void ValidEmail(string email, IScope scope) { if (!_emailRegex.IsMatch(email)) scope.Error("String is not a valid email address"); } or compose new validators through the enclosures /// /// Composes the string validator ensuring string length is shorter than /// /// /// Max string length. /// new validator instance public static Rule Limited(int maxLength) { Enforce.Argument(() => maxLength, Is.GreaterThan(0)); return (s, scope) => { if (s.Length > maxLength) scope.Error("String length can not be greater than '{0}'", maxLength); }; } Rules could be composed together and still stay readable: internal static Rule [] UserName = new[] { StringIs.Limited(6, 256), StringIs.ValidEmail }; In order to run a rule, you simply pass it an object, a scope (to write output to) and then check the scope for results. Additional extensibility points within this paradigm: rules can "communicate" with each other by checking current error level of the scope (i.e.: CPU intensive rule may skip if there are problems already) you can compose rules that check complex business objects (by leveraging IScope.Create) you can implement different rule behaviors (without changing rules) by passing in different scope implementations. For example: Fast argument scope could be used to check for function arguments and throw exception as soon as the first problem is encountered Validation scope could be used to check for function arguments to throw and exception with ALL problems encountered MessageBased scopes could be used to bind rule failures of complex domain object to the UI elements via some error provider (scope path is used for this) There are more extensibility points within this simple concept)) BTW, Open Source implementation is available for .NET. PS: in our company we've defined some rules for the public API in a single file (rather small) and reuse these for validation everywhere.
