[site]: stackoverflow
[post_id]: 5604207
[parent_id]: 5602870
[tags]: 
You could incorporate a range check into your shader. Setting clamp_to_edge affects what pixels you get back from sampling only, so the texture coordinates coming into your shader will still be outside of the range from zero to one when you're in the region where you don't want to output any pixels. On the hardware commonly used for GL ES today, it's faster to pass on a colour with an alpha of 0 than to discard, so do that if your blend mode allows it. E.g. supposing you currently have just the most trivial textured fragment shader: void main() { gl_FragColor = texture2D(tex2D, texCoordVarying); } You could instead go with: void main() { if(clamp(texCoordVarying, vec2(0.0, 0.0), vec2(1.0, 1.0)) == texCoordVarying) gl_FragColor = texture2D(tex2D, texCoordVarying); else gl_FragColor = vec4(0.0); // or discard, if you need to } However, an explicit range check is going to add processing cost. Obviously worry about that only if it becomes an issue, but the solution in that case is just to add a border inside your texture. So if your texture is 256x256 then you'd use the central 254x254 pixels and put a completely transparent border around the outside. EDIT: thinking more clearly, if alpha rather than discard is acceptable then you could use the step function to eliminate the conditional. Do it four times over - once for each limit on each axis, invert the results where you want a greater than test rather than a less than, then multiply the output alpha by all four results. If any one is zero, the output alpha will be zero.
