[site]: stackoverflow
[post_id]: 5606525
[parent_id]: 
[tags]: 
Calling a Function/Variables From Separate CPP files

I have to different CPP files in a program I'm writing for fun and in my main file I call an algorithm from my IsValid cpp file. My IsValid algorithm also needs to get a variable from my main file, email, and then I'll run it through the loop I wrote. I was wondering how to accomplish this since if I heard that it's bad coding practice to include cpp files and if I did it would cause an include loop anyways. Does any one have any suggestions on how to solve this issue. Code Below: #include #include #include "Validation.h" using namespace std; #define MAX_SIZE 260 #define NOT_FOUND -1 void main() { //High level alg // O) Open input file and output file ifstream input("Email.txt"); ofstream output("Result.txt"); // Oa) While not at the end of input while(!input.eof()) { char email[MAX_SIZE]; Validation A(email); // Ob)Read email input input.getline(email, MAX_SIZE); // Validat email if (A.Valid(email)) // Write results to output file output Second file: #include #include #include "Validation.h" using namespace std; #define NOT_FOUND -1 bool IsValid(char* email) { int Length, atIndex, LocalLength, DomainLength, aCheck = 0; char* Invalid = "()[]\\;:,<>"; // Searches for the NULL terminator at the end of the char array and returns Length of the arry Validation a(email); Length = a.GetLength; if(Length Third file: #define MAX_SIZE 260 #define NOT_FOUND -1 #include #pragma once using namespace std; struct Validation { //Returns the length of text by scanning for null-term int GetLength(char* text) { int i; for(i = 0; text[i] != '\0'; i++) { } return i; } Validation::Validation(char* email) { char* emailC = email; } Validation::Validation(char* email, int Length) { char* emailC = email; int Size = Length; } Validation::Validation(char* email, int atIndex, int Length) { char* emailC = email; int Size = Length; int IndA = atIndex; } Validation::Validation(char* email, char* Invalid, int atIndex) { char* emailC = email; char* InNum = Invalid; int IndA = atIndex; } bool Valid(char * email) { char* emailT = email; } bool CheckRuleLocal(char* text, int Achar) { int invalid = 0; if(text[0] == '.'|| text[Achar - 1] == '.') invalid++; if(text[0] == '-'|| text[Achar - 1] == '-') invalid++; for(int i = 0; i 0) return false; else return true; } bool CheckRuleDomain(char* text, int Achar, int length) { int invalid = 0; if(text[Achar + 1] == '.'|| text[length - 1] == '.') invalid++; if(text[Achar + 1] == '-'|| text[length - 1] == '-') invalid++; for(int i = Achar + 1; i 0) return false; else return true; } bool ValidCharsL(char* text, char* invalidCharacters, int Achar) { int invalid = 0; for(int i = 0; i 0) return false; else return true; } bool ValidCharsD(char* text, char* invalidCharacters, int Achar) { int invalid = 0; for(int i = Achar + 1; text[i] != '\0'; i++) { for(int t = 0; t 0) return false; else return true; } //Finds the position of @ and returns an int that will store value if not found returns -1 int Find(char* text, int arraySize) { int AIndex = 0; for(int i = 0; i 0) return AIndex; else return NOT_FOUND; } int CheckLengthLocal(char* text, int Achar) { int count = 0; for(int i = 0; i != Achar; i++) { count ++; } return count; } int CheckLengthDomain(char* text, int Achar) { int count = 0; for(int i = Achar + 1; text[i] != '\0'; i++) { count ++; } return count; } };
