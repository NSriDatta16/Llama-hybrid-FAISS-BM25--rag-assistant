[site]: datascience
[post_id]: 30872
[parent_id]: 
[tags]: 
Multi-label classifciation: keras custom metrics

Contextualization I am working on a multi_label classification problem with images. I am trying to predict 39 labels. In other words, I am trying to identifying which one of the 39 characteristics is present in a given image( many characteristics can be found in one image that's why I am on a multi label classification situation. Data My input data are (X,Y): X is of shape (1814,204,204,3) and Y is of shape (1814,39). So basically X are the set of images and Y are the labels associated to each images which will be used for the supervised learning process. Model I am building a Convolutional Neural Network in order to make predictions. For this task, I am using Keras in order to create my model. What I have done In order to validate my model, I need to choose a metric . However, metrics available in Keras are irrelevant in my case and won't help me validate my model since I am in multi-label classification situation. That's why I decided to create my custom metric. I created recall and precision metrics applied to columns of Y and Y_predict . In other words, I will calculate recall and precision for each class of the 39 classes. So here is the code of my metrics: def recall(y_true, y_pred): #Recall metric. true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)),axis=0) possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)),axis=0) recall = true_positives / (possible_positives + K.epsilon()) return recall def precision(y_true, y_pred): #Precision metric. true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)),axis=0) predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)),axis=1) precision = true_positives / (predicted_positives + K.epsilon()) return precision My vector Y is of shape (n,39) that's why I am doing operations over axis=0. In other words, for each label, I am calculating precision and recall. Next step, I called these two metrics by precising it to Keras fit function. In other words I used this line of code: model.compile(loss='binary_crossentropy', optimizer=sgd, metrics=[precision,recall]) Code for building, compiling and fitting model: Here is the code that I use for building the model an training it + its result . ( I am not putting the part of code where I split data into train and validation: Train on 1269 samples, validate on 545 samples ) # Model: CNN model = Sequential() model.add(Conv2D(32, (3, 3), input_shape=(204, 204, 3), padding='same', activation='relu', kernel_constraint=maxnorm(3))) model.add(Dropout(0.2)) model.add(Conv2D(32, (3, 3), activation='relu', padding='same', kernel_constraint=maxnorm(3))) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Flatten()) model.add(Dense(512, activation='relu', kernel_constraint=maxnorm(3))) model.add(Dropout(0.5)) model.add(Dense(39)) model.add(Activation('sigmoid')) # Compile model epochs = 5 lrate = 0.001 decay = lrate/epochs sgd = SGD(lr=lrate, momentum=0.9, decay=decay, nesterov=False) model.compile(loss='binary_crossentropy', optimizer=sgd, metrics=[precision,recall]) # fitting the model model.fit(X_train, Y_train, epochs=epochs, batch_size=32,validation_data=(X_valid,Y_valid)) Results Train on 1269 samples, validate on 545 samples Epoch 1/5 96/1269 [=>............................] - ETA: 6:40 - loss: 0.6668 - precision: 0.1031 - recall: 0.2493 Issues/Questions Question 1: In the log of the results section , there are precision and recall values. I don't know why I got real values instead of vector of values. The way I constructed my two metrics should give me an array of shape (1,39) for precision and (1,39) for recall, which should contain precision and recall for each class, still The output is only a number? Question 2: these values of precision and recall given by the log, they represent metric calculation for a data of size= batch? How can I calculate the metric over an epoch ( which is more useful as an information than just a calculation over a batch? Some may say, just calculate the average over all batches? Sure , that's what I am thinking of but I don't know how to do it since Keras is kinda of a black box to me and I don't exactly what is happening ''behind the scenes'' in order to follow/modify the adequate part of code?
