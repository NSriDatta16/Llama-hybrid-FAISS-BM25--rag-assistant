[site]: stackoverflow
[post_id]: 4256889
[parent_id]: 
[tags]: 
Paging viewcontrollers in Landscape mode

I have this code, modified version of Apple's PageScrollView sample. Here the differnce is that m using ViewControllers instead of UIView. MyClass.h @interface MyClass : UIViewController { UIScrollView *scrollView; UIPageControl *pageControl; NSMutableArray *viewControllers; BOOL pageControlUsed; } @property (nonatomic, retain) IBOutlet UIScrollView *scrollView; @property (nonatomic, retain) IBOutlet UIPageControl *pageControl; @property (nonatomic, retain) NSMutableArray *viewControllers; - (IBAction)changePage:(id)sender; @end MyClass.m #import "MyClass.h" #import "MyViewController.h" #import "MyViewControllerZero.h" #import "MyViewControllerOne.h" #import "MyViewControllerTwo.h" static NSUInteger kNumberOfPages = 3; @interface MyClass (PrivateMethods) - (void)loadScrollViewWithPage:(int)page; - (void)scrollViewDidScroll:(UIScrollView *)sender; @end @implementation MyClass @synthesize scrollView, pageControl, viewControllers; /* // The designated initializer. Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad. - (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil { if ((self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])) { // Custom initialization } return self; } */ // Implement viewDidLoad to do additional setup after loading the view, typically from a nib. - (void)viewDidLoad { NSMutableArray *controllers = [[NSMutableArray alloc] init]; for (unsigned i = 0; i = kNumberOfPages) return; if(page==0) { MyViewControllerZero *controller = [viewControllers objectAtIndex:page]; if ((NSNull *)controller == [NSNull null]) { controller = [[MyViewControllerZero alloc] init]; [viewControllers replaceObjectAtIndex:page withObject:controller]; if (nil == controller.view.superview) { CGRect frame = scrollView.frame; frame.origin.x = frame.size.width * page; frame.origin.y = 0; controller.view.frame = frame; [scrollView addSubview:controller.view]; } } } if(page==1) { MyViewControllerOne *controller = [viewControllers objectAtIndex:page]; if ((NSNull *)controller == [NSNull null]) { controller = [[MyViewControllerOne alloc] init]; [viewControllers replaceObjectAtIndex:page withObject:controller]; if (nil == controller.view.superview) { CGRect frame = scrollView.frame; frame.origin.x = frame.size.width * page; frame.origin.y = 0; controller.view.frame = frame; [scrollView addSubview:controller.view]; } } } if(page==2) { MyViewControllerTwo *controller = [viewControllers objectAtIndex:page]; if ((NSNull *)controller == [NSNull null]) { controller = [[MyViewControllerTwo alloc] init]; [viewControllers replaceObjectAtIndex:page withObject:controller]; if (nil == controller.view.superview) { CGRect frame = scrollView.frame; frame.origin.x = frame.size.width * page; frame.origin.y = 0; controller.view.frame = frame; [scrollView addSubview:controller.view]; } } } } - (void)scrollViewDidScroll:(UIScrollView *)sender { if (pageControlUsed) { return; } CGFloat pageWidth = scrollView.frame.size.width; int page = floor((scrollView.contentOffset.x - pageWidth / 2) / pageWidth) + 1; pageControl.currentPage = page; // load the visible page and the page on either side of it (to avoid flashes when the user starts scrolling) [self loadScrollViewWithPage:page - 1]; [self loadScrollViewWithPage:page]; [self loadScrollViewWithPage:page + 1]; // A possible optimization would be to unload the views+controllers which are no longer visible } - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { // Overriden to allow any orientation. return YES; } - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView { pageControlUsed = NO; } // At the end of scroll animation, reset the boolean used when scrolls originate from the UIPageControl - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView { pageControlUsed = NO; } - (IBAction)changePage:(id)sender { int page = pageControl.currentPage; // load the visible page and the page on either side of it (to avoid flashes when the user starts scrolling) [self loadScrollViewWithPage:page - 1]; [self loadScrollViewWithPage:page]; [self loadScrollViewWithPage:page + 1]; // update the scroll view to the appropriate page CGRect frame = scrollView.frame; frame.origin.x = frame.size.width * page; frame.origin.y = 0; [scrollView scrollRectToVisible:frame animated:YES]; // Set the boolean used when scrolls originate from the UIPageControl. See scrollViewDidScroll: above. pageControlUsed = YES; } - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc that aren't in use. } - (void)viewDidUnload { [super viewDidUnload]; // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; } - (void)dealloc { [viewControllers release]; [scrollView release]; [pageControl release]; [super dealloc]; } @end The Above code works absolutely fine in the potrait mode. But when i change the orientation,the whole paging gets screwed up.. :(( please help me to resolve this problem..
