[site]: stackoverflow
[post_id]: 3792103
[parent_id]: 3791302
[tags]: 
There's not quite enough code here to tell what the problem is but, from the error message, I'd guess that the playerId object is what's not being retained. That is, it seems that your tempCharacter is fine, but not the playerId field. If you have @property(nonatomic,retain) SomeObject *playerId; then remember that playerId = foo; will NOT hold onto the object for you. You must use the accessor: self.playerId = foo; EDIT in response to Tom's question-edit: I absolutely, positively guarantee you that objects placed in an NSMutableArray are retained by that array until (a) they are removed or (b) the array is released. So you can stop looking there, the problem is somewhere else. :) One thing you can try is to add the following code to the object that is being released when you think it shouldn't: #pragma mark - #pragma mark Memory-use debugging #define DEBUG_RETAIN_RELEASE 0 #define DEBUG_ALLOC_DEALLOC 0 #if DEBUG_ALLOC_DEALLOC static int allocCounter = 0; +(id)alloc { id me = [super alloc]; NSLog(@"%@ ALLOC (%2d): %@", [me class], ++allocCounter, me); return me; } #endif #if DEBUG_RETAIN_RELEASE - (id)retain { id result = [super retain]; NSLog(@"%@ retain %@, count: %2d", [self class], self, [self retainCount]); return result; } - (void)release { // we have to log BEFORE the release, in case it's the last one! e NSLog(@"%@ RELEASE %@, count: %2d", [self class], self, ([self retainCount] - 1)); [super release]; } - (id)autorelease { id result = [super autorelease]; NSLog(@"%@ AUTOrelease %@, count: %2d", [self class], self, [self retainCount]); return result; } #endif // ... - (void)dealloc { #if DEBUG_ALLOC_DEALLOC NSLog(@"%@ dealloc (%2d): %@", [self class], --allocCounter, self); #endif [self releaseMyStuff]; [super dealloc]; } Then start with DEBUG_ALLOC_DEALLOC = 1 and put a breakpoint on the dealloc log statement. If that doesn't help, set DEBUG_RETAIN_RELEASE = 1 and break on both retain & release. You'll be surprised at all the iOS retains you get, but don't worry about it, iOS promises balanced retain-release, if used properly. I'm just warning you because you may be expecting a much lower retain count, and be surprised to see it climb during some operation or another. Luck!
