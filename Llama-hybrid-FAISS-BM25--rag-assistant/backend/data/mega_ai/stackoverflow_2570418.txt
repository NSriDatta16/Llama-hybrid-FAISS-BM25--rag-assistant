[site]: stackoverflow
[post_id]: 2570418
[parent_id]: 2556138
[tags]: 
Step 1 : Make a procedure to generate a list of months before or after today's date. Use a negative parameter to go backwards in time, or a positive to go forward. create proc Timing.spGetMonthsFromToday(@months int) as BEGIN -- Modified Jeff Moden solution found at: -- http://www.sqlservercentral.com/Forums/Topic494640-149-1.aspx ;WITH cteTally AS ( SELECT TOP (ABS(@months)) N = case when @months Step 2 : Make the function callable within .NET. If you don't want to, or don't have an existing DL, you can use a quick Linq to SQL class. Go into Solution Explorer, add a Linq to SQL class. Go into Server Explorer and make a connection to your database. Find the stored procedure and drag it into the functions area of the L2SQL class. Step 3 : Call the function inside of a .NET class and push it into a List that's easily consumable and reusable by your ASP.NET code. namespace Sample { class Timing { public struct ListMonth { public readonly int Year; public readonly int Month; public readonly string Description; public readonly DateTime StartDate; public readonly DateTime NextStartDate; public ListMonth(int year, int month, string description, DateTime startDate, DateTime nextStartDate) { Year = year; Month = month; Description = description; StartDate = startDate; NextStartDate = nextStartDate; } public override string ToString() { return Description; } } public List GetMonthsFromToday(int months) { List _return = new List (); dcTimingDataContext dc = new dcTimingDataContext(); var data = dc.spGetMonthsFromToday(months); foreach (var row in data) { ListMonth month = new ListMonth(row.YearNumber.Value, row.MonthNumber.Value, row.MonthDesc, row.MonthStartDate.Value, row.NextMonthStartDate.Value); _return.Add(month); } return _return; } } } Step 4 : Bind the list to your dropdown list. I used a WPF front-end for this, but the databinding should be exactly, or very close to, the same. I used -120 as the parameter since you wanted to go back 10 years, but it's adjustable to whatever. private void LoadMonths() { Sample.Timing timing = new Sample.Timing(); cboMonths.ItemsSource = timing.GetMonthsFromToday(-120).OrderByDescending(row => row.StartDate); } private void cboMonths_SelectionChanged(object sender, SelectionChangedEventArgs e) { if (((ComboBox)sender).SelectedItem != null) { Sample.Timing.ListMonth month = (Sample.Timing.ListMonth)((ComboBox)sender).SelectedItem; Console.WriteLine(month.StartDate); // just showing these dates are accessible under the hood Console.WriteLine(month.NextStartDate); // just showing these dates are accessible under the hood /* use these dates in your query against data set where eventdate >= month.StartDate and eventdate Step 5 : As you can see at the end of Step 4, when a user makes a selection, you can get the actual datetimes for the beginning and end of the month. Then pass those to your query against your "Events" table. Make sure to use >= with StartDate and Cheers, hope this helps!
