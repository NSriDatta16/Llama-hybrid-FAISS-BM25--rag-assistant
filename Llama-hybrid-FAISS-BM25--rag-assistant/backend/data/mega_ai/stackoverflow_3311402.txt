[site]: stackoverflow
[post_id]: 3311402
[parent_id]: 3311242
[tags]: 
IList .Count() is very large number!!! Yes, which means that no matter what syntax sugar you use, the conversion is going to require O(n) time and O(n) storage. You cannot cast the list to avoid re-creating it. If that was possible, client code could add an element of BaseT1 to the list, violating the promise that list only contains objects that are compatible with T1. The only way to get ahead is to return an interface type that cannot change the list. Which would be IEnumerable in this case. Allowing you to iterate the list, nothing else. That conversion is automatic in .NET 4.0 thanks to its support for covariance. You'll have to write a little glue code in earlier versions: public static IEnumerable enumerate(IList p) { foreach (BaseT1 item in p) yield return item; }
