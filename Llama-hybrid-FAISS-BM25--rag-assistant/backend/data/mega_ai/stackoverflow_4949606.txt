[site]: stackoverflow
[post_id]: 4949606
[parent_id]: 
[tags]: 
How to write a clear and elegant code for a strategy pattern based application?

I am writing an application to compose musical freizes, but I am a little worried about the structure of classes and interfaces within the code. Here there are the signatures of some classes I wrote: Interface IGuidoFormattable Class Note : IGuidoFormattable, ICloneable Class Pause : IGuidoFormattable, ICloneable Class Chord : List , IGuidoFormattable, ICloneable Class Key : IGuidoFormattable, ICloneable Class Tempo : IGuidoFormattable, ICloneable Class Meter : IGuidoFormattable, ICloneable Class FretPiece : List , ICloneable Class Fret : List FretPiece represents a muscial phrase, a piece of the complete freize. It exposes as properties Key, Tempo and Meter, which are homonym with their types. More phrases put together create a freize, respresented by the Fret class. Every element within a single phrase must be formattable in accordance with the GUIDO standard notation, hence it has to implement the IGuidoFormattable interface. In another namespace, some mutation classes are defined and they all inherit from one of the two abstract classes: Class FretMutation Class LambdaFretMutation : FretMutation Finally, there exists a class called FretMutationGenerator which has the only task of applying selected mutations to a music theme and output the entire freize as an instance of Fret class. FretPiece must be able to contain several different elements (notes, pauses and chords in this case), which nonetheless must satisfy two constraints: they have to be formattable with GUIDO notation and therefore transformed into meaningful strings; they have to be cloneable. In the code as it is now, every class implements ICloneable, but syntax and semantics of current code do not grant that all members of the collection are cloneable. I need to find a way to express both constraint without applying inheritance to IGuidoFormattable and preferably without defining a Clone method in the IGuidoFormattable interface. Second, and most important, problem. FretMutation defines an abstract method, "Apply", that has to be overridden in every derived class. Therefore, any mutation class defines its own version of this method, which has the following signature: FretPiece Apply(FretPiece originalTheme) It accepts as input a FretPiece and outputs a copy of that object, mutated according to all other parameters specified as members of the class. I think that this is an implementation of the strategy pattern. However, only becase of the fact that this method creats a copy of the input, it means that the argument itself (and therefore all its members) must be cloneable. In addition, FretPiece is declared as a list of IGuidoFormattable, but every mutation class behaves differently from the others and may act on notes, pauses or chord, accordingly: this means that I need to check every element's type, and write a different code for each type with "a lot" (indeed, 3 at most) if statements. And this seems to me very little object oriented. How can I arrange classes and interface in a way that all become more object oriented and less dependent on assumptions and type-checking?
