[site]: stackoverflow
[post_id]: 499807
[parent_id]: 416760
[tags]: 
Even though Markus' solution remains the neatest I've seen so far, I've made some slight changes, which are hopefully improvements in the eyes of the original author as well ;). In case you add/remove an item of the list in response to an event, there is a chance of ending up with concurrent changes to the list; the event is handled, but the loop will continue in case there are more items after the one catching the event. Therefore it's required to use a slightly different approach. I've decided to use the ListIterator.add() method, as this one supports modifications to the list while walking through its items. Possibly there are more elegant solutions available, but this one does the job pretty decent. In case it will be of help to others; the modified code would similar be the following: ListIterator iterator = mActionListeners.listIterator(); public void actionPerformed(ActionEvent e) { iterator = mActionListeners.listIterator(); while (iterator.hasNext()) { ActionListener actionListener = (ActionListener)iterator.next(); actionListener.actionPerformed(e); } } public void addListener(ActionListener listener) { iterator.add(listener); } public void removeListener(ActionListener listener) { iterator.remove(listener); } In case there are better solutions or improvements I'll be glad to hear those as well.
