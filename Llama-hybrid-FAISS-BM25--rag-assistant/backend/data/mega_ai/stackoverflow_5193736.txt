[site]: stackoverflow
[post_id]: 5193736
[parent_id]: 5190956
[tags]: 
The comments to your question does indeed provide some useful information. I usually organize things like this to accomplish what you're talking about - it's only part of it that applies directly to dependency injection: I set up my Visual Studio solution to have one project/assembly per layer in the application. Having it this way, you must set a reference from one layer's project to another to be able to call that layer. So for example, you set up a reference from the MVC app layer to the service layer, but not from the MVC app to the repository layer, to prevent the MVC app from accessing the repository layer directly. Within each layer's project, I put the interfaces and classes that should be used in the project's top namespace, and put the actual implementation of the interfaces and other classes that should be hidden in a sub-namespace, usually called "Impl" or something like that; theses classes are also declared as "internal", which ensures that they can only be used from within the assembly (layer) and not from another layer by mistake. Each project/layer declares one NInject module that binds the public interfaces to the internal implementation classes. At the composition root of your application (see Mark Seeman's link: Where should I do Injection with Ninject 2+ (and how do I arrange my Modules?) ), you create a kernel that loads these modules. The actual injection is mostly done with constructor injection, meaning that the classes themself does not really know anything about injection taking place (sometimes you have to use the [Inject] attribute though, if you have ambigous constructors).
