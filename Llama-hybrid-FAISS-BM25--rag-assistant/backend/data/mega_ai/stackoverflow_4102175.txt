[site]: stackoverflow
[post_id]: 4102175
[parent_id]: 4101666
[tags]: 
I made a game like that , the first thing I ever made in C++ actually ( Who needs hello world :P) And everyone can use it if they want. Just don't forget it's my first C++ thing and it's definatly not properly coded :P but it has some nice C++ things like that in it. But there's a 100% optimized search algorithm in there that checks the absolute least amount of required permutation to check three in a row win conditions with heavy commenting and ASCII art. That could be quite usefull. Oh almost forgot the mention, It's a console application thingy (black screen DOS envi ,whatever it's called). It has an AI that (if this is my latest version) Should do pretty well. AND the grid is dynamically built (which was the hard part) U can play 3 in a row, but with a max of 20x20 grid ( lame game I found out, much more fun as 4 in a row with gravity ) Here you go: // DrieOpEenRij.cpp : Defines the entry point for the console application. #include "stdafx.h" #include #include #include using namespace std; typedef unsigned short USHORT; //USE ONLY IN A SQUARE GRID //This method checks a win for the minimimum amount of spaces covering 100% amount of the grid //It has 100% coverage and close to 0% overhead, discrimination between who to check for is required and //so currentMove char is required to check for win on 'H' human and 'C' Computer void CheckForWin(const char* Grid_ptr , const USHORT GridSize , const USHORT GridWidth ,bool &humanWin, bool &computerWin, const char currentMove) { //check for an x from 1-end of array //for all x's check if that makes a 3 line once per linetype //check for horizontal win (dont get overhead on edges) //A non square grid will have been detected by now const USHORT rowStart = 0; const USHORT rowEnd = GridWidth-1; USHORT passRowCounter = 1; const USHORT Side = GridWidth; const USHORT cond1 = rowEnd-2; const USHORT cond2 = GridSize-Side*2; //Check for all human win options ( after a human move ) if (currentMove == 'H') { //Check for human win code //Check all array slots for an occurence of 'X' for(USHORT i = 0; i if (iModSide Down Right // [?] [?] [?] [?] diagonal wins, similarly the Top Right --> Down Left is done mirrored // [?] [?] [?] [?] All other wins using this vector are impossible! // Using this amount of conditions to find it saves a lot of searching and with it time if (iPlusSideTimesTwo Down Left // [?] [?] [?] [?] diagonal wins, similarly the Top Left --> Down Right is done mirrored // [?] [?] [?] [?] This because all other wins using this vector are impossible! // Using this amount of conditions to find it saves a lot of searching and with it time if (i % Side > 1 && i + Side*2-2 if (iModSide Down Right // [?] [?] [?] [?] diagonal wins, similarly the Top Right --> Down Left is done mirrored // [?] [?] [?] [?] All other wins using this vector are impossible! // Using this amount of conditions to find it saves a lot of searching and with it time if (iPlusSideTimesTwo Down Left // [?] [?] [?] [?] diagonal wins, similarly the Top Left --> Down Right is done mirrored // [?] [?] [?] [?] This because all other wins using this vector are impossible! // Using this amount of conditions to find it saves a lot of searching and with it time if (iPlusSideTimesTwo+2 //WIN IN ONE MOVE (weight + 50) //NOT LOSE IN ONE MOVE (weight + 15) //BLOCK ENEMY + LINK UP OWN ( Equal prio but stacks so both matter ) weight +1 //These weights are determined using 8 directional vectors sprouting from all 'X' and 'O' locations in the grid //In it's path if it encounters on loc 1 'X' loc 2 + weight = 50 , and vice versa, else +1 for all 8 vectors //Create a weightgrid to store the data USHORT* WeightGrid_ptr = new USHORT[GridSize]; USHORT* fattest_ptr = new USHORT(0); USHORT* fattestIndex_ptr = new USHORT(0); USHORT Side = GridWidth; //Suggestion for optimization , make a forumula table to play all 8 vectors instead //Per vector u need Condition for the direction first space and next space. 24 statements in a list //A bit complex and harder to read so for now went the east 8 vectors copy pasting. But aware of the //solution none-the-less! Unfortunatly though it seems like a maze of code, it is well documented and //it's length is over 50% due to optimizations. for(USHORT i = 0; i Mid Right Vector //If within allowed parameters if(i % Side Down Right Vector //If within allowed parameters if (i % Side Down Mid Vector //If within allowed paramaters if (i + Side*2 Down Left Vector //If within allowed paramaters if(i % Side > 1 && i + Side*2 Mid Left Vector //If within allowed parameters if(i % Side > 1) { if (Grid_ptr[i-1] == '?' && Grid_ptr[i-2] == '?') { WeightGrid_ptr[i-1] += 1; WeightGrid_ptr[i-2] += 1; } else if(Grid_ptr[i-1] == 'X') { WeightGrid_ptr[i-2] += 15; } else if(Grid_ptr[i-2] == 'X') { WeightGrid_ptr[i-1] += 15; } } //CHECK X --> Top Left Vector //If within allowed parameters if( (i) % (Side > 1) && i > Side*2) { if (Grid_ptr[i-Side-1] == '?' && Grid_ptr[i-Side*2-2] == '?') { WeightGrid_ptr[i-Side-1] += 1; WeightGrid_ptr[i-Side*2-2] += 1; } else if (Grid_ptr[i-Side-1] == 'X') { WeightGrid_ptr[i-Side*2-2] += 15; } else if (Grid_ptr[i-Side*2-2] == 'X') { WeightGrid_ptr[i-Side-1] += 15; } } //CHECK X --> Mid Top Vector //If within allowed parameters if (i > Side*2) { if(Grid_ptr[i + Side] == '?' && Grid_ptr[i + Side*2] == '?') { WeightGrid_ptr[i + Side] += 1; WeightGrid_ptr[i + Side*2] += 1; } else if(Grid_ptr[i + Side] == 'X') { WeightGrid_ptr[i + Side*2] += 15; } else if (Grid_ptr[i + Side*2] == 'X') { WeightGrid_ptr[i + Side] += 15; } } } //end if 'X' detected else if (Grid_ptr[i] == 'O') { //CHECK 8 VECTORS //Add weights //CHECK O --> Mid Right Vector //If within allowed parameters if(i % Side Down Right Vector //If within allowed parameters if (i % Side Down Mid Vector //If within allowed paramaters if (i + Side*2 Down Left Vector //If within allowed paramaters if(i % Side > 1 && i + Side*2 Mid Left Vector //If within allowed parameters if(i % Side > 1) { if (Grid_ptr[i-1] == '?' && Grid_ptr[i-2] == '?') { WeightGrid_ptr[i-1] += 1; WeightGrid_ptr[i-2] += 1; } else if(Grid_ptr[i-1] == 'O') { WeightGrid_ptr[i-2] += 50; } else if(Grid_ptr[i-2] == 'O') { WeightGrid_ptr[i-1] += 50; } } //CHECK O --> Top Left Vector //If within allowed parameters if( (i) & (Side > 1) && i > Side*2) { if (Grid_ptr[i-Side-1] == '?' && Grid_ptr[i-Side*2-2] == '?') { WeightGrid_ptr[i-Side-1] += 1; WeightGrid_ptr[i-Side*2-2] += 1; } else if (Grid_ptr[i-Side-1] == 'O') { WeightGrid_ptr[i-Side*2-2] += 50; } else if (Grid_ptr[i-Side*2-2] == 'O') { WeightGrid_ptr[i-Side-1] += 50; } } //CHECK O --> Mid Top Vector //If within allowed parameters if (i > Side*2) { if(Grid_ptr[i + Side] == '?' && Grid_ptr[i + Side*2] == '?') { WeightGrid_ptr[i + Side] += 1; WeightGrid_ptr[i + Side*2] += 1; } else if(Grid_ptr[i + Side] == 'O') { WeightGrid_ptr[i + Side*2] += 50; } else if (Grid_ptr[i + Side*2] == 'O') { WeightGrid_ptr[i + Side] += 50; } } } } // end for scan 'X' 'O' //Get highest value from weightgrid, add an 'O' to that position, end method automatically for (USHORT q = 0; q *fattest_ptr) { *fattest_ptr = WeightGrid_ptr[q]; *fattestIndex_ptr = q; } } } Grid_ptr[*fattestIndex_ptr] = 'O'; //SAFE DELETE POINTER WeightGrid_ptr if (WeightGrid_ptr != NULL) { delete[] WeightGrid_ptr; WeightGrid_ptr = NULL; } //SAFE DELETE POINTER fattest_ptr if (fattest_ptr != NULL) { delete fattest_ptr; fattest_ptr = NULL; } //SAFE DELETE POINTER fattestIndex_ptr if (fattestIndex_ptr != NULL) { delete fattestIndex_ptr; fattestIndex_ptr = NULL; } } int _tmain(int argc, _TCHAR* argv[]) { //& adress off |-| &x = 0x? //* value pointed by |-| a = *b //Make the required variables on the heap USHORT GridHeight = 0; USHORT GridWidth = 0; USHORT GridSize = 0; USHORT moveCounter = 0; char currentMove; USHORT input; //bool* humanWin_ptr = new bool(false); //bool* computerWin_ptr = new bool(false); bool humanWin_ptr = false; bool computerWin_ptr = false; bool Draw = false; cout 2 && input 2 && input = GridSize) { Draw = true; cout
