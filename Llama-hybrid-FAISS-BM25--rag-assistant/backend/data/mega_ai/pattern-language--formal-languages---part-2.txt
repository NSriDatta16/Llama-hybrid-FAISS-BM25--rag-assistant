ite (hence also regular and context-free) language { 01, 10 } is not a pattern language. Each singleton language is trivially a pattern language, generated by a pattern without variables. Each pattern language can be produced by an indexed grammar: For example, using Σ = { a, b, c } and X = { x, y }, the pattern a x b y c x a y b is generated by a grammar with nonterminal symbols N = { Sx, Sy, S } ∪ X, terminal symbols T = Σ, index symbols F = { ax, bx, cx, ay, by, cy }, start symbol Sx, and the following production rules: An example derivation is: Sx[] ⇒ Sx[bx] ⇒ Sx[ax bx] ⇒ Sy[ax bx] ⇒ Sy[cy ax bx] ⇒ S[cy ax bx] ⇒ a x[cy ax bx] b y[cy ax bx] c x[cy ax bx] a y[cy ax bx] b ⇒ a x[ax bx] b y[cy ax bx] c x[cy ax bx] a y[cy ax bx] b ⇒ a a x[bx] b y[cy ax bx] c x[cy ax bx] a y[cy ax bx] b ⇒ a ab x[] b y[cy ax bx] c x[cy ax bx] a y[cy ax bx] b ⇒ a ab b y[cy ax bx] c x[cy ax bx] a y[cy ax bx] b ⇒ ... ⇒ a ab b c y[] c x[cy ax bx] a y[cy ax bx] b ⇒ a ab b c c x[cy ax bx] a y[cy ax bx] b ⇒ ... ⇒ a ab b c c ab x[] a y[cy ax bx] b ⇒ a ab b c c ab a y[cy ax bx] b ⇒ ... ⇒ a ab b c c ab a c y[] b ⇒ a ab b c c ab a c b In a similar way, an index grammar can be constructed from any pattern. Learning patterns Given a sample set S of strings, a pattern p is called descriptive of S if S ⊆ L(p), but not S ⊆ L(q) ⊂ L(p) for any other pattern q. Given any sample set S, a descriptive pattern for S can be computed by enumerating all patterns (up to variable renaming) not longer than the shortest string in S, selecting from them the patterns that generate a superset of S, selecting from them the patterns of maximal length, and selecting from them a pattern that is minimal with respect to ≤. Based on this algorithm, the class of pattern languages can be identified in the limit from positive examples. Notes == References ==