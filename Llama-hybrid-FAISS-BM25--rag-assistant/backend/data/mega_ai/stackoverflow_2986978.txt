[site]: stackoverflow
[post_id]: 2986978
[parent_id]: 2986951
[tags]: 
You can cast objects either up or down the type hierarchy; sometimes this is safe, and sometimes it isn't. If you attempt to cast a variable to an incompatible type (i.e. try to convince the compiler it's something it's not), you'll get a runtime exception (i.e. error). Going to a more general type (like changing an ActionListener into an Object ) is called upcasting, and is always safe, assuming the class you're casting to is one of the ancestors of your current class (and Object is an ancestor of everything in Java). Going to a more specific type (like casting from ActionListener to MySpecialActionListener ) only works if your object actually is an instance of the more specific type. So, in your case, it sounds like what you're trying to do is say that ConfirmFrame implements the interface ActionListener. I assume that that interface includes: public void actionPerformed( ActionEvent evt); And then here, in your implementation of that virtual method, you want to delegate the evt to whatever object o was passed into the constructor. The problem here is that Object doesn't have a method called actionPerformed ; only a more specialized class (in this case, an implementation of ActionListener like your ConfirmFrame class) would have it. So what you probably want is for that constructor to take an ActionListener instead of an Object . class ConfirmFrame extends JFrame implements ActionListener { JButton confirm = new JButton("Confirm"); JButton cancel = new JButton("Cancel"); ActionListener a; public ConfirmFrame(ActionListener a) { // Irrelevant code here add(confirm); add(cancel); this.a = a; } public void actionPerformed( ActionEvent evt) { a.actionPerformed(evt); } } Of course, more explanatory variable names than "o" or "a" would probably help you (and anyone else reading this) understand why you're passing an ActionListener into another ActionListener.
