e had something to show them! ... In a way it was ironic because we already had done the first example of what they were after; and second, they didn't pay much attention to it. Logic Theorist soon proved 38 of the first 52 theorems in chapter 2 of the Principia Mathematica. The proof of theorem 2.85 was actually more elegant than the proof produced laboriously by hand by Russell and Whitehead. Simon was able to show the new proof to Russell himself who "responded with delight". They attempted to publish the new proof in The Journal of Symbolic Logic, but it was rejected on the grounds that a new proof of an elementary mathematical theorem was not notable, apparently overlooking the fact that one of the authors was a computer program. Newell and Simon formed a lasting partnership, founding one of the first AI laboratories at the Carnegie Institute of Technology and developing a series of influential artificial intelligence programs and ideas, including the General Problem Solver, Soar, and their unified theory of cognition. Architecture The Logic Theorist is a program that performs logical processes on logical expressions. The Logic Theorist operates on the following principles: Expressions An expression is made of elements. There are two kinds of memories: working and storage. Each working memory contains a single element. The Logic Theorist usually uses 1 to 3 working memories. Each storage memory is a list representing a full expression or a set of elements. In particular, it contains all the axioms and proven logical theorems. An expression is an abstract syntax tree, each node being an element with up to 11 attributes. For example, the logical expression ¬ P → ( Q ∧ ¬ P ) {\displaystyle \neg P\to (Q\wedge \neg P)} is represented as a tree with a root element representing → {\displaystyle \to } . Among the attributes of the root element are pointers to the two elements representing the subexpressions ¬ P {\displaystyle \neg P} and Q ∧ ¬ P {\displaystyle Q\wedge \neg P} . Processes There are four kinds of processes, from the lowest to the highest level. Instruction: These are similar to assembly code. They may either perform a primitive operation on an expression in working memory, or perform a conditional jump to another instruction. An example is "put the right sub-element of working-memory 1 to working-memory 2" Elementary process: These are similar to subroutines. A sequence of instructions that can be called. Method: A sequence of elementary processes. There are 4 methods: substitution: given an expression, it attempts to transform it to a proven theorem or axiom by substitutions of variables and logical connectives. detachment: given expression B {\displaystyle B} , it attempts to find a proven theorem or axiom of form A → B ′ {\displaystyle A\to B'} , where B ′ {\displaystyle B'} yields B {\displaystyle B} after substitution, then attempts to prove A {\displaystyle A} by substitution. chaining forward: given expression A → C {\displaystyle A\to C} , it attempts to find for a proven theorem or axiom of form A → B {\displaystyle A\to B} , then attempt to prove B → C {\displaystyle B\to C} by substitution. chaining backward: given expression A → C {\displaystyle A\to C} , it attempts to find for a proven theorem or axiom of form B → C {\displaystyle B\to C} , then attempt to prove A → B {\displaystyle A\to B} by substitution. executive control method: This method applies each of the 4 methods in sequence to each theorem to be proved. Logic Theorist's influence on AI Logic Theorist introduced several concepts that would be central to AI research: Reasoning as search Logic Theorist explored a search tree: the root was the initial hypothesis, each branch was a deduction based on the rules of logic. Somewhere in the tree was the goal: the proposition the program intended to prove. The pathway along the branches that led to the goal was a proof – a series of statements, each deduced using the rules of logic, that led from th