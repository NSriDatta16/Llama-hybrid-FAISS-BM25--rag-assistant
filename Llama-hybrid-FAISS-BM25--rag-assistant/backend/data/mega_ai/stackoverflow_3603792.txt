[site]: stackoverflow
[post_id]: 3603792
[parent_id]: 3603519
[tags]: 
I had exactly the same idea as Jon Skeet : implement a wrapper around a T[] that provides random access by index, automatically handling the adjustment of indexed access for you. I threw together a quick implementation just now (skip ahead to the bottom of this answer for a short demo): public struct ArrayFragment : IList { private T[] _source; private int _start; private int _count; public ArrayFragment(T[] source, int start, int count) { if (source == null) { throw new ArgumentNullException("source"); } if (start = source.Length) { throw new ArgumentOutOfRangeException("start"); } if (count > source.Length - start) { throw new ArgumentOutOfRangeException("count"); } _source = source; _start = start; _count = count; } public T this[int index] { get { return _source[_start + index]; } } public int Count { get { return _count; } } public bool Contains(T value) { int index = Array.IndexOf(_source, value, _start, _count); return index != -1; } public void CopyTo(T[] destination, int index) { Array.Copy(_source, _start, destination, index, _count); } public int IndexOf(T value) { int index = Array.IndexOf(_source, value, _start, _count); return index != -1 ? index - _start : -1; } public IEnumerator GetEnumerator() { for (int i = 0; i members // that all throw a NotSupportedException #endregion } Here's a demo: int[] numbers = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; try { var fragment = new ArrayFragment (numbers, 2, 5); Console.WriteLine("Iterating using foreach: "); foreach (int number in fragment) { Console.WriteLine(number); } Console.WriteLine("Iterating using for: "); for (int i = 0; i Output: Iterating using foreach: 3 4 5 6 7 Iterating using for: 3 4 5 6 7 Index of 4: 1 Index of 1: -1 Index of 9: -1 Index of 7: 4
