[site]: stackoverflow
[post_id]: 1731793
[parent_id]: 1730649
[tags]: 
I like @iWerner's generator function idea. One small change to his code and it does what the question asked for. def readlines(filename): f = open(filename) # discard first lines that start with '#' for line in f: if not line.lstrip().startswith("#"): break yield line for line in f: yield line and use it like for line in readlines("data.txt"): # do things pass But here is a different approach. This is almost very simple. The idea is that we open the file, and get a file object, which we can use as an iterator. Then we pull the lines we don't want out of the iterator, and just return the iterator. This would be ideal if we always knew how many lines to skip. The problem here is we don't know how many lines we need to skip; we just need to pull lines and look at them. And there is no way to put a line back into the iterator, once we have pulled it. So: open the iterator, pull lines and count how many have the leading '#' character; then use the .seek() method to rewind the file, pull the correct number again, and return the iterator. One thing I like about this: you get the actual file object back, with all its methods; you can just use this instead of open() and it will work in all cases. I renamed the function to open_my_text() to reflect this. def open_my_text(filename): f = open(filename, "rt") # count number of lines that start with '#' count = 0 for line in f: if not line.lstrip().startswith("#"): break count += 1 # rewind file, and discard lines counted above f.seek(0) for _ in range(count): f.readline() # return file object with comment lines pre-skipped return f Instead of f.readline() I could have used f.next() (for Python 2.x) or next(f) (for Python 3.x) but I wanted to write it so it was portable to any Python. EDIT: Okay, I know nobody cares and I"m not getting any upvotes for this, but I have re-written my answer one last time to make it more elegant. You can't put a line back into an iterator. But, you can open a file twice, and get two iterators; given the way file caching works, the second iterator is almost free. If we imagine a file with a megabyte of '#' lines at the top, this version would greatly outperform the previous version that calls f.seek(0) . def open_my_text(filename): # open the same file twice to get two file objects # (We are opening the file read-only so this is safe.) ftemp = open(filename, "rt") f = open(filename, "rt") # use ftemp to look at lines, then discard from f for line in ftemp: if not line.lstrip().startswith("#"): break f.readline() # return file object with comment lines pre-skipped return f This version is much better than the previous version, and it still returns a full file object with all its methods.
