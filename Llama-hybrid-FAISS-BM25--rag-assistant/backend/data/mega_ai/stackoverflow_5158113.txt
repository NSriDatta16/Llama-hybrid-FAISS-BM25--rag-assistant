[site]: stackoverflow
[post_id]: 5158113
[parent_id]: 
[tags]: 
HDR, adaptive tone mapping and MSAA in GLSL

In an effort to teach myself OpenGL, I am working my way trough the 5th edition of the Superbible . I am currently trying to figure out how to combine HDR and MSAA (as described in chapter 9). For HDR, the book suggests a method for adaptive tone mapping that is based on calculating the average luminance for a 5x5 convolution filter for each fragment. For MSAA, the method used averages all samples by weights calculated from the sample distance. My attempt at combining both, found in the pastebin below, applies tone mapping to each sample then averages them to compute the final fragment color. Performance is (as one should perhaps have expected ?) terrible: at 25 lookups per sample, times 4 for 4xMSAA, I'm guessing the GPU spends much of its time looking up my FBO texture. Switching to the code path controlled by the use_HDR uniform in the code drops performance frop 400+fps to under 10 for a simple scene. My question is twofold: is this a sane method of performing tone mapping ? If not, what would you suggest ? how should MSAA and convolution based filters be combined ? I'm guessing I'll have this problem again for any filter that needs to look up neighboring texels, i.e. pretty much anything like bloom, blur, etc ? Code: #version 330 in Data { vec4 position; vec4 normal; vec4 color; vec2 texCoord; mat4 mvp; mat4 mv; } gdata; out vec4 outputColor; uniform sampler2DMS tex; uniform sampler1D lum_to_exposure; uniform samplerBuffer weights; uniform int samplecount; uniform bool use_HDR; vec4 tone_map(vec4 color, float exp) { return 1.0f - exp2(-color * exp); } const ivec2 tc_offset[25] = ivec2[](ivec2(-2, -2), ivec2(-1, -2), ivec2(0, -2), ivec2(1, -2), ivec2(2, -2), ivec2(-2, -1), ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1), ivec2(2, -1), ivec2(-2, 0), ivec2(-1, 0), ivec2(0, 0), ivec2(1, 0), ivec2(2, 0), ivec2(-2, 1), ivec2(-1, 1), ivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(-2, 2), ivec2(-1, 2), ivec2(0, 2), ivec2(1, 2), ivec2(2, 2)); void main() { ivec2 itexcoords = ivec2(floor(textureSize(tex) * gdata.texCoord)); float tex_size_x = textureSize(tex).x; float tex_size_y = textureSize(tex).y; outputColor = vec4(0.0f, 0.0f, 0.0f, 1.0f); // for each sample in the multi sample buffer... for (int i = 0; i
