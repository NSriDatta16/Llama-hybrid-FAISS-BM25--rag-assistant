[site]: stackoverflow
[post_id]: 2210146
[parent_id]: 2200787
[tags]: 
Preliminary Performance Analysis: Principal Observaton And Recommendation: It appears that this is a Data Warehouse (everything presented is consistent with a DW), and it has been implemented in a SQL Server OLTP database. Therefore, the best thing you could do would be to : 0. Re-implement it in a SQL Server OLAP Database: OLAP databases (or Analysis Services or SSAS) are much better suited for this kind of application and much better optimized for this kind of query. However, on the assumption that this would be far beyond the scope of your current intentions, I will proceed with lower impact recommendations. Preliminary Observations and Recommendations: these are necessarily preliminary as real performance analysis cannot be done on something this complex without at least an estimated query plan. In particular, although recommendations for possible improvements can be made, without the real data, or query plans based on the real data, it is impossible to tell which changes will actually make any real difference in performance. The basic problem that I see is that this very complex query is doing a lot of full-table scans and because of its complexity is almost effectively forcing these scans. Table scans can be very expensive, especially on large tables. However, if there is no effective way for SQL to pre-filter a table (that is, to eliminate 99% of the records via a test that does not require a join and can be applied to an index), then that is the most efficient choice that it has left. In that light, the following recommendations look at ways to remedy that situation: A. Make a SARGable [Created] column on the [vwLogSearchesCounty] View. Currently the [vwLogSearchesCounty] View defines its [Created] column like this: CAST(FLOOR(CAST(dbo.LogSearches.Created AS FLOAT)) AS DATETIME) AS Created The apparent reason for this is to allow the use of the BETWEEN operator on this column when searching for Date Ranges, without have to worry about the problems of time-of-day mismatches. However this has the side-effect of making this column non-SARGable, that is, not searchable via an index ("SARG" = "Search ARGument"). As the searches on this column are one of the few globally-fixed constraints (that is, something that can be searched on before doing joins) making it SARGable is one of your best oppurtunities for speeding up your queries. To make it SARGable, you need to do the following: Either remove the CAST(FLOOR(CAST(..))) function from the [Created] column or add a second column to the view without them (I will assume the later) like this: dbo.LogSearches.Created AS CreatedTime Change the Date-Range search in the view, as below, from AND v.Created BETWEEN @LowDate AND @HighDate to AND v.CreatedTime >= @LowDate AND v.CreatedTime Make sure that there is an Index on the original [Created] column. A clustered index would be best: CREATE CLUSTERED INDEX IX_LogSearches_Created ON [dbo].[LogSearches] (Created) (for more on correctly searching for dates and date ranges in SQL Server see here: http://www.sqlservercentral.com/Forums/Topic438717-338-1.aspx ) B. Make [LogSearchDimension_ID] column in the [LogSearchesDimensions] table Indexed. I do not know if this column is already indexed, but it should be as it is another of the very few globally-fixed constraints. Again, a clustered index would be best: CREATE CLUSTERED INDEX IX_LogSearchesDimensions_11 ON [dbo].[LogSearchesDimensions] ([LogSearchDimension_ID]) C. Make [State_code] column on the [State] table Indexed. Like (B) above, it may not be indexed, but your query would probably benefit if it was. D. Eliminate the explicit [County] and [State] tables from your query. It appears that the only reason that you are explicitly joining the [County] and [State] tables in your query is to get the [State_Code] column from the [State] table that is not included in the [vwLogSearchesCounty] view. Ideally, the optimizer would figure out that it could merge these two references to the [State] and [County] tables together and you could pick up that column for free. Unfortunately the optimizer often misses such things on more complex queries, and on my server it appears to be doing double work for this field. The best solution would be to just add the [State_code] column to the view and then eliminate the explicit [county] and [State] joins in your query. this additional colum should not affect the performance of any other queries that use the view but do not use this column (SQL Server 2005 and above). If you implement all four of these recommendations (including the CLUSTERED part) you should be able to elminate the table scans. At this time I see no other reasonable way to do so. More Desparate Recommendation: If all of this should fail to help you, I can only see one other relatively low-cost option, which is to turn your View [vwLogSearchesCounty], into an Indexed View. In particular, the Indexes that I mentioned above on [State_Code] and [Created]/[CreatedTime] should be reimplemented on the View (as well as any other important ones). This has the effect, not only of indexing important fields, but also of pre-aggregating the View and automatically maintaining that pre-aggregation. This also means that it will take up storage space, so if this view has a very large number of rows, that may be an issue for you.
