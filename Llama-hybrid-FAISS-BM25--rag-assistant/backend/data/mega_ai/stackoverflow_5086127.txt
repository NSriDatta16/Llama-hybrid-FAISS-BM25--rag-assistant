[site]: stackoverflow
[post_id]: 5086127
[parent_id]: 5086103
[tags]: 
Compilers are free to organise stack frames (assuming they even use stacks) any way they wish. They may do it for alignment reasons, or for performance reasons, or for no reason at all. You would be unwise to assume any specific order. If you hadn't invoked undefined behavior by overflowing the buffer, you probably never would have known, and that's the way it should be. A compiler can not only re-organise your variables, it can optimise them out of existence if it can establish they're not used. With the code: #include int main (void) { char bing[71]; int x = 7; bing[0] = 11; return 0; } Compare the normal assembler output: main: pushl %ebp movl %esp, %ebp andl $-16, %esp subl $80, %esp movl %gs:20, %eax movl %eax, 76(%esp) xorl %eax, %eax movl $7, (%esp) movb $11, 5(%esp) movl $0, %eax movl 76(%esp), %edx xorl %gs:20, %edx je .L3 call __stack_chk_fail .L3: leave ret with the insanely optimised: main: pushl %ebp xorl %eax, %eax movl %esp, %ebp popl %ebp ret Notice anything missing from the latter? Yes, there are no stack manipulations to create space for either bing or x . They don't exist. In fact, the entire code sequence boils down to: set return code to 0. return.
