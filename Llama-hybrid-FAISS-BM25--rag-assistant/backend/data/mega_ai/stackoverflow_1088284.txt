[site]: stackoverflow
[post_id]: 1088284
[parent_id]: 211216
[tags]: 
Equational Reasoning Haskell, being purely functional allows you to read an equal sign as a real equal sign (in the absence of non-overlapping patterns). This allows you to substitute definitions directly into code, and in terms of optimization gives a lot of leeway to the compiler about when stuff happens. A good example of this form of reasoning can be found here: http://www.haskell.org/pipermail/haskell-cafe/2009-March/058603.html This also manifests itself nicely in the form of laws or RULES pragmas expected for valid members of an instance, for instance the Monad laws: returrn a >>= f == f a m >>= return == m (m >>= f) >>= g == m >>= (\x -> f x >>= g) can often be used to simplify monadic code.
