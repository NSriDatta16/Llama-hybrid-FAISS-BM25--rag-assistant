[site]: crossvalidated
[post_id]: 606204
[parent_id]: 
[tags]: 
MCMC Python Code Question

I have a question about Python coding of a simple MCMC exercise. I wanted to visualize the transition matrix obtained from MCMC simulation. However, according to the following code, every entry is zero except one which has value 1. It means that the markov chain only visited a single state throughout the entire simulation, and thus my MCMC algorithm seems not working properly. So I was hoping if you guys could spot some mistake here. Thank you so much!! Below is my code: import numpy as np from scipy.stats import norm, invgamma # Set the true values of mu and sigma mu_true = 5.0 sigma_true = 2.0 # Generate some data n = 10000 data = np.random.normal(mu_true, sigma_true, n) # Set the prior distribution for mu and sigma mu_prior_mean = 0.0 mu_prior_std = 10.0 mu_prior = norm(mu_prior_mean, mu_prior_std) sigma_prior_shape = 2.0 sigma_prior_scale = 1.0 sigma_prior = invgamma(sigma_prior_shape, scale=sigma_prior_scale) # Number of Iterations for the MCMC algorithm n_iterations = 10000 # Set the initial values for mu and sigma mu_current = 0.0 sigma_current = 1.0 # Initialize the transition matrix n_states = 50 transition_matrix = np.zeros((n_states, n_states)) # Run the MCMC algorithm and record the transitions for i in range(n_iterations): # Generate proposal values for mu and sigma mu_proposal = np.random.normal(mu_current, 0.1) sigma_proposal = sigma_current * np.random.uniform(0.9, 1.1) # Calculate the likelihood of the data given the proposed values of mu and sigma likelihood_proposal = np.prod(norm.pdf(data, loc=mu_proposal, scale=sigma_proposal)) likelihood_current = np.prod(norm.pdf(data, loc=mu_current, scale=sigma_current)) # Calculate the prior probabilities of the proposed and current values of mu and sigma prior_proposal = mu_prior.pdf(mu_proposal) * sigma_prior.pdf(sigma_proposal) prior_current = mu_prior.pdf(mu_current) * sigma_prior.pdf(sigma_current) # Calculate the Metropolis-Hastings acceptance ratio acceptance_ratio = (likelihood_proposal * prior_proposal) / (likelihood_current * prior_current) # Accept or reject the proposed values of mu and sigma if acceptance_ratio >= 1 or np.random.uniform() = 0 and mu_index = 0 and sigma_index ```
