[site]: crossvalidated
[post_id]: 60814
[parent_id]: 21825
[tags]: 
While @whuber's excellent dynamic programming solution is well worth a read, its runtime is $\mathcal O(k^2m)$ with respect to total number of trials $m$ and the desired trial length $k$ whereas the matrix exponentiation method is $\mathcal O(k^3\log(m))$. If $m$ is much larger than $k$, the following method is faster. Both solutions consider the problem as a Markov chain with states representing the number of correct trials at the end of the string so far, and a state for achieving the desired correct trials in a row. The transition matrix is such that seeing a failure with probability $p$ sends you back to state 0, and otherwise with probability $1-p$ advances you to the next state (the final state is an absorbing state). By raising this matrix to the $n$th power, the value in the first row, and last column is the probability of seeing $k=8$ heads in a row. In Python: import numpy as np def heads_in_a_row(flips, p, want): a = np.zeros((want + 1, want + 1)) for i in range(want): a[i, 0] = 1 - p a[i, i + 1] = p a[want, want] = 1.0 return np.linalg.matrix_power(a, flips)[0, want] print(heads_in_a_row(flips=25, p=1.0 / 3.0, want=8)) yields 0.00187928367413 as desired.
