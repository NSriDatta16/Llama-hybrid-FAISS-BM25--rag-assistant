[site]: stackoverflow
[post_id]: 4757979
[parent_id]: 4757286
[tags]: 
Whenever possible avoid the const_cast , and here it is quite possible for any given type. Just create a helper function that takes the two arguments, composes the final value of the constant and use it in the initializer: // header file struct test { const type x; test( type const & a, type const & b ); }; // implementation file namespace { type compose( type const & arg1, type const & arg2 ) { // calculate the actual value here } } test::test(type const & a, type const & b) : x( compose(a,b) ) {} The cost of that is just writting a single free ( static or in an unnamed namespace) function in the implementation file, and the result it readable if you choose a proper name for the function. In your case: concatenate or concat would be good choices. While the use of const_cast in the example will not lead to undefined behavior, I would avoid it for personal reasons. Casts are cumbersome to write in C++ (compare with C or Java) for a reason: so that they will call the attention of the programmer: something weird is going on here! If you start sprinkling casts, then you will get used to seeing them, and they will become natural.
