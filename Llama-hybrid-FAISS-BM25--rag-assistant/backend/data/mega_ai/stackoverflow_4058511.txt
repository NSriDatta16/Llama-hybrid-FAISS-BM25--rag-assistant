[site]: stackoverflow
[post_id]: 4058511
[parent_id]: 4047234
[tags]: 
I've found another nice use-case for this today: you can await user interaction. For example, if one form has a button that opens another form: Form toolWindow; async void button_Click(object sender, EventArgs e) { if (toolWindow != null) { toolWindow.Focus(); } else { toolWindow = new Form(); toolWindow.Show(); await toolWindow.OnClosed(); toolWindow = null; } } Granted, this isn't really any simpler than toolWindow.Closed += delegate { toolWindow = null; } But I think it nicely demonstrates what await can do. And once the code in the event handler is non-trivial, await make programming much easier. Think about the user having to click a sequence of buttons: async void ButtonSeries() { for (int i = 0; i Sure, you could do this with normal event handlers, but it would require you to take apart the loop and convert it into something much harder to understand. Remember that await can be used with anything that gets completed at some point in the future. Here's the extension method Button.OnClick() to make the above work: public static AwaitableEvent OnClick(this Button button) { return new AwaitableEvent(h => button.Click += h, h => button.Click -= h); } sealed class AwaitableEvent { Action register, deregister; public AwaitableEvent(Action register, Action deregister) { this.register = register; this.deregister = deregister; } public EventAwaiter GetAwaiter() { return new EventAwaiter(this); } } sealed class EventAwaiter { AwaitableEvent e; public EventAwaiter(AwaitableEvent e) { this.e = e; } Action callback; public bool BeginAwait(Action callback) { this.callback = callback; e.register(Handler); return true; } public void Handler(object sender, EventArgs e) { callback(); } public void EndAwait() { e.deregister(Handler); } } Unfortunately it doesn't seem possible to add the GetAwaiter() method directly to EventHandler (allowing await button.Click; ) because then the method wouldn't know how to register/deregister that event. It's a bit of boilerplate, but the AwaitableEvent class can be re-used for all events (not just UI). And with a minor modification and adding some generics, you could allow retrieving the EventArgs: MouseEventArgs e = await button.OnMouseDown(); I could see this being useful with some more complex UI gestures (drag'n'drop, mouse gestures, ...) - though you'd have to add support for cancelling the current gesture.
