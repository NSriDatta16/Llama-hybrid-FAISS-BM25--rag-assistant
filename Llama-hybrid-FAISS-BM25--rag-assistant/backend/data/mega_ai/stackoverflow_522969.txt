[site]: stackoverflow
[post_id]: 522969
[parent_id]: 519881
[tags]: 
int[] somenumbers = getAnArrayOfSomenumbers(); int numbertoLookFor = getTheNumberToLookFor(); boolean arrayContainsNumber = new HashSet(Arrays.asList(somenumbers)) .contains(numbertoLookfor); It's fast, too. Oh - you wanted to find the nearest number? In that case: int[] somenumbers = getAnArrayOfSomenumbers(); int numbertoLookFor = getTheNumberToLookFor(); ArrayList l = new ArrayList ( Arrays.asList(somenumbers) ); Collections.sort(l); while(l.size()>1) { if(numbertoolookfor Oh - hang on: you were after a least squares solution? Collections.sort(l, new Comparator (){ public int compare(Integer o1, Integer o2) { return (o1-numbertoLookFor)*(o1-numbertoLookFor) - (o2-numbertoLookFor)*(o2-numbertoLookFor); }}); System.out.println("nearest number is" + l.get(0));
