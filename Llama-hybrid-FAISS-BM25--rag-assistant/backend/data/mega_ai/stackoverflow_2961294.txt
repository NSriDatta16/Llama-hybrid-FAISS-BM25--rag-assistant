[site]: stackoverflow
[post_id]: 2961294
[parent_id]: 2960826
[tags]: 
You can also use the hashCode of the operator and put it on a switch although this is not very "elegant" from the OOP perspective. This may work if you're not adding operators too often ( which I don't think you would ) So this should be enough: String op = "+"; switch( op.hashCode() ){ case ADD: r = a + b;break; case SUB: r = a - b;break; case TMS: r = a * b;break; case DIV: r = a / b;break; case MOD: r = a % b;break; case SLF: r = a > b;break; case AND: r = a & b;break; case OR: r = a | b;break; case XOR: r = a ^ b;break; default: out.print("Eerr!!!"); break; } And have AND defined as: private static final int ADD = 0x2b; Here's the complete running sample code: import static java.lang.System.out; class Evaluator { private static final int ADD = 0x2b; // + private static final int SUB = 0x2d; // - private static final int TMS = 0x2a; // * private static final int DIV = 0x2f; // / private static final int MOD = 0x25; // % private static final int SLF = 0x780; // > private static final int AND = 0x26; // & private static final int OR = 0x7c; // | private static final int XOR = 0x5e; // ^ private int r; private int a; private String op; private int b; private Evaluator( int a, String op, int b ) { this.a = a; this.op = op; this.b = b; } private Evaluator eval() { switch( op.hashCode() ){ case ADD: r = a + b;break; case SUB: r = a - b;break; case TMS: r = a * b;break; case DIV: r = a / b;break; case MOD: r = a % b;break; case SLF: r = a > b;break; case AND: r = a & b;break; case OR: r = a | b;break; case XOR: r = a ^ b;break; default: out.print("Eerr!!!"); break; } return this; } // For testing: public static int evaluate( int a, String op , int b ) { return new Evaluator(a, op, b).eval().r; } public static void main( String [] args ) { out.printf( " 1 + 2 = %d%n", evaluate( 1 ,"+" , 2 )); out.printf( " 1 - 2 = %d%n", evaluate( 1 ,"-" , 2 )); out.printf( " 1 * 2 = %d%n", evaluate( 1 ,"*" , 2 )); out.printf( " 1 / 2 = %d%n", evaluate( 1 ,"/" , 2 )); out.printf( " 1 %% 2 = %d%n", evaluate( 1 ,"%" , 2 )); out.printf( " 1 > 2 = %d%n", evaluate( 1 ,">>" , 2 )); out.printf( " 1 & 2 = %d%n", evaluate( 1 ,"&" , 2 )); out.printf( " 1 | 2 = %d%n", evaluate( 1 ,"|" , 2 )); out.printf( " 1 ^ 2 = %d%n", evaluate( 1 ,"^" , 2 )); } } And that's it. Runs very very fast ( I'm pretty sure a enum in in order ) From an OOP perspective I think Rahul answer would do, but if you want to get any serious with this you should use a parsers as Hank Gay suggest. p.s. Getting the hash code of a string is easy: System.out.println( "+".hashCode() ); I actually used this: public class HexHashCode { public static void main( String [] args ) { for( String s: args ) { System.out.printf("private final int %s = 0x%x; // %s\n",s,s.hashCode(), s ); } } } And run it with: java HexHashCode + - "*" / " >" "%" " " "==" "!=" "&" "|" "^"
