[site]: stackoverflow
[post_id]: 4148686
[parent_id]: 4148575
[tags]: 
The steps you describe aren't entirely clear, but here are several things that stand out: 1 - It's not your place to ask an object for its -retainCount to determine whether it's being used or not. You have no way of knowing (nor are you supposed to know or depend upon knowing) what else might have an interest in this object. 2 - You check for a valid object by seeing if the object pointer ("view" in your case) is valid (points to an object) or is nil. 3 - When creating a custom NSView subclass and instantiating a copy within your nib/xib, you need to drag an NSView instance out from the library, then set its class name to that of your subclass, otherwise Interface Builder is just creating an instance of NSView. I don't think this is your problem (see #4) but you didn't say this so it's another thing to check. 4 - When you send a message to nil, nothing is exactly what is supposed to happen, so it's likely your "view" pointer/outlet is nil. 5 - It's easy to confuse "an instance I created and referenced in a nib/xib" with "an instance I created at runtime". This happens frequently with those new to Cocoa. Are you absolutely positive that the instance of the object that holds the connection (named "view") is the same as the instance you're examining at runtime? For example, you create a controller class named MyController, instantiated it in your nib/xib (as a blue cube), wired it up, etc. Then at runtime, you instantiate a new MyController ([[MyController alloc] init]...) and tried to access its (nil) "view" outlet, which points to nothing because it's not the same instance as that in your nib/xib.
