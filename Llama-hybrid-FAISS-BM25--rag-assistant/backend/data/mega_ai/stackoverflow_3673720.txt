[site]: stackoverflow
[post_id]: 3673720
[parent_id]: 
[tags]: 
C++ template metaprogramming to create a boost::variant from a shared_ptr and a boost::static_visitor

As a personal exercise, I want to implement the visitor pattern using shared_ptr. I am familiar with Robert Martin's acyclic visitor paper but find the intrusive nature of the virtual accept() and necessary creation of an {X}Visitor class for each {X} class unpleasant. I like the boost::static_visitor class as it encapsulates all the logic locally without the necessity of {X}::accept() and {X}Visitor. What I am looking for is a hint (as I said, I'm doing this as an exercise) of how to create the template function function rip I mention below. I think it should be of the form: template boost::variant rip(U& p, boost::static_visitor sv) { if (T1 t1 = dynamic_cast (p)) return boost::variant (t1); ... and so on, splitting static_visitor return 0; // or throw an exception } Any hints or pointers to tutorials doing similar things would be appreciated. Thanks. #include #include #include #include #include #include struct Base {}; struct A : Base {}; struct B : Base {}; struct C : Base {}; typedef std::shared_ptr base_ptr; typedef boost::variant base_variant; struct variant_visitor : public boost::static_visitor { void operator()(A*, base_ptr) const {std::cout ". // base_variant rip(base_ptr&, variant_visitor) {...} // boost::apply_visitor(boost::bind(variant_visitor(), _1, b), rip(b, variant_visitor())); return EXIT_SUCCESS; }
