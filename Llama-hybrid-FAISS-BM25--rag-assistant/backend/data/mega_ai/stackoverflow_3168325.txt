[site]: stackoverflow
[post_id]: 3168325
[parent_id]: 3167914
[tags]: 
Early 80s, I was a kid and my family was fortunate enough to own a personal computer-- An "Apple II". Like many programmers, I got started as a kid because I wanted to create my own games. There was a BASIC language interpreter built in called Applesoft BASIC, but it was too slow to do any reasonable animation. The commercial games, at least I was told, were all written in assembly language. So there began the quest... to learn assembly language... which first meant learning MACHINE language... (the direct entry of hexidecimal numbers rather than three letter text codes representing microprocessor instructions). The Apple II used the 6502 microprocessor. The first thing you had to learn was the memory map, which was the range and purpose of each section of memory (RAM and ROM). Here is a link to the memory map of the Apple ][e: link text The black numbers on the left margin are the memory locations. Note it goes from $0000 to $FFFF. The 6502 could only address 16^4 = 65536 or 64k of memory. You can see the RAM ended at $BFFF. The $C000-$CFFF range would access any peripheral cards you placed in the computer. For example the disk drive controller would go in slot #6 and would show up at $C600. I felt really cool as a kid that I could reboot the system by typing $C600G which would execute ("G" for "Go") the disk controller re-boot routine in ROM. The space from $E000 to $FFFF was originally just ROM, but the Apple ][e ("e" for "enhanced") let you switch back and forth ("bank switch") and access that extra 8k of memory. Do you see the graphics and text areas of the memory map? That how you would display to the screen. In those days (pre-GUI) there was a "text" mode where programs in ROM would continually scan memory between $0400-$0800 (= 4*16*16 = 1024 byte locations each corresponding to a place on the screen). It would take whatever ASCII byte was stuffed there and turn it into a character on your monitor. Here is the 6502 instruction set which among other things allowed you to move bytes around: 6502 Instruction Set And to put it into context, here is a sub-routine from ROM which adds to floating point numbers called FADD: (full floating point routine collection here ) F46E: A5 F4 FADD LDA X2 F470: C5 F8 CMP X1 COMPARE EXP1 WITH EXP2. F472: D0 F7 BNE SWPALGN IF #,SWAP ADDENDS OR ALIGN MANTS. F474: 20 25 F4 JSR ADD ADD ALIGNED MANTISSAS. F477: 50 EA ADDEND BVC NORM NO OVERFLOW, NORMALIZE RESULT. F479: 70 05 BVS RTLOG OV: SHIFT M1 RIGHT, CARRY INTO SIGN F47B: 90 C4 ALGNSWP BCC SWAP SWAP IF CARRY CLEAR, * ELSE SHIFT RIGHT ARITH. F47D: A5 F9 RTAR LDA M1 SIGN OF MANT1 INTO CARRY FOR F47F: 0A ASL RIGHT ARITH SHIFT. F480: E6 F8 RTLOG INC X1 INCR X1 TO ADJUST FOR RIGHT SHIFT F482: F0 75 BEQ OVFL EXP1 OUT OF RANGE. F484: A2 FA RTLOG1 LDX #$FA INDEX FOR 6:BYTE RIGHT SHIFT. F486: 76 FF ROR1 ROR E+3,X F488: E8 INX NEXT BYTE OF SHIFT. F489: D0 FB BNE ROR1 LOOP UNTIL DONE. F48B: 60 RTS RETURN. Looking at the routine, the first four hex numbers before the colon are the memory address. So if you wanted to run the FADD routine directly, you'd type F46EG (again, the "G" for "go). The next two hex numbers, $A5 and $F4, are the instruction codes. If you look at the handy instruction set chart, you see that $A5 means "LDA" or load the accumulator. The accumulator was one of the three memory locations (each one byte) on the 6502 processor for you to do computations with (that was nice of them, eh?). The $A5 version of the LDA command meant that the memory location to load was from the so called "zero page" or first $FF bytes of RAM which were mostly reserved for system use (there were a few bytes free for programmer use. Again, that was so nice of them.) The $F4 is the memory location whose contents (one byte) will be transferred to the accumulator. The next line has the instruction $C5 or "CMP" command, again the zero page version, which then compares the contents of the accumulator with memory location $F8. So that's the lowest level known as "MACHINE LANGUAGE" and yes, we'd sometimes type in little programs or mess with memory for debugging purposes. The next few columns are more readable; you see the actual "LDA" and "CMP" commands and variables X1 and X2 which represent those memory locations. You also see Woz's comments on what the code is doing (comparing the exponents of two floats). This is known as "Assembly Language" and is what was actually typed in. After you typed it in your assembler would compile the byte codes. Well, I never did manage to create a reasonable game on the Apple ][ but I sure did learn a lot about programming trying!
