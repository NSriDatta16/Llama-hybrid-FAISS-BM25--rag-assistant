[site]: stackoverflow
[post_id]: 5476643
[parent_id]: 5472925
[tags]: 
I find that it is best to keep any fixtures I have in line with the current version of the code. So upon creating migration 0003 you do a data migration and a new dumpdata , replacing fixture 0002. When you create your data migration, make sure you do both forwards and backwards, that way you'll end up with the correct data when you migrate back to 0002. When you do the data migration, make sure you access all models through the orm object, otherwise you end up with errors similar to what you're already experiencing. If you want to actually run your django code with the old data (version 0002) for some reason, then your models need to match your database. That would mean checking out an appropriate version of the code using whatever code versioning you're using (git, hg, svn...). If you're trying to solve a problem "back in time" you probably want to branch at that point too. See also south's documentation comments on fixtures Here's an idea, inspired by that link above: "the best thing to do is to write a new migration to load the fixture in". What about loading your fixture (which you already have) from a migration, rather than loaddata . You would still need to create a data migration and use the orm object to manually load the data. You can make use of django's serialization functions , which is exactly what loaddata does . With respect to why loaddata uses the model version and not the database version: loaddata is a django management command , with no knowledge of what south is doing. Because of that, it needs to remain database agnostic and use django's ORM. You can always write your own management command if you need to do something more specific - potentially pulling out some of south's orm versioning, or doing a database specific loaddata that reads the schema directly from the database. I think the solution in the previous paragraph will be a lot less work though.
