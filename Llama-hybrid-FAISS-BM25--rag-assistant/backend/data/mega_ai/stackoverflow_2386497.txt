[site]: stackoverflow
[post_id]: 2386497
[parent_id]: 2386395
[tags]: 
Sounds like you should be using an Oracle Sequence instead - as already mentioned in my comment :) It will return unique numbers whenever calling NEXTVAL . If for some reason you cant' use a sequence, just perform an UPDATE on that row. Oracle will lock that row until you end your transaction ( COMMIT or ROLLBACK ) and all other updates will wait until the lock is released. EDIT : If transactions are not supported in ADO , you could also put that into an Oracle Procedure using an AUTONOMOUS_TRANSACTION : CREATE OR REPLACE PROCEDURE allocate_sequence_numbers( in_size IN max_value_table.val%TYPE, out_next_sequence_number OUT max_value_table.val%TYPE ) AS PRAGMA AUTONOMOUS_TRANSACTION; next_sequence_number max_value_table.val%TYPE; BEGIN UPDATE max_value_table SET val = val + in_size RETURNING val - in_size INTO out_next_sequence_number; COMMIT; END allocate_sequence_numbers; It will update your table to "allocate" the specified number of values, and return the first number of the sequence you allocated. The next application that calls it will receive the next sequence number. The UPDATE causes a lock on that row, so other calls have to wait for that lock to be released. By using COMMIT inside the AUTONOMOUS_TRANSACTION , the lock is released, while your own transaction will not be affected.
