[site]: stackoverflow
[post_id]: 2824964
[parent_id]: 2820263
[tags]: 
Ah, your edit clarifies things enough to warrant a new answer. Here it is: The whole reason a view model is called a "view model" is because it really is a model . Yes, it ususally doesn't get saved to disk (though it could), but it has all of the other aspects of a model: It stores user data, it is bound from a view, it has no references to the view, etc. In your case you have a collection of settings that you want to associate with each {user, widget} combination. This collection of settings needs to be persisted and available in each of your views. Conceptually this is a separate model object: It is not a widget, it is not a user, and it is not view-specific. Whether you call it a "view model" or simply a "model" is primarily a matter of terminology. However you want to classify it, let's call the object itself UserWidgetSettings . Somewhere you will have a backing store to which you will persist UserWidgetSettings objects. This may be in a local file, in the registry, or in the same database where your User and Widget objects are stored. For sake of discussion let's say you have them stored separately from the User and Widget objects, and have a class that persists them: public class UserWidgetSettings : DependencyObject // or INotifyPropertyChanged { public bool AutoScroll { get { return (bool)GetValue(AutoScrollProperty); } set { SetValue(AutoScrollPropery, value); } } public static readonly DependencyProperty AutoScrollProperty = DependencyProperty.Register("AutoScroll", typeof(bool), typeof(UserWidgetSettings)); ... more settings ... } public class UserWidgetSettingsStorage { public static readonly UserWidgetSettingsStorage Current = new UserWidgetSettingsStorage(); private Dictionary , WeakReference > _cache; public UserWidgetSettings GetSettings(User user, Widget widget) { ... code to retrieve settings from file, registry, etc ... } public void Savechanges() { ... code to iterate the cache and save back changes to UserWidgetSettings objects ... ... called on Application.OnExit and perhaps other times ... } } Now your ViewModels used by the views simply need a property to access the settings: public class SomeViewModel { public Widget Widget { get; set; } ... regular view model code ... public UserWidgetSettings UserSettings { get { return UserWidgetSettingsStorage.Current.GetSettings( MyApp.CurrentUser, Widget); } } } In your view, you can use the settings thusly: And your checkbox to control it looks like this: A side note: I've found that on average only about 20% of my views actually need their own view model. The rest can use common properties exposed by the model itself. If you find yourself creating a separate view model for every single view, something may be wrong. You may want to take a look and see if there are some things you're doing in the view model that would make as much or more sense to do in the model itself. Bottom line: Well-designed model objects can dramatically cut down on the amount of code in a WPF application.
