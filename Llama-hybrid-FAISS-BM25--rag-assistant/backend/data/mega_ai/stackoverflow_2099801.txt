[site]: stackoverflow
[post_id]: 2099801
[parent_id]: 2090121
[tags]: 
As far as I could tell, the issue with the previous code I posted is that the drop function of the droppable was getting called before the mouseup of the sortable, and since I rewrote the list the sortable was getting angry (for lack of better terms). That's somewhat a guess. Looking at the final code: var dropped = false; var templateHtml; $(document).ready(function(){ setSortable(); $("#droppable").droppable({ activeClass: 'active', hoverClass:'hovered', accept:".drop", drop:function(event,ui){ dropped = true; //alert(ui.draggable.text()); } }); }); function setSortable(){ $("#sortable").sortable({ stop:function(event,ui){ if(dropped){ $("#sortable").sortable('destroy').html(templateHtml); dropped = false; setSortable(); } } }); $("#sortable li").addClass("drop").bind('mousedown',function(){ templateHtml = $("#sortable").html(); }); } #sortable li{ clear:both; float:left; } #droppable { clear:both; height:300px; width:400px; background-color:#CCC; } #droppable.active { background-color:#CFC; } #droppable.hovered { background-color:#CCF; } One Two Three Four Five Six Drop Here Tons of quirks are involved here. I tried to save the #sortable html on the start event of sortable, but that get's called after all of the ui-css gets applied, and ended up placing list elements in crazy places. So, I needed to use the mousedown function on the LIs. The setSortable is in a function because the stop event rewrites the sortable, which is "recursive" I guess. Not sure the exact terminology here, but we can go with annoyingly confusing. Fortunately, the droppable's drop function gets called before the sortables stop function, so I was able to set a global "dropped" variable that was used to see if the element was dropped. I'm still surprised this wasn't easier to do, I thought jQuery would have functions to handle it a lot better. Perhaps I'm missing something?
