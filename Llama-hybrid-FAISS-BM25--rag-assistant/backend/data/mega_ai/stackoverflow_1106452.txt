[site]: stackoverflow
[post_id]: 1106452
[parent_id]: 512825
[tags]: 
I've implemented JavaScript HashMap which code can be obtained from http://github.com/lambder/HashMapJS/tree/master The keys and values can be arbitrary JavaScript objects. There aren't any requirements on objects used as keys or values. The mechanism is trivial. For every key there is generated a unique id (per HashMap instance). That id is injected to the key object under a high unlikely to collide field name ;) That id is then used to keying in the underlying baking standard JavaScript association object. Here is the code: /* ===================================================================== @license MIT @author Lambder @copyright 2009 Lambder. @end ===================================================================== */ var HashMap = function() { this.initialize(); } HashMap.prototype = { hashkey_prefix: " ", hashcode_field: " ", initialize: function() { this.backing_hash = {}; this.code = 0; }, /* Maps value to key, returning the previous association */ put: function(key, value) { var prev; if (key && value) { var hashCode = key[this.hashcode_field]; if (hashCode) { prev = this.backing_hash[hashCode]; } else { this.code += 1; hashCode = this.hashkey_prefix + this.code; key[this.hashcode_field] = hashCode; } this.backing_hash[hashCode] = value; } return prev; }, /* Returns value associated with given key */ get: function(key) { var value; if (key) { var hashCode = key[this.hashcode_field]; if (hashCode) { value = this.backing_hash[hashCode]; } } return value; }, /* Deletes association by given key. Returns true if the association existed, false otherwise */ del: function(key) { var success = false; if (key) { var hashCode = key[this.hashcode_field]; if (hashCode) { var prev = this.backing_hash[hashCode]; this.backing_hash[hashCode] = undefined; if(prev !== undefined) success = true; } } return success; } } //// Usage // Creation var my_map = new HashMap(); // Insertion var a_key = {}; var a_value = {struct: "structA"}; var b_key = {}; var b_value = {struct: "structB"}; var c_key = {}; var c_value = {struct: "structC"}; my_map.put(a_key, a_value); my_map.put(b_key, b_value); var prev_b = my_map.put(b_key, c_value); // Retrieval if(my_map.get(a_key) !== a_value){ throw("fail1") } if(my_map.get(b_key) !== c_value){ throw("fail2") } if(prev_b !== b_value){ throw("fail3") } // Deletion var a_existed = my_map.del(a_key); var c_existed = my_map.del(c_key); var a2_existed = my_map.del(a_key); if(a_existed !== true){ throw("fail4") } if(c_existed !== false){ throw("fail5") } if(a2_existed !== false){ throw("fail6") }
