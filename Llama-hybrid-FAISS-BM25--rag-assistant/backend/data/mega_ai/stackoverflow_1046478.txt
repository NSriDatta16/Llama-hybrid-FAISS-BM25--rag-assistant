[site]: stackoverflow
[post_id]: 1046478
[parent_id]: 1046278
[tags]: 
UPDATE You can do a simple trick - group the prefixes by their first digits into a dictionary and match the numbers only against the correct subset. I tested it with the following two LINQ statements assuming every prefix has at least three digis. const Int32 minimumPrefixLength = 3; var groupedPefixes = prefixes .GroupBy(p => p.Substring(0, minimumPrefixLength)) .ToDictionary(g => g.Key, g => g); var numberPrefixes = numbers .Select(n => groupedPefixes[n.Substring(0, minimumPrefixLength)] .First(n.StartsWith)) .ToList(); So how fast is this? 15.000 prefixes and 50.000 numbers took less than 250 milliseconds. Fast enough for two lines of code? Note that the performance heavily depends on the minimum prefix length (MPL), hence on the number of prefix groups you can construct. MPL Runtime ----------------- 1 10.198 ms 2 1.179 ms 3 205 ms 4 130 ms 5 107 ms Just to give an rough idea - I did just one run and have a lot of other stuff going on. Original answer I wouldn't care much about performance - an average desktop pc can quiete easily deal with database tables with 100 million rows. Maybe it takes five minutes but I assume you don't want to perform the task every other second. I just made a test. I generated a list with 15.000 unique prefixes with 5 to 10 digits. From this prefixes I generated 50.000 numbers with a prefix and additional 5 to 10 digits. List prefixes = GeneratePrefixes(); List numbers = GenerateNumbers(prefixes); Then I used the following LINQ to Object query to find the prefix of each number. var numberPrefixes = numbers.Select(n => prefixes.First(n.StartsWith)).ToList(); Well, it took about a minute on my Core 2 Duo laptop with 2.0 GHz. So if one minute processing time is acceptable, maybe two or three if you include aggregation, I would not try to optimize anything. Of course, it would be realy nice if the programm could do the task in a second or two, but this will add quite a bit of complexity and many things to get wrong. And it takes time to design, write, and test. The LINQ statement took my only seconds. Test application Note that generating many prefixes is really slow and might take a minute or two. using System; using System.Collections.Generic; using System.Diagnostics; using System.Linq; using System.Text; namespace Test { static class Program { static void Main() { // Set number of prefixes and calls to not more than 50 to get results // printed to the console. Console.Write("Generating prefixes"); List prefixes = Program.GeneratePrefixes(5, 10, 15); Console.WriteLine(); Console.Write("Generating calls"); List calls = Program.GenerateCalls(prefixes, 5, 10, 50); Console.WriteLine(); Console.WriteLine("Processing started."); Stopwatch stopwatch = new Stopwatch(); const Int32 minimumPrefixLength = 5; stopwatch.Start(); var groupedPefixes = prefixes .GroupBy(p => p.Substring(0, minimumPrefixLength)) .ToDictionary(g => g.Key, g => g); var result = calls .GroupBy(c => groupedPefixes[c.Number.Substring(0, minimumPrefixLength)] .First(c.Number.StartsWith)) .Select(g => new Call(g.Key, g.Sum(i => i.Duration))) .ToList(); stopwatch.Stop(); Console.WriteLine("Processing finished."); Console.WriteLine(stopwatch.Elapsed); if ((prefixes.Count p)) { Console.WriteLine(String.Format(" prefix={0}", prefix)); } Console.WriteLine("Calls"); foreach (Call call in calls.OrderBy(c => c.Number).ThenBy(c => c.Duration)) { Console.WriteLine(String.Format(" number={0} duration={1}", call.Number, call.Duration)); } Console.WriteLine("Result"); foreach (Call call in result.OrderBy(c => c.Number)) { Console.WriteLine(String.Format(" prefix={0} accumulated duration={1}", call.Number, call.Duration)); } } Console.ReadLine(); } private static List GeneratePrefixes(Int32 minimumLength, Int32 maximumLength, Int32 count) { Random random = new Random(); List prefixes = new List (count); StringBuilder stringBuilder = new StringBuilder(maximumLength); while (prefixes.Count !p.StartsWith(prefix) && !prefix.StartsWith(p))) { prefixes.Add(stringBuilder.ToString()); } } return prefixes; } private static List GenerateCalls(List prefixes, Int32 minimumLength, Int32 maximumLength, Int32 count) { Random random = new Random(); List calls = new List (count); StringBuilder stringBuilder = new StringBuilder(); while (calls.Count
