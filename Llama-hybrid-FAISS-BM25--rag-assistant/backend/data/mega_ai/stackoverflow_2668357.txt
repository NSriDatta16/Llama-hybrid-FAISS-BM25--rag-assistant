[site]: stackoverflow
[post_id]: 2668357
[parent_id]: 2668124
[tags]: 
It's possible - please ensure that the autofulush is on ( $|=1; ) as discussed here , or for that matter in "Perl Cookbook" (Chapter 7.12. Flushing Output). You also need to decouple the child process by "daemonizing" it - see Ether's answer to a different question for an example However, this is not reliable AND is subject to easy breakage due to HTTP timeouts. Therefore the proper solution to display a continuously changing output on a web page is to either: a. Simpler solution: Your CGI script prints to a temporary HTML file once in a while it takes that temp file, closes the HTML and copies the current latest version to some temp location visible from htdocs tree (e.g. that can be referenced by a client via a URL - say http://your_server/tmp/AYZ122.html your original CGI's produces an HTTP response redirecting to http://your_server/tmp/AYZ122.html after creating the very original version of the temp file and spawning off the child process. The temp HTML file in that location has a META REFRESH which instructs it to refresh itself every N seconds (say 10) and appropriate message/CSS for the user warning that the loading is in progress and please wait. b. Harder solution: Somewhat similar in that the main CGI script creates a "please wait" HTML page sent to the user, and launches a child process which writes a temp file. The temp file created by the child process, however, is not necessarily a whole HTML page, but some data file. The main HTML page created by original CGI script contains a loop which issues AJAX calls that retrieve the latest data (the retrieval process will read the temp file written by child process) and updates the HTML page according to latest data.
