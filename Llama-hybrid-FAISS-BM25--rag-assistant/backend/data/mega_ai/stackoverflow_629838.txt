[site]: stackoverflow
[post_id]: 629838
[parent_id]: 629638
[tags]: 
In XSLT 2.0 it would be rather easy with the new grouping functions. In XSLT 1.0 it's a little more complicated but this works: The heart of the matter is the long and ugly "descendants" variable, which looks for nodes after the current node that have a "depth" child greater than the current depth, but are not after another node that would have the same depth as the current depth (because if they were, they would be children of that node instead of the current one). BTW there is an error in your example result: "FLASH" should be a child of "MP3 PLAYERS" and not a sibling. EDIT In fact (as mentionned in the comments), in "pure" XSLT 1.0 this does not work for two reasons: the path expression uses generate-id() incorrectly, and one cannot use a "result tree fragment" in a path expression. Here is a correct XSLT 1.0 version of the "node" template (successfully tested with Saxon 6.5) that does not use EXSLT nor XSLT 1.1: Of course, one should factor the path expression that is repeated, but without the ability to turn "result tree fragments" into XML that can actually be processed, I don't know if it's possible? (writing a custom function would do the trick of course, but then it's much simpler to use EXSLT) Bottom line: use XSLT 1.1 or EXSLT if you can! 2nd Edit In order to avoid to repeat the path expression, you can also forget the test altogether, which will simply result in some empty that you can either leave in the result or post-process to eliminate.
