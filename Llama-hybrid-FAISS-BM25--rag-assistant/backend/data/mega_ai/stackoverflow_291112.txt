[site]: stackoverflow
[post_id]: 291112
[parent_id]: 290997
[tags]: 
No. There is no way to force code outside your control to not call something that is otherwise perfectly accessible. The best you can do is strongly discourage the practice in the documentation for the class. What are the consequences if a descendant calls the inherited method? If it means the program stops working, then so be it. The programmer who writes the descendant class will test the code, notice that it doesn't work, and then consult the documentation for the method to ensure that he's using it correctly (at which time he'll learn he isn't). You could take another approach. Instead of making the function virtual, and having descendants override it, provide a protected method-pointer property. type TGetFileImpl = procedure of object; TAncestor = class private FGetFile: TGetFileImpl; protected property GetFileImpl: TGetFileImpl write FGetFile write FGetFile; public procedure GetFile; // not virtual. end; TDescendant = class(TAncestor) private procedure SpecializedGetFile; public constructor Create; end; procedure TAncestor.GetFile; begin if Assigned(GetFileImpl) then GetFileImpl else begin // Do default implementation instead end; end; constructor TDescendant.Create; begin GetFileImpl := SpecializedGetFile; end; The base class provides a method pointer that descendants can assign to indicate they want their own special handling. If the descendant provides a value for that property, then the base class's GetFile method will use it. Otherwise, it will use the standard implementation. Define TGetFileImpl to match whatever the signature of GetFile will be.
