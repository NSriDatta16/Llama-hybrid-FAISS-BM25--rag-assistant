[site]: stackoverflow
[post_id]: 2180836
[parent_id]: 1518346
[tags]: 
a long time I wrote a Sudoku solver (several years ago, but I keep all the code I write). It hasn't been generalized to solve "bigger" size than the usual Sudoku, but it is pretty fast. It solves the following in 103 ms (on a Core 2 Duo 1.86 Ghz) and really hasn't been optimized: {0,0,0,0,7,0,9,4,0}, {0,7,0,0,9,0,0,0,5}, {3,0,0,0,0,5,0,7,0}, {0,8,7,4,0,0,1,0,0}, {4,6,3,0,0,0,0,0,0}, {0,0,0,0,0,7,0,8,0}, {8,0,0,7,0,0,0,0,0}, {7,0,0,0,0,0,0,2,8}, {0,5,0,2,6,8,0,0,0}, How fast is yours and on which board is it slow? Are you sure you're not constantly revisiting path that shouldn't be revisited? Here's the meat of the algo: private static void solveRec( final IPlatform p ) { if (p.fullBoardSolved()) { solved = p; return; } boolean newWayTaken = false; for (int i = 0; i s = p.avail(i / 3, j /3); for (Iterator it = s.iterator(); it.hasNext();) { final Byte b = it.next(); if (!p.columnContains(j, b) && !p.lineContains(i, b)) { final IPlatform ptemp = duplicateChangeOne(p, b, i, j); solveRec(ptemp); if (solved != null) { return; } } } } } } } And the IPlatform abstraction (please be nice, it was written a lot of years ago, before I knew that in Java adding 'I' before interface names wasn't all the rage): public interface IPlatform { byte getByteAt(int i, int j); boolean lineContains(int line, int value); boolean columnContains(int column, int value); Set avail(int i, int j); boolean fullBoardSolved(); }
