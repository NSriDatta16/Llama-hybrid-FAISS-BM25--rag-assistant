[site]: stackoverflow
[post_id]: 3068306
[parent_id]: 
[tags]: 
Concatenation of CLOB datatypes in a LOOP in PL/SQL

I am trying to concatenate clobs in a PL/SQL loop and it has been returning null whilst when using DBMS_OUTPUT prints out the loop values and when executing each result of the clobs gives an output as well. The system is meant to execute an already stored SQL in a table based on the report name passed into it. This particular report has many report names; hence the concatenation of each of the reports. The arguments passed are the report name, version of the report you're interested in, the kind of separator you want, and an argument list for the unknowns in the SQL if any. There are also two main types of SQL; 1 that needs the table_name be replaced with a temp table_name and another that needs an ID be appended to a table_name in the SQL. please find below the code for the REPREF1 function. CREATE OR REPLACE FUNCTION REPREF1(P_VER IN VARCHAR2 DEFAULT 'LATEST', P_SEPARATOR IN VARCHAR2 DEFAULT ', ', P_ARGLIST IN VAR DEFAULT NULL) RETURN CLOB IS L_CLOB CLOB; FUNCTION GET_CLOB(P_REPNAM IN VARCHAR2, P_VER IN VARCHAR2 DEFAULT 'LATEST', P_SEPARATOR IN VARCHAR2 DEFAULT ', ', P_ARGLIST IN VAR DEFAULT NULL) RETURN CLOB IS --------------------------------------------------------------------------------- -- TITLE - GET_CLOB beta - b.0 DATE 2010Mar12 -- -- DESCRIPTION - A function that return a report based on the report name put in -- -- USAGE - select get_clob(p_repnam,p_ver, p_separator, var(varay(val_1,...val_n), varay(val_1,...val_n))) FROM dual ----------------------------------------------------------------------------------------------------------------------------- V_SQL VARCHAR2(32767); L_RESULT CLOB; V_TITLE VARCHAR2(4000); V_REPDATE VARCHAR2(30); V_CNT NUMBER(2); V_NUMARG NUMBER(3); V_CDCRU NUMBER(3); V_BCNT NUMBER(3); V_NEWTABDAT VARCHAR2(30); V_NEWTABLIN VARCHAR2(30); L_COLLIST VARAY; V_VER VARCHAR2(6); N PLS_INTEGER; V_CNTTAB NUMBER(3); -- EXEC_SQL_CLOB FUNCTION EXEC_SQL_CLOB(P_SQL IN VARCHAR2, P_NUMARG IN NUMBER, P_COLLIST IN VARAY DEFAULT NULL, P_ARGLIST IN VARAY DEFAULT NULL, P_SEPARATOR IN VARCHAR2 DEFAULT '') RETURN CLOB IS ------------------------------------------------------------------------------------------------------ -- TITLE - EXEC_SQL_CLOB beta - b.0 DATE 2010Mar22 -- -- DESCRIPTION - A function that returns a clob value after executing the sql query that is passed into it -- -- USAGE - select exec_sql_clob(p_sql, p_numarg, var(varay(val_1, val_2,...val_n), varay(val_1, val_2,...val_n))) FROM dual --------------------------------------------------------------------------------------------------------------- L_CUR INTEGER DEFAULT DBMS_SQL.OPEN_CURSOR; L_STATUS INTEGER; V_COL VARCHAR2(4000); L_RESULT CLOB; L_COLCNT NUMBER DEFAULT 0; L_SEPARATOR VARCHAR2(10) DEFAULT ''; V_NUMARG NUMBER(3); BEGIN -- parse the query for the report DBMS_SQL.PARSE(L_CUR, P_SQL, DBMS_SQL.NATIVE); -- whilst it is not more than 255 per line FOR I IN 1 .. 255 LOOP BEGIN -- define each column in the select list DBMS_SQL.DEFINE_COLUMN(L_CUR, I, V_COL, 2000); L_COLCNT := I; EXCEPTION WHEN OTHERS THEN IF (SQLCODE = -1007) THEN EXIT; ELSE RAISE; END IF; END; END LOOP; -- If query has no bind variables IF (P_ARGLIST IS NULL) THEN IF (P_NUMARG = 0) THEN -- Execute the query in the cursor L_STATUS := DBMS_SQL.EXECUTE(L_CUR); LOOP -- Exit loop when fetch is complete EXIT WHEN(DBMS_SQL.FETCH_ROWS(L_CUR) 0) THEN -- Check if the number of arguments are the same IF (P_NUMARG = V_NUMARG) THEN -- Replace the bind variables in the query FOR J IN 1 .. P_ARGLIST.COUNT LOOP DBMS_SQL.BIND_VARIABLE(L_CUR, P_COLLIST(J), P_ARGLIST(J)); END LOOP; -- Execute the query in the cursor L_STATUS := DBMS_SQL.EXECUTE(L_CUR); LOOP -- Exit loop when fetch is complete EXIT WHEN(DBMS_SQL.FETCH_ROWS(L_CUR) 0) THEN -- Store the SQL statement, title and number of arguments of the report name passed. SELECT REPCODE, REPTITLE, NUMARG, COLLIST INTO V_SQL, V_TITLE, V_NUMARG, L_COLLIST FROM REPVER R, REPORT B WHERE UPPER(REPNAM) = UPPER(P_REPNAM) AND B.REPREF = R.REPREF AND VER = V_VER; V_REPDATE := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI'); L_RESULT := V_TITLE || ' (' || P_REPNAM || ' version ' || V_VER || ') generated ' || V_REPDATE || CHR(13) || CHR(13); -- Check for some specific type of queries SELECT COUNT(*) INTO V_CDCRU FROM REPVER R, REPORT B WHERE CTDDATA = 'Y' AND UPPER(REPNAM) = UPPER(P_REPNAM) AND B.REPREF = R.REPREF AND VER = V_VER; SELECT COUNT(*) INTO V_BCNT FROM REPVER R, BODCREPS B WHERE BENLIST = 'Y' AND UPPER(REPNAM) = UPPER(P_REPNAM) AND B.REPREF = R.REPREF AND VER = V_VER; IF (V_CDCRU > 0) THEN V_NEWTABDATA := 'CT_' || 'DAT_' || P_ARGLIST(1) (P_ARGLIST(1).FIRST); V_NEWTABLINK := 'CT_' || 'LIN_' || P_ARGLIST(1) (P_ARGLIST(1).FIRST); -- Check if the tables exist SELECT COUNT(*) INTO V_CNTTAB FROM ALL_TABLES WHERE TABLE_NAME = V_NEWTABDAT OR TABLE_NAME = V_NEWTABLIN AND OWNER = 'SCOTT'; IF (V_CNTTAB > 0) THEN V_SQL := UPPER(V_SQL); V_SQL := REPLACE(V_SQL, 'CT_DAT_CRU', V_NEWTABDAT); V_SQL := REPLACE(V_SQL, 'CT_LIN_CRU', V_NEWTABLIN); ELSE V_SQL := 'SELECT ''THE TABLE NOT CREATED YET'' FROM DUAL'; END IF; END IF; IF (V_BCNT > 0) THEN V_SQL := UPPER(V_SQL); V_SQL := REPLACE(V_SQL, 'LIST', P_ARGLIST(1) (P_ARGLIST(1).LAST)); END IF; IF (P_ARGLIST IS NULL) THEN -- execute the query L_RESULT := L_RESULT || EXEC_SQL_CLOB(V_SQL, V_NUMARG, L_COLLIST, NULL, P_SEPARATOR); ELSE N := P_ARGLIST.COUNT; -- execute the query L_RESULT := L_RESULT || EXEC_SQL_CLOB(V_SQL, V_NUMARG, L_COLLIST, P_ARGLIST(N), P_SEPARATOR); END IF; RETURN L_RESULT; ELSE RAISE_APPLICATION_ERROR(-20012, P_REPNAM || ' or ' || P_VER || ' DOES NOT EXIST '); END IF; END GET_CLOB; BEGIN FOR I IN (SELECT REPNAM FROM REPORT WHERE REPREF NOT IN ('R01', 'R02', 'R03', 'R04')) LOOP SELECT CONCAT_CLOB(GET_CLOB(I.REPNAM, P_VER, P_SEPARATOR, P_ARGLIST)) INTO L_CLOB FROM DUAL; DBMS_OUTPUT.PUT_LINE(I.REPNAM); -- DBMS_OUTPUT.PUT_LINE (COUNT(i.REPNAM)); END LOOP; RETURN L_CLOB; END REPREF1; / Cheers, Tunde Many thanks APC for making the code look better. @Robert, the last loop in the code returns null even with the CONCAT_CLOB aggregate function that concatenates clobs. FOR I IN (SELECT REPNAM FROM REPORT WHERE REPREF NOT IN ('R01', 'R02', 'R03', 'R04')) LOOP SELECT CONCAT_CLOB(GET_CLOB(I.REPNAM, P_VER, P_SEPARATOR, P_ARGLIST)) INTO L_CLOB FROM DUAL; DBMS_OUTPUT.PUT_LINE(I.REPNAM); END LOOP; when I try this, FOR I IN (SELECT REPNAM FROM REPORT WHERE REPREF NOT IN ('R01', 'R02', 'R03', 'R04')) LOOP L_CLOB := L_CLOB || CHR(13) || GET_CLOB(I.REPNAM, P_VER, P_SEPARATOR, P_ARGLIST); DBMS_OUTPUT.PUT_LINE(I.REPNAM); END LOOP; It also gives null; but this time the dbms output for the repnam are not complete.
