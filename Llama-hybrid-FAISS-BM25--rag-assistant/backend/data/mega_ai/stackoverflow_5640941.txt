[site]: stackoverflow
[post_id]: 5640941
[parent_id]: 
[tags]: 
Is it necessary to use GC::KeepAlive in C++/CLI when the managed handle is held in a managed container (IList )?

I'm confused about when I need to use KeepAlive in my C++/CLI wrapper code and how lifetimes are handled in it. Consider the following code and note the places where I ask whether KeepAlive is needed. // convert from managed to native string inline std::string ToStdString(String^ source) { if (String::IsNullOrEmpty(source)) return std::string(); int len = ((source->Length+1) * 2); /*** Do I need GC::KeepAlive(source) here? ***/ char *ch = new char[ len ]; bool result ; { pin_ptr wch = PtrToStringChars( source ); result = wcstombs( ch, wch, len ) != -1; } std::string target = ch; delete ch; if(!result) throw gcnew Exception("error converting System::String to std::string"); return target; } // convert from native to managed string inline String^ ToSystemString(const std::string& source) { return gcnew String(source.c_str()); } // unmanaged C++ class struct NativeDog { std::string name; std::string bark() const {return "woof";} void eat(std::string& food) const {food.clear();} }; typedef shared_ptr NativeDogPtr; // C++/CLI wrapper class ref class ManagedDog { NativeDogPtr* base_; NativeDog& base() {return **base_;} ManagedDog() {base_ = new NativeDogPtr(new NativeDog);} ~ManagedDog() {if (base_) delete base_;} !ManagedDog() {delete this;} property String^ name { String^ get() {return ToSystemString(base().name);} void set(String^ name) { base().name = ToStdString(name); /*** Do I need GC::KeepAlive(name) here? ***/ } } String^ bark() {return ToSystemString(base().bark());} void eat(String^ food) { std::string nativeFood = ToStdString(food); base().eat(nativeFood); food = ToSystemString(nativeFood); /*** Do I need GC::KeepAlive(food) here? ***/ } }; // unmanaged C++ class struct NativeKennel { vector dogs; }; // C++/CLI wrapper class ref class ManagedKennel { NativeKennel* base_; NativeKennel& base() {return *base_;} IList ^ dogs; void addDog(ManagedDog^ dog) { base().dogs.push_back(*dog->base_); dogs->Add(dog); /*** Do I need GC::KeepAlive(dog) here? Will the IList manage the ManagedDog lifetimes? ***/ } };
