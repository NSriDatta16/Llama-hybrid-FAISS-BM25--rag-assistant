[site]: stackoverflow
[post_id]: 3088480
[parent_id]: 3088217
[tags]: 
You can use the Report Definition Language. My method was a bit of hack but it does the job and without the need of third party assemblies. Drag a report viewer control ( http://msdn.microsoft.com/en-us/library/ms251670(VS.80).aspx ) on to your designer. Go to the markup and wrap the report viewer in a div element with the style.display attribute set to none. You can then programmatically generate the Excel file (in my example I outputted a PDF and needed to perform impersonation because the outfile was written to a Doc server): Dim aa As AliasAccount = New AliasAccount("ASP.NET", "Uiop_4567") ' Begin Impersonation aa.BeginImpersonation() iRetVal = ExportCoverLetter() If iRetVal = 0 Then Dim bytes() As Byte = report.Render( _ "PDF", Nothing, sMimeType, sEncoding, sFileNameExtension, _ sStreamids, warnings) Using fs As FileStream = New FileStream(sApplicationPath, FileMode.Create) fs.Write(bytes, 0, bytes.Length) End Using ' End of Impersonation aa.EndImpersonation() ' success Return 0 Else Return -1 End If Once the file is generated you need to output it somehow. I used a AjaxControlKit.Modal Pop Up Extender. I tied the TargetControlID property to a hidden button and set the PopUpControlID to a asp panel which display a link saying View PDF: View PDF When the user clicks View PDF it pops up a new window. The Document Path can be passed in via query string or session. In the new window obtain the Document Path, clear the HTTPContext buffer, change the content type and attach the file. Private Function SendPDFToClient(ByVal sPDFfilePath As String, ByVal sFileName As String, ByRef oReturnException As System.Exception) As Integer ' variables Dim oMethodBase As MethodBase = MethodBase.GetCurrentMethod() Dim METHOD_NAME As String = oMethodBase.DeclaringType.ToString() & "." & oMethodBase.Name.ToString() Try Dim aa As AliasAccount = New AliasAccount("ASP.NET", "Uiop_4567") ' Begin Impersonation aa.BeginImpersonation() Dim fs As System.IO.FileStream Dim br As System.IO.BinaryReader fs = New System.IO.FileStream(sPDFfilePath, System.IO.FileMode.Open) br = New System.IO.BinaryReader(fs) Dim oByteArray As Byte() = br.ReadBytes(fs.Length - 1) br.Close() ' End of Impersonation aa.EndImpersonation() lblHiddenFileExist.Text = "File Exist=" & System.IO.File.Exists(sPDFfilePath) & ControlChars.NewLine _ & " ByteArray Length=" & oByteArray.Length().ToString() HttpContext.Current.Response.Buffer = True HttpContext.Current.Response.Clear() HttpContext.Current.Response.ClearContent() HttpContext.Current.Response.ClearHeaders() HttpContext.Current.Response.ContentType = "application/pdf" HttpContext.Current.Response.AddHeader("Content-Disposition", "attachment;filename=" & sFileName) HttpContext.Current.Response.BinaryWrite(oByteArray) HttpContext.Current.Response.Flush() HttpContext.Current.Response.Close() ' success Return 0 Catch exThreadAbort As Threading.ThreadAbortException ' do nothing Catch ex As Exception ' failure ex.Data.Add("METHOD_NAME", METHOD_NAME) oReturnException = ex Return -1 End Try End Function The end result is a window prompting the user if they want to save or open the document. Hope this helps.
