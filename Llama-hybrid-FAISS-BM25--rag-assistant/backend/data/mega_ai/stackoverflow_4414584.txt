[site]: stackoverflow
[post_id]: 4414584
[parent_id]: 4414054
[tags]: 
Best practice is to not use auto_ptr . It will be deprecated in C++0x and replaced by std::unique_ptr (Reference: C++0x Draft Standard, Appendix D, Paragraph 10). In the meantime, alternatives include std::tr1::shared_ptr and boost::scoped_ptr . But your example is an array, and those pointer types are not for arrays. You can use boost::shared_array for that. However the Standard itself does not have array smart pointers. Thatâ€™s probably because they believe you should be using std::vector instead (or std::array for fixed size arrays when you know the size at compile time). Given that, you could do the following: std::vector dataVector; data.reserve(123); // or, if the size is always 123: std::tr1::array dataArray; Now, you can call your function that accepts a regular plain-old uint32* because both vector s and std::tr1::array s have methods to give you access to the data as a pointer to a C-style array: processData(&dataVector[0]); processData(dataArray.data()); I would strongly recommend adding bounds-checking if you are going to do this. Pass a second argument to processData with the size of the array: processData(&dataVector[0], dataVector.size()); And if you can abandon C-style pointer/arrays entirely, a better way might be to pass by reference: void processData(std::vector & data) { // process the data } // call it like this: processData(dataVector); But this only works for vector s, not std::tr1::array s or any other container. So, taking it one step further, you could use a template that accepts iterators: template void processData(AnIterator begin, AnIterator end) { for (AnIterator it = begin; it != end; ++it) { // process each item } } // call it like this processData(dataVector.begin(), dataVector,end()); // or like this processData(dataArray.begin(), dataArray.end()); // or even like this (assume c_data is a C-style array): processData(c_data, c_data + number_of_items_in_c_data); The last one works because pointers to C-style arrays can be used as iterators.
