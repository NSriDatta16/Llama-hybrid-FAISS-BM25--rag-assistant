[site]: stackoverflow
[post_id]: 194207
[parent_id]: 44965
[tags]: 
First: The term monad is a bit vacuous if you are not a mathematician. An alternative term is computation builder which is a bit more descriptive of what they are actually useful for. They are a pattern for chaining operations. It looks a bit like method chaining in object-oriented languages, but the mechanism is slightly different. The pattern is mostly used in functional languages (especially Haskell which uses monads pervasively) but can be used in any language which support higher-order functions (that is, functions which can take other functions as arguments). Arrays in JavaScript support the pattern, so let’s use that as the first example. The gist of the pattern is we have a type ( Array in this case) which has a method which takes a function as argument. The operation supplied must return an instance of the same type (i.e. return an Array ). First an example of method chaining which does not use the monad pattern: [1,2,3].map(x => x + 1) The result is [2,3,4] . The code does not conform to the monad pattern, since the function we are supplying as an argument returns a number, not an Array. The same logic in monad form would be: [1,2,3].flatMap(x => [x + 1]) Here we supply an operation which returns an Array , so now it conforms to the pattern. The flatMap method executes the provided function for every element in the array. It expects an array as result for each invocation (rather than single values), but merges the resulting set of arrays into a single array. So the end result is the same, the array [2,3,4] . (The function argument provided to a method like map or flatMap is often called a "callback" in JavaScript. I will call it the "operation" since it is more general.) If we chain multiple operations (in the traditional way): [1,2,3].map(a => a + 1).filter(b => b != 3) Results in the array [2,4] The same chaining in monad form: [1,2,3].flatMap(a => [a + 1]).flatMap(b => b != 3 ? [b] : []) Yields the same result, the array [2,4] . You will immediately notice that the monad form is quite a bit uglier than the non-monad! This just goes to show that monads are not necessarily “good”. They are a pattern which is sometimes beneficial and sometimes not. Do note that the monad pattern can be combined in a different way: [1,2,3].flatMap(a => [a + 1].flatMap(b => b != 3 ? [b] : [])) Here the binding is nested rather than chained, but the result is the same. This is an important property of monads as we will see later. It means two operations combined can be treated the same as a single operation. The operation is allowed to return an array with different element types, for example transforming an array of numbers into an array of strings or something else; as long as it still an Array. This can be described a bit more formally using Typescript notation. An array has the type Array , where T is the type of the elements in the array. The method flatMap() takes a function argument of the type T => Array and returns an Array . Generalized, a monad is any type Foo which has a "bind" method which takes a function argument of type Bar => Foo and returns a Foo . This answers what monads are. The rest of this answer will try to explain through examples why monads can be a useful pattern in a language like Haskell which has good support for them. Haskell and Do-notation To translate the map/filter example directly to Haskell, we replace flatMap with the >>= operator: [1,2,3] >>= \a -> [a+1] >>= \b -> if b == 3 then [] else [b] The >>= operator is the bind function in Haskell. It does the same as flatMap in JavaScript when the operand is a list, but it is overloaded with different meaning for other types. But Haskell also has a dedicated syntax for monad expressions, the do -block, which hides the bind operator altogether: do a This hides the "plumbing" and lets you focus on the actual operations applied at each step. In a do -block, each line is an operation. The constraint still holds that all operations in the block must return the same type. Since the first expression is a list, the other operations must also return a list. The back-arrow looks deceptively like an assignment, but note that this is the parameter passed in the bind. So, when the expression on the right side is a List of Integers, the variable on the left side will be a single Integer – but will be executed for each integer in the list. Example: Safe navigation (the Maybe type) Enough about lists, lets see how the monad pattern can be useful for other types. Some functions may not always return a valid value. In Haskell this is represented by the Maybe -type, which is an option that is either Just value or Nothing . Chaining operations which always return a valid value is of course straightforward: streetName = getStreetName (getAddress (getUser 17)) But what if any of the functions could return Nothing ? We need to check each result individually and only pass the value to the next function if it is not Nothing : case getUser 17 of Nothing -> Nothing Just user -> case getAddress user of Nothing -> Nothing Just address -> getStreetName address Quite a lot of repetitive checks! Imagine if the chain was longer. Haskell solves this with the monad pattern for Maybe : do user This do -block invokes the bind-function for the Maybe type (since the result of the first expression is a Maybe ). The bind-function only executes the following operation if the value is Just value , otherwise it just passes the Nothing along. Here the monad-pattern is used to avoid repetitive code. This is similar to how some other languages use macros to simplify syntax, although macros achieve the same goal in a very different way. Note that it is the combination of the monad pattern and the monad-friendly syntax in Haskell which result in the cleaner code. In a language like JavaScript without any special syntax support for monads, I doubt the monad pattern would be able to simplify the code in this case. Mutable state Haskell does not support mutable state. All variables are constants and all values immutable. But the State type can be used to emulate programming with mutable state: add2 :: State Integer Integer add2 = do -- add 1 to state x 9 The add2 function builds a monad chain which is then evaluated with 7 as the initial state. Obviously this is something which only makes sense in Haskell. Other languages support mutable state out of the box. Haskell is generally "opt-in" on language features - you enable mutable state when you need it, and the type system ensures the effect is explicit. IO is another example of this. IO The IO type is used for chaining and executing “impure” functions. Like any other practical language, Haskell has a bunch of built-in functions which interface with the outside world: putStrLine , readLine and so on. These functions are called “impure” because they either cause side effects or have non-deterministic results. Even something simple like getting the time is considered impure because the result is non-deterministic – calling it twice with the same arguments may return different values. A pure function is deterministic – its result depends purely on the arguments passed and it has no side effects on the environment beside returning a value. Haskell heavily encourages the use of pure functions – this is a major selling point of the language. Unfortunately for purists, you need some impure functions to do anything useful. The Haskell compromise is to cleanly separate pure and impure, and guarantee that there is no way that pure functions can execute impure functions, directly or indirect. This is guaranteed by giving all impure functions the IO type. The entry point in Haskell program is the main function which have the IO type, so we can execute impure functions at the top level. But how does the language prevent pure functions from executing impure functions? This is due to the lazy nature of Haskell. A function is only executed if its output is consumed by some other function. But there is no way to consume an IO value except to assign it to main . So if a function wants to execute an impure function, it has to be connected to main and have the IO type. Using monad chaining for IO operations also ensures that they are executed in a linear and predictable order, just like statements in an imperative language. This brings us to the first program most people will write in Haskell: main :: IO () main = do putStrLn ”Hello World” The do keyword is superfluous when there is only a single operation and therefore nothing to bind, but I keep it anyway for consistency. The () type means “void”. This special return type is only useful for IO functions called for their side effect. A longer example: main = do putStrLn "What is your name?" name This builds a chain of IO operations, and since they are assigned to the main function, they get executed. Comparing IO with Maybe shows the versatility of the monad pattern. For Maybe , the pattern is used to avoid repetitive code by moving conditional logic to the binding function. For IO , the pattern is used to ensure that all operations of the IO type are sequenced and that IO operations cannot "leak" to pure functions. Summing up In my subjective opinion, the monad pattern is only really worthwhile in a language which has some built-in support for the pattern. Otherwise it just leads to overly convoluted code. But Haskell (and some other languages) have some built-in support which hides the tedious parts, and then the pattern can be used for a variety of useful things. Like: Avoiding repetitive code ( Maybe ) Adding language features like mutable state or exceptions for delimited areas of the program. Isolating icky stuff from nice stuff ( IO ) Embedded domain-specific languages ( Parser ) Adding GOTO to the language.
