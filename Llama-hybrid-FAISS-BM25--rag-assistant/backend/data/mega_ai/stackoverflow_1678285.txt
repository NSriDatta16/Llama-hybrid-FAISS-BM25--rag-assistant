[site]: stackoverflow
[post_id]: 1678285
[parent_id]: 1677621
[tags]: 
The straight-forward translation. type Vector3D = (Double, Double, Double) class Shape shape where name :: shape -> String position :: shape -> Vector3D data Sphere = Sphere { sphereName :: String, spherePosition :: Vector3D, sphereRadius :: Double } data Prism = Prism { prismName :: String, prismPosition :: Vector3D, prismDimensions :: Vector3D } instance Shape Sphere where name = sphereName position = spherePosition instance Shape Prism where name = prismName position = prismPosition You usually wouldn't do this, though; it's repetitious and polymorphic lists require language extensions. Instead, sticking them into a single closed datatype is probably the first solution you should go for. type Vector3D = (Double, Double, Double) data Shape = Sphere { name :: String, position :: Vector3D, radius :: Double } | Prism { name :: String, position :: Vector3D, dimensions :: Vector3D } You can certainly simulate multiple levels of inheritance by creating more typeclasses: class (Shape shape) => Prism shape where dimensions :: Vector3D data RectangularPrism = ... data TriangularPrism = ... instance Prism RectangularPrism where ... instance Prism TriangularPrism where ... You can also simulate it by embedding datatypes. type Vector3D = (Double, Double, Double) data Shape = Shape { name :: String, position :: Vector3D } data Sphere = Sphere { sphereToShape :: Shape, radius :: Double } newSphere :: Vector3D -> Double -> Shape newSphere = Sphere . Shape "Sphere" data Prism = Prism { prismToShape :: Shape, dimensions :: Vector3D } data RectangularPrism = RectangularPrism { rectangularPrismToPrism :: Prism } newRectangularPrism :: Vector3D -> Vector3D -> RectangularPrism newRectangularPrism = (.) RectangularPrism . Prism . Shape "RectangularPrism" data TriangularPrism = TriangularPrism { triangularPrismToPrism :: Prism } newTriangularPrism :: Vector3D -> Vector3D -> TriangularPrism newTriangularPrism = (.) TriangularPrism . Prism . Shape "TriangularPrism" But simulating OO in Haskell is not anywhere near as satisfying as actually thinking in a Haskellish way. What are you trying to do? (Also note that all of these solutions only permit upcasts, downcasting is unsafe and disallowed.)
