[site]: stackoverflow
[post_id]: 1150975
[parent_id]: 1150739
[tags]: 
For the sake of having a unified storage in AllocatableActivity, I would have an abstract base class for Allocation and all resource types, like this: public abstract class Resource { public string Description { get; } } public class AllocatableResource where TResource : Resource { ... } public abstract class Allocation { protected Allocation( Resource resource, TActivity activity, TimeQuantity period) { this.Resource = resource; this.Activity = activity; this.Period = period; } public virtual Resource Resource { get; protected set; } public TActivity Activity { get; protected set; } public TimeQuantity Period { get; protected set; } } public class Allocation : Allocation where TActivity : AllocatableActivity where TResource : AllocatableResource { public new TResource Resource { get; private set; } public Allocation( TResource resource, TActivity activity, DateTime eventDate, TimeQuantity timeSpent) : base(resource, activity, timeSpent) { ... } } Now, in AllocatableActivity, you can store all Allocations in a polymorphic fashion, like this: public class AllocatableActivity { protected readonly IDictionary > _allocations; public virtual void ClockIn ( DateTime eventDate, TResource resource, TimeQuantity timeSpent) where TResource : Resource { var entry = new Allocation ( resource, this, eventDate, timeSpent); if (_allocations.ContainsKey(eventDate)) { Check.Require(_allocations[eventDate].Resource.Equals(resource), "This method requires that the same resource is the resource in this allocation."); _allocations[eventDate] = entry; } else _allocations.Add(eventDate, entry); } } The reason why I added a base Resource class is that you'll undoubtedly need to list resources in your application somewhere, so there should be some sort of commonality.
