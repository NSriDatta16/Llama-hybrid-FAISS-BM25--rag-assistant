[site]: stackoverflow
[post_id]: 4975891
[parent_id]: 4975779
[tags]: 
This does not mean what you think: fun funkyPlus 3 = (fn x => fn y => x*x*y)3 It defines a function which takes an argument that must be 3, and which evaluates to its RHS if it is 3 and is undefined otherwise. What you mean to say is this: If we only provide an argument for x, we have the following: funkyPlus 3 → (fn x => fn y => x*x+y) 3 and so forth. Secondly, there is an error in your foldl : fun foldl f b [] = b|foldl f b (h::t) = foldl f f(h,b) t; ^^^^^ Type clash: expression of type 'a * 'b cannot have type 'c list This is because (h,b) is parsed as the third argument to foldl and not as the argument to f . Parenthesize it: fun foldl f b [] = b|foldl f b (h::t) = foldl f (f(h,b)) t; > val ('a, 'b) foldl = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b Now, getting to your question, ML can tell us that an expression like foldl add would have type int -> int list -> int . But in general, it may help to realize that function application is entirely mechanical. If we have these two definitions: fun foldl f b [] = b | foldl f b (h::t) = foldl f (f(h,b)) t; add (x,y) = x + y; then var example = foldl add would be equivalent to this: fun example b [] = b | example b (h::t) = example (h::t) (add(h,b)) t; All that’s been done is that add has been substituted for f in the body of foldl , nothing more (although I have taken the liberty of replacing foldl add with example in the body).
