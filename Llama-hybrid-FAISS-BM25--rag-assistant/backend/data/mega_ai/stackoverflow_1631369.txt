[site]: stackoverflow
[post_id]: 1631369
[parent_id]: 
[tags]: 
Generated methods for polynomial evaluation

I'm trying to come up with an elegant way to handle some generated polynomials. Here's the situation we'll focus on (exclusively) for this question: order is a parameter in generating an n th order polynomial, where n:=order + 1. i is an integer parameter in the range 0..n The polynomial has zeros at x_j, where j = 1..n and j ≠ i (it should be clear at this point that StackOverflow needs a new feature or it's present and I don't know it) The polynomial evaluates to 1 at x_i. Since this particular code example generates x_1 .. x_n, I'll explain how they're found in the code. The points are evenly spaced x_j = j * elementSize / order apart, where n = order + 1 . I generate a Func to evaluate this polynomial¹. private static Func GeneratePsi(double elementSize, int order, int i) { if (order order) throw new ArgumentException("i", "i cannot be greater than order"); ParameterExpression xp = Expression.Parameter(typeof(double), "x"); // generate the terms of the factored polynomial in form (x_j - x) List factors = new List (); for (int j = 0; j product * (j == i ? 1.0 : (j * elementSize / order - xi))); /* generate an expression to evaluate * (x_0 - x) * (x_1 - x) .. (x_n - x) / (x_i - x) * obviously the term (x_i - x) is cancelled in this result, but included here to make the result clear */ Expression expr = factors.Skip(1).Aggregate(factors[0], Expression.Multiply); // multiplying by scale forces the condition f(x_i)=1 expr = Expression.Multiply(Expression.Constant(1.0 / scaleInv), expr); Expression > lambdaMethod = Expression.Lambda >(expr, xp); return lambdaMethod.Compile(); } The problem: I also need to evaluate ψ′=dψ/dx. To do this, I can rewrite ψ=scale×(x_0 - x)(x_1 - x)×..×(x_n - x)/(x_i - x) in the form ψ=α_n×x^n + α_n×x^(n-1) + .. + α_1×x + α_0. This gives ψ′=n×α_n×x^(n-1) + (n-1)×α_n×x^(n-2) + .. + 1×α_1. For computational reasons, we can rewrite the final answer without calls to Math.Pow by writing ψ′=x×(x×(x×(..) - β_2) - β_1) - β_0. To do all this "trickery" (all very basic algebra), I need a clean way to: Expand a factored Expression containing ConstantExpression and ParameterExpression leaves and basic mathematical operations (end up either BinaryExpression with the NodeType set to the operation) - the result here can include InvocationExpression elements to the MethodInfo for Math.Pow which we'll handle in a special manner throughout. Then I take the derivative with respect to some specified ParameterExpression . Terms in the result where the right hand side parameter to an invocation of Math.Pow was the constant 2 are replaced by the ConstantExpression(2) multiplied by what was the left hand side (the invocation of Math.Pow(x,1) is removed). Terms in the result that become zero because they were constant with respect to x are removed. Then factor out the instances of some specific ParameterExpression where they occur as the left hand side parameter to an invocation of Math.Pow . When the right hand side of the invocation becomes a ConstantExpression with the value 1 , we replace the invocation with just the ParameterExpression itself. ¹ In the future, I'd like the method to take a ParameterExpression and return an Expression that evaluates based on that parameter. That way I can aggregate generated functions. I'm not there yet. ² In the future, I hope to release a general library for working with LINQ Expressions as symbolic math.
