[site]: stackoverflow
[post_id]: 814865
[parent_id]: 814819
[tags]: 
An m-way tree is a tree structure that has m values and m + 1 links. A binary tree is a special case of an m-way tree with m equal to one, meaning only one value per node and two links (you either move down to the left or the right link). Here's an example of a binary tree that shows this: +----+ | 20 | +----+ / \ +----+ +----+ | 14 | | 23 | +----+ +----+ An m-way tree can have more than one value per node but the theory is still the same. You choose which link to move down to based on the values, and there's m + 1 possible choices. An m-way tree (where m is 2) may look like this: +----+----+ | 17 | 30 | +----+----+ ______/ | \______ / | \ +----+----+ +----+----+ +----+----+ | 11 | 15 | | 19 | 28 | | 33 | 34 | +----+----+ +----+----+ +----+----+ These m-way trees are often used in situations where you can fit more than one value in an efficient block. By efficient, I mean one that can be read and written efficiently, like a disk block, sector, cluster or cylinder depending on how your storage subsystem operates. For example, let's say that: a disk block is 512 bytes; the values in your tree take up 122 bytes; and the links take up 4 bytes. In this situation, you can fit 4 values into a disk block, calculated as follows: numvals = int ((blocksize - linksize) / (valuesize + linksize)) = int (( 512 - 4 ) / ( 122 + 4 )) = int ( 508 / 126 ) = int ( 4.0317 ) = 4 That gives you four values and five links for a total of 508 bytes: 4 * 122 = 488 5 * 4 = 20 --- 508 Although there's some wastage (four bytes in this case), this has the advantage of storing an integral number of values in each efficiently-retrievable block.
