[site]: stackoverflow
[post_id]: 5124583
[parent_id]: 5123688
[tags]: 
Just define an iterator that does what you want: template struct source { virtual source & operator++(void) = 0; virtual T operator*(void) = 0; virtual bool atend() = 0; }; struct source_exhausted { }; template bool operator==(const source & comparand, const source_exhausted&) { return comparand.atend(); } template bool operator!=(const source & comparand, const source_exhausted&) { return !comparand.atend(); } template bool operator==(const source_exhausted&, const source & comparand) { return comparand.atend(); } template bool operator!=(const source_exhausted&, const source & comparand) { return !comparand.atend(); } template struct source_iterator : source { iterT m_iter; endT m_end; source_iterator(iterT iter, endT end) : m_iter(iter), m_end(end) {} virtual source & operator++(void) { ++m_iter; return *this; } virtual T operator*(void) { return *m_iter; } virtual bool atend() { return m_iter == m_end; } }; template auto make_source_iterator(iterT iter, endT end) -> source_iterator { return source_iterator (iter, end); } template auto make_source_iterator(TContainer& c) -> source_iterator { return source_iterator (c.begin(), c.end()); } template struct source_transformer : source { source & m_src; TXform const m_f; source_transformer( source & src, TXform f ) : m_f(f), m_src(src) {} virtual source & operator++(void) { ++m_src; return *this; } virtual TOut operator*(void) { return m_f(*m_src); } virtual bool atend() { return m_src.atend(); } }; template auto make_source_transformer(source & src, TXform f) -> source_transformer { return source_transformer (src, f); }
