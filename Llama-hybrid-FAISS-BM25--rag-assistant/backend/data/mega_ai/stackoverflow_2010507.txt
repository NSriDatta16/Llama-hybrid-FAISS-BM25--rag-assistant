[site]: stackoverflow
[post_id]: 2010507
[parent_id]: 2010132
[tags]: 
Using an N bit integer to represent N booleans is a special case of the data structure known as a perfect hash table . Notice you're explicitly using dicts (which are general hash tables) in the idea that prompted you to think about bitsets. It's a hash table because you use hashes to find a value, and it's perfect because you never have collisions. The special case is because of how the table is packed and stored. Formulate the hash function, which shows how it's different from an array: int bitset_hash(int n) { // domain of this function is only non-negative ints return 1 Notice bitset_hash(3) is 0b1000, which corresponds to the 4th item (offset/index 3) when using a C int and bitwise operations. (Because of the storage implementation detail, bitwise operations are also used to manipulate a specific item from the hash.) Extending the approach to use bitwise-and/-or/-xor for set operations is common , and doesn't require any special name other than "set operations" or, if you need a buzzword, "set theory". Finally, here's another example use of it in a prime sieve (I've used this code on Project Euler solutions): class Sieve(object): def __init__(self, stop): self.stop = stop self.data = [0] * (stop // 32 // 2 + 1) self.len = 1 if stop >= 2 else 0 for n in xrange(3, stop, 2): if self[n]: self.len += 1 for n2 in xrange(n * 3, stop, n * 2): self[n2] = False def __getitem__(self, idx): assert idx >= 2 if idx % 2 == 0: return idx == 2 int_n, bit_n = divmod(idx // 2, 32) return not bool(self.data[int_n] & (1 = 2 and idx % 2 != 0 assert value is False int_n, bit_n = divmod(idx // 2, 32) self.data[int_n] |= (1
