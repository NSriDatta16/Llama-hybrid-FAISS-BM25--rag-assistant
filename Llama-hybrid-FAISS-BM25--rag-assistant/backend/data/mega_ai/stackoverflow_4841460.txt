[site]: stackoverflow
[post_id]: 4841460
[parent_id]: 4838357
[tags]: 
I found a fairly simple solution that is very low on computing power. It involves giving a proximity score for each gap. to calculate the proximity score for gap i, I simply sum 1 / {dist(gap_i, gap_j)+1} for all j!=i I stuck a +1 to avoid division by zero. this way if two values are almost equal they will get a score of 1, and this score heads to 0 as the gap increases but if Gap j is almost exactly twice gap i, it should also be considered as close proximity. so I first get the closest integer to gap_j/gap_i (maybe have to swap so that gap_j is bigger), then divide gap_j by this integer, and then consider dist(gap_i, fiddled_gap_j) if for example gap_j ~= 2*gap_i, Then I am careful to boost the score for Gap_i, and not gap_j this works very well to get a reasonably accurate candidate. a couple more processing passes should refine the value quite easily. the first I guess would be to average out values in light of the successful candidate. and then maybe a second that creates a harmonicity(f) function, and uses some sort of Newton-Raphson process starting at the previously calculated point to isolate the local maximum. anyway, fwiw here is the code: float ascertain_f0(PEAK * peaks, POTENTIAL_HARMONIC * pH, int phCount) { int gaps = phCount; // enumerate GAPS GAP gap [ MAX_POTENTIAL_HARMONICS ]; gap[0].len = peaks[pH[0].peakQ].freq; for (int i=1; i B_) continue; // a gap[best].score) best = i; return gap[best].len; }
