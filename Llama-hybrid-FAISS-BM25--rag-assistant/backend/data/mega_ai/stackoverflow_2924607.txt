[site]: stackoverflow
[post_id]: 2924607
[parent_id]: 2924440
[tags]: 
In this case you don't need to mock getaddrinfo , rather, you need to test without relying on its functionality. Both Patrick and Noah have good points but you have at least two other options: Option 1: Subclass to Test Since you already have your object in a class, you can subclass to test. For example, assume the following is your actual class: class DnsClass { int lookup(...); }; int DnsClass::lookup(...) { return getaddrinfo(...); } Then, for testing, you would subclass like this: class FailingDnsClass { int lookup(...) { return 42; } }; You can now use the FailingDnsClass subclass to generate errors but still verify that everything behaves correctly when an error condition occurs. Dependency Injection is often your friend in this case. NOTE: This is quite similar to Patrick's answer but doesn't (hopefully) involve changing the production code if you aren't already setup for dependency injection. Option 2: Use a link seam In C++, you also have link-time seams which Michael Feathers describes in Working Effectively with Legacy Code . The basic idea is to leverage the linker and your build system. When compiling the unit tests, link in your own version of getaddrinfo which will take precedence over the system version. For example: test.cpp: #include #include #include #include int main(void) { int retval = getaddrinfo(NULL, NULL, NULL, NULL); std::cout lib.cpp: #include #include #include int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res ) { return 42; } And then for testing: $ g++ test.cpp lib.cpp -o test $ ./test RV:42
