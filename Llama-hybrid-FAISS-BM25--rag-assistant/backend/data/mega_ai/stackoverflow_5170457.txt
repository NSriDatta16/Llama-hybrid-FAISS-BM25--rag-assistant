[site]: stackoverflow
[post_id]: 5170457
[parent_id]: 
[tags]: 
Using .NET to verify a digital signature generate with Java CXF/WSS4J application - Namespace issue?

Cliff Notes Digital signatures generated by .NET validate with .NET and Java WSS4J, signatures generated by Java WSS4J do not validate with .NET but validate with Java. Possibly (?) caused by XML namespaces generated in WSS4J. The Meat of the Question I have the following method that verifies digital signatures in SOAP XML: public static bool VerifySignature(XmlDocument soap, bool verifySignatureOnly, bool verifyUsername) { // Create namespace manager needed for xpath selections XmlNamespaceManager soapNamespaces = GetSoapNamespaces(soap.NameTable); // Use xPath constants to get binary security token string inputb64BinarySecurityToken = soap.SelectSingleNode(SxpBinarySecurityToken, soapNamespaces).InnerText; // Get public key from the binary security token string var certificate = new X509Certificate2(Convert.FromBase64String(inputb64BinarySecurityToken)); // Get signature element var signature = soap.SelectSingleNode(SxpSignatureElement, soapNamespaces) as XmlElement; // Load into SignedXml, verify and return var xml = new SignedXml(soap); xml.LoadXml(signature); return xml.CheckSignature(certificate, verifySignatureOnly); } I have the following methods that generates digitial signatures private static void PerformSoapSecurity(XmlDocument soapDom, XmlNamespaceManager soapNamespaces, string certificateThumbprint) { X509Certificate2 certificate = GetDigitalCertificate(certificateThumbprint); long certId = GenerateCertificateId(certificate); //Cerate Soap BinarySecurityToken Element XmlDocumentFragment securityToken = soapDom.CreateDocumentFragment(); securityToken.InnerXml = GetBinarySecurityToken(certId, GetDigitalCertificate(certificateThumbprint)); // Create Soap Signature Element // Here passing in the whole Xml document to 'GetSignature' // means the generated signature element doesn't need to // be imported into the dom before inserting] XmlElement signature = GetSignature(soapDom, certificate); //Create Soap Key Info Element XmlDocumentFragment keyinfo = soapDom.CreateDocumentFragment(); keyinfo.InnerXml = GetKeyInfo(certId); //Append the created elemnts into the Soap message ***the order here IS important*** soapDom.SelectSingleNode(SxpSecurityElement, soapNamespaces).AppendChild(securityToken); soapDom.SelectSingleNode(SxpSecurityElement, soapNamespaces).AppendChild(signature); soapDom.SelectSingleNode(SxpSignatureElement, soapNamespaces).AppendChild(keyinfo); // Assign the subject CN of the signing certificate as the user name (removing CN= prefix) soapDom.SelectSingleNode(SxpUsername, soapNamespaces).InnerText = certificate.Subject.Remove(0, 3); } private static XmlElement GetSignature(XmlDocument document, X509Certificate2 dsigCertificate) { Reference reference = new Reference("#Timestamp-1"); reference.AddTransform(new XmlDsigExcC14NTransform()); var signed = new SignedXmlWithId(document); signed.SigningKey = dsigCertificate.PrivateKey; signed.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl; signed.AddReference(reference); signed.ComputeSignature(); XmlElement signatureElement = signed.GetXml(); return signatureElement; } And this is the method I use to create my XmlNamespaceManager : private static XmlNamespaceManager GetSoapNamespaces(XmlNameTable nameTable) { XmlNamespaceManager soapNamespaces = new XmlNamespaceManager(nameTable); soapNamespaces.AddNamespace("soap", "http://schemas.xmlsoap.org/soap/envelope/"); soapNamespaces.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#"); soapNamespaces.AddNamespace("wsse", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"); soapNamespaces.AddNamespace("wsu", "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"); soapNamespaces.AddNamespace("addressing", "http://www.w3.org/2005/08/addressing"); return soapNamespaces; } Now, all this works fine I can generate SOAP XML with a signature and then verify that signature within .NET and Java. For example if I sign the following: 2011-03-02T10:51:18.178Z 2011-03-02T11:06:18.178Z I get: eC4H+inxmOWEAYTBAZCwcnK4tUA= --- SIGNATURE BASE64 ---- However my application also receives messages from a Java application that uses CXF and WSS4J . The code posted above is unable to verify the signatures that I receive from the Java app. If I use Java to sign the Timestamp XML fragment posted above I get a different signature to the one generated in .NET. Having spent some time looking into this it seems that this may be related to XML namespaces on the signature XML. As an example Java sends the following: eC4H+inxmOWEAYTBAZCwcnK4tUA= --- SIGNATURE BASE64 ---- The obvious difference here is the the usage of the "ds" namespace. If you look closer the DigestValues are the same so canonicalisation and hashing is working correctly. However the output signature is different. Curiously if I alter the Java signature to remove the ds namespace and put my .NET generated signature into SignatureValue then the signature validates. So it seems that SignedXml is stripping the namespaces and then using the sans-namespace XML to check the signature. Having spent some time looking at System.Security.Cryptography.Xml.SignedXml (which underpins all this) I cannot find a way to control how this handles namespaces. I have a feeling that it ignores/removes them (which is why when I generate a Signature with .NET the result does not contain namespaces) from the input XML which will of course invalidate the signature. So the question is, does anybody know what could possibly be going wrong here? It is worth mentioning that I cannot change the Java application in anyway.
