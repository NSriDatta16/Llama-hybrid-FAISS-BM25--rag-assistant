[site]: stackoverflow
[post_id]: 2697760
[parent_id]: 2697137
[tags]: 
According to Vijay's solution the implementation will be: Type* array; // to initialize the array array = new Type(size_of_array); // when you want to add values array[0] = new Int(42); // to add another string value array[1] = new String("fourty two"); The bit missing from his code is HOW to extract those values... Here's my version (actually I learned this from Ogre and modified it to my liking). Usage is something like: Any array[4]; // Automatically understands it's an integer array[0] = Any(1); // But let's say you want the number to be thought of as float array[1] = Any (2); // What about string? array[2] = Any ("fourty two"); // Note that this gets the compiler thinking it's a char* // instead of std::string array[3] = Any("Sometimes it just turns out to be what you don't want!"); Ok, now to see if a particular element is a string: if(array[2].isType () { // Extract the string value. std::string val = array[2].cast (); // Make the string do your bidding!!!... /evilgrin // WAIT! But what if you want to directly manipulate // the value in the array? std::string& val1 = array[2].cast (); // HOHOHO... now any changes to val1 affects the value // in the array ;) } The code for the Any class is given below. Feel free to use it however you like :). Hope this helps! In the header file... say Any.h #include #include /* * \class Any * \brief A variant type to hold any type of value. * \detail This class can be used to store values whose types are not * known before hand, like to store user-data. */ class Any { public: /*! * \brief Default constructor. */ Any(void); /*! * \brief Constructor that accepts a default user-defined value. * \detail This constructor copies that user-defined value into a * place holder. This constructor is explicit to avoid the compiler * to call this constructor implicitly when the user didn't want * the conversion to happen. * \param val const reference to the value to be stored. */ template explicit Any(const ValueType& val); /*! * \brief Copy constructor. * \param other The \c Any variable to be copied into this. */ Any(const Any& other); /*! * \brief Destructor, does nothing other than destroying the place holder. */ ~Any(void); /*! * \brief Gets the type of the value stored by this class. * \detail This function uses typeid operator to determine the type * of the value it stores. * \remarks If the place holder is empty it will return Touchscape::VOID_TYPE. * It is wise to check if this is empty by using the function Any::isEmpty(). */ const std::type_info& getType() const; /*! * \brief Function to verify type of the stored value. * \detail This function can be used to verify the type of the stored value. * Usage: * \code * int i; * Touchscape::Any int_any(i); * // Later in your code... * if (int_any.isType ()) * { * // Do something with int_any. * } * \endcode * \return \c true if the type matches, false otherwise. */ template bool isType() const; /*! * \brief Checks if the type stored can be converted 'dynamically' * to the requested type. * \detail This would useful when the type stored is a base class * and you would like to verify if it can be converted to type * the user wants. * Example: * \code * class Base * { * // class implementation. * }; * class Derived : public Base * { * // class implementation. * }; * * // In your implementation function. * { * //... * // Somewhere in your code. * Base* a = new Derived(); * Touchscape::Any user_data(a); * my_object.setUserData(user_data); * // Then when you need to know the user-data type * if(my_object.getUserData().isDynamicType ()) * { * // Do something with the user data * } * } * \endcode * \return \c true if the value stored can be dynamically casted to the target type. * \deprecated This function will be removed and/or changed in the future. */ template bool isDynamicType() const; /*! * \brief Convert the value stored to the required type. * \detail This function is used just like a static-cast to retrieve * the stored value. * \return A reference to the stored value. * \warning This function will throw std::bad_cast exception if it * finds the target type to be incorrect. */ template T& cast(); /*! * \brief Convert the value stored to the required type (const version). * \detail This function is used just like static_cast to retrieve * the stored value. * \return A \c const reference to the stored value. * \warning This function will throw std::bad_cast exception if it * finds the target type to be incorrect. */ template const T& cast() const; /*! * \brief Dynamically converts the stored value to the target type * \detail This function is just like dynamic_cast to retrieve * the stored value to the target type. * \return A reference to the stored value. * \warning This function will throw std::bad_cast exception if it * finds that the value cannot be dynamically converted to the target type. * \deprecated This function will be removed and/or changed in the future. */ template T& dynamicCast(); /*! * \brief Dynamically converts the stored value to the target type (const version) * \detail This function is just like dynamic_cast to retrieve * the stored value to the target type. * \return A const reference to the stored value. * \warning This function will throw std::bad_cast exception if it * finds that the value cannot be dynamically converted to the target type. * \deprecated This function will be removed and/or changed in the future. */ template const T& dynamicCast() const; /*! * \brief Swaps the contents with another \c Any variable. * \return reference to this instance. */ Any& swap(Any& other); /*! * \brief Checks if the place holder is empty. * \return \c true if the the place holder is empty, \c false otherwise. */ bool isEmpty() const; /*! * \brief Checks if the place holder is \b not empty. * \return \c true if the the place holder is not empty, \c false otherwise. * \remarks This is just a lazy programmer's attempt to make the code look elegant. */ bool isNotEmpty() const; /*! * \brief Assignment operator * \detail Assigns a 'raw' value to this instance. * \return Reference to this instance after assignment. */ template Any& operator = (const ValueType& rhs); /*! * \brief Default assignment operator * \detail Assigns another \c Any type to this one. * \return Reference to this instance after assignment. */ Any& operator = (const Any& rhs); /*! * \brief Boolean equality operator */ bool operator == (const Any& other) const; /*! * \brief Boolean equality operator that accepts a 'raw' type. */ template bool operator == (const ValueType& other) const; /*! * \brief Boolean inequality operator */ bool operator != (const Any& other) const; /*! * \brief Boolean inequality operator that accepts a 'raw' type. */ template bool operator != (const ValueType& other) const; protected: /*! * \class PlaceHolder * \brief The place holder base class * \detail The base class for the actual 'type'd class that stores * the value for T ouchscape::Any. */ class PlaceHolder { public: /*! * \brief Virtual destructor. */ virtual ~PlaceHolder(){} /*! * \brief Gets the \c type_info of the value stored. * \return (const std::type_info&) The typeid of the value stored. */ virtual const std::type_info& getType() const = 0; /*! * \brief Clones this instance. * \return (PlaceHolder*) Cloned instance. */ virtual PlaceHolder* clone() const = 0; }; /*! * \class PlaceHolderImpl * \brief The class that ultimately keeps hold of the value stored * in Touchscape::Any. */ template class PlaceHolderImpl : public PlaceHolder { public: /*! * \brief The only constructor allowed. * \param val The value to store. */ PlaceHolderImpl(const ValueType& val) :m_value(val){} /*! * \brief The destructor. * \detail Does nothing */ ~PlaceHolderImpl(){} /*! * \copydoc Touchscape::PlaceHolder::getType() */ const std::type_info& getType() const { return typeid(ValueType); } /*! * \copydoc Touchscape::PlaceHolder::clone() */ PlaceHolder* clone() const { return new PlaceHolderImpl (m_value); } ValueType m_value; }; PlaceHolder* m_content; }; /************************************************************************/ /* Template code implementation section */ /************************************************************************/ template Any::Any(const ValueType& val) :m_content(new PlaceHolderImpl (val)) { } //--------------------------------------------------------------------- template bool Any::isType() const { bool result = m_content?m_content->getType() == typeid(T):false; return result; } //--------------------------------------------------------------------- template bool Any::isDynamicType() const { bool result = m_content ?dynamic_cast (static_cast *>(m_content)->m_value)!=NULL :false; return result; } //--------------------------------------------------------------------- template T& Any::cast() { if (getType() != VOID_TYPE && isType ()) { T& result = static_cast *>(m_content)->m_value; return result; } StringStream ss; ss const T& Any::cast() const { Any& _this = const_cast (*this); return _this.cast (); } //--------------------------------------------------------------------- template T& Any::dynamicCast() { T* result = dynamic_cast (static_cast *>(m_content)->m_value); if (result == NULL) { StringStream ss; ss const T& Any::dynamicCast() const { Any& _this = const_cast (*this); return _this.dynamicCast (); } //--------------------------------------------------------------------- template Any& Any::operator = (const ValueType& rhs) { Any(rhs).swap(*this); return *this; } //--------------------------------------------------------------------- template bool Any::operator == (const ValueType& rhs) const { bool result = m_content == rhs; return result; } //--------------------------------------------------------------------- template bool Any::operator != (const ValueType& rhs) const { bool result = m_content != rhs; return result; } Now in the CPP file... Any.cpp #include "Any.h" static const std::type_info& VOID_TYPE(typeid(void)); Any::Any( void ) :m_content(NULL) { } //--------------------------------------------------------------------- Any::Any( const Any& other ) :m_content(other.m_content?other.m_content->clone():NULL) { } //--------------------------------------------------------------------- Any::~Any( void ) { SafeDelete(m_content); } //--------------------------------------------------------------------- const std::type_info& Any::getType() const { return m_content?m_content->getType():VOID_TYPE; } //--------------------------------------------------------------------- Any& Any::swap( Any& other ) { std::swap(m_content, other.m_content); return *this; } //--------------------------------------------------------------------- Any& Any::operator=( const Any& rhs ) { Any(rhs).swap(*this); return *this; } //--------------------------------------------------------------------- bool Any::isEmpty() const { bool is_empty = m_content == NULL; return is_empty; } //--------------------------------------------------------------------- bool Any::isNotEmpty() const { bool is_not_empty = m_content != NULL; return is_not_empty; } //--------------------------------------------------------------------- bool Any::operator==( const Any& other ) const { bool result = m_content == other.m_content; return result; } //--------------------------------------------------------------------- bool Any::operator!=( const Any& other ) const { bool result = m_content != other.m_content; return result; }
