[site]: stackoverflow
[post_id]: 5732323
[parent_id]: 
[tags]: 
Odd effect with GLSL normals

As a somewhat similar to a problem I had before and posted before, I'm trying to get normals to display correctly in my GLSL app. For the purposes of my explanation, I'm using the ninjaHead.obj model provided with RenderMonkey for testing purposes ( you can grab it here ). Now in the preview window in RenderMonkey, everything looks great: and the vertex and fragment code generated respectively is: Vertex: uniform vec4 view_position; varying vec3 vNormal; varying vec3 vViewVec; void main(void) { gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; // World-space lighting vNormal = gl_Normal; vViewVec = view_position.xyz - gl_Vertex.xyz; } Fragment: uniform vec4 color; varying vec3 vNormal; varying vec3 vViewVec; void main(void) { float v = 0.5 * (1.0 + dot(normalize(vViewVec), vNormal)); gl_FragColor = v* color; } I based my GLSL code on this but I'm not quite getting the expected results... My vertex shader code: uniform mat4 P; uniform mat4 modelRotationMatrix; uniform mat4 modelScaleMatrix; uniform mat4 modelTranslationMatrix; uniform vec3 cameraPosition; varying vec4 vNormal; varying vec4 vViewVec; void main() { vec4 pos = gl_ProjectionMatrix * P * modelTranslationMatrix * modelRotationMatrix * modelScaleMatrix * gl_Vertex; gl_Position = pos; gl_TexCoord[0] = gl_MultiTexCoord0; gl_FrontColor = gl_Color; vec4 normal4 = vec4(gl_Normal.x,gl_Normal.y,gl_Normal.z,0); // World-space lighting vNormal = normal4*modelRotationMatrix; vec4 tempCameraPos = vec4(cameraPosition.x,cameraPosition.y,cameraPosition.z,0); //vViewVec = cameraPosition.xyz - pos.xyz; vViewVec = tempCameraPos - pos; } My fragment shader code: varying vec4 vNormal; varying vec4 vViewVec; void main() { //gl_FragColor = gl_Color; float v = 0.5 * (1.0 + dot(normalize(vViewVec), vNormal)); gl_FragColor = v * gl_Color; } However my render produces this... Does anyone know what might be causing this and/or how to make it work? EDIT In response to kvark's comments, here is the model rendered without any normal/lighting calculations to show all triangles being rendered. And here is the model shading with the normals used for colors. I believe the problem has been found! Now the reason is why it is being rendered like this and how to solve it? Suggestions are welcome! SOLUTION Well everyone the problem has been solved! Thanks to kvark for all his helpful insight that has definitely helped my programming practice but I'm afraid the answer comes from me being a MASSIVE tit... I had an error in the display() function of my code that set the glNormalPointer offset to a random value. It used to be this: gl.glEnableClientState(GL.GL_NORMAL_ARRAY); gl.glBindBuffer(GL.GL_ARRAY_BUFFER, getNormalsBufferObject()); gl.glNormalPointer(GL.GL_FLOAT, 0, getNormalsBufferObject()); But should have been this: gl.glEnableClientState(GL.GL_NORMAL_ARRAY); gl.glBindBuffer(GL.GL_ARRAY_BUFFER, getNormalsBufferObject()); gl.glNormalPointer(GL.GL_FLOAT, 0, 0); So I guess this is a lesson. NEVER mindlessly Ctrl+C and Ctrl+V code to save time on a Friday afternoon AND... When you're sure the part of the code you're looking at is right, the problem is probably somewhere else!
