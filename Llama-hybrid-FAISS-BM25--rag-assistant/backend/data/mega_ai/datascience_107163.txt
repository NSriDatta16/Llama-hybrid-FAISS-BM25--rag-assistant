[site]: datascience
[post_id]: 107163
[parent_id]: 
[tags]: 
Is it possible to reduce the time of computing DTW with dtw-python package by disabling computation of?

I am trying to classify some time series using dtw-python package which is a python version of R package implementing Dynamic Time Warping described in this nice paper . By default a call to dtw function returns DTW object containing the distance as well as found warping path ( docs ). Classification with K-Nearest-Neighbours requires computing DTW(X,Y) for each of possible pairs $X \in T, Y \in E$ , where $T$ is a test set and $E$ is eval set. Results can be stored in $|T| \times |E|$ distances matrix $\lambda$ and later used to find the best matches. It is a lot of computations though. In the cited paper we can read that: $\lambda$ can be straightforwardly computed through proxy::dist(q, q, method = "DTW"). Computing K Ã— K alignments in this way is faster than iterating over the plain dtw call, because only the numeric value of the distance is computed, while the construction of the actual warping path is bypassed. I don't need to know the warping paths so I'd like to use this approach. Unfortunately this is valid for R version only as proxy is R package. Can I do something equivalent so that dtw in dtw-python doesn't return warping paths and only the distance so that it is faster?
