[site]: stackoverflow
[post_id]: 2209404
[parent_id]: 2124991
[tags]: 
I don't think that attaching the two databases and running INSERT INTO foo (SELECT * FROM bar) is the fastest way to do this. If you are synching between a handheld device and a server (or another device) could the transport mechanism be the bottleneck? Or are the two database files already on the same filesysem? If the filesystem on the device is slower flash-memory, could this be a bottleneck? Are you able to compile/run the raw SQLite C code on your device? (I think that the RAW sqlite3 amalgamation should compile for WinCE/Mobile) If so, and you are willing: To write some C code (using the SQLite C API) Increase risk of data loss by turning off disk journaling It should be possible for to write a small stand-alone executable to copy/synchronize the 100K records between the two databases extremely quickly. I've posted some of what I learned about optimizing SQLite inserts here: Improve INSERT-per-second performance of SQLite? Edit: Tried this out with real code... I don't know all the steps involved in building a Windows Mobile executable, but the SQLite3 amalgamation should compile out-of-the box using Visual Studio. Here is a sample main.c program that opens two SQLite databases (both have to have the same schema - see the #define TABLE statement) and executes a SELECT statement and then binds the resulting rows to an INSERT statement: /************************************************************* ** The author disclaims copyright to this source code. In place of ** a legal notice, here is a blessing: ** ** May you do good and not evil. ** May you find forgiveness for yourself and forgive others. ** May you share freely, never taking more than you give. **************************************************************/ #include #include #include #include #include "sqlite3.h" #define SOURCEDB "C:\\source.sqlite" #define DESTDB "c:\\dest.sqlite" #define TABLE "CREATE TABLE IF NOT EXISTS TTC (id INTEGER PRIMARY KEY, Route_ID TEXT, Branch_Code TEXT, Version INTEGER, Stop INTEGER, Vehicle_Index INTEGER, Day Integer, Time TEXT)" #define BUFFER_SIZE 256 int main(int argc, char **argv) { sqlite3 * sourceDB; sqlite3 * destDB; sqlite3_stmt * insertStmt; sqlite3_stmt * selectStmt; char * insertTail = 0; char * selectTail = 0; int n = 0; int result = 0; char * sErrMsg = 0; clock_t cStartClock; char sInsertSQL [BUFFER_SIZE] = "\0"; char sSelectSQL [BUFFER_SIZE] = "\0"; /* Open the Source and Destination databases */ sqlite3_open(SOURCEDB, &sourceDB); sqlite3_open(DESTDB, &destDB); /* Risky - but improves performance */ sqlite3_exec(destDB, "PRAGMA synchronous = OFF", NULL, NULL, &sErrMsg); sqlite3_exec(destDB, "PRAGMA journal_mode = MEMORY", NULL, NULL, &sErrMsg); cStartClock = clock(); /* Keep track of how long this took*/ /* Prepared statements are much faster */ /* Compile the Insert statement */ sprintf(sInsertSQL, "INSERT INTO TTC VALUES (NULL, @RT, @BR, @VR, @ST, @VI, @DT, @TM)"); sqlite3_prepare_v2(destDB, sInsertSQL, BUFFER_SIZE, &insertStmt, &insertTail); /* Compile the Select statement */ sprintf(sSelectSQL, "SELECT * FROM TTC LIMIT 100000"); sqlite3_prepare_v2(sourceDB, sSelectSQL, BUFFER_SIZE, &selectStmt, &selectTail); /* Transaction on the destination database */ sqlite3_exec(destDB, "BEGIN TRANSACTION", NULL, NULL, &sErrMsg); /* Execute the Select Statement. Step through the returned rows and bind each value to the prepared insert statement. Obviously this is much simpler if the columns in the select statement are in the same order as the columns in the insert statement */ result = sqlite3_step(selectStmt); while (result == SQLITE_ROW) { sqlite3_bind_text(insertStmt, 1, sqlite3_column_text(selectStmt, 1), -1, SQLITE_TRANSIENT); /* Get Route */ sqlite3_bind_text(insertStmt, 2, sqlite3_column_text(selectStmt, 2), -1, SQLITE_TRANSIENT); /* Get Branch */ sqlite3_bind_text(insertStmt, 3, sqlite3_column_text(selectStmt, 3), -1, SQLITE_TRANSIENT); /* Get Version */ sqlite3_bind_text(insertStmt, 4, sqlite3_column_text(selectStmt, 4), -1, SQLITE_TRANSIENT); /* Get Stop Number */ sqlite3_bind_text(insertStmt, 5, sqlite3_column_text(selectStmt, 5), -1, SQLITE_TRANSIENT); /* Get Vehicle */ sqlite3_bind_text(insertStmt, 6, sqlite3_column_text(selectStmt, 6), -1, SQLITE_TRANSIENT); /* Get Date */ sqlite3_bind_text(insertStmt, 7, sqlite3_column_text(selectStmt, 7), -1, SQLITE_TRANSIENT); /* Get Time */ sqlite3_step(insertStmt); /* Execute the SQL Insert Statement (Destination Database)*/ sqlite3_clear_bindings(insertStmt); /* Clear bindings */ sqlite3_reset(insertStmt); /* Reset VDBE */ n++; /* Fetch next from from source database */ result = sqlite3_step(selectStmt); } sqlite3_exec(destDB, "END TRANSACTION", NULL, NULL, &sErrMsg); printf("Transfered %d records in %4.2f seconds\n", n, (clock() - cStartClock) / (double)CLOCKS_PER_SEC); sqlite3_finalize(selectStmt); sqlite3_finalize(insertStmt); /* Close both databases */ sqlite3_close(destDB); sqlite3_close(sourceDB); return 0; } On my Windows desktop machine this code copies 100k records from source.sqlite to dest.sqlite in 1.20 seconds. I don't know exactly what kind of performance you'll see on a mobile device with flash memory (but I am curious).
