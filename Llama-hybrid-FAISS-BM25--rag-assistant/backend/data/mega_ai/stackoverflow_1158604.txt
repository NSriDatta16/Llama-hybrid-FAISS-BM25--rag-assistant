[site]: stackoverflow
[post_id]: 1158604
[parent_id]: 1157230
[tags]: 
To find the stack that isn't yet filled, the basic idea used is the fact: Stack k is not full TOP[k] The loop in the first step of the algorithm runs k from i+1 to n to find the first k that satisfies this condition. Also note that initially all space is given to the last, n th, stack by setting BASE[n] = TOP[n] = L0 and BASE[n+1]=LInfty . So unless all "higher" stacks have been filled, we will find such a k . Your second question (Why choose the smallest such k ?) is more easily answered: The algorithm on Page 247 is just one way of repacking and a simple one at that. As Knuth mentions in the paragraph just above the text of the algorithm: Several ways to do the repacking suggest themselves; ... We will start by giving the simplest of the methods, and will then consider some of the alternatives. Later, Knuth describes a repacking approach that takes into account the earlier repacking, making the process somewhat adaptive.
