[site]: stackoverflow
[post_id]: 223014
[parent_id]: 220867
[tags]: 
nyxtom's answer is very good. I'd add a couple of things to it: If you need read-only access to an XML document, XPathDocument is a much lighter-weight object than XmlDocument . The downside of using XPathDocument is that you can't use the familiar SelectNodes and SelectSingleNode methods of XmlNode . Instead, you have to use the tools that the IXPathNavigable provides: use CreateNavigator to create an XPathNavigator , and use the XPathNavigator to create XPathNodeIterator s to iterate over the lists of nodes you find via XPath. This generally requires a few more lines of code than the XmlDocument methods. But: the XmlDocument and XmlNode classes implement IXPathNavigable , so any code you write to use those methods on an XPathDocument will also work on an XmlDocument . If you get used to writing against IXPathNavigable , your methods can work against either object. (This is why using XmlNode and XmlDocument in method signatures is flagged by FxCop.) Lamentably, XDocument and XElement (and XNode and XObject ) don't implement IXPathNavigable . Another thing not present in nyxtom's answer is XmlReader . You generally use XmlReader to avoid the overhead of parsing the XML stream into an object model before you begin processing it. Instead, you use an XmlReader to process the input stream one XML node at a time. This is essentially .NET's answer to SAX. It lets you write very fast code for processing very large XML documents. XmlReader also provides the simplest way of processing XML document fragments, e.g. the stream of XML elements with no encluding element that SQL Server's FOR XML RAW option returns. The code you write using XmlReader is generally very tightly coupled to the format of the XML it's reading. Using XPath allows your code to be much, much more loosely coupled to the XML, which is why it's generally the right answer. But when you need to use XmlReader , you really need it.
