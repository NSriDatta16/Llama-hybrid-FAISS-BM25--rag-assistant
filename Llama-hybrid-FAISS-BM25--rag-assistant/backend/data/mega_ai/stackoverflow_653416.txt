[site]: stackoverflow
[post_id]: 653416
[parent_id]: 652555
[tags]: 
First of all, Ivy is not Maven ;) Maven2 is a software project management and comprehension tool, whereas Ivy is only a dependency management tool. Ivy heavily relies on a unique concept called configuration . In Ivy, a module configuration is a way to use or to see the module . For instance, you can have a test and runtime configuration in your module. But you can also have a MySQL and an Oracle configuration. Or an Hibernate and a JDBC configuration. In each configuration, you can declare: what artifacts (jar, war, ...) are required. your dependencies on other modules, and describe which configuration of the dependency you need. This is called configuration mapping. So the conf attribute does precisely that: Describes a configuration mapping for a dependency. The mapped child element is your "right hand side of the -> symbol" and represents the name of the dependency configuration mapped. '*' wildcard can be used to designate all configurations of this module. See more at " Simplest Explanation of Ivy Configuration " from Charlie Hubbard The important part of that is Ivy downloads dependencies and organizes them. An ivy-module (ie ivy.xml file) has two main parts: What dependencies do you need? How do you want them organized? The first part is configured under the element. The 2nd is controlled by the element When Ivy is downloading these dependencies it needs to know what scopes to use when pulling these transitive dependencies (are we pulling this for testing, runtime, compilation, etc?). We have to tell Ivy how to map our configurations to Maven scopes so it knows what to pull. Maven2 on its side has something called the scope . You can declare a dependency as being part of the test scope, or the buildtime scope. Then depending on this scope you will get the dependency artifact (only one artifact per module in maven2) with its dependencies depending on their scope. Scopes are predefined in maven2 and you can't change that. That means : There are a lot of unnecessary dependencies downloaded for many libraries. For example, Hibernate downloads a bunch of JBoss JARs and the Display Tag downloads all the various web framework JARs. I found myself excluding almost as many dependencies as I added. The problem is that hibernate can be used with several cache implementations, several connection pool implementation, ... And this can't be managed with scopes, wheres Ivy configurations offers an elegant solution to this kind of problem. For instance, in Ivy, assuming hibernate has an Ivy file like this one , then you can declare a dependency like that: proxool,oscache"/> to get hibernate with its proxool and oscache implementations, and like that: dbcp,swarmcache"/> to get hibernate with dbcp and swarmcache. By mapping your default master configuration to " proxool,oscache " or to " dbcp,swarmcache ", you specify what you need exactly from the module "hibernate". You can find those "proxool,..." arguments by listing the Ivy configuration defined for each modules associate with the library. For instance: default"> Example : let's suppose modA has two configurations, default and test. As a practical matter, it's going to be highly unusual to want to leave out the conf attribute of the dependency element. The ivy.xml for modA might have a dependency: *" /> You're starting from default, rather than from both default and test. The above example makes modA's default depend on modB's conf1, conf2, and conf3. Or you might want to say that modA's default only depends on modB's conf1: *conf1*" />
