[site]: stackoverflow
[post_id]: 831964
[parent_id]: 831721
[tags]: 
Fast is what you should worry about, not necessarily full vectorization. Recent versions of Matlab are much smarter about handling loops efficiently. If there's a compact vectorized way of expressing something, it's usually faster, but loops should not (always) be feared like they used to be. clc A = rand(5000)>0.5; A(1,find(sum(A,1)==0)) = 1; % make sure there is at least one match % Slow because it is doing too much work tic;[B,I1]=max(cumsum(A));toc % Fast because FIND is fast and it runs the inner loop tic; I3=zeros(1,5000); for i=1:5000 I3(i) = find(A(:,i),1,'last'); end toc; assert(all(I1==I3)); % Even faster because the JIT in Matlab is smart enough now tic; I2=zeros(1,5000); for i=1:5000 I2(i) = 0; for j=5000:-1:1 if A(j,i) I2(i) = j; break; end end end toc; assert(all(I1==I2)); On R2008a, Windows, x64, the cumsum version takes 0.9 seconds. The loop and find version takes 0.02 seconds. The double loop version takes a mere 0.001 seconds. EDIT: Which one is fastest depends on the actual data. The double-loop takes 0.05 seconds when you change the 0.5 to 0.999 (because it takes longer to hit the break; on average). cumsum and the loop&find implementation have more consistent speeds. EDIT 2: gnovice's flipud solution is clever. Unfortunately, on my test machine it takes 0.1 seconds, so it's much faster than cumsum, but slower than the looped versions.
