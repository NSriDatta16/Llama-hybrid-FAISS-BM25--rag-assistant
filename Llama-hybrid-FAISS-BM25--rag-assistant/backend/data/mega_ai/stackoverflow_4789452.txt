[site]: stackoverflow
[post_id]: 4789452
[parent_id]: 4788993
[tags]: 
That's not at all the way to use BeginThread . That function expects a pointer to a function that takes one parameter, but the function you're trying to call wants four. The one parameter you're giving to BeginThread for it to forward to the thread procedure is a string, but you evidently hope that some sort of magic will turn that string of characters into the values that those variables contain. That's not how Delphi works, and even for the languages that can do something like that, it's generally discouraged to actually do it. To pass multiple parameters to BeginThread , define a record with all the values you'll need, and also define a record pointer: type PCompareFilesParams = ^TCompareFilesParams; TCompareFilesParams = record Edit3Text, Edit4Text: string; Grid: TStringGrid; Op: Integer; end; Change CompareFiles to accept a pointer to that record: function CompareFiles(Params: PCompareFilesParams): Integer; To start the thread, you'll need to allocate an instance of that record and populate its fields: var Params: PCompareFilesParams; begin New(Params); Params.Edit3Text := Edit3.Text; Params.Edit4Text := Edit4.Text; Params.Grid := StringGrid2; Params.Op := op; BeginThread(nil, 0, @CompareFiles, Params, 0, x); Implement CompareFiles like this so that the record will get freed before the thread terminates: function CompareFiles(Params: PCompareFilesParams): Integer; begin try // finally Dispose(Params); end; end; You can make it all a lot easier if you just use TThread , though. You can make your descendant class have as many parameters as you want in its constructor, so you don't have to mess around with dynamically allocating and freeing a special record. type TCompareFilesThread = class(TThread) private FEdit3Text, FEdit4Text: string; FGrid: TStringGrid; FOp: Integer; procedure Execute; override; public constructor Create(const Edit3Text, Edit4Text: string; Grid: TStringGrid; Op: Integer); property ReturnValue; end; constructor TCompareFilesThread.Create; begin inherited Create(False); FEdit3Text := Edit3Text; FEdit4Text := Edit4Text; FGrid := Grid; FOp := Op; end; procedure TCompareFilesThread.Execute; begin ReturnValue := CompareFiles(FEdit3Text, FEdit4Text, FGrid, FOp); end; Instead of calling BeginThread , you just instantiate the class and let it run: var ThreadRef: TThread; ThreadRef := TCompareFilesThread.Create(Edit3.Text, Edit4.Text, StringGrid2, Op); There's more to using threads, such as knowing when the thread has finished running, but I think you have enough to get started. One last thing to beware of, though, is that TStringGrid is a VCL control. You mustn't do anything with it from this new thread you create (regardless of how you end up creating it). Eveything you do with the grid control need to be done from the main thread. Use TThread.Synchronize and TThread.Queue to shift any VCL operations onto the main thread. Your file-comparing thread will wait for the synchronized operation to complete, but it will keep running without waiting for a queued operation to complete.
