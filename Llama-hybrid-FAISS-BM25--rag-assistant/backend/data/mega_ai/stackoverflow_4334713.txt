[site]: stackoverflow
[post_id]: 4334713
[parent_id]: 4334339
[tags]: 
Well, the question I have to ask back is, "as opposed to what"? If you mean as opposed to a switch statement, then as well as readability it can sometimes be more efficient. As a rule (certainly in C#, likely in the others) below a certain number of branches it will just be turned into a series of if statements when compiled but beyond that number it will be turned into a hash-based lookup and jump that is likely to be faster on the average case. Alternatively, if you have good knowledge of the relative frequency of different cases, you can be more efficient with a set of if statements. E.g. if 95% of cases match the first branch, 4% match the second and 1% match all the rest, this can give better performance for the 95% of cases by doing a single comparison and perhaps not even branching in that case. So. Maybe there's an efficiency gain in this case. Still, readability counts for a hell of a lot. As an extreme example, there's a Turing-complete language that was designed just for the sake of seeing how small a compiler for a Turing-complete language could be. It's designer named the language "brainf**k". This in itself is a great comment on the importance of readable code in real programming. Now, a bigger issue with a large number of if statements, is that it often indicates that you are modelling something through those if statements that could be modelled better with a class hierarchy. In a way this is just another take on readability (assuming the program works either way). However, it's about the readability - and understandability - of the program as a whole. It will massively impact upon the mental model you have of the program, extensibility and affect not just how well you can maintain it, but you will conceive of as possible with it. It can easily be the difference between a program that becomes a legacy time-sink until someone works out how to get rid of it, and one that grows to continue to give return on investment.
