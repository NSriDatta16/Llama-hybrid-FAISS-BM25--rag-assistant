[site]: stackoverflow
[post_id]: 5517724
[parent_id]: 5517615
[tags]: 
You can use the count_if algorithm with a custom predicate function object: template struct second_equal_to : std::unary_function { second_equal_to(const typename Pair::second_type& value) : value_(value) { } bool operator()(const Pair& p) const { return p.second == *value_; } private: typename Pair::second_type value_; }; Usage: typedef std::map Map; typedef Map::value_type MapEntry; std::count_if(m.begin(), m.end(), second_equal_to ("A")); Or, for a more generic solution, you can write an apply_to_second predicate transformer: template struct apply_to_second_f : std::unary_function { apply_to_second_f(const Predicate& p) : predicate_(p) { } bool operator()(const Pair& p) const { return predicate_(p.second); } Predicate predicate_; }; template apply_to_second_f apply_to_second(const Predicate& p) { return apply_to_second_f (p); } Usage: std::count_if(m.begin(), m.end(), apply_to_second (std::bind2nd(std::equal_to (), "A"))); If you have a compiler that supports lambda expressions, you don't need any custom predicate functor at all; you can use a much simpler lambda: std::count_if(m.begin(), m.end(), [](const MapEntry& e) { return e.second == "A"; });
