[site]: stackoverflow
[post_id]: 2082927
[parent_id]: 
[tags]: 
Haskell Monad Transformer Stack and Type Signatures

I am attempting to create a stack of monad transformers and am having trouble getting the correct type signatures for my functions. (I'm still pretty new to Haskell) The stack combines multiple StateT transformers since I have multiple states I need to keep track of (two of which could be tupled, but I'll get to that in a second) and a WriterT for logging. Here's what I have so far: module Pass1 where import Control.Monad.Identity import Control.Monad.State import Control.Monad.Writer import Data.Maybe import qualified Data.Map as Map import Types data Msg = Error String | Warning String type Pass1 a = WriterT [Msg] (StateT Int (StateT [Line] (StateT [Address] Identity))) a runPass1 addrs instrs msgs = runIdentity (runStateT (runStateT (runStateT (runWriterT msgs) 1) instrs) addrs) --popLine :: (MonadState s m) => m (Maybe s) --popLine :: (Monad m) => StateT [Line] m (Maybe Line) popLine :: (MonadState s m) => m (Maybe Line) popLine = do ls do put xs return $ Just x [] -> return Nothing incLineNum :: (Num s, MonadState s m) => m () incLineNum = do ln m s curLineNum = do ln I would like the popLine to mess with the [Line] state and the xLineNum functions to affect the Int state. evalr is the computation which will be passed to runPass1 . Whenever I load the code I run into errors which are generally of the following variety: Pass1.hs:23:14: No instance for (MonadState [t] m) arising from a use of `get' at Pass1.hs:23:14-16 Possible fix: add an instance declaration for (MonadState [t] m) In a stmt of a 'do' expression: ls do ... [] -> return Nothing } In the definition of `popLine': popLine = do ls ... [] -> return Nothing } Pass1.hs:22:0: Couldn't match expected type `s' against inferred type `[Line]' `s' is a rigid type variable bound by the type signature for `popLine' at Pass1.hs:21:23 When using functional dependencies to combine MonadState [Line] m, arising from a use of `get' at Pass1.hs:23:14-16 MonadState s m, arising from the type signature for `popLine' at Pass1.hs:(22,0)-(28,31) When generalising the type(s) for `popLine' Pass1.hs:23:14: Could not deduce (MonadState [Line] m) from the context (MonadState s m) arising from a use of `get' at Pass1.hs:23:14-16 Possible fix: add (MonadState [Line] m) to the context of the type signature for `popLine' or add an instance declaration for (MonadState [Line] m) In a stmt of a 'do' expression: ls do ... [] -> return Nothing } In the definition of `popLine': popLine = do ls ... [] -> return Nothing } None of the signatures seem to be correct, but popLine is the first function so it's the only one that immediately causes an error. I try adding what it suggests in the type signature (eg: popLine :: (MonadState [Line] m) => ... but then it errors like so: Pass1.hs:21:0: Non type-variable argument in the constraint: MonadState [Line] m (Use -XFlexibleContexts to permit this) In the type signature for `popLine': popLine :: (MonadState [Line] m) => m (Maybe Line) I always seem to get this message whenever I try to do something that isn't a type variable. It seems to like (MonadState s m) ok and error on something else, but when I try it with a [a] instead of s it errors similar to the above. (Initially the [Line] and Int were tupled in a single state, but I was getting this error so I thought I'd try to put them in separate states). GHC 6.10.4, Kubuntu So, can anyone tell me what is going on and give an explanation / show me the right type signatures, or does anyone know of a good reference on this stuff (the only thing that has helped so far was "Monad Transformers Step by Step", but that just uses one aux state function and one StateT)? Many Thanks in advance. Edit Here's the compiling code incorporating JFT's and Edward's suggestions: {-# LANGUAGE GeneralizedNewtypeDeriving #-} -- needed for: deriving (Functor,Monad) {-# LANGUAGE MultiParamTypeClasses #-} -- needed for: MonadState instance {-# LANGUAGE FlexibleContexts #-} -- needed for: (MonadState PassState m) => ... module Pass1 where import Control.Monad.State import Control.Monad.Writer import Data.Maybe import Types type Lines = [Line] type Addresses = [Address] type LineNum = Int type Messages = [Msg] data Msg = Error String | Warning String data PassState = PassState { passLineNum :: LineNum , passLines :: Lines , passAddresses :: Addresses } newtype Pass1 a = Pass1 { unPass1 :: WriterT Messages (State PassState) a } deriving (Functor,Monad) instance MonadState PassState Pass1 where get = Pass1 . lift $ get put s = Pass1 . lift $ put s runPass1 :: PassState -> Pass1 a -> ((a, Messages), PassState) runPass1 state = flip runState state . runWriterT . unPass1 curLineNum :: (MonadState PassState m) => m LineNum curLineNum = do state m (Maybe Line) nextLine = do state do put state { passLines = xs, passLineNum = (c+1) } return $ Just x _ -> return Nothing evalr :: Pass1 (Maybe Line,LineNum) evalr = do l I combined incLineNum and popLine into nextLine I still need to get the Writer monad portion to work, but think I know where to go from here. Thanks, guys.
