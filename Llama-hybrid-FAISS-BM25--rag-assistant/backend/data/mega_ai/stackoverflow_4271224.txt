[site]: stackoverflow
[post_id]: 4271224
[parent_id]: 4261393
[tags]: 
I was doing something similar with a time entry tool and needed to detect overlap between entered times. If all you really need is "I have a fault. There will be 1 Break during the Fault period. Give me the amount of time during which they're co-incident", then your function is on the right track. When I did mine, I found exploring test cases visually was better than a truth table, and both were better than prose or code. Case 1: Case 2: Fault: |-------| Fault: |----------| Break: |-------| Break: |----------| Case 3: Case 4: Fault: |----------| Fault: |----------| Break: |----------| Break: |------| ...etc. As for doing this elegantly, I'd point out that if there is any overlap between the two lapses, you always wind up wanting the larger start date. Like so: Start Dates: Fault: |---- ... |---- ... |---- Break: |---- ... |---- ... |---- Verdict: break either fault ...and similar for the smallest end date. Because our zone of interest is when both have started and neither have finished. So your logic can become: DECLARE @Time int, @biggestStart datetime, @smallestEnd datetime; SET @Time = 0; IF (@BreakStartDate @FaultStartDate) BEGIN -- We have overlap. -- Poor man's Math.Max and Math.Min: SET @biggestStart = CASE WHEN @FaultStartDate > @BreakStartDate THEN @FaultStartDate ELSE @BreakEndDate END; SET @smallestEnd = CASE WHEN @FaultEndDate If I had to do what you stated, this is probably what I'd go with. That said, in analyzing your question, I'm wondering if you don't have to worry about multiple breaks per fault, if you are trying to do this for all faults in a result set, if you're aggregating "time per equipment per week" or something. If so, you want another approach. But that's another answer.
