[site]: stackoverflow
[post_id]: 5562254
[parent_id]: 5561174
[tags]: 
I suspect you are hitting something with the Windows message loop and threading in WinForms. I don't know what that is, but here are a few pointers: You can run the button's task in a backgroundWorker to keep the work off the UI thread. That solves the lock problem. Drag a BackgroundWorker from the toolbox and drop it on your Form in the designer, and hook up the event, i.e.: this.backgroundWorker1.DoWork += new System.ComponentModel.DoWorkEventHandler(this.backgroundWorker1_DoWork); then switch your code in btManual_Click to call the background worker like this: backgroundWorker1.RunWorkerAsync(); and then: private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) { Mcount = tty.SomeStupidBlockingFunction(Mcount); this.BeginInvoke((Action)delegate { txtManual.Text = Mcount.ToString(); }); } I've left out the lock (tty) because I would rather see only one of these statements inside the function, rather than five of them outside. And instead of locking on tty, I would create a private variable like this: public class MegaAPI { private object sync = new object(); public int SomeStupidBlockingFunction(int c) { lock (this.sync) { Thread.Sleep(800); return ++c; } } } Everywhere else is then simplified, for example: void UIUpdate1() { ACount1 = tty.SomeStupidBlockingFunction(ACount1); this.BeginInvoke((Action)delegate { txtAuto1.Text = ACount1.ToString(); }); } And since you can't run the background worker while it's still processing, here is a quick-and-dirty solution: disable the button while it's working: this.backgroundWorker1.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.backgroundWorker1_RunWorkerCompleted); and then: private void btManual_Click(object sender, EventArgs e) { this.btManual.Enabled = false; backgroundWorker1.RunWorkerAsync(); } and: private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { this.btManual.Enabled = true; } So I recommend: Keep a single lock () statement inside the function needing the synchronization Keep the lock object private Run the work on a background worker
