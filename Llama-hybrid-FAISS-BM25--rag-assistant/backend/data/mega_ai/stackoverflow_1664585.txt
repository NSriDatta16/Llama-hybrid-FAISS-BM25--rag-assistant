[site]: stackoverflow
[post_id]: 1664585
[parent_id]: 1664563
[tags]: 
Check out the IETF RFC 4648 for 'The Base16, Base32 and Base64 Data Encodings'. Partial code critique: size_t dl = sizeof(data); printf("sizeof(data):%d\n",dl); float fpl = ((float)dl / 4.0f) * 3.0f; size_t pl = (size_t)(fpl > (float)((int)fpl) ? fpl + 1 : fpl); printf("length of packed data:%d\n",pl); Don't use the floating point stuff - just use integers. And use '%z' to print 'size_t' values - assuming you've got a C99 library. size_t pl = ((dl + 3) / 4) * 3; I think your loop could be simplified by dealing with 3-byte input units until you've got a partial unit left over, and then dealing with a remainder of 1 or 2 bytes as special cases. I note that the standard referenced says that you use one or two '=' signs to pad at the end. I have a Base64 encoder and decode which does some of that. You are describing the 'decode' part of Base64 -- where the Base64 code has 4 bytes of data that should be stored in just 3 - as your packing code. The Base64 encoder corresponds to the unpacker you will need. Base-64 Decoder Note: base_64_inv is an array of 256 values, one for each possible input byte value; it defines the correct decoded value for each encoded byte. In the Base64 encoding, this is a sparse array - 3/4 zeroes. Similarly, base_64_map is the mapping between a value 0..63 and the corresponding storage value. enum { DC_PAD = -1, DC_ERR = -2 }; static int decode_b64(int c) { int b64 = base_64_inv[c]; if (c == base64_pad) b64 = DC_PAD; else if (b64 == 0 && c != base_64_map[0]) b64 = DC_ERR; return(b64); } /* Decode 4 bytes into 3 */ static int decode_quad(const char *b64_data, char *bin_data) { int b0 = decode_b64(b64_data[0]); int b1 = decode_b64(b64_data[1]); int b2 = decode_b64(b64_data[2]); int b3 = decode_b64(b64_data[3]); int bytes; if (b0 = 0 && b3 == DC_PAD && (b2 & 0x03) != 0) /* 4th byte is '='; 3rd byte is not '=' and must end with 2 zero bits */ return(B64_ERR_INVALID_TRAILING_BYTE); bin_data[0] = (b0 > 4); bytes = 1; if (b2 >= 0) { bin_data[1] = ((b1 & 0x0F) > 2); bytes = 2; } if (b3 >= 0) { bin_data[2] = ((b2 & 0x03) buflen) return(B64_ERR_OUTPUT_BUFFER_TOO_SMALL); while (datalen >= 4) { int nbytes = decode_quad(data, buffer + outlen); if (nbytes Base-64 Encoder /* Encode 3 bytes of data into 4 */ static void encode_triplet(const char *triplet, char *quad) { quad[0] = base_64_map[(triplet[0] >> 2) & 0x3F]; quad[1] = base_64_map[((triplet[0] & 0x03) > 4) & 0x0F)]; quad[2] = base_64_map[((triplet[1] & 0x0F) > 6) & 0x03)]; quad[3] = base_64_map[triplet[2] & 0x3F]; } /* Encode 2 bytes of data into 4 */ static void encode_doublet(const char *doublet, char *quad, char pad) { quad[0] = base_64_map[(doublet[0] >> 2) & 0x3F]; quad[1] = base_64_map[((doublet[0] & 0x03) > 4) & 0x0F)]; quad[2] = base_64_map[((doublet[1] & 0x0F) > 2) & 0x3F]; quad[1] = base_64_map[((singlet[0] & 0x03) buflen) return(B64_ERR_OUTPUT_BUFFER_TOO_SMALL); while (datalen >= 3) { encode_triplet(bin_data, b64_data); bin_data += 3; b64_data += 4; datalen -= 3; } b64_data[0] = '\0'; if (datalen == 2) encode_doublet(bin_data, b64_data, pad); else if (datalen == 1) encode_singlet(bin_data, b64_data, pad); b64_data[4] = '\0'; return((b64_data - buffer) + strlen(b64_data)); } I complicate life by having to deal with a product that uses a variant alphabet for the Base64 encoding, and also manages not to pad data - hence the 'pad' argument (which can be zero for 'null padding' or '=' for standard padding. The 'base_64_map' array contains the alphabet to use for 6-bit values in the range 0..63.
