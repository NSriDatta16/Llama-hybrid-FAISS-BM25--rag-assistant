[site]: stackoverflow
[post_id]: 1638441
[parent_id]: 1638288
[tags]: 
I should note that your Impl class is nothing more than the reimplementation of a shared_ptr without the thread safety and all those cast bonuses. Pimpl is nothing but a technic to avoid needless compile-time dependencies. You do not need to actually know how a class is implemented to inherit from it. It would defeat the purpose of encapsulation (though your compiler does...). So... I think that you are not trying to use Pimpl here. I would rather think this is a kind of Proxy patterns, since apparently: Polygon1 numberOne; Polygon2 numberTwo = numberOne; numberTwo.changeData(); // affects data from numberOne too // since they point to the same pointer!! If you want to hide implementation details Use Pimpl , but the real one, it means copying in depth during copy construction and assignment rather than just passing the pointer around (whether ref-counted or not, though ref-counted is preferable of course :) ). If you want a proxy class Just use a plain shared_ptr . For inheritance It does not matter, when you inherit from a class, how its private members are implemented. So just inherit from it. If you want to add some new private members (usual case), then: struct DerivedImpl; class Derived: public Base // Base implemented with a Pimpl { public: private: std::shared_ptr _data; }; There is not much difference with classic implementation, as you can see, just that there is a pointer in lieu of a bunch of data. BEWARE If you forward declare DerivedImpl (which is the goal of Pimpl), then the destructor automatically generated by the compiler is... wrong. The problem is that in order to generate the code for the destructor, the compiler needs the definition of DerivedImpl (ie: a complete type) in order to know how to destroy it, since a call to delete is hidden in the bowels of shared_ptr. However it may only generate a warning at compilation time (but you'll have a memory leak). Furthermore, if you want an in-depth copy (rather than a shallow one, which consists in the copy and the original both pointing to the same DerivedImpl instance), you will also have to define manually the copy-constructor AND the assignment operator. You may decide to create a better class that shared_ptr which will have deep-copy semantics (which could be called member_ptr as in cryptopp, or just Pimpl ;) ). This introduce a subtle bug though: while the code generated for the copy-constructor and the assignement operator could be thought of as correct, they are not, since once again you need a complete type (and thus the definition of DerivedImpl ), so you will have to write them manually. This is painful... and I'm sorry for you. EDIT: Let's have a Shape discussion. // Shape.h namespace detail { class ShapeImpl; } class Shape { public: virtual void draw(Board& ioBoard) const = 0; private: detail::ShapeImpl* m_impl; }; // class Shape // Rectangle.h namespace detail { class RectangleImpl; } class Rectangle: public Shape { public: virtual void draw(Board& ioBoard) const; size_t getWidth() const; size_t getHeight() const; private: detail::RectangleImpl* m_impl; }; // class Rectangle // Circle.h namespace detail { class CircleImpl; } class Circle: public Shape { public: virtual void draw(Board& ioBoard) const; size_t getDiameter() const; private: detail::CircleImpl* m_impl; }; // class Circle You see: neither Circle nor Rectangle care if Shape uses Pimpl or not, as its name implies, Pimpl is an implementation detail, something private that is not shared with the descendants of the class. And as I explained, both Circle and Rectangle use Pimpl too, each with their own 'implementation class' (which can be nothing more than a simple struct with no method by the way).
