[site]: stackoverflow
[post_id]: 3217268
[parent_id]: 3217088
[tags]: 
Imagine you want to create a caching service. This caching service would be app-agnostic so you could use it with many applications. You'd like to support lots of different web servers too. Notice how it kind of sits in the middle between server and framework? It's an example of middleware. It's not application logic and not really low-level network stuff either but provides a service somewhere in between. Some examples are QoS (quality of service), Security, caching, ... It would be nice if your service supported all n of the popular (and some of the not-so-popular) servers (thin, webrick). If you supported them all more people could use your wonderful software. You could see that making this happen would be a real drag, you'd need to support each server with special server-specific code. Now that's just half the problem because there are a number of web frameworks too. Rails is the 500-lb gorilla but there are other frameworks, such as Merb and Sinatra . Supporting these in your caching service is another m different things to support. Now you're supporting n x m different paths. What a drag. Enter Rack . Rack sits between the frameworks and the servers and gives you an interface to code your caching server to. If the servers and frameworks support rack, and most do, your service just needs to support the rack interface and you get support for all the frameworks and services rack supports. (It's a bit like latex compiling to dvi and then turning the dvi into ps, pdf,....). You don't need a converter from Merb to WEBrick and another from Sinata to Thin. If your caching service supports rack you're insulated from the differences. With this "narrow waist", where m-frameworks all come together before branching out to n-servers between the app and server you can also see how it provides a good place to add functionality such as routing, logging, static serving that bypasses the slowness of your interpreted framework, etc.
