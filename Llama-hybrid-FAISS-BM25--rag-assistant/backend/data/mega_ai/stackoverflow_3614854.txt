[site]: stackoverflow
[post_id]: 3614854
[parent_id]: 3614431
[tags]: 
Other people pointed out trivial solution: iterate over all numbers from 1 to A . But this problem, actually, can be solved in nearly constant time: O(length of A) , which is O(log(A)) . Code provided is for base 10. Adapting it for arbitrary base is trivial. To reach above estimate for time, you need to add memorization to recursion. Let me know if you have questions about that part. Now, recursive function itself. Written in Java, but everything should work in C#/C++ without any changes. It's big, but mostly because of comments where I try to clarify algorithm. // returns amount of numbers strictly less than 'num' with sum of digits 'sum' // pay attention to word 'strictly' int count(int num, int sum) { // no numbers with negative sum of digits if (sum 0) { --num; // check if current number is good if (sumOfDigits(num) == sum) { // one more result ++result; } } if (num == 0) { // zero reached, no more numbers to check return result; } num /= 10; // Using example above (1234), now we're left with numbers // strictly less than 1230 to check (1..1229) // It means, any number less than 123 with arbitrary digit appended to the right // E.g., if this digit in the right (last digit) is 3, // then sum of the other digits must be "sum - 3" // and we need to add to result 'count(123, sum - 3)' // let's iterate over all possible values of last digit for (int digit = 0; digit Helper function // returns sum of digits, plain and simple int sumOfDigits(int x) { int result = 0; while (x > 0) { result += x % 10; x /= 10; } return result; } Now, let's write a little tester int A = 12345; int C = 13; // recursive solution System.out.println(count(A + 1, C)); // brute-force solution int total = 0; for (int i = 1; i You can write more comprehensive tester checking all values of A, but overall solution seems to be correct. (I tried several random A's and C's.) Don't forget, you can't test solution for A == 1000000000 without memorization: it'll run too long. But with memorization, you can test it even for A == 10^1000 . edit Just to prove a concept, poor man's memorization. (in Java, in other languages hashtables are declared differently) But if you want to learn something, it might be better to try to do it yourself. // hold values here private Map mem; int count(int num, int sum) { // no numbers with negative sum of digits if (sum
