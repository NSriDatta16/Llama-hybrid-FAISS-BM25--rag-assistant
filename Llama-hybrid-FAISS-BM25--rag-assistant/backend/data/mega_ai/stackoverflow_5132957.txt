[site]: stackoverflow
[post_id]: 5132957
[parent_id]: 5132510
[tags]: 
Firstly, I have not tried to execute your code: my comments are based purely on inspection. I suspect the root of your problem is confusion between big-endian and little-endian data storage. The macros in the C code (GET_ULONG_BE and PUT_ULONG_BE) are extracting the raw data and converting to uint32 in BIG-endian format. In Delphi, you are copying the raw data from bytes to LongWord format without doing a little-endian to big-endian conversion. Apart from that, I'm not sure about the declaration of S as Int64, but that is probably minor in comparison to the big-end/little-end problem. Edit: You need to do the big-endian conversion in your XTeaCryptStr() routine. You need to apply it to the 4 elements of the key structure, and to your data block - both before (the data going in) and after (the result coming out) the call to the main encryption routine. Edit: Started trying to run the Delphi code. First problem is that your test password starts with a nul character. You need to use a different password (without nul characters). Yet another edit: I inserted calls to SwapEndian() as below: function XTeaCryptStr(const Msg, Pwd: string): string; var V: TTeaMsgBlock; K: TTeaKeyBlock; I, L, N: Integer; begin L := Length(Pwd); if L > SizeOf(K) then L := SizeOf(K); K[0] := 0; K[1] := 0; K[2] := 0; K[3] := 0; Move(Pwd[1], K[0], L); for i := 0 to 3 do K[i] := SwapEndian( K[i] ); I := 1; L := Length(Msg); if L > 0 then SetLength(Result, ((L - 1) div SizeOf(V) + 1) * SizeOf(V)) else SetLength(Result, 0); while I SizeOf(V) then N := SizeOf(V); Move(Msg[I], V[0], N); V[0] := SwapEndian( V[0] ); V[1] := SwapEndian( V[1] ); XTeaCrypt(V, K); V[0] := SwapEndian( V[0] ); V[1] := SwapEndian( V[1] ); Move(V[0], Result[I], SizeOf(V)); Inc(I, SizeOf(V)) end; end; With this (and a password that doesn't contain nul characters), I got the same result from the C and Delphi code.
