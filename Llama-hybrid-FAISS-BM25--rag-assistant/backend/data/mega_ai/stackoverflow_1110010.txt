[site]: stackoverflow
[post_id]: 1110010
[parent_id]: 
[tags]: 
Why doesn't my LINQ to Objects query return any results?

I have the following query I'm using (which mostly came from the help I received here ): public IEnumerable GetAuditRuleAgencyRecords(IEnumerable rules) { using (LinqModelDataContext db = new LinqModelDataContext()) { // Left-Outer Joins on Agency and its various other tables. var auditAgencyRecords = (from ag in db.Agencies join ara in db.AuditRuleAccounts on ag.Agency_Id equals ara.AgencyID into aran from ara in aran.DefaultIfEmpty() join arr in db.AuditRuleResults on ara.AuditRuleAccountID equals arr.AuditRuleAccountID into arrn from arr in arrn.DefaultIfEmpty() join are in db.AuditRuleEnterprises on arr.AuditRuleEnterpriseID equals are.AuditRuleEnterpriseID into aren from are in aren.DefaultIfEmpty() select new { AgencyID = ag.Agency_Id, AgencyName = ag.Agency_Name, AuditRuleEnterpriseID = arr.AuditRuleEnterpriseID, AuditRuleEnterpriseName = are.OverrideDisplayName, CorrectedDate = arr.CorrectedDate, NbrDaysToCorrect = arr.NbrDaysToCorrect, }); IEnumerable AuditAgencies = auditAgencyRecords .GroupBy(a => a.AgencyID) .Select(ag => new AuditAgency() { AgencyID = ag.Key, AgencyName = ag.First().AgencyName, Rules = ag .GroupBy(agr => agr.AuditRuleEnterpriseID) // ----> Do a left outer join on parameter "rules" object and the returned group above // ----> on both of their ID's .Select(agrg => new AuditAgencyRule() // Now I would like to only be creating "rules" for the rules with IDs that match the rules passed into this method { AuditRuleID = agrg.Key, AuditRuleName = agrg.First().AuditRuleEnterpriseName, Days = (Int32)agrg.Average(agrgr => agrgr.NbrDaysToCorrect) }) }).ToList(); return AuditAgencies; } This returns me a list of AuditAgency objects and each AuditAgency contains a list of AuditAgencyRules. Now, as my final step in this query, and the part I'm having trouble with.. is, you can see that an IEnumerable rules is passed in as a parameter to this method. What I would like to do, is in my second query there, where it creates a list of rules for each agency, I want to do a left outer join on my local "rules" object. Each rule object I'm passing in has a rule.ID. I want each agency to contain only the rules passed in, and if there is no data for them then simply leave its contents null. Right now, my query contains all rules returned from the database and their data. However, I need it to contain only the rules passed into the method, regardless of if it has a match with the rules returning from the database. So in other words, I need to do a left outer join on my local "rules" object with the rules I have in there now. You can see where I added comments to the above code to explain where and what I'm trying to do. So, if "rules" only contains 3 rules with their ID's set, then this query will only return those 3 rules for each agency, regardless of whether there is data for those rules (its data will be null). Rather than return all rules for each agency, which is what it does now. How do I write this left-outer join for a "local" object in my LINQ to SQL query? Here is an attempt by me to do my left-outer-join on my "rules" object and the rules in my AuditAgencies after that second query above: foreach (var agency in AuditAgencies) { agency.Rules = from rule in rules join lr in agency.Rules on rule.EnterpriseID equals lr.AuditRuleID into g from lr in g.DefaultIfEmpty() select new AuditAgencyRule { AuditRuleID = rule.EnterpriseID, AuditRuleName = rule.Name, Days = lr.Days, Flagged = lr.Flagged, PercentFlagged = lr.PercentFlagged }; } No dice. Now, instead of all the rules, I'm getting ~no~ rules. When all I want is to just get the rules I'm passing into this method. Can someone point me in the right direction?
