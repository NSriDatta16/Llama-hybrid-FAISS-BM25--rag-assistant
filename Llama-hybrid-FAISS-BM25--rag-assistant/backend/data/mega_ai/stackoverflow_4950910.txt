[site]: stackoverflow
[post_id]: 4950910
[parent_id]: 4928457
[tags]: 
Ok, so after a bit of playing around with it I managed to find a solution, I really appreciated Brian Bishop's help, who managed to very much point me in the right direction. As Brian suggested, simply entering d as a UIComponent rather a sprite allowed the dMove to effect (I'm still not sure why this is, as the dFade effect worked when it was still a sprite). However adding the floatBG (BG being background, the UIComponent to which all the d UIComponents are added) each time was unnecessary, so I made this.addElement(floatBG) part of my creationComplete function I then ran into the issue that the application began to fill with the d instances (d originally stood for "datapoint" by the way, which was kind of the theme of the effect which I was trying to create, a plume of them), and progressively slowed the application to a crawl. To continuously add d elements is necessary as it's part of the logo that sits in the corner of the screen looking as pretty as I can make it... Eventually I came to the below solution, the crux of it was to load floatBG with 600 dummy UIComponents, and then with each cycle of the addDP function both add a moving d UIComponent to floatBG and remove another UIComponent off of the total array of children which it contains. Thus, in the end it looked something like this: Ok, apologies if that was pretty long-winded, but someone may find it useful... it's a nice effect (I think so anyway) I use the mask to give a sharp edge to the point at which the d elements appear. Alternatively one could just place it behind another object, but if, as in my case, the object is a line of width less than the size of some of the d elements, such a mask is necessary. The colour is declared as a variable at the beginning as I'll likely add a function to change it on click, or something similar. Thanks! Josh
