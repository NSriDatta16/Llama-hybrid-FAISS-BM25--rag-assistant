[site]: stackoverflow
[post_id]: 5295921
[parent_id]: 5293877
[tags]: 
You'd want to use the ExpandoObject as you can dynamically add properties as needed. There isn't however a direct way to populate an instance with the values from another object easily. You'll have to add it manually using reflection. Do you want to write a wrapper object where you could add properties to while still accessing the inner? You may want to consider it that way you don't have to manage two copies of values between two different object instances. I wrote a test class to wrap string objects to demonstrate how you can do this (similar to how the ExpandoObject works). It should give you an idea on how you can do this for your types. class DynamicString : DynamicObject { static readonly Type strType = typeof(string); private string instance; private Dictionary dynProperties; public DynamicString(string instance) { this.instance = instance; dynProperties = new Dictionary (); } public string GetPrefixString(string prefix) { return String.Concat(prefix, instance); } public string GetSuffixString(string suffix) { return String.Concat(instance, suffix); } public override string ToString() { return instance; } public override bool TryConvert(ConvertBinder binder, out object result) { if (binder.Type != typeof(string)) return base.TryConvert(binder, out result); result = instance; return true; } public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result) { var method = strType.GetMethod(binder.Name, args.Select(a => a.GetType()).ToArray()); if (method == null) { result = null; return false; } result = method.Invoke(instance, args); return true; } public override bool TryGetMember(GetMemberBinder binder, out object result) { var members = strType.GetMember(binder.Name); if (members.Length > 0) { var member = members.Single(); switch (member.MemberType) { case MemberTypes.Property: result = ((PropertyInfo)member).GetValue(instance, null); return true; break; case MemberTypes.Field: result = ((FieldInfo)member).GetValue(instance); return true; break; } } return dynProperties.TryGetValue(binder.Name, out result); } public override bool TrySetMember(SetMemberBinder binder, object value) { var ret = base.TrySetMember(binder, value); if (ret) return true; dynProperties[binder.Name] = value; return true; } } If you want to be adventurous, you can define your own meta objects to handle the bindings. You could end up with reusable meta objects for different types and simplify your code immensely. I've been playing with this for a while and have this so far. It doesn't handle dynamically adding properties yet. I won't be working on this any further but I'll just leave it here for reference. class DynamicString : DynamicObject { class DynamicStringMetaObject : DynamicMetaObject { public DynamicStringMetaObject(Expression parameter, object value) : base(parameter, BindingRestrictions.Empty, value) { } public override DynamicMetaObject BindConvert(ConvertBinder binder) { if (binder.Type == typeof(string)) { var valueType = Value.GetType(); return new DynamicMetaObject( Expression.MakeMemberAccess( Expression.Convert(Expression, valueType), valueType.GetProperty("Instance")), BindingRestrictions.GetTypeRestriction(Expression, valueType)); } return base.BindConvert(binder); } public override DynamicMetaObject BindGetMember(GetMemberBinder binder) { System.Diagnostics.Trace.WriteLine(String.Format("BindGetMember: {0}", binder.Name)); var valueType = Value.GetType(); var self = Expression.Convert(Expression, valueType); var valueMembers = valueType.GetMember(binder.Name); if (valueMembers.Length > 0) { return BindGetMember(self, valueMembers.Single()); } var members = typeof(string).GetMember(binder.Name); if (members.Length > 0) { var instance = Expression.MakeMemberAccess( self, valueType.GetProperty("Instance")); return BindGetMember(instance, members.Single()); } return base.BindGetMember(binder); } private DynamicMetaObject BindGetMember(Expression instance, MemberInfo member) { return new DynamicMetaObject( Expression.Convert( Expression.MakeMemberAccess(instance, member), typeof(object)), BindingRestrictions.GetTypeRestriction(Expression, Value.GetType()) ); } } public string Instance { get; private set; } public DynamicString(string instance) { Instance = instance; } public override DynamicMetaObject GetMetaObject(Expression parameter) { return new DynamicStringMetaObject(parameter, this); } public override string ToString() { return Instance; } public string GetPrefixString(string prefix) { return String.Concat(prefix, Instance); } public string GetSuffixString(string suffix) { return String.Concat(Instance, suffix); } }
