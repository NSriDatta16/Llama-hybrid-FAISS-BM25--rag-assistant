[site]: stackoverflow
[post_id]: 3536628
[parent_id]: 3536409
[tags]: 
Here's my rather anti-pythonic implementation that nevertheless leverages python's wonderful built in sets and strings. a = 'ABCDDEGF' b = 'FPCDBDAX' best_solution = None best_solution_total_length = 0 def try_expand(a, b, a_loc, b_loc): # out of range checks if a_loc[0] best_solution_total_length: best_solution = (a_loc, b_loc) best_solution_total_length = len(a[a_loc[0] : a_loc[1]]) + len(b[b_loc[0] : b_loc[1]]) try_expand(a, b, (a_loc[0]-1, a_loc[1]), (b_loc[0], b_loc[1])) try_expand(a, b, (a_loc[0], a_loc[1]+1), (b_loc[0], b_loc[1])) try_expand(a, b, (a_loc[0], a_loc[1]), (b_loc[0]-1, b_loc[1])) try_expand(a, b, (a_loc[0], a_loc[1]), (b_loc[0], b_loc[1]+1)) for a_i in range(len(a)): for b_i in range(len(b)): # starts of the recursive expansion from identical letters in two substrings if a[a_i] == b[b_i]: # if substrings were expanded from this range before then there won't be an answer there if best_solution == None or best_solution[0][0] > a_i or best_solution[0][1] b_i or best_solution[1][1] Forgot to mention that this is obviously a fairly bruteforce approach and I'm sure there's an algorithm that runs much, much faster.
