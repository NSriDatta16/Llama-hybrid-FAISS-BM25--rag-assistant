[site]: stackoverflow
[post_id]: 1582817
[parent_id]: 1582754
[tags]: 
A delegate is itself an object, so if you create a delegate, perhaps for an anonymous method, and give this to some other method to execute, and don't store the delegate for future reference, then yes, that will produce garbage. For instance, this: collection.ForEach(delegate(T item) { // do something with item }); In this case, a new delegate object is created, but beyond the call to ForEach it is not referenced, and thus eligible for garbage collection. However, calling delegates does by itself not produce garbage, any more so than calling any other method of the same type would. For instance, if you call a delegate that takes an Object parameter, passing in an Int32 value, this value will be boxed, but that would happen if you called a normal method the same way as well. So using delegates should be fine, but excessive creation of delegate objects will be a problem. Edit : A good article on memory management for Xbox and XNA is here: Managed Code Performance on Xbox 360 for XNA: Part 2 - GC and Tools . Pay attention to this quote: So how does one control GC latency? Like NetCF for devices, the Xbox GC is non-generational. That means every collection is a full collection on the managed heap. Thus, we find that GC latency is approximately linear to the number of live objects… then add the cost of heap compaction on to that. Our benchmarks show that the difference between deep object hierarchies vs. shallow ones is negligible, so it’s mostly the number of objects that matter. Small objects also tend to be a somewhat cheaper to deal with than big objects. As you can see, try to avoid creating lots of unnecessary objects, and you should fare better.
