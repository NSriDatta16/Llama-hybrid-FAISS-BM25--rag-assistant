[site]: stackoverflow
[post_id]: 5411094
[parent_id]: 
[tags]: 
View in PersistenceCoreDataViewController.xib won't display

Yes, I'm a newbie, but I'd sure appreciate some help. I've got a fairly simple example app I'm working through in an effort to learn about Core Data. I've got a app that simply displays four text fields and allows a user to save text in those four fields. The app compiles, but upon execution I get a "black" screen. I had initially assumed my problem was that my view in my PersitenecCoreDataViewController.xib wasn't displaying for some reason. However, in my debugger console I've found where my app is being terminated due to an uncaught exception: NSInvalidArgumentException', reason: 'executeFetchRequest:error: A fetch request must have an entity I'm now thinking I'm not setting up my fetch request properly. I've got my app delegate and viewController classes code listed below. Thanks in advance for your time and assistance. . . // PersistenceCoreDataAppDelegate.h // Created by RICHARD COLEMAN on 3/21/11. #import #import @class PersistenceCoreDataViewController; @interface PersistenceCoreDataAppDelegate : NSObject { UIWindow* window; PersistenceCoreDataViewController* rootController; @private NSManagedObjectContext* managedObjectContext_; NSManagedObjectModel* managedObjectModel_; NSPersistentStoreCoordinator* persistentStoreCoordinator_; } @property (nonatomic, retain) IBOutlet UIWindow* window; @property (nonatomic, retain, readonly) NSManagedObjectContext* managedObjectContext; @property (nonatomic, retain, readonly) NSManagedObjectModel* managedObjectModel; @property (nonatomic, retain, readonly) NSPersistentStoreCoordinator* persistentStoreCoordinator; @property (nonatomic, retain) IBOutlet PersistenceCoreDataViewController* rootController; - (NSString *)applicationDocumentsDirectory; @end // PersistenceCoreDataAppDelegate.m // Created by RICHARD COLEMAN on 3/21/11. #import "PersistenceCoreDataAppDelegate.h" #import "PersistenceCoreDataViewController.h" @implementation PersistenceCoreDataAppDelegate @synthesize window; @synthesize rootController; #pragma mark - #pragma mark Application lifecycle - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Override point for customization after application launch. [window addSubview:rootController.view]; [window makeKeyAndVisible]; return YES; } // applicationWillTerminate: saves changes in the application's managed object context // before the application terminates. - (void)applicationWillTerminate:(UIApplication *)application { NSError *error = nil; if (managedObjectContext_ != nil) { if ([managedObjectContext_ hasChanges] && ![managedObjectContext_ save:&error]) { NSLog(@"Unresolved error %@, %@", error, [error userInfo]); abort(); } } } #pragma mark - #pragma mark Core Data stack - (NSManagedObjectContext *)managedObjectContext { if (managedObjectContext_ != nil) { return managedObjectContext_; } NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator]; if (coordinator != nil) { managedObjectContext_ = [[NSManagedObjectContext alloc] init]; [managedObjectContext_ setPersistentStoreCoordinator:coordinator]; } return managedObjectContext_; } - (NSManagedObjectModel *)managedObjectModel { if (managedObjectModel_ != nil) { return managedObjectModel_; } NSString *modelPath = [[NSBundle mainBundle] pathForResource:@"PersistenceCoreData" ofType:@"momd"]; NSURL *modelURL = [NSURL fileURLWithPath:modelPath]; managedObjectModel_ = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; return managedObjectModel_; } - (NSPersistentStoreCoordinator *)persistentStoreCoordinator { if (persistentStoreCoordinator_ != nil) { return persistentStoreCoordinator_; } NSURL *storeURL = [NSURL fileURLWithPath: [[self applicationDocumentsDirectory] stringByAppendingPathComponent: @"PersistenceCoreData.sqlite"]]; NSError *error = nil; persistentStoreCoordinator_ = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]]; if (![persistentStoreCoordinator_ addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&error]) { NSLog(@"Unresolved error %@, %@", error, [error userInfo]); abort(); } return persistentStoreCoordinator_; } #pragma mark - #pragma mark Applications Documents directory - (NSString *)applicationDocumentsDirectory { return [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; } #pragma mark - #pragma mark Memory management - (void)applicationDidReceiveMemoryWarning:(UIApplication *)application { } - (void)dealloc { [managedObjectContext_ release]; [managedObjectModel_ release]; [persistentStoreCoordinator_ release]; [window release]; [super dealloc]; } @end // PersistenceCoreDataViewController.h // Created by RICHARD COLEMAN on 3/21/11. #import @interface PersistenceCoreDataViewController : UIViewController { UITextField* line1; UITextField* line2; UITextField* line3; UITextField* line4; } @property (nonatomic, retain) IBOutlet UITextField* line1; @property (nonatomic, retain) IBOutlet UITextField* line2; @property (nonatomic, retain) IBOutlet UITextField* line3; @property (nonatomic, retain) IBOutlet UITextField* line4; @end // PersistenceCoreDataViewController.m // Created by RICHARD COLEMAN on 3/21/11. #import "PersistenceCoreDataViewController.h" #import "PersistenceCoreDataAppDelegate.h" @implementation PersistenceCoreDataViewController @synthesize line1; @synthesize line2; @synthesize line3; @synthesize line4; - (void)applicationWillTerminate:(NSNotification *)notification { // Get a reference to our application delegate, which we then use to get the managed object context, // i.e. context, that was created for us // Remember an application delegate performs a specific action at a certain predefined time on behalf // of the application PersistenceCoreDataAppDelegate* appDelegate = [[UIApplication sharedApplication] delegate]; NSManagedObjectContext* context = [appDelegate managedObjectContext]; NSError* error; // Loop to execute 4x, ie. once for each line for (int i = 1; i 0) theLine = [objects objectAtIndex:0]; else theLine = [NSEntityDescription insertNewObjectForEntityForName:@" Line" inManagedObjectContext:context]; // use key-value coding to set the line number and text for this managed object [theLine setValue:[NSNumber numberWithInt:i] forKey:@" lineNum"]; [theLine setValue:theField.text forKey:@" lineText"]; [request release]; } // looping is complete, save changes [context save:&error]; } // this method needs to determine if there is any existing data and if so, load it - (void)viewDidLoad { // get a reference to the application delegate and use it to get a pointer to the application's // default context PersistenceCoreDataAppDelegate* appDelegate = [[UIApplication sharedApplication] delegate]; NSManagedObjectContext* context = [appDelegate managedObjectContext]; // Create an Entity Description that describes our entity NSEntityDescription* entityDescription = [NSEntityDescription entityForName:@" Line" inManagedObjectContext:context]; // Create a fetch request, i.e. a query, and pass it the entity description so it knows what type // of objects to retriev NSFetchRequest* request = [[NSFetchRequest alloc] init]; [request setEntity:entityDescription]; // We don't create a predicate as we want to retrieve all Line objects in the persistent store NSError* error; NSArray* objects = [context executeFetchRequest:request error:&error]; // Ensure we get back a valid array if (objects == nil) { NSLog(@" There was an error!"); // Do whatever error handling is appropriate } // Using fast enumeration to loop thru array of retrieved managed objects pulling out the lineNum // and lineText and updating one of the text fields on our user interface for (NSManagedObject* oneObject in objects) { NSNumber* lineNum = [oneObject valueForKey:@" lineNum"]; NSString* lineText = [oneObject valueForKey:@" lineText"]; NSString* fieldName = [NSString stringWithFormat:@" line%@", lineNum]; UITextField* theField = [self valueForKey:fieldName]; theField.text = lineText; } [request release]; // Register to be notified when the app is about to terminate so you can save any changes the user // has made to the data UIApplication *app = [UIApplication sharedApplication]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillTerminate:) name:UIApplicationWillTerminateNotification object:app]; [super viewDidLoad]; } // Override to allow orientations other than the default portrait orientation. -(BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { // Return YES for supported orientations return (interfaceOrientation == UIInterfaceOrientationPortrait); } - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc that aren't in use. } - (void)viewDidUnload { // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; self.line1 = nil; self.line2 = nil; self.line3 = nil; self.line4 = nil; [super viewDidUnload]; } - (void)dealloc { [line1 release]; [line2 release]; [line3 release]; [line4 release]; [super dealloc]; } @end
