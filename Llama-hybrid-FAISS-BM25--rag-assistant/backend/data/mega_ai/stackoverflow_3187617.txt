[site]: stackoverflow
[post_id]: 3187617
[parent_id]: 
[tags]: 
How do you tell at run time if an IEnumerable is deferred?

I want to be able to ask, at run time, an IEnumerable if it is a deferred expression or if it is a concrete collection. So, if the method was called IsDeferred, then IsDeferred( myList.Where( i => i > 5 ) ) would return true and IsDeferred( myList.Where( i => i > 5 ).ToList() ) would return false. Thanks. EDIT: I thought I would be able to ask this without providing the underlying reason I want to do it, but I guess not. First, as others have pointed out, there is no way to tell this at compile time. The type of a collection cannot necessarily tell you whether it is lazy or not. You can have one IEnumerable which is a deferred query and another which is not (see original question). Using brute force to identify concrete types is not an elegant solution. Now, as for the reason I want to do this. Imagine a method that takes in an IEnumerable and then references it several times: public void MyMethod ( IEnumerable items) { foreach( var item in items ) // Do stuff. Console.WriteLine( "There are " + items.Count() + " items in the collection." ); if( items.Any() ) // Do some more things. } Now, this looks fine, but if I call MyMethod( myList.Where( i => i.ReallyExpensiveOperation() ) ), then you can see that the expensive Where is going to get executed three times. Once for the iteration, once for the Count, and once more for the Any. I could solve this by making the first line of the MyMethod do a ToList(). But, it would be better if I could not do that if I knew I didn't have to (like, if I knew it was a concrete list already). I understand I could re-write (the completely fake and not at all a real-world example) MyMethod to not reference the items collection multiple times, but I am not interested in that as a solution. Thanks again.
