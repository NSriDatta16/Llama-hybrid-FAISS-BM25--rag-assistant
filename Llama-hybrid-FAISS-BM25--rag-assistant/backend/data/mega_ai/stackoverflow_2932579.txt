[site]: stackoverflow
[post_id]: 2932579
[parent_id]: 2931867
[tags]: 
It might be interesting to see the value of POSIXLY_CORRECT environment variable and to determine whether xpg_echo shell option is enabled in both situations. if test -n "${POSIXLY_CORRECT+yes}"; then pc="set '$POSIXLY_CORRECT'" else pc=unset fi echo POSIXLY_CORRECT: "$pc" shopt -q xpg_echo && xe=set || xe=unset echo xpg_echo: $xe Here is the test code I used to examine the various combinations: { n=1 for p in '' p; do for x in '' x; do for e in '' e; do printf "\nmode: ${p:-_}${x:-_}${e:-_}\n" test -n "$x" && xx=-s || xx=-u bash ${p:+--posix} -c " shopt $xx xpg_echo test -n \"\${POSIXLY_CORRECT+yes}\" && pc=\"set '\$POSIXLY_CORRECT'\" || pc=unset shopt -q xpg_echo && xe=set || xe=unset echo POSIXLY_CORRECT: \"\$pc\" echo xpg_echo: \$xe echo${e:+ -e} \"$n\n$((n+1))\" " n=$((n+2)) done done done } On my system, your “as root” effect is reproduce in the last case (both POSIXLY_CORRECT and xpg_echo are set). mode: ___ POSIXLY_CORRECT: unset xpg_echo: unset 1\n2 mode: __e POSIXLY_CORRECT: unset xpg_echo: unset 3 4 mode: _x_ POSIXLY_CORRECT: unset xpg_echo: set 5 6 mode: _xe POSIXLY_CORRECT: unset xpg_echo: set 7 8 mode: p__ POSIXLY_CORRECT: set 'y' xpg_echo: unset 9\n10 mode: p_e POSIXLY_CORRECT: set 'y' xpg_echo: unset 11 12 mode: px_ POSIXLY_CORRECT: set 'y' xpg_echo: set 13 14 mode: pxe POSIXLY_CORRECT: set 'y' xpg_echo: set -e 15 16 These variations in the behavior are the primary reason the use of printf is advocated over echo . An ‘informative’ (i.e. not normative ) part of the POSIX specification for the echo command describes why echo can not be used portably unless both escapes and trailing newline suppression features are not used. New applications are encouraged to use printf instead of echo . See the echo entry under the Limitations of Builtins section of the GNU Autoconf manual. While searching, I found a random (but reasonable seeming) post that describes printf as a standardization of print from ksh . It also says that print in ksh was created to avoid portability problems with echo . Apple's Shell Scripting Primer recommends printf over echo when suppressing the trailing newline . Depending on the system and shell, sometimes printf is a shell built-in command and sometimes it is an external command, but its behavior is generally much more consistent than that of echo . You can be sure that each of the following commands will produce an embedded newline and no trailing newline: printf 'foo\nbar' printf '%s\n%s' foo bar BTW, this shows my preferred style of using single quotes for the format string to indicate that nothing funky is going into it (e.g. a parameter expansion that inserts an extra format specifier that is not reflected in the argument list).
