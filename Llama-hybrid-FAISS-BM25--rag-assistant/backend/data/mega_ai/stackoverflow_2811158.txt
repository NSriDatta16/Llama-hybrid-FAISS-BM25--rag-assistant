[site]: stackoverflow
[post_id]: 2811158
[parent_id]: 
[tags]: 
Add child to scene from within a class

I'm new to flash in general and have been writing a program with two classes that extend MovieClip (Stems and Star). I need to create a new Stems object as a child of the scene when the user stops dragging a Star object, but do not know how to reference the scene from within the Star class's code. I've tried passing the scene into the constructor of the Star and doing sometihng like: this.scene.addChild (new Stems ()); But apparently that's not how to do it... Below is the code for Stems and Stars, any advice would be appreciated greatly. package { import flash.display.MovieClip; import flash.events.*; import flash.utils.Timer; public class Stems extends MovieClip { public const centreX=1026/2; public const centreY=600/2; public var isFlowing:Boolean; public var flowerType:Number; public const outerLimit=210; public const innerLimit=100; public function Stems(fType:Number) { this.isFlowing=false; this.scaleX=this.scaleY= .0007* distanceFromCentre(this.x, this.y); this.setXY(); trace(distanceFromCentre(this.x, this.y)); if (fType==2) { gotoAndStop("Aplant"); } } public function distanceFromCentre(X:Number, Y:Number):int { return (Math.sqrt((X-centreX)*(X-centreX)+(Y-centreY)*(Y-centreY))); } public function rotateAwayFromCentre():void { var theX:int=centreX-this.x; var theY:int = (centreY - this.y) * -1; var angle = Math.atan(theY/theX)/(Math.PI/180); if (theX =0&&theY this.outerLimit || distanceFromCentre (tempX, tempY) } package { import flash.display.MovieClip; import flash.events.*; import flash.utils.Timer; public class Star extends MovieClip { public const sWide=1026; public const sTall=600; public var startingX:Number; public var startingY:Number; public var starColor:Number; public var flicker:Timer; public var canUpdatePos:Boolean=true; public const innerLimit=280; public function Star(color:Number, basefl:Number, factorial:Number) { this.setXY(); this.starColor=color; this.flicker = new Timer (basefl + factorial * (Math.ceil(100* Math.random ()))); this.flicker.addEventListener(TimerEvent.TIMER, this.tick); this.addEventListener(MouseEvent.MOUSE_OVER, this.hover); this.addEventListener(MouseEvent.MOUSE_UP, this.drop); this.addEventListener(MouseEvent.MOUSE_DOWN, this.drag); this.addChild (new Stems (2)); this.flicker.start(); this.updateAnimation(0, false); } public function distanceOK(X:Number, Y:Number):Boolean { if (Math.sqrt((X-(sWide/2))*(X-(sWide/2))+(Y-(sTall/2))*(Y-(sTall/2)))>innerLimit) { return true; } else { return false; } } public function setXY() { do { var tempX=this.x=Math.random()*sWide; var tempY=this.y=Math.random()*sTall; } while (distanceOK (tempX, tempY)==false); this.startingX=tempX; this.startingY=tempY; } public function tick(event:TimerEvent) { if (this.canUpdatePos) { this.setXY(); } this.updateAnimation(0, false); this.updateAnimation(this.starColor, false); } public function updateAnimation(color:Number, bright:Boolean) { var brightStr:String; if (bright) { brightStr="bright"; } else { brightStr="low"; } switch (color) { case 0 : this.gotoAndStop("none"); break; case 1 : this.gotoAndStop("N" + brightStr); break; case 2 : this.gotoAndStop("A" + brightStr); break; case 3 : this.gotoAndStop("F" + brightStr); break; case 4 : this.gotoAndStop("E" + brightStr); break; case 5 : this.gotoAndStop("S" + brightStr); break; } } public function hover(event:MouseEvent):void { this.updateAnimation(this.starColor, true); this.canUpdatePos=false; } public function drop(event:MouseEvent):void { this.stopDrag(); this.x=this.startingX; this.y=this.startingY; this.updateAnimation(0, false); this.canUpdatePos=true; } public function drag(event:MouseEvent):void { this.startDrag(false); this.canUpdatePos=false; } } }
