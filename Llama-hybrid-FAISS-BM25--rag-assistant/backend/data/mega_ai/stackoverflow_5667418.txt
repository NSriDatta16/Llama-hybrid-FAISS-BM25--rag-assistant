[site]: stackoverflow
[post_id]: 5667418
[parent_id]: 
[tags]: 
Accessing derived class method from base class method without virtual functions on run time

I have the following code sample. One base class and two derived classes with each their own functions (resp. function1 and function2). Neither function1 and function2 are virtual in the base class. I can not change this as these classes are already implemented. #include class Base { public: Base(){} Base(int val) : m_base(val){} virtual ~Base(){} //base class methods private: int m_base; }; class Derived1 : public Base { public: Derived1(int val) : m_derived1(val){} ~Derived1(){} void print1(){std::cout I'm trying to achieve the following now. I want to decide on run time which derived class I want to use. Moreover I would like to call them from the base class method by only using the object b. Otherwise I would have to rewrite my program for every option I allow to enter at runtime (in practice I have quite some classes from which I can choose from). int main() { int option; std::cin >> option; Base* b = new Base(5); Derived1* d1 = new Derived1(5); Derived2* d2 = new Derived2(5); d1->print1(); //obviously this works d2->print2(); //obviously this works //In reality I thus have a function in d1 and d2 which is not present in b //I have to decide on runtime which class I need to use if(option == 1) { b = d1; } else if(option == 2) { b = d2; } /* Rest of program ... b->invokeMethod; // ... // b->invokeMoreMethods; */ //Call derived functions on base object //b->print1(); //fails obviously if(option == 1) { dynamic_cast (b)->print1(); //will work if option == 1 is specified (*) } if(option == 2) { dynamic_cast (b)->print2(); //will work if option == 2 is specified (*) } return 0; } Is it possible to do the (*) code lines without an if(option == 1) and if(option == 2) loop? I can't make use of any virtual functionality as it is not implemented... Are there more elegant solutions to this problem?
