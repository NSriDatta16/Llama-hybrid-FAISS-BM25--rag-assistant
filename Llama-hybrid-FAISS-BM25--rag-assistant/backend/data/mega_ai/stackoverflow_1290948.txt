[site]: stackoverflow
[post_id]: 1290948
[parent_id]: 1290834
[tags]: 
The way we deal with this is to have our free list consist entirely of aligned nodes. In fact we have multiple free lists for different sizes of node, so we have lists that are aligned on 2 byte, 4 byte, and 16 byte boundaries (our platform doesn't care about alignment larger than one SIMD vector) . Any allocation gets rounded up to one of those values and put in a properly aligned node. So, sendMsg always copies its data into an aligned node. Since you're writing the free list yourself, you can easily enforce alignment. We would also use a #pragma or declspec to force that char buf[MAX_SIZE] array to be aligned to at least a word boundary inside the queue_t node struct. This assumes of course that the input data is aligned, but if for some reason you're passing in a message that expects to be (let's say) 3 bytes off from alignment, you can always detect that with a modulus and return an offset into the free node. With that underlying design we have interfaces that support both option 1 and 2 above. Again, we precondition that input data is always natively aligned, so our dequeue of course returns an aligned pointer; but if you need oddly aligned data in, again, just offset into the free node and return the offset pointer. This keeps you dealing in void *s thus avoiding your strict aliasing problems. (In general though I think you may need to relax your strict aliasing requirements when writing your own memory allocators, since by nature they blur types internally.)
