[site]: stackoverflow
[post_id]: 1408661
[parent_id]: 1406995
[tags]: 
You can use the "partition" algorithm along with "accumulate." Example #include #include #include #include struct test { float a; float b; test(const float one, const float two) : a(one), b(two) { } }; struct get_test_a { float interesting; get_test_a(const float i) : interesting(i) { } bool operator()(const test &value) const { static const float epi = 1e-6; return value.a interesting - epi; } }; struct add_test_b { float operator()(const float init, const test &value) const { return init + value.b; } }; int main(int argc, char **argv) { using std::partition; using std::accumulate; using std::distance; typedef std::vector container; container myContainer; // Say 'myVector' contains these five elements {a, b}: // {1, 1}, {1, 2}, {2, 1}, {1, 3}, {2, 2} myContainer.push_back(test(1, 1)); myContainer.push_back(test(1, 2)); myContainer.push_back(test(2, 1)); myContainer.push_back(test(1, 3)); myContainer.push_back(test(2, 2)); // I want to get v[0], v[1], v[3] (where a is 1) and // average b: (1 + 2 + 3)/3 = 2, // and v[2] and v[4] (where a is 2) and average b: (1+2)/2 = 1.5 const container::iterator split = partition(myContainer.begin(), myContainer.end(), get_test_a(1)); const float avg_of_one = accumulate(myContainer.begin(), split, 0.0f, add_test_b()) / distance(myContainer.begin(), split); const float avg_of_others = accumulate(split, myContainer.end(), 0.0f, add_test_b()) / distance(split, myContainer.end()); std::cout Documentation from the gcc headers /** * @brief Move elements for which a predicate is true to the beginning * of a sequence. * @ingroup mutating_algorithms * @param first A forward iterator. * @param last A forward iterator. * @param pred A predicate functor. * @return An iterator @p middle such that @p pred(i) is true for each * iterator @p i in the range @p [first,middle) and false for each @p i * in the range @p [middle,last). * * @p pred must not modify its operand. @p partition() does not preserve * the relative ordering of elements in each group, use * @p stable_partition() if this is needed. */ template inline _ForwardIterator partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) /** * @brief Accumulate values in a range with operation. * * Accumulates the values in the range [first,last) using the function * object @a binary_op. The initial value is @a init. The values are * processed in order. * * @param first Start of range. * @param last End of range. * @param init Starting value to add other values to. * @param binary_op Function object to accumulate with. * @return The final sum. */ template inline _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op)
