[site]: stackoverflow
[post_id]: 5122674
[parent_id]: 5122447
[tags]: 
No, it's not a safe way to end your program. Static-storage data and non-local automatic objects will destruct, but local automatic objects will not. From 18.3/8 in the C++ standard: The function exit() has additional behavior in this International Standard: First, objects with static storage duration are destroyed and functions registered by calling atexit are called. Non-local objects with static storage duration are destroyed […]. (Automatic objects are not destroyed as a result of calling exit() .)[207]) […] A local static object obj3 is destroyed at the same time it would be if a function calling the obj3 destructor were registered with atexit at the completion of the obj3 constructor. Next, all open C streams (as mediated by the function signatures declared in ) with unwritten buffered data are flushed, all open C streams are closed, and all files created by calling tmpfile() are removed.[209]) [207]: Objects with automatic storage duration are all destroyed in a program whose function main() contains no automatic objects and executes the call to exit() . Control can be transferred directly to such a main() by throwing an exception that is caught in main() . [209]: Any C streams associated with cin , cout , etc (27.3) are flushed and closed when static objects are destroyed in the previous phase. The function tmpfile() is declared in . On a related note, std::exit(EXIT_SUCCESS) is disturbingly misleading.
