[site]: stackoverflow
[post_id]: 3166008
[parent_id]: 3165722
[tags]: 
Either the result of your stored procedure should exactly match an existing table of your LINQ model or you should add both the stored procedure and the resulting element type to your dbml file. Usually the designer generates this for you if you drop your stored procedure anywhere in the designer (not on a table). You should take a look at the dbml file to see what is happening. As an example, here's a part of a dbml file in my current project: This means I have a stored procedure named uspGetDepartments that returns objects of type uspGetDepartmentsResult . Taking a look at the corresponding designer.cs file, I see: [global::System.Data.Linq.Mapping.FunctionAttribute()] public ISingleResult uspGetDepartments() { IExecuteResult result = this.ExecuteMethodCall( this, ((MethodInfo)(MethodInfo.GetCurrentMethod()))); return ((ISingleResult )(result.ReturnValue)); } and public partial class uspGetDepartmentsResult { private System.Nullable _ParentDepartmentId; private System.Nullable _DepartmentId; private string _DepartmentName; public uspGetDepartmentsResult() {} [global::System.Data.Linq.Mapping.ColumnAttribute( Storage="_ParentDepartmentId", DbType="Int")] public System.Nullable ParentDepartmentId { get { return this._ParentDepartmentId; } set { if ((this._ParentDepartmentId != value)) { this._ParentDepartmentId = value; } } } [global::System.Data.Linq.Mapping.ColumnAttribute( Storage="_DepartmentId", DbType="Int")] public System.Nullable DepartmentId { ... } [global::System.Data.Linq.Mapping.ColumnAttribute( Storage="_DepartmentName", DbType="NVarChar(200)")] public string DepartmentName { ... } }
