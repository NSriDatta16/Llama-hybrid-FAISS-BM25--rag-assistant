[site]: stackoverflow
[post_id]: 4237246
[parent_id]: 4237079
[tags]: 
Given two classes A and B (which might be smart pointer types), there are four main ways to convert an instance of type B to type A : A is an accessible base-class object of B (e.g. B is publicly derived from A ), and the conversion can slice or simply adjust the type of a reference or pointer. (intentional strike-through). A has an accessible constructor taking a B . B has an accessible conversion operator producing an A . There exists some function that takes a B and produces an A , and you're calling that function. For smart pointers inheritance is not used to facilitate conversion, because inheritance allows for incorrect conversions; hence strike-through above. For example, if SmartPtr inherited publicly from SmartPtr , then one would be able to do SmartPtr & spBase = spDerived; , and then e.g. spBase = spOtherDerived , which would be rather problematic... At a suitably high level of abstraction this is essentially the same problem as for const for pointer conversions; see FAQ item 18.17 "Why am I getting an error converting a Foo** → Foo const**?" . So, smart pointer conversions are generally expressed via the last three bullet points, namely constructors, conversion operators and named conversion functions. Essentially there are three smart pointers in C++0x, disregarding the deprecated auto_ptr : std::unique_ptr for single objects. std::unique_ptr for arrays. std::shared_ptr for single objects. unique_ptr expresses ownership transfer , as the old auto_ptr did and does. But auto_ptr did not support arrays. unique_ptr does, and that affects possible conversions. For single objects, unique_ptr supports the conversions that corresponding raw pointers does, via constructors. It has a templated constructor taking a unique_ptr of other type. See e.g. C++0x draft N3126 §20.9.10.2. But, for arrays that would be just as dangerous as with raw pointers! And so for arrays unique_ptr does not offer base/derived conversion. See e.g. C++0x draft N3126 §20.9.10.3. Since unique_ptr expresses ownership transfer while shared_ptr expressed shared ownership there can be no safe general conversion from shared_ptr to unique_ptr . However, the other way, the Boost shared_ptr has a constructor taking auto_ptr , and the C++0x shared_ptr retains this (also has it) and naturally adds a constructor taking unique_ptr . See C++0x draft N3126 §20.9.11.2/1. shared_ptr provides base/derived conversions via constructors and via free functions that conceptually implement "casts". Essentially this means that shared_ptr is pretty dangerous to use directly for arrays of class type objects. For that use, wrap it. Converting from shared_ptr to unique_ptr is, as mentioned, not supported as a general operation. Because shared ownership is not directly compatible with ownership transfer. However, disregarding complications wrt. thread safety, shared_ptr::unique tells you whether there is a single owner (namely your instance), and then, if you have the requisite knowledge of how the initial shared_ptr was constructed, you can use the free function get_deleter to get a pointer to the deleter function, and do some low level shenanigans. If you understand completely what I'm talking about here, then fine, good. If not, then it's best that I don't give more details, because this is a very very special case and it requires utmost care and that you Really Know What You're Doing™. ;-) Well, that's about it. I'm not discussing weak_ptr , since it's just part of the shared_ptr functionality. But hopefully the above is what you're asking about.
