[site]: stackoverflow
[post_id]: 2467629
[parent_id]: 2466735
[tags]: 
Originally, I mentioned in 2012 git archive (see Jared Forsyth 's answer and Robert Knight 's answer ), since git1.7.9.5 (March 2012) , Paul Brannan 's answer : git archive --format=tar --remote=origin HEAD:path/to/directory -- filename | tar -O -xf - But: in 2013, that was no longer possible for remote https://github.com URLs . See the old page " Can I archive a repository? " The current (2018) page " About archiving content and data on GitHub " recommends using third-party services like GHTorrent or GH Archive . So you can also deal with local copies/clone: You could alternatively do the following if you have a local copy of the bare repository as mentioned in this answer , git --no-pager --git-dir /path/to/bar/repo.git show branch:path/to/file >file Or you must clone first the repo, meaning you get the full history: in the .git repo in the working tree. But then you can do a sparse checkout (if you are using Git1.7+),: enable the sparse checkout option ( git config core.sparsecheckout true ) adding what you want to see in the .git/info/sparse-checkout file re-reading the working tree to only display what you need To re-read the working tree: $ git read-tree -m -u HEAD That way, you end up with a working tree including precisely what you want (even if it is only one file) Richard Gomes points ( in the comments ) to " How do I clone, fetch or sparse checkout a single directory or a list of directories from git repository? " A bash function which avoids downloading the history, which retrieves a single branch and which retrieves a list of files or directories you need. With Git 2.40 (Q1 2023), the logic to see if we are using the "cone" mode by checking the sparsity patterns has been tightened to avoid mistaking a pattern that names a single file as specifying a cone. See commit 5842710 (03 Jan 2023) by William Sprent ( williams-unity ) . (Merged by Junio C Hamano -- gitster -- in commit ab85a7d , 16 Jan 2023) dir : check for single file cone patterns Signed-off-by: William Sprent Acked-by: Victoria Dye The sparse checkout documentation states that the cone mode pattern set is limited to patterns that either recursively include directories or patterns that match all files in a directory. In the sparse checkout file, the former manifest in the form: /A/B/C/ while the latter become a pair of patterns either in the form: /A/B/ !/A/B/*/ or in the special case of matching the toplevel files: /* !/*/ The ' add_pattern_to_hashsets() ' function contains checks which serve to disable cone-mode when non-cone patterns are encountered. However, these do not catch when the pattern list attempts to match a single file or directory, e.g. a pattern in the form: /A/B/C This causes sparse-checkout to exhibit unexpected behaviour when such a pattern is in the sparse-checkout file and cone mode is enabled. Concretely, with the pattern like the above, sparse-checkout, in non-cone mode, will only include the directory or file located at ' /A/B/C '. However, with cone mode enabled, sparse-checkout will instead just manifest the toplevel files but not any file located at ' /A/B/C '. Relatedly, issues occur when supplying the same kind of filter when partial cloning with ' --filter=sparse:oid= '. ' upload-pack ' will correctly just include the objects that match the non-cone pattern matching. Which means that checking out the newly cloned repo with the same filter, but with cone mode enabled, fails due to missing objects. To fix these issues, add a cone mode pattern check that asserts that every pattern is either a directory match or the pattern ' /* '. Add a test to verify the new pattern check and modify another to reflect that non-directory patterns are caught earlier.
