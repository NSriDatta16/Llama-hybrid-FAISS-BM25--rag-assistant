[site]: stackoverflow
[post_id]: 5711382
[parent_id]: 
[tags]: 
Normalizing Frequencies of Chords, Parameter Passing

So, in the following code, I am generating a wav file from notes and composed chords. I've got it working for single notes and chords of two notes, but for combinations of more than 2 notes, I run into problems because I am not normalizing the frequencies. I know what I need to do (divide the frequencies at each frame by the number of notes composing it) but not necessarily how to do it in an elegant manner (or, in any manner at all). What has to happen is, I need to somehow get the length of the list returned by notes'' up to buildChord , and then work out how to map a division by that number across the input to buildChord . I'm really at a loss, here, so any input would be greatly appreciated. import Data.WAVE import Control.Applicative import Data.Char (isDigit) import Data.Function (on) import Data.Int (Int32) import Data.List (transpose, groupBy) import Data.List.Split (splitOn, split, oneOf) import System.IO (hGetContents, Handle, openFile, IOMode(..)) a4 :: Double a4 = 440.0 frameRate :: Int frameRate = 32000 noteLength :: Double noteLength = 1 volume :: Int32 volume = maxBound `div` 2 buildChord :: [[Double]] -> WAVESamples buildChord freqs = map ((:[]) . round . sum) $ transpose freqs generateSoundWave :: Int -- | Samples Per Second -> Double -- | Length of Sound in Seconds -> Int32 -- | Volume -> Double -- | Frequency -> [Double] generateSoundWave sPS len vol freq = take (round $ len * fromIntegral sPS) $ map ((* fromIntegral vol) . sin) [0.0, (freq * 2 * pi / fromIntegral sPS)..] generateSoundWaves :: Int -- | Samples Per Second -> Double -- | Length of Sound in Seconds -> Int32 -- | Volume -> [Double] -- | Frequency -> [[Double]] generateSoundWaves sPS len vol = map (generateSoundWave sPS len vol) noteToSine :: String -> WAVESamples noteToSine chord = buildChord $ generateSoundWaves frameRate noteLength volume freqs where freqs = getFreqs $ notes chord notes'' :: String -> [String] notes'' = splitOn "/" notes' :: [String] -> [[String]] notes' = map (split (oneOf "1234567890")) notes :: String -> [(String, Int)] notes chord = concatMap pair $ notes' $ notes'' chord where pair (x:y:ys) = (x, read y :: Int) : pair ys pair _ = [] notesToSines :: String -> WAVESamples notesToSines = concatMap noteToSine . splitOn " " getFreq :: (String, Int) -> Double getFreq (note, octave) = if octave >= -1 && octave 0.0 "C" -> 0.0 "C#" -> 1.0 "Db" -> 1.0 "D" -> 2.0 "D#" -> 3.0 "Eb" -> 3.0 "E" -> 4.0 "Fb" -> 4.0 "E#" -> 5.0 "F" -> 5.0 "F#" -> 6.0 "Gb" -> 6.0 "G" -> 7.0 "G#" -> 8.0 "Ab" -> 8.0 "A" -> 9.0 "A#" -> 10.0 "Bb" -> 10.0 "B" -> 11.0 "Cb" -> 11.0 _ -> 12.0 getFreqs :: [(String, Int)] -> [Double] getFreqs = map getFreq header :: WAVEHeader header = WAVEHeader 1 frameRate 32 Nothing getFileName :: IO FilePath getFileName = putStr "Enter the name of the file: " >> getLine getChordsAndOctaves :: IO String getChordsAndOctaves = getFileName >>= \n -> openFile n ReadMode >>= hGetContents main :: IO () main = getChordsAndOctaves >>= \co -> putWAVEFile "out.wav" (WAVE header $ notesToSines co)
