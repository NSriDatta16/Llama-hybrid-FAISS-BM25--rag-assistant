[site]: stackoverflow
[post_id]: 1489158
[parent_id]: 1488772
[tags]: 
I took the liberty to summarize your post in two main questions. I hope I managed to capture the essence of what you are asking. Q) What is the relationship between the intefaces exposed by the DAL and the ones exposed by the BLL? A) The BLL is an outward-facing API, and as such it should implement functionality that is useful to the external consumers of the application and expose it in a way that makes sense to them. The DAL, on the contrary, is a inward-facing API that exposes functionality to retrieve and persist data in way that hides the details of the storage mechanism being used. In short, the DAL focuses on how data is being represented and managed internally in the application, while the BLL focuses on exposing data in way that is meaningful to consumers. Q) How many methods should a public API have, and which ones? A) The design of an API is strictly related to what it is meant to achieve and by whom it will be used. In practice, this means that you should know the target audience of your API, and give them only what they need to get the job done . Since it is impossible to predict all the possible ways an API will be used, it is important to decide which main use cases to support, and work to make them really straightforward in the API. A good principle to keep in mind is what Alan Kay once said: Simple things should be simple, complex things should be possible. A few extensibility points can be built into the API to obtain a certain degree of flexibility. A common way to achieve this is to use interfaces to define the behavior of the API. This will allow consumers to replace or extend the pieces of the built-in functionality by providing custom implementations. To your point, I believe it is a good idea to prefer fewer coarse-grained methods in the BLL to cover all the functionality required by an entire business operation. On the other side it is perfectly fine to have many smaller data-centric methods in the DAL to work with specific pieces of data. UPDATE: About interfaces Interfaces should exist between layers. More specifically, classes should interact with classes from other layers exclusively through interfaces. For example, the DAL should expose interfaces for the classes used to access data, like IOrderHeaderTable or IOrderRepository depending on the design pattern being used. The BLL should expose classes used to execute business operations, like IOrderManagementWorkflow , or ICustomerService . Note: common functionality inside a layer can still be placed in base classes, since in modern Object-Oriented languages like C#, VB.NET and Java a class can both inherit from a base class and implement one or more interfaces. Also, external parties who wish to customize the built-in functionality by implementing any of the provided public interfaces can do so without needing access to the source code. Interfaces should however be self-describing and well-documented, in order to make it easy for extenders to understand its semantics. About the BLL The BLL should be explicit about the business logic it supports. Therefore it is generally a good idea to have methods that are directly related to business operations. For added clarity, instead of overloading methods to work with different parameters, I believe it is better to have one method that accepts a single parameter. This parameter would be an object containing all the data for the method to work with. Some of that data could be required, some could be optional and would influence the effect of the operation. Implementation detail: this kind of BLL API is fully supported by ObjectDataSource control built into ASP.NET Web Forms. About the API An API should contain all methods the designer can come up with, within the scope defined by the use cases the API is intended to support .
