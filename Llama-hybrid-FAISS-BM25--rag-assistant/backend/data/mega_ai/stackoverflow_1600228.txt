[site]: stackoverflow
[post_id]: 1600228
[parent_id]: 1600130
[tags]: 
As Russ Cam said, you avoid polluting the global namespace, which is very important in these days of combining scripts from multiple locations (TinyMCE, etc.). As Alex Sexton said, it makes for good code organisation as well. If you're using this technique, I'd suggest using the module pattern. This still uses object literals, but as the return value from a scoping function: var MyThingy = (function() { function doSomethingCool() { ... } function internalSomething() { .... } function anotherNiftyThing() { // Note that within the scoping function, functions can // call each other direct. doSomethingCool(); internalSomething(); } return { doSomethingCool: doSomethingCool, anotherNiftyThing: anotherNiftyThing }; })(); External use: MyThingy.doSomethingCool(); The scoping function is wrapped around all of your functions, and then you call it immediately and store its return value. Advantages: Functions are declared normally and therefore have names . (Whereas with the {name: function() { ... }} format, all of your functions are anonymous, even though the properties referencing them have names.) Names help tools help you, from showing call stacks in a debugger, to telling you what function threw an exception. (2015 Update: The latest JavaScript specification, ECMAScript 6th edition, defines a large number of ways the JavaScript engine must infer a function's name. One of those is when the function is assigned to a property as in our {name: function() { ... }} example. So as engines implement ES6, this reason will go away.) Gives you the freedom of having private functions only used by your module (such as my internalSomething above). No other code on the page can call those functions; they're truly private. Only the ones you export at the end, in the return statement, are visible outside the scoping function. Makes it easy to return different functions depending on environment, if the implementation just changes completely (such as IE-vs-W3C stuff, or SVG vs. Canvas, etc.). Example of returning different functions: var MyUtils = (function() { function hookViaAttach(element, eventName, handler) { element.attachEvent('on' + eventName, handler); } function hookViaListener(element, eventName, handler) { element.addEventListener(eventName, handler, false); } return { hook: window.attachEvent ? hookViaAttach : hookViaListener }; })(); MyUtils.hook(document.getElementById('foo'), 'click', /* handler goes here */);
