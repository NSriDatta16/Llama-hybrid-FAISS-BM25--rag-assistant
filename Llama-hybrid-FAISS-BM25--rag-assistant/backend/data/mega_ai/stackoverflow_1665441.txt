[site]: stackoverflow
[post_id]: 1665441
[parent_id]: 1665260
[tags]: 
I will take a shot and propose a helper function that can do something like that for you in a more generic+elegant way: def check_type(value, type_def): """ This validates an object instanct against a type template presented as a simplified object. E.g. if value is list of dictionaries that have string values as key and integers as values: >> check_type(value, [{'':0}]) if value is list of dictionaries, no restriction on key/values >> check_type(value, [{}]) """ if type(value) != type(type_def): return False if hasattr(value, '__iter__'): if len(type_def) == 0: return True type_def_val = iter(type_def).next() for key in value: if not check_type(key, type_def_val): return False if type(value) is dict: if not check_type(value.values(), type_def.values()): return False return True The comment explains a sample of usage, but you can always go pretty deep, e.g. >>> check_type({1:['a', 'b'], 2:['c', 'd']}, {0:['']}) True >>> check_type({1:['a', 'b'], 2:['c', 3]}, {0:['']}) False P.S. Feel free to modify it if you want one-by-one tuple validation (e.g. validation against ([], '', {0:0}) which is not handled as it is expected now)
