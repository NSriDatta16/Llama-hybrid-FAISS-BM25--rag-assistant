[site]: stackoverflow
[post_id]: 5574051
[parent_id]: 
[tags]: 
Core Data mergeChangesFromContextDidSaveNotification Doesn't Work

I am writing a Core Data ContextManager for a larger iOS application. A ContextManager provides an NSManagedContext that is automatically updated when other ContextManagers save their NSMangedContext to the persistent data store. I have a unit test (TestContextManager) that creates two contexts, adds an object to one, and tests to see if the object appears in the other context. It doesn't. Why does the last test fail? Here's the code for a ContextManager and the failing unit test. The last assert in the unit test fails. Every other assert passes. As you can see, the ContextManager relies upon getting a change notification from a different ContextManager and using mergeChangesFromContextDidSaveNotification to update itself. Notice that everything happens on the same thread for this test. I know the NSManagedObjectContextDidSaveNotification is being sent and received correctly. I know the NSManagedObjectContextDidSaveNotification has the correct data in its userInfo dictionary. I have also run this unit test as an application test on an actual device using an SQLite persistent store -- the same assert fails. Thanks in advance! ContextManager: #import "ContextManager.h" @implementation ContextManager @synthesize context; #pragma mark - Custom code - (void)save { NSError *error = nil; if (self.context != nil) { if ([self.context hasChanges] && ![self.context save:&error]) { NSAssert1(FALSE, @"Unable to save the managed object context. UserInfo:\n%@", [error userInfo]); } } return; } - (void)mergeChanges:(NSNotification *)notification { if (notification.object != self.context) { [self.context mergeChangesFromContextDidSaveNotification:notification]; } return; } #pragma mark - Overridden NSObject methods #pragma mark Creating, copying, and deallocating object - (id)initWithPersistentStoreCoordinator:(NSPersistentStoreCoordinator *)persistentStoreCoordinator { self = [super init]; if (self) { [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(mergeChanges:) name:NSManagedObjectContextDidSaveNotification object:nil]; self.context = [[[NSManagedObjectContext alloc] init] autorelease]; [self.context setPersistentStoreCoordinator:persistentStoreCoordinator]; } return self; } - (void)dealloc { [context release]; [super dealloc]; return; } @end TestContextManager: #import "TestContextManager.h" #import "ContextManager.h" #import "CoreDataManager.h" #define TEST_MANAGED_OBJECT @"AManagedObject" @implementation TestContextManager - (void)testContextManager { CoreDataManager *coreDataManager = [[CoreDataManager alloc] init]; coreDataManager.storeType = NSInMemoryStoreType; ContextManager *contextManagerA = [coreDataManager provideContextManager]; if (!contextManagerA) STFail(@"CoreDataManager did not provide a context manager."); NSManagedObjectContext *contextA = contextManagerA.context; if (!contextA) STFail(@"ContextManager did not provide a managed object context."); // setA1 has 0 objects (or whatever is initially there). NSSet *setA1 = [contextManagerA.context registeredObjects]; [NSEntityDescription insertNewObjectForEntityForName:TEST_MANAGED_OBJECT inManagedObjectContext:contextManagerA.context]; // setA2 has 1 object. NSSet *setA2 = [contextManagerA.context registeredObjects]; STAssertTrue([setA2 count] == [setA1 count]+1, @"Context provided by ContextManager is not accepting new objects."); [contextManagerA save]; ContextManager *contextManagerB = [coreDataManager provideContextManager]; [NSEntityDescription insertNewObjectForEntityForName:TEST_MANAGED_OBJECT inManagedObjectContext:contextManagerB.context]; [contextManagerB save]; NSSet *setA3 = [contextManagerA.context registeredObjects]; // setA3 should have 2 objects
