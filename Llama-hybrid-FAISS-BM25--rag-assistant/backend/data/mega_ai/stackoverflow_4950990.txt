[site]: stackoverflow
[post_id]: 4950990
[parent_id]: 4950749
[tags]: 
The best way to do this is to hit-test the bezier path. This requires access to the path outside of the drawRect: method. Since your path is the always the same, you can do this easily using static variables. //add this method to your class - (UIBezierPath *)myPath { static UIBezierPath *path = nil; if(!path) { path = [[UIBezierPath bezierPath] retain]; [path moveToPoint:CGPoingMake(200.053,79.688)]; [path addLineToPoint:CGPointMake(100.053,179.688)]; [path addLineToPoint:CGPointMake(304.412,280.125)]; [path addLineToPoint:CGPointMake(308.055,298.513)]; [path addLineToPoint:CGPointMake(200.053,79.688)]; [path closePath]; path.lineWidth = 5; } return path; } - (void)drawRect:(CGRect)rect { UIBezierPath* aPath = [self myPath]; [[UIColor blackColor] setStroke]; [[UIColor redColor] setFill]; CGContextRef aRef = UIGraphicsGetCurrentContext(); CGContextTranslateCTM(aRef, 50, 50); [aPath fill]; } -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { if(![[self myPath] containsPoint:[[touches anyObject] locationInView:self]]) return; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Title" message:@"Some message" delegate:self cancelButtonTitle:@"Cancel" otherButtonTitles: nil]; //After some time [alert show]; [alert release]; } Edit for a custom view which only responds to events inside the path. - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event { return [[self myPath] containsPoint:point]; } Using this method, you won't need to check whether or not the touch is inside the path in touchesBegan because you shouldn't get any events which would fail the test. You can move the view by changing its frame origin the same amount the touch moved.
