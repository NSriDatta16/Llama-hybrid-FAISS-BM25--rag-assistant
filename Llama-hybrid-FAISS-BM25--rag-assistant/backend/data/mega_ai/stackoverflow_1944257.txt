[site]: stackoverflow
[post_id]: 1944257
[parent_id]: 1944217
[tags]: 
That is, without a doubt, the second most hideous SQL query I have ever laid my eyes on :-) My advice is to trade storage requirements for speed. This is a common trick used when you find your queries have a lot of per-row functions ( ifnull , case and so forth). These per-row functions never scale very well as the table becomes larger. Create new fields in the table which will hold the values you want to extract and then calculate those values on insert/update (with a trigger) rather than select. This doesn't technically break 3NF since the triggers guarantee data consistency between columns. The vast majority of database tables are read far more often than they're written so this will amortise the cost of the calculation across many selects. In addition, just about every reported problem with databases is one of speed, not storage. An example of what I mean. You can replace: case when (`s`.`fieldid` in (2,35)) then `s`.`data` else NULL end with: `s`.`data_2_35` in your query if your insert/update trigger simply sets the data_2_35 column to data or NULL depending on the value of fieldid . Then you index data_2_35 and, voila, instant speed improvement at the cost of a little storage. This trick can be done to the five case clauses, the left/regexp bit and the "naked" ifnull function as well (the ifnull functions containing min and group_concat may be harder to do).
