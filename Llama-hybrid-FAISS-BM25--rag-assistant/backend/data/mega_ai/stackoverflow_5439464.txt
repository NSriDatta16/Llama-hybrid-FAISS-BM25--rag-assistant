[site]: stackoverflow
[post_id]: 5439464
[parent_id]: 5439380
[tags]: 
You just need to implement operator new() for your class. Your implementation should get memory from an instance of the allocator. In the header file for your class, you'll need to declare the allocation/deallocation operators: public: void * operator new(size_t size); void * operator delete(void * obj, size_t size); void * operator new[](size_t size); void * operator delete[](void * obj, size_t size); Then you need to implement them. Somewhere you need to instantiate an allocator; maybe just make it a static in the file where you implement these operators. Then, just looking at the API docs on that web site, you'd do something like the below. I put in the asserts because I can't see how to pass the object size to that allocator; that effectively means that YourClass better not serve as a parent to other classes. static cds::details::Allocator allocator; void * YourClass::operator new(size_t size) { assert size == sizeof(YourClass); return allocator.New(); } void * YourClass::operator new[](size_t size) { return allocator.NewArray(size/sizeof(YourClass)); } void YourClass::operator delete(void * object, size_t size) { return allocator.Delete(object); } void YourClass::operator delete[](void * object, size_t size) { return allocator.DeleteArray(object, size/sizeof(YourClass)); } I'm not too happy with the asserts and divisions, but it's late and I'm tired. Maybe somebody else knows a more elegant way to make these APIs match up a bit better. But this'd work.
