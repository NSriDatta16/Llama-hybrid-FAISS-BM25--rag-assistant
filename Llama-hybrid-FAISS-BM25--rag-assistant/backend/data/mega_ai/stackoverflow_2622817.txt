[site]: stackoverflow
[post_id]: 2622817
[parent_id]: 2431023
[tags]: 
Some of this will come down to taste. At work we also obtain an ADODB connection handle via $db = Registry :: getDB(); Likewise you can shorthand some of this code by using method chaining: $name = Registry :: getDB()->getOne( "SELECT name FROM user WHERE user_id = ?", $userId ); Using a registry means your calling code has a concrete dependency on your Registry class. This makes testing your code difficult (personally this is the only time I've banged my head on the wall using a Registry) . If you want to add unit tests for your code, you'd often want to mock your database connection so you don't manipulate the database each time you run your test suite. You can still get round this by examining your running environment and configuring your registry with a mock database abstraction class but it's not as elegant as dependency injection (DI). The best explanation of DI and containers (for a PHP developer) I've seen are Fabien Potencier's Dependency Injection with PHP 5.3 (starting on slide 9). You pass a DI container around in place of a Registry, it provides an elegant and easy way to obtain handles to dependencies (like the Registry) but is flexible and more loosely coupled so you can mock those dependencies when needed.
