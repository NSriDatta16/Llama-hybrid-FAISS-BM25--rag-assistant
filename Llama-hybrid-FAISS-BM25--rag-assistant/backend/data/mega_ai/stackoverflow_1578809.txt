[site]: stackoverflow
[post_id]: 1578809
[parent_id]: 1578778
[tags]: 
In essence its job is very similar to IEnumerable - to represent a queryable data source - the difference being that the various LINQ methods (on Queryable ) can be more specific, to build the query using Expression trees rather than delegates (which is what Enumerable uses). The expression trees can be inspected by your chosen LINQ provider and turned into an actual query - although that is a black art in itself. This is really down to the ElementType , Expression and Provider - but in reality you rarely need to care about this as a user . Only a LINQ implementer needs to know the gory details. Re comments; I'm not quite sure what you want by way of example, but consider LINQ-to-SQL; the central object here is a DataContext , which represents our database-wrapper. This typically has a property per table (for example, Customers ), and a table implements IQueryable . But we don't use that much directly; consider: using(var ctx = new MyDataContext()) { var qry = from cust in ctx.Customers where cust.Region == "North" select new { cust.Id, cust.Name }; foreach(var row in qry) { Console.WriteLine("{0}: {1}", row.Id, row.Name); } } this becomes (by the C# compiler): var qry = ctx.Customers.Where(cust => cust.Region == "North") .Select(cust => new { cust.Id, cust.Name }); which is again interpreted (by the C# compiler) as: var qry = Queryable.Select( Queryable.Where( ctx.Customers, cust => cust.Region == "North"), cust => new { cust.Id, cust.Name }); Importantly, the static methods on Queryable take expression trees, which - rather than regular IL, get compiled to an object model. For example - just looking at the "Where", this gives us something comparable to: var cust = Expression.Parameter(typeof(Customer), "cust"); var lambda = Expression.Lambda >( Expression.Equal( Expression.Property(cust, "Region"), Expression.Constant("North") ), cust); ... Queryable.Where(ctx.Customers, lambda) ... Didn't the compiler do a lot for us? This object model can be torn apart, inspected for what it means, and put back together again by the TSQL generator - giving something like: SELECT c.Id, c.Name FROM [dbo].[Customer] c WHERE c.Region = 'North' (the string might end up as a parameter; I can't remember) None of this would be possible if we had just used a delegate. And this is the point of Queryable / IQueryable : it provides the entry-point for using expression trees. All this is very complex, so it is a good job that the compiler makes it nice and easy for us. For more information, look at " C# in Depth " or " LINQ in Action ", both of which provide coverage of these topics.
