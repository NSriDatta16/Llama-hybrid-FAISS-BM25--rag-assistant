[site]: stackoverflow
[post_id]: 4742020
[parent_id]: 4625819
[tags]: 
The fact that you are using Stream classes in your pipeline component does not make it a Streaming pipeline component per-se as you have intuitively wondered. The most appropriate way is to split the responsabilities into two components: First, you create a customer System.IO.Stream class - that is a class that wraps the original incoming stream and exposes a streaming interface. In this class, you would effectively process the bytes as they are read by the calling code. This class should have no dependency over BizTalk and you should be able to create a sample unit-test program for this class outside BizTalk. For the first case, I recommend you browse to one of several articles with source code samples . Second, the pipeline component itself, whose sole responsability is to substitute the incoming stream with an instance of your custom stream. This is an idiomatic pattern that you'll find in good pipeline components. In particular, during the execution of the Execute method , you should not read the original incoming stream . The reading will happen - automagically - by itself when the Messaging Agent takes over. The following snippet should be the canonical source code for an Execute method, barring additional code for error handling, of course: IBaseMessage IComponent.Execute(IPipelineContext pContext, IBaseMessage pInMsg) { // assign a new CustomStream to the incoming message System.IO.Stream stream = pInMsg.BodyPart.GetOriginalDataStream(); System.IO.Stream customStream = new CustomStream(stream); // return the message for downstream pipeline components (further down in the pipeline) pInMsg.BodyPart.Data = customStream; pContext.ResourceTracker.AddResource(customStream); return pInMsg; } See? No reading whatsoever in the preceding method. The entire processing should happen during the (repated) calls of the Read method in your custom Stream class. As I wrote in my response to the following question , I strongly encourage you to check out the whole series of posts Nic Barden has done about Developing Streaming Pipeline Components.
