[site]: stackoverflow
[post_id]: 1987026
[parent_id]: 1986815
[tags]: 
This is good but not great; see below for a much-simplified method. def hash_to_eval_chain(hsh) make_eval_chain(hsh).join "." end private def make_eval_chain(obj) if obj.is_a? Hash raise "Hash cannot contain multiple key-value pairs unless they are nested" if obj.size > 1 return make_eval_chain(obj.to_a.flatten) elsif obj.is_a? Array return [ obj.first, *make_eval_chain(obj.last) ] if obj.last.is_a? Hash return obj if [String, Symbol, Array].include? obj.class raise "Only strings, symbols, and hashes are allowed as values in the hash." else raise "Expected Hash, received #{obj.class}" end end # Usage: # irb> hash_to_eval_chain { :one => { :two=> { :three => { :four=> :five } } } } # => "one.two.three.four.five" I couldn't find an elegant way to roll it all into one function, so I hope two will suffice. Basically I realized that {:one => {:two => :three}}.to_a.flatten returns [:one, {:two => :three}] and said A-ha!, this is classic car/cdr-style recursion. BETTER METHOD: You know what, I was making that WAY harder than necessary. This is better (inspired by Facets' Hash#recursively method): def hash_to_eval_chain(hsh) make_eval_chain(hsh).flatten.join "." end private def make_eval_chain(obj) if obj.is_a? Hash return obj.map {|key, val| [key, *make_eval_chain(val)] } if obj.is_a?(Hash) && obj.size hash_to_eval_chain { :one => { :two=> { :three => { :four=> :five } } } } # => "one.two.three.four.five"
