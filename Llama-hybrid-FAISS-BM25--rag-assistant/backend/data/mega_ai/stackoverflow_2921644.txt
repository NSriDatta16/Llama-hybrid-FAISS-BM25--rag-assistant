[site]: stackoverflow
[post_id]: 2921644
[parent_id]: 2916285
[tags]: 
Instead of creating a wrapper for each handler in all derived classes (not even remotely a viable approach, of course), you can simply use static_cast to convert DEH::func_t to EH::func_t . Member pointers are contravariant : they convert naturally down the hierarchy and they can be manually converted up the hierarchy using static_cast (opposite of ordinary object pointers, which are covariant ). The situation you are dealing with is exactly the reason the static_cast functionality was extended to allow member pointer upcasts. Moreover, the non-trivial internal structure of a member function pointer is also implemented that way specifically to handle such situations properly. So, you can simply do DEH() { func_t f5 = &DEH::handle_event_5; register_handler(5, static_cast (f5)); ........ } I would say that in this case there's no point in defining a typedef name DEH::func_t - it is pretty useless. If you remove the definition of DEH::func_t the typical registration code will look as follows DEH() { func_t f5 = static_cast (&DEH::handle_event_5); // ... where `func_t` is the inherited `EH::func_t` register_handler(5, f5); ........ } To make it look more elegant you can provide a wrapper for register_handler in DEH or use some other means (a macro? a template?) to hide the cast. This method does not provide you with any means to verify the validity of the handler pointer at the moment of the call (as you could do with dynamic_cast in the wrapper-based version). I don't know though how much you care to have this check in place. I would say that in this context it is actually unnecessary and excessive.
