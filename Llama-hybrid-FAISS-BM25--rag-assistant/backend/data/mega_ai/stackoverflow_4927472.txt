[site]: stackoverflow
[post_id]: 4927472
[parent_id]: 4927398
[tags]: 
For one thing, I would put a virtual method on the base class called Move() and override it in the derived classes. (The following is C#) public abstract class Animal { public string Talk() { return "yak yak yak"; } public virtual string Move(); } public class Dog : Animal { public override string Move() { return "walk walk walk"; } } public class Bird : Animal { public override string Move() { return "flap flap flap"; } } But to answer your question, if you want the animal to move if (and only if) it can fly, you could define an IFlyingAnimal interface and implement it with Bird . Then you can test whether an Animal implements that interface. If it does, cast it to IFlyingAnimal and call its Fly() method. public interface IFlyingAnimal { string Fly(); } public class Bird : Animal, IFlyingAnimal { public string Fly(){ return "flap flap flap"; } } //later, in your main program public string FlyIfYouCan(Animal animal) { if (animal is IFlyingAnimal) return ((IFlyingAnimal)animal).Fly(); return "I can't fly!"; } You don't have to use an interface; you could just use if (animal is Bird) instead. But it's much better practice to do it this way; birds aren't the only animals that can fly, so you're making the decision based on what your item does , not what it is . That's what interfaces are for.
