[site]: stackoverflow
[post_id]: 2916357
[parent_id]: 2916285
[tags]: 
You really shouldn't be doing it this way. Check out boost::bind http://www.boost.org/doc/libs/1_43_0/libs/bind/bind.html Elaboration : First, I urge you to reconsider your design. Most event handler systems I've seen involve an external registrar object that maintains mappings of events to handler objects. You have the registration embedded in the EventHandler class and are doing the mapping based on function pointers, which is much less desirable. You're running into problems because you're making an end run around the built-in virtual function behavior. The point of boost::bind and the like is to create objects out of function pointers, allowing you to leverage object oriented language features. So an implementation based on boost::bind with your design as a starting point would look something like this: struct EventCallback { virtual ~EventCallback() { } virtual void handleEvent() = 0; }; template struct EventCallbackFuncObj : public IEventCallback { EventCallbackT(FuncObj funcObj) : m_funcObj(funcObj) { } virtual ~EventCallbackT() { } virtual void handleEvent() { m_funcObj(); } private: FuncObj m_funcObj; }; Then your register_handler function looks something like this: void register_handler(int event_num, EventCallback* pCallback) { m_callbacks[event_num] = pCallback; } And your register call would like like: register_handler(event, new EventCallbackFuncObj(boost::bind(&DEH::DEH_handle_event_5_wrapper, this))); Now you can create a callback object from an (object, member function) of any type and save that as the event handler for a given event without writing customized function wrapper objects.
