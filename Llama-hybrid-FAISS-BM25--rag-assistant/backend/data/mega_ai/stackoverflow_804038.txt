[site]: stackoverflow
[post_id]: 804038
[parent_id]: 803543
[tags]: 
Consider not making K a generic, but using an interface that wraps the primitive wrapper (a double wrapper!). import java.util.HashMap; public class NodeWrapper > implements Comparable > { private static HashMap minVals = new HashMap (); private K value; private NodeWrapper() { super(); } public NodeWrapper(K value, Class clazz) { super(); this.value = value; if (minVals.get(clazz)==null) { minVals.put(clazz, new NodeWrapper ()); } } public K getValue() { return value; } public static NodeWrapper getMinValue(Class clazz){ return minVals.get(clazz); } public void setValue(K value) { this.value = value; } @Override public int compareTo(NodeWrapper o) { NodeWrapper min = minVals.get(this.getClass()); if (this==min && o==min) { return 0; } else if (this==min){ return -1; } else if (o==min){ return 1; } else { return this.value.compareTo(o.value); } } } Briefly, the idea is that whenever a new class is instantiated, a minimum value is created and put into a static hashmap that stores the minimum values for each class. (In fact, these values are NOTHING at all, just a sentinel object, but since we will use object equality to determine if something is the min value, this is no problem at all.) All that's necessary is that the wrapped object be comparable to other instances of itself in general. One drawback is that when you call getMinValue you will have compiler warnings, since the return type will have no generic information. There may be a more elegant way around this, but I can't think of it right now. This general idea might be rather nice overall. However, I should really stress: this will absolutely break if you try it with any polymorphism or any mixing of mutually comparable classes. Long s and Integer s in the same tree will completely destroy you.
