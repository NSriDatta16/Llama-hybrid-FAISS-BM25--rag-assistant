[site]: stackoverflow
[post_id]: 1898692
[parent_id]: 1898544
[tags]: 
Django's database queries are evaluated lazily, so the result of thread.comment_set.all is a QuerySet, not a list. A QuerySet supports many list-like functions, but not negative slicing, so the indexing error is not coming from the template filter itself. (If you're curious, slices on QuerySet objects get translated into a limit clause on the SQL statement, which is why you can't use a negative number). In general, Django encourages a strict decoupling of templates and models; the views.py module is the glue where you do any work that requires knowledge of database models and queryset methods to translate your model data into simple variables and structures for the template. Running a related query on a model from a template is not something you typically see in a Django template, and there's a good reason for this. Right now, it may seem very simple to slice the last three elements from the comment_set. Keep in mind, though, that the database will not return results in any guaranteed order. This means that, in addition to your slice, you now also need to add an order_by clause; there's simply no way to express this in a template, nor should there be. Better to think of the view as the translation between your model and the template, and let such database-facing work be done there, rather than embedded in HTML. In this case, I would encourage you to pass an ordered slice to your template from the view: # take first three sorted descending comments = thread.comment_set.order_by('-something')[:3] context = Context({'comments':comments}) return HttpResponse(tmplt.render(context)) If you must do the slicing in the template, and you really don't care about sorting the results, pass a list to the template. The slice filter will happily do negative slicing: comments = list(thread.comment_set.all()) context = Context('comments':comments) In the template: {% for comment in comments|slice:"-3:" %}
