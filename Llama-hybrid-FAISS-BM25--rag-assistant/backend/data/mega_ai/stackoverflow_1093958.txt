[site]: stackoverflow
[post_id]: 1093958
[parent_id]: 1093618
[tags]: 
You can think of C++ as having a very primitive access control system - either you can access all members (friend or member function), or you can access only public members (everything else, except...) or you can access public and protected members (...special rules for inheritance). "Encapsulation" in the abstract is likewise a primitive access control system, except that usually we say that code which is "part of the class" is privileged and can manipulate the object in all the ways the language allows. Code which is not "part of the class" is unprivileged and must use a smaller, probably published, public interface. So, what is "friend" for? If you think of things this way, it's for writing privileged code which is not a member function. It's necessary because there are some things which for technical reasons cannot be member functions. The ones I can think of off-hand are operator overloads where you need conversion on the LHS, and specializations of standard algorithm template functions like std::swap (the latter being less of an issue, since if there's a public swap function, it's unlikely to be harmful for there to be a public swap method too. But it's nice to support those folks who want interfaces to be orthogonal). The question then is, does it break encapsulation to have privileged code which is not a member function? In Java you'd probably say "yes", since Java code is clearly "part of the class" if it's in the class definition, and not part of the class if it's not. In C++ it's a bit less clear, since member functions definitions don't have to be in the class definition to start with. There's very little difference between: // Foo.h class Foo; void bar(Foo &); class Foo { friend void bar(Foo &); public: static void baz(Foo &); }; // Foo.cpp void bar(Foo &f) { // access private members of f } void Foo::baz(Foo &f) { // access private members of f } I cannot convince myself that in any meaningful sense bar "breaks encapsulation" whereas baz "preserves encapsulation". Even a tiny degree of pragmatism indicates that bar and baz are doing exactly the same thing, and furthermore that even though bar is not a member function, it clearly is "part of the class" just as much as baz is. The only differences are syntactic, and have nothing to do with encapsulation. On the other hand, clearly "friend" can be used to completely break encapsulation, by naming every other class you can think of as your friend (like making all your members public or package protected in Java, or making all your members public in C++). "friend" does need to work with classes and not just methods, so that you can declare nested classes as friends where appropriate, and have small clusters of tightly-coupled classes which aren't nested (which is to say: draw the bounds of encapsulation at a higher level than that of a single class). If you use it to tightly couple all your classes, then you'll probably end up with bad code. This isn't really because of "friend", since all that has done is given me a new syntax to expose members that I could have exposed as "public" anyway. But if I reach for "friend" as a workaround, and use it to break through my own inadequate public interfaces, then "friend" has in effect given me an excuse for poor design. I might swear off it in future, and advise others to do likewise, but this is for the same reason I swear off drink every time I wake up hung over. Others may be wise or lucky enough to enjoy the benefits without major side-effects. So "friend", in and of itself allows encapsulation-breaking, just like pointer arithmetic does, and just like alcohol allows falling into the gutter at 3am. With care and decent design, however, particular uses of friend should not and need not be encapsulation-breaking. And, in case any potential future employers are reading this, when I drink I'm not normally hung over ;-) Ultimately the issue is that in every language I know, interfaces behave like inheritance, in the sense that the class's public interface incorporates all the members of all the interfaces it implements. The class interface is therefore larger than any other. This is no a bad thing, since the "is-a" relationship is key to OO. Furthermore, it corresponds well with what happens which you publish an interface, which is that any client might be using it. It just doesn't naturally accommodate what a lot of designs call for, which is for classes by default to have a small interface, but to also offer a larger interface to "superusers". So instead the large interface is the default, and "subusers" stick to the boring parts. So, friend is one blunt tool for offering a larger interface to "superusers" without affecting the "subuser" interface. Since it is so blunt, though, it really only works when the relevant classes are all designed together, and arguments about how coupled classes ought to be is what leads to disagreements as to what "breaks encapsulation". Remember that access levels in languages aren't supposed to enforce encapsulation, and C++ in particular is a multi-paradigm language. So C++ makes some effort to assist programmers in enforcing encapsulation, but the programmer still has to design well, and use the available features in accordance with his own programming principles.
