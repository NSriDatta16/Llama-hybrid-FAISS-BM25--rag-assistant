[site]: stackoverflow
[post_id]: 942147
[parent_id]: 942112
[tags]: 
The main problems with using the Linux kernel to replace microcontroller systems is driving the devices you are interfacing with. For this you may have to write drivers. I would say stick with C as the language because you are going to want to keep the user-space as clean as possible. Look into the uclibc library for a leaner C standard library. http://www.uclibc.org/ You may also find busybox useful. This provides many userspace utilities as a single binary. http://www.busybox.net/ Then it is simply a matter of booting from some storage to a live system and running some controlling logic through init that interfaces with your hardware. If need be you can access the live system and run the busybox utilities. Really, the only difference is that the userspace is much leaner than in a normal distribution and you will be working 'closer' to the kernel in terms of objectives. Also look into realtime linux. http://www.realtimelinuxfoundation.org/ If you need some formal promise of task completion. I suspect the hardest bit will be booting/persistent storage and interfacing with your hardware if it is exotic. If you are unfamiliar with Linux booting then http://www.cromwell-intl.com/unix/linux-boot.html Might help. In short, if you have not developed at a deep level for Linux, built your own distro, or have kernel experience then you might find the programming hard-going . http://www.linuxdevices.com/ Might also help Good Luck
