[site]: stackoverflow
[post_id]: 4126652
[parent_id]: 4126616
[tags]: 
You can't pass a pointer to a member function to something that's expecting a function pointer . Fundamentally a pointer to a member function is a completely different type than a function pointer. There is no trivial conversion between the two and can never be one as there's no this pointer, which is required to call a non-static member function. Simply adding static doesn't technically solve the problem either, since it won't have C linkage, which could be a problem with a conforming implementation. In most implementations this is well behaved, but it is not portable in general and the portable solution requires using extern "C" { void my_callback() { } } Update: Given that both of the functions you're trying to call seem to take a void* "user argument" you can use this with a variable to pass a pointer to an instance of your class, e.g. something along these lines: class CallbackHandler { public: void my_callback(); }; extern "C" { void callback_wrapper(void *arg) { static_cast (arg)->my_callback(); } } void start_pcap_listen(CallbackHandler* receiver) { pcap_t *loc; char *dev; dev = pcap_lookupdev(errbuf); loc = pcap_open_live(dev,BUFSIZ,0,-1,errbuf); pcap_loop(loc,-1,callback_wrapper,receiver); } It's not pretty, but it works.
