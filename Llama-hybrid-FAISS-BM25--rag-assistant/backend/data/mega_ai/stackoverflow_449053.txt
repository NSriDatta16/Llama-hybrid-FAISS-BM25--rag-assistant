[site]: stackoverflow
[post_id]: 449053
[parent_id]: 448890
[tags]: 
I like Mehrdad's answer a lot. It not only solves the problem, it also teaches me something about Linq as well. Thank you! I've kept banging away at the problem, though, and did come up with a different approach that I'll describe here in case someone else stumbling on this question wants to consider. My Linq to SQL code now reads: return classQuery.Select(p => new SelectClassData { ClassID = p.ClassID, Title = p.Title, sDate = p.StartDate, eDate = p.EndDate }).ToList(); Note that sDate and eDate are now DateTime objects instead of strings. In the "SelectClassData" object, I simply changed the declaration so that access to the StartDate, EndDate and TimeOfClass variables go through a property getter: public class SelectClassData { public int ClassID { get; set; } public string Title { get; set; } public DateTime sDate { get; set; } public DateTime eDate { get; set; } public string StartDate { get { return GetSDate(); } } public string EndDate { get { return GetEDate(); } } public string TimeOfClass { get { return GetTimeOfClass(); } } protected string GetSDate() { return sDate.ToShortDateString(); } protected string GetEDate() { return eDate.ToShortDateString(); } protected string GetTimeOfClass() { return sDate.ToShortTimeString() + " - " + eDate.ToShortTimeString(); } } That is, I set the sDate and eDate via the LinqToSql but do the "ToShortTimeString" and "ToShortDateString" transformations after the Linq retrieval by implementing it in the target data class.
