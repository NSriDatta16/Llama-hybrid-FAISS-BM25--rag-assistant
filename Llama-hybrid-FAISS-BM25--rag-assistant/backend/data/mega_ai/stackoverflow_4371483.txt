[site]: stackoverflow
[post_id]: 4371483
[parent_id]: 4371333
[tags]: 
Yes, this is the standard way. Function.apply() and Function.call() can help, but not always. Consider the following function foo() { var self = this; this.name = 'foo'; setTimeout( function() { alert( "Hi from " + self.name ); }, 1000 ); } new foo(); If you wanted to do this but avoid the usage of a variable like self and use call() or apply() instead... well... you look at it and start to try, but soon realize you just can't. setTimeout() is responsible for the invocation of the lambda, making it impossible for you to leverage these alternate invocation styles. You'd still end up creating some intermediary variable to hold a reference to the object.
