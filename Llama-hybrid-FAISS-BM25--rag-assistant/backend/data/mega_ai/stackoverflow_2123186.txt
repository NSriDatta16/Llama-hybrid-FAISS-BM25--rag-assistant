[site]: stackoverflow
[post_id]: 2123186
[parent_id]: 2081872
[tags]: 
I've figured out a way for you to achieve the desired result though it's a bit... not so standard. :) The idea is to rearrange a bit the order of the inner views in the structure UIImagePickerController uses. OK, so we create an UIImagePickerController object, initialize it and add an overlay view to it. May I have your attention please! The UIView object ( UIImageView in the example code) is hidden from the very beginning. Don't miss that. Finally we present the image picker controller as modal view controller. This code should be somewhere in your applicationDidFinishLaunching: , viewWillAppear: or similar appropriate about to launch methods. UIImagePickerController *anImagePickerController = [UIImagePickerController new]; anImagePickerController.delegate = self; anImagePickerController.sourceType = UIImagePickerControllerSourceTypeCamera; UIImageView *anImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"Watermark.png"]]; anImageView.frame = CGRectMake(0, 1, anImageView.image.size.width, anImageView.image.size.height); anImageView.hidden = YES; anImagePickerController.cameraOverlayView = anImageView; [viewController presentModalViewController:anImagePickerController animated:NO]; [anImagePickerController release]; [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(timerFireMethod:) userInfo:anImageView repeats:YES]; [anImageView release]; Before the overlay view ( anImageView ) is released a NSTimer is created, initialized with anImageView ( NSTimer userInfo property) and scheduled right away. Here's the method it calls: - (void)timerFireMethod:(NSTimer*)theTimer { UIView *cameraOverlayView = (UIView *)theTimer.userInfo; UIView *previewView = cameraOverlayView.superview.superview; if (previewView != nil) { [cameraOverlayView removeFromSuperview]; [previewView insertSubview:cameraOverlayView atIndex:1]; cameraOverlayView.hidden = NO; [theTimer invalidate]; } } The whole NSTimer thing is added to the flow to ensure that the reordering work around will happen exactly when the UIImagePickerController will be totally ready for that. This is it. It works, it's not standard, it's rough and quick. Again feel free to optimize and make it 'righter' (oh please do, my aim was to show you the way).
