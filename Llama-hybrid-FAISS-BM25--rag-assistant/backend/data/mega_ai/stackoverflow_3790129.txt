[site]: stackoverflow
[post_id]: 3790129
[parent_id]: 3788853
[tags]: 
Essentially, it's about doing IO in a functional style, correctly and efficiently . That's all, really. Correct and efficient are easy enough using quasi-imperative style with strict IO. Functional style is easy with lazy IO, but it's technically cheating (using unsafeInterleaveIO under the hood) and can have issues with resource management and efficiency. In very, very general terms, a lot of pure functional code follows a pattern of taking some data, recursively expanding it into smaller pieces, transforming the pieces in some fashion, then recombining it into a final result. The structure may be implicit (in the call graph of the program) or an explicit data structure being traversed. But this falls apart when IO is involved. Say your initial data is a file handle, the "recursively expand" step is reading a line from it, and you can't read the entire file into memory at once. This forces the entire read-transform-recombine process to be done for each line before reading the next one, so instead of the clean "unfold, map, fold" structure they get mashed together into explicitly recursive monadic functions using strict IO. Iteratees provide an alternative structure to solve the same problem. The "transform and recombine" steps are extracted and, instead of being functions , are changed into a data structure representing the current state of the computation. The "recursively expand" step is given the responsibility of obtaining the data and feeding it to an (otherwise passive) iteratee. What benefits does this offer? Among other things: Because an iteratee is a passive object that performs single steps of a computation, they can be easily composed in different ways--for instance, interleaving two iteratees instead of running them sequentially. The interface between iteratees and enumerators is pure, just a stream of values being processed, so a pure function can be freely spliced in between them. Data sources and computations are oblivious to each other's internal workings, decoupling input and resource management from processing and output. The end result is that a program can have a high-level structure much closer to what a pure functional version would look like, with many of the same benefits to compositionality, while simultaneously having efficiency comparable to the more imperative, strict IO version. As for being "worth the complexity"? Well, that's the thing--they're really not that complex, just a bit new and unfamiliar. The idea's been floating around for only, what, a couple years? Give it some time for things to shake out as people use iteratee-based IO in larger projects (e.g., with things like Snap), and for more examples/tutorials to appear. It's likely that, in hindsight, the current implementations will seem very rough around the edges. Somewhat related: You may want to read this discussion about functional-style IO . Iteratees aren't mentioned all that much, but the central issue is very similar. In particular this solution , which is both very elegant and goes even further than iteratees in abstracting incremental IO.
