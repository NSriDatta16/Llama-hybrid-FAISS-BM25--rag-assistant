[site]: stackoverflow
[post_id]: 1943625
[parent_id]: 1943465
[tags]: 
One of the simplest ways to avoid NullReferenceExceptions is to aggressively check for null references in your class constructors/methods/property setters and draw attention to the problem. E.g. public MyClass { private ISomeDependency m_dependencyThatWillBeUsedMuchLater // passing a null ref here will cause // an exception with a meaningful stack trace public MyClass(ISomeDependency dependency) { if(dependency == null) throw new ArgumentNullException("dependency"); m_dependencyThatWillBeUsedMuchLater = dependency; } // Used later by some other code, resulting in a NullRef public ISomeDependency Dep { get; private set; } } In the above code, if you pass a null ref, you will find out immediately that the calling code is using the type incorrectly. If there was no null reference check, the error can be obscured in many different ways. You'll notice that the .NET framework libraries nearly always fail early and often if you provide null references where it's invalid to do so. Since the exception thrown explicitly says "you messed up!" and tells you why, it makes detecting and correcting defective code a trivial task. I've heard complaints from some developers who say this practice is overly verbose and redundant as a NullReferenceException is all you need, but in practice I find it makes a big difference. This is especially the case if the call stack is deep and/or the parameter is stored and its use is deferred until later (perhaps on a different thread or obscured in some other way). What would you rather have, an ArgumentNullException at the entry method, or an obscure error in the guts of it? The further you move away from the source of an error, the harder it is to trace it.
