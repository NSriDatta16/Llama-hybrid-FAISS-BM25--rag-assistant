[site]: stackoverflow
[post_id]: 1233958
[parent_id]: 
[tags]: 
How can I improve this underperforming, terrible Serial Port code?

I have an ugly piece of Serial Port code which is very unstable. void port_DataReceived(object sender, SerialDataReceivedEventArgs e) { Thread.Sleep(100); while (port.BytesToRead > 0) { var count = port.BytesToRead; byte[] buffer = new byte[count]; var read = port.Read(buffer, 0, count); if (DataEncapsulator != null) buffer = DataEncapsulator.UnWrap(buffer); var response = dataCollector.Collect(buffer); if (response != null) { this.OnDataReceived(response); } Thread.Sleep(100); } } If I remove either Thread.Sleep(100) calls the code stops working. Of course this really slows things down and if lots of data streams in, it stops working as well unless I make the sleep even bigger. (Stops working as in pure deadlock) Please note the DataEncapsulator and DataCollector are components provided by MEF, but their performance is quite good. The class has a Listen() method which starts a background worker to receive data. public void Listen(IDataCollector dataCollector) { this.dataCollector = dataCollector; BackgroundWorker worker = new BackgroundWorker(); worker.DoWork += new DoWorkEventHandler(worker_DoWork); worker.RunWorkerAsync(); } void worker_DoWork(object sender, DoWorkEventArgs e) { port = new SerialPort(); //Event handlers port.ReceivedBytesThreshold = 15; port.DataReceived += new SerialDataReceivedEventHandler(port_DataReceived); ..... remainder of code ... Suggestions are welcome! Update: *Just a quick note about what the IDataCollector classes do. There is no way to know if all bytes of the data that has been sent are read in a single read operation. So everytime data is read it is passed to the DataColllector which returns true when a complete and valid protocol message has been received. In this case here it just checks for a sync byte, length , crc and tail byte. The real work is done later by other classes. * Update 2: I replaced the code now as suggested, but still there is something wrong: void port_DataReceived(object sender, SerialDataReceivedEventArgs e) { var count = port.BytesToRead; byte[] buffer = new byte[count]; var read = port.Read(buffer, 0, count); if (DataEncapsulator != null) buffer = DataEncapsulator.UnWrap(buffer); var response = dataCollector.Collect(buffer); if (response != null) { this.OnDataReceived(response); } } You see this works fine with a fast and stable connection. But OnDataReceived is NOT called every time data is received. (See the MSDN docs for more). So if the data gets fragmented and you only read once within the event data gets lost. And now I remember why I had the loop in the first place, because it actually does have to read multiple times if the connection is slow or unstable. Obviously I can't go back to the while loop solution, so what can I do?
