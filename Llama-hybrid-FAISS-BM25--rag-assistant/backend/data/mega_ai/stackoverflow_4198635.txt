[site]: stackoverflow
[post_id]: 4198635
[parent_id]: 
[tags]: 
Append array using apr_array_push in D

I am writing a program in the D that uses svn and I came across something I can not figure out how to convert into D syntax. I took a stab at it but it segfaults. Example of what I am trying to accomplish in C: svn_auth_provider_object_t provider; providers = apr_array_make(pool, 1, sizeof(svn_auth_provider_object_t*)); svn_auth_get_simple_provider2(&provider, null, null, pool); *(svn_auth_provider_object_t**)apr_array_push (providers) = provider; svn_auth_open(&auth_baton, providers, pool); As far as I know, this code works just fine. I have found several examples done almost exactly the same way. Here is my attempt to copy this in D: svn_auth_provider_object_t provider; providers = apr_array_make(pool, 1, svn_auth_provider_object_t.sizeof); svn_auth_get_simple_provider2(&provider, null, null, pool); void* newSlot = apr_array_push(m); newSlot = provider; svn_auth_open(&auth_baton, providers, pool); This throws a Segmentation Fault on svn_auth_open. My best guess is that the contents of provider are not ending up at the pointer held by newSlot. And I am not sure why that is. Supplemental code: /// Code taken from Apache's APR libary which is licensed under Apache License, Version 2.0 struct apr_array_header_t { apr_pool_t* pool; int elt_size; int nelts; int nalloc; char* elts; }; struct svn_auth_provider_object_t { svn_auth_provider_t *vtable; void *provider_baton; } APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr) { if (arr->nelts == arr->nalloc) { int new_size = (arr->nalloc nalloc * 2; char *new_data; new_data = apr_palloc(arr->pool, arr->elt_size * new_size); memcpy(new_data, arr->elts, arr->nalloc * arr->elt_size); memset(new_data + arr->nalloc * arr->elt_size, 0, arr->elt_size * (new_size - arr->nalloc)); arr->elts = new_data; arr->nalloc = new_size; } ++arr->nelts; return arr->elts + (arr->elt_size * (arr->nelts - 1)); } #define APR_ARRAY_IDX(ary,i,type) (((type *)(ary)->elts)[i]) #define APR_ARRAY_PUSH(ary,type) (*((type *)apr_array_push(ary))) void svn_auth_open(svn_auth_baton_t **auth_baton, apr_array_header_t *providers, apr_pool_t *pool) { svn_auth_baton_t *ab; svn_auth_provider_object_t *provider; int i; /* Build the auth_baton. */ ab = apr_pcalloc(pool, sizeof(*ab)); ab->tables = apr_hash_make(pool); ab->parameters = apr_hash_make(pool); ab->creds_cache = apr_hash_make(pool); ab->pool = pool; /* Register each provider in order. Providers of different credentials will be automatically sorted into different tables by register_provider(). */ for (i = 0; i nelts; i++) { provider_set_t *table; provider = APR_ARRAY_IDX(providers, i, svn_auth_provider_object_t *); /* Add it to the appropriate table in the auth_baton */ table = apr_hash_get(ab->tables, provider->vtable->cred_kind, APR_HASH_KEY_STRING); if (! table) { table = apr_pcalloc(pool, sizeof(*table)); table->providers = apr_array_make(pool, 1, sizeof(svn_auth_provider_object_t *)); apr_hash_set(ab->tables, provider->vtable->cred_kind, APR_HASH_KEY_STRING, table); } APR_ARRAY_PUSH(table->providers, svn_auth_provider_object_t *) = provider; } *auth_baton = ab; } My best guess is that the segfault is happening in APR_ARRAY_IDX. Everything else has a valid memory address. Additional information: This doesn't work either: providers = apr_array_make(pool, 1, svn_auth_provider_object_t.sizeof); svn_auth_provider_object_t* newSlot = cast(svn_auth_provider_object_t*) apr_array_push(providers); svn_auth_get_simple_provider2(&newSlot, null, null, pool); svn_auth_open(&auth_baton, providers, pool); So that rules out my theory that the data wasn't going to the right place. However if I comment out the array push line and just send the array empty it works fine. So, this does not segfault: providers = apr_array_make(pool, 1, svn_auth_provider_object_t.sizeof); svn_auth_open(&auth_baton, providers, pool); I also know it is not svn_auth_get_simple_provider2 because this segfaults as well... providers = apr_array_make(pool, 1, svn_auth_provider_object_t.sizeof); svn_auth_provider_object_t* newSlot = cast(svn_auth_provider_object_t*) apr_array_push(providers); svn_auth_get_ssl_server_trust_file_provider(&newSlot, pool); svn_auth_open(&auth_baton, providers, pool);
