[site]: stackoverflow
[post_id]: 5175410
[parent_id]: 5175238
[tags]: 
1) What makes you think that this is TCP flow control, as opposed to SQL Server not producing data in the intervals where there is no traffic? Check if sys.dm_exec_requests look at wait_type. The wait types are described in Waits and Queues . If is indeed the client applying TCP flow control, then you'll see the wait type ASYNC_NETWORK_IO . 2) If the issue is indeed network wait type, then the solution is not to increase the bandwidth, but obviously to reduce the traffic. The client has no business requesting so much data from the server as to cause TCP flow control. This would be caused by doing horribly wrong things in the client, like counting rows or client-side paging. Move the processing on the server, and just get small results sets with the data you need. Edit Consuming the DB call result set ultimately boils down to one form or another of this: FetchNextRow while (not EnfOfResults) { ProcessRow; FetchNextRow; } What this could mean, in real terms, it could be foreach row in IQueryable or SqlDataReader.Read() . But the basic idea is the same, that the client fetches rows from the result, process them, then gets some more rows. If the client code does anything in that ProcessRow that blocks, then the client code will not reach the point where it fetches the next row again, and thus will eventually trigger TCP flow control which in turn will cause SQL Server to suspend the query (since it has no place to write the results into). There is nothing you can do in terms of TCP to make this better. Increasing the window size can actually make maters worse, as now all those results that were previously suppressed at source (DB) are going to be created and have to be stored somewhere, which will ultimately mean live memory allocated to storage and may make things far worse than they are now. If I would be in your shoes right now I'd focus on identifying where does that ProcessRow blocking occur. An hypothesis I put forward was that that processing would be an MVC View writing into the response buffer and being blocked in turn by TCP flow control resulting from the user agent not consuming the HTTP response (eg. Ajax call completed but the browser is not running the completion code to consume the response because the main thread is looping busy on something else). As always, the best approach is to methodically measure. Some possible tools: Look at ASP.Net performance counters . Instrument your code with your own performance counters (is much easier than most developer think, see Using XSLT to generate Performance Counters code ) Non-invasive sampled performance traces, see Rapid Web Site Profiling with VSPerfASPNETCmd
