[site]: stackoverflow
[post_id]: 93797
[parent_id]: 93569
[tags]: 
As others have mentioned, this isn't part of the standard and is left up to the compiler to implement as it sees fit for the processor in question. For example, VC could easily implement different alignment requirements for an ARM processor than it does for x86 processors. Microsoft VC implements what is basically called natural alignment up to the size specified by the #pragma pack directive or the /Zp command line option. This means that, for example, any POD type with a size smaller or equal to 8 bytes will be aligned based on its size. Anything larger will be aligned on an 8 byte boundary. If it is important that you control alignment for different processors and different compilers, then you can use a packing size of 1 and pad your structures. #pragma pack(push) #pragma pack(1) struct Example { short data1; // offset 0 short padding1; // offset 2 long data2; // offset 4 }; #pragma pack(pop) In this code, the padding1 variable exists only to make sure that data2 is naturally aligned. Answer to a: Yes, that can easily cause misaligned data. On an x86 processor, this doesn't really hurt much at all. On other processors, this can result in a crash or a very slow execution. For example, the Alpha processor would throw a processor exception which would be caught by the OS. The OS would then inspect the instruction and then do the work needed to handle the misaligned data. Then execution continues. The __unaligned keyword can be used in VC to mark unaligned access for non-x86 programs (i.e. for CE).
