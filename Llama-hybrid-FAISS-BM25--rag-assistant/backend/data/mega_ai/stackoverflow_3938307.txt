[site]: stackoverflow
[post_id]: 3938307
[parent_id]: 
[tags]: 
Serializing C-style structs (using C++)

Is it evil to serialize struct objects using memcpy? In one of my projects I am doing the following: I memcpy a struct object, base64 encode it, and write it to file. I do the inverse when parsing the data. It seems to work OK, but in certain situations (for example when using the WINDOWPLACEMENT for the HWND of Windows Media Player) it turns out that the decoded data does not match sizeof(WINDOWPLACEMENT) . Here are some code fragments: // Using WINDOWPLACEMENT from Windows API headers: typedef struct tagWINDOWPLACEMENT { UINT length; UINT flags; UINT showCmd; POINT ptMinPosition; POINT ptMaxPosition; RECT rcNormalPosition; #ifdef _MAC RECT rcDevice; #endif } WINDOWPLACEMENT; static std::string EncodeWindowPlacement(const WINDOWPLACEMENT & inWindowPlacement) { std::stringstream ss; { Poco::Base64Encoder encoder(ss); // From the Poco C++ libraries const char * offset = reinterpret_cast (&inWindowPlacement); std::vector buffer(offset, offset + sizeof(inWindowPlacement)); for (size_t idx = 0; idx != buffer.size(); ++idx) { encoder > decodedString; assert(decoder.eof()); if (decoder.fail()) { throw std::runtime_error("Failed to parse Window placement data from the configuration file."); } } if (decodedString.size() != sizeof(WINDOWPLACEMENT)) { // !! Occurs frequently !! throw std::runtime_error("Errors occured during parsing of the Window placement."); } WINDOWPLACEMENT windowPlacement; memcpy(&windowPlacement, &decodedString[0], decodedString.size()); return windowPlacement; } I'm aware that copying classes in C++ using memcpy is likely to cause trouble because the copy constructors are not properly executed. I'm not sure if this also applies to C-style structs. Or is serialization by memory dumping simply not done ? Update: A bug in Poco's Base64Encoder/Decoder is not impossible, but unlikely. Its test cases seem pretty thorough: Base64Test.cpp .
