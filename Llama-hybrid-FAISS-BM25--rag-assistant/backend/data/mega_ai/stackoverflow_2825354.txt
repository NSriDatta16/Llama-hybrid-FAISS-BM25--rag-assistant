[site]: stackoverflow
[post_id]: 2825354
[parent_id]: 2825138
[tags]: 
A quote from C# in Nutshell. A problem that can be solved with a delegate can also be solved with an interface. For instance, the following explains how to solve our filter problem using an ITransformer interface: public interface ITransformer { int Transform (int x); } public class Util { public static void TransformAll (int[] values, ITransformer t) { for (int i = 0; i A delegate design may be a better choice than an interface design if one or more of these conditions are true: The interface defines only a single method. Multicast capability is needed. The subscriber needs to implement the interface multiple times. In the ITransformer example, we don’t need to multicast. However, the interface defines only a single method. Furthermore, our subscriber may need to implement ITransformer multiple times, to support different transforms, such as square or cube. With interfaces, we’re forced into writing a separate type per transform, since Test can implement ITransformer only once. This is quite cumbersome: class Squarer : ITransformer { public int Transform (int x) { return x * x; } } class Cuber : ITransformer { public int Transform (int x) {return x * x * x; } } ... static void Main() { int[] values = { 1, 2, 3 }; Util.TransformAll (values, new Cuber()); foreach (int i in values) Console.WriteLine (i); } And here is the code with delegate public delegate int Transformer (int x); class Util { public static void Transform (int[] values, Transformer t) { for (int i = 0; i
