[site]: stackoverflow
[post_id]: 1642109
[parent_id]: 1626189
[tags]: 
I found this question intriguing, and since I'm teaching myself Haskell, I decided to try my hand at implementing a solution in that language. I thought about branch-and-bound, but couldn't come up with a good way to bound the solutions, so I just did some pruning by discarding boards that violate the rules. My algorithm works by starting with an "empty" board. It places each possible color of tower in the first empty slot and in each case (each color) then recursively calls itself. The recursed calls try each color in the second slot, recursing again, until the board is full. As each tower is placed, I check the just-placed tower and all of it's neighbors to verify that they're obeying the rules, treating any empty neighbors as wild cards. So if a white tower has four empty neighbors, I consider it valid. If a placement is invalid, I do not recurse on that placement, effectively pruning the entire tree of possibilities under it. The way the code is written, I generate a list of all possible solutions, then look through the list to find the best one. In actuality, thanks to Haskell's lazy evaluation, the list elements are generated as the search function needs them, and since they're never referred to again they become available for garbage collection right away, so even for a 5x5 board memory usage is fairly small (2 MB). Performance is pretty good. On my 2.1 GHz laptop, the compiled version of the program solves the 4x4 case in ~50 seconds, using one core. I'm running a 5x5 example right now to see how long it will take. Since functional code is quite easy to parallelize, I'm also going to experiment with parallel processing. There's a parallelized Haskell compiler that will not only spread the work across multiple cores, but across multiple machines as well, and this is a very parallelizable problem. Here's my code so far. I realize that you specified Java or PHP, and Haskell is quite different. If you want to play with it, you can modify the definition of the variable "bnd" just above the bottom to set the board size. Just set it to ((1,1),(x, y)), where x and y are the number of columns and rows, respectively. import Array import Data.List -- Enumeration of Tower types. "Empty" isn't really a tower color, -- but it allows boards to have empty cells data Tower = Empty | Blue | Red | Green | Yellow | White deriving(Eq, Ord, Enum, Show) type Location = (Int, Int) type Board = Array Location Tower -- towerScore omputes the score of a single tower towerScore :: Tower -> Int towerScore White = 100 towerScore t = (fromEnum t) * 10 -- towerUpper computes the upper bound for a single tower towerUpper :: Tower -> Int towerUpper Empty = 100 towerUpper t = towerScore t -- boardScore computes the score of a board boardScore :: Board -> Int boardScore b = sum [ towerScore (b!loc) | loc Int boardUpper b = sum [ bestScore loc | loc (Int,Int) -> [(Int,Int)] neighborLoc bounds (col, row) = filter valid neighborLoc' where valid loc = inRange bounds loc neighborLoc' = [(col-1,row),(col+1,row),(col,row-1),(col,row+1)] -- Array to store all of the neighbors of each location, so we don't -- have to recalculate them repeatedly. neighborArr = array bnd [(loc, neighborLoc bnd loc) | loc Location -> [Tower] neighborTowers board loc = [ board!l | l [Tower] requiredTowers Empty = [] requiredTowers Blue = [] requiredTowers Red = [Blue] requiredTowers Green = [Red, Blue] requiredTowers Yellow = [Green, Red, Blue] requiredTowers White = [Yellow, Green, Red, Blue] -- cellValid determines if a cell satisfies the rule. cellValid :: Board -> Location -> Bool cellValid board loc = null required || null needed || (length needed Location -> Tower -> Bool canPlace board loc tower = let b' = board // [(loc,tower)] in cellValid b' loc && and [ cellValid b' l | l [Location] -> Int -> Board solutions b empties best | null empties = b solutions b empties best = fst (foldl' f (cleanBoard, best) [ b // [(l,t)] | t Board -> (Board, Int) f (b1, best) b2 | boardUpper b2 lstScore then (new, max newScore best) else (b1, best) where lstScore = boardScore b1 new = solutions b2 e' best newScore = boardScore new l = head empties e' = tail empties colors = reverse (enumFromTo Blue White) -- showBoard converts a board to a printable string representation showBoard :: Board -> String showBoard board = unlines [ printRow row | row Also, please remember this is my first non-trivial Haskell program. I'm sure it can be done much more elegantly and succinctly. Update : Since it was still very time-consuming to do a 5x5 with 5 colors (I waited 12 hours and it hadn't finished), I took another look at how to use bounding to prune more of the search tree. My first approach was to estimate the upper bound of a partially-filled board by assuming every empty cell is filled with a white tower. I then modified the 'solution' function to track the best score seen and to ignore any board whose upper bound is less than than that best score. That helped some, reducing a 4x4x5 board from 23s to 15s. To improve it further, I modified the upper bound function to assume that each Empty is filled with the best tower possible, consistent with the existing non-empty cell contents. That helped a great deal, reducing the 4x4x5 time to 2s. Running it on 5x5x5 took 2600s, giving the following board: G B G R B R B W Y G Y G R B R B W Y G Y G R B R B with a score of 730. I may make another modification and have it find all of the maximal-scoring boards, rather than just one.
