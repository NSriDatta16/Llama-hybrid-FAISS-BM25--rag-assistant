[site]: stackoverflow
[post_id]: 2258902
[parent_id]: 
[tags]: 
How can I wrap a COM object in a native .NET class?

I'm using an extensive existing COM API (could be Outlook, but it's not) in .NET (C#). I've done this by adding a "COM Reference" in Visual Studio so all the "magic" is done behind the scenes (i.e., I don't have to manually run tlbimp ). While the COM API can now be "easily" used from .NET, it is not very .NET friendly. For example, there are no generics, events are strange, oddities like IPicture , etc. So, I'd like to create a native .NET API that is implemented using the existing COM API. A simple first pass might be namespace Company.Product { class ComObject { public readonly global::Product.ComObject Handle; // the "native" COM object public ComObject(global::Product.ComObject handle) { if (handle == null) throw new ArgumentNullException("handle"); Handle = handle; } // EDIT: suggestions from nobugz public override int GetHashCode() { return Handle.GetHashCode(); } public override bool Equals(object obj) { return Handle.Equals(obj); } } } One immediate problem with this approach is that you can easily end up with multiple instances of ComObject for the same underlying "native COM" object. For example, when doing an enumeration: IEnumerable Items { get { foreach (global::Item item in Handle.Items) yield return new Company.Product.Item(item); } } This would probably be unexpected in most situations. Fixing this problem might look like namespace Company.Product { class ComObject { public readonly global::Product.ComObject Handle; // the "native" COM object static Dictionary m_handleMap = new Dictionary (); private ComObject(global::Product.ComObject handle) { Handle = handle; handleMap[Handle] = this; } public ComObject Create(global::Product.ComObject handle) { if (handle == null) throw new ArgumentNullException("handle"); ComObject retval; if (!handleMap.TryGetValue(handle, out retval)) retval = new ComObject(handle); return retval; } } } That looks better. The enumerator changes to call Company.Product.Item.Create(item) . But now the problem is the Dictionary<> will keep both objects "alive" so they will never be garbage collected; this is likely bad for the COM object. And things start getting messy now... It looks like part of the solution is using a WeakReference in some way. There are also suggestions about using IDisposable but it doesn't seem very .NET-friendly at all to have to deal with Dispose() on every single object. And then there's the various discussions of when/if ReleaseComObject should be called. There is also code over on http://codeproject.com that uses late binding, but I'm happy with a version-dependent API. So, at this point I'm not really sure what is the best way to proceed. I'd like my native .NET API to be as ".NET-like" as possible (maybe even embedding the Interop assembly with .NET 4.0) and w/o having to employ heuristics like the "two dots" rule. One thing I thought of trying is to create an ATL project, compile with the /clr flag and use the C++'s compiler COM support ( Product::ComObjectPtr created by #import ) rather than .NET RCWs. Of course, I'd generally rather code in C# than C++/CLI...
