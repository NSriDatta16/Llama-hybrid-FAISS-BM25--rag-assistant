[site]: stackoverflow
[post_id]: 1618434
[parent_id]: 1618304
[tags]: 
You've got a couple of options, depending on your setup. Here are a few: 1) Add a reference to the class with the function (the callee) as a property in the caller's class: Caller.h @interface Caller : SomeObject { Callee *myCallee; ... } @property(nonatomic, retain) Callee *myCallee; Caller.m @synthesize myCallee; -(void)someAction { [myCallee doSomething]; } Something that sets up Caller after initializing both classes: caller.myCallee = callee; 2) Use another notification event, like it looks like you already know how to do. 3) Use a protocol if you've got a bunch of different classes that Caller might need to call that all support the same method: DoesSomething.h @protocol DoesSomething -(void)doSomething; @end Callee.h @interface Callee : NSObject { // NSObject or whatever you're using... ... } -(void)doSomething; Caller.h @interface Caller : SomeObject { id *myCallee; ... } @property(nonatomic, retain) id *myCallee; ... Then as per example 1. 4) Use performSelector to send a message to the class. Caller.h @interface Caller : NSObject { SEL action; id callee; } -(void)setupCallbackFor:(id)target action:(SEL)callback; Caller.m -(void)setupCallbackFor:(id)target action:(SEL)callback { callee = target; action = callback; } -(void)someAction { if([callee respondsToSelector:action]) { [callee performSelector:action]; } I'm sure there are other ways, and there are pros and cons to each of these, but something in there should fit your needs and/or give you enough to scan the documentation to fill in any gaps...
