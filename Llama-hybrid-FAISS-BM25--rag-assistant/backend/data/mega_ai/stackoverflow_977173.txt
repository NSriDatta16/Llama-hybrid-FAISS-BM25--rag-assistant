[site]: stackoverflow
[post_id]: 977173
[parent_id]: 976275
[tags]: 
After further investigation: /P takes too long (I never witnessed it getting beyond a few files over the course of nearly an hour, so I canceled that build) I was never able to find a clear-cut way to print out what the current warning level was, or any overrides that were in effect at a given point in compilation. So the question I asked is not really answered, unless the /P argument actually is useful to you (as I mentioned, it was impractical for my purposes). What I was able to do was to construct some inline calls in the various headers that should generate the requisite warning if the warning level included that warning as active, to verify if that warning was active or not: inline int test(char value) { return ++value; } include "something" inline int test1(int value) { return test(value); } // should generate C4244 - possible loss of data if the previous #include didn't mess up the warning level or override warning 4244. And so on... In the end, what I discovered was that 4244 in particular has some odd rules associated with it, and that it is effectively "disabled" in all but /W4 (warning level 4) - the highest warning level. Since that warning level is very, very touchy and complains about lots of things that are well beyond our scope of doing anything about them, I didn't want to enable /W4. What I did instead was to put the following in our stdafx.h PCH: pragma warning(error:4244) // this fully enables warnings for possible data loss due to implicit type conversion in all circumstances regardless of the active warning level That worked. So, MS did not leave unbalanced warning overrides in any of their files that affected us. It was just that 4244 is very forgiving except at the highest warning level, where it becomes truly useful to us, anyway. Thanks for your help!
