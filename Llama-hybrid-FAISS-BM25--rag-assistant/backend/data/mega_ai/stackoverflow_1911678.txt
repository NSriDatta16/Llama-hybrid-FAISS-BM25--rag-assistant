[site]: stackoverflow
[post_id]: 1911678
[parent_id]: 1911640
[tags]: 
The "CheckA", "CheckB", etc. names, presumably chosen to avoid exposing confidential information, also obfuscate the nature of the relationships between classes, so I'll have to wing it. However, this is very nearly double dispatch , except you are performing conversion of the objects in-between. EDIT: Try playing the double dispatch pattern "by the book", rather than decomposing the objects mid-dispatch. To do this, you'd need something like the following: public interface IPerformAction { bool ShouldPerformAction(IShouldPerformActionChecker checker); void PerformAction(); } public interface IShouldPerformActionChecker { bool CheckShouldPerformAction(FloorWax toCheck); bool CheckShouldPerformAction(DessertTopping toCheck); // etc... } public class FloorWax : IPerformAction { public string Fragrance { get; set; } // Note that the text of this method is identical in each concrete class, // but compiles to call a different overload of CheckShouldPerformAction. public bool ShouldPerformAction(IShouldPerformActionChecker checker) { return checker.CheckShouldPerformAction(this); } } public class DessertTopping: IPerformAction { public string Flavor { get; set; } // Note that the text of this method is identical in each concrete class, // but compiles to call a different overload of CheckShouldPerformAction. public bool ShouldPerformAction(IShouldPerformActionChecker checker) { return checker.CheckShouldPerformAction(this); } } public class ShimmerApplicationChecker : IShouldPerformActionChecker { // handles binding of FloorWax class to required checks public bool CheckShouldPerformAction(FloorWax toCheck) { return CheckAroma(toCheck.Fragrance); } // handles binding of DessertTopping class to required checks public bool CheckShouldPerformAction(DessertTopping toCheck); { return CheckAroma(toCheck.Flavor); } // some concrete check private bool CheckAroma(string aroma) { return aroma.Contains("chocolate"); } }
