[site]: stackoverflow
[post_id]: 3906927
[parent_id]: 3906231
[tags]: 
Since expressions can read and write into storage area, your evaluation function should get state of memory as a parameter, and return new state in result. evaluate :: Expr -> Int -> (Float, Int) [where Int is type of the storage, and Float is type of result, of course you can change that]. When implementing evaluate (Sum a b) , you need to pass memory into evaluate a , get new value of memory and give it to evaluate b . | | m \ / |----------| x |evaluate a|--------| |----------- | | | | m' | \ / \ / |----------| y --- |evaluate b|----->| + | |----------| --- | | | | \ / \ / final final value of result memory Use pattern matching. You'd start with let (x,m') = evaluate a m in ... .
