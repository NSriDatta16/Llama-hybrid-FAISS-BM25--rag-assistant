[site]: stackoverflow
[post_id]: 1284250
[parent_id]: 1283830
[tags]: 
Well... if you want to be technical, this is a function literal which is translated at runtime into a closure, closing the open terms (binding them to a val/var in the scope of the function literal). Also, in the context of this function literal ( _.sales >= threshold ), threshold is a free variable, as the function literal itself doesn't give it any meaning. By itself, _.sales >= threshold is an open term At runtime, it is bound to the local variable of the function, each time the function is called. Take this function for example, generating closures: def makeIncrementer(inc: Int): (Int => Int) = (x: Int) => x + inc At runtime, the following code produces 3 closures. It's also interesting to note that b and c are not the same closure ( b == c gives false ). val a = makeIncrementer(10) val b = makeIncrementer(20) val c = makeIncrementer(20) I still think the example given on wikipedia is a good one, albeit not quite covering the whole story. It's quite hard giving an example of actual closures by the strictest definition without actually a memory dump of a program running. It's the same with the class-object relation. You usually give an example of an object by defining a class Foo { ... and then instantiating it with val f = new Foo , saying that f is the object. -- Flaviu Cipcigan Notes: Reference: Programming in Scala, Martin Odersky, Lex Spoon, Bill Venners Code compiled with Scala version 2.7.5.final running on Java 1.6.0_14.
