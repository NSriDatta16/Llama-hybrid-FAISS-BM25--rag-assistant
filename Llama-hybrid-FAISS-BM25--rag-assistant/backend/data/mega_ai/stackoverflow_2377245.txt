[site]: stackoverflow
[post_id]: 2377245
[parent_id]: 2375980
[tags]: 
This means that you want all Points which have the (1, 1, 1) coordinates to be considered as only one. Despite it is not encouraged within the NHibernate practices, you may do so with composite-ids. Following this link: Chapter 7. Component Mapping , while you scroll down to 7.4 where composite-id is explained. Then you're mapping should look like so: And your class would need to get splitted like so: public class PointCoord { public double X { get; set; } public double Y { get; set; } public double Z { get; set; } } public class Point : PointCoord { public Guid Id { get; set; } } Doing that way, you won't need to keep your Guid as the Id of your class, since it is no longer the Id anymore. Your Id is now your coordinates X, Y and Z. Then, you would have to override the Equals() method accordingly: public override bool Equals(object obj) { if (obj == null) return false; if (((Point)obj) == null) return false; Point p = (Point)obj; return this.X == p.X && this.Y == p.Y && this.Z == p.Z } By the way, it is always good to have an overload of this method taking your classe type as the input parameter, this gives better performance: public bool Equals(Point pt) { if (pt == null) return false; return this.X == pt.X && this.Y == pt.Y && this.Z == pt.Z } However, this is normally not considered a good practice and NHibernate strongly recommends that every table have its own DB Id, and this Id must not be a significant domain value such as, for instance, an invoice number. You would have your invoice number, and your DB Id. This composite-id thing is kept for legacy compatibility.
