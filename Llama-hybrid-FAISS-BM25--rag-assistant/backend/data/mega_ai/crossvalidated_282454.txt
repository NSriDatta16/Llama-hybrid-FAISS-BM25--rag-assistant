[site]: crossvalidated
[post_id]: 282454
[parent_id]: 282430
[tags]: 
It would be best to explain more about what you're doing and what you're hoping to achieve. Taking it at face value, as mentioned in comments, I'd try a different scale -- specifically, since all the data start from exactly 1 and "spread out" from there -- I'd subtract 1 and take logs from the y-values, and if smoothness is expected, then I'd fit a smooth curve against log(x) (with natural splines at low df, say), and use the y-column indicator in the model. Then estimating the overall fit at the average level, and transforming everything back (exponentiate and add 1). The result would be like a geometric-mean curve (of the data-1). If you wanted something nearer the arithmetic mean you'd add an upshift of $s^2/2$ before the exponentiation (where the level shift is), which would just tilt it up a little -- but I wouldn't do that in this case; the higher curves are "noisier" on the raw scale and I think the geometric mean is the better choice. [If you don't seek a smooth curve you just fit a factor in levels of X as well as the column indicator.] Here's how I did that: pel=read.table(stdin(),head=TRUE) X1 Y2 Y3 Y4 Y5 Y6 0 1 1 1 1 1 1 1.33333 NA 1.22222 NA 1.2 2 NA 1.90909 2 NA 1.8 3 NA NA 2.6 NA 2.2 4 2 NA 3.51111 2.1 3.2 5 NA NA 4 NA 4.6 6 2.33333 3.09091 5.28889 2.9 5.6 7 2.53333 2.81818 5.37778 3 5.8 8 2.23333 3.27273 NA 3.2 6.4 9 2.56666 4 NA 4.1 8.4 pels=(data.frame(X=rep(0:9,5),stack(pel[,-1])) ) tpels=data.frame(lvm1=log(pels$values-1),lX=log(pels$X),ind=pels$ind)[pels$values>1,] library(splines) lfit4=lm(lvm1~ns(lX,4)+ind,tpels) mlev4=sum(lfit4$coefficients[6:9])/5 newp=data.frame(lX=log(seq(.1,9,.1)),ind=rep(tpels$ind[1],90)) ppred=predict(lfit4,newdata=newp) plot(values~X,pels,col=ind,pch=16) lines((exp(ppred+mlev4)+1)~exp(newp$lX),col="dimgrey",lwd=2)
