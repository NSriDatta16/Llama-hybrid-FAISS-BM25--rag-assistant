[site]: stackoverflow
[post_id]: 881622
[parent_id]: 877965
[tags]: 
Try writing a tiny test app, which consists of nothing except what you need to reproduce this problem. This will make profiling easier. Then post that app here, so we can take a look at possible solutions. I found your question interesting so I wrote a test app myself. This draws a Bezier curve which is continually resized as you drag. I created a gradient background to ensure this works well with a nasty background. I get good performance and low flicker, although I use top-notch machine. It pays to read "Filthy Rich Clients" to learn all the tricks of writing custom Swing components that perform really well. import javax.swing.*; import java.awt.*; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.awt.geom.CubicCurve2D; import java.awt.geom.Point2D; public class CustomComponent extends JComponent { private Point2D start = new Point2D.Double(0, 0); private Point2D end = new Point2D.Double(300, 200); private CustomComponent() { this.setOpaque(true); final MouseAdapter mouseAdapter = new MouseAdapter() { @Override public void mouseDragged(MouseEvent e) { setEnd(e.getPoint()); } }; this.addMouseListener(mouseAdapter); this.addMouseMotionListener(mouseAdapter); } public void setStart(Point2D start) { this.start = start; repaint(); } public void setEnd(Point2D end) { this.end = end; repaint(); } @Override protected void paintComponent(Graphics g) { final Graphics2D g2 = (Graphics2D) g; g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); // draw gradient background final int width = getWidth(); final int height = getHeight(); g2.setPaint(new GradientPaint(0, 0, Color.WHITE, width, height, Color.YELLOW)); g2.fillRect(0, 0, width, height); // draw Bezier curve final Shape shape = new CubicCurve2D.Double(start.getX(), start.getY(), start.getX(), end.getY(), end.getX(), start.getY(), end.getX(), end.getY()); g2.setColor(Color.BLACK); g2.draw(shape); g2.drawString("Click and drag to test for flickering", 100, 20); } public static void main(String[] args) { final CustomComponent component = new CustomComponent(); final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); final Dimension size = new Dimension(screenSize.width - 20, screenSize.height - 100); component.setPreferredSize(size); final JFrame frame = new JFrame(); frame.add(component); frame.pack(); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); } } Some things to note: only overwrite paintComponent(Graphics g), not the other paintXXX() methods set custom component to opaque if possible only use repaint() to request repainting. Never directly order a repaint directly in your code. This lets Swing handle it well.
