[site]: stackoverflow
[post_id]: 5003616
[parent_id]: 
[tags]: 
iOS / Core-Animation: Performance tuning

I have my app running on my iPad. but it is performing very badly -- I am getting below 15fps. can anyone help me to optimise? It is basically a wheel (derived from UIView) containing 12 buttons (derived from UIControl). As the user spins it, the buttons dynamically expand and contract (e.g. the one at the 12 o'clock position should always be the biggest) So my wheel contains a: - (void) displayLinkIsCallingBack: (CADisplayLink *) dispLink { : // using CATransaction like this goes from 14fps to 19fps [CATransaction begin]; [CATransaction setDisableActions: YES]; // NEG, as coord system is flipped/fucked self.transform = CGAffineTransformMakeRotation(-thetaWheel); [CATransaction commit]; if (BLA) [self rotateNotch: direction]; } â€¦ which calculates from recent touch input the new rotation for the wheel. There is already one performance issue here which I am pursuing on a separate thread: iOS Core-Animation: Performance issues with CATransaction / Interpolating transform matrices This routine also checks whether the wheel has completed another 1/12 rotation, and if so instructs all 12 buttons to resize: // Wheel.m - (void) rotateNotch: (int) direction { for (int i=0; i Now for the actual resizing code, in button.m: // Button.m - (void) scaleFrom: (float) s_old to: (float) s_new time: (float) t { CABasicAnimation * scaleAnimation = [CABasicAnimation animationWithKeyPath: @"transform.scale"]; [scaleAnimation setDuration: t ]; [scaleAnimation setFromValue: (id) [NSNumber numberWithDouble: s_old] ]; [scaleAnimation setToValue: (id) [NSNumber numberWithDouble: s_new] ]; [scaleAnimation setTimingFunction: [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut] ]; [scaleAnimation setFillMode: kCAFillModeForwards]; scaleAnimation.removedOnCompletion = NO; [self.contentsLayer addAnimation: scaleAnimation forKey: @"transform.scale"]; if (self.displayShadow && self.shadowLayer) [self.shadowLayer addAnimation: scaleAnimation forKey: @"transform.scale"]; size = s_new; } // - - - - (void) resize: (float) newSize { [self scaleFrom: size to: newSize time: 1.]; } I wonder if the problem is related to the overhead of multiple transform.scale operations queueing up -- each button resize takes a full second to complete, and if I am spinning the wheel fast I might spin a couple of revolutions per second; that means that each button is getting resized 24 times per second. ** creating the button's layer ** The final piece of the puzzle I guess is to have a look at the button's contentsLayer. but I have tried contentsLayer.setRasterize = YES; which should effectively be storing it as a bitmap. so with the setting the code is in effect dynamically resizing 12 bitmaps. I can't believe this is taxing the device beyond its limits. however, core animation instrument tells me otherwise; while I am rotating the wheel (by dragging my finger in circles), it is reporting ~15fps. This is no good: I eventually need to put a text layer inside each button and this is going to drag performance down further (...unless I am using the .setRasterize setting above, in which case it should be the same). There must be something I'm doing wrong! but what? EDIT: here is the code responsible for generating the button content layer (ie the shape with the shadow): - (CALayer *) makeContentsLayer { CAShapeLayer * shapeOutline = [CAShapeLayer layer]; shapeOutline.path = self.pOutline; CALayer * contents = [CALayer layer]; // get the smallest rectangle centred on (0,0) that completely contains the button CGRect R = CGRectIntegral(CGPathGetPathBoundingBox(self.pOutline)); float xMax = MAX(abs(R.origin.x), abs(R.origin.x+R.size.width)); float yMax = MAX(abs(R.origin.y), abs(R.origin.y+R.size.height)); CGRect S = CGRectMake(-xMax, -yMax, 2*xMax, 2*yMax); contents.bounds = S; contents.shouldRasterize = YES; // try NO also switch (technique) { case kMethodMask: // clip contents layer by outline (outline centered on (0, 0)) contents.backgroundColor = self.clr; contents.mask = shapeOutline; break; case kMethodComposite: shapeOutline.fillColor = self.clr; [contents addSublayer: shapeOutline]; self.shapeLayer = shapeOutline; break; default: break; } if (NO) [self markPosition: CGPointZero onLayer: contents ]; //[self refreshTextLayer]; //[contents addSublayer: self.shapeLayerForText]; return contents; } as you can see, I'm trying every possible approach, I am trying two methods for making the shape, and separately I am toggling .shouldRasterize ** compromising the UI design to get tolerable frame rate ** EDIT: Now I have tried disabling the dynamic resizing behaviour until the wheel settles into a new position, and setting wheel.setRasterize = YES. so it is effectively spinning a single prerendered UIView (which is admittedly taking up most of the screen) underneath the finger (which it happily does @~60fps), until the wheel comes to rest, at which point it performs this laggy resizing animation (@ while this gives a tolerable result, it seems nuts that I am having to sacrifice my UI design in such a way. I feel sure I must be doing something wrong. EDIT: I have just tried as an experiment to resize buttons manually; ie put a display link callback in each button, and dynamically calculate the expected size of this given frame, explicitly disable animations with CATransaction the same as I did with the wheel, set the new transformation matrix (scale transform generated from the expected size). added to this I have set the buttons content layer shouldRasterize = YES. so it should be simply scaling 12 bitmaps each frame onto a single UIView which is itself rotating. amazingly this is dead slow, it is even bringing the simulator to a halt. It is definitely 10 times slower than doing it automatically using core animation's animation feature.
