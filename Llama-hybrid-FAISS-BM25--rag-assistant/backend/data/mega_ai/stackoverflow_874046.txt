[site]: stackoverflow
[post_id]: 874046
[parent_id]: 872323
[tags]: 
Cerating extention method like one suggested does not really solve issues with race conditions, but rather hide them. public static void SafeInvoke(this EventHandler handler, object sender) { if (handler != null) handler(sender, EventArgs.Empty); } As stated this code is the elegant equivalent to solution with temporary variable, but... The problem with both that it's possible that subsciber of the event could be called AFTER it has unsubscribed from the event . This is possible because unsubscription can happen after delegate instance is copied to the temp variable (or passed as parameter in the method above), but before delegate is invoked. In general the behaviour of the client code is unpredictable in such case: component state could not allow to handle event notification already. It's possible to write client code in the way to handle it, but it would put unnecesssary responsibility to the client. The only known way to ensure thread safity is to use lock statement for the sender of the event. This ensures that all subscriptions\unsubscriptions\invocation are serialized. To be more accurate lock should be applied to the same sync object used in add\remove event accessor methods which is be default 'this'.
