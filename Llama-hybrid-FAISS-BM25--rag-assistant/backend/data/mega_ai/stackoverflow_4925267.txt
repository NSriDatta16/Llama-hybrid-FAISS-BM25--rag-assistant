[site]: stackoverflow
[post_id]: 4925267
[parent_id]: 4819099
[tags]: 
ok... just tried it... seems to work as expected.... in real life the VMInit callback would return an instance of a class that implemented an interface that mirrored the C JVMTI interface.... the C agent would store this instance and call it when required on events .... additionally before the VMInit Java returned it would set up capabilities and callbacks and register events etc.... you would probably be able to get about 90% JVMTI API coverage..... it's just a case of typing it in .... I could do it in a weekend if you have a strong case :-) the following code produces this: C: VMInit, preparing to callback Java method Java: JVMTI callback class, VMInit(). C: VMInit, callback Java method returned successfully Java: And Finally... Hello, I'm the Java main package com.stackoverflow; public class JVMTICallback { public static void VMInit() { System.out.println("Java:\tJVMTI callback class, VMInit()."); } public static void main(String[] args) { // This main is only here to give us something to run for the test System.out.println("Java:\tAnd Finally... Hello, I'm the Java main"); } } and the C #include #include "jvmti.h" jvmtiEnv *globalJVMTIInterface; void JNICALL vmInit(jvmtiEnv * jvmti_env, JNIEnv * jni_env, jthread thread) { printf("C:\tVMInit, preparing to callback Java method\n"); char *className = "com/stackoverflow/JVMTICallback"; char *methodName = "VMInit"; char *descriptor = "()V"; jclass callbackClass = (*jni_env)->FindClass(jni_env, className); if (!callbackClass) { fprintf(stderr,"C:\tUnable to locate callback class.\n"); return; } jmethodID callbackMethodID = (*jni_env)->GetStaticMethodID(jni_env, callbackClass, methodName, descriptor); if (!callbackMethodID) { fprintf(stderr, "C:\tUnable to locate callback VMInit method\n"); return; } (*jni_env)->CallStaticVoidMethodV(jni_env, callbackClass, callbackMethodID, NULL); printf("C:\tVMInit, callback Java method returned successfully\n"); } JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM * jvm, char *options, void *reserved) { jint returnCode = (*jvm)->GetEnv(jvm, (void **) &globalJVMTIInterface, JVMTI_VERSION_1_0); if (returnCode != JNI_OK) { fprintf(stderr, "The version of JVMTI requested (1.0) is not supported by this JVM.\n"); return JVMTI_ERROR_UNSUPPORTED_VERSION; } jvmtiEventCallbacks *eventCallbacks; eventCallbacks = calloc(1, sizeof(jvmtiEventCallbacks)); if (!eventCallbacks) { fprintf(stderr, "Unable to allocate memory\n"); return JVMTI_ERROR_OUT_OF_MEMORY; } eventCallbacks->VMInit = &vmInit; returnCode = (*globalJVMTIInterface)->SetEventCallbacks(globalJVMTIInterface, eventCallbacks, (jint) sizeof(*eventCallbacks)); if (returnCode != JNI_OK) { fprintf(stderr, "C:\tJVM does not have the required capabilities (%d)\n", returnCode); exit(-1); } returnCode = (*globalJVMTIInterface)->SetEventNotificationMode( globalJVMTIInterface, JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, (jthread) NULL); if (returnCode != JNI_OK) { fprintf( stderr, "C:\tJVM does not have the required capabilities, JVMTI_ENABLE, JVMTI_EVENT_VM_INIT (%d)\n", returnCode); exit(-1); } return JVMTI_ERROR_NONE; }
