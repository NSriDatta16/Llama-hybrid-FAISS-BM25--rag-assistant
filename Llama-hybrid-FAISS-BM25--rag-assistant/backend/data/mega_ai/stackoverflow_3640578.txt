[site]: stackoverflow
[post_id]: 3640578
[parent_id]: 3640120
[tags]: 
The basic approach would be to rewrite your Op monad as a monad transformer. This would allow you to use it in a "stack" of monads, the bottom of which might be IO . Here's an example of what that might look like: import Data.Array import Control.Monad.Trans data Registers = Reg { foo :: Int } data ST = ST {registers :: Registers, memory :: Array Int Int} newtype Op m a = Op {runOp :: ST -> m (ST, a)} instance Monad m => Monad (Op m) where return a = Op $ \st -> return (st, a) (>>=) stf f = Op $ \st -> do (st1, a1) do a (ST -> a) -> Op m a getState g = Op $ \st -> return (st, g st) updState :: Monad m => (ST -> ST) -> Op m () updState g = Op $ \st -> return (g st, ()) testOpIO :: Op IO String testOpIO = do x The key things to observe: The use of the MonadTrans class The use of the lift function acting on getLine , which is used to bring the getline function from the IO monad and into the Op IO monad. Incidentally, if you don't want the IO monad to always be present, you can replace it with the Identity monad in Control.Monad.Identity . The Op Identity monad behaves exactly the same as your original Op monad.
