[site]: stackoverflow
[post_id]: 3614927
[parent_id]: 3614758
[tags]: 
Well, yes, but you should avoid it as much as possible. One of the main benefits of writing internal implementations of functions is that, contrary to what happens in PHP, C function calls are cheap. Additionally, calling PHP functions internally in C code is relatively painful. For instance, in the case of session_start , you have php_session_start , which is exposed by the session extension. Owing to what I described in the first paragraph, extensions will usually export C functions that may be useful to others. In fact, the internal PHP function foo needed to call the internal PHP function bar , the best strategy, if possible, would be to define an auxiliary (non PHP_FUNCTION ) C function with most of the implementation of bar . Then both PHP_FUNCTION(foo) and PHP_FUNCTION(bar) could call that auxiliary function. Anyway, the easiest way to call PHP functions is to use call_user_function : int call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] TSRMLS_DC); The variant call_user_function_ex also allows prohibiting separation when the argument should be sent by reference by it's not and specifying a symbol table. This will work both if the relevant function is internal ( PHP_FUNCTION ) or was defined in userspace. If it's a regular function, you should use EG(function_table) as the first argument, the second should be NULL and I think you can figure out the others. If you execute the function several times, this is not very efficient. In that case, see the functions in "Zend_API.h" that start with zend_fcall_ . I wouldn't recommend other options to call internal functions, such as manually setting up the arguments stack and other trickery and them manually calling the underlying C function.
