[site]: stackoverflow
[post_id]: 2188188
[parent_id]: 
[tags]: 
gcc optimization, const static object, and restrict

I'm working on an embedded project and I'm trying add more structure to some of the code, which use macros to optimize access to registers for USARTs. I'd like to organize preprocessor #define'd register addresses into const structures. If I define the structs as compound literals in a macro and pass them to inline'd functions, gcc has been smart enough the bypass the pointer in the generated assembly and hardcode the structure member values directly in the code. E.g.: C1: struct uart { volatile uint8_t * ucsra, * ucsrb, *ucsrc, * udr; volitile uint16_t * ubrr; }; #define M_UARTX(X) \ ( (struct uart) { \ .ucsra = &UCSR##X##A, \ .ucsrb = &UCSR##X##B, \ .ucsrc = &UCSR##X##C, \ .ubrr = &UBRR##X, \ .udr = &UDR##X, \ } ) void inlined_func(const struct uart * p, other_args...) { ... (*p->ucsra) = 0; (*p->ucsrb) = 0; (*p->ucsrc) = 0; } ... int main(){ ... inlined_func(&M_UART(0), other_parms...); ... } Here UCSR0A, UCSR0B, &c, are defined as the uart registers as l-values, like #define UCSR0A (*(uint8_t*)0xFFFF) gcc was able to eliminate the structure literal entirely, and all assignments like that shown in inlined_func() write directly into the register address, w/o having to read the register's address into a machine register, and w/o indirect addressing: A1: movb $0, UCSR0A movb $0, UCSR0B movb $0, UCSR0C This writes the values directly into the USART registers, w/o having to load the addresses into a machine register, and so never needs to generate the struct literal into the object file at all. The struct literal becomes a compile-time structure, with no cost in the generated code for the abstraction. I wanted to get rid of the use of the macro, and tried using a static constant struct defined in the header: C2: #define M_UART0 M_UARTX(0) #define M_UART1 M_UARTX(1) static const struct uart * const uart[2] = { &M_UART0, &M_UART1 }; .... int main(){ ... inlined_func(uart[0], other_parms...); ... } However, gcc cannot remove the struct entirely here: A2: movl __compound_literal.0, %eax movb $0, (%eax) movl __compound_literal.0+4, %eax movb $0, (%eax) movl __compound_literal.0+8, %eax movb $0, (%eax) This loads the register addresses into a machine register, and uses indirect addressing to write to the register. Does anyone know anyway I can convince gcc to generate A1 assembly code for C2 C code? I've tried various uses of the __restrict modifier, with no avail.
