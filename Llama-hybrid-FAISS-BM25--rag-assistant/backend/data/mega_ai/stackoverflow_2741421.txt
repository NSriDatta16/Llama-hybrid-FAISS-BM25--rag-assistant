[site]: stackoverflow
[post_id]: 2741421
[parent_id]: 2740874
[tags]: 
The fragment shader receives gl_Color and gl_SecondaryColor as vertex attributes. It also gets four varying variables: gl_FrontColor , gl_FrontSecondaryColor , gl_BackColor , and gl_BackSecondaryColor that it can write values to. If you want to pass the original colors straight through, you'd do something like: gl_FrontColor = gl_Color; gl_FrontSecondaryColor = gl_SecondaryColor; gl_BackColor = gl_Color; gl_BackSecondaryColor = gl_SecondaryColor; Fixed functionality in the pipeline following the vertex shader will then clamp these to the range [0..1], and figure out whether the vertex is front-facing or back-facing. It will then interpolate the chosen (front or back) color like usual. The fragment shader will then receive the chosen, clamped, interpolated colors as gl_Color and gl_SecondaryColor . For example, if you drew the standard "death triangle" like: glBegin(GL_TRIANGLES); glColor3f(0.0f, 0.0f, 1.0f); glVertex3f(-1.0f, 0.0f, -1.0f); glColor3f(0.0f, 1.0f, 0.0f); glVertex3f(1.0f, 0.0f, -1.0f); glColor3f(1.0f, 0.0f, 0.0f); glVertex3d(0.0, -1.0, -1.0); glEnd(); Then a vertex shader like this: void main(void) { gl_Position = ftransform(); gl_FrontColor = gl_Color; } with a fragment shader like this: void main() { gl_FragColor = gl_Color; } will transmit the colors through, just like if you were using the fixed-functionality pipeline.
