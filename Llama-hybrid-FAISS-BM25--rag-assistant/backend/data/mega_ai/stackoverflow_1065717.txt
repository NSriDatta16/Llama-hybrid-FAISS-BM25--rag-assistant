[site]: stackoverflow
[post_id]: 1065717
[parent_id]: 1065218
[tags]: 
If you are simply trying to remove adjacent values within that tolerance from a vector, I would start with something like this: roc = ... tolerance = 0.1; idx = [logical(1) diff(roc)>tolerance)]; rocReduced = roc(idx); 'rocReduced' is now a vector with all values that didn't have an adjacent values within a tolerance in the original vector. This approach has two distinct limitations: The original 'roc' vector must be monotonic. No more than two items in a row may be within the tolerance, otherwise the entire swath will be removed. I suspect the above would not be sufficient. That said, I can't think of any simple operations that overcome those (and other) limitations while still using vectorized matrix operations. If performance is not a huge issue, you maybe the following iterative algorithm would suit your application: roc = ... tolerance = 0.1; mask = true(size(roc)); % Start with all points last = 1; % Always taking first point for i=2:length(roc) % for all remaining points, if(abs(roc(i)-roc(last)) This handles multiple consecutive sub-tolerance intervals without necessarily throwing all away. It also handles non-monotonic sequences. MATLAB users sometimes shy away from iterative solutions (vs. vectorized matrix operations), but sometimes it's not worth the trouble of finding a more elegant solution when brute force performance meets your needs.
