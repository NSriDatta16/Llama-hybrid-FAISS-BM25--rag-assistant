[site]: stackoverflow
[post_id]: 4316058
[parent_id]: 4315549
[tags]: 
TCP implementations tend to fragment and join messages; there's no telling how much data or how many message fragments a socket receive will return. You need to know where a message ends and a new one begins (which may happen multiple times in data returned by a single read). Some simple solutions: Use some kind of delimiter. End each message by '\0'. Send the message size along with the message. Start each message with "Content-length: 42\n" or two size bytes (0x00 0x42). Use XML. starts and ends a message. PHP's XML parser doesn't like incomplete XMLs, though so the third option is out unless you want to match the start and end tags manually. Use the first option if the protocol is based on ASCII, second if it's binary, third if it's already XML. Now, remember you can get any number of messages per packet. In the most complex case, you might have the end of an earlier message followed by a number of full messages and the beginning of yet another message in a single packet. A full solution would be along these lines: while (connected) { while (messages in buffer 0) { extract message from buffer; process message; } } ...though this is an asynchronous message loop. I'll leave the "if there's a message available, return it; else, wait for one" synchronous implementation as an exercise. (Hint: You'll need a class to build and buffer messages.)
