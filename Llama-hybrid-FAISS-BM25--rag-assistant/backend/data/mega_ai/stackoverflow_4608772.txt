[site]: stackoverflow
[post_id]: 4608772
[parent_id]: 
[tags]: 
Removing a parameter list from f(list) with preprocessor

It seems to me that I saw something weird being done in a boost library and it ended up being exactly what I'm trying to do now. Can't find it though... I want to create a macro that takes a signature and turns it into a function pointer: void f(int,int) {} ... void (*x)(int,int) = WHAT( (f(int,int)) ); x(2,4); // calls f() I especially need this to work with member function pointers so that WHAT takes two params: WHAT(ClassType, (f(int,int)); // results in static_cast (&ClassType::f) It's not absolutely necessary in order to solve my problem, but it would make things a touch nicer. This question has nothing, per-se, to do with function pointers. What needs to be done is to use the preprocessor to take "f(int,int)" and turn it into two different parts: 'f' '(int,int)' Why: I've solved the problem brought up here: Generating Qt Q_OBJECT classes pragmatically I've started a series of articles explaining how to do it: http://crazyeddiecpp.blogspot.com/2011/01/quest-for-sane-signals-in-qt-step-1.html http://crazyeddiecpp.blogspot.com/2011/01/quest-for-sane-signals-in-qt-step-2.html The signature must be evaluated from, and match exactly, the "signal" that the user is attempting to connect with. Qt users are used to expressing this as SIGNAL(fun(param,param)) , so something like connect_static(SIGINFO(object,fun(param,param)), [](int,int){}) wouldn't feel too strange. In order to construct the signature I need to be able to pull it out of the arguments supplied. There's enough information to get the member function address (using C++0x's decltype) and fetch the signature in order to generate the appropriate wrapper but I can't see how to get it out. The closest I can come up with is SIGINFO(object, fun, (param,param)) , which is probably good enough but I figured I'd ask here before considering it impossible to get the exact syntax I'd prefer.
