[site]: stackoverflow
[post_id]: 2186542
[parent_id]: 2179313
[tags]: 
Based on advice from David Liddle, I found a different design that was a bit more elegant. It uses more jQuery and fewer partial views and Ajax requests. Instead of adding a bunch of DropDownLists, I decided to go with a table, a pair of dropdowns and an "Add" button. When the user selects a Type option in the first dropdown, ajax is still used to retrieve the partial view for populating the second Value dropdown. Once a Value option has been selected, the user then clicks the Add button. Using jQuery, two hidden inputs are added to the page. The naming convention in the links from David are used to name these elements (comps[0].Type and comps[0].Value). Also, a new row is added to the table with the same Type and Value for visual feedback to the user showing what has been added. I also defined a Component class that just has Type and Value properties and added a List to the Model. In the view, I iterate over this list and add all components in the Model to the table and as hidden inputs. IndexView Type Deploy From ].Type" value=" " /> ].Value" value=" " /> Add the File ComponentValueSelector PartialView " %> jQuery function updateCompValues() { $.ajax({ url: ' ', async: true, type: 'POST', data: { type: $("#CompValue").value }, dataType: 'text', success: function(data) { $("#CompValueContainer").html(data); enable($("#CompValue")) }, error: function() { console.log('Erreur'); } }); } function AddComponentButtonClicked() { UpdateCompStatus("info", "Updating..."); var type = $("#ComponentTypeDropDown").val(); var value = $("#CompValue").val(); if (type == "" || value == "") { // No values selected UpdateCompStatus("warning", "* Please select both a type and a value"); return; // Don't add the component } AddComponent(type, value); } function AddComponent(type, setting_1) { // Add hidden fields var newIndex = GetLastCompsIndex() + 1; var toAdd = ' ' + ' '; $("#hiddenComponentFields").append(toAdd); // Add to page // Note: there will always be one row of headers so the selector should always work. $('#componentTable tr:last').after(' '+type+' '+setting_1+' remove '); } function GetLastCompsIndex() { // TODO alert("GetLastCompsIndex unimplemented!"); // haven't figured this out yet but something like // $("#hiddenComponentFields input:hidden" :last).useRegExToExtractIndexFromName(); :) } function UpdateCompStatus(level, message) { var statusSpan = $("#componentStatus"); // TODO Change the class to reflect level (warning, info, error?, success?) // statusSpan.addClassName(...) statusSpan.html(message); } Controller public ActionResult Index() { SelectList compTypes = repos.GetAllComponentTypesAsSelectList(); return View(new IndexViewModel(compTypes)); } [AcceptVerbs(HttpVerbs.Post)] public ActionResult Index(Component[] comps, other params...) { foreach(Component comp in comps) { // Do something with comp.Type and comp.Value } return RedirectToAction(...); } public ActionResult GetComponentValues(string type) { ComponentValueModel valueModel = new ComponentValueModel(); valueModel.SelectList = repos.GetAllComponentValuesForTypeAsSelectList(type); return PartialView("ComponentValueSelector", valueModel); } IndexViewModel public class IndexViewModel { public List comps { get; set; } public SelectList ComponentTypes { get; set; } public IndexViewModel(SelectList types) { comps = new List (); ComponentTypes = types; } }
