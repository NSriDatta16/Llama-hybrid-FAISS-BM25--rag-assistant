[site]: stackoverflow
[post_id]: 5571359
[parent_id]: 5017803
[tags]: 
Yes, I got the same problem. The weird problem is that if you sent back: {"Sex" : 'Male'} it would deserialize no problem. To solve the problem, I implemented a custom model binder for enums, leveraging the example found here (slightly modified as there were some errors): http://eliasbland.wordpress.com/2009/08/08/enumeration-model-binder-for-asp-net-mvc/ namespace yournamespace { /// /// Generic Custom Model Binder used to properly interpret int representation of enum types from JSON deserialization, including default values /// /// The enum type to apply this Custom Model Binder to public class EnumBinder : IModelBinder { private T DefaultValue { get; set; } public EnumBinder(T defaultValue) { DefaultValue = defaultValue; } #region IModelBinder Members public object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext) { return bindingContext.ValueProvider.GetValue(bindingContext.ModelName) == null ? DefaultValue : GetEnumValue(DefaultValue, bindingContext.ValueProvider.GetValue(bindingContext.ModelName).AttemptedValue); } #endregion public static T GetEnumValue (T defaultValue, string value) { T enumType = defaultValue; if ((!String.IsNullOrEmpty(value)) && (Contains(typeof(T), value))) enumType = (T)Enum.Parse(typeof(T), value, true); return enumType; } public static bool Contains(Type enumType, string value) { return Enum.GetNames(enumType).Contains(value, StringComparer.OrdinalIgnoreCase); } } } and then registering the model binder in global.asax.cs. In your case it would be something like: ModelBinders.Binders.Add(typeof(SexType), new EnumBinder (SexType.Male)); I am not sure if there is a quicker way, but this works great.
