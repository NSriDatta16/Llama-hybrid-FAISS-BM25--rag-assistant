[site]: stackoverflow
[post_id]: 2371089
[parent_id]: 2371044
[tags]: 
Only elegant solution for now is to use hash as parameters list: def some_method(options = {}) defaults = {:arg1 => 1, :arg2 => 2, :arg3 => 3} options = defaults.merge(options) ... end and later in code use implicit hash when calling your method: some_method() some_method(:arg1 => 2, :arg2 => 3, :arg3 => 4) some_method(:arg2 => 4) In Ruby 1.9 you can use new hash keys syntax to get ir more like in Python: some_method(arg1: 2, arg2: 3, arg3: 4) If you want simpler syntax and still be able to use positional parameters, then I would suggest to play with something like this: def some_method(*args) defaults = {:arg1 => 1, :arg2 => 2, :arg3 => 3} options = args.last.is_a?(::Hash) ? args.pop : {} options = defaults.merge(options) arg1 = args[0] || options[:arg1] arg2 = args[1] || options[:arg2] arg3 = args[2] || options[:arg3] ... end some_method() some_method(2) some_method(3,4,5) some_method(arg2: 5) some_method(2, arg3: 10) If you would like to mimic Ruby arguments number check for method, you can add: fail "Unknown parameter name(s) " + (options.keys - defaults.keys).join(", ") + "." unless options.length == defaults.length EDIT: I updated my answer with Jonas Elfstr√∂m 's comment
