[site]: stackoverflow
[post_id]: 3620785
[parent_id]: 3619062
[tags]: 
Sorry, I can't post comments yet, so here's a complete answer: Like jeremy said, you don't own the reference to data , so it will go away! There are—however—a few ways of ensuring it's viability: Store data (and I really mean the pointer here!) within your struct so you can release it when you're done using it. If you're running under GC, define that field as __strong void * or (since NSData is toll-free-bridged to CFData ) call CFRetain( (CFDataRef) data ) which is actually not a noop in GC-ed code ! (This has you covered in GC-ed and ref-counted environments BTW...) Create that object through [[NSData alloc] initWithContentsOfFile:] and stash it into your struct. (GC-notes apply here as well!) malloc the memory for your image and use -[NSData getBytes:range:] with that. This will probably mean a noticable performance hit, though. Whichever way you choose, don't forget to clean up after yourself— CFRelease() will probably be the nicest solution in case 1 and 2 because it covers GC and ref-counting. BTW (And I hope this doesn't come off as rudeness!): Is there a certain reason that... you are using NSFileHandle instead of going straight through NSData -methods? you have your data as a blob that way? You could store it as a binary-plist through NSKeyedArchiver and retrieve it a little more elegant than through pointer gymnastics and yet with little overhead. Oh and the big one: What exactly are you doing/trying to do here: // IMAGE 1 organizedImageData->image1Data = (UInt8 *)rawData; rawData++; // IMAGE 2 organizedImageData->image2Data = (UInt8 *)rawData; rawData++; I cannot make much sense of that. Suggestion 2 would probably simplify this as well, by the way :-)
