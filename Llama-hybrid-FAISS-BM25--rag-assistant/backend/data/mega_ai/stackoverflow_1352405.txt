[site]: stackoverflow
[post_id]: 1352405
[parent_id]: 1352378
[tags]: 
When Name returns a reference, it returns this - so when the instance is actually an instance of CorporationBuilder , that reference is returned as normal. Just because the method is declared to return OrganizationBuilder doesn't mean it only returns an OrganizationBuilder reference. It returns a reference to an instance of OrganizationBuilder instance or a derived class (or null , of course). When the Write method is then called, that's a virtual method so the execution-time type of the object is checked to find the implementation to use. The execution-time type is still CorporationBuilder , so the override specified in that type is used. As for how to make Name() return the appropriate type - that would require more generics, basically. It can be done, but it's a pain - I've done something similar in Protocol Buffers, but it's not pleasant. You'd make OrganizationBuilder generic in TContact and TBuilder as well, and make Name return TBuilder via a cast from this to TBuilder . Then CorporationBuilder would either be generic too, or just inherit from OrganizationBuilder . EDIT: Yes, I see the problem (which I'd forgotten about before). You may want to have a concrete non-generic class called CorporationBuilder as well, to avoid the recursive generics: public class OrganizationBuilder : OrganizationBuilder You might also want to rename OrganizationBuilder to OrganizationBuilderBase to avoid confusion :) (You don't need CorporationBuilder to be generic itself, if it's at the bottom of the hierarchy.) However, this is getting extremely complicated. You might want to at least consider avoiding inheritance here. Scrap the generics, and make OrganizationBuilder have a CorporationBuilder instead of deriving from it. Basically this pattern always gets complicated after a while - you end up needing every level to be generic apart from the leaf nodes, which always need to be nongeneric to avoid the recursion problem you've already seen. It's a pain.
