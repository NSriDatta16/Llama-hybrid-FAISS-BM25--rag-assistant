[site]: stackoverflow
[post_id]: 4176758
[parent_id]: 4176712
[tags]: 
I think actually the best solution here would be to implement a delegate protocol. It looks a little thornier, but it won't be as fragile as trying to store the variable reference. Here's what you need to do: First, declare the protocol so that other classes know what to implement in order to receive your delegate messages. Also, create a .delegate property so that other objects can tell your date picker that they want to get those messages: // MyDatePicker.h #import @class MyDatePicker; @protocol MyDatePickerDelegate - (void)myDatePicker:(MyDatePicker *)datePicker didChangeDate:(NSDate *)date; @end @interface MyDatePickerViewController : UIViewController { id delegate; } @property (nonatomic, assign) id delegate; @end Then when you get a new date from your picker, you just need to check to see if you have a delegate, and that they have implemented your method. If they have, just go ahead and tell them about the new date: // MyDatePickerViewController.m #import "MyDatePickerViewController.h" @implementation MyDatePickerViewController - (void)changedDate:(NSDate *)newDate { if ([delegate respondsToSelector:@selector(myDatePicker:didChangeDate:)]) { [delegate myDatePicker:self didChangeDate:newDate]; } } @end Then, in your class where you want to receive the date info you might do something like this: - (void)createDatePicker { MyDatePicker *datePicker = [[MyDatePicker alloc] init]; datePicker.delegate = self; } - (void)myDatePicker:(MyDatePicker *)datePicker didChangeDate:(NSDate *)date { if (startTimeOrSomething) { self.startDate = date; } else { self.endDate = date; } } I just typed that without compiling, but it should be correct. This may seem like a lot of work, but it will very quickly become second nature, and is a much more robust way to handle these kinds of situations.
