[site]: stackoverflow
[post_id]: 2464346
[parent_id]: 2464150
[tags]: 
As others have pointed out, your implementation isn't as expensive as you think. However, it may make some sense to define additional methods that modify the object in-place for use in critical inner loops. EDIT - fixed following paragraph The point here is that even with return value optimisations, you still end up constructing a local variable and then assigning that to the result variable after operator+ exits. And destructing that extra object, of course. There is still an extra object used to temporarily hold the result. It's possible to do reference-counting with copy-on-write, but that adds a dereferencing overhead to each use of a matrix. These are non-issues for 99% of cases, but once in a while you get a critical case. If you were dealing with large matrices, reference-counting overheads would be insignificant - but for 2D up to 4D there are times when you may care a great deal about those few extra cycles - or more to the point, about not putting the matrix on the heap when you want it on the stack or embedded within some struct/class/array. That said - in those cases, you probably won't be writing your own matrix code - you'll just use the matrix ops from DirectX or OpenGL or whatever.
