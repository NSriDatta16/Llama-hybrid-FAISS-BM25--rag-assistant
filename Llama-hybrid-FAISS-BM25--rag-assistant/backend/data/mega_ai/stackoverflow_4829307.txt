[site]: stackoverflow
[post_id]: 4829307
[parent_id]: 4829289
[tags]: 
You need to enclose your TextWriter object in a using block. List mList = ManuImport.GetManufacturers(); using(TextWriter tw = new StreamWriter(@"C:\manu.txt")) { foreach (Manufacturer manu in mList) { //Output name to txt file. tw.WriteLine(manu.ManufacturerName); Console.WriteLine(manu.ManufacturerName); Console.WriteLine(manu.ShortManufacturerName); Console.WriteLine(manu.ManufacturerDirectory); Console.WriteLine(manu.ManuId); Console.WriteLine("------------------------"); } } There are two reasons for this: First, fundamentally, TextWriter implements IDisposable , which means that you should always call Dispose() when you're finished with the object. The using block in C# and VB.NET are language-specific mechanisms for ensuring that Dispose gets called. This is true for all objects that implement IDisposable , so it's probably a good idea to look at other areas of your code and other framework objects that you're using to ensure that you're following this pattern. Some things you might want to pay particular attention to are: Database connections Anything IO related (files, streams of any kind, etc.) Second, for this particular case, the TextWriter class buffers the data that gets written (so, for example, if you write the data a character at a time, you don't have disk IO for EVERY character, since it does it in "chunks"). As a result, the buffer has to be flushed in order for data to get written to the disk. This happens under three cases: The buffer fills up under the course of using the object in code You close the TextWriter either by calling Close() or Dispose() You manually flush the buffer by calling Flush() The first one you have no control over, as it's automatic. The latter should be an exceptional case, where you want all buffered data written to disk immediately but still want to keep the writer open. The second case--the most important--is what you're missing.
