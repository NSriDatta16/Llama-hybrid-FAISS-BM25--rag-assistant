[site]: stackoverflow
[post_id]: 4654882
[parent_id]: 4654806
[tags]: 
At work at the moment, so nothing elegant, came up with this (untested) public static class Cache { private static readonly object _syncRoot = new object(); private static Dictionary _lookup = new Dictionary (); public static class OneToManyLocker { private static readonly Object WriteLocker = new Object(); private static readonly List ReadLockers = new List (); private static readonly Object myLocker = new Object(); public static Object GetLock(LockType lockType) { lock(WriteLocker) { if(lockType == LockType.Read) { var newReadLocker = new Object(); lock(myLocker) { ReadLockers.Add(newReadLocker); } return newReadLocker; } foreach(var readLocker in ReadLockers) { lock(readLocker) { } } return WriteLocker; } } public enum LockType {Read, Write}; } public static void Add(Type type, string value) { lock(OneToManyLocker.GetLock(OneToManyLocker.LockType.Write)) { _lookup.Add(type, value); } } public static string Lookup(Type type) { string result; lock (OneToManyLocker.GetLock(OneToManyLocker.LockType.Read)) { _lookup.TryGetValue(type, out result); } return result; } } You will need some sort of cleanup for the read lockers, but should be threadsafe allowing multiple reads at a time while also locking on writes, unless I'm totally missing something
