[site]: stackoverflow
[post_id]: 1036247
[parent_id]: 1029057
[tags]: 
If your queries are selective and the line table clustered index is narrow or non-existent, then a non-clustered index on checksum in the line table should provide good performance. After applying whatever criteria is present to the header table, it will use the checksum to perform an index seek on the non-clustered index. You still need to include the FKs in the join, but the non-checksum join criteria will be applied post-index seek, post-bookmark lookup. Very efficient. You want to optimize for the index seek. The checksum is already highly selective. Adding the FKs would increase the index size and corresponding I/O, and wouldn't help unless it included enough other fields to avoid the bookmark lookup altogether. Since the non-clustered index will contain the clustering keys or heap pointer, you want either a) a small clustering key (eg, an int identity column--4 byte pointer) or b) no clustered index at all (8 byte pointer). If your queries are not selective, or if the line table clustered index is huge (the entire table minus a few columns) then I don't know if the checksum would help (faster index navigation, perhaps?). In any case you would want to make it a clustered or covering index, and if the header table isn't clustered on the checksum first, there will be much sorting. If you can afford the storage and indexing costs, a few covering indexes--header and detail--may be the way to go.
