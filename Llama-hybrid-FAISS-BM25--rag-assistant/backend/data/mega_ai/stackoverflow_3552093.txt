[site]: stackoverflow
[post_id]: 3552093
[parent_id]: 3549815
[tags]: 
#include union header { uint8_t a[8]; uint64_t u; }; const struct header h = { .u = (sizeof( short ) This should be enough to verify the type sizes and endianness, except that floating point numbers are crazy difficult for this. If you want to verify that your floating point numbers are stored in the same format on the writer and the reader then you might want to store a couple of constant floating point numbers (more interesting than 0, 1, and -1) in the different sizes after this header, and verify that they are what you think they should be. It is very likely that storing an actual magic string with version number would also be good as another check that this is the correct file format. If you don't care about floats or something like that then feel free to delete them. I didn't include char because it is supposed to always be 1 byte. It might be a good idea if you also store the sizeof some struct like: struct misalligned { char c; uint64_t u; }; This should allow you to easily determine the alignment and padding of the compiler that generated the code that generated the file. If this were done on most 32 bit computers that care about alignment the size would be 96 because there would be 3 bytes of padding between c and u, but if it were done on a 64 bit machine then the sizeof it may be 128, having 7 bytes of padding between c and u. If this were done on an AVR the sizeof this would most likely be 9 because there would be no padding. NOTE this answer relied on the question stating that the files were being memory mapped and no need for portability beyond recognizing that a file was the wrong format. If the question were about general file storage and retrivial I would have answered differently. The biggest difference would be packing the data structures.
