[site]: stackoverflow
[post_id]: 150265
[parent_id]: 150011
[tags]: 
You might try switching to extended for greater precision. As was pointed out though, floating point numbers only have so many significant digits of precision, so it is still possible to display more digits then are accurately stored, which could result in the behavior you specified. From the Delphi help: Fundamental Win32 real types | Significant | Size in Type | Range | digits | bytes ---------+----------------------------------+-------------+---------- Real | -5.0 x 10^–324 .. 1.7 x 10^308 | 15–16 | 8 Real48 | -2.9 x 10^–39 .. 1.7 x 10^38 | 11-12 | 6 Single | -1.5 x 10^–45 .. 3.4 x 10^38 | 7-8 | 4 Double | -5.0 x 10^–324 .. 1.7 x 10^308 | 15-16 | 8 Extended | -3.6 x 10^–4951 .. 1.1 x 10^4932 | 10-20 | 10 Comp | -2^63+1 .. 2^63–1 | 10-20 | 8 Currency | -922337203685477.5808.. | | 922337203685477.5807 | 10-20 | 8 Note : The six-byte Real48 type was called Real in earlier versions of Object Pascal. If you are recompiling code that uses the older, six-byte Real type in Delphi, you may want to change it to Real48 . You can also use the {$REALCOMPATIBILITY ON} compiler directive to turn Real back into the six-byte type. The following remarks apply to fundamental real types. Real48 is maintained for backward compatibility. Since its storage format is not native to the Intel processor architecture, it results in slower performance than other floating-point types. Extended offers greater precision than other real types but is less portable. Be careful using Extended if you are creating data files to share across platforms. Notice that the range is greater then the significant digits. So you can have a number larger then can be accurately stored. I would recommend rounding to the significant digits to prevent that from happening.
