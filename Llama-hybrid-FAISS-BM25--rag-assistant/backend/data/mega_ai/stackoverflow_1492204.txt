[site]: stackoverflow
[post_id]: 1492204
[parent_id]: 
[tags]: 
Is it possible to generate types with all combinations of template arguments?

I have a templated class template class S { //... implementations }; and some stock type implementations for type U , V and W : typedef boost::mpl::vector u_types; typedef boost::mpl::vector u_types; typedef boost::mpl::vector w_types; I want to test class S with all possible combinations of the template arguments, typedef boost::mpl::vector , S , // ... S , > s_types; like this: boost::mpl::for_each (test_func). The only problem is there are 2 ** 5 ** 5 = 50 combinations that I do not wish to type in one by one. Is there a way to generate all the combinations( s_types ) with Boost::mpl or Boost.Preprocessor? thanks. Added my initial failed attempts: I was trying to resort to indexes(hence defining u_types and the like) and partial template specialization like this namespace wrapper { template struct S_Wrapper { typedef S type; S_Wrapper() // auto test in the ctor { cout static bool test(type t) { // implementations } // get stuck here, S_Wrapper s; // temp varible to invoke recursive-ness // what else to complete all recursive path? }; // specializations template struct S_Wrapper { typedef S type; // test with S // static bool test(type t) { // implementations } }; // get stuck here, too // what other specializations are ? // other specializations } then with wrapper::S_Wrapper ::type::value, mpl::size ::type::value, mpl::size ::type::value > s; all S types should be gengerated and tested ; However I failed to cover all the combination by determining 1) the proper specializations and 2) recursive-ness triggers in struct S_Wrapper All my trials either ended up in partial coverage of the combinations at runtime or deduction failure at compile time. Any thoughts? Solution Inspired by Matthieu, I've come up with a templated class Combine so that I could achieve my goal in 2 lines like this: typedef Combine ::Generate<> base_generator_type; base_generator_type::Run(); which will print all generated types. Code // example test implementation struct print_typeid { template static void run() { // print the typeinfo std::cout struct Combine { // forward declaration template class Generate; // this class implements recursion body template struct Next { // u_begin is not necessary ;) // it would be cheaper not to pre-declare all of them since we force evaluation // however this dramatically increase the readability typedef typename begin ::type v_begin; typedef typename begin ::type w_begin; typedef typename end ::type u_end; typedef typename end ::type v_end; typedef typename end ::type w_end; typedef typename next ::type u_next; typedef typename next ::type v_next; typedef typename next ::type w_next; typedef typename if_ , typename if_ , typename if_ , end_of_recursion_tag, Generate >::type, Generate >::type, Generate >::type type; }; // this class run test on generated types in thos round and go to next*/ template ::type, class VIterator = typename begin ::type, class WIterator = typename begin ::type > struct Generate { // generate > target type typedef typename Next ::type next_type; static void Run() { // increment recursion counter ++total_recursions; // test on the generated types of this round of recursion TestFunc::run ::type, typename deref ::type, typename deref ::type >(); // go to the next round of recursion next_type::Run(); } }; }; }// namespace argument_combination
