[site]: stackoverflow
[post_id]: 716119
[parent_id]: 715920
[tags]: 
This is the kind of behaviour that is often seen in event driven GUI frameworks when one wants to do continuous animation. I'm going to guess that eye::playSequence is called from a button click or maybe from some point during the application startup code? In any case, here is what's going on. Qt uses the main application thread to drive an event loop. The event loop is something like this: while(app_running) { if(EventPending) ProcessNextEvent(); } The problem you are seeing is that updates to the screen are done during a paint event. If you are running some code during a mouse click event or any other event, then all the drawing you are doing is queued up and will be drawn to the screen on the next paint event. Sometimes it takes awhile for this to sink in. The best way to address this is to change your approach a bit. One way is to throw away your while loop and setup a QTimer set to fire every 5 seconds. In the timer slot you can draw one slide. When the timer fires again, draw the next slide, etc. If you want a more direct and less elegant quick fix, try calling qapp->processEvents() right after your call to presentSlide(sequenceNum, i). This (most of the time) will force the application to clear out any queued up events which should include paint events. I should also mention that eye::presentSlide() is merely adding new scene objects to the scene on each iteration covering the ones that were added during the last call. Think of the scene as a fridge door and when you call scene().addXXX you are throwing more fridge magnets on the door :)
