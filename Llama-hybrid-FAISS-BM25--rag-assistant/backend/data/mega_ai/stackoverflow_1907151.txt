[site]: stackoverflow
[post_id]: 1907151
[parent_id]: 1906917
[tags]: 
If we are talking original language design, remember that C got most of its present shape on the PDP-11 CPU, which is 16 bit. So they had integers for arithmetic and characters for string storage. Pointers were basically the same as integers. The language was very pragmatic and only later got a more formal and intricate syntax. So the answer is, it just happened to be that way. Much later we got 32 bit and 64 bit CPUs and the need to distinguish between integers of different lengths. To this day I code almost all my C programs like as if there were no type other than char and integer. Oh, by the way, "char" in C can be either signed and unsigned according to the standard. This reflects that chars were meant for character storage (strings) and ints for arithmetic. To clarify, (thank you semaj) the compiler can choose to treat a variable declared "char" as "unsigned char". This does not happen for an "int". An "int" is always signed, but with chars you can not be sure. You have to assume that a char can have either unsigned or signed arithmetics. This is a speed optimization to accommodate CPUs that work faster with either implementation. I.e. focus is placed on chars as storage containers, not as an arithmetic type. (It's name is also a give-away. It could have been called "short" or "small", but was called "char" for a reason.)
