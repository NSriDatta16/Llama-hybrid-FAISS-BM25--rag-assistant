[site]: stackoverflow
[post_id]: 894915
[parent_id]: 894814
[tags]: 
You can use the fact that functions dereferences results when returning, for exemple here $array_by_myclone will still have a reference to $original ( $array_by_myclone[0][0] == 'foo' ) while $array_by_assignment will have a cloned value ( $array_by_assignment[0][0] == 'bar' ) $original = 'foo'; $array_of_reference = array(&$original); function myclone($value) { return $value; } $array_by_myclone = array(); $array_by_myclone[] = array_map('myclone', $array_of_reference); $array_by_assignment = array(); $array_by_assignment[] = $array_of_reference; $original = 'bar'; var_dump($array_by_myclone[0][0]); // foo, values were cloned var_dump($array_by_assignment[0][0]); // bar, still a reference EDIT: I wanted to check if the comment saying unserialize(serialize()) was faster was right so I did the test using php 5.5, and it turns out this is wrong: using the serialization method is slower even with a small dataset, and the more data you have the slower it gets. lepidosteus@server:~$ php -v PHP 5.5.1-1~dotdeb.1 (cli) (built: Aug 3 2013 22:19:30) Copyright (c) 1997-2013 The PHP Group Zend Engine v2.5.0, Copyright (c) 1998-2013 Zend Technologies with Zend OPcache v7.0.2-dev, Copyright (c) 1999-2013, by Zend Technologies lepidosteus@server:~$ php reference.php 1 myclone: 0.000010 seconds serialize: 0.000012 seconds lepidosteus@server:~$ php reference.php 1000000 myclone: 0.398540 seconds serialize: 0.706631 seconds Code used: $v) { $array_of_refs[] = &$items[$k]; } function myclone($value) { return $value; } $start = microtime(true); $copy = array_map('myclone', $array_of_refs); $time = microtime(true) - $start; printf("%-10s %2.6f seconds\n", 'myclone:', $time); $start = microtime(true); $copy = unserialize(serialize($array_of_refs)); $time = microtime(true) - $start; printf("%-10s %2.6f seconds\n", 'serialize:', $time);
