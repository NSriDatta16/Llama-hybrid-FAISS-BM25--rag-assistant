[site]: stackoverflow
[post_id]: 640920
[parent_id]: 640902
[tags]: 
This operation can be called a symmetric difference. You need a different data structure, like a hash table. Add the intersection of both sets to it, then difference the intersection from each set. UPDATE: I got a bit of time to try this in code. I used HashSet with a set of 50,000 strings, from 2 to 10 characters long with the following results: Original : 79499 ms Hashset : 33 ms BTW, there is a method on HashSet called SymmetricExceptWith which I thought would do the work for me, but it actually adds the different elements from both sets to the set the method is called on. Maybe this is what you want, rather than leaving the initial two sets unmodified, and the code would be more elegant. Here is the code: using System; using System.Collections.Generic; using System.Diagnostics; using System.Linq; class Program { static void Main(string[] args) { // foo and bar have some identical elements (given a case-insensitive match) var foo = getRandomStrings(); var bar = getRandomStrings(); var timer = new Stopwatch(); timer.Start(); // remove non matches var f = foo.Where(x => !bar.Contains(x)).ToList(); var b = bar.Where(x => !foo.Contains(x)).ToList(); timer.Stop(); Debug.WriteLine(String.Format("Original: {0} ms", timer.ElapsedMilliseconds)); timer.Reset(); timer.Start(); var intersect = new HashSet (foo); intersect.IntersectWith(bar); var fSet = new HashSet (foo); var bSet = new HashSet (bar); fSet.ExceptWith(intersect); bSet.ExceptWith(intersect); timer.Stop(); var fCheck = new HashSet (f); var bCheck = new HashSet (b); Debug.WriteLine(String.Format("Hashset: {0} ms", timer.ElapsedMilliseconds)); Console.WriteLine("Sets equal? {0} {1}", fSet.SetEquals(fCheck), bSet.SetEquals(bCheck)); //bSet.SetEquals(set)); Console.ReadKey(); } static Random _rnd = new Random(); private const int Count = 50000; private static List getRandomStrings() { var strings = new List (Count); var chars = new Char[10]; for (var i = 0; i
