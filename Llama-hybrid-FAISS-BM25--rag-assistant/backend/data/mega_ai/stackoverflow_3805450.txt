[site]: stackoverflow
[post_id]: 3805450
[parent_id]: 3805395
[tags]: 
IMO inheritance is not the best way to model this, I would try composition instead. You could have a Person class and several Role classes (implementing a common interface, or being members of a Role enum, depending on the context), with each person having one or more Roles attached. This way you can add new role types easily, and dynamically attach/detach roles to/from a person. (You can also have persons without a role, should the need arise.) Rough example: interface Role { ... } final class Client implements Role { ... } final class Provider implements Role { ... } final class Agent implements Role { ... } class Person { List roles; public void addRole(Role role) { ... } public void removeRole(Role role) { ... } public Role getRoleOfType(Class roleType) { ... } } Update: enum based example This is applicable if the role objects have no state, thus you attach the same role instance(s) to every person. enum Role { CLIENT, PROVIDER, AGENT; // possible members, constructor etc. } The Person class is almost the same as above, except that I use an EnumSet instead of a List , since this is tailored specifically for enums, getRoleOfType() makes no sense here, so I replaced it with hasRole() . class Person { Set roles = new EnumSet (); public void addRole(Role role) { ... } public void removeRole(Role role) { ... } public boolean hasRole(Role role) { ... } }
