[site]: datascience
[post_id]: 27599
[parent_id]: 
[tags]: 
Creating a posterior distribution for classic coin flipping in python using grid search

I'm reading the book "Bayesian Analysis with Python" and the author provides some python code designed to show the grid search method of obtaining an approximate posterior distribution for the classic coin flipping example. In this example we set a prior on the probability of obtaining a head, then given some data our likelihood is the binomial distribution. So from my understanding using grid search we will break the interval $[0,1]$ into chunks, in our case 100. We have a prior probability $P(\theta=\theta_{0})$ for each of the points in the discretised grid we multiply this by $P(D|\theta=\theta_{0})$ and we multiply these together to get an un-normalised estimate at each location. The code is the following def posterior_grid_approx(grid_points=100, heads=6, tosses=9): grid = np.linspace(0, 1, grid_points) prior=np.repeat(5,grid_points) likelihood=stats.binom.pmf(heads, tosses, grid) unstd_posterior = likelihood * prior posterior = unstd_posterior / unstd_posterior.sum() return grid, posterior I don't understand why the prior is set to a list of $5$'s isn't this meant to be a probability value? From my understanding they've broken the grid into 100 different points obtained a binomial pmf for each of these locations and then multiplied the number by 5. How is this a valid prior? I'd really appreciate if someone could clearly explain the reasoning behind this as i like to understand the code as clearly as the concept. Thanks!
