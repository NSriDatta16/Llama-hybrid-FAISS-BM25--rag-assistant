[site]: stackoverflow
[post_id]: 408691
[parent_id]: 408670
[tags]: 
The following is of course all not quite precise. Take it with a grain of salt when you read it :) Well, the three things you refer to are automatic, static and dynamic storage duration , which has something to do with how long objects live and when they begin life. Automatic storage duration You use automatic storage duration for short lived and small data, that is needed only locally within some block: if(some condition) { int a[3]; // array a has automatic storage duration fill_it(a); print_it(a); } The lifetime ends as soon as we exit the block, and it starts as soon as the object is defined. They are the most simple kind of storage duration, and are way faster than in particular dynamic storage duration. Static storage duration You use static storage duration for free variables, which might be accessed by any code all times, if their scope allows such usage (namespace scope), and for local variables that need extend their lifetime across exit of their scope (local scope), and for member variables that need to be shared by all objects of their class (classs scope). Their lifetime depends on the scope they are in. They can have namespace scope and local scope and class scope . What is true about both of them is, once their life begins, lifetime ends at the end of the program . Here are two examples: // static storage duration. in global namespace scope string globalA; int main() { foo(); foo(); } void foo() { // static storage duration. in local scope static string localA; localA += "ab" cout The program prints ababab , because localA is not destroyed upon exit of its block. You can say that objects that have local scope begin lifetime when control reaches their definition . For localA , it happens when the function's body is entered. For objects in namespace scope, lifetime begins at program startup . The same is true for static objects of class scope: class A { static string classScopeA; }; string A::classScopeA; A a, b; &a.classScopeA == &b.classScopeA == &A::classScopeA; As you see, classScopeA is not bound to particular objects of its class, but to the class itself. The address of all three names above is the same, and all denote the same object. There are special rule about when and how static objects are initialized, but let's not concern about that now. That's meant by the term static initialization order fiasco . Dynamic storage duration The last storage duration is dynamic. You use it if you want to have objects live on another isle, and you want to put pointers around that reference them. You also use them if your objects are big , and if you want to create arrays of size only known at runtime . Because of this flexibility, objects having dynamic storage duration are complicated and slow to manage. Objects having that dynamic duration begin lifetime when an appropriate new operator invocation happens: int main() { // the object that s points to has dynamic storage // duration string *s = new string; // pass a pointer pointing to the object around. // the object itself isn't touched foo(s); delete s; } void foo(string *s) { cout size(); } Its lifetime ends only when you call delete for them. If you forget that, those objects never end lifetime. And class objects that define a user declared constructor won't have their destructors called. Objects having dynamic storage duration requires manual handling of their lifetime and associated memory resource. Libraries exist to ease use of them. Explicit garbage collection for particular objects can be established by using a smart pointer: int main() { shared_ptr s(new string); foo(s); } void foo(shared_ptr s) { cout size(); } You don't have to care about calling delete: The shared ptr does it for you, if the last pointer that references the object goes out of scope. The shared ptr itself has automatic storage duration. So its lifetime is automatically managed, allowing it to check whether it should delete the pointed to dynamic object in its destructor. For shared_ptr reference, see boost documents: http://www.boost.org/doc/libs/1_37_0/libs/smart_ptr/shared_ptr.htm
