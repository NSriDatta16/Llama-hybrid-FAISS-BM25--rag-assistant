[site]: stackoverflow
[post_id]: 757400
[parent_id]: 757300
[tags]: 
A good generic solution is to use heap size delta. This involves minimal effort and is re-usable between any type of object / object graph. By instantiating and destroying your objects many times and garbage collecting in between, and then taking the average, you avoid compiler and JVM optimizations that alter results and get a fairly accurate result. If you need an EXACT answer down to the byte then this may not be the solution for you, but for all practical applications that I know of (profiling, memory requirement calcualtions) it works extremely well. The code below will do just that. public class Sizeof { public static void main(String[] args) throws Exception { // "warm up" all classes/methods that we are going to use: runGC(); usedMemory(); // array to keep strong references to allocated objects: final int count = 10000; // 10000 or so is enough for small ojects Object[] objects = new Object[count]; long heap1 = 0; // allocate count+1 objects, discard the first one: for (int i = -1; i = 0) { objects[i] = object; } else { object = null; // discard the "warmup" object runGC(); heap1 = usedMemory(); // take a "before" heap snapshot } } runGC(); long heap2 = usedMemory(); // take an "after" heap snapshot: final int size = Math.round(((float)(heap2 - heap1)) / count); System.out.println("'before' heap: " + heap1 + ", 'after' heap: " + heap2); System.out.println("heap delta: " + (heap2 - heap1) + ", {" + objects[0].getClass() + "} size = " + size + " bytes"); } // a helper method for creating Strings of desired length // and avoiding getting tricked by String interning: public static String createString(final int length) { final char[] result = new char[length]; for (int i = 0; i
