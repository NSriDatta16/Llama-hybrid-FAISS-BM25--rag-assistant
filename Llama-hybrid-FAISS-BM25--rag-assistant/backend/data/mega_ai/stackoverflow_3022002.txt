[site]: stackoverflow
[post_id]: 3022002
[parent_id]: 
[tags]: 
JUnit 4 test suite problems

I have a problem with some JUnit 4 tests that I run with a test suite. If I run the tests individually they work with no problems but when run in a suite most of them, 90% of the test methods, fail with errors. What i noticed is that always the first tests works fine but the rest are failing. Another thing is that a few of the tests the methods are not executed in the right order (the reflection does not work as expected or it does because the retrieval of the methods is not necessarily in the created order). This usually happens if there is more than one test with methods that have the same name. I tried to debug some of the tests and it seems that from a line to the next the value of some attributes becomes null . Does anyone know what is the problem, or if the behavior is "normal"? Thanks in advance. P.S.: OK, the tests do not depend on each other, none of them do and they all have the @BeforeClass , @Before , @After , @AfterClass so between tests everything is cleared up. The tests work with a database but the database is cleared before each test in the @BeforeClass so this should not be the problem. Simplefied example: TEST SUITE: import org.junit.BeforeClass; import org.junit.runner.RunWith; import org.junit.runners.Suite; importy testclasses...; @RunWith(Suite.class) @Suite.SuiteClasses({ Test1.class, Test2.class }) public class TestSuiteX { @BeforeClass public static void setupSuite() { System.out.println("Tests started"); } @AfterClass public static void setupSuite() { System.out.println("Tests started"); } } TESTS: The tests are testing the functionalily on a server application running on Glassfish. Now the tests extend a base class that has the @BeforeClass - method that clears the database and login's and the @AfterClass that only makes a logoff. This is not the source of the problems because the same thing happened before introducing this class. The class has some public static attributes that are not used in the other tests and implements the 2 controll methods. The rest of the classes, for this example the two extends the base class and does not owerride the inherited controll methods. Example of the test classes: imports.... public class Test1 extends AbstractTestClass { protected static Log log = LogFactory.getLog( Test1.class.getName() ); @Test public void test1_A() throws CustomException1, CustomException2 { System.out.println("text"); creates some entities with the server api. deletes a couple of entities with the server api. //tests if the extities exists in the database Assert.assertNull( serverapi.isEntity(..) ); } } and the second : public class Test1 extends AbstractTestClass { protected static Log log = LogFactory.getLog( Test1.class.getName() ); private static String keyEntity; private static EntityDO entity; @Test public void test1_B() throws CustomException1, CustomException2 { System.out.println("text"); creates some entities with the server api, adds one entities key to the static attribute and one entity DO to the static attribute for the use in the next method. deletes a couple of entities with the server api. //tests if the extities exists in the database Assert.assertNull( serverapi.isEntity(..) ); } @Test public void test2_B() throws CustomException1, CustomException2 { System.out.println("text"); deletes the 2 entities, the one retrieved by the key and the one associated with the static DO attribute //tests if the deelted entities exists in the database Assert.assertNull( serverapi.isEntity(..) ); } This is a basic example, the actual tests are more complex but i tried with simplified tests and still it does not work. Thank you.
