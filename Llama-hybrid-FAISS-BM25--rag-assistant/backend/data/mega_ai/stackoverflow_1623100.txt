[site]: stackoverflow
[post_id]: 1623100
[parent_id]: 1623024
[tags]: 
Yes, you've created a struct on the heap. You haven't populated it correctly, and you are going to face problems deleting it - I'm not sure whether the homework covered that or not. As it stands, you're more likely to get memory corruption or, if you're lucky, a memory leak than to release one of these strings. Code that works with standard C89 and C99 Your code, somewhat fixed up... typedef struct String { int length; int capacity; char *ptr; } String; char* modelstrdup(char* src){ int length = strlen(src); char *space = malloc(sizeof(String) + length + 1); //String *string = space; // Original code - compilers are not keen on it String *string = (String *)space; assert(space != 0); string->ptr = space + sizeof(String); // or sizeof(*string) string->length = length; string->capacity = length + 1; strcpy(string->ptr, src); return string->ptr; } This code will work in C89 as well as C99 (except for the C99/C++ comments). You can probably optimize it to work with the 'struct hack' (saves a pointer in the structure - but only if you have a C99 compiler). The assert is sub-optimal error handling. The code doesn't defend itself against a null pointer for input. In this context, neither the length nor the capacity provides any benefit - there must be other functions in the suite that will be able to make use of that information. As already intimated, you are going to face problems deleting the string structure when the value handed back is not a pointer to the string. You have some delicate pointer adjustments to make. Code that works with standard C99 only In C99, section 6.7.2.1 paragraph 16 describes 'flexible array members': As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. With two exceptions, the flexible array member is ignored. First, the size of the structure shall be equal to the offset of the last element of an otherwise identical structure that replaces the flexible array member with an array of unspecified length. 106) Second, when a . (or ->) operator has a left operand that is (a pointer to) a structure with a flexible array member and the right operand names that member, it behaves as if that member were replaced with the longest array (with the same element type) that would not make the structure larger than the object being accessed; the offset of the array shall remain that of the flexible array member, even if this would differ from that of the replacement array. If this array would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it. 106 The length is unspecified to allow for the fact that implementations may give array members different alignments according to their lengths. Using a 'flexible array member', your code could become: typedef struct String { int length; int capacity; char ptr[]; } String; char* modelstrdup(char* src){ int length = strlen(src); String *string = malloc(sizeof(String) + length + 1); assert(string != 0); string->length = length; string->capacity = length + 1; strcpy(string->ptr, src); return string->ptr; } This code was accepted as clean by GCC 4.0.1 apart from a declaration for the function (options -Wall -Wextra ). The previous code needs a cast on 'String *string = (String *)space;' to tell the compiler I meant what I said; I've now fixed that and left a comment to show the original. Using the 'struct hack' Before C99, people often used the 'struct hack' to handle this. It is very similar to the code shown in the question, except the dimension of the array is 1, not 0. Standard C does not allow array dimensions of size zero. typedef struct String { size_t length; size_t capacity; char ptr[1]; } String; char* modelstrdup(char* src) { size_t length = strlen(src); String *string = malloc(sizeof(String) + length + 1); assert(string != 0); string->length = length; string->capacity = length + 1; strcpy(string->ptr, src); return string->ptr; } Code that uses a GCC non-standard extension to C89 and C99 The zero-size array notation is accepted by GCC unless you poke it hard - specify the ISO C standard and request pedantic accuracy. This code, therefore, compiles OK unless you get to use gcc -Wall -Wextra -std=c99 -pedantic : #include #include #include typedef struct String { int length; int capacity; char ptr[0]; } String; char* modelstrdup(char* src){ int length = strlen(src); String *string = malloc(sizeof(String) + length + 1); assert(string != 0); string->length = length; string->capacity = length + 1; strcpy(string->ptr, src); return string->ptr; } However, you should not be being trained in non-standard extensions to the C language before you have a thorough grasp of the basics of standard C. That is simply unfair to you; you can't tell whether what you're being told to do is sensible, but your tutors should not be misguiding you by forcing you to use non-standard stuff. Even if they alerted you to the fact that it is non-standard, it is not fair to you. C is hard enough to learn without learning tricksy stuff that is somewhat compiler specific.
