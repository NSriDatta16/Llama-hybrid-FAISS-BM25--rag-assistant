[site]: stackoverflow
[post_id]: 4386484
[parent_id]: 
[tags]: 
How to save and compare the signature in Android

i have the coding for draw the user signature.now i need the coding for save that signature in database and i need to compare the signature is correct or not. you can see my coding for draw signature on screen import android.app.Activity; import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.Path; import android.graphics.RectF; import android.os.Bundle; import android.util.AttributeSet; import android.view.MotionEvent; import android.view.View; import android.view.View.OnClickListener; import android.view.ViewGroup.LayoutParams; import android.widget.Button; import android.widget.LinearLayout; public class sign extends Activity { LinearLayout content; signature pnlpanel; Button btn,btn1; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); content = (LinearLayout) findViewById(R.id.linear); pnlpanel = new signature(this, null); pnlpanel.setBackgroundColor(Color.WHITE); content.addView(pnlpanel, LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT); btn = (Button) findViewById(R.id.bt); btn.setOnClickListener(new OnClickListener() { public void onClick(View v) { pnlpanel.clear(); } }); btn1 = (Button) findViewById(R.id.button); btn1.setOnClickListener(new OnClickListener() { public void onClick(View v) { switch(v.getId()) { case R.id.linear: //db.open(); //if(equals(linear)); }} }); } public class signature extends View { private static final float STROKE_WIDTH = 5f; /** Need to track this so the dirty region can accommodate the stroke. **/ private static final float HALF_STROKE_WIDTH = STROKE_WIDTH / 2; private Paint paint = new Paint(); private Path path = new Path(); /** * Optimizes painting by invalidating the smallest possible area. */ private float lastTouchX; private float lastTouchY; private final RectF dirtyRect = new RectF(); public signature(Context context, AttributeSet attrs) { super(context, attrs); paint.setAntiAlias(true); paint.setColor(Color.BLACK); paint.setStyle(Paint.Style.STROKE); paint.setStrokeJoin(Paint.Join.ROUND); paint.setStrokeWidth(STROKE_WIDTH); } public void save() { // TODO Auto-generated method stub } /** * Erases the signature. */ public void clear() { path.reset(); // Repaints the entire view. invalidate(); } @Override protected void onDraw(Canvas canvas) { canvas.drawPath(path, paint); } @Override public boolean onTouchEvent(MotionEvent event) { float eventX = event.getX(); float eventY = event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: path.moveTo(eventX, eventY); lastTouchX = eventX; lastTouchY = eventY; // There is no end point yet, so don't waste cycles invalidating. return true; case MotionEvent.ACTION_MOVE: case MotionEvent.ACTION_UP: // Start tracking the dirty region. resetDirtyRect(eventX, eventY); // When the hardware tracks events faster than they are delivered, the // event will contain a history of those skipped points. int historySize = event.getHistorySize(); for (int i = 0; i dirtyRect.right) { dirtyRect.right = historicalX; } if (historicalY dirtyRect.bottom) { dirtyRect.bottom = historicalY; } } /** * Resets the dirty region when the motion event occurs. */ private void resetDirtyRect(float eventX, float eventY) { // The lastTouchX and lastTouchY were set when the ACTION_DOWN // motion event occurred. dirtyRect.left = Math.min(lastTouchX, eventX); dirtyRect.right = Math.max(lastTouchX, eventX); dirtyRect.top = Math.min(lastTouchY, eventY); dirtyRect.bottom = Math.max(lastTouchY, eventY); } } }
