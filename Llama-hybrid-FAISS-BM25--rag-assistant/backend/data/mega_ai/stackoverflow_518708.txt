[site]: stackoverflow
[post_id]: 518708
[parent_id]: 
[tags]: 
Consequences of these Pointer Errors in C++ vs Managed

I'm making this a community wiki in order to better understand the semantic differences between these errors and their runtime or compiled consequences. Also, I've coded on Java far too long and I want to learn pointers better in C++ -- so I need other people to do it. Edit2: I am refactoring this question. The distinction I am trying to draw is that on managed code, these errors are all uniformly dealt with via an Exception. However, C++ is not so simple -- and I want to understand whether in each case you are likely to get an error, segfault, recoverable behavior, or worse a silent error that propagates. Please see my new concrete examples (and yes, I know that the answer is always "exactly as it is coded"; I'm a programmer after all. I want to know the interesting details of what you often run in to.) Edit3: In the following, by "class" I instead mean an instance of a class. Thanks Error 1: Pointer value is NULL, aka pointer == 0 Managed code: Throws NullPointerException at runtime C++: ? Example: Well, duh, you have a pointer to a class but it is initialized to 0. What happens when you send it off to a function. ie. C++ does not leave any indication of class; it is just a concatenation of public "placeholders". Error 2: Pointer points to an former class in memory whose value is NULL or == 0 Managed code: Not allowed through memory model. All referenced objects remain in memory. No exceptional cases? C++: ? Example: You had a pointer to a class and the class got deleted. You then pass the pointer as an argument to a function. Obviously, the problem that occurs depends on how the function deals with the pointed to class. My question is: Is there failsafe handling for this on STL? A good proprietary library? The average open source code? Error 3: Pointer points to an class that is not of the correct class or subclass Managed code: Throws ClassCastException. C++: [correct if wrong] Compiler tries to fight this by not allowing bad casts. However, if this is to occur at runtime, I presume undefined behavior. Are there cases of similar class objects where this would not always blow up? Example: Your pointer is reassigned incorrectly to have its value equal to a another class entirely. I assume that the function you pass this referenced class to will just blindly grab for the offset of any instance variables it references. Thus, it interprets the raw binary wrongly. There is no way to prevent this in C++? And/or... is there any case where this ability is exploited for good? Error 4: Pointer points into middle of class (misaligned) or uninitialized garbage Managed code: Not allowed by memory model. C++: Equivalent to case 3? Example: Frequently you actually do use this legally. For example you can access the array of an STL vector directly - this is pointing into the middle of a class. However, it seems just as easy to "miss"? Is there a common pitfall where you might have this happen against your will, like if a library is loaded that is different than the one you linked to (and is there a mechanism to prevent that?) Thanks in advance to all contributors.
