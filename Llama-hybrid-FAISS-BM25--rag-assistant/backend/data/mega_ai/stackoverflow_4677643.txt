[site]: stackoverflow
[post_id]: 4677643
[parent_id]: 4677589
[tags]: 
Well, there's a horrible way of doing it: int tCounter = 0; var groups = sequence.GroupBy(x => x.Contains("t") ? ++tCounter : tCounter) .Select(group => group.ToList()) .ToList(); or equivalently (but without the call to Select): int tCounter = 0; var groups = sequence.GroupBy(x => x.Contains("t") ? ++tCounter : tCounter, (count, group) => group.ToList()) .ToList(); That relies on a side-effect within the GroupBy clause - which is a really bad idea. LINQ is designed around functional ideals, where queries shouldn't have side effects. You put side effects in the code which uses the query, not in the query itself. This will work, but I wouldn't advise it. Here's a short but complete demonstration, just to prove it does actually work: using System; using System.Collections.Generic; using System.Linq; public class Test { static void Main(string[] args) { var input = new List {"a","b","c","at","h","c","bt"}; int tCounter = 0; var groups = input.GroupBy(x => x.Contains("t") ? ++tCounter : tCounter) .Select(group => group.ToList()) .ToList(); foreach (var list in groups) { Console.WriteLine(string.Join(", ", list)); } } } Output: a, b, c at, h, c bt What we really need is a "Scan" (aka foldl, I believe - not sure) operator - like Aggregate, but providing a running aggregation. Then the scan could keep track of the current number of Ts as well as the current value, and the GroupBy could work on that. It's not hard to write such an operator, and IIRC the Reactive Extensions System.Interactive assembly already contains one. You may want to use that instead of my horribly grotty hack. At that point you could actually write it reasonably elegantly in LINQ.
