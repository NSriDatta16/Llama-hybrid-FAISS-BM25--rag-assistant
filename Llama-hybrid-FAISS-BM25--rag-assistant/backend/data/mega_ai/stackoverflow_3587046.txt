[site]: stackoverflow
[post_id]: 3587046
[parent_id]: 3538948
[tags]: 
Uh, seems like I can't edit or comment, so I'll have to post this as an answer. I got around the problem by splitting the rule into an if statement rule and an if-else statement rule. However, the problem is back for my definition of an init declaration. init_decl %= identifier >> -('=' >> expression) ; identifier %= lexeme[(alpha | char_(' ')) >> *(alnum | char ('_'))] ; expression %= literal ; literal %= real_literal | string_literal ; real_literal %= double_ ; string_literal %= lexeme['"' >> *(char_ - '"') >> '"'] ; Same problem as before. However, I didn't do a good job of investigation the problem the first time at all. In member function 'void boost::variant::convert_construct(T&, int, mpl_::false_) [with T = const Lang::Elements::Expression, T0_ = double, T1 = std::basic_string, std::allocator >, T2 = boost::detail::variant::void_, T3 = boost::detail::variant::void_, T4 = boost::detail::variant::void_, T5 = boost::detail::variant::void_, T6 = boost::detail::variant::void_, T7 = boost::detail::vari That is this method: template void convert_construct( T& operand , int , mpl::false_ = mpl::false_() // is_foreign_variant ) { // NOTE TO USER : // Compile error here indicates that the given type is not // unambiguously convertible to one of the variant's types // (or that no conversion exists). // indicate_which( initializer::initialize( storage_.address() , operand ) ); } Remember this error originates from the %= in the init_decl expression. The only variant in this expression is the one contained by the Expression object which is the expression rule's attribute value. The error seems to say that a variant (the type of object Expression contains) is trying to instantiate itself from an Expression, but I can't see this anywhere in the code. Anyway, I added cast operators to the Expression struct that exposes its underlying variant, but still I got the error. The method that calls the method above is this: template variant(const T& operand) { convert_construct(operand, 1L); } It seems like it's trying to call this method instead: template void convert_construct( Variant& operand , long , mpl::true_// is_foreign_variant ) { convert_copy_into visitor(storage_.address()); indicate_which( operand.internal_apply_visitor(visitor) ); } Is this a compiler misunderstanding that is the cause of this error?
