[site]: stackoverflow
[post_id]: 5408858
[parent_id]: 5408829
[tags]: 
A couple of years back, I did an experiment on this. It's much faster to assign to the innerHTML property of an element to create a complex structure than it is to use repeated createElement appendChild insertBefore etc. calls. I've dug up the post I did about it (to the Prototype & script.aculo.us mailing list); below. Remember that parsing HTML and rendering it quickly is what browsers do , and they're highly optimized to do it. If you assign a string with a complex HTML structure in it to a container element's innerHTML property, you're making one trip from the JavaScript layer to the browser's rendering layer, after which the browser's parsing and rendering code can proceed uninterrupted. In contrast, if you're building that some complex structure using the DOM API, not only is there a lot of cross-layer travel happening (JavaScript -> browser -> JavaScript), but the browser is also having to work with the DOM API rather than its internal structures. Consequently, it's usually worth looking at a well-written JavaScript templating engine (if you want to do this client-side). These will usually "compile" the template once into an easily processed form, and during processing for a particular data set, they'll use tricks like building up the string as fragments in an array via Array#push , and then getting the final result via Array#join passing in "" as the separator. For large strings, that can be faster than string concatenation, although whether it is (and to what degree) is very implementation dependent (Firefox's SpiderMonkey vs. Chrome's V8 vs. IE's JScript), unlike the innerHTML vs. DOM thing, which only varies in how much faster it is. Here's the mailing list message from a couple of years back I was talking about (saying basically what I say above; wow, it was two years ago), here's the Pastie it refers to, here's that copied to JSBin , and finally...here's the code: (Note that the code is not intended to be a thing of beauty and a joy forever, it was a quick hack... Still though, yeesh, I'd like to think I'd hack up something a bit better now, two years later.) It may be worth converting this into something that will work on jsPerf . No time to do that now, I'm afraid. #log { border-bottom: 1px solid black; } #log p { margin: 0; padding: 0; } document.observe('dom:loaded', function() { $('btnDOMDirect').observe('click', useDOMDirect); $('btnPrototypeDOM').observe('click', usePrototypeDOM); $('btnHTML').observe('click', useHTML); }); var numRows = 10; var numCols = 10; function usePrototypeDOM(evt) { var table; var tbody; var tr; var td; var row; var col; var start; var end; start = (new Date()).getTime(); table = new Element('table'); tbody = new Element('tbody'); table.appendChild(tbody); for (row = 0; row '; for (row = 0; row '; for (col = 0; col Row ' + row + ', col ' + col + ' '; } html += ' '; } html += ' '; $('targetTable').update(html); end = (new Date()).getTime(); log('HTML took ' + (end - start) + 'ms'); } function log(msg) { var l; var p; l = $('log'); if (l) { p = new Element('p'); p.update(msg); l.appendChild(p); } }
