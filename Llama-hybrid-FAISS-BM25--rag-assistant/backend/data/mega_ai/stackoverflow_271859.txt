[site]: stackoverflow
[post_id]: 271859
[parent_id]: 270350
[tags]: 
Prism handles the capture of local variables differently then native Delphi or C#. In those 2 all references in your code of those locals will be mapped to fields of the compiler generated class that will hold your anonymous method. In prism, these locals stay ordinary locals, yet the fields of this hidden fields are set when you instantiate the anonymous method. One way to get a recursive lambda, would be to use a reference type to hold the lambda for you. All of this sounds much more complicated then it really is. 2 methods of accomplishing your goal: 1) var fib := new class(Call : Func := nil); fib.Call := n -> iif(n > 1, fib.Call(n - 1) + fib.Call(n - 2), n); var x := fib.Call(3); 2)When you do not want to have a reference to this wrapper, you can do it like so: var fib : Func; with fibWrapper := new class(Call : Func := nil) do begin fibWrapper.Call := n -> iif(n > 1, fibWrapper.Call(n - 1) + fibWrapper.Call(n - 2), n); fib := fibWrapper.Call; end; btw, the reason behind Prism not following C# here, is that for threading and loop, this reusing of captured vars makes for hard weird runtime problems. In Prism, captures are really captured the moment you assign the anonymous method or lambda. Which has a certain immuatble touch to it... Cheers, Robert
