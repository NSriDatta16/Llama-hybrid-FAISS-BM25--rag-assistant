[site]: stackoverflow
[post_id]: 1551068
[parent_id]: 1551033
[tags]: 
Revised answer The amended code you provide compiles almost cleanly - you should #include so that printf() is declared before it is used. (You should also use prototypes for functions - such as yyerror(const char *str) , and generally drag the code into the 21st Century.) It even responds correctly to '1 2 +'. With a single file, you don't need to use ' bison -d '. If you are seeing garbage, you need to review your build commands and build environment. Original answer Where to begin? Recommendation: get hold of the O'Reilly book on Lex and Yacc (from the library) or Flex and Bison (an August 2009 update/rewrite - probably not in the library yet). If you need a resource quicker, then I suggest the Unix Version 7 manuals or the GNU Bison manual - both of which are available online. In particular, read the 7th edition documents on Lex and Yacc; you're not trying to do what wasn't covered in the original decriptions (though the C code there pre-dates the C89 standard by a decade or more). You need to use bison -d to generate a header containing the token numbers. For source file 'zzz.y', this will generate C code 'zzz.tab.c' and 'zzz.tab.h'. You need to include 'zzz.tab.h' in the main program. You need to use C99 and should, therefore, have a return type on yylex() and main() . You need to declare yylval . Fortunately, the Bison 'zzz.tab.h' file will do that correctly; it isn't quite as simple as it appears. You may want to allow for negative numbers in your lexical analyzer (-3.1416). You may want to allow for explicitly positive numbers too (+3.1416). You probably need to ensure that '$$' and friends are of type double rather than the default type of int ( #define YYSTYPE double ).
