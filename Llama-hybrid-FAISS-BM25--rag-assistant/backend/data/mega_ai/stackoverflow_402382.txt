[site]: stackoverflow
[post_id]: 402382
[parent_id]: 402364
[tags]: 
You can use the type() built-in function to detect the type of the function. Say, if you want to check if a certain name hold a string data, you could do this: if type(this_is_string) == type('some random string'): # this_is_string is indeed a string So in your case, you could do it like this: options = { 'some string' : string_function, (float)(123.456) : float_function, (int)(123) : int_function } def call_option(arg): # loop through the dictionary for (k, v) in options.iteritems(): # if found matching type... if type(k) == type(arg): # call the matching function func = option[k] func(arg) Then you can use it like this: call_option('123') # string_function gets called call_option(123.456) # float_function gets called call_option(123) # int_function gets called I don't have a python interpreter nearby and I don't program in Python much so there may be some errors, but you should get the idea. EDIT: As per @Adam's suggestion, there are built-in type constants that you can check against directly, so a better approach would be: from types import * options = { types.StringType : string_function, types.FloatType : float_function, types.IntType : int_function, types.LongType : long_function } def call_option(arg): for (k, v) in options.iteritems(): # check if arg is of type k if type(arg) == k: # call the matching function func = options[k] func(arg) And since the key itself is comparable to the value of the type() function, you can just do this: def call_option(arg): func = options[type(arg)] func(arg) Which is more elegant :-) save for some error-checking. EDIT: And for ctypes support, after some fiddling around, I've found that ctypes.[type_name_here] is actually implented as classes. So this method still works, you just need to use the ctypes.c_xxx type classes. options = { ctypes.c_long : c_long_processor, ctypes.c_ulong : c_unsigned_long_processor, types.StringType : python_string_procssor } call_option = lambda x: options[type(x)](x)
