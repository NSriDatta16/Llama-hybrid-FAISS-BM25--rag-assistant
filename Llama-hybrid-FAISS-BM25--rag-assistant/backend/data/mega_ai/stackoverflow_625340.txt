[site]: stackoverflow
[post_id]: 625340
[parent_id]: 
[tags]: 
Spurious unblocking in boost thread

I came across this interesting paragraph in the Boost thread documentation today: void wait(boost::unique_lock & lock) ... Effects: Atomically call lock.unlock() and blocks the current thread. The thread will unblock when notified by a call to this->notify_one() or this->notify_all(), or spuriously . When the thread is unblocked (for whatever reason), the lock is reacquired by invoking lock.lock() before the call to wait returns. The lock is also reacquired by invoking lock.lock() if the function exits with an exception. So what I am interested in is the meaning of the word "spuriously". Why would the thread be unblocked for spurious reasons? What can be done to resolve this?
