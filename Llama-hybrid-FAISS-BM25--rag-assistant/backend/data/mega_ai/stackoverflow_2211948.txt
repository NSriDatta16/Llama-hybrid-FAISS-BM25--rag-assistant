[site]: stackoverflow
[post_id]: 2211948
[parent_id]: 2211706
[tags]: 
It's easy to check if there's any difference, with the dis module: >>> dis.dis(compile('not a in b','','exec')) 1 0 LOAD_NAME 0 (a) 3 LOAD_NAME 1 (b) 6 COMPARE_OP 7 (not in) 9 POP_TOP 10 LOAD_CONST 0 (None) 13 RETURN_VALUE >>> dis.dis(compile('a not in b','','exec')) 1 0 LOAD_NAME 0 (a) 3 LOAD_NAME 1 (b) 6 COMPARE_OP 7 (not in) 9 POP_TOP 10 LOAD_CONST 0 (None) 13 RETURN_VALUE See? The awkward first form (who often confuses those who can't immediately tell the relative priority of not and in operators) gets compiled into exactly the same bytecode as the can't-confuse-anybody second for, with the single not in operator. Similarly: >>> dis.dis(compile('not a is b','','exec')) 1 0 LOAD_NAME 0 (a) 3 LOAD_NAME 1 (b) 6 COMPARE_OP 9 (is not) 9 POP_TOP 10 LOAD_CONST 0 (None) 13 RETURN_VALUE >>> dis.dis(compile('a is not b','','exec')) 1 0 LOAD_NAME 0 (a) 3 LOAD_NAME 1 (b) 6 COMPARE_OP 9 (is not) 9 POP_TOP 10 LOAD_CONST 0 (None) 13 RETURN_VALUE both these forms -- the goofy, confusing first one, and the elegant second one -- compare to exactly the same code, and both use the is not operator. Of course there's no good reason to use the forms that can confuse the reader (unless you like to set traps for those who read your code!-), but in terms of execution semantics and speed there's no difference whatsoever.
