[site]: stackoverflow
[post_id]: 5498835
[parent_id]: 5498776
[tags]: 
You'd need to have some way of creating an instance of T , based on a String (or equivalently, converting a String to a T ). Casting doesn't do what you perhaps think it does in this case. All a cast does is tell the type system, "I know that you have a different, less specific idea of what class this object is, but I'm telling you that it's a Foo . Go ahead, check its run-time class and see that I'm right!". In this case, however, the String is not necessarily a T , which is why the cast fails. Casting doesn't convert, it merely disambiguates . In particular, if T happens to be Integer in this case, you'd need to convert the String to an Integer by calling Integer.parseInt(element) . However, the part of the code that you've copied doesn't know what T is going to be when it's invoked, and can't perform these conversions itself. Hence you'd need to pass in some parameterised helper object to perform the conversion for you, something like the following: interface Transformer { O transform(I input); } ... public void yourMethod(BufferedReader br, Transformer transformer) { String element = br.readLine(); T elem = transformer.transform(element); // Do what you want with your new T }
