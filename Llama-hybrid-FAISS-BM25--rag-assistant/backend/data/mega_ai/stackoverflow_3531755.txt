[site]: stackoverflow
[post_id]: 3531755
[parent_id]: 3531415
[tags]: 
If the issue is simlpy "members have email addresses", then I'd keep the email address directly associated with the member, and not normalize it out to an Emails table. This is because not all "members" will necessarily share emails. If (and don't ask me why, I don't understand end-users) two memebers share the same email address, what happens when one of them changes their address--but the other one doesn't want to? Second case, what if I have two memberships in your system, both with the same email address, and then I want to change one of them to a different address? (Don't ask me why, I'm an end-user and I already said I don't understand end-users.) This would cover a fairly simple and straight-forward situation. If your system is different such that you need more or tighter control over emails, normalization may work for you. The trick is in determining if, from the perspective of the data, it's repeating data that can be normalized, or "distinct" data that just happens to contain some duplicating values. The Bounceback email table fits in either way, as its a separate kind of data (or kind of email address). As for strings and index length, these days if an RDBMS claims that it can index or uniquely index a string up to X characters (just how long do email addresses get?) you can rely on it to do so. It may not perform too quickly, as it has to process X bytes of data per key instaed of 4 (typical integer storage size), but it will work.
