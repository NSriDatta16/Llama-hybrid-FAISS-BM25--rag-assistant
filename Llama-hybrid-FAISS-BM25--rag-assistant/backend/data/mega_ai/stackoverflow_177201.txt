[site]: stackoverflow
[post_id]: 177201
[parent_id]: 177189
[tags]: 
If I believe this article , by : having the first instance attempt to open a listening socket on the localhost interface. If it's able to open the socket, it is assumed that this is the first instance of the application to be launched. If not, the assumption is that an instance of this application is already running. The new instance must notify the existing instance that a launch was attempted, then exit. The existing instance takes over after receiving the notification and fires an event to the listener that handles the action. Note: Ahe mentions in the comment that using InetAddress.getLocalHost() can be tricky: it does not work as expected in DHCP-environment because address returned depends on whether the computer has network access. Solution was to open connection with InetAddress.getByAddress(new byte[] {127, 0, 0, 1}) ; Probably related to bug 4435662 . I also found bug 4665037 which reports than Expected results of getLocalHost : return IP address of machine, vs. Actual results : return 127.0.0.1 . it is surprising to have getLocalHost return 127.0.0.1 on Linux but not on windows. Or you may use ManagementFactory object. As explained here : The getMonitoredVMs(int processPid) method receives as parameter the current application PID, and catch the application name that is called from command line, for example, the application was started from c:\java\app\test.jar path, then the value variable is " c:\\java\\app\\test.jar ". This way, we will catch just application name on the line 17 of the code below. After that, we search JVM for another process with the same name, if we found it and the application PID is different, it means that is the second application instance. JNLP offers also a SingleInstanceListener
