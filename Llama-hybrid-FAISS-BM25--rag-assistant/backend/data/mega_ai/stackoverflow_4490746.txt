[site]: stackoverflow
[post_id]: 4490746
[parent_id]: 4490001
[tags]: 
The amount of RAM has nothing to do with the amount of memory available to a .NET program. All modern operating systems provide virtual memory. On Windows, the typical amount of virtual memory available to a program is a bit less than 2 gigabytes. There's a special boot option (/3GB) that increases that to 3 gigabytes, at a cost of taking addressable memory away from the operating system. It doesn't work anymore on most modern machines, the video card tends to eat up too much addressable physical memory. It isn't impossible to actually get less than 2GB because of this. If the machine runs a 64-bit operating system then you'll get close to 4 gigabytes if the code runs in x86 mode. And oodles of virtual memory in x64 mode, limited only by the maximum size of the paging file. These virtual memory sizes are completely independent of the actual amount of RAM installed on the machine. If you have less RAM than addressable virtual memory space, very common 15 years ago, then it is possible to invoke so-called 'paging file thrashing'. You see the operating system trying to provide enough available RAM to honor the program's need to use too much virtual memory at the same time. It swaps data between RAM and the paging file. That can severely slow down the machine, you run out of patience before you run out of memory. An OutOfMemoryException tells you that the program ran out of addressable virtual memory. The most typical cause is not actually completely depleting all address space, it is running out of holes big enough to fit the object you're trying to allocate. Virtual memory can become fragmented. The SysInterals' VMMap utility can give you insight in how the virtual memory of your program is divvied-up. Running out of virtual memory is quite difficult to deal with, it is essentially an asynchronous exception that you cannot recover from. With the exception of doing something like loading a bitmap, the kind of object that requires lots of (unmanaged) memory and therefore almost always has trouble with finding a large enough hole. In general, your program should never get any closer than using up half of the available space. That's not usually difficult, a gigabyte is a lot of memory. When your program's needs are fundamentally beyond that limit then you must specify a 64-bit operating system requirement for your program. A two hundred dollar solution.
