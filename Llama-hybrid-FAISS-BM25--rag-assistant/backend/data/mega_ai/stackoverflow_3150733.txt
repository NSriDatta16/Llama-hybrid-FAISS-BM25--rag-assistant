[site]: stackoverflow
[post_id]: 3150733
[parent_id]: 
[tags]: 
C# - Organized object access with performance in mind

Uhm, so I had problems with the title, but this was my best shot! Situation: I am writing a library so that I easily can re-use my code in future projects, without thinking about the internals. This library is supposed to be able to create objects at runtime and then access them to do tasks via a method. All by using a easy-to-use identifier. Something like this: class Manager { Object[] Foo; // Other stuff + initialization logic CreateFoo(/*Some parameters here + Identifier*/) { // Create a new Foo here; } AddBar(/*Moar parameters + Foo identifier*/) { Foo[StoID(identifier)].AddBar(/*Params*/); } } class Software { Software() { // Create a lot of Foos. while(1) { manager.CreateFoo(/*Params*/); } } void OhHai() { // This method can be called a LOT (100 times per update) or not at all // depending on circumstances. manager.AddBar(/*Params*/); } } Disclaimer: No, that is NOT actually my code silly! Problem: I might want to access my Foo Objects a lot and the performance is crucial, but so is manageability and ease of use. My first thought, for example, was to use strings and array indexes to create a small, dynamic conversion-library. However this would mean a lot of iterations - depending on how many Foos are created - and string-comparing. Example: class Software { Manager manager; Software() { manager.CreateFoo("Lol", /*Parameters*/); manager.CreateFoo("Cat", /*Parameters*/); } void OhHai() { manager.AddBar("Lol", /*Parameters 1*/; manager.AddBar("Cat", /*Parameters 2*/; } } The performance of directly accessing a Foo with an index must be far greater than first converting a string to id. However strings are easily managed by humans so ease of use would be perfect that way. What I'm asking: How are these things usually handled and does anyone have a suggestion for how I should design this? Edit: Basically I'm trying to find an easy way for my manager to know which Foo to add a Bar to! :)
