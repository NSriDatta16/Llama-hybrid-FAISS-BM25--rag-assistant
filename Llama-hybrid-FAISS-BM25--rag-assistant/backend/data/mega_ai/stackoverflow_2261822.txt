[site]: stackoverflow
[post_id]: 2261822
[parent_id]: 2256875
[tags]: 
You sidestepped the problems you were having using slices by delegating them to StringVector. I've revised your initial implementation, which used string slices, to become a valid, working program. type Question struct { q []string a []string } The type Question is a struct which has two elements, q and a, which are slices of an array of strings. A slice implicitly contains a pointer to the element of the array which begins the slice, the length of the slice, and the capacity of the slice. var q Question declares q, allocating storage for the Question struct, and initializes the struct fields (slices q.q and q.a) to zero i.e. the slice pointers are nil, and the slice len() and cap() functions return zero. No storage is allocated for string arrays; we need to do that separately. package main import "fmt" type Question struct { q []string a []string } func addString(ss []string, s string) []string { if len(ss)+1 > cap(ss) { t := make([]string, len(ss), len(ss)+1) copy(t, ss) ss = t } ss = ss[0 : len(ss)+1] ss[len(ss)-1] = s return ss } func (item *Question) Add(q string, a string) { item.q = addString(item.q, q) item.a = addString(item.a, a) } func main() { var q Question q.Add("A?", "B.") fmt.Println("Q&A", q) }
