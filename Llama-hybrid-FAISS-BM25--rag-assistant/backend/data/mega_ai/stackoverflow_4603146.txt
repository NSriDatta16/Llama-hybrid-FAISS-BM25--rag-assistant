[site]: stackoverflow
[post_id]: 4603146
[parent_id]: 4583630
[tags]: 
The problem with standard symmetric/asymetric/hash algorithms (MDx, SHAx, RSA, etc.) is they cannot operate on very short strings like a 20/30 characters-long product key strings. If you can give your users ~1000 characters-long strings, then I would go for these algorithms. If you can't, here is some C# code that is capable of building an "almost-totally-random" short product key, but with a hidden byte in it. You can put anything you want in that "hidden byte" and the key follows some algorithm that is not so easy to guess. You can validate a passed in string & reread the byte using the TryReadKey() like this: string key = BuildKey(myHiddenByte); // give that to the end user ... byte hidden; if (!TryReadKey(key, out hidden)) { Console.WriteLine("key is not ok"); } else { Console.WriteLine("key is ok and hidden byte is " + hidden); } The algorithm uses Steganography principles, is certainly not bullet-proof and could be improved, but can be useful. Note key generation can take some time, it's normal. It produces keys like this (note the first word is 6 chars long, the other 5 chars long): KZGMB0-XYJC2-YRKH3-8LD8G-5FUZG YKU93K-M34PD-E5PL0-QM91J-QLDZF DH27H9-NCW8E-EMGPL-YCJXJ-N2PRG WDAKDE-G56NR-6BA3R-0JE6U-625EB 6D5EJ0-NJDAK-EMGZR-Z6ZDF-JHJGF .... Here is the code: // need 32 characters, so we can use a 5-bit base encoding // 0 1 2 3 // 01234567890123456789012345678901 private const string KeyChars = "ABCDEFGHJKLMNPQRTUWXYZ0123456789"; private const int MinSum = 2000; private const int Mask = 0xFFFFF; // beware, this can have a dramatic influence on performance /// /// Builds a key and hides data in it. /// Key format is XXXXXX-XXXXX-XXXXX-XXXXX-XXXXX. /// /// The hidden data. /// The build key public static string BuildKey(byte hiddenData) { int index; Guid guid; uint[] word = new uint[4]; byte[] array; while (true) { // we use guid initial randomness characteristics guid = Guid.NewGuid(); array = guid.ToByteArray(); int sum = array.Aggregate(0, (current, b) => current + b); // a simple check to make sure the guid is not filled with too much zeros... if (sum 0) && (key.Length % 6) == 0) { key.Append('-'); } key.Append(KeyChars[encodingByte]); encodingBitIndex += 5; } return key.ToString(); } /// /// Validates the specified key and reads hidden data from it. /// /// The key. /// The hidden data. /// true if the key is valid and hidden data was read; false otherwise. public static bool TryReadKey(string key, out byte hiddenData) { hiddenData = 0; if (key == null) return false; key = key.Replace("-", string.Empty); if (key.Length != 26) return false; byte[] array = new byte[16]; int encodingBitIndex = 0; foreach (char t in key) { byte b = 255; for (byte k = 0; k current + b); // add 256 because we changed the hidden byte sum += 256; if (sum > 24); hiddenData = (byte)(hiddenData ^ array[0] ^ array[4] ^ array[8] ^ array[12]); return true; } // get 5 bits from a byte buffer at an arbitrary bit index private static byte Get5Bits(byte[] buffer, int bitIndex) { int r = bitIndex % 8; if (r > r)) >> (3 - r)); byte b0 = (byte)((buffer[bitIndex / 8] & (0xFF >> r)) > (11 - r)); return b0; } // put 5 bits into a byte buffer at an arbitrary bit index private static void Put5Bits(byte[] buffer, int bitIndex, byte value) { int r = bitIndex % 8; if (r > (r - 3))); buffer[1 + (bitIndex / 8)] |= (byte)((value
