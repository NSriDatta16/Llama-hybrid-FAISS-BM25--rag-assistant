[site]: stackoverflow
[post_id]: 2671785
[parent_id]: 2671591
[tags]: 
Asking a question about SQL Server performance without providing a schema is a complete waste of everybody time. I'm going to answer a different question, which is one you should had been ask in the first place: What schema should I use to efficiently satisfy a query like SELECT DISTINCT TOP (200) COUNT(1) AS COUNT, KEYWORD FROM QUERIES WHERE KEYWORD LIKE '%Something%'GROUP BY KEYWORD ORDER BY 'COUNT' DESC when QUERIES table has over 1M rows? The proper schema depend on the selectivity of KEYWORD . One possible design would be to normalize KEYWORD into a lookup table and have a narrow non-clustered index on the lookup id: CREATE TABLE KEYWORDS (KeywordId INT NOT NULL IDENTITY(1,1) PRIMARY KEY, Keyword VARCHAR(...) UNIQUE); CREATE TABLE QUERIES (..., KeywordId INT NOT NULL, CONSTRAINT FK_KEYWORD FOREIGN KEY KeywordId REFERENCES KEYWORDS (KeywordId), ...); CREATE INDEX ndxQueriesKeyword ON Queries (KeywordId); If the number of distinct keyword is relatively low, the original query can be satisfied quickly by a scan of the Keywqord table followed by a nexted loop range scan of the ndxQueriesKeyword index, which is very narrow and therefore generates low IO. As the number of distinct keyword increases, this approach may start showing problems due to the high number of range scans on the Queries table, and possible even due to the full scan on the Keywords table. You may consider using a different WHERE clause, namely one LIKE 'Something% , which is SARGable and can leverage an index on KEYWORK, benefiting from a range reduction and a narrower scan than a full table scan. If you are on Enterprise Edition you can consider adding an indexes view with the pre-computed aggregates: CREATE VIEW vwQueryKeywords WITH SCHEMABINDING AS SELECT KEYWORD, COUNT_BIG(*) as COUNT FROM dbo.QUERIES GROUP BY KEYWORD; CREATE CLUSTERED INDEX cdxQueryKeywords ON vwQueryKeywords(KEYWORD); On EE the optimizer will consider the indexed view for the original query. On non-EE you will have to change the query to run against the view with the NOEXPAND hint: SELECT KEYWORD, COUNT FROM vwQueryKeywords WITH(NOEXPAND) WHERE KEYWORD LIKE '%Something%'; Another completely different approach is to ditch the LIKE '%Something%' condition altogether in favor of fullt-text search: SELECT DISTINCT TOP (200) COUNT(1) AS COUNT, KEYWORD FROM QUERIES WHERE CONTAINS (Keyword, Something) GROUP BY KEYWORD ORDER BY 'COUNT' DESC Because the FT search is a reverse-index lookup, it may prove optimal over a traditional WHERE. The only issue is that you'll only be able to search for full words, since FT won't let you search partial matches the way LIKE does. Again, the actual mileage will vary based on Keyword data profile (ie. its statistics and distribution).
