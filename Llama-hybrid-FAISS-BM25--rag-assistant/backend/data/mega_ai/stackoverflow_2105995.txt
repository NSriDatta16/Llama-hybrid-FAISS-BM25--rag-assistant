[site]: stackoverflow
[post_id]: 2105995
[parent_id]: 
[tags]: 
Help with PHP call_user_func and integrate function into Class?

Below is a function I found about a year ago that is supposed to put a lock on a memcache key so you can update it's value without any trouble of 2 request trying to update the key at the same time. It is pretty basic but I could use a little help in figuring out how to use it 100%. The part I am not sure about is where it passes in a $updateFunction which is then passed to ** call_user_func($updateFunction, $data); // update data I have never used the call_user_func() before. Based on this code could some one show me a basic example of what a function that it calls could look like (without doing any mysql or anything, just the way it would work). Would I be able to pass in multiple properties to the call function? Thanks for any help. Also assuming I already have a Class name Memcache which has a connection or object with this $this->connection would I need to change anything in the function below to add it into my Memcache class? Also once this function is part of my existing memcache class, will that callback function be able to call methods in other classes? Hope this isn't to confusing. // {{{ locked_mecache_update($memcache,$key,$updateFunction,$expiryTime,$waitUTime,$maxTries) /** * A function to do ensure only one thing can update a memcache at a time. * * Note that there are issues with the $expiryTime on memcache not being * fine enough, but this is the best I can do. The idea behind this form * of locking is that it takes advantage of the fact that * {@link memcache_add()}'s are atomic in nature. * * It would be possible to be a more interesting limiter (say that limits * updates to no more than 1/second) simply by storing a timestamp or * something of that nature with the lock key (currently stores "1") and * not deleitng the memcache entry. * * @param $memcache memcache the memcache object * @param $key string the key to do the update on * @param $updateFunction mixed the function to call that accepts the data * from memcache and modifies it (use pass by reference). * @param $expiryTime integer time in seconds to allow the key to last before * it will expire. This should only happen if the process dies during update. * Choose a number big enough so that $updateFunction will take much less * time to execute. * @param $waitUTime integer the amount of time in microseconds to wait before * checking for the lock to release * @param $maxTries integer maximum number of attempts before it gives up * on the locks. Note that if $maxTries is 0, then it will RickRoll forever * (never give up). The default number ensures that it will wait for three * full lock cycles to crash before it gives up also. * @return boolean success or failure */ function locked_memcache_update( $memcache, // Memcache Object $key, // Key to update $updateFunction, // Function to pass key/value into to update $expiryTime=3, // time before key expires $waitUtime=101, // time to wait for to check for lock release $maxTries=100000) // number of times to try to get lock { $lock = 'lock:'.$key; // get the lock {{{ if ($maxTries>0) { for ($tries=0; $tries add($lock,1,0,$expiryTime)) { break; } usleep($waitUtime); } if ($tries == $maxTries) { // handle failure case (use exceptions and try-catch if you need to be nice) trigger_error(sprintf('Lock failed for key: %s',$key), E_USER_NOTICE); return false; } } else { while (!$memcache->add($lock,1,0,$expiryTime)) { usleep($waitUtime); } } // }}} //Now we have a lock so we can update of key/value // modify data in cache {{{ $data = $memcache->get($key, $flag); call_user_func($updateFunction, $data); // update data $memcache->set($key, $data, $flag); // }}} // Update complete so we release our lock // clear the lock $memcache->delete($lock,0); return true; } // }}} ?> UPDATE Here is my existing Memcache class that I would like to integrate this with connection = new MemCache; } // Set a key/value to memcache with Expire time function store($key, $data, $ttl) { return $this->connection->set($key, $data, 0, $ttl); } // Retrieve a Value from Memcache with a KEY function fetch($key) { return $this->connection->get($key); } // DELETE a Key/Value from Memcache with a KEY function delete($key) { return $this->connection->delete($key); } // Add a server connection to memcache function addServer($host, $port = 11211, $weight = 10) { $this->connection->addServer($host, $port, true, $weight); } // Clear all memcache data function flush() { return $this->connection->flush(); } // Show Memcache stats function stats() { return statDetails($this->connection->getStats()); } // Show Memcache stats in a table function statDetails($status) { echo " "; echo " Memcache Server version: " . $status["version"] . " "; echo " Process id of this server process " . $status["pid"] . " "; echo " Number of seconds this server has been running " . $status["uptime"] . " "; echo " Accumulated user time for this process " . $status["rusage_user"] . " seconds "; echo " Accumulated system time for this process " . $status["rusage_system"] . " seconds "; echo " Total number of items stored by this server ever since it started " . $status["total_items"] . " "; echo " Number of open connections " . $status["curr_connections"] . " "; echo " Total number of connections opened since the server started running " . $status["total_connections"] . " "; echo " Number of connection structures allocated by the server " . $status["connection_structures"] . " "; echo " Cumulative number of retrieval requests " . $status["cmd_get"] . " "; echo " Cumulative number of storage requests " . $status["cmd_set"] . " "; $percCacheHit = ((real)$status["get_hits"] / (real)$status["cmd_get"] * 100); $percCacheHit = round($percCacheHit, 3); $percCacheMiss = 100 - $percCacheHit; echo " Number of keys that have been requested and found present " . $status["get_hits"] . " ($percCacheHit%) "; echo " Number of items that have been requested and not found " . $status["get_misses"] . "($percCacheMiss%) "; $MBRead = (real)$status["bytes_read"] / (1024 * 1024); echo " Total number of bytes read by this server from network " . $MBRead . " Mega Bytes "; $MBWrite = (real)$status["bytes_written"] / (1024 * 1024); echo " Total number of bytes sent by this server to network " . $MBWrite . " Mega Bytes "; $MBSize = (real)$status["limit_maxbytes"] / (1024 * 1024); echo " Number of bytes this server is allowed to use for storage. " . $MBSize . " Mega Bytes "; echo " Number of valid items removed from cache to free memory for new items. " . $status["evictions"] . " "; echo " "; } } ?>
