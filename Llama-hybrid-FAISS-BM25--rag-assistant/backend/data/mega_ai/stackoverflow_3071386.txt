[site]: stackoverflow
[post_id]: 3071386
[parent_id]: 3071340
[tags]: 
And just like that I figured it out myself (finally after several weeks). Here's the answer (simple change the mouse move event as follows): msi.MouseMove += delegate(object sender, MouseEventArgs e) { lastMousePos = e.GetPosition(msi); if (duringDrag) { Point newPoint = lastMouseViewPort; newPoint.X += (lastMouseDownPos.X - lastMousePos.X) / msi.ActualWidth * msi.ViewportWidth; newPoint.Y += (lastMouseDownPos.Y - lastMousePos.Y) / msi.ActualWidth * msi.ViewportWidth; var limits = new Rect(new Point(1, 1 / msi.AspectRatio), new Point(-1 / Settings.ZoomLevel, -1 / msi.AspectRatio / Settings.ZoomLevel)); if (newPoint.X limits.Right * .999) { newPoint.X += (-2 * (lastMouseDownPos.X - lastMousePos.X)) / msi.ActualWidth * msi.ViewportWidth; // we went off left so reverse X direction } if (newPoint.Y limits.Bottom * .999) { newPoint.Y += (-2 * (lastMouseDownPos.Y - lastMousePos.Y)) / msi.ActualWidth * msi.ViewportWidth; // we went off Top so reverse direction } msi.ViewportOrigin = lastMouseViewPort = newPoint; lastMouseDownPos = lastMousePos; msi.SendMovedZoomMsg(Settings.ZoomLevel, newPoint, myClassName); } }; This probably doesn't completely constrain the image, but it keeps it on screen and more than likely the user will stop trying to move in the wrong direction
