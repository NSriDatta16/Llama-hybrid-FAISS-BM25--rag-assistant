[site]: stackoverflow
[post_id]: 3064552
[parent_id]: 3063636
[tags]: 
Sorry, I didn't pay close attention to your code. Too much (at-first-glance) irrelevant code and several too localized names which only makes things confusing. At least one of your major mistakes is that you used DataModel instead of the actual Product as item value. This makes no sense. Here's a kickoff example how the code should look like to get non-standard types in dropdowns to work flawlessly. XHTML: Bean: private Product selectedProduct; // +getter+setter private List selectProducts; // +getter public Bean() { selectProducts = new ArrayList (); for (Product product : ejb.list()) { selectProducts.add(new SelectItem(product, product.getDescription())); } } public void submit() { System.out.println("Selected product: " + selectedProduct.getDescription()); } ProductConverter: public Object getAsObject(FacesContext context, UIComponent component, String value) { // Convert String to Integer and find Product by Integer ID. return ejb.find(Integer.valueOf(value)); } public String getAsString(FacesContext context, UIComponent component, Object value) { // Convert Integer ID to String. return String.valueOf(((Product) value).getId()); } Alternatively, you can also use the f:selectItems with new JSF 2.0 var attribute so that you don't need to convert List from EJB to List : XHTML: Bean: private Product selectedProduct; // +getter+setter private List selectProducts; // +getter public Bean() { selectProducts = ejb.list(); } public void submit() { System.out.println("Selected product: " + selectedProduct.getDescription()); } This still requires the same ProductConverter . See also : Using objects in h:selectOneMenu
