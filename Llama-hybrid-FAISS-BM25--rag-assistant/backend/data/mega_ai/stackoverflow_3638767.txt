[site]: stackoverflow
[post_id]: 3638767
[parent_id]: 3630173
[tags]: 
Got it working properly with JSON data. I had to edit the "reopen" and "reselect" functions inside jstree itself. Here's the new functioning reopen function for anyone who needs it. reopen: function(is_callback) { var _this = this, done = true, current = [], remaining = []; if (!is_callback) { this.data.core.reopen = false; this.data.core.refreshing = true; } if (this.data.core.to_open.length) { $.each(this.data.core.to_open, function(i, val) { val = val.replace(/^#/, "") if (val == "#") { return true; } if ($(("li[id=" + val + "]")).length && $(("li[id=" + val + "]")).is(".jstree-closed")) { current.push($(("li[id=" + val + "]"))); } else { remaining.push(val); } }); if (current.length) { this.data.core.to_open = remaining; $.each(current, function(i, val) { _this.open_node(val, function() { _this.reopen(true); }, true); }); done = false; } } if (done) { // TODO: find a more elegant approach to syncronizing returning requests if (this.data.core.reopen) { clearTimeout(this.data.core.reopen); } this.data.core.reopen = setTimeout(function() { _this.__callback({}, _this); }, 50); this.data.core.refreshing = false; } }, The problem was that it was trying to find the element by a custom attribute. It was just pushing these strings into the array to search when it was expecting node objects. Using this line if ($(("li[id=" + val + "]")).length && $(("li[id=" + val + "]")).is(".jstree-closed")) { current.push($(("li[id=" + val + "]"))); } instead of if ($(val).length && $(val).is(".jstree-closed")) { current.push(val); } was all it took. Using a similar process I was able to persist the selected nodes this way as well. Hope this is of help to someone.
