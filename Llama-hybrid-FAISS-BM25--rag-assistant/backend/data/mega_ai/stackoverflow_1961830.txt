[site]: stackoverflow
[post_id]: 1961830
[parent_id]: 
[tags]: 
unary pointer increment in function call vs increment before/after function call

I am trying to understand a code, here is fragment which is causing confusion: typedef map > people_map; people_map people; . . . cout second.GetAge() == 100) { people.erase(j++); // iterator is advanced before the erase occurs } else ++j; // advance the iterator } // end of erase loop the confusion is: if i want to increment j after the function call it causes segmentation fault. I am not able to understand why: I change it to something like this: if (j->second.GetAge() == 100) { temp = j++; j--; people.erase(j); // iterator is advanced before the erase occurs j=temp; } causes segmentation fault. or like this: if (j->second.GetAge() == 100) { people.erase(j); // iterator is advanced before the erase occurs j++; } causes segmentation fault. here is the complete program listing: // disable warnings about long names #ifdef WIN32 #pragma warning( disable : 4786) #endif #include #include #include #include #include #include #include using namespace std; class Person { // private members string m_sName; string m_sEmail; int m_iAge; public: // constructor Person(const string sName, const string sEmail, const int iAge) : m_sName(sName), m_sEmail(sEmail), m_iAge(iAge) { }; // default constructor Person() : m_iAge(0) { }; // copy constructor Person(const Person & p) : m_sName(p.m_sName), m_sEmail(p.m_sEmail), m_iAge(p.m_iAge) { }; // operator = Person & operator=(const Person & rhs) { // don't assign to self if (this == &rhs) return *this; m_sName = rhs.m_sName; m_sEmail = rhs.m_sEmail; m_iAge = rhs.m_iAge; return *this; }; // access private members string GetName() const { return m_sName; }; string GetEmail() const { return m_sEmail; }; int GetAge() const { return m_iAge; }; }; // end of class Person // function object to print one person class fPrint { ostream & m_os; public: // constructor - remember which stream to use fPrint(ostream & os) : m_os(os) { }; // person object arrives as a pair of key,object void operator() (const pair & item) const { m_os > people_map; int main(void) { // make a map of people people_map people; // add items to list people [1234] = Person("Nick", "nick@some-email-address.com", 15); people [4422] = Person("Fred", "fred@nurk.com.au", 100); people [88] = Person("John", "john@smith.com.au", 35); // insert a different way ... people.insert(make_pair(42, Person("Abigail", "abigail@blah.com.au", 22))); // best to declare this on its own line :) fPrint fo(cout); // instance of function output object // print everyone (calls a function object to print) cout first second.GetName() second.GetAge() == 100) { people.erase(j++); // iterator is advanced before the erase occurs } else ++j; // advance the iterator } // end of erase loop // now display who is left cout
