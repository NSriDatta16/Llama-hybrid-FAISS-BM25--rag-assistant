[site]: stackoverflow
[post_id]: 3367420
[parent_id]: 3367227
[tags]: 
You could hide the base implementation of MakeBackupCall : public new bool MakeBackupCall(RackspaceDatabase d) { // Do something } That way, if the method is called on a RackspaceServer variable, the compiler will enforce the type of the paramter to be BackspaceDatabase . But of course it won't work if it is called on a DBServer variable, since the base implementation would be called... An acceptable compromise would be to do the actual implementation in a protected virtual method that takes a Database parameter : public abstract class DBServer { public List Databases { get; set; } // Non-virtual; the actual implementation is not done in that method anyway public bool MakeBackupCall(Database d) { return MakeBackupCallCore(d); } // Actual implementation goes there protected abstract MakeBackupCallCore(Database d); } public class RackspaceServer : DBServer { // Hide the base method public new bool MakeBackupCall(BackspaceDatabase d) { return MakeBackupCallCore(d); } // Do the actual implementation here, and ensure it is really a BackspaceDatabase protected virtual bool MakeBackupCallCore(Database d) { BackspaceDatabase bd = d as BackspaceDatabase; if (bd == null) throw new ArgumentException("d must be a BackspaceDatabase"); // do some different stuff with bd return true; } } That way, you can enforce the type at compile time when you explicitly use a BackspaceServer , and still use the derived implementation when you use a DbServer without knowing its actual type. A similar approach is used in ADO.NET classes : for instance, SqlConnection.CreateCommand() returns a SqlCommand , even though the base DbConnection.CreateCommand() returns a DbCommand . The base method is hidden, and the actual implementation is protected abstract ( CreateDbCommand )
