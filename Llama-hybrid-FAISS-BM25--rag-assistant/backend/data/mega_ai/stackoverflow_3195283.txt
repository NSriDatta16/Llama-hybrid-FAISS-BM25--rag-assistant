[site]: stackoverflow
[post_id]: 3195283
[parent_id]: 3194485
[tags]: 
You design a data model based not on how the data will be displayed but instead on how the data logically relates to itself. Each entity should model a real world object, event or condition with no regard to how that data will end up being displayed. In this case, you are modeling books and a user supplied organization of those books into list. You need a book entity to model the books and a list entity to model the users organization. (It doesn't have to be a "list" it could be "collection", "shelf" etc depending on what you're trying to model.) Presumably, each book can be in different list and each list may contain many books. Book { author:string; copyright:sting/date; item:(?); title:sting; list >list.books } List { name:string; books >book.list; } In your UI, you would have the fetched results controller (FRC) fetch all list entities and then display the name of each in a table view. When a table row is selected, you push the next view and hand it the NSSet returned by list.books of the list object associated with that row. In the next table view, each row is populated from one or more attributes of each book entity in the passed set. When row is selected, you push a book detail view and pass it the book entity associated with the selected row. Notice that from the perspective of the data model, the UI is irrelevant. You could be displaying the data in web view or even a text based command line. All the data model cares about are the contents of the entities and the logical relationships between them. Design your data model to handle the logical relationships in your data. Once you do that, the UI becomes very simple to implement regardless of the format because the UI is not responsible for maintaining the integrity of the data model and the data model does not have to worry about the state of the UI.
