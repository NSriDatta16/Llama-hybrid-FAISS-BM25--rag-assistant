[site]: stackoverflow
[post_id]: 3843350
[parent_id]: 
[tags]: 
How to call a C++ DLL from VB6 without going through COM?

OK, so I have a C++ project that compiles to a DLL file. I am able to reference this file in C# and see/use all of the objects and functions within the DLL file. What I need to do is to reference those objects and function through VB6. The C++ code has nothing in it that looks like it's creating a DLL. There are no '__declspec(dllexport)' modifiers, just C++ code. There are objects like this: String ^ Array^ I'm not entirely sure what they are. My knowledge of C++ is not very extensive and I've only coded in C++ for Linux systems, although from the usage they sort of look like pointers. Do these objects have anything to do with a DLL in C++? Anyway, I can add any wrappers that I need or add a definition file (.def), although I do not know what wrappers to use and I don't know how a definition file works or how it needs to be constructed. Any help and/or suggestions are appreciated. If you can refer me to some good info as well, that would be helpful. All searching I have done has not helped. Remember, I need to access all functions and objects in this C++ DLL from VB6. Thanks. EDIT: Added .h file and AssemblyInfo.cpp spec to the question I changed some names in these files, but the structure is the same. Note that this references other files, but I assume that if one can be made to work then the others can with the same process. I can see every object, just not the methods: //myDBObject.h #pragma once using namespace System; namespace myDBNamespace { #include "ProblemSolution.h" public ref class MyDataBaseAccessor { public: MyDataBaseAccessor(); static String ^ GetServiceVersion() { return sDLLVersion;}; int GetServiceStatus() { return myiDBStatus;}; String ^ GetMyVersion(); String ^ GetDBVersion(); String ^ GetDLLVersion(); String ^ GetExpireDate(); MyOtherObject ^ GetMyOtherObject(); int ProcessProblem(ProblemSolution ^ dsps); private: static MyDataBaseController ^ myDataBase; static MyOtherObject ^ myObjs; static MyDataset ^ myDS; static String ^ myDBPath; static String ^ sDLLVersion = "0.01"; static String ^ sReqDBVer = "0.01"; static int myiDBStatus; static bool myBoolean, myOtherBoolean, mybNoChain; }; } Here is the AssemblyInfo.cpp file: #include "stdafx.h" using namespace System; using namespace System::Reflection; using namespace System::Runtime::CompilerServices; using namespace System::Runtime::InteropServices; using namespace System::Security::Permissions; // // General Information about an assembly is controlled through the following // set of attributes. Change these attribute values to modify the information // associated with an assembly. // [assembly:AssemblyTitleAttribute("My Product Title")]; [assembly:AssemblyDescriptionAttribute("")]; [assembly:AssemblyConfigurationAttribute("")]; [assembly:AssemblyCompanyAttribute("My Company")]; [assembly:AssemblyProductAttribute("My Product Name")]; [assembly:AssemblyCopyrightAttribute("My Copyright")]; [assembly:AssemblyTrademarkAttribute("My Program")]; [assembly:AssemblyCultureAttribute("")]; // // Version information for an assembly consists of the following four values: // // Major Version // Minor Version // Build Number // Revision // // You can specify all the value or you can default the Revision and Build Numbers // by using the '*' as shown below: [assembly:AssemblyVersionAttribute("1.0.*")]; [assembly:ComVisible(true)]; //Here is the ComVisible tag. It was false and I set it to true [assembly:CLSCompliantAttribute(true)]; [assembly:SecurityPermission(SecurityAction::RequestMinimum, UnmanagedCode = false)];
