[site]: stackoverflow
[post_id]: 1695339
[parent_id]: 1695311
[tags]: 
You want to derive from CriticalFinalizerObject in the case where the usage of your type should be treated as a constrained execution region or CER for short. A CER is an area of code that must complete without exception and in my experience they are not used that often (but that doesn't mean they aren't useful). Implementing the IDisposable interface is a bit different - this interface offers a deterministic way of cleaning up after your type once the consumer of it no longer needs it. This is often used to clean up unmanaged resources (like database connections and file handles). Yes, the garbage collector will have to move many objects in memory during its compact phase but this isn't really something that can be helped. Objects will be moved when virtual memory becomes fragmented and this is something that is outside of your control since the garbage collector is completely responsible for the managed heap. The best practice in this case is to build your types to work as best as possible and only worry about the garbage collector when instrumentation proves that it has become an issue. I will see if I can find some more helpful articles but CLR via C# is pretty much the best information you will be able to find on this topic.
