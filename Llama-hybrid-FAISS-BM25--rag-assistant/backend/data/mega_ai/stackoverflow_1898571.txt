[site]: stackoverflow
[post_id]: 1898571
[parent_id]: 1898161
[tags]: 
It's best not to think about it in the abstract, but in terms of a concrete design. If you run out of RAM, you'll be sorry, so keep your data structure as clean and simple as possible, even if it seems that you might have to code some loops that might seem inefficient. Complexifying code and data structure because of concerns about performance is the essence of premature optimization. And, as much as people inveigh against premature optimization and claim they don't do it, they do it anyway, to a scary degree. When it is working and doing what you need it to do, and if you actually have one or more performance problems, then deal with performance. The usual method is to use a profiling tool, but this is the method I prefer . Be careful of multi-cores. Parallelism and threads allow you to get multiple agents working overlapped in time, such as disk heads, CPUs, or human clients. If, for example, your processes are I/O bound, trying to do them on multiple cores won't help much and might hurt. If there is only a single physical disk drive, you might not gain much by trying to overlap I/O bound threads, and it might hurt. On the other hand, if you've got a thread per user, that might make sense because such threads spend most of their time waiting for the user.
