[site]: stackoverflow
[post_id]: 2941211
[parent_id]: 2940999
[tags]: 
Variables are scoped to functions, not if/else/for/while/etc. blocks. Every time you call fragment.appendChild((function() { ... you are creating a new function (new scope). This new function references the i and response variables. So now, i and response are scoped to BOTH the outer function and the new function. That's not enough to leak memory. ( i and response are normal variables that will go out-of-scope after the new function is done) BUT, you create a p DOM element in the new function, and reference it in the outer function (you return it to the fragment.appendChild call as an argument). Now think about it: you have the outer scope fragment referencing a p DOM created from the inner scope, which needed to use the i and response variables from the outer scope to create the DOM element in the first place. The fragment and p DOM objects each have a reference to each other. Despite your attempts to zero-out the reference count by nulling the variable pointers, p=null and fragment = null will not get rid of all references. The fragment still has a reference to the inner p , which still has a reference to the outer response variable. The two "scopes" will never be garbage collected because of this remaining circular dependency. Anyone, please correct me if I've made any mistakes. As for a solution, just don't use an inner function! fragment = document.createDocumentFragment(); for (var i = 0, var e = response.verses.length; i ', ' '); fragment.appendChild(p); } params[0].appendChild( fragment );
