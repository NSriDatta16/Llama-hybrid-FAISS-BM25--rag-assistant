[site]: stackoverflow
[post_id]: 833114
[parent_id]: 833034
[tags]: 
There are a few things I don't understand here. I see that this is tagged for C++/CLI , but what I describe below should be the same as Standard C++ . Doesn't compile The code you give doesn't compile; get_error_from_header does not specify a return type. In my experiments I made the return type size_t . Signature of C++ strstr() The signature for strstr() in the standard C library is: char * strstr(const char *s1, const char *s2); but the signature for strstr() in the C++ library , depending on the overload, is one of: const char * strstr ( const char * str1, const char * str2 ); char * strstr ( char * str1, const char * str2 ); I would choose the first overload, because you don't want to modify the string, you only want to read it. Therefore you can change your code to: const char* err = strstr((const char *)ptr, "550"); if (err != NULL) { ... } Also, I'm assuming your comment reporting the error: //error cannot convert const char** to char* is a typo: there's no const char** to be seen. Assignment to err unnecessary As is pointed out in a previous answer, the use of err to store the result of strstr is unnecessary if all it's used for is checking NULL . Therefore you could use: if (strstr((const char *)ptr, "550") != NULL) { ... } Use of reinterpret_cast<> encouraged As is pointed out in another answer you should be using reinterpret_cast<> instead of C-style casts: if (strstr(reinterpret_cast (ptr), "550") != NULL) { ... } Use of const_cast<> to strip const Given the example in the question, I don't see where this is necessary, but if you had a variable that you need to strip of const -ness, you should use the const_cast<> operator. As in: const char * p1; char * p2; p2 = const_cast (p1); As is pointed out in a comment, the reason to use const_cast<> operator is so that the author's intention is clear, and also to make it easy to search for the use of const_cast<> ; usually stripping const is the source of bugs or a design flaw.
