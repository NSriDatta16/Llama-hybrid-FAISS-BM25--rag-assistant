[site]: stackoverflow
[post_id]: 4719048
[parent_id]: 4716014
[tags]: 
Two things to improve efficiency (though only one or the other will ever apply to a particular case like this): define a return type for your function, i.e., Public Function getFooF4() should be Public Function getFooF4() As Long (or whatever the appropriate data type is. Without an explicit data type, it's returning a variant. In reality, there is never a VBA function that should ever lack a return type declaration -- if it's returning a variant (which is perfectly reasonable, particularly when you need to return Null in some cases), define it with As Variant . When it's some other data type, explicitly define it. declare a parameter in your SQL so that the query optimizer can use that information in its calculation of the query plan. That doesn't apply when your WHERE clause is using a function to supply the criterion, but if you were using a reference to a field on a control, you'd replace this: . select foo.f1, foo.f2, foo.f3 from foo where foo.f4 = Forms!MyForm!MyControl ...with this: PARAMETERS [Forms]![MyForm]![MyControl] Long; select foo.f1, foo.f2, foo.f3 from foo where foo.f4 = Forms!MyForm!MyControl Now, in either of these cases, since the function/parameter is in the WHERE clause, it needs to be resolved only once, so even if the function is inefficient (as is the case here, with it initializing a database variable and opening a recordset), it won't actually make much difference. Another thing to consider is replacing the function with a simple DLookup(), which is designed for exactly this purpose. Alternatively, since the value is coming from a table, you should be able to JOIN it to your one-row table: select foo.f1, foo.f2, foo.f3 from foo INNER JOIN Bar ON foo.f4 = Bar.MyF4 This would be maximally optimizable by the query optimizer since there are no unknowns in it at all -- the query optimizer will know everything it needs to know about data types and table stats and can pick the most efficient retrieval method possible.
