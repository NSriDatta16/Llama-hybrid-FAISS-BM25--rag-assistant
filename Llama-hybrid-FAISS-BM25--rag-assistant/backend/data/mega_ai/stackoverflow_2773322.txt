[site]: stackoverflow
[post_id]: 2773322
[parent_id]: 2773245
[tags]: 
I would say that doing this: this = new B(); within the constructor for A would violate OO design principles, even it were possible to do (and it isn't). That being said, if I were faced with this scenario: the problem is that in my project, the super class A is already used too many times I would solve it in one of the two following ways: I have assumed that your condition is that you do not want too many objects of type A, otherwise feel free to substitute in any other condition. Option 1 : Use a factory design pattern. public class AFactory { private static count = 0; private static final MAX_COUNT = 100; public A newObject() { if (count And then somehwere else you generate the objects like so: A obj1 = factory.newObject(); A obj2 = factory.newObject(); Option 2 : Static counter + try&catch Use a static counter within your A class that keeps track of the number of times A has been instantiated, by incrementing the static variable by one in the constructor. If it hits a limit for the max number of object of type A, throw an InstantiationError in A's constructor. This would mean that whenever you instantiate A, you have to a try..catch block to intercept the InstantionError , and then create a new object of type B instead. public class A { private static count = 0; private static final MAX_COUNT = 100; public A() { if (count > 100) { throw new InstationError(); } } } And when generating your objects: A obj1, obj2; try { obj1 = new A(); } catch (InstantiationError ie) { obj1 = new B(); } try { obj2 = new A(); } catch (InstantiationError ie) { obj2 = new B(); } Option 2 is closest to what you ask directly in the question. However, I would personally choose to use the factory design pattern, because it is much more elegant solution, and it allows you to achieve what you want to do anyway.
