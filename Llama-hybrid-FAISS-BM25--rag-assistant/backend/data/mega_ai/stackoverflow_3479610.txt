[site]: stackoverflow
[post_id]: 3479610
[parent_id]: 3472020
[tags]: 
I finally solved my problem by using George Costanza's technique: doing the opposite. Instead of trying to make my operators new and delete visibles, I hid them completely. The trick is to set these in every static libs & in the bundle settings: Set C++ Standard Library Type : Static Symbols Hidden by Default: Checked Fix & Continue: Unchecked (very important otherwise silently disable previous setting) and do a clean all & build because with XCode 3.2 simply hitting Build after changing these settings won't work. Obviously, I changed the operator new & delete prototypes to: #pragma GCC visibility push(hidden) extern "C++" { void* operator new(std::size_t) throw (std::bad_alloc); void* operator new[](std::size_t) throw (std::bad_alloc); void operator delete(void*) throw(); void operator delete[](void*) throw(); void* operator new(std::size_t, const std::nothrow_t&) throw(); void* operator new[](std::size_t, const std::nothrow_t&) throw(); void operator delete(void*, const std::nothrow_t&) throw(); void operator delete[](void*, const std::nothrow_t&) throw(); } // extern "C++" #pragma GCC visibility pop No why does that work? Must have both Static + Hidden Symbols to work. It seems to shield my bundle plug-in from STL specializations implementations that inlined their allocators. Also note that this only happened in a bundle plug-in dynamically loaded from a big app. In a trivial .dylib project called from a console application everything worked fine with any settings.
