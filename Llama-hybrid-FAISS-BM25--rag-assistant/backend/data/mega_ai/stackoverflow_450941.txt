[site]: stackoverflow
[post_id]: 450941
[parent_id]: 450820
[tags]: 
Sounded like a fun test, so I gave it a shot. Probably not the most elegant, and not the most efficient either, but this should work: public class SortedContainer : IList where T : IComparable { private List internalList = new List (); public int IndexOf(T item) { return internalList.IndexOf(item); } public void Insert(int index, T item) { internalList.Insert(index, item); } public void RemoveAt(int index) { internalList.RemoveAt(index); } public T this[int index] { get { return internalList[index]; } set { internalList[index] = value; } } public void Add(T item) { internalList.Add(item); this.Sort(); } public void Clear() { internalList.Clear(); } public bool Contains(T item) { return internalList.Contains(item); } public void CopyTo(T[] array, int arrayIndex) { internalList.CopyTo(array, arrayIndex); } public int Count { get { return internalList.Count; } } public bool IsReadOnly { get { return false; } } public bool Remove(T item) { bool result = internalList.Remove(item); this.Sort(); return result; } public IEnumerator GetEnumerator() { return internalList.GetEnumerator(); } System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return internalList.GetEnumerator(); } private void Sort() { internalList.Sort(); } private List GetCopy() { return internalList.ToList(); } public int GetSortedIndex(T item) { List copy = GetCopy(); copy.Add(item); copy.Sort(); return copy.IndexOf(item); } } Basically, implement IList, and keep an internatl List. Every time the Add method is called, you call sort on the internal list. Then, when you want to get the sorted index without actually adding, it creates a copy of that list, inserts the item into the copy, then sorts the copy. It then returns the index of that item where it is in the copy. The internal list at this point has not been affected. I tested it and it works. Again, probably not the most efficient.
