[site]: stackoverflow
[post_id]: 4817748
[parent_id]: 4808008
[tags]: 
OK, so I'll start from the end. I would like to achieve this model. With this in place, you can run the query on the history table directly, no need for the view and join to the dbo.DATE_MASTER . select x.symbol , x.dseqkey , avg(y.volume) as moving_average from dbo.QP_HISTORY as x join dbo.QP_HISTORY as y on (x.dSeqKey between y.dSeqKey and (y.dSeqKey + 29)) and (y.symbol = x.symbol) where x.dseqkey >= 15000 group by x.symbol, x.dseqkey order by x.dseqkey desc OPTION (ORDER GROUP) ; The QP_HISTORY is narrower than the STOCK_HISTORY view, so the query should be faster. The "redundant column removal" from joins is scheduled for the next generation of SQL Server (Denali), so for the time being narrower usually means faster -- at least for large tables. Also, the join on .. and the where clause nicely match the the PK(Symbol, dSeqKey) . Now, how to achieve this: a) Modify the [date] column in dbo.DATE_MASTER to be if the type date instead of datetime . Rename it FullDate to avoid confusion. Not absolutely necessary, but to preserve my sanity. b) Add PK to the dbo.DATE_MASTER alter table dbo.DATE_MASTER add constraint primary key pk_datemstr (dSeqKey); c) In the table QP_HISTORY add column dSeqKey and populate it for matching QPDate dates. d) Drop the QPDate column from the table. e) Add PK and FK to the QP_HISTORY alter table dbo.QP_HISTORY add constraint pk_qphist primary key (Symbol, dSeqKey) , add constraint fk1_qphist foreign key (dSeqKey) references dbo.DATE_MASTER(dSeqKey) ; f) Drop all those indexes mentioned at the end ouf your question, at least for the time being. g) I do not see the size of the Symbol field. Define it as narrow as possible. h) Needles to say, implement and test this on a development system first.
