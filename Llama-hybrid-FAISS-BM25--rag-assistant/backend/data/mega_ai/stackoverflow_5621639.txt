[site]: stackoverflow
[post_id]: 5621639
[parent_id]: 
[tags]: 
StreamWriter and Samba2 (SMB2)

Ok guys, this one is a tough one. The scenario : I have multiple services running on multiple machines Each service has multiple threads, and each thread writes a file on a FILER - the shared storage used by my machines (using a share such as \\filername\foo\bar) The FILER machine is a NetApp machine Both the FILER and the machines running the services are using SMB2 (http://en.wikipedia.org/wiki/Server_Message_Block) The instruction used to write the file is as simple as the one listed below in [THE CODE] [THE CODE] using (StreamWriter outfile = new StreamWriter(pathToTheFile, false)) { outfile.Write(stringToWriteInTheFile); } [/THE CODE] The problem : Sometimes the service remains "stuck" on this instruction. The error given is: The process cannot access the file '\\filername\foo\bar\myfile.txt' because it is being used by another process. After some of these errors, the service refuses to release the lock on the file. What happens then? You can delete the file, but the file is IMMEDIATELY recreated. Like if a sort-of permanent Stream is alive and keeps writing the file indefinitely. You can stop the service: it's stuck, and won't be stopped, so I forced a Thread.Abort (yeah, I know but practice, but what else?) after 2 minutes. So, the service is now stopped, but the machine retains an handle to the file and you CANNOT kill the process keeping the handle alive except by rebooting the machine. . . I don't know what to do right now, I think I tried everything. Considerations : Previously, the FILER and the machines were using SMB1, and this problem never arised. So I guess something fishy happens in the background, but I can't understand what... I changed recently the code used to write the file, in a desperate attempt to "delegate" everything to .net. Now it's: File.WriteAllText(pathToTheFile, stringToWriteInTheFile); but my gut feeling is that, under the wraps, .net is doing the exact same thing - the change is quite recent though, so I can't still say if the "fix" is working or not. EDIT (as per Vash comment): Usually the file is different, but it can happen (and it actually happens) sometimes that multiple threads are trying to write the same file, however :( - doing the File.WriteAllText shouldn't take care of concurrency issues?
