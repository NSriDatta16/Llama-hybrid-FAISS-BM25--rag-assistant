[site]: stackoverflow
[post_id]: 1995242
[parent_id]: 1994239
[tags]: 
Since you can't change the UITableViewStyle of a UITableView once created (it can only be set at construction time), you have to have two different instances. You can do this in very different ways, but I've done it this way: add a UISegmentedControl to your interface, and set its target to the RootViewController class instance in your application. The RootViewController class could look like this: @class DataSource; @interface RootViewController : UITableViewController { @private UITableView *_originalTableView; UITableView *_secondaryTableView; DataSource *_dataSource; BOOL _showingSecondaryTableView; } - (IBAction)swap:(id)sender; @end And this might be the implementation: #import "RootViewController.h" #import "DataSource.h" @implementation RootViewController - (void)dealloc { [_dataSource release]; [_originalTableView release]; [_secondaryTableView release]; [super dealloc]; } - (void)viewDidLoad { [super viewDidLoad]; _dataSource = [[DataSource alloc] init]; _secondaryTableView = [[UITableView alloc] initWithFrame:self.tableView.frame style:UITableViewStyleGrouped]; _secondaryTableView.delegate = _dataSource; _secondaryTableView.dataSource = _dataSource; _originalTableView = [self.tableView retain]; _showingSecondaryTableView = NO; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; } #pragma mark - #pragma mark IBAction method - (IBAction)swap:(id)sender { if (_showingSecondaryTableView) { self.tableView = _originalTableView; _showingSecondaryTableView = NO; } else { self.tableView = _secondaryTableView; _showingSecondaryTableView = YES; } } #pragma mark - #pragma mark Table view methods - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return 5; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @"Cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease]; } cell.textLabel.text = [NSString stringWithFormat:@"RootViewController cell %d", indexPath.row]; return cell; } @end This is the interface of the DataSource class: #import @interface DataSource : NSObject { } @end And the implementation: #import "DataSource.h" @implementation DataSource #pragma mark - #pragma mark Table view methods - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 2; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return 3; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @"DataSourceCell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease]; } cell.textLabel.text = [NSString stringWithFormat:@"DataSource cell %d", indexPath.row]; return cell; } @end You can change the datasource and delegate of the UITableView instances to anything you want, at any time during runtime, which might help you encapsulate different data sources with separate controllers. Hope this helps!
