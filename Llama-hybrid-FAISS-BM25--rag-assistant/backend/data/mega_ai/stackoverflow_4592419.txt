[site]: stackoverflow
[post_id]: 4592419
[parent_id]: 4592149
[tags]: 
Cryptographic hashes are specifically designed with these properties: They are one-way functions. It is practically infeasible to recalculate a specific input for a given hash value, or even any random input that hashes to this value. Though there must be collisions because the input size if much larger than the fixed output size, it is also practically infeasible to find two different input values that result in the same hash value. The exactly same input value always hashes to exactly the same hash value. Any small change in the input results in a completely different hash value. Flipping any single input bit changes 50 percent on average of the output bits. Thus a cryptographic hash can and actually is used as a unique identifier for any binary data. Even "name: codebeaker" has a different hash than "name: Codebeaker". If your set of keys is fixed, in a fixed order, always complete and only extended by new keys, and each key only has one allowed representation, then you can calculate the hash of the five old keys and compare it to the existing hashes of the current sets. If the keys are always unique, but the sets can be mixed, then you can calculate a separate hash for each key and store and search these for the existing sets in a separate database. Beyond this, cryptographic hashes may not be the right tool for the job. [Edit] Another approach is to first alphabetically sort the keys and then take the hash value from the sorted set. This now identifies your set without needing to care for the order. It may be more practical to first take the individual hashes of the single keys, sort the hashes instead and take the hash over the list of sorted hashes. This still requires uniques keys.
