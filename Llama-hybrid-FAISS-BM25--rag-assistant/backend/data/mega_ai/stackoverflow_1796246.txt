[site]: stackoverflow
[post_id]: 1796246
[parent_id]: 1777717
[tags]: 
I think enough discussion has been generated to warrant yet another answer. Firstly, to answer the actual question, yes, it is absolutely appropriate (and even necessary!) to pass an argument by smart pointer when ownership transfer occurs. Passing by a smart pointer is a common idiom to accomplish that. void manage(std::auto_ptr t) { ... } ... // The reader of this code clearly sees ownership transfer. std::auto_ptr t(new T); manage(t); Now, there is a very good reason why all smart pointers have explicit constructors. Consider the following function (mentally replace std::auto_ptr with boost::shared_ptr if it tickles your fancy): void func(std::auto_ptr w, const Gizmo& g) { ... } If std::auto_ptr had an implicit constructor, suddenly this code would compile: func(new Widget(), gizmo); What's wrong with it? Taking almost directly from "Effective C++", Item 17: func(new Widget(), a_function_that_throws()); Because in C++ order of argument evaluation is undefined, you can very well have arguments evaluated in the following order: new Widget() , a_function_that_throws() , std::auto_ptr constructor. If a function throws, you have a leak. Therefore all resources that will be released need to be wrapped upon construction in RAII classes before being passed into a function. This means all smart pointer have to be constructed before passing them as an argument to a function. Making smart pointers be copy-constructible with a const reference or implicitly-constructible would encourage unsafe code. Explicit construction enforces safer code. Now, why shouldn't you do something like this? void manage(T *ptr) { std::auto_ptr autoPtr(ptr); vector.push_back(ptr); autoPtr.release(); } As already mentioned, the interface idioms tell me that I can pass a pointer that I own and I get to delete it. So, nothing stops me from doing this: T item; manage(&t); // or manage(&t_class_member); Which is disastrous, of course. But you'd say "of course I know what the interface means, I'd never use it that way". However you may want to add an extra argument to a function later. Or someone (not you, or you 3 years later) comes along this code, they may not see it the same way as you do. This hypothetical "someone else" may only see a header without a comment and (rightly) presume the lack of ownership transfer. They may see how this function is used in some other code and replicate the usage without looking at the header. They may use code auto-completion to invoke a function and not read the comment or the function and presume the lack of ownership transfer. They may write a function that wraps you manage function and yet someone else will use the wrapper function and will miss the documentation of the original function. They may try to "extend" you code so that all the old code compiles (and automatically becomes unsafe): void manage(T *t, const std::string tag = some_function_that_throws()); As you can see, explicit construction of a smart pointer makes it much harder to write unsafe code in the above cases. Therefore, I would not recommend going against decades of C++ expertise to make perceivably "nicer" and "fun" API. My 2c.
