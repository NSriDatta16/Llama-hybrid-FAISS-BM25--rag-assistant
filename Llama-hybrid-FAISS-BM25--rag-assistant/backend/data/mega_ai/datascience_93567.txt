[site]: datascience
[post_id]: 93567
[parent_id]: 93553
[tags]: 
Just tried your cnn_model function and it works correctly for me. Not sure about what your problem is, but it seems to be your X and Y. X must not have shape (2023, 65), but shape (datasize, 2023, 65). and Y should have shape (datasize, 1) as well. otherwise your network treats X as 2023 inputs of shape (None, 65) instead of treating it as n inputs of shape (None, 2023, 65). here is my code in case you wanna run it (important part is the definition of X(ims) and Y(lab) : import keras from keras.layers import Conv1D, Dropout, MaxPooling1D, Flatten, Dense import numpy as np ims = np.random.randn(100, 2023, 65) lab = np.random.randn(100, 1) def cnn_model(X, Y): model = keras.Sequential() model.add(Conv1D(filters=64, kernel_size=3, activation='relu')) model.add(Dropout(0.25)) model.add(Conv1D(filters=64, kernel_size=3, activation='relu')) model.add(Dropout(0.25)) model.add(MaxPooling1D(pool_size=2)) model.add(Flatten()) model.add(Dense(64, activation='relu')) model.add(Dense(1, activation='sigmoid')) model.compile(loss='mse', optimizer='adam', metrics=['mse', 'mae']) print('training') model.fit(X, Y, epochs=10, batch_size=32, verbose=0) print('finished training') model.evaluate(X, Y) return model m = cnn_model(ims, lab) m.summary()
