[site]: stackoverflow
[post_id]: 4881367
[parent_id]: 4880691
[tags]: 
Okay, I think I can provide my answer, which is perhaps more an opinion than a definitive "do this" (I don't have any formal training in programming). I think you agent_locations should be a member of each World instance. I try to think in terms of interface primarily. In my view, the World class should be responsible for managing the resources of your world, in this case space. Since World is the manager of space, Agents should ask their world if space is available (i.e. unoccupied), not each other. Therefore, I think your self.location_is_good call more appropriately would be self.world.is_location_available(x, y) [1] This makes it natural for the world to be responsible for looking up the availability of the given space. The World class might furthermore have other variables deciding whether a space is available. What if there's a shrubbery there? Or something. You probably already have some kind of table for your (x, y) coordinates on each world. Being "occupied" can be a property of those objects. Furthermore: Your World already knows the state of every agent (by [(agent.x, agent.y) for agent in self.agents] [2]). The agent_locations dict is essentially an index or cache for these properties, which therefore belongs to World . Regarding the pain of sending state back to the World ... well, you're not going to solve that by making Agent do it instead. But doing update_agent_location(self, agent, x, y) is completely superfluous, since x == agent.x; y == agent.y (if you reverse the lines where you call it). You could simply have one method in World, update_agent_state(self, agent) , which World can use to update its indices. You might even submit an extra param to describe the type of state change (if you don't want to update all the properties eveytime). class World(object): # ... def update_agent_state(self, agent, state_change=None): # Update properties based on what changed, or # drop state_change param and update everything everytime if state_change == Agent.LOCATION_CHANGE: self.agent_locations[agent.x, agent.y] = agent elif state_change == Agent.WHATEVER: pass class Agent(object): LOCATION_CHANGE = 1 def update(self): for x, y in self.valid_locations(): if not self.can_move_to(x, y) continue self.move(x, y) def can_move_to(self, x, y): """Determines if x, y is a location where we can move.""" if not self.world.is_location_available(x, y): return False if not self.has_money_to_travel_to(x, y): return False return True def move(self, x, y): """Moves to x, y and notifies world of state change.""" self.x = x self.y = y self.world.update_agent_state(self, Agent.LOCATION_CHANGE) Something like that (read my footnotes). [1] Unless, of course, "goodness" of a location depends upon other variables than if the space is free. E.g. if you should only move to (x, y) if 1) the location is available and 2) the agent has 1000 $ to pay for a ticket, then you should have a Agent.can_move_to(x, y) which in turn calls the world's method, and checks its wallet. [2] I'm assuming your self.agents = {} is a typo, since you can't append on a dict. You mean a list ( [] ) right?
