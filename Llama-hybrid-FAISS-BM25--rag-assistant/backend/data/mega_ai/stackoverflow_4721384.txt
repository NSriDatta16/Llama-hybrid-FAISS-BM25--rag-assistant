[site]: stackoverflow
[post_id]: 4721384
[parent_id]: 4720218
[tags]: 
An example, though it does cater for a tree structure, can be found here: http://www.bjmsoftware.com/delphistuff/virtualstringtreeexample.zip It's something I have been playing with to start some new base frames, so there may be stuff in there you do not need. The BaseTree_fr unit contains the VirtualStringTree stuff from an old project. The Tree_fm.pas unit contains my new effort. Tree_fm.pas doesn't yet include dynamically adding new nodes and deleting existing ones, but you can find that in the BaseTree_fr unit. To keep in the spirit of StackOverflow standing on its own two feet, I am including both units here. The new effort unit Tree_fm; interface uses Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, Dialogs, VirtualTrees, StdCtrls, DomainObject, DogBreed, ImgList; type RTreeData = record CDO: TCustomDomainObject; end; PTreeData = ^RTreeData; TForm1 = class(TForm) VirtualStringTree1: TVirtualStringTree; Button1: TButton; Button2: TButton; Button3: TButton; Button4: TButton; Button5: TButton; HeaderImages: TImageList; TreeImages: TImageList; StateImages: TImageList; procedure VirtualStringTree1Checked(Sender: TBaseVirtualTree; Node: PVirtualNode); procedure VirtualStringTree1CompareNodes(Sender: TBaseVirtualTree; Node1, Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer); procedure VirtualStringTree1DblClick(Sender: TObject); procedure VirtualStringTree1FocusChanged(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex); procedure VirtualStringTree1GetImageIndex(Sender: TBaseVirtualTree; Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex; var Ghosted: Boolean; var ImageIndex: Integer); procedure VirtualStringTree1GetText(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType; var CellText: string); procedure VirtualStringTree1InitChildren(Sender: TBaseVirtualTree; Node: PVirtualNode; var ChildCount: Cardinal); procedure VirtualStringTree1InitNode(Sender: TBaseVirtualTree; ParentNode, Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates); private FIsLoading: Boolean; FCDO: TCustomDomainObject; protected procedure BeginLoad; procedure EndLoad; procedure ClearFrame; procedure ClearHeaders; procedure ShowColumnHeaders; procedure ShowDomainObject(aCDO, aParent: TCustomDomainObject); procedure ShowDomainObjects(aCDO, aParent: TCustomDomainObject); procedure AddColumnHeaders(aColumns: TVirtualTreeColumns); virtual; function GetColumnText(aCDO: TCustomDomainObject; aColumn: TColumnIndex; var aCellText: string): Boolean; virtual; protected property CDO: TCustomDomainObject read FCDO write FCDO; public constructor Create(AOwner: TComponent); override; procedure Load(aCDO: TCustomDomainObject); end; var Form1: TForm1; implementation {$R *.dfm} procedure TForm1.AddColumnHeaders(aColumns: TVirtualTreeColumns); var Col: TVirtualTreeColumn; begin Col := aColumns.Add; Col.Text := 'Breed(Group)'; Col.Width := 200; Col := aColumns.Add; Col.Text := 'Average Age'; Col.Width := 100; Col.Alignment := taRightJustify; Col := aColumns.Add; Col.Text := 'CDO.Count'; Col.Width := 100; Col.Alignment := taRightJustify; end; procedure TForm1.BeginLoad; begin FIsLoading := True; VirtualStringTree1.BeginUpdate; end; procedure TForm1.ClearFrame; begin VirtualStringTree1.Clear; // FNodeList.Clear; // DoSelectionChanged(nil); end; procedure TForm1.ClearHeaders; begin VirtualStringTree1.Header.Columns.Clear; end; constructor TForm1.Create(AOwner: TComponent); begin inherited; VirtualStringTree1.DefaultText := ''; VirtualStringTree1.NodeDataSize := SizeOf(RTreeData); VirtualStringTree1.Header.Options := VirtualStringTree1.Header.Options //- [] + [hoDblClickResize, hoHotTrack, hoShowImages] ; VirtualStringTree1.Header.Style := hsXPStyle; VirtualStringTree1.TreeOptions.AnimationOptions := VirtualStringTree1.TreeOptions.AnimationOptions //- [] //+ [] ; VirtualStringTree1.TreeOptions.AutoOptions := VirtualStringTree1.TreeOptions.AutoOptions //- [] // toAutoSort is (was once?) causing heavy recursions and InitNode executions!!! // It isn't now, but it does cause the entire tree to be loaded! + [{toAutoSort,}{ toAutoHideButtons}] ; //VirtualStringTree1.TreeOptions.ExportMode := emChecked; VirtualStringTree1.TreeOptions.MiscOptions := VirtualStringTree1.TreeOptions.MiscOptions - [toInitOnSave] + [toCheckSupport] ; VirtualStringTree1.TreeOptions.PaintOptions := VirtualStringTree1.TreeOptions.PaintOptions - [toShowTreeLines] + [toHotTrack, toGhostedIfUnfocused, toUseExplorerTheme] ; VirtualStringTree1.TreeOptions.SelectionOptions := VirtualStringTree1.TreeOptions.SelectionOptions //- [] + [toExtendedFocus, toFullRowSelect, toMultiSelect] ; VirtualStringTree1.TreeOptions.StringOptions := VirtualStringTree1.TreeOptions.StringOptions //- [] //+ [] ; VirtualStringTree1.Header.Images := HeaderImages; VirtualStringTree1.CheckImageKind := ckXP; VirtualStringTree1.CustomCheckImages := nil; VirtualStringTree1.Images := TreeImages; VirtualStringTree1.StateImages := StateImages; //VirtualStringTree1.ClipboardFormats := ; //VirtualStringTree1.DragMode := dmAutomatic; VirtualStringTree1.DragOperations := []; end; procedure TForm1.EndLoad; begin VirtualStringTree1.EndUpdate; FIsLoading := False; end; function TForm1.GetColumnText(aCDO: TCustomDomainObject; aColumn: TColumnIndex; var aCellText: string): Boolean; begin if Assigned(aCDO) then begin case aColumn of -1, 0: begin aCellText := aCDO.DisplayString; end; 1: begin if aCDO.InheritsFrom(TDogBreed) then begin aCellText := IntToStr(TDogBreed(aCDO).AverageAge); end; end; 2: begin aCellText := IntToStr(aCDO.Count); end; else // aCellText := ''; end; Result := True; end else begin Result := False; end; end; procedure TForm1.Load(aCDO: TCustomDomainObject); begin // This would be in a more generic ancestor. BeginLoad; try if Assigned(CDO) then begin ClearHeaders; ClearFrame; end; CDO := aCDO; if Assigned(CDO) then begin ShowColumnHeaders; ShowDomainObjects(CDO, nil); end; finally EndLoad; end; end; procedure TForm1.ShowColumnHeaders; begin AddColumnHeaders(VirtualStringTree1.Header.Columns); if VirtualStringTree1.Header.Columns.Count > 0 then begin VirtualStringTree1.Header.Options := VirtualStringTree1.Header.Options + [hoVisible]; end; end; procedure TForm1.ShowDomainObject(aCDO, aParent: TCustomDomainObject); begin // We are dealing with a virtual tree that asks for its data, and so we don't // need to do anything here. end; procedure TForm1.ShowDomainObjects(aCDO, aParent: TCustomDomainObject); begin // We are dealing with a virtual tree that asks for its data, and so we only need // to set the number of nodes under the root. if Assigned(aCDO) then begin VirtualStringTree1.RootNodeCount := aCDO.Count; end else begin VirtualStringTree1.RootNodeCount := 0; end; end; procedure TForm1.VirtualStringTree1Checked(Sender: TBaseVirtualTree; Node: PVirtualNode); begin (* procedure TBaseTreeFrame.Frame_VstChecked(Sender: TBaseVirtualTree; Node: PVirtualNode); var ACDO: TCustomDomainObject; NodeData: ^RTreeData; begin inherited; NodeData := Sender.GetNodeData(Node); ACDO := NodeData.CDO; if ACDO <> nil then begin ACDO.Checked := (Node.CheckState in [csCheckedNormal, csCheckedPressed]); end; end; *) end; procedure TForm1.VirtualStringTree1CompareNodes(Sender: TBaseVirtualTree; Node1, Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer); begin beep; (* procedure TBaseTreeFrame.Frame_VstCompareNodes(Sender: TBaseVirtualTree; Node1, Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer); var Node1Data: ^RTreeData; Node2Data: ^RTreeData; Node1CDO: TCustomDomainObject; Node2CDO: TCustomDomainObject; begin inherited; Node1Data := Frame_Vst.GetNodeData(Node1); Node2Data := Frame_Vst.GetNodeData(Node2); Node1CDO := Node1Data.CDO; Node2CDO := Node2Data.CDO; // if (Node1CDO = nil) or (Node2CDO = nil) then begin Result := 0; end else if (Node1CDO is TDomainObjectList) <> (Node2CDO is TDomainObjectList) then begin if Node1CDO is TDomainObjectList then begin Result := -1; end else begin Result := 1; end; end else begin Result := AnsiCompareText(Node1CDO.SortString, Node2CDO.SortString); end; end; *) end; procedure TForm1.VirtualStringTree1DblClick(Sender: TObject); begin (* procedure TBaseTreeFrame.Frame_VstDblClick(Sender: TObject); var ACDO: TCustomDomainObject; NodeData: ^RTreeData; Tree: TBaseVirtualTree; begin inherited; if Sender is TBaseVirtualTree then begin Tree := TBaseVirtualTree(Sender); if Tree.FocusedNode <> nil then begin NodeData := Tree.GetNodeData(Tree.FocusedNode); ACDO := NodeData.CDO; HandleDoubleClicked(ACDO); end; end; end; procedure TBaseTreeFrame.HandleDoubleClicked(ACDO: TCustomDomainObject); begin DoDoubleClicked(ACDO); end; procedure TBaseTreeFrame.DoDoubleClicked(ACDO: TCustomDomainObject); begin if assigned(FOnDoubleClicked) then begin FOnDoubleClicked(ACDO); end; end; *) end; procedure TForm1.VirtualStringTree1FocusChanged(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex); begin (* procedure TBaseTreeFrame.Frame_VstFocusChanged(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex); var ACDO: TCustomDomainObject; NodeData: ^RTreeData; begin inherited; NodeData := Sender.GetNodeData(Node); ACDO := NodeData.CDO; HandleSelectionChanged(ACDO); end; procedure TBaseTreeFrame.HandleSelectionChanged(ACDO: TCustomDomainObject); begin DoSelectionChanged(ACDO); end; procedure TBaseTreeFrame.DoSelectionChanged(ACDO: TCustomDomainObject); begin if assigned(FOnSelectionChanged) then begin FOnSelectionChanged(ACDO); end; end; *) end; procedure TForm1.VirtualStringTree1GetImageIndex(Sender: TBaseVirtualTree; Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex; var Ghosted: Boolean; var ImageIndex: Integer); begin (* procedure TBaseTreeFrame.Frame_VstGetImageIndex(Sender: TBaseVirtualTree; Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex; var Ghosted: Boolean; var ImageIndex: Integer); var ACDO: TCustomDomainObject; NodeData: ^RTreeData; begin inherited; Case Column of -1, 0 : begin NodeData := Sender.GetNodeData(Node); ACDO := NodeData.CDO; case Kind of ikState: ImageIndex := -1; ikNormal: ImageIndex := GetImageIndexFor(ACDO, false); ikSelected: ImageIndex := GetImageIndexFor(ACDO, true); ikOverlay: ImageIndex := -1; else ImageIndex := -1; end; end; else end; *) end; procedure TForm1.VirtualStringTree1GetText(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType; var CellText: string); var NodeData: ^RTreeData; begin NodeData := Sender.GetNodeData(Node); if GetColumnText(NodeData.CDO, Column, {var}CellText) then else begin if Assigned(NodeData.CDO) then begin case Column of -1, 0: CellText := NodeData.CDO.DisplayString; end; end; end; end; procedure TForm1.VirtualStringTree1InitChildren(Sender: TBaseVirtualTree; Node: PVirtualNode; var ChildCount: Cardinal); var NodeData: ^RTreeData; begin // This is called when user has clicked on a plus sign. // We only need to tell the tree for how many children to prepare. ChildCount := 0; NodeData := Sender.GetNodeData(Node); if Assigned(NodeData.CDO) then begin ChildCount := NodeData.CDO.Count; end; end; procedure TForm1.VirtualStringTree1InitNode(Sender: TBaseVirtualTree; ParentNode, Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates); var ParentNodeData: ^RTreeData; ParentNodeCDO: TCustomDomainObject; NodeData: ^RTreeData; begin if Assigned(ParentNode) then begin ParentNodeData := VirtualStringTree1.GetNodeData(ParentNode); ParentNodeCDO := ParentNodeData.CDO; end else begin ParentNodeCDO := CDO; end; NodeData := VirtualStringTree1.GetNodeData(Node); if Assigned(NodeData.CDO) then begin // CDO was already set, for example when added through AddDomainObject. end else begin if Assigned(ParentNodeCDO) then begin if ParentNodeCDO.Count > Node.Index then begin NodeData.CDO := ParentNodeCDO.CDO[Node.Index]; if NodeData.CDO.Count > 0 then begin InitialStates := InitialStates + [ivsHasChildren]; end; // FNodeList.Add(NodeData.CDO, Node); end; end; end; Sender.CheckState[Node] := csUncheckedNormal; end; end. And the old one Check in second answer, I exceeded the text character limit...
