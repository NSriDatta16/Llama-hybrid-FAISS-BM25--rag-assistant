[site]: stackoverflow
[post_id]: 4226275
[parent_id]: 4224544
[tags]: 
With Blaise Doughan 's help here is the final solution that I settled on. This includes some extra demonstration code to help others who may find themselves in this situation. The classes ProductList (a new wrapping class to show how this works for multiple Product entries) import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlElementWrapper; import javax.xml.bind.annotation.XmlRootElement; import java.util.ArrayList; import java.util.List; @XmlRootElement(name="ProductList") public class ProductList { @XmlElementWrapper(name="Products") @XmlElement(name="Product") public List products = new ArrayList (); } Product (with Blaise's modifications) import org.w3c.dom.Node; import javax.xml.bind.annotation.*; @XmlRootElement(name="Product") @XmlAccessorType(XmlAccessType.FIELD) public class Product { @XmlElement(name="CommonProperty") public String commonProperty="Something"; @XmlAnyElement public Node extraXml; } Main (some demonstration code) import org.w3c.dom.Document; import org.xml.sax.InputSource; import javax.xml.bind.JAXBContext; import javax.xml.bind.Marshaller; import javax.xml.parsers.DocumentBuilderFactory; import java.io.StringReader; public class Main { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // Build some arbitrary extra XML and prepare an InputStream String fragment1 = " Some extra 1 "; String fragment2 = " Some extra 2 "; Document document1 = factory.newDocumentBuilder().parse(new InputSource(new StringReader(fragment1))); Document document2 = factory.newDocumentBuilder().parse(new InputSource(new StringReader(fragment2))); Product product1 = new Product(); product1.commonProperty = "Hello 1"; product1.extraXml=document1.getFirstChild(); Product product2 = new Product(); product2.commonProperty = "Hello 2"; product2.extraXml=document2.getFirstChild(); ProductList productList = new ProductList(); productList.products.add(product1); productList.products.add(product2); JAXBContext jc = JAXBContext.newInstance(ProductList.class, Product.class); Marshaller marshaller = jc.createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); marshaller.marshal(productList, System.out); } } The final output: Hello 1 Some extra 1 Hello 2 Some extra 2 Result! But it doesn't work in JBoss... If you try the above in JBoss 4.2.3.GA or 4.3 you may find that you get an class com.sun.org.apache.xerces.internal.dom.DocumentFragmentImpl nor any of its super class is known to this context. exception being reported. This is (probably) due to the xercesImpl.jar in the JBoss lib and /lib/endorsed folders using the Java META-INF/Services override facility to prevent the JDK from marshalling using internal classes. You may need to specify an alternative DocumentBuilderFactory directly using the following approach: DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance("oracle.xml.jaxp.JXDocumentBuilderFactory", this .getClass().getClassLoader()); The Oracle implementation seems to alleviate these issues, perhaps because it keeps awareness of the DOM Node classes within the JAXB context. These classes are found in the xdb.jar and xmlparserv2.jar shipped with the Oracle client. Hope it helps.
