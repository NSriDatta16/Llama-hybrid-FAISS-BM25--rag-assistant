[site]: stackoverflow
[post_id]: 1781740
[parent_id]: 1776641
[tags]: 
It's actually extremely simple. First of all, take a look at Boost.Iterator library. Second: you need to declare a base class (it's well explained in the example how to proceed) that will be similar to this one. template class BaseIterator: boost::iterator_adaptor {}; You implement the operations to move your pointer around there. Note that because it's an adaptation over an already existing iterator, you can implement it with only a few strokes. It's really impressive. Third, you simply typedef it with the const and non-const versions: typedef BaseIterator iterator; typedef BaseIterator const_iterator; The library explictly show you how to make the const_iterator version be constructible from the iterator version. Fourth, for the reverse thing, there is a special reverse_iterator object, that is built on a regular iterator and move backwards :) All in all, a really elegant and yet fully functional way of defining iterators on custom classes. I regularly write my own container adaptors, and it's less about DRY than simply saving myself some typing!
