[site]: stackoverflow
[post_id]: 3612112
[parent_id]: 3611936
[tags]: 
FWIW, the command-line client for SQLite has a data-loading builtin command. But if you read the C code of that SQLite client, you'd see it doesn't do anything special. It just reads your data file line by line and executes INSERT in a loop. Other answers have suggested using explicit transactions so you can avoid overhead of I/O flushing after each row. I agree with that advice, it will certainly have a huge benefit. You can also disable the rollback journal : PRAGMA journal_mode = OFF Or set writes to asynchronous , allowing the operating system to buffer I/O: PRAGMA synchronous = OFF These pragma changes should save significant I/O overhead. But without a rollback journal, the ROLLBACK command won't work, and if your application crashes during an in-progress transaction, your database might be corrupted. Without synchronous writes, an operating system failure could also result in lost data. Not trying to scare you, but you should know that there is a tradeoff between performance and guaranteed I/O integrity. I recommend operating with safety modes enabled most of the time, and disable them only briefly when you need to do a big data load like you're doing -- then remember to re-enable the safety modes!
