[site]: stackoverflow
[post_id]: 2628592
[parent_id]: 2628339
[tags]: 
type TIndentifier = class private FOldValue: string; FNewValue: string; FStoredValue: string; public constructor Create(const OldValue, NewValue, StoredValue: string); property OldValue: string read FOldValue write FOldValue; property NewValue: string read FNewValue write FNewValue; property StoredValue: string read FStoredValue write FStoredValue; end; This is your base class. You use it for each value. Then you have two options. You can just do it like this: var Values: TStringList; begin Values.AddObject('SomeValue', TIndentifier.Create('OldValue', 'NewValue', 'StoredValue')); This reminds me how similar to a swiss knife is TStringList :). Watch out to free the objects in older versions of delphi, or set the TStringList as the owner of objects in latest versions. Or you can have an list of objects if you need more than just name: type TValue = class(TIndentifier) private FName: string; public property Name: string read FName write FName; end; var Value: TValue; Values: TObjectList; begin Value := TValue.Create('OldValue', 'NewValue', 'StoredValue'); Value.Name := 'SomeValue'; Values.Add(Value); But what I really like in such cases is the power of XML. It saves so much code, but hides the declarations on the other hand. With my SimpleStorage you could do something like this: var Value: IElement; Storage: ISimpleStorage: begin Storage := CreateStorage; Value := Storage.Ensure(['Values', 'SomeValue']); Value.Ensure('OldValue').AsString := 'OldValue'; Value.Ensure('NewValue').AsString := 'NewValue'; Value.Ensure('StoredValue').AsString := 'StoredValue';
