[site]: stackoverflow
[post_id]: 1073276
[parent_id]: 1064495
[tags]: 
There are many things wrong with your code. I'll try to go through them. First, its better to use a different ivar name to your property name so its clear where you are using each. Apple normally uses an underscore prefix, but any prefix will do. @interface Entry : NSObject { id _object; SEL _function; } @property (retain) id object; @property (assign) SEL function; @synthesize object = _object; @synthesize function = _function; Next, you aren't using the standard init template (although this probably wont make any difference normally). -(Entry*) initWithObject:(id)obj selector:(SEL)sel { self = [super init]; if (self != nil) { // initializations } return self; } Next, Apple (for good reasons) recommends against using getters/setters in your init/dealloc. So your init would be: -(Entry*) initWithObject:(id)obj selector:(SEL)sel { self = [super init]; if (self != nil) { _object = [obj retain]; _object = sel; } return self; } Next, after [super dealloc] your object is destroyed, so you cannot reference self (and hence your ivars) after that, so your dealloc should look like: -(void) dealloc { // your deallocations [super dealloc]; } Further, as above, Apple recommends you should not use setters or getters in your dealloc routine, so your deallocation would initially look like: if (_object != nil) [_object release]; But further still, Objective C allows (and Cocoa encourages) that sending a method to nil does nothing. This is in stark contast to most other languages where messaging nil would cause a crash, but it is how Objective C/Cocoa work and you need to get used to it. So your deallocation is actually just: [_object release]; And finally, alloc only allocates the memory for your object, you have to initialize it, so the initialization would be something like: Entry *hej = [[Entry alloc] initWithObject:myobj selector:@selector(mymethod)];
