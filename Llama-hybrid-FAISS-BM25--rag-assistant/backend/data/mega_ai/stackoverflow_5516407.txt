[site]: stackoverflow
[post_id]: 5516407
[parent_id]: 5508922
[tags]: 
The typical way to yield a predictable (if not constant) frame rate (with video or 3D graphics) is described in the following pseudo-code. Algorithm Prepare the next frame (render in back-buffer); Sleep for the remainder of the time slice; Ask the frame to be displayed (swap front and back buffers). Note the position of the sleep operation. It's sandwiched between the preparation and display of the same frame. This is the principal key to a constant frame rate! You want the preparation of the frame to count in the total time slice for displaying the frame . There are a number of variants on how to implement each of these steps (choice of sleep operation based on it's resolution, reliability, etc.), but the core is there. Tips for extra reliability Don't invoke your sleep function once for the entire interval. Define some constant with the maximum error you're ready to accept and repeatedly sleep for periods of this interval until the time remaining is smaller or equal to this amount. Don't be scared to occasionally drop a frame when you know you won't be able to prepare the next frame in time. It's visually more appealing to skip a frame than it is to produce a variable frame rate. If you can avoid background threads on a single-processor system, avoid them. Using worker threads will really mess up the reliability of your sleep function. The best approach is to split your background work into small chunks and have this work executed instead of sleeping. The 1st is easy to implement and can be hidden away in a helper function. The 2nd is a little more touchy as it requires you to keep statistics of average rendering speed, among other things. The 3rd is hard to implement as it's often difficult to predict how much time different tasks will take. It's only usually implemented in real-time systems with hard constraints.
