[site]: stackoverflow
[post_id]: 306284
[parent_id]: 
[tags]: 
Haskell Typeclass shorthand

So, I have a pair of typeclasses that I'll be using a lot together, and I want to avoid specifying both each time. Basically, instead of putting :: (Ord a, Fractional a, Ord b, Fractional b, ... Ord z, Fractional z) => at the beginning of all my type specifications, I'd rather put :: (OrdFractional a, OrdFractional b, ... OrdFractional z) So, my initial idea on how to do this was to just declare a new typeclass module Example where class (Fractional a, Ord a) => OrdFractional a example :: (OrdFractional a, OrdFractional b) => (a,b) -> (a,b) -> (a,b) -> Bool example (x1,y1) (x2,y2) (x3,y3) = (x1/x2 But this didn't work as automagically as I wished it would: % ghci Prelude> :l Example.hs Ok, modules loaded: Example. Prelude Example> example (1::Float,3::Float) (2,2) (3,1) :1:0: No instance for (OrdFractional Float) arising from a use of `example' at :1:0-39 Possible fix: add an instance declaration for (OrdFractional Float) In the expression: example (1 :: Float, 3 :: Float) (2, 2) (3, 1) In the definition of `it': it = example (1 :: Float, 3 :: Float) (2, 2) (3, 1) Manually creating instances seems like a drag so, next, I thought I might try to automatically create instances: module Example where class OrdFractional a instance (Fractional a, Ord a) => OrdFractional a example :: (OrdFractional a, OrdFractional b) => (a,b) -> (a,b) -> (a,b) -> Bool example (x1,y1) (x2,y2) (x3,y3) = (x1/x2 But the compiler didn't like that: ghc -c Example.hs Example.hs:4:0: Illegal instance declaration for `OrdFractional a' (All instance types must be of the form (T a1 ... an) where a1 ... an are type *variables*, and each type variable appears at most once in the instance head. Use -XFlexibleInstances if you want to disable this.) In the instance declaration for `OrdFractional a' So is there a way I can do this?
