[site]: stackoverflow
[post_id]: 5064571
[parent_id]: 5064443
[tags]: 
Because arrays are not pointers. They may decay into pointers under certain circumstances (such as passing to a function, as you can see in your code) but, while they remain an array, you cannot increment them. What you can do it create a pointer from the array such as by changing: foo(a); to: foo(&(a[1])); which will pass an explicit pointer to the second character instead of an implicit pointer to the first character that happens with foo(a); . Section 6.3.2.1 of C99 ("Lvalues, arrays, and function designators"), paragraph 3 has the definitive reason why you can't do what you're trying to do: Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type "array of type" is converted to an expression with type "pointer to type" that points to the initial element of the array object and is not an lvalue. It's that "not an lvalue" that's stopping you. You cannot change it if it's not an lvalue (so named because they typically appear on the left of assignment statements). The reason you can do in your first function is because of section 6.7.5.3 ("Function declarators"), paragraph 7: A declaration of a parameter as "array of type" shall be adjusted to "qualified pointer to type" In other words, the parameter in the function is an lvalue pointer, which can be changed.
