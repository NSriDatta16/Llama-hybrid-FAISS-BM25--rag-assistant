[site]: stackoverflow
[post_id]: 2985895
[parent_id]: 2985758
[tags]: 
Dependency Injection's primary advantage is testing. And you've hit on something that seemed odd to me when I first started adopting Test Driven Development and DI. DI does break encapsulation. Unit tests should test implementation related decisions; as such, you end up exposing details that you wouldn't in a purely encapsulated scenario. Your example is a good one, where if you weren't doing test driven development, you would probably want to encapsulate the data context. But where you say, Since the OrderRepository by necessity is dependent on a specific Linq to Sql DataContext , I would disagree - we have the same setup and are only dependent on an interface. You have to break that dependency. Taking your example a step further however, how will you test your repository (or clients of it) without exercising the database? This is one of the core tenets of unit testing - you have to be able to test functionality without interacting with external systems. And nowhere does this matter more than with the database. Dependency Injection is the pattern that makes it possible to break dependencies on sub-systems and layers . Without it, unit tests end up requiring extensive fixture setup, become hard to write, fragile and too damn slow. As a result - you just won't write them. Taking your example a step farther, you might have In Unit Tests: // From your example... new OrdersRepository(new InMemoryDataContext()); // or... IOrdersRepository repo = new InMemoryDataContext().OrdersRepository; and In Production (using an IOC container): // usually... Container.Create ().OrdersRepository // but can be... Container.Create (); (If you haven't used an IOC container, they're the glue that makes DI work. Think of it as "make" (or ant) for object graphs...the container builds the dependency graph for you and does all of the heavy lifting for construction). In using an IOC container, you get back the dependency hiding that you mention in your OP. Dependencies are configured and handled by the container as a separate concern - and calling code can just ask for an instance of the interface. There's a really excellent book that explores these issues in detail. Check out xUnit Test Patterns: Refactoring Test Code , by Mezaros. It's one of those books that takes your software development capabilities to the next level.
