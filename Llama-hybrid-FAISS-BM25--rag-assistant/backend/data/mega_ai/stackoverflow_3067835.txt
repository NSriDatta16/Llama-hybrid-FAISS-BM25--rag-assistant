[site]: stackoverflow
[post_id]: 3067835
[parent_id]: 3067729
[tags]: 
Designs Patterns are intended to encompass a broad variety of problem-solving tasks. So in the abstract you need to have a way to represent a variety of work being done, and a way to match a design pattern against that work. Doing this in general is "AI-hard". A specific representation of "work being done" is obviously computer source code. Now the design pattern matching problem is one of matching against a set of code fragments that exhibit the problem of interest, and applying the "pattern" (e.g., solution) as a set of steps that modify the source code to achieve the desired result. A tool that can express such patterns and effect automated source code changes is a Program Transformation engine. What you typically do with suc an engine is to collect a large set of design patterns together, instantiate them as sets of source-to-source rewrite rules, and then hand a chunk of code to the transformation engine so that it can do the pattern-match/replacement step. The hardest work, of course, is coding the design patterns as transformation rules, since most design patterns are written in prose and tend to be bit fuzzy about precise details. (The program transformation engine is very hard to build, but those are arguably already done :) Program transformation engines have been used to implement refactorings (a well-known class of design patterns), language translations (massive "design pattern application"), and code restructurings such as reshaping APIs to meet new needs (one specific example I have done is automating the conversion of C++ code APIs to CORBA-compliancy).
