[site]: stackoverflow
[post_id]: 3474642
[parent_id]: 3292686
[tags]: 
I have a workaround which can be helpful in a case like this. I guess we always be able to check how our module was been started. In this case we should check first argument. I will write code because I have some problem with English. Here two ways: The first case . we can compare module name with first command line argument. something like this: const TCHAR* csCommandLine = ::GetCommandLine(); // Attention!!! the first symbol can be quete if (*csCommandLine == _T('\"')) csCommandLine++; TCHAR sModuleFileName[MAX_PATH]; DWORD dwModuleFileName = ::GetModuleFileName(NULL, sModuleFileName, MAX_PATH); if (dwModuleFileName && !_tcsncmp(csCommandLine, sModuleFileName, dwModuleFileName)) { // The command line contains the module name. } The second case . we can try to get file attributes for the first command line argument something like this: // Attention!!! don't use it case if you are going to pass a file path in command line arguments. int nArgc; LPTSTR* szArglist = ::CommandLineToArgvW(::GetCommandLine(), &nArgc); if (nArgc && ::GetFileAttributes(szArglist[0]) != INVALID_FILE_ATTRIBUTES) { // The command line contains the module name. } ::LocalFree(szArglist); I hope it can be helpful someone. Regards, Vladimir
