[site]: stackoverflow
[post_id]: 4161811
[parent_id]: 4161001
[tags]: 
An unconventional approach using Perl is below. #! /usr/bin/perl use warnings; use strict; my $graph = q{ a + c b + c c - f b - d a + b f + g g + h f + h }; my $nodes = join ",", sort keys %{ { map +($_ => 1), $graph =~ /(\w+)/g } }; my $search = "$nodes:$nodes:$nodes:$graph"; my $subgraph = qr/ \A .*? (? \w+) .*: .*? (? \w+) .*: .*? (? \w+) .*: (?= .*^\s* \k \s* \+ \s* \k \s*$) (?= .*^\s* \k \s* \+ \s* \k \s*$) (?= .*^\s* \k \s* \+ \s* \k \s*$) (?{ print "x=$+{x}, y=$+{y}, z=$+{z}\n" }) (?!) /smx; $search =~ /$subgraph/; The regex engine is a powerful tool . For your problem, we describe the structure of a transitive subgraph and then allow the resulting machine to go find all of them. Output: x=a, y=b, z=c x=f, y=g, z=h A more general tool using this same technique is possible. For example, let's say you want to be able to specify gene patterns such as a+b+c;a+c or g1+g2-g3;g1+g3 . I hope the meanings of these patterns are obvious. In the front matter, I specify a minimum version of 5.10.0 because the code uses // and lexical $_ . The code constructs dynamic regexes that will evaluate code, which the use re 'eval' pragma enables. #! /usr/bin/perl use warnings; use strict; use 5.10.0; use re 'eval'; An identifier is a sequence of one or more “word characters,” i.e. , letters, digits, or underscores. my $ID = qr/\w+/; Given a regex that accepts variable names, unique_vars searches some specification for all variable names and returns them without repetition. sub unique_vars { my($_,$pattern) = @_; keys %{ { map +($_ => undef), /($pattern)/g } }; } Compiling a gene pattern into a regex is a little hairy. It dynamically generates a search target and regex with the same form as the static one above. The first part with multiple occurrences of comma-separated variables lets the regex engine try each possible value for each gene. Then the lookaheads, (?=...) , scan the graph looking for edges with the desired properties. If all the lookaheads succeed, we record the hit. The strange regex (?!) at the end is an unconditional failure that forces the matcher to backtrack and attempt the match with different genes. Because it's unconditional, the engine will evaluate all possibilities. Calling the same closure from multiple threads concurrently will likely produce strange results. sub compile_gene_pattern { my($dataset,$pattern) = @_; my @vars = sort +unique_vars $pattern, qr/[a-z]\d*/; # / for SO hilite my $nodes = join ",", sort +unique_vars $dataset, $ID; my $search = join("", map "$_:", ($nodes) x @vars) . "\n" . $dataset; my $spec = '\A' . "\n" . join("", map ".*? (? $ID) .*:\n", @vars); for (split /;/, $pattern) { while (s/^($ID)([-+])($ID)/$3/) { $spec .= '(?= .*^\s* ' . ' \b\k \b ' . ' \s*' . quotemeta($2) . '\s* ' . ' \b\k \b ' . ' \s*$)' . "\n"; } } my %hits; $spec .= '(?{ ++$hits{join "-", @+{@vars}} })' . "\n" . '(?!) # backtrack' . "\n"; my $nfa = eval { qr/$spec/smx } || die "$0: INTERNAL: bad regex:\n$@"; sub { %hits = (); # thread-safety? :-( (my $_ = $search) =~ /$nfa/; map [split /-/], sort keys %hits; } } Read the dataset and let the user know about any problems. sub read_dataset { my($path) = @_; open my $fh, " ) { next if /^\s*#/ || /^\s*$/; if (/^ \s* $ID \s* [-+] \s* $ID \s* $/x) { $graph .= $_; } else { push @errors, "$.: syntax error"; } } return $graph unless @errors; die map "$0: $path:$_\n", @errors; } Now we set it all into motion: my $graphs = shift // "graphs.txt"; my $dataset = read_dataset $graphs; my $ppp = compile_gene_pattern $dataset, "a+b+c;a+c"; print "@$_\n" for $ppp->(); my $pmp = compile_gene_pattern $dataset, "g1+g2-g3;g1+g3"; print "@$_\n" for $pmp->(); Given graphs.txt with contents a + b b + c c - f b - d a + c f + g g + h f + h foo + bar bar - baz foo + baz and then running the program, we get the following output: a b c f g h foo bar baz
