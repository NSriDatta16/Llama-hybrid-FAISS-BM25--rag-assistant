[site]: stackoverflow
[post_id]: 5533048
[parent_id]: 
[tags]: 
Why isn't my pathtracing code working?

I've been hacking together a pathtracer in pure Python, just for fun, and since my previous shading-thing wasn't too pretty ( Lambert's cosine law ), I'm trying to implement recursive pathtracing. My engine gives an abortive output: My pathtracing function is defined recursively, like this: def TracePath2(ray, scene, bounce_count): result = 100000.0 hit = False answer = Color(0.0, 0.0, 0.0) for object in scene.objects: test = object.intersection(ray) if test and test And my scene (I made a custom XML description format) is this: I'm pretty sure that there's some fundamental flaw in my engine, but I just can't find it... Here's my new-ish tracing function: def Trace(ray, scene, n): if n > 10: # Max raydepth of 10. In my scene, the max should be around 4, since there are only a few objects to bounce off, but I agree, there should be a cap. return Color(0.0, 0.0, 0.0) result = 1000000.0 # It's close to infinity... hit = False for object in scene.objects: test = object.intersection(ray) if test and test 0.0: point = ray.origin + ray.direction * (result + 0.0000001) # We're going inside an object (for use when tracing glass), so move a tad bit inside to prevent floating-point errors. else: point = ray.origin + ray.direction * (result - 0.0000001) # We're bouncing off. Move away from surface a little bit for same reason. newray = Ray(point, direction) return Trace(newray, scene, n + 1) * hit.diffuse + Color(hit.emittance, hit.emittance, hit.emittance) # Haven't implemented colored lights, so it's a shade of gray for now. I'm pretty sure that the pathtracing code works, as I manually casted some rays and got pretty legitimate results. The problem I'm having (now) is that the camera doesn't shoot rays through all the pixels in the image plane. I made this code to find the ray intersecting a pixel, but it's not working properly: origin = scene.camera.pos # + 0.5 because it # # puts the ray in the # This calculates the width of one "unit" # *middle* of the pixel # worldX = scene.camera.focalplane.width - (x + 0.5) * (2 * scene.camera.focalplane.width / scene.camera.focalplane.canvasWidth) worldY = scene.camera.pos.y - scene.camera.focalplane.offset # Offset of the imaging plane is know, and it's normal to the camera's direction (directly along the Y-axis in this case). worldZ = scene.camera.focalplane.height - (y + 0.5) * (2 * scene.camera.focalplane.height / scene.camera.focalplane.canvasHeight) ray = Ray(origin, (scene.camera.pos + Point(worldX, worldY, worldZ)).norm())
