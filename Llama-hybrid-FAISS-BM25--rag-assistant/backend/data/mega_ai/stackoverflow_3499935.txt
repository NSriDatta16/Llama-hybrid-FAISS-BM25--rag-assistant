[site]: stackoverflow
[post_id]: 3499935
[parent_id]: 3457900
[tags]: 
I almost found a suitable solution (it is not like a normal scrolling but...). First I determine the mamimum and minimum amount of pixels in the content area of the table view on the Y axis ( the height of the contentSize when the view has been fully loaded ). The I check the movement done incrementally but not referencing the position of the touch in the table view! I have to check it on a top layered UIView that covers it, because when you alter the content offset of the table you change dynamically its dimensions and you can end you having an acceleration effect . Here is some code: - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{ UITouch * touch = [touches anyObject]; CGPoint tPoint = [touch locationInView:[viewController draggableAreaView]]; CGRect rc = [self bounds]; float totalOS = tPoint.y - previousYPan; if ((contentOffSetY >= minY && contentOffSetY maxY + 5 && totalOS > 0)) { if (totalOS > 0) totalOS += OFFSET; else if (totalOS maxY) { [self setContentOffset:CGPointMake(rc.origin.x, maxY - 50)animated:YES]; } } Some more tips: here draggableAreaView is the top UIView from which I get an "absolute" position OFFSET is a constant defined to increment linearly the speed of the scroolling (without it the touchesMoved: , called many times, gives a relative movement of just one pixel each time) , minY and maxY are the precalculated limit values (in order to compute them I calculated the height of all the cells in the table for max and the height of the visible content view for min) I added some displacement to minY and maxY in order to have a more visible animation
