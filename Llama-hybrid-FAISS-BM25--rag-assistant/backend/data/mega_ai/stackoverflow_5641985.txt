[site]: stackoverflow
[post_id]: 5641985
[parent_id]: 5641709
[tags]: 
First of all there are no relations and joins in mongodb. All 'relations' are logical, but it not real relation like in sql database. In test above you storing person twice: first person goes into persons collection, second i guess goes into nested collection of persons within group. You just duplicated person. So, they are not related. And if person was updated in persons collection it does not mean that he will magically updated in nested collection of persons within group collection. This is the reason why your test fails. Usual one to many relation in mongodb good fit for embedding. Update: I guess you have documents like this: public class Person { public Person() { Id = ObjectId.GenerateNewId().ToString(); } [BsonId] public string Id { get; set; } public string Name { get; set; } } public class Group { public Group() { Id = ObjectId.GenerateNewId().ToString(); persons = new List (); } [BsonId] public string Id { get; set; } public string Description { get; set; } public List persons { get; set; } public void Add(Person p) { persons.Add(p); } } Also i a little modified your test to get it work: var database = _mongoServer.GetDatabase("StackoverflowExamples"); var p = new Person() { Name = "Testperson" }; var persons = database.GetCollection ("Persons"); persons.Save (p); var group = new Group() { Description = "A fancy descriptor" }; group.Add(p); var groups = database.GetCollection ("Groups"); groups.Save (group); //Groups collection //{ // "_id": "4da54d3c00a9ec06a0067456", // "Description": "A fancy descriptor", // "persons": [ // { // "_id": "4da54d3b00a9ec06a0067455", // "Name": "Testperson" // } // ] //} //Persons collection //{ // "_id": "4da54d3b00a9ec06a0067455", // "Name": "Testperson" //} var readPerson = persons.FindOneById(p.Id); readPerson.Name = "a different name"; //Here i've changed Insert to Save persons.Save(readPerson); //Here you updating person in persons collection, //but within group name still old //Persons collection //{ // "_id": "4da54d3b00a9ec06a0067455", // "Name": "a different name" //} //So to achieve 'physical relation' you need also update person within group var query = Query.EQ("persons._id", readPerson.Id); groups.Update(query, Update.Set("persons.$.Name", readPerson.Name)); //Groups collection //{ // "_id": "4da54d3c00a9ec06a0067456", // "Description": "A fancy descriptor", // "persons": [ // { // "_id": "4da54d3b00a9ec06a0067455", // "Name": "a different name" // } // ] //} //Test passed var readGroup = groups.FindOneById(group.Id); Assert.AreEqual(readPerson.Id, readGroup.persons[0].Id); Assert.AreEqual(readPerson.Name, readGroup.persons[0].Name);
