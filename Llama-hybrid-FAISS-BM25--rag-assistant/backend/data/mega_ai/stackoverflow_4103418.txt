[site]: stackoverflow
[post_id]: 4103418
[parent_id]: 4103405
[tags]: 
Here's my Java port, dodging the error condition when the determinant disappears with a very elegant IllegalArgumentException , my approach to coping with the "points are two far apart" or "points lie on a line" conditions. Also, this computes the radius (and copes with exceptional conditions) which your intersecting-slopes approach will not do. public class CircleThree { static final double TOL = 0.0000001; public static Circle circleFromPoints(final Point p1, final Point p2, final Point p3) { final double offset = Math.pow(p2.x,2) + Math.pow(p2.y,2); final double bc = ( Math.pow(p1.x,2) + Math.pow(p1.y,2) - offset )/2.0; final double cd = (offset - Math.pow(p3.x, 2) - Math.pow(p3.y, 2))/2.0; final double det = (p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x)* (p1.y - p2.y); if (Math.abs(det) See algorithm from The Math Forum : void circle_vvv(circle *c) { c->center.w = 1.0; vertex *v1 = (vertex *)c->c.p1; vertex *v2 = (vertex *)c->c.p2; vertex *v3 = (vertex *)c->c.p3; float bx = v1->xw; float by = v1->yw; float cx = v2->xw; float cy = v2->yw; float dx = v3->xw; float dy = v3->yw; float temp = cx*cx+cy*cy; float bc = (bx*bx + by*by - temp)/2.0; float cd = (temp - dx*dx - dy*dy)/2.0; float det = (bx-cx)*(cy-dy)-(cx-dx)*(by-cy); if (fabs(det) center.xw = c->center.yw = 1.0; c->center.w = 0.0; c->v1 = *v1; c->v2 = *v2; c->v3 = *v3; return; } det = 1/det; c->center.xw = (bc*(cy-dy)-cd*(by-cy))*det; c->center.yw = ((bx-cx)*cd-(cx-dx)*bc)*det; cx = c->center.xw; cy = c->center.yw; c->radius = sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by)); }
