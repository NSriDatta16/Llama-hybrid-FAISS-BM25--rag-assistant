[site]: stackoverflow
[post_id]: 2060534
[parent_id]: 2060474
[tags]: 
A few points; The domain of the service interface != the implementation domain The resources exposed by your service do not have to be directly implemented as objects in your code. The (service) interface is not the implementation. Put & Post require all of the external state You must provide all of the resource state when doing your updates (you said that you only provide the changes - that's a PATCH not a PUT). Modelling state changes via collection resources Sometimes it's best to model a state change as a collection resource. In your example, you really need to consider either a 'Review' resource with an associated 'Review-queue' or add a 'Needs review' attribute to the widget. Approach 1. A container for the 'review-queue' Having the 'Review' object would make it easy to list widgets for review, assign resources for review etc GET /review-queue -- to list the widgets which need review POST /review-queue -- create a new review entry (listing just the id, name of the widget and a url back to the widgets) DELETE /review-queue/X -- delete from the queue when the widget has been reviewed I'd use this approach if there was significant behaviour associated with the 'review-queue' e.g. permissions associated with adding a widget for review, multiple review queues etc Approach 2. 'Needs-review' attribute You may decide that a separate resource is over-kill for your needs. You can model the basic functionality with POST, PUT and GET. When a widget is created, it's state include a s 'needs-review' attribute which is set to False. Obviously you need all of the external state in the POST When a widget needs review, GET it and PUT it back with the 'needs-review' updated. Again, you need all of the external state in the PUT When listing the widgets for review use GET /widgets/?needs_review=true Poor old RPC You mention RPC in your last paragraph and although it's off-topic, I can't help but comment... I think perhaps we're all guilty now of blaming RPC for the ills of the world. The real problem with RPC is that it aimed to make remote function calls transparent to the programmer, hiding failure scenarios and attempting to make a remote call equivalent in the implementation language as a standard function call. As an old CORBA (which suffered from the same problem) programmer, I can appreciate how REST corrects that failing. Other points from your post You can't determine which method to call without examining the new state and comparing it to the existing state. You should validate the new state before doing anything else, passing any errors back to the submitter. From you're last paragraph, I think you know this already - sorry. Chris
