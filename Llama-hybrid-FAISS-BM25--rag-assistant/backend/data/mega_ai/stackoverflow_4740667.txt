[site]: stackoverflow
[post_id]: 4740667
[parent_id]: 4739748
[tags]: 
Joe -- if you are willing to set it up so that your lengthy processing all happens inside of drawRect, you can make it work. I just wrote a test project. It works. See code below. LengthyComputationTestAppDelegate.h: #import @interface LengthyComputationTestAppDelegate : NSObject { UIWindow *window; } @property (nonatomic, retain) IBOutlet UIWindow *window; @end LengthComputationTestAppDelegate.m: #import "LengthyComputationTestAppDelegate.h" #import "Incrementer.h" #import "IncrementerProgressView.h" @implementation LengthyComputationTestAppDelegate @synthesize window; #pragma mark - #pragma mark Application lifecycle - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Override point for customization after application launch. IncrementerProgressView *ipv = [[IncrementerProgressView alloc]initWithFrame:self.window.bounds]; [self.window addSubview:ipv]; [ipv release]; [self.window makeKeyAndVisible]; return YES; } Incrementer.h: #import //singleton object @interface Incrementer : NSObject { NSUInteger theInteger_; } @property (nonatomic) NSUInteger theInteger; +(Incrementer *) sharedIncrementer; -(NSUInteger) incrementForTimeInterval: (NSTimeInterval) timeInterval; -(BOOL) finishedIncrementing; incrementer.m: #import "Incrementer.h" @implementation Incrementer @synthesize theInteger = theInteger_; static Incrementer *inc = nil; -(void) increment { theInteger_++; } -(BOOL) finishedIncrementing { return (theInteger_>=100000000); } -(NSUInteger) incrementForTimeInterval: (NSTimeInterval) timeInterval { NSTimeInterval negativeTimeInterval = -1*timeInterval; NSDate *startDate = [NSDate date]; while (!([self finishedIncrementing]) && [startDate timeIntervalSinceNow] > negativeTimeInterval) [self increment]; return self.theInteger; } -(id) init { if (self = [super init]) { self.theInteger = 0; } return self; } #pragma mark -- #pragma mark singleton object methods + (Incrementer *) sharedIncrementer { @synchronized(self) { if (inc == nil) { inc = [[Incrementer alloc]init]; } } return inc; } + (id)allocWithZone:(NSZone *)zone { @synchronized(self) { if (inc == nil) { inc = [super allocWithZone:zone]; return inc; // assignment and return on first allocation } } return nil; // on subsequent allocation attempts return nil } - (id)copyWithZone:(NSZone *)zone { return self; } - (id)retain { return self; } - (unsigned)retainCount { return UINT_MAX; // denotes an object that cannot be released } - (void)release { //do nothing } - (id)autorelease { return self; } @end IncrementerProgressView.m: #import "IncrementerProgressView.h" @implementation IncrementerProgressView @synthesize progressLabel = progressLabel_; @synthesize nextUpdateTimer = nextUpdateTimer_; -(id) initWithFrame:(CGRect)frame { if (self = [super initWithFrame: frame]) { progressLabel_ = [[UILabel alloc]initWithFrame:CGRectMake(20, 40, 300, 30)]; progressLabel_.font = [UIFont systemFontOfSize:26]; progressLabel_.adjustsFontSizeToFitWidth = YES; progressLabel_.textColor = [UIColor blackColor]; [self addSubview:progressLabel_]; } return self; } -(void) drawRect:(CGRect)rect { [self.nextUpdateTimer invalidate]; Incrementer *shared = [Incrementer sharedIncrementer]; NSUInteger progress = [shared incrementForTimeInterval: 0.1]; self.progressLabel.text = [NSString stringWithFormat:@"Increments performed: %d", progress]; if (![shared finishedIncrementing]) self.nextUpdateTimer = [NSTimer scheduledTimerWithTimeInterval:0. target:self selector:(@selector(setNeedsDisplay)) userInfo:nil repeats:NO]; } - (void)dealloc { [super dealloc]; } @end
