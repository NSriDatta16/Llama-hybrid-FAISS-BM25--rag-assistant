[site]: stackoverflow
[post_id]: 4586058
[parent_id]: 4585840
[tags]: 
You could just add the UISwitch in your accessory view. That is the easiest way to do it, not to mention that it looks 'elegant'. Then, in your tableview controller code, you could just call a selector every time the switch is toggled, or even toggle the switch itself by getting the switch's current status in your controller. Let know if you'd like a code sample. ---sample code--- - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @"Cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease]; //add a switch UISwitch *switchview = [[UISwitch alloc] initWithFrame:CGRectZero]; cell.accessoryView = switchview; [switchview release]; } cell.textLabel.text = [NSString stringWithFormat:@"%d", indexPath.row]; return cell; } Then, you could have a method that updates a switch based on changes in your model. You could use anything you want - delegates, notifications, KVO, etc. Example: - (void)updateSwitchAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [self.tableView cellForRowAtIndexPath:indexPath]; UISwitch *switchView = (UISwitch *)cell.accessoryView; if ([switchView isOn]) { [switchView setOn:NO animated:YES]; } else { [switchView setOn:YES animated:YES]; } }
