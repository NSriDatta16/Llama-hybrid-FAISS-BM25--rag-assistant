[site]: stackoverflow
[post_id]: 4007447
[parent_id]: 4007382
[tags]: 
In C++, it is possible to allocate objects using automatic (stack) and dynamic (heap) storage. Type variable_name; // variable_name has "automatic" storage. // it is a local variable and is created on the stack. Type* pointer_name = NULL; // pointer_name is a "pointer". The pointer, itself, // is a local variable just like variable_name // and is also created on the stack. Currently it // points to NULL. pointer_name = new DerivedType; // (where DerivedType inherits from Type). Now // pointer_name points to an object with // "dynamic" storage that exists on the heap. delete pointer_name; // The object pointed-to is deallocated. pointer_name = NULL; // Resetting to NULL prevents dangling-pointer errors. You can use pointers and heap-allocation to dynamically construct objects as in: #include #include #include class Base { public: virtual ~Base(){} virtual void printMe() const = 0; protected: Base(){} }; class Alpha : public Base { public: Alpha() {} virtual ~Alpha() {} virtual void printMe() const { std::cout pointer; // it is generally better to use boost::unique_ptr, // but I'll use this in case you aren't familiar // with Boost so you can get up and running. std::string which; std::cout > which; if (which == "alpha") { pointer.reset(new Alpha); } else if (which == "bravo") { pointer.reset(new Bravo); } else { std::cerr printMe(); return 0; } Related: the "Factory" object-oriented design pattern
