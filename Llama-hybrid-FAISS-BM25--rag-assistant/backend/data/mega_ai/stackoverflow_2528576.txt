[site]: stackoverflow
[post_id]: 2528576
[parent_id]: 2528317
[tags]: 
Response to allocation test Add this to either of the samples I give below: #include void* allocate(size_t pAmount) { std::cout (Note, these are not fully correct replacements of the allocation operators, and are for demonstration.) Running the runtime-sized sample program gives me the following output: Allocating 40 bytes. Allocating 40 bytes. Allocating 40 bytes. Allocating 40 bytes. Allocating 40 bytes. Allocating 40 bytes. Allocating 40 bytes. Deallocating. Deallocating. Allocating 120 bytes. Deallocating. Allocating 20 bytes. Deallocating. Allocating 40 bytes. Deallocating. Deallocating. Deallocating. Inserting: [0,0] Inserting: [1,2] Inserting: [2,4] Inserting: [3,6] Inserting: [4,8] Deallocating. Deallocating. Deallocating. bad allocation Note there are no allocations once insertion has begun. You should be getting no memory allocations. How are you generating your output? The allocators What you need is a new allocator. Here's something I made now, so it's relatively untested, but it looks good to me. It creates a freelist and uses that to give out memory. Construction of the allocator takes O(N), but both allocations and deallocations are O(1). (Very fast!) Also, once it's constructed, no more memory allocations take place. Though freelists have average locality, it probably beats what you'd normally get out of a map with the default allocator. Here it is: #include #include #include #include // gets rid of "unused parameter" warnings #define USE(x) (void)(x) template class freelist_allocator { public: // types typedef T value_type; typedef const T const_value_type; typedef value_type& reference; typedef const_value_type& const_reference; typedef value_type* pointer; typedef const_value_type* const_pointer; typedef std::size_t size_type; typedef std::ptrdiff_t difference_type; // ensure it can hold both a pointer and T struct block_type { char data[sizeof(T) > sizeof(void*) ? sizeof(T) : sizeof(void*)]; }; typedef std::vector buffer_type; // constants static const size_t Elements = N; // rebind template struct rebind { typedef freelist_allocator other; }; // constructor freelist_allocator(void) : mBuffer(Elements), mNext(0) { build_list(); } freelist_allocator(const freelist_allocator&) : mBuffer(Elements), mNext(0) { build_list(); } template freelist_allocator(const freelist_allocator &) : mBuffer(Elements), mNext(0) { build_list(); } // address pointer address(reference r) { return &r; } const_pointer address(const_reference r) { return &r; } // memory pointer allocate(size_type pCount, const void* = 0) { USE(pCount); // pCount unused when assert is disabled in release assert(pCount == 1 && "freelist_allocator is noncontiguous"); // end of list if (!mNext) throw std::bad_alloc(); // remove from list void* memory = mNext; mNext = data_as_ptr(*mNext); return static_cast (memory); } void deallocate(pointer pPtr, size_type) { // get back our block block_type* b = reinterpret_cast (pPtr); // reinsert to list data_as_ptr(*b) = mNext; mNext = b; } // size size_type max_size(void) const { static const size_t MaxSize = std::numeric_limits ::max(); return MaxSize / sizeof(value_type); } // construction / destruction void construct(pointer pPtr, const T& pT) { new (pPtr) T(pT); } void destroy(pointer pPtr) { USE(pPtr); // trivial destructor skips next line pPtr->~value_type(); } private: // utility block_type*& data_as_ptr(block_type& pBlock) { return reinterpret_cast (pBlock.data); } void build_list(void) { // build list for (size_t i = 1; i bool operator==(freelist_allocator const&, freelist_allocator const&) { return false; } template bool operator!=(freelist_allocator const& pX, freelist_allocator const& pY) { return !(pX == pY); } #undef USE And use: #include #include #include static const size_t MaxElements = 5; typedef std::pair pair_type; typedef freelist_allocator allocator_type; typedef std::map , allocator_type> map_type; void do_insert(int pX, int pY, map_type& pMap) { std::cout ::max() / 2; ++i) { // will throw at MaxElements insertions do_insert(i, i * 2, m); } } catch (const std::exception& e) { std::cerr For now I've made the size a compile-time constant, but you want a run-time version just let me know and I'll write that up. Here's a version that takes a size at run-time: #include #include #include #include // gets rid of "unused parameter" warnings #define USE(x) (void)(x) template class freelist_allocator { public: // types typedef T value_type; typedef const T const_value_type; typedef value_type& reference; typedef const_value_type& const_reference; typedef value_type* pointer; typedef const_value_type* const_pointer; typedef std::size_t size_type; typedef std::ptrdiff_t difference_type; // ensure it can hold both a pointer and T struct block_type { char data[sizeof(T) > sizeof(void*) ? sizeof(T) : sizeof(void*)]; }; typedef std::vector buffer_type; // rebind template struct rebind { typedef freelist_allocator other; }; // constructor freelist_allocator(size_t pElements) : mBuffer(pElements), mNext(0) { build_list(); } freelist_allocator(const freelist_allocator& pRhs) : mBuffer(pRhs.size()), mNext(0) { build_list(); } template freelist_allocator(const freelist_allocator & pRhs) : mBuffer(pRhs.size()), mNext(0) { build_list(); } // address pointer address(reference r) { return &r; } const_pointer address(const_reference r) { return &r; } // memory pointer allocate(size_type pCount, const void* = 0) { USE(pCount); // pCount unused when assert is disabled in release assert(pCount == 1 && "freelist_allocator is noncontiguous"); // end of list if (!mNext) throw std::bad_alloc(); // remove from list void* memory = mNext; mNext = data_as_ptr(*mNext); return static_cast (memory); } void deallocate(pointer pPtr, size_type) { // get back our block block_type* b = reinterpret_cast (pPtr); // reinsert to list data_as_ptr(*b) = mNext; mNext = b; } // size size_type max_size(void) const { static const size_t MaxSize = std::numeric_limits ::max(); return MaxSize / sizeof(value_type); } size_t size(void) const { return mBuffer.size(); } // construction / destruction void construct(pointer pPtr, const T& pT) { new (pPtr) T(pT); } void destroy(pointer pPtr) { USE(pPtr); // trivial destructor skips next line pPtr->~value_type(); } private: // utility block_type*& data_as_ptr(block_type& pBlock) { return reinterpret_cast (pBlock.data); } void build_list(void) { // build list for (size_t i = 1; i bool operator==(freelist_allocator const&, freelist_allocator const&) { return false; } template bool operator!=(freelist_allocator const& pX, freelist_allocator const& pY) { return !(pX == pY); } #undef USE Use: #include #include #include static const size_t MaxElements = 5; template struct map_types // helpful { typedef std::pair pair_type; typedef freelist_allocator allocator_type; typedef std::less predicate_type; typedef std::map map_type; }; template void do_insert(const Key& pX, const Value& pY, Map& pMap) { std::cout map_types; // double parenthesis to avoid vexing parse map_types::map_type m((map_types::predicate_type()), map_types::allocator_type(MaxElements)); // just keep inserting for (int i = 0; i ::max() / 2; ++i) { do_insert(i, i * 2, m); } } catch (const std::exception& e) { std::cerr The run-time version could possibly allocate more space if there are no more remaining slots, which can be useful. But I leave that to you. (Don't resize the vector! You'll possibly lose your entire buffer. You'll need a list of vectors, likely.) Note if you can use Boost, they have such an allocator in their Pool library . That said, their allocator keeps track of the order you request memory, to ensure reverse construction destruction order. This turns allocations and deallocations into O(N). (A terrible choice in my opinion.) I actually wrote my own allocator around boost::pool<> to get around this.
