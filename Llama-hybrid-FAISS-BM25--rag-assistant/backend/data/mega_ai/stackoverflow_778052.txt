[site]: stackoverflow
[post_id]: 778052
[parent_id]: 371808
[tags]: 
One really good reason for having a public category, and one that Apple uses often, is for extending a class with functionality that exists in the category's framework, but which doesn't exist in the framework that defines the class. For example, NSString is defined in Foundation.framework, but categories on NSString defining methods for drawing an NSString to the screen are defined in AppKit.framework. Another good usage of categories is for dependency hiding; e g if you really need boost for a part of the class, you can have that in a separate header and implementation file, and a user of the class that needs the boost parts can import that header together with the one originally defining the class, and only that file will take ages to compile. This is more useful in the 64-bit runtime, where a category can add instance variables. A really large implementation over several source files (but a single header) is also a good candidate, as Tom points out :) I'd just like to add to Tom's original answer: Generally, it's better to use a class extension than a class category when declaring private methods. This way, you can implement the extension in the same @implementation block as the public methods, without getting a warning about "missing category implementation". Example: // .h file @interface Foo : NSObject -(void)publicMethod; @end // .m file @interface Foo () // Notice the empty paren; this is how you define // a class extension, which is not the same as a category -(void)somePrivateMethod; @end @implementation Foo #pragma mark Public methods -(void)publicMethod; { ... } #pragma mark Private methods -(void)privateMethod; { ... } @end
