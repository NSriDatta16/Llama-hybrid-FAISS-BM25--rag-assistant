[site]: stackoverflow
[post_id]: 5141899
[parent_id]: 4840230
[tags]: 
You've come a long way in four weeks. It helps to include minimal DDL and INSERT statements to encourage more people to respond. I added the GROUP BY statement to accomplish this. The correct number of records are returned with the correct loc_name and distance from the user. However, all of the other fields are never correct. They seem randomly selected from other records that are outside of the MIN value. Yes, that's normal for MySQL. The article MySQL Standard Group By explains that behavior. An indeterminate result set is returned when one or more non-aggregated columns in a SELECT clause aren’t listed in the GROUP BY clause. The columns listed in the SELECT clause but excluded from the GROUP BY clause return meaningless values because they’re column values chosen indeterminately from all pre-aggregated rows. You need a determinate result set, not an indeterminate one. This statement should give you a two-column result set containing one row per location name. SELECT loc_name, MIN( ((ACOS( . . . ) AS distance FROM locations GROUP BY loc_name And you should be able to use that statement and a JOIN expression on the location name and distance to get the other columns you need. I wrapped the arithmetic in a function named "distance", then SELECT L1.*, C.* FROM locations L1 INNER JOIN (SELECT L2.loc_name, MIN(distance($lat, $lon, L2.loc_lat, L2.loc_lon)) AS distance FROM locations L2 GROUP BY L2.loc_name) C ON L1.loc_name = C.loc_name AND C.distance = distance($lat, $lon, L1.loc_lat, L1.loc_lon) You'll need to add your bounding box information. I left it out while I was trying to make sure the JOIN worked right. I had an unnecessary ORDER BY in the inner SELECT clause, but that was a pre-caffeine clause, so I deleted it. You will probably need an index on loc_name, too, because it's used in the GROUP BY . See MySQL's docs for EXPLAIN syntax .
