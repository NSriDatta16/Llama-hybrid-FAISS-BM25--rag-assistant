[site]: stackoverflow
[post_id]: 1252815
[parent_id]: 1252795
[tags]: 
Inefficient query design Auto-growing files Too many indexes to be maintained on a table Too few indexes on a table Not properly choosing your clustered index Index fragmentation due to poor maintenance Heap fragmentation due to no clustered index Too high FILLFACTORs used on indexes, causing excessive page splitting Too low of a FILLFACTOR used on indexes, causing excessive space usage and increased scanning time Not using covered indexes where appropriate Non-selective indexes being used Improper maintenance of statistics (out of date statistics) Databases not normalized properly Transaction logs and data sharing the same drive spindles The wrong memory configuration Too little memory Too little CPU Slow hard drives Failing hard drives or other hardware A 3D screensaver on your database server chewing up your CPU Sharing the database server with other processes which compete for CPU and memory Lock contention between queries Queries which scan entire large tables Front end code which searches data in an inefficent manner (nested loops, row by row) CURSORS which are not necessary and/or are not FAST_FORWARD Not setting NOCOUNT when you have large tables being cursored through. Using a transaction isolation level which is too high (such as using SERIALIZABLE when it's not necessary) Too many round trips between the client and the SQL Server (a chatty interface) An unnecessary linked server query A linked server query which targets a table on a remote server with no primary or candidate key defined Selecting too much data Excessive query recompilations oh and there might be some others, too.
