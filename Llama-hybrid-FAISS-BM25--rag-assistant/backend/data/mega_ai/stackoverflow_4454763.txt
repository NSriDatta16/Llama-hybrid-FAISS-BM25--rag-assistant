[site]: stackoverflow
[post_id]: 4454763
[parent_id]: 4431781
[tags]: 
Unfortunately the answer appears to be no . If someone can prove otherwise I'll be happy to grant them the accepted answer. EDIT I found a way to do this using Entity SQL . I'm not sure it's the greatest way, but as it seems to be the only way then it may be the greatest by default :) var cmdText = "SELECT MIN(p.x), MAX(p.x), MIN(p.y), MAX(p.y) " + "FROM Places AS p JOIN Logs AS l ON p.Id = l.PlaceId " + "WHERE l.OwnerId==123"; var results = CreateQuery (cmdText) var row = results.First(); var minX = (double)row[0]; var maxX = (double)row[1]; var minY = (double)row[2]; var maxY = (double)row[3]; The above isn't exactly the code I am working with. For a simpler case without a join, here's the generated SQL, showing that only one trip to the DB is made: SELECT 1 AS [C1], [GroupBy1].[A1] AS [C2], [GroupBy1].[A2] AS [C3], [GroupBy1].[A3] AS [C4], [GroupBy1].[A4] AS [C5] FROM ( SELECT MIN([Extent1].[X1]) AS [A1], MAX([Extent1].[X1]) AS [A2], MAX([Extent1].[Y1]) AS [A3], MIN([Extent1].[Y1]) AS [A4] FROM [dbo].[Edges] AS [Extent1] WHERE [Extent1].[PlaceId] = 123 ) AS [GroupBy1] If someone finds a more elegant solution to this problem, I'll grant them the accepted answer. EDIT 2 Thanks to Costas who found a great solution to this problem that uses pure Linq.
