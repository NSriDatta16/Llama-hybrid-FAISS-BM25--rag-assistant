[site]: stackoverflow
[post_id]: 3409016
[parent_id]: 3408894
[tags]: 
1) The mouse movements and the button release are NOT in the window client area. Therefore, instead of WM_MOUSEMOVE and WM_LBUTTONUP, I should have WM_NCMOUSEMOVE and WM_NCLBUTTONUP. I'm not sure about this one, but I can guess: maybe the system always sends WM_MOUSEMOVE , and this is converted to WM_NCMOUSEMOVE somewhere along the way (depending on the result of WM_NCHITTEST ). During a drag operation, your application doesn't get to see these messages anyway (as you noticed) so there's no point in doing the conversion. 2) If I put a break, on those messages (WM_MOUSEMOVE and WM_LBUTTONUP), in my window procedure, I don't intercept theses mesages while dragging the window's title bar !!! Recall that WM_MOUSEMOVE and friends are posted, not sent. That means they will usually flow through your own message loop, and arrive at your window procedure via DispatchMessage . When you start to drag a window, the application enters a so-called modal message loop. This loop will not return until the drag is finished, so until that time, your own message loop will not run! The WM_ENTERSIZEMOVE and WM_EXITSIZEMOVE messages are sent to the window procedure when the modal loop is entered and exited, respectively. Now, it could be that the modal loop also dispatches messages to your window procedure; but (at least for WM_MOUSEMOVE and such) it does not. And it shouldn't, because the modal loop itself is handling those messages -- passing them to the winproc would probably cause confusion.
