[site]: stackoverflow
[post_id]: 1920082
[parent_id]: 1918385
[tags]: 
You can overallocate for any class instance, but it implies a certain amount of management overhead. The only valid way to do this is by using a custom memory allocation call. Without changing the class definition, you can do this. void* pMem = ::operator new(sizeof(myDerivedStruct) + n); myDerivedStruct* pObject = new (pMem) myDerivedStruct; Assuming that you don't overload operator delete in the hierarchy then delete pObject will be a correct way to destroy pObject and deallocate the allocated memory. Of course, if you allocate any objects in the excess memory area then you must correctly free them before deallocating the memory. You then have access to n bytes of raw memory at this address: void* p = pObject + 1 . You can memcpy data to and from this area as you like. You can assign to the object itself and shouldn't need to memcpy its data. You can also provide a custom memory allocator in the class itself that takes an extra size_t describing the amount of excess memory to allocate enabling you to do the allocation in a single new expression, but this requires more overhead in the class design. myDerivedStruct* pObject = new (n) myDerivedStruct; and struct myDerivedStruct { // ... void* operator new(std::size_t objsize, std::size_t excess storage); // other operator new and delete overrides to make sure that you have no memory leaks };
