[site]: stackoverflow
[post_id]: 3431431
[parent_id]: 3431408
[tags]: 
The numbers in brackets are the indices of the initializers. This is a C99 feature. Given that your example code does use this blemish, the reason you receive the output you do is that "foo" is stored in names[3] , while NULL is stored in names[2] . Your program crashes when it attempts to puts(names[2]) which is the same as puts(NULL) . Your loop would otherwise iterate to 16 or 32 iterations -- you are dividing by sizeof(char) for the array element size, and you mean to use sizeof(char *) . Better to use this macro: #define DIMENSION_OF (a) (sizeof(a)/sizeof(a[0])) I suggest never using any C99-specific features, such as these "designated initializers." There is a reason that most of the answers you received on this question were confused as to why your loop only output two strings rather than four. That reason is that C99 is not widely recognized by other programmers. There are several reasons that most programmers aren't familiar with C99's more distinctive features. A frequently cited reason is that C99 is more incompatible with C++ than ANSI C, and makes the possibility of future conversion to C++ more difficult. My personal complaint with C99 also makes extensions to ANSI C which are superfluous. An example of a superfluous addition is the example from C99 that you have provided. Don't use "designated inits." Do refer to the American National Standards Institute C Standard. Do not refer to the International Standards Organization C99 document. Most of the features which are "nice to have" form C99 were already available as extensions in all major compilers. Declaring a variable in the for-init-statement is an example of a non-ANSI-C-standard feature which is widely supported. The complex built-in type is an example of a non-ANSI-C-standard feature that is not widely supported.
