[site]: stackoverflow
[post_id]: 5408730
[parent_id]: 
[tags]: 
What is the encoding of argv?

It's not clear to me what encodings are used where in C's argv . In particular, I'm interested in the following scenario: A user uses locale L1 to create a file whose name, N , contains non-ASCII characters Later on, a user uses locale L2 to tab-complete the name of that file on the command line, which is fed into a program P as a command line argument What sequence of bytes does P see on the command line? I have observed that on Linux, creating a filename in the UTF-8 locale and then tab-completing it in (e.g.) the zw_TW.big5 locale seems to cause my program P to be fed UTF-8 rather than Big5 . However, on OS X the same series of actions results in my program P getting a Big5 encoded filename. Here is what I think is going on so far (long, and I'm probably wrong and need to be corrected): Windows File names are stored on disk in some Unicode format. So Windows takes the name N , converts from L1 (the current code page) to a Unicode version of N we will call N1 , and stores N1 on disk. What I then assume happens is that when tab-completing later on, the name N1 is converted to locale L2 (the new current code page) for display. With luck, this will yield the original name N -- but this won't be true if N contained characters unrepresentable in L2. We call the new name N2 . When the user actually presses enter to run P with that argument, the name N2 is converted back into Unicode, yielding N1 again. This N1 is now available to the program in UCS2 format via GetCommandLineW / wmain / tmain , but users of GetCommandLine / main will see the name N2 in the current locale (code page). OS X The disk-storage story is the same, as far as I know. OS X stores file names as Unicode. With a Unicode terminal, I think what happens is that the terminal builds the command line in a Unicode buffer. So when you tab complete, it copies the file name as a Unicode file name to that buffer. When you run the command, that Unicode buffer is converted to the current locale, L2, and fed to the program via argv , and the program can decode argv with the current locale into Unicode for display. Linux On Linux, everything is different and I'm extra-confused about what is going on. Linux stores file names as byte strings , not in Unicode. So if you create a file with name N in locale L1 that N as a byte string is what is stored on disk. When I later run the terminal and try and tab-complete the name, I'm not sure what happens. It looks to me like the command line is constructed as a byte buffer, and the name of the file as a byte string is just concatenated onto that buffer. I assume that when you type a standard character it is encoded on the fly to bytes that are appended to that buffer. When you run a program, I think that buffer is sent directly to argv . Now, what encoding does argv have? It looks like any characters you typed in the command line while in locale L2 will be in the L2 encoding, but the file name will be in the L1 encoding . So argv contains a mixture of two encodings! Question I'd really like it if someone could let me know what is going on here. All I have at the moment is half-guesses and speculation, and it doesn't really fit together. What I'd really like to be true is for argv to be encoded in the current code page (Windows) or the current locale (Linux / OS X) but that doesn't seem to be the case... Extras Here is a simple candidate program P that lets you observe encodings for yourself: #include int main(int argc, char **argv) { if (argc You can use locale -a to see available locales, and use export LC_ALL=my_encoding to change your locale.
