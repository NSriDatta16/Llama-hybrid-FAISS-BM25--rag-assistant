[site]: stackoverflow
[post_id]: 2609512
[parent_id]: 
[tags]: 
Workaround for HttpContext.HideRequestResponse being internal? Detect if HttpContext.Request is really available?

We're migrating an application to use IIS7 integrated mode. In library code that is designed to work either within the context of an HTTP request or not, we commonly have code like this: if (HttpContext.Current != null && HttpContext.Current.Request != null) { // do something with HttpContext.Current.Request } else { // do equivalent thing without HttpContext.. } But in IIS7 integrated mode the check for HttpContext.Current.Request throws an exception whenever this code is called from Application_Start . protected void Application_Start(object sender, EventArgs e) { SomeLibrary.DoSomethingWithHttpContextCurrentDetection(); } Results in: System.Web.HttpException: Request is not available in this context How can I detect whether the request is really available without wrapping these calls in an exception handler and taking action based on whether an exception is generated or not. Looking at HttpContext in Reflector I see it has an internal bool HideRequestResponse field but it's internal so I can only get to it with reflection and that's fragile. Is there a more official/approved way to determine if it's ok to call HttpContext.Request ? This blog post about the subject says not to use HttpContext , but how, in generic library code, can you determine if it's ok to use HttpContext ? http://mvolo.com/iis7-integrated-mode-request-is-not-available-in-this-context-exception-in-applicationstart/ I'm using the work-around mentioned there which is to use Application_BeginRequest and an initialized field to only initialize once as part of BeginRequest , but that has to be done in every calling application whereas I'd prefer to make the library code more robust and handle this situation regardless of where it's called from.
