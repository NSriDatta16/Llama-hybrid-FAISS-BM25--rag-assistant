[site]: stackoverflow
[post_id]: 1282752
[parent_id]: 1282322
[tags]: 
It looks like you are talking about two different things: URLs exposed by your web server framework. URLs used by JavaScript to re-create a state inside so-called "one page application". The former is relatively trivial and is outside of the client-side scope. The latter is a subject of the article you linked. The idea is to use a hash mark in the URL to convey the internal state of this web page. What is considered to be a part of state? Literally anything, but usually it has to have some tangible meaning. For example, if your web page presents different "pages" or sections to end users, the current section can be a part of state. Let me give you a concrete example. Links below point to the same web site and the same web page ( search.html ), yet they present different information encoded in the hash mark: http://www.nexplore.com/search.html#category=web&query=dojo%20toolkit http://www.nexplore.com/search.html#category=image&query=cat http://www.nexplore.com/search.html#category=video&query=stupid%20tricks You can see that the state is trivially encoded in a human-friendly way. Every time you search for something new, or switch categories the hash is updated and you can save it, send it to your friend, or put it in an article like I just did. A JavaScript application that employs this technique works like that: When the application initializes, e.g., using dojo.addOnLoad() , it checks the hash mark. If the hash mark is present, it is decoded as a state, and proper manipulations are made. During the normal course of actions, the application updates the hash mark to reflect its current state. This state can be persisted by end users. As soon as you start to use "one page web apps" the current state becomes essential to support. It gives users a stop point, so they can save and return to work later, rather than starting from the very beginning — just imagine that you have 15 screens encoded in one web page, and you have to enter information in all of them. Another thing which plagues "one page web apps" is the broken back button. Users may try to navigate your application using the familiar back and forward buttons supported by every browser. It would be most unfortunate to betray their expectations — imagine that user was on 7 th screen and clicked the back button. Whose fault is it? It is the web designer's failure. Both these problems are essentially the same thing, and can be solved simultaneously. Dojo provides a simple facility to do "all of the above" using dojo.back() . You can: Set custom state with one call whenever you need to do so. Associate "back" and "forward" actions with a particular state. Automate state transitions, when user uses back/forward buttons. And of course it attempts to hide browser differences in respect of handling all these things. PS: Why is a hash mark used for this? Because it can be changed from JavaScript without re-requesting a page from web server. Another popular option to convey state is a search part of URL (e.g., ?state=5 ), but it cannot be used if it is supposed to be changed dynamically because it will request the same page again. UPDATE: Now addressing the design of URIs. Over the time a lot was written and said about this topic. Probably the most influential authors in the field are: Tim Berners-Lee (the guy who invented the World Wide Web): Universal Resource Identifiers — Axioms of Web Architecture — DOs and DONTs of URIs. Cool URIs don't change — selecting the right URIs. Roy Fielding (the guy who developed HTTP and invented REST): Architectural Styles and the Design of Network-based Software Architectures — his dissertation, which explains REST. REST APIs must be hypertext-driven — the relationship between REST, hypertext, and URIs. Most modern applications nowadays are organized around REST ideas. Their typical implementation as far as URIs are concerned is to provide URIs as nouns, using HTTP verbs as, well, verbs. Examples: /articles — all articles. /articles/2005 — all articles for 2005. /articles/2005/12 — all articles for December of 2005. /articles/2005/12/about-rest — "About REST" article written in December of 2005. The verbs would be (with possible meaning): GET — get a resource (no side-effects!). PUT — create or replace a resource at given URI. POST — submit a resource for processing, or add a resource to a list, or create a sub-resource. DELETE — delete a resource. REST assumes that if a resource has links to other resources, URIs are used in the hypertext fashion. Common example would be a list of other resources. In URIs examples above I intentionally used human-readable URIs that can be used to present resources to end users. Typically modern web applications use two-tier URI schema: REST for the underlying resources used by programs. REST-like URIs of web pages for end users. The latter can be organized around the former, or around some user-centric concepts, like activity areas. I prefer to use simple and understandable URIs to present to my users, no /&p=29463&q=RcLGTt gobbledygook. Don't forget that web page URIs are organized around GET . Web pages with forms can produce POST yet it is a bad form to expose such URIs because they cannot be bookmarked and shared. The common technique is to redirect (using HTTP 302 ) in response to POST to a regular web page (e.g., "Thanks!" web page) — it provides for a seamless user experience, yet hides non-bookmarkable URIs. The hash is already a part of URL, and it denotes a state of a web page (a location inside it). Reusing it to mean a programmatic state is completely in line with its original purpose. While verbs have no meaning for hash marks, the rest is completely applicable (universality, global uniqueness, sameness, identity). It should be a "noun", not a "verb" (action). In simple cases a properly-escaped bag of key-value pairs can be used (like in the examples at the beginning of this post). In more complex cases it may be a composite name, like discussed above. Obviously the design of URIs for a web application is a part of architecture and should take into account the specifics. It is more art than science — that's why we pay software architect big bucks. ;-) But I hope that the above information will get you started on the right path.
