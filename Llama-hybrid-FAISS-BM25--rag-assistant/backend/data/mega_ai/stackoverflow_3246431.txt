[site]: stackoverflow
[post_id]: 3246431
[parent_id]: 3242133
[tags]: 
For the base definition of TDD, you write a failing test, write the minimum amount of code that will make the test pass, refactor, repeat. There isn't a lot of room there for deferring the refactoring. ;) I think this is so for a lot of reasons, mainly so that people like my boss won't be correct in assuming that the word "refactor" is a geek-speek code word for rewrite. How much easier is it to write one method, that say grabs some info from the web. You write your test, get it to pass, then say, "Ok, now take this hard coded URL and move it to the top of the class, or a property file." How much harder is that to do once you've got your class completed and weighing in a several hundred or more lines of code. Where the design portion comes in, is less in the big "D"esign, at least in my understanding and use of TDD, rather its in the good practices it encourages and/or demands. Going back to my use-case, ok, I've got my method written to grab my data, now I need to do something with it, do I go back and start adding code to my getData method? No, of course not, its "done.". I go on and write an new method or three to do something with the data. All the methods are kept short, on task, testable, in short, a much better design for the code. I think that's where the confusion comes in. TDD produces better designed CODE, which will probably produce better software, but if the overall SYSTEM design is no good, then the best coding practices in the universe aren't going to create a good product/system. YMMV of course.
