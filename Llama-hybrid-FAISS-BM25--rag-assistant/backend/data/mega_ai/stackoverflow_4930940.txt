[site]: stackoverflow
[post_id]: 4930940
[parent_id]: 
[tags]: 
GLSL shading problem: Why is my sphere in greyscale instead of red? (see code)

I'm working on a beginner level GLSL shader program. I'm following this tutorial. But my sphere always appear in greyscale and not colored red as I expected. Vertex Shader: varying vec3 normal, lightDir; void main() { gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; normal = gl_NormalMatrix * gl_Normal; vec4 vertex_in_modelview_space = gl_ModelViewMatrx * gl_Vertex; lightDir = vec3(gl_LightSource[0].position â€“ vertex_in_modelview_space); } Frag Shader: varying vec3 normal, lightDir; void main() { const vec4 AmbientColor = vec4(0.1, 0.0, 0.0, 1.0); const vec4 DiffuseColor = vec4(1.0, 0.0, 0.0, 1.0); vec3 normalized_normal = normalize(normal); vec3 normalized_lightDir = normalize(lightDir); float DiffuseTerm = clamp(dot(normal, lightDir), 0.0, 1.0); gl_FragColor = AmbientColor + DiffuseColor * DiffuseTerm; } The code is just copy and paste off the tutorial. From the frag shader, the diffuse color is red, but my sphere is greyscale. I know that the shaders are loaded correctly though because if I take out the code in the frag shader and use the following: gl_FragColor = vec4(0.0,1.0,0.0,1.0); then my sphere is solid green as expected. I do not know if it's something in the openGL code (like, Renderer.cpp) that's causing a conflict, or if there's something else wrong. This is my first time coding in GLSL, and I'm quite confused about what gl_Enable's I need to turn on/off for the shader to work properly. Thanks for any feedback! EDIT: Ok, if I call glColor3f before rendering, I can get the right color. But doesn't the light's color directly result in a change of color in the sphere? I'm worried that I'm not actually calling the functions in the shader... EDIT2: So it turns out that whenever I put any code in the vertex shader or frag shader (other than gl_Color = ...), the solid color I get disappears... I guess this means that there's something horribly wrong with my shaders? EDIT3: Here's the code for setting up my shader (supplied by my TA): char *vs = NULL,*fs = NULL; v = glCreateShader(GL_VERTEX_SHADER); f = glCreateShader(GL_FRAGMENT_SHADER); vs = textFileRead(vert); fs = textFileRead(frag); const char * ff = fs; const char * vv = vs; glShaderSource(v, 1, &vv,NULL); glShaderSource(f, 1, &ff,NULL); free(vs); free(fs); glCompileShader(v); glCompileShader(f); p = glCreateProgram(); glAttachShader(p,f); glAttachShader(p,v); glLinkProgram(p); int infologLength = 0; int charsWritten = 0; char *infoLog; glGetProgramiv(p, GL_INFO_LOG_LENGTH,&infologLength); if (infologLength > 0) { infoLog = (char *)malloc(infologLength); glGetProgramInfoLog(p, infologLength, &charsWritten, infoLog); printf("%s\n",infoLog); free(infoLog); } EDIT4: Using shader logs as suggested by kvark, I managed to fix the bugs in the shaders (turns out there were a couple of mistakes). If you would like to see the final code, please leave a comment or message me (this question is getting long).
