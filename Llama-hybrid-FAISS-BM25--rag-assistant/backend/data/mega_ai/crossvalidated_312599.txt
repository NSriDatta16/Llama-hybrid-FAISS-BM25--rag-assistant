[site]: crossvalidated
[post_id]: 312599
[parent_id]: 310962
[tags]: 
As @twiecki suggested, the devs at pymc3 provided me with an answer . The key to the solution is that theano provides an error function, allowing the skewed distribution to be coded. You can wrap the scipy function in theano using @theano.as_op (you can do a search in discourse, there are a few examples). However, you cannot use the gradient doing so it is discouraged. I would suggest you to rewrite the skew normal shape function in theano, the error function is available in theano, [...] import theano.tensor as tt def skewnorm_pdf(x, e=0, w=1, a=0, mag=1): t = (x-e) / w cdf = .5*(1+tt.erf(a*t/np.sqrt(2))) pdf = 1/np.sqrt(2*np.pi)*tt.exp(-t**2/2) return 2 * mag * pdf * cdf and hence with pm.Model() as model: #Baseline lambda - one of our unknown lambda_bl = pm.Uniform('lambda_bl', 0., 20) #Parameters for skewed Gaussians - also unknowns mu = pm.Uniform('mu', 0., 300, shape=N_SPOTS) sigma = pm.Uniform('sigma', 0., 50, shape=N_SPOTS) mag = pm.Uniform('mag', 0., 100, shape=N_SPOTS) alpha = pm.Uniform('alpha', 0., 50, shape=N_SPOTS) lam = lambda_bl + tt.sum( skew_theano(ts,e=mu,w=sigma,a=alpha, mag=mag) ) cs = pm.Poisson(mu=lam, name='cs', observed=count)
