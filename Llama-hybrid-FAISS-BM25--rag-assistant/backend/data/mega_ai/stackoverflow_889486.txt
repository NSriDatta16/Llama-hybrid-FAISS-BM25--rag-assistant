[site]: stackoverflow
[post_id]: 889486
[parent_id]: 865340
[tags]: 
With the help Mike Regan gave me in his answer (thanks again Mike), I managed to work out a solution that I want to share here. Maybe this also clarifies what my goal was. In terms of performance, this might not be the fastest or most efficient solution. Feel free to suggest improvements. The result of my code is a list of ReviewItem classes, that will be processed elsewhere. Without further ado, here's the code: /// /// Worker class that collects comments from a Word document and exports them as ReviewItems /// internal class ReviewItemCollector { /// /// Working document /// private Word.Document WorkingDoc = new Word.DocumentClass(); /// /// Extracts the review results from a Word document /// /// Fully qualified path of the file to be evaluated /// public ReviewResult GetReviewResults(string fileName) { Word.Application wordApp = null; List reviewItems = new List (); object missing = System.Reflection.Missing.Value; try { // Fire up Word wordApp = new Word.ApplicationClass(); // Some object variables because the Word API requires this object fileNameForWord = fileName; object readOnly = true; WorkingDoc = wordApp.Documents.Open(ref fileNameForWord, ref missing, ref readOnly, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing); // Gather all paragraphs that are chapter headers, sorted by their start position var headers = (from Word.Paragraph p in WorkingDoc.Paragraphs where IsHeading(p) select new Heading() { Text = GetHeading(p), Start = p.Range.Start }).ToList().OrderBy(h => h.Start); reviewItems.AddRange(FindComments(headers)); // I will be doing similar things with Revisions in the document } catch (Exception x) { MessageBox.Show(x.ToString(), "Error while collecting review items", MessageBoxButtons.OK, MessageBoxIcon.Error); } finally { if (wordApp != null) { object doNotSave = Word.WdSaveOptions.wdDoNotSaveChanges; wordApp.Quit(ref doNotSave, ref missing, ref missing); } } ReviewResult result = new ReviewResult(); result.Items = reviewItems.OrderBy(i => i.Position); return result; } /// /// Finds all comments in the document and converts them to review items /// /// List of ReviewItems generated from comments private List FindComments(IOrderedEnumerable headers) { List result = new List (); // Generate ReviewItems from the comments in the documents var reviewItems = from Word.Comment c in WorkingDoc.Comments select new ReviewItem() { Position = c.Scope.Start, Page = GetPageNumberOfRange(c.Scope), Paragraph = GetHeaderForRange(headers, c.Scope), Description = c.Range.Text, ItemType = DetermineCommentType(c) }; return reviewItems.ToList(); } /// /// Brute force translation of comment type based on the contents... /// /// /// private static string DetermineCommentType(Word.Comment c) { // This code is very specific to my solution, might be made more flexible/configurable // For now, this works :-) string text = c.Range.Text.ToLower(); if (text.EndsWith("?")) { return "Vraag"; } if (text.Contains("spelling") || text.Contains("spelfout")) { return "Spelling"; } if (text.Contains("typfout") || text.Contains("typefout")) { return "Typefout"; } if (text.ToLower().Contains("omissie")) { return "Omissie"; } return "Opmerking"; } /// /// Determine the last header before the given range's start position. That would be the chapter the range is part of. /// /// List of headings as identified in the document. /// The current range /// private static string GetHeaderForRange(IEnumerable headings, Word.Range range) { var found = (from h in headings where h.Start /// Identifies whether a paragraph is a heading, based on its styling. /// Note: the documents we're reviewing are always in a certain format, we can assume that headers /// have a style named "Heading..." or "Kop..." /// /// The paragraph to be evaluated. /// private static bool IsHeading(Word.Paragraph paragraph) { Word.Style style = paragraph.get_Style() as Word.Style; return (style != null && style.NameLocal.StartsWith("Heading") || style.NameLocal.StartsWith("Kop")); } /// /// Translates a paragraph into the form we want to see: preferably the chapter/paragraph number, otherwise the /// title itself will do. /// /// The paragraph to be translated /// private static string GetHeading(Word.Paragraph paragraph) { string heading = ""; // Try to get the list number, otherwise just take the entire heading text heading = paragraph.Range.ListFormat.ListString; if (string.IsNullOrEmpty(heading)) { heading = paragraph.Range.Text; heading = Regex.Replace(heading, "\\s+$", ""); } return heading; } /// /// Determines the pagenumber of a range. /// /// The range to be located. /// private static int GetPageNumberOfRange(Word.Range range) { return (int)range.get_Information(Word.WdInformation.wdActiveEndPageNumber); } }
