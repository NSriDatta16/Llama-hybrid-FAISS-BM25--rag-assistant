[site]: stackoverflow
[post_id]: 3526830
[parent_id]: 3526702
[tags]: 
Allocations with malloc are guaranteed to be aligned for any type provided by the compiler and hence any object[*]. The danger is when your header has a smaller alignment requirement than the maximum alignment requirement for your implementation. Then its size might not be a multiple of the max. alignment, and so when you try to cast/use buf + header_size as a pointer to something that does have the max. alignment, it's misaligned. As far a C is concerned, that's undefined behaviour. On Intel it works but is slower. On some ARMs it causes a hardware exception. On some ARMs it silently gives the wrong answer. So if you don't want to make assumptions about platform in your code, you must deal with it. There are basically three tricks that I'm aware of to ensure that your header doesn't cause misalignment: Use an implementation-specific alignment pragma to force the issue. Use platform-specific knowledge of struct layout and alignment to make sure that its size just so happens to be a multiple of the max alignment requirement on the system. Typically this means, "stick an extra int in as padding if necessary to make it an 8-multiple rather than just a 4-multiple". Make the header a union of every standard type, together with the struct that you actually want to use. Works well in C, but you'd have problems in C++ if your header isn't valid for membership of unions. Alternatively, you can just define header_size not to be sizeof(header) , but to be that size rounded up to a multiple of some chunky power of 2 that's "good enough". If you waste a bit of memory, so be it, and you can always have a "portability header" that defines this kind of thing in a way that isn't purely platform-independent, but makes it easy to adjust to new platforms. [*] with a common exception being over-sized SIMD types. Since they're non-standard, and it would be wasteful to 16-align every allocation just because of them, they get hand-waved aside, and you need special allocation functions for them.
