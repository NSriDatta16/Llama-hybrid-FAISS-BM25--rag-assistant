[site]: stackoverflow
[post_id]: 2964652
[parent_id]: 1818516
[tags]: 
David is right about not using primary key for indexing and such. If you'll just have to change a particular primary key value once (I've done it sometimes during migration) you could of course set identity_insert on and copy the row with a insert select and then delete the original one. For recreating a sort order or an column used as an index in your application you could use the following stored procedure: CREATE PROCEDURE [dbo].[OrganizeOrderConfirmationMessages] AS BEGIN SET NOCOUNT ON; DECLARE @sortOrder INT; SET @sortOrder = 0; -- // Create temporary table CREATE TABLE #IDs(ID INT, SortOrder INT) -- // Insert IDs in order according to current SortOrder INSERT INTO #IDs SELECT ocm.ID, 0 FROM OrderConfirmationMessages ocm ORDER BY ocm.SortOrder ASC -- // Update SortOrders UPDATE #IDs SET SortOrder = @sortOrder, @sortOrder = @sortOrder + 10 -- // Update the "real" values with data from #IDs UPDATE OrderConfirmationMessages SET SortOrder = x2.SortOrder FROM #IDs x2 WHERE OrderConfirmationMessages.ID = x2.ID END Results: An example of SortOrders will go from 1,2,5,7,10,24,36 to 10,20,30,40,50,60,70
