[site]: stackoverflow
[post_id]: 1150676
[parent_id]: 1149994
[tags]: 
As a testimonial: we use two methods mentioned in other answers at my workplace: custom allocators : for our memory leak tracking system, our instrumenting profiler, and a few other systems, we preallocate and/or "pool" (see e.g. boost::pool) allocs using a provided Allocator -- usually for std::set or std::map, but the principle is the same for std::list. reserve/resize : for std::vectors, it's very common practice for us to reserve or resize (the difference is important, but both can help avoid future allocs) ahead of time. Mostly we do these two things to avoid fragmentation, decrease allocator overhead, eliminate the copy-on-grow penalty, etc. But sometimes (especially with e.g. the instrumenting profiler) we want to absolutely avoid allocation during an interrupt handler. Usually, however, we avoid issues with interrupts and allocations in other manners: get in/get out : try to avoid doing anything other than setting flags or trivial copies during interrupts; some times a static (or preallocated) buffer is a far better solution than a STL container. Holding interrupts for too long is usually a recipe for disaster. disable interrupts during alloc/free : interrupts are queued up while we're allocating/freeing, instead of being dispatched immediately -- it's a feature of the CPU we're working with. Combined with a policy of selectively increasing the scope of that disabling/queuing (around e.g. std::list manipulation), we can sometimes get away with a interrupt-handler-as-producer, everything-else-as-consumer model, without overriding the allocator. If we're in the middle of consuming something from a std::list (e.g. a message received from the network hardware), interrupts are queued for as short a period as possible while pop off a copy of what we're about to process. Note that lock-free data structures could be an alternative to the second bullet here, we haven't set up and done profiling to see if it would help. Designing your own is tricky business anyway. Paranoia is the better part of valor for interrupt handlers: if you're not certain what you're doing will work, it's sometimes much better to approach the issue in an entirely different manner.
