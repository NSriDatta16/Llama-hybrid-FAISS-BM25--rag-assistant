[site]: stackoverflow
[post_id]: 5289435
[parent_id]: 5288871
[tags]: 
If you really insist on doing it this way you can store the values as an array, and the intarray module provides operators to manipulate those. That is: create table data(key text primary key, values int[] not null); insert into data values('Blue', '{10,20,23,47}'),('Green','{5,12,40}'),('Red', '{5,10,28}'); with this you can write: select unnest(values) from data where key = 'Blue' intersect select unnest(values) from data where key = 'Red'; Ideally you need an aggregate function to convert an int[] to a set and calculate intersections etc., but they don't seem to be provided. Really, this is just a slightly more compact storage of the more typical structure: select key, unnest(values) as value from data; key | value -------+------- Blue | 10 Blue | 20 Blue | 23 [...] In fact, you can simply define a view to be the above query. A more normalised approach would be to have two tables: one to describe keys, one to associate them with values: create table key_dimension(key_id serial primary key, key text not null unique); insert into key_dimension(key) values('Blue'),('Green'),('Red'); create table key_value(key_id int not null references key_dimension(key_id), value int not null, primary key(key_id, value)); insert into key_value(key_id, value) select key_id, unnest(values) from key_dimension join data using (key); and now: select value from key_value where key_id = (select key_id from key_dimension where key = 'Red') intersect select value from key_value where key_id = (select key_id from key_dimension where key = 'Blue') So any queries to select key values need run only against the set of keys (key_dimension), and then a minimal synthetic key (key_id) is used to convert these to actual sets of data values (from key_value).
