[site]: stackoverflow
[post_id]: 3556953
[parent_id]: 
[tags]: 
IPC bottleneck?

I have two processes, a producer and a consumer. IPC is done with OpenFileMapping/MapViewOfFile on Win32. The producer receives video from another source, which it then passes over to the consumer and synchronization is done through two events. For the producer: Receive frame Copy to shared memory using CopyMemory Trigger DataProduced event Wait for DataConsumed event For the consumer Indefinitely wait for DataProducedEvent Copy frame to own memory and send for processing Signal DataConsumed event Without any of this, the video averages at 5fps. If I add the events on both sides, but without the CopyMemory, it's still around 5fps though a tiny bit slower. When I add the CopyMemory operation, it goes down to 2.5-2.8fps. Memcpy is even slower. I find hard to believe that a simple memory copy can cause this kind of slowdown. Any ideas on a remedy? Here's my code to create the shared mem: HANDLE fileMap = CreateFileMapping(INVALID_HANDLE_VALUE, 0, PAGE_READWRITE, 0, fileMapSize, L"foomap"); void* mapView = MapViewOfFile(fileMap, FILE_MAP_WRITE | FILE_MAP_READ, 0, 0, fileMapSize); The size is 1024 * 1024 * 3 Edit - added the actual code: On the producer: void OnFrameReceived(...) { // get buffer BYTE *buffer = 0; ... // copy data to shared memory CopyMemory(((BYTE*)mapView) + 1, buffer, length); // signal data event SetEvent(dataProducedEvent); // wait for it to be signaled back! WaitForSingleObject(dataConsumedEvent, INFINITE); } On the consumer: while(WAIT_OBJECT_0 == WaitForSingleObject(dataProducedEvent, INFINITE)) { SetEvent(dataConsumedEvent); } Well, it seems that copying from the DirectShow buffer onto shared memory was the bottleneck after all. I tried using a Named Pipe to transfer the data over and guess what - the performance is restored. Does anyone know of any reasons why this may be? To add a detail that I didn't think was relevant before: the producer is injected and hooks onto a DirectShow graph to retrieve the frames.
