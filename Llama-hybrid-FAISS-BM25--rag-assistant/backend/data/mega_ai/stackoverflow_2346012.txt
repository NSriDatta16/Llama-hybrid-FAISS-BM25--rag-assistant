[site]: stackoverflow
[post_id]: 2346012
[parent_id]: 2345354
[tags]: 
Since you say "or something else" in the Q's title -- if you choose to use ctypes , you can represent a void* with c_void_p (one of ctypes' fundamental data types , and access functions such as free and memcpy from the C runtime library (as long as the latter's available as a DLL / .so dynamic library, but that's true pretty widely these days). To get a mutable character buffer into which you can memcpy the data, use create_string_buffer . Of course you could alternatively use the Python C API -- PyByteArray_FromStringAndSize is what you'd use in this case to make a byte array copy from your void* and length (and of course you'd call free directly, when appropriate, since it's just C code anyway). Another possibility to consider is Cython , a Python-like language designed to write Python extensions and such that the Cython compiler can generate compilable C code from Cython sources - in Cython, your struct would be: cdef struct data: void* hdr void* data unsigned int* len assuming you don't want to go to the trouble of declaring header (i.e., that only data and len matter to you here) -- size_t , I believe, is not part of Cython at this time (I could be wrong, they do keep adding stuff;-), but unsigned int can probably do. Sorry, it's been too long since I used SWIG in earnest (what with all these excellent alternatives) -- I'd have skipped the Q were it not for that tempting "or something else" clause in the title;-).
