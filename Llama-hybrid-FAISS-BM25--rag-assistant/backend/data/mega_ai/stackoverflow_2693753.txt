[site]: stackoverflow
[post_id]: 2693753
[parent_id]: 
[tags]: 
Compiler turning a string& into a basic_string<>&

I'm coming back to C++ after long years spent on other technologies and i'm stuck on some weird behavior when calling some methods taking std::string as parameters : An example of call : LocalNodeConfiguration *LocalNodeConfiguration::ReadFromFile(std::string & path) { // ... throw configuration_file_error(string("Configuration file empty"), path); // ... } When I compile I get this (I cropped file names for readability) : /usr/bin/g++ -g -I/home/shtong/Dev/OmegaNoc/build -I/usr/share/include/boost-1.41.0 -o CMakeFiles/OmegaNocInternals.dir/configuration/localNodeConfiguration.cxx.o -c /home/shtong/Dev/OmegaNoc/source/configuration/localNodeConfiguration.cxx .../localNodeConfiguration.cxx: In static member function ‘static OmegaNoc::LocalNodeConfiguration* OmegaNoc::LocalNodeConfiguration::ReadFromFile(std::string&)’: .../localNodeConfiguration.cxx:72: error: no matching function for call to ‘OmegaNoc::configuration_file_error::configuration_file_error(std::string, std::basic_string , std::allocator >&)’ .../configurationManager.hxx:25: note: candidates are: OmegaNoc::configuration_file_error::configuration_file_error(std::string&, std::string&) .../configurationManager.hxx:22: note: OmegaNoc::configuration_file_error::configuration_file_error(const OmegaNoc::configuration_file_error&) So as I understand it, the compiler is considering that my path parameter turned into a basic_string at some point, thus not finding the constructor overload I want to use. But I don't really get why this transformation happened. Some search on the net suggested me to use g++ but I was already using it. So any other advice would be appreciated :) Thanks
