[site]: stackoverflow
[post_id]: 4093698
[parent_id]: 4074991
[tags]: 
Earlier I mentioned that I concocted, in Python, a hideous lambda expression to generate all subsets of a sequence using the bin() integer to binary string built-in function that they added in 2.6. Here's the uglier version of it: subsets = lambda s: ( (s[x] for x,c in enumerate("0" * (len(s)-len(bin(i)[2:])) + bin(i)[2:]) if int(c)) for i in range(0,2**len(s) ) ) But I noticed that I can replace the "0" * ... +" portion of that expression with a simple call to the string's zfill() method (thanks SO User: gimel ). So that becomes the slightly less odious: subsets = lambda s: ( [s[x] for x,c in enumerate(bin(i)[2:].zfill(len(s))) if int(c) ] for i in range(0,2**len(s)) ) This, despite its appearances, is a relatively simple implementation of what I described: given the binary string representing any integer from zero to the size of our set, mask out any of the elements corresponding to zeros in our binary string. That's the inner list comprehension. The outer (generator) expression simply covers the necessary range. The OP's approach of using itertools.permutations() with two arguments is more elegant. I might have thought of it if I'd known to look at the __doc__ string for that function. However, I did have to spend a little time convincing myself that both approaches give the same results.
