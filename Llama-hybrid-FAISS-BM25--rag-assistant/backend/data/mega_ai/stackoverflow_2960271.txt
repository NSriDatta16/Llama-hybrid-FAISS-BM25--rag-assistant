[site]: stackoverflow
[post_id]: 2960271
[parent_id]: 2909862
[tags]: 
The simplest way is to subclass Slider: public class CustomSlider : Slider { public override void OnPreviewMouseMove(MouseEventArgs e) { if(e.LeftButton == MouseButtonState.Pressed) OnPreviewMouseLeftButtonDown(e); } } In which case your XAML would be: For a more versatile solution that doesn't subclass Slider you can do it with an attached property: public class SliderTools : DependencyObject { public static bool GetMoveToPointOnDrag(DependencyObject obj) { return (bool)obj.GetValue(MoveToPointOnDragProperty); } public static void SetMoveToPointOnDrag(DependencyObject obj, bool value) { obj.SetValue(MoveToPointOnDragProperty, value); } public static readonly DependencyProperty MoveToPointOnDragProperty = DependencyProperty.RegisterAttached("MoveToPointOnDrag", typeof(bool), typeof(SliderTools), new PropertyMetadata { PropertyChangedCallback = (obj, changeEvent) => { var slider = (Slider)obj; if((bool)changeEvent.NewValue) slider.MouseMove += (obj2, mouseEvent) => { if(mouseEvent.LeftButton == MouseButtonState.Pressed) slider.RaiseEvent(new MouseButtonEventArgs(mouseEvent.MouseDevice, mouseEvent.Timestamp, MouseButton.Left) { RoutedEvent = UIElement.PreviewMouseLeftButtonDownEvent, Source = mouseEvent.Source, }); }; } }); } You would use this attached property on Slider along with the IsMoveToPointEnabled property: Both of these solutions work by converting PreviewMouseMove events into equivalent PreviewMouseLeftButtonDown events whenever the left button is down. Note that the attached property does not remove the event handler when the property is set to false. I wrote it this way for simplicity since you almost never would need to remove such a handler. I recommend you stick with this simple solution, but if you want you can modify the PropertyChangedCallback to remove the handler when NewValue is false.
