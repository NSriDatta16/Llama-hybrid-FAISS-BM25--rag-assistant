[site]: stackoverflow
[post_id]: 5666591
[parent_id]: 5666013
[tags]: 
Roy Osherove in his book, The Art of Unit Testing recommends naming conventions based on the behavior you're trying to test and not necessarily having a one-to-one mapping between production methods and test methods. So, as a simple example, assume I have a Stack class like so: public class Stack { public void Push(int value); public int Pop(); public bool IsEmpty(); } One way to write tests is to have three test methods: [TestMethod] public void PushTest [TestMethod] public void PopTest [TestMethod] public void IsEmptyTest However, there's a better way to test that specifies the behaviors of the Stack class. The idea then is that you have a one-to-one mapping between class behaviors and test methods. So, one behavior is that IsEmpty on an empty stack returns true. Another is that pushing one element makes the stack not empty. I'd then write tests in the Arrange/Act/Assert format according to these plain English sentences specifying these behaviors in the format: MethodName_StateOfTheObject_ExpectedResult So for the behaviors mentioned above: [TestMethod] IsEmpty_OnEmptyStack_ReturnsTrue [TestMethod] Push_OnEmptyStack_MakesStackNotEmpty I would encourage you to think about the behaviors you're trying to test in on the methods above and then map those behaviors to tests. For example: [TestMethod] ToList_OnEmptyString_ReturnsEmptyList [TestMethod] ToList_OnStringWithDelimiters_ReturnsListWithTokensSeparatedByDelemiter [TestMethod] ToList_OnStringWithoutDelimiters_ReturnsListWithOneString More information here
