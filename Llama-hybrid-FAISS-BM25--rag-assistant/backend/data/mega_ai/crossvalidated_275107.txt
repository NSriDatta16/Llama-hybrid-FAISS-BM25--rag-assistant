[site]: crossvalidated
[post_id]: 275107
[parent_id]: 275103
[tags]: 
When you fit an lmer model, you can use the coef() function to extract the coefficients from the model. Your code would look something like: mod1 Then you can call coef() and extract the coefficients for each group by specifying: coef(mod1)$Country This will give you a vector of intercepts (the '1' you specified in the random term) and slopes (for 'C02.Emissions'). You can then save each of these into their own vector: intercepts Instead of calling geom_smooth() , you could then specify specific slopes and intercepts by adding this to your plot: geom_abline(slope=slopes, intercept=intercepts) The positive of this is that it is using the model-implied slopes and intercepts. The downside is that it will extrapolate the lines beyond the values for each cluster (in this case, 'Country'). I would then add another geom_abline that is the average slope and intercept, which you can get from: summary(mod1)$coef Another way of doing this—that is not using the model-implied slopes and intercepts—is by specifying group=cluster . Using this, it fits a different OLS line for each cluster (which is not what the multilevel model fit with lmer() is doing, obviously). I've done this before, and it adapted to your variables would look something like: ggplot(datalong, aes(x=CO2.Emissions, y=GDP, group=Country))+ stat_smooth(method="lm", se=FALSE, size=.5, color="springgreen") + # slopes for different countries stat_smooth(aes(group=1), method="lm", color="blue", size=1.5) + # average slope with SE This might be slightly easier to do, but it will not match up with the model-implied slopes and intercepts you get from the coef(lmer(...))$cluster approach.
