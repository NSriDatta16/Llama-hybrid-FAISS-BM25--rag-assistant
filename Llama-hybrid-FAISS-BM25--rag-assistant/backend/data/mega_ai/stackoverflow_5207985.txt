[site]: stackoverflow
[post_id]: 5207985
[parent_id]: 
[tags]: 
S#arp Architecture: How to arrange Application Services

With S#arp Architecture , my understanding is that domain logic (aka business logic) that operates on more than one type of entity is best handled by the Application Services layer. So the classes in Application Services will need access to the Repositories. Presumably then you inject the Repositories in via the constructors. Because there is one class of repository per entity type, any fairly realistic task is going to need access to several repositories. So you might have an Application Services class looking like this: public class DogTasks { public DogTasks(IRepository dogRepository, IRepository trickRepository, IRepository dogTrickRepository, IRepository lessonRepository) { // etc } public void TeachDogNewTrickAtALesson(int dogID, string trickName, int lessonID) { // etc } // other methods, etc } This Tasks class can then be injected into the relevant Controller. So far, I think I get it. But I am perturbed by the following: When I need a new Application Services method that uses a combination of repositories that I don't have yet, I have to choose between changing the constructor for one of my existing classes to accept the new repositories, or starting a new class altogether. Adding arguments to constructors upsets a lot of the unit tests, but proliferating new classes doesn't seem good either. When Controllers need to do simple Repository operations (like a get ) it makes sense to inject the repositories into the Controllers as well as the Application Services classes. But then I get the same 'changing constructor arguments' issue. The other alternative seems to be to only let the Application Services layer play with the Repositories, but then you get a lot of boilerplate code added to the Application Services to do very simple things. These sorts of things make me think I might be doing it wrong. So how should a good Application Services layer be organised? e.g. Do you have lots of classes that just do one task each? Or do you clump related tasks together along entity lines? How do you deal with tasks that need a lot of repositories? Does needing a lot of repositories for a task mean its time to go back to the drawing board?
