[site]: stackoverflow
[post_id]: 4183458
[parent_id]: 4181106
[tags]: 
As RyuuGan already posted you should go with the BitArrary . You just put the data in it by calling the constructor with the wanted elements. byte[] myBytes = new byte[5] { 1, 2, 3, 4, 5 }; BitArray bitArray = new BitArray( myBytes ); Afterwards the instance has some interesting properties to easily access each bit. At first you can just call the index operator to get or set the state of each bit: bool bit = bitArray[4]; bitArray[2] = true; Also you can enumerate over all bits by just using a foreach loop (or any LINQ-stuff you like) foreach (var bit in bitArray.Cast ()) { Console.Write(bit + " "); } To get back from the bits to some specific type (e.g. int) is a little bit trickier, but is quite easy using this extension methods: public static class Extensions { public static IList GetBitsAs (this BitArray bits) where TResult : struct { return GetBitsAs (bits, 0); } /// /// Gets the bits from an BitArray as an IList combined to the given type. /// /// The type of the result. /// An array of bit values, which are represented as Booleans. /// The zero-based index in array at which copying begins. /// An read-only IList containing all bits combined to the given type. public static IList GetBitsAs (this BitArray bits, int index) where TResult : struct { var instance = default(TResult); var type = instance.GetType(); int sizeOfType = Marshal.SizeOf(type); int arraySize = (int)Math.Ceiling(((bits.Count - index) / 8.0) / sizeOfType); var array = new TResult[arraySize]; bits.CopyTo(array, index); return array; } } With this in place you can just get out of it with this single line of code: IList result = bitArray.GetBitsAs ();
