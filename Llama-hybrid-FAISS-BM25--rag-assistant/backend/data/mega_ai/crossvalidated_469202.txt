[site]: crossvalidated
[post_id]: 469202
[parent_id]: 469094
[tags]: 
If you're working with lots of time series, it is much easier to use tsibble objects than ts objects. Here is an example. library(tidyverse) library(tsibble) library(feasts) library(lubridate) library(stringr) set.seed(999) # Create data frame with 47 columns df This is just a random matrix of the same shape that you describe. Now we turn it into a tsibble object. df % mutate( Month = yearmonth(seq(as.Date("2016-01-01"), by = "1 month", length = NROW(df))) ) %>% pivot_longer(-Month, names_to = "Series", values_to = "value") %>% as_tsibble(index = Month, key = Series) df #> # A tsibble: 3,008 x 3 [1M] #> # Key: Series [47] #> Month Series value #> #> 1 2016 Jan a 0.754 #> 2 2016 Feb a 0.269 #> 3 2016 Mar a 2.21 #> 4 2016 Apr a 1.31 #> 5 2016 May a 0.758 #> 6 2016 Jun a 0.568 #> 7 2016 Jul a 0.153 #> 8 2016 Aug a 0.282 #> 9 2016 Sep a 0.380 #> 10 2016 Oct a 0.326 #> # … with 2,998 more rows You were using classical time series decomposition. A more reliable approach is an STL decomposition. This is additive, but we can compute multiplicative seasonal indices by applying it to the logged data. # Seasonal indices via STL decompositions stl_indices % model( STL(log(value) ~ season(window = "periodic")) ) %>% components() %>% # Turn into indices mutate( stl_index = exp(season_year) ) %>% select(Series, Month, stl_index) %>% # Pull out one year of indices group_by(Series) %>% filter(year(Month) == min(year(Month))) %>% ungroup() %>% # Give months names mutate(Month = month(Month, label = TRUE)) stl_indices #> # A tsibble: 564 x 3 [1] #> # Key: Series [47] #> Series Month stl_index #> #> 1 a Jan 0.989 #> 2 a Feb 1.42 #> 3 a Mar 1.62 #> 4 a Apr 0.687 #> 5 a May 1.11 #> 6 a Jun 1.17 #> 7 a Jul 1.23 #> 8 a Aug 0.586 #> 9 a Sep 0.938 #> 10 a Oct 1.07 #> # … with 554 more rows Something similar can be done using regression. The fable package uses TSLM as the equivalent to the tslm() function from the forecast package. # Seasonal indices via regression with trend and seasonal dummies reg_indices % # Fit models model( TSLM(log(value) ~ trend() + season()) ) %>% # Extract seasonal coefficients tidy(fit) %>% filter(str_detect(term, "season")) %>% # Add Month column mutate(Month = parse_number(term)) %>% # Add January 0 coefficient bind_rows(tibble(Series = unique(df$Series), Month = 1, estimate = 0)) %>% # Normalize around 0 group_by(Series) %>% mutate(estimate = estimate - mean(estimate)) %>% ungroup() %>% # Turn into indices mutate(reg_index = exp(estimate)) %>% # Give months names mutate(Month = month(Month, label = TRUE)) %>% select(Series, Month, reg_index) %>% arrange(Series, Month) We can combine both indices into one data frame to see that they are relatively close to each other in this case. The STL ones are generally going to be more reliable because they allow for nonlinear trends while the regression approach assumes a linear trend. # Combine both indices stl_indices %>% left_join(reg_indices) #> Joining, by = c("Series", "Month") #> # A tsibble: 564 x 4 [1] #> # Key: Series [47] #> Series Month stl_index reg_index #> #> 1 a Jan 0.989 0.978 #> 2 a Feb 1.42 1.43 #> 3 a Mar 1.62 1.66 #> 4 a Apr 0.687 0.712 #> 5 a May 1.11 1.10 #> 6 a Jun 1.17 1.15 #> 7 a Jul 1.23 1.20 #> 8 a Aug 0.586 0.578 #> 9 a Sep 0.938 0.929 #> 10 a Oct 1.07 1.07 #> # … with 554 more rows Created on 2020-05-29 by the reprex package (v0.3.0)
