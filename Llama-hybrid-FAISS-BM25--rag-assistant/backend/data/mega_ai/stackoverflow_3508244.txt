[site]: stackoverflow
[post_id]: 3508244
[parent_id]: 3507466
[tags]: 
Well, add a constructor with a parameter and a property into your controller and use DI (personally I like Ninject) to inject the correct repository implementation: public IEventsRepository _repo; public EventsController(IEventsRepository repository) { _repo = repository; } Wire (bind) the dependencies up in the global.asax.cs in Ninject application and site module (if you need expanded answer with that included, please let me know), then in your Edit action use the repository to get the Locations . Suppose you have the LoadLocations() method on your repository interface and concrete implementation of it in, for instance, SqlEventsRepository (implements IEventsRepository ), you do it simply by calling the method: public ActionResult Edit(Event id) { ... EventsEditModel model = new EventsEditModel(); _repo.GetInstance(id); model.Locations = _repo.LoadLocations(); ... } I am making this up because you have not provided too much information. And I don't know Automapper specifics when you want to load some additional data from the datastore prior to mapping the Entity to the ViewModel. Also you don't specify whether this Edit action is GET or POST , but I assume it is GET . Assuming that it's really GET , I don't know how can you load anything by providing the Entity to the action. Most commonly the GET methods use parameters of type string or int (most likely those are slugs or ids of somekind) and POST methos use parameters of type ViewModel (not Entity). So you POST method signature should be like this [HttpPost] public ActionResult Edit(EventsEditModel model)... I used to use Entities directly in my action signatures and was failing all the time, so I discourage it to others now. HTH
