[site]: stackoverflow
[post_id]: 4875462
[parent_id]: 4875289
[tags]: 
So why not simply write a swap template that does exactly that: swap the object representations*? There's many ways in which an object, once being constructed, can break when you copy the bytes it resides in. In fact, one could come up with a seemingly endless number of cases where this would not do the right thing - even though in practice it might work in 98% of all cases. That's because the underlying problem to all this is that, other than in C, in C++ we must not treat objects as if they are mere raw bytes . That's why we have construction and destruction, after all: to turn raw storage into objects and objects back into raw storage. Once a constructor has run, the memory where the object resides is more than only raw storage. If you treat it as if it weren't, you will break some types. However, essentially, moving objects shouldn't perform that much worse than your idea, because, once you start to recursively inline the calls to std::move() , you usually ultimately arrive at where built-ins are moved . (And if there's more to moving for some types, you'd better not fiddle with the memory of those yourself!) Granted, moving memory en bloc is usually faster than single moves (and it's unlikely that a compiler might find out that it could optimize the individual moves to one all-encompassing std::memcpy() ), but that's the price we pay for the abstraction opaque objects offer us. And it's quite small, especially when you compare it to the copying we used to do. You could, however, have an optimized swap() using std::memcpy() for aggregate types .
