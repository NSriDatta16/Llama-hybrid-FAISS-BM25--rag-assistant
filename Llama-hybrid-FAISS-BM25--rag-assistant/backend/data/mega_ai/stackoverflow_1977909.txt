[site]: stackoverflow
[post_id]: 1977909
[parent_id]: 1977629
[tags]: 
You can pass a unique value into the constructor for the first call (with new ) that signifies you don't want the initialiser called yet: var _NOINIT= {}; function factory(init) { function constr() { if (!(this instanceof constr)) { var inst= new constr(_NOINIT); init.apply(inst, arguments); return inst; } if (arguments[0]!==_NOINIT) init.apply(this, arguments); } return constr; } Note I've used a named inline function for the constructor because arguments.callee will be going away in ECMAScript Fifth Edition's ‘strict’ mode. However if you're using a class factory, I suggest making the initialiser function a member of the class, rather than being passed in. That way, you can subclass a base class and have the subclass inherit the initialiser, which is normal behaviour in class-based languages. eg.: Function.prototype.makeSubclass= function() { function constr() { var that= this; if (!(this instanceof constr)) that= new constr(_NOINIT); if (arguments[0]!==_NOINIT && '_init' in that) that._init.apply(that, arguments); return that; } if (this!==Object) constr.prototype= new this(_NOINIT); return constr; }; var Shape= Object.makeSubclass(); Shape.prototype._init= function(x, y) { this.x= x; this.y= y; }; var Point= Shape.makeSubclass(); // inherits initialiser(x, y), as no need for anything else in there var Circle= Shape.makeSubclass() Circle.prototype._init= function(x, y, r) { Shape.prototype._init.call(this, x, y); this.r= r; }; Of course you don't have to put that into the Function prototype... it's a matter of taste, really. As is allowing constructors without new . Personally I prefer to throw an error rather than silently make it work, to try to discourage bare-constructor-calling, since this is a mistake elsewhere and may make the code slightly less clear.
