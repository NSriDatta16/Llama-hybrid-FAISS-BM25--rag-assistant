[site]: stackoverflow
[post_id]: 5207993
[parent_id]: 767579
[tags]: 
The best way I found to handle this scenario is: create your library, naming it with the compiler and stl versions included in the library name, exactly like boost libraries do. examples: - FontManager-msvc10-mt.dll for dll version, specific for MSVC10 compiler, with the default stl. - FontManager-msvc10_stlport-mt.dll for dll version, specific for MSVC10 compiler, with the stl port. - FontManager-msvc9-mt.dll for dll version, specific for MSVC 2008 compiler, with the default stl - libFontManager-msvc10-mt.lib for static lib version, specific for MSVC10 compiler, with the default stl. following this pattern, you will avoid problems related with different stl implementations. remember, the stl implementation in vc2008 differs from the stl implementation in the vc2010. See your example using boost::config library: #include #ifdef BOOST_MSVC # pragma warning( push ) # pragma warning( disable: 4251 ) #endif class DLL_EXPORT FontManager { public: std::map int2string_map; } #ifdef BOOST_MSVC # pragma warning( pop ) #endif
