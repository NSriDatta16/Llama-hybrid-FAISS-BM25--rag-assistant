[site]: stackoverflow
[post_id]: 5086654
[parent_id]: 5086604
[tags]: 
Reflection is rotten way to inspect properties of a program. You can only "reflect" what the guy designing the compiler wired into the reflection machinery. That's usually not a lot (what reflection system do you know that will let you peer inside an expression?) and it depends on the language. And for something like C++, where you are trying to add reflection on top of the language essentially as set of APIs, you are going to be extremely limited, or you'll have to code in truly stilted style that lets you in effect declare the reflection data as standard data structures. You could instead use a program transformation engine (PTS) . Such an engine manipulates the complete program representation, and can thus technically answer any question which is answerable. In particular, it can in principle answer all the reflection questions you can imagine, because it acts as a substitute for the compiler, and can see everything the compiler sees. (In fact, it can see more than the compiler sees; the compiler is limited to one compilation unit at a time, and a good PTS can see an arbitrarily big set of compilation units concurrently, and can thus answer questions about the set as a whole). Our DMS Software Reengineering Toolkit can parse full (and many dialects of) C++, builts ASTs and accurate symbol tables. Using that, you can implement any static computable reflection, and then use that to produce analysis results or modify the ASTs directly. DMS is language agnostic; it can do this for a large variety of languages. Regarding actually using DMS to do "reflection": OP wanted to know how one might implement property getters and setters. With a PTS like DMS, you parse the source code of the class of interest, and then walk the AST for the code. For each data declaration inside the class, you literally manufacture a getter for that data, by building up the AST that represents the getter code; for tools like DMS, you can do this by composing patterns of C++ source code that are interpreted to represent the corresponding AST fragments, complete with placeholders you can fill in with other ASTs. Minor transformations can then modify the original AST to include the generated getters/setters; this produces an AST that contains the original code and the generated getters/setters. A final step is to regenerat code from the AST, which DMS does by using AST-to-source prettyprinters that are part of the "domain definition" (parser, prettyprinter, name resolver) that make up the language (e.g., C++) front end.
