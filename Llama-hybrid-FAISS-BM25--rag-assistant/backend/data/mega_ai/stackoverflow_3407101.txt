[site]: stackoverflow
[post_id]: 3407101
[parent_id]: 3406899
[tags]: 
You can't use generic constraints to express the limitations you are interested in. Generics are not meant to express variation based on disjoint types - they're meant to express variation that is unified over a hierarchy of types (or those implementing certain interfaces). You have a few alternative choices, however. Which you choose depends on the exact nature of what you're trying to do. Use differently named methods to express each operation. I tend to use this approach when each method is truly doing something different. You could argue that returning a different type of value from a method is essentially a different operation, and deserves its own unique name. float GetFloat(string attrName) { } string GetString(string attrName) { } Provide a "default value" to allow the type to be inferred. In many designs where you ask for a value by name it useful to supply a default value. This can allow you to employ overloading to differentiate between which method to invoke (based on the type of the default value). Unfortunately, this approach is quite fragile - and breaks easily when passing literal values to overloads that accept numeric primitives (int vs. uint vs. long). float GetValue(string attrName, float defaultValue) { ... } string GetValue(string attrName, string defaultValue) { ... } Use a generic method, but throw a runtime exception if the type isn't one of those you support. Personally I find this kind of ugly and in violation of the spirit of generics - generics should unify functionality over a hierarchy or a set of types implementing some interface. However, in some cases it makes sense to do so (if let's so one specific type cannot be supported, let's say). Another problem with this approach is that the signature of the generic method cannot be inferred from any parameters, so you would have to specify the type desired when calling it ... at which point it's not much better (from a syntax point of view) than having different method names. T GetValue ( string attrName ) { if( typeof(T) != typeof(string) || typeof(T) != typeof(float) ) throw new NotSupportedException(); return default(T); } // call it by specifying the type expected... float f = GetValue (attrName); string s = GetValue (attrName); Use an out parameter instead of a return value. This approach works well, but it loses the concise syntax of being able to call a method and act on a return value, since you first have to declare a variable to populate. void GetValue( string attrName, out float value ) void GetValue( string attrName, out string value ) // example of usage: float f; GetValue( attrName, out f ); string s; GetValue( attrName, out s );
