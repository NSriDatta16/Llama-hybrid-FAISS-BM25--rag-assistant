[site]: stackoverflow
[post_id]: 5513921
[parent_id]: 
[tags]: 
Memoization in Haskell using premade data structures

I find this answer and this wiki page to be excellent introductions to memoization in Haskell. They do, however, still leave me with a question that I hope to get answered: It seems to me that the technique used requires you to "open up" (as in "access the internals of") the data structure you use to store your memoization. For example, 1 implements a table structure and 2 implements a tree in section 3 . Is it possible to do something similar with a pre-made data structure? Suppose, for example, that you think that Data.Map is really awesome, and would like to store your memoized values in such a Map . Can one approach memoization with a pre-made data structure such as this, where one does not implement the structure itself, but rather use a pre-made one? Hopefully someone will give me a hint on how to think, or, perhaps more likely, correct my misunderstanding of functional memoization in general. Edit: I can think of one way to do it, but it's not at all elegant: If f :: a -> b , then one can probably easily make a memoized version f' :: Map a b -> a -> (Map a b, b) , where the first argument is the memoization storage, and the output pair contains a potentially updated storage and the computed value. This state-passing is certainly not what I want (although I guess it could be wrapped in a monad, but it's several orders of magnitudes uglier than the approach in 1 and 2 ). Edit 2: Maybe it helps to try and express my current way of (incorrect) thought. Currently, I seem to repeatedly pull myself, against my will, into the non-solution import qualified Data.Map as Map memo :: (Ord a) => [a] -> (a -> b) -> (a -> b) memo domain f = (Map.!) storage where storage = Map.fromList (zip domain (map f domain)) The more I stare at this, the more I realize I've misunderstood something basic. You see, it feels to me that my memo [True, False] is equivalent to the bool memoizer of 1 .
