[site]: stackoverflow
[post_id]: 4706626
[parent_id]: 
[tags]: 
FacebookOAuthException was unhandled

I'm new in these things and I've been testing the api ... and came to me a situation that is: if the user changes the password of Facebook the Access token is renewed ... and try to post the API Launches an exception and the application crashes... how to resolve this situation? try { FacebookApp app = new FacebookApp(FacebookToken); var args = new Dictionary (); args["message"] = "hi"; args["caption"] = "appcaption"; args["description"] = "appdescription"; args["name"] = "appname"; args["picture"] = "apppicture"; args["link"] = "applink"; app.ApiAsync((X) => { calback(X); }, null, "/me/feed", args, HttpMethod.Post); } catch (Exception ex) { Uri url = new Uri("/MyFacebook.xaml", UriKind.Relative); NavigationService.Navigate(url); } this is Api code, and it's crashing when throwing the OAuthExcepion at the line marked with "Exception HERE" private static void ResponseCallback(IAsyncResult asyncResult, FacebookAsyncCallback callback, object state) { object result = null; FacebookApiException exception = null; try { var request = (HttpWebRequest)asyncResult.AsyncState; var response = (HttpWebResponse)request.EndGetResponse(asyncResult); using (Stream responseStream = response.GetResponseStream()) { result = JsonSerializer.DeserializeObject(responseStream); } } catch (FacebookApiException) { // Rest API Errors throw; } catch (WebException ex) { // Graph API Errors or general web exceptions exception = ExceptionFactory.GetGraphException(ex); if (exception != null) { // Thow the FacebookApiException throw exception; } throw; //Exception HERE } finally { // Check to make sure there hasn't been an exception. // If there has, we want to pass null to the callback. object data = null; if (exception == null) { data = result; } #if SILVERLIGHT callback(new FacebookAsyncResult(data, state, null, asyncResult.CompletedSynchronously, asyncResult.IsCompleted, exception)); #else callback(new FacebookAsyncResult(data, state, asyncResult.AsyncWaitHandle, asyncResult.CompletedSynchronously, asyncResult.IsCompleted, exception)); #endif } } thanks
