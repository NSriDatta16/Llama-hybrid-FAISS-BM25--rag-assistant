[site]: stackoverflow
[post_id]: 1828879
[parent_id]: 1828708
[tags]: 
Like most tools, you get out of them what you put in. Modern IDEs are complex and complex tools take time to learn. Drag and Drop and Auto-Generated code aren't horribly usefull - in my opinion - but there are many features that can do wonders for efficiency. The modern IDE isn't just about writing and compiling code anymore. The tools are designed to support the entire development life cycle from design to code to change control to testing ... and on ... and on ... and on. At the end of the day, the best tool is one that you are confortable with and that you know how to use. If you don't want to or need to use the features that and big-ol-IDE offers, then the IDE isn't much use. If you do want to or need to use them, then the big IDE is a wonderful thing. Like everything, there are tradeoffs - the modern IDE tends to be a resouce hog and they take longer to learn, but in exchange, you can get some great tools. Most new IDEs offer some flavor of the following ... Solution explorer - easly work and navigate across multiple projects efficiently integrated source control - don't have to work with external source control IDE debugger/watches - no need to add silly tracers directly into the code to monitor state; just step through the code code refactoring - rename variables and find all references to the renamed variables and change them as well ... or pull out whole chunks of code and encapsulate them into a private method debug/assertion output - interfaces for displaying assertion results integrated modeling/UML - view visual models of your code and keep them tightly integrated with your code so that the model is always consistent with changes made to the source code. intellisense and auto-complete - saves a lot of key strokes (though some would argue it also promotes laziness, but ... well ... code responsibly) macros - for performing repetitive tasks compile errors - presented in an easy to read manner code analysis tools - policy checking, cylomatic code complexity, call depth, coupling analysis - good stuff multi-file/project find/replace - because sometimes you just have search for things are change them ... a lot of them. rich editing - having an IDE that can cleanly format and color code your code ... and do it well, can be fabulous
