[site]: stackoverflow
[post_id]: 5498680
[parent_id]: 5488874
[tags]: 
Here's a BeanFactoryPostProcessor sample implementation that may help you here: class CollaboratorsFinder implements BeanFactoryPostProcessor { private final Object bean; private final Set collaborators = new HashSet (); CollaboratorsFinder(Object bean) { if (bean == null) { throw new IllegalArgumentException("Must pass a non-null bean"); } this.bean = bean; } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { for (String beanName : BeanFactoryUtils.beanNamesIncludingAncestors(beanFactory)) { BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName); if (beanDefinition.isAbstract()) { continue; // assuming you're not interested in abstract beans } // if you know that your bean will only be injected via some setMyBean setter: MutablePropertyValues values = beanDefinition.getPropertyValues(); PropertyValue myBeanValue = values.getPropertyValue("myBean"); if (myBeanValue == null) { continue; } if (bean == myBeanValue.getValue()) { collaborators.add(beanName); } // if you're not sure the same property name will be used, you need to // iterate through the .getPropertyValues and look for the one you're // interested in. // you can also check the constructor arguments passed: ConstructorArgumentValues constructorArgs = beanDefinition.getConstructorArgumentValues(); // ... check what has been passed here } } public Set getCollaborators() { return collaborators; } } Of course, there's a lot more to it (if you want to also catch proxies of your original bean or whatever). And, of course, the above code is completely untested. EDIT: To make use of this, you need to declare it as a bean in your application context. As you already noticed, it requires your bean (the one you want to monitor) to be injected into it (as a constructor-arg). As your question refers to the "bean hiearchy", I edited to look for the bean names in the entire hierarcy ...IncludingAncestors . Also, I assumed your bean is a singleton and that it is possible to inject it into the postprocessor (although in theory the postProcessor should be initialized before other beans -- need to see if this actually works).
