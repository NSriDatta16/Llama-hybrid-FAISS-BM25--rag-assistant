[site]: stackoverflow
[post_id]: 3049762
[parent_id]: 1694529
[tags]: 
There are several ways you could handle this. My favorite is to override hitTest:withEvent: in a view that is a common superview (maybe indirectly) to the conflicting views (sounds like you call these A and B). For example, something like this (here A and B are UIView pointers, where B is the "hidden" one, that is normally ignored): - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { CGPoint pointInB = [B convertPoint:point fromView:self]; if ([B pointInside:pointInB withEvent:event]) return B; return [super hitTest:point withEvent:event]; } You could also modify the pointInside:withEvent: method as gyim suggested. This lets you achieve essentially the same result by effectively "poking a hole" in A, at least for touches. Another approach is event forwarding, which means overriding touchesBegan:withEvent: and similar methods (like touchesMoved:withEvent: etc) to send some touches to a different object than where they first go. For example, in A, you could write something like this: - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { if ([self shouldForwardTouches:touches]) { [B touchesBegan:touches withEvent:event]; } else { // Do whatever A does with touches. } } However, this will not always work the way you expect! The main thing is that built-in controls like UIButton will always ignore forwarded touches. Because of this, the first approach is more reliable. There's a good blog post explaining all this in more detail, along with a small working xcode project to demo the ideas, available here: http://bynomial.com/blog/?p=74
