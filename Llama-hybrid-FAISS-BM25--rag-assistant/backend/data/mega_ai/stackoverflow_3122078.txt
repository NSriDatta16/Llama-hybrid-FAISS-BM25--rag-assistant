[site]: stackoverflow
[post_id]: 3122078
[parent_id]: 3097753
[tags]: 
I am quite certain that your problem results from the way you are interpolating angles. Here's an interpolation function (written in python) that should do the trick. It is based on a suggestion from the xna forums thread Shortest 2D Angle Interpolation . def wrap(value, lower, upper): distance = upper - lower return value - ((value-lower)//distance)*distance def shortestangle(a,b): angle = wrap(b-a, 0, 360) if angle>=180: angle -= 360 return angle def interpolate(a,b,amount): return (a+shortestangle(a,b)*amount)%360 Now, interpolate(originalHue,hue,amount) should produce the desired result. Edit: It is my understanding that your goal is to rotate the original hue towards a certain target hue by some given amount. I'm sure you're already familiar with this, but for the sake of illustration, here's a color wheel. (source: sapdesignguild.org ) The problem is that mixing (or interpolating) two angles is not trivial, so code like hue = ((hue - originalHue) * amount) + originalHue will not work. There is an infinite number of ways you can go from one angle to another because of the wraparound at 360°. To get from 0° to 60° you could rotate 60° counter-clockwise, 420° counter-clockwise, 300° clockwise etc. Usually the shortest angle is the desired one. For example, lets consider the penguin necks: if your original hue is 30° (orange), your target is 240° (blue) and the amount is 50%, you would get the following results: //Linear Interpolation (30° + (240° - 30°)*0.5) = 135° (green) //"Shortest 2D Angle Interpolation" (30° + shortestangle(30°,240°)*0.5) % 360 = (30° + (-150°)*0.5) % 360 = 315° (magenta) My guess is that the second result is the one you are looking for, but I may be wrong and the error could be somewhere else entirely...
