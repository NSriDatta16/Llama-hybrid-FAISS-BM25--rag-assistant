[site]: stackoverflow
[post_id]: 2312931
[parent_id]: 2312860
[tags]: 
The copying and lack of "string literal optimization" is just how std::strings work, and you cannot get exactly what you're asking for. Partially this is because virtual methods and dtor were explicitly avoided. The std::string interface is plenty complicated without those, anyway. The standard requires a certain interface for both std::string and std::map, and those interfaces happen to disallow the optimization you'd like (as "unintended consequence" of its other requirements, rather than explicitly). At least, they disallow it if you want to actually follow all the gritty details of the standard. And you really do want that, especially when it is so easy to use a different string class for this specific optimization. However, that separate string class can solve these "problems" (as you said, it's rarely an issue), but unfortunately the world has number_of_programmers + 1 of those already. Even considering that wheel reinvention, I have found it useful to have a StaticString class, which has a subset of std::string's interface: using begin/end, substr, find, etc. It also disallows modification (and fits in with string literals that way), storing only a char pointer and a size. You have to be slightly careful that it's only initialized with string literals or other "static" data, but that is somewhat mitigated by the construction interface: struct StaticString { template explicit StaticString(char (&data)[N]); // reference to char array StaticString(StaticString const&); // copy ctor (which is very cheap) static StaticString from_c_str(char const* c_str); // static factory function // this only requires that c_str not change and outlive any uses of the // resulting object(s), and since it must also be called explicitly, those // requirements aren't hard to enforce; this is provided because it's explicit // that strlen is used, and it is not embedded-'\0'-safe as the // StaticString(char (&data)[N]) ctor is operator char const*() const; // implicit conversion "operator" // here the conversion is appropriate, even though I normally dislike these private: StaticString(); // not defined }; Use: StaticString s ("abc"); assert(s != "123"); // overload operators for char* some_func(s); // implicit conversion some_func(StaticString("abc")); // temporary object initialized from literal Note the primary advantage of this class is explicitly to avoid copying string data, so the string literal storage can be reused. There's a special place in the executable for this data, and it is generally well optimized as it dates back from the earliest days of C and beyond. In fact, I feel this class is close to what string literals should've been in C++, if it weren't for the C compatibility requirement. By extension, you could also write your own map class if this is a really common scenario for you, and that could be easier than changing string types.
