[site]: stackoverflow
[post_id]: 1868987
[parent_id]: 1861654
[tags]: 
Just responding to this: Even in-lined functions (other than as required by classes) is a highly debatable practice. In theory, it creates faster, but larger code (avoids function calls and returns by duplicating code). However, several people have noticed that often using in-lining actually creates slower code. The reason why is because it can cause the code to get larger and exceed the size of what fits in one or more caches used at run-time. As a result it causes portions of the function to go in and out of cache every pass through some loop and the cache misses and subsequent reloads are far more costly than a function call to something already in another cache page. It’s an interesting situation and one that can’t be predicted, only observed by trial and error. Your colleague seems to be willing to throw out a perfectly good technique altogether because in some cases it can mess with instruction cache efficiency. Most programs running on most systems don't require much micromanagement of the instruction cache. In the common case, you're far more likely to get a performance gain out of inlining than you are out of this kind of micromanagement. Plus the compiler will inline for you anyway unless you specifically disable it. There's a lesson here, and it's that you should pay very close attention to what your compiler does with performance-intensive code. But for the other 80% of your code, the compiler will normally do the right thing on its own. (Also it's probably worth pointing out that inlined code will not always be larger than the original code. I've often observed this to be the case with heavy floating point or SIMD code.)
