[site]: stackoverflow
[post_id]: 3220819
[parent_id]: 3205819
[tags]: 
The exact parallel of a bezier curve is quite ugly from a mathematical point of view (it requires 10th-degree polynomials). What is easy to do is compute a widening from a polygonal approximation of the bezier (that is you compute line segments from the bezier and then move the points along the normals on the two sides of the curve). This gives good results if your thickness isn't too big compared to the curvature... a "far parallel" instead is a monster on its own (and it's not even easy to find a definition of what is a parallel of an open curve that would make everyone happy). Once you have two polylines for the two sides what you can do is finding a best approximating bezier for those paths if you need that representation. Once again I think that for "normal cases" (that is reasonably thin lines) even just a single bezier arc for each of the two sides should be quite accurate (the error should be much smaller than the thickness of the line). EDIT : Indeed using a single bezier arc looks much worse than I would have expected even for reasonably normal cases. I tried also using two bezier arcs for each side and the result are better but still not perfect. The error is of course much smaller than the thickness of the line so unless lines are very thick it could be a reasonable option. In the following picture it's shown a thickened bezier (with per-point thickening), an approximation using a single bezier arc for each side and an approximation using two bezier arcs for each side. EDIT 2 : As requested I add the code I used to get the pictures; it's in python and requires only Qt. This code wasn't meant to be read by others so I used some tricks that probably I wouldn't use in real production code. The algorithm is also very inefficient but I didn't care about speed (this was meant to be a one-shot program to see if the idea works). # # This code has been written during an ego-pumping session on # www.stackoverflow.com, while trying to reply to an interesting # question. Do whatever you want with it but don't blame me if # doesn't do what *you* think it should do or even if doesn't do # what *I* say it should do. # # Comments of course are welcome... # # Andrea "6502" Griffini # # Requirements: Qt and PyQt # import sys from PyQt4.Qt import * QW = QWidget bezlevels = 5 def avg(a, b): """Average of two (x, y) points""" xa, ya = a xb, yb = b return ((xa + xb)*0.5, (ya + yb)*0.5) def bez3split(p0, p1, p2,p3): """ Given the control points of a bezier cubic arc computes the control points of first and second half """ p01 = avg(p0, p1) p12 = avg(p1, p2) p23 = avg(p2, p3) p012 = avg(p01, p12) p123 = avg(p12, p23) p0123 = avg(p012, p123) return [(p0, p01, p012, p0123), (p0123, p123, p23, p3)] def bez3(p0, p1, p2, p3, levels=bezlevels): """ Builds a bezier cubic arc approximation using a fixed number of half subdivisions. """ if levels limit: best = None for dx1 in (-step, 0, step): for dy1 in (-step, 0, step): for dx2 in (-step, 0, step): for dy2 in (-step, 0, step): e = err(x0, y0, x1+dx1, y1+dy1, x2+dx2, y2+dy2, x3, y3) if best is None or e refine step *= 0.5 else: # We're still moving x1 += dx1 y1 += dy1 x2 += dx2 y2 += dy2 return [(x0, y0), (x1, y1), (x2, y2), (x3, y3)] def poly(pts): "Converts a list of (x, y) points to a QPolygonF)" return QPolygonF(map(lambda p: QPointF(*p), pts)) class Viewer(QW): def __init__(self, parent): QW.__init__(self, parent) self.pts = [(100, 100), (200, 100), (200, 200), (100, 200)] self.tracking = None # Mouse dragging callback self.ibez = 0 # Thickening algorithm selector def sizeHint(self): return QSize(900, 700) def wheelEvent(self, e): # Moving the wheel changes between # - original polygonal thickening # - single-arc thickening # - double-arc thickening self.ibez = (self.ibez + 1) % 3 self.update() def paintEvent(self, e): dc = QPainter(self) dc.setRenderHints(QPainter.Antialiasing) # First build the curve and the polygonal thickening pts = bez3(*self.pts) l1, l2 = thickPath(pts, 15) # Apply inverse bezier computation if requested if self.ibez == 1: # Single arc l1 = bez3(*ibez(l1)) l2 = bez3(*ibez(l2)) elif self.ibez == 2: # Double arc l1 = (bez3(*ibez(l1[:len(l1)/2+1], bezlevels-1)) + bez3(*ibez(l1[len(l1)/2:], bezlevels-1))[1:]) l2 = (bez3(*ibez(l2[:len(l2)/2+1], bezlevels-1)) + bez3(*ibez(l2[len(l2)/2:], bezlevels-1))[1:]) # Draw results dc.setBrush(QBrush(QColor(0, 255, 0))) dc.drawPolygon(poly(l1 + l2[::-1])) dc.drawPolyline(poly(pts)) dc.drawPolyline(poly(self.pts)) # Draw control points dc.setBrush(QBrush(QColor(255, 0, 0))) dc.setPen(QPen(Qt.NoPen)) for x, y in self.pts: dc.drawEllipse(QRectF(x-3, y-3, 6, 6)) # Display the algorithm that has been used dc.setPen(QPen(QColor(0, 0, 0))) dc.drawText(20, 20, ["Polygonal", "Single-arc", "Double-arc"][self.ibez]) def mousePressEvent(self, e): # Find closest control point i = min(range(len(self.pts)), key=lambda i: (e.x() - self.pts[i][0])**2 + (e.y() - self.pts[i][1])**2) # Setup a callback for mouse dragging self.tracking = lambda p: self.pts.__setitem__(i, p) def mouseMoveEvent(self, e): if self.tracking: self.tracking((e.x(), e.y())) self.update() def mouseReleaseEvent(self, e): self.tracking = None # Qt boilerplate class MyDialog(QDialog): def __init__(self, parent): QDialog.__init__(self, parent) self.ws = Viewer(self) L = QVBoxLayout(self) L.addWidget(self.ws) self.setModal(True) self.show() app = QApplication([]) aa = MyDialog(None) aa.exec_() aa = None
