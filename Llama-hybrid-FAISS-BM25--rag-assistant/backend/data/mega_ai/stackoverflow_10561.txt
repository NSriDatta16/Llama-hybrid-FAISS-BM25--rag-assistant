[site]: stackoverflow
[post_id]: 10561
[parent_id]: 9750
[tags]: 
Since the question asked for a non-C way, here's a Scheme implementation, cheerfully plagiarised from SLIB : (define (bit-reverse k n) (do ((m (if (negative? n) (lognot n) n) (arithmetic-shift m -1)) (k (+ -1 k) (+ -1 k)) (rvs 0 (logior (arithmetic-shift rvs 1) (logand 1 m)))) ((negative? k) (if (negative? n) (lognot rvs) rvs)))) (define (reverse-bit-field n start end) (define width (- end start)) (let ((mask (lognot (ash -1 width)))) (define zn (logand mask (arithmetic-shift n (- start)))) (logior (arithmetic-shift (bit-reverse width zn) start) (logand (lognot (ash mask start)) n)))) Rewritten as C (for people unfamiliar with Scheme), it'd look something like this (with the understanding that in Scheme, numbers can be arbitrarily big): int bit_reverse(int k, int n) { int m = n = 0) { rvs = (rvs >= 1; } return n > start); return (bit_reverse(width, zn)
