[site]: stackoverflow
[post_id]: 1533116
[parent_id]: 1532826
[tags]: 
As some people have said, the answers are: Threads on cores - Yes. Java has had support for native threads for a long time. Most OSes have provided kernel threads which automagically get scheduled to any CPUs you have (implementation performance may vary by OS). The simple answer is it will be safe in general. The more complex answer is that you have to ensure that your Object is actually created & initialized before any threads can access it. This is solved one of two ways: Let the class loader solve the problem for you using a Singleton (and lazy class loading): public class MyImmutableObject { private static class MyImmutableObjectInstance { private static final MyImmutableObject instance = new MyImmutableObject(); } public MyImmutableObject getInstance() { return MyImmutableObjectInstance.instance; } } Explicitly using acquire/release semantics to ensure a consistent memory model: MyImmutableObject foo = null; volatile bool objectReady = false; // initializer thread: .... /// create & initialize object for use by multiple threads foo = new MyImmutableObject(); foo.initialize(); // release barrier objectReady = true; // start worker threads public void run() { // acquire barrier if (!objectReady) throw new IllegalStateException("Memory model violation"); // start using immutable object foo } I don't recall off the top of my head how you can exploit the memory model of Java to perform the latter case. I believe, if I remember correctly, that a write to a volatile variable is equivalent to a release barrier, while a read from a volatile variable is equivalent to an acquire barrier. Also, the reason for making the boolean volatile as opposed to the object is that access of a volatile variable is more expensive due to the memory model constraints - thus, the boolean allows you to enforce the memory model & then the object access can be done much faster within the thread. As mentioned, there's all sorts of RPC mechanisms. There's also RMI which is a native approach for running code on remote targets. There's also frameworks like Hadoop which offer a more complete solution which might be more appropriate. For calling native code, it's pretty ugly - Sun really discourages use by making JNI an ugly complicated mess, but it is possible. I know that there was at least one commercial Java framework for loading & executing native dynamic libraries without needing to worry about JNI (not sure if there are any free or OSS projects). Good luck.
