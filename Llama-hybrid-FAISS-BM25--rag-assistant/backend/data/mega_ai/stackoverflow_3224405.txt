[site]: stackoverflow
[post_id]: 3224405
[parent_id]: 
[tags]: 
Std::vector fill time goes from 0ms to 16ms after a certain threshold?

Here is what I'm doing. My application takes points from the user while dragging and in real time displays a filled polygon. It basically adds the mouse position on MouseMove. This point is a USERPOINT and has bezier handles because eventually I will do bezier and this is why I must transfer them into a vector. So basically MousePos -> USERPOINT. USERPOINT gets added to a std::vector . Then in my UpdateShape() function, I do this: DrawingPoints is defined like this: std::vector > DrawingPoints; Contour[i].DrawingPoints.clear(); for(unsigned int x = 0; x SetCubicBezier() currently looks like this: void OGLSHAPE::SetCubicBezier(USERFPOINT &a,USERFPOINT &b, int &currentcontour ) { std::vector temp(2); if(a.RightHandle.x == a.UserPoint.x && a.RightHandle.y == a.UserPoint.y && b.LeftHandle.x == b.UserPoint.x && b.LeftHandle.y == b.UserPoint.y ) { temp[0] = (GLdouble)a.UserPoint.x; temp[1] = (GLdouble)a.UserPoint.y; Contour[currentcontour].DrawingPoints.push_back(temp); temp[0] = (GLdouble)b.UserPoint.x; temp[1] = (GLdouble)b.UserPoint.y; Contour[currentcontour].DrawingPoints.push_back(temp); } else { //do cubic bezier calculation } So for the reason of cubic bezier, I need to make USERPOINTS into GlDouble[2] (since GLUTesselator takes in a static array of double. So I did some profiling. At ~ 100 points, the code: for(unsigned int x = 0; x Took 0 ms to execute. then around 120, it jumps to 16ms and never looks back. I'm positive this is due to std::vector. What can I do to make it stay at 0ms. I don't mind using lots of memory while generating the shape then removing the excess when the shape is finalized, or something like this.
