[site]: stackoverflow
[post_id]: 2459783
[parent_id]: 2459762
[tags]: 
You should be able to pass an instance of SqlBytes as a parameter to a SqlCommand wherever a varbinary is needed. That same SqlBytes class has a constructor overload that wraps a Stream . So simply create a SqlBytes instance from the stream, then pass that in as the parameter value. In other words, fitting that into your revised code, instead of this: MemoryStream _MemoryStream = new System.IO.MemoryStream(); _Image.Save(_MemoryStream, _ImageFormat); SqlParameter _SqlParameter = new SqlParameter("@" + _ImageFieldName, SqlDbType.Image); _SqlParameter.Value = _MemoryStream.ToArray(); _SqlCommand.Parameters.Add(_SqlParameter); Use this: MemoryStream _MemoryStream = new System.IO.MemoryStream(); _Image.Save(_MemoryStream, _ImageFormat); _MemoryStream.Position = 0; // I *think* you need this SqlParameter _SqlParameter = new SqlParameter("@" + _ImageFieldName, SqlDbType.VarBinary); _SqlParameter.Value = new SqlBytes(_MemoryStream); _SqlCommand.Parameters.Add(_SqlParameter); Of course, don't forget to dispose the MemoryStream and all these other IDisposable instances after the command has been executed. Edit: OK, I just saw the bottom of your edit, which is implying that the data is extremely large and you don't want it to end up in memory, and this won't actually solve that problem. Thing is, if the value is that big, it's a bad idea to be storing it in a varbinary column in the first place. If you're using SQL Server 2008, you can (and should!) use FILESTREAM instead. This actually does support "true" streaming in ADO.NET through the SqlFileStream class. If you can't use FILESTREAM storage, then I'm afraid you're going to have to deal with the data being in memory at some point in time, that's pretty much how ADO.NET works.
