[site]: stackoverflow
[post_id]: 5627622
[parent_id]: 5623910
[tags]: 
Manually The simplest thing that you can do is just roll the code manually, I don't think that there is much that can be used to your advantage from the templates, so I will use plain classes, where A , B ... stand for particular instantiations of your types. That allows for compile time initialization of the types, at the cost of having to remember to update the lookup table whenever a new type is added to the system: typedef void (*function_t)(); function_t func[] = { &A::f, &B::f, &C::f }; I would recommend this, from a maintenance point of view. Automating the system will make the code much harder to understand and maintain in the future. Macros The simple most automated one, which will probably generate less code is a macro generation system is just using macros. Since this first approach will use extensive use of macros, I will generate the functions automatically, as you did in the previous question. You can remove that part of code if you have (hopefully) given up the path of full code generation through macros. To avoid having to retype the names of the types in different contexts you can define a macro with all the data you need for any context, and then use other macros to filter what is to be used (and how) in each particular context: // This is the actual list of all types, the id and the code that you were // generating in the other question for the static function: #define FOREACH_TYPE( macro ) \ macro( A, 0, { std::cout This is, on the other hand a maintenance nightmare, quite fragile and hard to debug. Adding new types is trivial, just add a new line to the FOREACH_TYPE macro and you are done... and the best of lucks once something fails... Templates and metaprogramming On the other hand, using templates you can get close but you cannot get to the single point of definition for the types. You can automate some of the operations in different ways, but at the very least you will need to define the types themselves and add them to a typelist to get the rest of the functionality. Simplifying the definition of the actual type_list with C++0x code you can start by defining the types and then creating the type_list . If you want to avoid using C++0x, then take a look at the Loki library, but with C++0x a type list is simple enough: template type_list {}; // generic type list typedef type_list types; // our concrete list of types A, B, C and D // this is the only source of duplication: // types must be defined and added to the // type_list manually [*] Now we need to use some metaprogramming to operate on the type list, we can for example count the number of elements in the list: template struct size; // declare template // general case (recursion) struct size > { static const int value = 1 + size ::value; }; template <> // stop condition for the recursion struct size > { static const int value = 0; }; Having the size of the type list is a first step in our problem, as it allows us to define an array of functions: typedef void (*function_t)(); // signature of each function pointer struct registry { static const int size = ::size ::value; static const function_t table[ size ]; }; function_t registry::table[ registry::size ]; // define the array of pointers Now we want to register the static functions from each particular type in that array, and for that we create an auxiliar function (encapsulated as a static function in a type to allow for partial specializations). Note that this concrete part is designed to be run during initialization: it will NOT be compile time, but the cost should be trivial (I would be more worried on the binary size with all the templates): template // declaration struct register_types_impl; template // general recursion case struct register_types_impl , N> { static int apply() { registry::table[ N ] = &T::f; // register function pointer return register_types_impl , N+1 >; } }; template // stop condition struct register_types_impl , int N> { static int apply() { return N; } }; // and a nicer interface: int register_types() { register_types_impl (); } Now we need an id function that maps our types to the function pointer, which in our case is the position of the type in the type list template // same old, same old... declaration struct id_impl; template struct id_impl , N > { // general recursion static const int value = id_impl , N+1 >; }; template // stop condition 1: type found struct id_impl , N> { static const int value = N; }; template // stop condition 2: type not found struct id_impl , N> { static const int value = -1; } // and a cleaner interface template struct id { static const int value = id_impl ::value; }; Now you just need to trigger the registration at runtime, before any other code: int main() { register_types(); // this will build the lookup table } [*] Well... sort of, you can use a macro trick to reuse the types, as the use of macros is limited, it will not be that hard to maintain/debug.
