[site]: stackoverflow
[post_id]: 3939963
[parent_id]: 3939867
[tags]: 
If it only requires pointer, you can allocate some unmanaged memory, marshal the structure to the memory, and pass that pointer to your function. Then afterwards you could marshal back to the structure (if you wish) and free the memory. Before you marshal anything, you need to properly define the structure. Something like this: [StructLayout( LayoutKind.Sequential, //must specify a layout CharSet = CharSet.Ansi)] //if you intend to use char public struct ToBePassed { public Int32 Num1; public Int32 Num2; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 255)] public Char[] Data; //specify the size using MarshalAs } [DllImport("...")] public static extern void APICall(IntPtr argPtr); public static void CallFunction(ToBePassed managedObj) { IntPtr unmanagedAddr = Marshal.AllocHGlobal(Marshal.SizeOf(managedObj)); Marshal.StructureToPtr(managedObj, unmanagedAddr, true); APICall(unmanagedAddr); Marshal.PtrToStructure(unmanagedAddr, managedObj); Marshal.FreeHGlobal(unmanagedAddr); unmanagedAddr = IntPtr.Zero; } [edit] To simulate variable length arrays, allocate unmanaged memory within the structure and initialize as usual. [StructLayout(LayoutKind.Sequential)] public struct SomeStruct { public Int32 X; public Int32 Y; } [StructLayout(LayoutKind.Sequential)] public struct VLA { public Int32 intArrayLength; public Int32 SomeStructArrayLength; public IntPtr intArray; public IntPtr SomeStructArray; } public static VLA CreateVLA(int[] intArray, SomeStruct[] SomeStructArray) { var vla = new VLA() { intArrayLength = intArray.Length, SomeStructArrayLength = SomeStructArray.Length, intArray = Marshal.AllocHGlobal(intArray.Length * Marshal.SizeOf(typeof(int))), SomeStructArray = Marshal.AllocHGlobal(SomeStructArray.Length * Marshal.SizeOf(typeof(SomeStruct))), }; Marshal.Copy(intArray, 0, vla.intArray, intArray.Length); //there's no overload to copy arbitrary arrays, do it manually for (int i = 0; i
