[site]: stackoverflow
[post_id]: 4628411
[parent_id]: 4628046
[tags]: 
I have 2 repositories: public class UserRepository : IUserRepository { public IQueryable GetUsers(); } public class PostRepository : IPostRepository { public IQueryable GetPosts(); } This is likely to become problematic. You likely don't want to simply GetUsers . As you say, you want child entities loaded with the aggregate, or top-level, entity. What will occur is that depending on the context of use - what your immediate purpose is - you will want variations on that User . You'll likely end up with methods like GetUsers , ' GetUsersWithPosts , GetUsersForImportantReport , GetUsersForAttendingAnIceCreamSocial , etc., etc., ad nauseam. What's missing is the concept of a role. What role are you retrieving the User for? Model that explicitly here. Start with a base interface for your aggregate. Basic properties can go here public interface IUser { public Guid UserId { get; set; } public string UserName { get; set; } public IEnumerable { get; set; } } Add interfaces to support the roles in which you will use the user. public interface IAddPostsToUser : IUser { public void AddPost(Post post); } And your repository can be defined as such: public interface IUserRepository { User Get (Guid userId) where TRole : IUser; } Now, use that role to define a fetching strategy; public interface IFetchingStrategy { TRole Fetch(Guid id, IRepository role) } Your repository would get the fetching strategies through injection or service location and call fetch. You can pass the repository in to provide the mechanism for the FetchingStrategy to query or have the FetchingStrategy inject or locate what services it needs to query. Of course, exactly how you query will depend on your ORM. But this way of modeling will help avoid many problems with loading entity graphs in different scenarios.
