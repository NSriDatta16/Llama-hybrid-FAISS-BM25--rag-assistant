[site]: stackoverflow
[post_id]: 5670424
[parent_id]: 5669217
[tags]: 
You should definitely use Common Table Expressions. This is ideal solution for your problem, because it does not change your current DB schema and most importantly, CTE is an elegant and the logical solution due to the recursiveness that your KeywordSynonymous table has. To accomplish this, its better to first create a view that selects all rows in KeywordSynonymous in both directions. In your case, this table returns the rows select * from KeywordSynonymous 1 5 5 4 and what the view below will do is to show select * from KeywordSynonymousAll 1 5 0 2 NULL 0 3 NULL 0 4 NULL 0 4 5 1 5 1 1 5 4 0 This view is the data structure that will simplify the recursive query. It adds a third column to identify when an reversion has been made. This is required to satisfy your concept number 2. So, here it is the view: create view KeywordSynonymousAll as select KeywordID, KeywordSynonymousID, 0 as reversed from KeywordSynonymous union select K.KeywordID, null as KeywordSynonymousID, 0 as reversed from Keywords K where not exists(select null from KeywordSynonymous where KeywordID = K.KeywordID) union select KeywordSynonymousID, KeywordID, 1 as reversed from KeywordSynonymous And the query declare @search varchar(200); set @search = 'MVC3'; -- TEST HERE for different search keywords with Synonymous (keywordID, SynKeywordID) as ( -- initial state: Get the keywordId and KeywordSynonymousID for the description as @search select K.keywordID, KS.KeywordSynonymousID from Keywords K inner join KeywordSynonymous KS on KS.KeywordID = K.keywordId where K.Description = @search union all -- also initial state but with reversed columns (because we want lookup in both directions) select KS.KeywordSynonymousID, K.keywordID from Keywords K inner join KeywordSynonymous KS on KS.KeywordSynonymousID = K.keywordId where K.Description = @search union all select S.SynKeywordID, KS.KeywordSynonymousID from Synonymous S inner join KeywordSynonymousAll KS on KS.KeywordID = S.SynKeywordID where KS.reversed = 0 -- to avoid infinite recursion union all select KS.KeywordSynonymousID, S.SynKeywordID from Synonymous S inner join KeywordSynonymousAll KS on KS.KeywordID = S.KeywordID where KS.reversed = 1 -- to avoid infinite recursion ) -- finally output the result select distinct K.Description from Synonymous S inner join Keywords K on K.KeywordID = S.keywordID For set @search = 'MVC3' , the result set is ASP.NET MVC MVC MVC3 The same result set happens for set @search = 'MVC' and set @search = 'ASP.NET MVC' For set @search = 'C#' and set @search = 'HTML' you get nothing EDIT In my previous post, I said that result set would be empty for C# and HTML. If you want also to return those values, then change the last part of query to: -- finally output the result select distinct T.Description from ( select K.Description from Synonymous S inner join Keywords K on K.KeywordID = S.keywordID union select Description from Keywords where Description = @search) T Now, for set @search = 'C#' , the result set is C# and for set @search = 'HTML' , the result set is HTML Hope this helps
