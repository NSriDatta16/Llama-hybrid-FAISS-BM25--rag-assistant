[site]: stackoverflow
[post_id]: 2538462
[parent_id]: 2538326
[tags]: 
A possible approach: Split the input into lines with line-seq . (If you want to test this on a string, you can obtain a line-seq on it by doing (line-seq (java.io.BufferedReader. (java.io.StringReader. test-string))) .) Partition it into sub-sequences each of which contains either a single header line or some number of "process lines" with (clojure.contrib.seq/partition-by is-header? your-seq-of-lines) . Assuming there's at least one process line after each header, (partition 2 *2) (where *2 is the sequence obtained in step 2 above) will return a sequence of a form resembling the following: (((header-1) (process-line-1 process-line-2)) ((header-2) (process-line-3 process-line-4))) . If the input might contain some header lines not followed by any data lines, then the above could look like (((header-1a header-1b) (process-line-1 process-line-2)) ...) . Finally, transform the output of step 3 ( *3 ) with the following function: (defn extract-fields-add-headers [[headers process-lines]] (let [header-fields (extract-fields (last headers) header-pattern)] (map #(concat header-fields (extract-fields % data-pattern)) process-lines))) (To explain the (last headers) bit: the only case where we'll get multiple headers here is when some of them have no data lines of their own; the one actually attached to the data lines is the last one.) With these example patterns: (def data-pattern #"(\w+)\s+(\w+)\s+(\d+)\s+(\d+)\s+([0-9.]+)\s+([0-9.]+)\s+([0-9:.]+)") (def header-pattern #"###(\w+)\s+([0-9-]+)\s+([0-9:]+)###") ;; we'll need to throw out the "USER COMM ..." lines, ;; empty lines and the "..." line which I haven't bothered ;; to remove from your sample input (def discard-pattern #"^USER\s+COMM|^$|^\.\.\.") the whole 'pipe' might look like this: ;; just a reminder, normally you'd put this in an ns form: (use '[clojure.contrib.seq :only (partition-by)]) (->> (line-seq (java.io.BufferedReader. (java.io.StringReader. test-data))) (remove #(re-find discard-pattern %)) ; throw out "USER COMM ..." (partition-by is-header?) (partition 2) ;; mapcat performs a map, then concatenates results (mapcat extract-fields-add-headers)) (With the line-seq presumably taking input from a different source in your final programme.) With your example input, the above produces output like this (line breaks added for clarity): (("andreadipersio" "2010-03-19" "16:10:00" "root" "launchd" "1" "0" "0.0" "0.0" "2:46.97") ("andreadipersio" "2010-03-19" "16:10:00" "root" "DirectoryService" "11" "1" "0.0" "0.2" "0:34.59") ("andreadipersio" "2010-03-19" "16:10:00" "root" "notifyd" "12" "1" "0.0" "0.0" "0:20.83") ("andreadipersio" "2010-03-19" "16:10:00" "root" "diskarbitrationd" "13" "1" "0.0" "0.0" "0:02.84") ("andreadipersio" "2010-03-19" "16:20:00" "root" "launchd" "1" "0" "0.0" "0.0" "2:46.97") ("andreadipersio" "2010-03-19" "16:20:00" "root" "DirectoryService" "11" "1" "0.0" "0.2" "0:34.59") ("andreadipersio" "2010-03-19" "16:20:00" "root" "notifyd" "12" "1" "0.0" "0.0" "0:20.83") ("andreadipersio" "2010-03-19" "16:20:00" "root" "diskarbitrationd" "13" "1" "0.0" "0.0" "0:02.84"))
