[site]: stackoverflow
[post_id]: 5171883
[parent_id]: 5171781
[tags]: 
The GC can move references around; using unsafe keeps an object outside of the GC's control, and avoids this. "Fixed" pins an object, but lets the GC manage the memory. By definition, if you have a pointer to the address of an object, and the GC moves it, your pointer is no longer valid. As to why you need pointers: Primary reason is to work with unmanaged DLLs, e.g. those written in C++ Also note, when you pin variables and use pointers, you're more susceptible to heap fragmentation. Edit You've touched on the core issue of managed vs. unmanaged code... how does the memory get released? You can mix code for performance as you describe, you just can't cross managed/unmanaged boundaries with pointers (i.e. you can't use pointers outside of the 'unsafe' context). As for how they get cleaned... You have to manage your own memory; objects that your pointers point to were created/allocated (usually within the C++ DLL) using (hopefully) CoTaskMemAlloc() , and you have to release that memory in the same manner, calling CoTaskMemFree() , or you'll have a memory leak. Note that only memory allocated with CoTaskMemAlloc() can be freed with CoTaskMemFree() . The other alternative is to expose a method from your native C++ dll that takes a pointer and frees it... this lets the DLL decide how to free the memory, which works best if it used some other method to allocate memory. Most native dlls you work with are third-party dlls that you can't modify, and they don't usually have (that I've seen) such functions to call. An example of freeing memory, taken from here : string[] array = new string[2]; array[0] = "hello"; array[1] = "world"; IntPtr ptr = test(array); string result = Marshal.PtrToStringAuto(ptr); Marshal.FreeCoTaskMem(ptr); System.Console.WriteLine(result); Some more reading material: C# deallocate memory referenced by IntPtr The second answer down explains the different allocation/deallocation methods How to free IntPtr in C#? Reinforces the need to deallocate in the same manner the memory was allocated http://msdn.microsoft.com/en-us/library/aa366533%28VS.85%29.aspx Official MSDN documentation on the various ways to allocate and deallocate memory. In short... you need to know how the memory was allocated in order to free it. Edit If I understand your question correctly, the short answer is yes, you can hand the data off to unmanaged pointers, work with it in an unsafe context, and have the data available once you exit the unsafe context. The key is that you have to pin the managed object you're referencing with a fixed block. This prevents the memory you're referencing from being moved by the GC while in the unsafe block. There are a number of subtleties involved here, e.g. you can't reassign a pointer initialized in a fixed block... you should read up on unsafe and fixed statements if you're really set on managing your own code. All that said, the benefits of managing your own objects and using pointers in the manner you describe may not buy you as much of a performance increase as you might think. Reasons why not: C# is very optimized and very fast Your pointer code is still generated as IL, which has to be jitted (at which point further optimizations come into play) You're not turning the Garbage Collector off... you're just keeping the objects you're working with out of the GC's purview. So every 100ms or so, the GC still interrupts your code and executes its functions for all the other variables in your managed code. HTH, James
