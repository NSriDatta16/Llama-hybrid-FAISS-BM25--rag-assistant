[site]: stackoverflow
[post_id]: 1568414
[parent_id]: 1568166
[tags]: 
Logging into a temporary table can be a good solution. For example, you could create a simple logging table like this: create table PROCESSING_LOG( MESSAGE_DATE timestamp, MESSAGE_TEXT varchar2(4000) ); If you decide to roll your own logging and log into a table you might go the Autonomous Transaction route. An Autonomous Transaction is a transaction that can be commited independently of the current transaction you are in. That way you can log and commit all the info you want to your log table independently of the success or failure of your stored procedure or batch process parent transaction. CREATE OR REPLACE PROCEDURE "SP_LOG" ( P_MESSAGE_TEXT VARCHAR2 ) IS pragma autonomous_transaction; BEGIN DBMS_OUTPUT.PUT_LINE(P_MESSAGE_TEXT); INSERT INTO PROCESSING_LOG ( MESSAGE_DATE, MESSAGE_TEXT ) VALUES ( SYSDATE, P_MESSAGE_TEXT ); COMMIT; END; / Then if you call it like this, you can still get messages committed to your log table even if you have a failure and roll back your transaction: BEGIN SP_LOG('Starting task 1 of 2'); ... code for task 1 ... SP_LOG('Starting task 2 of 2'); ... code for task 2 ... SP_LOG('Ending Tasks'); ... determine success or failure of process and commit or rollback ... ROLLBACK; END; / You may want to tidy it up with exceptions that make sense for your code, but that is the general idea, the data written in the calls to SP_LOG persists, but the parent transaction can still be rolled back.
