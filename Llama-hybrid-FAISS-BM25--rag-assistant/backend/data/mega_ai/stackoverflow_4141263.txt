[site]: stackoverflow
[post_id]: 4141263
[parent_id]: 4141078
[tags]: 
By "avoiding the use of strings", I'm going to assume you're doing this because a string-only representation is pretty inefficient if you want an integer value. To that end, I'm going to suggest a slightly unorthodox approach which may be suitable. Don't store them in one form, store them in both . The code below is in C - it will work in C++ but you may want to consider using c++ equivalents - the idea behind it doesn't change however. By "storing both forms", I mean you can have a structure like: typedef struct { int ival; char sval[sizeof("-2147483648")]; // enough for 32-bits int dirtyS; } tIntStr; and pass around this structure (or its address) rather than the integer itself. By having macros or inline functions like: inline void intstrSetI (tIntStr *is, int ival) { is->ival = i; is->dirtyS = 1; } inline char *intstrGetS (tIntStr *is) { if (is->dirtyS) { sprintf (is->sval, "%d", is->ival); is->dirtyS = 0; } return is->sval; } Then, to set the value, you would use: tIntStr is; intstrSetI (&is, 42); And whenever you wanted the string representation: printf ("%s\n" intstrGetS(&is)); fprintf (logFile, "%s\n" intstrGetS(&is)); This has the advantage of calculating the string representation only when needed (the fprintf above would not have to recalculate the string representation and the printf only if it was dirty). This is a similar trick I use in SQL with using precomputed columns and triggers. The idea there is that you only perform calculations when needed. So an extra column to hold the indexed lowercased last name along with an insert/update trigger to calculate it, is usually a lot more efficient than select lower(non_lowercased_last_name) . That's because it amortises the cost of the calculation (done at write time) across all reads. In that sense, there's little advantage if your code profile is set-int/use-string/set-int/use-string... . But, if it's set-int/use-string/use-string/use-string/use-string... , you'll get a performance boost. Granted this has a cost, at the bare minimum extra storage required, but most performance issues boil down to a space/time trade-off. And, if you really want to avoid strings, you can still use the same method (calculate only when needed), it's just that the calculation (and structure) will be different. As an aside: you may well want to use the library functions to do this rather than handcrafting your own code. Library functions will normally be heavily optimised, possibly more so than your compiler can make from your code (although that's not guaranteed of course). It's also likely that an itoa , if you have one, will probably outperform sprintf("%d") as well, given its limited use case. You should, however, measure, not guess! Not just in terms of the library functions, but also this entire solution (and the others).
