[site]: stackoverflow
[post_id]: 4266841
[parent_id]: 4266756
[tags]: 
The fact that primitives are signed in Java is irrelevant to how they're represented in memory / transit - a byte is merely 8 bits and whether you interpret that as a signed range or not is up to you. There is no magic flag to say "this is signed" or "this is unsigned". As primitives are signed the Java compiler will prevent you from assigning a value higher than +127 to a byte (or lower than -128). However, there's nothing to stop you downcasting an int (or short) in order to achieve this: int i = 200; // 0000 0000 0000 0000 0000 0000 1100 1000 (200) byte b = (byte) 200; // 1100 1000 (-56 by Java specification, 200 by convention) /* * Will print a negative int -56 because upcasting byte to int does * so called "sign extension" which yields those bits: * 1111 1111 1111 1111 1111 1111 1100 1000 (-56) * * But you could still choose to interpret this as +200. */ System.out.println(b); // "-56" /* * Will print a positive int 200 because bitwise AND with 0xFF will * zero all the 24 most significant bits that: * a) were added during upcasting to int which took place silently * just before evaluating the bitwise AND operator. * So the `b & 0xFF` is equivalent with `((int) b) & 0xFF`. * b) were set to 1s because of "sign extension" during the upcasting * * 1111 1111 1111 1111 1111 1111 1100 1000 (the int) * & * 0000 0000 0000 0000 0000 0000 1111 1111 (the 0xFF) * ======================================= * 0000 0000 0000 0000 0000 0000 1100 1000 (200) */ System.out.println(b & 0xFF); // "200" /* * You would typically do this *within* the method that expected an * unsigned byte and the advantage is you apply `0xFF` only once * and than you use the `unsignedByte` variable in all your bitwise * operations. * * You could use any integer type longer than `byte` for the `unsignedByte` variable, * i.e. `short`, `int`, `long` and even `char`, but during bitwise operations * it would get casted to `int` anyway. */ void printUnsignedByte(byte b) { int unsignedByte = b & 0xFF; System.out.println(unsignedByte); // "200" }
