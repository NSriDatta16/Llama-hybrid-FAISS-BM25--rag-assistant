[site]: stackoverflow
[post_id]: 4363322
[parent_id]: 4362604
[tags]: 
That C++ has been getting by with new and delete sans any equivalent of realloc shows how little attention these things get. Unsurprising _expand is largely ignored when it's not even consistently available at the OS level. If you want to roll your own, there's plenty of precedent for user-defined versions of malloc, and a quick look in /usr/include/malloc.h on my Linux box shows hooks explicitly for this... /* Called once when malloc is initialized; redefining this variable in the application provides the preferred way to set up the hook pointers. */ extern void (*__malloc_initialize_hook) __MALLOC_PMT ((void)); /* Hooks for debugging and user-defined versions. */ extern void (*__free_hook) __MALLOC_PMT ((__malloc_ptr_t __ptr, __const __malloc_ptr_t)); extern __malloc_ptr_t (*__malloc_hook) __MALLOC_PMT ((size_t __size, __const __malloc_ptr_t)); extern __malloc_ptr_t (*__realloc_hook) __MALLOC_PMT ((__malloc_ptr_t __ptr, size_t __size, __const __malloc_ptr_t)); extern __malloc_ptr_t (*__memalign_hook) __MALLOC_PMT ((size_t __alignment, size_t __size, __const __malloc_ptr_t)); extern void (*__after_morecore_hook) __MALLOC_PMT ((void)); Doesn't look like you'll be able to intercept the existing realloc implementation at that particular decision point though, or easily get insight into whether it will resize inplace, so you might have to reimplement everything (or adapt any of many existing heap implementations).
