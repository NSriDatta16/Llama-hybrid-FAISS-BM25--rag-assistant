[site]: stackoverflow
[post_id]: 2035106
[parent_id]: 2035060
[tags]: 
MVC Model-View-Controller allows for low cohesion between business logic and presentation layer and this is its primary value. Usually each Controller is a Servlet that handles GET/POST requests for a single page, responding to them by presenting a correct view or transferring jurisdiction to another Controller. Viwer turns data the Controller passes, into Html, Xml, JavaScript, JSON or whatever technology you'd like. Viewer is most often a Servlet or a Servlet abstraction like JSP, ASP, etc. Model is the domain-specific representation of the data upon which the application operates. It can also be coupled with domain logic that provides meaning to data (like calculating birthday, totals or shipping charges for cart shopping items). Model should encapsulate the data allowing easy access no matter the underlying storage facilities. Due to its low cohesion with MVC you can change, develop and test each component independently. ActiveRecord This one is often used when underlying storage mechanism is a database. Basically what ActiveRecord means is that all your object properties correspond to columns in the underlying database and that each object includes functions such as Insert, Update, Delete (and Load). So each class is translated into a table or a view and each object becomes a row in the said table. The reason for this is simple by having your classes implement the way to access and edit the database you are spared of writing the extra boiler plate code. That coupled with popularity of databases is enough to keep this pattern interesting. Pools Another one often used is Pools . PoolManager is a Singleton that manages the Resource (be it database, Factory method or a connection). PoolManager keeps a set of initialized copies. Whenever another process or an object asks for resource via PoolManager.acquire() he gets one of the objects from a pool. He then manipulates his copy of the resource and returns it when he is finished via Resource.release() . The object isn't destroyed however, it is merely returned to the pool. Pools are used to increase performance. For instance if there is a factory method that has a costly retrieval (i.e. it is slow to respond) it is often wrapped in a PoolManager and N instances are created on initialization of PoolManager . That way clients doesn't feel that that the underlying factory is slow since PoolManager takes the performance hit for them.
