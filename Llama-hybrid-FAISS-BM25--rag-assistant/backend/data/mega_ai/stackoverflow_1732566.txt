[site]: stackoverflow
[post_id]: 1732566
[parent_id]: 1732266
[tags]: 
In terms of speed, your original solution is the fastest I've tried so far (@Godeke's is a very close second). @Godeke's has a lot of readability, for only a minor amount of performance degradation. Add in some robustness checks, and his may be the long term way to go. In terms of robustness, you can add that in to yours like so: static char[] signChars = new char[] { '+', '-' }; static float ParseFloatingPoint(string data) { if (data.Length != EntryWidth) { throw new ArgumentException("data is not the correct size", "data"); } else if (data[0] != ' ' && data[0] != '+' && data[0] != '-') { throw new ArgumentException("unexpected leading character", "data"); } int signPos = data.LastIndexOfAny(signChars); // Found either a '+' or '-' if (signPos > 0) { // Create a new char array with an extra space to accomodate the 'e' char[] newData = new char[EntryWidth + 1]; // Copy from string up to the sign for (int ii = 0; ii Benchmarks on my X5260 (including the times to just grok out the individual data points): Code Average Runtime Values Parsed -------------------------------------------------- Nothing (Overhead) 13 ms 0 Original 50 ms 150000 Godeke 60 ms 150000 Original Robust 56 ms 150000
