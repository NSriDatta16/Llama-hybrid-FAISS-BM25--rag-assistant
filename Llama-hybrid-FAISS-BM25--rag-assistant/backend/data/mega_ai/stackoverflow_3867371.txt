[site]: stackoverflow
[post_id]: 3867371
[parent_id]: 3867315
[tags]: 
I think the crux of the problem is here: There are lots of scenarios I need to unit test (doing it via the UI is becoming really tedious, especially as there are lots of scenarios that don't occur naturally that often). However, to do so would mean making various properties public that really don't need to be (except for my testing purposes). I recommend not worrying too much about changing the interface to support testing. By all means keep set accessors internal. * You can limit the impact on your API, since all you really need are additional public constructors for the objects you need to arrange. For example: public Player(Guid id, Hand hand, bool isThisPlayersTurn, string name) { ... } You want to get to the point where you can write simple, clear test cases: Hand hand = new Hand(faceDownCards, faceUpCards, inHandCards); Player player = new Player(Guid.NewGuid(), hand, true, "Christo"); Game game = new Game(player); I've never regretted doing this, even when it's just for testing purposes. The API is still clear enough that people use the correct constructors: normally, they'd use a default constructor (or no constructor at all - instead they'll call game.AddPlayer("Christo") ) and only use the extended constructor for testing or deserialization (when appropriate). * And consider changing the public interface of members like Game.Players to IEnumerable to better communicate the read-only semantics.
