[site]: stackoverflow
[post_id]: 5468363
[parent_id]: 5468186
[tags]: 
You'll probably need to implement each one of those scheduling algorithms and write some kind of simulator. Instead of using arrays, as I always find it hard to remember what goes where, consider using a struct. struct Process { std::string name; int arrival; int burst; int priority; }; Then you can choose an appropriate data structure for whatever scheduling algorithm you're using. The simulator should probably do something like this... Place any processes that should be started at this time into the runnable queue Schedule if something needs to happen (either due to a timer interrupt or the current process waiting) Decrement currently running processes burst time (since it has run for an additional tick) Add one to the current time Repeat until finished If you can do this in whatever language you want, it might be easier to use a scripting language, as this probably isn't performance critical (a real scheduler would be). I would suggest you don't use arrays though, as they can get very confusing. Even if this were C I would still suggest using a struct for the processes instead of an array. In particular, FIFO is a pretty easy one. You just keep the active processes in a list/vector structure and keep running until the burst is 0. Then you pop the front of the container and do the same until you run out of processes. To keep the wait time, you can just count how many processes are currently in the wait queue every tick and average that together. For turnaround time, you can keep what tick a process was added and when it's finished, compute how long it took for the process to finish. Then add that time to whatever average you're keeping.
