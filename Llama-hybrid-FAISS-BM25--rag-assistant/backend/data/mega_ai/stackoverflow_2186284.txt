[site]: stackoverflow
[post_id]: 2186284
[parent_id]: 
[tags]: 
Changing selected objects inside a query

I have a class that needs a property set inside a LINQ-to-SQL query. My first attempt was to have a "setter" method that would return the object instance and could be used in my select, like this: public partial class Foo { public DateTime RetrievalTime { get; set; } public Foo SetRetrievalTimeAndReturnSelf ( DateTime value ) { RetrievalTime = value; return this; } } .... from foo in DataContext.GetTable select foo.SetRetrievalTimeAndReturnSelf(); Unfortunately, such a query throws an exception like this: "System.NotSupportedException: Method 'Foo.SetRetrievalTime(System.DateTime)' has no supported translation to SQL". Is there any alternative to converting the result to a list and iterating over it? The query is used in a custom "Get" method that wraps the DataContext.GetTable method, so will be used as the base for many other queries. Immediately converting a potentially-large result set to a list would not be optimal. UPDATE Here's a better example of what I'm trying to do, updated with Jason's proposed solution: protected IQueryable Get () where T : class, ISecurable { // retrieve all T records and associated security records var query = from entity in DataContext.GetTable () from userEntityAccess in DataContext.GetTable () where userEntityAccess.SysUserId == CurrentUser.Id && entity.Id == userEntityAccess.EntityId && userEntityAccess.EntityClassName == typeof ( T ).Name select new { entity, userEntityAccess }; return query.AsEnumerable () .Select ( item => { item.entity.CanRead = item.userEntityAccess.CanRead; item.entity.CanWrite = item.userEntityAccess.CanWrite; item.entity.CanDelete = item.userEntityAccess.CanDelete; return item.entity; } ).AsQueryable (); } public interface ISecurable { int Id { get; set; } bool CanRead { get; set; } bool CanWrite { get; set; } bool CanDelete { get; set; } } UserEntityAccess is a cross-reference table between a user and a business object record (i.e. an entity). Each record contains fields like "CanRead", "CanWrite", and "CanDelete", and determines what a specific user can do with a specific record. ISecurable is a marker interface that must be implemented by any LINQ-to-SQL domain class that needs to use this secured Get method.
