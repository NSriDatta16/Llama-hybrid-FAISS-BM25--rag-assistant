[site]: stackoverflow
[post_id]: 3436238
[parent_id]: 3435738
[tags]: 
[...] argues that the general purpose operators (new and delete) perform badly for allocating small objects. Platform dependent. E.g. on Linux I once benchmarked my homegrown AVL tree with static memory management vs. GNU's std::map which is red-black tree and fully dynamic memory management. To my surprise, std::map sometimes outran my own highly-efficient implementation. And std::map does hazardous amount of small memory allocations. In my program there are lot of objects created and destroyed on the free store. Memory management concern is a valid one. In a sense that you should always try to reuse existing resources if possible or avoid creation of temporary copies. That's if efficiency/CPU performance you are after. If the code is ran rarely, then it is pointless to bother. These objects measure more than 8000 bytes. What size is considered small? Are 8000 bytes small or big when it comes to memory allocation in C++? This is pointless question. If your program needs an object taking 8K, then your program needs it. Period. You should start worry only if you would receive complains that software takes too much RAM or profiler points to the performance bottleneck in memory management. Otherwise, modern memory management is relatively fast and robust. P.S. I personally would consider 8K to be an average memory allocation size. Not small - not big. But I'm already used to work with programs which on a whim allocate 10+GB on heap. If data set has to be resident in RAM and it is 10GB in size, well, then application has little choice but to try to load it.
