[site]: stackoverflow
[post_id]: 2110440
[parent_id]: 
[tags]: 
Why is there no IArray(T) interface in .NET?

Update 2011-Jan-06: Believe it or not, I went ahead and incorporated this interface into an open source library I've started, Tao.NET . I wrote a blog post explaining this library's IArray interface, which not only addresses the issues I originally raised in this question (a year ago?!) but also provides a covariant indexed interface , something that's sorely lacking (in my opinion) in the BCL. Question (in short): I asked why .NET has IList , which implements ICollection and therefore provides methods to modify the list ( Add , Remove , etc.), but doesn't offer any in-between interface such as IArray to provide random access by index without any list modification. EDIT 2010-Jan-21 2:22 PM EST: In a comment to Jon Skeet's original answer (in which he questioned how often one would have any need for a contract such as IArray ), I mentioned that the Keys and Values properties of the SortedList class are IList and IList , respectively, to which Jon replied: But in this case it's declared to be IList and you know to just use the indexers. . . . It's not hugely elegant, I agree - but it doesn't actually cause me any pain. This is reasonable, but I would respond by saying that it doesn't cause you any pain because you just know you can't do it . But the reason you know isn't that it's clear from the code; it's that you have experience with the SortedList class. Visual Studio isn't going to give me any warnings if I do this: SortedList mySortedList = new SortedList (); // ... IList keys = mySortedList.Keys; keys.Add("newkey"); It's legal, according to IList . But we all know, it's going to cause an exception. Guillaume made an apt point as well: Well, the interfaces aren't perfect but a dev can check the IsReadOnly property before calling Add/Remove/Set... Again, this is reasonable, BUT : does this not strike you as a bit circuitous? Suppose I defined an interface as follows: public interface ICanWalkAndRun { bool IsCapableOfRunning { get; } void Walk(); void Run(); } Now, suppose as well that I made it a common practice to implement this interface, but only for its Walk method; in many cases, I would opt to set IsCapableOfRunning to false and throw a NotSupportedException on Run ... Then I might have some code that looked like this: var walkerRunners = new Dictionary (); // ... ICanWalkAndRun walkerRunner = walkerRunners["somekey"]; if (walkerRunner.IsCapableOfRunning) { walkerRunner.Run(); } else { walkerRunner.Walk(); } Am I crazy, or is this kind of defeating the purpose of an interface called ICanWalkAndRun ? Original Post I find it very peculiar that in .NET, when I am designing a class with a collection property that provides random access by index (or a method that returns an indexed collection, etc.), but should not or cannot be modified by adding/removing items , and if I want to "do the right thing" OOP-wise and provide an interface so that I can change the internal implementation without breaking the API, I have to go with IList . The standard approach, it seems, is to go with some implementation of IList that explicitly defines the methods Add , Insert , etc. -- typically by doing something like: private List _items; public IList Items { get { return _items.AsReadOnly(); } } But I kind of hate this. If another developer is using my class, and my class has a property of type IList , and the whole idea of an interface is: "these are some available properties and methods" , why should I throw a NotSupportedException (or whatever the case may be) when he/she tries to do something that, according to the interface, should be completely legal? I feel like implementing an interface and explicitly defining some of its members is like opening a restaurant and putting some items on the menu -- perhaps in some obscure, easy-to-miss part of the menu, but on the menu nonetheless -- that are simply never available. It seems there ought to be something like an IArray interface that provides very basic random access by index, but no adding/removing, like the following: public interface IArray { int Length { get; } T this[int index] { get; } } And then IList could implement ICollection and IArray and add its IndexOf , Insert and RemoveAt methods. Of course, I could always just write this interface and use it myself, but that doesn't help with all the pre-existing .NET classes that don't implement it. (And yes, I know I could write a wrapper that takes any IList and spits out an IArray , but ... seriously?) Does anyone have any insight into why the interfaces in System.Collections.Generic were designed this way? Am I missing something? Is there a compelling argument against what I'm saying about my issues with the approach of explicitly defining members of IList ? I'm not trying to sound cocky, as if I know better than the people who designed the .NET classes and interfaces; it just doesn't make sense to me . But I'm ready to acknowledge there's plenty I probably haven't taken into consideration.
