[site]: stackoverflow
[post_id]: 4486547
[parent_id]: 4486442
[tags]: 
const means that you promise not to mutate the variable. It could still be changed. class A { public: A(const int& a); int getValue() const; void setValue(int b); private: const int& a; }; A::A(a) : a(a) {} int A::getValue() const { return a; } void A::setValue(int b) { a = b; // error } int main() { int my_a = 0; A a(my_a); std::cout No method A::* may change a , but main can. That much is identical between C and C++. What C++ does have are a couple (limited) ways to bypass const , which are supposed to discourage programmers from discarding const inappropriately. Take a class like this. class A { public: A(); int getValue(); private: static int expensiveComputation(); int cachedComputation; }; A::A() : cachedComputation(0) {} A::getValue() { if (cachedComputation == 0) cachedComputation = expensiveComputation(); return cachedComputation; } cachedComputation implicitly means this->cachedComputation . Keep this in mind. int main() { A a1; const A a2; std::cout a2.getValue() is illegal, because a non- const method is being called on a const A a2 . One could cast away the const -nessâ€¦ std::cout (a2).getValue() The second is preferred, because the compiler will check that only the const -ness is being casted, nothing else. However, this is still not ideal. Instead, there should be a new method added to the class. class A { public: int getValue() const; }; A::getValue() const { if (cachedComputation == 0) cachedComputation = expensiveComputation(); // error return cachedComputation; } Now there is a const method, so a2.getValue() is fine. However, the trailing const means that the method is given a const A *this pointer, not an A *this pointer like usual, making this->cachedComputation a const int & that cannot be mutated. const_cast could be applied inside the method, but better would be to change this one member's declaration. class A { private: mutable int cachedComputation; }; Now, even with a const A *this , this->cachedComputation can be mutated without casting.
