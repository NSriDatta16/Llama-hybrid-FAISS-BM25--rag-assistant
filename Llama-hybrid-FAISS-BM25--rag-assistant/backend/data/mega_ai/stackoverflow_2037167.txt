[site]: stackoverflow
[post_id]: 2037167
[parent_id]: 
[tags]: 
dynamic data model

I have a project that requires user-defined attributes for a particular object at runtime (Lets say a person object in this example). The project will have many different users (1000 +), each defining their own unique attributes for their own sets of 'Person' objects. (Eg - user #1 will have a set of defined attributes, which will apply to all person objects 'owned' by this user. Mutliply this by 1000 users, and that's the bottom line minimum number of users the app will work with.) These attributes will be used to query the people object and return results. I think these are the possible approaches I can use. I will be using C# (and any version of .NET 3.5 or 4), and have a free reign re: what to use for a datastore. (I have mysql and mssql available, although have the freedom to use any software, as long as it will fit the bill) Have I missed anything, or made any incorrect assumptions in my assessment? Out of these choices - what solution would you go for? Hybrid EAV object model. (Define the database using normal relational model, and have a 'property bag' table for the Person table). Downsides: many joins per / query. Poor performance. Can hit a limit of the number of joins / tables used in a query. I've knocked up a quick sample, that has a Subsonic 2.x 'esqe interface: Select().From().Where ... etc Which generates the correct joins, then filters + pivots the returned data in c#, to return a datatable configured with the correctly typed data-set. I have yet to load test this solution. It's based on the EA advice in this Microsoft whitepaper: SQL Server 2008 RTM Documents Best Practices for Semantic Data Modeling for Performance and Scalability Allow the user to dynamically create / alter the object's table at run-time. This solution is what I believe NHibernate does in the background when using dynamic properties, as discussed where http://bartreyserhove.blogspot.com/2008/02/dynamic-domain-mode-using-nhibernate.html Downsides: As the system grows, the number of columns defined will get very large, and may hit the max number of columns. If there are 1000 users, each with 10 distinct attributes for their 'Person' objects, then we'd need a table holding 10k columns. Not scalable in this scenario. I guess I could allow a person attribute table per user, but if there are 1000 users to start, that's 1000 tables plus the other 10 odd in the app. I'm unsure if this would be scalable - but it doesn't seem so. Someone please correct me if I an incorrect! Use a NoSQL datastore, such as CouchDb / MongoDb From what I have read, these aren't yet proven in large scale apps, based on strings, and are very early in development phase. IF I am incorrect in this assessment, can someone let me know? http://www.eflorenzano.com/blog/post/why-couchdb-sucks/ Using XML column in the people table to store attributes Drawbacks - no indexing on querying, so every column would need to be retrieved and queried to return a resultset, resulting in poor query performance. Serializing an object graph to the database. Drawbacks - no indexing on querying, so every column would need to be retrieved and queried to return a resultset, resulting in poor query performance. C# bindings for berkelyDB From what I read here: http://www.dinosaurtech.com/2009/berkeley-db-c-bindings/ Berkeley Db has definitely proven to be useful, but as Robert pointed out – there is no easy interface. Your entire wOO wrapper has to be hand coded, and all of your indices are hand maintained. It is much more difficult than SQL / linq-to-sql, but that’s the price you pay for ridiculous speed. Seems a large overhead - however if anyone can provide a link to a tutorial on how to maintain the indices in C# - it could be a goer. SQL / RDF hybrid. Odd I didn't think of this before. Similar to option 1, but instead of an "property bag" table, just XREF to a RDF store? Querying would them involve 2 steps - query the RDF store for people hitting the correct attributes, to return the person object(s), and use the ID's for these person object in the SQL query to return the relational data. Extra overhead, but could be a goer.
