[site]: crossvalidated
[post_id]: 432354
[parent_id]: 
[tags]: 
Implementing a Hit-And-Run MCMC Sampler in Python

I'm trying to implement the Metropolisized Hit-And-Run Sampler as described in Chapter 7.2 of Chen and Schmeiser, Performance of the Gibbs, Hit-and-Run, and Metropolis Samplers https://www.jstor.org/stable/pdf/1390645.pdf I chose the function $g$ to be a piecewise constant distribution function based on evaluations of the log probability along the direction of movement. It seems that the chain does not converge to the posterior distribution. I particular both mean and standard deviation of the produced samples are smaller than the true values. Here's my python implementation. Am I missing something? I haven't found a working version of this sampler anywhere. import numpy as np # test log probability def logprob(x): return - 0.5*np.sum((x-5.0)**2.0) x0 = np.array([-1.0,-1.0]) # Initial point nsteps = 50000 # Number of steps ndim = 2 # Number of dimensions # Piecewise constant density g def gfunc(logprob,x0,d,lmax=1.0,npieces=2): dl = 2. * lmax / npieces # Compute width of piecewise constant regions # Compute centres of those regions centres = np.linspace(x0-(npieces-1.0)/2.0*dl*d,x0+(npieces-1.0)/2.0*dl*d,npieces) logprobvals = list(map(logprob,centres)) # Evaluate the logprob at those points probvals = np.exp(logprobvals) # Get the probability gvals = probvals / np.sum(probvals) # Normalise the probability to sum to 1 piece = np.random.choice(np.arange(-int(npieces/2),int(npieces/2)),p=gvals) # Choose a random region with probability goals gprime = gvals[int(npieces/2)+piece] # Compute g(x0+l*d) l = np.random.uniform(piece*dl, (piece+1)*dl, size=ndim) # Uniformly sample l from that region return l, gprime x = np.empty((nsteps,ndim)) # Initialise array to save samples g = np.empty((nsteps)) # Initialise array to save g evaluations g[-1] = 0.1 # This is arbitrary x[-1] = x0 for i in range(nsteps): d = np.random.normal(0,1,size=ndim) # Compute unit direction vector d /= np.linalg.norm(d) l, gp = gfunc(logprob,x[i-1],d,lmax=5.0,npieces=100) # Sample l and get g(x0+l*d) ratio = g[i-1]/gp # Compute g/g' ratio to be used in M-H acceptance criterion Z = x[i-1] + l * d # Compute new point # Check Metropolis-Hastings acceptance criterion if np.random.uniform(0.0,1.0) Update Here are the produced Markov chains and samples respectively:
