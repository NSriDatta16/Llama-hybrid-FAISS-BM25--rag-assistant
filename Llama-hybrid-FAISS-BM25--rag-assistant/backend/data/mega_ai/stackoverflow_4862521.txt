[site]: stackoverflow
[post_id]: 4862521
[parent_id]: 4862120
[tags]: 
The Enumerator created by the Cache generates DictionaryEntry objects. Furthermore, a Cache may have only string keys. Thus, you can write the following: var httpCache = HttpContext.Current.Cache; var toRemove = httpCache.Cast () .Select(de=>(string)de.Key) .Where(key=>key.Contains("subcat")) .ToArray(); //use .ToArray() to avoid concurrent modification issues. foreach(var keyToRemove in toRemove) httpCache.Remove(keyToRemove); However, this is a potentially slow operation when the cache is large: the cache is not designed to be used like this. You should ask yourself whether an alternative design isn't possible and preferable. Why do you need to remove several cache keys at once, and why aren't you grouping cache keys by substring?
