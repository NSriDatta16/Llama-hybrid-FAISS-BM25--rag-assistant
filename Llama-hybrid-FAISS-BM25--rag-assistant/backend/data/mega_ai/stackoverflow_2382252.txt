[site]: stackoverflow
[post_id]: 2382252
[parent_id]: 2382054
[tags]: 
No, your "AFAIK" is incorrect. static_cast never behaves as reinterpret_cast (except, maybe when you convert to void * , although this conversion is not normally supposed to be carried out by reinterpret_cast ). Firstly, when static_cast is used for pointer or reference conversions, the specification of the static_cast explicitly requires a certain relationship to exist between the types (and be known to static_cast ). For class types, they shall be related by inheritance, as perceived by static_cast . It is not possible to satisfy that requirement without having both types completely defined by the point of static_cast . So, if the definition(s) is(are) not visible at the point of static_cast , the code simply will not compile. To illustrate the above with examples: static_cast can be used [redundantly] to perform object pointer upcasts. The code Derived *derived = /* whatever */; Base *base = static_cast (derived); is only compilable when the following code is compilable Base *base(derived); and for this to compile the definition of both types have to be visible. Also, static_cast can be used to perform object pointer downcasts. The code Base *base = /* whatever */; Derived *derived = static_cast (base); is only compilable when the following code is compilable Base *base(derived); // reverse direction and, again, for this to compile the definition of both types have to be visible. So, you simply won't be able to use static_cast with undefined types. If your compiler allows that, it is a bug in your compiler. static_cast can be unsafe for pointers/references for a completely different reason. static_cast can perform hierarchical downcasts for object pointer/reference types without checking the actual dynamic type of the object. static_cast can also perform hierarchical upcasts for method pointer types. Using the results of these unchecked casts can lead to undefined behavior, if done without caution. Secondly, when static_cast is used with arithmetic types, the semantics is totally different and has nothing to do with the above. It just performs arithmetic type conversions. They are always perfectly safe (aside form the range issues), as long as they fit your intent. In fact, it might be a good programming style to avoid static_cast for arithmetic conversions and use old C-style casts instead, just to provide a clear differentiation in the source code between always-safe arithmetic casts and potentially-unsafe hierarchical pointer/reference casts.
