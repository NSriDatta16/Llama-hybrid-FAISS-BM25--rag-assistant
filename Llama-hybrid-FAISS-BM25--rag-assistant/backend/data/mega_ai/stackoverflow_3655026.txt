[site]: stackoverflow
[post_id]: 3655026
[parent_id]: 3654873
[tags]: 
As long as two modules implement exactly the same interface (classes with the same names, methods, and other attributes, functions with the same names and signatures, ...) you can pick one or the other at the time your application is starting up, for example on the basis of some configuration file, and import the chosen one under a fixed name. All the rest of your application can then use that fixed name and, net of the startup code, be blissfully unaware of any shenanigans that may have been done at the start. For example, consider a simplified case: # english.py def greet(): return 'Hello!' # italian.py def greet(): return 'Ciao!' # french.py def greet(): return 'Salut!' # config.py langname = 'italian' # startit.py import config import sys lang = __import__(config.langname) sys.modules['lang'] = lang Now, all the rest of the application can just import lang , and it will be getting under that name the italian module, so, when calling lang.greet() , it will get the string 'Ciao!' . Of course, in real life you'll have multiple modules, each with multiple functions, classes, and whatnot, but the general principles stay very similar. Just take special care about modules with qualified names (such as foo.bar ), i.e., modules which must reside in a package (in this case, foo ). For those, you can't just use __import__ 's return value, but must use a slightly more roundabout approach, such as: import sys def importanyasname(actualname, fakename): __import__(actualname) sys.modules[fakename] = sys.modules[actualname] that is, ignore __import__ 's return value, and reach right for the value that's left (with the actual name as the key) in the sys.modules dictionary -- that is the module object you seek, and that you can set back into sys.modules with the "fake name" by which all the rest of the application will be able to blissfully import it any time.
