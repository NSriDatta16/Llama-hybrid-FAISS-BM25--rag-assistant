[site]: stackoverflow
[post_id]: 3114905
[parent_id]: 3113974
[tags]: 
Early warning - answer a little long… Use objects that model your domain. You have no need for singletons or globals, you need a regular instance of a regular class. What Objects are your storing in your global array? Create a class that represents that part of your model. If you use an NSMutableArray as storage it should be internal to your class and not visible to outside objects. eg if you are modelling a zoo, don't do [[[MyGlobals sharedMyGlobals].globalArray] addObject:tomTheZebra]; do do [doc addAnimal:tomTheZebra]; Dont try to observe a mutable array - you want to observe a to-many property of your object. eg. instead of [[[MyGlobals sharedMyGlobals].globalArray] addObserver:_controller] you want [doc addObserver:_controller forKeyPath:@"animals" options:0 context:nil]; where doc is kvo compliant for the to-many property 'anaimals'. To make doc kvo compliant you would need to implement these methods (Note - you don't need all these. Some are optional but better for performance) - (NSArray *)animals; - (NSUInteger)countOfAnimals; - (id)objectInAnimalsAtIndex:(NSUInteger)i; - (id)AnimalsAtIndexes:(NSIndexSet *)ix; - (void)insertObject:(id)val inAnimalsAtIndex:(NSUInteger)i; - (void)insertAnimals:atIndexes:(NSIndexSet *)ix; - (void)removeObjectFromAnimalsAtIndex:(NSUInteger)i; - (void)removeAnimalsAtIndexes:(NSIndexSet *)ix; - (void)replaceObjectInAnimalsAtIndex:(NSUInteger)i withObject:(id)val; - (void)replaceAnimalsAtIndexes:(NSIndexSet *)ix withAnimals:(NSArray *)vals; Ok, that looks pretty scary but it's not that bad, like i said you don't need them all. See here . These methods dont need to be part of the interface to your model, you could just add:- - (void)addAnimal:(id)val; - (void)removeAnimal:(id)val; and write them in terms of the kvc accessors. The key point is it's not the array that sends notifications when it is changed, the array is just the storage behind the scenes, it is your model class that send the notifications that objects have been added or removed. You may need to restructure your app. You may need to forget about NSArrayController altogether. Aaaaaannnnnyyywaaayyy… all this gets you nothing if you do this [[[MyGlobals sharedMyGlobals].globalArray] addObject:theNewObject]; or this [doc addAnimal:tomTheZebra]; from a background thread. You can't do this. NSMutableArray isn't thread safe. If it seems to work then the best that will happen is that the kvo/binding notification is delivered on the background as well, meaning that you will try to update your GUI on the background, which you absolutely cannot do. Making the array static does not help in any way i'm afraid - you must come up with a strategy for this.. the simplest way is performSelectorOnMainThread but beyond that is another question entirely. Threading is hard. And about that static array - just stop using static, you don't need it. Not because you have 2 nibs, 2 windows or anything. You have an instance that represents your model and pass a pointer to that to you viewControllers, windowControllers, whatever. Not having singletons/static variables helps enormously with testing, which of course you should be doing.
