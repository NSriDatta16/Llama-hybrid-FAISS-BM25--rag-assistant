[site]: stackoverflow
[post_id]: 3798841
[parent_id]: 3798809
[tags]: 
You seem to be inventing something that isn't really there, terminology-wise. numbers is an array. It is an automatic object of type int[3] . It cannot be used to form address constants in C, since in C address constants require objects with static storage duration. If your numbers was declared with static storage duration, then the result of array-to-pointer conversion applied to numbers would be an address constant. numbers + 1 as well as &numbers[2] would also be address constant in that case. You are right to note that { 1, 2, 3 } doesn't have static storage duration. In fact, it has no storage duration at all. It is not an object, but merely a piece of syntactic sugar called aggregate initializer . If you wanted it to become an anonymous object, you'd have to use the compound literal syntax: (int[]) { 1, 2, 3 } , but it wouldn't work in the above context anyway. numbers++ will not compile simply because the result of array-to-pointer conversion is not an lvalue. You can't apply ++ to a non-lvalue. Whether something is constant or not is irrelevant. You seem to making a strange conclusion that if you can't modify it it must be a constant. That's totally incorrect. In C terminology the property of being constant has very little to do with the property of being modifiable . The term constant refers to values that are known at compile time . Values that are not known at compile time are never called constants , even if they are not modifiable. This is an example of that: the address of an automatic array is not known at compile time, so even though that address is not modifiable, it is still not an address constant .
