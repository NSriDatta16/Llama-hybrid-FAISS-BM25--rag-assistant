[site]: stackoverflow
[post_id]: 933269
[parent_id]: 933242
[tags]: 
Original Answer The company that created this site apparently makes a scheduling system that answers this question in the context of employees writing code. The way it works is with Monte Carlo simulation of future based on the past. Appendix: Explanation of Monte Carlo This is how this algorithm would work in your situation: You model your task as a sequence of microtasks, say 1000 of them. Suppose an hour later you completed 100 of them. Now you run the simulation for the remaining 900 steps by randomly selecting 90 completed microtasks, adding their times and multiplying by 10. Here you have an estimate; repeat N times and you have N estimates for the time remaining. Note the average between these estimates will be about 9 hours -- no surprises here. But by presenting the resulting distribution to the user you'll honestly communicate to him the odds, e.g. 'with the probability 90% this will take another 3-15 hours' This algorithm, by definition, produces complete result if the task in question can be modeled as a bunch of independent, random microtasks. You can gain a better answer only if you know how the task deviates from this model: for example, installers typically have a download/unpacking/installing tasklist and the speed for one cannot predict the other. Appendix: Simplifying Monte Carlo I'm not a statistics guru, but I think if you look closer into the simulation in this method, it will always return a normal distribution as a sum of large number of independent random variables. Therefore, you don't need to perform it at all. In fact, you don't even need to store all the completed times, since you'll only need their sum and sum of their squares. In maybe not very standard notation, sigma = sqrt ( sum_of_times_squared-sum_of_times^2 ) scaling = 900/100 // that is (totalSteps - elapsedSteps) / elapsedSteps lowerBound = sum_of_times*scaling - 3*sigma*sqrt(scaling) upperBound = sum_of_times*scaling + 3*sigma*sqrt(scaling) With this, you can output the message saying that the thing will end between [lowerBound, upperBound] from now with some fixed probability (should be about 95%, but I probably missed some constant factor).
