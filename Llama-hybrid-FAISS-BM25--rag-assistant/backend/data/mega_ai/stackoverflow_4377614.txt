[site]: stackoverflow
[post_id]: 4377614
[parent_id]: 4376792
[tags]: 
Threat models are nonsense, anything that a security "expert" suggests is probably garbage. Code isn't secure if it's only secure under specific circumstances. Proper encapsulation is congruent to security, which is what E proves. Check out the E language, which has orthogonal security (object capability model) made easy. It's a good proof of concept, there are other languages like this too, such as Joe-E, which is the same paradigm for Java, Emily for Ocaml, Oz-E for Oz. Unfortunately, E is dynamically typed, but fortunately it's done in a much smarter way than other dynamically typed languages I've seen. Even if you don't end up using E for anything, it will still teach you how security comes natural with sound design. This is actually how security should be done; when I think of a computer, I think of a device made to run algorithms and software. Never did I expect a flash game to be able to compromise my entire system and steal all my data. But a few days ago I was running a fully up to date windows 7 install on my lab PC, and it got compromised after browsing the internet with a fully updated Firefox/Flash after a day. This is not how computing should work, you shouldn't have to worry that reading a certain piece of text will make your bank account get stolen. But the unfortunate fact is that every de-facto O/S is fundamentally flawed in this way, and will always be, because they are written in unsafe languages. Anyways, some fundamental things that will help security: no global mutable state, there is no reason for it, ever. sort of the above: don't write to random hardcoded paths in the filesystem, it will cause clashes and more bugs, and vulnerabilities. Ideally, you should just get a handle to some persistent storage passed to your program by the OS, which you can read/write to, then it would be impossible to clash, Java's java.util.prefs.Preferences does exactly this try to deal with strongly typed data as much as possible. stay away from toy languages that encourage parsing text to do everything and languages who are weakly typed, such as bash, Perl, PHP, JavaScript, tcl, C/C++ , Python *, etc. Every time you are manually escaping HTML, escaping input to a bash command, escaping input to SQL, you are asking for trouble. Speaking of HTML, avoid making your application for the web if possible, as the web was not made to be secure. no eval, that's stupid encapsulate properly, this is vital in any orthogonal security language, you can't make a function called getSocket() that creates a file in your system and renames ~/home/lol to ~/home/wtf, follow the Law of Demeter. Basically, just follow good practices (which don't exist much in the real world), and you'll be secure. Sound design = Security = Speed = Usability (but not dumbed down). Encapsulation is key, E forces you to do proper encapsulation. *C/C++ are forbidden. period. Not even the best mathematicians in the world can write large scale C/C++ programs without major vulnerabilities. The best case I know of was a ~4000K line microkernel which ended up with 250K lines of proof. I've never seen a large video game written in C++ without major vulnerabilities. **Python is strongly typed, but it is still error prone, because it encourages doing things like monkey patching, inheritance (but there is no way to prevent private member name clashes, which is a problem all the time). Scope is virtual, so when you access any local variable it looks it up in a dict. It has eval/exec. Everyone just pickles things, which leads to arbitrary code execution (ie, you can never use someone else's Python program data because it might have a pickle which will own you when you read from it). It's slow as hell and probably always will be compared to statically typed languages.
