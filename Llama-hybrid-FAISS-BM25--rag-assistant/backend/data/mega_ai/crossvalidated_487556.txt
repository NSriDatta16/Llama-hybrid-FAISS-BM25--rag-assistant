[site]: crossvalidated
[post_id]: 487556
[parent_id]: 294824
[tags]: 
"I am looking at an example in R, and I am confused as to what the second row in my control point matrix p represents. 0 0 dictates where my curve begins, and 2 2 where it ends. However, what's an intuitive interpretation of 1 4?" Given the time since you asked this, YQC, you've probably found an answer. But I'm going to write one anyway, as it may help other people. A brief answer is this. You've called a quadratic Bézier function, passing it the points 0 0, 1 4, and 2 2. You understand 0 0 and 2 2, but what does 1 4 do? Look at the graph below. In it, 0 0 is labelled P0 , 1 4 is labelled P1 , and 2 2 is labelled P2 . The points other than P1 make your Bézier curve. P1 controls the direction it takes. It starts by aiming directly for P1 from P0 , and then gradually changes direction, swinging round until right at the end, it's aiming directly for P1 from P2 . At its midpoint, it's aiming equally from both, if I can say it that way. Now I've given the executive summary, here are some details. First, a preliminary. You don't need to call that bezier function in such a complicated way, subscripting the matrix. I know why you did: it's because the example in the documentation does it that way. But you can simplify. This is how you called it: t And this is the simpler way: p Instead of subscripting the matrix p , I've put into it only the points that I need to recreate your example. I did this because I'm going to work with it further, matching it up with the Wikipedia article on these functions. But first, I'll check that the two calls do give the same results: assert_that( are_equal( bezier_points_1, bezier_points_2 ) ) See the documentation for package "assertthat" if you want to know what I just did. So now let's look at https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves . You said "I am confused as to what the second row in my control point matrix p represents. 0 0 dictates where my curve begins, and 2 2 where it ends. However, what's an intuitive interpretation of 1 4?". This is explained in the section on Quadratic Bézier curves. Stack Exchange don't encourage answering by linking to other sites, because these sites might die before Stack Exchange does. So I'll copy the appropriate chunk of Wikipedia. As an image, unfortunately, because I don't know a quick way to transcribe the formulae into HTML. The key clause is this: "from which it can be concluded that the tangents to the curve at P0 and P2 intersect at P1 . As t increases from 0 to 1, the curve departs from P0 in the direction of P1 , then bends to arrive at P2 from the direction of P1 ." To test my understanding, I recreated the Wikipedia definition in R. Wikipedia describes a function B which takes points P0 , P1 and P2 , and a parameter t . Here's my translation of Wikipedia's definition into R. In it, P0 , P1 and P2 have to remain the same for all calls that generate a particular curve, while t varies. B Now I'm going to test this and see whether it gives the same results as my calls to bezier above. If it doesn't, I've not understood it. Here's my code: bezier_points_3 In this, bezier_points_3 is a matrix that will hold the results. Unlike with bezier , I have to call B one point at a time, hence the loop. ti varies over t . P0 , P1 and P2 are your points. The assert_that checks that the result is the same as that given by bezier . When I ran this, it did indeed generate the same result as the calls to bezier , so I knew that I'd understood the purpose of Wikipedia's B . I then tried plotting a graph to answer your question about what P1 does. The graph is below, and shows the results produced by B , as well as point P1 . Note that, as you said, P0 is where the curve begins and P2 where it ends. But P1 is not on the curve: Again, I'll quote Wikipedia: "the tangents to the curve at P0 and P2 intersect at P1 . As t increases from 0 to 1, the curve departs from P0 in the direction of P1 , then bends to arrive at P2 from the direction of P1 ." And that's exactly what's happening. The first line segment, leading out of P0 , is pointing almost-but-not-quite at P1 . But then the curve starts bending around. The final line segment, leading into P2 , is pointing almost-but-not-quite from P1 to P2 . Please note that although I plotted the results from my Wikipedia-inspired function B , I'd have got exactly the same plot had I called bezier . Finally, my plotting code is below: colnames( bezier_points_3 ) This uses functions from Hadley Wickham's Tidyverse system. One of the packages called is ggplot2 , which I find more versatile than base-R plotting. Its graphs also look nicer. I also use "tibbles" , which are data frames but again more versatile, and more efficient. Most of the plotting code is just chopping around data and associating it with text or graphics. The first line sets the names in the matrix of results from B so that the first column is called "x" and the second "y". The second line generates a tibble (i.e. data frame) from those results. The third line generates another with P1 added. This will be used for plotting the points on my plot, whereas the other will be used for plotting the lines between them. labels becomes yet another tibble, holding the coordinates and names of P0 , P1 and P2 in order to label them. data_line_1 and data_line_2 are the dashed lines to P1 . And in the plotting code, geom_point adds the points including P1 ; the first geom_line adds the lines between them; geom_text_repel adds the three labels, pushing them away from other stuff they might overlap; and the final two geom_lines add the dashed lines. It's a feature of ggplot, designed in from the beginning, that you can build up graphs in layers like this. If you combine the code fragments above, they'll run, but you need some libraries at the beginning. These are: library( bezier ) library( assertthat ) library( tidyverse ) library( ggplot2 ) library( ggrepel )
