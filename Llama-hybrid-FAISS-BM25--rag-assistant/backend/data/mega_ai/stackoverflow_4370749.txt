[site]: stackoverflow
[post_id]: 4370749
[parent_id]: 4370660
[tags]: 
To clarify, you have multiple dictionaries, but you want a unique data['key']? E.g., if data1['key'] = 'hello' you want to make sure that data2['key'] = 'hello' isn't allowed? Do you want it just raise an error? This is a way to validate that its fine. (Also its not good to name your list 'list' as list is a datatype in python) datalist = [datadict1, datadict2, datadict3] big_key_list = [] for datadict in datalist: curkey = datadict.get('key') if curkey not in big_key_list: big_key_list.append(curkey) else: raise Exception("Key %s in two data dicts" % curkey) Now a better way of doing this would be to create a new class inheriting from dict that contains subdictionaries, but doesn't allow multiple keys to have the same value. This way errors get thrown upon assignment rather than you can just check if things are fine (and not know what to do if things aren't fine, other than raise an error). EDIT: Actually, looking at what you likely want to do, you have the data setup incorrectly. I say this as it seems you want to have a separate dictionary for each entry. This is almost certainly an inelegant way of doing it. First create a class: class MyDataObject(object): def __init__(self, **kwargs): for k,v in kwargs: self.__dict__[k] = v or if they always will have all 4 fixed parameters: class MyDataObject(object): def __init__(self, timestamp, action, obj_type, obj_id): self.timestamp = timestamp self.action = action self.type = obj_type self.id = obj_id Then just define your datatypes. data = {} data['key1'] = MyDataObject(timestamp='some timestamp', action='some action', type='some type', id = 1234) data['key2'] = MyDataObject(timestamp='some timestamp2', action='some action2', type='some type2', id = 1235) You would access your data like: data['key1'].timestamp # returns 'some timestamp' data['key2'].action # returns 'some action2' or you can even access using dict () (e.g., this is helpful if you have a variable x='action' and you want to access it). data['key1'].__dict__('action') # returns 'some action' data['key2'].__dict__('timestamp') # returns 'some timestamp2' Now you just have a dictionary of objects, where the key is unique and the data associated with the key is kept as one object (of type MyDataObject).
