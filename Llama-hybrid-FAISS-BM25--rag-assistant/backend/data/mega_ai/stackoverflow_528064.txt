[site]: stackoverflow
[post_id]: 528064
[parent_id]: 527510
[tags]: 
I sometimes use the approach I describe below, for the exact same reason that @Boris states: I would prefer that the use of some code is as easy as a) svn checkout/update - b) go. But for the record: I use virtualenv/easy_install most of the time. I agree to a certain extent to the critisisms by @Ali A and @S.Lott Anyway, the approach I use depends on modifying sys.path, and works like this: Require python and setuptools (to enable loading code from eggs) on all computers that will use your software. Organize your directory structure this: project/ *.py scriptcustomize.py file.pth thirdparty/ eggs/ mako-vNNN.egg ... .egg code/ elementtree\ *.py ... In your top-level script(s) include the following code at the top: from scriptcustomize import apply_pth_files apply_pth_files(__file__) Add scriptcustomize.py to your project folder: import os from glob import glob import fileinput import sys def apply_pth_files(scriptfilename, at_beginning=False): """At the top of your script: from scriptcustomize import apply_pth_files apply_pth_files(__file__) """ directory = os.path.dirname(scriptfilename) files = glob(os.path.join(directory, '*.pth')) if not files: return for line in fileinput.input(files): line = line.strip() if line and line[0] != '#': path = os.path.join(directory, line) if at_beginning: sys.path.insert(0, path) else: sys.path.append(path) Add one or more *.pth file(s) to your project folder. On each line, put a reference to a directory with packages. For instance: # contents of *.pth file thirdparty/code thirdparty/eggs/mako-vNNN.egg I "kind-of" like this approach. What I like: it is similar to how *.pth files work, but for individual programs instead of your entire site-packages. What I do not like: having to add the two lines at the beginning of the top-level scripts. Again: I use virtualenv most of the time. But I tend to use virtualenv for projects where I have tight control of the deployment scenario. In cases where I do not have tight control, I tend to use the approach I describe above. It makes it really easy to package a project as a zip and have the end user "install" it (by unzipping).
