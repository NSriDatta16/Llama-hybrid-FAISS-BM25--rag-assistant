[site]: stackoverflow
[post_id]: 2904886
[parent_id]: 2904839
[tags]: 
In C#, declaring previous like that gives you a reference. In C++, declaring previous like that gives you an object, embedded in each object of class Node . An object can't have an object of the same class embedded in it, recursively. previous.name would have to exist (and have storage allocated to it), as would previous.previous.name , and so on infinitely, all in a single memory allocation. The size of a Node object would have to be at least as much as the size of a string object plus the size of a Node object (which is impossible since string is more than 0 bytes). And other such contradictions. As others say, use a pointer: Node *previous or a reference Node &previous . Or a std::deque ;-) You might like to know that C++ differs from C# in other ways which will spoil your day if you're trying to write a singly-linked list by porting C# code. No garbage collection, for example. You can't write correct C++ code without understanding the C++ object model.
