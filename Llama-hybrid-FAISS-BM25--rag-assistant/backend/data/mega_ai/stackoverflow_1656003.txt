[site]: stackoverflow
[post_id]: 1656003
[parent_id]: 1655996
[tags]: 
I don't know what you're trying to do, but templates are parameterized by type. An ordinary function or a function object should do what you want. So let's make your function look like this: void calculate(const string &key, multimap & myMap) { // do something... } now we can use the STL's binders and ptr_fun to convert your function to an object and bind its second argument to your map. multimap map1; vector v = getValuesForMyVector(); for_each(v.begin(), v.end(), bind2nd(ptr_fun(calculate), map1); So what's going on is that ptr_fun(calculate) converts calculate , which is a pointer-to-function, into a special class called a pointer_to_binary_function , void> which has operator() defined to call your function, i.e. it takes 2 parameters. bind2nd(ptr_fun(calculate), map1) returns a binder2nd which still has operator() defined, but now it only takes 1 parameter. The 2nd parameter is bound to map1. This allows for_each to operate with this function object. Of course, you're stuck using these 2 adaptors if you make a function. A better way is to make a class: class MapCalculator { public: MapCalculator(multimap & destination) : map_(destination) {} void operator()(const string& s) { // do something... } private: multimap & map_; }; // later... multimap map1; vector v = getValuesForMyVector(); for_each(v.begin(), v.end(), MapCalculator(map1));
