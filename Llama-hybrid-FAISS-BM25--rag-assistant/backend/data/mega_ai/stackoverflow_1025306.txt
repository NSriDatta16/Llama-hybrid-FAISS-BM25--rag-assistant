[site]: stackoverflow
[post_id]: 1025306
[parent_id]: 15496
[tags]: 
An optimization trick that makes your code easier to maintain and less susceptible to a concurrency bug. public class Slow { /** Loop counter; initialized to 0. */ private long i; public static void main( String args[] ) { Slow slow = new Slow(); slow.run(); } private void run() { while( i++ $ time java Slow real 0m15.397s $ time java Slow real 0m20.012s $ time java Slow real 0m18.645s Average: 18.018s public class Fast { /** Loop counter; initialized to 0. */ private long i; public static void main( String args[] ) { Fast fast = new Fast(); fast.run(); } private void run() { long i = getI(); while( i++ $ time java Fast real 0m12.003s $ time java Fast real 0m9.840s $ time java Fast real 0m9.686s Average: 10.509s It requires more bytecodes to reference a class-scope variable than a method-scope variable. The addition of a method call prior to the critical loop adds little overhead (and the call might be inlined by the compiler anyway). Another advantage to this technique (always using accessors) is that it eliminates a potential bug in the Slow class. If a second thread were to continually reset the value of i to 0 (by calling slow.setI( 0 ) , for example), the Slow class could never end its loop. Calling the accessor and using a local variable eliminates that possibility. Tested using J2SE 1.6.0_13 on Linux 2.6.27-14.
