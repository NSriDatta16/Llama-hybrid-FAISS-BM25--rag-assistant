[site]: stackoverflow
[post_id]: 2745230
[parent_id]: 2745193
[tags]: 
Generics are invariant. Object o = "someString"; // FINE! Class klazz = String.class; // DOESN'T COMPILE! // cannot convert from Class to Class Depending on what it is that you need, you may be able to use wildcards. Class klazz = Integer.class; // FINE! Or perhaps you need something like this: Class > klazz = (Class >) new ArrayList ().getClass(); // WARNING! Type safety: Unchecked cast from // Class to Class > As for the non-reified at run-time case, you seem to have a good grasp, but here's a quote anyway, from the Java Tutorials on Generics , The Fine Print : A Generic Class is Shared by All Its Invocations : What does the following code fragment print? List l1 = new ArrayList (); List l2 = new ArrayList (); System.out.println(l1.getClass() == l2.getClass()); You might be tempted to say false , but you'd be wrong. It prints true , because all instances of a generic class have the same run-time class, regardless of their actual type parameters. That is, there's no such thing as List .class or List .class ; there's only List.class . This is also reflected in the JLS 15.8.2 Class Literals A class literal is an expression consisting of the name of a class, interface, array, or primitive type, or the pseudo-type void, followed by a . and the token class . Note the omission of any allowance for generic type parameters/arguments. Furthermore, It is a compile time error if any of the following occur: The named type is a type variable or a parameterized type, or an array whose element type is a type variable or parameterized type. That is, this also doesn't compile: void test() { Class klazz = T.class; // DOESN'T COMPILE! // Illegal class literal for the type parameter T } Basically you can't use generics with class literals, because it just doesn't make sense: they're non-reified.
