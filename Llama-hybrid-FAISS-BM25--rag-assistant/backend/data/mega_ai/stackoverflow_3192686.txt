[site]: stackoverflow
[post_id]: 3192686
[parent_id]: 3189545
[tags]: 
Globals aren't evil Had to get that off my chest first :) I'd stick the constants into a struct, and make a global instance of that: struct Constants { double g; // ... }; extern Constants C = { ... }; double Grav(double m1, double m2, double r) { return C.g * m1 * m2 / (r*r); } (Short names are ok, too, all scientists and engineers do that.....) I've used the fact that local variables (i.e. members, parameters, function-locals, ..) take precedence over the global in a few cases as "apects for the poor": You could easily change the method to double Grav(double m1, double m2, double r, Constants const & C = ::C) { return C.g * m1 * m2 / (r*r); } // same code! You could create an struct AlternateUniverse { Constants C; AlternateUniverse() { PostulateWildly(C); // initialize C to better values double Grav(double m1, double m2, double r) { /* same code! */ } } } The idea is to write code with least overhead in the default case, and preserving the implementation even if the universal constants should change. Call Scope vs. Source Scope Alternatively, if you/your devs are more into procedural rather thsn OO style, you could use call scope instead of source scope , with a global stack of values, roughly: std::deque g_constants; void InAnAlternateUniverse() { PostulateWildly(C); // g_constants.push_front(C); CalculateCoreTemp(); g_constants.pop_front(); } void CalculateCoreTemp() { Constants const & C= g_constants.front(); // ... } Everything in the call tree gets to use the "most current" constants. OYu can call the same tree of coutines - no matter how deeply nested - with an alternate set of constants. Of course it should be encapsulated better, made exception safe, and for multithreading you need thread local storage (so each thread gets it's own "stack") Calculation vs. User Interface We approach your original problem differently: All internal representation, all persistent data uses SI base units. Conversion takes place at input and output (e.g. even though the typical size is millimeter, it's always stored as meter). I can't really compare, but worksd very well for us. Dimensional Analysis Other replies have at least hinted at Dimensional Analysis, such as the respective Boost Library . It can enforce dimensional correctness, and can automate the input / output conversions.
