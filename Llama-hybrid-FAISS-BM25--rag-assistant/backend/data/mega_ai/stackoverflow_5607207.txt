[site]: stackoverflow
[post_id]: 5607207
[parent_id]: 5607099
[tags]: 
It seems that you have two tasks here. To count the number of occurrences of each index in z and allocate a data structure of the right size and configuration. To iterate over the data and copy it to the correct places. At the moment you appear to have solved (1) naively by allocating a big, two dimensional array iz . That works fine if you know in advance the limits on how big it could be (and your machine will have enough memory), no need to fix this until later. It is not clear to me exactly how (2) should be approached. Is the data currently going into iz guaranteed to consist of [0, 1, ... n ]? If you don't know the limits of the size of iz in advance, then you will have to allocate a dynamic structure. I'd suggest a ragged array though this means two (or even three) passes over z . What do I mean by a ragged array? A object like the argv argument to main , but in this case of type int ** . In memory it looks like this: +----+ +---+ +---+---+---+-- | iz |---->| |---->| | | ... +----+ +---+ +---+---+---+-- | |-- +---+ \ +---+---+---+-- | . | --->| | | ... . +---+---+---+-- . A ragged array can be accessed with iz[][] just like it was a two-dimensional array (but it is a different type of object), which is nice for your purposes because you can tune your algorithm with the code you have now, and then slap one of these in place. How to set it up. Iterate of z to find the largest number, maxZ , present. Allocate an array of int* of size maxZ+1 : iz=callac(maxZ+1,sizeof(int*)); . I chose calloc because it zeros the memory, which makes all those pointers NULL , but you could use malloc and NULL them yourself. Making the array one too big gives us a NULL termination, which may be useful later. Allocate an array of counters of size maxZ : int *cz = calloc(maxZ,sizeof(int)); iterate over z , filling cz with the number of entries needed in each row. For each row, allocate an array of ints: for(i=0; i Iterate over z one last time, sticking the figures into iz as you already do. You could re-use cz at this point to keep track of how many figure have already been put into each row, but you might want to allocate a separate array for that purpose because so that you have a record of how big each allocated array was. NB: Every call to malloc or calloc ought to be accompanied by a check to insure that the allocation worked. I've left that as an exercise for the student. This repeated passes over z business can be avoided entirely by using dynamic arrays, but I suspect you don't need that and don't want the added complexity.
