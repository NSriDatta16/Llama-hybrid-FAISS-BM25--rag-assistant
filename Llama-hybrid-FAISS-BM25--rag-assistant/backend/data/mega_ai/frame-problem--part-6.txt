y memory outside the footprint (memory accessed) of the code to be added to a specification: this enables the initial specification to concentrate only on the footprint. For example, the inference { list ⁡ ( x ) } c o d e { sortedlist ⁡ ( x ) } { list ⁡ ( x ) ∗ sortedlist ⁡ ( y ) } c o d e { sortedlist ⁡ ( x ) ∗ sortedlist ⁡ ( y ) } {\displaystyle {\frac {\{\operatorname {list} (x)\}\ \mathrm {code} \ \{\operatorname {sortedlist} (x)\}}{\{\operatorname {list} (x)\ast \operatorname {sortedlist} (y)\}\ \mathrm {code} \ \{\operatorname {sortedlist} (x)\ast \operatorname {sortedlist} (y)\}}}} captures that code which sorts a list x does not unsort a separate list y, and it does this without mentioning y at all in the initial spec above the line. Automation of the frame rule has led to significant increases in the scalability of automated reasoning techniques for code, eventually deployed industrially to codebases with tens of millions of lines. There appears to be some similarity between the separation logic solution to the frame problem and that of the fluent calculus mentioned above. Action description languages Action description languages elude the frame problem rather than solving it. An action description language is a formal language with a syntax that is specific for describing situations and actions. For example, that the action o p e n d o o r {\displaystyle \mathrm {opendoor} } makes the door open if not locked is expressed by: o p e n d o o r {\displaystyle \mathrm {opendoor} } causes o p e n {\displaystyle \mathrm {open} } if ¬ l o c k e d {\displaystyle \neg \mathrm {locked} } The semantics of an action description language depends on what the language can express (concurrent actions, delayed effects, etc.) and is usually based on transition systems. Since domains are expressed in these languages rather than directly in logic, the frame problem only arises when a specification given in an action description logic is to be translated into logic. Typically, however, a translation is given from these languages to answer set programming rather than first-order logic. See also Binding problem Common sense Commonsense reasoning Defeasible reasoning Linear logic Separation logic Non-monotonic logic Qualification problem Ramification problem Symbol grounding Yale shooting problem Notes References Doherty, P.; Gustafsson, J.; Karlsson, L.; Kvarnström, J. (1998). "TAL: Temporal action logics language specification and tutorial". Electronic Transactions on Artificial Intelligence. 2 (3–4): 273–306. Gelfond, M.; Lifschitz, V. (1993). "Representing action and change by logic programs". Journal of Logic Programming. 17 (2–4): 301–322. doi:10.1016/0743-1066(93)90035-f. Gelfond, M.; Lifschitz, V. (1998). "Action languages". Electronic Transactions on Artificial Intelligence. 2 (3–4): 193–210. Hanks, S.; McDermott, D. (1987). "Nonmonotonic logic and temporal projection". Artificial Intelligence. 33 (3): 379–412. doi:10.1016/0004-3702(87)90043-9. Levesque, H.; Pirri, F.; Reiter, R. (1998). "Foundations for the situation calculus". Electronic Transactions on Artificial Intelligence. 2 (3–4): 159–178. Liberatore, P. (1997). "The complexity of the language A". Electronic Transactions on Artificial Intelligence. 1 (1–3): 13–37. Lifschitz, V. (2012). "The frame problem, then and now" (PDF). University of Texas at Austin. Archived (PDF) from the original on 2014-02-11. Presented at Celebration of John McCarthy's Accomplishments, Stanford University, March 25, 2012. McCarthy, J.; Hayes, P. J. (1969). "Some philosophical problems from the standpoint of artificial intelligence". Machine Intelligence. 4: 463–502. CiteSeerX 10.1.1.85.5082. McCarthy, J. (1986). "Applications of circumscription to formalizing common-sense knowledge". Artificial Intelligence. 28: 89–116. CiteSeerX 10.1.1.29.5268. doi:10.1016/0004-3702(86)90032-9. Miller, R.; Shanahan, M. (1999). "The event-calculus in classical logic - alternative axiomatizations". Electronic Trans