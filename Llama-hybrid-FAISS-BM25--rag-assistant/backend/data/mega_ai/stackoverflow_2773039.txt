[site]: stackoverflow
[post_id]: 2773039
[parent_id]: 2772471
[tags]: 
To update with uninterrupted sequence you can use the following: SET @reset := 0; UPDATE dp_positions SET positions = CASE WHEN id_layout_position > @reset THEN IF(@pos:=0,NULL, @reset:=id_layout_position) ELSE @pos := @pos + 1 END - 1 ORDER BY id_layout_position, position; Notes: @reset should be set to minimum value of id_layout_position, assuming that you are restarting the counter on id_layout_position change, if it is more complicated the WHEN condition will need to change and you might need more variables to hold the values from previous row. Furthermore the IF is a hack, it will never be NULL as long you are setting @pos to 0 and not to some other starting value, I just didn't know how to force mysql to evaluate two expressions (anyone, is there something elegant there?) The above is tested, but with different column/table names (retyping errors possible). EDIT: My testing was not so good, the above has an error, and also seems OP needs to bypass security of a framework, so here's a correction and stored procedure version Using phpmyadmin or mysql command line execute delimiter // CREATE PROCEDURE `renumerate`() BEGIN SET @pos := -1; SET @reset := (SELECT MIN(id_layout_position) FROM dp_position); UPDATE dp_positions SET position = CASE WHEN b > @reset THEN IF(@reset:=id_layout_position, @pos:=0, @pos:=0) ELSE @pos := @pos + 1 END ORDER BY id_layout_position, position; END // delimiter ; (in case you use phpMyAdmin do not use delimiter statements but directly specify delimiter in the interface as //). When calling the procedure execute normal SQL $smcFunc['db_query']('', 'CALL renumerate()'); Hope my testing was better this time.
