[site]: stackoverflow
[post_id]: 3097196
[parent_id]: 3095146
[tags]: 
A well-considered question, even it'll scare most people off :) Anyway, I think option (2) is the closest to a practical solution. My first suggestion is that you encapsulate the list of tags into its own model class. This will give the data binding framework a concrete type to register against, whereas List and String are much too general. So you would have the model classes: public class Entry { private String name; private TagList tagList; } public class TagList { private final List tags; public TagList(List tags) { this.tags = tags; } public List getTags() { return tags; } } You then have a PropertyEditor that knows how to convert to and from a TagList : public class TagListEditor extends PropertyEditorSupport { @Override public void setAsText(String text) throws IllegalArgumentException { TagList tagList = // parse from the text value setValue(tagList); } @Override public String getAsText() { TagList tagList = (TagList) getValue(); return tagList.toString(); // or whatever } } And finally, you need to tell the controller to use the converter: @Controller public class EntryController { @InitBinder public void initBinder(WebDataBinder binder) { binder.registerCustomEditor(TagList.class, new TagListEditor()); } // request mappings here } I'm fairly sure the new Spring 3 Converter framework would produce a more elegant solution, but I haven't figured it out yet :) This approach, however, I know works.
