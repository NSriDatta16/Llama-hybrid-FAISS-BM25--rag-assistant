[site]: stackoverflow
[post_id]: 4795204
[parent_id]: 4795066
[tags]: 
Just use CanExecute method of the PageUpCommand for that. Return false if where are no pages left and the button will become disabled automatically. EDIT: I have created a simple attached behavior that can be used to fix this problem. Just set the following attached property on the ScrollViewer : And here is the source code of the behavior: public static class ScrollBarCommandsCanExecuteFixBehavior { #region Nested Types public class CommandCanExecuteMonitor where T : UIElement { protected T Target { get; private set; } protected CommandCanExecuteMonitor(T target, RoutedCommand command) { Target = target; var binding = new CommandBinding(command); binding.CanExecute += OnCanExecute; target.CommandBindings.Add(binding); } protected virtual void OnCanExecute(object sender, CanExecuteRoutedEventArgs e) { } } public class PageUpCanExecuteMonitor : CommandCanExecuteMonitor { public PageUpCanExecuteMonitor(ScrollViewer scrollViewer) : base(scrollViewer, ScrollBar.PageUpCommand) { } protected override void OnCanExecute(object sender, CanExecuteRoutedEventArgs e) { if (e.Handled) { return; } if (Equals(Target.VerticalOffset, 0.0)) { e.CanExecute = false; e.Handled = true; } } } public class PageDownCanExecuteMonitor : CommandCanExecuteMonitor { public PageDownCanExecuteMonitor(ScrollViewer scrollViewer) : base(scrollViewer, ScrollBar.PageDownCommand) { } protected override void OnCanExecute(object sender, CanExecuteRoutedEventArgs e) { if (e.Handled) { return; } if (Equals(Target.VerticalOffset, Target.ScrollableHeight)) { e.CanExecute = false; e.Handled = true; } } } #endregion #region IsEnabled Attached Property public static bool GetIsEnabled(DependencyObject obj) { return (bool) obj.GetValue(IsEnabledProperty); } public static void SetIsEnabled(DependencyObject obj, bool value) { obj.SetValue(IsEnabledProperty, value); } public static readonly DependencyProperty IsEnabledProperty = DependencyProperty.RegisterAttached("IsEnabled", typeof (bool), typeof (ScrollBarCommandsCanExecuteFixBehavior), new PropertyMetadata(false, OnIsEnabledChanged)); private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { if ((bool) e.NewValue) { var scrollViewer = d as ScrollViewer; if (scrollViewer != null) { OnAttached(scrollViewer); } else { throw new NotSupportedException("This behavior only supports ScrollViewer instances."); } } } private static void OnAttached(ScrollViewer target) { SetPageUpCanExecuteMonitor(target, new PageUpCanExecuteMonitor(target)); SetPageDownCanExecuteMonitor(target, new PageDownCanExecuteMonitor(target)); } #endregion #region PageUpCanExecuteMonitor Attached Property private static void SetPageUpCanExecuteMonitor(DependencyObject obj, PageUpCanExecuteMonitor value) { obj.SetValue(PageUpCanExecuteMonitorProperty, value); } private static readonly DependencyProperty PageUpCanExecuteMonitorProperty = DependencyProperty.RegisterAttached("PageUpCanExecuteMonitor", typeof (PageUpCanExecuteMonitor), typeof (ScrollBarCommandsCanExecuteFixBehavior), new PropertyMetadata(null)); #endregion #region PageDownCanExecuteMonitor Attached Property private static void SetPageDownCanExecuteMonitor(DependencyObject obj, PageDownCanExecuteMonitor value) { obj.SetValue(PageDownCanExecuteMonitorProperty, value); } private static readonly DependencyProperty PageDownCanExecuteMonitorProperty = DependencyProperty.RegisterAttached("PageDownCanExecuteMonitor", typeof (PageDownCanExecuteMonitor), typeof (ScrollBarCommandsCanExecuteFixBehavior), new PropertyMetadata(null)); #endregion } The basic idea is that we add a CommandBinding to the ScrollViewer for each of the commands and subscribe to the CanExecute event on those bindings. In the event handler we check the current position of the scroll and set the e.CanExecute property accordingly.
