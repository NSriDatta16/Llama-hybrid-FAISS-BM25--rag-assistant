[site]: stackoverflow
[post_id]: 2006254
[parent_id]: 2006163
[tags]: 
I don't know of anything that gives "100 %" coverage, but for vectorizing code (which aliasing often prevents) use the -ftree-vectorizer-verbose=n option, where n is an integer between 1 and 6. This prints out some info why a loop couldn't be vectorized. For instance, with g++ 4.1, the code //#define RSTR __restrict__ #define RSTR void addvec(float* RSTR a, float* b, int n) { for (int i = 0; i results in $ g++ -ftree-vectorizer-verbose=1 -ftree-vectorize -O3 -c aliastest.cpp aliastest.cpp:6: note: vectorized 0 loops in function. Now, switch to the other definition for RSTR and you get $ g++ -ftree-vectorizer-verbose=1 -ftree-vectorize -O3 -c aliastest.cpp aliastest.cpp:6: note: LOOP VECTORIZED. aliastest.cpp:6: note: vectorized 1 loops in function. Interestingly, if one switches to g++ 4.4, it can vectorize the first non-restrict case by versioning and a runtime check: $ g++44 -ftree-vectorizer-verbose=1 -O3 -c aliastest.cpp aliastest.cpp:6: note: created 1 versioning for alias checks. aliastest.cpp:6: note: LOOP VECTORIZED. aliastest.cpp:4: note: vectorized 1 loops in function. And this is done for both of the RSTR definitons.
