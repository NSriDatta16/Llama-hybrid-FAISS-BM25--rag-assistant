[site]: stackoverflow
[post_id]: 2732731
[parent_id]: 2732715
[tags]: 
What engine are you using for MySQL? The thing to note here is if you're using MyISAM, then you're going to have locking issues due to the table locking that engine uses. From: MySQL Table Locking Table locking is also disadvantageous under the following scenario: * A session issues a SELECT that takes a long time to run. * Another session then issues an UPDATE on the same table. This session waits until the SELECT is finished. * Another session issues another SELECT statement on the same table. Because UPDATE has higher priority than SELECT, this SELECT waits for the UPDATE to finish, after waiting for the first SELECT to finish. I won't repeat them here, but the page has some tips on increasing concurrency on a table within MySQL. Obviously, one option would be to change to an engine like InnoDB which has a more complex row locking mechanism that for high concurrency tables can make a huge difference in performance. For more info on InnoDB go here . Prior to changing the engine though it would probably be worth looking at the other tips like making sure your table is indexed properly, etc. as this will increase select and update performance regardless of the storage engine. Edit based on user comment: I would say it's one possible solution based on the symptoms you've described, but it may not be the one that will get you where you want to be. It's impossible to say without more information. You could be doing full table scans due to the lack of indexes. This could be causing I/O contention on your disk, which just further exasterbates the table locks used by MyISAM. If this is the case then the root of the cause is the improper indexing and rectifying that would be your best course of action before changing storage engines. Also, make sure your tables are normalized. This can have profound implications on performance especially on updates. Normalized tables can allow you to update a single row instead of hundreds or thousands in an un-normalized table. This is due to unduplicated values. It can also save huge amounts of I/O on selects as the db can more efficiently cache data blocks. Without knowing the structure of the tables you're working with or the indexes you have present it's difficult to provide you with a more detailed response. Edit after user attempted using InnoDB: You mentioned that your Java process is multi-threaded. Have you tried running the process with a single thread? I'm wondering if maybe it's possibly you're sending the same rows to update out to multiple threads and/or the way you're updating across threads is causing locking issues. Outside of that, I would check the following: Have you checked your explain plans to verify you have reasonable costs and that the query is actually using the indexes you have? Are your tables normalized? More specifically, are you updating 100 rows when you could update a single record if the tables were normalized? Is it possible that you're running out of physical memory when the Java process is running and the machine is busy swapping stuff in and out? Are you flooding your disk (a single disk?) with more IOPs than it can reasonably handle?
