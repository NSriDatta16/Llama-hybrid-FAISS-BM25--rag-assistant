[site]: stackoverflow
[post_id]: 5409903
[parent_id]: 5370032
[tags]: 
I suppose the main problem of your code is that you don't abort the previous pending ajax call. What happens in the browser if it simultaneously will try to modify $sr element on two server response? Both old XMLHttpRequest and new jqXHR has abort method which you can use. UPDATED : As I described in the comment the jQuery.load do not much more as the jQuery.ajax call and jQuery.html to place the server response on the page. You can verify this looking in the source code of jQuery.load here (for jQuery 1.4.4) or here (for jQuery 1.5.1). I prepared one small demo example for you which shows how you can use jQuery.ajax and jQuery.html directly instead of jQuery.load . You can download the full project here . If one types in the input box of the demo slowly one receive the following results If one types more quickly (I type very slow and so use 1 sec timeout on the server): One can see that I abort the previous ajax request to the server if any pending ajax request exist. In case of aborting the error handler of the corresponding (previous) ajax request are called and then the abort() function return. I hope if you follow the way you will never have the problems which you describes in your question. To be sure that you receive the example I include the full code, which I used in my test demo, below. The JavaScript code is following var jqXHR_Old, $myinput = $('#myinput'), $result = $('#result'), $protocol = $('#protocol'), logText = function(txt) { $protocol.append(txt+" "); // append or prepend }, doSearch = function(code) { var txt = $myinput.val(); if (txt != '') { // send request to the server if (jqXHR_Old) { // abort the previous request logText("aborting..."); jqXHR_Old.abort(); jqXHR_Old = null; } $result.empty(); logText('sending request to the server with '+ ' '+txt+' ...'); jqXHR_Old = $.ajax({ url: "MySimpleService.svc/GetTestHtmlFragment", data: {str:txt}, dataType: "html", success: function (data) { $result.html(data); logText("received from the server: "+data); jqXHR_Old = null; }, error: function (XMLHttpRequest, textStatus, errorThrown) { if (textStatus !== "abort" || errorThrown !== "abort") { $result.html("Error Occured!" + " | " + " | " + textStatus + " | " + errorThrown + "responseText: " + XMLHttpRequest.responseText); } else { logText("request aborted."); } jqXHR_Old = null; } }); } }; $myinput.keyup(function(e) { switch (e.keyCode) { //case 8: // Backspace case 9: // Tab case 13: // Enter doSearch(e.keyCode); break; case 37: // Left break; case 38: // Up doSearch(e.keyCode); break; case 39: // Right break; case 40: // Down doSearch(e.keyCode); break; default: doSearch(e.keyCode); } }); HTML is here Results from the server: Ajax protocol: As the server I use very simple WCF service with the interface using System.ServiceModel; using System.ServiceModel.Web; using System.ServiceModel.Channels; namespace AjaxLoad { [ServiceContract] public interface ISimpleService { [OperationContract] [WebGet] Message GetTestHtmlFragment (string str); } } and the implementation using System.ServiceModel.Activation; using System.ServiceModel.Web; using System.ServiceModel.Channels; using System.Text; using System.Threading; namespace AjaxLoad { [AspNetCompatibilityRequirements (RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)] public class SimpleService : ISimpleService { public Message GetTestHtmlFragment (string str) { Thread.Sleep (1000); return WebOperationContext.Current.CreateTextResponse (" " + str + " ", "text/html; charset=utf-8", Encoding.UTF8); } } } I simulate slow request processing just with Thread.Sleep with 1 sec waiting. I used SVC file free implementation and so used as web.config As "References" of the project three dependent assemblies needed: System, System.ServiceModel, System.ServiceModel.Web.
