[site]: stackoverflow
[post_id]: 1133013
[parent_id]: 1132941
[tags]: 
Suppose you have the following code fruits = ("apples", "bananas", "loganberries") def eat(food=fruits): ... When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple ("apples", "bananas", "loganberries") However, suppose later on in the code, I do something like def some_random_function(): global fruits fruits = ("blueberries", "mangos") then if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your foo function above was mutating the list. The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code: StringBuffer s = new StringBuffer("Hello World!"); Map counts = new HashMap (); counts.put(s, 5); s.append("!!!!"); System.out.println( counts.get(s) ); // does this work? Now, does my map use the value of the StringBuffer key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the Map using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys). Your example is a good one of a case where Python newcomers will be surprised and bitten. But I'd argue that if we "fixed" this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing. I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.
