[site]: stackoverflow
[post_id]: 5440301
[parent_id]: 5440248
[tags]: 
I don't think you're using std::type_info in a way that works with Boost::Variant. Idea: Use the code similar to that provided here to wrap your calls to encode your own tag. By using a visitor, you'll essentially restrict yourself to the public interface of the Boost.Variant library. Alternative: use variant.which Don't try to piggy back off of boost::variant's internal tagging and data storage, since it might change later. Keep in mind that Boost.Variant may allocate its internal data differently based on compiler features and based the properties of the template parameters (e.g. reference types are treated specially). Instead, encode the tag separately (as in step one) and then encode the (typed) data separately. I hope that helps. I guess the short version is this: your approach, while more direct than what I've described, is harder to get right because you're relying on the internals of Variant. Edit: I had a look at the Boost.Serialization source. It might help: http://svn.boost.org/svn/boost/trunk/boost/serialization/variant.hpp Edit: To illustrate (and to make the answer more self-contained), here is what the visitor in Boost.Serialization looks like (see link above): template struct variant_save_visitor : boost::static_visitor<> { variant_save_visitor(Archive& ar) : m_ar(ar) {} template void operator()(T const & value) const { m_ar
