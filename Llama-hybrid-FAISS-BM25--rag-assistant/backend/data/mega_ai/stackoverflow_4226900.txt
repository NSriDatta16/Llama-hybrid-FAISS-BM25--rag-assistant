[site]: stackoverflow
[post_id]: 4226900
[parent_id]: 4224527
[tags]: 
ACL, on openldap are organized by OU and/or DN check with regexp ex : access to attrs=userPassword by anonymous auth by self write by dn.base="ou=users_with_userPassword_write_access,dc=myproduct,dc=org" write by dn.exact="cn=manager,dc=myproduct,dc=org" write by * none access to * by dn.exact="cn=manager,dc=myproduct,dc=org" write by dn.base="ou=users_with_powerfull_write_access,dc=myproduct,dc=org" write by * none So, regarding, the dn of the logged user ( whoami_s with python-ldap), you can determine if user has some rights. You don't need to test if you can write the data, implement a function in your django application that check the DN. Maybe are you saying that ACL are dinamically generated? Regarding your comment, if your ACL are static, to know ACLs, the simpler way is to implement a python facility who's implement these ACLs. With my previous exemple : W_ACCESS_OU = "ou=users_with_powerfull_write_access,dc=myproduct,dc=org" def check_write_access(user_dn): return is_dn_base(W_ACCESS_OU, user_dn) For now, python-ldap can't retrieve the slapd.conf's ACLs... And it is not safe to parse the slapd.conf (because slapd.conf can be "anywhere" on the system and ACLs declaration might be tricky to parse), also it consumes lots of time to try to write data on the LDAP backend. I know this is not very satisfactory. Another solution is to use a "service user". Only this user has write access on the LDAP backend. It simplifies ACL's writing : access to * by dn.exact="cn=manager,dc=myproduct,dc=org" write by * none Then, on regular users, you set an authorisation's flag. Your application checks the flag when your logged user want to do something. And if this flag is OK, the service user writes data on the Backend. This is the strategy we deploy on one of our application. In the both case, ACL's check is done by our application, not by the ldap backend.
