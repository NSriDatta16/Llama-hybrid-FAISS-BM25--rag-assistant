[site]: stackoverflow
[post_id]: 5643836
[parent_id]: 5643753
[tags]: 
Let's say the definition of a looks something like this: int a[2][2] = {{1, 2}, {3, 4}}; Here's what the storage that the symbol a looks like: [ 1 ][ 2 ][ 3 ][ 4 ] In C, when you perform arithmetic on a pointer, the actual amount by which the pointer value is incremented or decremented is based on the size of the type stored in the array. The type contained in the first dimension of a is int[2] , so when we ask C to calculate the pointer value (a + 1), it takes the location named by a and increments it by the size of int[2] , which results in pointer referring to the memory location containing the integer value [3]. So yes, when you dereference this pointer and then add 2 to it, the result is the integer value 5. When you then try to dereference that integer value, it makes no sense. So now let's say the array contains pointers: char const * one = "one", two = "two", three = "three", four = "four"; char const * a[2][2] = {{one, two}, {three, four}}; Add 1 to a and then dereference it, and you get the char pointer referring to the string "three." Add two to this, and you'll get a pointer referring to a now shorter string "ree". Dereference that, and you get the char value 'r', but only by sheer luck did you avoid a memory protection fault.
