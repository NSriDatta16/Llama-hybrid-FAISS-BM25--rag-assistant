[site]: stackoverflow
[post_id]: 3582898
[parent_id]: 3582788
[tags]: 
This is the best advice I can give you: Don't worry about it. Yes, you have several options to create an ArrayList , but using the new , the default option provided by the library, isn't a BAD choice, otherwise it'd be stupid to make it the default choice for everyone without clarifying what's better. If it turns out that this is a problem, you'll quickly discover it when you profile. That's the proper place to find problems, when you profile your application for performance/memory problems. When you first write the code, you don't worry about this stuff -- that's premature optimization -- you just worry about writing good, clean code, with good design. If your design is good, you should be able to fix this problem in no time, with little impact to the rest of the system. Effective Java 2nd Edition, Item 52: Refer to objects by their interfaces . You may even be able to switch to a LinkedList , or any other kind of List out there, if that turns out to be a better data structure. Design for this kinds of flexibility. Finally, Effective Java 2nd Edition, Item 1: Consider static factory methods instead of constructors . You may even be able to combine this with Item 5: Avoid creating unnecessary objects , if in fact no new instances are actually needed (e.g. Integer.valueOf doesn't always create a new instance). Related questions Java Generics Syntax - in-depth about type inferring static factory methods (also in Guava ) On ArrayList micromanagement Here are some specific tips if you need to micromanage an ArrayList : You can use ArrayList(int initialCapacity) to set the initial capacity of a list. The list will automatically grow beyond this capacity if needed. When you're about to populate/add to an ArrayList , and you know what the total number of elements will be, you can use ensureCapacity(int minCapacity) (or the constructor above directly) to reduce the number of intermediate growth. Each add will run in amortized constant time regardless of whether or not you do this (as guaranteed in the API), so this can only reduce the cost by a constant factor. You can trimToSize() to minimize the storage usage. This kind of micromanagement is generally unnecessary, but should you decide (justified by conclusive profiling results) that it's worth the hassle, you may choose to do so. See also Collections.singletonList - Returns an immutable list containing only the specified object.
