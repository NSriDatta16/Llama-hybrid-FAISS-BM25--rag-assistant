[site]: stackoverflow
[post_id]: 2360100
[parent_id]: 2359379
[tags]: 
The distance formula is straightforward: distance :: Floating a => (a,a) -> (a,a) -> a distance (x1,y1) (x2,y2) = sqrt $ (x2 - x1)^2 + (y2 - y1)^2 Note the use of pattern matching to decompose the arguments rather than littering the code with fst and snd . The respective distances from a given point to all points in a list is then distanceFrom :: Floating a => (a,a) -> [(a,a)] -> [a] distanceFrom p = map (distance p) Although arguments appear to be missing, this is known in Haskell parlance as partial application . In distanceFrom , we have two of them: distance p is a function of one point whose value is that point's distance from p map (distance p) is a function of a list of points whose value is those points' respective distances from p Try to design your Haskell functions for partial application to make it easy to combine small functions into bigger ones. As noted in ephemient's answer , you could carry this a step further to get pointfree definition (no explicit arguments)â€”a more elegant, advanced style. The distance to each point in buildings from all points in lPoints is then main :: IO () main = do mapM_ (putStrLn . unwords . map (printf "%6.3f")) score where score = [ distanceFrom x buildings | x For example, making lPoints and buildings equal, the output is 0.000 3.162 5.385 5.099 1.414 3.162 0.000 3.606 2.828 2.828 5.385 3.606 0.000 1.000 4.123 5.099 2.828 1.000 0.000 4.000 1.414 2.828 4.123 4.000 0.000 But that's a little boring in this particular case given all the redundancy. To instead print the strict upper triangle , use strictUpperTriangle :: [[a]] -> [[a]] strictUpperTriangle [] = [] strictUpperTriangle xs = go (init xs) where go (x:xs) = tail x : map tail (go xs) go [] = [] printSUT :: PrintfArg a => [[a]] -> IO () printSUT sut = putStr (unlines $ map pad sut) where n = length sut pad xs = let k = n - length xs in unwords $ take k blanks ++ map (printf "%*.3f" w) xs blanks = repeat (take w $ repeat ' ') w = 6 :: Int main :: IO () main = printSUT tri where score = [ distanceFrom x buildings | x Output: 3.162 5.385 5.099 1.414 3.606 2.828 2.828 1.000 4.123 4.000
