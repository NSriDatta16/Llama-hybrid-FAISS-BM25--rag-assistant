[site]: stackoverflow
[post_id]: 3062512
[parent_id]: 2175530
[tags]: 
There is one solution out there that lots of people are reposting as their own. It can be found here: http://www.a2zdotnet.com/View.aspx?id=66 The problem w/ that is that it does resize your UI. So this next link takes the previous solution and resizes back to the original size when it's done. This does work, although I can't help but to think there's likely a more elegant solution out there somewhere: http://www.slickthought.net/post/2009/05/26/Visual-Tree-Printing-in-WPF-Applications.aspx Slickthought.net domain is defunct. Wayback Machine to the rescue. https://web.archive.org/web/20130603071346/http://www.slickthought.net/post/2009/05/26/Visual-Tree-Printing-in-WPF-Applications.aspx There are two important things to note here. First, I am using a WPF command to start the printing process. You don't have to do it this way, but it lets me tie the presenter to the UI pretty cleanly. The second thing is the CommandParameter. It is passing in a reference to the the ReportPanel. ReportPanel is just a WPF Grid control that wraps the title TextBlock and a Listbox that contains the actual charts. The simplified XAML is: With that UI established, lets jump to the code. When the user clicks the Print button, the following WPF command is executed: this.PrintCommand = new SimpleCommand { CanExecuteDelegate = execute => true, ExecuteDelegate = grid => { PrintCharts(grid); } }; This is pretty simple stuff. SimpleCommand implements the ICommand interface and lets me pass in some lambda expressions defining the code I want to run when this command is fired. Clearly, the magic happens in the PrintCharts(grid) call. The code shown below is basically the same code you would find in Pankajâ€™s article with a couple of modification highlighted in red. private void PrintCharts(Grid grid) { PrintDialog print = new PrintDialog(); if (print.ShowDialog() == true) { PrintCapabilities capabilities = print.PrintQueue.GetPrintCapabilities(print.PrintTicket); double scale = Math.Min(capabilities.PageImageableArea.ExtentWidth / grid.ActualWidth, capabilities.PageImageableArea.ExtentHeight / grid.ActualHeight); Transform oldTransform = grid.LayoutTransform; grid.LayoutTransform = new ScaleTransform(scale, scale); Size oldSize = new Size(grid.ActualWidth, grid.ActualHeight); Size sz = new Size(capabilities.PageImageableArea.ExtentWidth, capabilities.PageImageableArea.ExtentHeight); grid.Measure(sz); ((UIElement)grid).Arrange(new Rect(new Point(capabilities.PageImageableArea.OriginWidth, capabilities.PageImageableArea.OriginHeight), sz)); print.PrintVisual(grid, "Print Results"); grid.LayoutTransform = oldTransform; grid.Measure(oldSize); ((UIElement)grid).Arrange(new Rect(new Point(0, 0), oldSize)); } } All right, what are these modifications? The most obvious is that I am replacing the use of the original this object (which represented the entire application window in the original code) with the Grid control that was passed in as part of the Command. So all of the measurements and transforms are executed using the Grid. The other change is that I have save the original Transform and Size of the Grid as well. The reason is that when you transform the Grid to fit to the printing page, it causes the actual application UI to change as well. This doesn't look so good on your screen, so after sending the Grid to the printer, I transform it back to its original screen layout.
