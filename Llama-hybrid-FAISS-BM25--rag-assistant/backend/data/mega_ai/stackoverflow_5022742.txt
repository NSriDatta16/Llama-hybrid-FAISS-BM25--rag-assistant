[site]: stackoverflow
[post_id]: 5022742
[parent_id]: 5021892
[tags]: 
Why The Locks? As far as I remember in Enterprise Library uses the .NET Tracelistener class which has a property IsThreadSafe. If the listener is thread safe no synchronization is performed. For a file as output device there is no reason to synchronize access from several threads unless your StreamWriter which internally holds the write buffer could become corrupted by unsynchronized writes. This is the reason why you need to get a synchronized StreamWriter to write to a file from different threads. But at any rate this is more of academic interest. When you allow only one thread to write at a time you still can generate several hundred MB of output which brings even the fastest hard disc down. You are IO bound when you write to file. The slowest thing in the whole chain is the hard disc and not your synchronized write to a file. But sometimes it is nice to have the output of several processes in one file. Log4Net for example cannot do it. ... How do I get multiple process to log to the same file? The FileAppender holds a write lock on the log file while it is logging. This prevents other processes from writing to the file, therefore it is not possible to have multiple processes log directly to the same log file, even if they are on the same machine. ... Formatting Performance Even if you think that the lock is costing you performance there are often other costs overlooked. The configurable output format is very nice but at least the formatting in Enterprise Library until 4.0 was very slow . I have made it over 13 times faster which resulted in a net file throughput increase of a factor 2. Concurrent Writes To File With a little Win32 magic it is possible to write reliable from different processes into the same file concurrently. But to come back to your question if synchronization is needed: It may be needed depending on the output device. Scalabilty If your concern is scalability then you need to have a per thread buffer which is merged at a defined point in time to allow fast data gathering. Then you can implement a global ring buffer which gets from all threads the formatted data where the oldest data is overwritten. When something interesting happens you can dump the whole ring buffer to disc. This design is ~10-20 times faster than any file appender. Windows Event Tracing does employ the ring buffer trick which is blazingly fast. Since you asked about locking I do think that speed is your main concern. If that assumption is correct you should have a look at a tracing framework like the one the ApiChange tool uses. It has some innovative approaches like automatic exception tracing when your method is left with an exception or fault injection to unit test the error path without the need to modify your product code. To be scalable you should differentiate between logging and tracing as I have explained here: Logging is not Tracing. . Lock Free If you want to create a scalable tracing framework you need to pass all your data for one trace call as immutable data, format the data into a string and pass it on to your output device. It can be as simple as (C# Pseudo Code) Trace.Info("blahh {0}", data); traceString = Format(formatString, args, CurrentTime); Write(traceString); When the data is not stored in a class or the class members do not change after it has been initialized you will never need a lock. You have to be careful that you do share e.g. the formatting buffer between threads. To be scalable you need to set your design priorities for thread safety in the following order. Isolation This is by far the best solution. If the problem can be sliced in a way that several threads can operate independently you never need to think about locking or shared data. Immutability The second best solution is to share data but once more than one thread can "see" it it must never change. This can be achieved e.g. with objects which do have only getters and all data is passed via the ctor. Locking If you use lock free or some locking strategy does not matter much. You are in the world of pain where you must pay attention to processor caches, false sharing and if you are brave you even try some lock free method only to find out that it at best gets twice as fast as a normal lock. In some cases lock free code can be slower. If you want to read more about threading details I recommend Joe Duffys blog . Tracing Strategy To write maintainable software you need to be able to follow your application and data flow. Only then you can diagnose problems which happen only at your customer site. It does pay off to "clutter" your code with traces which do give you enough information to diagnos a problem quickly. You can trace too much or too less or not relevant data. One good trace line which does correlate e.g. your XPath query string with the file it operates on is much better as scattered pieces of information in your log file. Yours, Alois Kraus
