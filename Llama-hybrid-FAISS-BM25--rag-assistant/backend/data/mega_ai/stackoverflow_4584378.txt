[site]: stackoverflow
[post_id]: 4584378
[parent_id]: 4584135
[tags]: 
If you do it like this, it should work: // A: encrypting when writing // 1. create backing storage stream. In your case a file stream using(Stream innerStream = File.Create(path)) // 2. create a CryptoStream in write mode using(Stream cryptoStream = new CryptoStream(innerStream, encryptor, CryptoStreamMode.Write)) { // 3. write to the cryptoStream binaryFormatter.Serialize(cryptoStream, obj); } // B: decrypting when reading // 1. create backing storage stream. In your case a file stream using(Stream innerStream = File.Open(path, FileMode.Open)) // 2. create a CryptoStream in read mode using(Stream cryptoStream = new CryptoStream(innerStream, decryptor, CryptoStreamMode.Read)) { // 3. read from the cryptoStream obj = binaryFormatter.Deserialize(cryptoStream); } There are a couple of problems with your code: You're using an encryptor when reading. This was probably a typo, but it should be a decryptor. You are flushing the buffer , but that is not enough when using a CryptoStream . Encryptors and decryptors work on blocks of a fixed size. The last block may not have that size, so it needs special treatment. The last block is the one written before the stream is closed , not flushed . Flushing on a CryptoStream does nothing useful, because it cannot write anything of size less than the input block size of the encryptor/decryptor, unless it is the last thing to be written. And on top of this, in general you should always close your streams, no matter what. The using statement is the recommended way of doing it: using(buffer) _binaryFormatter.Serialize(buffer, bObj);
