[site]: stackoverflow
[post_id]: 2599063
[parent_id]: 
[tags]: 
About variadic templates

I'm currently experiencing with the new c++0x variadic templates, and it's quite fun, Although I have a question about the process of member instantiation. in this example, I'm trying to emulate the strongly typed enum with the possibility of choose a random valid strong enum (this is used for unit testing). #include #include using namespace std; template struct sp_enum; /* this is the solution I found, declaring a globar var vector _data; and it work just fine */ template<> struct sp_enum<>{ static const unsigned _count = 0; static vector _data; }; vector sp_enum<>::_data; template struct sp_enum : private sp_enum { static const unsigned _count = sp_enum ::_count+1; static vector _data; sp_enum( ) : sp_enum (values...) {_data.push_back(T);} sp_enum(unsigned v ) {_data.push_back(v);} sp_enum(unsigned v, unsigned...) : sp_enum (values...) {_data.push_back(v);} }; template vector sp_enum ::_data; int main(){ enum class t:unsigned{Default = 5, t1, t2}; sp_enum test; cout the result I'm getting with this code is : 3 1 5: can someone point me what I'm messing here ??? Ps: using gcc 4.4.3 I have reworked the code to be more generic and to reduce the hardcore coding as possible (@Matthieu M.). But I would like to explain why I'm doing all this before. I have, as many developer embraced the new c++0x standard in my code and I'm quit happy about it. But I have an issue with the strongly typed enums when trying to write test units. The problem is that you cannot generate a random strong typed enum (I know, that you can, but wanted to do it in a more elegant way). So, now with this code, I can, using variadic templates and variadic macro (yes old dirty macro) declare and randomly select a strongly typed and scoped enum. here is the code: #include #include #include #include #include using namespace std; template class sp_enum; template class sp_enum { protected: static const unsigned _count = 0; }; template class sp_enum : public sp_enum { protected: static const unsigned _count = sp_enum ::_count+1; static vector _data; public: sp_enum( ) : sp_enum (values...) {_data.push_back(head);for(auto i= sp_enum ::_data.begin();i != sp_enum ::_data.end();++i){_data.push_back(*i);}} sp_enum(T v ) {_data.push_back(v );} sp_enum(T v, T...) : sp_enum (values...) {_data.push_back(v );for(auto i= sp_enum ::_data.begin();i != sp_enum ::_data.end();++i){_data.push_back(*i);}} vector data() const { return _data ;} unsigned count() const { return _count ;} static T randomEnum() { srand (time(NULL));return _data[rand()%_count];} }; template vector sp_enum ::_data; #define PP_NARG(...) PP_NARG_(__VA_ARGS__,PP_RSEQ_N()) #define PP_NARG_(...) PP_ARG_N(__VA_ARGS__) #define PP_ARG_N( \ _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \ _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \ _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \ _61,_62,_63,N,...) N #define PP_RSEQ_N() \ 63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40, \ 39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16, \ 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 #define FOREACH_ARRAY( ... ) (PP_NARG(__VA_ARGS__) , ( __VA_ARGS__ ) ) #define FOREACH( Name, A, ... ) BOOST_PP_REPEAT_FROM_TO(1, PP_NARG(Name, __VA_ARGS__), A, FOREACH_ARRAY(Name, __VA_ARGS__) ) #define DECORATION(z,n,data) ,BOOST_PP_ARRAY_ELEM( 0, data ) :: BOOST_PP_ARRAY_ELEM( n, data ) #define SP_ENUM(enumName, ...) \ enum class _##enumName : unsigned { Default, __VA_ARGS__ }; \ typedef sp_enum enumName; SP_ENUM( xx, test1, test2, test3 ) int main(){ xx test; cout What bother me now, is the limitation of the PP_NARG macro (I haven't found any other way to count the number of argument). I will gladly accept any pointer or hint to enhance this.
