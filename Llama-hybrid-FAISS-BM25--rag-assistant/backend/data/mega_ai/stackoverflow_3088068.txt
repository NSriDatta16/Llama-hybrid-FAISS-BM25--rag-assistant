[site]: stackoverflow
[post_id]: 3088068
[parent_id]: 3087372
[tags]: 
It's not exactly pretty solution. In fact, it's quite a pain to implement, but it surely gives polynomial complexity. Although complexity is also big (n^5*k is my rough estimate), someone may find a way to improve it or find here an idea for better solution. Or it may be enough for you: even this complexity is much better than bruteforce. Note : optimal solution (set S ) with hull H includes all points from orignal set inside H . Otherwise, we could throw away one of the border points of H and include that missed point, reducing perimeter. ( update just like 'optimization' mbeckish posted) Assumption : no two points from the set form a vertical line. It can be achieved easily by rotating whole set of points by some irrational angle around origin of coordinates. Due to assumption above, any complex hull has one leftmost and one rightmost point. Also, these two points divide the hull into top and bottom parts. Now, let's take one segment from the top part of this hull and one from the bottom part. Let's call those two segments middle segments and perimeter of the right part of this hull - right perimeter. Note : those two segments is all we need to know about right part of our convex hull to continue building it to the left. But having just two points instead of 4 is not enough: we could not uphold condition of 'convexness' this way. It leads to a solution . For each set of points {p0, p1, p2, p3} and number i (i right perimeter that can be achieved if [p0, p1], [p2, p3] are two middle segments and i is the number of points in the right part of this solution (including the ones inside of it, not only on the border). We go through all points from right to left. For each new point p we check all combinations of points {p0, p1, p2, p3} such that point p can continue this hull to the left (either on the top or on the bottom part). For each such set and size i , we already store optimal perimeter size (see paragraph above). Note : if you add point p to a right-hull formed by points {p0, p1, p2, p3}, you'll increment set size i at least by 1. But sometimes this number will be > 1: you'll have to include all points in the triangle {p, p0, p2}. They aren't on the hull, but inside it. Algorithm is over :) In addition, despite scary complexity, you may note that not all segments [p0, p1], [p2, p3] can be middle segments: it should reduce actual computation time substantially. update This provides only optimal perimeter size, not the set itself. But finding the set is simple: for each 'state' above you store not only perimeter size, but also last point added. Then, you can 'trace' your solution back. It's quite standard trick, I suppose it's not a problem for you, you seem to be good at algorithms :) update2 This is essentially DP (dynamic programming), only a bit bloated
