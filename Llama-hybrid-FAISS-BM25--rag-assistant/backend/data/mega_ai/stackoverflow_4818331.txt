[site]: stackoverflow
[post_id]: 4818331
[parent_id]: 
[tags]: 
Saving user-defined Views with computed columns in a database structure

I have acquisition data from various sensors organized in db tables. I give user the ability to create his own Data Views adding columns, one for each sensor, grouped by data, like this View #1 +---------------------+------+----+-----+ | datetime | v1 | v2 | v3 | +---------------------+------+----+-----+ | 2010-09-13 00:05:00 | 40.9 | 1 | 0.3 | | 2010-09-13 00:10:00 | 41.0 | 2 | 0.3 | | 2010-09-13 00:15:00 | 41.1 | 4 | 0.3 | +---------------------+------+----+-----+ To store this kind of Views I use two tables: views and view_opts views id name view_opts id id_view id_sensor ord #for column ordering Now I have to go one step further: add more columns, not coming directly from sensor data but as a computation of other colums, like this: View #1 +---------------------+------+----+-----------+-----+ | datetime | v1 | v2 | (v1+v2)/2 | v3 | +---------------------+------+----+-----------+-----+ | 2010-09-13 00:05:00 | 40.9 | 1 | 20.95 | 0.3 | | 2010-09-13 00:10:00 | 41.0 | 2 | 21.5 | 0.3 | | 2010-09-13 00:15:00 | 41.1 | 4 | 22.55 | 0.3 | +---------------------+------+----+-----------+-----+ If this is not hard to achieve in SQL (I wrap the old SELECT in a new one that makes computation) I have to extend the way I store Views someway. I thought at several ways, all with some pro and a lot of cons... Any good idea? ================ Edit: one of my thoughts was to add a text field to view-opts to let user add his own computations in SQL-like syntax: (v1+v2)/2 in case sensor foreign keys are null in view_opt the text is used in query, something like: SELECT v1, v2, (v1+v2)/2, v3 FROM ( SELECT v1, v2, v3 FROM ... ) Of course I should parse the (v1+v2)/2 part for syntax errors, injections (improbable, this functionality is only for trusted administration users that have no interest in damaging their own data). =============== Add: here are som DDL for key tables in my database (I trimmed some fields and tables not needed for this question): CREATE TABLE acquisitions ( id INTEGER NOT NULL, id_cu INTEGER NOT NULL, datetime DATETIME NOT NULL, PRIMARY KEY (id), FOREIGN KEY(id_cu) REFERENCES ctrl_units (id), ) CREATE TABLE data ( id INTEGER NOT NULL, id_acq INTEGER NOT NULL, id_meas INTEGER NOT NULL, value FLOAT, PRIMARY KEY (id), FOREIGN KEY(id_acq) REFERENCES acquisitions (id) ) CREATE TABLE sensors ( id_cu INTEGER NOT NULL, id_meas INTEGER NOT NULL, name VARCHAR(40) NOT NULL, PRIMARY KEY (id_cu, id_meas), FOREIGN KEY(id_cu) REFERENCES ctrl_units (id) ) CREATE TABLE ctrl_units ( id INTEGER NOT NULL, name VARCHAR(40) NOT NULL, PRIMARY KEY (id) ) Brief description : I have ctrl_units sending data over a network in csv like files, every ctrl_unit has many sensors , a single sensor is identified as id_cu-id_meas . This is not a solution I found but the real way ctrl_units send data over the network. Every acquisition is a row in csv, with datetime and many sensor measures as id_meas, value ( simplified version : to say it all every sensor sends more measures in an acquisition as id_meas, id_elab, value where id_elab has different meanings according to sensor type) Working this way data of a sensor (a result column) is identified by it's Control Unit id (stored in parent acquisition) and it's Measure Type id (stored in single data). I use this query to extract data.
