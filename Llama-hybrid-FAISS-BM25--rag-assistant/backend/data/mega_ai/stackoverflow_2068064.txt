[site]: stackoverflow
[post_id]: 2068064
[parent_id]: 2067627
[tags]: 
Try to avoid complex nested data structures. I believe people tend to grok them only while they are intensively using the data structure. After the program is finished, or is set aside for a while, the data structure quickly becomes mystifying. Objects can be used to retain or even add richness to the data structure in a saner, more organized way. For instance, it appears the item and price always go together. So the two pieces of data might as well be paired in an object: class Item(object): def __init__(self,name,price): self.name=name self.price=price Similarly, a person seems to have an id and name and a set of possessions: class Person(object): def __init__(self,id,name,*items): self.id=id self.name=name self.items=set(items) If you buy into the idea of using classes like these, then your list_dicts could become list_people = [ Person('001','jim',Item('pencil',0.99)), Person('002','mary',Item('book',15.49)), Person('002','mary',Item('tape',7.99)), Person('003','john',Item('pen',3.49)), Person('003','john',Item('stapler',9.49)), Person('003','john',Item('scissors',12.99)), ] Then, to merge the people based on id , you could use Python's reduce function, along with take_items , which takes (merges) the items from one person and gives them to another: def take_items(person,other): ''' person takes other's items. Note however, that although person may be altered, other remains the same -- other does not lose its items. ''' person.items.update(other.items) return person Putting it all together: import itertools import operator class Item(object): def __init__(self,name,price): self.name=name self.price=price def __str__(self): return '{0} {1}'.format(self.name,self.price) class Person(object): def __init__(self,id,name,*items): self.id=id self.name=name self.items=set(items) def __str__(self): return '{0} {1}: {2}'.format(self.id,self.name,map(str,self.items)) list_people = [ Person('001','jim',Item('pencil',0.99)), Person('002','mary',Item('book',15.49)), Person('002','mary',Item('tape',7.99)), Person('003','john',Item('pen',3.49)), Person('003','john',Item('stapler',9.49)), Person('003','john',Item('scissors',12.99)), ] def take_items(person,other): ''' person takes other's items. Note however, that although person may be altered, other remains the same -- other does not lose its items. ''' person.items.update(other.items) return person list_people2 = [reduce(take_items,g) for k,g in itertools.groupby(list_people, lambda person: person.id)] for person in list_people2: print(person)
