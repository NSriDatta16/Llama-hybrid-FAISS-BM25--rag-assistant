[site]: stackoverflow
[post_id]: 4521575
[parent_id]: 4521535
[tags]: 
Use the high-level URLDownloadToFile function: uses UrlMon; ... URLDownloadToFile(nil, 'http://www.rejbrand.se/', 'C:\Users\Andreas Rejbrand\Desktop\index.html', 0, nil); Or, you could very easily write your own downloader function using the WinInet functions, something like uses WinInet; ... hInet := InternetOpen(PChar(UserAgent), INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0); try hURL := InternetOpenUrl(hInet, PChar('http://' + Server + Resource), nil, 0, 0, 0); try repeat InternetReadFile(hURL, @Buffer, SizeOf(Buffer), BufferLen); ... There is a lot of sample code here at SO. Use the search box above. Update I wrote a small sample. You might want to execute this code in its own thread and let it ping back every 10 kB or so, so that you can provide the user with some progress bar, for instance. function DownloadFile(const UserAgent, URL, FileName: string): boolean; const BUF_SIZE = 4096; var hInet, hURL: HINTERNET; f: file; buf: PByte; amtc: cardinal; amti: integer; begin result := false; hInet := InternetOpen(PChar(UserAgent), INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0); try hURL := InternetOpenUrl(hInet, PChar(URL), nil, 0, 0, 0); try GetMem(buf, BUF_SIZE); try FileMode := fmOpenWrite; AssignFile(f, FileName); try Rewrite(f, 1); repeat InternetReadFile(hURL, buf, BUF_SIZE, amtc); BlockWrite(f, buf^, amtc, amti); until amtc = 0; result := true; finally CloseFile(f); end; finally FreeMem(buf); end; finally InternetCloseHandle(hURL); end; finally InternetCloseHandle(hInet); end; end;
