[site]: stackoverflow
[post_id]: 1694930
[parent_id]: 1694673
[tags]: 
I think the key problems here are the definitions of Book and Wishlist, and where the authoritative copies of Wishlists are kept. I'd attack the problem this way. First you have Books, which are keyed by ISBN number and have all the metadata describing the book (title, authors, description, publication date, pages, etc.) Then you have Wishlists, which are merely lists of ISBN numbers. You'll also have Customer and other resources. You could name Book resources something like: /book/{isbn} and Wishlist resources: /customer/{customer}/wishlist assuming you have one wishlist per customer. The authoritative Wishlists are on the server, and the client has a local cached copy. Likewise the authoritative Books are on the server, and the client has cached copies. The Book representation could be, say, an XML document with the metadata. The Wishlist representation would be a list of Book resource names (and perhaps snippets of metadata). The Atom and RSS formats seem good fits for Wishlist representations. So your client-server synchronization would go like this: GET /customer/{customer}/wishlist for ( each Book resource name /book/{isbn} in the wishlist ) GET /book/{isbn} This is fully RESTful, and lets the client later on do PUT (to update a Wishlist ) and DELETE (to delete it). This synchronization would be pretty efficient on a wired connection, but since you're on a mobile you need to be more careful. As @marshally points out, HTTP 1.1 has a lot of optimization features. Do read that HTTP caching tutorial, and be sure to have your web server properly set Expires headers, ETags, etc. Then make sure the client has an HTTP cache. If your app were browser-based, you could leverage the browser cache. If you're rolling your own app, and can't find a caching library to use, you can write a really basic HTTP 1.1 cache that stores the returned representations in a database or in the file system. The cache entries would be indexed by resource names, and hold the expiration dates, entity tag numbers, etc. This cache might take a couple days or a week or two to write, but it is a general solution to your synchronization problems. You can also consider using GZIP compression on the responses, as this cuts down the sizes by maybe 60%. All major browsers and servers support it, and there are client libraries you can use if your programming language doesn't already (Java has GzipInputStream, for instance).
