[site]: stackoverflow
[post_id]: 4286708
[parent_id]: 
[tags]: 
WinForms Multithreading: Execute a GUI update only if the previous one has finished

I have multithreaded application with some background processing. It has long-running UI updates (on the UI-thread itself), which are invoked from the background thread via the well-known resource on MSDN . I can not shorten these UI updates since they are finally done in a external library(1). Now, from that background thread, I want to asynchronously invoke (using BeginInvoke() ) these updates on the UI thread, but only if the previous update has finished yet. If not, I would like to simply skip this update. This will prevent an overflow of the Windows Message Queue, in case the invokes come faster than the to invoked method is able to execute. My current solution is this: In the method that executes on the UI thread, I do enter and exit a ReaderWriterLockSlim instance. On the background thread, I try to enter the instance with zero timeout. When successful, I call 'BeginInvoke()' then exit again. When not successful, I skip the method invoke altogether. public void Update(double x, double y) { _updateLock.EnterWriteLock(); try { //...long running task... } finally { _updateLock.ExitWriteLock(); } } //.... void Provider_PositionChanged(object sender, SpecialEventArgs e) { if (_updateLock.TryEnterWriteLock(0)) //noone is currently executing an update? { try { myUiControl.BeginInvoke(/*...*/); } finally { _updateLock.ExitWriteLock(); } } This all works, but is there a more elegant solution? How to simply test, from the one thread, whether a method is executed on any (other) thread? Note: Using Invoke() (instead of BeginInvoke() ) is not an option, since this would block my background thread, preventing other stuff from executing there. (1) It's MapXtreme, a mapping solution, and I want to pan/zoom large bitmap terrain data, plus updating some features. PS. This question is somewhat related, but covers a different aspect: Winforms multithreading: Is creating a new delegate each time when invoking a method on the UI thread needed? Thanks for any answers! UPDATE: Hans Passant has helped me with his answer. See the solution below. Hopefully this helps someone else too. /// /// This class enqueues asynchronously executing actions (that are running on another thread), but allows /// to execute only one action at a time. When busy, newly enqueued actions are dropped. /// Any enqueued action is required to call Done() on this when it has finished, to allow further actions /// to execute afterwards. /// /// This class is intended to help prevent stacking UI-Updates when the CPU or other resources /// on the machine are not able to handle the amount of updates requested. However, the user /// must keep in mind, that using this class may result /// in dropped updates and that the last requested update is not always executed. public class ActionBouncer { /// /// A event that signals the idle/busy state. Idle means, that no action is currently executing. /// private ManualResetEvent _idle = new ManualResetEvent(true); /// /// Enqueues the specified action, executing it when this bouncer /// is currently idle. /// /// The action. public void Enqueue(Action action) { if (_idle.WaitOne(0)) //are we idle now? (Remark: This check and the reset below is not thread-safe (thanks to s.skov)) { _idle.Reset(); //go to busy state action(); //execute the action now. }//else drop the action immediately. } /// /// Signal the bouncer, that the currently executing asynchronous action is done, allowing /// subsequent requests to execute. /// This must get explicitly called (in code) at the end of the asynchronous action. /// public void Done() { _idle.Set(); } }
