[site]: stackoverflow
[post_id]: 2477973
[parent_id]: 2477934
[tags]: 
Generally, the best way to catch an exception (including the one you mention) is to put the suspect code in the try clause of a try / except statement; in the except clause you can use the traceback module or other ways to pinpoint the errant statement. Otherwise-uncaught exceptions end up in sys.excepthook , which is another way you can use to get a traceback if needed. However, I don't think the logging module has an architected way to tell it "let exceptions propagate" -- in which case your best bet, dirty as it may be, is probably monkey-patching. In other words, you generally can "change the Python standard library" at runtime -- by setting identifiers therein to your own functions / classes / etc wrapping the standard ones. For example, if you know the problem is with a logging.warning call, a "proof of concept" monkeypatch might be: import logging, traceback orgwarn = logging.warning def mywarn(msg, *a): try: res = msg % a except TypeError: traceback.print_exc() return orgwarn(msg, *a) logging.warning = mywarn There are cleaner ways, but they may be somewhat cumbersome (e.g., make your own logger class and set it as the root logger). Monkey-patching is not a good way to operate in a production environment (it's fragile to system upgrades, can be hard to understand and maintain, etc), but it can be acceptable for debugging and testing purposes.
