[site]: crossvalidated
[post_id]: 192589
[parent_id]: 
[tags]: 
Customization of a standard Bell Curve

Hopefully this isn't a duplicate, I've tried to search for similar things, but to no luck. I'm curious on how you would computationally compute a random distribution of numbers that follows a bell curve that's got slightly different constraints than normal. For example, a 'regular' bell curve graph ranging from 0-100 would be generated by something like: (rand(100) + rand(100) + rand(100)) / 3 I would like to get some more information on how to 'customize' these graphs. For example, let's say I want: Set min and max value. For this example, let's say 0-100 Set more or less specific requirements. For example, I want the highest distribution to be 10-20, so those being the most common. then a 'normal' curve down to the edges, despite the off-balance. For example, there is the same chance of getting 0 and 100. Another possibility would be having a steeper slope on one side than the other, despite having a regular curve. (Regular distribution being 50, but a much greater chance of getting 0 than 100, for example) I know I can get a steeper curve by increasing the number of rands that I get the average of. Would 'breaking' the average cause the imbalance I'm looking for there? For example, (rand(100) + rand(100) + rand(100) / 4) would cause a lower regular distribution. EDIT: To answer the comments below, I'll add to this. I added the 4 constraints in hope that that would make it less broad, but apparently it's still too vague. As far as example data, I'm looking for something that I can apply in many areas. The current situation I'm trying to apply this in, is generating an example score set for a potentially never ending game. Picture any infinite progression/distance game. Generally easy to play with simple rules. Easy enough that players will rarely score 0, most players eventually make a mistake and fail early on-ish, and a select few players make it super far. By this, assuming a scale of 0-100, you get something like this: Distribution | Score 1% - 0-3 3% - 4-9 20% - 10-20 40% - 21-40 20% - 41-60 10% - 61-70 3% - 71-80 2% - 81-90 1% - 91-100 Those are all obviously made-up results, but is shows approximately the goal. It's basically a bell curve, where most values are found in one area and are distributed apart from it, but it's not a regular curve, seeing as the peak isn't centered, and the two slopes don't have the same slopes. Even if it's not exact, that's fine. I'm looking for simple/easy to implement and straight forward, but I'm not looking for the mathematical formula to generate the graph, but rather the algorithm that can be used to approximately generate the numbers, like I showed an example of previously. I'm not concerned with the actual random value of the numbers, but rather what I need to do, given an assumed random number generation. rand(100) would like to manipulate that into a customizable function that, run many times, the points generated would approximately reflect a the desired curve.
