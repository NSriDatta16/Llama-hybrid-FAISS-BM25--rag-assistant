[site]: crossvalidated
[post_id]: 565800
[parent_id]: 565763
[tags]: 
There are a number of ways to do this. I'll describe a few that I think would be effective. Not all have been described in the literature, but that doesn't really matter since your primary task is to create two equivalent groups, and the performance of the methods can be evaluated based on their ability to do so. The three methods I'll describe are 1:1 matching, cardinality matching, and subset selection using the energy distance. I'll demonstrate these using R. Let's say we have a dataset called data_combined which contains the two datasets stacked on top of each other and a new variable data identifying which dataset each comes from, with 1 being the smaller dataset and 0 being the larger. 1:1 matching In 1:1 matching, you create pairs of units, where each pair contains one member from one dataset and one member from the other. The units are paired based on their value of age, so the differences in age between pairs will be as small as possible. It is possible to restrict the differences between ages to be no larger than a given value by imposing a "caliper". There are multiple algorithms to perform the matching, but a good one is optimal matching, which minimizes the average within-pair distance across all pairs. Any units that do not receive a pair are dropped from the subsample. This will give you the same number of units from both datasets. If you use a caliper, you may end up discarding units from both datasets, whereas if you don't, only units from the larger dataset will fail to be matched. You can perform 1:1 matching using MatchIt::matchit() by supplying age as the distance value and setting method = "optimal" . If you want to use a caliper, you can do so with the caliper argument, but you have to set method = "nearest" to do nearest neighbor instead of optimal matching (this won't matter too much, especially with a caliper). Here is some code to implement this: m.out Cardinality matching With cardinality matching, you find the largest subsample of units that satisfies a given balance (i.e., comparability) threshold. There are two ways to do this: classic cardinality matching and template matching. With classic cardinality matching, you must require that the sizes of the two subsamples are the same. With template matching, you choose a template distribution (i.e., one dataset, the other, or their combination) and the algorithm finds the largest subsample from each group that matches the template distribution. You need to supply a balance tolerance for this method, which is applied only to the mean. To ensure other features of the distribution are similar, you can supply balance tolerances to the square, cube, etc. of age and to binned versions of age. You can do this with MatchIt::matchit() by setting method = "cardinality" . See the documentation on how to choose between classic cardinality and template matching. #Classic cardinality matching m.out Subset selection using the energy distance With subset election using the energy distance, you compute a general measure of the distance between the distributions of age in the two subsamples called the energy distance. You then drop one unit at a time, in particular, the unit that when dropped makes the energy distance the smallest. You can keep doing this until the energy distance doesn't get any smaller or you have dropped too many units. This creates a "frontier", i.e., a function with energy distance on the y-axis and the number of units dropped on the x-axis. You can stop at any point along the frontier and extract the matched subsample. This method uses the technology of the "matching frontier" as implemented in the MatchingFrontier R package, which you can install using devtools::install_github("iqss/MatchingFrontier") . mf.out Finally, to assess how similar the distributions of ages are, you can use functions in the cobalt package that were specifically designed to assess balance between distributions. bal.plot() displays a density plot of the two distributions; ideally they overlap. bal.tab() computes balance statistics.
