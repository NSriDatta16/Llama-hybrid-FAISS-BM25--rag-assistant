[site]: stackoverflow
[post_id]: 939961
[parent_id]: 939904
[tags]: 
There are two options to speed up the playback of a sound file: Increase the sample rate Reduce the number of samples per unit of time. In either of these methods, the increase in playback speed will have a corresponding change in the pitch of the sound. Increasing the sample rate Increasing the sample rate will increase the playback speed of the sound. For example, going from a 22 KHz sampling rate to 44 KHz will make the playback sound twice as fast as the original. In this method, the original sampling data is unaltered -- only the audio playback settings need to be changed. Reduce the number of samples per unit of time In this method, the playback sampling rate is kept constant, but the number of samples are reduced -- some of the samples are thrown out. The naive approach to make the playback of the sound be twice the speed of the original is to remove every other sample, and playback at the original playback sampling rate. However, with this approach, some of the information will be lost, and I would expect that some artifacts will be introduced to the audio, so it's not the most desirable approach. Although I haven't tried it myself, the idea of averaging the samples to create a new sample to be a good approach to start with. This would seem to mean that rather than just throwing out audio information, it can be "preserved" to an extent by the averaging process. As a rough idea of the process, here's a piece of pseudocode to double the speed of playback: original_samples = [0, 0.1, 0.2, 0.3, 0.4, 0.5] def faster(samples): new_samples = [] for i = 0 to samples.length: if i is even: new_samples.add(0.5 * (samples[i] + samples[i+1])) return new_samples faster_samples = faster(original_samples) I've also posted an answered to the a question " Getting started with programmatic audio " where I went into some details about some basic audio manipulation that can be performed, so maybe that might be of interest as well.
