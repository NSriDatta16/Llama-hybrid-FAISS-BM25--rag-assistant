[site]: stackoverflow
[post_id]: 481106
[parent_id]: 478401
[tags]: 
Here's a solution in 1D for simplicity: The initial setup is with a concentration of 9 at the origin (), and 0 at all other positive and negative coordinates. initial state: 0 0 0 0 (9) 0 0 0 0 The algorithm to find next iteration values is to start at the origin and average current concentrations with adjacent neighbors. The origin value is a boundary case and the average is done considering the origin value, and its two neighbors simultaneously, i.e. average among 3 values. All other values are effectively averaged among 2 values. after iteration 1: 0 0 0 3 (3) 3 0 0 0 after iteration 2: 0 0 1.5 1.5 (3) 1.5 1.5 0 0 after iteration 3: 0 .75 .75 2 (2) 2 .75 .75 0 after iteration 4: .375 .375 1.375 1.375 (2) 1.375 1.375 .375 .375 You do these iterations in a loop. Outputting the state every n number of iterations. You may introduce a time constant to control how many iterations represent one second of clock-on-the-wall time. This is also a function of what length units the integer coordinates represent. For a given H/W system, you can tune this value empirically. You may also introduce a steady state tolerance value to control when the program says " all neighbor values are within this tolerance" or "no value changed between iterations by more than this tolerance" and so the algorithm has reached a steady state solution.
