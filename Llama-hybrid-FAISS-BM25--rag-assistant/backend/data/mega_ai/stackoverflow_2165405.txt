[site]: stackoverflow
[post_id]: 2165405
[parent_id]: 2148898
[tags]: 
You might want to just write the xml parts per class as strings to the stream instead of using the XmlWriter. This allows you full control over ending tags. But I've created a workaround which seems to work. This allows you to pass the stream which is serializable between appdomains. First off a helper class to initialize new XmlWriters and fixing the stream before we pass it on. public static class XmlWriterExt { /// /// Make sure any previous tag is ended by writing dummy text, then backtracking the position /// public static void PrepareStream(this XmlWriter writer, Stream stream) { writer.WriteElementString("x", string.Empty); writer.Flush(); stream.Position -= 5; //backtrack the dummy element } /// /// Get an xml writer which works on fragments and without the xml declaration /// public static XmlWriter GetWriter(Stream stream) { XmlWriterSettings settings = new XmlWriterSettings(); settings.OmitXmlDeclaration = true; settings.ConformanceLevel = ConformanceLevel.Fragment; XmlWriter xmlWriter = XmlWriter.Create(stream, settings); return xmlWriter; } } Here's a couple of test classes, nested in each other. class TopClass { InnerClass _innerClass = new InnerClass(); public void Serialize(Stream stream) { XmlWriter xmlWriter = XmlWriterExt.GetWriter(stream); xmlWriter.WriteStartElement("top"); xmlWriter.PrepareStream(stream); _innerClass.Serialize(stream); xmlWriter.WriteEndElement(); xmlWriter.Flush(); } } class InnerClass { public void Serialize(Stream stream) { XmlWriter xmlWriter = XmlWriterExt.GetWriter(stream); xmlWriter.WriteElementString("b", "testing"); xmlWriter.Flush(); } } Test code MemoryStream ms = new MemoryStream(); TopClass top = new TopClass(); top.Serialize(ms); string result = Encoding.UTF8.GetString(ms.ToArray()); and result testing
