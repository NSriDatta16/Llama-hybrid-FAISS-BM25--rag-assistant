[site]: stackoverflow
[post_id]: 3945186
[parent_id]: 3944293
[tags]: 
When you plug in a USB (or often many other types of removable) storage devices the kernel, after recognizing what it is, notifies a program called udevd. udevd looks through some rules (stored in files under /etc/udev/rules.d/, /lib/udev/rules.d/, or /dev/.udev/rules.d ) for rules that match the new device and executes the ones that do. One of the rules for removable block devices runs a program to mount the filesystem(s) on that drive (possibly creating mount points/directories). Gnome, KDE, or similar desktop interface get notified of this via D-BUS that a new device has been installed and mounted (I'm not 100% about the exact steps here). Anyway, in order to run a program on a newly inserted drive you are going to need a some program to do for you that is already running. You could try altering your udev rules or the script that mounts new drives to do this for you or write a new daemon that gets notified the way that desktop management systems like gnome or KDE get notified to run it, but there is no facility that I know if that already does this. Doing so is a security risk since it allows anyone with access to a USB (or similar) plug to run any program on a computer. I could walk up to someone using a laptop in a cafe and very quickly run a program on their computer without their consent. Or if I gave someone a USB drive and said "this has my vacation photos on it" and they put it in their Linux computer a malicious autorun program on the drive would be run without their consent. If such functionality were already part of some Linux distribution (it may be, I don't know) it should definitely require a user to agree before it is run, but even then it would have to be limited to running with that user's UID and GID (ignoring possibility of even more complicated SELinux security), and with a working directory that was safe for that user to have. And this totally ignores the issues with mobile filesystems' ownerships getting mixed up and SUID bits. This probably is not the right way to go about solving whatever problem you are trying to solve.
