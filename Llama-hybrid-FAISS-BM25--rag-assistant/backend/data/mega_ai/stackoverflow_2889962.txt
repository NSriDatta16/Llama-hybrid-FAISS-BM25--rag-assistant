[site]: stackoverflow
[post_id]: 2889962
[parent_id]: 2889723
[tags]: 
I've got the 90% solution, reverse-engineered from the clipboard formats and my answer in this thread . You'll need to set two pieces of clipboard data. The list of files, that's easy to do. And another clipboard format named "Preferred Dropeffect" that indicates whether a copy or a move of the files is requested. Leading to this code: public static void StartCopyFiles(IList files, bool copy) { var obj = new DataObject(); // File list first var coll = new System.Collections.Specialized.StringCollection(); coll.AddRange(files.ToArray()); obj.SetFileDropList(coll); // Then the operation var strm = new System.IO.MemoryStream(); strm.WriteByte(copy ? (byte)DragDropEffects.Copy : (byte)DragDropEffects.Move); obj.SetData("Preferred Dropeffect", strm); Clipboard.SetDataObject(obj); } Sample usage: var files = new List () { @"c:\temp\test1.txt", @"c:\temp\test2.txt" }; StartCopyFiles(files, true); Pressing Ctrl+V in Windows Explorer copied the files from my c:\temp directory. What I could not get going is the "cut" operation, passing false to StartCopyFiles() produced a copy operation, the original files where not removed from the source directory. No idea why, should have worked. I reckon that the actual stream format of "Preferred DropEffects" is fancier, probably involving the infamous PIDLs.
