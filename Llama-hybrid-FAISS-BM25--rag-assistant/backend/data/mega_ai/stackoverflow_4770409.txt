[site]: stackoverflow
[post_id]: 4770409
[parent_id]: 4769676
[tags]: 
As suggested by others, you can roll your own mock or you can set a number of expectations on the dependency. For example, you can verify that your method was called: var mock = new Mock (); var subject = new MyClass(mock.Object); subject.Clear(); mock.Verify( dep => dep.Reset(), Times.AtMost(2)); However it's worth pointing out that work within the constructor is a known code smell , and this smell is exacerbated when you try to write tests. The fact that your constructor needs to call this method on the dependency suggests that this object knows too much information about the implementation details of the dependency. This violates the Open Closed Principle and closes you off from scenarios where you don't want the Reset method from being called when it's initialized. Also consider that any class or test that uses the MyClass concrete object as an dummy parameter will need a Mock initialized or you'll get a NullReferenceException. This adds considerable overhead to writing your tests and adds a level of fragility that equates to long term maintenance and false negatives in your tests. The only way around this is to make everything an interface which although effective isn't the best long term strategy either. As per http://googletesting.blogspot.com/2009/07/separation-anxiety.html , the use of a Factory would reduce some of this coupling and open you up to better reuse of this object.
