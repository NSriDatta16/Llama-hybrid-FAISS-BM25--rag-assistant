[site]: stackoverflow
[post_id]: 3300547
[parent_id]: 3300419
[tags]: 
There are quite a few such functions around. Here's a directory of various implementations, sorted into recursive and non-recursive, etc. In case you don't like the licensing there (or have trouble with the link, etc.) here's one possible implementation of a matching algorithm that at least closely approximates what Windows uses: #include #include bool match(char const *needle, char const *haystack) { for (; *needle != '\0'; ++needle) { switch (*needle) { case '?': if (*haystack == '\0') return false; ++haystack; break; case '*': { if (needle[1] == '\0') return true; size_t max = strlen(haystack); for (size_t i = 0; i Since there was a discussion of complexity of some of the other answers, I'll note that I believe this has O(NM) complexity and O(M) storage use (where N is the size of the target string, and M is the size of the pattern). With @masterxilo's test pair: "*a*??????*a*?????????a???????????????", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ...this finds a match in approximately 3 microseconds on my machine. That is a lot slower than a typical pattern--most of my other tests run in about 300 nanoseconds or so on this particular machine. At the same time, @masterxilo's code takes approximately 11 microseconds to run on the same machine, so this is still around 3 to 4 times faster (not to mention being somewhat smaller and simpler).
