[site]: stackoverflow
[post_id]: 3798704
[parent_id]: 3798148
[tags]: 
I believe that true Ruby solution is based on meta-programming. I'd strongly recommend you this book http://pragprog.com/titles/ppmetr/metaprogramming-ruby ($20) if you are interested. By the way - the solution proposed above probably will not work as overriding column accessors is not that simple. So I would recommend to create a class method that you use in your model definition like this: class MyModel Well, that was an easy part, now comes the tougher one - the module itself: # # extends the ActiveRecord with the class method ideize that # adds to_id method to selected attributes # module Ideizer module ClassMethods def ideize(*args) # generates accessors args.each do |name| define_method("#{name}") do # read the original value value = read_attribute(name) # if value does not contain to_id method then add it unless value.respond_to?(:to_id) # use eigen class for the value class I have to admit that I did not write the solution above just from my memory so I've prepared some tests that I'm sharing here: require 'spec_helper' describe MyModel do before :each do @mod = MyModel.new(:name => "Foo Bar", :title => "Bar Bar", :untouched => "Dont touch me") end it "should have to_id on name" do @mod.name.respond_to?(:to_id).should be_true @mod.name.to_id.should eql "foo_bar" end it "should have to_id on title" do @mod.title.respond_to?(:to_id).should be_true @mod.title.to_id.should eql "bar_bar" end it "should NOT have to_id on untouched" do @mod.untouched.respond_to?(:to_id).should be_false end it "should work with real model" do @mod.save! @mod.name.to_id.should eql "foo_bar" # reload from the database @mod.reload @mod.name.to_id.should eql "foo_bar" end end Ruby rules!
