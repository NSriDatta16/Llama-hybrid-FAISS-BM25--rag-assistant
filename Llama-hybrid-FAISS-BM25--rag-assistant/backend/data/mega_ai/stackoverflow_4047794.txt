[site]: stackoverflow
[post_id]: 4047794
[parent_id]: 4045722
[tags]: 
I think my program below meets your requirements exactly, with one possible caveat: you're not allowed to type in the text area. So this would be good for a log viewer, but not an interactive console. The code runs a little long because I have made it into a ready-to-run demo of the approach. I suggest running the program as-is and checking out the behavior. If the behavior works well for you, then invest a little time in studying the code. I have included comments in the code to highlight some of the more important sections. Update 2013-07-17: You may also want to check out random dude 's solution in his separate answer farther down the page. His approach is more elegant than mine. Also see Swing: Scroll to bottom of JScrollPane, conditional on current viewport location for a potential solution that does not interfere with the caret position. SCCE source code follows: import java.awt.*; import java.awt.event.*; import java.util.*; import java.util.Timer; import javax.swing.*; import javax.swing.event.*; import javax.swing.text.*; public class ScrollingJTextAreaExample extends JFrame { // Worker thread to help periodically append example messages to JTextArea Timer timer = new Timer(); // Merely informative counter, will be displayed with the example messages int messageCounter = 0; // GUI components JScrollPane jScrollPane; JTextArea jTextArea; public ScrollingJTextAreaExample() { initComponents(); // Boiler plate GUI construction and layout // Configure JTextArea to not update the cursor position after // inserting or appending text to the JTextArea. This disables the // JTextArea's usual behavior of scrolling automatically whenever // inserting or appending text into the JTextArea: we want scrolling // to only occur at our discretion, not blindly. NOTE that this // breaks normal typing into the JTextArea. This approach assumes // that all updates to the ScrollingJTextArea are programmatic. DefaultCaret caret = (DefaultCaret) jTextArea.getCaret(); caret.setUpdatePolicy(DefaultCaret.NEVER_UPDATE); // Schedule a task to periodically append example messages to jTextArea timer.schedule(new TextGeneratorTask(), 250, 250); // This DocumentListener takes care of re-scrolling when appropriate Document document = jTextArea.getDocument(); document.addDocumentListener(new ScrollingDocumentListener()); } // Boring, vanilla GUI construction and layout code private void initComponents() { jScrollPane = new javax.swing.JScrollPane(); jTextArea = new javax.swing.JTextArea(); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); jScrollPane.setViewportView(jTextArea); getContentPane().add(jScrollPane, java.awt.BorderLayout.CENTER); setSize(320, 240); setLocationRelativeTo(null); } // ScrollingDocumentListener takes care of re-scrolling when appropriate class ScrollingDocumentListener implements DocumentListener { public void changedUpdate(DocumentEvent e) { maybeScrollToBottom(); } public void insertUpdate(DocumentEvent e) { maybeScrollToBottom(); } public void removeUpdate(DocumentEvent e) { maybeScrollToBottom(); } private void maybeScrollToBottom() { JScrollBar scrollBar = jScrollPane.getVerticalScrollBar(); boolean scrollBarAtBottom = isScrollBarFullyExtended(scrollBar); boolean scrollLock = Toolkit.getDefaultToolkit() .getLockingKeyState(KeyEvent.VK_SCROLL_LOCK); if (scrollBarAtBottom && !scrollLock) { // Push the call to "scrollToBottom" back TWO PLACES on the // AWT-EDT queue so that it runs *after* Swing has had an // opportunity to "react" to the appending of new text: // this ensures that we "scrollToBottom" only after a new // bottom has been recalculated during the natural // revalidation of the GUI that occurs after having // appending new text to the JTextArea. EventQueue.invokeLater(new Runnable() { public void run() { EventQueue.invokeLater(new Runnable() { public void run() { scrollToBottom(jTextArea); } }); } }); } } } class TextGeneratorTask extends TimerTask { public void run() { EventQueue.invokeLater(new Runnable() { public void run() { String message = (++messageCounter) + " Lorem ipsum dolor sit amet, consectetur" + " adipisicing elit, sed do eiusmod tempor" + " incididunt ut labore et dolore magna aliqua.\n"; jTextArea.append(message); } }); } } public static boolean isScrollBarFullyExtended(JScrollBar vScrollBar) { BoundedRangeModel model = vScrollBar.getModel(); return (model.getExtent() + model.getValue()) == model.getMaximum(); } public static void scrollToBottom(JComponent component) { Rectangle visibleRect = component.getVisibleRect(); visibleRect.y = component.getHeight() - visibleRect.height; component.scrollRectToVisible(visibleRect); } public static void main(String args[]) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new ScrollingJTextAreaExample().setVisible(true); } }); } }
