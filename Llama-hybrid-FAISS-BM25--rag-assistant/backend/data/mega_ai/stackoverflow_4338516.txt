[site]: stackoverflow
[post_id]: 4338516
[parent_id]: 4337391
[tags]: 
The most stable and safe way to do this is to load the HTML into a DOM, strip the unwanted bits from it (or, more securely, strip everything but the wanted bits) and convert the result back to a string. However — to my knowledge ColdFusion does not provide an own DOM parser for HTML (only one for XML), and the YUI Rich Text Editor does not produce XML (i.e. XHTML). This is a bit unfortunate, but not necessarily a dead end. There are plenty HTML parsers available for Java and using Java objects from ColdFusion is easy. You could include one of them in your project. You could convert your HTML input to XHTML (via jTidy) and then use the built-in XML parser to implement the scrubbing. You can even convert it back to HTML with jTidy after you're done. To get you started, I've created a sample strict white-listing solution for HTML elements and attributes around the built-in XML parser: foo bar Link baz doSomethingEvil(); ', true)> When done, the contents of xhtml looks like this: foo bar Link baz A few explanations: There are a several descriptions and UDFs on how to get Tidy to work in ColdFusion around the web, just look for them. XML DOM handling is cumbersome in ColdFusion. It's neither beautiful nor elegant, but it is still better than trying to use (God forbid) regular expressions to achieve the same effect. I strongly discourage you from using them for this problem. Use to get a feeling how ColdFusion represents XML documents and understand what's going on in my code. The second bit (removing all non-white-listed elements) is a bit hairy. Apparently it is impossible to delete a node from ColdFusion more elegantly, since ColdFusion XML nodes do expose neither the parentNode() nor the removeChild() DOM methods. This implementation is based on Ben Nadel's approach to deleting DOM nodes in CF . It works, but I am painfully aware that it sucks. Sorry for that. :-\ XPath: The expression "//*[not(contains(',#StructKeyList(whiteList)#,', concat(',',local-name(),',')))]" selects all nodes whose local name (i.e. without looking at the XML namespace) is not contained in the list of allowed names. In detail: // is a shorthand for "anywhere in the document". * means "any element node". The square brackets denote the condition. The extra commas are to make sure only full matches are taken into account — otherwise contains() would return "a" as a match in "abbr" , for example.
