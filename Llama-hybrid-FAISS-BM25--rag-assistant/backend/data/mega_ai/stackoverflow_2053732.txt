[site]: stackoverflow
[post_id]: 2053732
[parent_id]: 2052684
[tags]: 
Since the range is limited (1 to 1000000) the maximum sum of the digits does not exceed 9*6 = 54. This means that to implement the sieve a circular buffer of 54 elements should be perfectly sufficient (and the size of the sieve grows very slowly as the range increases). You already have a sieve-based solution, but it is based on pre-building the full-length buffer (sieve of 1000000 elements), which is rather inelegant (if not completely unacceptable). The performance of your solution also suffers from non-locality of memory access. For example, this is a possible very simple implementation #define N 1000000U void print_self_numbers(void) { #define NMARKS 64U /* make it 64 just in case (and to make division work faster :) */ unsigned char marks[NMARKS] = { 0 }; unsigned i, imark; for (i = 1, imark = i; i 0; digits /= 10) sum += digits % 10; marks[sum % NMARKS] = 1; } } (I'm not going for the best possible performance in terms of CPU clocks here, just illustrating the key idea with the circular buffer.) Of course, the range can be easily turned into a parameter of the function, while the size of the curcular buffer can be easily calculated at run-time from the range. As for "optimizations"... There's no point in trying to optimize the code that contains I/O operations. You won't achieve anything by such optimizations. If you want to analyze the performance of the algorithm itself, you'll have to put the generated numbers into an output array and print them later.
