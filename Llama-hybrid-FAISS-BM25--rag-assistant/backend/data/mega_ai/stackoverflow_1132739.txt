[site]: stackoverflow
[post_id]: 1132739
[parent_id]: 1131456
[tags]: 
EDIT Better/recent info is here: Keeping partially applied function generic (original below) I think a pragmatic thing here is not to try to understand this too deeply, but rather to know a couple general strategies to get past the VR and move on with your work. It's a bit of a 'cop out' answer, but I'm not sure it makes sense to spend time understanding the intracacies of the F# type system (which continues to change in minor ways from release to release) here. The two main strategies I would advocate are these. First, if you're defining a value with a function type (type with an arrow '->'), then ensure it is a syntactic function by doing eta-conversion : // function that looks like a value, problem let tupleList = List.map (fun x -> x,x) // make it a syntactic function by adding argument to both sides let tupleList l = List.map (fun x -> x,x) l Second, if you still encounter VR/generalizing problems, then specify the entire type signature to say what you want (and then 'back off' as F# allows): // below has a problem... let toleq (e:float ) a b = (abs ( a - b ) ) ]'u> (e:float ) (a:float ) (b:float ) : bool = (abs ( a - b ) ) ]'u> e (a:float ) b = (abs ( a - b ) ) I think those two strategies are the best pragmatic advice. That said, here's my attempt to answer your specific questions. I don't know. '>' is a fully generic function ('a -> 'a -> bool) which works for all types, and thus is_bigger generalizes. On the other-hand, '+' is an 'inline' function which works on a handful of primitive types and a certain class of other types; it can only be generalized inside other 'inline' functions, otherwise it must be pinned down to a specific type (or will default to 'int'). (The 'inline' method of ad-hoc polymorphism is how the mathematical operators in F# overcome the lack of "type classes".) This is the 'syntactic function' issue I discussed above; 'let's compile down into fields/properties which, unlike functions, cannot be generic. So if you want it to be generic, make it a function. (See also this question for another exception to this rule.)
