[site]: stackoverflow
[post_id]: 4083467
[parent_id]: 4030433
[tags]: 
Okay, first of all you can't guarantee anything over an unreliable link. The Two Generals' Problem proves this for both deterministic and nondeterministic protocols. All you can do is mitigate the unreliability to an acceptable degree. The easiest method is, in your case, once the server receives a poll request, it sends x number of replies, all with the same GUID . For example. S: B, anything new? S: B, anything new? S: B, anything new? B: Yes, S, I need a jacket (order #123). S: B, anything new? B: Yes, S, I need a jacket (order #123). S: B, anything new? B: Yes, S, I need a jacket (order #123). S: B, anything new? B: Yes, S, I need a jacket (order #123). B: Yes, S, I need some shoes (order #124). S: B, anything new? B: Yes, S, I need a jacket (order #123). B: Yes, S, I need some shoes (order #124). S: B, anything new? B: Yes, S, I need some shoes (order #124). S: B, anything new? B: Yes, S, I need some shoes (order #124). ... S may get spammed with orders, but since the # is sent with every request, it's not a big deal. If we missed it before, we're getting it now. If we didn't get it before, woohoo! We have it now. The system works! You'll notice that B sends messages 5 times in my example. In a realistic scenario you would probably send a message hundreds or thousands of times, until you have the desired reliability. Now the above solution is processing and bandwidth intensive, but it does work. A more clever method is to do what TCP does: have a three-way handshake. S: Hello B. Are you there? -> SYN B: Hello S, yep I'm here. What's up? -> SYN+ACK S: Oh good, you're there. -> ACK S: B, anything new? B: Yes, S, I need a jacket (order #123). But.. HTTP already does this. So if something doesn't get somewhere, you'll know. Connection timed out, connection broke, etc. Now, you could re-write these scenarios within the application level (enter WS-ReliableMessaging), but really TCP is already reliable. Some critics of these SOAP(ish) frameworks and faux-protocols (they work on top of HTTP usually) accuse them of essentially reinventing the wheel - and the wheel's problems - on a higher level of abstraction. The bottom line is that any system can fail, including reliable messaging systems. As far as eventual consistency is concerned, I think you may be confused. Eventual consistency only applies to distributed storage systems where after a Write() , you may not be able to deterministically retrieve it with a Read() for some time. This doesn't seem like your problem at all. I mean, I see what you're saying, but in a eventually consistent system, a reliable (enough) connection is assumed between the nodes. You don't make that assumption (even though I think you should .. TCP is pretty darn reliable).
