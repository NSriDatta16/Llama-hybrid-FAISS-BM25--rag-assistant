[site]: stackoverflow
[post_id]: 2609082
[parent_id]: 2608913
[tags]: 
Basic Pattern In terms of your basic pattern, can I suggest modifying your structure to use the module pattern and named functions: var Search = (function(){ var pubs = {}; pubs.carSearch = carSearch; function carSearch(color) { } pubs.peopleSearch = peopleSearch; function peopleSearch(name) { } return pubs; })(); Yes, that looks more complicated, but that's partially because there's no helper function involved. Note that now, every function has a name (your previous functions were anonymous; the properties they were bound to had names, but the functions didn't, which has implications in terms of the display of the call stack in debuggers and such). Using the module pattern also gives you the ability to have completely private functions that only the functions within your Search object can access. (Just declare the functions within the big anonymous function and don't add them to pubs .) More on my rationale for that (with advantages and disadvantages, and why you can't combine the function declaration and property assignment) here . Retrieving Parameters One of the functions I really, really like from Prototype is the Form#serialize function, which walks through the form elements and builds a plain object with a property for each field based on the field's name. (Prototype's current – 1.6.1 – implementation has an issue where it doesn't preserve the order of the fields, but it's surprising how rarely that's a problem.) It sounds like you would be well-served by such a thing and they're not hard to build; then your business logic is dealing with objects with properties named according to what they're related to, and has no knowledge of the actual form itself. Returning Values / Mixing UI and Logic I tend to think of applications as objects and the connections and interactions between them. So I tend to create: Objects representing the business model and such, irrespective of interface (although, of course, the business model is almost certainly partially driven by the interface). Those objects are defined in one place, but used both client- and server-side (yes, I use JavaScript server-side), and designed with serialization (via JSON, in my case) in mind so I can send them back and forth easily. Objects server-side that know how to use those to update the underlying store (since I tend to work on projects with an underlying store), and Objects client-side that know how to use that information to render to the UI. (I know, hardly original!) I try to keep the store and rendering objects generic so they mostly work by looking at the public properties of the business objects (which is pretty much all of the properties; I don't use the patterns like Crockford's that let you really hide data, I find them too expensive). Pragmatism means sometimes the store or rendering objects just have to know what they're dealing with, specifically, but I do try to keep things generic where I can.
