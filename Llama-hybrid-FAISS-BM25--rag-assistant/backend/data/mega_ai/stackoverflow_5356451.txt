[site]: stackoverflow
[post_id]: 5356451
[parent_id]: 5331196
[tags]: 
I thought I'd put the actual solution here in case any other nutters wish to do this. Please bear in mind that it was written by a moron so it probably isn't the most elegant solution. maxFieldWidth :: Int maxFieldWidth = 30 rect :: String -> String rect xs = (unlines (chunk (bestFieldWidth (maxFieldWidth) (lines input)) input)) where input = itemsReplace '\n' ' ' xs --Should be called with the point maximum desired width as n bestFieldWidth :: Int -> [String] -> Int bestFieldWidth _ [] = error "bestFieldWidth: Empty List" bestFieldWidth n xs | n == 6 = 6 | 1 == (length (last input)) = n | otherwise = (bestFieldWidth (n-1) xs) where input = chunk n (unlines xs) chunk :: Int -> [a] -> [[a]] chunk n [] = [] chunk n xs = ys : chunk n zs where (ys,zs) = splitAt n xs itemsReplace :: Eq a => a -> a -> [a] -> [a] itemsReplace _ _ [] = [] itemsReplace c r (x:xs) | c == x = r:itemsReplace c r xs | otherwise = x:itemsReplace c r xs
