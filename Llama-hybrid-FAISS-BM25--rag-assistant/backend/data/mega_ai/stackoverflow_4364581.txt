[site]: stackoverflow
[post_id]: 4364581
[parent_id]: 4363009
[tags]: 
Reading your file this way will work only for struct having no pointers at all - just plain variable types. That means you can not store even a table there (eg. char *). If your Student structure is more complex, you should have some kind of protocol saying how is your file organized. For example, you can use one or two bytes which would contain string size. Let's say we have the following: struct Student { std::string name; int some_id; std::string hair_color_description; }; Now when we want to write this to a file we can do void saveToFile( Student s, fstream& f ) { size_t strSize = s.name.size(); f.write( reinterpret_cast ( &strSize ), sizeof(size_t) ); f.write( reinterpret_cast ( s.name.data() ), strSize ); f.write( reinterpret_cast ( &s.some_id ), sizeof(int) ); strSize = s.hair_color_description.size(); f.write( reinterpret_cast ( &strSize ), sizeof(size_t) ); f.write( reinterpret_cast ( s.hair_color_description.data() ), strSize ); } And to load void loadFromFile( Student& s, fstream& f ) { char *buffer = NULL; size_t strSize; f.read( reinterpret_cast ( &strSize ), sizeof(size_t) ); buffer = new char[strSize]; f.read( buffer, strSize ); s.name = buffer; delete[] buffer; f.read( reinterpret_cast ( &s.some_id ), sizeof(int) ); f.read( reinterpret_cast ( &strSize ), sizeof(size_t) ); buffer = new char[strSize]; f.read( buffer, strSize ); s.hair_color_description = buffer; delete[] buffer; } Of course this code doesn't contain any error handling, which always should be performed for any I/O actions.
