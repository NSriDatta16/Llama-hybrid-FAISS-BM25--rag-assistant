[site]: stackoverflow
[post_id]: 5305360
[parent_id]: 5304972
[tags]: 
My best guess is that the IntPtr is not equivalent to the char* of your string. So when you call SW_ReleaseString, you're not providing the same pointer. What you can do, is throw together a little C++CLI intermediary. In C++CLI, and you will have access to the char* directly, as well as being able to use Marshal::PtrToString and managed string pointers, with String^ . Here's what I think that would look like: C++/CLI: String^ GetStringAndRelease(char* ptr) { string result = Marshal::PtrToStringAnsi(ptr); SW_ReleaseString(ptr); return result; } int SW_DealGetSWML(int lh, const char* swmlVersion, const char* dealVersionHandle, String% outputSWML) { char* outputSWML_out; int result = SW_DealGetSWML(lh, swmlVersion, dealVersionHandle, outputSWML_out); outputSWML = GetStringAndRelease(outputSWML_out); return result; } String^ SW_GetLastErrorSpecifics() { char* ptr = SW_GetLastErrorSpecifics(); return GetStringAndRelease(ptr); } and then in C#: [DllImport(your_wrapper_dll, EntryPoint = "_SW_DealGetSWML@16", CharSet = CharSet.Ansi)] public static extern int SW_DealGetSWML(int lh, string swmlVersion, string dealVersionHandle, [Out] out string outputSWML); [DllImport(your_wrapper_dll, EntryPoint = "_SW_GetLastErrorSpecifics@0", CharSet = CharSet.Ansi)] public static extern string SW_GetLastErrorSpecifics();
