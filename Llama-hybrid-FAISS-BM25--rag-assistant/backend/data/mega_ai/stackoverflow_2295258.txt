[site]: stackoverflow
[post_id]: 2295258
[parent_id]: 2222292
[tags]: 
I had an idea today; check this out public static IEnumerable Take (this IEnumerator iterator, int count) { for (var i = 0; i > Section (this IEnumerator iterator, int length) { var sct = Enumerable.Empty (); do { sct = iterator.Take(length).ToArray(); if (sct.Any()) yield return sct; } while (sct.Any()); } This is still not super-elegant but at least the implementation is very short and readable. It may be quite interesting investigating query operators over IEnumerator. And for convenience public static IEnumerable > Section (this IEnumerable source, int length) { using (var iterator = source.GetEnumerator()) foreach (var e in iterator.Section(length)) yield return e; }
