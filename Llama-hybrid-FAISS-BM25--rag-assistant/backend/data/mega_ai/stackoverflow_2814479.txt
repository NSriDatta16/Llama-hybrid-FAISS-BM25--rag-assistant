[site]: stackoverflow
[post_id]: 2814479
[parent_id]: 2811635
[tags]: 
Ok I'm going out on a limb here, because I know C but I don't know Java. Literally rewriting this C code in Java is begging for trouble. Even in C, the code is unportable. Among other things it relies on: The size of floating point numbers. The size of integers. The internal representation of floating point numbers. The byte alignment of both floating point numbers and integers. Right shift ( i.e. i>>1) being implemented using logical right shift as opposed to arithmetic right shift (which would shift in a 1 on integers with a high order 1 bit and thus no longer equate to divide by 2). I understand Java compiles to a bytecode rather than directly to machine code. Implementers of byte code interpreters tune using assumptions based on the spec for the byte code and an understanding of what is output by the compiler from sensible input source code. Hacks like this don't fall under the umbrella "sensible input source". There is no reason to expect the interpreter will perform faster with your C hack, in fact there is a good chance it will be slower. My advice is: IGNORE The C code. Look for a gain in efficiency that is Java centric. The concept of the C hack is: Approximate 1/square(x) by leveraging knowledge that the internal representation of floating point numbers already has the exponent broken out of the number, exponent(x)/2 is faster to compute than root(x) if you already have exponent(x). The hack then performs one iteration of newton's method to reduce the error in the approximation. I Presume one iteration reduced the error to something tolerable. Perhaps the concept warrants investigation in Java, but the details will depend on intimate knowledge of how JAVA is implemented, not how C is implemented.
