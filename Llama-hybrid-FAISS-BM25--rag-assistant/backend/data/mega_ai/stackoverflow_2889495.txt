[site]: stackoverflow
[post_id]: 2889495
[parent_id]: 2889182
[tags]: 
There's a lot you need to learn here. First of all, you're treating a structure as an array of bytes. This is strictly undefined behavior due to the strict aliasing rule . Anything can happen. So don't do it. Use proper serialization (for example via boost ) instead. Yes, it's tedious. Yes, it's necessary. Even if you ignore the undefinedness, and choose to become dependant on some particular compiler implementation (which may change even in the next compiler version), there's still reasons not to do it. If you save a file on one machine, then load it on another, you may get garbage, because the second machine uses a different float representation, or a different endianness , or has different alignment rules , etc. If your struct contains any pointers, it's very likely that saving them verbatim then loading them back will result in an address that doesn't not point to any meaningful place. Typically when you add a member function, this happens: the function's machine code is stored in a place shared by all the class instances (it wouldn't make sense to duplicate it, since it's logically immutable) a hidden "this" pointer is passed to the function when it's called, so it knows which object it's been called on. none of this requires any storage space in the instances. However, when you add at least one virtual function, the compiler typically needs to also add a data chunk called a vtable (read up on it). This makes it possible to call different code depending on the current runtime type of the object (aka polymorphism). So the first virtual function you add to the class likely does increase the object size.
