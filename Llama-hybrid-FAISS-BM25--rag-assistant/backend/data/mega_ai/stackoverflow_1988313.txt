[site]: stackoverflow
[post_id]: 1988313
[parent_id]: 1987884
[tags]: 
If you have a lot of tiles, that will impact performance because Flash needs to update the transformations of a lot of display objects (which internally means a lot of matrix calculations, and subsequent redraws of big areas of the screen.) There is another way to achieve interactivity, if you find that you must use a single bitmap data for performance. Keep an "abstract" (i.e. not graphical) data model in memory, that stores your game state. Make sure that you are able to read from your store where a certain element is positioned in the game world. Then you can use a flat bitmap data to render the game world, because the individual positions are stored elsewhere. When the user clicks the DisplayObject containing the bitmap data (a Sprite in which the bitmap is drawn using a bitmap fill, or that wraps a Bitmap), look in your model which of your game elements was hit by that click. // myTileSprite is a Sprite with a bitmap fill myTileSprite.addEventListener(MouseEvent.CLICK, handleWorldClick); function handleWorldClick(ev : MouseEvent) : void { var i : int; // Loop through all game element data models for (i=0; i Here, whenever the player clicks the world graphics, the loop tries to find that element which was directly under the mouse position. You will need to implement a hitTest() method on all your game element data models, of course. Such a method simply checks the supplied world space position against the tile's area: // GameElement.hitTest(): /** * Tests a world position against the position and area of this game * element tile. Returns a boolean indicating whether this tile was hit. */ public function hitTest(mouseX : Number, mouseY : Number) : void { var rect : Rectangle = new Rectangle(this.worldX, this.worldY, this.width, this.height); if (mouseX > rect.left && mouseX rect.top && mouseY The GameElement class is not an display object, but has worldX and worldY properties indicating where it is located in the world. It's width and height properties define it's dimensions. The trick from hereon is to make sure that the rendered bitmap and your model storage is synchronized, so that a tile's position on the bitmap really corresponds to it's worldX/worldY properties in the data model.
