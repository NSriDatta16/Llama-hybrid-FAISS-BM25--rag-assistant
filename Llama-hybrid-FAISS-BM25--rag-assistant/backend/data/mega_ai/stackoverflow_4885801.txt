[site]: stackoverflow
[post_id]: 4885801
[parent_id]: 
[tags]: 
How to serialize access to an asynchronous resource?

Can anyone point me to a good working solution to the following problem? The application I'm working on needs to communicate over TCP to software running on another system. Some of the requests I send to that system can take a long time to complete (up to 15sec). In my application I have a number of threads, including the main UI thread, which can access the service which communicates with the remote system. There is only a single instance of the service which is accessed by all threads. I need to only allow a single request to be processed at a time, i.e. it needs to be serialized, otherwise bad things happen with the TCP comms. Attempted Solutions so far Initially I tried using lock() with a static object to protect each 'command' method, as follows: lock (_cmdLock) { SetPosition(position); } However I found that sometimes it wouldn't release the lock, even though there are timeouts on the remote system and on the TCP comms. Additionally, if two calls came in from the same thread (e.g. a user double clicked a button) then it would get past the lock - after reading up about locking again I know that the same thread won't wait for the lock. I then tried to use AutoResetEvents to only allow a single call through at a time. But without the locking it wouldn't work with multiple threads. The following is the code I used to send a command (from the calling thread) and process a command request (running in the background on its own thread) private static AutoResetEvent _cmdProcessorReadyEvent = new AutoResetEvent(false); private static AutoResetEvent _resultAvailableEvent = new AutoResetEvent(false); private static AutoResetEvent _sendCommandEvent = new AutoResetEvent(false); // This method is called to send each command and can run on different threads private bool SendCommand(Command cmd) { // Wait for processor thread to become ready for next cmd if (_cmdProcessorReadyEvent.WaitOne(_timeoutSec + 500)) { lock (_sendCmdLock) { _currentCommand = cmd; } // Tell the processor thread that there is a command present _sendCommandEvent.Set(); // Wait for a result from the processor thread if (!_resultAvailableEvent.WaitOne(_timeoutSec + 500)) _lastCommandResult.Timeout = true; } return _lastCommandResult.Success; } // This method runs in a background thread while the app is running private void ProcessCommand() { try { do { // Indicate that we are ready to process another commnad _cmdProcessorReadyEvent.Set(); _sendCommandEvent.WaitOne(); lock (_sendCmdLock) { _lastCommandResult = new BaseResponse(false, false, "No Command"); RunCOMCommand(_currentCommand); } _resultAvailableEvent.Set(); } while (_processCommands); } catch (Exception ex) { _lastCommandResult.Success = false; _lastCommandResult.Timeout = false; _lastCommandResult.LastError = ex.Message; } } I haven't tried implementing a queue of command requests as the calling code expects everything to be synchronous - i.e. the previous command must have completed before I sent the next one. Additional Background The software running on the remote system is a 3rd party product and I don't have access to it, it is used to control a laser marking machine with an integrated XY table. I'm actually using a legacy VB6 DLL to communicate with the laser as it has all the code for formatting commands and processing the responses. This VB6 DLL uses a WinSock control for the comms.
