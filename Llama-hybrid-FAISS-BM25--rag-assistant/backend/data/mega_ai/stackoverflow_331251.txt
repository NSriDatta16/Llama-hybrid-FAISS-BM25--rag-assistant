[site]: stackoverflow
[post_id]: 331251
[parent_id]: 328127
[tags]: 
As I found, the window will move to "negative" location, but will then jump back. To prevent this you could do something like: public partial class Window1: Window { public Window1() { InitializeComponent(); } private void Window_MouseDown(object sender, MouseButtonEventArgs e) { DragMove(); } public struct WINDOWPOS { public IntPtr hwnd; public IntPtr hwndInsertAfter; public int x; public int y; public int cx; public int cy; public UInt32 flags; }; private static IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled) { switch(msg) { case 0x46://WM_WINDOWPOSCHANGING if(Mouse.LeftButton != MouseButtonState.Pressed) { WINDOWPOS wp = (WINDOWPOS)Marshal.PtrToStructure(lParam, typeof(WINDOWPOS)); wp.flags = wp.flags | 2; //SWP_NOMOVE Marshal.StructureToPtr(wp, lParam, false); } break; } return IntPtr.Zero; } private void Window_Loaded(object sender, RoutedEventArgs e) { HwndSource source = HwndSource.FromHwnd(new WindowInteropHelper(this).Handle); source.AddHook(new HwndSourceHook(WndProc)); } } Handling WM_WINDOWPOSCHANGING this way will prevent any movement of the window unless left mouse button is pressed. This includes maximizing the window and programmatic change of window position as well, so you'll have to adapt the code if you need another behavior.
