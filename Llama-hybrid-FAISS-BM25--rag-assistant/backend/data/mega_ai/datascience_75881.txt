[site]: datascience
[post_id]: 75881
[parent_id]: 75671
[tags]: 
@Ben Norris found out that the relaimpo packages has a hard minimum number of observations, so if I wanted to pursue this path I have to up my sample size. As I only have the data that I have, I pursued a "hacky" solution which I am going to describe for completionists sake. The steps were as follows: Assign each individual to one of k groups randomly, so that n/k > 4 (with n being the total sample size) Repeat this step i couple of times,so that each individual is assigned to i groups Split the total data set into a list of k dfs along the groups Train a regression model with relaimpo for each data set Average the resulting coefficients over all groups an individual was a part of to get approximate "individual coefficients" This is a rather unscientific process but seemed better to me than simply "duplicating" individuals answers until the minimum sample size was met. Here is the code I used: library(dplyr) library(magrittr) library(relaimpo) #create groups df %>% add_count(i_TAN) %>% group_by(i_TAN) %>% mutate( g1 = as.integer(runif(n, 1, 51)), g2 = as.integer(runif(n, 1, 51)), g3 = as.integer(runif(n, 1, 51)), g4 = as.integer(runif(n, 1, 51)) ) %>% {.} -> df # Create all dfs df %>% select(i_TAN,g1,g2,g3,g4) %>% gather(nam,group,-i_TAN) %>% distinct() %>% select(-nam) %>% left_join(df, by = "i_TAN") %>% select(1:35) %$% split(.,group) %>% {.} -> list_of_df lapply(list_of_df, function(x) { x["group"] % lapply(function(x) { x["i_TAN"] % {.} -> list_of_modelDF # Fit all models lapply(list_of_modelDF,function(x){lm(Consideration~.,data = x)}) -> list_of_reg lapply(list_of_reg,function(x){relaimpo::calc.relimp(object = x, type = c("lmg"), rela = TRUE)}) -> list_of_relaimpo ```
