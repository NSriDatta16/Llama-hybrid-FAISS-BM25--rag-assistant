[site]: stackoverflow
[post_id]: 2201964
[parent_id]: 
[tags]: 
_heapwalk reports _HEAPBADNODE, causes breakpoint or loops endlessly

I use _heapwalk to gather statistics about the Process' standard heap. Under certain circumstances i observe unexpected behaviours like: _HEAPBADNODE is returned some breakpoint is triggered inside _heapwalk, telling me the heap might got corrupted access violation inside _heapWalk. I saw different behaviours on different Computers. On one Windows XP 32 bit machine everything looked fine, whereas on two Windows XP 64 bit machines i saw the mentioned symptoms. I saw this behaviour only if LowFragmentationHeap was enabled. I played around a bit. I walked the heap several times right one after another inside my program. First time doing nothing in between the subsequent calls to _heapWalk (everything fine). Then again, this time doing some stuff (for gathering statistics) in between two subsequent calls to _heapWalk. Depending upon what I did there, I sometimes got the described symptoms. Here finally a question: What exactly is safe and what is not safe to do in between two subsequent calls to _heapWalk during a complete heap walk run? Naturally, i shall not manipulate the heap. Therefore i doublechecked that i don't call new and delete . However, my observation is that function calls with some parameter passing causes my heap walk run to fail already. I subsequently added function calls and increasing number of parameters passed to these. My feeling was two function calls with two paramters being passed did not work anymore. However I would like to know why. Any ideas why this does not happen on some machines? Any ideas why this only happens if LowFragmentationHeap is enabled? Sample Code finally: #include void staticMethodB( int a, int b ) { } void staticMethodA( int a, int b, int c) { staticMethodB( 3, 6); return; } ... _HEAPINFO hinfo; hinfo._pentry = NULL; while( ( heapstatus = _heapwalk( &hinfo ) ) == _HEAPOK ) { //doing nothing here works fine //however if i call functions here with parameters, this causes //_HEAPBADNODE or something else staticMethodA( 3,4,5); } switch( heapstatus ) { ... case _HEAPBADNODE: assert( false ); /*ERROR - bad node in heap */ break; ...
