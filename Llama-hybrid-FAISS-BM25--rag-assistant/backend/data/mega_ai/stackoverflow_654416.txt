[site]: stackoverflow
[post_id]: 654416
[parent_id]: 651661
[tags]: 
I would suggest overriding save, but I'm guessing you're using the django.contrib.auth.User object. In that case, you can accomplish about the same thing with a pre_save signal: def manage_domains(signal,**kwargs): if kwargs.has_key('instance'): instance = kwargs['instance'] else: return old_instance = User.objects.get(pk=instance.pk) instance_categories = instance.categories.all() for group in old_instance.groups.all(): if group not in instance_categories: instance.groups.clear() pre_save.connect(manage_domains, sender=User) This is not even close to an efficient solution. What will happen is that when a User object is saved, the above changes will be made to the object in memory, then the save will overwrite the object in the database. You've gone to the trouble not only of hitting the database to find out if the unmodified version of the object agrees with with what you're about to save, but you're also looping through two category sets, both requiring a database hit to load. The best way to make an efficiency improvement here would be to subclass the ManyToMany field manager itself, because that's what's paying attention to changes as they occur in memory, rather than merely comparing state after the fact. But this would be a bit more involved and would also require you to abandon the built-in User object.
