[site]: stackoverflow
[post_id]: 3706448
[parent_id]: 3706264
[tags]: 
Unless your multiplications are fairly simplistic, the add most likely won't outperform a mul . Having said that, you can use add to do multiplications: Multiply by 2: add eax,eax ; x2 Multiply by 4: add eax,eax ; x2 add eax,eax ; x4 Multiply by 8: add eax,eax ; x2 add eax,eax ; x4 add eax,eax ; x8 They work nicely for powers of two. I'm not saying they're faster. They were certainly necessary in the days before fancy multiplication instructions. That's from someone whose soul was forged in the hell-fires that were the Mostek 6502, Zilog z80 and RCA1802 :-) You can even multiply by non-powers by simply storing interim results: Multiply by 9: push ebx ; preserve push eax ; save for later add eax,eax ; x2 add eax,eax ; x4 add eax,eax ; x8 pop ebx ; get original eax into ebx add eax,ebx ; x9 pop ebx ; recover original ebx I generally suggest that you write your code primarily for readability and only worry about performance when you need it. However, if you're working in assembler, you may well already at that point. But I'm not sure my "solution" is really applicable to your situation since you have an arbitrary multiplicand. You should , however, always profile your code in the target environment to ensure that what you're doing is actually faster. Assembler doesn't change that aspect of optimisation at all. If you really want to see some more general purpose assembler for using add to do multiplication, here's a routine that will take two unsigned values in ax and bx and return the product in ax . It will not handle overflow elegantly. START: MOV AX, 0007 ; Load up registers MOV BX, 0005 CALL MULT ; Call multiply function. HLT ; Stop. MULT: PUSH BX ; Preserve BX, CX, DX. PUSH CX PUSH DX XOR CX,CX ; CX is the accumulator. CMP BX, 0 ; If multiplying by zero, just stop. JZ FIN MORE: PUSH BX ; Xfer BX to DX for bit check. POP DX AND DX, 0001 ; Is lowest bit 1? JZ NOADD ; No, do not add. ADD CX,AX NOADD: SHL AX,1 ; Shift AX left (double). SHR BX,1 ; Shift BX right (integer halve, next bit). JNZ MORE ; Keep going until no more bits in BX. FIN: PUSH CX ; Xfer product from CX to AX. POP AX POP DX ; Restore registers and return. POP CX POP BX RET It relies on the fact that 123 multiplied by 456 is identical to: 123 x 6 + 1230 x 5 + 12300 x 4 which is the same way you were taught multiplication back in grade/primary school. It's easier with binary since you're only ever multiplying by zero or one (in other words, either adding or not adding). It's pretty old-school x86 (8086, from a DEBUG session - I can't believe they still actually include that thing in XP) since that was about the last time I coded directly in assembler. There's something to be said for high level languages :-)
