[site]: stackoverflow
[post_id]: 4893119
[parent_id]: 4891172
[tags]: 
Your query (based on the SQL) looks like it needs to read the entire revert table, and find the appropriate revision rows for each row in the revert table. Since the entire revert table needs to be read, a sequential scan of it is appropriate. It seems to expect roughly the right number of rows. Each revert row is then going to match a number of revisions, which it thinks will be best done through an index scan and merge join. It estimates that on average, each revert row will match roughly 3300 revisions, resulting in 88 billion rows. I don't know of any ways to select 88 billion rows quickly. In order to get a more accurate estimate, you'll need a way of convincing PostgreSQL that there are a lot less than 3300 revisions covered by each revert. You say that you are after reverted revisions, indicating that each revision should appear only once, even if included within multiple reverts. So try using an EXISTS (subquery) instead of an INNER JOIN This won't give you the revert revisions though: EXPLAIN SELECT r.revision_id FROM revision_main r WHERE EXISTS (SELECT 1 FROM revert rvt WHERE r.page_id = rvt.page_id AND r.revision_id > rvt.reverted_to AND r.revision_id
