[site]: stackoverflow
[post_id]: 114289
[parent_id]: 114214
[tags]: 
Methods in Python are a very, very simple thing once you understood the basics of the descriptor system. Imagine the following class: class C(object): def foo(self): pass Now let's have a look at that class in the shell: >>> C.foo >>> C.__dict__['foo'] As you can see if you access the foo attribute on the class you get back an unbound method, however inside the class storage (the dict) there is a function. Why's that? The reason for this is that the class of your class implements a __getattribute__ that resolves descriptors. Sounds complex, but is not. C.foo is roughly equivalent to this code in that special case: >>> C.__dict__['foo'].__get__(None, C) That's because functions have a __get__ method which makes them descriptors. If you have an instance of a class it's nearly the same, just that None is the class instance: >>> c = C() >>> C.__dict__['foo'].__get__(c, C) > Now why does Python do that? Because the method object binds the first parameter of a function to the instance of the class. That's where self comes from. Now sometimes you don't want your class to make a function a method, that's where staticmethod comes into play: class C(object): @staticmethod def foo(): pass The staticmethod decorator wraps your class and implements a dummy __get__ that returns the wrapped function as function and not as a method: >>> C.__dict__['foo'].__get__(None, C) Hope that explains it.
