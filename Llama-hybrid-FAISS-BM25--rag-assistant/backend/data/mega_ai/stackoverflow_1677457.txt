[site]: stackoverflow
[post_id]: 1677457
[parent_id]: 1677415
[tags]: 
There's nothing in the standard that mandates how things are organized on the stack at all. In fact, you could build a conforming compiler that didn't store array elements at contiguous elements on the stack at all, provided it had the smarts to still do array element arithmetic properly (so that it knew, for example, that a 1 was 1K away from a[0] and could adjust for that). The reason you may be getting different results is because, while the stack may grow down to add "objects" to it, the array is a single "object" and it may have ascending array elements in the opposite order. But it's not safe to rely on that behaviour since direction can change and variables could be swapped around for a variety of reasons including, but not limited to: optimization. alignment. the whims of the person the stack management part of the compiler. See here for my excellent treatise on stack direction :-) In answer to your specific questions: Does stack grow up or down? It doesn't matter at all (in terms of the standard) but, since you asked, it can grow up or down in memory, depending on the implementation. What happen between a[2] and q memory addresses? Why there are a big memory difference there? (20 bytes)? It doesn't matter at all (in terms of the standard). See above for possible reasons.
