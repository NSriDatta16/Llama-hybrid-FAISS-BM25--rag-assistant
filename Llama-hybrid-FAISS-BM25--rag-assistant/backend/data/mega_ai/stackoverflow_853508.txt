[site]: stackoverflow
[post_id]: 853508
[parent_id]: 853483
[tags]: 
Is this what you want? def func(**kwargs): for key, value in kwargs.items(): pass # Do something func(**myDict) # Call func with the given dict as key/value parameters (See the documentation for more about keyword arguments. The keys in myDict must be strings.) Edit : you edited your question to include the following: I think the ** notation in front of myDict instructs the function to expect a dictionary and to unpack the key (the first *) and the value, the second * This is not correct. To understand what is happening, you must consider the following: A function can have multiple formal parameters ( a and b in this case): def f1(a, b): pass We can pass positional arguments to such function (like in most other languages): f1(2, 3) We can also pass keyword arguments : f1(a=2, b=3) We can also mix these, but the positional arguments must come first : f1(2, b=3) f1(a=2, 3) # SyntaxError: non-keyword arg after keyword arg There is a way to let a function accept an arbitrary number of positional arguments, which it can access as a tuple ( args in this case): def f2(*args): assert isinstance(args, tuple) Now we can call f2 using separately specified arguments, or using a list whose contents first need to be unpacked , using a syntax similar to the notation used for *args : f2(2, 3) f2(*[2, 3]) Likewise, an arbitrary number of keyword arguments may be accepted: def f3(**kwargs): pass Note that f3 does not ask for a single argument of type dict . This is the kind of invocations it expects: f3(a=2, b=3) f3(**{'a': 2, 'b': 3}) All arguments to f3 must be named: f3(2, 3) # TypeError: f3() takes exactly 0 arguments (2 given) Putting all of this together, and remembering that positional arguments must come first, we may have: >>> def f4(a, b, *args, **kwargs): ... print('%r, %r' % (args, kwargs)) ... >>> f4(2, 3) (), {} >>> f4(2, 3, 4, 5) (4, 5), {} >>> f4(2, 3, x=4, y=5) (), {'y': 5, 'x': 4} >>> f4(2, 3, 4, 5, x=6, y=7) (4, 5), {'y': 7, 'x': 6} >>> f4(2, *[3, 4, 5], **{'x': 6, 'y': 7}) (4, 5), {'y': 7, 'x': 6} Pay special attention to the following two errors: >>> f4(2) Traceback (most recent call last): File " ", line 1, in TypeError: f4() takes at least 2 arguments (1 given) >>> f4(2, 3, a=4) Traceback (most recent call last): File " ", line 1, in TypeError: f4() got multiple values for keyword argument 'a' The second error should help you explain this behavior: >>> f4(**{'foo': 0, 'a': 2, 'b': 3, 'c': 4}) (), {'c': 4, 'foo': 0}
