[site]: stackoverflow
[post_id]: 5091599
[parent_id]: 5088527
[tags]: 
So IdUser is in reality an existential type: For User there exists a type IdUser.current such that the public IdUser.t can be lifted to it. There are a couple of ways to encode this: either functorize User as Gasche shows if statically managing the dependence is sufficient, or use first-class modules or objects if you need more dynamism. I'll work out Gasche's example a bit more, using private type abbreviations for convenience and to show how to leverage translucency to avoid privatizing implementation types too much. First, and this might be a limitation, I want to declare an ADT of persistent IDs : (* File id.ml *) module type ID = sig type t type current = private t end module type PERSISTENT_ID = sig include ID val persist : t -> current end With this I can define the type of Post s using concrete types for the ID s but with ADTs to enforce the business rules relating to persistence: (* File post.ml *) module Post (UID : ID with type t = string) (PID : PERSISTENT_ID with type t = int) : sig val is_mine : UID.current -> PID.t -> PID.current end = struct let is_mine uid pid = if (uid : UID.current :> UID.t) = "me" && pid = 0 then PID.persist pid else failwith "is_mine" end The same thing with User s: (* File user.ml *) module User (UID : PERSISTENT_ID with type t = string) : sig val check_password : UID.t -> password:string -> UID.current end = struct let check_password uid ~password = if uid = "scott" && password = "tiger" then UID.persist uid else failwith "check_password" end Note that in both cases I make use of the concrete but private ID types. Tying all together is a simple matter of actually defining the ID ADTs with their persistence rules: module IdUser = struct type t = string type current = string let persist x = x end module IdPost = struct type t = int type current = int let persist x = x end module MyUser = User (IdUser) module MyPost = Post (IdUser) (IdPost) At this point and to fully decouple the dependencies you will probably need signatures for USER and POST that can be exported from this module, but it's a simple matter of adding them in.
