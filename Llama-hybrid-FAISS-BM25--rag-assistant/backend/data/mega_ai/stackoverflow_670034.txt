[site]: stackoverflow
[post_id]: 670034
[parent_id]: 669576
[tags]: 
Good question. Not sure there's a good answer, other than changing the schema to use Unicode characters instead of bytes. For example in SQL Server with NVARCHAR or MySQL with UTF-8 collations columns are limited by character length. That's pushing it a bit regarding “column lengths can't change” of course, even if they're technically the same ‘length’. For what it's worth, East Asian users will be used to the idea that a character isn't a byte, because there's a long-standing tradition of ‘half-width’ latin characters taking up half as much storage and screen space as the Chinese ideographs. You can't really generally expect anyone to grok UTF-8 byte numbers though. Perhaps at the client side you could do it purely visually, using an ‘amount used’ bar instead of a number of bytes: .field { width: 12em; } .field input { width: 100%; } .field input { box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box; -khtml-box-sizing: border-box; } .indicator { background: blue; height: 5px; } .indicator-over { background: red; height: 5px; } function limitInput(element, limit) { var indicator= document.createElement('div'); element.parentNode.insertBefore(indicator, element.nextSibling); element.onchange=element.onkeyup= function() { var utf8= unescape(encodeURIComponent(element.value)); indicator.className= utf8.length>limit? 'indicator-over' : 'indicator'; var used= Math.min(utf8.length/limit, 1); indicator.style.width= Math.floor(used*100)+'%'; } element.onchange(); } var inputs= document.getElementsByTagName('input'); for (var i= inputs.length; i-->0;) if (inputs[i].className.substring(0, 8)=='limited-') limitInput(inputs[i], parseInt(inputs[i].className.substring(8)));
