[site]: stackoverflow
[post_id]: 5508649
[parent_id]: 5484434
[tags]: 
Looking at the problem from the book, you have misstated the problem a little. The input data is a sequence of key/values (t -> x(t)), where t is a time and x(t) if the value observed at that time. Then to compute a moving average at any time, you use the formula: y(t) = a0 * x(t) + a1 * x(t-1) + a2 * x(t-2) + ... + aN * x(t-N) where a0, a1, a2, ... aN are known constants. The key to implementing a mapper for this problem is to recognize all y(t) equations that contain a particular x and using the equation as the key. This is done by observing the patterns of the time parameter, t. For any x(t), x(t) is in the first in y(t). x(t) is also the second term in y(t+1), the third term in y(t+2), and so on up to the (N+1) place term in y(t+N). So, for each for each (t -> x(t)) key/value in the input the mapper needs to output several new key/value pairs: t -> {a0, x(t)} t+1 -> {a1, x(t)} t+2 -> {a2, x(t)} ... t+N -> {aN, x(t)} After the mapper is complete, there will be a collection of {an, x(t)} values keyed by the y(t) equation they are part of. On the reducer side, the set of {an, x(t)} values for a particular y(t) will be delivered for which a sum of products can be computed to produce the y(t) value.
