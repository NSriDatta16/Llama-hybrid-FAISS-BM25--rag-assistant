[site]: stackoverflow
[post_id]: 4408865
[parent_id]: 4408679
[tags]: 
What you're looking for is called a " pivot " (see also " Pivoting Operations " in the Oracle Database Data Warehousing Guide): SELECT * FROM tbl PIVOT(SUM(value) FOR Key IN (40, 41, 42)) It was added to Oracle in 11g. Note that you need to specify the result columns (the values from the unpivoted column that become the pivoted column names) in the pivot clause. Any columns not specified in the pivot are implicitly grouped by. If you have columns in the original table that you don't wish to group by, select from a view or subquery, rather than from the table. You can engage in a bit of wizardry and get Oracle to create the statement for you, so that you don't need to figure out what column values to pivot on. In 11g, when you know the column values are numeric: SELECT 'SELECT * FROM tbl PIVOT(SUM(value) FOR Key IN (' || LISTAGG(Key, ',') WITHIN GROUP (ORDER BY Key) || ');' FROM tbl; If the column values might not be numeric: SELECT 'SELECT * FROM tbl PIVOT(SUM(value) FOR Key IN (\'' || LISTAGG(Key, '\',\'') WITHIN GROUP (ORDER BY Key) || '\'));' FROM tbl; LISTAGG probably repeats duplicates (would someone test this?), in which case you'd need: SELECT 'SELECT * FROM tbl PIVOT(SUM(value) FOR Key IN (\'' || LISTAGG(Key, '\',\'') WITHIN GROUP (ORDER BY Key) || '\'));' FROM (SELECT DISTINCT Key FROM tbl); You could go further, defining a function that takes a table name, aggregate expression and pivot column name that returns a pivot statement by first producing then evaluating the above statement. You could then define a procedure that takes the same arguments and produces the pivoted result. I don't have access to Oracle 11g to test it, but I believe it would look something like: CREATE PACKAGE dynamic_pivot AS -- creates a PIVOT statement dynamically FUNCTION pivot_stmt (tbl_name IN varchar2(30), pivot_col IN varchar2(30), aggr IN varchar2(40), quote_values IN BOOLEAN DEFAULT TRUE) RETURN varchar2(300); PRAGMA RESTRICT_REFERENCES (pivot_stmt, WNDS, RNPS); -- creates & executes a PIVOT PROCEDURE pivot_table (tbl_name IN varchar2(30), pivot_col IN varchar2(30), aggr IN varchar2(40), quote_values IN BOOLEAN DEFAULT TRUE); END dynamic_pivot; CREATE PACKAGE BODY dynamic_pivot AS FUNCTION pivot_stmt ( tbl_name IN varchar2(30), pivot_col IN varchar2(30), aggr_expr IN varchar2(40), quote_values IN BOOLEAN DEFAULT TRUE ) RETURN varchar2(300) IS stmt VARCHAR2(400); quote VARCHAR2(2) DEFAULT ''; BEGIN IF quote_values THEN quote := '\\\''; END IF; -- "\||" shows that you are still in the dynamic statement string -- The input fields aren't sanitized, so this is vulnerable to injection EXECUTE IMMEDIATE 'SELECT \'SELECT * FROM ' || tbl_name || ' PIVOT(' || aggr_expr || ' FOR ' || pivot_col || ' IN (' || quote || '\' \|| LISTAGG(' || pivot_col || ', \'' || quote || ',' || quote || '\') WITHIN GROUP (ORDER BY ' || pivot_col || ') \|| \'' || quote || '));\' FROM (SELECT DISTINCT ' || pivot_col || ' FROM ' || tbl_name || ');' INTO stmt; RETURN stmt; END pivot_stmt; PROCEDURE pivot_table (tbl_name IN varchar2(30), pivot_col IN varchar2(30), aggr_expr IN varchar2(40), quote_values IN BOOLEAN DEFAULT TRUE) IS BEGIN EXECUTE IMMEDIATE pivot_stmt(tbl_name, pivot_col, aggr_expr, quote_values); END pivot_table; END dynamic_pivot; Note: the length of the tbl_name , pivot_col and aggr_expr parameters comes from the maximum table and column name length . Note also that the function is vulnerable to SQL injection. In pre-11g, you can apply MySQL pivot statement generation techniques (which produces the type of query others have posted, based on explicitly defining a separate column for each pivot value).
