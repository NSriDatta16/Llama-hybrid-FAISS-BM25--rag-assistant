[site]: stackoverflow
[post_id]: 4267784
[parent_id]: 
[tags]: 
What could be the reason for AlphaBlend to return 'false'

I am trying to stretch an HBITMAP with alpha and draw it to anther hdc. I'm using StretchDIBits and then AlphaBlend, as shown in the code below. The problem is that AlphaBlend fails and returns false. 1. Does anyone knows what could be the reason? 2. Is there a better why to stretch and draw a transparent image? void AnimationManager::Draw(HDC hBBDC, Instance sInstance,RECT sClientRect) { // sClientRect is the hwnd rect int nID = GetId(sInstance.nAnemationId); int nFrameindex = sInstance.nFrameIndexs; HDC hdcScreen = GetDC(NULL); HDC hdcMem = CreateCompatibleDC(hdcScreen); BITMAP bmp; PBITMAPINFO pbmi; WORD cClrBits; ///******************* create PBITMAPINFO *********************/// GetObject(m_pAnimations[nID]->m_pFramesArray[nFrameindex]->hBmp, sizeof(bmp), &bmp); cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel); if(cClrBits == 1) cClrBits = 1; else if(cClrBits bmiHeader.biSize = sizeof(BITMAPINFOHEADER); pbmi->bmiHeader.biWidth = bmp.bmWidth; pbmi->bmiHeader.biHeight = bmp.bmHeight; pbmi->bmiHeader.biPlanes = bmp.bmPlanes; pbmi->bmiHeader.biBitCount = bmp.bmBitsPixel; if(cClrBits bmiHeader.biClrUsed = (1 bmiHeader.biCompression = BI_RGB; pbmi->bmiHeader.biSizeImage = ((pbmi->bmiHeader.biWidth * cClrBits + 31)& ~31)/8 * pbmi->bmiHeader.biHeight; pbmi->bmiHeader.biClrImportant = 0; ///**************************end PBITMAPINFO creation *****************************************/// // I checked the code to this point and it seems to be fine. The problem stasrts here: ///create a pointer to the image bits LPVOID lpvBits = (LPVOID)LocalAlloc(GPTR,pbmi->bmiHeader.biSizeImage); GetBitmapBits(m_pAnimations[nID]->m_pFramesArray[nFrameindex]->hBmp, pbmi->bmiHeader.biSizeImage, lpvBits); ///stretch bool test = StretchDIBits(hdcMem,0,sClientRect.bottom,sClientRect.right, -1*sClientRect.bottom,0,0,pbmi->bmiHeader.biWidth,pbmi->bmiHeader.biHeight, lpvBits,pbmi,DIB_RGB_COLORS, SRCCOPY); ///blend test = AlphaBlend(hBBDC,0,0,sClientRect.right, sClientRect.bottom,hdcMem,0,0,sClientRect.right,sClientRect.bottom,m_sBlendfunc); test = DeleteDC(hdcMem); // after CreateCompatibleDC test = ReleaseDC(NULL, hdcScreen); // after GetDC LocalFree(pbmi); LocalFree(lpvBits); }
