[site]: crossvalidated
[post_id]: 565573
[parent_id]: 565566
[tags]: 
The default syntax performs propensity score matching with a propensity score estimated using a logistic regression of the treatment on the covariates. Based on this, the priority of each covariate depends on its role in computing the propensity score. You of course can estimate propensity scores however you want outside matchit() , including using a model that penalizes other coefficients but not the one on Sales2 , which will have the effect of increasing the priority of Sales2 . There are a few other ways to prioritize certain variables. You can add a caliper on that variable directly, which means in order for two units to be paired, their difference on the variable must be less that the supplied caliper. In your case, you could do something like caliper = c(Sales2 = .5) , which means in order for two units to be paired, they must be within .5 standard deviations of Sales2 of each other. This will naturally improve balance on Sales2 . You can also perform exact matching on Sales2 or a coarsened version of it; for example, to perform exact matching on a Sales2 after splitting it into 5 bins, you can include exact = ~cut(Sales2, 5) . You can also try different forms of matching. Coarsened exact matching ( method = "cem" ) allows you to specify how close units can be to fall in the same stratum by controlling the number of bins each variable is split into. Have more bins for a covariate means better balance will be achieved on it (at the expense of possibly discarding more units). Cardinality matching ( method = "cardinality" ) allows you to specify exactly how balanced you want each covariate to be; you can simply request that Sales2 is better balanced than the other covariates. Neither of these methods involves a propensity score. You can read more about them in the MatchIt vignette on matching methods.
