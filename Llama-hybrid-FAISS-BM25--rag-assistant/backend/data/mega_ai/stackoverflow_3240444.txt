[site]: stackoverflow
[post_id]: 3240444
[parent_id]: 3240266
[tags]: 
I also think that this is a very useful analogy. In fact, I used exactly this analogy when describing the pipelining operator in my Real World Functional Programming book (which tries to explain functional ideas to people with C# background). Below is a quote from Chapter 6. Regarding the differences between the two - there are some conceptual differences (e.g. extension methods "add members to objects"), but I don't think this has any impact on the way we use them in practice. One notable practical difference between C# extension methods and F# functions is editor support - when you type "." in C#, you can see extension methods for the particular type. I believe that F# IntelliSense could show a filtered list when you type |> (in principle) as well, but it is probably much more work and it isn't supported yet. Both of the constructs are used to enable expression-based compositional programming style. By this I mean that you can write much larger portions of code as a single expression that describes what should be done (without extension methods/pipelining operator, you would probably break code into multiple stements). I think that this style of programming generally leads to a more declarative code. The pipelining operator ( |> ) allows us to write the first argument for a function on the left side; that is, before the function name itself. This is useful if we want to invoke a several processing functions on some value in sequence and we want to write the value that's being processed first. Let's look at an example, showing how to reverse a list in F# and then take its first element: List.hd(List.rev [1 .. 5]) This isn't very elegant, because the operations are written in opposite order then in which they are performed and the value that is being processed is on the right side, surrounded by several braces. Using extension methods in C#, we'd write: list.Reverse().Head(); In F#, we can get the same result by using the pipelining operator: [1 .. 5] |> List.rev |> List.hd Even though, this may look tricky, the operator is in fact very simple. It has two arguments - the second one (on the right side) is a function and the first one (on the left side) is a value. The operator gives the value as an argument to the function and returns the result. In some senses, pipelining is similar to calling methods using dot-notation on an object, but it isn't limited to intrinsic methods of an object. This is similar to extension methods, so when we write a C# alternative of an F# function that's usually used with the pipelining operator, we'll implement it as an extension method.
