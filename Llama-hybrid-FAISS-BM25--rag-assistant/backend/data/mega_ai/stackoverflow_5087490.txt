[site]: stackoverflow
[post_id]: 5087490
[parent_id]: 5087413
[tags]: 
You can use special classes that inherit classes with private (now protected) methods and provide public methods that call invisible from outside protected methods. This is called Test Specific Subclass or Test Specific Extension in great book Refactoring Test Code http://xunitpatterns.com/ You can read more details and ideas for testing private methods here : http://xunitpatterns.com/Test-Specific%20Subclass.html It works like public TestClass : RealClass { public int CallHiddenCalculate() { return Calculate(); // Calculate is now protected method that we expose for test purposes in this class } } You can place this class to test assembly so your real assembly doesnt contain test specific logic and classes because its bad design. You can also use conditional compilation for visibility attribute like the following #if DEBUG public #else private #endif In this case in Debug you can call unit tests but in release those methods won't be visible. However this approach is much worse than the above and is more ugly too. Testing just public interface can easily be not enough (and often is not) in order to say that you got good test coverage and your code is easy to maintain and refactor. As for marking private methods as internal and having test assembly see internal methods is bad for many reasons your ex private methods are visible from your assembly cause they are internal you will have test specific logic (internal for those methods will only be for test purposes) in release version of your product, which is bad and I think there are more but those are most important
