[site]: stackoverflow
[post_id]: 4094245
[parent_id]: 4094222
[tags]: 
That last argument to the pthread_create is handed over to the thread when it's called, so you can just pass a value to the specific thread. Since you want both a specific mutex and a specific queue, you're better off passing in the value of i directly. for(int i = 0; i However, if you want to do it this way, I'd go for a single queue and mutex. That's because the act of putting something on the queue is almost certainly going to be much faster than processing an item on the queue (otherwise you wouldn't need threads at all). If you have multiple queues, the main thread has to figure out somehow which are the underutilised threads so it can select the best queue. If you have one queue and one mutex to protect it, the threads will self-organise for efficiency. Those threads that do long jobs won't try to get something from the queue. Those doing short jobs will come back sooner. I should mention that mutexes on their own are not a good solution for this producer/consumer model. You can't have a thread lock the mutex then wait indefinitely on the queue since that will prevent the main thread putting anything on the queue. So that means your worker threads will be constantly polling the queues looking for work. If you use a mutex combined with a condition variable, it will be a lot more efficient. That's because the threads are signalled by the main thread when work is available rather than constantly grabbing the mutex, checking for work, then releasing the mutex. The basic outline will be, for the main thread: initialise while not finished: await work lock mutex put work on queue signal condvar unlock mutex terminate and, for the worker threads: initialise while not finished: lock mutex while queue is empty: wait on condvar get work from queue unlock mutex do work terminate
