[site]: stackoverflow
[post_id]: 781486
[parent_id]: 750890
[tags]: 
You can't do it normally. Here's what I've done to get more dynamic validations working via Hibernate Validator. Extend the ClassValidator class. Override the getInvalidVaues(Object myObj) method. First, call super.getInvalidValues(myObj) , then add the hook to your customized validation. Instantiate your custom validator and call getInvalidValues to validate. Any hibernate annotated validations will kick off at this point, and your custom dynamic validations (anything not supported by annotations) will kick off as well. Example: public class MyObjectValidator extends ClassValidator { public MyObjectValidator() { super(MyObject.class); } public InvalidValue[] getInvalidValues(MyObject myObj) { List invalids = new ArrayList (); invalids.addAll(Arrays.asList(super.getInvalidValues(myObj))); // add custom validations here invalids.addAll(validateDynamicStuff(myObj)); InvalidValue[] results = new InvalidValue[invalids.size()]; return invalids.toArray(results); } private List validateDynamicStuff(MyObject myObj) { // ... whatever validations you want ... } } So your custom validation code can contain logic like "Do this validation, if the user configured it, otherwise do that one", etc. You may or may not be able to leverage the same code that powers the hibernate validations, but either way, what you are doing is more involved that the 'normal' use case for hibernate validator.
