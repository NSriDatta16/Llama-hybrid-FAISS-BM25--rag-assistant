[site]: stackoverflow
[post_id]: 5502223
[parent_id]: 5463505
[tags]: 
Another compact (space-wise) solution that us assistants have suggested and doesn't use O(n^2) storage space is to have each node store only which node it came from. This can be done by changing the visited-list to an integer array ( int[] visited ). step 1: initialize visited list, so that every element is '-1' , or "unvisited" step 2: mark the first node as visited by itself visited[v] = v; Do a BFS (like you do, with the following modifications:) when moving from v -> v_next: if(visited[v_next] == -1) { visited[v_next] = v; q.put(v_next); } // else skip it, it's already been visited This way, if w is reachable, visited[w] will store which node it came from, from that node, you can backtrack all the way back to v and finally print them in the opposite order. (This is done either using a stack or a recursive print method.) Hope that makes sense. :)
