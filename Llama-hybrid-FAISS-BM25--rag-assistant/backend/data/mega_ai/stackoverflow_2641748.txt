[site]: stackoverflow
[post_id]: 2641748
[parent_id]: 2641725
[tags]: 
Linq to Sql data contexts are NOT thread safe, and should only be used within the context of a single thread. Using the singleton pattern is not only contrary to standard linq2sql practices, but will result in serious problems if your application comes under any sort of serious load. EDIT: In response to your limitations with regard to the using block, try implement your RolesFor method as an extension method: public static IQueryable GetUserRoles(this Database db, string username) { return from g in db.GetInstance().Groups join ug in db.GetInstance().UsersGroups on g.Id equals ug.GroupId where ug.UserId == user.Id select g; } This would allow you to call your method inside a using block from anywhere: using(Database db = createContext()) { IQueryable queryable = db.GetUserRoles("MyUsername"); // from here on you can query the queryable object var groups = (from g in queryable where g.Name == "MyRole" select g).ToList(); } EDIT 2 In reponse to your comment about opening another connection to the sql server for each instance of the data context. Creating a datacontext will not open a connection to the sql server, but each actual operation will. Regardless of whether you create 1 or 4 datacontexts, if you are performing 4 operations on the database, 4 sqlconnections will be opened. However, keep in mind that .NET uses a sql server connection pool, so each operation doesn't require the creation of an entirely new SqlConnection, but only the retrieval of an existing one from the connection pool and the reopening of the connection
