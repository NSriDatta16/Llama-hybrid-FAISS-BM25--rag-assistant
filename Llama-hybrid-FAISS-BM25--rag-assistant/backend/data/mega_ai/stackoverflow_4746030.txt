[site]: stackoverflow
[post_id]: 4746030
[parent_id]: 4744483
[tags]: 
Your class is performing two distinct tasks: Reading a file and parsing it as a Document Processing the Document to determine host, port, browser, url and fullurl Since this currently all occurs within the constructor and the file name is hardcoded, this class is pretty hard to unit test. If you can modify the class, then here are my suggestions to make this class testable: Don't hardcode the name of the file to be parsed. I would pass it as a constructor argument here because you don't need the fileName later on so no need to keep it as a private field. Separate the tasks, let the constructor read the file and create a separate method to process the document. Since you wanted the codez, here is the modified class: import java.io.File; import java.io.IOException; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import org.apache.log4j.Logger; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.SAXException; public class ABC { private static final Logger LOG = Logger.getLogger(ABC.class); private static final String DEFAULT_FILENAME = "Element.xml"; private String host; private String port; private String browser; private String url; private String fullurl; public class AbcFileAccessException extends Exception { private static final long serialVersionUID = 1L; public AbcFileAccessException(Exception e) { super(e); } } public ABC() throws AbcFileAccessException { this(DEFAULT_FILENAME); } public ABC(String fileName) throws AbcFileAccessException { File file = new File(fileName); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); try { DocumentBuilder db = dbf.newDocumentBuilder(); process(db.parse(file)); } catch (ParserConfigurationException e) { throw new AbcFileAccessException(e); } catch (SAXException e) { throw new AbcFileAccessException(e); } catch (IOException e) { throw new AbcFileAccessException(e); } } public ABC(Document document) { process(document); } public void process(Document document) { if (document == null) { throw new IllegalArgumentException("Document may not be null"); } document.getDocumentElement().normalize(); LOG.info("Root element " + document.getDocumentElement().getNodeName()); NodeList nodeLst = document.getElementsByTagName("selenium"); for (int s = 0; s Other improvements I made : Avoid static fields for runtime data like this. If they are private (as in your example) then they can just be instance field, seeing you are already creating a (non-singleton) instance of the class. If you intended them to be accessed by other classes it is even worse, because those other classes could access the fields like ABC.host which makes them hard to test and locked in to you implementation class. Let's not go into that now (-: NEVER call setters from a contructor (see http://www.javapractices.com/topic/TopicAction.do?Id=215 for an explanation). Scope try-catch blocks as narrowly as possible (or practical). This makes your code more readable because it is clear where the exceptions are being thrown. Catch each exception type separately. Bundeling them together makes the code less readable. I agree this is a pain for some parts of the API (try using reflection), but it is good practice. Assume a developer should be able to read and understand your code from a printout (so without hovering and code navigation features of your IDE). Don't handle exceptions by calling printStacktrace, logging an error or throwing a RuntimeException if you can avoid it. If you do, at least document these error conditions thoroughly. It is ok to create your own exception types for error conditions, this makes for a very understandable API (so other developers don't have to delve into your code, but can use the class after reading the JavaDoc). Don't use System.out.println for logging, use a logging framework like Log4j. This class can now be tested as follows: import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Result; import javax.xml.transform.Source; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.TransformerFactoryConfigurationError; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import junit.framework.Assert; import org.junit.Before; import org.junit.Test; import org.w3c.dom.Document; import org.w3c.dom.Element; import xcon.pilot.ABC.AbcFileAccessException; public class ABCTest { private Document document; @Before public void setUp() throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); document = builder.newDocument(); } @Test public void testProcess() throws ParserConfigurationException, AbcFileAccessException, TransformerFactoryConfigurationError, TransformerException { Element root = (Element) document.createElement("root"); document.appendChild(root); String host = "myhost"; String port = "myport"; String browser = "mybrowser"; String url = "myurl"; String fullurl = "myfullurl"; root.appendChild(createElement("host", host)); root.appendChild(createElement("port", port)); root.appendChild(createElement("browser", browser)); root.appendChild(createElement("url", url)); root.appendChild(createElement("fullurl", fullurl)); // for your convenience printXml(); ABC instance = new ABC(document); Assert.assertEquals(host, instance.getHost()); Assert.assertEquals(port, instance.getPort()); Assert.assertEquals(browser, instance.getBrowser()); Assert.assertEquals(url, instance.getUrl()); Assert.assertEquals(fullurl, instance.getFullurl()); } private Element createElement(String name, String value) { Element result = (Element) document.createElement("selenium"); Element nameElement = document.createElement("name"); nameElement.setTextContent(name); result.appendChild(nameElement); Element valueElement = document.createElement("value"); valueElement.setTextContent(value); result.appendChild(valueElement); return result; } private void printXml() throws TransformerConfigurationException, TransformerFactoryConfigurationError, TransformerException { Transformer transformer = TransformerFactory.newInstance() .newTransformer(); Source source = new DOMSource(document); Result output = new StreamResult(System.out); transformer.transform(source, output); } } This tests your Document processing logic. Testing the reading and parsing of files is notably tricky and can't really be seen as unit testing because you are always dependent on the operating system and its filesystem. I usually leave that as part of integration testing and build/deployment support. It helps to build good sanity checks and error handling in your code so missing/incorrect files are reported clearly and early. Hope this helped you.
