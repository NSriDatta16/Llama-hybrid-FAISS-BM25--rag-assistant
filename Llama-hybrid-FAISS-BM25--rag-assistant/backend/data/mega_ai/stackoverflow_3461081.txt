[site]: stackoverflow
[post_id]: 3461081
[parent_id]: 3460995
[tags]: 
Stack overflows aren't caused by infinite recursion but by more recursion (or, rather, call stack) than the process can handle. In your case, each recursive call to processSprite is going to do the same number of recursive calls to processSprite . So in the worst-case scenario of 1600 pixels without finding a boundary, your call tree would look like this: processSprite(0, j) processSprite(1, j) processSprite(2, j) ... processSprite(1599, j) You'll want to reorganize your algorithm into a linear loop that does a depth-first search, perhaps in a spiral pattern if you're wanting to to find a pixel that's closest to the starting point. I'm sure there are already other spiffy algorithms others have already developed to solve this problem. Edit: I think I understand better now the problem that you're trying to solve. It sounds like you have an image that may contain multiple image tiles surrounded by 0-alpha pixels and you want to find the bounding rectangles for each of these tiles. That looked like an interesting problem to solve, so I implemented it: IEnumerable FindImageTiles(Bitmap compositeImage) { var result = new List (); // Scan for a non-empty region that hasn't already been "captured" for (var x = 0; x r.Contains(x, y)) && compositeImage.GetPixel(x, y).A != 0) { // Now that we've found a point, create a rectangle // surrounding that point, then expand outward until // we have a bounding rectangle that doesn't intersect // with the tile var rect = new Rectangle(x - 1, y - 1, 2, 2); bool foundBounds = false; while (!foundBounds) { var xRange = Enumerable.Range(rect.Left, rect.Right) .Where(px => px >= 0 && px py >= 0 && py = 0 && xRange .Select(bx => compositeImage.GetPixel(bx, rect.Top)) .Any(p => p.A != 0)) { rect.Y--; rect.Height++; } else if (rect.Bottom compositeImage.GetPixel(bx, rect.Bottom)) .Any(p => p.A != 0)) { rect.Height++; } else if (rect.Left >= 0 && yRange .Select(by => compositeImage.GetPixel(rect.Left, by)) .Any(p => p.A != 0)) { rect.X--; rect.Width++; } else if (rect.Right compositeImage.GetPixel(rect.Right, by)) .Any(p => p.A != 0)) { rect.Width++; } else { foundBounds = true; } } result.Add(rect); } } } return result; }
