[site]: stackoverflow
[post_id]: 5183231
[parent_id]: 5182262
[tags]: 
You don't necessarily need to create new types of objects from scratch; you can always coerce to other classes, including ts as you need to. zoo or xts are arguably to most useful and intuitive but there are others. Here is your example, cast as a zoo object, which we then coerce to class ts for use in acf() . ## create the data x Now we can easily go to a ts object using the as.ts() method: > as.ts(df.zoo) Time Series: Start = 13920 End = 14040 Frequency = 0.0333333333333333 [1] 1 2 3 4 5 > ## zooreg object: > as.ts(df.zoo2) Time Series: Start = 13909 End = 14029 Frequency = 1 [1] 1 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [21] NA NA NA NA NA NA NA NA NA NA 2 NA NA NA NA NA NA NA NA NA [41] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [61] 3 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [81] NA NA NA NA NA NA NA NA NA NA 4 NA NA NA NA NA NA NA NA NA [101] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [121] 5 Notice the two ways in which the objects are represented (although we could have made the zooreg version the same as the standard zoo object by setting the frequency argument to 0.03333333 ): > as.ts(with(df, zooreg(test, order.by = datefield, + frequency = 0.033333333333333))) Time Series: Start = 13920.0000000001 End = 14040.0000000001 Frequency = 0.033333333333333 [1] 1 2 3 4 5 We can use the zoo/zooreg object in acf() and it will get the correct lags (daily observations but every 30 days): acf(df.zoo) Whether this is intuitive to you or not depends on how you view the time series. We can do the same thing in terms of a 30-day interval via: acf(coredata(df.zoo)) where we use coredata() to extract the time series itself, ignoring the date information.
