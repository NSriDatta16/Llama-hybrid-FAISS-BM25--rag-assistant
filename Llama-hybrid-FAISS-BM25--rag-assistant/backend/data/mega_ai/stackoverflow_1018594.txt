[site]: stackoverflow
[post_id]: 1018594
[parent_id]: 1017692
[tags]: 
Changing the type of the callback function in your application won't magically change the type that the DLL expects to receive. The DLL expects to receive an ordinary function pointer, so that's what you need to provide. The declarations in your own code need to match the declarations that appeared in the DLL's code when it was compiled, but there is nothing to enforce that. The compiler can't deduce the DLL's declarations and print an error when your Delphi code doesn't match. A method pointer (which is what you get when you add of object to a declaration) isn't the same as an ordinary function pointer. It's really a closure consisting of the pointer to a method and a reference to the object whose method it is. Delphi knows how to call method pointers by taking the referenced object and calling the pointed-to method on that object. Your DLL doesn't know how to call method pointers, unless it was written in Delphi or C++ Builder. But even if it did know how, you'd be stuck since the DLL doesn't know you're giving it a method pointer. It assumes you're giving it an ordinary function pointer since that's how the DLL's code was written. You can't give the DLL a method of your class. There are some techniques that allow you to solve the problem indirectly, though: If the DLL's callback definition allows it, you can pass an extra parameter to the DLL that the DLL will then pass back. You can use it to hold a reference to your object, and then in your callback function you can use the object. It doesn't look like this particular DLL supports that, though. You can put a reference to your object in a global variable that you can then refer to in your standalone callback function. This isn't very elegant, and the technique falls apart if you can ever have multiple calls to the DLL at the same time (either through multiple threads or through recursion). You can allocate your own memory for a function and then put the object reference into code you generate on the fly for that one method. In effect, each instance of your class that could call into the DLL will have its own private callback function. The technique is a little more involved than I'm prepared to explain right here. There are some concerns about your program looking suspicious to virus scanners or to computers that have the no-execute flag set on certain memory, but every VCL program actually already uses the technique to associate forms and controls with their underlying Win32 windows.
