[site]: stackoverflow
[post_id]: 866362
[parent_id]: 
[tags]: 
Lua, C++, and poor man's subclassing

I'm lead dev for Bitfighter , and we're working with a mix of Lua and C++, using Lunar (a variant of Luna, available here ) to bind them together. I know this environment does not have good support for object orientation and inheritance, but I'd like to find some way to at least partially work around these limitations. Here's what I have: C++ Class Structure GameItem |---- Rock |---- Stone |---- RockyStone Robot Robot implements a method called getFiringSolution(GameItem item) that looks at the position and speed of item , and returns the angle at which the robot would need to fire to hit item . -- This is in Lua angle = robot:getFiringSolution(rock) if(angle != nil) then robot:fire(angle) end So my problem is that I want to pass rocks , stones , or rockyStones to the getFiringSolution method, and I'm not sure how to do it. This works for Rocks only: // C++ code S32 Robot::getFiringSolution(lua_State *L) { Rock *target = Lunar ::check(L, 1); return returnFloat(L, getFireAngle(target)); // returnFloat() is my func } Ideally, what I want to do is something like this: // This is C++, doesn't work S32 Robot::getFiringSolution(lua_State *L) { GameItem *target = Lunar ::check(L, 1); return returnFloat(L, getFireAngle(target)); } This potential solution does not work because Lunar's check function wants the object on the stack to have a className that matches that defined for GameItem. (For each object type you register with Lunar, you provide a name in the form of a string which Lunar uses to ensure that objects are of the correct type.) I would settle for something like this, where I have to check every possible subclass: // Also C++, also doesn't work S32 Robot::getFiringSolution(lua_State *L) { GameItem *target = Lunar ::check(L, 1); if(!target) target = Lunar ::check(L, 1); if(!target) target = Lunar ::check(L, 1); return returnFloat(L, getFireAngle(target)); } The problem with this solution is that the check function generates an error if the item on the stack is not of the correct type, and, I believe, removes the object of interest from the stack so I only have one attempt to grab it. I'm thinking I need to get a pointer to the Rock/Stone/RockyStone object from the stack, figure out what type it is, then cast it to the correct thing before working with it. The key bit of Lunar which does the type checking is this: // from Lunar.h // get userdata from Lua stack and return pointer to T object static T *check(lua_State *L, int narg) { userdataType *ud = static_cast (luaL_checkudata(L, narg, T::className)); if(!ud) luaL_typerror(L, narg, T::className); return ud->pT; // pointer to T object } If I call it thusly: GameItem *target = Lunar ::check(L, 1); then the luaL_checkudata() checks to see if the item on the stack is a Rock. If so, everything is peachy, and it returns a pointer to my Rock object, which gets passed back to the getFiringSolution() method. If there is a non-Rock item on the stack, the cast returns null, and luaL_typerror() gets called, which sends the app off into lala land (where the error handling prints a diagnostic and terminates the robot with extreme prejudice). Any ideas on how to move forward with this? Many thanks!! Best solution I've come up with... ugly, but works Based on the suggestions below, I came up with this: template T *checkItem(lua_State *L) { luaL_getmetatable(L, T::className); if(lua_rawequal(L, -1, -2)) // Lua object on stack is of class { lua_pop(L, 2); // Remove both metatables return Lunar ::check(L, 1); // Return our object } else // Object on stack is something else { lua_pop(L, 1); // Remove 's metatable, leave the other in place // for further comparison return NULL; } } Then, later... S32 Robot::getFiringSolution(lua_State *L) { GameItem *target; lua_getmetatable(L, 1); // Get metatable for first item on the stack target = checkItem (L); if(!target) target = checkItem (L); if(!target) target = checkItem (L); if(!target) // Ultimately failed to figure out what this object is. { lua_pop(L, 1); // Clean up luaL_typerror(L, 1, "GameItem"); // Raise an error return returnNil(L); // Return nil, but I don't think this // statement will ever get run } return returnFloat(L, getFireAngle(target)); } There are probably further optimizations I can do with this... I'd really like to figure out how to collapse this into a loop because, in reality, I will have a lot more than three classes to deal with, and this process is a bit cumbersome. Slight improvement on the above solution C++: GameItem *LuaObject::getItem(lua_State *L, S32 index, U32 type) { switch(type) { case RockType: return Lunar ::check(L, index); case StoneType: return Lunar ::check(L, index); case RockyStoneType: return Lunar ::check(L, index); default: displayError(); } } Then, later... S32 Robot::getFiringSolution(lua_State *L) { S32 type = getInteger(L, 1); // My fn to pop int from stack GameItem *target = getItem(L, 2, type); return returnFloat(L, getFireAngle(target)); // My fn to push float to stack } Lua helper function, included as a separate file to avoid user needing to add this manually to their code: function getFiringSolution( item ) type = item:getClassID() -- Returns an integer id unique to each class if( type == nil ) then return nil end return bot:getFiringSolution( type, item ) end User calls this way from Lua: angle = getFiringSolution( item )
