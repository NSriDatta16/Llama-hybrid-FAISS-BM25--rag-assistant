[site]: stackoverflow
[post_id]: 5711321
[parent_id]: 5709931
[tags]: 
When you say "read and store the file to each struct", could you clarify that question? To ensure the right padding and endian-ness, you have to do two things: Send the struct one field at a time. It is a pain. Since you are declaring each struct member as a uint16_t type (and from that family), sizeof() will give you the same answer across all platforms. TO ensure endianness, you have to use the host-to-network-order family. See: http://www.gnu.org/s/hello/manual/libc/Byte-Order.html When you do this, you have to use htons() (host to network short) when sending and then ntohs() (network to host short) when receiving. For each member of your struct. Often people ignore this; if both machines are modern Intel boxes, which is true for the vast majority of us, you can get away with the code you have for sending structs. But like you have mentioned, that doesn't gaurantee padding and endinaness! You could also use the #pragma pack() GNU directives for specifying how padding should be handled. This works if you can rely on the GNU toolchain for both your client and server, as that is not part of the C specification.
