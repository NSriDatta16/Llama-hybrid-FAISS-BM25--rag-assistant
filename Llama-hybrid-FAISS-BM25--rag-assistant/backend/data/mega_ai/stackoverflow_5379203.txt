[site]: stackoverflow
[post_id]: 5379203
[parent_id]: 5376817
[tags]: 
This isn't really an answer but the comments bit is too short to post this. Your inline assembly is problematic, in multiple ways: it assumes by the time the compiler gets to the inline block, the function arguments are still in the arg registers. This isn't guaranteed. it uses MS-VC++ style inline assembly; I'm unsure about OSX Clang, but gcc proper refuses to even compile this. It'd also be good to have a complete (compilable) source fragment. Something like (32bit code): int mogrifyFramebufferContents(unsigned char *fb, int width, int height) { int i, sum; glReadPixels(1, 1, width, height, GL_RGBA, GL_UNSIGNED_BYTE, fb); for (i = 0, sum = 0; i If I haven't made a one-off error, this code should result in the same output for C and assembly. Try something similar, right at the place where you access the read data within C, and compare assembly results - or even singlestep through the generated assembly with a debugger. A stackoverflow search for "gcc inline assembly syntax" will give you a starting point for what the %0 ... %2 placeholders mean, and/or how the register assignment constraints like "=r"(sum) above work.
