[site]: stackoverflow
[post_id]: 386526
[parent_id]: 386464
[tags]: 
You need to ask yourself (and tell us) what kind of pattern of use you expect. Do these relations get added in order or randomly, do yours queries come in order (as you show them) or randomly, and is this essentially a batch process -- load them up, read off the queries -- or do you expect to do it "on line" in the sense that you may add some, then query some, then add some more and query some more? Will you know how many you want to store beforehand, and how many do you expect to store? Dozens? Thousands? Tens of millions? Here are some suggestions: if you know beforehand how many you expect to store, it's not a really big number, you don't expect to add them after first loading up, there aren't any duplicates in the left-hand side of the pair, and they're reasonably "dense" in the sense that there aren't big gaps between numbers in the left-hand one of the pair, then you probably want an array. Insertion is O(1) , access is O(1) , but can't have duplicate indices and expanding it after you build it is a pain. if the number is really large, like > 10 8 , you probably want some kind of database. Databases are relatively very slow -- 4 to 5 orders of magnitude greater than in-memory data structures -- but handle really big data. If you have insertions after the first load, and you care about order, you're going to want some sort of tree, like a 2-3 tree. Insertion and access both O(lg n) . You'd probably find an implmentation under a name like "ordered list" (I'm not a C# guy.) Most any other case, you probably want a hash. Average insertion and access both O(1) , like an array; worst case [which you won't hit with this data] is O(n)
