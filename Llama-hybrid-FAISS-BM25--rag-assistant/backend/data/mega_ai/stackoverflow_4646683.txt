[site]: stackoverflow
[post_id]: 4646683
[parent_id]: 4646580
[tags]: 
A simple array copy is O(n) in this case, which should be good enough for almost all real-world purposes. However, I will grant you that in certain cases - if this is a part deep inside a multi-level algorithm - this may be relevant. Also, do you simply need to iterate through this collection in an ordered fashion or create a copy? Linked lists are very easy to reorganize like this, although accessing random elements will be more costly. Overall, the computational efficiency will also depend on how exactly you access this collection of items (and also, what sort of items they are - value types or reference types?). The standard .NET linked list does not seem to support such manual manipulation but in general, if you have a linked list, you can easily move around sections of the list in the way you describe, just by assigning new "next" and "previous" pointers to the endpoints. The collection library available here supports this functionality: http://www.itu.dk/research/c5/ . Specifically, you are looking for LinkedList .Slide() the method which you can use on the object returned by LinkedList .View() .
