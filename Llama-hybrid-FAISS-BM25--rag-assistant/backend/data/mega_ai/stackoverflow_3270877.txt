[site]: stackoverflow
[post_id]: 3270877
[parent_id]: 3270822
[tags]: 
Technically, this isn't valid C. (It is valid C++, though.) char *array[10]={}; You should use char *array[10] = {0}; This declares an array of 10 pointers to char and initializes them all to null pointers. char* token; token = "testing"; This declares token as a pointer to char and points it at a string literal which is non-modifiable. array[0] = "again"; This points the first char pointer of array at a string literal which (again) is a non-modifiable sequence of char. strcat(array[0], token); strcat concatenates one string onto the end of another string. For it to work the first string must be contained in writeable storage and have enough excess storage to contain the second string at and beyond the first terminating null character ('\0') in the first string. Neither of these hold for array[0] which is pointing directly at the string literal. What you need to do is something like this. (You need to #include and .) I've gone for runtime calculation of sizes and dynamic allocation of memory as I'm assuming that you are doing a test for where the strings may not be of known size in the future. With the strings known at compile time you can avoid some (or most) of the work at compile time; but then you may as well do "againtesting" as a single string literal. char* token = "testing"; char* other_token = "again"; /* Include extra space for string terminator */ size_t required_length = strlen(token) + strlen(other_token) + 1; /* Dynamically allocated a big enough buffer */ array[0] = malloc( required_length ); strcpy( array[0], other_token ); strcat( array[0], token ); /* More code... */ /* Free allocated buffer */ free( array[0] );
