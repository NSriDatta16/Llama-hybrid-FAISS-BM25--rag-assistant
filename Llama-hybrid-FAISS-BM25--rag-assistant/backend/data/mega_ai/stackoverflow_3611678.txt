[site]: stackoverflow
[post_id]: 3611678
[parent_id]: 3583735
[tags]: 
Lighting is a very complex topic in computer graphics. What really matter is, of course, the object illumination, emulating the real world lighting or the effect we are targeting. The lighting environment could be composed by many sources in order to approximate the real effect we are trying to achieve. OpenGL lighting implementation are dynamic lights, which are light point abstraction which allow to "light" (that is, give a color) to rendered vertices (which are used for render triangles). ...the vertex is illuminated, get color contribution for each light. As you mentioned, the rendering process take more time more lights we has enabled. To minimize this, you have different possibilities. Light culling (exclude lights which contribution is to little to change the color), and this is determined using light properties (distance, cone, attenuation, point of view and obstructing objects). Static lighting, which uses textures to emulate lighting on objects which never moves. OpenGL fixed lighting contributes to vertex color, which is interpolated with other vertex colors in order to rasterize the triangle. In the case the geometry is composed by few triangles, you cannot see any light cone inside the each triangle, because its fragment's color are the result of the interpolation of three colors (the three vertices). To achieve a more precise lighting, the software shall determine each fragment (pixel) color (pixel lighting) in the same way a vertex is colored by lights, but as you can understand, there could be more pixels than vertices. An approach is to compute (using shaders or an OpenGL extension) the light's contribution for each pixel of the geometry during the rasterization phase, or determine the pixel color using deferred lighting. Deferred lighting uses multiple textures (corresponding to the viewport) to store lights parameters for each displayed pixel. In this way you execute light computation after the image is produced, determining pixel light contribution once for each pixel, instead of once for each geometry pixel.
