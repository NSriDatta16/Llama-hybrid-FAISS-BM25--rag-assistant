[site]: stackoverflow
[post_id]: 2344668
[parent_id]: 2344590
[tags]: 
There are similar questions here , here answered in stackoverflow. You need to use the operator PIVOT in your query to acheive this.Here is the example and explanation on how you can do that.The example is referenced from this source. ---I assumed your tablename as TESTTABLE--- DECLARE @cols NVARCHAR(2000) DECLARE @query NVARCHAR(4000) SELECT @cols = STUFF(( SELECT DISTINCT TOP 100 PERCENT '],[' + t.Name FROM TESTTABLE AS t ORDER BY '],[' + t.Name FOR XML PATH('') ), 1, 2, '') + ']' SET @query = N'SELECT '+ @cols +' FROM (SELECT t1.Name , t1.Count FROM TESTTABLE AS t1) p PIVOT (MAX([Count]) FOR Name IN ( '+ @cols +' )) AS pvt;' EXECUTE(@query) Explanation 1.The first part of the query SELECT @cols = STUFF(( SELECT DISTINCT TOP 100 PERCENT '],[' + t.Name FROM TESTTABLE AS t ORDER BY '],[' + t.Name FOR XML PATH('') ), 1, 2, '') + ']' gives you a nice flattened result of your Name column values in a single row as follow [Cheryl],[Drew],[Karen],[Kath],[Kirk],[Matt] You can learn more about the STUFF and XML PATH here and here . 2. SELECT + @cols + FROM will select all the rows as coloumn names for the final result set (pvt - step 3) i.e Select [Chery],[Drew],[Morgan],[Kath],[Kirk],[Matt] 3.This query pulls all the rows of data that we need to create the cross-tab results. The (p) after the query is creating a temporary table of the results that can then be used to satisfy the query for step 1. (SELECT t1.Name, t1.Count FROM TESTTABLE AS t1) p 4.The PIVOT expression PIVOT (MAX (Count) FOR Name IN ( @cols) AS pvt does the actual summarization and puts the results into a temporary table called pvt as Chery | Drew | Morgon | Kath | Kirk | Matt ------------------------------------------- 257 1500 13 500 200 76
