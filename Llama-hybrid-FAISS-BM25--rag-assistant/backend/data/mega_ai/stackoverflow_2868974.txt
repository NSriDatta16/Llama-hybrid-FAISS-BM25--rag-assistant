[site]: stackoverflow
[post_id]: 2868974
[parent_id]: 2868893
[tags]: 
I think you will find the answer here usefull There are a number of compilcated ways to achieve this, but the solution I posed that the above link is easy and only has one quirk, that to be honest can be worked around. When dragging the input window it does not provide feedback until the move is completed, but you can work around this by handling some non-client messages, I can spend sometime look at the work around if you need, but first confirm this solution is right for you. Update : A sample of how a the approach above can be applied to a WPF form. using System; using System.Windows; using System.Windows.Controls; using System.Windows.Input; using System.Windows.Interop; using System.Runtime.InteropServices; namespace WpfApplication1 { /// /// Interaction logic for Window1.xaml /// public partial class Window1 : Window { public Window1() { InitializeComponent(); } const int WS_EX_NOACTIVATE = 0x08000000; const int GWL_EXSTYLE = -20; [DllImport("user32", SetLastError = true)] private extern static int GetWindowLong(IntPtr hwnd, int nIndex); [DllImport("user32", SetLastError = true)] private extern static int SetWindowLong(IntPtr hwnd, int nIndex, int dwNewValue); private void Window_Loaded(object sender, RoutedEventArgs e) { WindowInteropHelper wih = new WindowInteropHelper(this); int exstyle = GetWindowLong(wih.Handle, GWL_EXSTYLE); exstyle |= WS_EX_NOACTIVATE; SetWindowLong(wih.Handle, GWL_EXSTYLE, exstyle); } } }
