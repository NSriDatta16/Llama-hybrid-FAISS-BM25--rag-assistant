[site]: crossvalidated
[post_id]: 579371
[parent_id]: 
[tags]: 
Reverse engineering device RGB data

I'm working with a device that maps certain RGB colors to a 7 bit value (0-127): I want to reverse the process, i.e. given any RGB triplet, what is the (closest) corresponding color index (0-127) ? And I want to do so using the minimum number of parameters. E.g.: assuming there is some kind of rule behind how these colors are mapped to the 0-127 index, cracking this rule results in a model with zero parameters and 100% accuracy, i.e. the best one. But perhaps these colors have been thrown out more or less randomly, then the question is how to reconstruct the inverse mapping with these two characteristics: it covers most of the color indices (0-127) above (see below) it has high accuracy To be precise: there should be an upper bound on the error made by the reconstructed mapping, so that at least N distinct colors are output for all input RGB values. For instance: approximating all the colors with a single average color is a bad solution, as it fails both points. Here the same RGB values in CSV format: 0,0,0 37,37,37 143,143,143 253,253,253 255,101,92 255,40,18 110,10,3 34,1,0 255,199,124 255,108,29 110,40,6 48,31,2 255,248,77 255,248,63 108,105,21 32,31,2 148,247,81 83,246,60 30,104,20 25,51,6 69,247,81 9,246,59 2,104,19 0,30,2 67,247,104 9,246,59 2,104,19 0,30,2 64,248,151 4,247,93 1,104,34 0,36,19 57,248,193 0,247,167 0,105,67 0,31,19 63,204,252 0,184,252 0,82,99 0,20,31 73,158,251 0,112,250 0,41,107 0,7,32 79,105,250 0,60,249 0,20,108 0,2,32 146,106,250 91,61,249 23,24,119 8,8,64 255,112,250 255,71,250 109,25,107 33,3,32 255,105,149 255,44,101 110,13,36 44,2,19 255,51,19 173,71,16 142,99,21 80,116,23 1,70,10 0,101,67 0,103,143 0,60,249 0,85,95 10,50,214 143,143,143 43,43,43 255,40,18 200,247,62 186,235,58 107,247,60 3,149,32 0,247,148 0,184,252 0,70,249 56,61,249 134,63,249 194,52,142 83,43,5 255,97,26 151,225,55 122,247,60 9,246,59 9,246,59 87,247,127 0,249,213 92,158,251 40,104,207 145,147,237 218,70,250 255,45,108 255,144,37 199,187,45 158,247,61 150,111,24 74,52,6 16,92,19 0,97,72 23,26,53 13,47,107 126,77,35 188,25,10 233,103,73 229,125,31 255,227,58 171,225,55 116,189,44 35,38,63 229,249,117 136,249,199 164,173,252 154,128,250 81,81,81 135,135,135 228,252,253 181,24,9 69,3,1 6,211,50 1,79,12 199,187,45 79,62,9 195,112,26 93,28,3 Plotting the above values in various ways doesn't suggest anything obvious. If bits are packed, maybe a Karnaugh map would help, however I am a bit rusty on how to apply the concept to this problem. Other ways to solve the problem, e.g. by machine learning or dimensionality reduction?
