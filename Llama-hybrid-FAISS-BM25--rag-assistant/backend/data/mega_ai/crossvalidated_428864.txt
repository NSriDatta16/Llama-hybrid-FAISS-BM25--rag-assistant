[site]: crossvalidated
[post_id]: 428864
[parent_id]: 4909
[tags]: 
I can't answer this question in full generality, but I think I can state one circumstance where it certainly is not useful: The Anderson-Darling test: \begin{align*} A^2/n &:= \int_{-\infty}^{\infty} \frac{(F_{n}(x) -F(x))^2}{F(x)(1-F(x))} \, \mathrm{d}F(x) \\ &= \int_{-\infty}^{x_0} \frac{F(x)}{1-F(x)} \, \mathrm{d}F(x) + \int_{x_{n-1}}^{\infty} \frac{1-F(x)}{F(x)} \, \mathrm{d}F(x) + \sum_{i=0}^{n-2} \int_{x_i}^{x_{i+1}} \frac{(F_n(x) - F(x))^2}{F(x)(1-F(x))} \mathrm{d}F(x) \end{align*} Here, $F$ is the cumulative distribution function of the normal distribution, namely, $$ F(x) := \frac{1}{2}\left[1 + \mathrm{erf}\left(\frac{x}{\sqrt{2}}\right) \right] $$ and $F_n$ is the empirical cumulative distribution function $$ F_n(x) := \frac{1}{n} \sum_{i=0}^{n-1} \mathbb{1}_{x_i \le x} $$ (We will abuse notation a bit and let $F_{n}$ denote the linearly interpolated version of $F_n$ as well.) I repeatedly generated $n$ $~N(0,1)$ random numbers, sorted them, and then considered $F_n$ first as a step function, and then as a sequence of linear interpolants. Each interior integral was computed via Gaussian quadrature of ridiculously high degree, and the tails via exp-sinh. Did the empirical distribution fit the cumulative distribution better with linear interpolation than step interpolation? No, in fact they are indistinguishable as $n\to \infty$ and one is not uniformly better than the other for small $n$ : Code to reproduce: #include #include #include #include #include template std::pair step_vs_linear(size_t n) { std::random_device rd; Real mu = 0; Real sd = 1; std::normal_distribution dis(mu, sd); std::vector v(n); for (size_t i = 0; i (step, line); } int main(int argc, char** argv) { using std::log; using std::pow; using std::floor; size_t samples = 10000; std::vector > linear_Asq(samples); std::vector > step_Asq(samples); std::default_random_engine generator; std::uniform_real_distribution distribution(3, 18); #pragma omp parallel for for(size_t sample = 0; sample (n); step_Asq[sample] = std::make_pair (std::log2(double(n)), std::log(step/n)); linear_Asq[sample] = std::make_pair (std::log2(double(n)), std::log(line/n)); if (sample % 10 == 0) { std::cout (title, filename, x_label, y_label); scat.add_dataset(linear_Asq, false, "steelblue"); scat.add_dataset(step_Asq, false, "orange"); scat.write_all(); } Anderson-Darling tests: #ifndef BOOST_MATH_DISTRIBUTIONS_ANDERSON_DARLING_HPP #define BOOST_MATH_DISTRIBUTIONS_ANDERSON_DARLING_HPP #include #include #include #include #include namespace boost { namespace math { template auto anderson_darling_normality_step(RandomAccessContainer const & v, typename RandomAccessContainer::value_type mu = 0, typename RandomAccessContainer::value_type sd = 1) { using Real = typename RandomAccessContainer::value_type; using std::log; using std::pow; if (!std::is_sorted(v.begin(), v.end())) { throw std::domain_error("The input vector must be sorted in non-decreasing order v[0] Real { Real Fx = boost::math::cdf(normal, x); Real dmu = boost::math::pdf(normal, x); return Fx*dmu/(1-Fx); }; auto es = boost::math::quadrature::exp_sinh (); Real left_tail = es.integrate(left_integrand, -std::numeric_limits ::infinity(), v[0]); auto right_integrand = [&normal](Real x)->Real { Real Fx = boost::math::cdf(normal, x); Real dmu = boost::math::pdf(normal, x); return (1-Fx)*dmu/Fx; }; Real right_tail = es.integrate(right_integrand, v[v.size()-1], std::numeric_limits ::infinity()); auto integrator = boost::math::quadrature::gauss (); Real integrals = 0; int64_t N = v.size(); for (int64_t i = 0; i Real { Real Fx = boost::math::cdf(normal, x); Real Fn = (i+1)/Real(N); Real dmu = boost::math::pdf(normal, x); return (Fn - Fx)*(Fn-Fx)*dmu/(Fx*(1-Fx)); }; auto term = integrator.integrate(integrand, v[i], v[i+1]); integrals += term; } return v.size()*(left_tail + right_tail + integrals); } template auto anderson_darling_normality_linear(RandomAccessContainer const & v, typename RandomAccessContainer::value_type mu = 0, typename RandomAccessContainer::value_type sd = 1) { using Real = typename RandomAccessContainer::value_type; using std::log; using std::pow; if (!std::is_sorted(v.begin(), v.end())) { throw std::domain_error("The input vector must be sorted in non-decreasing order v[0] Real { Real Fx = boost::math::cdf(normal, x); Real dmu = boost::math::pdf(normal, x); return Fx*dmu/(1-Fx); }; auto es = boost::math::quadrature::exp_sinh (); Real left_tail = es.integrate(left_integrand, -std::numeric_limits ::infinity(), v[0]); auto right_integrand = [&normal](Real x)->Real { Real Fx = boost::math::cdf(normal, x); Real dmu = boost::math::pdf(normal, x); return (1-Fx)*dmu/Fx; }; Real right_tail = es.integrate(right_integrand, v[v.size()-1], std::numeric_limits ::infinity()); auto integrator = boost::math::quadrature::gauss (); Real integrals = 0; int64_t N = v.size(); for (int64_t i = 0; i Real { Real Fx = boost::math::cdf(normal, x); Real dmu = boost::math::pdf(normal, x); Real y0 = (i+1)/Real(N); Real y1 = (i+2)/Real(N); Real Fn = y0 + (y1-y0)*(x-v[i])/(v[i+1]-v[i]); return (Fn - Fx)*(Fn-Fx)*dmu/(Fx*(1-Fx)); }; auto term = integrator.integrate(integrand, v[i], v[i+1]); integrals += term; } return v.size()*(left_tail + right_tail + integrals); } }} #endif
