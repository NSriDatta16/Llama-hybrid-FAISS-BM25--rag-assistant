[site]: stackoverflow
[post_id]: 1778946
[parent_id]: 1599945
[tags]: 
I ended up using a more complex way to do upgrades, by reading the raw XML from the user settings file, then run a series of upgrade routines that refactor the data to the way it's supposed to be in the new next version. Also, due to a bug I found in ClickOnce's ApplicationDeployment.CurrentDeployment.IsFirstRun property (you can see the Microsoft Connect feedback here ), I had to use my own IsFirstRun setting to know when to perform the upgrade. The whole system works very well for me (but it was made with blood and sweat due to a few very stubborn snags). Ignore comments mark what is specific to my application and is not part of the upgrade system. using System; using System.Collections.Specialized; using System.Configuration; using System.Xml; using System.IO; using System.Linq; using System.Windows.Forms; using System.Reflection; using System.Text; using MyApp.Forms; using MyApp.Entities; namespace MyApp.Properties { public sealed partial class Settings { private static readonly Version CurrentVersion = Assembly.GetExecutingAssembly().GetName().Version; private Settings() { InitCollections(); // ignore } public override void Upgrade() { UpgradeFromPreviousVersion(); BadDataFiles = new StringCollection(); // ignore UpgradePerformed = true; // this is a boolean value in the settings file that is initialized to false to indicate that settings file is brand new and requires upgrading InitCollections(); // ignore Save(); } // ignore private void InitCollections() { if (BadDataFiles == null) BadDataFiles = new StringCollection(); if (UploadedGames == null) UploadedGames = new StringDictionary(); if (SavedSearches == null) SavedSearches = SavedSearchesCollection.Default; } private void UpgradeFromPreviousVersion() { try { // This works for both ClickOnce and non-ClickOnce applications, whereas // ApplicationDeployment.CurrentDeployment.DataDirectory only works for ClickOnce applications DirectoryInfo currentSettingsDir = new FileInfo(ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal).FilePath).Directory; if (currentSettingsDir == null) throw new Exception("Failed to determine the location of the settings file."); if (!currentSettingsDir.Exists) currentSettingsDir.Create(); // LINQ to Objects for .NET 2.0 courtesy of LINQBridge (linqbridge.googlecode.com) var previousSettings = (from dir in currentSettingsDir.Parent.GetDirectories() let dirVer = new { Dir = dir, Ver = new Version(dir.Name) } where dirVer.Ver = oldSettingsVersion && methodVer.Version ", "FieldName>"); xml = xml.Replace("Type>", "Comparison>"); savedSearch.InnerXml = xml; if (savedSearch["Name"].GetTextValue() == "Tournament") savedSearch.AppendNewElement("ShowTournamentColumn", "true"); else savedSearch.AppendNewElement("ShowTournamentColumn", "false"); } } } } } The following custom extention methods and helper classes were used: using System; using System.Windows.Forms; using System.Collections.Generic; using System.Xml; namespace MyApp { public static class ExtensionMethods { public static XmlNode AppendNewElement(this XmlNode element, string name) { return AppendNewElement(element, name, null); } public static XmlNode AppendNewElement(this XmlNode element, string name, string value) { return AppendNewElement(element, name, value, null); } public static XmlNode AppendNewElement(this XmlNode element, string name, string value, params KeyValuePair [] attributes) { XmlDocument doc = element.OwnerDocument ?? (XmlDocument)element; XmlElement addedElement = doc.CreateElement(name); if (value != null) addedElement.SetTextValue(value); if (attributes != null) foreach (var attribute in attributes) addedElement.AppendNewAttribute(attribute.Key, attribute.Value); element.AppendChild(addedElement); return addedElement; } public static XmlNode AppendNewAttribute(this XmlNode element, string name, string value) { XmlAttribute attr = element.OwnerDocument.CreateAttribute(name); attr.Value = value; element.Attributes.Append(attr); return element; } } } namespace MyApp.Forms { public static class MessageBoxes { private static readonly string Caption = "MyApp v" + Application.ProductVersion; public static void Alert(MessageBoxIcon icon, params object[] args) { MessageBox.Show(GetMessage(args), Caption, MessageBoxButtons.OK, icon); } public static bool YesNo(MessageBoxIcon icon, params object[] args) { return MessageBox.Show(GetMessage(args), Caption, MessageBoxButtons.YesNo, icon) == DialogResult.Yes; } private static string GetMessage(object[] args) { if (args.Length == 1) { return args[0].ToString(); } else { var messegeArgs = new object[args.Length - 1]; Array.Copy(args, 1, messegeArgs, 0, messegeArgs.Length); return string.Format(args[0] as string, messegeArgs); } } } } The following Main method was used to allow the system to work: [STAThread] static void Main() { // Ensures that the user setting's configuration system starts in an encrypted mode, otherwise an application restart is required to change modes. Configuration config = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal); SectionInformation sectionInfo = config.SectionGroups["userSettings"].Sections["MyApp.Properties.Settings"].SectionInformation; if (!sectionInfo.IsProtected) { sectionInfo.ProtectSection(null); config.Save(); } if (Settings.Default.UpgradePerformed == false) Settings.Default.Upgrade(); Application.Run(new frmMain()); } I welcome any input, critique, suggestions or improvements. I hope this helps someone somewhere.
