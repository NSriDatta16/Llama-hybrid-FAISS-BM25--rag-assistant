[site]: stackoverflow
[post_id]: 4784957
[parent_id]: 
[tags]: 
Translating native API into C#, Marshalling structs arrays and delegates

I've worked on a C# version of a C++ API but I can't manage to get it right. Since the whole API was too big the first time I posted, I've cut it down to some core functions for which I really need some help to make a managed version of. So basically, this is a C++ dll containing exported functions that are used to communicate with a technical analysis software. C++ function I'd like to convert #define PLUGINAPI extern "C" __declspec(dllexport) PLUGINAPI int GetFunctionTable( FunctionTag **ppFunctionTable ) { *ppFunctionTable = gFunctionTable; // must return the number of functions in the table return gFunctionTableSize; } GetFunctionTable is called by the software which provides a pointer to an array of FunctionTag called gFunctionTable: typedef struct FunctionTag { char *Name; FunDesc Descript; } FunctionTag; FunctionTag gFunctionTable[] = {"ExampleA",{ VExampleA, 0, 0, 0, 0, NULL }, "ExampleB",{ VExampleB, 1, 0, 1, 0, NULL } }; FunctionTag structure contains an embedded structure called Fundesc: // FunDesc structure holds the pointer to actual // user-defined function that can be called by AmiBroker. typedef struct FunDesc { AmiVar (*Function)( int NumArgs, AmiVar *ArgsTable ); UBYTE ArrayQty; // number of Array arguments required UBYTE StringQty; // number of String arguments required SBYTE FloatQty; // number of float args UBYTE DefaultQty; // number of default float args float *DefaultValues; // the pointer to defaults table } FunDesc; Finally, Fundesc contains AmiVar type: #pragma pack( push, 2 ) typedef struct AmiVar { int type; union { float val; float *array; char *string; void *disp; }; } AmiVar; #pragma pack(pop) C# conversion so far Now, this is what I've written so far in an attempt to get my C# dll to "mimic" the C++ original API. The GetFunctionTable() exported function: namespace AmiBrokerFrontDll { internal static class AmiBrokerFrontDll { [DllExport("GetFunctionTable", CallingConvention = CallingConvention.Cdecl)] public static Int32 GetFunctionTable(ref FunctionTag[] ppFunctionTable) { FillFunction(); ppFunctionTable=gFunctionTable; return gFunctionTableSize; } Then comes the definition of FunctionTag structure and gFunctionTableSize: [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)] public struct FunctionTag { [MarshalAs(UnmanagedType.LPStr)] public string Name; public FunDesc Description; } public static FunctionTag[] gFunctionTable=new FunctionTag[1]; public static FunctionTag gfunc; static Int32 gFunctionTableSize = Marshal.SizeOf(gFunctionTable) / Marshal.SizeOf(gfunc); public static void FillFunction() { gFunctionTable[0].Name = "VExempleA"; gFunctionTable[0].Description.Function += VExempleDeMacd; //ArrayQty, StringQty, FloatQty, DefaultQty, DefaultTablePtr gFunctionTable[0].Description.ArrayQty = 0; gFunctionTable[0].Description.StringQty = 0; gFunctionTable[0].Description.FloatQty = 2; gFunctionTable[0].Description.DefaultQty = 0; gFunctionTable[0].Description.DefaultValues = new IntPtr(); } FunDesc declaration includes a delegate: [UnmanagedFunctionPointer(CallingConvention.Cdecl)] public delegate AmiVar FunctionDelegate(int NumArgs, ref AmiVar ArgsTable); public struct FunDesc { [MarshalAs(UnmanagedType.FunctionPtr)] public FunctionDelegate Function; public byte ArrayQty; // The number of Array arguments required public byte StringQty; // The number of String arguments required public byte FloatQty; // The number of float args public byte DefaultQty; // The number of default float args public IntPtr DefaultValues; // The pointer to defaults table } Finally, we have an AmiVar structure: [StructLayoutAttribute(LayoutKind.Explicit, Size = 8)] public struct AmiVar { [FieldOffset(0)] public Int32 type; [FieldOffset(4)] public Single val; [FieldOffset(4)] public IntPtr array; [FieldOffset(4)] [MarshalAs(UnmanagedType.LPStr)] public string name; [FieldOffset(4)] public IntPtr disp; } Sorry this is too long. Unfortunately, I couldn't make a small consise question. So this code compiled (maybe not anymore since this is an extract from the bigger picture) but when loading the resulting dll from the technical analysis software, I received an ACCESS VIOLATION ERROR. I believe this means the C# conversion doesn't map the C++ variables size correctly. With the arrays of structures and delegates this project has become too difficult for me to solve alone. Any help will be much appreciated! Thanks, Guillaume
