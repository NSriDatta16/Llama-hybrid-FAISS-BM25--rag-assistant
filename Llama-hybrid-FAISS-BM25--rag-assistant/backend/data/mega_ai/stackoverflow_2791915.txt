[site]: stackoverflow
[post_id]: 2791915
[parent_id]: 2791869
[tags]: 
Use a bit masking operator. In the C language: X & 8 is true, if the "8"s bit is set. You can enumerate the bit masks, and count how many are set. If it really is the case that the entire word contains bits, and you want to simply compute how many bits are set, you want in essence a "population count". The absolute fastest way to get a population count is to execute a native "popcnt" usually available in your machine's instruction set. If you don't care about space, you can set up a array countedbits[...] indexed by your value with precomputed bit counts. Then a single memory access computes your bit count. Often used is just plain "bit twiddling code" that computes bit counts: (Kernigan's method): unsigned int v; // count the number of bits set in v unsigned int c; // c accumulates the total bits set in v for (c = 0; v; c++) { v &= v - 1; // clear the least significant bit set } (parallel bit summming, 32 bits) v = v - ((v >> 1) & 0x55555555); // reuse input as temporary v = (v & 0x33333333) + ((v >> 2) & 0x33333333); // temp c = ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24; // count If you haven't seen the bit twiddling hacks before, you're in for a treat. PHP, being funny, may do funny things with some of this arithmetic.
