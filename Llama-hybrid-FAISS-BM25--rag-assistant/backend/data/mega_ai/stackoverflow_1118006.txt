[site]: stackoverflow
[post_id]: 1118006
[parent_id]: 
[tags]: 
Most "pythonic" way of organising class attributes, constructor arguments and subclass constructor defaults?

Being relatively new to Python 2, I'm uncertain how best to organise my class files in the most 'pythonic' way. I wouldn't be asking this but for the fact that Python seems to have quite a few ways of doing things that are very different to what I have come to expect from the languages I am used to. Initially, I was just treating classes how I'd usually treat them in C# or PHP, which of course made me trip up all over the place when I eventually discovered the mutable values gotcha: class Pants(object): pockets = 2 pocketcontents = [] class CargoPants(Pants): pockets = 200 p1 = Pants() p1.pocketcontents.append("Magical ten dollar bill") p2 = CargoPants() print p2.pocketcontents Yikes! Didn't expect that! I've spent a lot of time searching the web and through some source for other projects for hints on how best to arrange my classes, and one of the things I noticed was that people seem to declare a lot of their instance variables - mutable or otherwise - in the constructor, and also pile the default constructor arguments on quite thickly. After developing like this for a while, I'm still left scratching my head a bit about the unfamiliarity of it. Considering the lengths to which the python language goes to to make things seem more intuitive and obvious, it seems outright odd to me in the few cases where I've got quite a lot of attributes or a lot of default constructor arguments, especially when I'm subclassing: class ClassWithLotsOfAttributes(object): def __init__(self, jeebus, coolness='lots', python='isgoodfun', pythonic='nebulous', duck='goose', pants=None, magictenbucks=4, datawad=None, dataload=None, datacatastrophe=None): if pants is None: pants = [] if datawad is None: datawad = [] if dataload is None: dataload = [] if datacatastrophe is None: datacatastrophe = [] self.coolness = coolness self.python = python self.pythonic = pythonic self.duck = duck self.pants = pants self.magictenbucks = magictenbucks self.datawad = datawad self.dataload = dataload self.datacatastrophe = datacatastrophe self.bigness = None self.awesomeitude = None self.genius = None self.fatness = None self.topwise = None self.brillant = False self.strangenessfactor = 3 self.noisiness = 12 self.whatever = None self.yougettheidea = True class Dog(ClassWithLotsOfAttributes): def __init__(self, coolness='lots', python='isgoodfun', pythonic='nebulous', duck='goose', pants=None, magictenbucks=4, datawad=None, dataload=None, datacatastrophe=None): super(ClassWithLotsOfAttributes, self).__init__(coolness, python, pythonic, duck, pants, magictenbucks, datawad, dataload, datacatastrophe) self.noisiness = 1000000 def quack(self): print "woof" Mild silliness aside (I can't really help myself when cooking up these artificial example classes), assuming I have a real-world need for a set of classes with this many attributes, I suppose my questions are: What is the most, uhh, 'pythonic' way of declaring a class with that many attributes? Is it best to put them against the class if the default is immutable, ala Pants.pockets, or is it better to put them in the constructor, ala ClassWithLotsOfAttributes.noisiness? Is there a way to eliminate the need to redeclare the defaults for all of the subclass constructor arguments, as in Dog.__init__? Should I even be including this many arguments with defaults anyway?
