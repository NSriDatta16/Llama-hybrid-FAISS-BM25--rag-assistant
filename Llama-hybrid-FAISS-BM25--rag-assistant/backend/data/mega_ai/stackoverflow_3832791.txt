[site]: stackoverflow
[post_id]: 3832791
[parent_id]: 
[tags]: 
Can one assign 4 little-endian-ordered bytes of an unsigned integer to a Java primitive using just bitwise operators?

I want to read 4 bytes which are a little-endian encoding of an unsigned 32-bit integer, and assign the value to a Java int (Yes, in reality I will use a 'long', but in this case I 'know' that the unsigned value is never so big that it will overflow a signed int in two's complement notation, and it suits my illustration to use an int). The 4 bytes in question encode the value '216' little-endian style: 0xD8000000 And basically I just need to stuff the following bit pattern into Java int: 0x000000D8 The following simple code ought to do it ... and for the first three '0x00' bytes it succeeds: byte b1 = din.readByte(); byte b2 = din.readByte(); byte b3 = din.readByte(); byte b4 = din.readByte(); int s = 0; s = s | b4; s = (s However, it screws up on: s = s | b1; ... because the bits of b1 are 1101 1000, which is a negative number (-40) in two's complement notation, since the most-significant bit is a 1. When Java widens b1 to an int before evaluating the bitwise or operator |, -40 is encoded as 0xFFFFFFD8, which screws our naive assumption that the first 3 bytes of the widened int will be 0's. So my strategy runs aground. But what should I do instead? Is it even possible to solve this using primitive operators (please give solution), or must we resort to the class library? (I don't play around with bits and bytes directly very much in my normal coding, so I lack the idiom for what seems like it ought to be 'everyday' code). As for the class library approach, the following fragment gets the right result: ByteBuffer b = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).put((byte) 0xD8).put((byte) 0x00).put((byte) 0x00).put((byte) 0x00); b.flip(); int s = b.getInt(); ... which is fine for readability, but uses 8 method invocations which I'd rather dispense with. thanks! David.
