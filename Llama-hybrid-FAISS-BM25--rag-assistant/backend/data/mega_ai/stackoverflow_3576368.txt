[site]: stackoverflow
[post_id]: 3576368
[parent_id]: 3509598
[tags]: 
The pinvokes are necessary but what you are doing seems well slightly overkill, no need to go down that route, consider this code sample below, which is a VS2008 solution and indeed does work... using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Runtime.InteropServices; using System.IO; using HWND = System.IntPtr; namespace RtfStream { public partial class Form1 : Form { private Win32API.EDITSTREAM _es; private FileStream _fs = null; private MemoryStream _mStream; private IntPtr _globPtr = IntPtr.Zero; public Form1() { InitializeComponent(); // this._mStream = new MemoryStream(); // this._fs = new FileStream(@"C:\EditCb.rtf", FileMode.OpenOrCreate); // this._es = new Win32API.EDITSTREAM(); this._es.dwCookie = this._fs.Handle; this._es.pfnCallback = new Win32API.EditStreamCallback(this.Form1_rtfCb); // this._globPtr = Marshal.AllocHGlobal(Marshal.SizeOf(this._es)); if (this._globPtr.ToInt32() > 0) Marshal.StructureToPtr(this._es, this._globPtr, false); } public uint Form1_rtfCb(IntPtr dwCookie, IntPtr pbBuff, Int32 cb, IntPtr pcb) { uint result = 0; byte[] buf; if (cb > 0) { buf = new byte[cb]; Marshal.Copy(pbBuff, buf, 0, cb); this._mStream.Write(buf, 0, cb); Marshal.WriteInt32(pcb, cb); } // System.Diagnostics.Debug.WriteLine("Form1_rtfCb"); // return result; } private void Form1_FormClosed(object sender, FormClosedEventArgs e) { if (this._globPtr.ToInt32() > 0) { IntPtr rv = Win32API.SendMessage(this.richTextBox1.Handle, Win32API.EM_STREAMOUT, new IntPtr(Win32API.SF_RTF), this._globPtr); if (rv.ToInt32() != 0) System.Diagnostics.Debug.WriteLine("Fail"); else System.Diagnostics.Debug.WriteLine("OK"); byte[] mbStream = this._mStream.ToArray(); this._mStream.Close(); if (this._fs != null) { this._fs.Write(mbStream, 0, mbStream.Length); this._fs.Close(); } Marshal.FreeHGlobal(this._globPtr); this._globPtr = IntPtr.Zero; System.Diagnostics.Debug.WriteLine("Cleaned Up!"); } } } public class Win32API { public const int EM_STREAMIN = 0x449; public const int EM_STREAMOUT = 0x44A; public const int SF_TEXT = 1; public const int SF_RTF = 2; public const int SF_RTFNOOBJS = 3; public const int SF_TEXTIZED = 4; public const int SF_UNICODE = 16; public const int SF_USECODEPAGE = 32; public const int SF_NCRFORNONASCII = 64; public const int SF_RTFVAL = 0x0700; [DllImport("user32")]public static extern int SendMessage(HWND hwnd, int wMsg, int wParam, IntPtr lParam); [DllImport("user32")]public static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam); // public delegate UInt32 EditStreamCallback(IntPtr dwCookie, IntPtr pbBuff, Int32 cb, IntPtr pcb); public struct EDITSTREAM { public IntPtr dwCookie; public UInt32 dwError; public EditStreamCallback pfnCallback; } } } The Form1 contains a simple richtext box control docked to the form, that is all is needed. Then, within the constructor, we open up a MemoryStream for writing to, set up an EDITSTREAM and marshal a pointer to it, define a callback function, we do nothing there at this point. The call back will definitely be executed when the form closes. Notice in the Form1_rtfCb method, we are able to marshal the data out of the pointer pbBuff into a temporary byte array, which is then written to the memory stream. We must explicitly set the pointer pcb to the value of the length of data, a zero value written into the pcb, indicates a failure (because the documentation is a bit sparse), see the MSDN documentation on this. I did think the call back would happen every now and then on its own but no it did not so at the end of the day, I highly doubt that it is called back at regular intervals, perhaps implement a timer every now and then to flush the data out of the control... Another thought - there may be a data limit on how much data gets put into the rich text box control, once the limit is reached, the call back gets fired - I do not know.. The magic happens during the Form_Closed event handler, where we send a message to the rich text control to pull the data out of that into a byte buffer via way of the callback, then we write out the memorystream into the file buffer and close it. The data is now written out. This code demonstrates the conclusion that you must explicitly send the message to the rich text control every now and then for this to work - PITA I know... In relation to code injection, it might be worth your while to investigate Detours , from what I've heard, one guy on the SO managed to use it on a OpenGL application to grab a screenshot by injecting their code into the process - a equivalent of a LD_PRELOAD under Linux... EDIT 31st Aug 2010: I have been playing around with this block of code that I wrote which I felt Oleg and Jim's code, in particular Oleg's answer is not quite right either as really that code is demonstrating passing data back and forth between the shared memory that is readable/writeable via the usage of this pragma linker #pragma data_seg(".shared") char sharedStr[255] = "a"; char sharedRichTextBoxString[255] = "a"; int addr = 0; HMODULE module = 0; int flag = 0; #pragma data_seg() #pragma comment(linker, "/SECTION:.shared,RWS") That is not sufficient enough. I have devised a way to do it, but for a reason or other it is crashing the process that has the EditStream callback... #define WIN32_LEAN_AND_MEAN #include #include #include #include static HWND _HWND_Rtf; static HWND _HWND_Parent; static HANDLE _hModule; static DWORD CALLBACK EditStreamCallBack(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb); BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { _hModule = hModule; switch(ul_reason_for_call){ case DLL_PROCESS_ATTACH: OutputDebugString("W00t! Process Attached...."); break; case DLL_PROCESS_DETACH: OutputDebugString("W00t! Process Detached...."); break; case DLL_THREAD_ATTACH: OutputDebugString("W00t! Thread Attached...."); break; case DLL_THREAD_DETACH: OutputDebugString("W00t! Thread Detached...."); break; } OutputDebugString("W00tness!...."); return TRUE; } __declspec(dllexport) int _stdcall NotifyStreamOut(HWND rtfHandle, HWND parentHandle) { EDITSTREAM _editStream; // _HWND_Parent = parentHandle; _HWND_Rtf = rtfHandle; // _editStream.dwCookie = 0; _editStream.dwError = 0; _editStream.pfnCallback = (EDITSTREAMCALLBACK)EditStreamCallBack; // Fire the message... SendMessage(rtfHandle, EM_STREAMOUT, SF_RTF, (LPARAM)&_editStream); OutputDebugString("Fired Event to RTF's Handle"); if (_editStream.dwError == (DWORD)0) return 0; else return -1; } static DWORD CALLBACK EditStreamCallBack(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb) { COPYDATASTRUCT cds; cds.dwData = &pbBuff; cds.cbData = cb; cds.lpData = &pbBuff; SendMessage(_HWND_Parent, WM_COPYDATA, (WPARAM)_hModule, (LPARAM)&cds); OutputDebugString("Fired Event to Outside Process's Handle with WM_COPYDATA message"); return 0; } The intention is to send the callback to the RichText box within this DLL which gets injected into the process that has the richtext box in question, then, from the Managed side of C#, we invoke the function NotifyStreamOut by passing in the handle to the richtext box that we are targetting and also, the crucial bit, is the handle of the Managed Code's process. The reason is quite simple, the handle to the richtext box is obvious, the other handle is so that from the unmanaged process where this DLL gets injected, we use the WM_COPYDATASTRUCT message to pass the information back out to our managed process, in which we trap that message in this way and extract that information by marshalling it across... sadly, the process (WordPad in fact) get's injected with this DLL but dies of a terminal death - heh, a lethal injection to put it another way... the code to inject into the WordPad's process can be found here on this external link ... so far attempts have failed... The DLL is called RtfHandler, which has the module definition exports declared as shown LIBRARY "RtfHandler" EXPORTS NotifyStreamOut This is what I have in the C# code [DllImport(@"RtfHandler.dll", EntryPoint = "NotifyStreamOut", CallingConvention = CallingConvention.StdCall)] public static extern void NotifyRtfStreamOut(IntPtr rtfHandle, IntPtr ourHandle); So... the theory still stands...
