[site]: stackoverflow
[post_id]: 758546
[parent_id]: 757897
[tags]: 
It's simple. Listening to the .NET framework guidelines for once actually helps (although plenty of material in the book is just plain Elements of Java style Yet Again in Redmond Wonderland).. You should avoid similar type names in cross or intra-project/library mixing namespaces ie. mixing across domains and models in generial ( even in C++ one that is extremellly strict and powerful, it also has an incarnation in compiler, resolution and enum-style compiler crashes and problems). Therefore even fully qualifying all the time is no fool-proof (and btw aliases and 'using' are extremely limited and cause mild duplication at best, as well as prove C# weakness in generic programming etc ). In my experience, Data domain types are a primary target for a more appropriate name, and thus for name refactoring which is: a) cheap (as a process in rich ASTs but simple adt-s support like in C#, right-click in IDE and feel powerful according to type-challenged dynamic Ruby fans/backers ) [can also be read as: 4.0 dynamic features sheep will blame everyone but not think about namespaces or functional JS, C-with templates(not C-with-classes), or similar ] b) communicates the semantics better ie. the intent (ie. plumbing + support to build your own processing ) c) usually of primitive but typed nature or message ( typed not OO; ie. OO-style critique as in aforementioned book which itself breaks straight out of intro lifts all 'Models' to reference land) d) and 'aliasing' becomes a useful artifact in cross-domain usage (which is actually possible and quite 2020-like.. ie. value-type programming ) There really are no rules but beware that you will see mixing of namespaces in development when least expected.. which means only one thing for a managed-minded dev: confusion. Plus somewhat less serious, more compile-time and IntelliNonsense errors of course.. Tough problem in all languages, so it is your design/naming issue.. Even tool vendors can mess up for machines to parse.. say output of enhanced popular IDEs based on outdated browse information; then again, others do it real well for managed languages. Not that I am against duplicating names, there are cases (they are tough but necessary) when mixing dual + interop + representation etc other models where same name makes it more readable; ie. where duplication is a necessity of dual-usage.. but that is lower level idioms that C# is not friendly or encouraging of (re: in favour of overhead).
