[site]: stackoverflow
[post_id]: 2088035
[parent_id]: 2086142
[tags]: 
Take a look at Signals and slots across threads . If you always use signals and slots to communicate with the worker thread, Qt handles the moveToThread for you if it's needed and you used the correct connection. Edit: I would guess the article's author was seeing his problem since he was calling start in the constructor before the thread was actually created. In other words, don't trust third-party code blindly. Edit: In response to your comment, look at the Mandelbrot example, under the MandelbrotWidget Class Implementation header: With queued connections, Qt must store a copy of the arguments that were passed to the signal so that it can pass them to the slot later on. Qt knows how to take of copy of many C++ and Qt types, but QImage isn't one of them. We must therefore call the template function qRegisterMetaType() before we can use QImage as parameter in queued connections. I believe this is slightly outdated, here are the valid meta types . Since signals and slots across threads use queued connections, you should not have to do the moveToThread calls in most cases. Edit: I will try to explain things with a similar example: mythread.h: #ifndef MYTHREAD_H #define MYTHREAD_H #include #include class MyThread : public QThread { Q_OBJECT protected: virtual void run(); signals: void signalGUI(QString); }; #endif // MYTHREAD_H mythread.cpp: #include "mythread.h" #include void MyThread::run() { qDebug("Thread id inside run %d",(int)QThread::currentThreadId()); static int run = 0; QString temp = QString("Run: %1").arg(run++); qDebug("String address inside run %p", &temp); emit signalGUI(temp); } mylineedit.h #ifndef MYLINEEDIT_H #define MYLINEEDIT_H #include class MyLineEdit : public QLineEdit { Q_OBJECT public: explicit MyLineEdit(QWidget *parent = 0); public slots: void setText(const QString &string); }; #endif // MYLINEEDIT_H mylineedit.cpp #include "mylineedit.h" #include MyLineEdit::MyLineEdit(QWidget *parent) : QLineEdit(parent) { } void MyLineEdit::setText(const QString &string) { qDebug("Thread id inside setText %d",(int)QThread::currentThreadId()); qDebug("String address inside setText %p\n", &string); QLineEdit::setText(string); } main.cpp: #include #include #include #include "mythread.h" #include "mylineedit.h" //GUI calls a thread to do some job and sub update the text box once it is done int main(int argc, char *argv[]) { QApplication a(argc, argv); QWidget w; QHBoxLayout * pH = new QHBoxLayout(&w); QPushButton * pushButton = new QPushButton("Run Thread", &w); MyLineEdit * lineEdit = new MyLineEdit(&w); pH->addWidget(pushButton); pH->addWidget(lineEdit); w.show(); MyThread thread; qDebug("Thread id %d",(int)QThread::currentThreadId()); QObject::connect(pushButton,SIGNAL(clicked()),&thread,SLOT(start())) ; QObject::connect(&thread,SIGNAL(signalGUI(const QString&)),lineEdit,SLOT(setText(const QString&))); return a.exec(); } Sample output after clicking button: Thread id 1088110320 Thread id inside run 1093176208 String address inside run 0x41288350 Thread id inside setText 1088110320 String address inside setText 0x974af58 As you can see, the run thread is different than the main GUI thread. Also, even though you pass a const reference to a QString, since it crosses thread boundaries it copies it. I strongly encourage you to read Threads and QObject .
