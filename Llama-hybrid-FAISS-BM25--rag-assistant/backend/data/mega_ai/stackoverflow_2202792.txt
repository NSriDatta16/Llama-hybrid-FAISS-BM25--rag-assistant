[site]: stackoverflow
[post_id]: 2202792
[parent_id]: 2202585
[tags]: 
It sounds to me like your problem is due primarily to how you're (ab)using namespaces, not due to the namespaces themselves. It sounds like you're throwing a lot of minimally related "stuff" into one namespace, mostly (when you get down to it) because they happen to have been developed by the same person. At least IMO, a namespace should reflect logical organization of the code, not just the accident that a bunch of utilities happened to be written by the same person. A namespace name should usually be fairly long and descriptive to prevent any more than the most remote possibility of a collision. For example, I usually include my name, date written, and a short description of the functionality of the namespace. Most client code doesn't need to (and often shouldn't) use the real name of the namespace directly. Instead, it should define a namespace alias, and only the alias name should be used in most code. Putting points two and three together, we can end up with code something like this: #include "jdate.h" namespace dt = Jerry_Coffin_Julian_Date_Dec_21_1999; int main() { dt::Date date; std::cout >date; dt::Julian jdate(date); std::cout This removes (or at least drastically reduces) coupling between the client code and a particular implementation of the date/time classes. For example, if I wanted to re-implement the same date/time classes, I could put them in a different namespace, and switch between one and the other just by changing the alias and re-compiling. In fact, I've used this at times as a kind of compile-time polymorphism mechanism. For one example, I've written a couple versions of a small "display" class, one that displays output in a Windows list-box, and another that displays output via iostreams. The code then uses an alias something like: #ifdef WINDOWED namespace display = Windowed_Display #else namespace display = Console_Display #endif The rest of the code just uses display::whatever , so as long as both namespaces implement the entire interface, I can use either one, without changing the rest of the code at all, and without any runtime overhead from using a pointer/reference to a base class with virtual functions for the implementations.
