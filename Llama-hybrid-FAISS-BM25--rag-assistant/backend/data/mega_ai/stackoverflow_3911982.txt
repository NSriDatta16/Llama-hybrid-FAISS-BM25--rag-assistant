[site]: stackoverflow
[post_id]: 3911982
[parent_id]: 3911966
[tags]: 
Because you cannot have a general algorithm for every locale, no. You have to implement your own algorithm for every locale that you are supporting. ** EDIT ** Just for the heck of it, I played around until I got this class. It cannot display Long.MIN_VALUE because of bit restrictions... but I presume it could be modified and change long value types to double for decimal or even bigger numbers It can display any numbers up to 66 digits and 26 decimals using a string representation of the number. You may add more ScaleUnit for more decimals... /** * This class will convert numeric values into an english representation * * For units, see : http://www.jimloy.com/math/billion.htm * * @author yanick.rochon@gmail.com */ public class NumberToWords { static public class ScaleUnit { private int exponent; private String[] names; private ScaleUnit(int exponent, String...names) { this.exponent = exponent; this.names = names; } public int getExponent() { return exponent; } public String getName(int index) { return names[index]; } } /** * See http://www.wordiq.com/definition/Names_of_large_numbers */ static private ScaleUnit[] SCALE_UNITS = new ScaleUnit[] { new ScaleUnit(63, "vigintillion", "decilliard"), new ScaleUnit(60, "novemdecillion", "decillion"), new ScaleUnit(57, "octodecillion", "nonilliard"), new ScaleUnit(54, "septendecillion", "nonillion"), new ScaleUnit(51, "sexdecillion", "octilliard"), new ScaleUnit(48, "quindecillion", "octillion"), new ScaleUnit(45, "quattuordecillion", "septilliard"), new ScaleUnit(42, "tredecillion", "septillion"), new ScaleUnit(39, "duodecillion", "sextilliard"), new ScaleUnit(36, "undecillion", "sextillion"), new ScaleUnit(33, "decillion", "quintilliard"), new ScaleUnit(30, "nonillion", "quintillion"), new ScaleUnit(27, "octillion", "quadrilliard"), new ScaleUnit(24, "septillion", "quadrillion"), new ScaleUnit(21, "sextillion", "trilliard"), new ScaleUnit(18, "quintillion", "trillion"), new ScaleUnit(15, "quadrillion", "billiard"), new ScaleUnit(12, "trillion", "billion"), new ScaleUnit(9, "billion", "milliard"), new ScaleUnit(6, "million", "million"), new ScaleUnit(3, "thousand", "thousand"), new ScaleUnit(2, "hundred", "hundred"), //new ScaleUnit(1, "ten", "ten"), //new ScaleUnit(0, "one", "one"), new ScaleUnit(-1, "tenth", "tenth"), new ScaleUnit(-2, "hundredth", "hundredth"), new ScaleUnit(-3, "thousandth", "thousandth"), new ScaleUnit(-4, "ten-thousandth", "ten-thousandth"), new ScaleUnit(-5, "hundred-thousandth", "hundred-thousandth"), new ScaleUnit(-6, "millionth", "millionth"), new ScaleUnit(-7, "ten-millionth", "ten-millionth"), new ScaleUnit(-8, "hundred-millionth", "hundred-millionth"), new ScaleUnit(-9, "billionth", "milliardth"), new ScaleUnit(-10, "ten-billionth", "ten-milliardth"), new ScaleUnit(-11, "hundred-billionth", "hundred-milliardth"), new ScaleUnit(-12, "trillionth", "billionth"), new ScaleUnit(-13, "ten-trillionth", "ten-billionth"), new ScaleUnit(-14, "hundred-trillionth", "hundred-billionth"), new ScaleUnit(-15, "quadrillionth", "billiardth"), new ScaleUnit(-16, "ten-quadrillionth", "ten-billiardth"), new ScaleUnit(-17, "hundred-quadrillionth", "hundred-billiardth"), new ScaleUnit(-18, "quintillionth", "trillionth"), new ScaleUnit(-19, "ten-quintillionth", "ten-trillionth"), new ScaleUnit(-20, "hundred-quintillionth", "hundred-trillionth"), new ScaleUnit(-21, "sextillionth", "trilliardth"), new ScaleUnit(-22, "ten-sextillionth", "ten-trilliardth"), new ScaleUnit(-23, "hundred-sextillionth", "hundred-trilliardth"), new ScaleUnit(-24, "septillionth","quadrillionth"), new ScaleUnit(-25, "ten-septillionth","ten-quadrillionth"), new ScaleUnit(-26, "hundred-septillionth","hundred-quadrillionth"), }; static public enum Scale { SHORT, LONG; public String getName(int exponent) { for (ScaleUnit unit : SCALE_UNITS) { if (unit.getExponent() == exponent) { return unit.getName(this.ordinal()); } } return ""; } } /** * Change this scale to support American and modern British value (short scale) * or Traditional British value (long scale) */ static public Scale SCALE = Scale.SHORT; static abstract public class AbstractProcessor { static protected final String SEPARATOR = " "; static protected final int NO_VALUE = -1; protected List getDigits(long value) { ArrayList digits = new ArrayList (); if (value == 0) { digits.add(0); } else { while (value > 0) { digits.add(0, (int) value % 10); value /= 10; } } return digits; } public String getName(long value) { return getName(Long.toString(value)); } public String getName(double value) { return getName(Double.toString(value)); } abstract public String getName(String value); } static public class UnitProcessor extends AbstractProcessor { static private final String[] TOKENS = new String[] { "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen" }; @Override public String getName(String value) { StringBuilder buffer = new StringBuilder(); int offset = NO_VALUE; int number; if (value.length() > 3) { number = Integer.valueOf(value.substring(value.length() - 3), 10); } else { number = Integer.valueOf(value, 10); } number %= 100; if (number 3) { number = Integer.valueOf(value.substring(value.length() - 3), 10); } else { number = Integer.valueOf(value, 10); } number %= 100; // keep only two digits if (number >= 20) { buffer.append(TOKENS[(number / 10) - 2]); number %= 10; tensFound = true; } else { number %= 20; } if (number != 0) { if (tensFound) { buffer.append(UNION_SEPARATOR); } buffer.append(unitProcessor.getName(number)); } return buffer.toString(); } } static public class HundredProcessor extends AbstractProcessor { private int EXPONENT = 2; private UnitProcessor unitProcessor = new UnitProcessor(); private TensProcessor tensProcessor = new TensProcessor(); @Override public String getName(String value) { StringBuilder buffer = new StringBuilder(); int number; if (value.isEmpty()) { number = 0; } else if (value.length() > 4) { number = Integer.valueOf(value.substring(value.length() - 4), 10); } else { number = Integer.valueOf(value, 10); } number %= 1000; // keep at least three digits if (number >= 100) { buffer.append(unitProcessor.getName(number / 100)); buffer.append(SEPARATOR); buffer.append(SCALE.getName(EXPONENT)); } String tensName = tensProcessor.getName(number % 100); if (!tensName.isEmpty() && (number >= 100)) { buffer.append(SEPARATOR); } buffer.append(tensName); return buffer.toString(); } } static public class CompositeBigProcessor extends AbstractProcessor { private HundredProcessor hundredProcessor = new HundredProcessor(); private AbstractProcessor lowProcessor; private int exponent; public CompositeBigProcessor(int exponent) { if (exponent and a sample output (for the random big number generator) 0 = zero 4 = four 10 = ten 12 = twelve 100 = one hundred 108 = one hundred eight 299 = two hundred ninety-nine 1000 = one thousand 1003 = one thousand three 2040 = two thousand fourty 45213 = fourty-five thousand two hundred thirteen 100000 = one hundred thousand 100005 = one hundred thousand five 100010 = one hundred thousand ten 202020 = two hundred two thousand twenty 202022 = two hundred two thousand twenty-two 999999 = nine hundred ninety-nine thousand nine hundred ninety-nine 1000000 = one million 1000001 = one million one 10000000 = ten million 10000007 = ten million seven 99999999 = ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine 9223372036854775807 = nine quintillion two hundred twenty-three quadrillion three hundred seventy-two trillion thirty-six billion eight hundred fifty-four million seven hundred seventy-five thousand eight hundred seven -9223372036854775808 = minus nine quintillion two hundred twenty-three quadrillion three hundred seventy-two trillion thirty-six billion eight hundred fifty-four million seven hundred seventy-five thousand eight hundred eight 0001.2 = one and two tenth 3.141592 = three and one hundred fourty-one thousand five hundred ninety-two millionth 694780458103427072928672912656674465845126458162617425283733729646.85695031739734695391404376 = six hundred ninety-four vigintillion seven hundred eighty novemdecillion four hundred fifty-eight octodecillion one hundred three septendecillion four hundred twenty-seven sexdecillion seventy-two quindecillion nine hundred twenty-eight quattuordecillion six hundred seventy-two tredecillion nine hundred twelve duodecillion six hundred fifty-six undecillion six hundred seventy-four decillion four hundred sixty-five nonillion eight hundred fourty-five octillion one hundred twenty-six septillion four hundred fifty-eight sextillion one hundred sixty-two quintillion six hundred seventeen quadrillion four hundred twenty-five trillion two hundred eighty-three billion seven hundred thirty-three million seven hundred twenty-nine thousand six hundred fourty-six and eighty-five septillion six hundred ninety-five sextillion thirty-one quintillion seven hundred thirty-nine quadrillion seven hundred thirty-four trillion six hundred ninety-five billion three hundred ninety-one million four hundred four thousand three hundred seventy-six hundred-septillionth
