[site]: stackoverflow
[post_id]: 3660604
[parent_id]: 3660277
[tags]: 
I've found that in MySQL at least, almost any query using GROUP BY invokes a temporary table. This is where your big performance cost goes. Try examining where it's spending its time using the profiler: edit: I'm correcting the following to SET PROFILING (not SET PROFILES ): SET PROFILING = On; SELECT ...the whole query you want to profile... SHOW PROFILES; SHOW PROFILE FOR QUERY 1; See http://dev.mysql.com/doc/refman/5.1/en/show-profiles.html for more details. There's not much you can do to fix this. It's sometimes preferable for performance reasons to eliminate the GROUP BY and aggregate functions: select `ev`.`EventID` AS `EventID` ,`ev`.`EventName` AS `EventName` ,concat(`ev`.`EventDate`,' ',`ev`.`StartTime`) AS `EventDT` ,`ev`.`NumberTicketsAvailable` AS `TotalTickets` ,`ev`.`Soldout` AS `Soldout` ,case when (`ec`.`CartStatus` = 'InCart') then 1 else 0 end AS `InCartCounter` ,case when (`ec`.`CartStatus` = 'InPayment') then 1 else 0 end AS `InPaymentCounter` ,case when (`ec`.`CartStatus` = 'Paid') then 1 else 0 end AS `PaidCounter` ,case when ((`ec`.`CartStatus` = 'Paid') and ((`ec`.`DateRecordModified` + interval 604800 second) > now())) then 1 else 0 end AS `PaidOverWeekCounter` ,case when ((`ec`.`CartStatus` = 'Paid') and ((`ec`.`DateRecordModified` + interval 432000 second) > now())) then 1 else 0 end AS `PaidOverFiveDaysCounter` ,case when ((`ec`.`CartStatus` = 'Paid') and ((`ec`.`DateRecordModified` + interval 86400 second) > now())) then 1 else 0 end AS `PaidOverDayCounter` ,case when ((`ec`.`CartStatus` = 'Paid') and ((`ec`.`DateRecordModified` + interval 43200 second) > now())) then 1 else 0 end AS `PaidOverHalfDayCounter` ,case when ((`ec`.`CartStatus` = 'Paid') and ((`ec`.`DateRecordModified` + interval 21600 second) > now())) then 1 else 0 end AS `PaidOverQuarterDayCounter` ,case when ((`ec`.`CartStatus` = 'Paid') and ((`ec`.`DateRecordModified` + interval 10800 second) > now())) then 1 else 0 end AS `PaidOverThreeHoursCounter` ,case when ((`ec`.`CartStatus` = 'Paid') and ((`ec`.`DateRecordModified` + interval 3600 second) > now())) then 1 else 0 end AS `PaidOverHourCounter` from `Events` `ev` inner join `Events_EventCart_Rel` `eecr` on `ev`.`EventID` = `eecr`.`EventID` inner join `EventCart` `ec` on `eecr`.`EventCartID` = `ec`.`EventCartID` where `eecr`.`Active` = 1 and `eecr`.`Deleted` = 'No' Then in your application code, fetch all the rows, and loop over them, calculating the aggregate counts as you go. For instance in PHP: $stmt = $pdo->query($sql); $events = array(); $counters = array("InCartCounter", "InPaymentCounter", "PaidCounter", "PaidOverWeekCounter", "PaidOverFiveDaysCounter", "PaidOverDayCounter", "PaidOverHalfDayCounter", "PaidOverQuarterDayCounter", "PaidOverThreeHoursCounter", "PaidOverHourCounter"); while ($row = $stmt->fetch()) { if (!isset($events[$row["EventID"]])) { $events[$row["EventID"]] = $row; } else { foreach ($counters as $key) { $events[$row["EventID"]][$key] += $row[$key]; } } } It looks like a lot of code and trouble to do something that SQL should be able to do more efficiently, but in the case of MySQL and GROUP BY writing more application code is often better. PS: In the example SQL query, I changed your joins to inner joins. I don't think you need outer joins.
