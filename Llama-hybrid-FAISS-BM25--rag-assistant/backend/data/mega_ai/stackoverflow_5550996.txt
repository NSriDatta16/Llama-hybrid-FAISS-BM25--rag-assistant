[site]: stackoverflow
[post_id]: 5550996
[parent_id]: 5549215
[tags]: 
In general, this isn't really a very useful thing to do: because the data used by any single ref is likely to be shared by many other refs, knowing this information isn't particularly useful. Also, it will be highly JVM-specific - different JVM implementations may use different amounts of memory for the same Clojure structures depending on how they choose to pack data structures and pointers. For example, I believe that HotSpot pads object sizes up to the nearest 8 bytes, but other JVMs could do something completely different. Also 32/64-bit JVMs will typically use different sizes for pointers (but not necessarily in the obvious way, as some 64-bit JVMs use compressed pointers....) If you are still determined to do this, the best approach would probably be to recursively descend the data structure in the ref and add up the estimated size of each sub-element. You'd need to make assumptions or experimentally verify the size/overhead of each possible component type. Not easy... see this question for some of the gory details of estimating object sizes on the JVM. If you're lucky, you might be able to find a library that does this for you. You would also need to keep track of all objects visited - which is a also bit tricky since you'd need to compare on object identity rather than equality, and hence you wouldn't be able to use any of the standard hashmap/set types. A hashmap of (object hashcode -> collection of objects with the same hashcode) would work. There will also be some fun Clojure-specific corner cases to consider... e.g. are you counting meta data on a data structure or not? On average though, I'd still recommend paying attention to the memory consumed by your application as a whole , rather than specific refs.
