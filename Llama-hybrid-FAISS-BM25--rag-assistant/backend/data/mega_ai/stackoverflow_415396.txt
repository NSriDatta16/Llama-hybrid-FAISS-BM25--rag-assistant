[site]: stackoverflow
[post_id]: 415396
[parent_id]: 415291
[tags]: 
For primitive types (including bytes), use System.Buffer.BlockCopy instead of System.Array.Copy . It's faster. I timed each of the suggested methods in a loop executed 1 million times using 3 arrays of 10 bytes each. Here are the results: New Byte Array using System.Array.Copy - 0.2187556 seconds New Byte Array using System.Buffer.BlockCopy - 0.1406286 seconds IEnumerable using C# yield operator - 0.0781270 seconds IEnumerable using LINQ's Concat<> - 0.0781270 seconds I increased the size of each array to 100 elements and re-ran the test: New Byte Array using System.Array.Copy - 0.2812554 seconds New Byte Array using System.Buffer.BlockCopy - 0.2500048 seconds IEnumerable using C# yield operator - 0.0625012 seconds IEnumerable using LINQ's Concat<> - 0.0781265 seconds I increased the size of each array to 1000 elements and re-ran the test: New Byte Array using System.Array.Copy - 1.0781457 seconds New Byte Array using System.Buffer.BlockCopy - 1.0156445 seconds IEnumerable using C# yield operator - 0.0625012 seconds IEnumerable using LINQ's Concat<> - 0.0781265 seconds Finally, I increased the size of each array to 1 million elements and re-ran the test, executing each loop only 4000 times: New Byte Array using System.Array.Copy - 13.4533833 seconds New Byte Array using System.Buffer.BlockCopy - 13.1096267 seconds IEnumerable using C# yield operator - 0 seconds IEnumerable using LINQ's Concat<> - 0 seconds So, if you need a new byte array, use byte[] rv = new byte[a1.Length + a2.Length + a3.Length]; System.Buffer.BlockCopy(a1, 0, rv, 0, a1.Length); System.Buffer.BlockCopy(a2, 0, rv, a1.Length, a2.Length); System.Buffer.BlockCopy(a3, 0, rv, a1.Length + a2.Length, a3.Length); But, if you can use an IEnumerable , DEFINITELY prefer LINQ's Concat<> method. It's only slightly slower than the C# yield operator, but is more concise and more elegant. IEnumerable rv = a1.Concat(a2).Concat(a3); If you have an arbitrary number of arrays and are using .NET 3.5, you can make the System.Buffer.BlockCopy solution more generic like this: private byte[] Combine(params byte[][] arrays) { byte[] rv = new byte[arrays.Sum(a => a.Length)]; int offset = 0; foreach (byte[] array in arrays) { System.Buffer.BlockCopy(array, 0, rv, offset, array.Length); offset += array.Length; } return rv; } *Note: The above block requires you adding the following namespace at the the top for it to work. using System.Linq; To Jon Skeet's point regarding iteration of the subsequent data structures (byte array vs. IEnumerable ), I re-ran the last timing test (1 million elements, 4000 iterations), adding a loop that iterates over the full array with each pass: New Byte Array using System.Array.Copy - 78.20550510 seconds New Byte Array using System.Buffer.BlockCopy - 77.89261900 seconds IEnumerable using C# yield operator - 551.7150161 seconds IEnumerable using LINQ's Concat<> - 448.1804799 seconds The point is, it is VERY important to understand the efficiency of both the creation and the usage of the resulting data structure. Simply focusing on the efficiency of the creation may overlook the inefficiency associated with the usage. Kudos, Jon.
