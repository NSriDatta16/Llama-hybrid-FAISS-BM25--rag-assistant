[site]: stackoverflow
[post_id]: 3878749
[parent_id]: 3878061
[tags]: 
"It works, but it takes forever!" Forever in this case meaning less than three seconds a table :) There is more to dropping a table than just dropping the table. There are dependent objects to drop as well - constraints, indexes, triggers, lob or nested table storage, etc. There are views, synonyms stored procedures to invalidate. There are grants to be revoked. The table's space (and that of its indexes, etc) has to be de-allocated. All of this activity generates recursive SQL, queries which select from or update the data dictionary, and which can perform badly. Even if we don't use triggers, views, stored procs, the database still has to run the queries to establish their absence. Unlike normal SQL we cannot tune recursive SQL but we can shape the environment to make it run quicker. I'm presuming that this is a development database, in which objects get built and torn down on a regular basis, and that you're using 10g or higher. Clear out the recycle bin. SQL> purge recyclebin; Gather statistics for the data dictionary (will require DBA privileges). These may already be gathered, as that is the default behaviour in 10g and 11g. Find out more . Once you have dictionary stats ensure you're using the cost-based optimizer. Ideally this should be set at the database level, but we can fix it at the session level: SQL> alter session set optimizer_mode=choose;
