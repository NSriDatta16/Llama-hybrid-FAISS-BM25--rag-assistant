[site]: stackoverflow
[post_id]: 2140688
[parent_id]: 2140042
[tags]: 
Here is the function I use to deliver this sort of thing:- public static IEnumerable Descendents(this DependencyObject root) { int count = VisualTreeHelper.GetChildrenCount(root); for (int i = 0; i With that extension method available your code becomes:- foreach(var txt in baseLayout.Descendents().OfType ()) { txt.reset(); } Note the avoidance of a "foreach" extension method is one of choice. I don't like the idea of a LINQEsq extension method actually mutating or doing anything for to he application. I prefer to use a proper foreach to actually then operate on the results of the query. Edit for the "extension method junkies" (if your sensible you won't do this):- public static IEnumerable ForEach(this IEnumerable items, Action fn) { foreach (T item in items) fn(item); } Edit what's wrong with your code. Well primarily this line deep in your Traverse method is the main cause of your problem:- t.Traverse(fnRecurse); It returnns a IEnumerable but you don't do anything with it, not even store the result in a variable. Also this line:- var g = source.OfType (); would cause each grid found to be enumerated, for each UIElement found. So for example if source contains a TextBox and 2 Grids the above line gets called 3 times. Both Grids would be run through the inner foreach twice. Also this line:- yield return itemsub; well itemsub is always a Grid and will be filtered out by the subsequent TypeOf . Hence the only TextBox this code would ever return is any TextBox found in the initial UIElementCollection .
