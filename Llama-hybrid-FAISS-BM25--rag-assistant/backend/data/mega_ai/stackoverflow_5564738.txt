[site]: stackoverflow
[post_id]: 5564738
[parent_id]: 
[tags]: 
iPhone error in delete function

The YApp crashes whenever I press the Delete button from the simulator in iPhone. I have copied some code from my project here. How can I solve the delete bug? I found a similar question, Error in the delete function of the alarm app in iPhone , but it does not answer my question. My code is below. #import "FirstPage.h" @implementation FirstPage @synthesize datePicker, eventText,tableview; - (void) viewWillAppear:(BOOL)animated { [self.tableview reloadData]; } - (IBAction) scheduleAlarm:(id) sender { [eventText resignFirstResponder]; NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; // Get the current date NSDate *pickerDate = [self.datePicker date]; // Break the date up into components NSDateComponents *dateComponents = [calendar components:( NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit ) fromDate:pickerDate]; NSDateComponents *timeComponents = [calendar components:( NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit ) fromDate:pickerDate]; // Set up the fire time NSDateComponents *dateComps = [[NSDateComponents alloc] init]; [dateComps setDay:[dateComponents day]]; [dateComps setMonth:[dateComponents month]]; [dateComps setYear:[dateComponents year]]; [dateComps setHour:[timeComponents hour]]; // Notification will fire in one minute [dateComps setMinute:[timeComponents minute]]; [dateComps setSecond:[timeComponents second]]; NSDate *itemDate = [calendar dateFromComponents:dateComps]; [dateComps release]; UILocalNotification *localNotif = [[UILocalNotification alloc] init]; if (localNotif == nil) return; localNotif.fireDate = itemDate; localNotif.timeZone = [NSTimeZone defaultTimeZone]; // Notification details localNotif.alertBody = [eventText text]; // Set the action button localNotif.alertAction = @"View"; localNotif.soundName = UILocalNotificationDefaultSoundName; localNotif.applicationIconBadgeNumber = 1; // Specify custom data for the notification NSDictionary *infoDict = [NSDictionary dictionaryWithObject:@"someValue" forKey:@"someKey"]; localNotif.userInfo = infoDict; // Schedule the notification [[UIApplication sharedApplication] scheduleLocalNotification:localNotif]; [localNotif release]; [self.tableview reloadData]; } // The designated initializer. Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad. /* - (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { // Custom initialization. } return self; } */ - (BOOL)textFieldShouldReturn:(UITextField *)theTextField { [eventText resignFirstResponder]; return YES; } // Implement viewDidLoad to do additional setup after loading the view, typically from a nib. - (void)viewDidLoad { Array = [[NSMutableArray alloc]init]; eventText.delegate = self; [super viewDidLoad]; } #pragma mark - #pragma mark Table view data source - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { // Return the number of sections. return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { // Return the number of rows in the section. int count = [Array count]; if(self.editing) count++; //return count; return [[[UIApplication sharedApplication] scheduledLocalNotifications] count]; } // Customize the appearance of table view cells. - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @"Cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier] autorelease]; } // Configure the cell... NSArray *notificationArray = [[UIApplication sharedApplication] scheduledLocalNotifications]; // notificationArray = Array; notif = [notificationArray objectAtIndex:indexPath.row]; [cell.textLabel setText:notif.alertBody]; [cell.detailTextLabel setText:[notif.fireDate description]]; return cell; } - (IBAction)DeleteButtonAction:(id)sender { [Array removeLastObject]; [tableview reloadData]; } - (IBAction) EditTable:(id)sender { if(self.editing) { [super setEditing:NO animated:NO]; [tableview setEditing:NO animated:NO]; // [tableview reloadData]; // [self.navigationItem.leftBarButtonItem setTitle:@"Edit"]; // [self.navigationItem.leftBarButtonItem setStyle:UIBarButtonItemStylePlain]; } else { [super setEditing:YES animated:YES]; [tableview setEditing:YES animated:YES]; // [tableview reloadData]; // [self.navigationItem.leftBarButtonItem setTitle:@"Done"]; // [self.navigationItem.leftBarButtonItem setStyle:UIBarButtonItemStyleDone]; } } // The editing style for a row is the kind of button displayed to the left of the cell when in editing mode. - (UITableViewCellEditingStyle)tableView:(UITableView *)aTableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath { // No editing style if not editing or the index path is nil. if (self.editing == NO || !indexPath) return UITableViewCellEditingStyleNone; // Determine the editing style based on whether the cell is a placeholder for adding content or already // existing content. Existing content can be deleted. if (self.editing && indexPath.row == ([Array count])) { return UITableViewCellEditingStyleInsert; } else { return UITableViewCellEditingStyleDelete; } return UITableViewCellEditingStyleNone; } // Update the data model according to edit actions delete or insert. - (void)tableView:(UITableView *)aTableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { [Array removeObjectAtIndex:indexPath.row]; // [tableview reloadData]; } else if (editingStyle == UITableViewCellEditingStyleInsert) { } } #pragma mark Row reordering // Determine whether a given row is eligible for reordering or not. - (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath { return YES; } // Process the row move. This means updating the data model to correct the item indices. - (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath { NSString *item = [[Array objectAtIndex:fromIndexPath.row] retain]; [Array removeObject:item]; [Array insertObject:item atIndex:toIndexPath.row]; [item release]; } /* // Override to allow orientations other than the default portrait orientation. - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { // Return YES for supported orientations. return (interfaceOrientation == UIInterfaceOrientationPortrait); } */ - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc. that aren't in use. } - (void)viewDidUnload { datePicker = nil; tableview = nil; eventText = nil; [super viewDidUnload]; // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; } - (void)dealloc { [super dealloc]; } @end
