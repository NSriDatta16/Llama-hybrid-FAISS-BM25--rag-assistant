[site]: stackoverflow
[post_id]: 3470189
[parent_id]: 
[tags]: 
Why can't templates take function local types?

In C++ it's OK to have a funcction that takes a function local type: int main() { struct S { static void M(const S& s) { } }; S s; S::M(s); } but not OK to have a template that does: template void Foo(const T& t) { } int main() { struct S { } s; Foo(s); // Line 5: error: no matching function for call to 'Foo(main()::S&)' } 14.3.1 paragraph 2 in the c++ standard. A type with no linkage [...] shall not be used as a template-argument for a template type-parameter Why does C++ disallow that? The best explanation I've heard so far it that inner types have no linkage and that this could imply that a function that takes them as an arg must have no linkage. But there is no reason I can see that a template instantiation must have linkage. p.s. Please don't just say " thats not allowed because the standard says it's not "
