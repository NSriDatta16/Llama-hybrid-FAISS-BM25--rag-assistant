[site]: stackoverflow
[post_id]: 2323209
[parent_id]: 
[tags]: 
Mesh smoothing with Gaussian

I wish to smooth a given 3D mesh, which uses the Half-Edge structure to store adjacency information, using a Gaussian function. The following is the algorithm that was proposed: Smooth the mesh by moving every vertex to a position determined by a weighted average of its immediate neighbors (with weights determined by a Gaussian with sigma equal to the average length of edges attached to the vertex, normalized such that the weights sum to one). So for each vertex curr_vertex , I calculate the average length of its attached edges obtain all of the neighboring vertices determine the weight of each neighboring vertex by doing the following: ` weight = exp(-(distance*distance)/(2. sigma sigma)) where distance is the 3D distance between the curr_vertex and the neighbor and sigma = average length of attached edges of curr_vertex` sum up all of the weights and divide each neighbor's weight by this sum (normalization step) multiply the position of each neighboring vertex by its corresponding weight add up all of the weighted vertices and add the result to curr_vertex to produce the new vertex. When I do this and run my algorithm, instead of smoothing what actually happens is a scale - my mesh just becomes enlarged without any apparent smoothing. Any thoughts on what I'm doing wrong? Edit: Here's the code that I have: void R3Mesh:: Smooth(void) { R3Mesh *new_mesh = new R3Mesh(*this); for(int i = 0; i neighbors; // stores vertex-weight pairs map ::iterator neighbors_iter; // store each vertex neighbor by going through // all adjacent edges and obtaining those edges' vertices R3MeshHalfEdge *tmp = v->half_edge; do { neighbors.insert(make_pair(tmp->opposite->vertex,0)); tmp = tmp->opposite->next; }while(tmp != v->half_edge); // determine the sigma to use for Gaussian double sigma = v->AverageEdgeLength(); double weight = 0, total_weight = 0; double distance; // determine and store the weight of each neighboring vertex for(neighbors_iter = neighbors.begin(); neighbors_iter != neighbors.end(); neighbors_iter++) { distance = R3Distance(v->position, neighbors_iter->first->position); weight = (1./(sigma*sqrt(2.*3.14)))*exp(-(distance*distance)/(2.*sigma*sigma)); total_weight += weight; neighbors_iter->second = weight; } // determine new position of current vertex R3Point new_pos = v->position; for(neighbors_iter = neighbors.begin(); neighbors_iter != neighbors.end(); neighbors_iter++) { new_pos += (neighbors_iter->second/total_weight)*(neighbors_iter->first->position); } new_pos.Translate(new_pos - v->position); new_mesh->Vertex(i)->position.Reset(new_pos.X(), new_pos.Y(), new_pos.Z()); neighbors.clear(); } *this = *new_mesh; }
