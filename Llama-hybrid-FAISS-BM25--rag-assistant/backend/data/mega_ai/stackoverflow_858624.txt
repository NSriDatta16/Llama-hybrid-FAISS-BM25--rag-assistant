[site]: stackoverflow
[post_id]: 858624
[parent_id]: 
[tags]: 
Changing SQL Provider from SQLOLEDB.1 to SQLNCLI.1 causes app to fail when accessing data via stored procedure

I'm supporting a legacy app written in MFC/C++. The database for the app is in SQL Server 2000. We bolted on some new functionality recently and found that when we change the SQL Provider from SQLOLEDB.1 to SQLNCLI.1 some code that is trying to retrieve data from a table via a stored procedure fails. The table in question is pretty straightforward and was created via the following script: SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE TABLE [dbo].[UAllergenText]( [TableKey] [int] IDENTITY(1,1) NOT NULL, [GroupKey] [int] NOT NULL, [Description] [nvarchar](150) NOT NULL, [LanguageEnum] [int] NOT NULL, CONSTRAINT [PK_UAllergenText] PRIMARY KEY CLUSTERED ( [TableKey] ASC) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] GO ALTER TABLE [dbo].[UAllergenText] WITH CHECK ADD CONSTRAINT FK_UAllergenText_UBaseFoodGroupInfo] FOREIGN KEY([GroupKey]) REFERENCES [dbo].[UBaseFoodGroupInfo] ([GroupKey]) GO ALTER TABLE [dbo].[UAllergenText] CHECK CONSTRAINT FK_UAllergenText_UBaseFoodGroupInfo] Bascially four columns, with TableKey being an identity column and everything else is populated via the following script: INSERT INTO UAllergenText (GroupKey, Description, LanguageEnum) VALUES (401, 'Egg', 1) with a long list of other INSERT INTO's that follow the one above. Some of the rows inserted have special characters (like accent marks above letters) in their descriptions. I had originally thought that the inclusion of the special characters was part of the problem but if I completely clear out the table and then repopulate it with just the single INSERT INTO from above that has no special characters, it still fails. So I moved on... The data in this table is then accessed via the following code: std::wstring wSPName = SP_GET_ALLERGEN_DESC; _variant_t vtEmpty1 (DISP_E_PARAMNOTFOUND, VT_ERROR); _variant_t vtEmpty2(DISP_E_PARAMNOTFOUND, VT_ERROR); _CommandPtr pCmd = daxLayer::CDataAccess::GetSPCommand(pConn, wSPName); pCmd->Parameters->Append(pCmd->CreateParameter("@intGroupKey", adInteger, adParamInput, 0, _variant_t((long)nGroupKey))); pCmd->Parameters->Append(pCmd->CreateParameter("@intLangaugeEnum", adInteger, adParamInput, 0, _variant_t((int)language))); _RecordsetPtr pRS = pCmd->Execute(&vtEmpty1, &vtEmpty2, adCmdStoredProc); //std::wstring wSQL = L"select Description from UAllergenText WHERE GroupKey = 401 AND LanguageEnum = 1"; //_RecordsetPtr pRS = daxLayer::CRecordsetAccess::GetRecordsetPtr(pConn,wSQL); if (pRS->GetRecordCount() > 0) { std::wstring wDescField = L"Description"; daxLayer::CRecordsetAccess::GetField(pRS, wDescField, nameString); } else { nameString = ""; } The daxLayer is a third party data access library the application is using, though we have the source to it (some of which will be seen below.) SP__GET_ALLERGEN_DESC is the stored proc used to get the data out of the table and it was created via this script: SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE PROCEDURE [dbo].[spRET_AllergenDescription] -- Add the parameters for the stored procedure here @intGroupKey int, @intLanguageEnum int AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; -- Insert statements for procedure here SELECT Description FROM UAllergenText WHERE GroupKey = @intGroupKey AND LanguageEnum = @intLanguageEnum END When the SQL Provider is set to SQLNCLI.1, the app blows up at: daxLayer::CRecordsetAccess::GetField(pRS, wDescField, nameString); from the above code snippet. So I stepped into GetField, which looks like the following: void daxLayer::CRecordsetAccess::GetField(_RecordsetPtr pRS, const std::wstring wstrFieldName, std::string& sValue, std::string sNullValue) { if (pRS == NULL) { assert(false); THROW_API_EXCEPTION(GetExceptionMessageFieldAccess(L"GetField", wstrFieldName, L"std::string", L"Missing recordset pointer.")) } else { try { tagVARIANT tv = pRS->Fields->GetItem(_variant_t(wstrFieldName.c_str()))->Value; if ((tv.vt == VT_EMPTY) || (tv.vt == VT_NULL)) { sValue = sNullValue; } else if (tv.vt != VT_BSTR) { // The type in the database is wrong. assert(false); THROW_API_EXCEPTION(GetExceptionMessageFieldAccess(L"GetField", wstrFieldName, L"std::string", L"Field type is not string")) } else { _bstr_t bStr = tv ;//static_cast (pRS->Fields->GetItem(_variant_t(wstrFieldName.c_str()))->Value); sValue = bStr; } } catch( _com_error &e ) { RETHROW_API_EXCEPTION(GetExceptionMessageFieldAccess(L"GetField", wstrFieldName, L"std::string"), e.Description()) } catch(...) { THROW_API_EXCEPTION(GetExceptionMessageFieldAccess(L"GetField", wstrFieldName, L"std::string", L"Unknown error")) } } } The culprit here is: tagVARIANT tv = pRS->Fields->GetItem(_variant_t(wstrFieldName.c_str()))->Value; Stepping into Fields->GetItem brings us to: GetItem inline FieldPtr Fields15::GetItem ( const _variant_t & Index ) { struct Field * _result = 0; HRESULT _hr = get_Item(Index, &_result); if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this)); return FieldPtr(_result, false); } Which then takes us to: GetValue inline _variant_t Field20::GetValue ( ) { VARIANT _result; VariantInit(&_result); HRESULT _hr = get_Value(&_result); if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this)); return _variant_t(_result, false); } If you look at _result while stepping through this at runtime, _result's BSTR value is correct, its value is "Egg" from the "Description" field of the table. Continuing to step through traces back through all the COM release calls, etc. When I finally get back to: tagVARIANT tv = pRS->Fields->GetItem(_variant_t(wstrFieldName.c_str()))->Value; And step past it to the next line, the contents of tv, which should be BSTR="Egg" are now: tv BSTR = 0x077b0e1c "ᎀݸﻮﻮﻮﻮﻮﻮﻮﻮﻮﻮﻮﻮ㨼㺛帛᠄" When the GetField function tries to set its return value to the value in tv.BSTR _bstr_t bStr = tv; sValue = bStr; it unsurprisingly chokes and dies. So what happened to the value of BSTR and why does it only happen when the provider is set to SQLNCLI.1? For the heck of it, I commented out using the stored procedure in the topmost code and just hard coded the same SQL SELECT statement that the stored procedure uses and found that it works just fine and the value returned is correct. Also, it's possible for users to add rows to the table through the application. If the application creates a new row in that table and retrieves that row via stored procedure, it also works correctly unless you include a special character in the description in which case it correctly saves the row but blows up again in the exact same way as above upon retrieval of that row. So to summarize, if I can, rows put into the table via the INSERT script ALWAYS blow up the app when they are accessed by stored procedure (regardless of whether they contain any special characters). Rows put into the table from within the application by the user at runtime are retrieved correctly via stored procedure UNLESS they contain a special character in the Description, at which point they blow up the app. If you access any of the rows in the table by using SQL from the code at runtime instead of the stored procedure it works whether there is a special character in the Description or not. Any light that can be shed on this will be greatly appreciated, and I thank you in advance.
