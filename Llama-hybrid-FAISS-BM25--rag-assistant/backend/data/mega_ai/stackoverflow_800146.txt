[site]: stackoverflow
[post_id]: 800146
[parent_id]: 790014
[tags]: 
There are several reasons that Cocoa encourages the use of [Foo sharedFoo] rather than a global Foo object. [Foo sharedFoo] can auto-instantiate the first time it's used. Naming the instance with a capital letter is very confusing because it looks like a class, encouraging bugs. Consistency in naming is at the heart of good Objective-C. The compiler cannot protect you against a wide variety of mistakes because ObjC is highly dynamic. Good naming and self-discipline in consistency is what leads to bug-free Cocoa. Parallelism: Foo *foo = [Foo sharedFoo]; Foo *foo = [[[Foo alloc] init] autorelease]; Foo *foo = [Bar fooAtIndex:0]; All three of those may be legal in the same program. Just because there is a singleton instance doesn't mean that there aren't other instances, too. NSNotificationCenter is a good example of this. It's a singleton, but you can make additional instances (and there are reasons to do so). A global variable can be globally modified. A sharedInstance cannot be. For instance, if State is a global variable (rather than a class), then State=nil is legal anywhere in the program. That breaks encapsulation and is an easy typo for state=nil that cannot be caught by the compiler. If State is a class, then the compiler can catch this easy error. The many rules of Cocoa naming are there to encourage highly readable code, and to minimize bugs in a highly dynamic and loosely typed environment. Like Perl's use strict we should be very careful before giving up what little safety net we have.
