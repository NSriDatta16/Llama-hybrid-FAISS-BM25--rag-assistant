[site]: stackoverflow
[post_id]: 476399
[parent_id]: 476328
[tags]: 
OK, so I cleaned those up a little. There are three functions for three possible datatypes (which solves problem #2 automatically). I took those all from above (one for Array, one for List, one for Seq.): def filter(numbers: Seq[Double], filterSize: Int): Seq[Double] = { require(filterSize > 0) val ringBuffer = new Array[Double](filterSize) var ringBufferIndex = 0 numbers.map(x => { // update ring buffer ringBuffer(ringBufferIndex) = x // increase ring index ringBufferIndex += 1 if (ringBufferIndex == filterSize) { ringBufferIndex = 0 } // get avarage ringBuffer.foldLeft(0.0)(_ + _) / filterSize }) } def filter(numbers: Array[Double], filterSize: Int): Array[Double] = { require(filterSize > 0) (0 until numbers.length).map(x => { (((x - filterSize) max 0) to x).foldLeft(0.0)((sum, index) => sum + numbers(index)) / filterSize }).toArray } def filter(numbers: List[Double], filterSize: Int): List[Double] = { require(filterSize > 0) val ringBuffer = new Array[Double](filterSize) numbers.zipWithIndex.map(pair => { val (value, index) = pair // update ring buffer ringBuffer(index % filterSize) = value // get avarage ringBuffer.foldLeft(0.0)(_ + _) / filterSize }) }
