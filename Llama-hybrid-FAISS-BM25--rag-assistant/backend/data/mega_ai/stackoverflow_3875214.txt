[site]: stackoverflow
[post_id]: 3875214
[parent_id]: 3872996
[tags]: 
Canned answer : In all-too-many cases an indexed view may solve your short term performance goals but at some later time become counterproductive. So if you choose to use an indexed view, you may need an exit strategy. Let me describe a few common problems with indexed views. Indexed views may increase lock contention. It is very easy to demonstrate. Create the following table: CREATE TABLE dbo.ChildTable(ChildID INT NOT NULL CONSTRAINT PK_ChildTable PRIMARY KEY, ParentID INT NOT NULL, Amount INT NOT NULL); GO From one tab in SSMS, run this script: BEGIN TRAN; INSERT INTO dbo.ChildTable(ChildID, ParentID, Amount) VALUES(1,1,1); From another tab, run a similar one: BEGIN TRAN; INSERT INTO dbo.ChildTable(ChildID, ParentID, Amount) VALUES(2,1,1); ROLLBACK; Note that both inserts complete, they do not block each other. Rollback in both tabs, and create an indexed view: CREATE VIEW dbo.ChildTableTotals WITH SCHEMABINDING AS SELECT ParentID, COUNT_BIG(*) AS ChildRowsPerParent, SUM(Amount) AS SumAmount FROM dbo.ChildTable GROUP BY ParentID; GO CREATE UNIQUE CLUSTERED INDEX ChildTableTotals_CI ON dbo.ChildTableTotals(ParentID); Rerun the two inserts. Note that the second one does not complete; it is blocked. The reason is very simple: the first insert modifies the corresponding entry in the indexed view, so the insert acquires and holds a lock on it. It is just as easy to demonstrate that when you create an indexed view, deadlocks may become more likely too. Note: this is not a problem with the way indexed views are implemented. If you roll out your own summary table, and develop triggers which directly modify it to keep it up-to-date, you will encounter the same problem. Only if you don't maintain your summary table all the time, you can get around this locking problem, but a more detailed discussion of this is beyond the scope of this post. Edit: the example may look contrived to you, but the problem it demonstrates is very real and very common. Indexed views in OLTP environments are of limited use, because they seriously increase lock contention and cause many deadlocks. It is quite common that someone creates them in OLTP, but eventually drops, because they introduce more problems than they solve. There are two common way of demonstrating problems caused by concurrency - we either write loops and run them from multiple connections, or explicitly begin transactions in two or more connections. I encourage everyone to come up with a simpler way to demonstrate this problem.
