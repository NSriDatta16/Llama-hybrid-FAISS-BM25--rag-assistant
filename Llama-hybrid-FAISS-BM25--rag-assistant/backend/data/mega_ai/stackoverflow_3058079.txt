[site]: stackoverflow
[post_id]: 3058079
[parent_id]: 3057792
[tags]: 
I would probably write it like this: class Object def all_variables(root=true) vars = {} self.instance_variables.each do |var| ivar = self.instance_variable_get(var) vars[var] = [ivar, ivar.all_variables(false)] end root ? [self, vars] : vars end end def string_variables(vars, lb="\n", indent="\t", current_indent="") out = "#{vars[0].inspect}#{lb}" current_indent += indent out += vars[1].map do |var, ivar| ivstr = string_variables(ivar, lb, indent, current_indent) "#{current_indent}#{var}: #{ivstr}" end.join return out end def inspect_variables(obj, lb="\n", indent="\t", current_indent="") string_variables(obj.all_variables, lb, indent, current_indent) end The Object#all_variables method produces an array containing (0) the given object and (1) a hash mapping instance variable names to arrays containing (0) the instance variable and (1) a hash mappingâ€¦. Thus, it gives you a nice recursive structure. The string_variables function prints out that hash nicely; inspect_variables is just a convenience wrapper. Thus, print inspect_variables(foo) gives you a newline-separated option, and print inspect_variables(foo, " \n") gives you the version with HTML line breaks. If you want to specify the indent, you can do that too: print inspect_variables(foo, "\n", "|---") produces a (useless) faux-tree format instead of tab-based indenting. There ought to be a sensible way to write an each_variable function to which you provide a callback (which wouldn't have to allocate the intermediate storage); I'll edit this answer to include it if I think of something. Edit 1: I thought of something. Here's another way to write it, which I think is slightly nicer: class Object def each_variable(name=nil, depth=0, parent=nil, &block) yield name, self, depth, parent self.instance_variables.each do |var| self.instance_variable_get(var).each_variable(var, depth+1, self, &block) end end end def inspect_variables(obj, nl="\n", indent="\t", sep=': ') out = '' obj.each_variable do |name, var, depth, _parent| out += [indent*depth, name, name ? sep : '', var.inspect, nl].join end return out end The Object#each_variable method takes a number of optional arguments, which are not designed to be specified by the user; instead, they are used by the recursion to maintain state. The given block is passed (a) the name of the instance variable, or nil if the variable is the root of the recursion; (b) the variable; (c) the depth to which the recursion has descended; and (d), the parent of the current variable, or nil if said variable is the root of the recursion. The recursion is depth-first. The inspect_variables function uses this to build up a string. The obj argument is the object to iterate through; nl is the line separator; indent is the indentation to be applied at each level; and sep separates the name and the value. Edit 2: This doesn't really add anything to the answer to your question, but: just to prove that we haven't lost anything in the reimplementation, here's a reimplementation of all_variables in terms of each_variables . def all_variables(obj) cur_depth = 0 root = [obj, {}] tree = root parents = [] prev = root obj.each_variable do |name, var, depth, _parent| next unless name case depth cur_depth when -1 # We've gone back up tree = parents.pop(cur_depth - depth)[0] when +1 # We've gone down parents I feel like it ought to be shorter, but that may not be possible; because we don't have the recursion now, we have to maintain the stack explicitly (in parents ). But it is possible, so the each_variable method works just as well (and I think it's a little nicer).
