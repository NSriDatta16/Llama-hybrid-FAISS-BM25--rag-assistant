[site]: stackoverflow
[post_id]: 3753799
[parent_id]: 3753619
[tags]: 
You're right that sticking variables inside an anonymous function is a good practice to avoid cluttering up the global object. To answer your latter two questions: It's completely impossible for the interpreter to know that an object won't be used again as long as there's a globally visible reference to it. For all the interpreter knows, you could eval some code that depends on window['aVar'] or window['operation'] at any moment. Essentially, remember two things: As long as an object is around, none of its slots will be magically freed without your say-so. Variables declared in the global context are slots of the global object ( window in client-side Javascript). Combined, these mean that objects in global variables last for the lifetime of your script (unless the variable is reassigned). This is why we declare anonymous functions — the variables get a new context object that disappears as soon as the function finishes execution. In addition to the efficiency wins, it also reduces the chance of name collisions. Your second example (with the inner anonymous function) might be a little overzealous, though. I wouldn't worry about "helping the garbage collector" there — GC probably isn't going to run in the middle that function anyway. Worry about things that will be kept around persistently, not just slightly longer than they otherwise would be. These self-executing anonymous functions are basically modules of code that naturally belong together, so a good guide is to think about whether that describes what you're doing. There are reasons to use anonymous functions inside anonymous functions, though. For example, in this case: (function () { var bfa = new Array(24 * 1024*1024); var calculation = calculationFor(bfa); $('.resultShowButton').click( function () { var text = "Result is " + eval(calculation); alert(text); } ); })(); This results in that gigantic array being captured by the click callback so that it never goes away. You could avoid this by quarantining the array inside its own function.
