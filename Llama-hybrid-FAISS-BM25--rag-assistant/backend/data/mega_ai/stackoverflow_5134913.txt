[site]: stackoverflow
[post_id]: 5134913
[parent_id]: 5134217
[tags]: 
Update Check Robert Knight's answer! Uses C++11 but is much cleaner than this... Original Answer How about this nasty hack: namespace priv { #define PRIVATE_STATICMEM(_A_) \ template \ struct StaticMem { \ __declspec(align(_A_)) char data[size]; \ void *operator new(size_t parSize) { \ return _aligned_malloc(parSize,_A_); \ } \ void operator delete(void *ptr) { \ return _aligned_free(ptr); \ } \ }; template struct StaticMem {}; template struct StaticMem {char data[size];}; PRIVATE_STATICMEM(2) PRIVATE_STATICMEM(4) PRIVATE_STATICMEM(8) PRIVATE_STATICMEM(16) PRIVATE_STATICMEM(32) PRIVATE_STATICMEM(64) PRIVATE_STATICMEM(128) PRIVATE_STATICMEM(256) PRIVATE_STATICMEM(512) PRIVATE_STATICMEM(1024) PRIVATE_STATICMEM(2048) PRIVATE_STATICMEM(4096) PRIVATE_STATICMEM(8192) } template struct StaticMem : public priv::StaticMem { T *unhack() {return (T*)this;} T &unhack(size_t idx) {return *(T*)(data+idx*sizeof(T));} const T &unhack() const {return *(const T*)this;} const T &unhack(size_t idx) const {return *(const T*)(data+idx*sizeof(T));} StaticMem() {} StaticMem(const T &init) {unhack()=init;} }; Looks scary, but you need all that only once (preferably in some well hidden header file :) ). Then you can use it in the following way: StaticMem array; //allocate an uninitialized array of size N for type T array.data //this is a raw char array array.unhack() //this is a reference to first T object in the array array.unhack(5) //reference to 5th T object in the array StaticMem array; can appear in the code, but also as a member of some bigger class (that's how I use this hack) and should also behave correctly when allocated on the heap. Bug fix: Line 6 of the example: char data[_A_] corrected into char data[size]
