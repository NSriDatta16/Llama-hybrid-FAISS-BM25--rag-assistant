[site]: stackoverflow
[post_id]: 4085899
[parent_id]: 4084458
[tags]: 
You can flip the 32 bit as well: works with ASCII characters thus: char flipcase(char x) { if( ::isalpha(x) ) { return x ^ 32; } } You can also use a table. Create a static table then char flipcase( char x ) { return fliptable[x]; } The latter method having the advantage of being able to be used for foreign character sets too as long as they are not multi-byte - it won't work for that. You can make a similar table for wchar_t characters with whatever character set you are using. Storing the table requires a small amount of memory use if sizeof your character is no more than 2, although it would use too much for UTF-32 and the lookup time is trivial. Of course in reality you would store a small struct for each character with its traits. With either of the above you would use std::transform. And now the really clever bit: std::transform can use a class (functor) as well as a plain function. For multi-byte characters we can therefore store the state as long as the replacement character will always have the same first element. If that is not the case then transform won't work with the regular iterators. However you could write a custom iterator to handle multi-byte character strings that would iterate up a printable character at a time (The iterator would have to dereference to multi-byte characters representing a symbol).
