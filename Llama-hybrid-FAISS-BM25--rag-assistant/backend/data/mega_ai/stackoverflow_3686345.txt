[site]: stackoverflow
[post_id]: 3686345
[parent_id]: 
[tags]: 
Passing blocks into nested method within class_eval in Ruby?

I want to be able to define a block, and later evaluate that block from within a dynamically generated module/class. It seems like I could accomplish this somehow using eval and block.binding , but I haven't figured it out. I have this as the base: def define_module(name, &block) name = name.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase } parts = name.split("::") parts.each_with_index do |part, index| sub_name = parts[0..index].join("::") eval("module #{sub_name}; end") end clazz = eval(name) clazz.class_eval(&block) if block_given? clazz end def add_module(name, &block) module_block = block define_module(name).class_eval And I want to use it like this: add_module("My::Library") do def a_method "added 'a_method'" end end class ::User include My::Library end user = ::User.new assert_equal "added 'a_method'", user.a_method Is there any way to do something like that?
