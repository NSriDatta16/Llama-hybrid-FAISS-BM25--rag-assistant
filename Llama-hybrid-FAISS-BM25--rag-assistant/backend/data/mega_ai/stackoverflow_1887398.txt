[site]: stackoverflow
[post_id]: 1887398
[parent_id]: 
[tags]: 
C++ class hierarchy for collection providing iterators

I'm currently working on a project in which I'd like to define a generic 'collection' interface that may be implemented in different ways. The collection interface should specify that the collection has methods that return iterators by value. Using classes that wrap pointers I came up with the following (greatly simplified): Collection.h class Collection { CollectionBase *d_base; public: Collection(CollectionBase *base); Iterator begin() const; }; inline Iterator Collection::begin() const { return d_base->begin(); } CollectionBase.h class CollectionBase { public: virtual Iterator begin() const = 0; virtual Iterator end() const = 0; }; Iterator.h class Iterator { IteratorBase *d_base; public: bool operator!=(Iterator const &other) const; }; inline bool Iterator::operator!=(Iterator const &other) const { return d_base->operator!=(*other.d_base); } IteratorBase.h class IteratorBase { public: virtual bool operator!=(IteratorBase const &other) const = 0; }; Using this design, different implementations of the collection derive from CollectionBase and can return their custom iterators by returning an Iterator that wraps some specific implementation of IteratorBase . All is fine and dandy so far. I'm currently trying to figure out how to implement operator!= though. Iterator forwards the call to IteratorBase , but how should the operator be implemented there? One straightforward way would be to just cast the IteratorBase reference to the appropriate type in implementations of IteratorBase and then perform the specific comparison for the implementation of IteratorBase . This assumes that you will play nice and not pass two different types of iterators though. Another way would be to perform some type of type checking that checks if the iterators are of the same type. I believe this check will have to be made at run-time though, and considering this is an iterator I'd rather not perform expensive run time type checking in operator!= . Am I missing any nicer solutions here? Perhaps there are better alternative class designs (the current design is an adaptation from something I learned in a C++ course I'm taking)? How would you approach this? Edit: To everyone pointing me to the STL containers: I am aware of their existence. I cannot use these in all cases however, since the amounts of data I need to process are often enormous. The idea here is to implement a simple container that uses the disk as storage instead of memory.
