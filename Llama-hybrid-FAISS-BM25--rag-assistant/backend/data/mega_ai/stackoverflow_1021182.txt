[site]: stackoverflow
[post_id]: 1021182
[parent_id]: 1021125
[tags]: 
I think that you are making the problem more difficult than it has to be. Assuming that the module storageManager.lua is not itself localizing the io module, then all you need to do is to replace the global io with your mock object while running the test. If the module does localize the io object for performance, then you would need to inject the new value of io before loading the module. This might mean that you need to make the call to require part of the test case setup (and a matching cleanup that removes all traces of the module from package.loaded and _G ) so that it can be mocked differently in different test cases. WinImage Edit: By localizing a module for performance I mean the Lua idiom of copying the module's methods into local variables in the module's name space. For example: -- somemodule.lua require "io" require "math" -- copy io and math to local variables local io,math=io,math -- begin the module itself, note that package.seeall is not used so globals are -- not visible after this point module(...) function doMathAndIo() -- does something interesting here end If you do this, the references to the stock modules io and math are made at the moment that require "somemodule" is executed. Replacing either of those modules after the call to require() with a mocked version will not be effective. To effectively mock a module that is used with this idiom, you would have to have the mock object in place before the call to require() . Here is a how I would go about replacing the io object for the duration of the call in a test case: function test_load_reads_file_properly() io_mock = mc:mock() file_handle_mock = mc:mock() io_mock:open(VALID_FILENAME, "r");mc:returns(file_handle_mock) file_handle_mock:read("*all") file_handle_mock:close() mc:replay() local saved_io = _G.io _G.io = io_mock package.loaded.io = io_mock storageManager = StorageManager:new{ } storageManager:load(VALID_FILENAME) _G.io = saved_io package.loaded.io = saved_io mc:verify() end I may not be restoring the real object at exactly the right moment, and this is untested, but it should point you in the right direction.
