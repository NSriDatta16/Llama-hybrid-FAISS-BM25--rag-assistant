[site]: stackoverflow
[post_id]: 105329
[parent_id]: 28160
[tags]: 
Overwhelmed by thousands lines of code? Having one set of header/source files per class in a directory can seem overkill. And if the number of classes goes toward 100 or 1000, it can even be frightening. But having played with sources following the philosophy "let's put together everything", the conclusion is that only the one who wrote the file has any hope to not be lost inside. Even with an IDE, it is easy to miss things because when you're playing with a source of 20,000 lines, you just close your mind for anything not exactly referring to your problem. Real life example: the class hierarchy defined in those thousand lines sources closed itself into a diamond-inheritance, and some methods were overridden in child classes by methods with exactly the same code. This was easily overlooked (who wants to explore/check a 20,000 lines source code?), and when the original method was changed (bug correction), the effect was not as universal as excepted. Dependancies becoming circular? I had this problem with templated code, but I saw similar problems with regular C++ and C code. Breaking down your sources into 1 header per struct/class lets you: Speed up compilation because you can use symbol forward-declaration instead of including whole objects Have circular dependencies between classes (ยง) (i.e. class A has a pointer to B, and B has a pointer to A) In source-controlled code, class dependencies could lead to regular moving of classes up and down the file, just to make the header compile. You don't want to study the evolution of such moves when comparing the same file in different versions. Having separate headers makes the code more modular, faster to compile, and makes it easier to study its evolution through different versions diffs For my template program, I had to divide my headers into two files: The .HPP file containing the template class declaration/definition, and the .INL file containing the definitions of the said class methods. Putting all this code inside one and only one unique header would mean putting class definitions at the beginning of this file, and the method definitions at the end. And then, if someone needed only a small part of the code, with the one-header-only solution, they still would have to pay for the slower compilation. (ยง) Note that you can have circular dependencies between classes if you know which class owns which. This is a discussion about classes having knowledge of the existence of other classes, not shared_ptr circular dependencies antipattern. One last word: Headers should be self-sufficients One thing, though, that must be respected by a solution of multiple headers and multiple sources. When you include one header, no matter which header, your source must compile cleanly. Each header should be self-sufficient. You're supposed to develop code, not treasure-hunting by greping your 10,000+ source files project to find which header defines the symbol in the 1,000 lines header you need to include just because of one enum. This means that either each header defines or forward-declare all the symbols it uses, or include all the needed headers (and only the needed headers). Question about circular dependencies underscore-d asks: Can you explain how using separate headers makes any difference to circular dependencies? I don't think it does. We can trivially create a circular dependency even if both classes are fully declared in the same header, simply by forward-declaring one in advance before we declare a handle to it in the other. Everything else seems to be great points, but the idea that separate headers facilitate circular dependencies seems way off underscore_d, Nov 13 at 23:20 Let's say you have 2 class templates, A and B. Let's say the definition of class A (resp. B) has a pointer to B (resp. A). Let's also say the methods of class A (resp. B) actually call methods from B (resp. A). You have a circular dependency both in the definition of the classes, and the implementations of their methods. If A and B were normal classes, and A and B's methods were in .CPP files, there would be no problem: You would use a forward declaration, have a header for each class definitions, then each CPP would include both HPP. But as you have templates, you actually have to reproduce that patterns above, but with headers only. This means: a definition header A.def.hpp and B.def.hpp an implementation header A.inl.hpp and B.inl.hpp for convenience, a "naive" header A.hpp and B.hpp Each header will have the following traits: In A.def.hpp (resp. B.def.hpp ), you have a forward declaration of class B (resp. A), which will enable you to declare a pointer/reference to that class A.inl.hpp (resp. B.inl.hpp ) will include both A.def.hpp and B.def.hpp , which will enable methods from A (resp. B) to use the class B (resp. A). A.hpp (resp. B.hpp ) will directly include both A.def.hpp and A.inl.hpp (resp. B.def.hpp and B.inl.hpp ) Of course, all headers need to be self sufficient, and protected by header guards The naive user will include A.hpp and/or B.hpp , thus ignoring the whole mess. And having that organization means the library writer can solve the circular dependencies between A and B while keeping both classes in separate files, easy to navigate once you understand the scheme. Please note that it was an edge case (two templates knowing each other). I expect most code to not need that trick.
