[site]: crossvalidated
[post_id]: 443693
[parent_id]: 443445
[tags]: 
I want to ... uh ... "attenuate" @whuber's amazing answer, which @TomZinger says is too difficult to follow. By that I mean I want to re-describe it in terms that I think Tom Zinger will understand, because it's clearly the best answer here. And as Tom gradually uses the method and finds that he needs, say, to know the distribution of the samples rather than just their mean, whuber's answer will be just what he's looking for. In short: there are no original ideas here, only a simpler explanation. You'd like to create $n$ integers from $1$ to $4$ with mean $r$ . I'm going to suggest computing $n$ integers from $0$ to $3$ with mean $r-1$ , and then adding one to each of them. If you can do that latter thing, you can solve the first problem. For instance, if we want 10 integers between $1$ and $4$ with mean $2.6$ , we can write down these $10$ integers between $0$ and $3$ ... 0,3,2,1,3,1,2,1,3,0 whose mean is $1.6$ ; if we increase each by $1$ , we get 1,4,3,2,4,2,3,2,4,1 whose mean is $2.6$ . It's that simple. Now let's think about the numbers $0$ through $3$ . I'm going to think of those as "how many items do I have in a 'small' set?" I might have no items, one item, two items, or three items. So the list 0,3,2,1,3,1,2,1,3,0 represents ten different small sets. The first is empty; the second has three items, and so on. The total number of items in all the sets is the sum of the ten numbers, i.e., $16$ . And the average number of items in each set is this total, divided by $10$ , hence $1.6$ . whuber's idea is this: suppose you make yourself ten small sets, with the total number of items being $10t$ for some number $t$ . Then the average size of the sets will be exactly $t$ . In the same way, if you make yourself $n$ sets with a total number of items being $nt$ , the average number of items in a set will be $t$ . You say you're interested in the case $n = 100$ . Let's make this concrete for your example: you want 100 items between 1 and 4 whose average is $1.9$ . Using the idea of my first paragraph, I'm going to change this to "make $100$ ints between $0$ and $3$ whose average is $0.9$ ". When I'm done, I'll add $1$ to each of my ints to get a solution to your problem. So my target average is $t = 0.9$ . I want to make $100$ sets, each with between $0$ and $3$ items in it, with an average set-size of $0.9$ . As I've observed above, this means that there have to be a total of $100 \cdot 0.9 = 90$ items in the sets. From the numbers $1, 2, \ldots, 300$ , I'm going to select exactly $90$ . I can indicate the selected ones by making a list of 300 dots and Xs: ..X....X...XX... where the list above indicates that I selected the numbers 3, 9, 13, 14, and then many others that I haven't shown because I got sick of typing. :) I can take this sequence of 300 dots and Xs and break it into three groups of 100 dots each, which I arrange one atop the other, getting something that looks like this: ...X....X..X.....X... .X...X.....X...X..... ..X...X.X..X......X.. but goes on for a full 100 items in each row. The number of Xs in each row might differ -- there might be 35 in the first row, 24 in the second, and 31 in the third, for instance, and that's OK. [Thanks to whuber for pointing out that I had this wrong in a first draft!] Now look at each column : each column can be considered as a set, and that set has between 0 and 3 "X"s in it. I can write the tallies below the rows to get something like this: ...X....X..X.....X... .X...X.....X...X..... ..X...X.X..X......X.. 011101102003000101100 That is to say, I've produced 100 numbers, each between 1 and 3. And the sum of those 100 numbers must be the number of Xs, total, in all three rows, which was 90. So the average must be $90/100 = 0.9$ , as desired. So here are the steps to getting 100 integers between 1 and 4 whose average is exactly $s$ . Let $t = s - 1$ . Compute $k = 100 t$ ; that's how many Xs we'll place in the rows, total. Make a list of 300 dots-or-Xs, $k$ of which are Xs. Split this into three rows of 100 dots-or-Xs, each containing about a third of the Xs, more or less. Arrange these in an array, and compute column sums, getting 100 integers between $0$ and $3$ . Their average will be $t$ . Add one to each column sum to get 100 integers between $1$ and $4$ whose average is $s$ . Now the tricky part of this is really in step 4: how do you pick $300$ items, $k$ of which are "X" and the other $300-k$ of which are "."? Well, it turns out that R has a function that does exactly that. And then whuber tells you how to use it: you write tabulate(sample.int((k-1)*n, s-n) %% n + 1, n) For your particular case, $n = 100$ , and $s$ , the total number of items in all the small sets, is $100r$ , and you want numbers between $1$ and $4$ , so $k = 4$ , so $k-1$ (the largest size for a 'small set') is 3, so this becomes tabulate(sample.int(3*100, 100r-100) %% 100 + 1, n) or tabulate(sample.int(3*100, 100*(r-1)) %% 100 + 1, 100) or, using my name $t$ for $r - 1$ , it becomes tabulate(sample.int(3*100, 100*t) %% 100 + 1, 100) The "+1" at the end of his original formula is exactly the step needed to convert from "numbers between $0$ and $3$ " to "numbers between $1$ and $4$ ". Let's work from the inside out, and let's simplify to $n = 10$ so that I can show sample outputs: tabulate(sample.int(3*10, 10*t) %% 10 + 1, 10) And let's aim for $t = 1.9$ , so this becomes tabulate(sample.int(3*10, 10*1.9) %% 10 + 1, 10) Starting with sample.int(3*10, 10*1.9) : this produces a list of $19$ integers between $1$ and $30$ . (i.e., it solved the problem of picking $k$ numbers out of your total -- $300$ in your real problem, $30$ in my smaller example). As you'll recall, we want to produce three rows of ten dots-and-Xs each, something like X.X.XX.XX. XXXX.XXX.. XX.X.XXX.. We can read this left-to-right-top-to-bottom (i.e., normal reading order) to produce a list of locations for Xs: the first item's a dot; the second and third are Xs, and so on, so our list of locations starts out $1, 3, 5, 6, \ldots$ . When we get to the end of a row, we just keep counting up, so for the picture above, the X-locations would be $1, 3, 5, 6, 8, 9, 11, 12, 13, 14, 16, 17, 18, 21, 22, 24, 26, 27, 28$ . Is that clear? Well, whubers code produces exactly that list of locations with its innermost section. The next item is %% 10 ; that takes a number and produces its remainder on division by ten. So our list becomes $1, 3, 5, 6, 8, 9, 1, 2, 3, 4, 6, 7, 8, 1, 2, 4, 6, 7, 8$ . If we break that into three groups --- those that came from numbers between $1$ and $10$ , those that came from numbers from $11$ to $20$ , and those that came from numbers $21$ to $30$ , we get $1, 3, 5, 6, 8, 9$ , then $1, 2, 3, 4, 6, 7, 8,$ , and finally $1, 2, 4, 6, 7, 8$ . Those tell you where the Xs in each of the three rows are. There's a subtle problem here: if there had been an X in position 10 in the first row, the first of our three lists would have been $1, 3, 5, 6, 8, 9, 0$ , and the tabulate function doesn't like "0". So whuber adds 1 to each item in the list to get $2, 4, 6, 7, 9, 10, 1$ . Let's move on to the overall computation: tabulate(sample.int(3*10, 10*1.9) %% 10 + 1, 10) This asks "for those $30$ numbers, each indicating whether there's an X in some column, tell me how many times each column (from $1$ to $10$ --- that's what the final "10" tells you) appears, i.e., tell me how many Xs are in each column. The result is 0 3 2 2 2 1 3 2 3 1 which (because of the shift-by-one thing) you have to read as "there are no Xs in the 10th column; there are 3 Xs in the first column; there are 2 Xs in the second column," and so on up to "there is one X in the 9th column". That gives you ten integers between $0$ and $3$ whose sum is $19$ , hence whose average is $1.9$ . If you increase each by 1, you get ten integers between $1$ and $4$ whose sum is $29$ , hence an average value of $2.9$ . You can generalize to $n = 100$ , I hope.
