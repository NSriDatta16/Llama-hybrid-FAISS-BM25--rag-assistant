[site]: stackoverflow
[post_id]: 5513177
[parent_id]: 5510591
[tags]: 
You could try something like this: using System; using System.Text.RegularExpressions; static class Program { static void Main(params string[] args) { string text = @"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodo consequat."; ExtractParagraph(text, "magna"); ExtractParagraph(text, "ipsum"); ExtractParagraph(text, "ut"); } static void ExtractParagraph(string text, string word) { Console.WriteLine("Matches for: {0}", word); string expression = @"((^.{0,30}|\w*.{30})\b" + word + @"\b(.{30}\w*|.{0,30}$))"; Regex wordMatch = new Regex(expression, RegexOptions.IgnoreCase | RegexOptions.Singleline); foreach (Match m in wordMatch.Matches(text)) { Console.WriteLine(" {0}", m.Value); } } } The basic idea is to match extra stuff around the word: .*{30}\bword\b.*{30} and then add some "word characters" not to cut the word in half: \w*.*{30}\bword\b.*{30}\w* . The pieces like ^.{0,30} and . .{0,30}$ are to match even if there are less than 30 characters from the beginning or end of the sentence. As always with regular expressions, this is unlikely to win a readability contest, but it seems to work...
