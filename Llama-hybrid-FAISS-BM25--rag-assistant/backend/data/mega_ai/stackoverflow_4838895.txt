[site]: stackoverflow
[post_id]: 4838895
[parent_id]: 4797486
[tags]: 
I think your first paragraph is wrong. And I think your edit doesn't change that. Assuming you are requiring that the observed behaviour of an implementation conforms to the time complexity of the algorithm, then... When calculating the complexity of an algorithm assumptions are made about what operations are constant time. These assumptions are where you're going to find your clues. Some of the more common assumptions are things like constant time array access, function calls, and arithmetic operations. If you cannot provide those operations in a language in constant time you cannot reproduce the algorithm in a way that preserves the time complexity. Reasonable languages can break those assumptions, and sometimes have to if they want to deal with, say, immutable data structures with shared state, concurrency, etc. For example, Clojure uses trees to represent Vectors. This means that access is not constant time (I think it's log32 of the size of the array, but that's not constant even though it might as well be). You can easily imagine a language having to do complicated stuff at runtime when calling a function. For example, deciding which one was meant. Once upon a time floating point and multi-word integer multiplication and division were sadly not constant time (they were implemented in software). There was a period during which languages transitioned to using hardware when very reasonable language implementations behaved very differently. I'm also pretty sure you can come up with algorithms that fare very poorly in the world of immutable data structures. I've seen some optimisation algorithms that would be horribly difficult, maybe impossible or effectively so, to implement while dealing immutability without breaking the time complexity. For what it's worth, there are algorithms out there that assume set union and intersection are constant time... good luck implementing those algorithms in constant time. There are also algorithms that use an 'oracle' that can answer questions in constant time... good luck with those too.
