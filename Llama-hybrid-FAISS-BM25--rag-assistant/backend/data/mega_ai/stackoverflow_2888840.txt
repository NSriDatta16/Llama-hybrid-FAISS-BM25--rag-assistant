[site]: stackoverflow
[post_id]: 2888840
[parent_id]: 2888749
[tags]: 
Hmmm... Of course, you can do this. What you're talking about doing is stepping back in time to the period before the RDBMS became successful. This isn't hard to do but you might well take some lessons learned: Before you begin coding - or, at least, before you write data-access code, do your database design as if you were going to use a database - what data do you need? Can you reduce the number of attributes ("fields") you need? What are the commonalities among media types in your library? etc. Consider use of directory trees and file names as a bit of an ad-hoc storage structure. This will put the data directly into the hands of command-line utilities, should you need or want to manage the data beyond your program's present abilities. For example, books might all be in a books subdirectory, and within that, you might use ISBN or title as the file name. I look for things that will naturally sort as a file name using ls, dir, or whatever your CLI uses. Another good choice would be to put it in an XML format. Possibly both - use a directory hierarchy for the overall data layout and put the library entry data in flat files in an XML format. This could turn out to be handy at some point. Put the data ONLY in plain text format as strings - no binary data! This is important, again, for being able to access / manipulate the data outside your program. With such a strategy, you can use system tools like grep, sed, lex and so forth to do completely unplanned things with the data, should the need arise. Have a feature - or write a separate reader program - that walks your "database" and outputs its entire contents as plain text, one line per entry. You might well have options that tell it what kind of media to output, etc. Also, include a flag that lets you set the delimiter used between attributes for output - comma separated is a common choice, but you might also just want a space, a carrage return, new line, or whatever else. If you make it an optional flag to let the user use anything and provide your favorite default, it should be fine. Modularize your code so you can replace your storage strategy later if you so choose and not have to re-hack the whole program. You might even provide multiple storage strategies. This ought to do it. Note that the amount of data you will be managing, with modern computer hardware, is not likely to ever become a performance or space issue, so don't worry about saving a few bytes - it's not worth the hassle. Good luck, and enjoy the ride.
