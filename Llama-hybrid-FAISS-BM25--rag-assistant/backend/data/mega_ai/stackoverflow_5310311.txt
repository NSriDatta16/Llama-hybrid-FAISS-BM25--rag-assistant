[site]: stackoverflow
[post_id]: 5310311
[parent_id]: 5296110
[tags]: 
I wouldn't care about using exclusively CharMatcher if I were you. In fact I don't care about using exclusively Guava, but I care about the excellent design Guava tries to enforce. If guava can't help you here, just use what you can use. It's not because we use Guava that we have no right to look at other components. If regex are what you need and Guava offers no suitable alternative, then you have all reasons in the world to continue using regex. Obviously, you might want to encapsulate this in specific methods/classes to make it reusable a la guava. All I'd care about is that the code is readable enough as well as efficient. For instance, don't use String#replaceAll() , but compile a j.u.regex.Pattern and reuse that pattern and use Pattern#matcher() and Matcher#replaceAll(String) . Example: public class Regexes { public static Function replaceAll(String pattern,final String replacement) { final Pattern p = Pattern.compile(pattern); return new Function () { public String apply(String input) { return p.matcher(input).replaceAll(replacement); } }; } // end replace(String, String) } // end class ... private static final Function myTransformer = Regexes.replaceAll("['\\\\]", "\\\\$0"); This is not a Guava solution (even if there is a Function in it), but it's the most Guava-like solution I could come up to and you still clearly indicate it's a regex (where String#replaceAll(String,String) doesn't.
