[site]: stackoverflow
[post_id]: 3874750
[parent_id]: 3874199
[tags]: 
I don't think there is a particular standard way of doing it but I thought I would throw in a possible method. I work in Oracle and our in-house web application framework that utilizes XML for storing application data. We use something called a Master - Detail model that at it's simplest consists of: Master Table for example called Widgets often just containing an ID. Will often contain data that won't change over time / isn't historical. Detail / History Table for example called Widget_Details containing at least: ID - primary key. Detail/historical ID MASTER_ID - for example in this case called 'WIDGET_ID', this is the FK to the Master record START_DATETIME - timestamp indicating the start of that database row END_DATETIME - timestamp indicating the end of that database row STATUS_CONTROL - single char column indicated status of the row. 'C' indicates current, NULL or 'A' would be historical/archived. We only use this because we can't index on END_DATETIME being NULL CREATED_BY_WUA_ID - stores the ID of the account that caused the row to be created XMLDATA - stores the actual data So essentially, a entity starts by having 1 row in the master and 1 row in the detail. The detail having a NULL end date and STATUS_CONTROL of 'C'. When an update occurs, the current row is updated to have END_DATETIME of the current time and status_control is set to NULL (or 'A' if preferred). A new row is created in the detail table, still linked to the same master, with status_control 'C', the id of the person making the update and the new data stored in the XMLDATA column. This is the basis of our historical model. The Create / Update logic is handled in an Oracle PL/SQL package so you simply pass the function the current ID, your user ID and the new XML data and internally it does all the updating / inserting of rows to represent that in the historical model. The start and end times indicate when that row in the table is active for. Storage is cheap, we don't generally DELETE data and prefer to keep an audit trail. This allows us to see what our data looked like at any given time. By indexing status_control = 'C' or using a View, cluttering isn't exactly a problem. Obviously your queries need to take into account you should always use the current (NULL end_datetime and status_control = 'C') version of a record.
