[site]: stackoverflow
[post_id]: 2333566
[parent_id]: 2333364
[tags]: 
In C, you can read to any address that is mapped, you can also write to any address that is mapped to a page with read-write areas. In practice, the OS gives a process memory in chunks (pages) of normally 8K (but this is OS-dependant). The C library then manages these pages and maintains lists of what is free and what is allocated, giving the user addresses of these blocks when asked to with malloc. So when you get a pointer back from malloc(), you are pointing to an area within an 8k page that is read-writable. This area may contain garbage, or it contain other malloc'd memory, it may contain the memory used for stack variables, or it may even contain the memory used by the C library to manage the lists of free/allocated memory! So you can imagine that writing to addresses beyond the range you have malloc'ed can really cause problems: Corruption of other malloc'ed data Corruption of stack variables, or the call stack itself, causing crashes when a function return's Corruption of the C-library's malloc/free management memory, causing crashes when malloc() or free() are called All of which are a real pain to debug, because the crash usually occurs much later than when the corruption occurred. Only when you read or write from/to the address which does not correspond to a mapped page will you get a crash... eg reading from address 0x0 (NULL) Malloc, Free and pointers are very fragile in C (and to a slightly lesser degree in C++), and it is very easy to shoot yourself in the foot accidentally There are many 3rd party tools for memory checking which wrap each memory allocation/free/access with checking code. They do tend to slow your program down, depending on how much checking is applied..
