[site]: stackoverflow
[post_id]: 2803937
[parent_id]: 2803591
[tags]: 
I've found out the solution - albeit, it's not as simple, or elegant as I would have liked. The solution is to use a secondary thread that pauses only for a moment before executing. ie. public partial class Navigation : UserControl { public Navigation() { ParentMenuBtn.Click += delegate { SubMenu.Visibility = (SubMenu.Visibility == Visibility.Visible) ? Visibility.Collapsed : Visibility.Visible; }; ParentMenuBtn.LostFocus += delegate(object sender, RoutedEventArgs e) { HideSubMenu(SubMenu); }; SubMenuBtn.Click += delegate { //Sub Menu Button actions... }; private void HideSubMenu(UIElement subMenu) { //Get the Main Page App app = (App)Application.Current; MainPage mainPage = (MainPage)app.RootVisual; Thread thread = new Thread(Navigation.HideSubMenu); thread.Start(new ThreadState(mainPage, subMenu)); } private static void HideSubMenu(object threadStateObj) { ThreadState threadState = (ThreadState)threadStateObj; //Execute after 5 milliseconds... System.Threading.Thread.Sleep(5); threadState.MainPage.Dispatcher.BeginInvoke(delegate() { threadState.TargetElement.Visibility = Visibility.Collapsed; }); } I just use a simple object called ThreadState to handle all the state objects I want to preserve: public class ThreadState { public MainPage MainPage = null; public UIElement TargetElement = null; public ThreadState(MainPage mainPage, UIElement targetElement) { this.MainPage = mainPage; this.TargetElement = targetElement; } }
