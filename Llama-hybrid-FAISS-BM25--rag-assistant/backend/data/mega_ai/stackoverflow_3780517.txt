[site]: stackoverflow
[post_id]: 3780517
[parent_id]: 3718967
[tags]: 
It is working as expected now and the ViewDatas are accessible from any controller/view. First I created a public class where I store my Windsor container so it can be accessed from any controller: public static class IOCcontainer { public static IWindsorContainer Container { get; set; } } Then in my global.asax.cs I have: protected void Application_Start() { AreaRegistration.RegisterAllAreas(); RegisterRoutes(RouteTable.Routes); InitializeContainer(); } private void InitializeContainer() { _container = new WindsorContainer(); // Register context manager. _container.Register( Component.For () .ImplementedBy () .LifeStyle.Singleton .Parameters( Parameter.ForKey("connectionString").Eq(ConfigurationManager.ConnectionStrings["ProvidersConnection"].ConnectionString) ) ); //Products repository _container.Register( Component.For () .ImplementedBy () .LifeStyle.Singleton ); // Register all MVC controllers _container.Register(AllTypes.Of () .FromAssembly(Assembly.GetExecutingAssembly()) .Configure(c => c.LifeStyle.Transient) ); IOCcontainer.Container = _container; //set the container class with all the registrations ControllerBuilder.Current.SetControllerFactory(new WindsorControllerFactory(_container)); } So now in my master controller I can use: public class MasterController : Controller { private IProductRepository g_productRepository; public MasterController() : this(null,null,null,null,null) { } public MasterController(IProductRepository productRepository) { g_productRepository = productRepository ?? IOCcontainer.Container.Resolve (); } //I don't use an action here, this will make execute it for any action in any controller protected override void OnActionExecuting(ActionExecutingContext context) { if (!(context.ActionDescriptor.ActionName.Equals("Index") && context.Controller.ToString().IndexOf("Home")>0)) { //I now can use this viewdata to populate a dropdownlist along the whole application ViewData["products"] = g_productRepository.GetProducts().ToList().SelectFromList(x => x.Id.ToString(), y => y.End.ToShortDateString()); } } } Then the rest of controllers: //will be based on MasterController public class AboutController : MasterController { } public ActionResult Index() { return View(); } etc... Probably not the most elegant way to do it but it will do until I find a better way or someone else brighten my mind up!
