[site]: stackoverflow
[post_id]: 1629619
[parent_id]: 
[tags]: 
Account memory usage with custom allocator

I'm using a custom allocator to account for memory usage in several containers. Currently I use a static variable to account for the memory usage. How could I separate this account across several containers without having to rewrite the allocator to use different static variables? static size_t allocated = 0; template class accounting_allocator { public: // type definitions typedef T value_type; typedef T* pointer; typedef const T* const_pointer; typedef T& reference; typedef const T& const_reference; typedef std::size_t size_type; typedef std::ptrdiff_t difference_type; //static size_t allocated; // rebind allocator to type U template struct rebind { typedef accounting_allocator other; }; // return address of values pointer address (reference value) const { return &value; } const_pointer address (const_reference value) const { return &value; } /* constructors and destructor * - nothing to do because the allocator has no state */ accounting_allocator() throw() { } accounting_allocator(const accounting_allocator&) throw() { } template accounting_allocator (const accounting_allocator &) throw() { } ~accounting_allocator() throw() { } // return maximum number of elements that can be allocated size_type max_size () const throw() { // std::cout ::max() / sizeof(T); } // allocate but don't initialize num elements of type T pointer allocate (size_type num, const void* = 0) { // print message and allocate memory with global new //std::cerr ~T(); } // deallocate storage p of deleted elements void deallocate (pointer p, size_type num) { // print message and deallocate memory with global delete #if 0 std::cerr class accounting_allocator { public: typedef size_t size_type; typedef ptrdiff_t difference_type; typedef void* pointer; typedef const void* const_pointer; typedef void value_type; template struct rebind { typedef allocator other; }; }; // return that all specializations of this allocator are interchangeable template bool operator== (const accounting_allocator &, const accounting_allocator &) throw() { return true; } template bool operator!= (const accounting_allocator &, const accounting_allocator &) throw() { return false; }
