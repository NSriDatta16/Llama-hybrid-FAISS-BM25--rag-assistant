[site]: stackoverflow
[post_id]: 2181848
[parent_id]: 2175117
[tags]: 
The Java classloader mechanism is powerful because it provides an abstraction point at exactly the point where code is loaded, which lets you do things such as: finding the class bits someplace other than the classpath (db, remote url, file system, etc) loading source code you just created and compiled yourself (with the javac api) loading byte code you just generated yourself (say with ASM) loading code and MODIFYING it before you use it (with ASM, Java agents, etc etc) RE-load code on the fly chain loaders together in trees (normal delegation) or webs (sibling-based OSGi style) or whatever you want On the point of modifying code during load, there are a world of interesting things you can do to remix your code - AOP, profiling, tracing, behavior modifications, etc. At Terracotta we relied on the classloader abstraction to dynamically load a class, then intercept all access to fields and dynamically add the ability to load state from the same object at a remote node in the cluster later. Cool stuff.
