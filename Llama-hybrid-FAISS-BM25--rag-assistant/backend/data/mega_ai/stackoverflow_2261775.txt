[site]: stackoverflow
[post_id]: 2261775
[parent_id]: 2261366
[tags]: 
I learnt a lot writing my reply to a similar question by the same author, so I couldn't resist to do the same here. In short, I've written a benchmark to compare the following approaches to the problem of storing heterogeneous elements in a standard container: Make a class for each type of element and have them all inherit from a common base and store polymorphic base pointers in a std::vector > . This is probably the more general and flexible solution: struct Shape { ... }; struct Point : public Shape { ... }; struct Circle : public Shape { ... }; std::vector > shapes; shapes.push_back(new Point(...)); shapes.push_back(new Circle(...)); shapes.front()->draw(); // virtual call Same as (1) but store the polymorphic pointers in a boost::ptr_vector . This is a bit less general because the elements are owned exclusively by the vector, but it should suffice most of the times. One advantage of boost::ptr_vector is that it has the interface of a std::vector (without the *), so its simpler to use. boost::ptr_vector shapes; shapes.push_back(new Point(...)); shapes.push_back(new Circle(...)); shapes.front().draw(); // virtual call Use a C union that can contain all possible elements and then use a std::vector . This is not very flexible as we need to know all element types in advance (they are hard-coded into the union) and also unions are well known for not interacting nicely with other C++ constructs (for example, the stored types can't have constructors). struct Point { ... }; struct Circle { ... }; struct Shape { enum Type { PointShape, CircleShape }; Type type; union { Point p; Circle c; } data; }; std::vector shapes; Point p = { 1, 2 }; shapes.push_back(p); if(shapes.front().type == Shape::PointShape) draw_point(shapes.front()); Use a boost::variant that can contain all possible elements and then use a std::vector . This is not very flexible like the union but the code to deal with it is much more elegant. struct Point { ... }; struct Circle { ... }; typedef boost::variant Shape; std::vector shapes; shapes.push_back(Point(1,2)); draw_visitor(shapes.front()); // use boost::static_visitor Use boost::any (which can contain anything) and then a std::vector . That is very flexible but the interface is a little clumsy and error prone. struct Point { ... }; struct Circle { ... }; typedef boost::any Shape; std::vector shapes; shapes.push_back(Point(1,2)); if(shapes.front().type() == typeid(Point)) draw_point(shapes.front()); This is the code of the full benchmark program (doesn't run on codepad for some reason). And here are my performance results: time with hierarchy and boost::shared_ptr: 0.491 microseconds time with hierarchy and boost::ptr_vector: 0.249 microseconds time with union: 0.043 microseconds time with boost::variant: 0.043 microseconds time with boost::any: 0.322 microseconds My conclusions: Use vector > only if you need the flexibility provided by runtime polymorphism and if you need shared ownership. Otherwise you'll have significant overhead. Use boost::ptr_vector if you need runtime polymorphism but don't care about shared ownership. It will be significantly faster than the shared_ptr counterpart and the interface will be more friendly (stored elements not presented like pointers). Use boost::variant if you don't need much flexibility (i.e. you have a small set of types which will not grow). It will be lighting fast and the code will be elegant. Use boost::any if you need total flexibility (you want to store anything). Don't use unions. If you really need speed then boost::variant is as fast. Before I finish I want to mention that a vector of std::unique_ptr will be a good option when it becomes widely available (I think it's already in VS2010)
