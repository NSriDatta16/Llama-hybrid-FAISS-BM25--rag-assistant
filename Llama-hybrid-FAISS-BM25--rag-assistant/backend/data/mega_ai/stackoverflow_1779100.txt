[site]: stackoverflow
[post_id]: 1779100
[parent_id]: 1779035
[tags]: 
There is no universal 'best' way to thread work. You just have to try different ways of doing things, I'm afraid. I particularly like Jeremy D. Miller's continuation idea described at this page (scroll down to find the "continuations" section). It's really elegant and means writing very little boilerplate code. Basically, when you call "ExecuteWithContinuation" with a Func argument, the function is executed asynchronously, then returns an action when it finishes. The action is then marshalled back onto your UI thread to act as a continuation. This allows you to quickly split your operations into two bits: Perform long running operation that shouldn't block the UI ... when finished, update the UI on the UI thread It takes a bit of getting used to, but it's pretty cool. public class AsyncCommandExecutor : ICommandExecutor { private readonly SynchronizationContext m_context; public AsyncCommandExecutor(SynchronizationContext context) { if (context == null) throw new ArgumentNullException("context"); m_context = context; } public void Execute(Action command) { ThreadPool.QueueUserWorkItem(o => command()); } public void ExecuteWithContinuation(Func command) { ThreadPool.QueueUserWorkItem(o => { var continuation = command(); m_context.Send(x => continuation(), null); }); } } You'd then use it like this (forgive the formatting...) public void DoSomethingThatTakesAgesAndNeedsToUpdateUiWhenFinished() { DisableUi(); m_commandExecutor.ExecuteWithContinuation( () => { // this is the long-running bit ConnectToServer(); // This is the continuation that will be run // on the UI thread return () => { EnableUi(); }; }); }
