[site]: datascience
[post_id]: 93704
[parent_id]: 93516
[tags]: 
KNeighborsTransformer only gives you the indices of the nearest neighbors and the distances. You need to do more work to retrieve the points to fit your linear regression. Here's a draft that appears to be working: from sklearn.neighbors import NearestNeighbors from sklearn.base import RegressorMixin, BaseEstimator, clone from sklearn.linear_model import Lasso from sklearn.utils import check_X_y import numpy as np class LocalLinearRegressor(RegressorMixin, BaseEstimator): def __init__(self, n_neighbors=10, linear_model=Lasso()): self.n_neighbors = n_neighbors self.linear_model = linear_model def fit(self, X, y=None): "Fits the neighbors search." X, y = check_X_y(X, y) self._fit_X = X self._fit_y = y self.neighbor_search = NearestNeighbors(n_neighbors=self.n_neighbors) self.neighbor_search.fit(X) self.local_regressors_ = {} return self def predict(self, X): """Fits linear regressions on the k nearest training points to predict new values. We don't fit these linear regressions at fit time because there would be so many. However, we do save the regressions as we see them to speed up predictions. """ neighbors = self.neighbor_search.kneighbors(X, return_distance=False) ksets, mapper = np.unique(neighbors, return_inverse=True, axis=0) for kset in ksets: if tuple(kset) in self.local_regressors_: continue local_X = self._fit_X[kset, :] local_y = self._fit_y[kset] self.local_regressors_[tuple(kset)] = clone(self.linear_model).fit(local_X, local_y) return np.array([ self.local_regressors_[tuple(ksets[mapper[i]])].predict(X[i, :].reshape(1, -1))[0] for i in range(X.shape[0]) ]) And here's a Colab notebook showing it in action.
