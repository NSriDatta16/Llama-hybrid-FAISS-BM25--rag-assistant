[site]: stackoverflow
[post_id]: 3436194
[parent_id]: 
[tags]: 
How to find the mean/average of a sound in Nyquist

I'm trying to write a simple measurement plug-in for Audacity and it's about as much fun as pounding rocks against my skull. All I want to do is take a chunk of audio and find the average of all the samples (the chunk's DC offset ) so that I can present it as a number to the user, and so that I can subtract the DC offset from the samples for further processing. I know and understand the math I want to do, but I don't understand how to do it in Lisp/XLisp/Nyquist/whatever. Background information in this thread As far as I know, there is no function to do this. For some reason, the snd-avg function does not actually compute the average of the sound, as you might expect. It does the absolute value first, and then computes the average computes the average and then does the absolute value. Even though there's a separate snd-abs function that could do it. >:( So I guess I have to write my own? This means converting a sound into an array and then computing the average of that? (snd-fetch-array sound len step) Reads sequential arrays of samples from sound, returning either an array of FLONUMs or NIL when the sound terminates. (snd-samples sound limit) Converts the samples into a lisp array. Nyquist Functions And there's not even an average function, so I'll have to do a sum myself, too? But the math functions only work on lists? So I need to convert the array into a list? And this will also use up a huge amount of memory for longer waveforms (18 bytes per sample), so it would be best to process it in chunks and do a cumulative average . But I don't even know how to do the unoptimized version. No, (hp s 0.1) won't work, since: I want to remove DC only, and keep arbitrarily low frequencies. 0.01 Hz should pass through unchanged, DC should be removed. The high-pass filter is causal and the first samples of the waveform remain unchanged, no matter what knee frequency you use, making it useless for measuring peak samples, etc.
