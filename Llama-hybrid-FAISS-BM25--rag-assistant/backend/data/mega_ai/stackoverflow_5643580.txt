[site]: stackoverflow
[post_id]: 5643580
[parent_id]: 5598388
[tags]: 
Your server side code looks fine, but Sixto is right about standard channel factories. Luckily, you can request a security token from ACS yourself using a WSTrustChannelFactory. In the context of your sample, your code would look like this: // // Get the token from ACS // WSTrustChannelFactory trustChannelFactory = new WSTrustChannelFactory( Bindings.CreateAcsCertificateBinding(), new EndpointAddress( acsCertificateEndpoint ) ); trustChannelFactory.Credentials.ClientCertificate.Certificate = GetClientCertificateWithPrivateKey(); RequestSecurityToken rst = new RequestSecurityToken() { RequestType = RequestTypes.Issue, AppliesTo = new EndpointAddress( new Uri( "urn:federation:customer:222:agent:11" ) ), KeyType = KeyTypes.Symmetric }; WSTrustChannel wsTrustChannel = (WSTrustChannel)trustChannelFactory.CreateChannel(); SecurityToken token = wsTrustChannel.Issue( rst ); // // Call StringService, authenticating with the retrieved token // WS2007FederationHttpBinding binding = new WS2007FederationHttpBinding( WSFederationHttpSecurityMode.Message ); binding.Security.Message.EstablishSecurityContext = false; binding.Security.Message.NegotiateServiceCredential = false; ChannelFactory factory = new ChannelFactory ( binding, new EndpointAddress( new Uri( ServiceAddress ), EndpointIdentity.CreateDnsIdentity(GetServiceCertificateSubjectName()) ) ); factory.ConfigureChannelFactory (); factory.Credentials.SupportInteractive = false; factory.Credentials.ServiceCertificate.DefaultCertificate = GetServiceCertificate(); IStringService channel = factory.CreateChannelWithIssuedToken ( token ); string reversedString = channel.Reverse( "string to reverse" );
