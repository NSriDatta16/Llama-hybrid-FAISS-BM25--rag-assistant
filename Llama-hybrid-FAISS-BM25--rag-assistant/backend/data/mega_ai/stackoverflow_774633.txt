[site]: stackoverflow
[post_id]: 774633
[parent_id]: 774426
[tags]: 
I wrote this before your clarifying comment so it probably isn't quite is applicable. I'm not sure if a lookup table approach is possible or not. If you really don't need arbitrary precision, then take advantage of the runtime. If a C/C++ solution is acceptable, I believe that the following is what you are looking for is something like the following. It probably contains bugs in edge cases, but it does compile and work as expected at least for positive numbers. Making it really work is an exercise for the reader. /* * NAME * convert_num - convert a numerical string (str) of base (b) to * a printable binary representation * SYNOPSIS * int convert_num(char const* s, int b, char** o) * DESCRIPTION * Generates a printable binary representation of an input number * from an arbitrary base. The input number is passed as the ASCII * character string `s'. The input string consists of characters * from the ASCII character set {'0'..'9','A'..('A'+b-10)} where * letter characters may be in either upper or lower case. * RETURNS * The number of characters from the input string `s' which were * consumed by this operation. The output string is placed into * newly allocated storage which is pointed to by `*o' upon successful * completion. An error is signalled by returning `-1'. */ int convert_num(char const *str, int b, char **out) { int rc = -1; char *endp = NULL; char *outp = NULL; unsigned long num = strtoul(str, &endp, b); if (endp != str) { /* then we have some numbers */ int numdig = -1; rc = (endp - str); /* we have this many base `b' digits! */ frexp((double)num, &numdig); /* we need this many base 2 digits */ if ((outp=malloc(numdig+1)) == NULL) { return -1; } *out = outp; /* return the buffer */ outp += numdig; /* make sure it is NUL terminated */ *outp-- = '\0'; while (numdig-- != 0) { /* fill it in from LSb to MSb */ *outp-- = ((num & 1) ? '1' : '0'); num >>= 1; } } return rc; }
