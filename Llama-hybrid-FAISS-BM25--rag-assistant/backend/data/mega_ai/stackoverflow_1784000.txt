[site]: stackoverflow
[post_id]: 1784000
[parent_id]: 1783822
[tags]: 
Everybody loves their micro-optimizations, but this would not make a difference as far as I can see. I compiled the two variations with g++ on for Intel processors without any fancy optimizations and the results are for for(int i = 0; i movl $0, -12(%ebp) jmp L2 L3: leal -12(%ebp), %eax incl (%eax) L2: cmpl $4, -12(%ebp) jle L3 for(int i = 0; i != 5; ++i) movl $0, -12(%ebp) jmp L7 L8: leal -12(%ebp), %eax incl (%eax) L7: cmpl $5, -12(%ebp) jne L8 I think jle and jne should translate to equally fast instructions on most architectures. So for performance, you should not distinguish between the two. In general, I would agree that the first one is a little safer and I also think more common. EDIT (2 years later): Since this thread recently got again a lot of attention, I would like to add that it will be difficult to answer this question generally. Which versions of code are more efficient is specifically not defined by the C-Standard [PDF] (and the same applies to C++ and probably also for C# ). Section 5.1.2.3 Program execution ยง1 The semantic descriptions in this International Standard describe the behavior of an abstract machine in which issues of optimization are irrelevant. But it is reasonable to assume that a modern compiler will produce equally efficient code and I think that in only very rare cases will the loop-test and the counting expression be the bottleneck of a for-loop. As for taste, I write for(int i = 0; i
