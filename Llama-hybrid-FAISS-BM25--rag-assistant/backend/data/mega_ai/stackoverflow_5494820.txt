[site]: stackoverflow
[post_id]: 5494820
[parent_id]: 2426113
[tags]: 
i find %lu to be the only C89-compliant (or, gcc-c89-warnings-compliant) format for size_t , on linux. under glibc, size_t seems to always be long unsigned int , so %lu is appropriate there. in particular i found that gcc-4.4.3 with -std=c89 -pedantic or -std=c89 -Wall will warn about %llu and %lld . makes sense, since they expect long long , a C99 type. tragically there isn't a way to print a size_t in a platform-independent C89-compliant way. in C89, all printf formats refer to specific primitive types ( long , int , etc), but in all C dialects, size_t is platform-dependent (might be long or int or something else). as usual, microsoft throws you its own special monkey wrench. the windows compilation environment is a badly-modified C89: it has long long , but no ll printf modifier. in windows-land, %llu becomes %I64u and %zu becomes %Iu . i ended up using the following in my lab's codebase: #ifdef _WIN32 #define PRIuZ "Iu" #else #define PRIuZ "lu" #endif use: printf("%"PRIuZ"\n", sizeof(struct foo)); i modeled the name from the definitions in C99's inttypes.h . aside: my version of win64 mingw-gcc (4.4.5 20100527 (prerelease) [svn/rev.159909 - mingw-w64/oz]), plus -Wall or -pedantic , always warns when printing a size_t . it complains that %I64u and %Iu are nonstandard, and that %lu is incorrect. seems like the compiler is correctly getting tripped up by microsoft's insanity. i had to use -pedantic -Wformat=0 to get it to not whine about %Iu .
