[site]: stackoverflow
[post_id]: 1123745
[parent_id]: 1064325
[tags]: 
Why not use pointers for everything? They're slower. Compiler optimizations will not be as effective with pointer access symantics, you can read up about it in any number of web sites, but here's a decent pdf from Intel. Check pages, 13,14,17,28,32,36; Detecting unnecessary memory references in the loop notation: for (i = j + 1; i The notation for the loop boundaries contains the pointer or memory reference. The compiler does not have any means to predict whether the value referenced by pointer n is being changed with loop iterations by some other assignment. This uses the loop to reload the value referenced by n for each iteration. The code generator engine also may deny scheduling a software pipelined loop when potential pointer aliasing is found. Since the value referenced by pointer n is not anging within the loop and it is invariant to the loop index, the loading of *n s to be carried outside of the loop boundaries for simpler scheduling and pointer disambiguation. ... a number of variations on this theme.... Complex memory references. Or in other words, analyzing references such as complex pointer computations, strain the ability of compilers to generate efficient code. Places in the code where the compiler or the hardware is performing a complex computation in order to determine where the data resides, should be the focus of attention. Pointer aliasing and code simplification assist the compiler in recognizing memory access patterns, allowing the compiler to overlap memory access with data manipulation. Reducing unnecessary memory references may expose to the compiler the ability to pipeline the software. Many other data location properties, such as aliasing or alignment, can be easily recognized if memory reference computations are kept simple. Use of strength reduction or inductive methods to simplify memory references is crucial to assisting the compiler.
