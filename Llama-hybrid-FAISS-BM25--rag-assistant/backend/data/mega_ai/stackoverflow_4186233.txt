[site]: stackoverflow
[post_id]: 4186233
[parent_id]: 
[tags]: 
changing UILabel text on a subview from main view

Ok, so I'm a relative noob with Objective-C/iOS programming, so hopefully someone with more knowledge here can help me out. I have an iPad application using the SplitViewController template (with Core Data). I created another UIViewController (with xib file) called PlayerViewController. This View has several UILabel components on it. I have a list of players that show up in the RootViewController ( UITableView ) and when you select a player, I programmatically create a PlayerViewController (in DetailViewController), pass it the NSManagedObject that was passed to the DetailViewController, try to set the text of one of the labels on the PlayerViewController's view, and then add it as a subview to the DetailViewController. All of this works great except for the setting the text of the label on the PlayerViewController's view. I'm not sure what I'm doing wrong. I have used NSLog to confirm that the NSManagedObject is not nil and that the NSManagedObject property I'm trying to use has the correct text. I'm at a loss here. Any help would be greatly appreciated. (Code follows): This method is in the DetailViewController.m file: - (void)configureView { // Update the user interface for the detail item. PlayerViewController *player = [[PlayerViewController alloc] init]; player.player = detailItem; [self.view addSubview:player.view]; } This method is called when the user selects an item from the RootViewController (This functionality, calling of configureView, is setup by the template and I haven't changed it). Setting the player property of the PlayerViewController to object detailItem is handled in the setPlayer method of that class. - (void)setPlayer:(NSManagedObject *)managedObject { if (player != managedObject) { [player release]; player = [managedObject retain]; // Update the view. [self configureView]; } } I then have a configureView method as well in PlayerViewController that sets the text of the label: - (void)configureView { nickName.text = [[player valueForKey:@"Nickname"] description]; NSLog(@"Nickname %@", [[player valueForKey:@"Nickname"] description]); NSLog(@"Nickname %@", nickName.text); } Ok, so the first NSLog statement prints the desired value, but the text of the UILabel (called nickName) returns nil. The following is the full PlayerViewController.h & .m files: PlayerViewController.h: #import #import @interface PlayerViewController : UIViewController { NSManagedObject *player; IBOutlet UILabel *nickName; IBOutlet UILabel *goalCount; IBOutlet UILabel *assistCount; IBOutlet UILabel *timeInGame; } @property (nonatomic, retain) IBOutlet UILabel *nickName; @property (nonatomic, retain) IBOutlet UILabel *goalCount; @property (nonatomic, retain) IBOutlet UILabel *assistCount; @property (nonatomic, retain) IBOutlet UILabel *timeInGame; @property (nonatomic, retain) NSManagedObject *player; @end PlayerViewController.m: #import "PlayerViewController.h" @implementation PlayerViewController @synthesize nickName, goalCount, assistCount, timeInGame, player; #pragma mark - #pragma mark Managing the detail item /* When setting the player item, update the view */ - (void)setPlayer:(NSManagedObject *)managedObject { if (player != managedObject) { [player release]; player = [managedObject retain]; // Update the view. [self configureView]; } } - (void)configureView { nickName.text = [[player valueForKey:@"Nickname"] description]; NSLog(@"Nickname %@", [[player valueForKey:@"Nickname"] description]); NSLog(@"Nickname %@", nickName.text); } /* // The designated initializer. Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad. - (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil { if ((self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])) { // Custom initialization } return self; } */ /* // Implement viewDidLoad to do additional setup after loading the view, typically from a nib. - (void)viewDidLoad { [super viewDidLoad]; } */ - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { // Overriden to allow any orientation. return YES; } - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc that aren't in use. } - (void)viewDidUnload { [super viewDidUnload]; // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; } - (void)dealloc { [super dealloc]; } @end I'm sure I'm just missing something trivial, but I can't figure it out, and haven't been able to find any answers searching the web. Thanks for any help!
