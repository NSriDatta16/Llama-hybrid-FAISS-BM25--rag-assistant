[site]: stackoverflow
[post_id]: 251268
[parent_id]: 251209
[tags]: 
The approach you suggest seems to indicate that the set of validation should not be applied always. Which is ok. I've seen plenty of rules and validations we want 'most of the times' but not really always. So, the question becomes 'when do you want these validations to apply' ? Say that, for instance, you have some validations you always want to apply and some you want to verify only when... I don't know.. you're about to save to the storage (database). In that case, the checks that apply always should be in the properties (see more on this below), and those that apply only when you're about to save to the storage should be in a method (maybe named along the lines of 'VerifyRulesForStorage') that will be called when appropriate (e.g. in the middle of your 'SaveToStorage' method). One thing worth considering, I think, is the duplication you risk incurring when you have the same validation across multiple entities. Be it in the property, or in a 'VerifyRulesForStorage' method, it is likely that you'll have the same check (e.g.: String.IsNullOrEmpty, or CheckItsANumber, or CheckItsOneOfTheAcceptedValues, etc etc) in many places, across many classes. Of course, you can resolve this via inheritance (e.g. all your entities inherit from a base Entity class that has methods implementing each type of check), or composition (probably a better approach, so that your entities' class tree is driven by other, more appropriate, considerations, e.g.: all your entities have a Validator object that implements all those checks). Either way, you might want to stay away from static methods, cine they tend to create problematic situations if you are Test-Driven (there are ways around, when needed). In our system, we actually have metadata describing the validation rules. The class' property name is used to retrieve the proper metadata, which then tells the system which rules to apply. We then have a validator object that instantiates the proper type of object to actually perform the validation, through a factory (e.g. we have one class implementing the IsRequiredString rule, one implementing the IsNumber rule, etc etc). Sounds like a lot of complexity, but, in a lrge system like ours, it was definitely worth it. Finally, the off-the-shelves libraries out there might be a good alternative. In our case they weren't because of particular requirements we had - but in general.. there are benefits in using a wheel someone else has developed (and will support) over building your own (trust me, I love to rebuild wheels when I can.. I'm just saying there are cases where each approach is better than the other).
