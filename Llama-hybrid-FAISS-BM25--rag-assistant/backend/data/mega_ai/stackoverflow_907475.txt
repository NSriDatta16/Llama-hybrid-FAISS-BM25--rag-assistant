[site]: stackoverflow
[post_id]: 907475
[parent_id]: 907087
[tags]: 
I'll second (or maybe third...) the opinion that std::vector or std::deque will do the job. The only thing that I will add is a few additional factors that should guide the decision between std::vector and std::list . These have a lot to do with the characteristics of T and what algorithms you plan on using. The first is memory overhead. Std::list is a node-based container so if T is a primitive type or relatively small user-defined type, then the memory overhead of the node-based linkage might be non-negligible - consider that std::list is likely to use at least 3 * sizeof(int) storage for each element whereas std::vector will only use sizeof(int) storage with a small header overhead. Std::deque is similar to std::vector but has a small overhead that is linear to N . The next issue is the cost of copy construction. If T(T const&) is at all expensive, then steer clear of std::vector since it cause a bunch of copies to occur as the size of the vector grows. This is where std::deque is a clear winner and std::list is also a contender. The final issue that usually guides the decision on container type is whether your algorithms can work with the iterator invalidation constraints of std::vector and std::deque . If you will be manipulating the container elements a lot (e.g., sorting, inserting in the middle, or shuffling), then you might want to lean towards std::list since manipulating the order requires little more than resetting a few linkage pointers.
