[site]: stackoverflow
[post_id]: 1584282
[parent_id]: 1584267
[tags]: 
Hardware is complex; this is a simplified explanation. A typical modern computer might have a 32-bit data bus. This means that any fetch that the CPU needs to do will fetch all 32 bits of a particular memory address. Since the data bus can't fetch anything smaller than 32 bits, the lowest two address bits aren't even used on the address bus, so it's as if RAM is organised into a sequence of 32-bit words instead of 8-bit bytes . When the CPU does a fetch for a single byte, the read cycle on the bus will fetch 32 bits and then the CPU will discard 24 of those bits, loading the remaining 8 bits into whatever register. If the CPU wants to fetch a 32 bit value that is not aligned on a 32-bit boundary, it has several general choices: execute two separate read cycles on the bus to load the appropriate parts of the data word and reassemble them read the 32-bit word at the address determined by throwing away the low two bits of the address read some unexpected combination of bytes assembled into a 32-bit word, probably not the one you wanted throw an exception Various CPUs I have worked with have taken all four of those paths. In general, for maximum compatibility it is safest to align all n-bit reads to an n-bit boundary. However, you can certainly take shortcuts if you are sure that your software will run on some particular CPU family with known unaligned read behaviour. And even if unaligned reads are possible (such as on x86 family CPUs), they will be slower.
