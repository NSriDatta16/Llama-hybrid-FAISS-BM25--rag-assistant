[site]: stackoverflow
[post_id]: 5400421
[parent_id]: 5377114
[tags]: 
A more compact version of what you're doing is below, note I used a simplified data structure for my test and Flatten returns an IEnumerable of every node in the tree from the variable tree on down. I would make the recursive depth function part of the tree class if you have access to that source. If you are doing this often or your trees are huge (or both) I'm particular to the solution of caching the depth in a dictionary or the tree structure itself. If you don't do it often this will work fine. I use it for going through relatively small tree structures from a GUI and no one has ever thought the operation was slow. Complexity is O(N log N) average case for getting the depth of every node. If you would like to see all of the code I can put it in tomorrow. Func Depth = null; Depth = p => p.Parent == null ? 0 : Depth(p.Parent) + 1; var depth = tree.Flatten().Select(p => new { ID = p.NodeID(), HowDeep = Depth(p) });
