[site]: stackoverflow
[post_id]: 3204893
[parent_id]: 3204776
[tags]: 
You missed a method: Returning a failure indication and requiring an additional call to get the details of the error. There's a lot to be said for this. Example: int count; if (!TryParse("12x3", &count)) DisplayError(GetLastError()); edit This answer has generated quite a bit of controversy and downvoting. To be frank, I am entirely unconvinced by the dissenting arguments. Separating whether a call succeeded from why it failed has proven to be a really good idea . Combining the two forces you into the following pattern: HKEY key; long errcode = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &key); if (errcode != ERROR_SUCCESS) return DisplayError(errcode); Contrast this with: HKEY key; if (!RegOpenKey(HKEY_CLASSES_ROOT, NULL, &key)) return DisplayError(GetLastError()); (The GetLastError version is consistent with how the Windows API generally works, but the version that returns the code directly is how it actually works, due to the registry API not following that standard.) In any case, I would suggest that the error-returning pattern makes it all too easy to forget about why the function failed, leading to code such as: HKEY key; if (RegOpenKey(HKEY_CLASSES_ROOT, NULL, &key) != ERROR_SUCCESS) return DisplayGenericError(); edit Looking at R.'s request, I've found a scenario where it can actually be satisfied. For a general-purpose C-style API, such as the Windows SDK functions I've used in my examples, there is no non-global context for error codes to rest in. Instead, we have no good alternative to using a global TLV that can be checked after failure. However, if we expand the topic to include methods on a class, the situation is different. It's perfectly reasonable, given a variable reg that is an instance of the RegistryKey class, for a call to reg.Open to return false , requiring us to then call reg.ErrorCode to retrieve the details. I believe this satisfies R.'s request that the error code be part of a context, since the instance provides the context. If, instead of a RegistryKey instance, we called a static Open method on RegistryKeyHelper , then the retrieval of the error code on failure would likewise have to be static, which means it would have to be a TLV, albeit not an entirely global one. The class, as opposed to an instance, would be the context. In both of these cases, object orientation provides a natural context for storing error codes. Having said that, if there is no natural context, I would still insist on a global, as opposed to trying to force the caller to pass in an output parameter or some other artificial context, or returning the error code directly.
