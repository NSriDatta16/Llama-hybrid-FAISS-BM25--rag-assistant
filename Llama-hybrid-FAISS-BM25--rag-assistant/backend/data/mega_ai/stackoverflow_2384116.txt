[site]: stackoverflow
[post_id]: 2384116
[parent_id]: 2383826
[tags]: 
Yes, I know, Linus never intended it for that. Actually, Linus argues that centralized systems just can't work. And, what's wrong with the dictator-and-lieutenants workflow? Remember, git is a distributed system; don't try to use it like a central one. (updated) Most of your problems will go away if you don't try to use git as if it was "svn on steroids" (because it's not). Instead of using a bare repository as a central server where everyone can push to (and potentially screw up), setup a few integration managers that handle merges, so that only they can push to the bare repository. Usually these people should be the team leads: each leader integrates his own team's work and pushes it to the blessed repository. Even better, someone else (i.e. dictator) pulls from the team leaders and integrates their changes into the blessed repository. There's nothing wrong with that workflow, but we're an overworked startup and need our tools to substitute for human time and attention; nobody has bandwidth to even do code reviews, let alone be benevolent dictator. If the integrators don't have time to review code, that's fine, but you still need to have people that integrate the merges from everybody. Doing git pulls doesn't take all that much time. git pull A git pull B git pull C git does substitute for human time and attention; that's why it was written in the first place. The GUI tools aren't mature The gui tools can handle the basic stuff pretty well. Advanced operations require a coder/nerdy mindset (e.g. I'm comfortable working from the command line). It takes a bit of time to grasp the concepts, but it's not that hard. Using the command line tools, it's far to easy to screw up a merge and obliterate someone else's changes This won't be a problem unless you have many incompetent developers with full write access to the "central repository". But, if you set up your workflow so that only a few people (integrators) write to the "blessed" repository, that won't be a problem. Git doesn't make it easy to screw up merges. When there are merge conflicts, git will clearly mark the conflicting lines so you know which changes are yours and which are not. It's also easy to obliterate other people's code with svn or any other (non-dsitributed) tool. In fact, it's way easier with these other tools because you tend to "sit on changes" for a long time and at some point the merges can get horribly difficult. And because these tools don't know how to merge, you end up always having to merge things manually. For example, as soon as someone makes a commit to a file you're editing locally, it will be marked as a conflict that needs to be manually resolved; now that is a maintenance nightmare. With git, most of the time there won't be any merge conflicts because git can actually merge. In the case where a conflict does occur, git will clearly mark the lines for you so you know exactly which changes are yours and which changes are from other people. If someone obliterates other people's changes while resolving a merge conflict, it won't be by mistake: it will either be because it was necessary for the conflict resolution, or because they don't know what they're doing. It doesn't offer per-user repository permissions beyond global read-only or read-write privileges If you have a permission to ANY part of a repository, you can do that same thing to EVERY part of the repository, so you can't do something like make a small-group tracking branch on the central server that other people can't mess with. Workflows other than "anything goes" or "benevolent dictator" are hard to encourage, let alone enforce These problems will go away when you stop trying to use git as if it was a centralized system. It's not clear whether it's better to use a single big repository (which lets everybody mess with everything) or lots of per-component repositories (which make for headaches trying to synchronize versions). Judgment call. What kind of projects do you have? For example: does version x.y of project A depend on exactly version w.z of project B such that every time you check x.y of project A you also have to checkout w.z of project B, otherwise it won't build? If so I'd put both project A and project B in the same repository, since they're obviously two parts of a single project. The best practice here is to use your brain With multiple repositories, it's also not clear how to replicate all the sources someone else has by pulling from the central repository, or to do something like get everything as of 4:30 yesterday afternoon. I'm not sure what you mean.
