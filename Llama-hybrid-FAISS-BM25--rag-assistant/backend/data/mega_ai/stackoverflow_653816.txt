[site]: stackoverflow
[post_id]: 653816
[parent_id]: 653738
[tags]: 
I would opt for a sparse array (a linked list of linked lists) to give maximum flexibility with minimum storage. In this example, you have a linked list of rows with each element pointing to a linked list of cells in that row (you could reverse the cells and rows depending on your needs). | V +-+ +---+ +---+ |1| -> |1.1| ----------> |1.3| -: +-+ +---+ +---+ | V +-+ +---+ |7| ----------> |7.2| -: +-+ +---+ | = Each row element has the row number in it and each cell element has a pointer to its row element, so that getting the row number from a cell is O(1). Similarly, each cell element has its column number, making that O(1) as well. There's no easy way to get O(1) for finding immediately the cell at a given row/column but a sparse array is as fast as it's going to get unless you pre-allocate information for every possible cell so that you can do index lookups on an array - this would be very wasteful in terms of storage. One thing you could do is make one dimension non-sparse, such as making the columns the primary array (rather than linked list) and limiting them to 1,000 - this would make the column lookup indexed (fast), then a search on the sparse rows. I don't think you can ever get O(1) for a text lookup simply because text can be duplicated in multiple cells (unlike row/column). I still believe the sparse array will be the fastest way to search for text, unless you maintain a sorted index of all text values in another array (again, that can make it faster but at the expense of copious amounts of memory).
