[site]: stackoverflow
[post_id]: 4051072
[parent_id]: 4046910
[tags]: 
I have not used AspectJ so cannot vouch for how easy it is to use. I have used ASM to create a custom code profiler, this was about 2 days work. The effort to instrument synchronization should be similar. AspectJ should be quicker and easier once you are up to speed with aspects. I have implemented deadlock detecting trace for our c++ based server. Here is how I did it: When ever acquiring or releasing a lock I traced: This extra trace affected performance quite drastically and was not usable in production. So when a possible deadlock was discovered in production I used the log file to figure out what was happening around the deadlock. Then reproduced this functionality in a test environment with my tracing turned on. Then I ran a script on the log file to see if deadlock was possible and how. I used an awk script, using this algoritm: Foreach line if acquiring add lockid to list of current locks for this thread add each pair of locks in this list to a set lock pairs for this thread. eg for list of Lock A -> Lock B -> Lock C generate the pairs (Lock A, Lock B), (Lock A, Lock C), (Lock B, Lock C) if releasing remove current lockid from tail of list for this thread For each lock pair search all other threads for the reverse lock pairs, each match is a potential deadlock so print the pairs and threads affected Instead of making the algorithm smarter I then desk checked that the lock acquisition to see if it was a real deadlock. I did this after failing to find the cause of a deadlock for a number of days, it took a few more days to implement and a few hours to find the deadlock. If you are considering this approach in Java things to consider are: Do you only use synchronized to protect your critical sections? Are you using the classes in java.lang.concurrent? (these might require special handling/instrumentation) How easy is it to print the code location with aspects/ASM? I used __FILE__ and __LINE__ in c++. ASM will give you the class name, method name and signature. You cannot instrument the locks used to protect your tracing/logging. You can streamline your instrumentation if you use a log file per thread and thread local storage for the file object. How do you uniquely identify objects you synchronize on? Maybe toString() and System.identityHashCode() would be enough, but might require more. I used the address of the object in C++.
