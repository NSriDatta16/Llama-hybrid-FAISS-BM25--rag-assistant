[site]: stackoverflow
[post_id]: 2035255
[parent_id]: 2035066
[tags]: 
For understanding the difference, we need to understand two different contexts . In value contexts, the name of an array of type T is equivalent to a pointer to type T , and is equal to a pointer to the array's first element. In object contexts, the name of an array of type T does not reduce to a pointer. What is object context? In a = b; , a is in object context. When you taken the address of a variable, it's used in object context. Finally, when you use sizeof operator on a variable, it's used in object context. In all other cases, a variable is used in value context. Now that we have this knowledge, when we do: void f(int arr[4]); It is exactly equivalent to void f(int *arr); As you found out, we can omit the size (4 above) from the function declaration. This means that you can't know the size of the "array" passed to f() . Later, when you do: int a[]={1,2,3,4}; f(a); In the function call, the name a is in value context, so it reduces to a pointer to int . This is good, because f expects a pointer to an int , so the function definition and use match. What is passed to f() is the pointer to the first element of a ( &a[0] ). In the case of int a[]={1,2,3,4}; int b[4] = a; The name b is used in a object context, and does not reduce to a pointer. (Incidentally, a here is in a value context, and reduces to a pointer.) Now, int b[4]; assigns storage worth of 4 int s and gives the name b to it. a was also assigned similar storage. So, in effect, the above assignment means, "I want to make the storage location the same as the previous location". This doesn't make sense. If you want to copy the contents of a into b , then you could do: #include int b[4]; memcpy(b, a, sizeof b); Or, if you wanted a pointer b that pointed to a : int *b = a; Here, a is in value context, and reduces to a pointer to int , so we can assign a to an int * . Finally, when initializing an array , you can assign to it explicit values: int a[] = {1, 2, 3, 4}; Here, a has 4 elements, initialized to 1, 2, 3, and 4. You could also do: int a[4] = {1, 2, 3, 4}; If there are fewer elements in the list than the number of elements in the array, then the rest of the values are taken to be 0: int a[4] = {1, 2}; sets a[2] and a[3] to 0.
