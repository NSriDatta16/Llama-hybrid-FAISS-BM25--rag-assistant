[site]: stackoverflow
[post_id]: 2159672
[parent_id]: 2159603
[tags]: 
In the general case, the linker will only bring in what it needs. Once the compiler phase has turned your source code into an object file, it's treated much the same as all other object files. You have: the C start-up code which prepares the execution environment (sets up argv, argv and so on) then calls your main or equivalent. your code itself. whatever object files need to be dragged in from libraries (dynamic linking is a special case of linking that happens at runtime and I won't cover that here since you asked specifically about static linking). The linker will include all the object files you explicitly specify (unless it's a particularly smart linker and can tell you're not using the object file). With libraries, it's a little different. Basically, you start with a list of unresolved symbols (like cout ). The linker will search all the object files in all the libraries you specify and, when it finds an object file that satisfies that symbol, it will drag it in and fix up the symbol references. This may, of course, add even more unresolved symbols if, for example, there was something in the object file that relies on the C printf function (unlikely but possible). The linker continues like this until all symbols are satisfied (when it gives you an executable) or one cannot be satisfied (when it complains to you bitterly about your coding practices). So as to what is in your executable, it may be the entire iostream library or it may just be the minimum required to do what you asked. It will usually depend on how many object files the iostream library was built into. I've seen code where an entire subsystem went into one object file so, that if you wanted to just use one tiny bit, you still got the lot. Alternatively, you can put every single function into its own object file and the linker will probably create an executable as small as possible. There are options to the linker which can produce a link map which will show you how things are organised. You probably won't generally see it if you're using the IDE but it'll be buried deep within the compile-time options dialogs under MSVC. And, in terms of your added comment, the code: cout will quite possibly bring in sizeable chunks of both the iostream and string processing code.
