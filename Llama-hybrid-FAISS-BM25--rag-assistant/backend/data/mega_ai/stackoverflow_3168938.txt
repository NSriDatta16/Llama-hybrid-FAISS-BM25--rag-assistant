[site]: stackoverflow
[post_id]: 3168938
[parent_id]: 3167886
[tags]: 
This doesn't really solve your problem, here is a bit of a refactoring of that second method to make it look a bit more like idiomatic ruby. I know I wrote it the same way when I was learning the language, but there were a lot of thing that made that function look like C# or java written in ruby. def replace_assembly_strings path, helper raise %{the path "#{path}" can not be written to. Does it exist?} unless File.exists?(path) or File.writable?(path) file = Pathname.new(path).read methods = {/(AssemblyVersion\(\")[\d.*]*(\"\))/ => helper.build_info.build_number_template, /(AssemblyFileVersion\(\")[\d.*]*(\"\))/ => helper.build_info.build_number_template, /(AssemblyCopyright\(\").*(\"\))/ => helper.build_info.copyright, /(AssemblyCompany\(\").*(\"\))/ => helper.build_info.company} methods.keys.each do |regex| file.gsub! regex, "\1#{methods[regex]}\2" end File.open(path, 'w') {|f| f.write(file)} end There is a lot of personal style involved in ruby code, this is just the way I would do it. This sort of thing was pure gold to me when I was learning, so I'll go through step by step in detail on why I changed what I changed. So, starting from the top :) First I dropped the parens from the method signature. As a general practice, you shouldn't use parens unless either you need to, since excessive punctuation tends to make stuff harder to read. Also went from file_path to path, again, this is just a terseness thing (and personal taste) Next, you will never see if not in ruby, unless is always used. It takes a bit of getting used to, but the less boolean algebra you need to do while reading, the better. Removed some parens as well (same reasoning as the first time), and switched the || to or . When it comes to and/or vs &&/|| , I like the former quite a bit more (going back to the point on punctuation). That being said, there is a pretty huge gotcha that can happen from using that form because of the difference in operator precedence. Lets say you have something like this def foo bar 'foobar!' if bar end foobar = foo false || true # foobar == 'foobar!' What will happen first is false || true will evaluation to true , then true gets passed into foo . if we go the other way foobar = foo false or true # foobar == true ???? first, false will get passed to foo . foo will return nil , and nil is considered false in boolean expressions, so nil or true ends up evaluating to true . As you can see, this can lead to REALLY strange bugs. Because of that, a lot of rubyists just use the &&/|| forms exclusively. Personally, I just try to keep that issue in mind, because I really like and/or better. Last point on the guard clause, I swapped quotes for %{...} syntax. There are an absolutely insane amount of ways to make string literals in ruby. Because of that, there is always a way to avoid having to escape your quotes. Next change was just in the name of terseness. In a general way, I try to minimize the amount of variables I use, although this is also a style thing. Next change is the biggest. First thing I did was change all your regexs to have a grouping ( () ) around the beginning and end bits we wanted to stay the same, and removed the grouping around the stuff we want to change. I did that because with gsub, we can get a reference to whatever was matched by the groups in the other side ( \1 is the first group, \2 the second). That helps a lot when it comes to reducing noise, regexs are already hard enough to read ;-) Next, I tried to address that you were basically applying the same operation to four things in a brute force kind of way. When you find yourself doing that, usually it will make things a lot more clear if you separate the operation from what you want to operate on. The other consideration here is that we are dealing with moderately long regexs, which again, are hard enough to read all by themselves. Pull that stuff into a hash of the regex and what to replace it with makes that a lot clearer. So now we can loop over that hash and do the substitution. You may notice that I changed the gsub to gsub! , and got rid of the assignment. In general, methods that end with ! will be variants of the ones that don't end with ! , but in a way where you have to pay more attention to using it. In this case, gsub returns a new string with the substitution, gsub! does the substitution in place. Another point here is that in ruby, strings are mutable, which is a subtle difference to C#, but allows for things like in place substitution. In general, most of the differences can be boiled down to three things; DRY (don't repeat yourself) is taken WAY further in ruby then it is in C#, dont use punctuation unless you need to, and embrace the terseness of the language by doing things with the least typing you can (before reducing readability) Let me know if you have any comments/questions, and good luck with your further ruby adventures :)
