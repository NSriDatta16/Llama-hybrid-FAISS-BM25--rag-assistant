[site]: stackoverflow
[post_id]: 1605833
[parent_id]: 1605640
[tags]: 
An answer to your first question: The virtual destructor in your dll is called - the information about its location is embedded in your object (in the vtable). In the case of memory deallocation it depends how disciplined the users of your IBase are. If they know they have to call Release() and consider that exception can bypass the control flow in an surprising direction, the right one will be used. But if CreateInterface() returns shared_ptr it can bind the right deallocation function right to this smart pointer. Your library may look like this: Destroy(IBase* p) { ... // whatever is needed to delete your object in the right way } boost::shared_ptr CreateInterface() { IBase *p = new MyConcreteBase(...); ... return shared_ptr (p, Destroy); // bind Destroy() to the shared_ptr } // which is called instead of a plain // delete Thus every user of your DLL is easily prevented against resource leaks. They never have to bother about calling Release() or pay attention to exceptions bypassing surprisingly their control flow. To answer your second question: The downside of this approach is clearly stated by the other answer s: You're audience has to use the same compiler, linker, settings, libraries as you. And if they could be quite a lot this can be major drawback for your library. You have to choose: Safety vs. larger audience But there's a possible loophole: Use shared_ptr in your application, i.e. { shared_ptr p(CreateInterface(), DestroyFromLibrary); ... func(); ... } Thus no implementation specific object is passed across the DLL boundary. Nevertheless your pointer is safely hidden behind the shared_ptr , who's calling DestroyFromLibrary at the right time even if func() 's throwing an exception or not.
