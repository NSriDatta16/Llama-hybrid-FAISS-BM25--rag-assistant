[site]: stackoverflow
[post_id]: 2344860
[parent_id]: 2344383
[tags]: 
After having just tackled this myself recently (12 languages and counting) on a production system and having run into some major performance issues along the way I would suggest a hybrid system. 1) Store the language strings and translations in a database--this will make it easy to interact with/update/remove items plus will be part of your normal backup routines. 2) Cache the languages into flat files on the server and draw those out as necessary to display on the page. The benefits here are many--mostly it is fast! I am not dealing with connection overhead for MySQL or any traffic slowdowns during the transfer. (especially important if your DB server is not localhost). This will also make it very easy to use. Store the data from your database in the file as a php serialized array and GZIP the contents of the file to shrink storage overhead (this also makes it faster in my benchmarking). Example: $lang = array( 'hello' => 'Hallo', 'good_morning' => 'Guten Tag', 'logout_message' = > 'We are sorry to see you go, come again!' ); $storage_lang = gzcompress( serialize( $lang ) ); // WRITE THIS INTO A FILE SUCH AS 'my_page.de' When a user loads your system for the first time do a file_exists('/files/languages/my_page.de') . If the file exists then load the content, un-gzip, and un-serialize and it is ready to go. Example $file_contents = get_contents( 'my_page.de' ); $lang = unserialize( gzuncompress( $file_contents ) ); As you can see you can make the caching specific to each page in the system keeping the overhead even smaller and use the file extension to denote language... (my_page.en, my_page.de, my_page.fr) If the file DOESN'T exist then query the DB, build your array, serialize it, gzip it and write the missing file--at the same time you have just constructed the array that the page needed so continue on to display the page and everyone is happy. Finally, this allows you to build in update pages accessible to non-programmers but you also control when changes appear by deciding when to remove cache files so they can be rebuilt by the system. Warnings and Pitfalls When I kept everything in the database directly we hit some MAJOR slowdowns when our traffic spiked. Trying to keep them in flat-file arrays only was so much trouble because updates were painful and prone to errors. Not GZIP compressing the contents of the cache files made the language system about 20% slower in my benchmarks. Make sure all of your database fields containing languages are set to UTF8-general-ci (or at least one of the UTF8 options, I find general-ci best for my use). If you don't you will not be able to store non-unicode character sets in your database (like Chinese, Japanese, etc) Extension: In response to a comment below, be sure to set your database tables up with page level language strings in mind. id string page global 1 hello NULL 1 2 good_morning my_page.php 0 Anything that shows up in headers or footers can have a global flag that will be queried in every cache file created, otherwise query them by page to keep your system responsive.
