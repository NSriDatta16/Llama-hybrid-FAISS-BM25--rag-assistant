[site]: stackoverflow
[post_id]: 4253177
[parent_id]: 4253106
[tags]: 
if you can use a standard container, then you should. In your specific example, the container you should use is std::string , as: #include std::string some_function(){ std::string my_string = "The quick brown fox jumps over the lazy dog"; return my_string; } If, on the other hand, you really need to pass around an actual array, you have to do things a bit more to do. most likely the best choice is to let the caller work out the details of the array, and just pass that as an argument to the callee: this would look like so: // notice here that we use 'string.h', with the '.h' extension, different from above #include void some_function(size_t len, char * dest) { std::strncpy(dest, "The quick brown fox jumps over the lazy dog", len); } int main() { const std::size_t stringSize = 100; char myString[stringSize]; some_function(stringSize, myString); } Another option, though even less desirable in many cases, is to allocate a new area of storage to hold the array. char* some_function() { char* result = new char[44]; strcpy(result, "The quick brown fox jumps over the lazy dog"); return result; } int main() { char *myString = some_function(); // do some stuff with myString delete myString[]; }
