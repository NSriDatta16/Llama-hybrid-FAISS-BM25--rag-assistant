[site]: stackoverflow
[post_id]: 2896475
[parent_id]: 2895559
[tags]: 
This answer used to suggest storing the quotient and remainder (mod count) separately. That solution is less space-efficient and more code-complex. In order to accurately compute the average, you must keep track of the total. There is no way around this, unless you're willing to sacrifice accuracy. You can try to store the total in fancy ways, but ultimately you must be tracking it if the algorithm is correct. For single-pass algorithms, this is easy to prove. Suppose you can't reconstruct the total of all preceding items, given the algorithm's entire state after processing those items. But wait, we can simulate the algorithm then receiving a series of 0 items until we finish off the sequence. Then we can multiply the result by the count and get the total. Contradiction. Therefore a single-pass algorithm must be tracking the total in some sense. Therefore the simplest correct algorithm will just sum up the items and divide by the count. All you have to do is pick an integer type with enough space to store the total. Using a BigInteger guarantees no issues, so I suggest using that. var total = BigInteger.Zero var count = 0 for i in values count += 1 total += i return total / (double)count //warning: possible loss of accuracy, maybe return a Rational instead?
