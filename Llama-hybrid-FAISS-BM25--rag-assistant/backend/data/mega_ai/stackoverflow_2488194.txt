[site]: stackoverflow
[post_id]: 2488194
[parent_id]: 2488165
[tags]: 
Edit/Preamble I'd like to edit and note that I've learned a lesson here today. There's no reason to implement a boolean as I explain in the following two paragraphs; the interrupt mechanism does that for me. For some reason I had assumed that "interrupt" stops the thread dead in its tracks (I don't know what I thought isInterrupted() did then!). So, here is an example of what not to do. Keep on using your interrupt technique! Original answer I tend to avoid interrupt, but especially to stop a thread. In your case, you're trying to use interrupt() as an alternative to stop(), which has been deprecated for good reason. All you need to do is declare a boolean which represents whether the thread should stop counting, and have the thread continuously check that boolean value. Then, when the parent thread is ready for the counter to stop, it should set the boolean to true (stop), which will cause the counter thread to stop as soon as it checks the value again. In your Counter thread's anonymous class definition, add public volatile boolean shouldStop; . At the beginning of run() , set shouldStop = false; . Then replace all Thread.interrupted() with shouldStop (in your if statements). Finally, instead of calling counter.interrupt() , just say counter.shouldStop = true; . You can additionally call counter.join() right after setting shouldStop=true if you want to ensure that counter has stopped before continuing.
