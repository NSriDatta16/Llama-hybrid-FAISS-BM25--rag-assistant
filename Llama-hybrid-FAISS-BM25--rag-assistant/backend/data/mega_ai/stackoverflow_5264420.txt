[site]: stackoverflow
[post_id]: 5264420
[parent_id]: 4052907
[tags]: 
I'll assume that you haven't actually tested what's going on to form your analysis that it "gets applied to the background of all views inside the cell". I did something like this: @interface TestView : UIView { } @end @implementation TestView -(void)setBackgroundColor:(UIColor*)c { // Breakpoint here. NSLog("setBackgroundColor: %@",c); [super setBackgroundColor:c]; } @end ... UIView * v = [[[UIView alloc] initWithFrame:(CGRect){{0,0},{20,20}}] autorelease]; v.backgroundColor = [UIColor magentaColor]; UIView * v2 = [[[TestView alloc] initWithFrame:(CGRect){{5,5},{10,10}}] autorelease]; v2.backgroundColor = [UIColor yellowColor]; [v addSubview:v2]; cell.selectedBackgroundView = v; The end result is that -setBackgroundColor: is called from -[UITableViewCell _setOpaque:forSubview:] when the view is selected, with something like UIDeviceWhiteColorSpace 0 0 (i.e. [UIColor clearColor] ). Or, in other words, the background colour of some of the subviews are set to [UIColor clearColor] while the cell is selected, allowing selectedBackgroundView to show through. I think this happens because a common optimization is to give textLabel / detailTextLabel the table's background colour (e.g. white) so it draws faster, but this means the background colour has to be reset when the cell is selected. The easiest fix is to use an image instead: a 1-by-1-pixel image of the correct colour in a UIImageView will work, if a bit messy. (I had this problem when drawing custom separator lines with 1-pixel-high UIViews, so I just included the separator into the background image.) An alternative fix is to use a CALayer instead: Add a 52x52 sublayer to the UIImageView's layer, and set the sublayer's background colour. I'm pretty sure UITableViewCell simply walks the view hierarchy, so it should ignore custom layers. (The big disadvantage with layers is that they don't auto-size, which made them unsuitable for my purposes, and means the 30px right border won't auto-size.) A workaround is to subclass the relevant views and ignore -setBackgroundColor: if it's equal to [UIColor clearColor] .
