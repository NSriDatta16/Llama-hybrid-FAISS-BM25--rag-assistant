[site]: stackoverflow
[post_id]: 1446353
[parent_id]: 1441488
[tags]: 
I've made some modifications to my code, and it certainly runs a lot faster, but its not very accurate. I've made the following improvements: Using Vinko's suggestion , I avoid GetPixel in favor of working with bytes directly, now the code runs at the speed I needed. My original code simply used "IsBlack" and "IsWhite", but this isn't granular enough. The original code traces the following paths through the image: http://img43.imageshack.us/img43/1545/tilted3degtextoriginalw.gif Note that a number of paths pass through the text. By comparing my center, above, and below paths to the actual brightness value and selecting the brightest pixel. Basically I'm treating the bitmap as a heightmap, and the path from left to right follows the contours of the image, resulting a better path: http://img10.imageshack.us/img10/5807/tilted3degtextbrightnes.gif As suggested by Toaomalkster , a Gaussian blur smooths out the height map, I get even better results: http://img197.imageshack.us/img197/742/tilted3degtextblurredwi.gif Since this is just prototype code, I blurred the image using GIMP, I did not write my own blur function. The selected path is pretty good for a greedy algorithm. As Toaomalkster suggested , choosing the min/max slope is naive. A simple linear regression provides a better approximation of the slope of a path. Additionally, I should cut a path short once I run off the edge of the image, otherwise the path will hug the top of the image and give an incorrect slope. Code private double ToDegrees(double slope) { return (180.0 / Math.PI) * Math.Atan(slope); } private double GetSkew(Bitmap image) { BrightnessWrapper wrapper = new BrightnessWrapper(image); LinkedList slopes = new LinkedList (); for (int y = 0; y = wrapper.Height) { break; } int center = wrapper.GetBrightness(x, endY); int above = wrapper.GetBrightness(x, aboveY); int below = wrapper.GetBrightness(x, belowY); if (center >= above && center >= below) { /* no change to endY */ } else if (above >= center && above >= below) { endY = aboveY; } else if (below >= center && below >= above) { endY = belowY; } itemsInSet++; sumOfX += x; sumOfY += endY; sumOfXX += (x * x); sumOfXY += (x * endY); } // least squares slope = (NΣ(XY) - (ΣX)(ΣY)) / (NΣ(X^2) - (ΣX)^2), where N = elements in set if (itemsInSet > image.Width / 2) // path covers at least half of the image { decimal sumOfX_d = Convert.ToDecimal(sumOfX); decimal sumOfY_d = Convert.ToDecimal(sumOfY); decimal sumOfXY_d = Convert.ToDecimal(sumOfXY); decimal sumOfXX_d = Convert.ToDecimal(sumOfXX); decimal itemsInSet_d = Convert.ToDecimal(itemsInSet); decimal slope = ((itemsInSet_d * sumOfXY) - (sumOfX_d * sumOfY_d)) / ((itemsInSet_d * sumOfXX_d) - (sumOfX_d * sumOfX_d)); slopes.AddLast(Convert.ToDouble(slope)); } } double mean = slopes.Average(); double sumOfSquares = slopes.Sum(d => Math.Pow(d - mean, 2)); double stddev = Math.Sqrt(sumOfSquares / (slopes.Count - 1)); // select items within 1 standard deviation of the mean var testSample = slopes.Where(x => Math.Abs(x - mean) The code is good , but not great . Large amounts of whitespace cause the program to draw relatively flat line, resulting in a slope near 0, causing the code to underestimate the actual tilt of the image. There is no appreciable difference in the accuracy of the tilt by selecting random sample points vs sampling all points, because the ratio of "flat" paths selected by random sampling is the same as the ratio of "flat" paths in the entire image.
