[site]: stackoverflow
[post_id]: 2568070
[parent_id]: 
[tags]: 
Java - Creating a Compiler Help

So for my programming class we have had a project to create a virtual machine including a memory unit, cpu, Input, Output, Instruction Register, Program Counter, MAR, MDR and so on. Now we need to create a compiler using Java Code that will take a .exe file written in some txt editor and convert it to java byte code and run the code. The code we will be writing in the .exe file is machine code along the lines of: IN X IN Y ADD X STO Y OUT Y STOP DC X 0 DC Y 0 I am just a beginner and only have 2 days to write this and am very lost and have no idea where to start....Any Help will be much appreciated. Thanks Ok seeing no one really understands I will clarify......I am in my first year programming course and my teacher had us make a Virtual Machine which I have done and I will post the code for the CPU and Computer Classes but my teacher is very unorganized and we have run out of time for the last project which is the compiler.....The code above is just an example of the code that will be turned into byte code...here is the code for CPU and Computer in my Virtual Machine Package... class Cpu{ private MemEl acc; private InstReg ir; private ProgCount pc; private Input in; private OutPut out; private MemEl mdr; private MemEl mar; public Cpu() { pc = new ProgCount(); ir = new InstReg(); acc = new MemEl(); } public Boolean stop() { return ir.getOpcode() == 0; } public int getMAR() { return ir.getOpcode(); } public int getMDR() { return mdr.read(); } public void setMDR(int n) { mdr.write(n); } public boolean OutFlag() { return ir.getOpcode() == 8; } public boolean InFlag() { return ir.getOpcode() == 7; } public boolean StoreFlag() { return ir.getOpcode() == 2; } public void fetch() { mar.write(pc.getValue()); pc.plus(); } public void reset() { mar.write(0); pc.write(0); pc.write(1); } public void fetch2() { ir.write(mdr.read()); } public void decode() { mar.write(ir.getOperand()); mdr.write(acc.read()); } public void execute() { switch(ir.getOpcode()){ case 0: System.out.println("Complete"); break; case 1: acc.write(mdr.read()); break; case 2: acc.write(ir.getOperand()); break; case 3: acc.write(acc.read() + mdr.read()); break; case 4: acc.write(acc.read() - mdr.read()); break; case 5: acc.write(acc.read() * mdr.read()); break; case 6: acc.write(acc.read() / mdr.read()); break; case 7: mar.write(ir.getOperand()); break; case 8: System.out.println(getMDR()); break; case 9: pc.write(getMDR()); break; case 10: if(0 == acc.read()) pc.write(getMDR()); else fetch(); break; case 11: if(0 Here is my Computer Class import java.io.*; class Computer{ private Cpu cpu; private Input in; private OutPut out; private Memory mem; public Computer() throws IOException { Memory mem = new Memory(100); Input in = new Input(); OutPut out = new OutPut(); Cpu cpu = new Cpu(); System.out.println(in.getInt()); } public void run() throws IOException { cpu.reset(); cpu.setMDR(mem.read(cpu.getMAR())); cpu.fetch2(); while (!cpu.stop()) { cpu.decode(); if (cpu.OutFlag()) OutPut.display(mem.read(cpu.getMAR())); if (cpu.InFlag()) mem.write(cpu.getMDR(),in.getInt()); if (cpu.StoreFlag()) { mem.write(cpu.getMAR(),in.getInt()); cpu.getMDR(); } else { cpu.setMDR(mem.read(cpu.getMAR())); cpu.execute(); cpu.fetch(); cpu.setMDR(mem.read(cpu.getMAR())); cpu.fetch2(); } } } public void load() { mem.write(0,799); mem.write(1,199); mem.write(2,1009); mem.write(3,398); mem.write(4,298); mem.write(5,199); mem.write(6,497); mem.write(7,299); mem.write(8,902); mem.write(9,898); mem.write(97,0); mem.write(98,0); mem.write(99,1); } } The Load method is just a temporary method, just to see if the machine works...what it will load is bytecode formed by the compiler.
