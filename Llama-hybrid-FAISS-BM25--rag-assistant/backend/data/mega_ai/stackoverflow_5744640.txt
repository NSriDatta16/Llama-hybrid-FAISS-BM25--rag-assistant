[site]: stackoverflow
[post_id]: 5744640
[parent_id]: 
[tags]: 
Elegant way of reading a child property of an object

Say you are trying to read this property var town = Staff.HomeAddress.Postcode.Town; Somewhere along the chain a null could exist. What would be the best way of reading Town? I have been experimenting with a couple of extension methods... public static T2 IfNotNull (this T1 t, Func fn) where T1 : class { return t != null ? fn(t) : default(T2); } var town = staff.HomeAddress.IfNotNull(x => x.Postcode.IfNotNull(y=> y.Town)); or public static T2 TryGet (this T1 t, Func fn) where T1 : class { if (t != null) { try { return fn(t); } catch{ } } return default(T2); } var town = staff.TryGet(x=> x.HomeAddress.Postcode.Town); Obviously these are just abstracting away the logic and making the code (a little) more readable. But is there a better/ more efficient way? EDIT: In my particular case the objects are being returned from a WCF service and I have no control over the architecture of those objects. EDIT 2: There is also this method: public static class Nullify { public static TR Get (TF t, Func f) where TF : class { return t != null ? f(t) : default(TR); } public static TR Get (T1 p1, Func p2, Func p3) where T1 : class where T2 : class { return Get(Get(p1, p2), p3); } /// /// Simplifies null checking as for the pseudocode /// var r = Pharmacy?.GuildMembership?.State?.Name /// can be written as /// var r = Nullify( Pharmacy, p => p.GuildMembership, g => g.State, s => s.Name ); /// public static TR Get (T1 p1, Func p2, Func p3, Func p4) where T1 : class where T2 : class where T3 : class { return Get(Get(Get(p1, p2), p3), p4); } } from this article http://qualityofdata.com/2011/01/27/nullsafe-dereference-operator-in-c/
