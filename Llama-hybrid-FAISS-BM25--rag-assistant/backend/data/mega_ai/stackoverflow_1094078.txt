[site]: stackoverflow
[post_id]: 1094078
[parent_id]: 1094046
[tags]: 
Deriving from std::list or other std:: containers is discouraged. Write your operations as free functions so they can work on any standard container via iterators. Do you mean "define map without using a template function"? You should be able to use the result_type member type of std::function to get the type it returns. Also it's not necessary for you to specify that the function is passed as a std::function . You could leave it open as any type, and let the compiler join everything up. You only need std::function for runtime polymorphism. And using new to create raw heap-allocation objects and returning them by pointer is soooo 1992! :) Your iter function is essentially the same thing as the range-based for loop . But all that aside... do you mean something like this? template auto map(const TFunc &f) -> FList * { auto temp = new FList (); for (auto i = begin(); i != end(); i++) temp->push_back(f(*i)); return temp; } This will match anything callable, and will figure out the return type of the function by using decltype. Note that it requires _Ty to be default constructable. You can get around that by manufacturing an instance: template T make_instance(); No implementation is required because no code is generated that calls it, so the linker has nothing to complain about (thanks to dribeas for pointing this out!) So the code now becomes: FList ()))>* Or, literally, a list of whatever the type would be you'd get from calling the function f with a reference to an instance of _Ty. And as a free bonus for accepting, look up rvalue references - these will mean that you can write: std::list make_list_somehow() { std::list result; // blah... return result; } And then call it like this: std::list l(make_list_somehow()); Because std::list will have a "move constructor" (like a copy constructor but chosen when the argument is a temporary, like here), it can steal the contents of the return value, i.e. do the same as an optimal swap . So there's no copying of the whole list. (This is why C++0x will make naively-written existing code run faster - many popular but ugly performance tricks will become obsolete). And you can get the same kind of thing for free for ANY existing class of your own, without having to write a correct move constructor, by using unique_ptr . std::unique_ptr myThing(make_my_thing_somehow());
