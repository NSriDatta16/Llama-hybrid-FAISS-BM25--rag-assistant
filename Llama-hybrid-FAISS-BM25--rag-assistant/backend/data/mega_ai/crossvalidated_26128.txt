[site]: crossvalidated
[post_id]: 26128
[parent_id]: 26121
[tags]: 
I doubt it's really the case that the data are uniformly distributed within each minute, but if you think that's a good approximation, an efficient solution can be had by means of binary searching. Analysis Each time represents a uniform distribution supported on the interval from $\text{min}$ to $\text{max}$. By definition, this has a cumulative distribution function starting at $0$, increasing linearly from $0$ to $1$ on the interval $[\text{min}, \text{max}]$, then remaining at $1$. Notice that it is a piecewise linear function. The average of these CDFs is the CDF of the hourly data. Because each of its components is piecewise linear, the overall CDF is piecewise linear: its graph will be a polyline. We can therefore represent the CDF as an ordered array of vertices of the graph. (In R , this will be a two-column array.) Obtaining a quantile means inverting this function: given a y-value, find the corresponding x-value. That is done by searching through the set of y-values, which must monotonically non-decrease within the graph, and linearly interpolating between the vertices found to surround the target value of $y$. As an example, consider these data: Begin End [1,] 0 1 [2,] 1 3 [3,] 3 8 [4,] 6 5 [5,] 5 1 [6,] 1 2 [7,] 4 4 [8,] 10 12 (Some of the minima and maxima are interchanged just to show it will not matter.) Notice there are no values between $8$ and $10$--the CDF must be horizontal here--and that in the penultimate interval the values are constant at $4$--the CDF will be vertical here. Here is a graph of it: Solution The R code to produce this plot is x The line segments in the plot were computed by the quantile function, not by connecting the points in the CDF array: this visually confirms the correctness of the solution across the full range of percentiles (at least for this dataset). For example , to obtain the 75th percentile, execute > quantile(0.75, cdf) The output is 5.5 . Indeed, looking across the graph at a height of $0.75$ shows a crossing around $5.5$. Looking back at the data, we can compute the chance of exceeding $5.5$: In the third interval $[3,8]$, there's a 50% chance. In the fourth interval $[6,5]$ there is also a 50% chance. In the eighth interval $[10,12]$ there is a 100% chance. Because each interval occurs one-eighth of the time, the total chance of exceeding $5.5$ therefore equals $(.5 + .5 + 1.0)/8 = 0.25 = 1-0.75$, as required. As another example, quantile(0.875, cdf) returns 10, whereas quantile(0.8749999999, cdf) returns 8 . This shows how the quantile function selects the largest possible value it can. (This behavior can be modified by flipping the graph around both axes, making sure to keep the cdf array sorted: -quantile(-0.875, -cbind(rev(cdf[,1]), rev(cdf[,2]))) returns 8 , the smallest possible answer.) Details This solution exploits two helper functions. The first, edf , computes the uniform CDF for a single interval: edf 0) { y = x.max] The second, quantile , performs the search and linear interpolation needed to invert a piecewise linear graph: quantile Assisting these functions is a search routine, binsearch . I could not find a bug-free binary search (although no doubt some are lurking in the R repositories), so here is one quickly whipped up for the occasion. The tricky part is handling CDFs with jumps: this requires searching within an array that can have repeated values and selecting exactly the correct one (namely, the highest possible index that works). binsearch 1) { mid = floor((high+low)/2) if (s[mid]
