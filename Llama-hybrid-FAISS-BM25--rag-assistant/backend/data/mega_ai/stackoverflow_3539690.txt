[site]: stackoverflow
[post_id]: 3539690
[parent_id]: 3537153
[tags]: 
I'll just cough up the MSDN Library article titled "How to: Migrate to /clr:safe Visual C++ can generate verifiable components with using /clr:safe, which causes the compiler to generate errors for each non-verifiable code construct. The following issues generate verifiability errors: Native types. Even if it isn't used, the declaration of native classes, structures, pointers, or arrays will prevent compilation. Global variables Function calls into any unmanaged library, including common language runtime function calls A verifiable function cannot contain a static_cast Operator for down-casting. The static_cast operator can be used for casting between primitive types, but for down-casting, safe_cast or a C-Style cast (which is implemented as a safe_cast) must be used. A verifiable function cannot contain a reinterpret_cast operator (or any C-style cast equivalent). A verifiable function cannot perform arithmetic on an interior_ptr. It may only assign to it and dereference it. A verifiable function can only throw or catch pointers to reference types, so value types must be boxed before throwing. A verifiable function can only call verifiable functions (such that calls to the common language runtime are not allowed, include AtEntry/AtExit, and so global constructors are disallowed). A verifiable class cannot use Explicit. If building an EXE, a main function cannot declare any parameters, so GetCommandLineArgs must be used to retrieve command-line arguments. Making a non-virtual call to a virtual function. Also, the following keywords cannot be used in verifiable code: unmanaged and pack pragmas naked and align __declspec modifiers __asm __based __try and __except I reckon that will keep you busy for a while. There is no magic wand to wave to turn native C++ into verifiable code. Are you sure this is worth the investment?
