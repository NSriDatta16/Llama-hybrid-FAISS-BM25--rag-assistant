[site]: stackoverflow
[post_id]: 3849819
[parent_id]: 3849634
[tags]: 
First, as should be clear to you by now that there are very few people who can confirm these answers from first hand knowledge. Very few people have worked on recent HotSpot JVMs or studied them to the depth needed to really know. Most people here (myself included) are answering based on things they have seen written elsewhere, or what they have inferred. Usually what is written here, or in various articles and web pages, is based on other sources which may or may not be definitive. Often it is simplified, inaccurate or just plain wrong. If you want definitive confirmation of your answers, you really need to download the OpenJDK sourcecode ... and do your own research by reading and understanding the source code. Asking questions on SO, or trawling through random web articles is not a sound academic research technique. Having said that ... ... my question is Sun specific. At the time this question was asked, Sun Microsystems had ceased to exist. The question was therefore Oracle specific. AFAIK, all current (non-research) 3rd-party JVM implementations are either direct ports of an OpenJDK release or descended from another Sun/Oracle release. The answers below apply to Oracle Hotspot and OpenJDK releases, and probably to most others as well ... including GraalVM. 1) Classes (loaded by the classloaders) go in a special area on heap : Permanent Generation. Prior to Java 8, yes. As of Java 8, the PermGen space has been replaced with Metaspace. Loaded and JIT-compiled classes now go there. PermGen no longer exists. 2) All the information related to a class like name of the class, Object arrays associated with the class, internal objects used by JVM (like java/lang/Object) and optimization information goes into the Permanent Generation area. More or less, yes. I'm not sure what you mean by some of those things. I'm guessing that "internal objects used by JVM (like java/lang/Object)" means JVM-internal class descriptors. 3) All the static member variables are kept on the Permanent Generation area again. The variables themselves yes. These variables (like all Java variables) will hold either primitive values or object references. However, while the static member variables are in a frame that is allocated in the permgen heap, the objects/arrays referred to by those variables may be allocated in any heap. 4) Objects go on a different heap : Young generation Not necessarily. Large objects may be allocated directly into the tenured generation. 5) There is only one copy of each method per class, be the method static or non-static. That copy is put in the Permanent Generation area. Assuming that you are referring to the code of the method, then AFAIK yes. It may be a little more complicated though. For instance that code may exist in bytecode and/or native code forms at different times during the JVM's life. ... For non-static methods, all the parameters and local variables go onto the stack - and whenever there is a concrete invocation of that method, we get a new stack-frame associated with it. Yes. ... I am not sure where are the local variables of a static method are stored. Are they on the heap of Permanent Generation ? Or just their reference is stored in the Permanent Generation area, and the actual copy is somewhere else (Where ?) No. They are stored on the stack, just like local variables in non-static methods. 6) I am also unsure where does the return type of a method get stored. If you mean the value returned by a (non-void) method call, then it is either returned on the stack or in a machine register. If it is returned on the stack, this takes 1 or two words, depending on the return type. 7) If the objects (in the young generation) nees to use a static member (in the permanent generation), they are given a reference to the static member && they are given enough memory space to store the return type of the method,etc. That is inaccurate (or at least, you are not expressing yourself clearly). If some method accesses a static member variable, what it gets is either a primitive value or an object reference . This may be assigned to an (existing) local variable or parameter, assigned to an (existing) static or non-static member, assigned to an (existing) element of a previously allocated array, or simply used and discarded. In no case does new storage need to be allocated to hold either a reference or a primitive value. Typically, one word of memory is all that is needed to store an object or array reference, and a primitive value typically occupies one or two words, depending on the hardware architecture. In no case does space need to be allocated by the caller to hold some object / array returned by a method. In Java, objects and arrays are always returned using pass-by-value semantics ... but that value that is is returned is an object or array reference. For more information, please refer to these resources: Class metadata: a user guide What is the difference between PermGen and Metaspace? Java 8: From PermGen to Metaspace About G1 Garbage Collector, Permanent Generation and Metaspace
