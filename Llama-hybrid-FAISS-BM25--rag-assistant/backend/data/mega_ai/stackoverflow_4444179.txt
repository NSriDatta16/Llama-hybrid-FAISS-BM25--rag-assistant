[site]: stackoverflow
[post_id]: 4444179
[parent_id]: 
[tags]: 
Elegantly handle different parameter types

I have a function that, in the simplest of cases, operates on an iterable of items. def foo(items): for item in items: # do stuff Sometimes, I do not want to pass it an iterable of items directly, but rather an object that provides a method to get the iterable: def foo(obj): for item in obj.iteritems(): # do same stuff as above I can merge these two cases like this: def foo(obj): try: items = obj.iteritems() except ValueError: items = obj for item in items: # do stuff This works just fine. Now I get a third use case that looks like this: def foo(objs): for item in itertools.chain.from_iterable(obj.iteritems() for obj in objs): # do same stuff again I can still use the try-except approach, since the interfaces are incompatible. However, the nested try catch would start to become very ugly. More so when I want to add a fourth use-case. Is there any way to solve this without nesting the try -blocks?
