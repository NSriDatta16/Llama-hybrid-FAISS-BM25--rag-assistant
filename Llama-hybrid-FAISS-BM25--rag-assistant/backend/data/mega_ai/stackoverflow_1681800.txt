[site]: stackoverflow
[post_id]: 1681800
[parent_id]: 1674937
[tags]: 
This will be a two part answer to my own question. What is the right place to plug in changes to the user instance during the login process? Judging from the Django code, my current implementation, and thraxil 's answer above, I can only assume that it is expected and OK to modify the user instance in a custom authenticate() method. It smells wrong to me, as I said in my question, but the django code clearly assumes that it is possible that a user instance will be modified and I can find no other hooks to apply changes to the user model AFTER authentication, elsewhere. So, if you need an example, look at thraxil 's code - in the selected answer to my question. Why my implementation is working differently from thraxil 's and generating a unique constraint violation? This one was rather nasty to figure out. There is absolutely nothing wrong with Django. Well, if it already supported multiple databases (it is coming, I know!!!) I probably wouldn't have the problem. I have multiple databases, and different applications connect to one or more different ones. I'm using SQL Server 2005 (with django_pyodbc). I wanted to share the auth_user table between all my applications. With that in mind, what I did was create the auth models in one of the databases, and then create SQL Server synonyms for the tables in the other databases. It works just fine: allowing me to, when using database B, select/insert/update/delete from B.dbo.auth_user as if it were a real table; although what is really happening is that I'm operating on A.dbo.auth_user . But it does break down in one case: to find the generated identity, django_pyodbc does a: SELECT CAST(IDENT_CURRENT(%s) as bigint) % [table_name] and that doesn't appear to work against synonyms. It always returns nulls. So when in my authenticate() method I did user.save() , the saving part worked fine, but the retrieval of the identity column didn't - it would keep the user instance with a id of None, which would indicate to the django code that it should be inserted, not updated. The workaround: I had two choices: a) Use views instead of synonyms (this is what I did) b) Reload the user right after a user.save() using User.objects.get(username=username) Hope that might help someone else.
