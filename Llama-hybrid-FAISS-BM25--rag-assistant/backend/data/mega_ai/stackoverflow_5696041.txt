[site]: stackoverflow
[post_id]: 5696041
[parent_id]: 5695838
[tags]: 
I think this approach would be asymptotically very efficient for huge data sets (d*u >> n), as long as they can fit in memory: If the number of days is d, the number of users is u and the average number of appointments per user per day is n, this is O(d*u*n), whereas a sorting-based individual day approach would be more like O(d*u*n*log n). (If u=1 or d=1, it doesn't matter - it makes no difference.) Create an array of lists indexed by all the possible time slots. For example if you can have time slots every 5 minutes, you would have an array of size 120. This step is O(1). We assume that the number of possible time slots is fixed, and it should therefore have no bearing on the complexity analysis. Loop through all the appointments, for all days and all users, and add the appointments (together with a record of for which user and day it is) to the corresponding list for both the appointment start and the appointment end times. This step is O(d*u*n), if you use a linked list and add them at the head of the list each time. Create an array to record the "current" free time slot for each day and user - you'll see how this works in the next step. Loop through the first array, and for each list in the array, loop through that list (so, the loops are nested). For each appointment you see that is an "end appointment now", start recording a new free time slot at that time, for that day and user. For each appointment you see that is a "start appointment now", finish recording the free time slot for that day and user, if any, and discard it if it is zero-duration - if there is not one and it's not 8am, create one. This step is also O(d*u*n). Finish up any open free time records at 6pm. This step is worst case O(d*u). No inter-appointment comparisons or searches needed! This is based on radix sort. However, I am not sure whether this will be better in practice . It certainly requires more space!
