[site]: stackoverflow
[post_id]: 1851088
[parent_id]: 1523872
[tags]: 
The smooth function doesn't work well in this case because you've got abutting polygons. It's a little tricky to follow without a picture, but think about a pixel which is on the edge between two polygons. For the example, let's say that the background is (0,0,0) and the polygons are (255,255,255). The first polygon draws and hits that pixel. It covers half of it, so it computes 0.5*(0,0,0) + 0.5*(255,255,255) and saves (126,126,126) as the new value for that pixel. The second polygon draws. It also covers half of the pixel so it computes 0.5*(126,126,126) + 0.5*(255,255,255) and saves (190,190,190). This isn't correct because the two polygons should have each covered a different half and resulted in a color of (255,255,255). But you can't figure that out if you draw each polygon individually and don't save any coverage information in between. Modern graphics cards support something called multisample antialiasing . This saves some information about what part of the pixel the first polygon covered. Processing is trying to simulate this without the hardware support, so it uses a trick which works pretty well when you don't have abutting primitives, but falls apart when you do. As for the oblateness. By default, Processing fills the entire window, and your size isn't square. The easiest way to deal with this is to use the ortho function to make the aspect ratio of your camera square. Try adding this to your setup: ortho(-360,360,-180,180,-10,10);
