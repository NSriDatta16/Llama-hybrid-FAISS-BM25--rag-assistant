[site]: stackoverflow
[post_id]: 2634647
[parent_id]: 
[tags]: 
GRAPH: find an algorithm to determine the shortest path from one point to another in a rectangular maze?

I'm getting such an headache trying to elaborate an appropriate algorithm to go from a START position to a EXIT position in a maze. For what is worth, the maze is rectangular , maxsize 500x500 and, in theory, is resolvable by DFS with some branch and bound techniques ... 10 3 4 7 6 3 3 1 2 2 1 0 2 2 2 4 2 2 5 2 2 1 3 0 2 2 2 2 1 3 3 4 2 3 4 4 3 1 1 3 1 2 2 4 2 2 1 Output: 5 1 4 2 Explanation: Our agent looses energy every time he gives a step and he can only move UP, DOWN, LEFT and RIGHT. Also, if the agent arrives with a remaining energy of zero or less, he dies, so we print something like "Impossible". So, in the input 10 is the initial agent's energy, 3 4 is the START position (i.e. column 3, line 4) and we have a maze 7x6 . Think this as a kind of labyrinth, in which I want to find the exit that gives the agent a better remaining energy (shortest path). In case there are paths which lead to the same remaining energy, we choose the one which has the small number of steps, of course. I need to know if a DFS to a maze 500x500 in the worst case is feasible with these limitations and how to do it, storing the remaining energy in each step and the number of steps taken so far. The output means the agent arrived with remaining energy= 5 to the exit pos 1 4 in 2 steps. If we look carefully, in this maze it's also possible to exit at pos 3 1 (column 3, row 1) with the same energy but with 3 steps, so we choose the better one. With these in mind, can someone help me some code or pseudo-code? I have troubles working this around with a 2D array and how to store the remaining energy, the path (or number of steps taken).... EDIT: Larry, as I said, I'me a little bit confused about the code. Here's what I've tried so far, only to determine the shortest path with less steps from START to EXIT, fixing EXIT in the meanwhile... public class exitFromMaze { int energy, startY, startX, xMax, yMax; int adjMatrix[][]; boolean visited[][]; ArrayList neighbours; //ArrayList visited; Cell start; Stack stack; public exM() { Scanner cin = new Scanner(System.in); int nrTests = cin.nextInt(); for (int i = 0; i (); this.stack = new Stack (); for (int r = 0; r ) curCell.getNeighbours(this.xMax, this.yMax); for (Cell neighbourCell: neighbours) { //1- I think something's missing here and it would be here the point to cut some cases...isn't it? if ( curCell.getEnergy() + neighbourCell.getEnergy() 0) { ret = new Cell(row-1, col ,this); //ret.previous = this; } return ret; } /** * Gives the west (left) to our current Cell * @return the Cell in that direction, null if it's * impossible to go in that direction */ public Cell west() { Cell ret = null; if (col > 0) { ret = new Cell(row, col-1,this); //ret.previous = this; } return ret; } /** * Gives the east direction(right) to our current Cell * @return the Cell in that direction, null if it's * impossible to go in that direction */ public Cell east(int horizontalLimit) { Cell ret = null; //if it's inside the number max of collumns if (col res = new ArrayList (4); Cell n; n = south(ylimit); if (n != null) { res.add(n); } n = north(); if (n != null) { res.add(n); } n = east(xlimit); if (n != null) { res.add(n); } n = west(); if (n != null) { res.add(n); } return res; } } private void printArray(int h, int w) { int i, j; // print array in rectangular form System.out.print(" "); for (i = 0; i For the input: 1 40 3 3 7 8 12 11 12 11 3 12 12 12 11 11 12 2 1 13 11 11 12 2 13 2 14 10 11 13 3 2 1 12 10 11 13 13 11 12 13 12 12 11 13 11 13 12 13 12 12 11 11 11 11 13 13 10 10 13 11 12 It should print: 12 5 1 8 i.e., the agent exit in a better exit, (0,4),with the a remaining energy= 12 and in only 8 steps. With my ideas, your help, is it ask to much to point me out my fails or correct them? I'm getting so sick of this ... because I gotta be complicating something easy... More inputs/outputs (when it's not possible to achieve an exit alive (with Energy>0), just print that fact). 3 40 3 3 7 8 12 11 12 11 3 12 12 12 11 11 12 2 1 13 11 11 12 2 13 2 14 10 11 13 3 2 1 12 10 11 13 13 11 12 13 12 12 11 13 11 13 12 13 12 12 11 11 11 11 13 13 10 10 13 11 12 8 3 4 7 6 4 3 3 2 2 3 2 2 5 2 2 2 3 3 2 1 2 2 3 2 2 4 3 3 2 2 4 1 3 1 4 3 2 3 1 2 2 3 3 0 3 4 10 3 4 7 6 3 3 1 2 2 1 0 2 2 2 4 2 2 5 2 2 1 3 0 2 2 2 2 1 3 3 4 2 3 4 4 3 1 1 3 1 2 2 4 2 2 1 Output 12 5 1 8 Goodbye cruel world! 5 1 4 2
