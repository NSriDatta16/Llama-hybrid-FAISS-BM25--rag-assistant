[site]: stackoverflow
[post_id]: 3613405
[parent_id]: 3608844
[tags]: 
To your first question: no. † Clojure is here to help you get things done correctly, quickly, and enjoyably. Everything after that is gravy. And there's a lot of gravy. I don't presume to know the Clojure way , even if there is one, but here are some guidelines I've been told and have discovered while writing in Clojure: First, get something working. Then you can examine, test, and optimize if necessary. There's a reason that the time macro is in the core language. Correctness before quickness , to be cute. Abstract. If you are repeating yourself, you're probably not doing it right . Compose, curry and combine functions. Separate side-effects from your logic . e.g. if you want to format and save a string, format it in one function, then use another function to save it, however you need to. 3a. Don't go too crazy with this. Sometimes it's better to have a a few anonymous functions than a bunch of one-line defn s littering your code. Test. Rich gave you a REPL for a reason; use the hell out of that REPL. Don't clutter your namespace . We're clean in Clojure-land. Qualify your use s or use :only what you need. Make your code readable. Know the core library . Not just clojure.core , but clojure.java.io , clojure.string , clojure.set and everything in between. If you think Clojure should have a function to do X, it probably does. You can use apropos (from, yes, another core library: clojure.repl ). Document your code . Docstrings are a beautiful thing. If you have a tendency to be verbose, the doctsring is the place to let loose. But, know too that good code often "documents itself". If the code is self-explanatory, there's no need to be pedantic. This is a functional language. When you can, use a function . Protocols, macros and records are all great: but when you can get away with it, use a function. You can compose, combine, map, reduce, iterate (the list goes on, and on, and on…) functions. That's really nice. Above all, break the above rules if it makes sense . But be prepared to rethink and refactor. If you've kept your code modular enough, refactoring your code should be a matter of reorganization and recombination. Some other tips: read other people's code. If you begin to read code, and become good at reading code, you'll become better at writing your own, and you're likely to learn new things, too: there's more than one way to do just about everything. Finally, read though the Clojure Library Coding Standards to get an idea of what's expected in production Clojure code. † At least, not yet.
