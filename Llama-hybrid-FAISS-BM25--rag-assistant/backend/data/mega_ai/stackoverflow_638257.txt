[site]: stackoverflow
[post_id]: 638257
[parent_id]: 638192
[tags]: 
2001? Wow, times have changed. That was what? Java 1.3? Firstly, language features: Generics: Java added generics in the 5.0 release in 2004, basically as syntactic sugar to stop you do all those casts from Objects out of collections; Annotations: also in Java 5. Used extensively in persistence frameworks, Spring and elsewhere; Typesafe enums: Java 5 added an enum type, which is basically a class (sort of); Concurrency: Java 5 added extensive concurrency utils so multithreading has changed a lot; and Asserts: a highly underused language feature added in Java 1.4. If enabled when you run your program, assets can check for various conditions and bomb out if they aren't true. The fact that you can turn them on or off when you run your program is great for diagnostics. Thing is though, the above aren't even the big changes. In the early part of this decade, Java underwent radical architectural and philosophical changes. Back in 2001 the big things were EJB, Swing and servlets/JSP. None of them really are anymore (at least not directly). Proably the biggest thing to happen in Java (since its inception imho) is Spring and Spring really became big about 5 years ago. Spring is a lightweight container that also seeks to hide implementation differences between different providers and APIs. The biggest thing about Spring however is the principle of "inversion of control" or "dependency injection". The idea is that classes ("beans") are assembled from an external config ("application context"). A typical pattern in the earlier J2EE days was the Service Locator. It's now viewed largely as an anti-pattern. Basically you'd see code like this: public MyClass() { this.dataMember = ServiceLocator.locate("some service"); } If you go around advocating this sort of approach these days you will be viewed as an anachronism, a rank amateur, a crackpot or some combination of the three. Dependency injection, in its simplest form, will instead inject the necessary behaviour into classes without regard for the actual implementation. This kind of separation is deceptively powerful and a profound shift that Sun (still) hasn't really caugh tup with. It also greatly enhances unit testing. Swing is still around but not so big anymore. Sun released JavaFX as a Flash competitor and applet replacement in recent months. I personally don't think it has much of a future (as Joel put it in his recent podcast, Java on the desktop is basically dead) but others will disagree. EJB was big in 2001. Not so much anymore. It was (correctly) viewed as a nightmare of XML configuration, differences in application servers that made them largely non-portable (or non-trivially portable if you prefer) and they're such a heavyweight solution (pre-3.0) that they don't really have that many applications. EJB 3.0 has taken a much more Spring-like approach of dependency injection (sort of) and annotations of POJOs (plain old Java objects). Servlets and JSP were big in 2001. Struts began then or soon thereafter and was big until a few years ago. It's now been surpassed by other more modern Web frameworks (like Struts 2--no real relation to STruts 1 despite the name--Spring MVC, Seam and so on). The big thing these days--not just in Java--is of coruse the Web and RIAs. Flash/Flex and Javascript/HTML/CSS (plus frameworks) rule the roost here these days (and yes theres GWT but it has a small following). Weblogic and Websphere aren't as big as they were in 2001. JBoss still has a lot of momentum but my appserver of choice these days is Sun's Glassfish v2 or v3 Prelude. IDEs have also changed. JBuilder was big in 2001. Now there are only really three: Eclipse, Netbeans and IntelliJ (probalby in that order of popularity but my preference is IntelliJ, which is also the only commercial one of the bunch).
