[site]: stackoverflow
[post_id]: 4489864
[parent_id]: 4488888
[tags]: 
If we ignore the density issue, which @Joris expertly answers, you don't seem to have grasped how to set up a loop. What you are returning from the loop is the value NULL . This is the value that is being inserted in foo$density and that won't not work because it is the NULL , which means it is an empty component, i.e. it doesn't exists as far as R is concerned. See ?'for' for further details. > bar bar NULL > foo foo$density head(foo) ## No `density` A B 1 1 A 2 2 B 3 3 C 4 4 D 5 5 E 6 6 F If you want to insert the return value for each iteration of the loop, you must do the assignment inside the loop, and that means you should pre-allocate the storage space before you enter the loop, e.g. the above loop if we wanted to have i + 1 for i in 1,...,10, we could do this: > bar for(i in seq_along(bar)) { + bar[i] bar [1] 2 3 4 5 6 7 8 9 10 11 Of course, you would not do such a calculation as this via a loop, because R is vectorized and will work with vectors of numbers rather than you having to code each computation element by element as you might in C or other programming languages. > bar bar [1] 2 3 4 5 6 7 8 9 10 11 Notice that R has turned 1 into a vector of 1 s of sufficient length to allow the computation to proceed, something known as recycling in R-speak. Sometimes, you might need to iterate over an object with a loop or using one of the s|l|t|apply() family, but most often you will find a function that works for an entire vector of data in one go. This is one of the advantages of R over other programming languages, but does require you to get your head into vectorized mode.
