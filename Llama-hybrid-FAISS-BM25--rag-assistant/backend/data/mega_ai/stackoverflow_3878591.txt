[site]: stackoverflow
[post_id]: 3878591
[parent_id]: 3877745
[tags]: 
First, just look at the control flow by stripping everything else and adding explicit goto s for execution that reaches a label by straight-line execution. NC: if (…) goto print; goto NR; NR: if (…) goto backtrack; if (…) goto NR; goto NC; backtrack: if (…) return; goto NR; print: goto backtrack; Now, take the unconditional gotos and try to move the blocks so they represent straight-line execution. NR: if (…) goto backtrack; if (…) goto NR; goto NC; NC: if (…) goto print; goto NR; print: goto backtrack; backtrack: if (…) return; goto NR; Now eliminate the straight-line gotos NR: if (…) goto backtrack; if (…) goto NR; NC: if (…) goto print; goto NR; print: backtrack: if (…) return; goto NR; Note that a label with all backward-going gotos is a loop: for (;;) { NR: if (…) goto backtrack; if (…) continue; NC: if (…) goto print; continue; print: backtrack: if (…) return; } Hmm, we can reverse the sense of the NC: if() and eliminate the goto print . And the goto backtrack just jumps over some statements, which is equivalent to another reversed if . for (;;) { NR: if (! …) { if (…) continue; NC: if (! …) continue; print: } backtrack: if (…) return; } The loop has no condition, but backtrack: … if(…) return; just exits it, so move that block and the condition into the loop. for (;…; /* backtrack */ …) { NR: if (! …) { if (…) continue; NC: if (! …) continue; print: } } Looking pretty good, no more gotos and no "suspicious" structure! However, NC is supposed to be the entry point. This is where blind, mechanistic, compiler-ish transformations fail. I see three alternatives: Introduce variables to force execution there for the first loop iteration. This is uglier than goto , in my opinion. Disguise a goto NC; as a switch(0) and call label NC: as case 0: . The teacher will probably not accept this compromise. Copy the blocks from NC to the end of the loop and paste above the beginning of the loop. You can then factor them out into functions. Actually, this is a blind, mechanistic transformation. Hooray. I'll also represent NR and backtrack as functions for uniformity. . NC(); if (…) { print(); } while ( backtrack(), … ) { // There is probably a more elegant solution that involves looking at the contents of the code, but this takes less thinking.
