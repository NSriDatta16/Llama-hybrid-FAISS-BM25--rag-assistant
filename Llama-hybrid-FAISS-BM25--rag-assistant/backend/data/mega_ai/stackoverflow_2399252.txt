[site]: stackoverflow
[post_id]: 2399252
[parent_id]: 2398808
[tags]: 
Converting C++ pointers to CLI pointers CLI types don't have to be pointers. In C++/CLI handle (^) is used. Any differences in passing by value/doubly indirect pointers/CLI pointers from C#/C++ and what is 'recommended'. If you need better interoperability with C#, avoid using pointers. Use all the pointer related stuff in C++/CLI and expose only managed types so that C# applications can use it easily. The "fixed" keyword; does that exist? pin_ptr<> is the equivalent. Finalizers (~ClassName() {}) are discouraged in C# because there are no garantuees they will run deterministically, but since in C++ I have to use "delete" or use copy-c'tors as to stack allocate memory, what are the recommendations between C#/C++ interactions? C++/CLI supports deterministic resource management. When you write a destructor, compiler will implement IDisposable interface on the class and convert destructor into Dispose() method. delete will call this Dispose() to do the resource de-allocation. Because of this, you don't have issues in using it from C#. You can wrap the usage in using statement in C# which will ensure call on Dispose . Attributes in C++ similar to Attributes in C#? Yes they are similar. Can I use the full meta-programming patterns available in C++ through templates now and still have it compile like ordinary C++? Yes. C++/CLI supports templates on ref classes. You can use metaprogramming techniques like you do in standard C++. But these won't be portable to C#. Have you tried writing C++/CLI with boost? C++/CLI has access to the whole .NET framework. I don't think boost helps much here.
