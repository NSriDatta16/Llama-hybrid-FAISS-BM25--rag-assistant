[site]: stackoverflow
[post_id]: 3946947
[parent_id]: 3945515
[tags]: 
I think you need to check three cases: end reached -> return this path no more choices -> return nil find longest path of neighbors Code outline: (defun longest-path (node end-node net current-path) (cond ((eql node end-node) (or current-path (list node end-node))) ((null (node-neighbors node net)) ()) (t (let* ((neighbors (node-neighbors node net)) (not-visited-neighbors (set-difference neighbors current-path)) (paths (mapcar (lambda (next-node) (longest-path next-node end-node net (cons node current-path))) not-visited-neighbors))) (first (sort paths #'> :key #'length))))))
