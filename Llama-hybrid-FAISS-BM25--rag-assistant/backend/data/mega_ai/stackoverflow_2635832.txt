[site]: stackoverflow
[post_id]: 2635832
[parent_id]: 2635764
[tags]: 
If you are stripping "nested" comments, i.e.: /* This is a comment /* that has been re-commented */ possibly /* due to */ various modifications */ regexp may not be the best solution. Especially if this spans multiple lines as in the example above. Last time I had to do something like this, I read the lines one at a time, keeping a count of how many levels of "/*" (or whatever the delimiter was for the specific language) and not printing anything unless the count was at 0. Here is an example - I apologize in advance because it's pretty bad Perl, but this should give you an idea, at least: use strict; my $infile = $ARGV[0]; # File name # Slurp up input file in an array open (FH, " ; my @ARRAY; my ($i,$j); my $line; # Removes all kind of comments (single-line, multi-line, nested). # Further parsing will be carried on the stripped lines (in @ARRAY) but # the error messaging routine will reference the original @INPUT_ARRAY # so line fragments may contain comments. my $commentLevel = 0; for ($i=0; $i 0) { $resultLine .= " "; } if ($explodedLine[$j] eq "/" && $explodedLine[($j+1)] eq "*") { $commentLevel++; next; } if ($explodedLine[$j] eq "*" && $explodedLine[($j+1)] eq "/") { $commentLevel--; $j++; next; } if (($commentLevel == 0) || ($explodedLine[$j] eq "\n")) { $resultLine .= $explodedLine[$j]; } } $ARRAY[$i]=join(" ",$resultLine); } close(FH) or die "Closing: $!";
