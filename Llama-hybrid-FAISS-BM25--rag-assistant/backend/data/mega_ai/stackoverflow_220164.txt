[site]: stackoverflow
[post_id]: 220164
[parent_id]: 77342
[tags]: 
In my opinion, one of the most annoying things in standard XSLT (I'm talking about XSLT 1.0 because that's the only version I have used) is that it lacked support of string transformations and some basic date-time functions manipulations. One thing I could never understand is why a function such as translate() was designed and implemented into xpath wheras other more useful functions such as replace , to_lower , to_upper, or - let's be crazy - regular expressions were not. Some of these issues were adressed I guess with eXSLT (extended xslt ?) for parsers other than Microsoft's MSXML. I say I guess because I actually never used it as it was declared incompatible with MSXML. I don't understand why XSLT 1.0 was designed with this principle that 'text' manipulation was not be in the scope of the language when it's obvious that whenever you are converting files you can't avoid those string conversion issues (e.g. : transform an unregularly padded date given in french format to american format, 31/1/2008 to 2008-01-31) huh... These text manipulation issues were generally very basic and easily adressed in MSXML by allowing XSL to be extended with JScript functions : you could call a JScript function to perform some processing just as you would call any XSL template, but I always found that solution inelegant and ended up creating my own XSL template libraries. First because the JScript way broke your XSL portability, and then because it forced you to mix your programming logic : some bits in pure XPath/XSLT expression and other bits in DOM/object notation with JScript. Not having updatable variables is another limitation that is very confusing for newcomers, some people just don't overcome this and keep struggling with that. In some simple cases you can have workarounds with a mix of paremetrized templates and recursive calls (for example to implement an increasing or decrasing counter) but let's face it, recursion is not that natural. I think I heard all those limitations were adressed in the XSLT 2.0 specification, sadly MS decided not to implement it and promote XQuery instead. That's sad, why not implement both of them? I think that XSLT would still have a good chance of becoming as popular as CSS became for HTML. When you think about it, the most difficult part in learning XSLT is XPath, the rest is not as difficult as understanding the cascading behaviour in CSS, and CSS has become so popular... So, in my opinon, it's the lack of all those little things mentioned here and the time it took to adress them in XSLT 2.0 (with not even MS supporting it anyway) that has lead to this situation of impopularity. How I wish MS decided to implement it after all...
