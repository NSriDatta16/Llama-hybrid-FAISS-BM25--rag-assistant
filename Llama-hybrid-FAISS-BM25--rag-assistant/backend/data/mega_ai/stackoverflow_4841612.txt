[site]: stackoverflow
[post_id]: 4841612
[parent_id]: 
[tags]: 
c# event fires windows form incorrectly

I'm trying to understand what's happening here. I have a CheckedListBox which contains some ticked and some un-ticked items. I'm trying to find a way of determining the delta in the selection of controls. I've tried some cumbersome like this - but only works part of the time, I'm sure there's a more elegant solution. A maybe related problem is the myCheckBox_ItemCheck event fires on form load - before I have a chance to perform an ItemCheck. Here's what I have so far: void clbProgs_ItemCheck(object sender, ItemCheckEventArgs e) { // i know its awful System.Windows.Forms.CheckedListBox cb = (System.Windows.Forms.CheckedListBox)sender; string sCurrent = e.CurrentValue.ToString(); int sIndex = e.Index; AbstractLink lk = (AbstractLink)cb.Items[sIndex]; List _links = clbProgs.DataSource as List ; foreach (AbstractLink lkCurrent in _links) { if (!lkCurrent.IsActive) { if (!_groupValues.ContainsKey(lkCurrent.Linkid)) { _groupValues.Add(lkCurrent.Linkid, lkCurrent); } } } if (_groupValues.ContainsKey(lk.Linkid)) { AbstractLink lkDirty = (AbstractLink)lk.Clone(); CheckState newValue = (CheckState)e.NewValue; if (newValue == CheckState.Checked) { lkDirty.IsActive = true; } else if (newValue == CheckState.Unchecked) { lkDirty.IsActive = false; } if (_dirtyGroups.ContainsKey(lk.Linkid)) { _dirtyGroups[lk.Linkid] = lkDirty; } else { CheckState oldValue = (CheckState)e.NewValue; if (oldValue == CheckState.Checked) { lkDirty.IsActive = true; } else if (oldValue == CheckState.Unchecked) { lkDirty.IsActive = false; } _dirtyGroups.Add(lk.Linkid, lk); } } else { if (!lk.IsActive) { _dirtyGroups.Add(lk.Linkid, lk); } else { _groupValues.Add(lk.Linkid, lk); } } } Then onclick of a save button - I check whats changed before sending to database: private void btSave_Click(object sender, EventArgs e) { List originalList = new List (_groupValues.Values); List changedList = new List (_dirtyGroups.Values); IEnumerable dupes = originalList.ToArray ().Intersect(changedList.ToArray ()); foreach (ILink t in dupes) { MessageBox.Show("Changed"); } if (dupes.Count() == 0) { MessageBox.Show("No Change"); } } For further info. The definition of type AbstractLink uses: public bool Equals(ILink other) { if (Object.ReferenceEquals(other, null)) return false; if (Object.ReferenceEquals(this, other)) return true; return IsActive.Equals(other.IsActive) && Linkid.Equals(other.Linkid); }
