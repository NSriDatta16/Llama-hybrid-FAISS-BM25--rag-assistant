[site]: stackoverflow
[post_id]: 937636
[parent_id]: 937573
[tags]: 
I'm not sure whether I should just copy/paste from a website , but I'd rather leave the answer here, instead of a link. If anyone can clarify in comments, I'll be much obliged. Basically, you have to extend the WebBrowser class. public class ExtendedWebBrowser : WebBrowser { bool renavigating = false; public string UserAgent { get; set; } public ExtendedWebBrowser() { DocumentCompleted += SetupBrowser; //this will cause SetupBrowser to run (we need a document object) Navigate("about:blank"); } void SetupBrowser(object sender, WebBrowserDocumentCompletedEventArgs e) { DocumentCompleted -= SetupBrowser; SHDocVw.WebBrowser xBrowser = (SHDocVw.WebBrowser)ActiveXInstance; xBrowser.BeforeNavigate2 += BeforeNavigate; DocumentCompleted += PageLoaded; } void PageLoaded(object sender, WebBrowserDocumentCompletedEventArgs e) { } void BeforeNavigate(object pDisp, ref object url, ref object flags, ref object targetFrameName, ref object postData, ref object headers, ref bool cancel) { if (!string.IsNullOrEmpty(UserAgent)) { if (!renavigating) { headers += string.Format("User-Agent: {0}\r\n", UserAgent); renavigating = true; cancel = true; Navigate((string)url, (string)targetFrameName, (byte[])postData, (string)headers); } else { renavigating = false; } } } } Note: To use the method above you’ll need to add a COM reference to “Microsoft Internet Controls”. He mentions your approach too, and states that the WebBrowser control seems to cache this user agent string, so it will not change the user agent without restarting the process.
