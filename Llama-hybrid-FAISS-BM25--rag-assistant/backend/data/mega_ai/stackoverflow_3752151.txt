[site]: stackoverflow
[post_id]: 3752151
[parent_id]: 3749282
[tags]: 
Appendix B of RFC 2396 specifies a regular expression that parses a URI reference. Adapt that a bit to get what you want: #! /usr/bin/perl use warnings; use strict; use 5.10.0; # for defined-or (//) my $uri = qr{ ^ (?:([^:/?\#]+):)? # scheme = $1 (?://([^/?\#]*))? # authority = $2 ([^?\#]*) # path = $3 (\?[^\#]*)? # query = $4 (\#.*)? # fragment = $5 }x; The code above uses the /x modifier It tells the regular expression parser to ignore most whitespace that is neither backslashed nor within a character class. You can use this to break up your regular expression into (slightly) more readable parts. The # character is also treated as a metacharacter introducing a comment, just as in ordinary Perl code. but we want to match literal # characters if they're present, which meant I needed to escape them with backslashes. Out of habit, I started with qr/ but had to change the delimiter because of the slashes in the pattern. A few test cases: my @cases = qw( ftp://www.foo.com.invalid/ http://www.foo.com.invalid/ http://www.foo.com.invalid/long_path http://www.foo.com.invalid/?query http://www.foo.com.invalid?query http://www.foo.com.invalid/#fragment http://www.foo.com.invalid#fragment ); A bit of logic for (@cases) { my $nice; if (my($scheme,$auth,$path,@rest) = /$uri/) { if ($scheme eq "http" && defined $auth) { if (grep defined, @rest) { $nice = join "" => map $_ // "" => $auth, $path, @rest; } else { $nice = $auth . ($path eq "/" ? "" : $path); } } else { $nice = $_; } } print "$_ → $nice\n"; } and the output: ftp://www.foo.com.invalid/ → ftp://www.foo.com.invalid/ http://www.foo.com.invalid/ → www.foo.com.invalid http://www.foo.com.invalid/long_path → www.foo.com.invalid/long_path http://www.foo.com.invalid/?query → www.foo.com.invalid/?query http://www.foo.com.invalid?query → www.foo.com.invalid?query http://www.foo.com.invalid/#fragment → www.foo.com.invalid/#fragment http://www.foo.com.invalid#fragment → www.foo.com.invalid#fragment
