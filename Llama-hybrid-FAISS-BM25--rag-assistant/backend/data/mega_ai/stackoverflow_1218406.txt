[site]: stackoverflow
[post_id]: 1218406
[parent_id]: 1186134
[tags]: 
Since you already storing the object in the HttpContext.User property all you really need to acheive you goal is a Static method that acheives your goal:- public static class MySpecialContext { public static CommunityPrinciple Community { get { return (CommunityPrinciple)HttpContext.Current.User; } } } Now you can get the CommunityPrinciple as:- var x = MySpecialContext.Community; However it seems a lot of effort to got to avoid:- var x = (CommunityPrinciple)Context.User; An alternative would be an Extension method on HttpContext:- public static class HttpContextExtensions { public static CommunityPrinciple GetCommunity(this HttpContext o) { return (CommunityPrinciple)o.User; } } The use it:- var x = Context.GetCommunity(); That's quite tidy but will require you to remember to include the namespace where the extensions class is defined in the using list in each file the needs it. Edit : Lets assume for the moment that you have some really good reason why even a cast performed inside called code as above is still unacceptable (BTW, I'd be really interested to understand what circumstance leads you to this conclusion). Yet another alternative is a ThreadStatic field:- public class MyModule : IHttpModule { [ThreadStatic] private static CommunityPrinciple _threadCommunity; public static CommunityPrinciple Community { get { return _threadCommunity; } } // Place here your original module code but instead of (or as well as) assigning // the Context.User store in _threadCommunity. // Also at the appropriate point in the request lifecyle null the _threadCommunity } A field decorated with [ThreadStatic] will have one instance of storage per thread. Hence multiple threads can modify and read _threadCommunity but each will operate on their specific instance of the field.
