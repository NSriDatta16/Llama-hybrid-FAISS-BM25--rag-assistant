[site]: stackoverflow
[post_id]: 1057379
[parent_id]: 1033934
[tags]: 
In case anyone else ever has the exact same problem as me (I hope not), here is my monkeypatch. It's fragile and ugly, and changes private methods, but thankfully it's small. Please don't use it unless you really have to. As mentioned by others, any application using it effectively prevents multiple users doing updates at the same time, on penalty of deadlock. (In my application, there may be many readers, but multiple concurrent updates are deliberately excluded.) I have a "user" object which persists across a user session, and contains a persistent connection object. When I validate a particular HTTP interaction is part of a session, I also store the user object on django.db.connection, which is thread-local. def monkeyPatchDjangoDBConnection(): import django.db def validConnection(): if django.db.connection.connection is None: django.db.connection.connection = django.db.connection.user.connection return True def close(): django.db.connection.connection = None django.db.connection._valid_connection = validConnection django.db.connection.close = close monkeyPatchDBConnection() def setUserOnThisThread(user): import django.db django.db.connection.user = user This last is called automatically at the start of any method annotated with @login_required, so 99% of my code is insulated from the specifics of this hack.
