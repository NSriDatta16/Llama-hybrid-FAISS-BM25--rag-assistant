[site]: stackoverflow
[post_id]: 5044087
[parent_id]: 5043773
[tags]: 
I can't find any evidence to support my theory, but ImageList appears to not be aware of selecting different size icons. My hunch is that it simply converts icons to bitmaps and stores that data. At MSDN forums , I found this snippet from MVP user nobugz: I think I can reproduce your problem. When I use MicroAngelo (an icon editor utility) to extract icon #5 from shell32.dll, save it to disk, then add the icon to a 16x16 ImageList, I see a poorly interpolated version of the icon. When I edit the icon and remove all formats except 16x16x256 colors, I get a nice sharp looking version of the icon. Looks like ImageList isn't smart enough to select the icon that best matches the ImageList's ImageSize and ColorDepth property. It never was a particularly smart control. This doesn't quite match your scenario but the outcome is the same. Seeing a PhysicalDimension of 32x32 hints that something went wrong when you extracted the icon. I see 16x16 on the edited icon but 32x32 on the un-edited icon. Also, this page from CSharpKey seemed a useful resource working with ImageLists and icons. Here's an excerpt: If you are creating a list of icons, you can create each with the default size of 16x16. In some cases (for example if you intend to use the images for a list view ), you can create or design a second set of icons whose size are 32x32 (and/or 48x48) each. It seems to be, "reading between the lines" that the ImageList merely stores one size and returns resampled versions of the image stored. Edit I found another reference at CodeProject ( Embedding Icons in your VB.NET application ) that says this: Well, that seemed like a pretty good solution, until I realized that an ImageList only stores images as bitmaps at a single resolution . So if I have all these great icons in various sizes that I want to use throughout my application, maybe using their different sizes (since icons have multiple sizes stored within their single file), the ImageList wasn't quite going to cut it.
