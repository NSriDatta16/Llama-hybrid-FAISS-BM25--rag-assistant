[site]: stackoverflow
[post_id]: 5352331
[parent_id]: 5352021
[tags]: 
May I add another choice to your list? If you don't use any inheritance feature for the data in TAtom , you could use a record instead of a class . Each class instance will require to be allocated in memory, filled with zero and initialized individually. Getmem/Freemem always cost, and memory fragmentation will increase. A pre-allocated dynamic array of record will be faster than individual class instances for adding. And the data will fit better for CPU L1/L2 cache. For inserting and deleting, an array of such records will be slower than TList if you have a huge number of items, because there'll be more data to delete/insert ( TList/TObjectList both maintain just a list of pointers). For even faster insertion/deletion, you should better use a linked list. There is some overhead in the TList/TObjectList mechanism because of internal notification. mechanism And the GetItem() property could be a bit slower (because of range checking) than using directly a dynamic array. But with our TDynArray wrapper , you could stick to a dynamic array, and still have good performance, pre-allocation features, and TList -like methods. And even more methods available, like SaveToStream, Slice, Reverse , sorting with external indexes and such... type TAtom = record // could be 'packed record' to save memory (but loose perf) ElementZ: Integer; X, Y, Z: Extended; other variables: other types; // TDynArray also handle complex (e.g. string) types here end; TAtoms = array of TAtom; var Atom: TAtom; AtomArray: TAtoms; AtomCount: integer; Atoms: TDynArray; begin Atoms.Init(TypeInfo(TAtoms),AtomArray,@AtomCount); Atoms.Capacity := 10000; // pre-allocate array = same as SetLength(AtomArray,10000) for i := 1 to 10000 do begin A.ElementZ := Random(1000); A.X := Random; A.Y := Ramdom; A.Z := Random; // set other fields Atoms.Add(A); // fast adding of A properties end; // you have TList-like methods for your dynamic array Atoms.Delete(500); // delete 500th item A.ElementZ := 5000; Atoms.Insert(500,A); // insert A values at 500th index assert(Atoms.Count=10000); assert(AtomCount=10000); // same as Atoms.Count Atoms.Compare := SortDynArrayInteger; Atoms.Sort; // will sort by 1st Integer value = ElementZ for i := 1 to Atoms.Count-1 do // or AtomCount-1 // you have still direct access to AtomArray[] // -> this is even the fastest access to the data assert(AtomArray[i].ElementZ >=AtomArray[i-1].ElementZ ) Atoms.SaveToStream(aStream); // will also save any string content Atoms.Reverse; // reverse all items order Atoms.Clear; // faster adding will be done with direct access to the dynamic array Atom.Count := 10000; // allocate memory for 10000 items for i := 0 to 10000-1 do with AtomArray[i] do begin ElementZ := Random(2000); X := Random; Y := Random; Z := Random; end; Atoms.Sort; // TDynArray knows about the data just created end; // no need to have any try...finally ..Free block Works with Delphi 6 up to XE. With newer version of Delphi supporting generics, you should better go into this direction.
