[site]: stackoverflow
[post_id]: 1747236
[parent_id]: 1747235
[tags]: 
'The' answer (Read more below if you want to see how I got to this solution) Usage, given a control with a vanilla MouseDown event, and a specific EventHandler ValueEvent event: // for 'vanilla' events SetAnyHandler ( h => (o,e) => h(o,e), //don't ask me, but it works*. h => control.MouseDown += h, h => control.MouseDown -= h, subscriber, (s, e) => s.DoSomething(e)); //**See note below // for generic events SetAnyHandler ( h => control.ValueEvent += h, h => control.ValueEvent -= h, subscriber, (s, e) => s.DoSomething(e)); //**See note below (*This is a workaround from Rx ) (** it is important to avoid invoking the subscriber object directly here (for instance putting subscriber.DoSomething(e), or invoking DoSomething(e) directly if we are inside the Subscriber class. Doing this effectively creates a reference to subscriber, which completely defeats the object...) Note : in some circumstances, this CAN leave references to the wrapping classes created for the lambdas in memory, but they only weigh bytes, so I'm not too bothered. Implementation: //This overload handles any type of EventHandler public static void SetAnyHandler ( Func , TDelegate> converter, Action add, Action remove, S subscriber, Action action) where TArgs : EventArgs where TDelegate : class where S : class { var subs_weak_ref = new WeakReference(subscriber); TDelegate handler = null; handler = converter(new EventHandler ( (s, e) => { var subs_strong_ref = subs_weak_ref.Target as S; if(subs_strong_ref != null) { action(subs_strong_ref, e); } else { remove(handler); handler = null; } })); add(handler); } // this overload is simplified for generic EventHandlers public static void SetAnyHandler ( Action > add, Action > remove, S subscriber, Action action) where TArgs : EventArgs where S : class { SetAnyHandler , TArgs>( h => h, add, remove, subscriber, action); } The detail My starting point was Egor 's excellent answer (see link for version with comments): public static void Link(Publisher publisher, Control subscriber) { var subscriber_weak_ref = new WeakReference(subscriber); EventHandler > handler = null; handler = delegate(object sender, ValueEventArgs e) { var subscriber_strong_ref = subscriber_weak_ref.Target as Control; if (subscriber_strong_ref != null) subscriber_strong_ref.Enabled = e.Value; else { ((Publisher)sender).EnabledChanged -= handler; handler = null; } }; publisher.EnabledChanged += handler; } What bothered me was that the event is hard coded into the method. So that means for each new event, there is a new method to write. I fiddled around and managed to come up with this generic solution: private static void SetAnyGenericHandler ( Action > add, //to add event listener to publisher Action > remove, //to remove event listener from publisher S subscriber, //ref to subscriber (to pass to action) Action action) //called when event is raised where T : EventArgs where S : class { var subscriber_weak_ref = new WeakReference(subscriber); EventHandler handler = null; handler = delegate(object sender, T e) { var subscriber_strong_ref = subscriber_weak_ref.Target as S; if(subscriber_strong_ref != null) { Console.WriteLine("New event received by subscriber"); action(subscriber_strong_ref, e); } else { remove(handler); handler = null; } }; add(handler); } However the problem with that solution is that it is ONLY generic, it can't handle the standard winforms MouseUp, MouseDown, etc... So I tried to make it even more generic: private static void SetAnyHandler ( Action add, //to add event listener to publisher Action remove, //to remove event listener from publisher Subscriber subscriber, //ref to subscriber (to pass to action) Action action) where T : class { var subscriber_weak_ref = new WeakReference(subscriber); T handler = null; handler = delegate(object sender, R e) // However, as I hinted here , this won't compile, because there is no way of constraining T to be a delegate. At that point, I pretty much gave up. There's no point trying to fight with the C# specs. However, yesterday, I discovered the Observable.FromEvent method from the Reactive framework, I didn't have the implementation, but the usage seemed slightly familiar, and very interesting: var mousedown = Observable.FromEvent ( h => new MouseEventHandler(h), h => control.MouseDown += h, h => control.MouseDown -= h); It was the first argument that caught my attention. This is the workaround for the absence of a delegate type constraint. We take of it by passing in the function which will create the delegate. Putting all this together gives us the solution shown at the top of this answer. Afterthought I thoroughly recommended taking the time to learn about the reactive framework (or whatever it ends up being called). It is VERY interesting, and slightly mindblowing. I suspect that it will also render questions like this totally redundant. So far, the most interesting stuff I've seen has been the videos on Channel9 .
