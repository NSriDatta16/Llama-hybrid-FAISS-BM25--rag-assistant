[site]: stackoverflow
[post_id]: 5451271
[parent_id]: 5451042
[tags]: 
I'm not sure whether you are asking for the words commonly used or something else. In any case, a REPL is a Read Eval Print Loop (see first letters). If you have an interpreter that doesn't read your program or doesn't evaluate it (i.e. "understand" what you want it to do and do it) or doesn't print the results anywhere, what good is it? If you wouldn't see anything at all and it wouldn't hear you it wouldn't do what you want anyway or you only had 1 try you could as well put a rock on the table instead of the computer. Maybe there could be funny playing-with-words objections like "if it only changes an icon that is displayed, is it really printing?" and such :-) Or "if it isn't reading from the keyboard, is it really reading?". Silly pure philosophy, really. What's true is that some systems react differently depending on whether you make them read from the keyboard or from a file. I'm not sure what the use of that is, but I guess you could offer help to the human (i.e. command completion etc) when he's actually typing on the keyboard. Maybe some don't accept more than 1 expression when reading from a file? I was wondering if REPL always exists for an interpreter? I guess its a question of the definition of "interpreter". If you take it to mean (in the pragmatic sense) "something that does what I tell it to do", no. How would you tell it if it won't listen? Does Wikipedia say REPL also exists for a compiler? If yes, how is that like? Yes, of course. All LISP systems are like that. They feel exactly like an interpreter but stuff just gets magically faster over time as the system learns how you phrase yourself and learns what changes and what doesn't and just compiles what doesn't change to machine code. Java also does that nowadays, the longer your VM session lasts the more it finds out how to make things faster and if you stop changing things it will eventually end up running the entire program in machine code. The whole artificial distinction of interpreter/compiler came to be accidentially, that is to say, because of resource constraints back in the day.
