[site]: stackoverflow
[post_id]: 5530567
[parent_id]: 5530388
[tags]: 
Okay, I'm going to suggest a completely different direction than my first one. My guess is that you have the ItemsSource for grdDatasets bound to something. For the item that's going to act as your datacontext for the control, make sure it has the following characteristics, or at least a comparable structure: public class ListOfDataSets : DependencyObject { public IEnumerable Items { get { ...Whatever you normally use to get your DataSetOptions... } } public DataSetOption SelectedItem { get { return (DataSetOption)GetValue(SelectedItemProperty); } set { SetValue(SelectedItemProperty, value); } } public static readonly DependencyProperty SelectedItemProperty = DependencyProperty.Register("SelectedItem", typeof(DataSetOption), typeof(ListOfDataSets), new PropertyMetadata(null)); } The key here is that you have one property that is a list of your choices, and another property that represents one of those items. Then, in your XAML, your control can have the following structure: ... ... I actually tried this structure out, and the databinding works fine. If the DataSetOptions change a lot, though, this solution may not work, unless you're using MVVM, and the ViewModel is good at tracking what options are available, and presents them properly to the View. Hopefully this makes sense. I actually tried this one before answering. I was not correct with my original answer, and overestimated the capabilities of RelativeSource before I experimented with it. ---Original text below--- I think I can help, but I need a few more details. For now I'm just going to work off assumptions. Assumption 1: You're in a WPF UserControl with a DataGrid that has a defined ItemsSource. Assumption 2: The UserControl has another element that you want a column within your DataGrid to have access to. If these two assumptions are correct, it is a much better problem to have in WPF than in Silverlight. Each row in your DataGrid is going to be working from within a DataContext that consists of the Item for that row. But, you can reach outside of the cell's (or any) DataContext with a RelativeSource. So, if you wanted to go up the Visual Tree to get to your control's Width, you would use: {Binding RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type MyUserControl}}, Path=Width} This will trace upward in the Visual Tree until an object of type "MyUserControl" is found, at which point it will grab the "Width" property and bind to it. The Path doesn't have to be only one item deep, either. You can run up an down your visual tree as required. As this gets more complex, though, your code is going to be more fragile. If this isn't correct, please post your XAML (or something similar) and say so, and I'll spin up a test environment and edit my post.
