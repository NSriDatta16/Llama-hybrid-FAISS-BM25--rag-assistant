[site]: stackoverflow
[post_id]: 4254837
[parent_id]: 4253789
[tags]: 
It's important to read it in context. The protection attribute associated with the region has no effect on the committed storage mapped to the region. was referring to reserving , not committing regions. A reserved page has no backing store, so it's protection is always conceptually PAGE_NOACCESS, regardless of what you pass to VirtualAlloc . I.e. if a thread attempts to read/write to an address in a reserved region, an access violation is raised. From linked article: Reserved addresses are always PAGE_NOACCESS, a default enforced by the system no matter what value is passed to the function. Committed pages can be either read-only, read-write, or no-access. Re: Where exactly is the protection attribute stored for reserved region and committed storage, repectively? The protection attributes for virtual address regions are stored in the VAD tree, per process. (VAD == Virtual Address Descriptor, see Windows Internals , or linked article) Since it is recommended to use the same protection attribute for both reserving and committing, why does Windows still offer us the option to use different attribute? Isn't it mis-leading and kind of a paradox? Because the function always accepts a protection parameter, but its behaviour depends on fdwAllocationType . Protection only makes sense for committed storage. The reason Richter suggests using the same protection setting is presumably because fewer changes in the protection flags in a region mean fewer "blocks" (see your book for definition), and hence a smaller AVL tree for the VADs. I.e. if all pages in a region are committed with the same flags, there'll only be 1 block. Otherwise there could be as many blocks as pages in the region. And you need a VAD for each block (not page). Block == set of consecutive pages with identical protection/state. If the protection attribute associated with the region has no effect on the committed storage, why do we need it? As above.
