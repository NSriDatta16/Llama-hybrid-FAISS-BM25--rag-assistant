[site]: stackoverflow
[post_id]: 4267151
[parent_id]: 4265987
[tags]: 
Since to my taste all the answers, even the accepted one, get the main aspect of inline wrong and in particular in what it means for the use in macros, I try another one. The inline keyword determines if a function definition (not declaration) will result in the generation of the function in the current compilation unit. There are basically 3 cases: If you just put a "plain" definition the function must be generated and an external symbol for that function is inserted. For an inline definition a function may be generated and if so this may or may not insert an external symbol to the object. For a static definition a function may be generated (usually if it is used) but the name will never be an external symbol. For the first, if two compilation units define the same function there will be an error when linking the two object files together in one executable. For the later, if two compilation units define the same function both object files will contain copies of the function that will not be merged when they are linked. With respect to the macros that are presented in the question this makes an important functional difference. The first, inline , can be expanded anywhere especially in a header file without causing conflicts. The second can only be use in a .c file and in addition no two such .c should do that if they should end up in the same executable. Edit: w.r.t to Charles' comment. inline functions may well be also external symbols. The rules for that are a bit complex, see the corresponding paragraph 6.7.4 from C99 below. Basically there are three cases that will work if you have several translation units that will be linked together declare and define the function extern inline in a .h file and declare it again just inline without extern in exactly one .c file. declare and define the function inline in a .h file and redeclare it without inline in exactly one .c file. This is in fact similar to the instantiation of template functions in C++. declare and define the function inline in a .h file and redeclare it extern inline in exactly one .c file. Before version 4.3, gcc had a different model for this type of instantiation of inline functions that is incompatible with this normative one. See also this page for a good read on this subject. Any function with internal linkage can be an inline function. For a function with external linkage, the following restrictions apply: If a function is declared with an inline function specifier, then it shall also be defined in the same translation unit. If all of the file scope declarations for a function in a translation unit include the inline function specifier without extern, then the definition in that translation unit is an inline definition. An inline definition does not provide an external definition for the function, and does not forbid an external definition in another translation unit. An inline definition provides an alternative to an external definition, which a translator may use to implement any call to the function in the same translation unit. It is unspecified whether a call to the function uses the inline definition or the external definition.
