[site]: stackoverflow
[post_id]: 1121891
[parent_id]: 1111874
[tags]: 
This could be accomplished by using the ActionFilterAttribute. Action Filters basically intersects the request before or after the Action Result. So I just built a custom action filter attribute for POST Action Result. Here is what I did: public class RestAPIAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext filterContext) { HttpContextBase httpContext = filterContext.HttpContext; if (!httpContext.IsPostNotification) { throw new InvalidOperationException("Only POST messages allowed on this resource"); } Stream httpBodyStream = httpContext.Request.InputStream; if (httpBodyStream.Length > int.MaxValue) { throw new ArgumentException("HTTP InputStream too large."); } int streamLength = Convert.ToInt32(httpBodyStream.Length); byte[] byteArray = new byte[streamLength]; const int startAt = 0; /* * Copies the stream into a byte array */ httpBodyStream.Read(byteArray, startAt, streamLength); /* * Convert the byte array into a string */ StringBuilder sb = new StringBuilder(); for (int i = 0; i Then on the action result method on your controller you should do something like this: [RestAPIAttribute] public ActionResult MyActionResult() { //Gets XML Data From Model and do whatever you want to do with it } Hope this helps somebody else, if you think there are more elegant ways to do it, let me know.
