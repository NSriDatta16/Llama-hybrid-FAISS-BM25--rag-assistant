[site]: stackoverflow
[post_id]: 1407746
[parent_id]: 1406995
[tags]: 
Perhaps a brute force approach?... struct MYAVG { int count; float avg; }; // first pass - calculate averages for ( vector ::iterator first = v.begin(); first != v.end(); ++first ) { MYAVG myAvg; myAvg.count = 1; myAvg.avg = first->b; if ( mapAvg.find( first->a ) == mapAvg.end() ) mapAvg[ first->a ] = myAvg; else { mapAvg[ first->a ].count++; mapAvg[ first->a ].avg = ( ( mapAvg[ first->a ].avg * ( mapAvg[ first->a ].count - 1 ) ) + myAvg.avg ) / mapAvg[ first->a ].count; } } // second pass - update average values for ( vector ::iterator second = v.begin(); second != v.end(); ++second ) second->b = mapAvg[ second->a ].avg; I've tested this with the values you've supplied and get the required vector - It's not exactly optimal, but I think it's quite easy to follow (might be more preferable to a complex algorithm).
