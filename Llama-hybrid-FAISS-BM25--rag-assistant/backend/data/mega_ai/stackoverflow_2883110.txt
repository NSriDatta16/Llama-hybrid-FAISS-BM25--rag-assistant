[site]: stackoverflow
[post_id]: 2883110
[parent_id]: 2883062
[tags]: 
FillRectangle doesnt do this - given a transparent brush, the existing pixels are unchanged. Makes sense, since you are drawing with 0% opacity. :) A fast solution for a Control would be a color key. You can set the key color of the control to a specific color (i.e. magenta); all pixels that are of this color would then be rendered transparent. (If the control supports it, of course.) That, or bitmap.MakeTransparent(color) for general purposes. The problem is, again, that the color specified would be transparent, so you'd have to choose a color that doesn't exist in the image. (There's another example here: https://web.archive.org/web/20131030025202/http://msdn.microsoft.com/en-us/library/ms172507(v=VS.80).aspx ) Edit: In the end, the LockBits() approach mentioned in the other comments could be what you seek. Once you understand how the width and stride values interact, it's easy to manipulate the image at the lowest possible level. Here's a general example: https://web.archive.org/web/20141229164101/http://bobpowell.net/lockingbits.aspx Just make sure the image supports transparency (see PixelFormat), then lock the image with an appropriate mode (i.e. PixelFormat.Format32bppArgb), loop over every pixel, read for bytes, write your new color, etc.
