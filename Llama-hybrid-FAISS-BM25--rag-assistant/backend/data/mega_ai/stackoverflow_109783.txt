[site]: stackoverflow
[post_id]: 109783
[parent_id]: 109705
[tags]: 
Your larger problem is blocking in signal handlers. This is usually discouraged since it can lead to strange timing conditions. But it's not quite the cause of your problem since the timing condition you're vulnerable to exists because of your choice of signal handlers. Anyway, here's how to at least minimize the timing condition by only setting flags in your handlers and leaving the main while loop to do the actual work. The explanation for why your code is behaving strangely is described after the code. #!/usr/bin/python from signal import * from time import sleep from sys import stdout print_Qs = 0 print_Zs = 0 def write(text): stdout.write(text) stdout.flush() def process_quit(signum, frame): global print_Qs print_Qs = 10 def process_tstp(signum, frame): global print_Zs print_Zs = 10 signal(SIGQUIT, process_quit) signal(SIGTSTP, process_tstp) while 1: if print_Zs: print_Zs -= 1 c = 'Z' elif print_Qs: print_Qs -= 1 c = 'Q' else: c = '.' write(c) sleep(0.5) Anyway, here's what's going on. SIGTSTP is more special than SIGQUIT. SIGTSTP masks the other signals from being delivered while its signal handler is running. When the kernel goes to deliver SIGQUIT and sees that SIGTSTP's handler is still running, it simply saves it for later. Once another signal comes through for delivery, such as SIGINT when you CTRL + C (aka KeyboardInterrupt), the kernel remembers that it never delivered SIGQUIT and delivers it now. You will notice if you change while 1: to for i in range(60): in the main loop and do your test case again, the program will exit without running the SIGTSTP handler since exit doesn't re-trigger the kernel's signal delivery mechanism. Good luck!
