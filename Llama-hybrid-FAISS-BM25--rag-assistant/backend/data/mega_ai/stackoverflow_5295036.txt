[site]: stackoverflow
[post_id]: 5295036
[parent_id]: 5293469
[tags]: 
It took me a minute to understand why LoggedIn is a class when LoggedOut is data, but ... Yes, I think it is a reasonable model. Yes, TVar is the best way to do this afaik. I assume you know about the combinator atomically Yes, afaik. See next paragraph. If you want the type checking and the synchronizing TMVar, then you need to define both the types (for type checking) and the data wrapper (for the TMVar). I see no way around it; to my knowledge, a TMVar must remain the same type. (correct me if I'm wrong!) If it were me, I would drop the types, and instead use functions and guards. data SessionState = Ready {errors :: [String], players :: [String]} | NotReady {errors :: [String], players :: [String]} | LoggedOut {errors :: [String]} deriving (Eq, Show, Ord) loggedIn :: SessionState -> Bool loggedIn (LoggedOut _) = False loggedIn _ = True ready :: SessionState -> Bool ready (Ready _ _) = True ready _ = False addError :: SessionState -> String -> SessionState addError s e = s {errors = e:errors s} addPlayer :: SessionState -> String -> SessionState addPlayer s@(LoggedOut _) p = addError s $ "Can't add " ++ p ++ " when logged out" addPlayer s p = s {players = p:players s} Here are some simple functions you might use to move from one state to another. I tried to give examples both using guards and using pattern matching; you can pick which style you like better or mix it up like I did: login :: SessionState -> SessionState login (LoggedOut es) = NotReady es [] login s = addError s "Can't log in when already logged in" logout :: SessionState -> SessionState logout s | loggedIn s = LoggedOut $ errors s | otherwise = addError s "Can't log out when not logged in" enable :: SessionState -> SessionState enable (NotReady es ps) = Ready es ps enable s@(LoggedOut _) = addError s "Can't enable when logged out" enable s@(Ready _ _ ) = addError s "Can't enable when already ready" disable :: SessionState -> SessionState disable s | ready s = NotReady (errors s) (players s) | otherwise = addError s "Can't disable when not ready" And a dumb example function that uses the loggedIn function: countPlayers :: SessionState -> (SessionState, Maybe Int) countPlayers s | loggedIn s = (s, Just . length $ players s) | otherwise = (addError s "Can't count players whilst logged out", Nothing) This approach would have less type safety via the compiler, but can still be very readable, and as added benefit, flexible. Here's me fiddling around in ghci: *Main> LoggedOut [] LoggedOut {errors = []} *Main> login it NotReady {errors = [], players = []} *Main> enable it Ready {errors = [], players = []} *Main> addError it "Illegal somethingorother" Ready {errors = ["Illegal somethingorother"], players = []} *Main> logout it LoggedOut {errors = ["Illegal somethingorother"]} *Main> disable it LoggedOut {errors = ["Can't disable when not ready","Illegal somethingorother"]}
