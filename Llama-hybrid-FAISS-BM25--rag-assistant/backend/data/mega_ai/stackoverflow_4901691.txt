[site]: stackoverflow
[post_id]: 4901691
[parent_id]: 4900164
[tags]: 
At first glance, I was going to suggest toList and fromList . It's more code, but it enables elegant composition in the end. toList :: QT a -> [QT a] toList (Q w x y z) = [w,x,y,z] fromList :: [QT a] -> QT a fromList [w,x,y,z] = Q w x y z listOpOnQT :: ([QT a] -> [QT a]) -> QT a -> QT a listOpOnQT _ (C a) = C a listOpOnQT f q = fromList . map (listOpOnQT f) . f . toList $ q flipv :: QT a -> QT a flipv = listOpOnQT reverse Loosely tested in ghci ghci> let q = Q (Q (C 1) (C 2) (C 3) (C 4)) (C 22) (C 33) (C 44) ghci> q Q (Q (C 1) (C 2) (C 3) (C 4)) (C 22) (C 33) (C 44) ghci> flipv q Q (C 44) (C 33) (C 22) (Q (C 4) (C 3) (C 2) (C 1)) You can easily make 'sort' work on your QT structure as well, now. import Data.List (sort) instance (Ord a) => Ord (QT a) where compare (C x) (C y) = x `compare` y compare (C x) _ = LT compare _ (C x) = GT compare _ _ = EQ sortv :: (Ord a) => QT a -> QT a sortv = listOpOnQT sort Tested as part of the previous ghci session... ghci> sortv it Q (C 22) (C 33) (C 44) (Q (C 1) (C 2) (C 3) (C 4)) ghci> sortv q Q (C 22) (C 33) (C 44) (Q (C 1) (C 2) (C 3) (C 4)) Notice sorting the flipped q and just plain q both came out with the same result (therefore the sorting probably works! yay). You might want to pick a better implementation of compare , I just threw that one together to see stuff happen. So how does it work? The magic sauce, as you might have guessed, is listOpOnQT . In the non-trivial case, it turns the QT structure into a list, applies the listy function to the list, maps the lifted listy function on all elements of the list, and then pulls the list back into a QT structure. A better name for listOpOnQT might be liftQT , though it only works for a very special kind of function...
