[site]: crossvalidated
[post_id]: 360231
[parent_id]: 
[tags]: 
Fitting a Multiple Gaussian Peaks to a Smooth Curve to Calculate Resolution in R

I used interpolation to fit a smooth curve to my data. I did this in order to visualize peak and valley regions. My goal is to calculate resolution (separation between peaks). I have peak to valley distances, which I calculated and stored as a vector named a and b. I calculated these distances with the following code and labeled the plot output. The code is not very elegant but it works for finding peak and valley distances. The generated plot is easier to look at. #Smoothing function# f=approx(uniqDDF,av_slope) X=c(f[[1]]) Y=c(f[[2]]) deriv_1=smooth.spline(X,Y,spar = 0.5) deriv_2=predict(deriv_1, uniqDDF, deriv = 1) n=length(deriv_2[[2]]) locate_pk_min=c(rep(0,n)) locate_pk_max=c(rep(0,n)) locate_val_min=c(rep(0,n)) locate_val_max=c(rep(0,n)) for (i in 2:n) { if (deriv_2[[2]][i]>=0 & deriv_2[[2]][i-1] =0){ locate_val_max[i]=i locate_val_min[i]=i-1 } } peak_upper=uniqDDF[na.omit(unique(locate_pk_max))] peak_lower=uniqDDF[na.omit(unique(locate_pk_min))] val_upper=uniqDDF[na.omit(unique(locate_val_max))] val_lower=uniqDDF[na.omit(unique(locate_val_min))] ad_pk[[z]]=(peak_lower+peak_upper)/2 ad_val[[z]]=(val_lower+val_upper)/2 peak_to_val[[z]]=diff(sort(append(ad_pk[[z]],ad_val[[z]]))) ### The conditions below handle cases where the smoothing function either starts (and ends) with a peak or valley AND CALCULATES THE PEAK TO VALLEY DISTANCES ### ##peak start and peak end## # 0 and 0 # if (pk_start[[z]]==0 & pk_end[[z]]==0) {a[[z]]=peak_to_val[[z]][c (TRUE,FALSE)]; b[[z]]=peak_to_val[[z]][c(FALSE,TRUE)] } # 0 and 1 # if (pk_start[[z]]==0 & pk_end[[z]]==1) {a[[z]]=peak_to_val[[z]][c (TRUE,FALSE)]; b[[z]]=append(peak_to_val[[z]][c(FALSE,TRUE)],(65-ad_pk[[z]] [length(ad_pk[[z]])])) } # 1 and 0 # if (pk_start[[z]]==1 & pk_end[[z]]==0) {a[[z]]=append(ad_pk[[z]][1] -40.1,peak_to_val[[z]][c(FALSE,TRUE)]); b[[z]]=peak_to_val[[z]][c(TRUE,FALSE)] } # 1 and 1 # if (pk_start[[z]]==1 & pk_end[[z]]==1) {a[[z]]=append(ad_pk[[z]][1] -40.1,peak_to_val[[z]][c(FALSE,TRUE)]); b[[z]]=append(peak_to_val[[z]][c (TRUE,FALSE)],(65-ad_pk[[z]][length(ad_pk[[z]])])) } a[[z]] is a list vector of valley to peak distances at file number z and b[[z]] is peak to valley distances at file z. I took a screen shot of one of the plots generated with the code below and labeled a and b for clarity. plot(av_slope~uniqDDF) lines(predict(deriv_1,uniqDDF)) Now, at first I thought you could calculate Asymmetry, Tailing factor, and resolutions with the following formulas, Asymmetry = b/a Tailing Factor = T = (a+b)/(2*a) Width = W = a+b Resolution = T2-T1/[0.5(W1+W2)] However, the Resolution formula is for baseline widths only and not peak to valley widths. This is why I need to fit multiple Gaussians to my smooth curve to correctly calculate resolution. Notice in the plot the separation of peak 2 and peak 3. These peaks are not clearly resolved and so I need a way of quantifying that. Does anyone have any suggestions to how I could go about fitting Gaussians to my smooth interpolation curve to calculate baseline resolution or... other ways I could calculate resolution? Maybe not a baseline calculation but should a half max one work for this case?
