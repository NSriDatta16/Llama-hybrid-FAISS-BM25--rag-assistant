[site]: stackoverflow
[post_id]: 4749642
[parent_id]: 4748083
[tags]: 
constexpr functions are really nice and a great addition to c++. However, you are right in that most of the problems it solves can be inelegantly worked around with macros. However, one of the uses of constexpr has no C++03 equivalent, typed constants. // This is bad for obvious reasons. #define ONE 1; // This works most of the time but isn't fully typed. enum { TWO = 2 }; // This doesn't compile enum { pi = 3.1415f }; // This is a file local lvalue masquerading as a global // rvalue. It works most of the time. But May subtly break // with static initialization order issues, eg pi = 0 for some files. static const float pi = 3.1415f; // This is a true constant rvalue constexpr float pi = 3.1415f; // Haven't you always wanted to do this? // constexpr std::string awesome = "oh yeah!!!"; // UPDATE: sadly std::string lacks a constexpr ctor struct A { static const int four = 4; static const int five = 5; constexpr int six = 6; }; int main() { &A::four; // linker error &A::six; // compiler error // EXTREMELY subtle linker error int i = rand()? A::four: A::five; // It not safe use static const class variables with the ternary operator! } //Adding this to any cpp file would fix the linker error. //int A::four; //int A::six;
