[site]: stackoverflow
[post_id]: 4097709
[parent_id]: 4097012
[tags]: 
So, basically you need to compute a hash of the request body. The elegant way to do it is to apply a decorator to the InputStream . For example, inside a handler method (in this case you can't use @RequestBody and need to create HttpMessageConverter manually): @RequestMapping(...) public void handle(HttpServletRequest request) throws IOException { final HashingInputStreamDecorator d = new HashingInputStreamDecorator(request.getInputStream(), secretKey); HttpServletRequest wrapper = new HttpServletRequestWrapper(request) { @Override public ServletInputStream getInputStream() throws IOException { return d; } }; HttpMessageConverter conv = ...; Foo requestBody = (Foo) conv.read(Foo.class, new ServletServerHttpRequest(wrapper)); String hash = d.getHash(); ... } where hash is computed incrementally in overriden read methods of HashingInputStreamDecorator . You can also use @RequestBody if you create a Filter to apply the decorator. In this case decorator can pass the computed hash to the handler method as a request attribute. However, you need to map this filter carefully to apply it only to the requests to specific handler method.
