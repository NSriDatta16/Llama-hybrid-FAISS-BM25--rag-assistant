[site]: stackoverflow
[post_id]: 817278
[parent_id]: 817135
[tags]: 
To handle the globally disabling them, JUnit (4.5+) has two ways One is to use the new method assumeThat. If you put that in the @BeforeClass (or the @Before) of a test class, and if the condition fails, it will ignore the test. In the condition you can put a system property or something else that can be globally set on or off. The other alternative is to create a custom runner which understands the global property and delegates to the appropriate runner. This approach is a lot more brittle (since the JUnit4 internal runners are unstable and can be changed from release to release), but it has the advantage of being able to be inherited down a class hierarchy and be overridden in a subclass. It is also the only realistic way to do this if you have to support legacy JUnit38 classes. Here is some code to do the custom Runner. Regarding what getAppropriateRunnerForClass might do, the way I implemented it was to have a separate annotation that tells the custom runner what to run with. The only alternative was some very brittle copy paste from the JUnit code. private class CustomRunner implements Runner private Runner runner; public CustomRunner(Class klass, RunnerBuilder builder) throws Throwable { if (!isRunCustomTests()) { runner = new IgnoredClassRunner(klass); } else { runner = getAppropriateRunnerForClass(klass, builder); } public Description getDescription() { return runner.getDescription(); } public void run(RunNotifier notifier) { runner.run(notifier); } } EDIT: The @RunWith tag only works for a whole class. One way to work around that limiation is to move the test methods into a static inner class and annotate that. That way you have the advantage of the annotation with the organization of the class. But, doing that won't help with any @Before or @BeforeClass tags, you will have to recreate those in the inner class. It can call the outer class's method, but it would have to have its own method as a hook.
