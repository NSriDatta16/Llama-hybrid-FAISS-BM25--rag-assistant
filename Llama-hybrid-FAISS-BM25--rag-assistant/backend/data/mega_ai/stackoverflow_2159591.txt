[site]: stackoverflow
[post_id]: 2159591
[parent_id]: 2159496
[tags]: 
Your compiler has chosen what it thinks is the most appropriate overload. a1 and a2 are both declared as references to class A, so they fit the overload which takes references to class A "better" than they fit the other one, since that would require some sort of implicit cast to convert them to class B. Note also that you can't implicitly upcast that way. If you have a pointer or reference to an instance of the base class (A in this case) then it can't be implicitly converted to a derived class, because in general not all instances of the base class are instances of the derived class (all Bs are As, but not all As are Bs). You will need to declare them as instances of B before calling the function: B& b1 = ... B& b2 = ... somefunction(b1, b2);
