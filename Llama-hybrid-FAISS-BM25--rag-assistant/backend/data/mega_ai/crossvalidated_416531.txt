[site]: crossvalidated
[post_id]: 416531
[parent_id]: 415974
[tags]: 
Let's do some analysis first. Suppose within the polygon $\mathcal{P}$ its probability density is proportional function $p(x,y).$ Then the constant of proportionality is the inverse of the integral of $p$ over the polygon, $$\mu_{0,0}(\mathcal{P})=\iint_{\mathcal P} p(x,y) \mathrm{d}x\,\mathrm{d}y.$$ The barycenter of the polygon is the point of average coordinates, computed as their first moments. The first one is $$\mu_{1,0}(\mathcal{P})=\frac{1}{\mu_{0,0}(\mathcal{P})} \iint_{\mathcal P} x\,p(x,y)\mathrm{d}x\,\mathrm{d}y.$$ The inertial tensor can be represented as the symmetric array of second moments computed after translating the polygon to put its barycenter at the origin: that is, the matrix of central second moments $$\mu^\prime_{k,l}(\mathcal{P}) = \frac{1}{\mu_{0,0}(\mathcal{P})} \iint_{\mathcal P} \left(x - \mu_{1,0}(\mathcal{P})\right)^k\,\left(y - \mu_{0,1}(\mathcal{P})\right)^l\,p(x,y)\mathrm{d}x\,\mathrm{d}y$$ where $(k,l)$ range from $(2,0)$ to $(1,1)$ to $(0,2).$ The tensor itself-- aka covariance matrix--is $$I(\mathcal{P}) = \pmatrix{\mu^\prime_{2,0}(\mathcal{P}) & \mu^\prime_{1,1}(\mathcal{P}) \\ \mu^\prime_{1,1}(\mathcal{P}) & \mu^\prime_{0,2}(\mathcal{P})}.$$ A PCA of $I(\mathcal{P})$ yields the principal axes of $\mathcal{P}:$ these are the unit eigenvectors scaled by their eigenvalues. Next, let's work out how to do the calculations. Because the polygon is presented as a sequence of vertices describing its oriented boundary $\partial\mathcal P,$ it is natural to invoke Green's Theorem: $$\iint_{\mathcal{P}} \mathrm{d}\omega = \oint_{\partial\mathcal{P}}\omega$$ where $\omega = M(x,y)\mathrm{d}x + N(x,y)\mathrm{d}y$ is a one-form defined in a neighborhood of $\mathcal{P}$ and $$\mathrm{d}\omega = \left(\frac{\partial}{\partial x}N(x,y) - \frac{\partial}{\partial y}M(x,y)\right)\mathrm{d}x\,\mathrm{d}y.$$ For instance, with $\mathrm{d}\omega = x^k y^l \mathrm{d}x\mathrm{d}y$ and constant ( i.e. , uniform) density $p,$ we may (by inspection) select one of the many solutions, such as $$\omega(x,y) = \frac{-1}{l+1}x^k y^{l+1}\mathrm{d}x.$$ The point of this is that the contour integral follows the line segments determined by the sequence of vertices. Any line segment from vertex $\mathbf{u}$ to vertex $\mathbf{v}$ can be parameterized by a real variable $t$ in the form $$t \to \mathbf{u} + t\mathbf{w}$$ where $\mathbf{w} \propto \mathbf{v}-\mathbf{u}$ is the unit normal direction from $\mathbf{u}$ to $\mathbf{v}.$ The values of $t$ therefore range from $0$ to $|\mathbf{v}-\mathbf{u}|.$ Under this parameterization $x$ and $y$ are linear functions of $t$ and $\mathrm{d}x$ and $\mathrm{d}y$ are linear functions of $\mathrm{d}t.$ Thus the integrand of the contour integral over each edge becomes a polynomial function of $t,$ which is easily evaluated for small $k$ and $l.$ Implementing this analysis is as straightforward as coding its components. At the lowest level we will need a function to integrate a polynomial one-form over a line segment. Higher level functions will aggregate these to compute the raw and central moments to obtain the barycenter and inertial tensor, and finally we can operate on that tensor to find the principal axes (which are its scaled eigenvectors). The R code below performs this work. It makes no pretensions of efficiency: it is intended only to illustrate the practical application of the foregoing analysis. Each function is straightforward and the naming conventions parallel those of the analysis. Included in the code is a procedure to generate valid closed, simply connected, non-self-intersecting polygons (by randomly deforming points along a circle and including the starting vertex as its final point in order to create a closed loop). Following this are a few statements to plot the polygon, display its vertices, adjoin the barycenter, and plot the principal axes in red (largest) and blue (smallest), creating a polygon-centric positively-oriented coordinate system. # # Integrate a monomial one-form x^k*y^l*dx along the line segment given as an # origin, unit direction vector, and distance. # lintegrate $vectors) * obj$ values) } # # Construct a polygon. # circle $Inertia) sign Barycenter[1], 2), rep(i.xy $Barycenter[2], 2), -axes[1,] + i.xy$ Barycenter[1], # The -signs make the first axis .. -axes[2,]*sign + i.xy $Barycenter[2],# .. point to the right or down. length=0.1, angle=15, col=c("#e02020", "#4040c0"), lwd=2) points(matrix(i.xy$ Barycenter, 1, 2), pch=21, bg="#404040")
