[site]: stackoverflow
[post_id]: 1182746
[parent_id]: 1181102
[tags]: 
It depends on your needs and relative performance. Javascript isn't the most type-safe language and isn't very strong with regards to member visibility. Traditionally you can have "private", "public privileged", and "public" visibility within a Javascript type. You can declare private and public privileged members using: function FooClass() { var privateVar = 1; function privateFn() { return privateVar; // etc... } this.publicVar = 2; this.publicFn = function() { return privateFn(); } } This example uses a function closure, which consists of a function declaration that includes values from the scope where the function is defined. This is acceptable when member visibility is necessary but can lead to overhead. The JavaScript interpreter cannot reuse the privateFn or publicFn definitions for every instantiation since they refer to variables or functions in the outer scope. As a result every instance of FooClass results in additional storage space for privateFn and publicFn. If the type is uses infrequently or in moderation the performance penalty is neglegible. If the type is used very often in the page, or if the page is more of an "AJAX" style where memory isn't freed as frequently since the page is not unloaded then the penalty can be more visible. An alternative approach is to use prototype members. These are unprivleged public members. Since Javascript is not entirely type-safe and is relatively easy to modify after it's loaded, type safety and member visibility aren't as reliable for controlling access to type internals. For performance reasons, some frameworks like ASP.NET Ajax instead using member naming to infer visibility rules. For example, the same type in ASP.NET Ajax might look like: function FooClass2() { this._privateVar = 1; this.publicVar = 2; } FooClass2.prototype = { _privateFn : function() { return this._privateVar; }, publicFn : function() { return this._privateFn(); } } FooClass2.registerClass("FooClass2"); In this case the private scoped members are private in name only, the "_" prefix is considered to mean a private member variable. It has the downside of preventing the member from being truly private, but the upside of allowing in-memory patching of the object. The other main benefit is that all functions are created once by the interpreter and engine and reused over and over for the type. The "this" keyword then refers to the instance of the type even though the function reference itself is the same. One way to see the difference in action is to try this with both types (if you don't have ASP.NET Ajax, you can ignore the last line in FooClass2 that calls registerClass()) var fooA = new FooClass(), fooB = new FooClass(); alert(fooA.publicFn===fooB.publicFn); // false var foo2A = new FooClass2(), foo2B = new FooClass2(); alert(foo2A.publicFn===foo2B.publicFn); // true So its a matter of type safety and member visibility vs. performance and the ability to patch in memory
