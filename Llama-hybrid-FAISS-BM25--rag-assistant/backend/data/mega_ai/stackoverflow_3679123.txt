[site]: stackoverflow
[post_id]: 3679123
[parent_id]: 3679047
[tags]: 
For your C99 answer, I think 6.5 Expressions , paragraph 5 is what you're looking for: If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined. That means if you get an overflow, you're out of luck - no behaviour of any kind guaranteed. Unsigned types are a special case, and never overflow ( 6.2.5 Types , paragraph 9): A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type. C++ has the same statements, worded a bit differently: 5 Expressions , paragraph 4: If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined. [ Note: most existing implementations of C++ ignore integer overflows. Treatment of division by zero, forming a remainder using a zero divisor, and all floating point exceptions vary among machines, and is usually adjustable by a library function. â€”endnote ] 3.9.1 Fundamental types , paragraph 4: Unsigned integers, declared unsigned , shall obey the laws of arithmetic modulo 2^ n where n is the number of bits in the value representation of that particular size of integer.
