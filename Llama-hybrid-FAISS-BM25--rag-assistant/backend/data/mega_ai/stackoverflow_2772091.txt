[site]: stackoverflow
[post_id]: 2772091
[parent_id]: 2771825
[tags]: 
I think the heart of the concern comes from the C/C++ philosophy of speed above all. These languages were created at a time when raw power was sparse and you needed to get all the optimizations you could just to have something usable. Specifying how to deal with UB would mean detecting it in the first place and then of course specifying the handling proper. However detecting it is against the speed first philosophy of the languages! Today, do we still need fast programs ? Yes, for those of us working either with very limited resources (embedded systems) or with very harsh constraints (on response time or transactions per second), we do need to squeeze out as much as we can. I know the motto throw more hardware at the problem . We have an application where I work: expected time for an answer ? Less than 100ms, with DB calls in the midst (say thanks to memcached). number of transactions per second ? 1200 in average, peaks at 1500/1700. It runs on about 40 monsters: 8 dual core opteron (2800MHz) with 32GB of RAM. It gets difficult to be "faster" with more hardware at this point, so we need optimized code, and a language that allows it (we did restrain to throw assembly code in there). I must say that I don't care much for UB anyway. If you get to the point that your program invokes UB then it needs fixing whatever the behavior that actually occurred. Of course it would be easier to fix them if it was reported straight away: that's what debug builds are for. So perhaps that instead of focusing on UB we should learn to use the language: don't use unchecked calls (for experts) don't use unchecked calls (for gurus) are you sure you really need an unchecked call here ? And everything is suddenly better :)
