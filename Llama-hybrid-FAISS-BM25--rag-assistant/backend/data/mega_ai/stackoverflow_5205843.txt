[site]: stackoverflow
[post_id]: 5205843
[parent_id]: 5205823
[tags]: 
It's logical. Every derived object is base object, hence upcasting is automatic. But every base object is not derived, hence you need to explicitly cast it. See this simple example: struct Fruit {}; struct Apple : Fruit {}; Apple apple; Fruit fruit; fruit = apple; //ok - automatic - since apple is fruit (see "object slicing") apple = fruit; //error - not automatic - since fruit is necessarily apple! See the error and line number: http://ideone.com/JnLc2 However, if you overload operator= in the following way, struct Apple : Fruit { Apple & operator = (const Fruit &); }; Then explicit casting is not needed. You can write apple = fruit; //alright - assignment (not construction) See this : http://ideone.com/IGbFI Now if you add this: struct Apple : Fruit { Apple(const Fruit &); }; then you can write Apple apple = fruit ; //ok - construction ( not assignment) See this : http://ideone.com/muQc0
