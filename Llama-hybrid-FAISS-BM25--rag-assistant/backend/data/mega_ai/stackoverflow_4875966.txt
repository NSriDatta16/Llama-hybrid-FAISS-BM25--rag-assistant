[site]: stackoverflow
[post_id]: 4875966
[parent_id]: 4869585
[tags]: 
I was able to get tombstoning to work, along with having an object be visible to all my ViewModels, by doing the following: In a Model class, I added: private static Model1 _instance; public static Model1 Instance { get { return _instance; } set { _instance = value; } } public static void CreateNew() { if (_instance == null) { _instance = new Model1(); _instance.FirstString = "init"; } } Then in ApplicationExtensions.cs I added: public static void SaveToIsolatedStorage(this Application app, Model1 model) { var dataFileName = GetIsFile((model.GetType())); using (var userAppStore = IsolatedStorageFile.GetUserStoreForApplication()) { if (userAppStore.FileExists(dataFileName)) { userAppStore.DeleteFile(dataFileName); } using (var iss = userAppStore.CreateFile(dataFileName)) { SilverlightSerializer.Serialize(model, iss); } } } And in App.xaml.cs I changed LoadModel() to: private void LoadModel() { try { Model1.Instance = this.RetrieveFromIsolatedStorage (); } catch (Exception) { } if (Model1.Instance == null) Model1.CreateNew(); } That all made things like this work in my ViewModel files: public string TestStr { get { return Model1.Instance.FirstString; } set { Model1.Instance.FirstString = value; } } And by that, I mean that the Model1 object is getting serialized and tombstoning is working - at least I’m getting what I think I want. I’ve tested it a lot by navigating between apps, phone settings, turning the phone off and on, locking it and calling it while in the app from another phone. Performance when deserializing is great. And I can work with the vars. That said, Mr. Van Schaik replied to a request for assistance with: "If you are subclassing from an MVVMLight ViewModelBase it does, and then you should call RaisePropertyChanged from your setter like this: private string _foobar ="init"; public string TestStr { get { return _foobar; } set { RaisePropertyChanged("TestStr"); _foobar = value; } } RaisePropertyChanged notifies any listenings views (i.e. the TextBox you bound to it) that a property is changed and that the should update their contents. This is a crucial mechanism." So I will work with what I was originally trying but with the addition of RaisePropertyChanged to see what that does. UPDATE Although I implemented RaisedPropertyChanged (using the code snippet mvvminpc) in my MainViewModel.cs file, that still had no effect (as good as it may be for other things) on serializing anything created within the ViewModel. I'm probably still doing something wrong, but it may also be because view models inherit from a protected class ( answer from Laurent Bugnion ). I (very reluctantly) tried changing that class from protected to public and recompiling, but it didn't help in my case and I hate to fork a referenced library like that. Anyway, I'm just forging ahead for now with creating the Model1 instance in App.xaml.cs. Seems to work. While I was at it, I modified one of Van Schaik's methods to accept any type of object: public static void SaveToIsolatedStorage (this Application app, T obj) where T : class { var dataFileName = GetIsFile(typeof(T)); using (var userAppStore = IsolatedStorageFile.GetUserStoreForApplication()) { if (userAppStore.FileExists(dataFileName)) { userAppStore.DeleteFile(dataFileName); } using (var iss = userAppStore.CreateFile(dataFileName)) { SilverlightSerializer.Serialize(obj, iss); } } }
