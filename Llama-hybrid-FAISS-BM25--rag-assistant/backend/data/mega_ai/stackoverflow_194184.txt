[site]: stackoverflow
[post_id]: 194184
[parent_id]: 193864
[tags]: 
Reason [1] Faster compile times Not in my projects: source files (CPP) only include the headers (HPP) they need. So when I need to recompile only one CPP because of a tiny change, I have ten times the same number of files that are not recompiled. Perhaps you should break down your project in more logical sources/headers: A modification in class A's implementation should NOT need the recompilation of implementations of class B, C, D, E, etc.. Reason[2] It avoids circular dependencies Circular dependencies in code? Sorry, but I have yet to have this kind of problem being a real problem: Let's say A depends on B, and B depends on A: struct A { B * b ; void doSomethingWithB() ; } ; struct B { A * a ; void doSomethingWithA() ; } ; void A::doSomethingWithB() { /* etc. */ } void B::doSomethingWithA() { /* etc. */ } A good way to resolve the problem would be to break down this source into at least one source/header per class (in a way similar to the Java way, but with one source and one header per class): // A.hpp struct B ; struct A { B * b ; void doSomethingWithB() ; } ; . // B.hpp struct A ; struct B { A * a ; void doSomethingWithA() ; } ; . // A.cpp #include "A.hpp" #include "B.hpp" void A::doSomethingWithB() { /* etc. */ } . // B.cpp #include "B.hpp" #include "A.hpp" void B::doSomethingWithA() { /* etc. */ } Thus, no dependency problem, and still fast compile times. Did I miss something? When working on "real-world" projects in a real-world project, cpp files tend to include random headers until you can't figure out who depends on whom Of course. But then if you have time to reorganize those files to build your "one CPP" solution, then you have time to clean those headers. My rules for headers are: break down header to make them as modular as possible Never include headers you don't need If you need a symbol, forward-declare it only if the above failed, include the header Anyway, all headers must be self-sufficient, which means: An header include all needed headers (and only needed headers - see above) an empty CPP file including one header must compile without needing to include anything else This will remove ordering problems and circular dependencies. Is compile times an issue? Then... Should compile time be really an issue, I would consider either: Using precompiled headers (this is quite useful for STL and BOOST) Decrease coupling through the PImpl idiom, as explained in http://en.wikipedia.org/wiki/Opaque_pointer Use network shared compilation Conclusion What you are doing is not putting everything in headers. You are basically including all your files into one and only one final source. Perhaps you are winning in terms of full-project compilation. But when compiling for one small change, you'll always lose. When coding, I know I compile often small changes (if only to have the compiler validate my code), and then one final time, do a full project change. I would lose a lot of time if my project was organized your way.
