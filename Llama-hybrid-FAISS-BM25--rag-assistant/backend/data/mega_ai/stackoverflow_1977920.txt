[site]: stackoverflow
[post_id]: 1977920
[parent_id]: 1977339
[tags]: 
well, here is what i wrote, since there does not seem to be one. the generator does not use any internal storage besides single integer. range object can be passed around and used in nested loops. there is a small test case. #include "iostream" #include "foreach.hpp" #include "boost/iterator/iterator_categories.hpp" struct range { struct iterator_type { typedef int value_type; typedef int difference_type; typedef boost::single_pass_traversal_tag iterator_category; typedef const value_type* pointer; typedef const value_type & reference; mutable value_type value; const difference_type increment; iterator_type(value_type value, difference_type increment = 0) : value(value), increment(increment) {} bool operator==(const iterator_type &rhs) const { return value >= rhs.value; } value_type operator++() const { return value += increment; } operator pointer() const { return &value; } }; typedef iterator_type iterator; typedef const iterator_type const_iterator; int first_, last_, increment_; range(int last) : first_(0), last_(last), increment_(1) {} range(int first, int last, int increment = 1) : first_(first), last_(last), increment_(increment) {} iterator begin() const {return iterator(first_, increment_);} iterator end() const {return iterator(last_);} }; int test(const range & range0, const range & range1){ foreach(int i, range0) { foreach(int j, range1) { std::cout
