[site]: stackoverflow
[post_id]: 5112270
[parent_id]: 
[tags]: 
In computer science, program or software optimization is the process of modifying a system to make some aspect of it work more efficiently or use fewer resources. In general, a computer program may be optimized so that it executes more rapidly, or is capable of operating with less memory storage or other resources, or draw less power Wikipedia . Other resources may include disk access, communication bandwidth, video performance and user interface responsiveness. Common software-related optimization goals are: Design or algorithm efficiency . Source code level. For example Duff's Device . Build level or optimizer flags, often trading build time for run-time efficiency. Compile level; choosing the best compiler. Assembly level. The best machine mapping to a problem. Run time. Examples include virtual machine parameters and profile guided optimization . Less strictly software-related optimization goals are: Query Optimization . This is the process of improving the design of a database query to increase performance. Use the query-optimization tag for questions about query optimization. Numerical Optimization . Use the mathematical-optimization tag for questions about numerical optimization. Teacher/colleague happiness. Writing software in a way that some important person or a group of persons appreciates the code as read by a human, e.g. for clarity and ease of maintenance. Performance optimization often increases program complexity and reduces its maintainability . Reducing space requirements often means code running slower, while making code run faster often increases its memory demands, although the most profound algorithmic optimization will often improve on both aspects. A commonly cited peril is "premature optimization" ("the root of all evil", as the saying goes). In contrast, the most dramatic effect on optimization is at the Design Level via algorithm efficiency ; this is the earliest stage of development thus seemingly a paradox. The way to resolve this paradox is to consider the correct order of implementations. Correctness should come first (thus starting with the simplest, most self-evidently correct code), algorithmic improvements second, performance-improving "micro-optimizations" come last. " Premature optimization" means focusing on micro-optimizations right away before even formulating a correct solution (which often leads to altogether wrong, though efficiently so, code); or before considering algorithmic optimizations which, if possible, would obviate those micro-optimizations in the first place. When using this tag, i.e. asking about optimization, please state the optimization goal you have in mind. The lists above illustrate that many possible optimization goals are mutually exclusive (e.g. performance vs simplicity / maintainability). It is hence not possible to optimize for everything; and optimizing without a clear goal is another common peril and makes a question too broad or unclear. See also: profiling assembly compiler
