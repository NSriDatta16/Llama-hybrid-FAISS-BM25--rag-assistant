[site]: stackoverflow
[post_id]: 4297367
[parent_id]: 
[tags]: 
Am I leaking memory in my UIScrollView implementation?

I am working on an app which uses a UIScrollView to scroll through a bunch of slides. When the app opens, it creates the slides and passes them to the scroll view. My app also has a timer which causes the UIScrollView to scroll through the slides. I also have a settings button. When I press on that button, it opens the settings panel. The timer is invalidated and set to nil . When the settings panel opens, the user can change things like the application theme, the slides and the animation direction. When the settings panel is closed, the settings are applied: The slides are removed from the UIScrollView and the UIScrollView is given a new NSArray of slides to work with. The UIScrollView then lays out the new slides in the proper order and direction. The timer is reset. Once, approximately every 14-16 times, the app crashes while running dismissAndRestart (the "close" code). I'm not sure why. I thought I was leaking memory, and apparently I am, but I don't see where. Here's my code: This runs on startup: - (void)viewDidLoad { [scrollView setPagingEnabled:YES]; } - (void) viewWillAppear:(BOOL)animated{ [self prepareViews]; [self applyTheme]; } - (void) viewDidAppear:(BOOL)animated{ [self createTimerWithInterval:kScrollInterval]; } Workhorse method that loads the views into the scroller. (It also removes the older ones): - (void)loadViews:(NSArray *)views IntoScroller:(UIScrollView *)scroller withDirection:(NSString *)direction{ [scrollView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)]; [scrollView setShowsHorizontalScrollIndicator: NO]; [scrollView setShowsVerticalScrollIndicator:NO]; scrollView.scrollsToTop = NO; if([direction isEqualToString:@"horizontal"]){ scrollView.frame = CGRectMake(0, 0, 1024, 768); scrollView.contentSize = CGSizeMake(scrollView.frame.size.width * [[NSNumber numberWithUnsignedInt:[views count]] floatValue], scrollView.frame.size.height); }else if([direction isEqualToString:@"vertical"]){ scrollView.frame = CGRectMake(0, 0, 1024, 768); scrollView.contentSize = CGSizeMake(scrollView.frame.size.width, scrollView.frame.size.height * [[NSNumber numberWithUnsignedInt:[views count]] floatValue]); } for (int i=0; i Create the timer for automated scrolling: #pragma mark - #pragma mark Create the Timer to automate scrolling - (void) createTimerWithInterval:(float)interval{ self.timer = [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(scrollWrapperForTimer) userInfo:nil repeats:YES]; } Wrapper function for the timer function. (This was necessary before the direction was an NSUserDefault, now I shouldn't need this.) #pragma mark - #pragma mark Scroll Automatically Every N seconds - (void) scrollWrapperForTimer{ [self scrollToNewViewInDirection:kDirection]; } - (void)scrollToNewViewInDirection:(NSString *)direction{ if([[NSUserDefaults standardUserDefaults] boolForKey:@"animated_scrolling"] == YES){ if([direction isEqualToString:@"horizontal"]){ if([[NSNumber numberWithFloat:scrollView.contentOffset.x] compare:[NSNumber numberWithFloat:scrollView.contentSize.width - scrollView.frame.size.width]] == (NSOrderedAscending)){ [scrollView scrollRectToVisible:CGRectMake(scrollView.contentOffset.x + scrollView.frame.size.width, 0, scrollView.frame.size.width, scrollView.frame.size.height) animated:YES]; }else if([[NSNumber numberWithFloat:scrollView.contentOffset.x] compare:[NSNumber numberWithFloat:scrollView.contentSize.width - scrollView.frame.size.width]] == (NSOrderedSame)){ [scrollView scrollRectToVisible:CGRectMake(0, 0, scrollView.frame.size.width, scrollView.frame.size.height) animated:YES]; } }else if([direction isEqualToString:@"vertical"]){ if([[NSNumber numberWithFloat:scrollView.contentOffset.y] compare:[NSNumber numberWithFloat:scrollView.contentSize.height - scrollView.frame.size.height]] == (NSOrderedAscending)){ [scrollView scrollRectToVisible:CGRectMake(0, scrollView.contentOffset.y + scrollView.frame.size.height, scrollView.frame.size.width, scrollView.frame.size.height) animated:YES]; }else if([[NSNumber numberWithFloat:scrollView.contentOffset.y] compare:[NSNumber numberWithFloat:scrollView.contentSize.height - scrollView.frame.size.height]] == (NSOrderedSame)){ [scrollView scrollRectToVisible:CGRectMake(0, 0, scrollView.frame.size.width, scrollView.frame.size.height) animated:YES]; } } }else { if([direction isEqualToString:@"horizontal"]){ if([[NSNumber numberWithFloat:scrollView.contentOffset.x] compare:[NSNumber numberWithFloat:scrollView.contentSize.width - scrollView.frame.size.width]] == (NSOrderedAscending)){ [scrollView scrollRectToVisible:CGRectMake(scrollView.contentOffset.x + scrollView.frame.size.width, 0, scrollView.frame.size.width, scrollView.frame.size.height) animated:NO]; }else if([[NSNumber numberWithFloat:scrollView.contentOffset.x] compare:[NSNumber numberWithFloat:scrollView.contentSize.width - scrollView.frame.size.width]] == (NSOrderedSame)){ [scrollView scrollRectToVisible:CGRectMake(0, 0, scrollView.frame.size.width, scrollView.frame.size.height) animated:NO]; } }else if([direction isEqualToString:@"vertical"]){ if([[NSNumber numberWithFloat:scrollView.contentOffset.y] compare:[NSNumber numberWithFloat:scrollView.contentSize.height - scrollView.frame.size.height]] == (NSOrderedAscending)){ [scrollView scrollRectToVisible:CGRectMake(0, scrollView.contentOffset.y + scrollView.frame.size.height, scrollView.frame.size.width, scrollView.frame.size.height) animated:NO]; }else if([[NSNumber numberWithFloat:scrollView.contentOffset.y] compare:[NSNumber numberWithFloat:scrollView.contentSize.height - scrollView.frame.size.height]] == (NSOrderedSame)){ [scrollView scrollRectToVisible:CGRectMake(0, 0, scrollView.frame.size.width, scrollView.frame.size.height) animated:NO]; } } } } This method gets called when the done button is pressed in the setting panel. #pragma mark - #pragma mark Restart the program - (void) dismissAndRestart{ [self prepareViews]; [self applyTheme]; [self dismissModalViewControllerAnimated:YES]; [self createTimerWithInterval:kScrollInterval]; } This creates the proper image files and loads them into place: #pragma mark - #pragma mark Apply the theme to the main view - (void) applyTheme{ //Front panel UIImage *frontImage = [[UIImage alloc] initWithContentsOfFile:[[NSBundle mainBundle] pathForResource:[[NSString stringWithFormat:@"%@_front", kTheme]description] ofType:@"png"]]; [self.overlayImage setImage:frontImage]; [frontImage release]; //Back Panel if([kTheme isEqualToString:@"walnut"]){ [self.backgroundImage setHidden:NO]; UIImage *backImage = [[UIImage alloc] initWithContentsOfFile:[[NSBundle mainBundle] pathForResource:[[NSString stringWithFormat:@"%@_back", kTheme]description] ofType:@"png"]]; [self.backgroundImage setImage:backImage]; [backImage release]; }else if([kTheme isEqualToString:@"metal"]){ [self.backgroundImage setHidden:YES]; [self.view setBackgroundColor: [UIColor scrollViewTexturedBackgroundColor]]; } //Gabbai Button UIImage *gabbaiImage = [[UIImage alloc] initWithContentsOfFile:[[NSBundle mainBundle] pathForResource:[[NSString stringWithFormat:@"%@_settings_button", kTheme]description] ofType:@"png"]]; [self.gabbaiButton setImage:gabbaiImage forState:UIControlStateNormal]; [gabbaiImage release]; } Another wrapper function that needs to be refactored: #pragma mark - #pragma mark Slide View related - (void) prepareViews{ [self loadViews:[self createandReturnViews] IntoScroller:scrollView withDirection:kDirection]; } Creates the Array of slides to pass to the scroller: //recreation of the views causes a delay each time the admin panel is closed. - (NSArray*) createandReturnViews{ NSMutableArray *announcements = [NSMutableArray array]; NSArray *announcementsArray = [NSArray arrayWithObjects: @"Welcome to\nGabbai HD!", @"First slide", @"Second Slide", @"Third Slide", @"etc.", nil]; for (int i = 0; i Why would my settings panel be crashing the app on close?
