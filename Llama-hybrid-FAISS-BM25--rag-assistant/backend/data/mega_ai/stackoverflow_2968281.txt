[site]: stackoverflow
[post_id]: 2968281
[parent_id]: 2968073
[tags]: 
There was a similar question that came up recently asking how to do this in SQL - there's no really elegant solution and unless this is Linq to SQL or Entity Framework (i.e. being translated into a SQL query), I'd really suggest that you not try to solve this problem with Linq and instead write an iterative solution; it's going to be a great deal more efficient and easier to maintain. That said, if you absolutely must use a set-based ("Linq") method, this is one way you could do it: var grouped = from n in nums group n by n into g select new { Num = g.Key, Qty = g.Count() }; int maxPerGroup = 2; var portioned = from x in grouped from i in Enumerable.Range(1, grouped.Max(g => g.Qty)) where (x.Qty % maxPerGroup) == (i % maxPerGroup) let tempQty = (x.Qty / maxPerGroup) == (i / maxPerGroup) ? (x.Qty % maxPerGroup) : maxPerGroup select new { Num = x.Num, Qty = (tempQty > 0) ? tempQty : maxPerGroup }; Compare with the simpler and faster iterative version: foreach (var g in grouped) { int remaining = g.Qty; while (remaining > 0) { int allotted = Math.Min(remaining, maxPerGroup); yield return new MyGroup(g.Num, allotted); remaining -= allotted; } }
