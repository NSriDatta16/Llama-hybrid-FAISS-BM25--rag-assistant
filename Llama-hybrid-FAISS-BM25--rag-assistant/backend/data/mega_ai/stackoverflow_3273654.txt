[site]: stackoverflow
[post_id]: 3273654
[parent_id]: 
[tags]: 
ostream showbase does not show "0x" for zero value

PSPS: (a Pre-scripted Post-script) It has just come to mind that a more prescient question would have included the notion of: Is this non-display of "0x"(showbase) for zero-value integers a standard behaviour, or is it just a quirk of my MinGW implementation? It all began on a pleasant Sunday morning... I want to dump some Handles in their hex representation, and in a consistant, formatted way. I want a leading 0x and a fixed width , but this is proving to be elusive using the expected stream manipulators. The only way I've found to do this is to cast the Handles to an unsigned long. This seems a bit unreasonable, and I would expect that I'm not the only person to have ever wanted this.. Am I missing something in the standard hex manipulators? Is it because type void* (HANDLE) is simply defined outside of the normal hex-handling of ostream? In summary: I don't want to have to cast HANDLE to something which it isn't. and I don't want to hard code a "0x" prefix. Is there a way to do it using standard manipulators? or would I need to overload ostream's handling of HANDLE? (but that might overload me!) Here is my test code (and its output). I've used '.' as the fill char, for clarity, (I will actually be using '0') HANDLE h; ULONG ul; int iH = sizeof(h); // how many bytes to this void* type. int iW = iH*2; // the max number of hex digits (width). int iW2= iW+2; // the max number of hex digits (+ 2 for showbase "0x"). int iX = 4; // the number of bits per hex digit. int ib = iH*8; // the max number bits in HANDLE (exponent). int i; std::cout
