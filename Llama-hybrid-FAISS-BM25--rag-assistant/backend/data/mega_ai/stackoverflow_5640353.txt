[site]: stackoverflow
[post_id]: 5640353
[parent_id]: 5639264
[tags]: 
If you're just going to be using the ivar internally, and you're using the modern runtime (Snow Leopard 64 bit and iOS 3.0+, I think) then you can just declare properties in a class extension and synthesize them inside the class. No ivars are exposed in your header, no messy id _internal objects, and you get around fragile ivars, too. // public header @interface MyClass : NSObject { // no ivars } - (void)someMethod; @end // MyClass.m @interface MyClass () @property (nonatomic, retain) NSString *privateString; @end @implementation MyClass @synthesize privateString; - (void)someMethod { self.privateString = @"Hello"; NSLog(@"self.privateString = %@", self.privateString); NSLog(@"privateString (direct variable access) = %@", privateString); // The compiler has synthesized not only the property methods, but also actually created this ivar for you. If you wanted to change the name of the ivar, do @synthesize privateString = m_privateString; or whatever your naming convention is } @end This works with Apple's gcc, in addition to LLVM. (I'm not sure if this works on other platforms, ie not Apple's gcc, but it will certainly work for both iOS and Snow Leopard+).
