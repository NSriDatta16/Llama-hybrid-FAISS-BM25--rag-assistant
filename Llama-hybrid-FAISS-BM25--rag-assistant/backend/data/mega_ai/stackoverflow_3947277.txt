[site]: stackoverflow
[post_id]: 3947277
[parent_id]: 3947083
[tags]: 
You're using an integer divide (both list_count and table->bucket_ct are ints), so your result will be truncated and you'll get a return value of 0 if the average bucket list length is less than 1.0 -- if you have more buckets in the hash table than entries. Since you want a double answer, it makes more sense to use a double divide: ret = (double)list_count / table->bucket_ct; edit It's tough to tell what's going on as you never print out the value of table or show the code that calls insert (which is where it gets its value). But a couple of things might be going on. table is a local var so the compiler might put it in a register and reuse that register for something else once table is dead (after the last use in the code), in which case printing table at that point (or anything depending on it) with gdb might print anything. if table is a dangling pointer into the stack (it comes from another function that returned the address of a local variable), it might well be pointing at memory used for some other local vars, in which case assigning to those local vars will change the value of table->buckets
