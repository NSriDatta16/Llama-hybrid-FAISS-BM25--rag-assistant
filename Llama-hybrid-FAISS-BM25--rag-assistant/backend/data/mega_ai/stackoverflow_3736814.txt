[site]: stackoverflow
[post_id]: 3736814
[parent_id]: 3730574
[tags]: 
You can't assign array contents using the = operator. First of all, an array object cannot be a target of the assignment operator ( Online C Standard, draft n1256 , section 6.5.16.1, paragraph 1). strings[0] is an array object of type char [6] , so it can't appear on the LHS of the = operator. Second of all, when an array expression is not an operand of either the sizeof or address-of & operators and is not a string literal being used to initialize the contents of another array, the type of the expression is implicitly converted ("decays") from "N-element array of T" to "pointer to T", and the value of the expression is the address of the first element in the array (section 6.3.2.1, paragraph 3). The string literal "test" is a 5-element array of char ( const char in C++) with static extent (meaning the memory for it is allocated at program startup and held until the program exits). However, when it appears in the expression strings[0] = "test"; its type is converted from "5-element array of char" to "pointer to char" and its value is the address of the first element, so what you wind up doing is attempting to assign a pointer value to an array object, which is not a compatible type; bad juju, over and above not being able to assign an array object anyway. If you want to copy the contents of one array to another, then you will need to either assign each array element individually, such as strings[0][0] = 't'; strings[0][1] = 'e'; strings[0][2] = 's'; strings[0][3] = 't'; strings[0][4] = 0; or even size_t len = strlen("test"); size_t i; for (i = 0; i or use a library function like memcpy() , strcpy() , strncpy() , strcat() , sprintf() , etc.: strcpy(strings[0], "test"); or strncpy(strings[0], "test", sizeof strings[0] - 1); // -1 to leave room // for 0 terminator // if necessary or sprintf(strings[0], "%*s", (int) sizeof strings[0] - 1, "test"); Note that you can initialize the array's contents when you declare it, like so: char foo[] = "test"; // foo is implicitly sized to 5 (+1 for 0 terminator) int bar[] = {1,2,3,4,5}; // again, size is implied from initializer float f[3] = {1.0, 2.0, 3.0}; // Initializer cannot contain more items than // array is sized for I see there's a merry war over the use of strcpy() vs. strncpy() in the comments to another answer; my position is to use whichever one is appropriate to the given situation. If you know that your buffers are big enough to handle the largest possible input, use strcpy() . If not, use strncpy() , but be aware that you may have to add the 0 terminator manually.
