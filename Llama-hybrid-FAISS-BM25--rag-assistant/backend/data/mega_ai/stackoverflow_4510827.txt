[site]: stackoverflow
[post_id]: 4510827
[parent_id]: 4325091
[tags]: 
I recommend using represent(Variant) because then youâ€™ll be leveraging the content negotiation functionality provided by the default implementation of handleGet(Request, Response) . BTW, lately I've started using the annotation-based syntax instead of overriding superclass methods, and I like it. I find it clearer, simpler, and more flexible. For example: @Post('html') Representation doSearch(Form form) throws ResourceException { // get a field from the form String query = form.getFirstValue("query"); // validate the form - primitive example of course if (query == null || query.trim().length() == 0) throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST, "Query is required."); // do something SearchResults searchResults = SearchEngine.doSearch(query); // return a HTML representation return new StringRepresentation(searchResults.asHtmlString(), MediaType.TEXT_HTML); } The advantages of using this approach include the incoming representation being automatically converted to a useful form, the method can be named whatever makes sense for your application, and just by scanning the class you can see which class methods handle which HTTP methods, for what kind of representations.
