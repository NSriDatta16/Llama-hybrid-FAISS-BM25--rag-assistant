[site]: stackoverflow
[post_id]: 1198007
[parent_id]: 
[tags]: 
Save Me on a Business Object

I've commonly seen examples like this on business objects: public void Save() { if(this.id > 0) { ThingyRepository.UpdateThingy(this); } else { int id = 0; ThingyRepository.AddThingy(this, out id); this.id = id; } } So why here, on the business object? This seems like contextual or data related more so than business logic. For example, a consumer of this object might go through something like this... ...Get form values from a web app... Thingy thingy = Thingy.CreateNew(Form["name"].Value, Form["gadget"].Value, Form["process"].Value); thingy.Save(); Or, something like this for an update... ... Get form values from a web app... Thingy thingy = Thingy.GetThingyByID(Int32.Parse(Form["id"].Value)); Thingy.Name = Form["name"].Value; Thingy.Save(); So why is this? Why not contain actual business logic such as calculations, business specific rules, etc., and avoid retrieval/persistence? Using this approach, the code might look like this: ... Get form values from a web app... Thingy thingy = Thingy.CreateNew(Form["name"].Value, Form["gadget"].Value, Form["process"].Value); ThingyRepository.AddThingy(ref thingy, out id); Or, something like this for an update... ... get form values from a web app ... Thingy thingy = ThingyRepository.GetThingyByID(Int32.Parse(Form["id"].Value)); thingy.Name = Form["Name"].Value; ThingyRepository.UpdateThingy(ref thingy); In both of these examples, the consumer, who knows best what is being done to the object, calls the repository and either requests an ADD or an UPDATE. The object remains DUMB in that context, but still provides it's core business logic as pertains to itself, not how it is retrieved or persisted. In short, I am not seeing the benefit of consolidating the GET and SAVE methods within the business object itself. Should I just stop complaining and conform, or am I missing something?
