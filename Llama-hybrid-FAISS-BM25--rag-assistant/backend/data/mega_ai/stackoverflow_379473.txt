[site]: stackoverflow
[post_id]: 379473
[parent_id]: 379172
[tags]: 
I think other answers (and their comments) have covered all the important points, but here's one thing that hasn't been done properly yet: What your code should look like instead: bool foo() //lowercase bool is a built-in C++ type. Use it if you're writing C++. { try { std::unique_ptr p(new int); // lots of code, and just return true or false directly when you're done } catch (std::bad_alloc){ // new throws an exception on OOM, it doesn't return NULL cout Well, it's shorter, and as far as I can see, more correct (handles the OOM case properly), and most importantly, I didn't need to write any cleanup code or do anything special to "make sure my return value is initialized". One problem with your code I only really noticed when I wrote this, is "what the hell is bRetVal's value at this point?". I don't know because, it was declared waaaaay above, and it was last assigned to when? At some point above this. I have to read through the entire function to make sure I understand what's going to be returned. And how do I convince myself that the memory gets freed? How do I know that we never forget to jump to the cleanup label? I have to work backwards from the cleanup label, finding every goto that points to it, and more importantly, find the ones that aren't there. I need to trace through all paths of the function just to be sure that the function gets cleaned up properly. That reads like spaghetti code to me. Very fragile code, because every time a resource has to be cleaned up you have to remember to duplicate your cleanup code. Why not write it once, in the type that needs to be cleaned up? And then rely on it being executed automatically, every time we need it?
