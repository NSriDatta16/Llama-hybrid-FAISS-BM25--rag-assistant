[site]: stackoverflow
[post_id]: 3526403
[parent_id]: 3523541
[tags]: 
This is caused by Canvas itself. It is not well perfomed for more advanced rendering. Insted you need to use a Visual class. It's a bit harder yet you gain the advantage of low level rendering. Solution download Here is the code: MainWindow.xaml Zoom WAY in to 0,0 Zoom WAY in to 200, 200 Zoom back MainWindow.xaml.cs using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Windows; using System.Windows.Controls; using System.Windows.Data; using System.Windows.Documents; using System.Windows.Input; using System.Windows.Media; using System.Windows.Media.Imaging; using System.Windows.Navigation; using System.Windows.Shapes; namespace VisualTest { /// /// Interaction logic for MainWindow.xaml /// public partial class MainWindow : Window { // Variables for dragging shapes. private bool isDragging = false; private Vector clickOffset; private DrawingVisual selectedVisual; // Drawing constants. private Brush drawingBrush = Brushes.Black; private Brush selectedDrawingBrush = Brushes.LightGoldenrodYellow; private Pen drawingPen = new Pen(Brushes.SteelBlue, 3); private Size squareSize = new Size(10, 10); public MainWindow() { InitializeComponent(); DrawingVisual v = new DrawingVisual(); DrawSquare(v, new Point(0, 0)); drawingSurface.AddVisual(v); v = new DrawingVisual(); DrawSquare(v, new Point(200, 200)); drawingSurface.AddVisual(v); } private void button1_Click(object sender, RoutedEventArgs e) { TransformGroup tg = new TransformGroup(); double scale = 1000000; double xCenter = 0; double yCenter = 0; double xOffset = (drawingSurface.ActualHeight / 2.0 - xCenter); double yOffset = (drawingSurface.ActualWidth / 2.0 - yCenter); ScaleTransform st = new ScaleTransform(scale, scale); st.CenterX = xCenter; st.CenterY = yCenter; TranslateTransform tt = new TranslateTransform(xOffset, yOffset); tg.Children.Add(st); tg.Children.Add(tt); drawingSurface.RenderTransform = st; } private void button2_Click(object sender, RoutedEventArgs e) { TransformGroup tg = new TransformGroup(); double scale = 1000000; double xCenter = 200; double yCenter = 200; double xOffset = (drawingSurface.ActualHeight / 2.0 - xCenter); double yOffset = (drawingSurface.ActualWidth / 2.0 - yCenter); ScaleTransform st = new ScaleTransform(scale, scale); st.CenterX = xCenter; st.CenterY = yCenter; TranslateTransform tt = new TranslateTransform(xOffset, yOffset); tg.Children.Add(st); tg.Children.Add(tt); drawingSurface.RenderTransform = st; } private void button3_Click(object sender, RoutedEventArgs e) { ScaleTransform st = new ScaleTransform(1, 1); drawingSurface.RenderTransform = st; } private void drawingSurface_MouseLeftButtonDown(object sender, MouseButtonEventArgs e) { Point pointClicked = e.GetPosition(drawingSurface); DrawingVisual visual = drawingSurface.GetVisual(pointClicked); if (visual != null) { // Calculate the top-left corner of the square. // This is done by looking at the current bounds and // removing half the border (pen thickness). // An alternate solution would be to store the top-left // point of every visual in a collection in the // DrawingCanvas, and provide this point when hit testing. Point topLeftCorner = new Point( visual.ContentBounds.TopLeft.X , visual.ContentBounds.TopLeft.Y ); DrawSquare(visual, topLeftCorner); clickOffset = topLeftCorner - pointClicked; isDragging = true; if (selectedVisual != null && selectedVisual != visual) { // The selection has changed. Clear the previous selection. ClearSelection(); } selectedVisual = visual; } } // Rendering the square. private void DrawSquare(DrawingVisual visual, Point topLeftCorner) { using (DrawingContext dc = visual.RenderOpen()) { Brush brush = drawingBrush; dc.DrawRectangle(brush, null, new Rect(topLeftCorner, squareSize)); } } private void drawingSurface_MouseLeftButtonUp(object sender, MouseButtonEventArgs e) { isDragging = false; } private void ClearSelection() { Point topLeftCorner = new Point( selectedVisual.ContentBounds.TopLeft.X , selectedVisual.ContentBounds.TopLeft.Y ); DrawSquare(selectedVisual, topLeftCorner); selectedVisual = null; } private void drawingSurface_MouseMove(object sender, MouseEventArgs e) { if (isDragging) { Point pointDragged = e.GetPosition(drawingSurface) + clickOffset; DrawSquare(selectedVisual, pointDragged); } } } } DrawingCanvas.cs using System; using System.Collections.Generic; using System.Text; using System.Windows.Media; using System.Windows.Controls; using System.Windows; namespace VisualTest { public class DrawingCanvas : Panel { private List visuals = new List (); protected override Visual GetVisualChild(int index) { return visuals[index]; } protected override int VisualChildrenCount { get { return visuals.Count; } } public void AddVisual(Visual visual) { visuals.Add(visual); base.AddVisualChild(visual); base.AddLogicalChild(visual); } public void DeleteVisual(Visual visual) { visuals.Remove(visual); base.RemoveVisualChild(visual); base.RemoveLogicalChild(visual); } public DrawingVisual GetVisual(Point point) { HitTestResult hitResult = VisualTreeHelper.HitTest(this, point); return hitResult.VisualHit as DrawingVisual; } private List hits = new List (); public List GetVisuals(Geometry region) { hits.Clear(); GeometryHitTestParameters parameters = new GeometryHitTestParameters(region); HitTestResultCallback callback = new HitTestResultCallback(this.HitTestCallback); VisualTreeHelper.HitTest(this, null, callback, parameters); return hits; } private HitTestResultBehavior HitTestCallback(HitTestResult result) { GeometryHitTestResult geometryResult = (GeometryHitTestResult)result; DrawingVisual visual = result.VisualHit as DrawingVisual; if (visual != null && geometryResult.IntersectionDetail == IntersectionDetail.FullyInside) { hits.Add(visual); } return HitTestResultBehavior.Continue; } } } Dragging system need to be rewrite. The idea is simple yet implementation is a bit complicated.
