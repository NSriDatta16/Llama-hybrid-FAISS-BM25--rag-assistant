[site]: stackoverflow
[post_id]: 4206121
[parent_id]: 2044926
[tags]: 
As you have probably noticed, jBPM has no concurrency controls for the process instance data. For instance, process variables cannot be locked when accessed nor are they implicitly locked by the engine. Truly parallel executions would lead to race conditions due to that. This is a common design trade-off when it comes to BPM engines. You avoid all concurrency control pitfalls (deadlocks, race conditions, starvation, consistency problems...) with a single thread of execution for each process instance. Business processes are supposed to be long-running but are also supposed to be waiting for some event to happen most of the time and should not be compute intensive by themselves. So CPU should never be a bottleneck when executing a single process instance. You can work around this limitation by splitting parallel workload out of the process as you described. You can also keep it inside the process by creating a java activity and manually spawns threads, though this is highly discouraged. For starters, you'll block the jBPM thread that's executing the instance and you won't be able to monitor progress of your parallelised workload.
