[site]: stackoverflow
[post_id]: 5590521
[parent_id]: 5589619
[tags]: 
It depends on the calling convention; for Unix, you typically look up this information in the SYSV ABI (Application Binary Interface). You may find: Return address (if the machine is a popular Intel architecture). On more modern architectures, the return address is passed in a register. Callee-saves registers—these are registers that "belong" to the caller which the callee has chosen to borrow and must therefore save and restore. Any incoming parameters that could not be passed in registers. In IA-32, no parameters are passed in registers; they all go on the stack. In x86-64, up to six integer and six floating-point parameters can be passed in registers, so it is seldom necessary to use the stack for that purpose. You may or may not find a saved stack pointer or frame pointer. Most modern calling conventions go without a frame pointer in order to save an extra registers. In this design, the size of each frame is known at compile time, so restoring the old stack pointer is just a matter of adding a constant. But it makes it harder to implement alloca() . The older Intel calling conventions use both stack pointer and frame pointer, which burns an extra register, but it simplifies alloca() and also stack unwinding. Local variables with storage class auto are allocated on the stack. The stack may contain compiler temporaries that hold values which are "spilled" if the hardware does not provide enough registers to hold all the intermediate results of computations. (This happens if at any point the number of live intermediate results—the ones that will be needed later in the program—exceeds the number of registers available to the compiler for storing intermediate results.) You may find variables allocated with alloca() . You may find metadata that says which PC ranges are in scope for which exception handlers, or other very platform-dependent exception stuff. C and C++ do not support garbage collection, but in a language that does, you will often find metadata that identifies where in the stack frame you will find pointers. Finally, the stack may contain "padding" used to ensure that the stack pointer is aligned on an 8-byte or 16-byte boundary. Calling conventions are complex beasts, and stack-frame layout is not for the faint of heart!
