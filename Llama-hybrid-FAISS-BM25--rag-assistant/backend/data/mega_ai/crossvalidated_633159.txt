[site]: crossvalidated
[post_id]: 633159
[parent_id]: 
[tags]: 
Distribution of team sizes when splitting up a company at random

A monopoly has just lost an anti-trust case with the government, and will soon be broken into two smaller, separate companies. The former owners, bitter about this outcome, withhold the organisation's team rosters, making it difficult for government officials to break apart the company along team lines. The officials decide to go ahead with the breakup anyway, simply choosing a subset of employees at random to bring across into a newly created company. However, they are worried about the team composition in the newly created company being too low, and ask us to figure out what the expected distribution of team sizes will be in the newly created company, given this reliance on random selection. Knowing this will provide information on how much spending is needed to re-organise/rebuild teams in the new company. The question is broken down into the following problem in probability. The Problem Given a population of $N$ (employees in the monopoly company), a new company is to be created with size $n$ (the sample size). The monopoly comprises teams of size $G$ only (say, e.g. $G$ = 10), and each employee is only in one team. It follows that $N$ is perfectly divisible by $G$ : $G | N$ . For all possible team sizes in the newly created company, $g$ [ $1\le g\le min(G,n)$ ], we want to calculate $H(N,n,G,g)$ [ $\sum_g H(N,n,G,g) = 1)$ ], or, the distribution of varying team sizes in the newly created company. Note, for those individuals selected from the old monopoly without the rest of their team, we still describe them as "teams of size 1" in the new company. What I've Tried So Far I first broke the problem down into an easier one: Calculating the number of ways in which $k$ occurrences of size- $g$ teams might occur in the newly created company of size $n$ . Before I describe what each part means, here is that equation I came up with for this number: $ {\frac{N}{G}\choose{k}} {{G}\choose{g}}^k \left[ {N-Gk\choose n-gk} + \sum\limits_{i=1}^{ \min\left( \frac{n-gk}{g}, \frac{N-Gk}{G} \right) } \left[- {{G}\choose{g}}\right]^i {\frac{N-Gk}{G}\choose i} {N-Gk-Gi\choose {n-gk-gi}} \right] $ The first part of the equation, ${\frac{N}{G}\choose{k}}$ , concerns itself with how many ways there are to select $k$ teams from all the teams in the monopoly. After this, ${{G}\choose{g}}^k$ addresses the question of, how many ways are there to extract teams of size $g$ from each of the selected $k$ teams? At this point, we have all the $k$ teams of size $g$ , but there are still many ways to populate the rest. If there were no constraints at all on how we populate the rest, there would be ${N-Gk\choose n-gk}$ ways to fill that space. We simply need to subtract the bad combinations from this, and then we have the number of valid ways to fill in the remaining space. This subtract the invalid combinations part is what the $\sum$ does. This last part is a bit tricky, because it first subtracts too much, then corrects for this by adding (too much), correcting again, plus and minus back and forward a few times, and then the sum is the total number of invalid ways to fill in the rest of the space, which then gets subtracted to create a factor that can be described as total valid ways to fill the remaining space . Validating the Above I validated that the above expression is correct using the following Python program. The program uses the formula to predict combinations, and then uses exhaustive simulation (more computationally heavy) to compare these predictions against the reality. The program found no mismatches in a moderately sized search space. from math import comb, perm, factorial from itertools import combinations def predict(N, n, G, g, k): if N % G != 0: raise Exception("(G | N) is a must.") if k * g > n: raise Exception("kg > n is a must.") product = comb(G, g) ** k product *= comb(N // G, k) factor_overestimate = comb(N - G * k, n - g * k) limit = min( (n - g * k) // g, (N - G * k) // G ) for i in range(1, limit + 1): calibration = (-1) ** i calibration *= comb(G, g) ** i calibration *= comb((N - G * k) // G, i) calibration *= comb(N - G * k - G * i, n - g * k - g * i) factor_overestimate += calibration factor = factor_overestimate product *= factor return product def validate(N, n, G, g, k): population = sorted(list(range(N//G)) * G) counts = {} count_counts = {} good = 0 for combination in combinations(population, n): for c in combination: counts[c] = counts.get(c, 0) + 1 for count in counts.values(): count_counts[count] = count_counts.get(count, 0) + 1 g_count = count_counts.get(g, 0) if g_count == k: good += 1 counts.clear() count_counts.clear() return good print("N,n,G,g,k,p,v,bad") for G in range(1, 6): for N in range(0, 30, G): n = 5 for n in range(0, min(10, N) + 1): for g in range(2, G): for k in range(1, min(N // G, n // g + 1)): bad = False p = None v = None try: p = predict(N, n, G, g, k) v = validate(N, n, G, g, k) except Exception: bad = True if p is None or p != v: print(N,n,G,g,k,p,v,bad,sep=",") Applying the Formula To apply the formula to the aforementioned $H(N, n, G, g)$ problem, I use the following: $ H(N,n,G,g) = \frac{g\sum\limits_{k=1}^{\left\lfloor\frac{n}{g}\right\rfloor} k{\frac{N}{G}\choose{k}} {{G}\choose{g}}^k \left[ {N-Gk\choose n-gk} + \sum\limits_{i=1}^{ \min\left( \frac{n-gk}{g}, \frac{N-Gk}{G} \right) } \left[- {{G}\choose{g}}\right]^i {\frac{N-Gk}{G}\choose i} {N-Gk-Gi\choose {n-gk-gi}} \right] }{n{N\choose{n}}} $ This basically just uses the earlier formula as the kernel of a sum over all reasonable values of $k$ , counting up individuals in the combinations who fit the criteria of $H$ , and dividing that count by the sum of all individuals across all combinations (the denominator). My questions: Is the first formula I presented (above the Python code) really the best way to find the number of combinations with $k\times g$ -sized groups among $n$ ? It seems too long and inefficient for such a simple problem, but it was the best I could come up with for the moment. Are there any other more efficient alternatives to the above $H(N,n,G,g)$ formula?
