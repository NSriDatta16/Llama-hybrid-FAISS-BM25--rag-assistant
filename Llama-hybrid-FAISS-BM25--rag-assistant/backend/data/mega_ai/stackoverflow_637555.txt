[site]: stackoverflow
[post_id]: 637555
[parent_id]: 637535
[tags]: 
Create a new instance and then use the linq mapping classes together with reflection to copy member values. E.g. public static void CopyDataMembers(this DataContext dc, object sourceEntity, object targetEntity) { //get entity members IEnumerable dataMembers = from mem in dc.Mapping.GetTable(sourceEntity.GetType()) .RowType.DataMembers where mem.IsAssociation == false select mem; //go through the list of members and compare values foreach (MetaDataMember mem in dataMembers) { object originalValue = mem.StorageAccessor.GetBoxedValue(targetEntity); object newValue = mem.StorageAccessor.GetBoxedValue(sourceEntity); //check if the value has changed if (newValue == null && originalValue != null || newValue != null && !newValue.Equals(originalValue)) { //use reflection to update the target System.Reflection.PropertyInfo propInfo = targetEntity.GetType().GetProperty(mem.Name); propInfo.SetValue(targetEntity, propInfo.GetValue(sourceEntity, null), null); // setboxedvalue bypasses change tracking - otherwise // mem.StorageAccessor.SetBoxedValue(ref targetEntity, newValue); // could be used instead of reflection } } } ...or you can clone it using the DataContractSerializer: internal static T CloneEntity (T originalEntity) where T : someentitybaseclass { Type entityType = typeof(T); DataContractSerializer ser = new DataContractSerializer(entityType); using (MemoryStream ms = new MemoryStream()) { ser.WriteObject(ms, originalEntity); ms.Position = 0; return (T)ser.ReadObject(ms); } }
