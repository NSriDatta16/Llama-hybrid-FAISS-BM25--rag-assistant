[site]: stackoverflow
[post_id]: 1571413
[parent_id]: 1570810
[tags]: 
Clojure is designed for concurrency . Clojure provides concurrency primitives at a higher level of abstraction than Java. Some of these are: A Software Transactional Memory system for dealing with synchronous and coordinated changes to shared references. You can change several references as an atomic operation and you don't have to worry about what the other threads in your program are doing. Within your transaction you will always have a consistent view of the world. An agent system for asynchronous change. This resembles message passing in Erlang. Thread local changes to variables. These variables have a root binding which are shared by every thread in your program. However, when you re-bind a variable it will only be visible in that thread. All these concurrency primitives are built on top of Clojures immutable data structures (i.e., lists, maps, vectors etc.). When you enter the world of mutable Java objects all of the primitives break down and you are back to locks and condition variables (which also can be used in clojure, when necessary).
