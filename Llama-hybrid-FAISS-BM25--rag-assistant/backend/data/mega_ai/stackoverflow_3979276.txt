[site]: stackoverflow
[post_id]: 3979276
[parent_id]: 3973374
[tags]: 
First, I'm assuming that you are going to use the qsort or similar function to do your sorting, and need a comparison function to pass to that. These comparison functions behave like memcnp and strcmp -- returning an integer to signify less than, equal to, or greater than. One way to do this is by treating the entire color value as one big number as far as the comparison goes: int bright_hue_compare(const void * a, const void * b) { int rc = bright_compare(a, b); if (!rc) { rc = hue_compare(a, b); } return rc; } This would group colors first by their brightness (assuming that you write a brightness compare function) and second by their hue. You may want to swap the order of these, and internally they can be more complicated. Sorting such that similar colors are further from each other is more complicated, since you really need to compare it to several values possible neighbor values at a time to space them out further. I doubt that you could get this reliably with quicksort (the stdlib qsort function may not be quicksort, but assuming that it is), though: int bright_hue_inverse_compare(const void * a, const void * b) { int rc = bright_hue_compare(a, b); if (rc) { return 0; } return random(); // so that they are the same so randomize greater/lesser } Might be good enough for you, but yields far from optimal results. Really you would probably have to write your own sorting function for this, and it will probably be have a very high run time because each color needs to be compared against many of its neighbors. The more optimal you want this distribution the more this starts to look like an AI problem where each color wants to move as far away from like colors as it can. Oh, something that I just thought of that might yield good results would be if averaged all of the hues and all of the brightnesses and then divided the array in half and tried to make each sub-array's averages be as close as you could to the averages of the entire array as you could by swapping some colors between the arrays to balance things out. Then you divide these arrays in half and repeat. I don't think you will (and probably can't) get optimal results with this, but I think it's may be pretty good. Finding what to swap would be the biggest problem here.
