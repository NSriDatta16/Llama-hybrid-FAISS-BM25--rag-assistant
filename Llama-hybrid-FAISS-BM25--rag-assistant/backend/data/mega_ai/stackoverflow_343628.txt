[site]: stackoverflow
[post_id]: 343628
[parent_id]: 343605
[tags]: 
You can use a technique called NVI ( Non-Virtual-Interface ) together with the template method pattern. This probably is how i would do it (of course, it's only my personal opinion, which is indeed debatable): class Printer { public: // checks invariant, and calls the actual queuing void Queue(const PrintJob&); private: virtual void DoQueue(const PringJob&); }; void Printer::Queue(const PrintJob& job) // not virtual { // Validate the state in both release and debug builds. // Never proceed with the queuing in a bad state. if(!IsValidState()) { throw std::logic_error("Printer not ready"); } // call virtual method DoQueue which does the job DoQueue(job); } void Printer::DoQueue(const PrintJob& job) // virtual { // Do the actual Queuing. State is guaranteed to be valid. } Because Queue is non-virtual, the invariant is still checked if a derived class overrides DoQueue for special handling. To your options: I think it depends on the condition you want to check. If it is an internal invariant If it is an invariant, it should not be possible for a user of your class to violate it. The class should care about its invariant itself. Therefor, i would assert(CheckInvariant()); in such a case. It's merely a pre-condition of a method If it's merely a pre-condition that the user of the class would have to guarantee (say, only printing after the printer is ready), i would throw std::logic_error as shown above. I would really discourage from check a condition, but then doing nothing. The user of the class could itself assert before calling a method that the pre-conditions of it are satisfied. So generally, if a class is responsible for some state, and it finds a state to be invalid, it should assert. If the class finds a condition to be violated that doesn't fall in its responsibility, it should throw.
