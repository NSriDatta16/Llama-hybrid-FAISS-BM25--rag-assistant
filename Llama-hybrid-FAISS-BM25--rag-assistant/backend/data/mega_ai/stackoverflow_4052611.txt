[site]: stackoverflow
[post_id]: 4052611
[parent_id]: 4052204
[tags]: 
I've been trying to find an elegant solution to the problem for a while now. I wish that the framework designers had added a little "IsImmutable" or similar property getter to IEnumerable so that one could easily add an Evaluate (or similar) extension method that doesn't do anything for an IEnumerable that is already in its "fully evaluated" state. However, since that doesn't exist, here's the best I've been able to come up with: I've created my own interface that exposes the immutability property, and I implement it in all of my custom collection types. My implementation of the Evaluate extension method is aware of this new interface as well as the immutability of the subset of relevant BCL types that I consume most frequently. I avoid returning "raw" BCL collection types from my APIs in order to increase the efficiency of my Evaluate method (at least when running against my own code). It's rather kludgy, but it's the least intrusive approach I've been able to find so far to address the problem of allowing an IEnumerable consumer to create a local copy only when this is actually necessary. I very much hope that your question lures some more interesting solutions out of the woodwork...
