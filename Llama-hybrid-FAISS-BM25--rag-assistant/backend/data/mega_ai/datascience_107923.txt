[site]: datascience
[post_id]: 107923
[parent_id]: 
[tags]: 
Does the sequence length of a RNN/LSTM have to be the same for the input and output?

I have a question about the input and output data in a RNN or LSTM. A RNN expects a 3-dimensional vector as input of the form (Batch_size, sequence_length_input, features_input) and a 3-dimensional output vector of the form (Batch_size, sequence_length_output, features_output). I know that the features_input and features_output don't have to have the same number. But what about the middle part sequence_length_input and sequence_length_output. Do they have to be the same? At least in my example (with Keras and Tensorflow) I always get an error if they are not the same. So I am wondering whetever I have a bug in the code or if this is generally not possible. Update : Here is my code with a RNN for time series forecasting that only works if the sequence_length of the input steps_backward is equal to the sequence_length of the output steps_forward otherwise it will throw a ValueError: ValueError: Dimensions must be equal, but are 192 and 96 for '{{node mean_squared_error/SquaredDifference}} = SquaredDifference[T=DT_FLOAT](sequential_5/time_distributed_5/Reshape_1, IteratorGetNext:1)' with input shapes: [?,192,1], [?,96,1]. In the code I use the 96 past timesteps (or 2*96=192 timesteps) to predict the future 96 timesteps. When the number of past and future timesteps are equal (equal sequence_length), everything works fine. Otherwise (unequal sequence_length) I get the ValueError. #Import modules import pandas as pd import numpy as np import tensorflow as tf from sklearn.preprocessing import StandardScaler from tensorflow import keras # Define the parameters of the RNN and the training epochs = 1 batch_size = 50 steps_backwards = 2 * 96 steps_forward = 96 split_fraction_trainingData = 0.70 split_fraction_validatinData = 0.90 randomSeedNumber = 50 #Read dataset df = pd.read_csv('C:/Users/User1/Desktop/TestData.csv', sep=';', header=0, low_memory=False, infer_datetime_format=True, parse_dates={'datetime':[0]}, index_col=['datetime']) # standardize data data = df.values indexWithYLabelsInData = 0 data_X = data[:, 0:3] data_Y = data[:, indexWithYLabelsInData].reshape(-1, 1) scaler_standardized_X = StandardScaler() data_X = scaler_standardized_X.fit_transform(data_X) data_X = pd.DataFrame(data_X) scaler_standardized_Y = StandardScaler() data_Y = scaler_standardized_Y.fit_transform(data_Y) data_Y = pd.DataFrame(data_Y) # Prepare the input data for the RNN series_reshaped_X = np.array([data_X[i:i + (steps_backwards+steps_forward)].copy() for i in range(len(data) - (steps_backwards+steps_forward))]) series_reshaped_Y = np.array([data_Y[i:i + (steps_backwards+steps_forward)].copy() for i in range(len(data) - (steps_backwards+steps_forward))]) timeslot_x_train_end = int(len(series_reshaped_X)* split_fraction_trainingData) timeslot_x_valid_end = int(len(series_reshaped_X)* split_fraction_validatinData) X_train = series_reshaped_X[:timeslot_x_train_end, :steps_backwards] X_valid = series_reshaped_X[timeslot_x_train_end:timeslot_x_valid_end, :steps_backwards] X_test = series_reshaped_X[timeslot_x_valid_end:, :steps_backwards] Y_train = series_reshaped_Y[:timeslot_x_train_end, steps_backwards:] Y_valid = series_reshaped_Y[timeslot_x_train_end:timeslot_x_valid_end, steps_backwards:] Y_test = series_reshaped_Y[timeslot_x_valid_end:, steps_backwards:] # Build the model and train it np.random.seed(randomSeedNumber) tf.random.set_seed(randomSeedNumber) model = keras.models.Sequential([ keras.layers.SimpleRNN(10, return_sequences=True, input_shape=[None, 3]), keras.layers.SimpleRNN(10, return_sequences=True), keras.layers.TimeDistributed(keras.layers.Dense(1)) ]) model.compile(loss="mean_squared_error", optimizer="adam") history = model.fit(X_train, Y_train, epochs=epochs, batch_size=batch_size, validation_data=(X_valid, Y_valid)) #Predict the test data Y_pred = model.predict(X_test) and here is some test data https://filetransfer.io/data-package/ufbzh09o#link Reminder : The code and the data provide a Minimal reproducible example. Maybe you can have a look at it as in this code the sequence_length has to be equal for the input and output data, otherwise I get an error. Unfortuantely I still have not figured out why this this problem occurs
