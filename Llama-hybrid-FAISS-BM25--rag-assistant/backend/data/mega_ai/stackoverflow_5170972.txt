[site]: stackoverflow
[post_id]: 5170972
[parent_id]: 5170321
[tags]: 
I think what you're looking for is split between SampleModel and ColorModel . The SampleModel describes how the data is organized which allows you to get the data for one or more pixels. (You get a SampleModel by calling bi.getData().getSampleModel(), where bi is a BufferedImage). ColorModel then provides methods ( getAlpha , getRed , getGreen , GetBlue ) for getting the ARGB components from a pixel. Addendum: I think the way you use this is: BufferedImage bi = ...; Raster r = bi.getData(); // Use the sample model to get the pixel SampleModel sm = r.getSampleModel(); Object pixel = sm.getPixel(0, 0, (int[])null, r.getDataBuffer()); // Use the color model to get the red value from the pixel ColorModel cm = bi.getColorModel(); int red = cm.getRed(pixel[0]); This looks like it would be very flexible for handling any color/sample model you may encounter, but I can't imagine the performance would be spectacular. I'd probably use this model agnostic approach to convert the image to TYPE_INT_ARGB where the layout is well documented, then manipulate the data directly. Then, if necessary, convert it back to the original form.
