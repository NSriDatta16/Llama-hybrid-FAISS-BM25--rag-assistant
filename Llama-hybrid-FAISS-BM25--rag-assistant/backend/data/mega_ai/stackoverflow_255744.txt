[site]: stackoverflow
[post_id]: 255744
[parent_id]: 255612
[tags]: 
For building containers you obviously want to use one of the standard containers (such as a std::vector). But this is a perfect example of the things you need to consider when your object contains RAW pointers. If your object has a RAW pointer then you need to remember the rule of 3 (now the rule of 5 in C++11). Constructor Destructor Copy Constructor Assignment Operator Move Constructor (C++11) Move Assignment (C++11) This is because if not defined the compiler will generate its own version of these methods (see below). The compiler generated versions are not always useful when dealing with RAW pointers. The copy constructor is the hard one to get correct (it's non trivial if you want to provide the strong exception guarantee). The Assignment operator can be defined in terms of the Copy Constructor as you can use the copy and swap idiom internally. See below for full details on the absolute minimum for a class containing a pointer to an array of integers. Knowing that it is non trivial to get it correct you should consider using std::vector rather than a pointer to an array of integers. The vector is easy to use (and expand) and covers all the problems associated with exceptions. Compare the following class with the definition of A below. class A { std::vector mArray; public: A(){} A(size_t s) :mArray(s) {} }; Looking at your problem: A* arrayOfAs = new A[5]; for (int i = 0; i The compiler generated assignment operator is fine for nearly all situations, but when RAW pointers are in play you need to pay attention. In your case it is causing a problem because of the shallow copy problem. You have ended up with two objects that contain pointers to the same piece of memory. When the A(3) goes out of scope at the end of the loop it calls delete [] on its pointer. Thus the other object (in the array) now contains a pointer to memory that has been returned to the system. The compiler generated copy constructor ; copies each member variable by using that members copy constructor. For pointers this just means the pointer value is copied from the source object to the destination object (hence shallow copy). The compiler generated assignment operator ; copies each member variable by using that members assignment operator. For pointers this just means the pointer value is copied from the source object to the destination object (hence shallow copy). So the minimum for a class that contains a pointer: class A { size_t mSize; int* mArray; public: // Simple constructor/destructor are obvious. A(size_t s = 0) {mSize=s;mArray = new int[mSize];} ~A() {delete [] mArray;} // Copy constructor needs more work A(A const& copy) { mSize = copy.mSize; mArray = new int[copy.mSize]; // Don't need to worry about copying integers. // But if the object has a copy constructor then // it would also need to worry about throws from the copy constructor. std::copy(&copy.mArray[0],&copy.mArray[c.mSize],mArray); } // Define assignment operator in terms of the copy constructor // Modified: There is a slight twist to the copy swap idiom, that you can // Remove the manual copy made by passing the rhs by value thus // providing an implicit copy generated by the compiler. A& operator=(A rhs) // Pass by value (thus generating a copy) { rhs.swap(*this); // Now swap data with the copy. // The rhs parameter will delete the array when it // goes out of scope at the end of the function return *this; } void swap(A& s) noexcept { using std::swap; swap(this.mArray,s.mArray); swap(this.mSize ,s.mSize); } // C++11 A(A&& src) noexcept : mSize(0) , mArray(NULL) { src.swap(*this); } A& operator=(A&& src) noexcept { src.swap(*this); // You are moving the state of the src object // into this one. The state of the src object // after the move must be valid but indeterminate. // // The easiest way to do this is to swap the states // of the two objects. // // Note: Doing any operation on src after a move // is risky (apart from destroy) until you put it // into a specific state. Your object should have // appropriate methods for this. // // Example: Assignment (operator = should work). // std::vector() has clear() which sets // a specific state without needing to // know the current state. return *this; } }
