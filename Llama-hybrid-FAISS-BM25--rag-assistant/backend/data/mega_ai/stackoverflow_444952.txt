[site]: stackoverflow
[post_id]: 444952
[parent_id]: 444245
[tags]: 
If you browse the .NET Framework assemblies and drill down into the base classes for any of the standard objects, you will notice many interfaces (members named as ISomeName). Interfaces are basically for implementing frameworks, large or small. I felt the same way about interfaces until I wanted to write a framework of my own. I also found that understanding interfaces helped me learn frameworks much more rapidly. The moment that you want to write a more elegant solution for just about anything, you will find that an interface makes a lot of sense. It's like a method of letting a class put on the appropriate clothes for the job. More importantly, interfaces allow systems to become much more self-documenting, because complex objects become less complex when the class implements interfaces, which helps to categorize its functionality. Classes implement interfaces when they want to be able to participate in a framework explicitly or implicitly. For example, IDisposable is a common interface that provides method signature for the popular and useful Dispose() method. In a framework, all that you or another developer needs to know about a class is that if it implements IDisposable, then you know that ((IDisposable)myObject).Dispose() is available to be called for cleanup purposes. CLASSIC EXAMPLE: without implementing the IDisposable interface, you cannot use the "using( )" keyword construct in C#, because it requires that any object specified as a parameter can be implicitly cast to IDisposable. COMPLEX EXAMPLE: A more complex example would be the System.ComponentModel.Component class. This class implements both IDisposable and IComponent. Most, if not all, .NET objects that have a visual designer associated with them implement IComponent so that the IDE will be able to interact with the component. CONCLUSION: As you become more familiar with the .NET Framework, the first thing you will do when encountering a new class in the Object Browser or within the .NET Reflector (free) tool ( http://www.red-gate.com/products/reflector/ ) is to check to see which class it inherits from and also the interfaces that it implements. .NET Reflector is even better than the Object Browser because it lets you see the Derived classes as well. That allows you to learn about all objects that derive from a particular class, thereby potentially learning about framework functionality that you did not know existed. This is particularly significant when updated or new namespaces are added to the .NET Framework.
