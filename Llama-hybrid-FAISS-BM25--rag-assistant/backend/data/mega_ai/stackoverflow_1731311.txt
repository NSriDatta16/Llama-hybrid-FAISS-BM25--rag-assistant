[site]: stackoverflow
[post_id]: 1731311
[parent_id]: 1720803
[tags]: 
I would not use the AStar algorithm there yet, unless I really need to, because this can be done with some simple 'coloring'. # maze is a m x n array def canBeTraversed(maze): m = len(maze) n = len(maze[0]) colored = [ [ False for i in range(0,n) ] for j in range(0,m) ] open = [(0,0),] while len(open) != 0: (x,y) = open.pop() if x == m-1 and y == n-1: return True elif x Yes it's stupid, yes it's breadfirst and all that. Here is the A* implementation def dist(x,y): return (abs(x[0]-y[0]) + abs(x[1]-y[1]))^2 def heuristic(x,y): return (x[0]-y[0])^2 + (x[1]-y[1])^2 def find(open,f): result = None min = None for x in open: tmp = f[x[0]][x[1]] if min == None or tmp Here is my (simple) benchmark code: def tryIt(func,size, runs): maze = [ [ 1 for i in range(0,size) ] for j in range(0,size) ] begin = datetime.datetime.now() for i in range(0,runs): func(maze) end = datetime.datetime.now() print size, 'x', size, ':', (end - begin) / runs, 'average on', runs, 'runs' tryIt(canBeTraversed,100,100) tryIt(canBeTraversed,1000,100) tryIt(canBeTraversedAStar,100,100) tryIt(canBeTraversedAStar,1000,100) Which outputs: # For canBeTraversed 100 x 100 : 0:00:00.002650 average on 100 runs 1000 x 1000 : 0:00:00.198440 average on 100 runs # For canBeTraversedAStar 100 x 100 : 0:00:00.016100 average on 100 runs 1000 x 1000 : 0:00:01.679220 average on 100 runs The obvious here: going A* to run smoothly requires a lot of optimizations I did not bother to go after... I would say: Don't optimize (Expert only) Don't optimize yet How much time are you talking about when you say too much ? Really a 100x100 grid is so easily parsed in brute force it's a joke :/
