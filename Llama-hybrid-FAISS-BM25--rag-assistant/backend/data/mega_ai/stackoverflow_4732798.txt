[site]: stackoverflow
[post_id]: 4732798
[parent_id]: 4729820
[tags]: 
As @Alf P. Steinbach noted, you oversaw the fact that copying your pointer would yield a non-const object pointing to the same underlying object. Pimpl (below) nicely circumvent the issue by performing a deep-copy, unique_ptr circumvents it by being non-copyable. It is much easier, of course, if the pointee is owned by a single entity. Boost.Optional propagates const-ness, however it's not exactly a pointer (though it models the OptionalPointee concept). I know of no such other library. I would favor that they provide it by default. Adding another template parameter (traits class I guess) does not seem worth the trouble. However that would radically change the syntax from a classic pointer, so I am not sure that people would be ready to embrace it. Code of the Pimpl class template class Pimpl { public: /** * Types */ typedef T value; typedef const T const_value; typedef T* pointer; typedef const T* const_pointer; typedef T& reference; typedef const T& const_reference; /** * Gang of Four */ Pimpl() : _value(new T()) {} explicit Pimpl(const_reference v) : _value(new T(v)) {} Pimpl(const Pimpl& rhs) : _value(new T(*(rhs._value))) {} Pimpl& operator=(const Pimpl& rhs) { Pimpl tmp(rhs); swap(tmp); return *this; } // operator= ~Pimpl() { boost::checked_delete(_value); } void swap(Pimpl& rhs) { pointer temp(rhs._value); rhs._value = _value; _value = temp; } // swap /** * Data access */ pointer get() { return _value; } const_pointer get() const { return _value; } reference operator*() { return *_value; } const_reference operator*() const { return *_value; } pointer operator->() { return _value; } const_pointer operator->() const { return _value; } private: pointer _value; }; // class Pimpl // Swap template void swap(Pimpl & lhs, Pimpl & rhs) { lhs.swap(rhs); } // Not to be used with pointers or references template class Pimpl {}; template class Pimpl {};
