[site]: stackoverflow
[post_id]: 3244701
[parent_id]: 3237696
[tags]: 
Don't do this; what you're doing is porting a pattern from one context to another where it doesn't really make sense. For one thing, you shouldn't be modeling IDs at all in Core Data; the framework does that for you with NSManagedObjectID already. Thus a -clientWithID: method on a CoreDataDAL class is redundant. (Note that I've also changed the name of your hypothetical method to follow proper Cocoa naming conventions.) Instead, you can just use -[NSManagedObjectContext objectWithID:] or -[NSManagedObjectContext existingObjectWithID:error:] to get an object based on its NSManagedObjectID. Similarly, relationship management is handled for you. You don't need to have a method in your DAL that can (say) fetch all of the Address instances that apply for a given Client by evaluating some query. You can just traverse your Client's to-many addresses relationship to get at them, and manipulate the same relationship directly (rather than setting foreign keys etc.). Finally, if you really do want to have methods to perform specialized queries, you can either specify the query via a fetched property on the appropriate entity for its results, or you can add that method directly to the appropriate class . Class methods in Objective-C aren't like static methods in C++, Java or C# - they can be overridden just as instance methods can, and are much more appropriate for this kind of use. For example, say your Client entity has a syncID property representing the ID of the object that it represents in some web service. (Note that this is specifically for relating a local object to a remote object, not the "primary key" of the local object.) You'd probably have class methods on the MyClient class associated with your Client entity like this: @implementation MyClient + (NSString *)entityClassName { return @"Client"; } + (NSEntityDescription *)entityInManagedObjectContext:(NSManagedObjectContext *)context { return [NSEntityDescription entityForName:[self entityClassName] inManagedObjectContext:context]; } + (MyClient *)clientWithSyncID:(NSString *)syncID inManagedObjectContext:(NSManagedObjectContext *)context error:(NSError **)error { MyClient *result = nil; NSFetchRequest *request = [[NSFetchRequest alloc] init]; [request setEntity:[self entityInManagedObjectContext:context]]; [request setPredicate:[NSPredicate predicateWithFormat:@"syncID == %@", syncID]]; [request setFetchLimit:1]; NSArray *results = [context executeFetchRequest:request error:error]; if ([results count] > 0) { result = [results objectAtIndex:0]; } else { if (error != NULL) { *error = [NSError errorWithDomain:MyAppErrorDomain code:MyAppNoClientFoundError userInfo:nil]; } } return result; } @end This is similar to what you wrote in your DAL class, but instead of consolidating all of the fetches in one place, it puts the logic for fetches appropriate to a particular managed object class on that class, which is really where it belongs. Thanks to the fact Objective-C has true class methods, you can actually put methods like +entityInManagedObjectContext: and +entityClassName on a common base class and then override only the latter as appropriate in subclasses (or even have it generate an appropriate entity name from the class name). To sum up: Don't recreate what Core Data already implements for you in terms of things like object IDs, relationship management, and so on. Leverage polymorphism at both the instance and the class level to keep your code clean, rather than use "utility" classes like "data access layers."
