[site]: stackoverflow
[post_id]: 4717924
[parent_id]: 4717761
[tags]: 
Quoting the django source for value_from_datadict() : Given a dictionary of data and this widget's name, returns the value of this widget. Returns None if it's not provided. It isn't actually clear what this function is for. Its purpose is to return the value for that widget based on the entire dictionary of posted data; namely, it looks through that data, works out given an instance of the widget which data belongs to it and returns that. I checked this by crashing my own custom widget with a carefully placed raise exception. File "/usr/lib/python2.7/site-packages/django/forms/forms.py" in is_valid 121. return self.is_bound and not bool(self.errors) File "/usr/lib/python2.7/site-packages/django/forms/forms.py" in _get_errors 112. self.full_clean() File "/usr/lib/python2.7/site-packages/django/forms/forms.py" in full_clean 267. self._clean_fields() File "/usr/lib/python2.7/site-packages/django/forms/forms.py" in _clean_fields 278. value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name)) Do you want to validate here? I did using a multiwidget subclass, but that's not necessarily the best approach. My method re-constructs the date from the dictionary, attempts to create a python date object from it. If this succeeds, it converts it to a string and returns that which is valid; if it doesn't it returns None, which fails validation in the database for the DateField() type, which is what I wanted to happen. Whether your widget wants that to happen that way depends on what you're doing. I'm not convinced its the most elegant solution so I'm going to open up my own question... Refs: How do I use Django's MultiWidget? Django subclassing multiwidget - reconstructing date on post using custom multiwidget
