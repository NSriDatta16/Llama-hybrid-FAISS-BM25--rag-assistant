[site]: stackoverflow
[post_id]: 3739331
[parent_id]: 3726738
[tags]: 
If you're implementing it in C++, the "easiest" way would just to have a Texture class that can load and unload itself. Whenever an object loads, it also loads up the textures it needs. When that object goes away, it destroys the textures that it loaded, thereby unloading them. A solution in C would be similar; you have a struct that contains enough data to "unload" that texture when it's time to take it out of vram and free its resources. This is basically what we do on "professional games," although on the series I'm currently working on each world area pulls in all of the textures that it needs, so every object in that area that has the same texture shares the same texture data. Adjoining areas may have objects with the same source textures, but in that case we just let there be two copies in memory as the management is much easier. You could get tricky with reference counting and a global manager, but then you'll also need to come up with a scheme for defragmenting memory and so on and so forth that is a fun academic exercise but which ends up causing too much trouble as the project nears completion.
