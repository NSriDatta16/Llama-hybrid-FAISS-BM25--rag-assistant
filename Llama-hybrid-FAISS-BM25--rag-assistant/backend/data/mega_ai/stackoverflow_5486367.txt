[site]: stackoverflow
[post_id]: 5486367
[parent_id]: 
[tags]: 
Actionscript - After I do removechild(), and re add with addChild() the MC keeps moving

I have a MC that the mouse can drag and slide, when it gets removed from the stage when it hits an out of bounds object. I re add it to the stage at the x,y position it originally started from but when I re add it it continues to slide in the direction it was going before it was removed. function __checkHit($evt:Event):void { if (this.test_object.hitTestObject(bounds1)) { // do our in-circle check stopDrag(); removeChild(test_object); test_object.x = 437.25; test_object.y = 808.3; addChild(test_object); } else { } EDIT: var props:Dictionary=new Dictionary(); var currItem:Sprite; var mass=5; var friction=0.9; var drag=false; ... function onMovement(e:Event):void { var instanceX=e.currentTarget.x; var instanceY=e.currentTarget.y; var instanceR=e.currentTarget.rotation; if (props[e.currentTarget].drag==false) { instanceX+=props[e.currentTarget].vX; instanceY+=props[e.currentTarget].vY; } else { // Set Current Mouse Position var mx=stage.mouseX; var my=stage.mouseY; //Calculate Distance Traveled var dmx=mx-props[e.currentTarget].mx0; var dmy=my-props[e.currentTarget].my0; // Set Previous Mouse Position props[e.currentTarget].mx0=mx; props[e.currentTarget].my0=my; // Calculate Force var fx = (dmx - props[e.currentTarget].vX) * mass; var fy = (dmy - props[e.currentTarget].vY) * mass; // Calculate Offset Between Mouse and Registration Point var ax=mx-instanceX; var ay=my-instanceY; // Calculate Rotation from Offset var t=fx*ay-fy*ax; //Set Velocity = To Distance props[e.currentTarget].vX=dmx; props[e.currentTarget].vY=dmy; // Set Rotation Angle props[e.currentTarget].vR+=t*.005; // Set Instance = Instance + Velocity instanceX+=props[e.currentTarget].vX; instanceY+=props[e.currentTarget].vY; // var dx=mx-instanceX; var dy=my-instanceY; // Convert Degrees to Radians var cos=Math.cos(props[e.currentTarget].vR*Math.PI/180); var sin=Math.sin(props[e.currentTarget].vR*Math.PI/180); // Calculate Offset Points After Rotation var aax = dx - (cos * dx + sin * dy); var aay = dy - (cos * dy - sin * dx); // Set Instance Points after Rotation instanceX+=aax; instanceY+=aay; } instanceR-=props[e.currentTarget].vR; // Bounce Off Edges if (instanceX stage.stageWidth) { props[e.currentTarget].vX*=-1; instanceX=stage.stageWidth; } if (instanceY stage.stageHeight) { props[e.currentTarget].vY*=-1; instanceY=stage.stageHeight; } e.currentTarget.x=instanceX; e.currentTarget.y=instanceY; e.currentTarget.rotation=instanceR; props[e.currentTarget].vX*=friction; props[e.currentTarget].vY*=friction; props[e.currentTarget].vR*=friction; }
