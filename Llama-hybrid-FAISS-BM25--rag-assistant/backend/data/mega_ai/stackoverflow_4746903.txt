[site]: stackoverflow
[post_id]: 4746903
[parent_id]: 
[tags]: 
calling presentModalViewController causes “EXC_BAD_ACCESS”

I'm creating an iPad app. In it, I have a UITabBarController set up that shows 3 views. View 1, View 2, and View 3. This all works just fine. On View 1, the user is creating an order. They make then touch a button that builds the order. This is shown in a modal view that allows the user to review it before actually sending it. They can either "submit" or "edit" the order, either way, I dismiss the modal and return to View 1. That works fine as well. But if the user touches the "make" order button again, this time the loading of the modal view causes a crash "EXC_BAD_ACCESS". I copied the code just the same as I did for another modal view in the app, that has no problem showing itself time after time after time. I'm pretty perplexed at this point and would appreciate any help. Thanks. The code calling the modal is: -(IBAction) makeOrder { NSMutableArray *orderItems = [[NSMutableArray alloc] init]; //code that populates orderItems array - removed for brevity NSLog(@"order items count:%d", [orderItems count]); // Create the modal view controller PartsOrderViewController *modalController = [[PartsOrderViewController alloc] initWithNibName:@"PartsOrderView" bundle:nil]; //this is the only difference b/w this and the other modal view. The other //modal presents as a formsheet modalController.modalPresentationStyle = UIModalPresentationFullScreen; modalController.modalTransitionStyle = UIModalTransitionStyleCoverVertical; modalController.orderList = orderItems; modalController.storeId = selectedCustomer.storeID; modalController.customerInfo = customerInfo.text; modalController.customerTamsId = selectedCustomer.customerTAMSID; // show the Controller modally -- This is the line that cause the error after the second time [self presentModalViewController:modalController animated:YES]; // Clean up resources [modalController release]; } It actually gets into the viewDidLoad of the modal, but crashes as soon as that is finished running. Here is the code for the modal: #import "PartsOrderViewController.h" @implementation PartsOrderViewController @synthesize customerTamsId; @synthesize customerInfo; @synthesize invoiceDate; @synthesize invoiceTime; @synthesize storeId; @synthesize customerInfoLabel; @synthesize invoiceDateLabel; @synthesize invoiceTimeLabel; @synthesize storeIdLabel; @synthesize orderList; @synthesize delegate; #pragma mark - #pragma mark View methods -(IBAction) editOrder { [self dismissModalViewControllerAnimated:YES]; } -(IBAction) submitOrder { //code removed for brevity } #pragma mark - #pragma mark View implementation methods // The designated initializer. Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad. /* - (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { // Custom initialization. } return self; } */ // Implement viewDidLoad to do additional setup after loading the view, typically from a nib. - (void)viewDidLoad { [super viewDidLoad]; self.customerInfoLabel.text = self.customerInfo; self.storeIdLabel.text = self.storeId; self.invoiceDateLabel.text = self.invoiceDate; self.invoiceTimeLabel.text = self.invoiceTime; } - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { // Overriden to allow any orientation. return NO; } - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc. that aren't in use. } - (void)viewDidUnload { [super viewDidUnload]; // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; } - (void)dealloc { [super dealloc]; } @end UPDATE: Solution found: Offending code is marked as such- -(NSMutableArray *)buildOrderList { NSMutableArray *orderItems = [[NSMutableArray alloc] init]; id cellObject = NULL; int counter = 0; NSEnumerator *theEnum = [self.partsList objectEnumerator]; while((cellObject = [theEnum nextObject]) != NULL) { GridTableCell *cell = (GridTableCell *)[self.partsListGrid cellForRowAtIndexPath:[NSIndexPath indexPathForRow:counter inSection:0]]; UILabel *lineAbbrev = (UILabel *)[cell.contentView.subviews objectAtIndex:0]; UILabel *partNo = (UILabel *)[cell.contentView.subviews objectAtIndex:1]; UITextView *orderQty = (UITextView *)[cell.contentView.subviews objectAtIndex:3]; //NSLog(@"OrderQty length: %d", [orderQty.text length]); //NSLog(@"Part#:%@, OrderQty:%@", partNo.text, orderQty.text); PartOrderIn *invItem = [[PartOrderIn alloc] init]; invItem.lineAbbrev = lineAbbrev.text; invItem.partNumber = partNo.text; invItem.orderQty = orderQty.text; invItem.partMessage = @""; if ([invItem.orderQty length] > 0) { [orderItems addObject:invItem]; } counter++; [invItem release]; //The following three lines is what was killing it //[lineAbbrev release]; //[partNo release]; //[orderQty release]; } //NSLog(@"order items count:%d", [orderItems count]); return orderItems; }
