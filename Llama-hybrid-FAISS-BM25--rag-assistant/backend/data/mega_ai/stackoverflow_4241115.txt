[site]: stackoverflow
[post_id]: 4241115
[parent_id]: 4240292
[tags]: 
Here is my problem: We also need to support a scenario where a user can skip to a specific data feed, possibly 10 or more pages to the right or left, which throws my entire lazy loading scheme out the window. Then you need to fix your data structure. I wrote pretty much exactly this (a UITableView-like paging scroll view) and it works fine (there are some reloading quirks, but hey...). Keep track of which pages you've loaded. I used a ring-buffer-alike modulo 8 and spent a while getting the code right; it's probably a lot easier to just use an NSDictionary with NSNumber keys and UIView values. This means when you change from page 1 to 10, you can still tell that the loaded views are for pages 1, 2, and 3, and drop them. Load the required pages in -layoutSubviews. I would load 1 or 3; 5 is probably too many (but you need to load at least 2 if you're between pages). Load 3 (one to either side) in -scrollViewDidScroll: . This is so that when you scroll from page 1 to 2, it doesn't try to load page 4 (which hasn't been loaded yet). Load 5 (two to either side) in –scrollViewDidEndDragging:willDecelerate: if willDecelerate is NO, –scrollViewDidEndDecelerating: , –scrollViewDidScrollToTop: , and –scrollViewDidEndScrollingAnimation: . The idea is that the animation's over, so you can load the extra views without the user perceiving lag. Possibly load 5 in –scrollViewWillBeginDragging: , to make sure that page 3 is loaded if you're currently on page 1. I decided to do "two pages either side" because when you flick from page 1 to page 2, it often shows a pixel-wide sliver of page 3 when it bounces. This can be avoided with scroll view insets, but we didn't think of that at the time (oops). There's otherwise not that much of a reason to choose 5 over 3. It's a bit of work to get right, but otherwise seems to work flawlessly.
