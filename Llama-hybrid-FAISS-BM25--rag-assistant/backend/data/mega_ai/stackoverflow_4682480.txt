[site]: stackoverflow
[post_id]: 4682480
[parent_id]: 4682388
[tags]: 
Be careful. I would actually strongly discourage this since if you ever want to overload the == operator for your Foo type in terms of Equals (as is usually done in my experience) you'll find yourself with an infinite recursion. To illustrate what I mean, here is a common implementation of == in terms of Equals : public static bool operator ==(Foo x, Foo y) { // Will overflow the stack if Equals uses ==: return !ReferenceEquals(x, null) && x.Equals(y); } That said, I can wholeheartedly agree with Jon's point that it may be appropriate to use ReferenceEquals instead.
