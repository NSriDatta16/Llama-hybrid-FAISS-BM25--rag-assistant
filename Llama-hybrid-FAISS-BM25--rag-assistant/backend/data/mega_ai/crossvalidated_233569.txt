[site]: crossvalidated
[post_id]: 233569
[parent_id]: 
[tags]: 
SAS rand("Normal") generates strange distribution

I'm attempting a parametric bootstrap of a statistic in SAS. I'm using the RAND("Normal") function to generate a distribution around the statistic similar to this: http://support.sas.com/resources/papers/proceedings15/SAS1387-2015.pdf . XRate is actually more complicated with an unknown variance (hence the bootstrap), but let's say I do this 25,000 times... xrate = rate + std * rand("Normal"); I create the original rates from a large dataset within subpopulations, and overall. The within-subpopulation bootstrapped estimates look ok. A little skewed sometimes, but mostly Normal. The overall rate, however, which goes through the same process as the within-subpopulation rates, looks like this. Not sure what to call the little humps on either end of the main distribution, nor can I fathom where they are coming from. Why is it doing this? What am I doing wrong? Thanks. EDIT: More details... XRate is the average difference between a minimum percent (+/- a random deviation) and 1 to 4 other percentages (+/- a random deviation). This is done several thousand times. The distribution of XRate for all the subpopulation estimates look ok, but the overall estimates (which have a much larger sample) result in a distribution posted above. The rates are rounded because this process was producing estimates with means that did not match the actual point estimate (which is rounded) for which I'm trying to generate confidence intervals. Within a macro that cycles through the different combinations of rates... data outboot; array rate [&ratecnt] rate_1 - rate_&ratecnt (&pRATE); array stde [&ratecnt] stde_1 - stde_&ratecnt (&STDERR); min_pos = WHICHN(MIN(OF rate{*}),OF rate{*}); call streaminit(4511); do Replicate = 1 to 25000; min_rate = rate{min_pos}/100 + stde{min_pos} * rand("Normal"); %DO j=1 %TO &ratecnt; IF min_pos = &j then x&j = .; ELSE x&j = 100*((ROUND(rate{&j},0.1)/100 + stde{&j} * rand("Normal")) - ROUND(min_rate,0.001))/ROUND(min_rate,0.001); %END; XRate = MEAN(OF x1 - x%EVAL(&j-1)); output; end; run;
