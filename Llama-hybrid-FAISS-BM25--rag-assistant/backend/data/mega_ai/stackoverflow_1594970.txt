[site]: stackoverflow
[post_id]: 1594970
[parent_id]: 
[tags]: 
How do you save a Linq object if you don't have its data context?

I have a Linq object, and I want to make changes to it and save it, like so: public void DoSomething(MyClass obj) { obj.MyProperty = "Changed!"; MyDataContext dc = new MyDataContext(); dc.GetTable ().Attach(dc, true); // throws exception dc.SubmitChanges(); } The exception is: System.InvalidOperationException: An entity can only be attached as modified without original state if it declares a version member or does not have an update check policy. It looks like I have a few choices: put a version member on every one of my Linq classes & tables (100+) that I need to use in this way. find the data context that originally created the object and use that to submit changes. implement OnLoaded in every class and save a copy of this object that I can pass to Attach() as the baseline object. To hell with concurrency checking; load the DB version just before attaching and use that as the baseline object (NOT!!!) Option (2) seems the most elegant method, particularly if I can find a way of storing a reference to the data context when the object is created. But - how? Any other ideas? EDIT I tried to follow Jason Punyon's advice and create a concurrency field on on table as a test case. I set all the right properties (Time Stamp = true etc.) on the field in the dbml file, and I now have a concurrency field... and a different error: System.NotSupportedException: An attempt has been made to Attach or Add an entity that is not new, perhaps having been loaded from another DataContext. This is not supported. So what the heck am I supposed to attach, then, if not an existing entity? If I wanted a new record, I would do an InsertOnSubmit()! So how are you supposed to use Attach()? Edit - FULL DISCLOSURE OK, I can see it's time for full disclosure of why all the standard patterns aren't working for me. I have been trying to be clever and make my interfaces much cleaner by hiding the DataContext from the "consumer" developers. This I have done by creating a base class public class LinqedTable where T : LinqedTable { ... } ... and every single one of my tables has the "other half" of its generated version declared like so: public partial class MyClass : LinqedTable { } Now LinqedTable has a bunch of utility methods, most particularly things like: public static T Get(long ID) { // code to load the record with the given ID // so you can write things like: // MyClass obj = MyClass.Get(myID); // instead of: // MyClass obj = myDataContext.GetTable ().Where(o => o.ID == myID).SingleOrDefault(); } public static Table GetTable() { // so you can write queries like: // var q = MyClass.GetTable(); // instead of: // var q = myDataContext.GetTable (); } Of course, as you can imagine, this means that LinqedTable must somehow be able to have access to a DataContext. Up until recently I was achieving this by caching the DataContext in a static context. Yes, "up until recently", because that "recently" is when I discovered that you're not really supposed to hang on to a DataContext for longer than a unit of work, otherwise all sorts of gremlins start coming out of the woodwork. Lesson learned. So now I know that I can't hang on to that data context for too long... which is why I started experimenting with creating a DataContext on demand, cached only on the current LinqedTable instance. This then led to the problem where the newly created DataContext wants nothing to do with my object, because it "knows" that it's being unfaithful to the DataContext that created it. Is there any way of pushing the DataContext info onto the LinqedTable at the time of creation or loading? This really is a poser. I definitely do not want to compromise on all these convenience functions I've put into the LinqedTable base class, and I need to be able to let go of the DataContext when necessary and hang on to it while it's still needed. Any other ideas?
