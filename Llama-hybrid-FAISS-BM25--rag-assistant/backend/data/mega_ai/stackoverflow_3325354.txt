[site]: stackoverflow
[post_id]: 3325354
[parent_id]: 3321833
[tags]: 
The wrapper-program (as proposed before) does not need to be a seperate executable. You could just fork, run your program and then test the return code of the child. This would have the additional benefit, that the operating system automatically reclaims the child's memory when it dies. (at least I think so) Anyway, I imagined something like this (this is C, you might have to change the includes for C++): #include #include #include #define OUT_OF_MEMORY 99999 /* or whatever */ int main(void) { int pid, status; fork_entry: pid = fork(); if (pid == 0) { /* child - call the main function of your program here */ } else if (pid > 0) { /* parent (supervisor) */ wait(&status); /* waiting for the child to terminate */ /* see if child exited normally (i.e. by calling exit(), _exit() or by returning from main()) */ if (WIFEXITED(status)) { /* if so, we can get the status code */ if (WEXITSTATUS(status) == OUT_OF_MEMORY) { /* change parameters */ goto fork_entry; /* forking again */ } } } else { /* fork() error */ return 1; } return 0; } This might not be the most elegant solution/workaround/hack, but it's easy to do.
