[site]: stackoverflow
[post_id]: 3837278
[parent_id]: 3837165
[tags]: 
I think your class hierarchy could use some rethinking. How about this: My suggestion is that you create an interface, IBeverage that you implement on everything that is drinkable. Then you create a base class for the "fundamental" beverages - DarkRoast, Espresso, HouseBlend - just like you did now. For the Condiments, you implement a new abstract base class implementing IBeverage, but not providing a default GetDescription implementation. This class could also take a IBeverage in its constructor to force other condiments to do the same. Something like this should work I think (untested, uncompiled - but you get the idea) public interface IBeverage { string GetDescription (); } public abstract class BeverageBase : IBeverage { public virtual string GetDescription () { return "Unknown Beverage"; } } public class DarkRoast : BeverageBase { ... } public class HouseBlend : BeverageBase { ...} public abstract class CondimentBase : IBeverage { public CondimentBase(IBeverage beverage) { Beverage = beverage; } protected IBeverage Beverage { get; set; } public abstract string GetDescription (); } public class Mocha : CondimentBase { public Mocha(IBeverage beverage) : base (beverage) { } public string GetDescription() { return Beverage.GetDescription() + ", Mocha"; } }
