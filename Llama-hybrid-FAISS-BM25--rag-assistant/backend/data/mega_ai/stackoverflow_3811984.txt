[site]: stackoverflow
[post_id]: 3811984
[parent_id]: 3811513
[tags]: 
You could use event-delegation: the DOM equivalent of jQuery live() and delegate() methods. The following might work: function linkMatcher(node) { // modify this if not all links are disabled if (node.href) return true; else return false; } document.onclick = function(e) { e = e || window.event; var target = e.target || e.srcElement; for (var node=target; node!=document; node=node.parentNode) { if (node.tagName == "A") return !linkMatcher(node); } } EDIT: This disables the links permanently. They can be re-enabled by removing the event-handler, e.g. document.onclick = null . The complete, live example below works on Chrome, Opera, and Firefox for Linux as well as IE6 and IE8 for Windows. It prevents clicks on links with the class "wait" (you could do all links instead if you liked) and remembers the first link clicked. Then it simulates a long load delay (five seconds) and then hooks up jQuery handlers on the links and removes the document-level handler that was preventing clicks, and then triggers the jQuery handler on the link that was clicked (note that this only triggers the handler, not the underlying default behavior — but as you want to trigger your ajax stuff, I figure that's okay). — T.J. Crowder HTML: Link Click Delay Test Page article, aside, figure, footer, header, hgroup, menu, nav, section { display: block; } body { font-family: sans-serif; } p { margin: 0px; } // A scoping function to avoid creating global symbols (function() { // Figure out what to hook clicks on var container = document.body || document.documentElement || document; // Hook clicks that reach the bottom level hookClicks(); function hookClicks() { if (container.attachEvent) { container.attachEvent("onclick", handleClick); } else if (document.addEventListener) { container.addEventListener("click", handleClick, false); } } // Set up an unhook function for jQuery to call window.unhookClicks = unhookClicks; function unhookClicks() { if (container.attachEvent) { container.detachEvent("onclick", handleClick); } else if (document.addEventListener) { container.removeEventListener("click", handleClick, false); } } // Handle clicks function handleClick(event) { var target; // Handle Microsoft vs. W3C event passing style event = event || window.event; // Get the target (again handling Microsoft vs. W3C style) target = event.target || event.srcElement; // Do we have a target that's an A with the class "wait"? if (target && target.tagName.toUpperCase() === "A" && (" " + target.className + " ").indexOf(" wait ") >= 0 ) { // It's a link we want to prevent for the moment // Remember the element that was clicked if there // isn't already one (or replace it, depends on the // UX you want to provide if (!window.pendingLink) { window.pendingLink = target; } // Prevent it from being processed if (event.preventDefault) { // If W3C method... event.preventDefault(); } // This should work if preventDefault doesn't return false; } } })(); Google - This one waits BBC News - This one also waits CNN - This one doesn't wait, it goes immediately ​ JavaScript (wherever your jQuery ready handler is): jQuery(function($) { // Use setTimeout to fake a long delay loading setTimeout(function() { // Hook up our proper click handling // Obviously, replace this with whatever does the ajax $("a.wait").click(function(event) { alert("The jQuery handler for " + this.href + " link was triggered."); }); // If we have clicks disabled, enable them if (window.unhookClicks) { window.unhookClicks(); window.unhookClicks = undefined; } // Do we have a pending link to follow? if (window.pendingLink) { // Yes, grab it and clear it var $link = $(window.pendingLink); window.pendingLink = undefined; // Trigger any jQuery event handlers on it. // Note that this will NOT follow the link, // just trigger jQuery event handlers that // are on the link. $link.click(); } // We've loaded! $(" Finally loaded! ").appendTo(document.body); // End of fake delay function }, 5000); });​
