[site]: stackoverflow
[post_id]: 2336323
[parent_id]: 2335883
[tags]: 
List actually has a built in capacity to prevent allocation for every add/remove. Once you exceed the capacity, it adds more ( I think I doubles every time ). The problem may be more on remove than add. Add will just drop on at the first open spot which is tracked by size. To remove, the list has to be condensed to fill in the now empty slot. If you are always removing for the front of the list, then every element needs to slide down. A Stack still uses an array as its internal storage mechanism. So you are still bound by the add/remove properties of an array. To make the array work, you need to create all the bullets up from with an Active property for each. When you need a new one, filled the Active flag to true and set all of the new bullets properties. Once complete, flip the Active flag false. If you wanted to try to eliminate the need to iterate the list ( which could be very large depending on what you are going to allow ) for each repaint, you could try to implement a double linked list within the array. When a new bullet is needed, asked the array for the first available free entry. Go to the last active bullet ( a variable ) and add the new bullet array position into its next active bullet property. When it is time to remove it, go to the previous bullet and change its active bullet property to the removed next active. //I am using public fields for demonstration. You will want to make them properties public class Bullet { public bool Active; public int thisPosition; public int PrevBullet = -1; public int NextBullet = -1; public List list; public void Activate(Bullet lastBullet) { this.Active = true; this.PrevBullet = lastBullet.thisPosition; list[this.PrevBullet].NextBullet = this.thisPosition; } public void Deactivate() { this.Active = false; list[PrevBullet].NextBullet = this.NextBullet; list[NextBullet].PrevBullet= this.PrevBullet; } } That way, you have a prebuilt array with all the needed bullets but the paint only hits the bullets that are active regardless of their position within the array. You just need to maintain a link to the first active bullet to start the paint and the last active bullet to know where list starts anew. Now you are just worried about the memory to hold the entire list instead of when the GC is going to clean up.
