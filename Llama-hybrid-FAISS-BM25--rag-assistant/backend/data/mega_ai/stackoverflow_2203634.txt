[site]: stackoverflow
[post_id]: 2203634
[parent_id]: 2202585
[tags]: 
I'd like to expand on the second paragraph of David Rodr√≠guez - dribeas' answer (upvoted): To ease the forwarding you could have written a forward header (there are a couple in the STL, you can surely find it in libraries) like usefulfwd.h that only forward defined the library interface (or implementing classes or whatever you need). But this has nothing to do with coupling. I think this points to the core of your problem. Namespaces are a red herring here, you were bitten by underestimating the need to contain syntactic dependencies. I can understand your "laziness": it is not right to overengineer ( enterprise HelloWorld.java), but if you keep your code low-profile in the beginning (which is not necessarily wrong) and the code proves successful, the success will drag it above its league. the trick is to sense the right moment to switch to (or employ from the first moment the need appears) a technique that scratches your itch in a forward compatible way . Sparkling forward declarations over a project is just begging for a second and subsequent rounds. You don't really need to be a C++ programmer to have read the advice "don't forward-declare standard streams, use instead" (though it's been a few years when this was relevant; 1999? VC6 era, definitely). You can hear a lot of painful shrieks from programmers who didn't heed the advice if you pause a little. I can understand the urge to keep it low-brow, but you must admit that #include is no more pain than class Useful , and scales . Just this simple delegation would spare you N-1 changes from class Useful to class useful::Useful . Of course, it wouldn't help you with all the uses in the client code. Easy help: in fact, if you use a library in a large application, you should wrap the forward headers supplied with the library in application-specific headers. Importance of this grows with the scope of the dependency and the volatility of the library. src/libuseful/usefulfwd.h #ifndef GUARD #define GUARD namespace useful { class Useful; } // namespace useful #endif src/myapp/myapp-usefulfwd.h #ifndef GUARD #define GUARD #include using useful::Useful; #endif Basically, it's a matter of keeping the code DRY . You might not like catchy TLAs, but this one describes a truly core programming principle.
