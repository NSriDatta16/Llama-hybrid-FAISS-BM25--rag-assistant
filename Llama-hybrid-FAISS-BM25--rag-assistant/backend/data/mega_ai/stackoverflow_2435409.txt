[site]: stackoverflow
[post_id]: 2435409
[parent_id]: 2434823
[tags]: 
Sinan's idea is a great start. But with an little extra tweak, you can make using your method accessor just like using a normal method. #!/usr/bin/perl use strict; use warnings; use Carp; my $f = Frob->new; $f->frob( sub { my $self = shift; print "$self was frobbed\n"; print Carp::longmess('frob') } ); print "\nCall frob as normal sub\n"; $f->frobit; print "\nGoto frob\n"; $f->goto_frob; BEGIN { package Frob; use Moose; has 'frob' => ( is => 'rw', isa => 'CodeRef', ); sub frobit { &{$_[0]->frob}; } sub goto_frob { goto $_[0]->frob; } } The two methods in Frob are very similar. frobit passes all arguments, including the invocant to the code ref. goto_frob passes all arguments, including the invocant to the code ref, and replaces goto_frob 's stack frame with the code refs. Which to use depends on what you want in the stack. Regarding munging the body storage of a Class::MOP::Method object, like so $method->{body} = sub { 'foo' } : It's never a good idea to violate encapsulation when you are doing OOP. Especially not when you are working with complex object systems like Moose and Class::MOP. It's asking for trouble. Sometimes, there is no other way to get what you want, but even then, violating encapsulation is still a bad idea.
