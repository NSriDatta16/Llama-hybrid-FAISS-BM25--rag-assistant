[site]: stackoverflow
[post_id]: 1873952
[parent_id]: 1873352
[tags]: 
My rule-of-thumb performance guess is that depends whether you are little-endian-ising a big block of data in one go, or just one value: If just one value, then the function call overhead is probably going to swamp the overhead of unnecessary byte-swaps, and that's even if the compiler doesn't optimise away the unnecessary byte swaps. Then you're maybe going to write the value as the port number of a socket connection, and try to open or bind a socket, which takes an age compared with any sort of bit-manipulation. So just don't worry about it. If a large block, then you might worry the compiler won't handle it. So do something like this: if (!is_little_endian()) { for (int i = 0; i Or look into SIMD instructions on your architecture which can do it considerably faster. Write is_little_endian() using whatever trick you like. I think the one Robert S. Barnes provides is sound, but since you usually know for a given target whether it's going to be big- or little-endian, maybe you should have a platform-specific header file, that defines it to be a macro evaluating either to 1 or 0. As always, if you really care about performance, then look at the generated assembly to see whether pointless code has been removed or not, and time the various alternatives against each other to see what actually goes fastest.
