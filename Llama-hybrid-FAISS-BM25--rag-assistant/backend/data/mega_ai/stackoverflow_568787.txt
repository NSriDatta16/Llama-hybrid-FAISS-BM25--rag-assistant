[site]: stackoverflow
[post_id]: 568787
[parent_id]: 567579
[tags]: 
Thank you for all the responses. I finally followed Thorbj√∏rn's suggestion and wrote a little test programm, measuring the performance myself. The result is: No difference between the two variants (in matters of performance). Even though I didn't ask about code aesthetics or something, i.e. what the intention of exceptions was etc. most of you addressed also that topic. But in reality things are not always that clear... In the case under consideration the code was born a long time ago when the situation in which the exception is thrown seemed to be an exceptional one. Today the library is used differently, behaviour and usage of the different applications changed, test coverage is not very well, but the code still does it's job, just a little bit too slow (That's why I asked for performance!!). In that situation, I think, there should be a good reason for changing from A to B, which, in my opinion, can't be "That's not what exceptions were made for!". It turned out that the logging ("A message") is (compared to everything else happening) very expensive, so I think, I'll get rid of this. EDIT : The test code is exactly like the one in the original post, called by a method testPerfomance() in a loop which is surrounded by System.currentTimeMillis() -calls to get the execution time...but: I reviewed the test code now, turned of everything else (the log statement) and looping a 100 times more, than before and it turns out that you save 4.7 sec for a million calls when using B instead of A from the original post. As Ron said fillStackTrace is the most expensive part (+1 for that) and you can save nearly the same (4.5 sec) if you overwrite it (in the case you don't need it, like me). All in all it's still a nearly-zero-difference in my case, since the code is called 1000 times an hour and the measurements show I can save 4.5 millis in that time... So, my 1st answer part above was a little misleading, but what I said about balancing the cost-benefit of a refactoring remains true.
