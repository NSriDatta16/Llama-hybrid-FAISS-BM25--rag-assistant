[site]: stackoverflow
[post_id]: 851078
[parent_id]: 
[tags]: 
Why does this first Haskell function FAIL to handle infinite lists, while this second snippet SUCCEEDS with infinite lists?

I have two Haskell functions, both of which seem very similar to me. But the first one FAILS against infinite lists, and the second one SUCCEEDS against infinite lists. I have been trying for hours to nail down exactly why that is, but to no avail. Both snippets are a re-implementation of the "words" function in Prelude. Both work fine against finite lists. Here's the version that does NOT handle infinite lists: myWords_FailsOnInfiniteList :: String -> [String] myWords_FailsOnInfiniteList string = foldr step [] (dropWhile charIsSpace string) where step space ([]:xs) | charIsSpace space = []:xs step space (x:xs) | charIsSpace space = []:x:xs step space [] | charIsSpace space = [] step char (x:xs) = (char : x) : xs step char [] = [[char]] Here's the version that DOES handle infinite lists: myWords_anotherReader :: String -> [String] myWords_anotherReader xs = foldr step [""] xs where step x result | not . charIsSpace $ x = [x:(head result)]++tail result | otherwise = []:result Note: "charIsSpace" is merely a renaming of Char.isSpace. The following interpreter session illustrates that the first one fails against an infinite list while the second one succeeds. *Main> take 5 (myWords_FailsOnInfiniteList (cycle "why ")) *** Exception: stack overflow *Main> take 5 (myWords_anotherReader (cycle "why ")) ["why","why","why","why","why"] EDIT: Thanks to the responses below, I believe I understand now. Here are my conclusions and the revised code: Conclusions: The biggest culprit in my first attempt were the 2 equations that started with "step space []" and "step char []". Matching the second parameter of the step function against [] is a no-no , because it forces the whole 2nd arg to be evaluated (but with a caveat to be explained below). At one point, I had thought (++) might evaluate its right-hand argument later than cons would, somehow. So, I thought I might fix the problem by changing " = (char:x):xs" to "= [char : x] ++ xs". But that was incorrect . At one point, I thought that pattern matching the second arg against (x:xs) would cause the function to fail against infinite lists. I was almost right about this, but not quite! Evaluating the second arg against (x:xs), as I do in a pattern match above, WILL cause some recursion. It will "turn the crank" until it hits a ":" (aka, "cons"). If that never happened, then my function would not succeed against an infinite list. However, in this particular case , everything is OK because my function will eventually encounter a space, at which point a "cons" will occur. And the evaluation triggered by matching against (x:xs) will stop right there, avoiding the infinite recursion. At that point, the "x" will be matched, but the xs will remain a thunk, so there's no problem. (Thanks to Ganesh for really helping me grasp that). In general, you can mention the second arg all you want, as long as you don't force evaluation of it . If you've matched against x:xs, then you can mention xs all you want, as long as you don't force evaluation of it. So, here's the revised code. I usually try to avoid head and tail, merely because they are partial functions, and also because I need practice writing the pattern matching equivalent. myWords :: String -> [String] myWords string = foldr step [""] (dropWhile charIsSpace string) where step space acc | charIsSpace space = "":acc step char (x:xs) = (char:x):xs step _ [] = error "this should be impossible" This correctly works against infinite lists. Note there's no head, tail or (++) operator in sight. Now, for an important caveat: When I first wrote the corrected code, I did not have the 3rd equation, which matches against "step _ []". As a result, I received the warning about non-exhaustive pattern matches. Obviously, it is a good idea to avoid that warning. But I thought I was going to have a problem. I already mentioned above that it is not OK to pattern match the second arg against [] . But I would have to do so in order to get rid of the warning. However, when I added the "step _ []" equation, everything was fine! There was still no problem with infinite lists! . Why? Because the 3rd equation in the corrected code IS NEVER REACHED! In fact, consider the following BROKEN version. It is EXACTLY the SAME as the correct code, except that I have moved the pattern for empty list up above the other patterns: myWords_brokenAgain :: String -> [String] myWords_brokenAgain string = foldr step [""] (dropWhile charIsSpace string) where step _ [] = error "this should be impossible" step space acc | charIsSpace space = "":acc step char (x:xs) = (char:x):xs We're back to stack overflow, because the first thing that happens when step is called is that the interpreter checks to see if equation number one is a match. To do so, it must see if the second arg is []. To do that, it must evaluate the second arg. Moving the equation down BELOW the other equations ensures that the 3rd equation is never attempted, because either the first or the second pattern always matches . The 3rd equation is merely there to dispense with the non-exhaustive pattern warning. This has been a great learning experience. Thanks to everyone for your help.
