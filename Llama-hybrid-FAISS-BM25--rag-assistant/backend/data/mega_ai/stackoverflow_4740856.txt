[site]: stackoverflow
[post_id]: 4740856
[parent_id]: 
[tags]: 
Aborting a long running task in TPL

Our application uses the TPL to serialize (potentially) long running units of work. The creation of work (tasks) is user-driven and may be cancelled at any time. In order to have a responsive user interface, if the current piece of work is no longer required we would like to abandon what we were doing, and immediately start a different task. Tasks are queued up something like this: private Task workQueue; private void DoWorkAsync (Action callback, CancellationToken token) { if (workQueue == null) { workQueue = Task.Factory.StartWork (() => DoWork(callback, token), token); } else { workQueue.ContinueWork(t => DoWork(callback, token), token); } } The DoWork method contains a long running call, so it is not as simple as constantly checking the status of token.IsCancellationRequested and bailing if/when a cancel is detected. The long running work will block the Task continuations until it finishes, even if the task is cancelled. I have come up with two sample methods to work around this issue, but am not convinced that either are proper. I created simple console applications to demonstrate how they work. The important point to note is that the continuation fires before the original task completes . Attempt #1: An inner task static void Main(string[] args) { CancellationTokenSource cts = new CancellationTokenSource(); var token = cts.Token; token.Register(() => Console.WriteLine("Token cancelled")); // Initial work var t = Task.Factory.StartNew(() => { Console.WriteLine("Doing work"); // Wrap the long running work in a task, and then wait for it to complete // or the token to be cancelled. var innerT = Task.Factory.StartNew(() => Thread.Sleep(3000), token); innerT.Wait(token); token.ThrowIfCancellationRequested(); Console.WriteLine("Completed."); } , token); // Second chunk of work which, in the real world, would be identical to the // first chunk of work. t.ContinueWith((lastTask) => { Console.WriteLine("Continuation started"); }); // Give the user 3s to cancel the first batch of work Console.ReadKey(); if (t.Status == TaskStatus.Running) { Console.WriteLine("Cancel requested"); cts.Cancel(); Console.ReadKey(); } } This works, but the "innerT" Task feels extremely kludgey to me. It also has the drawback of forcing me to refactor all parts of my code that queue up work in this manner, by necessitating the wrapping up of all long running calls in a new Task. Attempt #2: TaskCompletionSource tinkering static void Main(string[] args) { var tcs = new TaskCompletionSource (); //Wire up the token's cancellation to trigger the TaskCompletionSource's cancellation CancellationTokenSource cts = new CancellationTokenSource(); var token = cts.Token; token.Register(() => { Console.WriteLine("Token cancelled"); tcs.SetCanceled(); }); var innerT = Task.Factory.StartNew(() => { Console.WriteLine("Doing work"); Thread.Sleep(3000); Console.WriteLine("Completed."); // When the work has complete, set the TaskCompletionSource so that the // continuation will fire. tcs.SetResult(null); }); // Second chunk of work which, in the real world, would be identical to the // first chunk of work. // Note that we continue when the TaskCompletionSource's task finishes, // not the above innerT task. tcs.Task.ContinueWith((lastTask) => { Console.WriteLine("Continuation started"); }); // Give the user 3s to cancel the first batch of work Console.ReadKey(); if (innerT.Status == TaskStatus.Running) { Console.WriteLine("Cancel requested"); cts.Cancel(); Console.ReadKey(); } } Again this works, but now I have two problems: a) It feels like I'm abusing TaskCompletionSource by never using it's result, and just setting null when I've finished my work. b) In order to properly wire up continuations I need to keep a handle on the previous unit of work's unique TaskCompletionSource, and not the task that was created for it. This is technically possible, but again feels clunky and strange. Where to go from here? To reiterate, my question is: are either of these methods the "correct" way to tackle this problem, or is there a more correct/elegant solution that will allow me to prematurely abort a long running task and immediately starting a continuation? My preference is for a low-impact solution, but I'd be willing to undertake some huge refactoring if it's the right thing to do. Alternately, is the TPL even the correct tool for the job, or am I missing a better task queuing mechanism. My target framework is .NET 4.0.
