[site]: stackoverflow
[post_id]: 5111347
[parent_id]: 
[tags]: 
C++ free() changing other memory

I started noticing that sometimes when deallocating memory in some of my programs, they would inexplicably crash. I began narrowing down the culprit and have come up with an example that illustrates a case that I am having difficulty understanding: #include #include using namespace std; int main() { char *tmp = (char*)malloc(16); char *tmp2 = (char*)malloc(16); long address = reinterpret_cast (tmp); long address2 = reinterpret_cast (tmp2); cout (startBytes[0]) (startBytes[1]) (startBytes[2]) (startBytes[3]) (endBytes[0]) (endBytes[1]) (endBytes[2]) (endBytes[3]) (startBytes[0]) (startBytes[1]) (startBytes[2]) (startBytes[3]) (endBytes[0]) (endBytes[1]) (endBytes[2]) (endBytes[3]) Here is the output that I am seeing: tmp = 8795380 tmp2 = 8795400 Start: 16 0 0 0 End: 16 0 0 0 --------------- Start: 17 0 0 0 End: 18 0 0 0 I am using Borland's free compiler. I am aware that the header bytes that I am looking at are implementation specific, and that things like "reinterpret_cast" are bad practice. The question I am merely looking to find an answer to is: why does the first byte of "End" change from 16 to 18? The 4 bytes that are considered "end" are 16 bytes after tmp, which are 4 bytes before tmp2. They are tmp2's header - why does a call to free() on tmp affect this place in memory? I have tried the same example using new [] and delete [] to create/delete tmp and tmp2 and the same results occur. Any information or help in understanding why this particular place in memory is being affected would be much appreciated.
