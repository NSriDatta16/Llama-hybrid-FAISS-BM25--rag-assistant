[site]: stackoverflow
[post_id]: 4505114
[parent_id]: 4505073
[tags]: 
If you want to be able to do that you need to declare the 'public' function like you would a private function, and then expose it as public. Like this: $(function() { var modulePattern = (function($) { var privateMethod = function() { appendText("called privateMethod()"); publicAlert(); }; var appendText = function(text) { var text2 = $('#output').text() + " | " + text; $('#output').text(text2); }; var publicAlert = function(){ alert("publicAlert"); }; return { publicMethod: function() { appendText("called publicMethod()"); privateMethod(); }, publicAlert: publicAlert }; }); mp = new modulePattern($); mp.publicMethod(); }); [Edit] I would also encourage you to get into the habit of clicking on the 'jslint' button at the top of jsfiddle, your code was missing a few semicolons, and you also redeclared the 'text' variable inside your appendText function (it was already passed in) Also, you're using the module pattern in a slightly different way to how I've learned it. Do you have a link to your reference material? This is how I would have done the module pattern as I know it: http://jsfiddle.net/sVxvz/ [/Edit] Also, if you use the module pattern correctly, you can refer to the public functions by using the module name, like this: var testModule = (function($) { var privateMethod = function() { appendText("called privateMethod()"); testModule.publicAlert(); }; var appendText = function(text) { var text2 = $('#output').text() + " | " + text; $('#output').text(text2); }; return { publicMethod: function() { appendText("called publicMethod()"); privateMethod(); }, publicAlert: function() { alert("publicAlert"); } }; }(jQuery)); $(function() { testModule.publicMethod(); }); But I don't really like this because the public methods can be overwritten. someone could go testModule.publicAlert = function(){EVIL CODE OF DOOM;}; and your internal workings will happily execute it.
