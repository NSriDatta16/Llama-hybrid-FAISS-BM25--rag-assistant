[site]: stackoverflow
[post_id]: 3551709
[parent_id]: 
[tags]: 
Using IoC container as a service locator for HttpHandler

This question relates to my other post . Ok so after a bit more messing around I decided to do it this way. Which seems to work fine when I run it, although I'm getting the following error in NUnit: Could not load file or assembly 'Castle.Core, Version=1.0.3.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040) So not sure what is happening there??? Just wanted to know what others thought about the design and if there are any obvious 'no no's' or improvements. I.e. Is the constructor of the base handler a good place to instantiate the windsor component or is there a better place to do this? As I said in the original post the idea behind doing things this way was to keep the components nicely decoupled and to make unit testing easy. I should also add I'm new to unit testing, mocking. Thanks! public abstract class BaseHttpHandler : IHttpHandler { private HttpContext _httpContext; private ILogger _logger; private IDataRepository _dataRepository; protected HttpRequest Request { get { return _httpContext.Request; } } protected HttpResponse Response { get { return _httpContext.Response; } } protected bool IsRequestFromUAD { get { return Request.UserAgent == null ? false : Request.UserAgent.Equals("UAD"); } } protected ILogger Logger { get { return _logger; } } protected IDataRepository DataRepository { get { return _dataRepository; } } public virtual bool IsReusable { get { return false; } } public BaseHttpHandler() { var container = new WindsorContainer(new XmlInterpreter(new ConfigResource("castle"))); _logger = container.Resolve (); _dataRepository = container.Resolve (); } public void ProcessRequest(HttpContext context) { _httpContext = context; ProcessRequest(new HttpContextWrapper(context)); } public abstract void ProcessRequest(HttpContextBase context); } public class UADRecordHttpHandler : BaseHttpHandler { public override void ProcessRequest(HttpContextBase context) { if (IsRequestFromUAD) { using (var reader = new StreamReader(context.Request.InputStream)) { string data = reader.ReadToEnd(); if (Logger != null) Logger.Log(data); if(DataRepository != null) DataRepository.Write(data); context.Response.Write(data); } } else ReturnResponse(HttpStatusCode.BadRequest); } }
