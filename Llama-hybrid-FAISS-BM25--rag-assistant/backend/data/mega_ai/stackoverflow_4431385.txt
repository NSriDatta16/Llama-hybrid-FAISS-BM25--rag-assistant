[site]: stackoverflow
[post_id]: 4431385
[parent_id]: 4427953
[tags]: 
We've been doing quite a lot of this sort of thing over the last couple of years. We use a mixed-mode 'bridge' assembly to manage mapping function calls and marshalling data between managed and unmanaged environments. We often use a 'mixed-mode' class to wrap a managed class, providing a native interface for calling it's functionality. Let's consider your problem. You could write GetFunctionTable in managed c++. It can call some managed c# code to get the function information in a managed struct, and then 'marshall' it into the native struct. In (c#) a managed version of GetFunctionTable function: delegate void FunctionDelegate(); public struct FuncDescStructManager { public string Name; public FunctionDelegate Function; //... } public static List GetFunctionTableManaged() { List list = new List (); list.Add(new FuncDescStructManaged () {"ExampleF1", VExampleF1}); return list; } In the mixed-mode bridge assembly you can implement the native function GetFunctionTable, calling the managed function and marshalling the data: int GetFunctionTable(FuncDescStruct **ppFunctionTable) { // Call the managed function List ^ managedList = GetFunctionTableManaged(); nativeArray = malloc(managedList.Length * sizeof(FuncDescStruct)); int i=0; foreach (FuncDescStructManaged managedFunc in managedList) { // Marshall the managed string to native string could look like this: stringPtr = Marshal::StringToHGlobalUni(managedFunc.Name); nativeArray[i].Name = ((wchar_t*)stringPtr.ToPointer()); Marshal::FreeHGlobal(stringPtr); // Marshall a delegate into a native function pointer using a // wrapper class: WrapDelegateAsPtr funcPtr = new WrapDelegateAsPtr(managedFunc.Function); // funcPtr will need to be deleted by caller nativeArray[i].Function = funcPtr.NativeFunction; i++; } return i; } // Mixed mode wrapper class // Member is a reference to a managed delegate. // Because we need to reference this from native code, the wrapped // delegate will be stored as a void*. class WrapDelegateAsFPtr { public: WrapDelegateAsNativeFunctionPointer(FunctionDelegate _delegate) { delegate = _delegate; // Tell the garbage handler not to remove the delegate object yet GCHandle gch = GCHandle::Alloc(svgContents); managedDelegatePtr = GCHandle::ToIntPtr(gch).ToPointer(); } ~WrapDelegateAsNativeFunctionPointer { // Tell the garbage collector we are finished with the managed object IntPtr temp(managedDelegatePtr;); GCHandle gch = static_cast (temp); gch.Free(); } void NativeFunction() { } private: void* managedDelegatePtr; } Hope this helps - Any questions just ask!
