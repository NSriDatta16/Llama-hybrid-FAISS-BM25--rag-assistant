[site]: stackoverflow
[post_id]: 1822421
[parent_id]: 
[tags]: 
IsSynchronizedWithCurrentItem attribute and current item updates

I have a view model to manage a dialog type of view that allows filtering of a listing (if necessary) and selection of an item. The code works fine whether I set IsSynchronizedWithCurrentItem to true or not. My understanding is that this property is not true by default in a ListView, so I'd like to better understand this property. Here is the binding setup in the view's xaml (which works just as well without the synch property setting): The view model Projects is actually a CollectionViewSource that is backed by a private ObservableCollection. I think I glommed this idea from a sample project of Josh Smith's, but I honestly don't recall right now. Here is the relevant portion of the VM that relates to the xaml binding: private ObservableCollection _projectsInternal { get; set; } public CollectionViewSource Projects { get; set; } private void _populateProjectListings(IEnumerable openProjects) { var listing = (from p in openProjects orderby p.Code.ToString() select new ProjectViewModel(p)).ToList(); foreach (var pvm in listing) pvm.PropertyChanged += _onProjectViewModelPropertyChanged; _projectsInternal = new ObservableCollection (listing); Projects = new CollectionViewSource {Source = _projectsInternal}; } /// Property that is updated via the binding to the view public ProjectViewModel SelectedProject { get; set; } The Filter property of the CollectionViewSource has a handler which returns various predicates on the view model items in the list which is picked up by the bindings correctly. Here is the gist of that code (which is in the same ProjectSelctionViewModel): /// Trigger filtering of the listing. public void Filter(bool applyFilter) { if (applyFilter) Projects.Filter += _onFilter; else Projects.Filter -= _onFilter; OnPropertyChanged (vm=>vm.Status); } private void _onFilter(object sender, FilterEventArgs e) { var project = e.Item as ProjectViewModel; if (project == null) return; if (!project.IsMatch_Description(DescriptionText)) e.Accepted = false; if (!project.IsMatch_SequenceNumber(SequenceNumberText)) e.Accepted = false; if (!project.IsMatch_Prefix(PrefixText)) e.Accepted = false; if (!project.IsMatch_Midfix(MidfixText)) e.Accepted = false; if (!project.IsAvailable) e.Accepted = false; } Setting the Mode=TwoWay is redundant since the ListView's SelectedItem binding is two way by default, but I don't mind being explicit about it (I might feel differently about that once I understand WPF better). What about my code is making the IsSynchronizedWithCurrentItem=True redundant? My gut is that this is decent code, but I don't like that pieces of it seem to be working via "magic", which means I would welcome any constructive feedback! Cheers, Berryl
