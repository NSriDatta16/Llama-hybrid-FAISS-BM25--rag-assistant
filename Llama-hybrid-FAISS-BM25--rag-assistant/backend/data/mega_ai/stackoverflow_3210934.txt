[site]: stackoverflow
[post_id]: 3210934
[parent_id]: 3209123
[tags]: 
Proposed algorithm: Use fseek , ftell , fseek to seek to end, determine file length, and seek back to beginning. malloc a buffer big enough for the whole file plus null-termination. Use fread to read the whole file into the buffer, then write a 0 byte at the end. Loop through the buffer byte-by-byte and count newlines. Use malloc to allocate that number + 1 char * pointers. Loop through the buffer again, assigning the first pointer to point to the beginning of the buffer, and successive pointers to point to the byte after a newline. Replace the newline bytes themselves with 0 (null) bytes in the process. One optimization: if you don't need random access to the lines (indexing them by line number), do away with the pointer array and just replace all the newlines with 0 bytes. Then s+=strlen(s)+1; advances to the next line. You'll need to add some check to make sure you don't advance past the end (or beginning if you're doing this in reverse) of the buffer. Either way, this method is very efficient (no memory fragmentation) but has a couple drawbacks: You can't individually free lines; you can only free the whole buffer once you finish. You have to overwrite the newlines. Some people prefer to have them kept in the in-memory structure. If the file ended with a newline, the last "line" in your pointer array will be zero-length. IMO this is the sane interpretation of text files, but some people prefer considering the empty string after the last newline a non-line and considering the last proper line "incomplete" if it doesn't end with a newline.
