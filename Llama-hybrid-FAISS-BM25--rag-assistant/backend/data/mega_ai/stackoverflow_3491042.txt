[site]: stackoverflow
[post_id]: 3491042
[parent_id]: 3443788
[tags]: 
I have a couple of suggestions and hints that may or may not be obvious / helpful. To me it this sounds like a problem that can be split into 3 separate aspects: Synchronisation process You should definitely ensure that all rows have some sort of "last_update" column so that your synchronisation process can efficiently and reliably determine what data is already up-to-date - that way you can be a lot more aggressive with the number of records that you are synchronising. I would avoid having a complex synchronisation processes and simply use the brute force approach wherever possible. 14,000 records doesn't sound like that many to me - with optimisations you may find that its possible to synchronise all changes made between connections in a reasonable time. If not then I'd still probably be quite liberal about what you synchronise to avoid users working with out-of-date data without realising. Pushing changes made in offline mode If at all possible I would probably simply disallow changes in offline mode - it thats not possible then you should consider pushing changes as being as a separate (and probably fairly complex) process in its own right. Without knowing more about the application its difficult to make good suggestions as the synchronisation process is very business dependent, however some things to consider are: Should uses be able to lock (or check out) an item to prevent other people from changing it while they are working offline? Should the lock be overridable? If a lock is overrided, what should happen when someone attempts to save changes (a merge process seems like a sensible choice) Should someone be able to edit an item that they don't have checked out? If you do decide to implement a complex offline changes process then you might want to take a look at the workflow used in common distributed VCS for inspiration. Changing the offline data store You might find using SQL Compact or SQLite as your local data store a more elegant solution (it would certainly make the installation process easier), if you are using LINQ then I'd probably swing in favour of SQL Compact as it definitely has LINQ to SQL support. I would focus on the above two first as this change delivers the least in terms of end-user improvements and is probably the most work - the above two are completely achievable while still using SQL Server Express as the local data store.
