[site]: stackoverflow
[post_id]: 3543537
[parent_id]: 3543461
[tags]: 
At a linux system you can do some experiments with static compiled example programs. E.g. $ size `which busybox ` text data bss dec hex filename 1830468 4448 25650 1860566 1c63d6 /bin/busybox The sizes are given in bytes. This output is independent from the executable file format, since the sizes of the different sections inside the file format. The text section contains the machine code and const stufff. The data section contains data for static initialization of variables. The bss size is the size of uninitialized data - of course uninitialized data does not need to be stored in the executable file.) Well, busybox contains a lot of functionality (like all common shell commands, a shell etc.). If you link own examples with gcc -static , keep in mind, that your used libc may dramatically increase the program size and that using an embedded libc may be much more space efficient. To test that you can check out the diet-libc or uclibc and link against that. Actually, busybox is usually linked against uclibc. Note that the sizes you get this way give you only an order of magnitude . For example, your workstation probably uses another CPU architecture than the arduino board and the machine code of different architecture may differ, more or less, in its size (because of operand sizes, available instructions, opcode encoding and so one). To go on with rough order of magnitude reasoning, busybox contains roughly 309 tools (including ftp daemon and such stuff), i.e. the average code size of a busybox tool is roughly 5k.
