[site]: stackoverflow
[post_id]: 1028705
[parent_id]: 1028661
[tags]: 
This construction is illegal, as you have discovered. Members whose constructors throw checked exceptions cannot be constructed except when in a context that allows exception handling, such as a constructor, an instance initializer, or (for a static member) a static initializer. So this would be a legal way to do it: public class MyClass { MyFileWriter x; { try { x = new MyFileWriter("foo.txt"); } catch (IOException ex) { ex.printStackTrace(); } } ... } Legal, but rather ugly. I would prefer either initializing it in the constructor and declaring the exception there, or else making the user call a method to explicitly initialize it. But if the user must initialize it, you must then account in any dependent methods for the possibility of the object's being invalid. If you are writing MyClass as a wrapper for MyFileWriter , I would say to do the initialization in the constructor. Otherwise, I would first question whether it is necessary to have a writer open during the object's entire lifetime. It may be possible to refactor this away. Edit: When I was writing this, the " static " hadn't been added to the field. This changes things quite a bit: I now would like to know why on earth you want to have a writer open for the classloader's entire lifetime. How could it ever be closed? Is this a home-grown logging system of some sort? If so, I'd encourage you to have a look at java.util.logging or any of the many fine third-party logging frameworks around.
