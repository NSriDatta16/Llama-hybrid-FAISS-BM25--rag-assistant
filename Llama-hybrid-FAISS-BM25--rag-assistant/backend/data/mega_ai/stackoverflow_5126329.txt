[site]: stackoverflow
[post_id]: 5126329
[parent_id]: 5125864
[tags]: 
As Robert commented, maybe your makeCorridor function needs some attention. I've adapted your code, making my own makeCorridor function and replacing Rect by int. I've used an active pattern to determine when a BspTree is a room. I've also used yield! sequence instead of for x in sequence -> x . These modifications result in the same behavior. I just wanted to show what an active pattern can do: type BspTree = | Node of int * BspTree * BspTree | Null let (|IsRoom|_|) dungeon = match dungeon with | Node(_,Null,Null) -> Some dungeon | _ -> None let rec getRooms = function | IsRoom dungeon -> Seq.singleton dungeon | Null -> Seq.empty | Node (_, left, right) -> seq { yield! getRooms left yield! getRooms right } let makeCorridor leftNode rightNode = match leftNode, rightNode with | Node(left,Null,Null), Node(right,Null,Null) -> sprintf "(%d) -> (%d)" left right | _ -> failwith "Illegal corridor!" let rec getCorridors = function | Null -> failwith "Unexpected null room" | Node(_, Null, Null) -> Seq.empty | Node(_, IsRoom left, IsRoom right) -> seq { yield makeCorridor left right } | Node(_, left, right) -> seq { yield! getCorridors left yield! getCorridors right } Example: let dungeon = Node(1, Node(2, Node(4,Null,Null), Node(5,Node(8,Null,Null), Node(9,Null,Null))), Node(3, Node(6,Null,Null), Node(7,Null,Null))) Result in FSI: > getCorridors dungeon;; val it : seq = seq ["(8) -> (9)"; "(6) -> (7)"]
