[site]: stackoverflow
[post_id]: 2535886
[parent_id]: 
[tags]: 
Scheme Formatting Help

I've been working on a project for school that takes functions from a class file and turns them into object/classes. The assignment is all about object oriented programming in scheme. My problem however is that my code doesn't format right. The output it gives me whenever I give it a file to pass in wraps the methods of the class in a list, making it so that the class never really gets declared. I can't for the life of me figure out how to get the parenthesis wrapping the method list to remove. I would really appreciate any help. Below is the output, the class file and the code,. (define pointInstance (let ((myx 1) (myy 2)) (lambda msg (cond (((eq? (car msg) getx) myx) ((eq? (car msg) gety) myy) ((eq? (car msg) setx) (set! myx x)) ((eq? (car msg) show) (begin (display "[") (display myx) (display ",") (display myy) (display "]")))))))) If you look at just after the cond you'll see how all those eq statements are contained in a list. I can't get this to work right unless they're not wrapped by that top level list. ;;;; PART1 --- A super-easy set of classes. Just models points and lines. Tests all of >the ;; basics of class behavior without touching on anything particularly complex. (class pointInstance (parent:) (constructor_args:) (ivars: (myx 1) (myy 2)) (methods: (getx () myx) (gety () myy) (setx (x) (set! myx x)) (show () (begin (display "[") (display myx) (display ",") (display myy) (display "]"))) )) (require (lib "trace.ss")) ;; Continue reading until you hit the end of the file, all the while ;; building a list with the contents (define load-file (lambda (port) (let ((rec (read port))) (if (eof-object? rec) '() (cons rec (load-file port)))))) ;; Open a port based on a file name using open-input-file (define (load fname) (let ((fport (open-input-file fname))) (load-file fport))) ;(define lis (load "C:\\Users\\Logan\\Desktop\\simpletest.txt")) ;(define lis (load "C:\\Users\\Logan\\Desktop\\complextest.txt")) (define lis (load "C:\\Users\\Logan\\Desktop\\pointinstance.txt")) ;(display (cdaddr (cdddar lis))) (define makeMethodList (lambda (listToMake retList) ;(display listToMake) (cond [(null? listToMake) retList ;(display "The list passed in to parse was null") ] [else (makeMethodList (cdr listToMake) (append retList (list (getMethodLine listToMake)))) ] ) )) ;(trace makeMethodList) ;this works provided you just pass in the function line (define getMethodLine (lambda (functionList) `((eq? (car msg) ,(caar functionList)) ,(caddar functionList)))) (define load-classes (lambda paramList (cond [(null? paramList) (display "Your parameters are null, man.")] [(null? (car paramList))(display "Done creating class definitions.")] [(not (null? (car paramList))) (begin (let* ((className (cadaar paramList)) (classInstanceVars (cdaddr (cddaar paramList))) (classMethodList (cdr (cadddr (cddaar paramList)))) (desiredMethodList (makeMethodList classMethodList '())) ) ;(display "Classname: ") ;(display className) ;(newline)(newline) ;(display "Class Instance Vars: ") ;(display classInstanceVars) ;(newline)(newline) ;(display "Class Method List: ") ;(display classMethodList) ;(newline) ;(display "Desired Method List: ") ;(display desiredMethodList)) ;(newline)(newline) ;---------------------------------------------------- ;do not delete the below code!` `(define ,className (let ,classInstanceVars (lambda msg ;return the function list here (cond ,(makeMethodList classMethodList '()))) )) ;--------------------------------------------------- ))] ) )) (load-classes lis) ;(load-classes lis) ;(load-classes-helper lis) ;(load-classes "simpletest.txt") ;(load-classes "complextest.txt") ;method list ;(display (cdr (cadddr (cddaar ))))
