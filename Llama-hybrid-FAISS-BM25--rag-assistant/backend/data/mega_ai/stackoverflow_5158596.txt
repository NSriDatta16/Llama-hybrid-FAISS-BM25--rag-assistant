[site]: stackoverflow
[post_id]: 5158596
[parent_id]: 4013906
[tags]: 
This is an interesting observation because you cannot use a Transaction from a different Connection. The System.Data.SqlClient.SqlCommand (4.0) has a private member called ValidateCommand that contains several validation checks, including this one: if ((this._transaction != null) && (this._activeConnection != this._transaction.Connection)) { throw ADP.TransactionConnectionMismatch(); } The overall design of the SqlCommand class is for flexibility. The CommandText, Connection and Transaction properties (which are also exposed in the three additional constructor overloads) are read/write. This makes the class flexible, but also prone to incorrect usage. Certainly, things would be much cleaner if the properties were read-only and the constructors used as the primary means of passing data into the object. In which case the following constructor would make much more sense: public SqlCommand(string commandText, SqlTransaction transaction) However, I would imagine that these properties are read/write to enable drag-n-drop designer support where the object is constructed using the default constructor and properties are set in the InitializeComponent method.
