[site]: stackoverflow
[post_id]: 4808957
[parent_id]: 
[tags]: 
Need to speed up C++ code involving Boost multi-index and lookups to unordered_multimap

I'm looking for strategies to speed up an agent-based model that's based on objects of class Host , pointers to which are stored in a Boost multi-index container. I've used Shark to determine that the vast majority of the time is consumed by a function calcSI() : Function calcSI() has to compute for every instance of class Host certain probabilities that depend on attributes of other instances of class Host . (There are approximately 10,000-50,000 instances of Host , and these calculations are run for each host approximately 25,600 times.) If I'm interpreting the profile correctly, the majority of the time spent in calcSI() goes to Host::isInfectedZ(int) , which simply counts instances of something in a Boost unordered_multimap of type InfectionMap : struct Infection { public: explicit Infection( double it, double rt ) : infT( it ), recT( rt ) {} double infT; double recT; }; typedef boost::unordered_multimap InfectionMap; All members of Host contain InfectionMap carriage , and Host::isInfectedZ(int) simply counts the number of Infections associated with a particular int key: int Host::isInfectedZ( int z ) const { return carriage.count( z ); } I'm having trouble finding information on how costly the count function is for Boost's unordered multimaps. Should I increase the overhead by adding to Host a separate two-dimensional array to track the number of instances of each key (i.e., the number of Infections associated with each int )? I'm wondering if a larger structural overhaul of the Boost multi-index, like eliminating one or two less-needed composite key indices, would be more helpful. The background maintenance of the multi-index doesn't appear in the profiler, which (maybe stupidly) makes me worry it might be large. I have 8 indices in the multi-index, most of which are ordered_non_unique. Are there other things I should be concerned with that might not appear in the profiler, or am I missing a major result from the profiler? Parallelization and multithreading of calcSI() are unfortunately not options. Update: It might be helpful to know that InfectionMap carriage rarely has more than 10 pairs and usually has Update 2: I tried the strategy proposed in #1 above, giving each Host an array int carriageSummary[ INIT_NUM_STYPES ] , which is indexed by the possible values of z (for most simulations, there are carriage . The Host::isInfectedZ( int z ) function now reads: int Host::isInfectedZ( int z ) const { //return carriage.count( z ); return carriageSummary[ z ]; } And the time dedicated to this function appears to have dropped substantially--I can't do an exact comparison right now: Obviously, using an array is kind of bulky but okay for small ranges of z . Would some other container (i.e., not an unordered_map) be more efficient for larger ranges? Would love any feedback on changing multi-index too.
