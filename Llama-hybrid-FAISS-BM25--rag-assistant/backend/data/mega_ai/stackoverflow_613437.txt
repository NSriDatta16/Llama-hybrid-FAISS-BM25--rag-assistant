[site]: stackoverflow
[post_id]: 613437
[parent_id]: 613282
[tags]: 
There is a simple and direct answer, that may not be the most efficient answer. SWIG produces wrappers for manipulating objects from the scripting language side. For objects, it also synthesizes a wrapped constructor. So, the direct solution is to just let the Lua interpreter call SWIG's constructor to create the new object. For the wrapped engine.GuiInst class, you almost certainly can do something like: int main() { lua_State *L=lua_open(); luaopen_engine(L); //this is swigs module int error=luaL_loadfile(L,"mainmenu.lua")|| lua_pcall(L, 0, 0, 0); luaL_dostring(L, "Init(engine.new_GuiInst())"); lua_close(L); } For a one-shot case like script startup, the penalty of running a string constant through luaL_dostring() is not bad at all. I'd look harder to avoid it in an event callback or an inner loop, however. It does seem like there ought to be a way to convert a pointer directly into a wrapped object, I'm not spotting it in my own handful of SWIG generated wrappers. Edit: Of course, the Lua fragment can be decomposed to API calls that get the engine table global on the stack, extract from it the new_GuiInst member, call it, then call the global Init , but the little bit of efficiency comes at the cost of some clarity. As for dealing with objects that shouldn't be constructed by accident in user code, as the clarified question indicates, my first impulse would be to let SWIG generate the constructor function, keep a private reference if needed later, and remove it from the table. Even a C module is (usually) just a table whose members contain function values. Being implemented in C doesn't make them read-only unless extra effort is taken. So, you could always retrieve the value of engine.new_GuiInst and park it in the registry (see luaL_ref() and the discussion in section 3.5 of the Lua Reference Manual of the pseudo-index LUA_REGISTRYINDEX for the details) for later use. Then, before letting any user code run, simply do the equivalent of engine.new_GuiInst = nil . I should note that for the C data types I've been playing with most recently, SWIG created two constructors for each type, named new_TYPE and TYPE . Both were visible in the module's table, and you would want to set both names to nil . If have much less experience with SWIG wrapping C++ classes, and the result may differ... You might want to check and review the whole content of the engine table returned by SWIG, and create a proxy object that contains only the methods you want available to your users. You can also change the environment seen by the user script so that it only has the proxy available, and names the proxy engine as well. There has been a fair amount of discussion of sandboxing user scripts on the Lua list and at the lua-users wiki .
