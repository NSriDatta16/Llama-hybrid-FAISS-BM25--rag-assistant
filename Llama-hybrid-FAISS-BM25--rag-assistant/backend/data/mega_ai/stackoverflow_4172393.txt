[site]: stackoverflow
[post_id]: 4172393
[parent_id]: 4172288
[tags]: 
Integer and floating point math as such in Java are handed right down to the hardware, and the calculations as such are in principle not slower than in C, say, or FORTRAN. The library routines for stuff like transcendental functions ( sin() , sqrt() , log() , etc) are in fact implemented in C, so again there's no good reason to look to other libraries. There's some information I wish your question gave us. You mention that there's a lot of calculation going on, and that's number crunching. But you don't tell us anything about how those numbers are organized and accessed. This is probably interesting and useful information. If you're using intricate object structures to hold your data, accessing those structures is going to take time. If your results create new objects, that's also expensive. If you use arrays, those are also objects. Multi-dimensional arrays in Java are arrays of arrays, and indexing through multiple dimensions may resolve to object references which are slower than in other languages. Though I don't have benchmarks to prove it, I suspect you might be better off to replace multi-dimensional arrays with one-dimensional arrays and a bit of "manual" index calculation. You are certainly better off using fixed-size arrays, perhaps dimensioned with a bit of slack, rather than creating and discarding new arrays for each calculation. Finally, many of the object oriented tricks to make your program's structure more "elegant" and "flexible" tend to introduce a lot of unnecessary object orientation with attendant slowdowns. Primitive but simple is usually faster. A very simple optimization might be to simply use the -server option of your JVM (if that's available) to get the benefit of more pre-compilation, if you're not already doing that. I second other folks' recommendation that you profile your calculations, though, before you go blindly re-architecting your program. There may be bottlenecks in surprising places.
