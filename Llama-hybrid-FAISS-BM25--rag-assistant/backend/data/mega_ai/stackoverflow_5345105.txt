[site]: stackoverflow
[post_id]: 5345105
[parent_id]: 5345003
[tags]: 
The reason you're getting that error is You have PHP code which produces warnings Magento runs with error handling cranked up to 11 Magento tries to log the error, and can't find the class. The code in question is $this->WBSAPI_CurlCall ( "once?action=probe" , &$result) ); You're passing a variable by reference at call time ( &$result ). That's been depreciated in modern versions of PHP. Without custom error handling, you'll get an warning something like PHP Warning: Call-time pass-by-reference has been deprecated; So, pass in $result without the & . Given than your method has the paramater declared in its prototype as a pass-by-reference, doing so won't functionally change your code. That should take care of your immediate problem. The larger reason Magento's giving you this error is its custom error handler. #File: app/code/core/Mage/Core/functions.php function mageCoreErrorHandler($errno, $errstr, $errfile, $errline) { ... if (Mage::getIsDeveloperMode()) { throw new Exception($errorMessage); } else { Mage::log($errorMessage, Zend_Log::ERR); } } Since you're not working in developer mode , Magento tries to log an error using the constant Zend_Log as its type. The problem is (or appears to be) that if your error happens too soon in the Magento bootstrap/dispatch process, Zend_Log hasn't been loaded yet and the autoloader doesn't take care of it. That's why you're getting your error. You should fix your code not to use call-time pass by reference (remove &$result from your calling code, but not from the function definitions). If you don't want to do that you could try including lib/Zend/Log.php earlier yourself. I think that's a bad idea so I'll leave the hows as an exercise for the reader. Also, for those not familiar with the term "call time pass by reference", it means indicating a variable should be passed by reference when you call a method . foo(&$bar); Passing a reference to a function $bar = &baz; foo($bar); Or declaring a paramater in a method's prototype indicating it should be passed by reference public function applyInApp(&$content) { } is still legal PHP code.
