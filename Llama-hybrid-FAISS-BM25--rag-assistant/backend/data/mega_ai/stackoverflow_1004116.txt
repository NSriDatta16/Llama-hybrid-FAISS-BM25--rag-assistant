[site]: stackoverflow
[post_id]: 1004116
[parent_id]: 1004022
[tags]: 
In contrast to .NET Java generics are implemented by a technique called "type erasure". What this means is that the compiler will use the type information when generating the class files, but not transfer this information to the byte code. If you look at the compiled classes with javap or similar tools, you will find that a List is a simple List (of Object ) in the class file, just as it was in pre-Java-5 code. Code accessing the generic List will be "rewritten" by the compiler to include the casts you would have to write yourself in earlier versions. In effect the following two code fragments are identical from a byte code perspective once the compiler is done with them: Java 5: List stringList = new ArrayList (); stringList.add("Hello World"); String hw = stringList.get(0); Java 1.4 and before: List stringList = new ArrayList(); stringList.add("Hello World"); String hw = (String)stringList.get(0); When reading values from a generic class in Java 5 the necessary cast to the declared type parameter is automatically inserted. When inserting, the compiler will check the value you try to put in and abort with an error if it is not a String. The whole thing was done to keep old libraries and new generified code interoperable without any need to recompile the existing libs. This is a major advantage over the .NET way where generic classes and non-generic ones live side-by-side but cannot be interchanged freely. Both approaches have their pros and cons, but that's the way it is in Java. To get back to your original question: You will not be able to get at the type information at runtime, because it simply is not there anymore, once the compiler has done its job. This is surely limiting in some ways and there are some cranky ways around it which are usually based on storing a class-instance somewhere, but this is not a standard feature.
