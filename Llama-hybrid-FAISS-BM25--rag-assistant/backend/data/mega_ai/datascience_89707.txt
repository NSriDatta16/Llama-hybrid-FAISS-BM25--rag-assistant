[site]: datascience
[post_id]: 89707
[parent_id]: 
[tags]: 
Classify from list of embedding vertors

My goals is to create a classifier from list of N vectors as input. My vectors came from embedding model of image. Is There paper which propose method to create classifier from embedding vectors ? Edit: As Shubham Panchal advices me. I try to process the data as 1D vector. Each embedding from image generates me a 1280 float vector. I decided to take 10 images took at consecutive times. Here is how I capture images. In my example, I want to classify blinking leds from a device. So I use opencv to diff images and generates me 10 images when differences between frames are important. I checked in my dataset, the result is ok. For each blinking type, the goog image is extracted. Then for each image of my behavior, I use a VGG-16 to generate a 1280 embedding vector, so I get a 10x1280 array for each behavior. I find the max and min value of the dataset and I normalize it. Finally, I create a classifier to classify the behavior. I get poor result, lower than 0.4 in accuracy on my train dataset and my test dataset. Here is the models, I used def create_model1D(input_shape, output_label_size): model = Sequential() model.add(Conv1D(16, 5 , activation='relu', input_shape=input_shape)) model.add(Dropout(0.1)) model.add(Conv1D(32, 5 , activation='relu', input_shape=input_shape)) model.add(Dropout(0.1)) model.add(Flatten()) model.add(Dense(128, activation='relu')) model.add(Dropout(0.5)) model.add(Dense(6, activation='softmax')) model.compile(optimizer=Adam(learning_rate=0.000001), loss = "sparse_categorical_crossentropy", metrics= ['accuracy']) model.summary() # plot_model(model, to_file='model.png') return model def create_model2D(input_shape, output_label_size): model = Sequential() model.add(Conv2D(16, (2, 2), activation='relu', input_shape=input_shape)) model.add(MaxPool2D()) model.add(Dropout(0.1)) model.add(Conv2D(32, (2, 2), activation='relu')) model.add(MaxPool2D()) model.add(Dropout(0.2)) model.add(Flatten()) model.add(Dense(128, activation='relu')) model.add(Dropout(0.5)) model.add(Dense(6, activation='softmax')) model.compile(optimizer=Adam(learning_rate=0.000001), loss = "sparse_categorical_crossentropy", metrics= ['accuracy']) model.summary() # plot_model(model, to_file='model.png') return model
