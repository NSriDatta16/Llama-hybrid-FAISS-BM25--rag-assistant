[site]: stackoverflow
[post_id]: 1685504
[parent_id]: 1684489
[tags]: 
You certainly have put in a lot of work on this. I think the main problem is that BitmapCacheOption.None doesn't prevent the underlying BitmapDecoder(s) from being cached. There are several tricky solutions to this such as doing a GC.Collect(), loading 300 small images from 300 different Uris, and calling GC.Collect() again, but the simple one is straightforward: Instead of loading from a Uri, just construct a Stream and pass it to BitmapFrame's constructor: var source = new BitmapImage(); using(Stream stream = ...) { source.BeginInit(); source.StreamSource = stream; source.CacheOption = BitmapCacheOption.OnLoad; // not a mistake - see below source.EndInit(); } The reason this should work is that loading from a stream completely disables the cache. Not only is the top-level source not cached, but none of the internal decoders are cached either. Why BitmapCacheOption.OnLoad? It seems counterintuitive, but this flag has two effects: It enables caching if caching is possible, and it causes the load to happen at EndInit(). In our case caching is impossible, so all it does it cause the load to happen immediately. Obviously you'll want to run this code off your UI thread, then freeze the BitmapSource so you can move it over. You may also wonder why I didn't use BitmapCreateOptions.IgnoreImageCache. Other than the fact that caching is impossible any with no URI given, the IgnoreImageCache doesn't completely ignore the image cache: It only ignores it for reading. So even if IgnoreImageCache is set, the loaded image is still inserted into the cache. The difference is that the existing image in the cache is ignored.
