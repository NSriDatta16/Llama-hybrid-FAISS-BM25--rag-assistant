[site]: stackoverflow
[post_id]: 4838570
[parent_id]: 4837102
[tags]: 
To add on: What you ought to do here is make an NSObject subclass to represent your packet, and then adopt NSCoding to serialize it to an NSData in the way that you want. Doing this with a struct isn't buying you anything, and makes things even harder. It's also fragile, since packing a struct into an NSData doesn't account for things like endian-ness, etc. The tricky part of the packetizing process using NSCoding is that you don't really know what the overhead of the coding process is, so being as big as possible, but still under the max packet size is tricky... I present this without testing, or warranty, but if you want a decent start on that approach, this may be it. Be warned, I didn't check to see if my arbitrary 100 bytes for overhead was realistic. You'll have to play with the numbers a little bit. Packet.h: @interface Packet : NSObject { NSString* fileName; NSInteger fileType; NSUInteger totalPackets; NSUInteger packetIndex; NSData* packetContents; } @property (readonly, copy) NSString* fileName; @property (readonly, assign) NSInteger fileType; @property (readonly, assign) NSUInteger totalPackets; @property (readonly, assign) NSUInteger packetIndex; @property (readonly, retain) NSData* packetContents; + (NSArray*)packetsForFile: (NSString*)name ofType: (NSInteger)type withData: (NSData*)fileContents; @end Packet.m: #import "Packet.h" @interface Packet () @property (readwrite, assign) NSUInteger totalPackets; @property (readwrite, retain) NSData* packetContents; @end @implementation Packet - (id)initWithFileName: (NSString*)pFileName ofType: (NSInteger)pFileType index: (NSUInteger)pPacketIndex { if (self = [super init]) { fileName = [pFileName copy]; fileType = pFileType; packetIndex = pPacketIndex; totalPackets = NSUIntegerMax; packetContents = [[NSData alloc] init]; } return self; } - (void)dealloc { [fileName release]; [packetContents release]; [super dealloc]; } @synthesize fileName; @synthesize fileType; @synthesize totalPackets; @synthesize packetIndex; @synthesize packetContents; - (void)encodeWithCoder:(NSCoder *)aCoder { [aCoder encodeObject: self.fileName forKey: @"fileName"]; [aCoder encodeInt64: self.fileType forKey:@"fileType"]; [aCoder encodeInt64: self.totalPackets forKey:@"totalPackets"]; [aCoder encodeInt64: self.packetIndex forKey:@"packetIndex"]; [aCoder encodeObject: self.packetContents forKey:@"totalPackets"]; } - (id)initWithCoder:(NSCoder *)aDecoder { if (self = [super init]) { fileName = [[aDecoder decodeObjectForKey: @"fileName"] copy]; fileType = [aDecoder decodeInt64ForKey:@"fileType"]; totalPackets = [aDecoder decodeInt64ForKey:@"totalPackets"]; packetIndex = [aDecoder decodeInt64ForKey:@"packetIndex"]; packetContents = [[aDecoder decodeObjectForKey:@"totalPackets"] retain]; } return self; } + (NSArray*)packetsForFile: (NSString*)name ofType: (NSInteger)type withData: (NSData*)fileContents { const NSUInteger quanta = 8192; Packet* first = [[[Packet alloc] initWithFileName:name ofType:type index: 0] autorelease]; // Find out how big the NON-packet payload is... NSMutableData* data = [NSMutableData data]; NSKeyedArchiver* coder = [[[NSKeyedArchiver alloc] initForWritingWithMutableData:data] autorelease]; [first encodeWithCoder: coder]; [coder finishEncoding]; const NSUInteger nonPayloadSize = [data length]; NSMutableArray* packets = [NSMutableArray array]; NSUInteger bytesArchived = 0; while (bytesArchived The reassemblage of the original file from these packets can be done using much the same approach as splitting it up... Iterate over the packets, copying from the individual packet payload NSDatas into a big NSMutableData. In closing, I feel compelled to say that when you find yourself doing something like this, that boils down to implementing a primitive TCP stack, it's usually time to stop yourself and ask if there aren't better ways to do this. Put differently, if GameKit were the best way to transfer files between devices over bluetooth, one would expect that the API would have a method for doing just that, but instead it has this 8K limit. I'm not being intentionally cryptic -- I don't know what the right API would be for your situation, but the exercise of cooking up this Packet class left me thinking, "there's gotta be a better way." Hope this helps.
