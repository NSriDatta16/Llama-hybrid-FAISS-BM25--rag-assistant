[site]: stackoverflow
[post_id]: 1226341
[parent_id]: 1225628
[tags]: 
Couple of things: You're probably better off using UITextField instead of UITextView. UITextField is ideal for single-line entries like what you're describing here. As for your solution, here's what I'd recommend. (Also took the liberty of cleaning up your memory management) Add a BOOL property to your Player class called, say, 'needsKeyboardDisplay', then set it to yes after you create a new instance. -(IBAction)addPlayerPressed:(id)sender { Player *newPlayer = [[Player alloc] init]; newPlayer.needsKeyboardDisplay = YES; [players addObject:newPlayer]; [newPlayer release]; [table reloadData]; // Scroll to bottom showing the new player location NSIndexPath *scrollIndexPath = [NSIndexPath indexPathForRow:([players count] - 1) inSection:0]; [table scrollToRowAtIndexPath:scrollIndexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES]; } Then, in cellForRowAtIndexPath, insert this after you've otherwise set up your cell: Player *playerForCell = [players objectAtIndex:indexPath.row]; if (playerForCell.needsKeyboardDisplay) { [nameField becomeFirstResponder]; playerForCell.needsKeyboardDisplay = NO; } All that said, from a user experience perspective, the (somewhat) standard iPhone experience for editing details in a long list of items like this is to do it in another view. It's up to you, of course.
