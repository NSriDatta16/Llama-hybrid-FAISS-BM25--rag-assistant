[site]: datascience
[post_id]: 43087
[parent_id]: 43086
[tags]: 
I figured it out by using a temporary array as mentioned, but the result is ugly as hell a = 2 / (n + 1) for _, group in data.groupby('group'): ema = np.zeros(len(group.index)) ema[0] = group.iloc[0]['price'] i = 1 for index, row in group.iloc[1:].iterrows(): ema[i] = a * row['price'] + (1 - a) * ema[i-1] data.loc[index, 'EMA'] = ema[i] i = i + 1 print(data) price group bin EMA 0 5.121409 one 0 5.121409 1 6.359162 one 1 5.533993 2 0.841837 one 2 3.969941 3 9.348758 one 3 5.762880 4 3.671258 one 4 5.065673 5 1.651604 two 0 1.651604 6 7.940099 two 1 3.747769 7 8.777750 two 2 5.424429 8 8.227762 two 3 6.358873 9 3.283300 two 4 5.333682 10 8.290492 three 0 8.290492 11 8.589680 three 1 8.390221 12 0.159063 three 2 5.646502 13 5.504104 three 3 5.599036 14 9.392295 three 4 6.863456 I'm not going to accept my answer because there has to be a more elegant way of doing it. Any offers?
