[site]: stackoverflow
[post_id]: 1496267
[parent_id]: 1496246
[tags]: 
Tail recursion is optimized in every functional language -- it has no overhead compared to a procedural language's loop (or, ahem, goto;-). While the specific example you give might or might not be "tail recursion" depending on the language (lazy vs eager functional languages, for examples), when you're coding in one specific language you can generally refactor to a purely tail-recursive expression... if and when that's needed. In a lazy language, e.g. Haskell, the append in (the Haskell's equivalent of) [First | append(Rest, List)] would be just saved as a "thunk" to be execute when and IF needed, as opposed to eagerly expanded at once. Then, when, later, somebody pattern matches THAT thunk against a head/tail structure -- then, and only then, the thunk is first executed. Eager (non-lazy) languages have a different approach, but it's not any less efficient (although lazy-language fans might argue it IS less elegant;-).
