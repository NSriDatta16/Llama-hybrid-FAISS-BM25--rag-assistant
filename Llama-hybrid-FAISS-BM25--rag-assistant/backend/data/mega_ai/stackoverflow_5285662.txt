[site]: stackoverflow
[post_id]: 5285662
[parent_id]: 5284458
[tags]: 
I was going to comment regarding @knivil's Scheme. Instead I'll just throw this up as another answer. Lazy data structures aren't the only way to accomplish most tasks. This might irritate Pythonistas. But I believe it's best when programmers get to choose which techniques they use. Lazy techinques are powerful and elegant. Knivil mentioned using Scheme's iota . Look how easy it is to write the full method (with all 3 args), relying on laziness: iota count begin step = let xs = begin:map (+step) xs in take count xs -- or, alternately iota count begin step = take count $ map ((+begin).(*step)) [0..] I could also write length for non-empty lists by abusing laziness: len = fst . last . zip [1..] -- or even handling empty lists len = fst . last . zip [0..] . (undefined:) Consider the powerful and elegant iterate function defined in Prelude. iterate f x = x : iterate f (f x) It creates the infinite list [x, f x, f (f x), f (f (f x)), ...] . I could have written iota in terms of iterate : iota count begin step = take count $ iterate (+step) begin The lazy approach is an elegant way to program. It's not the only way, and people used to C or Java will certainly cry out "but I don't need laziness, I can just _", and they are correct. If your language is Turing-complete, it can be done. But laziness can be oh so elegant.
