[site]: stackoverflow
[post_id]: 2627659
[parent_id]: 2625440
[tags]: 
The elegant solution would be to pass the reference to class fun instance to the oneThread constructor, as other suggested, but you seem to be trying to do something else: making the fun class as singleton an accessing it as a global object. Is that right? That is usually a bad idea, but sometimes makes sense. If that is the case, then you are making two mistakes: you use self.fun in oneThread.run , although 'fun' is not part of the oneThread class or its instance. You should be using just 'fun' to access the class 'fun'. It doesn't matter it is defined below, as the code will be executed when the class is already defined. in fun.__init__ you are not writting the class attribute fun.wTree , but creating a instance attribute wTree . The class attribute fun.wTree will stay None . To change it use fun.wTree = gtk.glade.XML( "main.glade" ) instead (though, you may keep using self.wTree to access it later). So the code would look like this: class oneThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.start() def run(self): print "1" time.sleep(1) print "2" time.sleep(1) print "3" fun.wTree.get_widget("entryResult").set_text("Done with One.") class fun: wTree = None def __init__( self ): fun.wTree = gtk.glade.XML( "main.glade" ) self.wTree.signal_autoconnect( {"on_buttonOne" : self.one} ) gtk.main() def one(self, widget): oneThread(); gtk.gdk.threads_init() do=fun() I would also suggest renaming wTree attribute to instance in such case too. And once more: this (using a singleton as a kind of global variable) is probably not the way to go.
