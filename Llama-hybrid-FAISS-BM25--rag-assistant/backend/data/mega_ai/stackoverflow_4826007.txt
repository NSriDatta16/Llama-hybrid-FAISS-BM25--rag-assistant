[site]: stackoverflow
[post_id]: 4826007
[parent_id]: 4825945
[tags]: 
What you have there is a function that returns an istance of Object, not a JS class. You will want to check out using DataSource.prototype , and you should be adding properties to or modifying this within your constructor if you want to use this in conjunction with new You should probably be doing something like this: function DataSource(src, extension){ //Make sure this behaves correctly if someone forgets to use new if (! this instanceof DataSource) return new DataSource(src,extension); //store the constructor arguments //so you can use them in the shared methods below this._src=src; this._extension=extension; } DataSource.prototype.exists=function(){ //use this._src and this._extension here //This method will be available to all //objects constructed by new DataSource(...) }; DataSource.prototype.get=function(){ //use this._src and this._extension here //This method will be available to all //objects constructed by new DataSource(...) }; var instance = new DataSource('a source','an extension'); Edit: You've mentioned you would prefer 'private' variables Constructing closures is the only portable way of simulating private properties, however in my experience prefixing them with an _ and having a convention within your organisation to not rely on _ prefixed variables is sufficient in most situations
