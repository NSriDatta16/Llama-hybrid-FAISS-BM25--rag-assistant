[site]: stackoverflow
[post_id]: 2123868
[parent_id]: 2123675
[tags]: 
I think usage of Strategy pattern would help in your case. You can have a abstract base class (say Agent) and provide setters for setting the behavior or the behavior can be set in the constructors. Here is some sample code to explain my intention: abstract class Agent { Strategic strategy; Decidable chooser; public setStrategy(Strategic s) { this.strategy = s; } public setChoiceMaker(Decidable c) { this.choser = c; } abstract public void action(); } class IntelligentAgent extends Agent { public void action() { // perform some action by invoking methods in // interface Strategic and Decidable } } class StupidtAgent extends Agent { public void action() { // for stupid agent you can set strategy and choice // to refer to some suboptimal implementations of // Strategic and Decidable } } The advantage comes with the Strategy pattern is that behavior of the agents is now determined by composition which this can be modified if necessary (by providing setters).
