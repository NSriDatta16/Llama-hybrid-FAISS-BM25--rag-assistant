[site]: stackoverflow
[post_id]: 2288322
[parent_id]: 2288171
[tags]: 
For elegance and simplicty: void Choose (const int size, int &first, int &second) { // pick a random element first = rand () * size / MAX_RAND; // pick a random element from what's left (there is one fewer to choose from)... second = rand () * (size - 1) / MAX_RAND; // ...and adjust second choice to take into account the first choice if (second >= first) { ++second; } } using first and second to index the vector. For uniformness, this is very tricky since as size approaches RAND_MAX there will be a bias towards the lower values and if size exceeds RAND_MAX then there will be elements that are never chosen. One solution to overcome this is to use a binary search: int GetRand (int size) { int lower = 0, upper = size; do { int mid = (lower + upper) / 2; if (rand () > RAND_MAX / 2) // not a great test, perhaps use parity of rand ()? { lower = mid; } else { upper = mid; } } while (upper != lower); // this is just to show the idea, // need to cope with lower == mid and lower != upper // and all the other edge conditions return lower; }
