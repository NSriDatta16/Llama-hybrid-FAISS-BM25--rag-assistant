[site]: stackoverflow
[post_id]: 3095203
[parent_id]: 799446
[tags]: 
My answer is like above Aggregate solution but should be less call-stack heavy since there are no explicit delegate calls: public static string ToCommaDelimitedString (this IEnumerable items) { StringBuilder sb = new StringBuilder(); foreach (var item in items) { sb.Append(item.ToString()); sb.Append(','); } if (sb.Length >= 1) sb.Length--; return sb.ToString(); } Of course, one can extend the signature to be delimiter-independent. I'm really not a fan of the sb.Remove() call and I'd like to refactor it to be a straight-up while-loop over an IEnumerable and use MoveNext() to determine whether or not to write a comma. I'll fiddle around and post that solution if I come upon it. Here's what I wanted initially: public static string ToDelimitedString (this IEnumerable source, string delimiter, Func converter) { StringBuilder sb = new StringBuilder(); var en = source.GetEnumerator(); bool notdone = en.MoveNext(); while (notdone) { sb.Append(converter(en.Current)); notdone = en.MoveNext(); if (notdone) sb.Append(delimiter); } return sb.ToString(); } No temporary array or list storage required and no StringBuilder Remove() or Length-- hack required. In my framework library I made a few variations on this method signature, every combination of including the delimiter and the converter parameters with usage of "," and x.ToString() as defaults, respectively.
