[site]: stackoverflow
[post_id]: 5425803
[parent_id]: 5422047
[tags]: 
Fortunately for us, we don't have to worry about a hotfix/service pack; we're still on Delphi 5. :D Sigh, there was a time when an entire application (settings and all) would exist within a single directory - making this a non-issue. But, the world has moved on, and we have various parts of an application scattered all over the place: registry Windows\System Program Files Sometimes even User folders in "Application Data" or "Local Settings" You are quite right to consider the impact of hotfixes/service packs. It's not only RTL/VCL that could be affected, but the compiler itself could have been slightly changed. Note also that running on the same line of thought, even when you upgrade Delphi versions, you need to build using the correct version. Admittedly this is a little easier because you can run different Delphi versions alongside each other. However, I'm going to advise that it's probably not worth going to too much effort. Remember, working on old versions is always more expensive than working on the current version. Ideally you want all your dev to be be on main branch code, you want to minimise patch-work on older versions. So strive to keep the majority of your users on the latest version as much as possible. Admittedly this isn't always possible. You wouldn't want to jump over to the 'new version' without some testing first in any case. Certain agile processes do tend to make this easier. By using a separate build machine or VM, you already have a measure of control. TIP: I would also suggest that the build process automtically copy build output to a different machine, or at least a different hard-drive. Once you're satisfied with the service pack, you can plan when you want to roll it to your build machine. It is extremely important to keep record of the label at which the build configuration changed. (Just in case.) If your build scripts are also kept in source control, this happens implicitly. When you've rolled out the hotfix/service pack, fixes to older versions should be actively discouraged. Of course, they probably can't be eliminated, but if it's rare enough, then even manual reconfiguration could be feasible. Instead of a VM option to keep your old configuration, you can also consider drive-imaging. To save on the $$$ of VMWare LabManager, look for a command-line driven VM Player. You might have to keep 2 "live" machines/VMs, but should never need more than that. It's okay for an automatic build script to fail because the desired configuration isn't available. This will remind you to set it up manually. Remember, working on old versions is always more expensive than working on the current version. Third Party Packages We went to a little bit more effort here. One of our main motivations though was the fact that we use about 8 third party packages. So doing something to standardise this in itslef made sense. We also decided running 8 installation programs was a PITA, so we devised an easy way to manually install all required packages from source-control. Key Considerations The build environment doesn't need any packages installed , provided the object and/or source files are accessible. It would help if developers could fairly easily ensure they're building with the same version of third party libraries when necessary. However, dev environments usually must install packages into the IDE. This can sometimes cause problems with source compatibility. For example new properties that get written to IDE maintained files. Which of course brings us back to the second point. Since Third Party packages are infrequently updated, they are placed within a slightly different area of source-control. But, NB must still be referenced via relative paths. We created the following folder structure: ...\ThirdParty\_DesignTimePackages //The actual package files only are copied here ...\ThirdParty\_RunTimePackages //As above, for any packages "required" by those above ...\ThirdParty\Suite1 ...\ThirdParty\Suite2 ...\ThirdParty\Suite3 As a result of this it's quite easy to configure a new environment: Get latest version of all ThirdParty files. Add _DesignTimePackages and _RunTimePackages to Windows Path Open Delphi Select Install Components Select all packages from _DesignTimePackages. Done! Edit : Darian was concerned about the possibility of errors when switching switching versions of Design Packages. However, this approach avoids those kinds of problems. By adding _DesignTimePackages and _RunTimePackages to the Windows Path, Delphi will always find required packages in the same place. As a result, you're less likely to encounter the 'package nightmare' of incompatible versions. Of course, if you do something silly like rebuild some of your packages and check-in the new version, you can expect problems - no matter what approach you follow.
