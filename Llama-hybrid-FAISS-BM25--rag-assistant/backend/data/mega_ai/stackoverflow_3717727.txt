[site]: stackoverflow
[post_id]: 3717727
[parent_id]: 3717179
[tags]: 
Fair question really... it's so easy for us to take so much for granted. To read the manual page for the command called file , just type... man file ...which will present a lot of information that will probably be quite confusing, but you'll get used to this stuff pretty quick if you keep at it. Crucially, file is a program that tries to categorise the files you ask it to. If you type... file /dev/* ...that will do what the question asked, and invoke file with a list of the files in the /dev/ subdirectory. The list is actually prepared by the "shell" program that you're typing into, which then executes the file program and passes it the list. file then outputs some description of the files. On my computer, and where [SHELL-PROMPT] will be different on your computer, I typed file /dev/* and part of the output looked like: [SHELL-PROMPT] file /dev/* ...lots of stuff... /dev/cevt: character special (255/176) /dev/console: character special (5/1) /dev/core: symbolic link to `/proc/kcore' /dev/cpqci: character special (10/209) /dev/cpqhealth: directory /dev/crom: character special (255/180) ...lots of stuff... /dev/md8: block special (9/8) /dev/md9: block special (9/9) /dev/mem: character special (1/1) /dev/mice: character special (13/63) /dev/mouse0: character special (13/32) /dev/mptctl: character special (10/220) /dev/net: directory /dev/nflog: character special (36/5) /dev/null: character special (1/3) /dev/parport0: character special (99/0) ...lots of stuff... There's a filesystem entry for each directory/file combination (known as a path) in the left column, and file is describing the content in the right. Those descriptions may not make a lot of sense, but you can see that some patterns: some entries are "block special", others "character special", some are directory which implies you may find more files underneath (i.e. ls /dev/net/* ). The numbers after "special" files are just operating system identifiers to differentiate the files mentioned. The import of this is that input and output from some devices connected to the computer is being made possible as if the device was a file in the filesystem. That "file" abstraction is being used as a general model for input and output. So, /dev/tty for example is tty - or terminal - device. Any data you try to read from there will actually be taken from the keyboard you're using to type into the shell (in the simple case), and anything you write there will become visible in the same terminal you're typing into. /dev/null is another interesting one: you can read and write from it, but it's an imaginary thing that never actually provides data (just indicates and End-of-File condition, and throws away any data written into it). You can keep reading from /dev/random and it will produce random values each time... good if you need random numbers or file content for encryption or some kind of statistical work. 2) Run the tty command, and note the device name of your terminal. Now use this device name(/dev/pst/6) in the command cp /etc/passwd /dev/pts/6. what do you observe? By typing "tty" you can ask for the device representing your terminal... [SHELL-PROMPT] tty /dev/pts/11 But, I just said /dev/tty is another name for the same thing, so there's normally no need to use the "tty" program to find this more specific name. Still, if you create a couple terminal windows to your host, and type tty in each, you will see that each shell is connected to a different pseudo-terminal device. Still, each shell - and program run from the shell - can by default also refer to its own terminal input and output device as /dev/tty... it's a convenient context-sensitive name. The command... cp /etc/passwd /dev/pts/6 ...where you replace 6 with whatever your tty program really reported (e.g. 11 in my case), does the same thing as... cp /etc/passwd /dev/tty ...it just reads the contents of the file /etc/passwd and writes them out on your screen. Now, the problem is that /etc/password looks like a lot of unintelligible junk to the average person - it's no wonder you couldn't make sense of what was happening. Try this instead... echo "i said hello" > /tmp/hello.file cp /tmp/hello.file /dev/tty ...and you'll see how to direct some specific, recognisable content into a new file (in this case putting it in the tmp "temporary" directory (the file will disappear when you reboot your PC), then copying that file content back to your screen. (If you have logged on in two terminal windows, you can even go into one shell and copy the file to the /dev/pts/NN device reported by the other shell, effectively sending a message to the other window. You can even bypass the file and echo 'boo' > /dev/tty/NN . You'll only have permissions to do this if the same userid is logged into both windows.)
