[site]: stackoverflow
[post_id]: 2039172
[parent_id]: 2039138
[tags]: 
I suspect you have a string struct like this: struct string { int length; int somethingelse; /* thanks alok */ char *str; } and this function is trying to access the length field when given a pointer to the str? Am I correct? I imagine this is what isOurs checks for (to make sure it's not any old string). In which case, you want this: length = (*((int*)(src - 2))) * sizeof(int); int utstrlen(char* src){ int length=0 ; if(isOurs(src) ==1){ length = *((int*)(src - (2 * sizeof(int)))); /* from str moveback 2 ints worth*/ } else { //return strlen(src) ? } return length; } But ideally you wouldn'd do that. It's not portable or maintainable. What happens if the compiler inserts padding you don't know about? The C99 standard says it will not put padding between the 0 sized array and the previous field, but there's nothing to stop it going mad with the other ones (if you have a mixture of types, for instance). What happens if someone comes along later and inserts more data into the structure? Naturally, they'd have to put it before the field str, as the 'struct hack' works by having it at the end. Ideally you should be using offsetof() to do this, which is a standard macro. Alok provides a better solution here and Ugly Macro Interpretation (just 1 line) edit (it seems in the 2 minutes it took me to type that new last paragraph, Alok's offsetof() answer has been accepted over this one ;) )
