[site]: stackoverflow
[post_id]: 4495061
[parent_id]: 4495003
[tags]: 
def __init__(self, _app_parent, _db_path, stock_list=None): self.db_path = _db_path self.app_parent = _app_parent self.tracking_stocks = [] self.registered_stocks = [] self.total_purchase_exp = 0 self.ytd_roi = 0 self.cash_reserve = 500 if stock_list: if database_exists( self.db_path ): return None self.create_database() self.import_portfolio_data() for stock_data in stock_list: self.add_stock( stock_data ) else: if not self.database_exists( self.db_path ): return None self.import_portfolio_data() self.import_stocks() Most of this is copy-pasted, so I can't attest to the accuracy of the indentation, etc., but this is the general pattern for creating versatile __init__ methods in Python (note that __init__ by itself is not a constructor, it's an initializer). Since Python supports keyword args and default values for keyword args, there's really no reason to ever use overloading (in fact, we save a lot of repetitious code by not having overloading). Instead, we just use a keyword arg stock_list with a default value of None. This isn't perfectly fixed up, either; some of the problems persist (since it's copy-pasted). I don't know the details of what the constructor does, but I think with a little more refactoring you could get things set up where the __init__ is much shorter and much more elegant (consider separating out pieces of the initialization into methods, like _init_db() and call those from __init__ ).
