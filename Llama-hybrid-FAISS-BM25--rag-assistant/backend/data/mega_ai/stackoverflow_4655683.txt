[site]: stackoverflow
[post_id]: 4655683
[parent_id]: 4456861
[tags]: 
The most elegant way I know of is to use Core Data for the local data, and to have your UITableView listening for change notifications from the Core Data store. This maintains model/view separation, and yet you can still get the eye candy of a row-deletion animation. It goes like this: User says to delete a row. Your code sends off an ASIHTTPRequest, and registers a selector to be called back when the request succeeds. When it's done, the callback selector modifies the model that is in your Core Data store. This automatically causes your UITableView to be notified that a row was deleted, so it can animate the deletion of the row. This doesn't get the bonus points, because it doesn't give you any sort of UI indication that the cell will be deleted soon. One thing I've considered doing sometimes, but haven't been brave enough to try, is to optimistically code things on the assumption that the web-service call will almost certainly succeed, so go ahead and delete the row immediately, before the ASIHTTPRequest indicates success/failure; but then, if it does fail, roll back, and make the row re-appear. This has the advantage of making the app much faster in the common case where the web-service call succeeds. Core Data gives you a couple of ways to do this kind of "roll-back" stuff, but still, it definitely gets tricky, so it may not be worth it. If you don't want to use Core Data, then to me KVO is the second-best solution. EDIT: Thinking about it a bit more, in order to get a visual indicator that the row is about to be deleted, your Core Data model could have a flag on each row, "markedForDeletion" or something; when you fire off the ASIHTTPRequest, you would also modify the model to set markedForDeletion to true. The UITableView would be notified of the change (because it has registered for notifications); so it would then do whatever UI you want on top of the row, e.g. a spinner or something, to indicate that it's being deleted. Then, if the ASIHTTPRequest succeeds, it just deletes the row; but if it fails, it sets the rows "markedForDeletion" flag back to false, which causes the UITableView to turn off the spinner.
