[site]: stackoverflow
[post_id]: 4542698
[parent_id]: 4542600
[tags]: 
If you give a person a fish, they eat for a day. If you teach a person to fish... My measures for the quality of an implementation are: Correctness : If you aren't getting the right answer in all cases, then it isn't ready Readability/maintainability : Look at code repetition, understandable names, the number of lines of code per block/method (and the number of things each block does), and how difficult it is to trace the flow of your code. Look at any number of books focused on refactoring, programming best-practices, coding standards, etc, if you want more information on this. Theoretical performance (worst-case and ammortized): Big-O is a metric you can use. CPU and memory consumption should both be measured Complexity : Estimate how it would take an average professional programmer to implement (if they already know the algorithm). See if that is in line with how difficult the problem actually is As for your implementation: Correctness : I suggest writing unit tests to determine this for yourself and/or debugging it (on paper) from start to finish with interesting sample/edge cases. Null, one item, two items, various numbers of duplicates, etc Readability/maintainability : It looks mostly fine, though your last two comments don't add anything. It is a bit more obvious what your code does than the code in the book Performance : I believe both are N-squared. Whether the amortized cost is lower on one or the other I'll let you figure out :) Time to implement : An average professional should be able to code this algorithm in their sleep, so looking good
