[site]: stackoverflow
[post_id]: 3792376
[parent_id]: 3786365
[tags]: 
The accepted answer answered the question that you asked, but didn't address whether you ought. Your string is a class and has class semantics. The initializer may be fine for kernel code where every last instruction counts, but in application code your static initializers are ugly and error prone. It is possible to write classes in C, the stdio FILE type is a fabulous example, and here is the same idea applied to your string class: typedef struct { int length; char *data; } String; String *sopen() { String *s = malloc(sizeof(String)); if(s) { s->length = 0; s->data = NULL; } return s; } int sclose(String *s) { free(s->data); free(s); return 0; } int main() { String *s = sopen(); return sclose(s); } Where I've followed the FILE* function name style for metaphoric reasons. Yep, there's more code. Yep, you have to explicitly deallocate the structure; but note that even though you were counting on auto class initialization in your code sample, if data was ever allocated, you couldn't count on leaving scope to automatically deallocate the storage for you. This approach also has the merit of abstracting the type of data from the users of the class. As there seems to be some confusion about what type you really want to use, this flexibility may come in handy.
