[site]: stackoverflow
[post_id]: 4949330
[parent_id]: 4927014
[tags]: 
But I want to apply an I/O action to the inside of the Maybe. This can be achieved with monad transformers. MaybeT is a monad that can be wrapped around another monad. Put another way, MaybeT can use any other Monad to abstract away (innocent[1]) failure in a computation. Sadly, GHCi does not (in 2011) have any functionality to make playing with monad transformers easier, but here you go: > :m + Control.Monad.Maybe Control.Monad.Trans > let a = Just 5 > runMaybeT$ do { v For more in-depth understanding of monads and monad transformers, I suggest you read other sources in the web. Keep in mind monads also simply wrap values. I'll try to keep it simple. Signatures: m = IO, a = Integer runMaybeT :: MaybeT m a -> m (Maybe a) -- Turns a computation in MaybeT IO into a computation in IO. do { -- do notation without indentation to make it fit on ghci's prompt[2]. MaybeT :: m (Maybe a) -> MaybeT m a -- Wrap a computation of type IO (Maybe Integer). return a :: IO (Just Integer) -- Replace this with your computation. lift -- Run the computation in the wrapped monad.[3] Just () -- The result of the computation. GHCi prints IO results whenever it is not (). MaybeT is not included in mtl, so you might have to install it cabal install MaybeT Or consider [1] [1] For passing error messages as well, use MonadError [2] I know about multiline input in GHCi [3] Use liftIO if you need IO from a stack of monads.
