[site]: stackoverflow
[post_id]: 4439978
[parent_id]: 4435995
[tags]: 
Updated : see below. I'd approach this first by visualizing the imaginary parts of the roots: This tells you three things immediately: 1) the first root is always real, 2) the second two are the conjugate pairs, and 3) there is a small region near zero in which all three are real. Additionally, note that the exclusions only got rid of the singular point at x=0 , and we can see why when we zoom in: We can then use the EvalutionMonitor to generate the list of roots directly: Map[Module[{f, fcn = #1}, f[x_] := Im[fcn]; Reap[Plot[f[x], {x, 0, 1.5}, Exclusions -> {True, f[x] == 1, f[x] == -1}, EvaluationMonitor :> Sow[{x, f[x]}][[2, 1]] // SortBy[#, First] &];] ]&, geyvals] (Note, the Part specification is a little odd, Reap returns a List of what is sown as the second item in a List , so this results in a nested list. Also, Plot doesn't sample the points in a straightforward manner, so SortBy is needed.) There may be a more elegant route to determine where the last two roots become complex, but since their imaginary parts are piecewise continuous, it just seemed easier to brute force it. Edit : Since you've mentioned that you want an automatic method for generating where some of the roots become complex, I've been exploring what happens when you substitute in y -> p + I q . Now this assumes that x is real, but you've already done that in your solution. Specifically, I do the following In[1] := poly = g.RotationMatrix[Pi/2].h.g /. {y -> p + I q} // ComplexExpand; In[2] := {pr,pi} = poly /. Complex[a_, b_] :> a + z b & // CoefficientList[#, z] & // Simplify[#, {x, p, q} \[Element] Reals]&; where the second step allows me to isolate the real and imaginary parts of the equation and simplify them independent of each other. Doing this same thing with the generic 2D polynomial, f + d x + a x^2 + e y + 2 c x y + b y^2 , but making both x and y complex; I noted that Im[poly] = Im[x] D[poly, Im[x]] + Im[y] D[poly,[y]] , and this may hold for your equation, also. By making x real, the imaginary part of poly becomes q times some function of x , p , and q . So, setting q=0 always gives Im[poly] == 0 . But, that does not tell us anything new. However, if we In[3] := qvals = Cases[List@ToRules@RReduce[ pi == 0 && q != 0, {x,p,q}], {q -> a_}:> a]; we get several formulas for q involving x and p . For some values of x and p , those formulas may be imaginary, and we can use Reduce to determine where Re[qvals] == 0 . In other words, we want the "imaginary" part of y to be real and this can be accomplished by allowing q to be zero or purely imaginary. Plotting the region where Re[q]==0 and overlaying the gradient extremal lines via With[{rngs = Sequence[{x,-2,2},{y,-10,10}]}, Show@{ RegionPlot[Evaluate[Thread[Re[qvals]==0]/.p-> y], rngs], ContourPlot[g.RotationMatrix[Pi/2].h.g==0,rngs ContourStyle -> {Darker@Red,Dashed}]}] gives which confirms the regions in the first two plots showing the 3 real roots.
