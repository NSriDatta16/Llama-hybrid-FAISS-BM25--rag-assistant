[site]: stackoverflow
[post_id]: 3145419
[parent_id]: 3144546
[tags]: 
TDD forces you to think from the perspective of "consuming" the code you are going to write. This point of view helps to place you (the developer) into a position where you need to think about how your API will be structured as well as how you would verify the requirements of the implementation. TDD helps identify defects in areas like: Requirements. Is it clear what the code will need to do. Is it possible to verify the invariants or end-effects of the code. Are the success criteria defined in the requirements or are they vague or absent. Ease of Use. Can you effectively use the code you plan on writing to achieve the kinds of things that are needed by end users, or by other code that it will integrate with in the future. Testability. Is the code verifiable based on the accessible data or objects in the design. Is it possible to confirm that things will function as they should. Edge Cases. It's often easier to identify and respond to edge cases by identifying their existance up-front. WHen edge cases crop up late in the game, there's an inclination to try to "force" the existing design to accomodate them, rather than rethinking the design. Exception Handling. When you start writing tests cases, you begin to realize areas where you may want to be able respond to errors or exceptional conditions. This can help plan your exception handling strategy, the kinds of exceptions to throw, what information to include, etc. TDD also help to improve the level of coverage in tests because it brings testing to the foreground, rather than making it an "after the fact" activity. When testing happens last, it is most prone to be omitted or short-shrifted due to time and budget constraints, or due to the natural drop in enthusiasm and motivation on the part of the developer.
