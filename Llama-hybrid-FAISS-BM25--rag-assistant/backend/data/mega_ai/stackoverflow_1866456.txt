[site]: stackoverflow
[post_id]: 1866456
[parent_id]: 
[tags]: 
Calling equals on an ArrayList After Serialization

I am hitting a strange problem in relation to equals on an object transported over RMI. This has been wrecking my head for a few days now and I was wondering if anyone can help shed some light on the Problem. I have a Garage Class (that is also a JPA entity in case its relevant) that I push to a java process called X over RMI (So this object is being serialized). The Garage object stores a list of objects called Car (also JPA entities) that are also Serializable. The equals method on Garage is basically calling equals on its list of cars (an ArrayList) When I call equals in the java process it does not for some reason call equals on the list like i expect I would expect it to call equals on all the Cars in the list to check if the lists are equal it does not do this. The strange thing is when unit testing it does call equals on all the members of the Cars ArrayList. I even serialized the objects as part of my unit test and this worked too. Any ideas? I hope I am getting the problem across, feel free to request any info to clarify anything. Edit : I am nearly certain its ArrayList being weird as when I manually do equals in my object instead of calling equals on the list of cars I did a foreach loop on the list of cars and called equals on each Car (like I expected ArrayList equals to do anyway and it worked as expected) @Entity @Table(schema="pdw", name="garage") public class Garage implements Comparable , Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private String id; private String name; @OneToMany(cascade = CascadeType.ALL) @JoinTable(schema="pdw") private List cars = new ArrayList (); public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List getCars() { return cars; } public void setCars(List cars) { this.cars = cars; } @Override public String toString() { StringBuffer buffer = new StringBuffer(); buffer.append("["); buffer.append("Garage:"); buffer.append("[id:" + id + "]"); buffer.append("[Cars:" + cars + "]"); buffer.append("]"); return buffer.toString(); } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (!(obj instanceof Garage)) return false; Garage other = (Garage) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; if (cars == null) { if (other.cars != null) return false; } else if (!cars.equals(other.cars)) return false; return true; } @Override public int compareTo(Garage other) { return this.getName().compareTo(other.getName()); } } @Entity @Table(schema="pdw", name="car") public class Car implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private String id; private String name; @OneToOne(fetch = FetchType.LAZY) private Garage garage; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Garage getGarage() { return garage; } public void setGarage(Garage garage) { this.garage = garage; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Car other = (Car) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } @Override public String toString() { StringBuffer buffer = new StringBuffer(); buffer.append("["); buffer.append("Car:"); buffer.append("[id:" + id + "]"); buffer.append("[name:" + name + "]"); buffer.append("[garage:" + garage.getName() + "]"); buffer.append("]"); return buffer.toString(); } }
