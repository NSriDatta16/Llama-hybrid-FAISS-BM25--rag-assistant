[site]: stackoverflow
[post_id]: 4596186
[parent_id]: 4594433
[tags]: 
Jon gave you the answer you need, but there are some details to be aware of. C's treatment of arrays is such that the search function doesn't receive a 3x3 array of int ; rather, it receives a pointer to a 3-element array of int . From the C language standard, draft n1256 : 6.3.2.1 Lvalues, arrays, and function designators ... 3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined. Thus, when you call result = search(Array, number); , the type of the expression Array is implicitly converted from a 3-element array of 3-element arrays of int ( int [3][3] ) to a pointer to a 3-element array of int ( int (*)[3] ). In the context of a function parameter declaration, T a[] and T a[n] are synonymous with T *a . You could change the function prototype to int search(int (*a)[3], int x) and it would behave exactly the same. One consequence of this is that search can operate not just on 3x3 arrays, but on any Nx3 array. You've written your function to assume that a is always 3x3; if you want to be able to handle arrays of different numbers of rows, you would need to pass in a separate parameter to specify the number of rows in the array: int search(int (*a)[3], size_t rows, int x) { size_t i, j; for (i = 0; i The sizeof arr / sizeof *arr expression calculates the number of elements in the array by getting the total array size in bytes ( sizeof arr ) and dividing that by the number of bytes in an individual array element ( sizeof *arr or sizeof arr[0] ). Note that this only works for expressions of array type; it will not work for pointers that are being treated as arrays (such as the expression a in the search function). If you want to handle different numbers of rows and columns, you'll have to take a different approach: int search(int *a, size_t rows, size_t cols, int x) { size_t i, j; for (i = 0; i In this case, we explicitly pass a pointer to the first element in each array, so instead of receiving a pointer to an array of int , search receives a simple pointer to int , which we treat as a 1D array, and compute the offset manually as i * cols + j . This code assumes that all elements in the 2D array are contiguous. Edit Note that in C99, you can have what are called Variable Length Arrays (VLAs), where the array dimension can be specified by a runtime variable rather than a constant expression; this allows us to write the prototype as int search(size_t rows, size_t cols, int arr[rows][cols], int x) and not mess with pointers.
