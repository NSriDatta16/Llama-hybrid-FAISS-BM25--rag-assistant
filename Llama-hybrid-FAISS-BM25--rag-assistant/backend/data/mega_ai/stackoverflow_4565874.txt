[site]: stackoverflow
[post_id]: 4565874
[parent_id]: 4565681
[tags]: 
I too often wondered how exactly the MVC elements fit in a traditional web application structure, where you have views (pages), controllers, services, and data objects (model). As you said, there are many versions of that. I believe the confusion exists because of the above stated, widely accepted architecture, which uses the "anemic domain model" (alleged)-anti pattern. I won't go into much details about the "anti-patternness" of anemic data model (you can look at an effort of mine to explain things here (Java-based, but relevant for any language)). But in short, it means that our model holds only data, and business logic is placed in services/managers. But let's assume we have domain driven architecture , and our domain objects are the way they are expected to be - having both state and business logic. And in this domain-driven perspective things come into place: the view is the UI the controller gathers the inputs of the UI, invokes methods on the model, and sends back a response to the UI the model is our business components - holding the data, but also having business logic. I guess that answers your main questions. Things get complicated when we add some more layers, like the repository layer. It is often suggested that it should be invoked by the business logic placed in the model (and hence each domain object has a reference to a repository). In the article of mine that I linked I argue that this is not quite a best practice. And that in fact it is not a bad thing to have a service layer. By the way, domain-driven design does not exclude the service layer, but it is supposed to be 'thin', and only coordinating domain objects (so no business logic there). For the anemic data model paradigm, which is widely adopted (for good or for bad), the model would be both the service layer and your data objects.
