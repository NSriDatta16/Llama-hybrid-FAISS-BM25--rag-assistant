[site]: stackoverflow
[post_id]: 2256489
[parent_id]: 2255841
[tags]: 
What you're doing resembles both the Composite and Visitor patterns. Those two patterns mesh well together, so it seems you are on the right track. To implement the composite pattern, assign the following roles (refer to Composite pattern UML diagram): Leaf -> Field Composite -> Record Component -> Abstract base class of Field and Record (can't think of a good name) Component operations that are called on Composite types, are passed on recursively to all children (Leaves and other nested Composite types). To implement the Visitor pattern, overload operator() in your functor classes for each Component subtype (Field and Record). I recommend that you get a copy of the Design Patterns book by the "Gang of Four", which explains these concepts better and goes into much more detail than I possibly can. Here is some sample code to whet your appetite: #include #include #include "boost/shared_ptr.hpp" #include "boost/foreach.hpp" class Field; class Record; struct Visitor { virtual void operator()(Field& field) = 0; virtual void operator()(Record& field) = 0; }; class Component { public: virtual bool isLeaf() const {return true;} virtual void accept(Visitor& visitor) = 0; }; typedef boost::shared_ptr ComponentPtr; class Field : public Component { public: explicit Field(int value) : value_(value) {} void accept(Visitor& visitor) {visitor(*this);} int value() const {return value_;} private: int value_; }; class Record : public Component { public: typedef std::vector Children; Record(int id) : id_(id) {} int id() const {return id_;} Children& children() {return children_;} const Children& children() const {return children_;} bool isLeaf() const {return false;} void accept(Visitor& visitor) { visitor(*this); BOOST_FOREACH(ComponentPtr& child, children_) { child->accept(visitor); } } private: int id_; Children children_; }; typedef boost::shared_ptr RecordPtr; struct OStreamVisitor : public Visitor { OStreamVisitor(std::ostream& out) : out_(out) {} void operator()(Field& field) {out_ children().push_back(ComponentPtr(new Field(201))); rec->children().push_back(ComponentPtr(new Field(202))); RecordPtr root(new Record(1)); root->children().push_back(ComponentPtr(new Field(101))); root->children().push_back(rec); OStreamVisitor visitor(std::cout); root->accept(visitor); } In Record, you may want to provide methods for manipulating/accessing children, instead of returning a reference to the underlying children vector.
