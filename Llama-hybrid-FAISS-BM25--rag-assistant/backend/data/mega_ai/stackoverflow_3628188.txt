[site]: stackoverflow
[post_id]: 3628188
[parent_id]: 3627625
[tags]: 
Assuming that methodName is a static method of QueryWindow , this should work: private static void RegisterEvent(object targetObject, string eventName, string methodName) { var eventInfo = targetObject.GetType().GetEvent(eventName); var method = eventInfo.EventHandlerType.GetMethod("Invoke"); var types = method.GetParameters().Select(param => param.ParameterType); var methodInfo = typeof(QueryWindow).GetMethod(methodName, new[] { typeof(object) }); // replaced typeof(void) by null var dynamicMethod = new DynamicMethod(eventInfo.EventHandlerType.Name, null, types.ToArray(), typeof(QueryWindow)); ILGenerator ilGenerator = dynamicMethod.GetILGenerator(256); // Using Ldarg_0 to pass the sender to methodName ; Ldarg_1 to pass the event args ilGenerator.Emit(OpCodes.Ldarg_0); ilGenerator.EmitCall(OpCodes.Call, methodInfo, null); // Added return ilGenerator.Emit(OpCodes.Ret); // Removed parameter definition (implicit from DynamicMethod constructor) // Removed the target argument var methodDelegate = dynamicMethod.CreateDelegate(eventInfo.EventHandlerType); eventInfo.AddEventHandler(targetObject, methodDelegate); } Edit : Since you can use .NET 3.5, you should create an expression tree. Here is another solution: public class QueryWindow { public void RegisterEvent(object targetObject, string eventName, string methodName) { var eventInfo = targetObject.GetType().GetEvent(eventName); var sender = Expression.Parameter(typeof (object), "sender"); var e = Expression.Parameter(typeof (EventArgs), "e"); var body = Expression.Call(Expression.Constant(this), methodName, null, e); var lambda = Expression.Lambda(eventInfo.EventHandlerType, body, sender, e); eventInfo.AddEventHandler(targetObject, lambda.Compile() ); } public void OnEvent(object o) { Console.WriteLine(o); } } Notice that the OnEvent method is no longer static. I also assume that events you are trying to subscribe to are events that follow .NET conventions (sender + event args). This way, we can leverage contravariance and always pass a lambda of type : (object sender, EventArgs e) => { /* */ }
