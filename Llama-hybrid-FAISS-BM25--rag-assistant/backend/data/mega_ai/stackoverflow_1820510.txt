[site]: stackoverflow
[post_id]: 1820510
[parent_id]: 1820452
[tags]: 
Assuming that you can use bitwise operators you can check what the numbers with same output have in common, in this case I preferred using input 0-31 because it's simpler (you can just subtract 1 to actual values) What you have? 0x0000 -> 1 0x0001 -> 1 0x0010 -> 1 0x0011 -> 1 0x0100 -> 2 0x0101 -> 2 0x0110 -> 2 0x0111 -> 2 0x1000 -> 1 0x1001 -> 1 0x1010 -> 1 0x1011 -> 1 0x1100 -> 2 ... It's quite easy if you notice that third bit is always 0 when output should be 1 and viceversa it's always 1 when output should be 2 so: char codify(char input) { return ((((input-1)&0x04)>>2 == 1)?(2):(1)); } EDIT As suggested by comment it should work also with char codify(char input) { return ((input-1 & 0x04)?(2):(1)); } because in some languages (like C) 0 will evaluate to false and any other value to true . I'm not sure if it works in C# too because I've never programmed in that language. Of course this is not a language-agnostic answer but it's more C-elegant!
