[site]: stackoverflow
[post_id]: 2637454
[parent_id]: 
[tags]: 
controlling threads flow

I had a task to write simple game simulating two players picking up 1-3 matches one after another until the pile is gone. I managed to do it for computer choosing random value of matches but now I'd like to go further and allow humans to play the game. Here's what I already have : http://paste.pocoo.org/show/201761/ Class Player is a computer player, and PlayerMan should be human being. Problem is, that thread of PlayerMan should wait until proper value of matches is given but I cannot make it work this way. Logic is as follows: thread runs until matches equals to zero. If player number is correct at the moment function pickMatches() is called. After decreasing number of matches on table, thread should wait and another thread should be notified. I know I must use wait() and notify() but I can't place them right. Class Shared keeps the value of current player, and also amount of matches. public void suspendThread() { suspended = true; } public void resumeThread() { suspended = false; } @Override public void run(){ int matches=1; int which = 0; int tmp=0; Shared data = this.selectData(); String name = this.returnName(); int number = this.getNumber(); while(data.getMatches() != 0){ while(!suspended){ try{ which = data.getCurrent(); if(number == which){ matches = pickMatches(); tmp = data.getMatches() - matches; data.setMatches(tmp, number); if(data.getMatches() == 0){ System.out.println(" "+ name+" takes "+matches+" matches."); System.out.println("Winner is player: "+name); stop(); } System.out.println(" "+ name+" takes "+matches+" matches."); if(number != 0){ data.setCurrent(0); } else{ data.setCurrent(1); } } this.suspendThread(); notifyAll(); wait(); }catch(InterruptedException exc) {} } } } @Override synchronized public int pickMatches(){ Scanner scanner = new Scanner(System.in); int n = 0; Shared data = this.selectData(); System.out.println("Choose amount of matches (from 1 to 3): "); if(data.getMatches() == 1){ System.out.println("There's only 1 match left !"); while(n != 1){ n = scanner.nextInt(); } } else{ do{ n = scanner.nextInt(); } while(n = 3); } return n; } }
