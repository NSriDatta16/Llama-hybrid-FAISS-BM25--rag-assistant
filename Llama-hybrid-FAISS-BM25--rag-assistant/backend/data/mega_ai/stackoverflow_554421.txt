[site]: stackoverflow
[post_id]: 554421
[parent_id]: 548311
[tags]: 
Lastly, on the topic of thread safety, what should I look for in my code to get an idea of thread safety? Writing thread-safe code is a hefty topic that I won't go into here, but I will say one thing on the topic of static & thread safety. Most methods of ensuring code runs as intended for multiple calling threads involve some kind of locking on an object instance. You will notice that in the .NET framework (BCL), all static members are threadsafe. This is because there is no clear way of knowing what instance of an object ought to be locked on in order to share this resource between all conceivable callers. Old guidelines used to suggest locking on the type itself, ie: lock (typeof(SomeType)) { SomeType.SomeStaticMethod(...); } This approach is now discouraged and is inadvisable because there is no way of controlling the order of accesses to these lock objects across all conceivable calling threads. Locking on public objects (including ICollection.SyncRoot , which is now deprecated for the same reason) is opening the door to deadlocks. In the case above, the type instance is publically available, and should not be locked upon. Given that there is no single instance that all clients of static methods can reasonably agree upon using for their access of static members, Microsoft's BCL team has had to make all static members typesafe. Thankfully for them, static members are few and far between.
