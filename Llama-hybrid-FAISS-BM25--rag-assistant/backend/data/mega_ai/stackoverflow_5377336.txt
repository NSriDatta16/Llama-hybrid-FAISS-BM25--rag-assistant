[site]: stackoverflow
[post_id]: 5377336
[parent_id]: 5377237
[tags]: 
Well, in my experience, operator overloading in such scenarios usually doesn't work too well and can lead to all kinds of problems. Also, if you provide implicit cast operators to/from type int , are you sure that a statement such as: SomeCompany.ID = SomePerson.ID will still get caught as invalid by the compiler? Or might the compiler just use your cast operators and thus let the invalid assignment through...? A less elegant solution involves defining your own value object type (as a class ) and accessing the actual ID via a Value property: sealed class PersonId { readonly int value; public int Value { get { return value; } } public PersonId(int value) { // (you might want to validate 'value' here.) this.value = value; } // override these in order to get value type semantics: public override bool Equals(object other) { … } public override int GetHashCode() { … } } Now, whenever you would write person.Id , you'll need to write person.Id.Value if you actually need the raw integer. It would be even better if you actually tried to reduce access to the raw integer value to as few places as possible, e.g. where you persist an entity to (or load it from) a DB. P.S.: In the above code, I would really like to make PersonId a struct , since it's a value object. However, struct s have one problem, which is a parameter-less constructor that's automatically provided by the compiler. This means that a user of your type can bypass all your constructors (where validation might happen), and you might end up with an invalid object right after construction. Thus, try to make PersonId as similar to a struct as possible: by declaring it sealed , by overriding Equals and GetHashCode , and by not providing a parameterless constructor.
