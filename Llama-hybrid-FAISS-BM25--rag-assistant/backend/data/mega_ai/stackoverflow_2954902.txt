[site]: stackoverflow
[post_id]: 2954902
[parent_id]: 2954783
[tags]: 
You are using the wrong HTTP verb for your create operation. RFC 2616 specifies the semantic of the operations for POST and PUT . Paragraph 9.5: POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line Paragraph 9.6 PUT method requests that the enclosed entity be stored under the supplied Request-URI. There are subtle details of that behavior, for example PUT can be used to create new resource at the specified URL, if one does not already exist. However, POST should never put the new entity at the request URL and PUT should always put any new entity at the request URL. This relationship to the request URL defines POST as CREATE and PUT as UPDATE . As per that semantic, if you want to use PUT to create a new person, it should be created in /CREATE_PERSON/{transaction_id} . In other words, the transaction ID returned by your first request should be the person key used to fetch that record later. You shouldn't make PUT request to a URL that is not going to be the final location of that record. Better yet, though, you can do this as an atomic operation by using a POST to /CREATE_PERSON . This allows you with a single request to create the new person record and in the response to get the new ID (which should also be referred in the HTTP Location header as well). Meanwhile, the REST guidelines specify that verbs should not be part of the resource URL. Thus, the URL to create new person should be the same as the location to get the list of all persons - /PERSONS (I prefer the plural form :-)). Thus, your REST API becomes: to get all persons - GET /PERSONS to get single person - GET /PERSONS/{id} to create new person - POST /PERSONS with the body containing the data for the new record to update existing person or create new person with well-known id - PUT /PERSONS/{id} with the body containing the data for the updated record. to delete existing person - DELETE /PERSONS/{id} Note: I personally prefer not using PUT for creating records for two reasons, unless I need to create a sub record that has the same id as an already existing record from a different data set (also known as 'the poor man's foreign key' :-)). Update: You are right that POST is not idempotent and that is as per HTTP spec. POST will always return a new resource. In your example above that new resource will be the transaction context. However, my point is that you want the PUT to be used to create a new resource (a person record) and according to the HTTP spec, that new resource itself should be located at the URL. In particular, where your approach breaks is that the URL you use with the PUT is a representation of the transactional context that was created by the POST, not a representation of the new resource itself. In other words, the person record is a side effect of updating the transaction record, not the immediate result of it (the updated transaction record). Of course, with this approach the PUT request will be idempotent, since once the person record is created and the transaction is 'finalized', subsequent PUT requests will do nothing. But now you have a different problem - to actually update that person record, you will need to make a PUT request to a different URL - one that represents the person record, not the transaction in which it was created. So now you have two separate URLs your API clients have to know and make requests against to manipulate the same resource. Or you could have a complete representation of the last resource state copied in the transaction record as well and have person record updates go through the transaction URL for updates as well. But at this point, the transaction URL is for intends and purposes the person record, which means it was created by the POST request in first place.
