[site]: stackoverflow
[post_id]: 3065203
[parent_id]: 1899436
[tags]: 
Try if __name__ == '__main__': from [whatever the name of your package is] import one else: import one Note that in Python 3, the syntax for the part in the else clause would be from .. import one On second thought, this probably won't fix your specific problem. I misunderstood the question and thought that two.py was being run as the main module, but that is not the case. And considering the differences in the way Python 2.6 (without importing absolute_import from __future__ ) and Python 3.x handle imports, you wouldn't need to do this for Python 2.6 anyway, I don't think. Still, if you do eventually switch to Python 3 and plan on using a module as both a package module and as a standalone script inside the package, it may be a good idea to keep something like if __name__ == '__main__': from [whatever the name of your package is] import one # assuming the package is in the current working directory or a subdirectory of PYTHONPATH else: from .. import one in mind. EDIT: And now for a possible solution to your actual problem. Either run PyLint from the directory containing your one module (via the command line, perhaps), or put the following code somewhere when running PyLint: import os olddir = os.getcwd() os.chdir([path_of_directory_containing_module_one]) import one os.chdir(olddir) Basically, as an alternative to fiddling with PYTHONPATH, just make sure the current working directory is the directory containing one.py when you do the import. (Looking at Brian's answer, you could probably assign the previous code to init_hook , but if you're going to do that then you could simply do the appending to sys.path that he does, which is slightly more elegant than my solution.)
