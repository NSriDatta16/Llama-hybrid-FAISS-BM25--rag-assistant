[site]: stackoverflow
[post_id]: 4247033
[parent_id]: 4239763
[tags]: 
I think it might be hard to solve with one single nice looking linq expression so I wrote a recursive function using linq that solves the problem: class Program { static void Main(string[] args) { var input = new string[] { "A", "A.B.D", "A", "A.B", "E", "F.E", "F", "B.C", "B.C.D", "B.E" }; var output = FilterFunc(input); foreach (var str in output) Console.WriteLine(str); Console.ReadLine(); } static string[] FilterFunc(string[] input) { if (input.Length 0; i--) { var numberOfFilteredElems = input.Where(x => x.StartsWith(firstElem.Substring(0, i))).Count(); if (numberOfFilteredElems > maxFilteredElems) { maxFilteredElems = numberOfFilteredElems; indexNr = i; } } var prefix = firstElem.Substring(0, indexNr); var recursiveResult = FilterFunc(input.Where(x => !x.StartsWith(prefix)).ToArray()); var result = recursiveResult.ToList(); prefix = prefix.EndsWith(".") ? prefix.Substring(0, prefix.Length - 1) : prefix; result.Insert(0, prefix); return result.ToArray(); } } } The code could probably be more effective and more organized but don't have time for that now. I think the other solutions are wrong so far, so that's why you get my longer one. I think you need to solve it recursively to be sure to get the shortest list.
