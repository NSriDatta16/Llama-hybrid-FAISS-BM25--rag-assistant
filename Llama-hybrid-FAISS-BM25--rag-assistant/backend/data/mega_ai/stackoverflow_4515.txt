[site]: stackoverflow
[post_id]: 4515
[parent_id]: 3255
[tags]: 
Seeing the answers here I think we can conclude that most of us do indeed approximate the order of the algorithm by looking at it and use common sense instead of calculating it with, for example, the master method as we were thought at university. With that said I must add that even the professor encouraged us (later on) to actually think about it instead of just calculating it. Also I would like to add how it is done for recursive functions : suppose we have a function like ( scheme code ): (define (fac n) (if (= n 0) 1 (* n (fac (- n 1))))) which recursively calculates the factorial of the given number. The first step is to try and determine the performance characteristic for the body of the function only in this case, nothing special is done in the body, just a multiplication (or the return of the value 1). So the performance for the body is: O(1) (constant). Next try and determine this for the number of recursive calls . In this case we have n-1 recursive calls. So the performance for the recursive calls is: O(n-1) (order is n, as we throw away the insignificant parts). Then put those two together and you then have the performance for the whole recursive function: 1 * (n-1) = O(n) Peter , to answer your raised issues; the method I describe here actually handles this quite well. But keep in mind that this is still an approximation and not a full mathematically correct answer. The method described here is also one of the methods we were taught at university, and if I remember correctly was used for far more advanced algorithms than the factorial I used in this example. Of course it all depends on how well you can estimate the running time of the body of the function and the number of recursive calls, but that is just as true for the other methods.
