[site]: stackoverflow
[post_id]: 1171541
[parent_id]: 1171474
[tags]: 
Considering the title of this blog entry: " Why you shouldn’t touch Change­Window­Message­Filter with a 10-ft pole… ", I guess it is not the best approach ;) Now, this might seem like a great approach at first - after all, you’ll only use Change­Window­Message­Filter when you’re sure you can completely validate a received message even if it is from an untrusted source, such that there’s no way something could go wrong, right? Well, the problem is that even if you do this, you are often opening your program up to attack unintentionally . Consider for a moment how custom window messages are typically used; virtually all the common controls in existence have “dangerous” messages in the custom class message range (e.g. WM_USER and friends). Additionally, many programs and third party libraries confuse WM_USER and WM_APP , such that you may have programs communicating cross process via both WM_USER and WM_APP , via “dangerous” messages that are used to make sensitive decisions or include pointer parameters. In the comments of this blog entry, an alternative approach was discussed, but with pretty much the same conclusion: I would use RegisterWindowMessage and then allow that via ChangeWindowMessageFilter . However, be aware that you cannot design a cross-process window message interface that passes pointers or other untrusted values or you are creating a security hole. For this reason, I would tend to avoid using window at all messages for most cross-process IPC (if possible), as it is typically very difficult to do non-trivial things in a secure fashion using them. Note: this entry " So, who wants to design a feature today? " illustrates the same problem, and points to the insightful articles of Raymond Chen: Why aren't console windows themed on Windows XP? Windows Vista has more extended options on the context menu which both detail the issue. This ServerFault question " Why can’t I drag/drop a file for editing in notepad in Windows Server 2008? " also includes some answers, but no quick-win. See also this article on IE
