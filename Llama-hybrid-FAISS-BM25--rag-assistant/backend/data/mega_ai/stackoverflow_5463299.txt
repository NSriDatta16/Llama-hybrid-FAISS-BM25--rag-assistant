[site]: stackoverflow
[post_id]: 5463299
[parent_id]: 5463009
[tags]: 
The short answer is that you cannot do that. The long answer is that you can simulate it, but be aware that you'll have to create a lot of code as workaround (actually, I don't think there is an elegant solution). In the discussion, a very complex workaround is provided using operator- (which is a bad idea, in my opinion). I guess that the solution provided in the dead link was more o less similar (since it was based on operator|). This is based in the capability of being able to do more or less the same thing as an extension method with operators. For example, if you want to overload the ostream's operator class Foo { friend ostream &operator As I said, this is the only similar mechanism availabe in C++ for extension methods. If you can naturally translate your function to an overloaded operator, then it is fine. The only other possibility is to artificially overload an operator that has nothing to do with your objective, but this is going to make you write very confusing code. The most similar approach I can think of would mean to create an extension class and create your new methods there. Unfortunately, this means that you'll need to "adapt" your objects: class stringext { public: stringext(std::string &s) : str( &s ) {} string trim() { ...; return *str; } private: string * str; }; And then, when you want to do that things: void fie(string &str) { // ... cout As said, this is not perfect, and I don't think that kind of perfect solution exists. Sorry.
