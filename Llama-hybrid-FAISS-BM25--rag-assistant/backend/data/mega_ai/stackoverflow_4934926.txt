[site]: stackoverflow
[post_id]: 4934926
[parent_id]: 
[tags]: 
What does the compiler optimization "constant propagation" mean?

From Effective C++ by Scott Meyers: template class SquareMatrix: private SquareMatrixBase { public: SquareMatrix( ) : SquareMatrixBase (n, 0), pData(new T[n*n]) { this->setDataPtr(pData.get()); } ... private: boost::scoped_array pData; }; Regardless of where the data is stored, the key result from a bloat point of view is that now many — maybe all — of SquareMatrix’s member functions can be simple inline calls to base class versions that are shared with all other matrices holding the same type of data, regardless of their size. At the same time, SquareMatrix objects of different sizes are distinct types, so even though, e.g., SquareMatrix and SquareMatrix objects use the same member functions in SquareMatrixBase , there’s no chance of passing a SquareMatrix object to a function expecting a SquareMatrix . Nice, no? Nice, yes, but not free. The versions of invert with the matrix sizes hardwired into them are likely to generate better code than the shared version where the size is passed as a function parameter or is stored in the object. For example, in the size-specific versions, the sizes would be compile-time constants, hence eligible for such optimizations as constant propagation, including their being folded into the generated instructions as immediate operands. That can’t be done in the size-independent version. In above description in last paragraph it was mentioned as "hence eligible for such optimizations as constant propagation, including their being folded into the generated instructions as immediate operands". What does this statment mean? Kindly request to explain this. Thanks!
