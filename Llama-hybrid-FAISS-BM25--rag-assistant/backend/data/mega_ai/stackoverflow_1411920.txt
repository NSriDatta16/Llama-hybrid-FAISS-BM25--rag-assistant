[site]: stackoverflow
[post_id]: 1411920
[parent_id]: 1411071
[tags]: 
I ended up going with the solution from here: Partially Populate Child Collection with NHibernate My page now has these properties: public virtual Revision CurrentRevision { get { return _revision ?? Revisions.OrderByDescending(x => x.Revised).FirstOrDefault(); } set { _revision = value; } } public virtual ISet Revisions { get; private set; } The loading code is: public Page GetPage(string name) { var entryHash = (Hashtable)_session.CreateCriteria ("page") .Add(Restrictions.Eq("page.Name", name)) .CreateCriteria("Revisions", "rev") .AddOrder(Order.Desc("rev.Revised")) .SetMaxResults(1) .SetResultTransformer(Transformers.AliasToEntityMap) .UniqueResult(); var page = (Page)entryHash["page"]; page.LatestRevision = (Revision)entryHash["rev"]; return page; } NHProf shows this as the only query being executed now, which is perfect: SELECT top 1 this_.Id as Id3_1_, this_.Name as Name3_1_, this_.Title as Title3_1_, rev1_.Id as Id0_0_, rev1_.Body as Body0_0_, rev1_.Revised as Revised0_0_, .... FROM [Page] this_ inner join [Revision] rev1_ on this_.Id = rev1_.PageId WHERE this_.Name = 'foo' /* @p0 */ ORDER BY rev1_.Revised desc
