[site]: stackoverflow
[post_id]: 3672380
[parent_id]: 
[tags]: 
Weird situation with TextBox.Text property in WPF

This one has me stumped. I found some code posted by Ray Burns to create a DependencyProperty for a TextBox that allows you to restrict which characters can be deleted by the user. I modified it a little to instead restrict which characters can be inserted , and used that to create TextBoxes that only accept numeric input (plus the decimal point). This works great for entering text via the keyboard, pasting, dragging and dropping, etc. The only problem comes when setting the Text through code. There it allows non-numeric text to be entered, which in and of itself isn't really the issue. The issue is that if you check the value of the TextBox's Text property after doing that, it says it is an empty string. Here's some code to demonstrate what I mean. A simple WPF Window: Enter Text Check Value Its code-behind: using System; using System.Windows; namespace TestApp { public partial class Test : Window { public Test() { InitializeComponent(); } private void Button_Click(object sender, RoutedEventArgs e) { txtTest.Text = "Test"; } private void Button_Click_1(object sender, RoutedEventArgs e) { MessageBox.Show(txtTest.Text, "Length = " + txtTest.Text.Length.ToString()); } } } And my modification of Ray's class: using System; using System.Linq; using System.Windows; using System.Windows.Controls; namespace TestApp { //Based on code by Ray Burns at https://stackoverflow.com/questions/3051590/how-to-track-which-character-is-deleted-in-textbox-in-wpf/3056168#3056168. public class TextBoxRestriction : DependencyObject { //RestrictInsertTo: Set this to the characters that may be inserted. public static string GetRestrictInsertTo(DependencyObject obj) { return (string)obj.GetValue(RestrictInsertToProperty); } public static void SetRestrictInsertTo(DependencyObject obj, string value) { obj.SetValue(RestrictInsertToProperty, value); } public static readonly DependencyProperty RestrictInsertToProperty = DependencyProperty.RegisterAttached("RestrictInsertTo", typeof(string), typeof(TextBoxRestriction), new PropertyMetadata { PropertyChangedCallback = (obj, e) => { var box = (TextBox)obj; box.TextChanged += (obj2, changeEvent) => { var oldText = GetUnrestrictedText(box); var allowedChars = GetRestrictInsertTo(box); if (box.Text == oldText || allowedChars == null) return; foreach (var change in changeEvent.Changes) { if (change.AddedLength > 0) { string added = box.Text.Substring(change.Offset, change.AddedLength); if (added.Any(ch => !allowedChars.Contains(ch))) { var ss = box.SelectionStart; var sl = box.SelectionLength; box.Text = oldText; box.SelectionStart = ss; box.SelectionLength = sl; } } } SetUnrestrictedText(box, box.Text); }; } }); //UnrestrictedText: Bind or access this property to update the Text property bypassing all restrictions. public static string GetUnrestrictedText(DependencyObject obj) { return (string)obj.GetValue(UnrestrictedTextProperty); } public static void SetUnrestrictedText(DependencyObject obj, string value) { obj.SetValue(UnrestrictedTextProperty, value); } public static readonly DependencyProperty UnrestrictedTextProperty = DependencyProperty.RegisterAttached("UnrestrictedText", typeof(string), typeof(TextBoxRestriction), new PropertyMetadata { DefaultValue = "", PropertyChangedCallback = (obj, e) => { var box = (TextBox)obj; box.Text = (string)e.NewValue; } }); } } If you try typing in the TextBox, you'll see it works pretty much as expected, and that clicking the Check Value button accurately reflects the text; however, if you click the Enter Text button, then click the Check Value button, you'll see that the app thinks the TextBox's Text property is an empty string (even though it has text clearly visible in the UI). If you modify the text in the UI in any way (delete a character, say), then click Check Value, it now recognizes the correct text. Can anyone shed any light on why this is happening? I may be missing something patently obvious, but I just can't seem to figure it out. Thanks in advance! Jeff
