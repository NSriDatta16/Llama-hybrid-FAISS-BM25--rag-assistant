[site]: stackoverflow
[post_id]: 5451052
[parent_id]: 5399314
[tags]: 
I am not a UI programmer by any means. This was a test I wrote to see how to write custom controls. This code may or may not work. I have not touched it in some time. header @interface SUIMaxSlider : UIControl { @private float_t minimumValue; float_t maximumValue; float_t value; CGPoint trackPoint; } @property (nonatomic, assign) float_t minimumValue, maximumValue; @property (nonatomic, assign) float_t value; @end implementation #import "SUIMaxSlider.h" #import #import //#import "Common.h" #define kSliderPadding 5 @implementation SUIMaxSlider @synthesize minimumValue, maximumValue; #pragma mark - #pragma mark Interface Initialization - (id) initWithCoder:(NSCoder *)aDecoder { if (self = [super initWithCoder:aDecoder]) { trackPoint.x = self.bounds.size.width; self.backgroundColor = [UIColor colorWithRed:135.0/255.0 green:173.0/255.0 blue:255.0/255.0 alpha:0.0]; } return self; } - (id) initWithFrame: (CGRect) aFrame { if (self = [super initWithFrame:aFrame]) { self.frame = aFrame; self.bounds = aFrame; self.center = CGPointMake(CGRectGetMidX(aFrame), CGRectGetMidY(aFrame)); trackPoint.x = aFrame.size.width; } return self; } - (id) init { return [self initWithFrame:CGRectZero]; } #pragma mark - #pragma mark Properties. #pragma mark - - (float_t) value { return value; } - (void) setValue:(float_t) v { value = fmin(v, maximumValue); value = fmax(value, minimumValue); float_t delta = maximumValue - minimumValue; float_t scalar = ((self.bounds.size.width - 2 * kSliderPadding) / delta) ; float_t x = (value - minimumValue) * scalar; x += 5.0; trackPoint.x = x; [self setNeedsDisplay]; } #pragma mark - #pragma mark Interface Drawing #pragma mark - - (void) drawRect:(CGRect) rect { CGContextRef context = UIGraphicsGetCurrentContext(); CGColorRef lightBlue = [UIColor colorWithRed:135.0/255.0 green:173.0/255.0 blue:255.0/255.0 alpha:1.0].CGColor; CGColorRef lightBlueAlpha = [UIColor colorWithRed:135.0/255.0 green:173.0/255.0 blue:255.0/255.0 alpha:0.7].CGColor; CGColorRef lightGrayColor = [UIColor colorWithRed:130.0/255.0 green:130.0/255.0 blue:130.0/255.0 alpha:1.0].CGColor; CGColorRef darkGrayColor = [UIColor colorWithRed:70.0/255.0 green:70.0/255.0 blue:70.0/255.0 alpha:1.0].CGColor; CGColorRef redColor = [UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.6].CGColor; CGRect boundsRect = self.bounds; CGRect sliderRect = CGRectMake(0, 0, boundsRect.size.width, boundsRect.size.height / 2); /* CGContextSetFillColorWithColor(context, lightGrayColor); CGContextFillRect(context, sliderRect); halfHeight.origin.y = sliderRect.size.height; CGContextSetFillColorWithColor(context, darkGrayColor); CGContextFillRect(context, sliderRect); */ CGFloat tx = fmin(sliderRect.size.width - kSliderPadding, trackPoint.x); tx = fmax(kSliderPadding, tx); sliderRect.origin.y = boundsRect.origin.y; sliderRect.size.width = tx ; CGContextSetFillColorWithColor(context, lightBlueAlpha); CGContextFillRect(context, sliderRect); sliderRect.origin.y = sliderRect.size.height; CGContextSetFillColorWithColor(context, lightBlue); CGContextFillRect(context, sliderRect); CGFloat mid = boundsRect.size.height / 2 ; CGPoint a = CGPointMake(tx - kSliderPadding, mid); CGPoint b = CGPointMake(tx, mid - kSliderPadding); CGPoint c = CGPointMake(tx + kSliderPadding, mid); CGPoint d = CGPointMake(tx, mid + kSliderPadding); CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0); CGContextSetLineWidth(context, 2.0); CGContextBeginPath(context); CGContextMoveToPoint(context, a.x, a.y); CGContextAddLineToPoint(context, b.x, b.y); CGContextAddLineToPoint(context, c.x, c.y); CGContextAddLineToPoint(context, d.x, d.y); CGContextAddLineToPoint(context, a.x, a.y); CGContextFillPath(context); } #pragma mark - #pragma mark Touch Tracking #pragma mark - - (void) trackTouch:(UITouch *) touch { CGPoint p = [touch locationInView:self]; //bound track point trackPoint.x = fmax(p.x, kSliderPadding) ; trackPoint.x = fmin(trackPoint.x, self.bounds.size.width - kSliderPadding); [self setNeedsDisplay]; float_t x = trackPoint.x - kSliderPadding; float_t delta = maximumValue - minimumValue; float_t scalar = (x / (self.bounds.size.width - 2 * kSliderPadding)) ; value = minimumValue + (delta * scalar); [self sendActionsForControlEvents:UIControlEventValueChanged]; } - (void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event { [self trackTouch:touch]; } - (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event { CGPoint p = [touch locationInView:self]; trackPoint.x = fmax(p.x, kSliderPadding) ; trackPoint.x = fmin(trackPoint.x, self.bounds.size.width - kSliderPadding); [self setNeedsDisplay]; return YES; } - (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event { [self trackTouch:touch]; return YES; } @end
