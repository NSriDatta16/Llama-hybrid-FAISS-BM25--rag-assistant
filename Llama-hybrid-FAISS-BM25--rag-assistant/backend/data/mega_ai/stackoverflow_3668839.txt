[site]: stackoverflow
[post_id]: 3668839
[parent_id]: 3668454
[tags]: 
Some of the examples say to initialize A , B , C and D directly and skip the initialization with 0 , but this is functionally different than your original code in some ways. I would do this however: inline float BoxIntegral(IplImage *img, int row, int col, int rows, int cols) { const float *data = (float *) img->imageData; const int step = img->widthStep/sizeof(float); // The subtraction by one for row/col is because row/col is inclusive. const int r1 = std::min(row, img->height) - 1; const int r2 = std::min(row + rows, img->height) - 1; const int c1 = std::min(col, img->width) - 1; const int c2 = std::min(col + cols, img->width) - 1; const float A = (r1 >= 0 && c1 >= 0) ? data[r1 * step + c1] : 0.0f; const float B = (r1 >= 0 && c2 >= 0) ? data[r1 * step + c2] : 0.0f; const float C = (r2 >= 0 && c1 >= 0) ? data[r2 * step + c1] : 0.0f; const float D = (r2 >= 0 && c2 >= 0) ? data[r2 * step + c2] : 0.0f; return std::max(0.f, A - B - C + D); } like your original code, this will make A , B , C and D have a value either from data[] if the condition is true or 0.0f if the condition is false. Also, I would (as I have shown) use const wherever it is appropriate. Many compilers aren't able to improve code much based on const -ness, but it certainly can't hurt to give the compiler more information about the data it is operating on. Finally I have reordered the r1 / r2 / c1 / c2 variables to encourage reuse of the fetched width and height. Obviously you would need to profile to determine if any of this is actually an improvement.
