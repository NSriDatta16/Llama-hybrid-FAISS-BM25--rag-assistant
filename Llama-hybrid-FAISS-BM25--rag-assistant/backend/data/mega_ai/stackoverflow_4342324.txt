[site]: stackoverflow
[post_id]: 4342324
[parent_id]: 
[tags]: 
Problem with invalidation of STL iterators when calling erase

The STL standard defines that when an erase occurs on containers such as std::deque, std::list etc iterators are invalidated. My question is as follows, assuming the list of integers contained in a std::deque, and a pair of indicies indicating a range of elements in the std::deque, what is the correct way to delete all even elements? So far I have the following, however the problem here is that the assumed end is invalidated after an erase: #include #include int main() { std::deque deq; for (int i = 0; i r(10,50); std::deque ::iterator it = deq.begin() + r.first; std::deque ::iterator end = deq.begin() + r.second; while (it != end) { if (*it % 2 == 0) { it = deq.erase(it); } else ++it; } return 0; } Examining how std::remove_if is implemented, it seems there is a very costly copy/shift down process going on. Is there a more efficient way of achieving the above without all the copy/shifts In general is deleting/erasing an element more expensive than swapping it with the next nth value in the sequence (where n is the number of elements deleted/removed so far) Note: Answers should assume the sequence size is quite large, +1mil elements and that on average 1/3 of elements would be up for erasure.
