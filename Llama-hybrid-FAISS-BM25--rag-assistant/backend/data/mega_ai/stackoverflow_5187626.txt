[site]: stackoverflow
[post_id]: 5187626
[parent_id]: 
[tags]: 
Rewriting a sequence by partitioning and collapsing

what is the most elegant and simple algorithm to map a sequential collection such that contiguous elements that satisfy some predicate are collapsed into another element, and those that do not satisfy the predicate are mapped 1:1 into another element? here is an example: sealed trait A // say the input elements are of this type sealed trait B // say the output elements are of this type case class C(i: Int) extends A // these are the input elements satisfying the predicate case class D(s: C*) extends B // they should be collapsed into this case class E(i: Int) extends A with B // these are input elems that are left as such given this input sequence: val input = Seq(C(1), C(2), C(3), E(4), E(5), C(6), E(7), C(8), C(9)) the expected output is: val output = Seq(D(C(1), C(2), C(3)), E(4), E(5), D(C(6)), E(7), D(C(8), C(9))) // --------------- - - - - -------- // the dashes indicate how the sequence is regrouped (collapsed) here is one way of doing it, but i'm not sure this is particularly elegant: def split(xs: Seq[A]): Seq[B] = split1(Seq.empty[B], true, xs) @annotation.tailrec def split1(done: Seq[B], test: Boolean, rem: Seq[A]) : Seq[B] = { val (pre, post) = rem.span { case _: C => test; case _ => !test } val add = if(test) { D(pre.collect({ case x: C => x }): _*) :: Nil } else { pre.collect({ case x: E => x }) } val done2 = done ++ add if(post.isEmpty) done2 else split1(done2, !test, post) } verify: val output2 = split(input) output2 == output // ok
