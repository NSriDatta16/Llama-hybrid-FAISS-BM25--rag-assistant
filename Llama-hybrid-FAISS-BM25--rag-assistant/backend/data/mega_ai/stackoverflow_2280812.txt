[site]: stackoverflow
[post_id]: 2280812
[parent_id]: 2280725
[tags]: 
An occasionally useful alternative to the shuffle approach is to use a subscriptable set container. At each step, choose a random number 0 The main problem is that typical containers can't handle this efficiently. I have used it with bit-vectors, but it only works well if the largest possible member is reasonably small, due to the linear scanning of the bitvector needed to find the nth set bit. 99% of the time, the best approach is to shuffle as others have suggested. EDIT I missed the fact that a simple array is a good "set" data structure - don't ask me why, I've used it before. The "trick" is that you don't care whether the items in the array are sorted or not. At each step, you choose one randomly and extract it. To fill the empty slot (without having to shift an average half of your items one step down) you just move the current end item into the empty slot in constant time, then reduce the size of the array by one. For example... class remaining_items_queue { private: std::vector m_Items; public: ... bool Extract (int &p_Item); // return false if items already exhausted }; bool remaining_items_queue::Extract (int &p_Item) { if (m_Items.size () == 0) return false; int l_Random = Random_Num (m_Items.size ()); // Random_Num written to give 0 The trick is to get a random number generator that gives (with a reasonably even distribution) numbers in the range 0 to n-1 where n is potentially different each time. Most standard random generators give a fixed range. Although the following DOESN'T give an even distribution, it is often good enough... int Random_Num (int p) { return (std::rand () % p); } std::rand returns random values in the range 0
