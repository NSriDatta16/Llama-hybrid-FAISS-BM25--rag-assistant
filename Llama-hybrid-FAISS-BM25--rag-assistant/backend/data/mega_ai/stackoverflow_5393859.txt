[site]: stackoverflow
[post_id]: 5393859
[parent_id]: 
[tags]: 
longjmp and RAII

So I have a library (not written by me) which unfortunately uses abort() to deal with certain errors. At the application level, these errors are recoverable so I would like to handle them instead of the user seeing a crash. So I end up writing code like this: static jmp_buf abort_buffer; static void abort_handler(int) { longjmp(abort_buffer, 1); // perhaps siglongjmp if available.. } int function(int x, int y) { struct sigaction new_sa; struct sigaction old_sa; sigemptyset(&new_sa.sa_mask); new_sa.sa_handler = abort_handler; sigaction(SIGABRT, &new_sa, &old_sa); if(setjmp(abort_buffer)) { sigaction(SIGABRT, &old_sa, 0); return -1 } // attempt to do some work here int result = f(x, y); // may call abort! sigaction(SIGABRT, &old_sa, 0); return result; } Not very elegant code. Since this pattern ends up having to be repeated in a few spots of the code, I would like to simplify it a little and possibly wrap it in a reusable object. My first attempt involves using RAII to handle the setup/teardown of the signal handler (needs to be done because each function needs different error handling). So I came up with this: template struct signal_guard { signal_guard(void (*f)(int)) { sigemptyset(&new_sa.sa_mask); new_sa.sa_handler = f; sigaction(N, &new_sa, &old_sa); } ~signal_guard() { sigaction(N, &old_sa, 0); } private: struct sigaction new_sa; struct sigaction old_sa; }; static jmp_buf abort_buffer; static void abort_handler(int) { longjmp(abort_buffer, 1); } int function(int x, int y) { signal_guard sig_guard(abort_handler); if(setjmp(abort_buffer)) { return -1; } return f(x, y); } Certainly the body of function is much simpler and more clear this way, but this morning a thought occurred to me. Is this guaranteed to work? Here's my thoughts: No variables are volatile or change between calls to setjmp / longjmp . I am longjmp ing to a location in the same stack frame as the setjmp and return ing normally, so I am allowing the code to execute the cleanup code that the compiler emitted at the exit points of the function. It appears to work as expected. But I still get the feeling that this is likely undefined behavior. What do you guys think?
