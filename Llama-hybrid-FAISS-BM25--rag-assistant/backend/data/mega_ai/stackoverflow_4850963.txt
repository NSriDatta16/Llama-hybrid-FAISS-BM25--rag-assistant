[site]: stackoverflow
[post_id]: 4850963
[parent_id]: 4850379
[tags]: 
I would suggest something like: (defn timeline ([] (timeline (ffirst *events*) *events*)) ([time evts] (let [[now later] (split-with #(= time (first %)) evts)] (cons (map rest now) (lazy-seq (timeline (inc time) later)))))) Test: user> (take 30 (timeline)) (((:marry "Catherine of Aragon")) () () () () () () () () () () () () () () () () () ((:unmarry "Catherine of Aragon")) () () () () () ((:marry "Anne Boleyn")) () () ((:unmarry "Anne Boleyn") (:marry "Jane Seymour")) ((:unmarry "Jane Seymour")) ()) I'm assuming that the list of events is infinite as well :) Updated with improvements, and borrowing a couple of ideas from cgrand (thanks :)
