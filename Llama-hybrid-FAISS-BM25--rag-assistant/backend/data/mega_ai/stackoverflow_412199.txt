[site]: stackoverflow
[post_id]: 412199
[parent_id]: 412183
[tags]: 
Update : You told us what you want. I found this question here on SO: Best method for storing this pointer for use in WndProc . I'm not a Windows Programmer, but the Adam Rosenfield guy seem to be right in using SetWindowLongPtr and GetWindowLongPtr. So, you use it like this: LRESULT CALLBACK my_callback(HWND hwnd, UINT ui, WPARAM wp, LPARAM lp) { Window * self = reinterpret_cast ( GetWindowLongPtr(hwnd, 0)); return self->update(hwnd, ui, wp, lp); // handle it. } Register that function as the wnd-proc and store the this pointer of your Window object using SetWindowLongPtr. In the WNDCLASSEX structure, there is a cbWndExtra field that you assign sizeof(Window*) to, which is enough storage to just contain the this pointer. Then you can call SetWindowLongPtr(my_hwnd, 0, reinterpret_cast (this)); to put the this pointer into that region. Then receive it like the above and delegate to the real member function. You could in theory also use a static member function. But you have to be careful. Calling a static member function from C code can cause bugs, because the calling convention might be different between C code and C++ code. For Windows, that may not be an issue - I don't know. So better check yourself in addition. The thing you try is invalid. You try to return a pointer to the function call operator, but there is no object provided when the call is made, beside that your conversion operator has the wrong type. The type that the conversion operator returns has function pointer type, but not member function pointer type. The closest you can get to is to use the proper type: struct adder; typedef int (adder::*int_to_int)(int); struct adder { int n_; adder (int n) : n_(n) {} int operator() (int x) { return x + n_; } operator int_to_int () { return &adder::operator(); } }; Now, your conversion operator is not even considered, because it has to be called like this: adder a(10); cout And manually like this: // note, we just get the member function pointer using the conversion operator. // Nothing is related to the actual temporary adder object. int_to_int i = adder(5); cout The usual function call syntax does not cope with that. In short, what you try is not possible. I think another question is, why the heck do you want to do that? I think we can help you better when we know what the original problem is. If you are trying to make it look and work like a function call, you don't need any conversion operators at all: struct adder { int n_; adder (int n) : n_(n) {} int operator() (int x) { return x + n_; } }; adder a(10); cout
