[site]: stackoverflow
[post_id]: 5140646
[parent_id]: 5140198
[tags]: 
Here is an explanation in terms of the Java Language Specification. The section on integer literals ( JLS 3.10.1 ) says this: The largest decimal literal of type int is 2147483648 (2 31 ). All decimal literals from 0 to 2147483647 may appear anywhere an int literal may appear, but the literal 2147483648 may appear only as the operand of the unary negation operator - . So ... The first statement is an assignment of a legal integer literal value. No compilation error. The second statement is a compilation error because 2147483648 is not preceded by the unary negation operator. The third statement does not contain an integer literal that is out-of-range, so it is not a compilation error from that perspective. Instead, the third statement is a binary addition expression as described in JLS 15.18.2 . This states the following about the integer case: If an integer addition overflows, then the result is the low-order bits of the mathematical sum as represented in some sufficiently large two's-complement format. If overflow occurs, then the sign of the result is not the same as the sign of the mathematical sum of the two operand values. Thus, 2147483647 + 1 overflows and wraps around to -2147483648 . @Peter Lawrey's suggests (flippantly?) that the third statement could be "rewritten by the compiler" as +2147483648 , resulting in a compilation error. This is not correct. There is nothing in the JLS that says that a constant expression can have a different meaning to a non-constant expression. On the contrary, in cases like 1 / 0 the JLS flips things around and says that the expression is NOT a constant expression BECAUSE it terminates abnormally. (It is in JLS 15.28 ) The JLS tries very hard to avoid cases where some Java construct means different things, depending on the compiler. For instance, it is very particular about the "definite assignment" rules, to avoid the case where only a smart compiler can deduce that variable is always initialized before it is used. This is a GOOD THING from the perspective of code portability. The only significant area where there is "wiggle room" for compiler implementers to do platform specific things is in the areas of concurrency and the Java memory model. And there is a sound pragmatic reason for that - to allow multi-threaded Java applications to run fast on multi-core / multi-processor hardware.
