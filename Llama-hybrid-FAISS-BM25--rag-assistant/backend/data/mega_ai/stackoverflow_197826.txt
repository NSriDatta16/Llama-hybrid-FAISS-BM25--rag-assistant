[site]: stackoverflow
[post_id]: 197826
[parent_id]: 197753
[tags]: 
Check out the designer.cs file. This is the key's property [Column(Storage="_ParentKey", DbType="Int")] public System.Nullable ParentKey { get { return this._ParentKey; } set { if ((this._ParentKey != value)) { //This code is added by the association if (this._Parent.HasLoadedOrAssignedValue) { throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException(); } //This code is present regardless of association this.OnParentKeyChanging(value); this.SendPropertyChanging(); this._ParentKey = value; this.SendPropertyChanged("ParentKey"); this.OnServiceAddrIDChanged(); } } } And this is the associations property. [Association(Name="Parent_Child", Storage="_Parent", ThisKey="ParentKey", IsForeignKey=true, DeleteRule="CASCADE")] public Parent Parent { get { return this._Parent.Entity; } set { Parent previousValue = this._Parent.Entity; if (((previousValue != value) || (this._Parent.HasLoadedOrAssignedValue == false))) { this.SendPropertyChanging(); if ((previousValue != null)) { this._Parent.Entity = null; previousValue.Exemptions.Remove(this); } this._Parent.Entity = value; if ((value != null)) { value.Exemptions.Add(this); this._ParentKey = value.ParentKey; } else { this._ParentKey = default(Nullable ); } this.SendPropertyChanged("Parent"); } } } It's best to assign changes through the association instead of the key. That way, you don't have to worry about whether the parent is loaded.
