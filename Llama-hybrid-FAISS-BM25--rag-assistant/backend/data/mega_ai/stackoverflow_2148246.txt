[site]: stackoverflow
[post_id]: 2148246
[parent_id]: 2147572
[tags]: 
There are a lot of differences, but the biggest one I can think of that programmers coming from Java/C# always get wrong, and which they never realize they've got wrong, is C++'s value semantics. In C#, you're used to using new any time you wish to create an object. And whenever we talk about a class instance, we really mean "a reference to the class instance". Foo x = y doesn't copy the object y , it simply creates another reference to whatever object y references. In C++, there's a clear distinction between local objects, allocated without new ( Foo f or Foo f(x, y) , and dynamically allocated ones ( Foo* f = new Foo() or Foo* f = new Foo(x, y) ). And in C# terms, everything is a value type. Foo x = y actually creates a copy of the Foo object itself. If you want reference semantics, you can use pointers or references: Foo& x = y creates a reference to the object y . Foo* x = &y creates a pointer to the address at which y is located. And copying a pointer does just that: it creates another pointer, which points to whatever the original pointer pointed to. So this is similar to C#'s reference semantics. Local objects have automatic storage duration -- that is, a local object is automatically destroyed when it goes out of scope. If it is a class member, then it is destroyed when the owning object is destroyed. If it is a local variable inside a function, it is destroyed when execution leaves the scope in which it was declared. Dynamically allocated objects are not destroyed until you call delete . So far, you're probably with me. Newcomers to C++ are taught this pretty soon. The tricky part is in what this means , how it affects your programming style: In C++, the default should be to create local objects. Don't allocate with new unless you absolutely have to. If you do need dynamically allocated data, make it the responsibility of a class. A (very) simplified example: class IntArrayWrapper { explicit IntArrayWrapper(int size) : arr(new int[size]) {} // allocate memory in the constructor, and set arr to point to it ~IntArrayWrapper() {delete[] arr; } // deallocate memory in the destructor int* arr; // hold the pointer to the dynamically allocated array }; this class can now be created as a local variable, and it will internally do the necessary dynamic allocations. And when it goes out of scope, it'll automatically delete the allocated array again. So say we needed an array of x integers, instead of doing this: void foo(int x){ int* arr = new int[x]; ... use the array ... delete[] arr; // if the middle of the function throws an exception, delete will never be called, so technically, we should add a try/catch as well, and also call delete there. Messy and error-prone. } you can do this: void foo(int x){ IntArrayWrapper arr(x); ... use the array ... // no delete necessary } Of course, this use of local variables instead of pointers or references means that objects are copied around quite a bit: Bar Foo(){ Bar bar; ... do something with bar ... return bar; } in the above, what we return is a copy of the bar object. We could return a pointer or a reference, but as the instance created inside the function goes out of scope and is destroyed the moment the function returns, we couldn't point to that. We could use new to allocate an instance that outlives the function, and return a function to that -- and then we get all the memory management headaches of figuring out whose responsibility it is to delete the object, and when that should happen. That's not a good idea. Instead, the Bar class should simply be designed so that copying it does what we need. Perhaps it should internally call new to allocate an object that can live as long as we need it to. We could then make copying or assignment "steal" that pointer. Or we could implement some kind of reference-counting scheme where copying the object simply increments a reference counter and copies the pointer -- which should then be deleted not when the individual object is destroyed, but when the last object is destroyed and the reference counter reaches 0. But often, we can just perform a deep copy, and clone the object in its entirety. If the object includes dynamically allocated memory, we allocate more memory for the copy. It may sound expensive, but the C++ compiler is good at eliminating unnecessary copies (and is in fact in most cases allowed to eliminate copy operations even if they have side effects). If you want to avoid copying even more, and you're prepared to put up with a little more clunky usage, you can enable "move semantics" in your classes as well as (or instead of) "copy semantics". It's worth getting into this habit because (a) some objects can't easily be copied, but they can be moved (e.g. a Socket class), (b) it's a pattern established in the standard library and (c) it's getting language support in the next version. With move semantics, you can use objects as a kind of "transferable" container. It's the contents that move. In the current approach, it's done by calling swap , which swaps the contents of two objects of the same type. When an object goes out of scope, it is destructed, but if you swap its contents into a reference parameter first, the contents escape being destroyed when the scope ends. Therefore, you don't necessarily need to go all the way and use reference counted smart pointers just to allow complex objects to be returned from functions. The clunkiness comes from the fact that you can't really return them - you have to swap them into a reference parameter (somewhat similar to a ref parameter in C#). But the language support in the next version of C++ will address that. So the biggest C# to C++ gotcha I can think of: don't make pointers the default. Use value semantics, and instead tailor your classes to behave the way you want when they're copied, created and destroyed. A few months ago, I attempted to write a series of blog posts for people in your situation: Part 1 Part 2 Part 3 I'm not 100% happy with how they turned out, but you may still find them useful. And when you feel that you're never going to get a grip on pointers, this post may help.
