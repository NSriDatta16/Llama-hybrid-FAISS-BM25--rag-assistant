[site]: stackoverflow
[post_id]: 1148804
[parent_id]: 1148631
[tags]: 
In my mind there are three viable candidates: Haskell, Standard ML, OCaml. (Scala is out on the grounds that it compiles to JVM codes and is therefore unlikely to be fast enough when programs must run for days.) All are primarily functional. I will comment where I have knowledge. Performant OCaml gives the most stable performance for all situations, but performance is hard to improve. What you get is what you get :-) Haskell has the best parallel performance and can get excellent use out of an 8-core or 16-core machine. If your future is parallel, I urge you to master your dislike of the type system and learn to use Haskell effectively, including the Data Parallel Haskell extensions. The down side of Haskell performance is that it can be quite difficult to predict the space and time required to evaluate a lazy functional program. There are excellent profiling tools, but still significant effort may be required. Standard ML with the MLton compiler gives excellent performance. MLton is a whole-program compiler and does a very good job. High-level and elegant Syntactically Haskell is the clear winner. The type system, however, is cluttered with the remains of recent experiments. The core of the type system is, however, high-level and elegant. The "type class" mechanism is particularly powerful. Standard ML has ugly syntax but a very clean type system and semantics. OCaml is the least elegant, both from a point of view of syntax and from the type system. The remains of past experiments are more obtrusive than in Haskell. Also, the standard libraries do not support functional programming as well as you might expect. Primarily functional Haskell is purely functional; Standard ML is very functional; OCaml is mostly functional (but watch out for mutable strings and for some surprising omissions in the libraries; for example, the list functions are not safe for long lists). Portability All three work very well on Linux. The Haskell developers use Windows and it is well supported (though it causes them agony). I know OCaml runs well on OSX because I use an app written in OCaml that has been ported to OSX. But I'm poorly informed here. Object-oriented Not to be found in Haskell or SML. OCaml has a bog-standard OO system grafted onto the core language, not well integrated with other languages. You don't say why you are keen for object-orientation. ML functors and Haskell type classes provide some of the encapsulation and polymorphism (aka "generic programming") that are found in C++. Type system than can be subverted All three languages provide unsafe casts. In all three cases they are a good way to get core dumps. I like to be able to do some implicit casting. I think you will find Haskell's type-class system to your likingâ€”you can get some effects that are similar to implicit casting, but safely. In particular, numeric and string literals are implicitly castable to any type you like. Tools There are pretty good profiling tools with Haskell. Standard ML has crappy tools. OCaml has basically standard Unix profiling plus an unusable debugger. (The debugger refuses to cross abstraction barriers, and it doesn't work on native code.) My information may be out of date; the tools picture is changing all the time. Garbage-collected and compiled to native code Check. Nothing to choose from there. Recommendation Overcome your aversion to safe, secure type systems. Study Haskell's type classes (the original paper by Wadler and Blott and a tutorial by Mark Jones may be illuminating). Get deeper into Haskell , and be sure to learn about the huge collection of related software at Hackage .
