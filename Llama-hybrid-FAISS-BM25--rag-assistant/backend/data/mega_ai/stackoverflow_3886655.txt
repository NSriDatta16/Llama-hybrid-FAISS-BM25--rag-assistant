[site]: stackoverflow
[post_id]: 3886655
[parent_id]: 3784437
[tags]: 
At least rails 2.3.4 does not do this automatically. One needs to write a multipart/related parser and register it, inside initializers/mime_types.rb NOTE : Feel free to update the hard coded values( like main and attachment part prefix etc.,) in your copy. This same strategy can be used for multipart/related content as well. We are still debating whether to use multipart/related or multipart/mixed in this example below. Microsoft's notes on this subject. http://msdn.microsoft.com/en-us/library/ms527355(EXCHG.10).aspx Mime::Type.register "multipart/mixed", :mixed class ActionController::Request def initialize(env) Thread.current[:request]=self super end end class MultiPartParamsParser def main_part_name "main" end def attachment_part_prefix "my_company_attachment" end def content_type(main_part) # TODO ---- :xml_simple end def content(main_part) # TODO implement this if main_part.is_a?(String) main_part.gsub!("Content-Type: application/xml",'') # remove content type if it exists main_part.strip! # to remove any trailing or leading whitespaces else main_part[:tempfile].read end end def request Thread.current[:request] end def parse_formatted_parameters(data) multi_parts = Rack::Utils::Multipart.parse_multipart(request.try(:env)) main_part = multi_parts[main_part_name] data = content(main_part) # TODO return an error if data is not found params = case content_type(main_part) when :xml_simple, :xml_node data.blank? ? {} : Hash.from_xml(data).with_indifferent_access when :yaml YAML.load(data) when :json if data.blank? {} else ret = ActiveSupport::JSON.decode(data) ret = {:_json => data} unless data.is_a?(Hash) ret.with_indifferent_access end else {} end process_attachments(params, multi_parts) params end def process_attachments(data, multi_parts) data.each do |key, value| value ||= key # when array value is nil if value.is_a?(Hash) or value.is_a?(Array) process_attachments(value, multi_parts) elsif value.respond_to?(:match) and value.match("^#{attachment_part_prefix}") and (attachment=multi_parts[value]) # there could Time,Numbers etc.., but we match only string. data[key] = create_uploaded_file(attachment) # TODO handle the scenarios for short strings end end end def create_uploaded_file (attachment) upload = attachment[:tempfile] upload.extend(ActionController::UploadedFile) upload.original_path = attachment[:filename] upload.content_type = attachment[:type] upload end end proc = Proc.new do |data| MultiPartParamsParser.new.parse_formatted_parameters(data) end ActionController::Base.param_parsers[Mime::Type.lookup('multipart/mixed')] = proc then, you can post your message like this. Nesting gets automatically taken with no further changes to the models or controllers. POST /posts.xml HTTP/1.1 Content-type: multipart/mixed; boundary=---------------------------###987612345### Accept: application/xml,text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 Cache-Control: no-cache Pragma: no-cache Connection: keep-alive Content-Length: ## -----------------------------###987612345### content-disposition: name="main" Content-Length: ## post_title post_body my_company_attachment_0 my_company_attachment_1 -----------------------------###987612345### content-disposition: name="my_company_attachment_0"; filename="C:/Users/mv288/files/1.txt" content-type: application/octet-stream ÿþ sample file content -----------------------------###987612345### content-disposition: name="my_company_attachment_1"; filename="C:/Users/mv288/Pictures/1.png" content-type: image/png ÿþ sample file content -----------------------------###987612345###
