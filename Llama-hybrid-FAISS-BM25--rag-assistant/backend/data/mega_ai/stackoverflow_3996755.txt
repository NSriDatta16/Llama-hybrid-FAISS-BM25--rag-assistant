[site]: stackoverflow
[post_id]: 3996755
[parent_id]: 3992399
[tags]: 
I like Craig 's answer , but I think the point has to be more strongly made. There are no "primitives" -- if Int can do it, then so can a user-made Complex (for example). Basic usage of ++ would be like this: var x = 1 // or Complex(1, 0) x++ How do you implement ++ in class Complex ? Assuming that, like Int , the object is immutable, then the ++ method needs to return a new object, but that new object has to be assigned . It would require a new language feature. For instance, let's say we create an assign keyword. The type signature would need to be changed as well, to indicate that ++ is not returning a Complex , but assigning it to whatever field is holding the present object. In Scala spirit of not intruding in the programmers namespace, let's say we do that by prefixing the type with @ . Then it could be like this: case class Complex(real: Double = 0, imaginary: Double = 0) { def ++: @Complex = { assign copy(real = real + 1) // instead of return copy(real = real + 1) } The next problem is that postfix operators suck with Scala rules. For instance: def inc(x: Int) = { x++ x } Because of Scala rules, that is the same thing as: def inc(x: Int) = { x ++ x } Which wasn't the intent. Now, Scala privileges a flowing style: obj method param method param method param ... . That mixes well C++/Java traditional syntax of object method parameter with functional programming concept of pipelining an input through multiple functions to get the end result. This style has been recently called "fluent interfaces" as well. The problem is that, by privileging that style, it cripples postfix operators (and prefix ones, but Scala barely has them anyway). So, in the end, Scala would have to make big changes, and it would be able to measure up to the elegance of C/Java's increment and decrement operators anyway -- unless it really departed from the kind of thing it does support.
