[site]: stackoverflow
[post_id]: 4823078
[parent_id]: 4798640
[tags]: 
I usually go for a simple dictionary-like API using an int as the key and a fixed-size value. This executes quickly, uses a very small amount of program RAM and has predictable data RAM usage. In other words, the lowest-level API looks like: void data_set(uint16 key, uint32 value); uint32 data_get(uint16 key); Keys become a list of constants: #define KEY_BOGOMIPS 1 #define KEY_NERDS_PER_HOUR 2 You handle different data types by casting. Sucks, but you can write macros to make the code a little cleaner: #define data_get_float(key) (float)data_get(key) Achieving type safety is difficult to do without writing a separate macro or accessor function for each item. On one project, I needed validation of input data, and this became the type-safety mechanism. The way you structure the physical storage of data depends how much data memory, program memory, cycles and separate keys you have. If you've got lots of program space, hash the key to get a smaller key that you can look up directly in an array. Usually, I make the underlying storage look like: struct data_item_t { uint16 key; uint32 value; } struct data_item_t items[NUM_ITEMS]; and iterate through. For me, this has been fast enough even on very small (8-bit) microcontrollers, though it might not fit for you if you've got a lot of items. Remember that your compiler will probably inline or optimise the writes nicely, so cycles per access may be lower than you'd expect.
