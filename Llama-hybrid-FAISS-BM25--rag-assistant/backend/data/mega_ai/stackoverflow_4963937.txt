[site]: stackoverflow
[post_id]: 4963937
[parent_id]: 4957038
[tags]: 
Basically, you need to do following: Configure security on client and service binding so identity is transferred to service. Implement custom authorization manager that will track sessions and allow/forbid user to use the service. Configure serviceAuthorization behavior to use implemented authorization manager. See following configuration and code samples. Client configuration : Service configuration : Custom authorization manager : public class SingleSessionPerUserManager : ServiceAuthorizationManager { private SessionStorage Storage { get; set; } public SingleSessionPerUserManager() { Storage = new SessionStorage(); } protected override bool CheckAccessCore( OperationContext operationContext ) { string name = operationContext.ServiceSecurityContext.PrimaryIdentity.Name; if ( Storage.IsActive( name ) ) return false; Storage.Activate( operationContext.SessionId, name ); operationContext.Channel.Closed += new EventHandler( Channel_Closed ); return true; } private void Channel_Closed( object sender, EventArgs e ) { Storage.Deactivate( ( sender as IContextChannel ).SessionId ); } } The helper class used to track session information : public class SessionStorage { private Dictionary Names { get; set; } public SessionStorage() { Names = new Dictionary (); } public void Activate( string sessionId, string name ) { Names[ name ] = sessionId; } public void Deactivate( string sessionId ) { string name = ( from n in Names where n.Value == sessionId select n.Key ).FirstOrDefault(); if ( name == null ) return; Names.Remove( name ); } public bool IsActive( string name ) { return Names.ContainsKey( name ); } } EDIT : After first session is activated, each following request for a session will cause a System.ServiceModel.Security.SecurityAccessDeniedException: Access is denied. exception to be thrown.
