[site]: stackoverflow
[post_id]: 1566137
[parent_id]: 1565993
[tags]: 
I can think of four possible workarounds for your scenario: use fully-qualified-table-names when querying for the external table. MySQL supports the dbname.tablename -syntax to access tables outside the current database scope. This requires that the currently connected user has the appropriate rights to read from the requested table in another physical db. if your external database is running on a different MySQL server (either on the same machine or via a network connection) you could use replication to constantly update a read-only copy of the remote table. Replication is only possible if you're running two separate MySQL instances. use the FEDERATED MySQL storage engine to virtually import the table into your current database. This lifts the requirement of giving the current user access rights into the second database as the credentials are given with the CREATE TABLE -statement when using the FEDERATED storage engine. This also works with the databases running on different physical servers or different MySQL instances. I think that this will be the poorest performing option and does have some limitations - more or less important depending on your usage scenario and your requirements. This is an extension to method 1. Instead of having to specify the fully-qualified-table-names every time you request information from your external table, you simply can create a view inside your current database based on a simple SELECT > FROM >. > . This resemble the way, the FEDERATED -method works, but is limited to tables on the same MySQL instance. Personally I'd consider method (4) as the most useful - but the others could also be possible workarounds depending on your requirements.
