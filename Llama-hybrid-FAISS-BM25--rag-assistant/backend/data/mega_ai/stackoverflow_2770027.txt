[site]: stackoverflow
[post_id]: 2770027
[parent_id]: 2769990
[tags]: 
struct item sandwich{"Sandwich", 3.00}; is a usage of compound literal , which is legal in C (C99 standard) but not legal in C++ quite yet. But since most of the C++ compilers compile both C and C++ code, some decide to allow such structures in C++. Most do not though, not without special command line arguments. So, for this to be legal and portable, you have to write a constructor for your item struct. This is easy, though struct item { item(string const & name_, double price_) : name(name_), price(price_) {} string name; double price; }; And now you can create new items with item sandwich("Sandwich", 3.00); P.S. Note, that I'd use named initializers in compound literals when you have fields with different meaning in single structure, it's just easier to understand what is what then. struct item sandwich = {.name = "Sandwich", .price = 3.0}; That's not going to work in C++ as well, of course, but at least it looks better. P.P.S. Turns out I wasn't paying enough attention to C++0x and there it's called initializer lists . Seems like you can't make it named though, it's a shame. So, instead of using C99 standard in C++ code, your Linux compiler has used C++0x experimental standards silently. Nevertheless, if you want crossplatform code, it's still better to stay away from those fancy features and use plain old constructors instead.
