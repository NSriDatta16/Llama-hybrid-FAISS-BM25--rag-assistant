[site]: stackoverflow
[post_id]: 2967334
[parent_id]: 2915944
[tags]: 
The fix in my case was to use an updated tile service from the same publisher. It accepts simpler paramaters: globalfoovar = new google.maps.ImageMapType({ getTileUrl: function(tile, zoom) { return "http://bar.com/" + zoom + "/" + tile.x + "/" + tile.y +".png"; }, tileSize: new google.maps.Size(256, 256), opacity:0.60, isPng: true }); googleMap.overlayMapTypes.push(null); // create empty overlay entry googleMap.overlayMapTypes.setAt("0",globalfoovar); // set the overlay, 0 index // if you want to hide the layer later (toggle): // googleMap.overlayMapTypes.setAt("0",null); As you can see, this is much easier than the code I posted in the problem description. However if you're still reading you probably still want the answer to the original problem, which is converting latlng to pixels. Don't worry, I have a solution for that as well. To gain access to the 4 useful latlng, point, and pixel conversions you need to add a dummy OverlayView. Step 1) Define the stub so it is globally available, along with your map and other vars: var googleMap = {}; // global map var var mapCanvasStub = {}; // map OverlayView var Step 2) After you render your map, setup this dummy/stub OverlayView like so: googleMap = new google.maps.Map($('#mapCanvas')[0]); // google map init mapCanvasStub = function (map) { this.setMap(map); } // start building overlay stub mapCanvasStub.prototype = new google.maps.OverlayView(); mapCanvasStub.prototype.draw = function() {}; mapCanvasStub = new mapCanvasStub(googleMap); // bin dthe overlay to the map Now you've got a functional OverlayView tied to the map, whenever you need to use those conversions you can do so like this: var projection = mapCanvasStub.getProjection(); var position = projection.fromLatLngToContainerPixel( latLng ); // or fromContainerPixelToLatLng() // or fromDivPixelToLatLng() // or fromLatLngToDivPixel() // or fromLatLngToDivPixel() In my case I'm using this to create custom info bubbles, here is a snippet from my click event: function customAlertClick(a,b,c) { var projection = mapCanvasStub.getProjection(); var position = projection.fromLatLngToContainerPixel(b); var top = (position.y + parseInt($('#mapCanvas').position().top)); var lft = (position.x + parseInt($('#mapCanvas').position().left)); // obviously this is an overly simple example $('#foo').css('top',top + 'px'); $('#foo').css('lft',left + 'px'); } Hope this helps anyone else making the jump to V3. If you're wondering why we have to jump through these extra hoops to do something that is so simple in V2, the answer is pretty obvious when you think about it. V3 is setup to work well on mobile devices where bandwidth and cpu power are limited. They've eliminated as much code as possible to get the simple maps rendering, and they expect you to manually wire up these extras if you absolutely need them. If I had more time I'd write a sample.html but this should get you going.
