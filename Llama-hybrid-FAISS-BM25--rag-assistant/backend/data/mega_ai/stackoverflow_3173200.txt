[site]: stackoverflow
[post_id]: 3173200
[parent_id]: 3173062
[tags]: 
In general, there are two ways of doing things in F#. You can either use recursion explicitly or you can use existing functions. In your case, you need to do two things in a nested way - you need to iterate over the outer list and sort the inner lists. The sorting can be done using List.sortBy and the iteration (projection) can be done using List.map . To correct your original approach (using recursion) - I simplfied it slightly (because you don't need the loop function - you can make the function itself recursive): let rec sortPositionList list = match list with | [] -> [] | hd::tl -> // Sort the list of positions first - by storing this as a new value // using 'let', you get more readable code (and you can use IntelliSense // to explore the type of 'sorted' and understand what's going on) let sorted = List.sortBy (fun (x, _) -> x) (GetInternStruct(hd)) // As Brian suggests, more idiomatic F# encoding of the line would be: // let sorted = GetInternStruct(hd) |> List.sortBy (fun (x, _) -> x) // but both of the options would work in this case. // Note: The result shouldn't be wrapped in '[ .. ]'. The operator '::' // takes an element and a list and returns a new list created by // prepending the element in front of the list sorted::(sortPositionList tl) The solution using existing functions ( List.map ) has been already posted by JDU. I would just add that he uses partial function application - so the parameter passed to List.map is a function. If this feels confusing, you can rewrite that using lambda function explicitly: let SortPositionList (positionList) = List.map (fun positions -> List.sortBy (fun (index, _) -> index) positions) positionList Which could be more idiomatically written using the pipelining operator and the fst function instead of explicit lambda parameter (as Brian mentioned): let SortPositionList (positionList) = positionList |> List.map (fun positions -> positions |> List.sortBy fst) This means exactly the same thing as the code posted by JDU, but you may find it more readable. Finally, you can write the same thing using sequence expressions (which is perhaps the most elegant option in my opinion): let SortPositionList (positionList) = [ for positions in positionList do yield positions |> List.sortBy fst ] EDIT The functions as I wrote them here work with values of type (int*Point) list list and not with the type Positions list . To change this, you need to add some wrapping and unwrapping. The recursive implementation should be: match list with // List is always 'Positions', so we use pattern | Positions [] -> [] // matching to unwrap the underlying list in | Positions (hd::tl) -> // both cases // Wrap the resulting list into the positions type let sorted = Positions(List.sortBy (fun (x, _) -> x) (GetInternStruct(hd))) (sorted::(sortPositionList tl)) Similarly, for the List.map implementation: let SortPositionList (positionList) = positionList |> List.map (fun (Positions positions) -> // pattern matching positions |> List.sortBy fst |> Positions) // wrapping
