[site]: stackoverflow
[post_id]: 2101756
[parent_id]: 2101566
[tags]: 
The solution is to avoid incompatible changes to your types. Take for example, SystemBObject. You describe "version 1" and "version 2" of this type, but they are not the same type at all. A compatible change to this type involves only Adding properties, and not changing the type of any existing properties. Your hypothetical "Version update" has violated both of those constraints. By following that one guildeline, you can avoid ALL of the problems you described. Therefore, if this is your type definition in version 1 class SystemBObject{ // version 1 String key; Integer year; Integer month; Integer day; ... // getters and setters etc; } Then, this cannot be your type definition in v2: // version 2 - NO NO NO class SystemBObject{ String key; BDate date; ... // getters and setters etc; } ...because it has eliminated existing fields. If that is the change you need to make, it is not a new "version", it is a new type, and should be named as such, both in code and in the serialization format. Another example: If this is your existing v1 type : class SomethingFromARequest { Integer requestedId; ... // getters and setters etc; } ... then this is not a valid "v2" of that type: class SomethingFromARequest { Long requestedId; ... // getters and setters etc; } ...because you have changed the type of the existing property. These constraints are explained in much more detail a mostly technology-neutral way in Microsoft's Service Versioning article . Aside from avoiding that source of incompatibility, you can and should include a version number in the type. This can be a simple serial number. If you are in the habit of logging or auditing messages, and bandwidth and storage space is not a problem, you may want to augment the simple integer with a UUID to identify an instance of each unique version of a type. Also, you can design forward-compatibility into your data transfer objects, by using lax processing, and mapping "extra" data into an "extra" field. If XML is your serialization format, then you might use xsd:xmlAny or xsd:any and processContents="lax" to capture any unrecognized schema elements, when a v1 service receives a v2 request ( more ). If your serialization format is JSON, with its more open content model, then this comes for free.
