[site]: stackoverflow
[post_id]: 3444813
[parent_id]: 3444557
[tags]: 
First, you do definitely need the new thread to have an autorelease pool, so don't punt on solving this. :-) That said, this has some of the hallmarks of a premature release or an over-release somewhere in the code. I would pay particular attention to the Connection object's delegate, as the rules about an object retaining its delegate are somewhat slippery. (Cocoa objects in general do not retain their delegates, but third-party code may -- and sometimes for good reasons.) I'll now call your attention to Tracking Memory Usage . Some permutation of MallocDebug and NSZombieEnabled=YES should eventually uncover the culprit code. Once you're past this bug, though, you might want to explore Grand Central Dispatch for this sort of thing rather than rolling your own threads... Your code as it stands looks like it should probably be using an NSCondition or pthread_condition variable to be strictly correct. While you can get away with a lot on current hardware, these kinds of unsynchronized shared accesses can easily cause some really nasty races. GCD (AKA libdispatch) offers a much cleaner and more modern paradigm, so if you're going to learn something new it's a much better investment than pthreads / NSThread / etc. :-)
