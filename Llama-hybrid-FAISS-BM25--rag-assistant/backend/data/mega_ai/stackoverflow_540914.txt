[site]: stackoverflow
[post_id]: 540914
[parent_id]: 540848
[tags]: 
The first method will be faster - but IMO it's not the right way of doing it. I'm in agreement with tehvan about that. I'd recommend keeping the item_id as is, but add two extra fields one for the code and one for the size, then you can do: select * from items where item_code = 'S' and item_size = 'm' With indexes the performance will be greatly increased, and you'll be able to easily match a range of sizes, or codes. select * from items where item_code = 'S' and item_size IN ('m','s') Migrate the db as follows: alter table items add column item_code varchar(1) default ''; alter table items add column item_size varchar(1) default ''; update items set item_code = SUBSTRING(item_id, 1, 1); update items set item_size = SUBSTRING(item_id, 2, 1); The changes to the code should be equally simple to add. The long term benefit will be worth the effort. For scenario 2 - that is not an efficient way of storing and retrieving data from a database. When used in this way the database is only acting as a storage engine, by encoding multiple data into fields you are precluding the relational part of the database from being useful. What you should do in that circumstance is to have another table, call it 'items_collected'. The schema would be along the lines of CREATE TABLE items_collected ( id int(11) NOT NULL auto_increment KEY, userid int(11) NOT NULL, item_code varchar(10) NOT NULL, FOREIGN KEY (`userid`) REFERENCES `user`(`id`), FOREIGN KEY (`itemcode`) REFERENCES `items`(`item_code`) ); The foreign keys ensure that there is Referential integrity , it's essential to have referential integrity . Then for the example you give you would have multiple records. user_id | username | items_collected U0001 | Alex | Ss001 U0001 | Alex | Tm002 U0002 | Daniel | Sb002 U0002 | Daniel | Tb001 U0003 | Michael | ... U0004 | Thomas | ...
