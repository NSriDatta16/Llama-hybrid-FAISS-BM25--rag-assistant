[site]: stackoverflow
[post_id]: 3511680
[parent_id]: 3497748
[tags]: 
You can convert methods of service so they return IObservable instead of taking callback as a parameter. In this case sequential workflow can be implemented using SelectMany , something like this... WidgetService.Query() .SelectMany( widgets => { Widgets.Clear(); foreach (var w in widgets) { Widgets.Add(w); } return WidgetService.Load(); } ) .Do( defaultWidget => { if (defaultWidget != null) Default = defaultWidget; } ) .Subscribe( _ => { }, e => { throw e; } ); However IMO F# asyncs will look much more clear (in sample I assume that methods of service returns Async> and Async respectively). Note that sample doesn't take in account what thread is modifying data fields, in real-world code you should pay attention to this: let load = async { let! widgets = WidgetService.Query() Widgets.Clear() for w in widgets do Widgets.Add(w) let! defaultWidget = WidgetService.Load() if defaultWidget <> null then Default EDITED In fact it is possible to use technique with iterators you mentioned in your question: private IEnumerable > Intialize() { var widgetsList = WidgetService.Query().Start(); yield return widgetsList; Widgets.Clear(); foreach (var w in widgetsList[0]) { Widgets.Add(w); } var defaultWidgetList = WidgetService.Load().Start(); yield return defaultWidgetList; if (defaultWidgetList[0] != null) Default = defaultWidgetList[0]; } Observable .Iterate(Intialize) .Subscribe( _ => { }, ex => { throw ex; } );
