[site]: stackoverflow
[post_id]: 1964820
[parent_id]: 
[tags]: 
returning and using multiple tree structures in a recursive function

I have a function get_trees() that operates on a complex tree structure T and returns two component tree structures A and B. The only way I have been able tot get this to work is to create a new structure C with pointers to A and B, which is then passed as a parameter to the function and is also a return value: typedef struct Composite { itree *A; itree *B; } composite; composite *get_trees(complextree *T, itree *A, itree *B, composite *C); Root nodes of trees A & B are initialized in another function: itree *A = new_itree(0); itree *B = new_itree(0); A->n = T->a; B->n = T->b; composite *C; C = get_trees(T, A, B, C); get_trees() walks down branches of complextree T, allocates and populates nodes of A and B and recursively calls itself on subodes. Simplified code: //code for allocating subnodes of A and B if (T->nodes != NULL){ for (i=0; i nn; i++){ //code for computing p & q C = get_trees(T->nodes[i], A->nodes[p], B->nodes[q]); } } The code works fine. However it seems very ugly. (1) C has no intrinsic meaning and ie being used to allow return of multiple values. Is there an alternative?? Something along the following lines: (2) Is it possible to write the recursive function with the following signature: void get_trees(T, A, B); Is seems that if I pass the root nodes of A & B as parameters and subnodes are allocated within the recursive function, then there is a continuous chain of command so to speak and the whole tree should be available when the recursive call completes. It did not work for me, so it must not be allowed. I would appreciate if someone could explain why that is the case, or if a more elegant solution is possible?? Thanks and happy holidays. ~RT
