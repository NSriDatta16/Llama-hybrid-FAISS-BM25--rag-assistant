[site]: stackoverflow
[post_id]: 2226798
[parent_id]: 2225850
[tags]: 
Lets explore some possibilities for what's going on here: int main(int argc; char **argv){ char **tmp1; // Could point any where char **tmp2 = NULL; char **tmp3 = NULL; char **tmp4 = NULL; char **tmp5 = NULL; char **realDest; int size = SIZE_MACRO; // Well, you never said int cb = sizeof(char) * size * 8; //string inside 2. level has 8 chars /* Case 1: did nothing with tmp */ memcpy(realDest,tmp,cb); // copies 8*size bytes from WHEREEVER tmp happens to be // pointing. This is undefined behavior and might crash. printf("%p\n",tmp[0]); // Accesses WHEREEVER tmp points+1, undefined behavior, // might crash. printf("%c\n",tmp[0][0]); // Accesses WHEREEVER tmp points, undefined behavior, // might crash. IF it hasn't crashed yet, derefernces THAT // memory location, ALSO undefined behavior and // might crash /* Case 2: NULL pointer */ memcpy(realDest,tmp2,cb); // Dereferences a NULL pointer. Crashes with SIGSEGV printf("%p\n",tmp2[0]); // Dereferences a NULL pointer. Crashes with SIGSEGV printf("%c\n",tmp2[0][0]); // Dereferences a NULL pointer. Crashes with SIGSEGV /* Case 3: Small allocation at the other end */ tmp3 = calloc(sizeof(char*),1); // Allocates space for ONE char*'s // (4 bytes on most 32 bit machines), and // initializes it to 0 (NULL on most machines) memcpy(realDest,tmp3,cb); // Accesses at least 8 bytes of the 4 byte block: // undefined behavior, might crash printf("%p\n",tmp3[0]); // FINALLY one that works. // Prints a representation of a 0 pointer printf("%c\n",tmp3[0][0]); // Derefereces a 0 (i.e. NULL) pointer. // Crashed with SIGSEGV /* Case 4: Adequate allocation at the other end */ tmp4 = calloc(sizeof(char*),32); // Allocates space for 32 char*'s // (4*32 bytes on most 32 bit machines), and // initializes it to 0 (NULL on most machines) memcpy(realDest,tmp4,cb); // Accesses at least 8 bytes of large block. Works. printf("%p\n",tmp3[0]); // Works again. // Prints a representation of a 0 pointer printf("%c\n",tmp3[0][0]); // Derefereces a 0 (i.e. NULL) pointer. // Crashed with SIGSEGV /* Case 5: Full ragged array */ tmp5 = calloc(sizeof(char*),8); // Allocates space for 8 char*'s for (int i=0; i The moral of the story is: you must to know what is on the other side of your pointers. Or else. The second moral of the story is: just because you can access a double pointer using the [][] notation does not make it is the same as two-dimensional array. Really. Let me clarify the second moral a little bit. An array (be it one dimensional, two dimensional, whatever) is an allocated piece of memory, and the compiler knows how big it is (but never does any range checking for you), and a what address it starts. You declare arrays with char string1[32]; unsigned int histo2[10][20]; and similar things; A pointer is a variable that can hold a memory address. You declare pointers with char *sting_ptr1; double *matrix_ptr = NULL; They are two different things. But: If you use the [] syntax with a pointer, the compiler will do pointer arithmetic for you. In almost any place you use an array without dereferencing it, the compiler treats it as a pointer to the arrays start location. So, I can do strcpy(string1,"dmckee"); because rule 2 says that string1 (an array) is treated as a char* ). Likewise, I can fllow that with: char *string_ptr2 = string1; Finally, if (string_ptr[3] == 'k') { prinf("OK\n"); } will print "OK" because of rule 1.
