[site]: stackoverflow
[post_id]: 3372343
[parent_id]: 
[tags]: 
Use of type synonyms in monad transformers

Is it possible to use type synonyms as arguments of monad transformers' type constructor? In particular, if there is an unary type synonym for an applied monad transformer, could it be used as a type of the underlying monad in another monad transformer? From what I see type synonyms are not accepted as first-class type constructors, see example and error messages below: -- Using type synonym of a monad transformer in another monad transformer. import Control.Monad.Reader -- inner transformer type A a = ReaderT Int IO a -- type B a = ReaderT String A a {- Error: readert2.hs:8:0: Type synonym `A' should have 1 argument, but has been given 0 In the type synonym declaration for `B' -} -- type B a = ReaderT String (A a) a {- Error: readert2.hs:15:27: Kind mis-match The second argument of `ReaderT' should have kind `* -> *', but `A a' has kind `*' In the type `ReaderT String (A a) a' In the type synonym declaration for `B' -} type B a = ReaderT String (ReaderT Int IO) a {- OK -} main = do r Is there a way to avoid expanding the type synonym A in the definition of B a ?
