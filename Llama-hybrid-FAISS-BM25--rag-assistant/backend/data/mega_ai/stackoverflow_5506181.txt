[site]: stackoverflow
[post_id]: 5506181
[parent_id]: 5493500
[tags]: 
So you're introducing the ref because you want to be able to not blow up memory when time passes, 'cause just using memoize around fetch-posts may lead to this, sooner or later, right ? Maybe you could try an alternate approach : let fetch-posts be "pure", memoize-free. With this scenario, someone can call fetch-posts blindlessly, without having to fear OutOfMemoryExceptions. Indeed, maybe for some usecases, it may be sufficient to "cache the value" in a local of the calling code. But the story does not end here, or I would not have taken the time to answer :-) : you can pretty easily have your "localized in time" memoize by rebinding fetch-posts using clojure.core/binding : from then, all the code in the same thread in the call stack will benefit from the bound memoized fetch-posts. If you're using clojure 1.3 alpha, you'll need to declare the fetch-posts var as rebindable explicitly via the :dynamic metadata. ;; most simple definition (defn ^:dynamic fetch-posts [& options] (let [options (apply array-map options)] (fetch :posts options))) ;; a la carte caching by the calling code (lexically scoped) (let [posts (apply fetch-posts options)] ...) ;; a la carte caching by the calling code (dynamically scoped) (binding [fetch-posts (memoize fetch-posts)] ...) My last guess would be that you'd want to "memoize" in posts, in your original version, by indexing the posts by a key which would be the options seq, right ? Some maybe your code was not right ? (or you made the assumption that fetch-posts would always be called with the same args over and over ?) Another idea. Use an agent to serialize write-access to posts and then ensure the call to fetch is only done when it is nil : (def posts (agent nil)) (defn reset-posts [] (send posts (constantly nil))) (defn fetch-posts [& options] (let [options (apply array-map options)] (send-off posts #(or % (fetch :posts options))) (await-for (Long/MAX_VALUE) posts) @posts))
