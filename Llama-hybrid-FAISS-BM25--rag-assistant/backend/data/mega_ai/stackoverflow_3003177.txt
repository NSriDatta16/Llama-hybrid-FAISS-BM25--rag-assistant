[site]: stackoverflow
[post_id]: 3003177
[parent_id]: 2469267
[tags]: 
Wow, no one answered you after all this time? Okay, here's the answer. If you inspect your MySQL database after you get a few WPMU blogs up and running, you'll notice that each blog has a separate table prefix. The wp_1_ prefix goes to the main admin blog. And then wp_2_ prefix and so on go to all the non-main admin blogs that you create in the wp-admin system. If you want to use the Codex function to access which table prefix, it's actually easy -- just do "global $table_prefix;". In fact, as a side note, WordPress emits a ton of global vars that are quite useful and you can find out what these are by doing "print_r($GLOBALS);die();" in like a plugin or theme file. But anyway, the answer to your question is that if you look into the MySQL database, you'll find that each blog in WPMU gets its own options table, and it is separate, not sitewide, but blogwide -- just as you desired. And when you use the standard WordPress options API, it will access the options table you need automatically without you having to use the $wpdb global object and without you needing to use $table_prefix global string. So, if you are using get_option(), update_option(), add_option(), and delete_option() -- these will all work still in a WPMU environment. And even though the plugins folder is shared among all blogs, a plugin's settings are not and are exclusive to each blog. Now, if you are not using the WP Options API in the Codex, but are going at it with the $wpdb global object, then you'll need to be aware that you'll need to address tables by the $table_prefix global string as part of the table path. There are some cases where this is desirable, such as having a LOT of data that you need to store in a custom table. For instance, storing HTTP_REFERER and user agent info into a table for connections coming in.
