[site]: stackoverflow
[post_id]: 5053271
[parent_id]: 5048349
[tags]: 
You could build an Expression tree to query for the object or objects in question: public T GetSingleObject (int someValue) { MyEntities db = new MyEntities(); var result = db.CreateQuery (String.Format("[{0}]", typeof(T).Name + "s")); var param = Expression.Parameter(typeof(T)); var lambda = Expression.Lambda >( Expression.Equal( Expression.Property(param, "WhateverPropertyYourComparing"), Expression.Constant(someValue)), param); return result.SingleOrDefault(lambda); } Or if you want a collection of objects public IEnumerable GetResultCollection (int someValue) { MyEntities db = new MyEntities(); var result = db.CreateQuery (String.Format("[{0}]", typeof(T).Name + "s")); var param = Expression.Parameter(typeof(T)); var lambda = Expression.Lambda >( Expression.Equal( Expression.Property(param, "WhateverPropertyYourComparing"), Expression.Constant(someValue)), param); return result.Where(lambda); } Of course if your desired query is very long, this can get out of hand, and you should consider adding in the necessary interface using partial classes, as Justin Morgan suggested. Note that this method assumes that your ObjectSet collection is the same name as your object, plus an "s", ie, "Invoice" to "Invoices". If that's not the case, ie, "Person" to "People", then you could use System.Data.Entity.Design.PluralizationServices.PluralizationService to get the proper name
