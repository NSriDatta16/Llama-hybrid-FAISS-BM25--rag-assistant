[site]: stackoverflow
[post_id]: 1743846
[parent_id]: 1743764
[tags]: 
maybe something like this - override the save() method where you can call encrypt method. for decrypt you can use signal post_init , so every time you instantiate the model from the database the product_id field is decrypted automatically class MyClass(models.Model): user_field = models.ForeignKey(User) product_id = EncryptedCharField() ...other fields... def save(self): self.product_id._encrypt(product_id, self.user_field) super(MyClass,self).save() def decrypt(self): if self.product_id != None: user = self.user_field self.product_id._decrypt(user=user) def post_init_handler(sender_class, model_instance): if isinstance(model_instance, MyClass): model_instance.decrypt() from django.core.signals import post_init post_init_connect.connect(post_init_handler) obj = MyClass(user_field=request.user) #post_init will be fired but your decrypt method will have #nothing to decrypt, so it won't garble your input #you'll either have to remember not to pass value of crypted fields #with the constructor, or enforce it with either pre_init method #or carefully overriding __init__() method - #which is not recommended officially #decrypt will do real decryption work when you load object form the database obj.product_id = 'blah' obj.save() #field will be encrypted maybe there is a more elegant "pythonic" way of doing this
