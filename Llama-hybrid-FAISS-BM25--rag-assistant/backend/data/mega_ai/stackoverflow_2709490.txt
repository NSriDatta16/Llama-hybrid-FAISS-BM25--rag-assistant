[site]: stackoverflow
[post_id]: 2709490
[parent_id]: 2709435
[tags]: 
Yes, this is an endianness issue. If you are supporting just one platform, you can lay out the struct members according to the architecture's endianness. If you are dealing with multiple architectures, you will need #define multiple struct member layouts, dependent on endianness. Structs and unions always look more elegant to me, but bitwise operations are the more portable of the two. When I do stuff like this, I stick an assert into my startup code to make sure the struct is the size I expect it to me, before indeterminate nastiness ensues. In C++, you might write a class that encapsulates your data and performs your operations for you.
