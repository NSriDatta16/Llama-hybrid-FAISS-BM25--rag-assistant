[site]: stackoverflow
[post_id]: 1418009
[parent_id]: 1417596
[tags]: 
This is a horrid way to do this. As others have pointed out, exceptions should only be used for handling exceptional, unexpected situations. And because we make that assumption, many organizations run their code in contexts which aggressively seek out and report exceptions, even handled ones , because a handled null reference exception is almost certainly a bug . If your program is unexpectedly dereferencing invalid memory and continuing merrily along then odds are good that something is deeply, badly broken in your program and it should be brought to someone's attention. Do not "cry wolf" and deliberately construct a situation that looks horribly broken but is in fact by design. That's just making more work for everyone. There is a standard, straightforward, accepted way to make a singleton in C#; do that if that's what you mean. Don't try to invent some crazy thing that violates good programming principles. People smarter than me have designed a singleton implementation that works; it's foolish to not use it. I learned this the hard way. Long story short, I once deliberately used a test that would most of the time dereference bad memory in a mainline scenario in the VBScript runtime. I made sure to carefully handle the exception and recover correctly, and the ASP team went crazy that afternoon. Suddenly all their checks for server integrity started reporting that huge numbers of their pages were violating memory integrity and recovering from that. I ended up rearchitecting the implementation of that scenario to only do code paths that did not result in exceptions. A null ref exception should always be a bug, period. When you handle a null ref exception, you are hiding a bug. More musing on exception classifications: http://ericlippert.com/2008/09/10/vexing-exceptions/
