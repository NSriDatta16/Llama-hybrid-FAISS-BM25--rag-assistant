[site]: stackoverflow
[post_id]: 2984841
[parent_id]: 2984019
[tags]: 
Analyzing others people code is a must... I'm a student... public open source repositories might be the answer? The problem with open source is that the quality varies too much. (There's lots of my own code sitting in public open-source repositories that I wouldn't want anyone to try to see , let alone learn from. And yet some of my code, the code I have lavished time and attention on, is very good—or so my peers tell me.) So you don't want to pick an open-source project and learn from J. Random Hacker. You want to learn from the best hackers. Here are some strategies: If you're a student, you have acccess to teachers. One or two of them may have an idea about software. Ask them what is worth reading—what you will learn from. Look at conferences and journals that publish about software: SIGPLAN, SIGSOFT, USENIX, Software—Practice & Experience , Journal of Functional Programming . Read about systems that look interesting to you. Write to the authors and ask them if they recommend you try to learn from their code. Listen carefully to what they say; most of the best hackers know they can do better. If you extract a grudging admission, with a bunch of caveats, that maybe there is something to learn there, you've found the right person. If you're learning C, a lot of the old Bell Labs stuff is really worth looking at (and a lot isn't). I admire the work of Jon Bentley, Brian Kernighan, and Rob Pike, among many others. You can download and read the source of the original awk , or Pike's interpreter for Newsqueak. Popularity does not correlate with suitability for learning. The GNU tools are very popular, but almost anyone who has seen both will tell you that you will learn more from the Bell Labs versions. And Linux is very popular, but people I trust who work in the field tell me that if you want to learn about operating systems, you should study BSD. I myself work in the field of compilers and can tell you that if you want to write a compiler in C, the model to emulate is the little-known lcc , not the wildly popular gcc . Finally, I highly recommend the work of Richard Bird, Hans Boehm, Ralf Hinze, and Phong Vo (two Haskell programmers and two C/C++ programmers).
