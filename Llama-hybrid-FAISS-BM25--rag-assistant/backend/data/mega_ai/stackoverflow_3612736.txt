[site]: stackoverflow
[post_id]: 3612736
[parent_id]: 3612027
[tags]: 
Okay - first things first - using the term Aggregate implies you are adhering to DDD? If you are - you are doing an encapsulation no-no :-). One Aggregate should never be allowed to edit another Aggregate. If what you have is that both are really Aggregate they would become associated (which is perfectly 'legal' in a DDD-sense - but then your propety on the FooViewModel wouldn't be of type BarViewModel, but rather type Bar. That way Bar would (as it should) be responsible for updating itself - and we only maintain the link in FooViewModel. However, if what you are doing is AggregateRoot with a ValueType child - then here is what you could do given a slightly modified domain model: public class Foo { public string SomeProperty { get; set; } public Bar Bar { get; set; } public void Save() { //Magically saves to persistent storage... } } public class Bar { public Bar(string someOtherProperty) { SomeOtherProperty = someOtherProperty; } public string SomeOtherProperty { get; private set; } } And then for the ViewModels: public class FooViewModel { private Foo _foo; public FooViewModel() { Bar = new BarViewModel(); } public BarViewModel Bar { get; private set; } public void SetFoo(Foo foo) { _foo = foo; SomeProperty = foo.SomeProperty; Bar.SetBar(foo.Bar); } public string SomeProperty { get; set; } public void SaveChanges() { _foo.SomeProperty = SomeProperty; _foo.Bar = Bar.CreateUpdatedBar(); _foo.Save(); } } public class BarViewModel { public string SomeOtherProperty { get; set; } public void SetBar(Bar bar) { SomeOtherProperty = bar.SomeOtherProperty; } public Bar CreateUpdatedBar() { return new Bar(SomeOtherProperty); } } This way - the FooViewModel is now capable of controlling the BarViewModel (which does nothing but accept a valuetype - and create a new one when asked). This also solves a common UI-problem ('How do we edit an object that has no setters?' - answer: 'We don't - we create a new one'). A lot of fleshing out is missing (INotifyPropertyChanged, dirty-tracking etc., but those are easy if you get through this leap of thinking :-). I hope this makes a wee bit of sense :-) Otherwise, I'll be happy to elaborate.
