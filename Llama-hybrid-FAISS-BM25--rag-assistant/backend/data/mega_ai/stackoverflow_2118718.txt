[site]: stackoverflow
[post_id]: 2118718
[parent_id]: 2118422
[tags]: 
Stephan T. Lavavej, a member of the MSVC team, addresses the reality of this situation (and some of the refinements to the standard) in this comment on one of his blog postings ( http://blogs.msdn.com/vcblog/archive/2008/08/28/the-mallocator.aspx#8904359 ): > also, , , and std::size_t etc should be used! I used to be very careful about that. C++98 had a splendid dream wherein > would declare everything within namespace std, and would include and then drag everything into the global namespace with using-declarations. (This is D.5 [depr.c.headers].) This was ignored by lots of implementers (some of which had very little control over the C Standard Library headers). So, C++0x has been changed to match reality. As of the N2723 Working Paper, http://open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf , now is guaranteed to declare everything within namespace std, and may or may not declare things within the global namespace. is the opposite: it is guaranteed to declare everything within the global namespace, and may or may not declare things within namespace std. In reality and in C++0x, including is no safeguard against everything getting declared in the global namespace anyways. That's why I'm ceasing to bother with . This was Library Issue 456, http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456 . (C++0x still deprecates the headers from the C Standard Library, which is hilarious.) I'm in 100% agreement with Lavavej, except I never tried to be very careful about using the style headers even when I first started using C++ - the standard C ones were just too ingrained - and there was never any real world problem using them (and apparently there was never any real world benefit to using the style headers).
