[site]: stackoverflow
[post_id]: 389578
[parent_id]: 389528
[tags]: 
I recently had to do something similar on a personal project of mine, but never ended up actually using the feature I was writing it for, but here's the code I used: function refactor() { var array = jQuery.makeArray($('ul#remapped > li:not(.target)')); var mappedArray = jQuery.map(array, function(i) { var merged = $(i).find('ul.merge > li:not(.target) > span'); return { column: $(i).children('span').text(), merged: jQuery.map(jQuery.makeArray(merged), function(mi) { return { column: mi.innerText }; }) }; }); var xml = ' '; jQuery.each(mappedArray, function(index, item) { xml += '\n\t '; xml += '\n\t\t ' + item.column + ' '; if (item.merged.length > 0) { xml += '\n\t\t\t '; jQuery.each(item.merged, function(mindex, mitem) { xml += '\n\t\t\t\t ' + mitem.column + ' '; }); xml += '\n\t\t\t '; } xml += '\n\t '; }); xml += '\n '; $('div#result').load('/Tools/Csv/Refactor', { mapping: xml }); } Basically, the user would use the UI to drag and drop as they please to create the structure they want. Then, they click a button which executes this method. The $('ul#remapped') query is the element (in my code) that contained the new structure, and then I did some additional querying, again, based on my DOM structure, to extract the values I needed from the DOM and generate an XML string, which was then posted to the server. I'm sure this isn't exactly what you need, but I'm hoping its close enough that you can modify it for what you need.
