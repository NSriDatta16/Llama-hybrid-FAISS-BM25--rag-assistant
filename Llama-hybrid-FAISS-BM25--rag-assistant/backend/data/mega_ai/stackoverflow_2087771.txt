[site]: stackoverflow
[post_id]: 2087771
[parent_id]: 2087693
[tags]: 
As a basic approach, "all permutations" follow this recursive pattern: all permutations of a list L is: for each element E in L: that element prepended to all permutations of [ L with E removed ] If we take as given that you have no duplicate elements in your list, the following should do: (defun all-permutations (list) (cond ((null list) nil) ((null (cdr list)) (list list)) (t (loop for element in list append (mapcar (lambda (l) (cons element l)) (all-permutations (remove element list)))))))
