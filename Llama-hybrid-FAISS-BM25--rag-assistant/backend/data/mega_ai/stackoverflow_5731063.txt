[site]: stackoverflow
[post_id]: 5731063
[parent_id]: 5229561
[tags]: 
The problem is that the *.d Makefile-fragments generation must be performed after all the header generation is complete. Putting it this way, one can use the make dependencies to force the right order: SRCS := main.c foo.c HDRS := foo.h main: main.o foo.o %.o: %.c | generated_headers $(CC) -MMD -MG -MT '$@ $*.d' -c $ > $*.d rm $*.tmp -include $(SRCS:.c=.d) $(HDRS): mk_header.sh $* generated_headers: $(HDRS) clean: -rm $(HDRS) *.o *.d main .PHONY: clean generated_headers Notes: I use an order-only dependency . This solution is fairly scalable: Each generate-header rule, needs only to be a prerequisite of the generated_headers .PHONY target. Assuming that the header generation rule is written properly, once it has been generated correctly, satisfying the generated_headers target should be a no-op. One can't compile a single object, even if that object does not require any generated headers, without generating all the generated headers of the project first. While this is technically sound, your developers will complain. So you should think about having a FAST_AND_LOOSE flag, that will turn this feature off: %.o: %.c | $(if $(FAST_AND_LOOSE),,generated_headers) ... Thus a developer may issue: make FAST_AND_LOOSE=1 main.o
