[site]: stackoverflow
[post_id]: 4431638
[parent_id]: 4430388
[tags]: 
The address of the access violation is a very small positive offset from 0xcdcdcdcd Wikipedia says: CDCDCDCD Used by Microsoft's C++ debugging runtime library to mark uninitialised heap memory Here is the relevant MSDN page . The corresponding value after free is 0xdddddddd , so it's likely to be incomplete initialization rather than use-after-free. EDIT: James asked how optimization could mess up virtual function calls. Basically, it's because the currently standardized C++ memory model makes no guarantees about threading. The C++ standard defines that virtual calls made from within a constructor will use the declaring type of the constructor currently being run, not the final dynamic type of the object. So this means that, from the perspective of the C++ sequential execution memory model, the virtual call mechanism (practically speaking, a v-table pointer) must be set up before the constructor starts running (I believe the specific point is after base subobject construction in the ctor-initializer-list and before member subobject construction). Now, two things can happen to make the observable behavior different in a threaded scenario: First, the compiler is free to perform any optimization that would, in the C++ sequential execution model, act as-if the rules were being followed. For example, if the compiler can prove that no virtual calls are made inside the constructor, it could wait and set the v-table pointer at the end of the constructor body instead of the beginning. If the constructor doesn't give out the this pointer, since the caller of the constructor also hasn't received its copy of the pointer yet, then none of the functions called by the constructor can call back (virtually or statically) to the object under construction. But the constructor DOES give away the this pointer. We have to look closer. If the function to which the this pointer is given is visible to the compiler (i.e. included in the current compilation unit), the the compiler can include its behavior in the analysis. We weren't given that function in this question (the constructor and member functions of class task ), but it seems likely that the only thing that happens is that said pointer is stored in a subobject which is also not reachable from outside the constructor. "Foul!", you cry, "I passed the address of that task subobject to a library CreateThread function, therefore it is reachable and through it, the main object is reachable." Ah, but you do not comprehend the mysteries of the "strict aliasing rules". That library function does not accept a parameter of type task * , now does it? And being a parameter whose type is perhaps intptr_t , but definitely neither task * nor char * , the compiler is permitted to assume, for purposes of as-if optimization, that it does not point to a task object (even if it clearly does). And if it does not point to a task object, and the only place our this pointer got stored is in a task member subobject, then it cannot be used to make virtual calls to this , so the compiler may legitimately delay setting up the virtual call mechanism. But that's not all. Even if the compiler does set up the virtual call mechanism on schedule, the CPU memory model only guarantees that the change is visible to the current CPU core. Writes may become visible to other CPU cores in a completely different order. Now, the library create thread function ought to introduce a memory barrier that constrains CPU write reordering, but that fact that Koz's answer introducing a critical section (which definitely includes a memory barrier) changes the behavior suggests that perhaps no memory barrier was present in the original code. And, CPU write reordering can not only delay the v-table pointer, but the storage of the this pointer into the task subobject. I hope you have enjoyed this guided tour of one small corner of the cave of "multithreaded programming is hard".
