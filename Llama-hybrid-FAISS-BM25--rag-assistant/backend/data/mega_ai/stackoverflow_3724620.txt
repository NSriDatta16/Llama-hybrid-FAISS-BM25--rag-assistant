[site]: stackoverflow
[post_id]: 3724620
[parent_id]: 3724295
[tags]: 
You don't need smart matching here. The ~~ with a single regex on the right hand side and a string on the left hand side might as well be a =~, just like you have it. What are you trying to do? For your match, you have two ways to go. If you want to use a string as a pattern, you need to use the match operator: basename($subdir) =~ m/$regex/ If you want to not use the match operator, as you have it now, you need a regex object: my $regexes_to_filter_a = (qr/tmp/, qr/temp/, qr/del/); I guess you could match all the regexes at once. Note that if you are going to set maxdepth to 1, you don't really need File::Find::Rule. If you aren't going to walk a directory structure, don't use a module designed to walk a directory structure: my $regexes_to_filter_a = (qr/tmp/, qr/temp/, qr/del/); my @organism_dirs = (); foreach my $subdir ( glob( '*' ) ) { next unless -d $subdir; unless (basename($subdir) ~~ @regexes_to_filter_a) { push @organism_dirs, $subdir; } } I think all of that is too much work though. If you want to exclude known, static directory names (so, not patterns), just use a hash: my %ignore = map { $_, 1 } qw( tmp temp del ); my @organism_dirs = grep { ! exists $ignore{ basename($_) } } glob( "$rootdir/*" ); If you really want to use the smart match: my %ignore = map { $_, 1 } qw( tmp temp del ); my @organism_dirs = grep { basename($_) ~~ %ignore } glob( "$rootdir/*" );
