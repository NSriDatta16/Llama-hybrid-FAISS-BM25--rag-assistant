[site]: stackoverflow
[post_id]: 4051600
[parent_id]: 4051154
[tags]: 
You can do it with manifests without probing. Create "fake" assemblies - by defining .manifests, that contain the dlls. (No change is requried in the dll's for this) Since assembly support was added to NT 5.1 (Windows XP) the windows loader first looks for assemblies by scanning for a folder with the assemblies name. So, for example, if you need to distribute the Microsoft Visual C runtime for Visual C 2008 with your application, you could create a folder structure that looks like this: --> Application Folder --> Application.exe --> MyDll1.dll --> MyDll2.dll --> Microsoft.VC90.CRT --> Microsoft.VC90.CRT.manifest --> msvcr90.dll --> msvcp90.dll --> msvcm90.dll This same scheme would work for your 3rd party dlls. All you would then need to do would be to add the "fake" assemblies as dependent assemblies to your application's manifest (if your dlls have manifests, (and they access the 3rd party dlls) then their manifests will have to have entries too. The manifest files describing the assemblies need an assemblyIdentity, and a file node per dll: And your application, and dlls are built with MS Visual Studio 2005 or later, the following pragma directive would make your app look for the dlls in the assemblies: #pragma comment(linker, "/manifestDependency:\"name='Assembly Name' processorArchitecture='*' version='1.0.0.0' type='win32' \"")
