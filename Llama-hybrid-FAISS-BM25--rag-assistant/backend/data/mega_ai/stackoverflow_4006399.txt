[site]: stackoverflow
[post_id]: 4006399
[parent_id]: 4006309
[tags]: 
Thanks, Tim. Thanks to your answer, I was able to find the following at http://www.digitalmars.com/d/2.0/memory.html : Allocating Class Instances On The Stack Class instances are normally allocated on the garbage collected heap. However, if they: are allocated as local symbols in a function are allocated using new use new with no arguments (constructor arguments are allowed) have the scope storage class then they are allocated on the stack. This is more efficient than doing an allocate/free cycle on the instance. But be careful that any reference to the object does not survive the return of the function. class C { ... } scope c = new C(); // c is allocated on the stack scope c2 = new C(5); // allocated on stack scope c3 = new(5) C(); // allocated by a custom allocator If the class has a destructor, then that destructor is guaranteed to be run when the class object goes out of scope, even if the scope is exited via an exception. My code now reads scope t = new PerformanceCounter(); //On the stack This (allegedly) allocates on the stack and runs fine. :) Thanks again!
