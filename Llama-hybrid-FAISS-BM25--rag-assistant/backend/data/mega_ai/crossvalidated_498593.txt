[site]: crossvalidated
[post_id]: 498593
[parent_id]: 498552
[tags]: 
@Fiodor1234 (+1) has discussed some of the things that are unchanged by sorting. However, one way to check whether whether software is really giving a sequence of independent observations is to look at runs for discrete distributions and runs above and below the mean for continuous data. Sorting destroys information about runs. Here such a sample: set.seed(2020) x = rnorm(100) summary(x) Min. 1st Qu. Median Mean 3rd Qu. Max. -3.0388 -0.5620 0.1200 0.1089 0.7394 3.2016 d = sign(x-mean(x)); d d [1] 1 1 -1 -1 -1 1 1 -1 1 1 -1 1 1 -1 -1 1 1 -1 -1 -1 1 1 1 -1 1 [26] 1 1 1 -1 1 -1 -1 1 1 1 1 -1 -1 -1 1 1 -1 -1 -1 -1 1 -1 -1 1 1 [51] -1 1 -1 1 1 1 -1 -1 -1 1 1 1 -1 1 1 1 1 -1 -1 1 1 1 -1 -1 -1 [76] -1 -1 -1 -1 1 1 -1 1 1 -1 1 -1 1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 In R, the procedure rle (for Run Length Encoding) finds how many runs of 1 s and -1 s there are. And from that we can know the number $(46)$ of runs (of both kinds). rle(d) Run Length Encoding lengths: int [1:46] 2 3 2 1 2 1 2 2 2 3 ... values : num [1:46] 1 -1 1 -1 1 -1 1 -1 1 -1 ... length(rle(d)$val) [1] 46 Theoretical results about distributions of runs are available . However, we use a simulation below to get the distribution of such runs in a normal sample of $n=100.$ The number of runs averages about 51 with a SD of about 5. And 95% of run counts are between 41 and 61. (The distribution of the number of runs is approximately normal.) If a "randomly" generated normal distributed standard normal random samples do not have a number of runs above and below the mean between 41 and 61, it is fair to whether the generation process is random. In particular, the sample from seed 2020 above, with 46 such runs, seems OK. set.seed(1129) m = 10^5; nr.runs = numeric(m); n = 100 for(i in 1:m) { x = rnorm(n); d = sign(x-mean(x)) nr.runs[i] = length(rle(d)$val) } mean(nr.runs); sd(nr.runs) [1] 50.82255 [1] 4.967916 quantile(nr.runs, c(.025, .975)) 2.5% 97.5% 41 61 Of course if you sort a random sample, then it will have two runs. y = sort(rnorm(100)); d = sign(y-mean(y)) length(rle(d)$val) [1] 2 Notes: (1) Runs tests are not the only way to explore or test for lack of independence. See this Q&A for a brief introduction to autocorrelateion and associated tests and graphics. There is no point in finding autocorrelatiions for sorted data. (2) I trust the procedure rnorm in R because it has been extensively vetted, so it seems OK to use it to get the distribution of runs by simulation in R. See the link above to the Wald-Wolfowitz run test for theoretical details.
