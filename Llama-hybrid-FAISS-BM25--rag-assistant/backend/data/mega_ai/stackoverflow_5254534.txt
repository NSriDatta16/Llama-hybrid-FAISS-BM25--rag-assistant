[site]: stackoverflow
[post_id]: 5254534
[parent_id]: 5254021
[tags]: 
This may help you. Edit the regexp to match the digit patterns you're interested in. Mine will treat any digit fields containing . as floats. Uses swapcase() to invert your case so that 'A' sorts after 'a' . Updated : Refined: import re def _human_key(key): parts = re.split('(\d*\.\d+|\d+)', key) return tuple((e.swapcase() if i % 2 == 0 else float(e)) for i, e in enumerate(parts)) nums = ['9', 'aB', '1a2', '11', 'ab', '10', '2', '100ab', 'AB', '10a', '1', '1a', '100', '9.9', '3'] nums.sort(key=_human_key) print '\n'.join(nums) Output: 1 1a 1a2 2 3 9 9.9 10 10a 11 100 100ab ab aB AB Update : (response to comment) If you have a class Foo and want to implement __lt__ using the _human_key sorting scheme, just return the result of _human_key(k1) ; class Foo(object): def __init__(self, key): self.key = key def __lt__(self, obj): return _human_key(self.key) >> Foo('ab') >> Foo('AB') So for your case, you'd do something like this: def __lt__(self, other): column = self.treeWidget().sortColumn() k1 = self.text(column) k2 = other.text(column) return _human_key(k1) The other comparison operators ( __eq__ , __gt__ , etc) would be implemented in the same way.
