[site]: stackoverflow
[post_id]: 5196318
[parent_id]: 
[tags]: 
Reallocation of contiguous 2D array

I am generating contiguous 2d arrays using the method posted on here by Shawn Chin.[1][2] It works very well. Briefly from his post: char** allocate2Dchar(int count_x, int count_y) { int i; # allocate space for actual data char *data = malloc(sizeof(char) * count_x * count_y); # create array or pointers to first elem in each 2D row char **ptr_array = malloc(sizeof(char*) * count_x); for (i = 0; i And the following free function: void free2Dchar(char** ptr_array) { if (!ptr_array) return; if (ptr_array[0]) free(ptr_array[0]); free(ptr_array); } It is not obvious to me how to create an equivalent reallocate function in either dimension, though I am only interested in realloc'ing the number of rows while maintaining continuity. Growing the number of columns would be interesting to understand but probably quite difficult. I haven't found any direct discussion of this issue anywhere other than to say, "it's hard!".[2] Of course this is doable by a horrible brute force method, copying the data to a new 1D array (data, above) for storage, realloc'ing the 1D array, then freeing and regenerating the pointers (ptr_array) to the row elements for the new size. This, however, is pretty slow for row modifications, since it is necessary to at least double the memory requirement to copy out the data, and this is truly horribly bad for changing the number of columns. This is an example of said method for changing the number of rows (it wouldn't work properly for changing the number of columns because the offsets for the pointers would be wrong for the data). I haven't fully tested this, but you get the idea ... double ** reallocate_double_array (double **ptr_array, int count_row_old, int count_row_new, int count_col) { int i; int old_size = count_row_old * count_col; int new_size = count_row_new * count_col; double *data = malloc (old_size * sizeof (double)); memcpy (&data[0], &ptr_array[0][0], old_size * sizeof (double)); data = realloc (data, new_size * sizeof (double)); free (ptr_array[0]); free (ptr_array); ptr_array = malloc (count_row_new, sizeof (double *)); for (i = 0; i Plus, this method requires you know the previous size, which is obnoxious! Any thoughts greatly appreciated. [1] How can I allocate a 2D array using double pointers? [2] http://www.eng.cam.ac.uk/help/tpl/languages/C/teaching_C/node52.html
