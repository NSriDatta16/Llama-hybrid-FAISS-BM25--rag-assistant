[site]: stackoverflow
[post_id]: 837871
[parent_id]: 837649
[tags]: 
I've recently dome something similar using a single query and a single while loop. It uses references to build a tree data structures (array) by means of a flat one (array). There's no SPL involved because I don't felt there was a need for it. There's a gist on GitHub with a better color scheme :) /** * Each element in the return array has a 'data' key, holding category data, * like name, and a 'children' key holding its subcategories. * * @param resource $resource MySQL resource resulted from mysql_query * @param string $id_key Name of the 'id' field * @param string $parent_id_key Name of the 'parent_id' field * @param boolean $use_cache Use cached result from previous calls. Defaults to TRUE * @return array */ function categories($resource, $id_key, $parent_id_key, $use_cache = true) { // Cache the categories in a static local variable. This way, the query // will be executed just for the first function call. Subsequent calls // will return imediatelly, unless you tell it not to. static $tree = array(); if ($tree && $use_cache) { return $tree; } // Flat representation of the categories for fast retrieval using array // keys. Each element will be referenced in the $tree array. This // allows to build a tree data structure using a flat one. $flat = array(); // Reset the $tree, in case $use_cache=false in a subsequent call $tree = array(); while ($row = mysql_fetch_object($resource)) { $flat[$row->$id_key] = array( 'data' => $row, 'children' => array(), ); if (array_key_exists($row->$parent_id_key, $flat)) { // Assign children by reference so that possible subcategories of // this one will appear in the tree structure ($tree) $flat[$row->$parent_id_key]['children'][] =& $flat[$row->$id_key]; } if ($row->$parent_id_key == 0) { // Assign by reference for synchronizing $flat with $tree; $tree[] =& $flat[$row->$id_key]; } } return $tree; } Also, the function is decoupled from the structure of the database. You need to pass it a mysql_query resource, a string representing the id field and a string representing the parent_id field. The bad part is that it is coupled to the PHP mysql extension because it uses a call to mysql_fetch_object. It could probably be improved. Some other advantage is that it caches the result for consequent calls, unless you tell it to invalidate the cache, which is the fourth (boolean) parameter. Take a look and see if it helps you.
