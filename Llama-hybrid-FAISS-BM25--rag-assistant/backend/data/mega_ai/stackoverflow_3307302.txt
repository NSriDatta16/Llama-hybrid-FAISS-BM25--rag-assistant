[site]: stackoverflow
[post_id]: 3307302
[parent_id]: 
[tags]: 
ARG! Contravarience foils callback plot! Want to change virtual return type

I am working on a AI dynamic link library. It is to be explicitly linked and all of this is handled by a simple header include. I am at the moment trying to create the code for the DLL to be able to call functions in the main EXE to manipulate the world and also to be able to query functions to learn about the state of the world. I am now at the point where I can call void return functions (be they global functions or member functions) with no parameters. I am now trying to implement the ability to call functions in the EXE and get the return value from them. (non-void functions) Things are not going well.. I've been trying for a while now trying to find the best way to implement this. I can use boost libraries in the DLL but not in the EXE. I'm going to do a dump of the relavent code here. I know it is alot but I hope someone will be able to point out how I can improve. Even if you do not read the code (very understandable) it would be very helpful to know how you would go about tackling this problem in general terms. Here goes (I've tried to cut out as many unrelated sections of code as I can): ---------------------------------------EXE side header-------------------------------------- typedef void (*Command)(); typedef void (*CommandMF)(int, std::string); typedef void (*AddEntityFunction)(int&); typedef void (*AddActionToEntityFunction)(int, Command); typedef void (*AddActionToEntityFunctionMF)(int, CommandMF, std::string); typedef void (*UpdateDoubleThinkFunction)(); class MemberFunctionStorageExecute { public: virtual void Execute() const =0; }; template struct MemberFunctionStorage : MemberFunctionStorageExecute { typedef void (T::*MemberFunctionWorker)(); MemberFunctionWorker mbw; T *obj; virtual void Execute() const { (obj->*mbw)(); } }; typedef std::map MemberFunctionsList; typedef std::map ListofLists; //Template hack to allow static properties inside header template class DoubleThinkInterfaceImpl { protected: static HINSTANCE hinstDLL; static AddEntityFunction DLLAddEntity; static AddActionToEntityFunction DLLAddActionToEntity; static AddActionToEntityFunctionMF DLLAddActionToEntityMF; static UpdateDoubleThinkFunction DLLUpdateDoubleThink; static ListofLists m_plistlist; }; template HINSTANCE DoubleThinkInterfaceImpl ::hinstDLL; template AddEntityFunction DoubleThinkInterfaceImpl ::DLLAddEntity; template UpdateDoubleThinkFunction DoubleThinkInterfaceImpl ::DLLUpdateDoubleThink; template AddActionToEntityFunction DoubleThinkInterfaceImpl ::DLLAddActionToEntity; template AddActionToEntityFunctionMF DoubleThinkInterfaceImpl ::DLLAddActionToEntityMF; template ListofLists DoubleThinkInterfaceImpl ::m_plistlist; class DoubleThinkInterface : protected DoubleThinkInterfaceImpl { private: int m_pid; MemberFunctionsList m_pmemfunlist; public: int ID() { return m_pid; } DoubleThinkInterface() { if(!hinstDLL) { hinstDLL = LoadLibrary("DoubleThink.dll"); DLLAddEntity = (AddEntityFunction)GetProcAddress(hinstDLL, "AddEntity"); DLLUpdateDoubleThink = (UpdateDoubleThinkFunction)GetProcAddress(hinstDLL, "Update"); DLLAddActionToEntity = (AddActionToEntityFunction)GetProcAddress(hinstDLL, "AddActionToEntity"); DLLAddActionToEntityMF = (AddActionToEntityFunctionMF)GetProcAddress(hinstDLL, "AddActionToEntityMF"); } DLLAddEntity(m_pid); DoubleThinkInterface::m_plistlist.insert(std::pair (m_pid, &m_pmemfunlist)); } ~DoubleThinkInterface() { //if(hinstDLL != 0) // FreeLibrary(hinstDLL); } void AddAction(Command action) { DLLAddActionToEntity(m_pid, action); } void Update() { DLLUpdateDoubleThink(); } template void AddActionMF(T *object, void (T::*memberfunc)(), std::string actionName) { MemberFunctionStorage *store = new MemberFunctionStorage ; store->mbw = memberfunc; store->obj = object; m_pmemfunlist.insert(std::pair (actionName, store)); DLLAddActionToEntityMF(m_pid, &DoubleThinkInterface::ResolveMF, actionName); } static void ResolveMF(int idnum,std::string mfName) { ListofLists::iterator lit; lit = m_plistlist.find(idnum); MemberFunctionsList::iterator it; it = lit->second->find(mfName); it->second->Execute(); } }; -------------------------------EXE-side example------------------------------------ class BaseEntity { public: DoubleThinkInterface dtInterface; BaseEntity(){} virtual ~BaseEntity(){} }; class Humanoid : public BaseEntity { public: Humanoid(){} ~Humanoid(){} std::string name; void Move(); int GetAge(){return 10;} }; void Humanoid::Move() { std::cout name = "Bobby"; entity->dtInterface.AddAction(&EndLifeAsWeKnowIt); entity->dtInterface.AddActionMF (entity, &Humanoid::Move, "Move"); entity->dtInterface.Update(); int x; cin >> x; return 0; } -------------------------DLL-side code------------------------------------ DTEntityManager* DTEntityManager::Instance() { static DTEntityManager instance; return &instance; } template void AddAction(int id, void (*comm)(int, std::string), std::string mfid) { DTEntity *ent = DTEntityManager::Instance()->GetEntityFromID(id); CommandMemberFunction *newcomm = new CommandMemberFunction (); newcomm->comm = comm; newcomm->entityid = id; newcomm->mfid = mfid; ent->SetCommandMF(newcomm); } extern "C" { DLL_EXPORT void AddEntity(int &idnumber) { DTEntity *entity = new DTEntity(); idnumber = entity->ID(); DTEntityManager::Instance()->RegisterEntity(entity); } DLL_EXPORT void AddActionToEntity(int id, void (*comm)()) { DTEntity *ent = DTEntityManager::Instance()->GetEntityFromID(id); CommandGlobal *newcomm = new CommandGlobal (); newcomm->comm = comm; ent->SetCommand(newcomm); } DLL_EXPORT void AddActionToEntityMF(int id, void (*comm)(int, std::string), std::string mfid) { AddAction (id, comm, mfid); } DLL_EXPORT void AddActionToEntityMF_int(int id, void (*comm)(int, std::string), std::string mfid) { AddAction (id, comm, mfid); } } --------------------------DLL-side Structure for holding callbacks --------------------------- class CommandBase { public: virtual void Execute() const =0; }; template struct CommandGlobal : CommandBase { typedef boost::function Command; Command comm; virtual T Execute() const { return comm(); } }; template struct CommandMemberFunction : CommandBase { typedef boost::function Command; Command comm; int entityid; std::string mfid; virtual T Execute() const { return comm(entityid, mfid); } }; At the moment the DLL doesn't compile because of this line: AddAction (id, comm, mfid); Because it tries to override virtual void Execute() const =0; with a function which returns int. Gives non-covariance error.. I know I have been barking up the wrong tree but I can't see any other solution at the moment either. Does anyone have any advice on how to do it better? Even if it just a vague direction I should direct my attention in I would appreciate it. Thanks a lot if you bother to read all this!
