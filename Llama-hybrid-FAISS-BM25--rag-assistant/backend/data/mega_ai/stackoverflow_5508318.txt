[site]: stackoverflow
[post_id]: 5508318
[parent_id]: 5508312
[tags]: 
Edit: the code fragments below no longer apply as the question changed several times. That it compiles is surprising, unless there's a forward reference or other type information for ChildStructure somewhere. A pure forward reference should not compile, either, as there's no size information available to the compiler to allocate the correct amount of space for ParentStructure without it. struct ChildStructure { int A; int B; }; struct ParentStructure { struct ChildStructure A; struct ChildStructure B; struct ChildStructure C; struct ChildStructure D; }; This code compiles. Is it possible that you are passing the structures to functions "by value" instead of "by reference"? If you are passing them by reference, then is it possible the compiler is seeing two different definitions of the types ParentStructure or ChildStructure , and therefore making potential data-hash of your program's execution? The behavior you are seeing would be immediately explained by passing the structures "by value" to a function to operate upon. void ChangeAB( ChildStructure child ) { child.A = 3; child.B = 4; } void ChangeABByReference( ChildStructure& child ) { child.A = 3; child.B = 4; } int main(int argc, char *argv[]) { ParentStructure parent; parent.A.A = 0; parent.A.B = 2; ChangeAB(parent.A); // check values after returning from ChangeAB() ChangeABByReference(parent.A); // check values after returning - this time they should stick. }
