[site]: stackoverflow
[post_id]: 3797719
[parent_id]: 3797695
[tags]: 
I think that boost::thread is your best bet. It's throughly tested, and the std::thread is based on it. You should just keep in mind the different areas and try to deal with them the best you can. As specified here : The design of this thread is an evolution from boost::thread. The intent is to reuse as much of the boost::thread experience as possible, keeping the good, and changing the very minimum necessary to respond to the known limitations of this field experience. boost's non-copyable, one-handle-maps-to-one-os-thread, semantics are retained. But this thread is movable to allow returning thread from factory functions and placing into containers. This proposal adds cancellation to the boost::thread, which is a significant complication. This change has a large impact not only on thread but the rest of the C++ threading library as well. It is believed this large change is justifiable because of the benefit. The thread destructor must now call cancel prior to detaching to avoid accidently leaking child threads when parent threads are canceled. An explicit detach member is now required to enable detaching without canceling. The concepts of thread handle and thread identity have been separated into two classes (they are the same class in boost::thread). This is to support easier manipulation and storage of thread identity. The ability to create a thread id which is guaranteed to compare equal to no other joinable thread has been added (boost::thread does not have this). This is handy for code which wants to know if it is being executed by the same thread as a previous call (recursive mutexes are a concrete example). There exists a "back door" to get the native thread handle so that clients can manipulate threads using the underlying OS if desired.
