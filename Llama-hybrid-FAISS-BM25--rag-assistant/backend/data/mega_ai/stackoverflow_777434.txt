[site]: stackoverflow
[post_id]: 777434
[parent_id]: 776960
[tags]: 
The first rule of operators overloading: do not overload operators that make no sense. For instance, the + operator may look like a good choice to append elements to lists, but it is not: not everybody would find this use logical. Regarding the mathematical operators, friend is unneeded. The typical way to define them (that respects symmetries and implicit conversions) is the following one: struct T { T& operator+=(T const& rhs) { // the actual addition code return *this; } }; T const operator+(T const& lhs, T const& rhs) { return T(lhs) += rhs; }; However, this organization is not adapted to operators like Matrix or Polynomial multiplication as the *=(T const&) operator is not that trivial. In that case, we would define operator*=(T const&) on top of operator*(T const&, T const&) , and the binary operator*() could be made friend if there is no accessor to the internal data -- this use of friend is not an encapsulation violation, but an encapsulation enforcement --, or for optimization purposes. If you really want to eliminate most temporaries, have a look at expression templates (see Blitz++, boost.ublas, newmat, ...), or wait for C++0x rvalue references.
