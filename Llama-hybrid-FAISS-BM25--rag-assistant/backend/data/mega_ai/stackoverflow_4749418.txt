[site]: stackoverflow
[post_id]: 4749418
[parent_id]: 
[tags]: 
Finding combinations of stems and endings

I have mappings of "stems" and "endings" (may not be the correct words) that look like so: all_endings = { 'birth': set(['place', 'day', 'mark']), 'snow': set(['plow', 'storm', 'flake', 'man']), 'shoe': set(['lace', 'string', 'maker']), 'lock': set(['down', 'up', 'smith']), 'crack': set(['down', 'up',]), 'arm': set(['chair']), 'high': set(['chair']), 'over': set(['charge']), 'under': set(['charge']), } But much longer, of course. I also made the corresponding dictionary the other way around: all_stems = { 'chair': set(['high', 'arm']), 'charge': set(['over', 'under']), 'up': set(['lock', 'crack', 'vote']), 'down': set(['lock', 'crack', 'fall']), 'smith': set(['lock']), 'place': set(['birth']), 'day': set(['birth']), 'mark': set(['birth']), 'plow': set(['snow']), 'storm': set(['snow']), 'flake': set(['snow']), 'man': set(['snow']), 'lace': set(['shoe']), 'string': set(['shoe']), 'maker': set(['shoe']), } I've now tried to come up with an algorithm to find any match of two or more "stems" that match two or more "endings". Above, for example, it would match down and up with lock and crack, resulting in lockdown lockup crackdown crackup But not including 'upvote', 'downfall' or 'locksmith' (and it's this that causes me the biggest problems). I get false positives like: pancake cupcake cupboard But I'm just going round in "loops". (Pun intended) and I don't seem to get anywhere. I'd appreciate any kick in the right direction. Confused and useless code so far, which you probably should just ignore: findings = defaultdict(set) for stem, endings in all_endings.items(): # What stems have matching endings: for ending in endings: otherstems = all_stems[ending] if not otherstems: continue for otherstem in otherstems: # Find endings that also exist for other stems otherendings = all_endings[otherstem].intersection(endings) if otherendings: # Some kind of match findings[stem].add(otherstem) # Go through this in order of what is the most stems that match: MINMATCH = 2 for match in sorted(findings.values(), key=len, reverse=True): for this_stem in match: other_stems = set() # Stems that have endings in common with this_stem other_endings = set() # Endings this stem have in common with other stems this_endings = all_endings[this_stem] for this_ending in this_endings: for other_stem in all_stems[this_ending] - set([this_stem]): matching_endings = this_endings.intersection(all_endings[other_stem]) if matching_endings: other_endings.add(this_ending) other_stems.add(other_stem) stem_matches = all_stems[other_endings.pop()] for other in other_endings: stem_matches = stem_matches.intersection(all_stems[other]) if len(stem_matches) >= MINMATCH: for m in stem_matches: for e in all_endings[m]: print(m+e)
