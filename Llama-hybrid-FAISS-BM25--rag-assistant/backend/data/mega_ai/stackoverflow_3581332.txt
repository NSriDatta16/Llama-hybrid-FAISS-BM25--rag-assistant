[site]: stackoverflow
[post_id]: 3581332
[parent_id]: 21449
[tags]: 
Philibert said, bits were actually inverted I doubt any architecture would break byte value invariance. The order of bit-fields may need inversion when mapping structs containing them against data. Such direct mapping relies on compiler specifics which are outside the C99 standard but which may still be common. Direct mapping is faster but does not comply with the C99 standard that does not stipulate packing, alignment and byte order. C99-compliant code should use slow mapping based on values rather than addresses. That is, instead of doing this, #if LITTLE_ENDIAN struct breakdown_t { int least_significant_bit: 1; int middle_bits: 10; int most_significant_bits: 21; }; #elif BIG_ENDIAN struct breakdown_t { int most_significant_bits: 21; int middle_bits: 10; int least_significant_bit: 1; }; #else #error Huh #endif uint32_t data = ...; struct breakdown_t *b = (struct breakdown_t *)&data; one should write this (and this is how the compiler would generate code anyways even for the above "direct mapping"), uint32_t data = ...; uint32_t least_significant_bit = data & 0x00000001; uint32_t middle_bits = (data >> 1) & 0x000003FF; uint32_t most_significant_bits = (data >> 11) & 0x001fffff; The reason behind the need to invert the order of bit-fields in each endian-neutral, application-specific data storage unit is that compilers pack bit-fields into bytes of growing addresses. The "order of bits" in each byte does not matter as the only way to extract them is by applying masks of values and by shifting to the the least-significant-bit or most-significant-bit direction. The "order of bits" issue would only become important in imaginary architectures with the notion of bit addresses. I believe all existing architectures hide this notion in hardware and provide only least vs. most significant bit extraction which is the notion based on the endian-neutral byte values.
