[site]: stackoverflow
[post_id]: 2682166
[parent_id]: 2675793
[tags]: 
Consider "playing" the HTTP protocol a bit to get what you want while still being able to go over all of the proxies and NAT's and firewalls one might have on the client side. Have every single client do a plain HTTP request for the message count in a way that would inhibit any sort of caching (example: GET http://yourserver.org/getcount/nodeid/timeofday/sequence ). In the server-side implementation of the HTTP server delay providing the answer if the "count" is the same it used to be (ie: no new messages). I've done this for a Ajax-style application that ran in a browser and behaved a bit like a chat application, but your solution can be even faster. I implemented the server side stuff using the TIdHttp server and that allowed me to actually delay providing the answer to the client stuff by simply Sleep()-ing in it's thread. From the client side it looked like an server that's sometimes really slow to give an answer. Pseudocode for the server-side stuff: function ClientHasMessages(ClientID:Integer; MaxWait:TDateTime):Boolean; var MaxTime:TDateTime; begin if ClientActuallyHasMessage(ClientID) then Result := True else begin MaxTime := Now + MaxWait; while Now The idea behind this code: It runs in a thread on your own server, where it can test the message count, presumably, for very little cost: It causes no network traffic while waiting. It uses no CPU while Sleeping. It will let the user know about it's message very quickly. It lets the client control how long the wait might be (the client will increase the amount of time the server may delay the answer until it no longer receives the answer, and then step back a bit - that way the protocol adapts to whatever buggy NAT router the client uses). You can get away with long periods of no TCP/IP communications and still being able to provide the answer instantly. 30 seconds is easily done and for clients with good NAT routers it can be much longer. The down size of this would be the requirements on the server, but I'm tempted to say they're doable: The server's TCP/IP implementation needs to track quite an number of simultaneous connections (every client will have a HTTP request active at all times). My Linux NAT machine is tracking 15K connections right now and it's basically idle, so it might work. The server would have an thread open for every single client HTTP request, at all times: Again, the Server 2008 "Workstation" I'm using to write this (thank you MSDN for allowing me to do such outrageous things) has about 1500 threads active and it's also basically idle... Depending on the technology you use for the server-side code MEMORY might be the limiting factor.
