[site]: stackoverflow
[post_id]: 3322538
[parent_id]: 
[tags]: 
Multipe Send()'s and Recv()'s using Winsock2

I am working on a small networking project using Winsock2. I am using a TCP connection and actually am working with IRC as an example since IRC is fairly simple. What I am doing is connecting to the server and sending an initial buffer so the server recognizes a connection. This works fine. What concerns me is that I cannot write to the socket again. It seems my program hangs if I do not use shutdown() (on SD_SEND) after I send the initial buffer. So the next data (based on RFC 1459) I want to send is the USER and NICK information, however, I feel like using shutdown() is what is causing my current issue. Is there a way to reinitialize the write socket? Thanks! ADDED CODE Note that these are located within a class so it still may be slightly obscured. I am writing it into a simpler example using the elements I have. Everything is properly defined, so if I forget to define things, I apologize, but many of my recurring variables are defined for the scope of the class. int main(int argc,char *argv[]) { int iResult; SOCKET Connection; iResult = WSAStartup(MAKEWORD(2,2), &wsaData); if(iResult != 0) throw "Startup failed!"; // Prep stuff ZeroMemory(&hints,sizeof(hints)); // This struct is defined addrinfo hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; hints.ai_protocol = IPPROTO_TCP; // Now resolve server addr iResult = getaddrinfo(argv[1],argv[2],&hints,&result); if(iResult != 0) throw "getaddrinfo() failed!"; // Now try to connect for(ptr=result;ptr != NULL;ptr = ptr->ai_next) { Connection = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol); // defined in that "hints" struct. argument number 2 if(Connection == INVALID_SOCKET) { freeaddrinfo(result); WSACleanup(); throw "Error at socket();"; } // Connect to server iResult = connect(Connection, ptr->ai_addr, (int)ptr->ai_addrlen); if(iResult != 0) { closesocket(Connection); Connection = INVALID_SOCKET; continue; } break; } freeaddrinfo(result); // Send initial buffer so server know you're there :) iResult = send(Connection, "", 1, 0); if(iResult == SOCKET_ERROR) { close(); throw "Could not send initial buffer!"; } // Close this connection for the inital buffer iResult = shutdown(Connection, SD_SEND); if(iResult == SOCKET_ERROR) { close(); throw "Could not close initial buffer socket!"; } bool connected = true; // This is taken from my read function within the class // BEGIN READ FUNCTION iResult = 0; // Reset std::string data = ""; // Capture the output and send it all at once! // This only works if we're connected sweet cakes 0) { // Working properly // Save all data even if there is more than BUFLEN sent continue; } else if(iResult == 0) // Connection closed properly break; else printf("ERROR!"); } while(iResult > 0); } data += recvbuf; ZeroMemory(&recvbuf,sizeof(recvbuf)); // Function returns std::string but essentially this is what happens printf("%s",data.c_str()); // END READ FUNCTION // BEGIN WRITE FUNCTION iResult = 0; // Reset SOCKET socket = Connection; // Write function arg 1 char *data; // Write function arg 2 iResult = send(socket,data,(int)strlen(data),0); if(iResult == SOCKET_ERROR) { close(); printf("Could not write data: %ld",WSAGetLastError()); return 1; } // Data sent, let's close the write socket iResult = shutdown(socket, SD_SEND); if(iResult != 0) { close(); printf("Could not close write socket!"); return 1; } //return iResult; // END WRITE FUNCTION // Now that will produce "Could not write data: 0" for any value of data // So realistically I want to send the USER and NICK data, then read // and probably process a PING string from the server and send my PONG response return 0; } I hope that clarifies things! EDIT I think I have figured out what is going wrong. I made the corrections listed below to my code; thanks guys. However, it's my read loop which is messing with things. Even after it has all the information it seems that it is waiting for the connection to be closed before it sends the output. Any ideas? My output currently looks like this (the bytes written/total is something I added to make sure everything was going down the wire correctly) Bytes Written: 41 Bytes Total: 41 Data: ERROR :Closing Link: raged123[127.0.0.1] 6667 (Ping timeout) ... :irc.foonet.com NOTICE AUTH :*** Found your hostname (cached) PING :2ED39CE5 [A bunch of funny characters]WinSock 2.0 So it appears to have timed out because the PING did not receive PONG in time, however, I cannot send the PONG without first processing the PING request which means I would need to be able to read the output before the connection is closed. Any ideas?
