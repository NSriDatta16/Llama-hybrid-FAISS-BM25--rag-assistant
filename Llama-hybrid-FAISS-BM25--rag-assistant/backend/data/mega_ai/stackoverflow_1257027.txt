[site]: stackoverflow
[post_id]: 1257027
[parent_id]: 1256788
[tags]: 
This is a very difficult issue to resolve, whether your implementation language is object oriented or not (and in any case object methodologies can usually be applied regardless of whether to programming language supports them as a language construct, so I have described my solution in terms of objects) What you would like to be able to do is treat all data storage equivilantly. In reality this is almost impossible and you must choose a paradigm and accept it's limts. For instance it is possible to base the design of your abstraction upon an RDBMS paradigm (connect/query/fetch) and attempt to encapsulate access to files withion the same interface. An approach I have used with success is to avoid embedding the retrieval of data within (in your case) the Employee "object" as this creates a coupling that is to close between the abstraction of the Employee within the program and the storage and retrival of it's data. Instead I create a seperate object, responsible for retrieving the data to construct the Employee object, and in turn construct the Employee object from that data. I can now construct an Employee from any data source provided I can translate the data into an appropriately generic structure. (I have the advantage of language support for associative arrays, which simplifies the process of passing tuples around considerably, you may have trouble if your development language makes it difficult or impossible to do this). This also make the application easier to test, since I can construct the Employee "object" directly within my unit test without having to worry about creating the data source (or whether the data that was there last time is still there). In a complex design this setup and tear down can account for the majority of the test code. In addition, should the need arise to create 1000 Employee "objects" I can re-use my code without having to query my datasource (file, db, card index etc) 1000 times (in other words it neatly solves the famous ORM N+1 query problem). So to summarise, seperate data retrival from business logic entirely as the hidden dependency you describe has some very nasty pitfalls. IMHO it is an anti-pattern to encapsulate retrieval of specific data within the construction of an "object" or within a function to retrieve a property from some stored data.
