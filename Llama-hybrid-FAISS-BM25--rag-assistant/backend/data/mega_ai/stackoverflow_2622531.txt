[site]: stackoverflow
[post_id]: 2622531
[parent_id]: 2622421
[tags]: 
Let's say you want a function that you can use to return a unique "id" value to use when you create new DOM elements. Now, in something like Java, you could create a class with an internal private counter, and then have a method that appends the counter to some prefix string. Well, in Javascript: var getId = (function() { var counter = 0; return function() { return "prefix" + counter++; }; })(); Now the variable "getId" is bound to a function that's created by another function, and created in such a way that it has a persistent variable to use between invocations. Similarly, if I wanted to have a family of "getId" functions (say, one for each type of DOM element I might add), I could do this: var getIdFunc = function(prefix) { var counter = 0; return function() { return prefix + counter++; }; }; var getId = { 'div': getIdFunc('div'), 'span': getIdFunc('span'), 'dl': getIdFunc('dl'), // ... }; Now I can call getId.div() to get a new "id" value for a new . The function was created by calling a function that provides two values stashed away in a closure: the prefix string (passed in as an argument) and the counter (a var declared in the closure scope). Once you get used to it, the facility is so flexible and useful that you'll feel pain at moving back to an environment without it. Oh, and here's a tip to help keep you off StackOverflow should you try this out: it's an issue that pops up all the time: for (var i = 0; i What's the problem here? Well, that "i" variable that's referenced by that function is the "i" from the scope in which that loop runs. That variable, you'll note, gets incremented through the loop (duhh, right?). Well, every single one of those little functions created and assigned as event handlers will share that same, single variable "i" in the closure scope. Oops! The solution is to do something like this: for (var i = 0; i We make a copy of the outer "i" into a closure scope of its own, so now each event handler has its own! To summarize: the technique of leveraging closures comes up all the freaking time once you get used to it. It's not a free ticket into a new wonderland of error-free programming; don't get me wrong. It is, however, a very useful and flexible paradigm.
