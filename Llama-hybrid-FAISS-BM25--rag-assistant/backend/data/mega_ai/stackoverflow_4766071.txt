[site]: stackoverflow
[post_id]: 4766071
[parent_id]: 
[tags]: 
Observer pattern in c++

I am having a bit of trouble with observer pattern I have a beverage class that uses decorator fine. I am trying to implement observer to let an observer( say a cell phone/text message) in this case know when there order is done. i wont include the beverage/decorator classes since they work fine. In main i was going to do something like this: Subject mySubject = new Subject(); Observer myObserver1 = new Observer1(); Observer myObserver2 = new Observer2(); // register observers mySubject.Register(myObserver1); mySubject.Register(myObserver2); mySubject.Notify("message 1"); mySubject.Notify("message 2"); I have a subject class, observer, phone behavior class and a cellhone1,cellphone2 classes.. Here is the subject class #ifndef _SUBJECT_ #define _SUBJECT_ //#include "Starbuzz.h" //#include "Starbuzz2.h" #include "Observer.h" #include namespace CoffeeHouse { namespace Observers { class Subject { private: std::list observers; public: Subject(); ~Subject(); void Subject::Register(Observer observer) { //if (!observers.(observer)) //{ observers.insert(observer); } //} //void Unregister(Observer observer) //{ // if observer is in the list, remove //if (observers.Contains(observer)) //{ //observers.Remove(observer); //} //} void Notify(std::string message) { //need loop Observer observer; observer.update(message); } //} //} //void Subject::registerObserver( Observer* o ) { assert( o ); //_observers.push_front(o); //} //void Subject::removeObserver( Observer* o ) { assert( o ); // _observers.remove(o); //} //void Subject::notifyObservers() const { //for( std::list ::iterator iterator = _observers.begin(); _observers.end() != iterator; ++iterator ) { //Observer* observer = *iterator; //observer->update(message); //} //} }; } // namespace Observer } #endif Here is the observer class #ifndef _OBSERVER_ #define _OBSERVER_ #include namespace CoffeeHouse { namespace Observers { class Subject; class Observer { //public: virtual ~Observer() = 0; public: virtual void Update(std::string message) = 0; }; here is the phone behavior class #ifndef _PHONEBEHAVIOR_ #define _PHONEBEHAVIOR_ namespace CoffeeHouse { namespace Observer { class PhoneBehavior { public: virtual void Update() const = 0; }; protected: virtual ~PhoneBehavior() = 0 { }; }; } // namespace Observer } // here is cellphone 1 #ifndef _CELLPHONE1_ #define _CELLPHONE1_ namespace CoffeeHouse { namespace Observer { include class CellPhone1: public Observer, public PhoneBehavior { public: CellPhone1(); ~CellPhone1(); virtual void Update(std::string message) { std::cout here re the errors i am getting.. error C2259: 'CoffeeHouse::Observers::Observer' : cannot instantiate abstract class 1> due to following members: 1> 'void CoffeeHouse::Observers::Observer::update(std::string)' : is abstract see declaration of 'CoffeeHouse::Observers::Observer::update' error C2661: 'std::list ::insert' : no overloaded function takes 1 arguments with[_Ty=CoffeeHouse::Observers::Observer * error C2259: 'CoffeeHouse::Observers::Observer' : cannot instantiate abstract class due to following members: 'void CoffeeHouse::Observers::Observer::update(std::string)' : is abstract observer.h(15) : see declaration of 'CoffeeHouse::Observers::Observer::update When i click on error "cannot instantiate abstract class" it takes me to: void Subject::Register(Observer observer) I understand that Abstract classes are made such that they cannot be instantiated! How could i do an update then?? any suggestions of a better way? I appreciate any help!
