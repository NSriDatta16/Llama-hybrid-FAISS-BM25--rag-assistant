[site]: stackoverflow
[post_id]: 397796
[parent_id]: 397301
[tags]: 
Hmm. You should distinguish between arrays and associative arrays. arrays: A=[0,1,4,9,16]; associative arrays: B={a:'ha',b:27,c:30}; The former has a length, the latter does not. When I run this in a javascript shell, I get: js>A=[0,1,4,9,16]; 0,1,4,9,16 js>A instanceof Array true js>A.length 5 js>B={a:'ha',b:27,c:30}; [object Object] js>B instanceof Array false js>B.length js> How arrays "work" in Javascript is implementation-dependent. (Firefox and Microsoft and Opera and Google Chrome would all use different methods) My guess is they (arrays, not associative arrays) use something like STL's std::vector . Your question: how is memory allocated for an array to still provide a O(1) access time since the 'amount' of memory locations is not specified beforehand ? is more along the lines of how std::vector (or similar resizable arrays) works. It reallocates to a larger array as necessary. Insertions at the end take amortized O(1) time, namely if you insert N elements where N is large, the total time takes N*O(1). Those individual inserts where it does have to resize the array may take longer, but on the average it takes O(1).
