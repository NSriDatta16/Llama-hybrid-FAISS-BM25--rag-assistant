[site]: stackoverflow
[post_id]: 3574411
[parent_id]: 3574208
[tags]: 
Have access to the C++ library source The cleanest way is to use C++ Interop to create a wrapper as a mixed mode assembly. This allows you to use the pragmas managed and unmanaged to switch between native and managed code. This way you can nicely wrap your C++ class with a managed C++ wrapper and call it from (of course) managed C#. Be aware this won't work under Mono. Don't have access to the C++ library source, but know a bit of C++? You can write a small managed wrapper in managed C++ to call the unmanaged C++ library due to C++'s unique ability to call COM natively. This is done using custom runtime callable wrappers, or CRCWs . You can then call your managed wrapper directly from C# using native .Net types and all. Benefits of this (as stated by MSDN): The interop code is built into the application, so there is no dependency on a separate assembly. Also, the exposed managed interface is customized to be more .NET-like. For example, the RenderFile method takes a System.String instead of a char*. The managed version of the COM interface is called a Custom Runtime Callable Wrapper (CRCW). Don't have access to the C++ library source and don't know C++? Then you are stuck with C++ COM Interop which is a bit more messy. You'll need to generate a wrapper using Tlbimp.exe . It's messy because: Types that don't have a direct match in managed code are exposed as IntPtr pointer types (quite difficult to handle in C#) The resulting assemlblies will be very large as interfaces for everything in the library are generated (not just the stuff you want). You'll have to deloy an additional assembly with your application and manage versioning etc...
