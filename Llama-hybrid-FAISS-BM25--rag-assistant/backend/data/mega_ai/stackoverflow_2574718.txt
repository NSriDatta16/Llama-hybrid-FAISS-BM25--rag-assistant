[site]: stackoverflow
[post_id]: 2574718
[parent_id]: 2574654
[tags]: 
The way I see it, you have a few options, depending on your skills, the way you are allowed to change the current POCO's or other classes: If you must use a dictionary, create a similar dictionary which maps the "0D" etc to the OneDay names. Loop through the dictionary and assign using simple reflection. If you can change the way the data is read, have the dictionary read with OneDay etc, instead of the "0D", which is only applicable to the external application. Create an attribute, LegacyKeyAttribute , augment your POCO gettors/settors with this attribute. Now it becomes trivial: loop through the properties of the POCO to find the correct property for your current legacy key. The last option requires a bit more understanding of C# than many average programmers know: writing and using attributes and reflection. However, in the end it's the cleanest and easiest solution (I'll try to come up with an example). UPDATE: here's a little example. Meanwhile, many improvement suggestions have been posted, but none still uses attributes, while your case seems ideal. Why? It poses the least burden on existing code, I believe, and it makes reading and understanding your code even easier. Usage: // any price: Prices prices = new Prices(); prices.SetPriceByLegacyName("0D", 1.2345M); // or, your loop becomes a bit easier: SetPricesValues(IDictionary pricesDictionary) { foreach(string key in pricesDictionary.Keys) { // assuming "this" is of type Prices (you didn't specify) this.SetPriceByLegacyName(key, pricesDictionary[key]); } } The implementation: // the simplest attribute class is enough for you: [AttributeUsage(AttributeTargets.Property)] public class LegacyNameAttribute : Attribute { public string Name { get; set; } public LegacyNameAttribute(string name) { this.Name = name; } } // your Prices POCO class becomes easier to read public class Prices { [LegacyName("0D")] public decimal Today { get; set; } [LegacyName("1D")] public decimal OneDay { get; set; } [LegacyName("6D")] public decimal SixDay { get; set; } [LegacyName("10D")] public decimal TenDay { get; set; } [LegacyName("12D")] public decimal TwelveDay { get; set; } [LegacyName("1DA")] public decimal OneDayAdjusted { get; set; } [LegacyName("6DA")] public decimal SixDayAdjusted { get; set; } [LegacyName("10DA")] public decimal TenDayAdjusted { get; set; } [LegacyName("100DA")] public decimal OneHundredDayAdjusted { get; set; } } // an extension method to ease the implementation: public static class PricesExtensions { public static void SetPriceByLegacyName(this Prices price, string name, decimal value) { if (price == null) throw new ArgumentException("Price cannot be null"); foreach (PropertyInfo prop in price.GetType().GetProperties()) { LegacyNameAttribute legNameAttribute = (LegacyNameAttribute) Attribute.GetCustomAttribute(prop, typeof(LegacyNameAttribute)); // set the property if the attribute matches if (legNameAttribute != null && legNameAttribute.Name == name) { prop.SetValue(price, value, null); break; // nothing more to do } } } } That's all there is to it. Even with all the added lines, it may well be that your total line count becomes less. But more importantly, it becomes easier to maintain and use.
