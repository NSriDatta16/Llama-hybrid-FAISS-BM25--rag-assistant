[site]: stackoverflow
[post_id]: 3375472
[parent_id]: 3375459
[tags]: 
WIN32_FIND_DATA is a struct. Check out the cFileName member. For example: WIN32_FIND_DATA FindData = {0}; HANDLE hFind = FindFirstFile(pszPattern, &FindData); if (hFind != INVALID_HANDLE_VALUE) { do { PTSTR pszFileName = FindData.cFileName; // TODO: Use pszFileName in some way... } while (FindNextFile(hFind, &FindData)); FindClose(hFind); } Update in response to comments In this example the storage for the string is on the stack, and the same buffer is used for every call. This means that every FindNextFile() overwrites the previous string. You will have to make a copy of the string. Since you're using C++ and classes in std I suggest you store it in std::string (or better yet, make sure you define UNICODE and _UNICODE and use wstring .) Initializing a new string class will do the allocation and copying on your behalf. Alternatively you can copy the string using the typical C techniques (for example: using malloc + memcpy , strdup , or similar), but it sounds like you might want a refresher in strings, pointers, and memory allocation in C before you get to that. By the way -- to check for error, your code compares the find handle against NULL ; this is incorrect. FindFirstFile() returns INVALID_HANDLE_VALUE (which works out to (HANDLE)-1 ) on failure. Additionally, to close the handle you will want to use FindClose() , and not CloseHandle() . (A "find handle" isn't really a handle to a kernel object in the same sense that a file handle, handle to a module, or a thread or process handle is. They've just overloaded the type.)
