[site]: stackoverflow
[post_id]: 4686781
[parent_id]: 4686672
[tags]: 
Normally, you should try to lock the pthread mutex before waiting on the condition object as the pthread_cond_wait call release the mutex (and reacquire it before returning). So, your check_flag function should be rewritten like that to conform to the semantic on the pthread condition. void check_flag(foo_t* f) { pthread_mutex_lock(&f->m); while(f->flag) pthread_cond_wait(&f->c, &f->m); pthread_mutex_unlock(&f->m); } Concerning the question of whether or not the compiler is allowed to optimize the reading of the flag field, this answer explains it in more detail than I can. Basically, the compiler know about the semantic of pthread_cond_wait , pthread_mutex_lock and pthread_mutex_unlock . He know that he can't optimize memory reading in those situation (the call to pthread_cond_wait in this exemple). There is no notion of memory barrier here, just a special knowledge of certain function, and some rule to follow in their presence. There is another thing protecting you from optimization performed by the processor. Your average processor is capable of reordering memory access (read / write) provided that the semantic is conserved, and it is always doing it (as it allow to increase performance). However, this break when more than one processor can access the same memory address. A memory barrier is just an instruction to the processor telling it that it can move the read / write that were issued before the barrier and execute them after the barrier. It has finish them now.
