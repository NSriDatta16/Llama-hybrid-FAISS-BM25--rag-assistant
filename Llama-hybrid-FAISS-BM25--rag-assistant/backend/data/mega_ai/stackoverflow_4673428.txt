[site]: stackoverflow
[post_id]: 4673428
[parent_id]: 2271204
[tags]: 
Might have to do with too many large objects being created (and not released) from your application? Dont know the Java GC really, but coming from .NET, large objects are placed on a seperate large object heap which is not compacted by the GC. In an application, utilizing a busy allocation pattern, this could lead to fragmentation on the LOB -> which in turn often causes those nasty OutOfMemory (OOM) exceptions. Moreover, LOB collections are always generation 2 collections. This means, they are costly! So, the clean solution would be to implement a pooling. Implement a disposal pattern for your large objects and make sure, they are released to the pool after use. Reuse them for new objects by reclaiming them from the pool. Once again, this does only apply, if you have too many large allocations. So you may clear this out first.
