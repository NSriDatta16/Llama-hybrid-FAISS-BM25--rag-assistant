[site]: stackoverflow
[post_id]: 4535141
[parent_id]: 4535050
[tags]: 
I'm a bit lost. Why do you need a new dynamically-generated va_list ? Why not just reuse the old one? I believe vsnprintf() uses a current va_list object (if you can call it that). So you are free to va_start() , use the arguments you want via va_arg() , then pass the remaining arguments via the va_list to vsnprintf() , and then call va_end() . Am I missing something? Why the deep copy? And if you do need a deep copy, why not va_start() fresh, remove the arguments you want via va_arg() , and then pass the resulting va_list object to vsnprintf() . (Each call to va_arg modifies the va_list object so that the next call returns the next argument.) Alternatively, you could just use va_copy() . (Though be sure to follow it with a corresponding va_end() .) Addendum: Also note that these va_ macros are based on C89 & C99 standards. GNU g++ will support them. Microsoft is somewhat more limited. Following up on TonyK's comment: What I said above works if you are pulling the first N items off the va_list . If you are pulling items out of the middle, that's harder. There is no portable way to construct a va_list . However, you could pull apart the format string, use it to determine the object types (double,float,int,etc), and print each one out individually with it's own format string (a subsection of the original format string). The multiple snprintf() calls will cause some overhead. But if this routine isn't called too often, it should be viable. You could also print out subsections of the original format string with a suitably crafted va_list . In other words, the first vsnprintf() call prints elements 1..3, the second elements 5..7, the third 10..13, etc. (As vsnprintf() will ignore extra elements on the va_list beyond what it needs. You just need a series of corresponding format-string-fragments, and popping items off the va_list with va_arg() as needed for each vsnprintf() call.)
