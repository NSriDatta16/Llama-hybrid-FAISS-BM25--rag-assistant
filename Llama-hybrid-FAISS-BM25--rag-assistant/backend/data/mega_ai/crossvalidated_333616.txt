[site]: crossvalidated
[post_id]: 333616
[parent_id]: 
[tags]: 
How to produce a normalized cumulative histogram?

I am having trouble understanding the proper method to calculate specific histograms, specifically with regard to cumulative and normalized histograms. If I want to calculate a normalized cumulative histogram, is it okay to first normalize the data and then apply accumulation? If the question is clear, you can skip ahead to the plots further below; otherwise, I've provided sample python code To illustrate my misunderstanding. import numpy as np import matplotlib.pyplot as plt data = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5]) + 0.5 # data consists of 5 occurrences 1.5, 4 occurrences of 2.5's, 3 occurrences of 3.5, etc bins = np.linspace(1, 6, 6) def accumulate(bin_counts): """ This function returns the cumulative sum of bin_counts. """ return np.cumsum(bin_counts) def normalize(bin_counts): """ This function returns the modified bin_counts such that they sum to one. """ return bin_counts / np.sum(bin_counts) # calculate histogram bin_counts, bin_edges = np.histogram(data, bins=bins) # calculate midpoints of bins bin_middles = (bin_edges[1:] + bin_edges[:-1])/2 # calculate array of each bin-width (one per bin) bin_widths = np.diff(bin_edges) The code just below will print the bin specs in a readable format via terminal. print("\n{} DATAS:\n\t{}\n".format(len(data), data)) print("{} BINS:\n\t{}\n".format(len(bins), bins)) print("{} BIN COUNTS:\n\t{}\n".format(len(bin_counts), bin_counts)) print("{} BIN EDGES:\n\t{}\n".format(len(bin_edges), bin_edges)) print("{} BIN MIDDLES:\n\t{}\n".format(len(bin_middles), bin_middles)) print("{} BIN WIDTHS:\n\t{}\n".format(len(bin_widths), bin_widths)) The code below allows for the creaion of a plot of the histogram data. def organize_binstogram(bin_middles, bin_counts, width=bin_widths, align='center', first=None, second=None): """ """ func_dict = dict(norm=normalize, accum=accumulate) if first is not None: func_first = func_dict[first] bin_counts = func_first(bin_counts) print("{} BIN COUNTS AFTER {} SUM TO {}:\n\t{}\n".format(len(bin_counts), first.upper(), sum(bin_counts), bin_counts)) if second is not None: func_second = func_dict[second] bin_counts = func_second(bin_counts) print("{} BIN COUNTS AFTER {} SUM TO {}:\n\t{}\n".format(len(bin_counts), second.upper(), sum(bin_counts), bin_counts)) plt.bar(bin_middles, bin_counts, width=width, align=align) plt.xticks(bin_middles) plt.show() To call the function just above, one can run any of the following: # organize_binstogram(bin_middles, bin_counts, first=None, second=None) # organize_binstogram(bin_middles, bin_counts, first='norm', second='accum') # organize_binstogram(bin_middles, bin_counts, first='accum', second='norm') Running the code above will produce the following plots: No accumulation or normalization Apply accumulation and then normalization Apply normalization and then accumulation I believe that the last version (normalizing and then applying accumulation) is correct. But I think I may be misunderstanding and wanted to verify that this method is actually correct.
