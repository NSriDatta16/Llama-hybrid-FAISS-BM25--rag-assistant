[site]: stackoverflow
[post_id]: 3828320
[parent_id]: 3807508
[tags]: 
Johann's answer, IMO is the correct one. It works this way because when you send SOAP messages, the elements need to be namespace qualified, otherwise the WCF doesnt know how to deserialize the SOAP into the User data contract because of the namespace mismatch. In C#, these two objects are different because they are in different namespaces... namespace UserServices { public class User { public string FirstName { get; set; } } } namespace TempuriServices { public class User { public string FirstName { get; set; } } } The Namespace in XML / SOAP serves the same purpose, to make sure the objects are from the same "body" / "company" / "organization" / "domain" etc. From what I have found, when I build SOAP services, I tend to keep all of my data contracts, service contracts, and binding namespaces in the same namespace, e.g. " http://mycompany.com/services/serviceName " here are some great resources... Data Contract Equivalence => http://msdn.microsoft.com/en-us/library/ms734767.aspx Data Contract Versioning Best Practices => http://msdn.microsoft.com/en-us/library/ms733832.aspx Hope this helps.
