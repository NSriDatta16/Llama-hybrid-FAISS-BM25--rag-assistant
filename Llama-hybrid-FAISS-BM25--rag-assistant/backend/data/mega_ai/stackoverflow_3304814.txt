[site]: stackoverflow
[post_id]: 3304814
[parent_id]: 3304795
[tags]: 
No, addresses aren't always positive - on x86_64, pointers are sign-extended and the address space is clustered symmetrically around 0 (though it is usual for the "negative" addresses to be kernel addresses). However the point is mostly moot, since C only defines the meaning of and > pointer comparisons between pointers that are to part of the same object, or one past the end of an array. Pointers to completely different objects cannot be meaningfully compared other than for exact equality, at least in standard C - if (p has no well defined semantics. You should create a dummy object with static storage duration and use its address as your unintialised value: extern char uninit_sentinel; #define UNINITIALISED ((void *)&uninit_sentinel) It's guaranteed to have a single, unique address across your program.
