[site]: stackoverflow
[post_id]: 1681960
[parent_id]: 1681667
[tags]: 
Let's take SOUNDEX , as an illustration of what you may be looking for... it does hash distinct but similar keys with the same value it would allow asserting that entity A (say, "McDonald") is possibly the same as entity C ("MacDonnel") One characteristic of SOUNDEX is that it works well in a specific domain (that of names, particular family names) and that it leverages rules associated with the pronunciation of words [in the English language, and by extension many languages of the same origin]. Your hashing (or is it almost a form of indexing?) algorithm will only be successful if a [relatively simple] set of rules exist (or can be discovered) to express the " sameness " of the items/records considered. For example if the underlying database pertains to automobiles, and if the criteria for "sameness" is that of size and general performance, maybe the hashing algorithm should be based on attributes from the record such as price (converted to a range), number of cylinders, number of doors, and maybe estimated gas mileage (too converted to a range). In a nutshell, I hope the above illustrates the need to tailor the algorithm to the semantics we wish to associate with hash value identity (or proximity... hence looking more and more like an index...), as well as these semantics are represented within the available data from the items. Items may be similar along many very dimensions. It is a matter of defining what these dimensions are are how the attributes "on" this dimension can be used as keys to a hashing function. On CMPH and gperf ... These are implementations of perfect, optionally mimimal, hash functions. This kind of function would allow you to prevent collisions . Not what is needed here (I think)
