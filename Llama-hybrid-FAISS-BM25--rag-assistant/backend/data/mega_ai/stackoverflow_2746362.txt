[site]: stackoverflow
[post_id]: 2746362
[parent_id]: 2746139
[tags]: 
You can consult MSDN for guidance. For instance, RoleProvider.RemoveUsersFromRoles provides the following guidance: RemoveUsersFromRoles is called by RemoveUserFromRole , RemoveUsersFromRole , RemoveUserFromRoles , and RemoveUsersFromRoles methods of the Roles class to remove the specified users from the specified roles at the data source. Only roles for the configured ApplicationName are modified. If any of the specified role names are not found for the configured applicationName, we recommend that your provider throw a ProviderException. If any of the specified user names are not associated with any of the specified role names for the configured applicationName, we recommend that your provider throw a ProviderException. If any of the specified user names is null or is an empty string, we recommend that your provider throw an exception. If any of the specified role names is null or is an empty string, we recommend that your provider throw an exception. If your data source supports transactions, we recommend that you include each remove operation in a transaction and that you roll back the transaction and throw an exception if any remove operation fails. And RoleProvider.GetRolesForUser says: GetRolesForUser is called by the GetRolesForUser method of the Roles class to retrieve the role names that the specified user is associated with from the data source. Only the roles for the configured ApplicationName are retrieved. If no roles exist for the specified user for the configured applicationName, we recommend that your provider return a string array with no elements. If the specified user name is null or is an empty string, we recommend that your provider throw an exception. But, in practice, there are just a few methods and behaviors in each provider that are required and expected. The rest are support for the features that you wish to implement. After several years of dealing with the default provider stack I have come to understand some of the things that are giving you pause regarding the sample you link to, which is a very simple implementation that cuts corners, for instance, in the ChangePassword method. If you use reflector and examine SqlMembershipProvider you will notice some salient differences... For instance: ValidateUser updates login date because, well, the user is logging in and it does so by calling .CheckPassword with true for UpdateLastLoginTime. Change password calls the same method but supplies false. The CreateUser method accepts a ProviderUserKey because the SPROC also will accept a UserId parameter. This is to allow recreation and syncronization between the membership and users tables. As a consumer of the API you would not normally utilize this functionality but the provider stack does internally. Regarding lockout.. It is up to you. That is what implementing custom providers is all about: getting the behavior you want. As I said, there are very few systematic requirements. So, this brings us to the last part of your question (both paragraphs allude to the same concern): expected behavior and unit testing... Since the behavior of a provider is largely arbitrary and there are few expected behaviors, an established set of generic tests would contain very few methods. You need to write tests that apply to the behavior of your implementation. As a final note, I suggest you find and download the Asp.Net provider toolkit samples. It provides you with working source code for the complete Sql provider stack and will give you some insight as to how 'real' providers are implemented. Afterthoughts : At this very moment, I am implementing a full SQLite provider stack that is 100% compatible with the default Sql stack. The test suite verifies behavioral parity between my stack and asp.net's. If you hit my blog via my profile and contact me I will let you know when the tests are complete and you can use them as a benchmark as to what exactly is expected from the default stack.
