[site]: stackoverflow
[post_id]: 4208399
[parent_id]: 4208264
[tags]: 
This is mostly dependent on a couple of things: Supported platform(s): this will push or pull you toward different code structure if you abstract the different platforms differently. Build system: stuff like CMake, qmake, autocr*p, Ant, Bjam, jam, etc... IDE: this won't be a show-stopper, but still could decide number 2. Is it a GUI or console only or library project: this will IMO force your to structure your program differently, especially if you obey the unspoken rule of splitting GUI and "processing" functions. A library will need a nice API header set, where another (non-library API bound) project will let you be free in that regard. What do you think is best? If you don't feel right in a certain set-up, don't use it and refactor (if it doesn't take all your time of course... I have just started a humble C++ project, with a small platform abstraction layer, maybe that can give you some hints/suggestions. Source code is viewable here (it is quite nonfunctional now and uses qmake to build): http://sourceforge.net/p/ambrosia/git -> browse What I did: - One platform abstraction header which provides platform-independent function definitions which are implemented in (currently) one source file per platform. - One global header including several headers which contain stuff needed virtually everywhere. - Some subfolders logically organized per goal of the code.
