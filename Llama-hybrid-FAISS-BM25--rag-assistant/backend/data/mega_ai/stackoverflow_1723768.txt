[site]: stackoverflow
[post_id]: 1723768
[parent_id]: 1723558
[tags]: 
All very good responses. And I would like to promote the general conscensus of "in moderation". A quick anecdote however, I have personally seen whole solutions explode with a proliferation of function-specific assemblies. I have also seen monolithic approaches. Reiterating: you want something in between. In my personal projects, I use a lot of Dependency Injection [DI] and Inversion of Control [IoC], and leverage Castle Windsor Container to do a lot the heavy lifting. I also determine early on which components require a "broad" scope, and which ones do not require exposure. For instance, a service [say the container itself, or an event broker] would be considered "broad" as there are likely to be many many consumers of this service across the entire application. A component that is isolated [say a business-specific date formatter] would not be broad, as no one is interested in consuming it directly except the business it is specific to. Broad interfaces, I would place in a separate SomeProductName.Interfaces assembly. Business-specific interfaces may be placed in their own function-oriented assembly SomeProductName.SomeStuffForAlice and SomeProductName.SomeStuffForBob , typically the same library as its implementation. Assemblies are just a physical representation of source organization - they don't actually mean anything in and of themselves [ie a monolithic mash, though distgusting, is functionally equivalent to a well organized solution and the disturbing project per interface nightmare]. An organizational convention is only useful if it serves its consumer [you! the developer!]
