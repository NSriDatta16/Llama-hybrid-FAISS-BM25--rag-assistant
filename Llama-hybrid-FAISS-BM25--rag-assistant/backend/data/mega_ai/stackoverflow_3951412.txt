[site]: stackoverflow
[post_id]: 3951412
[parent_id]: 3950877
[tags]: 
Loved the solution of Charles, which works perfectly for the case n=2. Alas, it's not extendible to larger windows. It still has the problem described by OP: with larger windows, the selection is not centered around the search value. Given n is even, I came up with following solution, heavily based on Charles idea. The function controls the borders. if there are 100 days, and the next midpoint is say the second last day, a window of 4 would mean that you select index 101, which gives NA . This function shifts the window so all selected indices lie within the original data. This also has the side effect that depending on the values of start ( st ), length( l ) and window( n ) values of the start and the end have a higher chance of been selected twice. The lengths should always be at least twice the window size. The output of the function are the indices of the bootstrap sample. It can be used as the pos variable of Charles on vectors and dataframes. bboot y) seq( from=min( lx-n, max(1,m+(-n/2)) ), to=min( lx, max(n,m+(n/2-1)) ) ) } ) pos Then > day sample.rownr sort(day) [1] 3 4 5 7 9 10 13 15 16 18 19 21 22 24 25 26 27 28 29 [20] 30 31 32 35 36 38 40 45 49 51 52 54 55 58 59 62 65 69 72 73 [40] 74 80 84 87 88 91 92 94 97 98 99 > day[sample.rownr] [1] 5 7 9 13 15 16 27 28 29 31 32 35 40 45 49 51 52 54 62 [20] 65 69 72 73 74 84 87 88 91 92 94 > edit : regarding bootstrapping for time series, you should go through The CRAN taskview on time series , especially the section about resampling. For irregular time series, the zoo package also offers quite some other functionalities that can come in handy.
