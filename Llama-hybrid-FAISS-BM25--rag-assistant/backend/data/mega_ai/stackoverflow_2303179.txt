[site]: stackoverflow
[post_id]: 2303179
[parent_id]: 2303068
[tags]: 
You can use the List type to hold the pairs, Sort them and use List.BinarySearch. For instance you could have something like the following: struct Pair { public Pair(DateTime t, int v) { date = t; value = v; } public DateTime date; public int value; } .... List pairs = new List (); pairs.Add(new Pair(DateTime.Now, 100)); pairs.Add(new Pair(DateTime.Now, 200)); .... // Sort using the time. pairs.Sort(delegate(Pair pair1, Pair pair2) { return pair1.date.CompareTo( pair2.date); } ); // Do binary search. int index = pairs.BinarySearch(new Pair(dateToSearch, 0), delegate(Pair pair1, Pair pair2) { return pair1.date.CompareTo(pair2.date); }); if (index >= 0) { // Found the element! return pairs[index].value; } // If not found, List.BinarySearch returns the complement // of the index where the element should have been. index = ~index; // This date search for is larger than any if (index == pairs.Count) { // } // The date searched is smaller than any in the list. if (index == 0) { } // Otherwise return average of elements at index and index-1. return (pairs[index-1].value + pairs[index].value)/2; Of course the code is not the best possible, but you get the idea: use List, Sort it and then do BinarySearch. Lookup MSDN for more information. List: http://msdn.microsoft.com/en-us/library/6sh2ey19.aspx List.Sort: http://msdn.microsoft.com/en-us/library/3da4abas.aspx List.BinarySearch: http://msdn.microsoft.com/en-us/library/3f90y839.aspx
