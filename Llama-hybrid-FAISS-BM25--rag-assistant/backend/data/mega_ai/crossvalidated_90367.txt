[site]: crossvalidated
[post_id]: 90367
[parent_id]: 90331
[tags]: 
I think you have the right idea but stumbled over a nasty feature of R. Here again the relevant code piece as you've stated it: trans_data = final_data trans_data[,2] = 0 row_orig_data = t(t(feat_vec[1,]) %*% t(trans_data)) plot(row_orig_data, asp=T, pch=16) Essentially final_data contains the coordinates of the original points with respect to the coordinate system defined by the eigenvectors of the covariance matrix. To reconstruct the original points one therefore has to multiply each eigenvector with the associated transformed coordinate, e.g. (1) final_data[1,1]*t(feat_vec[1,] + final_data[1,2]*t(feat_vec[2,]) which would yield the original coordinates of the first point. In your question you set the second component correctly to zero, trans_data[,2] = 0 . If you then (as you already edited) calculate (2) row_orig_data = t(t(feat_vec) %*% t(trans_data)) you calculate formula (1) for all points simultaneously. Your first approach row_orig_data = t(t(feat_vec[1,]) %*% t(trans_data)) calculates something different and only works because R automatically drops the dimension attribute for feat_vec[1,] , so it is not a row vector anymore but treated as a column vector. The subsequent transpose makes it a row vector again and that's the reason why at least the calculation does not produce an error, but if you go through the math you will see that it is something different than (1). In general it is a good idea in matrix multiplications to suppress dropping of the dimension attribute which can be achieved by the drop parameter, e.g. feat_vec[1,,drop=FALSE] . Your edited solution seems correct, but you calculated the slope if PCA1 wrongly. The slope is given by $\Delta y / \Delta x$, hence s1 = e$vectors[2,1] / e$vectors[1,1] # PC1 s2 = e$vectors[2,2] / e$vectors[1,2] # PC2
