[site]: stackoverflow
[post_id]: 5049863
[parent_id]: 
[tags]: 
Service dies when activity dies

Hope you can help me, because I am almost sure that it can be done... but I don't seem to be able to do it. I'm doing a task that can take very long (varies from a few seconds to a couple of hours), so I though of a service to make the task and an activity to start/stop/monitor. Organically similar to a MP3 player, which is why I think this to be possible. However, when I rotate the screen, the activity is destroyed/created (this is not a problem), and so it is the service! (this is a problem, because the new service is a different service, with a different state). I want my service to survive the destruction of the activity (by the way, the current reproducible problem is rotation, but it may happen in any other moment, such as presing BACK in the activity or so). 1) Am I asking for something impossible? It is hard for me to believe it, because what I want is exactly what a music player wants... 2) if (impossible) { Any other idea? } 3) else { Any idea of what I am doing wrong? } I would also apreciate something like "what you are doing is right", since that would tell me that the problem is in the code, and not in the concept. Here is my pseudocode (android 2.2, api 8): EDIT1: added "return START_NOT_STICKY", since it may be important... // THE SERVICE class MyService extends Service { private MyInterface.Stub binder = new MyInterface.Stub() { public int getProgress() {...} public void doStop() {...} } onCreate() { Log("MyService created"); } onDestroy() { Log("MyService destroyed"); doStop(); } onBind() { Log("MyService bound"); return binder; } onStartCommand() { (new Thread() { void run() { while (!stop) { //Do long task } stopSelf(); } }).start(); return START_NOT_STICKY; } } // THE ACTIVITY class MyActivity extends Activity { MyInterface _service; ServiceConnection conn = new ServiceConnection() { onServiceConnected(s) { _service = MyInterface.Stub.asInterface(s); } onServiceDisconnected() { _service = null; } } onCreate() { Log("MyActivity created"); bindService(MyService, conn); } onDestroy() { Log("MyActivity destroyed"); unbindService(conn); } clickStart() { startService(new Intent(this, MyService)); } clickStop() { _service.doStop(); } clickProgress() { _service.getProgress(); } } // THE MANIFEST Edit2: More information. My pseudocode says: class MyService extends Service { ... } However, it is an oversimplification, since it actually is: class MyService extends MyBaseService { ... } class MyBaseService extends Service { ... } MyBaseService is in a different package and even in a different project (a "library project"). Then, if I do not start/bindto MyService, but MyBaseService (and change manifest acordingly), everything works as expected. It is enough for me, since the behaviour implemented in MyService (in relation to MyBaseService) is easily coded into MyBaseService, and controlled via putExtra to the Intent which launches the service (although it breaks OOP, I don't mind). However, I still can't find why this one works but the other does not. I will report if I progress further. Edit3: fixed pseudocode (duplicated onCreate). But real code does not have it. Edit4: a notice on the procedure: 1) Everything starts as expected. 2) The user clicks Start, so click_start() is run, the service is serviceStart()'ed. 3) The user changes orientation. MyActivyty.onDestroy() is called, causing unbindService(). 4) The service is destroyed; MyService.onDestroy() is called. 5) The activity is re-created. MyActivity.onCreate() is called, causing bindService(). 6) The service is re-created; MyService.onCreate() is called. State has been lost. My problem is step 4 (6 is just a consecuence of 4).
