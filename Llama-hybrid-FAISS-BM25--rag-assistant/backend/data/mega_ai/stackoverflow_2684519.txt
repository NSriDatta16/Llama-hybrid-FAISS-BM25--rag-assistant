[site]: stackoverflow
[post_id]: 2684519
[parent_id]: 2683847
[tags]: 
Actually the compiler just catches the DirectCast violation if it infers that the typed variable cannot be converted to the other type. These are the actual equivalents: double d = 10; int i = (int)d; Dim d As Double = 10 Dim i As Integer = d Note the dangerousness of this construct. When you just merely assign double to integer in VB.NET, the double will be accidentally downsized to integer. Whereas C# programmers get the compile-time safety of not accidentally downsizing a variable in .NET. VB.NET programmers have to contend with always using DirectCast as a safe programming habit. These are the actual equivalents: // Will not compile, cannot convert double to int double d = 10; int i = d; ' Will not compile, cannot convert double to int Dim d As Double = 10 Dim i As Integer = DirectCast(d, Integer) Regarding Dan Tao's comment : There's no need to use DirectCast in C#. The runtime also prevents loading of long to integer value. This is what the OP is contending, that C# doesn't have DirectCast, that DirectCast can prevent assigning of different types of variable, whereas "because" C# doesn't have this DirectCast, it will silently error on assigning different types. But as you can see, that's not the case. C#'s casting is exactly the same as DirectCast. This will cause a InvalidCastException runtime error: long l = 10; object o = l; int i = (int)o; This will also cause the same runtime error as above: Dim l As Long = 10 Dim o As Object = l Dim i As Integer = DirectCast(o, Integer) Now, this is where the "fun" part comes in. With VB.NET you have to remember many keywords in order to accomplish something. In C#, if a given keyword could be used in another scenario (like in this one downcasting of variable), they will not invent another keyword just to make it happen. In C# you just have to do this: long l = 10; object o = l; int i = (int)(long)o; In VB.NET if you really want to downcast the variable, and want the orthogonal way to do it, i.e. just remembering one keyword, you must do this: Dim l As Long = 10 Dim o As Object = l Dim i As Integer = DirectCast(DirectCast(o, Long), Integer) But that will not compile, so how can we achieve downcasting long to integer? You must remember VB.NET's other keywords. Whereas in C#, it's orthogonal, you unbox variable using this construct (typehere) , you also downcast/upcast using same construct (typehere) . In VB.NET there's a fundamental disconnect between loading a value from object and downcasting it. So in VB.NET, you have to do this: Dim l As Long = 10 Dim o As Object = l Dim i As Integer = CType(o, Integer) Hmm.. I think the OP's confusion stems from C# multiple use of (typehere) . First, it is used for downcasting; second, the same construct (check the first part of this post, object o = l ) is also used for unboxing of value from object, which, rest assured, it has DirectCast's safe type conversion behavior. They are the same! This downcasting... long l = 1; int i = (int) l; ...is not equivalent to: Dim l As Long = 1 Dim i As Integer = DirectCast(l, Integer) If you want to perform downcasting, you have to do this: Dim l As Long = 1 Dim i As Integer = CInt(l) ' Can also use CType Now, if a VB.NET programmer is programming by intent, and not sleepy while coding, why will he/she use DirectCast when he/she is fully aware that it cannot assign different types? If what the VB.NET programmer really wanted is to downcast, he/she should not attempt DirectCast in the first place. Now the VB.NET programmer, upon discovering that DirectCast cannot be used for downcasting, must backspace what he/she has written and replace it with CInt (or CType).
