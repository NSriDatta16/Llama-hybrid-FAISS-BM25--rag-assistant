[site]: stackoverflow
[post_id]: 5289476
[parent_id]: 5288102
[tags]: 
Don't reinvent the wheel ! IMHO your hashing is far from efficient, and your collision algorithm can be improved. Take a look for instance at the IniFiles unit, and the THashedStringList. It's a bit old, but a good start for a string list using hashes. There are a lot of good Delphi implementation of such, like in SuperObject and a lot of other code ... Take a look at our SynBigTable unit, which can handle arrays of data in memory or in file very fast, with full indexed searches. Or our latest TDynArray wrapper around any dynamic array of data, to implement TList-like methods to it, including fast binary search. I'm quite sure it could be faster than your hand-tuned code using hashing, if you use an ordered index then fast binary search. Post-Scriptum: About pure hashing speed of a string content, take a look at this function - rename RawByteString into AnsiString, PPtrInt into PPointer, and PtrInt into Integer for Delphi 7: function Hash32(const Text: RawByteString): cardinal; function SubHash(P: PCardinalArray): cardinal; {$ifdef HASINLINE}inline;{$endif} var s1,s2: cardinal; i, L: PtrInt; const Mask: array[0..3] of cardinal = (0,$ff,$ffff,$ffffff); begin if P<>nil then begin L := PPtrInt(PtrInt(P)-4)^; // fast lenght(Text) s1 := 0; s2 := 0; for i := 1 to L shr 4 do begin // 16 bytes (4 DWORD) by loop - aligned read inc(s1,P^[0]); inc(s2,s1); inc(s1,P^[1]); inc(s2,s1); inc(s1,P^[2]); inc(s2,s1); inc(s1,P^[3]); inc(s2,s1); inc(PtrUInt(P),16); end; for i := 1 to (L shr 2)and 3 do begin // 4 bytes (DWORD) by loop inc(s1,P^[0]); inc(s2,s1); inc(PtrUInt(P),4); end; inc(s1,P^[0] and Mask[L and 3]); // remaining 0..3 bytes inc(s2,s1); result := s1 xor (s2 shl 16); end else result := 0; end; begin // use a sub function for better code generation under Delphi result := SubHash(pointer(Text)); end; There is even a pure asm version, even faster, in our SynCommons.pas unit. I don't know any faster hashing function around (it's faster than crc32/adler32/IniFiles.hash...). It's based on adler32, but use DWORD aligned reading and summing for even better speed. This could be improved with SSE asm, of course, but here is a fast pure Delphi hash function. Then don't forget to use "multiplication"/"binary and operation" for hash resolution, just like in IniFiles. It will reduce the number of iteration to your list of hashs. But since you didn't provide the search source code, we are not able to know what could be improved here.
