[site]: stackoverflow
[post_id]: 2249468
[parent_id]: 2246695
[tags]: 
It sounds like you have habit of over complicating things. I would probably not use a tweening engine, but might use the Timer class. I would also separate things out into manageable chunks. At the moment it looks like you have your timing code and you display code all mixed in together. I would create these seperate parts: CounterTimer - The thing that works out what Count your up to (time-based). CounterView - The visual graphics of your counter. It's only job is to render what ever number it is TOLD to display. And handle the transitions between states. CounterController - Sort of a middle-man. Gets the current Count from CounterTimer, and tells CounterView to render that number (frame-based, because you can only render once per frame). Breaking it down like this means you can concentrate on one component at a time, and test that one part in isolation from the other parts. For example; first you could build the CounterView. This would probably be a MovieClip that holds your graphics on the stage. It might have a method called: public function displayNumber(numberToDisplay:Number):void When this method is called, the CounterView will show the graphics for that number, including transitions. To test this component, just call this method from the CounterView parent, with a random number. Once it works you can start working on the CounterTimer. For the CounterTimer you would probably want it to have a bit more of an API e.g. public function CounterTimer( startCount:Number ) //This is the constructor. public function start() public function reset():void public function getCount():Number When CounterTimer is finished, just start on the CounterController to hook them together. The CounterController would need to listen to the enterframe event, and tell CounterView to display CounterTimer's count every frame.
