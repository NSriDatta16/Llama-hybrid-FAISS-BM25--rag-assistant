[site]: stackoverflow
[post_id]: 5386752
[parent_id]: 2689092
[tags]: 
I've been looking for the same, and I don't think it's possible. The only decent solution seems to be to name them, from Bytes.com : SELECT CASE WHEN patientid IS NULL THEN 1 ELSE 0 END+ CASE WHEN age IS NULL THEN 1 ELSE 0 END+ CASE WHEN weight IS NULL THEN 1 ELSE 0 END+ CASE WHEN height IS NULL THEN 1 ELSE 0 END+ CASE WHEN race IS NULL THEN 1 ELSE 0 END FROM tblPatientDemographics Of course that's no fun, so I wrote some dynamic SQL to do this for me. Hardly elegant, but I'm not sure there's a better way. DECLARE @tableName SYSNAME DECLARE @sql VARCHAR(MAX) DECLARE @sqltail VARCHAR(MAX) -- loop through all the fields in a table. DECLARE @colName SYSNAME SET @tableName = 'YourTableName' DECLARE crsCol CURSOR FORWARD_ONLY READ_ONLY FOR SELECT name FROM syscolumns WHERE id = OBJECT_ID(@tableName) ORDER BY colid OPEN crsCol SET @sql = '' SET @sqltail = 'FROM [' + @tableName + ']' FETCH NEXT FROM crsCol INTO @colName WHILE @@FETCH_STATUS = 0 BEGIN IF @sql = '' SET @sql = 'SELECT /* Add Your PK Fields here, */ NullCount = ' ELSE SET @sql = @sql + '+ ' SET @sql = @sql + 'CASE WHEN [' + @colName + '] IS NULL THEN 1 ELSE 0 END ' FETCH NEXT FROM crsCol INTO @colName END CLOSE crsCol DEALLOCATE crsCol PRINT (@sql + @sqltail) EXEC(@sql + @sqltail)
