[site]: stackoverflow
[post_id]: 4058069
[parent_id]: 4056008
[tags]: 
As far as I know, you can't get a variable list of elements as an SPARQL solution. I think the easiest way to do what you need is just to get the pairs (a,b) from ?a g:eastOf ?b and sort them. SELECT ?a ?b WHERE { ?a g:eastOf ?b } ORDER BY ASC(?a) ASC(?b) It should be pretty straight forward to put some logic in place to convert the list of tuples on a list of elements. If you use reasoning with transitivity you won't be able to trace back what's the path that connects A with C. In case you have something like (A,g:eastOf,B) and (B,g:eastOf,C). Basically in this case using reasoning will make the things more complicated because you want to construct the full list of connected elements. Transitivity in SPARQL will give you the start and end node but you'll loose traceability of all the intermediate points. If you don't have millions of statements I think that the above SPARQL query plus some logic to transform the resultset will do the job. Edited to give pointers to Jena + owl:TransitiveProperty So first make sure that you load an ontology with the following axiom into your Jena Model : g:eastOf rdf:type owl:TransitiveProperty . Then enable the Jena OWL reasoner see documentation here : Jena OWL coverage And connect Jena ARQ to your model so to be able to launch SPARQL queries. Once you've done that ... if you had something like ... :x g:eastOf :y . :y g:eastOf :t . :t g:eastOf :z . and you run a query like ... SELECT ?a ?b WHERE { ?a g:eastOf ?b } ORDER BY ASC(?a) ASC(?b) you'll get ... :x g:eastOf :y . :x g:eastOf :t . :x g:eastOf :z . :y g:eastOf :t . :y g:eastOf :z . (...) Also with Jena consider to use Property Paths . It'll do the job as well. Let us know if its works or if you run into any issues, cheers !!!
