[site]: stackoverflow
[post_id]: 3411941
[parent_id]: 3411793
[tags]: 
First of all, I'll assume your nodes have a "parent" field that points to their parent. It's either that, or you need a stack to be able to move back up in the tree (and thus can't achieve that O(1) auxiliary memory requirement). There is a well-known in-order iteration which is both iterative and in O(1) space. Suppose for instance you'd want to print items in order. Basically, when you traverse a binary tree, you have to decide at any given moment, in any given node, whether you want to move UP (to the parent), LEFT (to the left child) or RIGHT. The idea for this algorithm is to base this decision on where you come from: if you come down from the parent, then clearly you are visiting the node for the first time, so you go LEFT; if you come up from the left child, then you have visited all nodes that are smaller than the current node, so you can print (remember we want to print nodes in order here) the current node, and then go RIGHT; finally, if you come up from the right child, that means you have visited the entire subtree rooted at this particular node, and so you can back UP to the parent. OK: so this is the algorithm that you take for a base. Now, clearly, if you are destructively modifying this into a linked list, you should only modify a node once you aren't going to visit it anymore. That is when you are coming up from the right. At that point, you have to decide what the successor of that node is going to be... ? Well, you need to keep track, at all times, of two pointers: one to the smallest node you have visited, and one to the largest node you have visited in the current rooted subtree. You use the smallest as the successor for nodes you last visit when you come up from the right child, and use the largest as the successor for nodes you last visit coming up from somewhere else, because they happen to not have a right child! EDIT 1 : I forgot to say that I implicitly consider that the "parent" field in the binary tree becomes the "next" field in the linked list---that is what I modify in the last step. EDIT 3 : The following part of my answer has turned out to not quite answer the original question (but what preceded is still pertinent). EDIT 2 : Following Svante's understandable wish that I explicit my suggestion of using left rotations into some code: #include #include typedef struct node *node; struct node { int value; node left; node right; }; node new_node(int value, node left, node right) { node n = (node) malloc(sizeof(struct node)); n->value = value; n->left = left; n->right = right; return n; } int rotate_right(node tree) { if(tree != NULL && tree->left != NULL) { node a = tree->left->left, b = tree->left->right, c = tree->right; int tmp = tree->value; tree->value = tree->left->value; tree->left->value = tmp; tree->left->left = b; tree->left->right = c; tree->right = tree->left; tree->left = a; return 1; } return 0; } The rotation function is not elegant, but as it is easy to get mixed up, I tried to follow the exact same naming as used in Wikipedia's article on rotations . The nodes A, B, C are named as such in my code; the nodes P and Q are not, and since I chose not to use pointers of pointers, I instead resorted to the trick of switching values of P and Q---in lieu of switching places. With "rotation_right" at our disposal, the conversion algorithm is quite simple: void convert_to_list(node tree) { if(tree != NULL) { while(rotate_right(tree) != 0); convert_to_list(tree->right); } } The resulting tree is a sorted linked-list, where the next pointer of the list is what used to be the right pointer in the tree. Finally, here is a test program: int main() { node t = new_node(4, new_node(2, NULL, new_node(3, NULL, NULL)), new_node(8, new_node(5, NULL, NULL), NULL)); convert_to_list(t); for(; t != NULL; t = t->right) printf("%d, ", t->value); return 0; }
