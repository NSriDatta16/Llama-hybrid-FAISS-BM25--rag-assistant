[site]: stackoverflow
[post_id]: 3104288
[parent_id]: 3103568
[tags]: 
Some guidelines: Keep the business end of the code and the GUI separate. Avoid the use of compiler specific crutches (#pragma, etc.) Use conventional expressions that won't change behavior with compiler/platform instead of cute bit manipulation tricks. If it touches hardware it belongs in a device driver. Use data type headers like types.h (uint32_t, etc.). Use an operating system abstraction layer so you are not calling operating system calls directly. Sometimes you have to trade off efficiency and performance to gain portability. For example, if your code requires accessing fields out of a buffer you can always cast a packed struct to the buffer pointer. But that is horribly non-portable. So instead you need to use named pointers calculated with offsets -- sometimes with boundary alignment handling code. Not pretty, but portable. Fortunately you can hide a lot of that stuff with judicious use of class interfaces. Not all code needs to be written that way. If you design your application in a very modular way with well defined boundaries of responsibility then 90-95% of the code can be portable without pain. Then just isolate the 5-10% in a very localized area that would need to be customized for a new platform.
