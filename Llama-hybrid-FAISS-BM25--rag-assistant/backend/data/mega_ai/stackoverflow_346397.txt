[site]: stackoverflow
[post_id]: 346397
[parent_id]: 346306
[tags]: 
They are different things. I'm not an expert in volatile semantics. But i think it makes sense what is described here. Global Global just means the identifier in question is declared at file-scope. There are different scopes, called function (where goto-labels are defined in), ﬁle (where globals reside), block (where normal local variables reside), and function prototype (where function parameters reside). This concept just exist to structure the visibility of identifiers. It doesn't have anything to do with optimizations. Static static is a storage duration (we won't look at that here) and a way to give a name declared within file scope internal linkage. This can be done for functions or objects only required within one translation unit. A typical example might be a help function printing out the accepted parameters, and which is only called from the main function defined in the same .c file. 6.2.2/2 in a C99 draft: If the declaration of a ﬁle scope identiﬁer for an object or a function contains the storage class speciﬁer static, the identiﬁer has internal linkage. Internal linkage means that the identifier is not visible outside the current translation unit (like the help function of above). Volatile Volatile is a different thing: ( 6.7.3/6 ) An object that has volatile-qualiﬁed type may be modiﬁed in ways unknown to the implementation or have other unknown side effects. Therefore any expression referring to such an object shall be evaluated strictly according to the rules of the abstract machine, as described in 5.1.2.3. Furthermore, at every sequence point the value last stored in the object shall agree with that prescribed by the abstract machine, except as modiﬁed by the unknown factors mentioned previously. The Standard provides an excellent example for an example where volatile would be redundant ( 5.1.2.3/8 ): An implementation might deﬁne a one-to-one correspondence between abstract and actual semantics: at every sequence point, the values of the actual objects would agree with those speciﬁed by the abstract semantics. The keyword volatile would then be redundant. Sequence points are points where the effect of side effects concerning the abstract machine are completed (i.e external conditions like memory cell values are not included). Between the right and the left of && and || , after ; and returning from a function call are sequence points for example. The abstract semantics is what the compiler can deduce from seeing only the sequence of code within a particular program. Effects of optimizations are irrelevant here. actual semantics include the effect of side effects done by writing to objects (for example, changing of memory cells). Qualifying an object as volatile means one always gets the value of an object straight from memory ("as modified by the unknown factors"). The Standard doesn't mention threads anywhere, and if you must rely on the order of changes, or on atomicity of operations, you should use platform dependent ways to ensure that. For an easy to understand overview, intel has a great article about it here . What should i do now? Keep declaring your file-scope (global) data as volatile. Global data in itself does not mean the variables' value will equal to the value stored in memory. And static does only make your objects local to the current translation unit (the current .c files and all other files #include'ed by it).
