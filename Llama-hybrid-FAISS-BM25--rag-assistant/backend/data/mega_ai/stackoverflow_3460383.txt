[site]: stackoverflow
[post_id]: 3460383
[parent_id]: 3453874
[tags]: 
I've completed my workaround. I would still like to know if there is any better way to do this, so if you know of one or have any suggestions I'm willing to try them out. Notes: I only check for bools, ints, strings, and arrays because according to Apple's documentation thats all that should be in the Auxiliary Information in a PDF. The array bit is untested, because I dont have a PDF with an array in the Aux Info. If someone would like to test that for me or link to a pdf with one in it I will gladly test it out. First, in the class header create an id selfClass outside the @interface tags so that the C functions called by CGPDFDictionaryApplyFunction can access the current class. Also add an NSDictionary *auxInfo for storing the information. Once extracted, the NS type can be easily cast like this: CFDictionaryRef newDictionary = (CFDictionaryRef)[self auxInfo]; I was actually done last night but thought I had to do another round of looping to convert from NS to CF, forgetting they were token-free bridged. So there you have it, hope everyone benefits from my labors. Ask questions if you need clarification. And once again, if there is an easier way to do this, if only an optimization of my code, please say so. I know this isn't a very elegant way to do this but it works for now. - (void)extractPDFDictionary:(CGPDFDocumentRef)pdf{ NSLog(@"extractingPDFDictionary"); CGPDFDictionaryRef oldDict = CGPDFDocumentGetInfo(pdf); CGPDFDictionaryApplyFunction(oldDict, copyDictionaryValues, NULL); } void copyDictionaryValues (const char *key, CGPDFObjectRef object, void *info) { NSLog(@"key: %s", key); CGPDFObjectType type = CGPDFObjectGetType(object); switch (type) { case kCGPDFObjectTypeString: { CGPDFStringRef objectString; if (CGPDFObjectGetValue(object, kCGPDFObjectTypeString, &objectString)) { NSString *tempStr = (NSString *)CGPDFStringCopyTextString(objectString); [[selfClass auxInfo] setObject:tempStr forKey:[NSString stringWithCString:key encoding:NSUTF8StringEncoding]]; [tempStr release]; NSLog(@"set string value"); } } case kCGPDFObjectTypeInteger: { CGPDFInteger objectInteger; if (CGPDFObjectGetValue(object, kCGPDFObjectTypeInteger, &objectInteger)) { [[selfClass auxInfo] setObject:[NSNumber numberWithInt:objectInteger] forKey:[NSString stringWithCString:key encoding:NSUTF8StringEncoding]]; NSLog(@"set int value"); } } case kCGPDFObjectTypeBoolean: { CGPDFBoolean objectBool; if (CGPDFObjectGetValue(object, kCGPDFObjectTypeBoolean, &objectBool)) { [[selfClass auxInfo] setObject:[NSNumber numberWithBool:objectBool] forKey:[NSString stringWithCString:key encoding:NSUTF8StringEncoding]]; NSLog(@"set boolean value"); } } case kCGPDFObjectTypeArray : { CGPDFArrayRef objectArray; if (CGPDFObjectGetValue(object, kCGPDFObjectTypeArray, &objectArray)) { NSArray *tempArr = [selfClass copyPDFArray:objectArray]; [[selfClass auxInfo] setObject:tempArr forKey:[NSString stringWithCString:key encoding:NSUTF8StringEncoding]]; [tempArr release]; NSLog(@"set array value"); } } } } - (NSArray *)copyPDFArray:(CGPDFArrayRef)arr{ int i = 0; NSMutableArray *temp = [[NSMutableArray alloc] init]; for(i=0; i
