[site]: stackoverflow
[post_id]: 1797746
[parent_id]: 1796777
[tags]: 
Taking my cue from the C# definition as well as the C version, it looks more like pbuffer is meant to be a pointer to a byte buffer. That is, in delphi it would be better as a PByte, passed by reference. No need to use a PChar when you really want a PByte. eg. type IMAGE_RESOLUTION = integer; // judging from the c# parameters... float = Single; // 4 bytes... TRetScreenFn = function(number: integer; var buffer: PByte; var size: Cardinal; resolution: IMAGE_RESOLUTION; zoom: float; dx : integer; dy : integer): integer; cdecl; (I'm assuming cdecl here from the extern "C" -- might be wrong here, depending on what "export_dll_function" means. If it's not this, it'll probably be stdcall instead.) If it's possible for nil to be given instead of buffer or size, you won't be able to use "var". In that case, you'd need to do something like this: type PPByte = ^PByte; PCardinal = ^Cardinal; TRetScreenFn = function(number: integer; buffer: PPByte; size: PCardinal; resolution: IMAGE_RESOLUTION; zoom: float; dx : integer; dy : integer): integer; cdecl; This is essentially the same thing. Except with the first version, the compiler will enforce the var parameters to be non-nil. This second version, it just sees pointers, and doesn't care. Then, you know the rest (ignoring sane error checks): var retScreen : TRetScreenFn; dll : HMODULE; begin dll := LoadLibrary("API.dll"); try retScreen := TRetScreenFn(GetProcAddress(dll, "RetScreen")); // ... call retScreen(); do stuff... finally CloseHandle(dll); end; end;
