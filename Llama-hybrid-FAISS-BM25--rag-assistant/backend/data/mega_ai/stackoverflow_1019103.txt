[site]: stackoverflow
[post_id]: 1019103
[parent_id]: 442585
[tags]: 
I think I understand what you're after, but I could wildy off... If you mock up classes in a DBML (right-click -> new -> class) that are the same structure as your source tables, you could simply create new objects based on what is read from the stored procedure. Using LINQ to objects, you could still query your selection. It's more code, but it's not that hard to do. For example, mock up your DBML like this: Pay attention to the associations http://geeksharp.com/screens/orders-dbml.png Make sure you pay attention to the associations I added. You can expand "Parent Property" and change the name of those associations to "InvoiceAddress" and "DeliveryAddress." I also changed the child property names to "InvoiceOrders" and "DeliveryOrders" respectively. Notice the stored procedure up top called "usp_GetOrders." Now, with a bit of code, you can map the columns manually. I know it's not ideal, especially if the stored proc doesn't expose every member of each table, but it can get you close: public List GetOrders() { // our DBML classes List dbOrders = new List (); using (OrderSystemDataContext db = new OrderSystemDataContext()) { // call stored proc var spOrders = db.usp_GetOrders(); foreach (var spOrder in spOrders) { Order ord = new Order(); Address invAddr = new Address(); Address delAddr = new Address(); // set all the properties ord.OrderID = spOrder.OrderID; // add the invoice address invAddr.AddressID = spOrder.InvAddrID; invAddr.Street = spOrder.InvStreet; invAddr.ZipCode = spOrder.InvZipCode; ord.InvoiceAddress = invAddr; // add the delivery address delAddr.AddressID = spOrder.DelAddrID; delAddr.Street = spOrder.DelStreet; delAddr.ZipCode = spOrder.DelZipCode; ord.DeliveryAddress = delAddr; // add to the collection dbOrders.Add(ord); } } // at this point I have a List of orders I can query... return dbOrders; } Again, I realize this seems cumbersome, but I think the end result is worth a few extra lines of code.
