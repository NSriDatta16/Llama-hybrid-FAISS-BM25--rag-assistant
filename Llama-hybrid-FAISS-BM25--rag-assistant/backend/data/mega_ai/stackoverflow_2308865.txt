[site]: stackoverflow
[post_id]: 2308865
[parent_id]: 2308444
[tags]: 
While it is possible (although a pain) to have an array of arbitrary types, you pretty much never need it, since you have to know something about what is where to do anything interesting with it: for example, your 'TL;DR' example seems to look something like: struct AIRule { // Can only handle comparing ints, see later for more general solution. typedef bool compare_type(AIObject*, AIObject::*int, int); compare_type* compare; AIObject* object; AIObject::int* member; int comparand; }; So now you can do something like: bool ai_equal(AIObject* object, AIObject::int* member, int comparand) { return object->*member == comparand; } ... ai[n].compare = &ai_equal; ai[n].object = some_object; ai[n].member = &AIObject::some_member; ai[n].comparand = 50; ... if (ai[n].compare(ai[n].object, ai[n].member, ai[n].comparand)) { ... } This just moves the any type problem from the rules array to member though. C++ needs to know at least how many bytes a member is, and a string (for example) can be much bigger than an int. You can get around this by using pointers: which essentially is C++'s version of any, but you then need to delete it yourself (or you will leak memory!), at which point the interface method below becomes simpler. If I was doing what you seem to want, I would use inheritance: struct Sprite { int frame; double rotation; Sprite() { frame = 0; rotation = 0.0; } virtual ~Sprite() {} virtual void think() { ++frame; } virtual void draw() { ... } }; struct RotatingSprite : public Sprite { int state; MyShape() { state = 0; } void think() { Sprite::think(); if (state == 0 && frame > 64) { state = 1; rotation += 180.0; } } }; Or a function pointer: struct Sprite { int frame; double rotation; void (*think)(Sprite*); Sprite() { frame = 0; rotation = 0.0; } }; void rotate_think(Sprite* sprite) { if (sprite->state == 0 && sprite->frame > 64) { sprite->state = 1; sprite->rotation += 180.0; } } ... sprite->think = &rotate_think; If you really need to do it dynamically I would recommend using the ++ part of C++. For the predicates (a predicate is just something that returns a boolean, like isLowerCase()) create an AIPredicate interface, and the actions an AIAction interface: struct AIPredicate { // "When you delete an AIPredicate, delete the full type, not just this interface." virtual ~AIPredicate() {} // "You can treat this as a function (operator()) but I'm not providing an implementation here ( = 0)" virtual bool operator()(AIObject* object) = 0; }; struct AIAction { virtual ~AIAction() {} virtual void operator()(AIObject* object) = 0; }; struct AIRule { // std::auto_ptr (or std::unique_ptr if you can use C++0x) will delete predicate for you. // Add "#include " to your includes if it complains (most std headers will include it already) std::auto_ptr predicate; std::auto_ptr action; }; Now you can make types like: struct AIFrame : public AIPredicate { // Implement the operator() member AICondition promises. bool operator()(AIObject* object) { return object->foo If you want to have a very general predicate type, you can use the very powerful (and complicated) templates feature: // The naming convention I'm using here is 'T'TitleCase for template parameters, TitleCase for types, // lower_case for arguments and variables and '_'lower_case for members. template struct AIMemberEquals : public AIPredicate { // Constructor: Initializes a new instance after it is created. AIMemberEquals(TMemberType comparand) { // Save comparand argument so we can use it in operator(). _comparand = comparand; } bool operator()(AIObject* object) { return object->*TMember == comparand; } // Stores the value to compare. TMemberType _comparand; }; Unfortunately, creating templates looks a bit crazy: ai[n].predicate = new AIMemberEquals (100); Read it as "create a new instance of (the type that AIMemberEquals applied to int and (the some_member member of AIObject) creates), with the argument 100". When you have multiple predicates memory management becomes a bit more difficult without C++0x's unique_ptr or shared_ptr, types that will delete the object for you, since std::auto_ptr doesn't work in containers: #include struct AIData { // vector is fairly close to AS3's Array type, it is a good default for // arrays of changing or unknown size. std::vector predicates; // Destructor: will be run before the memory for this object is freed. ~AIData() { for (int i = 0; i != predicates.size(); ++i) { delete predicates[i]; } } }; ... ai[n].predicates.push_back(new AIFooIsLow()); ... for (int i = 0; i != ai[n].predicates.size(); ++i) { (*ai[n].predicates[i])(ai[n].object); } In C++0x: struct AIData { // unique_ptr will delete it for you, so no ~AIData() needed. std::vector > predicates; }; Your final example could in C++ look something like: std::auto_ptr shape(new Shape()); ... std::auto_ptr rule(new AIRule()); rule->predicates.push(new AIMemberEquals (0)); rule->predicates.push(new AIMemberGreater (64)); rule->actions.push(new AIAddMember (180.0)); rule->actions.push(new AISetMember (1)); shape->ai.push(rule); // .push(std::move(rule)); if you are using unique_ptr Certainly not as pretty, but it works and is fairly flexible.
