[site]: stackoverflow
[post_id]: 2465985
[parent_id]: 2465738
[tags]: 
It rather depends on what the codes are and how many there are. Good compilers have various tricks they use to optimise switch statements, some of which they won't employ with straight if/then statements. Most are bright enough to do simple maths or use lookup/jump tables for case 0, 1, 2 or case 3, 6, 9 for example. Of course some don't, and many are easily foiled by unusual or irregular sets of values. Also if code for handling several cases looks remarkably similar, cut and paste can lead to maintenance issues. If you have many codes but they can be divided algorithmically into groups, you might consider several/nested switch statements, for example rather than: switch (code) { case 0x0001: ... case 0x0002: ... ... case 0x8001: ... case 0x8002: ... ... } You might use: if (code & 0x8000) { code &= ~0x8000; switch (code) { case 0x0001: ... // actually 0x8001 case 0x0002: ... // actually 0x8002 ... } } else { switch (code) { case 0x0001: ... case 0x0002: ... ... } } Many language interpreters decode opcodes this way, since a single byte opcode may have additional information packed into various bits, and transcribing all possible combinations and their handlers would be repetitious and fragile. On the other hand, excessive bit mangling can defeat any optimisation by the compiler and be counter-productive. Unless you're sure this is a real performance bottleneck I'd avoid premature optimisation: do it whichever way strikes you as reasonably robust and quick to implement. As and if your application is running too slowly, profile it and optimise accordingly.
