[site]: stackoverflow
[post_id]: 3744849
[parent_id]: 3744601
[tags]: 
You want not a HashSet but a (sorted) tree or array as the value in the dictionary; the dictionary contains mappings from values you find in the input array to the (sorted) list of indices where that value appears. Then you do the following Look up the first entry in the query. Pick the lowest index where it appears. Look up the second entry; pick the lowest entry greater than the index of the first. Look up the third; pick the lowest greater than the second. (Etc.) When you reach the last entry in the query, (1 + last index - first index) is the size of the smallest match. Now pick the second index of the first query, repeat, etc. Pick the smallest match found from any of the starting indices. (Note that the "lowest entry greater" is an operation supplied with sorted trees, or can be found via binary search on a sorted array.) The complexity of this is approximately O(M*n*log n) where M is the length of the query and n is the average number of indices at which a given value appears in the input array. You can modify the strategy by picking that query array value that appears least often for the starting point and going up and down from there; if there are k of those entries ( k n ) then the complexity is O(M*k*log n) .
