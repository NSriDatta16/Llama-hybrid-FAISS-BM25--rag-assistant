[site]: stackoverflow
[post_id]: 4179006
[parent_id]: 4177746
[tags]: 
On x86 or x86_64, using p[i] or *(p+i) (note: these two forms are identical in the C language) may be faster than incrementing p at each step of the loop, assuming you need to keep i around for some other purpose already. The x86 architecture has efficient addressing for base/offset usage like this, including scaling the offset by small powers of 2. On the other hand, if you can eliminate i by incrementing p , you may reduce the number of registers needed in you loop, which could allow further optimization. Here are some quick thoughts on the relative cost in various cases on x86: If you array a has static storage duration ( static or extern global) in non-PIC-compiled code, the a[i] and *p (with no i ) methods use the same number of registers (e.g. 0xdeadbeef(,%ecx,4) vs (%esi) ). If Your array a is automatic (local stack variable) and not a variable-length array, the a[i] and *p methods use the same number of registers (e.g. 12(%esp,%ecx,4) vs (%esi) where %esp , the stack pointer, is already reserved anyway). If your array a has static storage duration and your code is compiled as PIC, a[i] is probably significantly more expensive than the *p method, even if you have to keep i around for another purpose anyway. If your array a is not an array variable in the current scope, but a pointer to an array passed to your function from somewhere else, then a[i] takes one more register than *p (e.g. (%eax,%ecx,4) vs (%esi) ).
