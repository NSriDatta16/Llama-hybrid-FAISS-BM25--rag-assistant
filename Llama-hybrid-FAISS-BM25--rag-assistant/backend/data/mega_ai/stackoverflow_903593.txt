[site]: stackoverflow
[post_id]: 903593
[parent_id]: 903573
[tags]: 
"did I miss something?" Yes. The thing works, does it not? And, more importantly, you can demonstrate that it works. The relative degree of complexity added for testability isn't very interesting when compared with the fact that it actually works and you can demonstrate that it actually works. Further, you can make changes and demonstrate that you didn't break it. The alternatives (may or may not work, no possibility of demonstrating if it works, can't make a change without breaking it) reduces the value of the software to zero. Edit "Complexity" is a slippery concept. There are objective measures of complexity. What's more important is the value created by an increase in complexity. Increasing complexity gives you testability, configurability, late binding, flexibility, and adaptability. Also, the objective measure of complexity are usually focused on coding within a method, not larger complexity of the relationships among classes and objects. Complexity seems objective, but it isn't defined at all layers of the software architecture. "Testability" is also slippery. There may be objective measures of testability. Mostly, however, these devolve to test coverage. And test coverage isn't a very meaningful metric. How does the possibility of a production crash vary with test coverage? It doesn't. You can blame complexity on a focus on testability. You can blame complexity on a lot of things. If you look closely at highly testable code, you'll find that it's also highly flexible, configurable and adaptable. Singling out "testability" as the root cause of "complexity" misses the point. The point is that there are numerous interrelated quality factors. "It Works" is a way of summarizing the most important ones. Other, less important ones, include adaptability, flexibility, maintainability. These additional factors usually correlate with testability, and they can also be described negatively as "complexity".
