[site]: stackoverflow
[post_id]: 5470956
[parent_id]: 
[tags]: 
Error in the delete function of the alarm app in iPhone

My app crashes whenever I press the Delete button from the simulator in iPhone. I have copied some code from my project here. How can I solve the delete bug? EnableAlarm.h file #import @interface EnableAlarm : UIViewController { IBOutlet UITableView *tableview; IBOutlet UIDatePicker *datePicker; IBOutlet UITextField *eventText; NSMutableArray *arraydata; } -(IBAction) btnReturn:(id) sender; @property (nonatomic, retain) IBOutlet UITableView *tableview; @property (nonatomic, retain) IBOutlet UIDatePicker *datePicker; @property (nonatomic, retain) IBOutlet UITextField *eventText; - (IBAction) scheduleAlarm:(id) sender; - (IBAction) EditTable:(id)sender; @end EnableAlarm.m #import "EnableAlarm.h" @implementation EnableAlarm -(IBAction) btnReturn:(id) sender { [self.view removeFromSuperview]; } @synthesize datePicker,tableview, eventText; - (void) viewWillAppear:(BOOL)animated { [self.tableview reloadData]; } - (IBAction) scheduleAlarm:(id) sender { [eventText resignFirstResponder]; NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; // Get the current date NSDate *pickerDate = [self.datePicker date]; // Break the date up into components NSDateComponents *dateComponents = [calendar components:( NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit ) fromDate:pickerDate]; NSDateComponents *timeComponents = [calendar components:( NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit ) fromDate:pickerDate]; // Set up the fire time NSDateComponents *dateComps = [[NSDateComponents alloc] init]; [dateComps setDay:[dateComponents day]]; [dateComps setMonth:[dateComponents month]]; [dateComps setYear:[dateComponents year]]; [dateComps setHour:[timeComponents hour]]; // Notification will fire in one minute [dateComps setMinute:[timeComponents minute]]; [dateComps setSecond:[timeComponents second]]; NSDate *itemDate = [calendar dateFromComponents:dateComps]; [dateComps release]; UILocalNotification *localNotif = [[UILocalNotification alloc] init]; if (localNotif == nil) return; localNotif.fireDate = itemDate; localNotif.timeZone = [NSTimeZone localTimeZone]; // Notification details localNotif.alertBody = [eventText text]; // Set the action button localNotif.alertAction = @"View"; localNotif.soundName = UILocalNotificationDefaultSoundName; localNotif.applicationIconBadgeNumber = 1; // Specify custom data for the notification NSDictionary *infoDict = [NSDictionary dictionaryWithObject:@"someValue" forKey:@"someKey"]; localNotif.userInfo = infoDict; // Schedule the notification [[UIApplication sharedApplication] scheduleLocalNotification:localNotif]; [localNotif release]; [self.tableview reloadData]; } #pragma mark - #pragma mark Table view data source - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { // Return the number of sections. return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { // Return the number of rows in the section. int count = [arraydata count]; if(self.editing) count++; return [[[UIApplication sharedApplication] scheduledLocalNotifications] count]; } // Customize the appearance of table view cells. - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @"Cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier] autorelease]; } int count = 0; if(self.editing && indexPath.row != 0) count = 1; // Configure the cell... NSArray *arraydata = [[UIApplication sharedApplication] scheduledLocalNotifications]; UILocalNotification *notif = [arraydata objectAtIndex:indexPath.row]; [cell.textLabel setText:notif.alertBody]; [cell.detailTextLabel setText:[notif.fireDate description]]; return cell; } - (IBAction) EditTable:(id)sender{ if(self.editing) { [super setEditing:NO animated:NO]; [tableview setEditing:NO animated:NO]; [tableview reloadData]; //[self.navigationItem.leftBarButtonItem setTitle:@"Edit"]; //[self.navigationItem.leftBarButtonItem setStyle:UIBarButtonItemStylePlain]; } else { [super setEditing:YES animated:YES]; [tableview setEditing:YES animated:YES]; [tableview reloadData]; //[self.navigationItem.leftBarButtonItem setTitle:@"Done"]; //[self.navigationItem.leftBarButtonItem setStyle:UIBarButtonItemStyleDone]; } } // Implement viewDidLoad to do additional setup after loading the view, typically from a nib. - (void)viewDidLoad { // arraydata = [[NSMutableArray alloc] initWithObjects:nil];; [super viewDidLoad]; } - (UITableViewCellEditingStyle)tableView:(UITableView *)aTableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath { // No editing style if not editing or the index path is nil. //if (self.editing == NO || !indexPath) return UITableViewCellEditingStyleNone; // Determine the editing style based on whether the cell is a placeholder for adding content or already // existing content. Existing content can be deleted. if (self.editing && indexPath.row == ([arraydata count])) { return UITableViewCellEditingStyleDelete; } else { return UITableViewCellEditingStyleDelete; } return UITableViewCellEditingStyleNone; } // Update the data model according to edit actions delete or insert. - (void)tableView:(UITableView *)TableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { [arraydata removeObjectAtIndex:indexPath.row]; NSString *item = [[arraydata objectAtIndex:indexPath.row] retain]; [arraydata removeObject:item]; [TableView removeFromSuperview:indexPath.row]; [item release]; //if (editingStyle == UITableViewCellEditingStyleDelete) { // [arraydata removeObjectAtIndex:indexPath.row]; // NSMutableArray * mArray = [NSMutableArray arrayWithContentsOfURL:theNewURL]; // [mArray removeObjectAtIndex:indexPath.row]; [tableview deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath]withRowAnimation:UITableViewRowAnimationFade]; [tableview reloadData]; } } #pragma mark Row reordering // Determine whether a given row is eligible for reordering or not. - (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath { return YES; } // Process the row move. This means updating the data model to correct the item indices. - (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath { NSString *item = [[arraydata objectAtIndex:fromIndexPath.row] retain]; [arraydata removeObject:item]; [arraydata insertObject:item atIndex:toIndexPath.row]; [item release]; } // The designated initializer. Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad. /* - (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { // Custom initialization. } return self; } */ /* // Override to allow orientations other than the default portrait orientation. - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { // Return YES for supported orientations. return (interfaceOrientation == UIInterfaceOrientationPortrait); } */ - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc. that aren't in use. } - (void)viewDidUnload { [super viewDidUnload]; datePicker = nil; tableview = nil; eventText = nil; // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; } - (void)dealloc { [super dealloc]; } @end
