[site]: stackoverflow
[post_id]: 5692297
[parent_id]: 5691740
[tags]: 
what you are trying to do is an upcoming current feature of C++ called "initializer lists", where a vector or list can be initialized with = { }. I don't know if they have come out with it in TR1 or not. maybe it's in TR2. #include #include #include using namespace std; int main(void) { vector vi = {1, 2, 3, 4, 5}; list li = {5, 4, 3, 2, 1, 0}; cout the code you are using doesn't look proper to me. If you want to implement structures that contain structures (a tree), include a list of pointers to the structures/nodes (or just void pointers if that's not implementable) within the node. most menu structures are essentially an ordered list-based tree (n nodes in one place, but could be m nodes elsewhere, etc). Robert Sedgewick makes a textbook "Algorithms in C++". #include #include #include void * pRoot = NULL; //pointer to CTree class CTreenode; class CTree; class CTree { public: vector lctnNodeList; //list does not have at() or operator[] vector ::iterator lctni; public: CTree() {} ~CTree() { for (lctni=lctnNodeList.begin(); lctni != lctnNodeList.end(); nctni++) { if (NULL==lctni->getChildPtr()) { //do nothing, we have already done all we can } else { delete (CTree *)lctnNodeList.pChild; } //do action here } } void addToList(string& data, CTree * p) { CTreeNode ctn(data, p); lctnNodeList.push_back(d); } void eraseAt(size_t index) { vector ::iterator i = lctnNodeList.begin(); vector ::iterator i2 = lctnNodeList.begin(); i2++; size_t x; for (x=0; x ::iterator i = lctnNodeList.begin(); size_t x; for (x=0; x getData(returndata, p); break; } } } const CTreeNode& operator[](const size_t idx) { if (idx lctni=pct->lctnNodeList.begin(); pct->lctni != pct->lctnNodeList.end(); pct->nctni++) { //this is a depth-first traversal. if (NULL==pct->lctni->getChildPtr()) { //do nothing, we have already done all we can //we do this if statement to prevent infinite recursion } else { //at this point, recursively entering child domain doActionToThisSubtree(pct->lctni->getChildPtr()); //at thisd point, exiting child domain } //do Action on CTreeNode node pct->lctni-> here. } } }; class CTreeNode { public: CTree * pChild; //CTree *, may have to replace with void * string sData; public: CTreeNode() : pChild(NULL) {} CTreeNode(string& data, pchild) : pChild(pchild) { sData = data; } ~CTreeNode() { if (NULL!=pChild) { delete pChild;//delete (CTree *)pChild; pChild = NULL; } void getChild(CTreeNode& child) { child = *pChild;//child = *((CTree *)pChild); } bool addChild(string& s) { if (NULL==pChild) { return false; } else { pChild = new CTree; } return true; } void * getChildPtr() { return pChild; } void getData(string& data, CTree * &p) { //not sure about how to put the & in there on CTree data=sData; p = pChild; } void setData(string& data, CTree * p) { sData=data; pChild = p; } }; the problem is mutual dependency here, and I think I have it resolved with the class declaration. do class CTreeNode; before class CTree {}. http://www.codeguru.com/forum/showthread.php?t=383253 I am probably mangling this code, and it's incomplete, because I haven't had the need to write a tree in years, but I think I've covered the basics. I didn't implement operator[].
