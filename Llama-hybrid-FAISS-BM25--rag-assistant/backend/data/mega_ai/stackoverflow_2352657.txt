[site]: stackoverflow
[post_id]: 2352657
[parent_id]: 2352533
[tags]: 
(I do propose a solution down further... bear with me...) One way to (almost) solve your problem is to use a Visitor design pattern. Something like this: class DrawVisitor { public: void draw(const Shape &shape); // dispatches to correct private method private: void visitSquare(const Square &square); void visitCircle(const Circle &circle); }; Then instead of this: Shape &shape = getShape(); // returns some Shape subclass shape.draw(); // virtual method You would do: DrawVisitor dv; Shape &shape = getShape(); dv.draw(shape); Normally in a Visitor pattern you would implement the draw method like this: DrawVisitor::draw(const Shape &shape) { shape.accept(*this); } But that only works if the Shape hierarchy was designed to be visited: each subclass implements the virtual method accept by calling the appropriate visitXxxx method on the Visitor. Most likely it was not designed for that. Without being able to modify the class hierarchy to add a virtual accept method to Shape (and all subclasses), you need some other way to dispatch to the correct draw method. One naieve approach is this: DrawVisitor::draw(const Shape &shape) { if (const Square *pSquare = dynamic_cast (&shape)) { visitSquare(*pSquare); } else if (const Circle *pCircle = dynamic_cast (&shape)) { visitCircle(*pCircle); } // etc. } That will work, but there is a performance hit to using dynamic_cast that way. If you can afford that hit, it is a straightforward approach that is easy to understand, debug, maintain, etc. Suppose there was an enumeration of all shape types: enum ShapeId { SQUARE, CIRCLE, ... }; and there was a virtual method ShapeId Shape::getId() const = 0; that each subclass would override to return its ShapeId . Then you could do your dispatch using a massive switch statement instead of the if-elsif-elsif of dynamic_cast s. Or perhaps instead of a switch use a hashtable. The best case scenario is to put this mapping function in one place, so that you can define multiple visitors without having to repeat the mapping logic each time. So you probably don't have a getid() method either. Too bad. What's another way to get an ID that is unique for each type of object? RTTI. This is not necessarily elegant or foolproof, but you can create a hashtable of type_info pointers. You can build this hashtable in some initialization code or build it dynamically (or both). DrawVisitor::init() // static method or ctor { typeMap_[&typeid(Square)] = &visitSquare; typeMap_[&typeid(Circle)] = &visitCircle; // etc. } DrawVisitor::draw(const Shape &shape) { type_info *ti = typeid(shape); typedef void (DrawVisitor::*VisitFun)(const Shape &shape); VisitFun visit = 0; // or default draw method? TypeMap::iterator iter = typeMap_.find(ti); if (iter != typeMap_.end()) { visit = iter->second; } else if (const Square *pSquare = dynamic_cast (&shape)) { visit = typeMap_[ti] = &visitSquare; } else if (const Circle *pCircle = dynamic_cast (&shape)) { visit = typeMap_[ti] = &visitCircle; } // etc. if (visit) { // will have to do static_cast<> inside the function ((*this).*(visit))(shape); } } Might be some bugs/syntax errors in there, I haven't tried compiling this example. I have done something like this before -- the technique works. I'm not sure if you might run into problems with shared libraries though. One last thing I'll add: regardless of how you decide to do the dispatch, it probably makes sense to make a visitor base class: class ShapeVisitor { public: void visit(const Shape &shape); // not virtual private: virtual void visitSquare(const Square &square) = 0; virtual void visitCircle(const Circle &circle) = 0; };
