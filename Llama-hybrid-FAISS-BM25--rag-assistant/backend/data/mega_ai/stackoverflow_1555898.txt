[site]: stackoverflow
[post_id]: 1555898
[parent_id]: 1555660
[tags]: 
Imagine that you have an interface for interacting with some storage facility. The client/user of the interface should be able to store and retrieve objects. Furthermore, you'll have 'kinds' of objects in the storage, and when storing or retrieving, the client must specify what kind of object they're storing or retrieving. Because we like types and abhor strings, they'll do it with types. So: interface ObjectStorage { void storeObject( object, type ); object retrieveObject( type ); } An implementation of the interface would like to specify only the types that it is able to handle, and so defines the types to go with the implementation of the interface. The 'consistent abstraction' in this context would mean that the abstraction of the interface should be on the same level. An inconsistent abstraction would be defining the types of the implementation in the interface, like so: interface ObjectStorage { void storeObject( object, FileType ); FileType retrieveObject( FileType ); } this would bind any implementation to work solely with FileType s or subtypes thereof. I hope I was somewhat coherent in my answer.
