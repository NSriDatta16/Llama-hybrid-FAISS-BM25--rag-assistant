[site]: stackoverflow
[post_id]: 2786445
[parent_id]: 2786417
[tags]: 
"But In worst case, this is O(N M). is there a better efficient algorithm?" Probably not due to the dimension of the data being O(N M). Many matrix operations like this are of order M N because in the worst case there are M N elements that will all need to be checked in the case that the matrices are equal. Looking at the average case is more interesting, if the difference box is necessarily a single rectangle within the whole matrix then I suspect you could get away with scanning less than all the elements on average. Here's a quick though I had: keep track of the current element, call this XY Start at top left corner so XY is the top corner now Check that elements XY in both are equal, if not equal go to 3 else go to 4 If the elements are not then you have an element of the difference matrix. Record this element then search that row and column for the other elements (maybe something like binary search is fastest). Once the row/column is searched you have the coordinates of the edges. If elements are not equal move to 4. Next step move XY diagonally one element down and one element right, then go to 2 again once a diagonal is covered then you will need to test along the next diagonal ( I suspect that choosing a new diagonal that is the furthest away from the current diagonal will be the best, though I have no proof that this is the best choice) until all the elements are covered. Worst case this is still O(N*M) but it might be faster in the average case. Essentially you are trying to one different element as fast as possible, so the aim is choosing the first element in such a way to minimize the expected value of the number of searches to find the first different element.
