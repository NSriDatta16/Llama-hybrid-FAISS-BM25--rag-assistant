[site]: stackoverflow
[post_id]: 4207266
[parent_id]: 4034908
[tags]: 
If you want to get old value of x and a is not changed, use (x-a) as old value: fetch_and_add(int *x, int a) { #pragma omp atomic *x += a; return (*x-a); } UPDATE: it was not really an answer, because x can be modified after atomic by another thread. So it's seems to be impossible to make universal "Fetch-and-add" using OMP Pragmas. As universal I mean operation, which can be easily used from any place of OMP code. You can use omp_*_lock functions to simulate an atomics: typedef struct { omp_lock_t lock; int value;} atomic_simulated_t; fetch_and_add(atomic_simulated_t *x, int a) { int ret; omp_set_lock(x->lock); x->value +=a; ret = x->value; omp_unset_lock(x->lock); } This is ugly and slow (doing a 2 atomic ops instead of 1). But If you want your code to be very portable, it will be not the fastest in all cases. You say "as the following (only non-locking)". But what is the difference between "non-locking" operations (using CPU's "LOCK" prefix, or LL/SC or etc) and locking operations (which are implemented itself with several atomic instructions, busy loop for short wait of unlock and OS sleeping for long waits)?
