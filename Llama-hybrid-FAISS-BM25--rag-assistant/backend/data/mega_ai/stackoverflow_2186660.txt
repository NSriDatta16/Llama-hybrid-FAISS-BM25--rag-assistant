[site]: stackoverflow
[post_id]: 2186660
[parent_id]: 2186459
[tags]: 
I'm under the impression that you're trying to involve MonadError for the wrong reason. In the try (many1 parser1) parser2 , the behaviour you're trying to avoid stems from the use of try and -- if you don't like it, use different combinators. Perhaps an expression like (many1 parser1) >> parser2 would work better for you? (This discards the results from (many1 parser1) ; you could of course use >>= and combine the results from (many1 parser1) with those from parser2 .) (Note: Below this point, there is no really good solution to the problem at hand, just some musings as to why some things probably won't work... Hopefully this may be (somewhat) enlightening, but don't expect too much.) A closer examination of ParsecT / MonadError interaction. I'm afraid it's a bit messy and I'm still not really sure how best to go about doing what the OP wants to do, but I'm hoping the following will at least provide insight into the reasons for the lack of success of the original approach. Firstly, note that it is not correct to say that Parsec is an instance of MonadError . Parsec is the monad produced by ParsecT when the inner monad is Identity; ParsecT produces instances of MonadError if and only if it is given an inner monad which is itself an instance of MonadError to work with. Relevant fragments of GHCi interactions: > :i Parsec type Parsec s u = ParsecT s u Identity -- Defined in Text.Parsec.Prim -- no MonadError instance instance (MonadError e m) => MonadError e (ParsecT s u m) -- Defined in Text.Parsec.Prim -- this explains why the above is the case -- (a ParsecT-created monad will only become an instance of MonadError through -- this instance, unless of course the user provides a custom declaration) Next, let's have ourselves a working example with catchError and ParsecT . Consider this GHCi interaction: > (runParserT (char 'a' >> throwError "some error") () "asdf" "a" :: Either String (Either ParseError Char)) `catchError` (\e -> Right . Right $ 'z') Right (Right 'z') The type annotation appears necessary (this seems to make intuitive sense to me, but it isn't pertinent to the original question, so I won't try to elaborate). The type of the whole expression is determined by GHC to be as follows: Either String (Either ParseError Char) So, we've got a regular parse result -- Either ParseError Char -- wrapped in the Either String monad in place of the usual Identity monad. Since Either String is an instance of MonadError , we can use throwError / catchError , but the handler passed to catchError must of course produce a value of the correct type. That's not very useful for breaking out of the parsing routine, I'm afraid. Back to the example code from the question. That does a slightly different thing. Let's examine the type of ret as defined in the question: forall (m :: * -> *) a. (Monad m) => m (Either [Char] (Either ParseError a)) (According to GHCi... note that I had to lift the monomorphism restriction with {-# LANGUAGE NoMonomorphismRestriction #-} to have the code compile without type annotations.) That type is a hint as to the possibility of doing something amusing with ret . Here we go: > runParserT ret () "asdf" "a" Right (Left "some error") In hindsight, the handler given to catchError produces a value using unexpected , so of course it's going to be (usable as) a parser... And I'm afraid I don't see how to hammer this into something useful for breaking out of the parsing process.
