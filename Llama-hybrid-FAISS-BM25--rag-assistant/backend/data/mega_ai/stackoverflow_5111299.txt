[site]: stackoverflow
[post_id]: 5111299
[parent_id]: 4640536
[tags]: 
Looking back at the results gathered so far, there are a couple of solutions suggested: Use pattern matching (leads to fragmentation of the different strategies of dealing with the different parameter types) Use reflection (to expensive for something that ideally should be super fast ) ... and adding the one that I eventually ended up implementing: write an adapter per type of parameter. To be a little more precise, the whole exercise was about writing a wrapper around Kyoto Cabinet. Kyoto Cabinet has methods for associating byte array keys with byte array values and String keys with String values. And then it basically replicates most of the operations for dealing with keys and values for both byte array as well as Strings. In order to create a Map wrapper around Kyoto Cabinet's DB class, I defined a trait TypedDBOperations[T], with T being the type of parameter, and had it implemented twice. If I now construct a Map[Array[Byte], Array[Byte]], an implicit conversion will automatically assign it the proper instane of TypedDBOperations, calling the Array[Byte] based operations of the DB class. This is the trait that I have been talking about: trait TypedDBOperations[K,V] { def get(db: DB, key: K): V def set(db: DB, key: K, value: V): Boolean def remove(db: DB, key: K): Boolean def get(cursor: Cursor): (K, V) } And these are the implementations for both type of key value combinations: implicit object StringDBOperations extends TypedDBOperations[String] { def get(cursor: Cursor) = { val Array(a, b) = cursor.get_str(false) (a, b) } def remove(db: DB, key: String) = db.remove(key) def set(db: DB, key: String, value: String) = db.set(key, value) def get(db: DB, key: String) = db.get(key) } implicit object ByteArrayOperations extends TypedDBOperations[Array[Byte]] { def get(cursor: Cursor) = { val Array(a, b) = cursor.get(false) (a, b) } def remove(db: DB, key: Array[Byte]) = db.remove(key) def set(db: DB, key: Array[Byte], value: Array[Byte]) = db.set(key, value) def get(db: DB, key: Array[Byte]) = db.get(key) } Not the most satisfying solution ever, but it gets the job done. Again, note there still is quite a bit of duplication, but it seems there's no way to get rid of it.
