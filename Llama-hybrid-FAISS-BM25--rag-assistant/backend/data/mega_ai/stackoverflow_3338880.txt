[site]: stackoverflow
[post_id]: 3338880
[parent_id]: 3338859
[tags]: 
There is a trick here, that I have used before; you do something like an Expression > , and embed the fetch-by-index and casting inside the expression. Then you have as many parameters as you could want, a single signature, and reasonable performance. It does , however, make writing the lambda a bit tricker. I don't have my old code for this "to hand", but if I needed to reverse engineer it, I would simply write something typical like the following, and then look in reflector to see what it used: Expression > func = arr => ((string)arr[0]) + (int)arr[1]; (in particular, paying attention to the indexer usage, the casting from inputs , and the casting to output )
