[site]: stackoverflow
[post_id]: 3006045
[parent_id]: 3004795
[tags]: 
I worked with .net for about 3-4 years, and java for 3 years before that, now I work at a rails shop. Learning basic syntax is dead simple. Wrapping your head around some of the concepts will take a lot longer. As a bit of a checklist how instance variables work and are set (very different then c#) how everything related to methods is just sugar for message passing what self means at any given part of your code (especially self in class declaration scope vs method declaration scope) mixins when to use a module, when to use a class how classes are just a different kind of object This is the simple stuff. After that, you want to be learning more of this stuff learning about the more commonly used language level callbacks (like method_missing and included) wrapping your head around methods that define methods understanding blocks, coroutines, procs, and how they all work together (this is probably number one) understanding how method parsing works, and choosing the right amount of () or {} that will result in the least typing wrapping your head around object individuation (this took a while for me) stop using objects for everything, and stick to hashes where appropriate learn when meta-programming is appropriate, and when it isn't (many, many rubyists out there do not know this well) learning how to solve common problems with these new tools in better ways then is possible with something like C# (Builders, Adapters, and Strategies stand out to me as the most radically different in terms of GoF patterns) It is hard to say how long this will take. For me, the first bits took about a month of playing with ruby and reading books. The second half probably took more like three or four (although there was rails learning in there too) As for MySQL/pg, its not like you have to start completely from scratch. The tooling isn't as great as SSMS (imo, the best part of the MS stack), but it is enough to get by. If you use rails, most of the database stuff is abstracted away. If you need to check out something in the db, nine times out of ten you fire up a script/console and just use the ActiveRecord api (which is out of this world amazing) EDIT: Object Individuation means that each object instance is its own "thing", which is based on a class, but may not just be that class. here are some examples first, we build a class irb(main):001:0> class TestClass irb(main):002:1> def tc irb(main):003:2> puts 'testclass method' irb(main):004:2> end irb(main):005:1> end => nil now we instantiate it twice irb(main):006:0> t1 = TestClass.new => # irb(main):007:0> t2 = TestClass.new => # def a method that is only on t2 irb(main):008:0> def t2.only_on_t2 irb(main):009:1> puts 'this will not be accessible anywhere else' irb(main):010:1> end => nil irb(main):011:0> t1.only_on_t2 NoMethodError: undefined method `only_on_t2' for # from (irb):11 from :0 irb(main):012:0> t2.only_on_t2 this will not be accessible anywhere else => nil redefine a method that is pulled in from the class, but only on t1 irb(main):013:0> def t1.tc irb(main):014:1> puts 'redeffing something picked up from the class' irb(main):015:1> end => nil irb(main):016:0> t1.tc redeffing something picked up from the class => nil irb(main):017:0> t2.tc testclass method => nil The above code is extremely rare to see, because having a bunch of method definition stuff inline in another method is generally pretty ugly. Mixing in modules with specific instances is pretty powerful though, especially when you take duck typing into account. irb(main):018:0> module TestModule irb(main):019:1> def tm irb(main):020:2> puts 'this is where it gets interesting' irb(main):021:2> end irb(main):022:1> end => nil irb(main):023:0> t2.extend TestModule => # irb(main):024:0> t2.tm this is where it gets interesting => nil irb(main):025:0> t1.tm NoMethodError: undefined method `tm' for # from (irb):25 from :0 irb(main):026:0> t1.is_a? TestModule => false irb(main):027:0> t2.is_a? TestModule => true This is more advanced stuff, and is one of those things that is the last thing you should be reaching for, but there are cases where doing an on the fly extend is a much more elegant solution to a problem then the alternatives (which is a common warning with most advanced ruby stuff, don't do it this way because you can, only do it when you need to)
