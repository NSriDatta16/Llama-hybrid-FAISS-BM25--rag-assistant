[site]: stackoverflow
[post_id]: 5255217
[parent_id]: 
[tags]: 
OpenGL program error. need help

// // This code was created by Lionel Brits / Jeff Molofee '99 // // If you've found this code useful, please let me know. // // Visit NeHe Productions at www.demonews.com/hosted/nehe // /**************************************************************/ // This code was ported to MacOS by Tony Parker. // I'd also appreciate it if you could drop me a line if you found // this code useful. // // Tony Parker - asp@usc.edu // // Have a nice day. #include // Header File For Standard Input / Output #include // Header File For Variable Argument Routines #include // Header File For String Management #include #include #include // Header File For The OpenGL32 Library #include // Header File For The GLu32 Library #include // Header File For The GLUT Library #include "math.h" #include "model.h" // Constants ---------------------------------------------------------------------- #define kWindowHeight 400 #define kWindowWidth 400 // Structures ---------------------------------------------------------------- typedef struct // Create A Structure { GLubyte *imageData; // Image Data (Up To 32 Bits) GLuint bpp; // Image Color Depth In Bits Per Pixel. GLuint width; // Image Width GLuint height; // Image Height GLuint texID; // Texture ID Used To Select A Texture } TextureImage; // Structure Name // Function Prototypes ------------------------------------------------------- bool LoadTGA(TextureImage *texture, char *filename); float rad(float angle); void readstr(FILE *f,char *string); void SetupWorld(void); GLvoid InitGL(GLvoid); GLvoid DrawGLScene(GLvoid); GLvoid ReSizeGLScene(int Width, int Height); GLvoid Idle(GLvoid); GLvoid LoadGLTextures(void); GLvoid Keyboard(unsigned char key, int x, int y); // Global Variables ---------------------------------------------------------- char *worldfile = "world.txt"; bool light; // Lighting ON/OFF bool gBlend; // Blending ON/OFF GLfloat xrot; // X Rotation GLfloat yrot; // Y Rotation GLfloat xspeed; // X Rotation Speed GLfloat yspeed; // Y Rotation Speed GLfloat walkbias = 0; GLfloat walkbiasangle = 0; GLfloat lookupdown = 0.0f; const float piover180 = 0.0174532925f; float heading, xpos, zpos; GLfloat camx=0, camy=0, camz=0; // Camera Location GLfloat therotate; GLfloat z=0.0f; // Depth Into The Screen GLfloat LightAmbient[] = { 0.5f, 0.5f, 0.5f, 1.0f }; // Ambient Light GLfloat LightDiffuse[] = { 1.0f, 1.0f, 1.0f, 1.0f }; // Diffuse Light GLfloat LightPosition[] = { 0.0f, 0.0f, 2.0f, 1.0f }; // Light Position GLuint filter; // Which Filter To Use TextureImage texture[3]; // Storage for 3 textures // Our Model Goes Here: SECTOR sector1; // rad ----------------------------------------------------------------------- // Converts Degrees To Radians. There Are 2 PI Radians In 360 Degrees. float rad(float angle) { return angle * piover180; } // readstr ------------------------------------------------------------------- void readstr(FILE *f,char *string) { do { fgets(string, 255, f); } while ((string[0] == '/') || (string[0] == '\n')); return; } // SetupWorld ---------------------------------------------------------------- void SetupWorld(void) { float x, y, z, u, v; int numtriangles; FILE *filein; char oneline[255]; filein = fopen(worldfile, "rt"); readstr(filein,oneline); sscanf(oneline, "NUMPOLLIES %d\n", &numtriangles); sector1.triangle = new TRIANGLE[numtriangles]; sector1.numtriangles = numtriangles; int loop; for ( loop = 0; loop 2) { filter = 0; } break; case 'l': light = !light; if (!light) glDisable(GL_LIGHTING); else glEnable(GL_LIGHTING); break; case 'w': // walk forward xpos -= (float)sin(heading*piover180) * 0.05f; zpos -= (float)cos(heading*piover180) * 0.05f; if (walkbiasangle >= 359.0f) walkbiasangle = 0.0f; else walkbiasangle+= 10; walkbias = (float)sin(walkbiasangle * piover180)/20.0f; //lookupdown -= 1.0f; break; case 'x': // walk back xpos += (float)sin(heading*piover180) * 0.05f; zpos += (float)cos(heading*piover180) * 0.05f; if (walkbiasangle sizeX, texture1->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, texture1->data); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, texture[0].width, texture[0].height, 0, GL_RGB, GL_UNSIGNED_BYTE, texture[0].imageData); // Create Linear Filtered Texture glBindTexture(GL_TEXTURE_2D, texture[1].texID); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); //glTexImage2D(GL_TEXTURE_2D, 0, 3, texture1->sizeX, texture1->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, texture1->data); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, texture[1].width, texture[1].height, 0, GL_RGB, GL_UNSIGNED_BYTE, texture[1].imageData); // Create MipMapped Texture glBindTexture(GL_TEXTURE_2D, texture[2].texID); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST); gluBuild2DMipmaps(GL_TEXTURE_2D, 3, texture[2].width, texture[2].height, GL_RGB, GL_UNSIGNED_BYTE, texture[2].imageData); } /********************> LoadTGA() width = header[1] * 256 + header[0]; // Determine The TGA Width (highbyte*256+lowbyte) texture->height = header[3] * 256 + header[2]; // Determine The TGA Height (highbyte*256+lowbyte) if( texture->width height bpp = header[4]; // Grab The TGA's Bits Per Pixel (24 or 32) bytesPerPixel = texture->bpp/8; // Divide By 8 To Get The Bytes Per Pixel imageSize = texture->width*texture->height*bytesPerPixel; // Calculate The Memory Required For The TGA Data texture->imageData=(GLubyte *)malloc(imageSize); // Reserve Memory To Hold The TGA Data if( texture->imageData==NULL || // Does The Storage Memory Exist? fread(texture->imageData, 1, imageSize, file)!=imageSize) // Does The Image Size Match The Memory Reserved? { if(texture->imageData!=NULL) // Was Image Data Loaded free(texture->imageData); // If So, Release The Image Data fclose(file); // Close The File return false; // Return False } GLuint i; for( i=0; i imageData[i]; // Temporarily Store The Value At Image Data 'i' texture->imageData[i] = texture->imageData[i + 2]; // Set The 1st Byte To The Value Of The 3rd Byte texture->imageData[i + 2] = temp; // Set The 3rd Byte To The Value In 'temp' (1st Byte Value) } fclose (file); // Close The File if (texture[0].bpp==24) // Was The TGA 24 Bits { type=GL_RGB; // If So Set The 'type' To GL_RGB } // Build A Texture From The Data // We're doing this in a different function in this tutorial glGenTextures(1, &texture[0].texID); // Generate OpenGL texture IDs /* glBindTexture(GL_TEXTURE_2D, texture[0].texID); // Bind Our Texture glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); // Linear Filtered glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Linear Filtered glTexImage2D(GL_TEXTURE_2D, 0, type, texture[0].width, texture[0].height, 0, type, GL_UNSIGNED_BYTE, texture[0].imageData); */ return true; // Texture Building Went Ok, Return True } NEED HELP. I got this error: /Users/ /Desktop/XcodeGLUT/../gora.cs.illinois.edu:display:cs418sp11:Home/Lesson 10 Folder/main.c:126:0 /Users/ /Desktop/XcodeGLUT/../gora.cs.illinois.edu:display:cs418sp11:Home/Lesson 10 Folder/main.c:126: error: 'new' undeclared (first use in this function)
