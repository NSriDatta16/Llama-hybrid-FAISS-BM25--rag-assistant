[site]: stackoverflow
[post_id]: 1978102
[parent_id]: 1952201
[tags]: 
It seems to me that you are operating on at least one false assumption. 1. You don't need to raise the ProgressChanged event to have a responsive UI In your question you say this: BackgroundWorker is not the answer because it may be that I don't get the progress notification, which means there would be no call to ProgressChanged as the DoWork is a single call to an external function . . . Actually, it does not matter whether you call the ProgressChanged event or not . The whole purpose of that event is to temporarily transfer control back to the GUI thread to make an update that somehow reflects the progress of the work being done by the BackgroundWorker . If you are simply displaying a marquee progress bar, it would actually be pointless to raise the ProgressChanged event at all . The progress bar will continue rotating as long as it is displayed because the BackgroundWorker is doing its work on a separate thread from the GUI . (On a side note, DoWork is an event, which means that it is not just "a single call to an external function"; you can add as many handlers as you like; and each of those handlers can contain as many function calls as it likes.) 2. You don't need to call Application.DoEvents to have a responsive UI To me it sounds like you believe that the only way for the GUI to update is by calling Application.DoEvents : I need to keep call the Application.DoEvents(); for the progress bar to keep rotating. This is not true in a multithreaded scenario ; if you use a BackgroundWorker , the GUI will continue to be responsive (on its own thread) while the BackgroundWorker does whatever has been attached to its DoWork event. Below is a simple example of how this might work for you. private void ShowProgressFormWhileBackgroundWorkerRuns() { // this is your presumably long-running method Action exec = DoSomethingLongAndNotReturnAnyNotification; ProgressForm p = new ProgressForm(this); BackgroundWorker b = new BackgroundWorker(); // set the worker to call your long-running method b.DoWork += (object sender, DoWorkEventArgs e) => { exec.Invoke(path, parameters); }; // set the worker to close your progress form when it's completed b.RunWorkerCompleted += (object sender, RunWorkerCompletedEventArgs e) => { if (p != null && p.Visible) p.Close(); }; // now actually show the form p.Show(); // this only tells your BackgroundWorker to START working; // the current (i.e., GUI) thread will immediately continue, // which means your progress bar will update, the window // will continue firing button click events and all that // good stuff b.RunWorkerAsync(); } 3. You can't run two methods at the same time on the same thread You say this: I just need to call Application.DoEvents() so that the Marque progress bar will work, while the worker function works in the Main thread . . . What you're asking for is simply not real . The "main" thread for a Windows Forms application is the GUI thread, which, if it's busy with your long-running method, is not providing visual updates. If you believe otherwise, I suspect you misunderstand what BeginInvoke does: it launches a delegate on a separate thread . In fact, the example code you have included in your question to call Application.DoEvents between exec.BeginInvoke and exec.EndInvoke is redundant; you are actually calling Application.DoEvents repeatedly from the GUI thread, which would be updating anyway . (If you found otherwise, I suspect it's because you called exec.EndInvoke right away, which blocked the current thread until the method finished.) So yes, the answer you're looking for is to use a BackgroundWorker . You could use BeginInvoke , but instead of calling EndInvoke from the GUI thread (which will block it if the method isn't finished), pass an AsyncCallback parameter to your BeginInvoke call (instead of just passing null ), and close the progress form in your callback. Be aware, however, that if you do that, you're going to have to invoke the method that closes the progress form from the GUI thread, since otherwise you'll be trying to close a form, which is a GUI function, from a non-GUI thread. But really, all the pitfalls of using BeginInvoke / EndInvoke have already been dealt with for you with the BackgroundWorker class, even if you think it's ".NET magic code" (to me, it's just an intuitive and useful tool).
