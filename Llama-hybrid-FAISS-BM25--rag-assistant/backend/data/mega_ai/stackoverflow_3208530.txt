[site]: stackoverflow
[post_id]: 3208530
[parent_id]: 3208449
[tags]: 
You probably need to explicitly upcast your return values: let spread (spr: Spreader) = match spr with | :? Fire -> (Fire() :> Spreader) | :? Disease -> (Disease() :> Spreader) This is a very unusual programming style though. What exactly are you trying to do? EDIT I still don't understand what you are trying to accomplish. Why are you using augmentations and members? Why do you want burn to apply to Speader types when it is only applicable to one? What is the purpose of your Fn member? Why did you use an abstract class instead of an interface? Why did you define strength as an alias for float32 ? What is the actual concrete problem you are trying to solve?! What about this: type fire = ... let burn fire = ... type spreader = Disease | Fire of fire let spread = function | Disease -> ... | Fire fire -> ... Basically, if you have functions that only apply to a subset of spreaders then you need to separate concerns somehow. Either by indirecting through new types (as above) or by using OOP and making the subset of classes implement an interface.
