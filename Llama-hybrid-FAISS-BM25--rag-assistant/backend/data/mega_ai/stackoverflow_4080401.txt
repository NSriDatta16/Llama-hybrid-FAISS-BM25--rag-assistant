[site]: stackoverflow
[post_id]: 4080401
[parent_id]: 4080217
[tags]: 
Redefining Classes You can do this with the runkit PECL extension aka the "Toolkit from Hell": runkit_class_adopt — Convert a base class to an inherited class, add ancestral methods when appropriate runkit_class_emancipate — Convert an inherited class to a base class, removes any method whose scope is ancestral Redefining Instances The runkit functions do not work on object instances. If you want to do that on object instances, you could theoretically do that by messing with the serialized object strings. This is the realms of black magic though. The code below allows you to change an instance to whatever other class: function castToObject($instance, $className) { if (!is_object($instance)) { throw new InvalidArgumentException( 'Argument 1 must be an Object' ); } if (!class_exists($className)) { throw new InvalidArgumentException( 'Argument 2 must be an existing Class' ); } return unserialize( sprintf( 'O:%d:"%s"%s', strlen($className), $className, strstr(strstr(serialize($instance), '"'), ':') ) ); } Example: class Foo { private $prop1; public function __construct($arg) { $this->prop1 = $arg; } public function getProp1() { return $this->prop1; } } class Bar extends Foo { protected $prop2; public function getProp2() { return $this->prop2; } } $foo = new Foo('test'); $bar = castToObject($foo, 'Bar'); var_dump($bar); Result: object(Bar)#3 (2) { ["prop2":protected]=> NULL ["prop1":"Foo":private]=> string(4) "test" } As you can see, the resulting object is a Bar object now with all properties retaining their visibility but prop2 is NULL . The ctor doesnt allow this, so technically, while you have a Bar child of Foo , it is not in a valid state. You could add a magic __wakeup method to handle this somehow, but seriously, you dont want that and it shows why casting is ugly business. DISCLAIMER: I absolutely do not encourage anyone to use any of these solutions in production.
