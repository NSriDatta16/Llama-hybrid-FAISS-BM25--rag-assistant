[site]: stackoverflow
[post_id]: 4209165
[parent_id]: 4208444
[tags]: 
This really depends on the context of where the declarations occur. Outside of a function parameter definition, the declaration T a[]; declares a as an unknown -sized array of T; the array type is incomplete , so unless a is defined elsewhere (either in this translation unit or another translation unit that gets linked) then no storage is set aside for it (and you will probably get an "undefined reference" error if you attempt to link, although I think gcc's default behavior is to define the array with 1 element) . It cannot be used as an operand to the sizeof operator. It can be used as an operand of the & operator. For example: /** * module1.c */ extern char *a[]; /* non-defining declaration of a */ void foo() { size_t i = 0; for (i = 0; a[i] != NULL; i++) printf("a[%lu] = %s\n", (unsigned long) i, a[i++]); } module1.c uses a non-defining declaration of a to introduce the name so that it can be used in the function foo , but since no size is specified, no storage is set aside for it in this translation unit. Most importantly, the expression a is not a pointer type ; it is an incomplete array type. It will be converted to a pointer type in the call to printf by the usual rules. /** * module2.c */ char *a[] = {"foo", "bar", "bletch", "blurga", NULL}; /* defining declaration of a */ int main(void) { void foo(); foo(); return 0; } module2.c contains a defining declaration for a (the size of the array is computed from the number of elements in the initializer), which causes storage to be allocated for the array. Style note: please don't ever write code like this. In the context of a function parameter declaration, T a[] is synonymous with T *a ; in both cases, a is a pointer type. This is only true in the context of a function parameter declaration.
