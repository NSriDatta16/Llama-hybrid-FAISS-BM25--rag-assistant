[site]: stackoverflow
[post_id]: 3535179
[parent_id]: 3535157
[tags]: 
If the "throw" statement in question is truly unreachable under any possible scenario then it should be deleted and replaced with: Debug.Fail("This should be unreachable; please find and fix the bug that caused this to be reached."); If the code is reachable then write a unit test that tests that scenario. Error-reporting scenarios for public-accessible methods are perfectly valid scenarios. You have to handle all inputs correctly, even bad inputs. If the correct thing to do is to throw an exception then test that you are throwing an exception. UPDATE: according to the comments, it is in fact impossible for the error to be hit and therefore the code is unreachable. But now the Debug.Fail is not reachable either, and it doesn't compile because the compiler notes that a method that returns a value has a reachable end point. The first problem should not actually be a problem; surely the code coverage tool ought to be configurable to ignore unreachable debug-only code. But both problem can be solved by rewriting the loop: public int FirstInvalidDigitPosition { get { int index = 0; while(true) { Debug.Assert(index An alternative approach would be to reorganize the code so that you don't have the problem in the first place: public int? FirstInvalidDigitPosition { get { for (int index = 0; index and now you don't need to restrict the callers to call AreThereInvalidDigits first; just make it legal to call this method any time. That seems like the safer thing to do. Methods that blow up when you don't do some expensive check to verify that they are safe to call are fragile, dangerous methods.
