[site]: stackoverflow
[post_id]: 2707046
[parent_id]: 2707023
[tags]: 
I believe you're looking for steganography . You can start with this MATLAB implementation of LSB steganography . A simple way of doing LSB steganography is to take an lossless-compressed image and set the LSB of each component (R,G,B). Then for a m x n image you get 3mn bits to store information in. Since you're modifying the LSB, the difference will not be perceivable in the image. Update SO I decided to code up a small, inefficient but demonstrative example: function LSBStega %%// Image and text I = imread('coins.png'); text = 'Hello World etc'; assert(numel(I) > numel(text)*8,'Insufficient number of pixels'); %%// Encode %// The end character signifies the end of the hidden text end_char = '.'; %// Append it text = [text end_char]; %// Convert each character into binary form with atleast 8 bits %// We transpose it before calling (:) since the binary representation %// is stores each character in binary per row and the (:) operations %// vectorizes the matrix by column. b = transpose(dec2bin(text,8)); %// Find which bits should be set to 1 or 0 ind_0 = find(b == '0'); ind_1 = find(b == '1'); %// Set the appropriate bits to 1 and 0 and leave the rest alone I(ind_0) = bitset(I(ind_0),1,0); I(ind_1) = bitset(I(ind_1),1,1); %%// Faster decode text_back = []; for i = 1:8:numel(I) %// Extract the LSB from a set of 8 bytes in the image C = bitget(I(i:i+7),1); %// Convert from binary to decimal C = bin2dec(num2str(C)); %// Check if it's the end character; break if so, store if not if(C == end_char) break; else text_back(end+1) = C; end end %// Convert to text text_back = char(text_back); %%// Display subplot(1,2,1); title('Original'); imshow(imread('coins.png')); subplot(1,2,2); title('Steganography Result'); imshow(I); disp(text_back); end
