[site]: stackoverflow
[post_id]: 551228
[parent_id]: 550919
[tags]: 
I do believe switching on type is a code smell. However I share your concerns about separation-of-concerns in code. But those can be solved in many ways that allow you to still use polymorphism, e.g. the visitor pattern or something similar. Read up on "Design Patterns" by the Gang of Four. If your core objects like Customer stays fixed most of the time but operations change often, then you can define operations as objects. interface Operation { void handlePrimeCustomer(PrimeCustomer customer); void handleMidPrimeCustomer(MidPrimeCustomer customer); void handleSubPrimeCustomer(SubPrimeCustomer customer); }; class InvestibleOperation : public Operation { void handlePrimeCustomer(PrimeCustomer customer) { bool investible = customer.isCeo(); } void handleMidPrimeCustomer(MidPrimeCustomer customer) { handleSubPrimeCustomer(customer); } void handleSubPrimeCustomer(SubPrimeCustomer customer) { bool investible = customer.getSavingsAccount().getBalance() > 1e6; } }; class SubPrimeCustomer : public Customer { void doOperation(Operation op) { op.handleSubPrimeCustomer(this); } }; class PrimeCustomer : public Customer { void doOperation(Operation op) { op.handlePrimeCustomer(this); } }; This looks like overkill, but it can easily save you a lot of coding when you need to handle operations as collections. E.g. display all of them in a list and let user select one. If operations are defined as functions you easily end up with a lot of hard coded switch-case logic, multiple places which needs to be update each time you add another operation, or product as I see it referred to here.
