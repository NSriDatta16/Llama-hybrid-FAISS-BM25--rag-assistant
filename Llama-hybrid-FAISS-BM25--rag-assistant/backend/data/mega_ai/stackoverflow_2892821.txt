[site]: stackoverflow
[post_id]: 2892821
[parent_id]: 2892676
[tags]: 
The idea is that you keep an auxiliary array with all the nodes (parent and child) you find. The values of this arrays are references that back your result. This builds the tree in linear time (array_key_exists does a hash table lookup, which is on average O(1)): //table contains (id, parent) $orig = array( 11 => 8, 7 => 3, 8 => 7, 99 => 8, 16 => 8, ); $childrenTable = array(); $result = array(); foreach ($orig as $n => $p) { //parent was not seen before, put on root if (!array_key_exists($p, $childrenTable)) { $childrenTable[$p] = array(); $result[$p] = &$childrenTable[$p]; } //child was not seen before if (!array_key_exists($n, $childrenTable)) { $childrenTable[$n] = array(); } //root node has a parent after all, relocate if (array_key_exists($n, $result)) { unset($result[$n]); } $childrenTable[$p][$n] = &$childrenTable[$n]; } unset($childrenTable); var_dump($result); gives array(1) { [3]=> array(1) { [7]=> array(1) { [8]=> array(3) { [11]=> array(0) { } [99]=> array(0) { } [16]=> array(0) { } } } } } EDIT: unset $childrenTable in the end to clear reference flags. In practice, you will probably want to do the operation inside a function anyway.
