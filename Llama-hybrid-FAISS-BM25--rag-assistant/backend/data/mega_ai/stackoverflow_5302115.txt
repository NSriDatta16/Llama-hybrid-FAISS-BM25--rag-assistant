[site]: stackoverflow
[post_id]: 5302115
[parent_id]: 5301962
[tags]: 
BackgroundWorker should typically be used for one-offs. Calling another BackgroundWorker from one BackgroundWorker is technically legit; yet it feels dirty and cumbersome. If you sincerely want to continue with this approach you can however; I would not recommend it. In general any exception that is not caught within a BackgroundWorker will end the thread and propagate outward in a nice clean fashion as you mentioned. If you want to catch Exception you could analyze the exceptions and wrap them in a defined type that would suit your needs upstream. Then you can simply analyze the Exception type and do as you wish. In going another route you could put a proxy in place that that mimics the Task behavior if you are not on .NET 4; however if you are on .NET 4 then leverage the Task class. An MSDN article exists by Shawn Wildermuth which touches on varying ways to implement threading within a WPF application; one of which is listed below. ThreadStart start = delegate() { // ... // This will work as its using the dispatcher DispatcherOperation op = Dispatcher.BeginInvoke( DispatcherPriority.Normal, new Action (SetStatus), "From Other Thread (Async)"); DispatcherOperationStatus status = op.Status; while (status != DispatcherOperationStatus.Completed) { status = op.Wait(TimeSpan.FromMilliseconds(1000)); if (status == DispatcherOperationStatus.Aborted) { // Alert Someone } } }; // Create the thread and kick it started! new Thread(start).Start();
