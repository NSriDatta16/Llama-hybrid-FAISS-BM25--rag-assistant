[site]: stackoverflow
[post_id]: 5173119
[parent_id]: 5172828
[tags]: 
Everyone seems to be asserting you're using the List to keep a queue of Tasks, but I don't actually see that in your question. But if it is, or if the manipulations to the list are otherwise independent — that is, if you are simply adding to or removing from the list as opposed to say, scanning the list and removing some items from the middle as a part of the job — then you should consider using a BlockingQueue or QueueDeque instead of a List and simply leveraging the java.util.concurrent package. These types do not require external lock management. If you require in earnest a List which is concurrently accessed by the each job, where the reads and writes to the list not independent, I would encapsulate the part of the processing which does this manipulation in a singleton, and use an exclusive lock to have each thread make use of the list. For instance, if your list contains some sort of aggregate statistics which are only a part of the process execution, then I would have my job be one class and a singleton aggregate statistics be a separate job. class AggregateStatistics { private static final AggregateStatistics aggregateStatistics = new AggregateStatistics(); public static AggregateStatistics getAggregateStatistics () { return aggregateStatistics; } private List list = new ArrayList (); private Lock lock = new ReentrantLock(); public void updateAggregates (...) { lock.lock(); try { /* Mutation of the list */ } finally { lock.unlock(); } } } Then have your task enter this portion of the job by accessing the singleton and calling the method on it which is managed with a lock. Never pass a collection which into a concurrent environment, it will only cause you problems. You can always pass around an immutable "wrapper" though if it's really suitable, by using java.util.Collections.unmodifiableList(List) and similar methods.
