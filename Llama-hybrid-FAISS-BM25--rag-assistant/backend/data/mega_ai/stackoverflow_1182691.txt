[site]: stackoverflow
[post_id]: 1182691
[parent_id]: 
[tags]: 
Archiving and Unarchiving results in Bad Access

I'm having trouble setting up a model object to save the visual state of user generated CALayers in a simple graphics application for the iphone. I'm attempting to save the background color and frame of all the current layers on screen by passing those properties to model objects which implement the NSCoding protocol and then into an NSMutableArray which the app delegate owns. Then I archive the array with NSKeyedArchiver and store it in the NSUserDefaults. Each CALayer's backgroundColor property is converted to a UIColor to be encoded by the model object for storage. I think that I'm unarchiving the array incorrectly or not restoring state from the unarchived array correctly. When I attempt to access the UIColor object that was store in the model object, I get an EXC_BAD_ACCESS. I thought it was possibly a bug with encoding UIColor objects so tried pulling the values out of the CGColorRef with the CGColorGetComponents function and storing them in an array to encode and archive, but I had the same result of bad access after unarchiving, so I think I'm just doing it wrong. This is my model object: @interface AILayerData : NSObject { UIColor* color; CGRect frame; } @property (retain) UIColor* color; @property (assign) CGRect frame; @end @implementation AILayerData @synthesize color; @synthesize frame; - (void)encodeWithCoder:(NSCoder *)coder; { [coder encodeObject:color forKey:@"color"]; [coder encodeCGRect:frame forKey:@"frame"]; } - (id)initWithCoder:(NSCoder *)coder; { self = [[AILayerData alloc] init]; if (self != nil) { color = [coder decodeObjectForKey:@"color"]; frame = [coder decodeCGRectForKey:@"frame"]; } return self; } @end And this is my archiving implementation: @implementation AppDelegate - (void)applicationWillTerminate:(UIApplication *)application { NSArray *layersArray = viewController.view.layer.sublayers; dataArray = [NSMutableArray array]; for(AILayer *layer in layersArray) { AILayerData *layerData = [[AILayerData alloc] init]; layerData.frame = layer.frame; UIColor *layerColor = [UIColor colorWithCGColor:layer.backgroundColor]; layerData.color = layerColor; [dataArray addObject:layerData]; [layerData release]; } [[NSUserDefaults standardUserDefaults] setObject:[NSKeyedArchiver archivedDataWithRootObject:layerDataArray] forKey:@"savedArray"]; } @end And here is where I restore state: @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; spaceView = [[AISpaceView alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; self.view = spaceView; [spaceView release]; spaceView.delegate = self; NSUserDefaults *currentDefaults = [NSUserDefaults standardUserDefaults]; NSData *dataRepresentingSavedArray = [currentDefaults objectForKey:@"savedArray"]; if (dataRepresentingSavedArray != nil) { [self restoreStateWithData:dataRepresentingSavedArray]; } } - (void)restoreStateWithData:(NSData *)data { NSArray *savedLayers = [NSKeyedUnarchiver unarchiveObjectWithData:data]; if (savedLayers != nil) { NSArray *restoredLayers = [[NSArray alloc] initWithArray:savedLayers]; for(AILayerData *layerDataObject in restoredLayers) { UIColor *layerColor = layerDataObject.color; AILayer *newLayer = [[AILayer alloc] init]; newLayer.backgroundColor = layerColor.CGColor; newLayer.frame = layerDataObject.frame; newLayer.isSelected = NO; [self.view.layer addSublayer:newLayer]; [newLayer release]; } [restoredLayers release]; [spaceView.layer layoutSublayers]; } } @end Any help with this is greatly appreciated. I'm pretty much a noob. I was encoding, archiving and unarching an NSArray of NSNumbers converted from the color's floats in pretty much the same way and getting bad access.
