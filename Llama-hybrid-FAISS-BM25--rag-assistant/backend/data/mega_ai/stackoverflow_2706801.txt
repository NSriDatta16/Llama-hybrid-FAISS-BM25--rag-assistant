[site]: stackoverflow
[post_id]: 2706801
[parent_id]: 2699956
[tags]: 
If drag is all you need, wouldn't a simple .Zip work? : var drag = _mouseDown .Select(args => args.EventArgs.GetPosition(canvas)) .Zip(_mouseUp.Select(args => args.EventArgs.GetPosition(canvas)), (p1, p2) => new { p1, p2 }); drag.Subscribe(p1p2 => Console.WriteLine(@"({0}:{1})({2}:{3})", p1p2.p1.X, p1p2.p1.Y, p1p2.p2.X, p1p2.p2.Y)); You can apply Where filter if you need to exclude zero-length drag. Edit: though, Zip would be vulnerable to releasing the mouse outside the window - in that case, you do not get mouseUp unless you capture... Here's the version that uses only the latest mouseDown before mouseUp: var drag = _mouseDown .Select(args => args.EventArgs.GetPosition(canvas)) .TakeUntil(_mouseUp) .CombineLatest(_mouseUp .Select(args => args.EventArgs.GetPosition(canvas)) .Take(1), (p1, p2) => new { p1, p2 }) .Repeat();
