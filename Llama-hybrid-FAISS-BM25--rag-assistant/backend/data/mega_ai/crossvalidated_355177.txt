[site]: crossvalidated
[post_id]: 355177
[parent_id]: 
[tags]: 
linear mixed model gives wrong results

I am currently learning Stan (MCMC C++ engine with wrappers in python and R) and implemented a linear mixed model $y_{i,j} = \beta_0 + \mathbf{x}_{i,j}^T\beta + \alpha_i + \epsilon_{i,j},\ 1\leq i\leq I,\ 1\leq j\leq J$ where $\epsilon_{i,j}\sim\mathcal{N}(0,\sigma_{\epsilon}^2),\ \beta_k\sim\mathcal{N}(0,100),\ \alpha_l\sim\mathcal{N}(0,\sigma_r^2),\ \sigma_r^2\sim\text{Half-Cauchy}(0,25)$ and $I=4500,\ J=20$ I set $\beta_0=1,\beta_2=2,\beta_3=3$ and $\alpha_l$ where initialized to uniform random numbers between $1$ and $4$. So there is a random intercept effect per group. After the sampler is done fit = pystan.stan(model_code=stan_code, data=model_data, iter=10000, chains=3, thin=10, warmup=6000, n_jobs=3) the estimates for $\beta_1,\beta_2$ are spot on but $\beta_0$ and the random effects are totally off. Disregarding stan, is there something about the mixed model that I misunderstand? Here is the stan code (using pystan) model_data = {} model_data['N'] = len(Y) model_data['D_fixed'] = X_fixed_effect.shape[1] model_data['D_random'] = X_random_effect.shape[1] model_data['Y'] = Y model_data['X_fixed'] = X_fixed_effect model_data['X_random'] = X_random_effect model_data['prior_mean_beta_fixed'] = np.zeros_like(beta_fixed) model_data['prior_cov_beta_fixed'] = 100 * np.eye(len(beta_fixed)) model_data['prior_mean_beta_random'] = np.zeros_like(beta_random) model_data['prior_cov_beta_random'] = np.eye(len(beta_random)) stan_code = """ data { int N; int D_fixed; int D_random; matrix[N,D_fixed] X_fixed; matrix[N,D_random] X_random; vector[N] Y; vector[D_fixed] prior_mean_beta_fixed; matrix[D_fixed,D_fixed] prior_cov_beta_fixed; vector[D_random] prior_mean_beta_random; matrix[D_random,D_random] prior_cov_beta_random; } parameters { vector[D_fixed] beta_fixed; vector[D_random] beta_random; real sigma_eps; real sigma_random; } transformed parameters { } model { sigma_eps ~ cauchy(0,25); beta_fixed ~ multi_normal(prior_mean_beta_fixed, prior_cov_beta_fixed); beta_random ~ multi_normal(prior_mean_beta_random, sigma_random * prior_cov_beta_random); Y ~ normal(X_fixed * beta_fixed + X_random * beta_random, sigma_eps); } """ fit = pystan.stan(model_code=stan_code, data=model_data, iter=10000, chains=3, thin=10, warmup=6000, n_jobs=3) Thanks for the help
