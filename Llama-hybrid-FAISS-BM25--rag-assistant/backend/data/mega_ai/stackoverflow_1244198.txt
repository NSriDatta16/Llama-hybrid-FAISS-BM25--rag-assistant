[site]: stackoverflow
[post_id]: 1244198
[parent_id]: 1244077
[tags]: 
Try using a templated function. It should infer the type based on the type of parameter you pass, so you shouldn't need to explicitly specify the type in the AddData call. public class MyClass { private void AddData (Receiver receiver, Func , T> func) { var aHelper = new AHelper(); var bHelper = new BHelper(); var cHelper = new CHelper(); receiver.ObjA = func(aHelper); receiver.ObjB = func(bHelper); receiver.ObjC = func(cHelper); } } Attempt #2: Tricky problem I think you need a more generic IHelper interface. Would something like this help? public interface IHelper { IMyObj GetBasic(); IMyObj GetExisting(); } public interface IHelper : IHelper { T GetBasic(); T GetExisting(); } You'll have to work out the name conflict between the derived interface and the base interface, but I'm not sure exactly how you'd want to do that, and I'm running out of time, so I'll leave that as it for the moment. Attempt #3 (I'm determined to get this!): Would this be cheating? public enum RetrievalMethod { Basic, Existing } public class Helper : IHelper where T : IMyObj { public T Get(RetrievalMethod rm) { switch(rm) { case RetrievalMethod.Basic: return GetBasic(); case RetrievalMethod.Existing: return GetExisting(); } } ... } ... private void AddData(Receiver receiver, RetrievalMethod rm) { var aHelper = new AHelper(); var bHelper = new BHelper(); var cHelper = new CHelper(); receiver.ObjA = aHelper.Get(rm); receiver.ObjB = bHelper.Get(rm); receiver.ObjC = cHelper.Get(rm); }
