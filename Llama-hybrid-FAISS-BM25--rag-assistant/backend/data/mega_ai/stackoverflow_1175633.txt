[site]: stackoverflow
[post_id]: 1175633
[parent_id]: 
[tags]: 
WPF Shell Drag Drop Sample - Unsafe Code

I have been considering using the code example shown at Shell Style Drag and Drop in .NET - Part 3 within a WPF project. The sample project works fine, it is a great article so check it out! However when moving the code to my project I receive an error when compiling "Unsafe code may only appear if compiling with /unsafe" I understand that I could just change the compile options, however I would prefer to not have the unsafe code in there. The unsafe code is as follows. How can I make this code safe? I don't really have experience in this field. /// /// Replaces any pixel with a zero alpha value with the specified transparency key. /// /// The bitmap data in which to perform the operation. /// The transparency color. This color is rendered transparent /// by the DragDropHelper. /// /// This function only supports 32-bit pixel formats for now. /// private static void ReplaceTransparentPixelsWithTransparentKey(BitmapData bmpData, DrawingColor transKey) { DrawingPixelFormat pxFormat = bmpData.PixelFormat; if (DrawingPixelFormat.Format32bppArgb == pxFormat || DrawingPixelFormat.Format32bppPArgb == pxFormat) { int transKeyArgb = transKey.ToArgb(); // We will just iterate over the data... we don't care about pixel location, // just that every pixel is checked. unsafe { byte* pscan = (byte*)bmpData.Scan0.ToPointer(); { for (int y = 0; y The function calling this code is as follows, maybe the ReplaceTransparentPixelsWithTransparentKey function could be removed entirely by another method. Any ideas? /// /// Gets a System.Drawing.Bitmap from a BitmapSource. /// /// The source image from which to create our Bitmap. /// The transparency key. This is used by the DragDropHelper /// in rendering transparent pixels. /// An instance of Bitmap which is a copy of the BitmapSource's image. private static Bitmap GetBitmapFromBitmapSource(BitmapSource source, Color transparencyKey) { // Copy at full size Int32Rect sourceRect = new Int32Rect(0, 0, source.PixelWidth, source.PixelHeight); // Convert to our destination pixel format DrawingPixelFormat pxFormat = ConvertPixelFormat(source.Format); // Create the Bitmap, full size, full rez Bitmap bmp = new Bitmap(sourceRect.Width, sourceRect.Height, pxFormat); // If the format is an indexed format, copy the color palette if ((pxFormat & DrawingPixelFormat.Indexed) == DrawingPixelFormat.Indexed) ConvertColorPalette(bmp.Palette, source.Palette); // Get the transparency key as a System.Drawing.Color DrawingColor transKey = transparencyKey.ToDrawingColor(); // Lock our Bitmap bits, we need to write to it BitmapData bmpData = bmp.LockBits( sourceRect.ToDrawingRectangle(), ImageLockMode.ReadWrite, pxFormat); { // Copy the source bitmap data to our new Bitmap source.CopyPixels(sourceRect, bmpData.Scan0, bmpData.Stride * sourceRect.Height, bmpData.Stride); // The drag image seems to work in full 32-bit color, except when // alpha equals zero. Then it renders those pixels at black. So // we make a pass and set all those pixels to the transparency key // color. This is only implemented for 32-bit pixel colors for now. if ((pxFormat & DrawingPixelFormat.Alpha) == DrawingPixelFormat.Alpha) ReplaceTransparentPixelsWithTransparentKey(bmpData, transKey); } // Done, unlock the bits bmp.UnlockBits(bmpData); return bmp; }
