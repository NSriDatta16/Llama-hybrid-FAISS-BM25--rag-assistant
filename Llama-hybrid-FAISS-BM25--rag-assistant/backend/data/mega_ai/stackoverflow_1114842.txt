[site]: stackoverflow
[post_id]: 1114842
[parent_id]: 1114834
[tags]: 
(This answer is in some ways two different answers, depending on the meaning of your question. Hopefully one part of it is helpful, anyway :) Probably the best way is to pass in an argument which is a function which can be used to create the new control at the right time. If you're using C# 3, this is as simple as: Form.RegisterControl("Text", () => new Text()) Alternatively, you could make it a generic method with two constraints: one for being a control, and one for having a parameterless constructor. public void RegisterControl (string name) where T : Control, new() then call it with: Form.RegisterControl ("Text"); Form.RegisterControl ("DateTime"); RegisterControl would have to remember typeof(T) in whatever storage it's using, but at least then it could be reasonably sure that Activator.CreateInstance(Type) would work later on - and you'd have compile-time checking. Personally I like the flexibility of the first form though - if you're passing in a delegate, that can choose to use a singleton, or perhaps some internal or even private constructor (depending on where it's being called from). You could also use a delegate which took the appropriate data, too: Form.RegisterControl("Text", data => new Text(data)); You can't express that sort of constructor with a generic constraint, and it would be relatively hard to invoke later anyway. EDIT: It's possible that both myself and Mehrdad have misinterpreted the question. Do you actually have different overloads of RegisterControl based on the control type? If so, then the only ways of directly calling the right overload at execution time are to either use reflection or use dynamic typing in C# 4. Another alternative would be to use double dispatch - put a method in the control itself which knows how to register itself with a form. This would be specified in the interface or base class, but overridden in the concrete subclasses. So your code which is currently: Form.RegisterControl("Text", control); would become: control.RegisterWith(Form, "Text"); That could then call the correct overload with no issues. Basically you need to remember that overload resolution is performed at compile time, but override resolution is performed at execution time - so if you want to make something dynamic, try to approach it with polymorphism.
