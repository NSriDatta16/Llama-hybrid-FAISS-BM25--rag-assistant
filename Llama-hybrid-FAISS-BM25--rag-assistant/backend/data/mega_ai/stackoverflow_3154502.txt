[site]: stackoverflow
[post_id]: 3154502
[parent_id]: 3154091
[tags]: 
While Carl is correct, that is almost assuredly exactly what you don't want to do. Namely, it is exceptionally rare in Cocoa or iOS to pass values by reference with the purpose of updating them remotely. Beyond being fragile and error prone, it is also generally a violation of encapsulation, a fundamental OO principal. Given context, it sounds like you are doing some kind of a baseball sort of app? Assuming so. Thus, you have a Lineup class whose instances represent a lineup within a Team (maybe even a Team class whose instances represent individual teams) with each team managing a lineup of Player instances. So, you might have something like: @interface Lineup:NSObject - (BOOL) substitutePlayer: (Player *) sub; @end And you might call it like this: - (void)handleResult:(Result)result forPlayer:(Player *)player inLineup:(Lineup *)lineup { ... handle substituion ... [lineup substitutePlayer: player]; } And you might implement the substitutePlayer: as: - (BOOL) substitutePlayer: (Player *) playerToReplace; { NSUInteger *index = [self.players indexOfObject: playerToReplace]; [self.players replaceObjectAtIndex: index withObject: [self.substitutes objectAtIndex: 0]]; [self.substitues removeObjectAtIndex: 0]; return YES; } By doing this, you avoid the goofy (Player **) stuff and you encapsulate all the lineup manipulation inside of the lineup class. If you were ever to need to specialize the lineup -- say, -substitutePlayer: should use the last guy in self.substitutes -- you could subclass Lineup and do so. End result; much cleaner OO design, much easier to maintain code, and much less fragile patterns. (Fixed some stupid bugs due to coding in SO's edit window.)
