[site]: stackoverflow
[post_id]: 1358928
[parent_id]: 1358902
[tags]: 
I would suspect it's due to how Clojure handles tail-cail optimizations. Since the JVM doesn't natively perform this optimization (and both Clojure and Scala run on it), Clojure optimizes tail recursion through the recur keyword. From the Clojure site : In functional languages looping and iteration are replaced/implemented via recursive function calls. Many such languages guarantee that function calls made in tail position do not consume stack space, and thus recursive loops utilize constant space. Since Clojure uses the Java calling conventions, it cannot, and does not, make the same tail call optimization guarantees. Instead, it provides the recur special operator, which does constant-space recursive looping by rebinding and jumping to the nearest enclosing loop or function frame. While not as general as tail-call-optimization, it allows most of the same elegant constructs, and offers the advantage of checking that calls to recur can only happen in a tail position. EDIT: Scala optimizes tail calls also , as long as they're in a certain form. However, as the previous link shows, Scala can only do this for very simple cases: In fact, this is a feature of the Scala compiler called tail call optimization. It optimizes away the recursive call. This feature works only in simple cases as above, though. If the recursion is indirect, for example, Scala cannot optimize tail calls, because of the limited JVM instruction set. Without actually compiling and decompiling your code to see what JVM instructions are produced, I suspect it's just not one of those simple cases (as Michael put it, due to having to fetch a.tail on each recursive step) and thus Scala just can't optimize it.
