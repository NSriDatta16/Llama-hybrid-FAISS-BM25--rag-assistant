[site]: stackoverflow
[post_id]: 3602284
[parent_id]: 3182621
[tags]: 
I tried the first two answers and what I got worked in code but not on XAML (also doesn't let you see changes in the design view when using the control). To get a property working like any other native one, here is the full process: (The sample adds a dependency property of type Nullable to show in the control as text or a default if null) In the code file: 1.a Define a dependency property: public static readonly DependencyProperty MyNumberProperty = DependencyProperty.Register("MyNumber", typeof(Nullable ), typeof(MyUserControl), new PropertyMetadata(null, new PropertyChangedCallback(OnMyNumberChanged))); 1.b Implement the OnMyNumberChanged Callback: private static void OnMyNumberChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args){ // When the color changes, set the icon color PlayButton MyUserControl muc = (MyUserControl)obj; Nullable value = (Nullable )args.NewValue; if (value != null) { muc.MyNumberTextBlock.Text = value.ToString(); } else { muc.MyNumberTextBlock.Text = "N/A"; } } 1.c implement the MyNumber property (not dependency) to use the dependency property for easy in code use: public Nullable MyNumber{ get { return (Nullable )GetValue(MyNumberProperty); } set { SetValue(MyNumberProperty, value); OnTargetPowerChanged(this, new DependencyPropertyChangedEventArgs(TargetPowerProperty, value, value)); // Old value irrelevant. } } In the XAML file bind the TextBlock control's text to the property (not dependency) to get the default value of the dependency property in case it is not set by the user of the control (assuming you called your root element of the user control "RootElement"): This code:
