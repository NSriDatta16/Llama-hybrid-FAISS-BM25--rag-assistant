[site]: stackoverflow
[post_id]: 3640958
[parent_id]: 
[tags]: 
Assembly is a family of very low-level programming languages, just above machine code. In assembly, each statement corresponds to a single machine code instruction. These instructions are represented as mnemonics in the given assembly language and are converted into executable machine code by a utility program referred to as an assembler ; the conversion process is referred to as assembly , or assembling the code. Language design Basic elements There is a large degree of diversity in the way that assemblers categorize statements and in the nomenclature that they use. In particular, some describe anything other than a machine mnemonic or extended mnemonic as a pseudo-operation (pseudo-op). A typical assembly language consists of three types of instruction statements that are used to define program operations: Opcode mnemonics Data sections Assembly directives Opcode mnemonics and extended mnemonics Instructions (statements) in assembly language are generally very simple, unlike those in high-level languages . Generally, a mnemonic is a symbolic name for a single executable machine language instruction (an opcode), and there is at least one opcode mnemonic defined for each machine language instruction. Each instruction typically consists of an operation or opcode plus zero or more operands . Most instructions refer to a single value, or a pair of values. Operands can be immediate (value coded in the instruction itself), registers specified in the instruction or implied, or the addresses of data located elsewhere in storage. This is determined by the underlying processor architecture: the assembler merely reflects how this architecture works. Extended mnemonics are often used to specify a combination of an opcode with a specific operand. For example, the System/360 assemblers use B as an extended mnemonic for BC with a mask of 15 and NOP for BC with a mask of 0. Extended mnemonics are often used to support specialized uses of instructions, often for purposes not obvious from the instruction name. For example, many CPU's do not have an explicit NOP instruction, but do have instructions that can be used for the purpose. In 8086 CPUs the instruction xchg ax,ax is used for nop , with nop being a pseudo-opcode to encode the instruction xchg ax,ax . Some disassemblers recognize this and will decode the xchg ax,ax instruction as nop . Similarly, IBM assemblers for System/360 and System/370 use the extended mnemonics NOP and NOPR for BC and BCR with zero masks. For the SPARC architecture, these are known as synthetic instructions Some assemblers also support simple built-in macro-instructions that generate two or more machine instructions. For instance, with some Z80 assemblers the instruction ld hl,bc is recognized to generate ld l,c followed by ld h,b . These are sometimes known as pseudo-opcodes. Tag use Use the assembly tag for assembly language programming questions, on any processor. You should also use a tag for your processor or instruction set architecture ( arm , avr , mips , x86 , x86-64 , etc). Consider a tag for your assembler as well ( gas , masm , nasm , et cetera). If your question is about inline assembly in C or other programming languages, see inline-assembly . For questions about .NET assemblies, use .net-assembly instead and for .NET's Common Intermediate Language, use cil . For Java ASM, use the tag java-bytecode-asm . Resources Beginner's resources Professional Assembly Language - Richard Blum Assembly Language Step-by-Step: Programming with Linux - Jeff Duntemann Assembly primer - Write your own OS Introduction to Assembly Language - Dandamudi Assembly language tutorials, guides, and reference material The x86 tag wiki has a large collection of links, including beginner material and reference docs. GNU C inline asm docs/guides/info (at the bottom of that answer) : how to use GNU C inline asm well, to make efficient code without a lot of wasted instructions. Also the inline assembly tag wiki . OSdev.org Pretty much everything you need to write your own OS (toy or otherwise). Mostly x86, but some mention of ARM. X86 Assembly/wikibooks Programming from the Ground Up (PDF book using i386 Linux with AT&T syntax) Paul Carter's Tutorial on x86 Assembly Software optimization resources by Agner Fog (for x86 and x86-64, but some of the optimization advice generalizes.) A whirlwind introduction to dataflow graphs : how to analyze dependency chains for throughput and latency. How much of ‘What Every Programmer Should Know About Memory’ is still valid? - most of it; understanding memory performance and caches is important for performance in any language.
