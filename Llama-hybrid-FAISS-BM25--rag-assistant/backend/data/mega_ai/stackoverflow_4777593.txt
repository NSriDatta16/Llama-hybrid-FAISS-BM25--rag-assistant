[site]: stackoverflow
[post_id]: 4777593
[parent_id]: 
[tags]: 
causes EXC_BAD_ACCESS

ich have the following problem: I'm using a the construct of the default "Navigation based Application | Use core data to storage". My RootViewController holds kind of categories. Selecting one, the navigation controller will push another (default) table-view controller (ItemsViewController). This is constructed as the RootViewController (managedObjectContext_ and fetchedResultsController_). There is just one change: The fetchedResultsController uses a predicate for fetching items of the selected category. The error occurs when the navigation controller pops and the ItemsViewController releases the fetchedResultsController_ in dealloc. - (void)dealloc { [fetchedResultsController_ release]; // is not nil and causes error [managedObjectContext_ release]; self.category = nil; [super dealloc]; } Stack: 0 0x010fca63 in objc_msgSend () 1 0x010ffbe0 in __FUNCTION__.13263 () 2 0x00d2ef73 in -[_PFBatchFaultingArray dealloc] () 3 0x00daa236 in -[NSFetchedResultsController dealloc] () 4 0x00004762 in -[ItemsViewController dealloc] (self=0x4d11e00, _cmd=0xfd09d6) 5 0x00385f1d in -[UINavigationController setDisappearingViewController:] () 6 0x003834f6 in -[UINavigationController _clearLastOperation] () 7 0x00383e3f in -[UINavigationController navigationTransitionView:didEndTransition:fromView:toView:] () 8 0x00510e23 in -[UINavigationTransitionView _notifyDelegateTransitionDidStopWithContext:] () 9 0x00511fd2 in -[UINavigationTransitionView _cleanupTransition] () 10 0x002fd665 in -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] () 11 0x002fd4f7 in -[UIViewAnimationState animationDidStop:finished:] () 12 0x01e816cb in run_animation_callbacks () 13 0x01e81589 in CA::timer_callback () 14 0x00f7bfe3 in __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ () 15 0x00f7d594 in __CFRunLoopDoTimer () 16 0x00ed9cc9 in __CFRunLoopRun () 17 0x00ed9240 in CFRunLoopRunSpecific () 18 0x00ed9161 in CFRunLoopRunInMode () 19 0x018cf268 in GSEventRunModal () 20 0x018cf32d in GSEventRun () 21 0x002db42e in UIApplicationMain () 22 0x00002330 in main (argc=1, argv=0xbffff094) Category selection: - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { ItemsViewController *ivc = [[ItemsViewController alloc] initWithStyle:UITableViewStylePlain]; ivc.managedObjectContext = self.managedObjectContext; ivc.category = [self.fetchedResultsController objectAtIndexPath:indexPath]; [self.navigationController pushViewController:ivc animated:YES]; [ivc release]; } Interface: @interface ItemsViewController : UITableViewController { RankCategory *category; @private NSFetchedResultsController *fetchedResultsController_; NSManagedObjectContext *managedObjectContext_; } @property (nonatomic, retain) RankCategory *category; @property (nonatomic, retain) NSManagedObjectContext *managedObjectContext; @property (nonatomic, retain) NSFetchedResultsController *fetchedResultsController; @end Implementation: @synthesize category; @synthesize fetchedResultsController=fetchedResultsController_, managedObjectContext=managedObjectContext_; - (NSFetchedResultsController *)fetchedResultsController { if (fetchedResultsController_ != nil) { return fetchedResultsController_; } /* Set up the fetched results controller. */ // Create the fetch request for the entity. NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init]; // Edit the entity name as appropriate. NSEntityDescription *entity = [NSEntityDescription entityForName:@"Item" inManagedObjectContext:self.managedObjectContext]; [fetchRequest setEntity:entity]; // Set the batch size to a suitable number. [fetchRequest setFetchBatchSize:20]; // Edit the sort key as appropriate. NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"itemName" ascending:NO]; NSArray *sortDescriptors = [[NSArray alloc] initWithObjects:sortDescriptor, nil]; [fetchRequest setSortDescriptors:sortDescriptors]; NSPredicate *predicate = [NSPredicate predicateWithFormat:@"category = %@",self.category]; [fetchRequest setPredicate:predicate]; // Edit the section name key path and cache name if appropriate. // nil for section name key path means "no sections". NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:nil cacheName:nil]; aFetchedResultsController.delegate = self; self.fetchedResultsController = aFetchedResultsController; [aFetchedResultsController release]; [fetchRequest release]; [sortDescriptor release]; [sortDescriptors release]; [predicate release]; NSError *error = nil; if (![fetchedResultsController_ performFetch:&error]) { /* Replace this implementation with code to handle the error appropriately. abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. If it is not possible to recover from the error, display an alert panel that instructs the user to quit the application by pressing the Home button. */ NSLog(@"Unresolved error %@, %@", error, [error userInfo]); abort(); } return fetchedResultsController_; }
