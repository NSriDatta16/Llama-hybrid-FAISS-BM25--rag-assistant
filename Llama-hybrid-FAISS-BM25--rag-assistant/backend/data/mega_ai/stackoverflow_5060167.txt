[site]: stackoverflow
[post_id]: 5060167
[parent_id]: 5058543
[tags]: 
I assume that you are perfectly comfortable with plain ol' SendMessage . The step from there to SendMessageCallback is not that long. First, look at LRESULT WINAPI SendMessage(__in HWND hWnd, __in UINT Msg, __in WPARAM wParam, __in LPARAM lParam); Then look at BOOL WINAPI SendMessageCallback(__in HWND hWnd, __in UINT Msg, __in WPARAM wParam, __in LPARAM lParam, __in SENDASYNCPROC lpCallBack, __in ULONG_PTR dwData); It's glaringly obvious that the differing parts are the SENDASYNCPROC and ULONG_PTR parameters of SendMessageCallback . The lpCallBack up there is the name of a callback of yours that will be called by the OS when the hWnd window procedure returns after handling the message Msg you sent to it. The type of lpCallBack is SENDASYNCPROC , which is declared as VOID CALLBACK SendAsyncProc(__in HWND hwnd, __in UINT uMsg, __in ULONG_PTR dwData, __in LRESULT lResult); The dwData up there is any kind of data you want to use inside your callback, whenever it gets called. This is usually a pointer to complex data, like a struct or C++ class. In that case the lifetime of the memory must be considered carefully, so that it's valid when the callback is called. The dwData can also be just the simple integer data it looks like. Bringing it all together, then. In your code you call SendMessageCallback like this (error checking omitted for readability): SendMessageCallback(hWnd, WM_FOO, 0, 0, MySendAsyncProc, (ULONG_PTR)myData); But, hmmm, since this is an exercise, let's assume that myData is just 0: SendMessageCallback(hWnd, WM_FOO, 0, 0, MySendAsyncProc, 0); That means you have declared a callback MySendAsyncProc : VOID CALLBACK MySendAsyncProc(__in HWND hwnd, __in UINT uMsg, __in ULONG_PTR dwData, // This is *the* 0 __in LRESULT lResult) // The result from the callee { // Whohoo! It called me back! } And that callback will be called when your WM_FOO message has been handled. That pretty much sums it up.
