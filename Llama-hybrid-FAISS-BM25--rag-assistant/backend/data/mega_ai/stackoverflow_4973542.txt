[site]: stackoverflow
[post_id]: 4973542
[parent_id]: 4973077
[tags]: 
I am not really sure of the exact implementation of std::next_permutation, but if it is the same as Narayana Pandita's algorithm as desribed in the wiki here: http://en.wikipedia.org/wiki/Permutation#Systematic_generation_of_all_permutations , assuming the elements are distinct, looks like it is O(1) amortized! (Of course, there might be errors in the below) Let us count the total number of swaps done. We get the recurrence relation T(n+1) = (n+1)T(n) + Θ(n 2 ) (n+1)T(n) comes from fixing the first element and doing the swaps for the remaining n. Θ(n 2 ) comes from changing the first element. At the point we change the first element, we do Θ(n) swaps. Do that n times, you get Θ(n 2 ). Now let X(n) = T(n)/n! Then we get X(n+1) = X(n) + Θ(n 2 )/(n+1)! i.e there is some constant C such that X(n+1) 2 /(n+1)! Writing down n such inequalities gives us X(n+1) - X(n) 2 /(n+1)! X(n) - X(n-1) 2 /(n)! X(n-1) - X(n-2) 2 /(n-1)! ... X(2) - X(1) 2 /(1+1)! Adding these up gives us X(n+1) - X(1) . Since the infinite series \sum j = 1 to infinity j^2/(j+1)! converges to C', say, we get X(n+1) - X(1) Remember that X(n) counts the average number of swaps needed (T(n)/n!) Thus the average number of swaps is O(1). Since finding the elements to swap is linear with the number of swaps, it is O(1) amortized even if you take other operations into consideration.
