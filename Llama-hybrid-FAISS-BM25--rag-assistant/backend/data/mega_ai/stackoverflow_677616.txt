[site]: stackoverflow
[post_id]: 677616
[parent_id]: 677579
[tags]: 
A number of a series of digits. A 32 bit unsigned int is 32 binary digits. The string "12345" is a series of 5 digits. Digits can be stored in many ways: as bits, characters, array elements and so on. The largest "native" datatype in C# with complete precision is probably the decimal type (128 bits, 28-29 digits). Just choose your own method of storing digits that allows you to store much bigger numbers. As for the rest, this will give you a clue: 2 1 = 2 2 2 = 2 1 + 2 1 2 3 = 2 2 + 2 2 Example: The sum of digits of 2^100000 is 135178 Ran in 4875 ms The sum of digits of 2^10000 is 13561 Ran in 51 ms The sum of digits of 2^1000 is 1366 Ran in 2 ms SPOILER ALERT: Algorithm and solution in C# follows. Basically, as alluded to a number is nothing more than an array of digits. This can be represented easily in two ways: As a string; As an array of characters or digits. As others have mentioned, storing the digits in reverse order is actually advisable. It makes the calculations much easier. I tried both of the above methods. I found strings and the character arithmetic irritating (it's easier in C/C++; the syntax is just plain annoying in C#). The first thing to note is that you can do this with one array. You don't need to allocate more storage at each iteration. As mentioned you can find a power of 2 by doubling the previous power of 2. So you can find 2 1000 by doubling 1 one thousand times. The doubling can be done in place with the general algorithm: carry = 0 foreach digit in array sum = digit + digit + carry if sum > 10 then carry = 1 sum -= 10 else carry = 0 end if digit = sum end foreach This algorithm is basically the same for using a string or an array. At the end you just add up the digits. A naive implementation might add the results into a new array or string with each iteration. Bad idea. Really slows it down. As mentioned, it can be done in place. But how large should the array be? Well that's easy too. Mathematically you can convert 2^a to 10^f(a) where f(a) is a simple logarithmic conversion and the number of digits you need is the next higher integer from that power of 10. For simplicity, you can just use: digits required = ceil(power of 2 / 3) which is a close approximation and sufficient. Where you can really optimise this is by using larger digits. A 32 bit signed int can store a number between +/- 2 billion (approximately. Well 9 digits equals a billion so you can use a 32 bit int (signed or unsigned) as basically a base one billion "digit". You can work out how many ints you need, create that array and that's all the storage you need to run the entire algorithm (being 130ish bytes) with everything being done in place. Solution follows (in fairly rough C#): static void problem16a() { const int limit = 1000; int ints = limit / 29; int[] number = new int[ints + 1]; number[0] = 2; for (int i = 2; i = 1000000000) { carry = 1; n[i] -= 1000000000; } else { carry = 0; } } } static String NumberToString(int[] n) { int i = n.Length; while (i > 0 && n[--i] == 0) ; String ret = "" + n[i--]; while (i >= 0) { ret += String.Format("{0:000000000}", n[i--]); } return ret; }
