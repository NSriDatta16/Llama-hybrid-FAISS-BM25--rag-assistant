[site]: stackoverflow
[post_id]: 2310158
[parent_id]: 2310103
[tags]: 
Edit: There are serious editorial concerns about this post, apparently. See comment section. A little of both. Philosophically , it works out - there are classes, which are the "real" building block for object oriented programming, and there are structs, which are lightweight data types for storage but allow object-like method calls for familiarity and convenience. Technically , being a "value type" means that the entire struct - all of its contents - are (usually) stored wherever you have a variable or member of that type. As a local variable or function parameter, that means on the stack. For member variables, that means stored entirely as part of the object. As a (primary) example of why inheritance is a problem, consider how storage is affected at a low level if you allowed structs to have subtypes with more members. Anything storing that struct type would take up a variable amount of memory based on which subtype it ended up containing, which would be an allocation nightmare. An object of a given class would no longer have a constant, known size at compile time and the same would be true for stack frames of any method call. This does not happen for objects, which have storage allocated on the heap and instead have constant-sized references to that storage on the stack or inside other objects. This is just an intuitive, high-level explanation - See comments and other answers for both expanded and more precise information. Edit : The link in the comments to Eric Lippert's article The Stack Is An Implementation Detail , is now located on his personal blog site .
