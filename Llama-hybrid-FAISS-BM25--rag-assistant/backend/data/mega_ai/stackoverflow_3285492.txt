[site]: stackoverflow
[post_id]: 3285492
[parent_id]: 3284603
[tags]: 
Hm. I'm surprised that you see that much difference (in seconds?), but I guess it is possible that you see different order of execution from machine to machine, jvm to jvm etc. Especially, when the JIT is compiling your code for the first time, I tend to see delay (compared to subsequent execution of same code) in the order of 100-300ms in my code for example, so maybe it's more dramatic in your code? Not sure what you mean with "process interrupt mechanism". Do you mean that the timer task interrupts some thread? Anyways, what I can suggest now is to use System.nanoTime() instead. (Although I don't think it will explain anything, Use of System.currentTimeMillis() is discouraged in serious measurements). Addition of -server to your JAVA_OPTS is generally advised so that you see the behavior when the code is optimized by JIT. It is also highly advisable to run your code multiple times and take statistics. If I were you, I'll do these small things first, then debug using synchronizers like CyclicBarrier , CountdownLatch and see where exactly the delay is coming. What are the "background noise" (degree of activity) in the SLES? Maybe the OS is very very busy or something? What is the task's nature? Is it anything network/IO related?
