[site]: stackoverflow
[post_id]: 1713787
[parent_id]: 1707127
[tags]: 
ANSWER The first thing to do if you ever get into this exception for seeming identical types, is to check that the two types are actually the same. System.Type t1 = typeof(XMLobj); System.Type t2 = o.GetType(); And then check them in the debugger. Take especially note of the "AssemblyQualifiedName". My two types turned out to be different versions of the same class. Then do pay careful attention to the output window in Visual Studio as you are single stepping through. It will tell you when which assemblies are loaded. In my example, the culprit came in clear text in the debug output just as I stepped over the line XmlSerializer xmlser = new XmlSerializer(typeof(IRDnet.XMLobj)); There, the debugger revealed that another, older, version of my assembly was loaded from a location that I wasn't aware of. I neglected to tell the guys here that I debug using an external exe that loads my assembly. It turns out that the CLR, I assume on behalf of the XmlSerializer class constructor to resolve the "typeof", looks in the exe folder and its subfolders (which is what CLR does). And, lo and behold, deep down there there was a bastard of the original version of the IRDnet.dll file that I was fixing. I still do not see how the two "typeof" statements produce different results: One results in the object type currently within context, whereas the other causes the CLR do go out looking for it in the execution folder. One possible theory is that the typeof statement is somehow lazily evalutated. I wouldn't know.
