[site]: stackoverflow
[post_id]: 3296650
[parent_id]: 
[tags]: 
iPhone OpenGL ES Contexts and Framebuffers

I'm attempting to setup a framebuffer properly in order to support depth and correct perspective. I'm using the OpenGL ES Application template in XCode and I have been following the guidelines in the OpenGL ES Programming Guide . I have my renderer set to ES1 manually since I just want to get something rendering with depth using the FFP. This is my current code: #import "ES1Renderer.h" #import "water.h" //#import "EAGLError.h" #define PRINT_GLERR(error) ((error == GL_NO_ERROR) ? NSLog(@"No error") : NSLog(@"GL Error: %d", (error))) //#define GLE(X) {X; eglGetError(); } @implementation ES1Renderer // Create an OpenGL ES 1.1 context - (id)init { if ((self = [super init])) { context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1]; if (!context || ![EAGLContext setCurrentContext:context]) { [self release]; return nil; } glGenFramebuffersOES(1, &framebuffer); glBindFramebufferOES(GL_FRAMEBUFFER_OES, framebuffer); glGenRenderbuffersOES(1, &colorRenderbuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, colorRenderbuffer); glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, colorRenderbuffer); glViewport(0, 0, backingWidth, backingHeight); // Start in projection mode. glMatrixMode(GL_PROJECTION); glLoadIdentity(); double xmin, xmax, ymin, ymax; ymax = NEAR_PLANE * tanf(DEGREES_TO_RADIANS(FOV) / 2.0f); ymin = -ymax; xmin = ymin * ((float)backingWidth / (float)backingHeight); xmax = ymax * ((float)backingWidth / (float)backingHeight); glFrustumf(xmin, xmax, ymin, ymax, NEAR_PLANE, FAR_PLANE); glViewport(0, 0, backingWidth, backingHeight); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LESS); glDepthRangef(0.0f, 1.0f); glDepthMask(TRUE); glClearColor(0.0f, 0.0f, 0.0f, 1.0f); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); } return self; } - (void)render { static const GLfloat squareVertices[] = { -0.5f, -0.33f, -1.0f, 0.5f, -0.33f, -1.0f, -0.5f, 0.33f, -1.0f, 0.5f, 0.33f, -1.0f, }; static const GLubyte squareColors[] = { 255, 255, 0, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 255, 255, }; static float transY = 0.0f; [EAGLContext setCurrentContext:context]; glBindFramebufferOES(GL_FRAMEBUFFER_OES, framebuffer); glViewport(0, 0, backingWidth, backingHeight); glMatrixMode(GL_PROJECTION); glLoadIdentity(); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glTranslatef(0.0f, (GLfloat)(sinf(transY)/2.0f), 0.0f); transY += 0.075f; glClearColor(0.5f, 0.5f, 0.5f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glVertexPointer(3, GL_FLOAT, 0, squareVertices); glEnableClientState(GL_VERTEX_ARRAY); glColorPointer(4, GL_UNSIGNED_BYTE, 0, squareColors); glEnableClientState(GL_COLOR_ARRAY); glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); glBindRenderbufferOES(GL_RENDERBUFFER_OES, colorRenderbuffer); [context presentRenderbuffer:GL_RENDERBUFFER_OES]; } - (BOOL)resizeFromLayer:(CAEAGLLayer *)layer { glGenFramebuffersOES(1, &framebuffer); glGenRenderbuffersOES(1, &colorRenderbuffer); glBindFramebufferOES(GL_FRAMEBUFFER_OES, framebuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, colorRenderbuffer); [context renderbufferStorage:GL_RENDERBUFFER_OES fromDrawable:layer]; glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, colorRenderbuffer); glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_WIDTH_OES, &backingWidth); glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_HEIGHT_OES, &backingHeight); glGenRenderbuffersOES(1, &depthRenderbuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, depthRenderbuffer); glRenderbufferStorageOES(GL_RENDERBUFFER_OES, GL_DEPTH_COMPONENT16_OES, backingWidth, backingHeight); glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_DEPTH_ATTACHMENT_OES, GL_RENDERBUFFER_OES, depthRenderbuffer); if(glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES) != GL_FRAMEBUFFER_COMPLETE_OES) { NSLog(@"failed to make complete framebuffer object %x", glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES)); return NO; } return YES; } - (void)dealloc { if (framebuffer) { glDeleteFramebuffersOES(1, &framebuffer); framebuffer = 0; } if (colorRenderbuffer) { glDeleteRenderbuffersOES(1, &colorRenderbuffer); colorRenderbuffer = 0; } if (depthRenderbuffer) { glDeleteRenderbuffersOES(1, &depthRenderbuffer); depthRenderbuffer = 0; } if ([EAGLContext currentContext] == context) [EAGLContext setCurrentContext:nil]; [context release]; context = nil; [super dealloc]; } @end When I commend out this part of the code: glGenRenderbuffersOES(1, &depthRenderbuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, depthRenderbuffer); glRenderbufferStorageOES(GL_RENDERBUFFER_OES, GL_DEPTH_COMPONENT16_OES, backingWidth, backingHeight); glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_DEPTH_ATTACHMENT_OES, GL_RENDERBUFFER_OES, depthRenderbuffer); I get a quad that bounces up and down and renders correctly. Any help on the depth issue would be awesome!
