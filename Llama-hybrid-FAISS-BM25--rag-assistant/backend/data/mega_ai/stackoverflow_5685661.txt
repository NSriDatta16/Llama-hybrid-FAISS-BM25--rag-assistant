[site]: stackoverflow
[post_id]: 5685661
[parent_id]: 5678666
[tags]: 
In response to a similar question, someone on sqlmonster.com provided a nifty VarBinaryStream class . It works with a column type of varbinary(max) . If your data is stored in a varbinary(max), and is in zip format, you could use that class to instantiate a VarBinaryStream, then instantiate a ZipInputStream around that , and ba-da-boom, you're there. Just read from the ZipInputStream. In C# it might look like this using (var imageSrc = new VarBinarySource(connection, "Table.Name", "Column", "KeyColName", 1)) { using (var s = new VarBinaryStream(imageSrc)) { using(var zis = new ZipInputStream(s)) { .... } } } If the images are small, then you probably wouldn't want all this streaming stuff. If the column is a binary(n) or a varbinary(n) where n is less than 8000, just use the SqlBinary type and read in all the data into memory, then instantiate a MemoryStream around that. Simpler. In VB.NET it looks something like this: Dim bytes as Bytes() bytes = dr.GetSqlBinary(columnNumber) Using ms As New MemoryStream(bytes) Using zis As New ZipInputStream(ms) ... End Using End Using Finally, I'm going to question the wisdom of applying zip compression to .jpg images, and similar. The jpg format is already compressed; compressing it again before putting the data into SQL Server won't cause the data to become appreciably smaller. It only increases processing time. If possible, I'd suggest you reconsider your design for storage of compressed images.
