[site]: stackoverflow
[post_id]: 1915234
[parent_id]: 1915124
[tags]: 
For legacy systems setting up a barrier like this is probably too painful for the entire codebase , particularly if the codebase is non-trivially large. You can do more harm than good, particularly since paying off this technical debt likely involves additional periods of instability during the inevitable refactorings that would be involved in catching up the old code, which is likely not very test-friendly. I would recommend targeted refactorings with a coverage threshold set for new code only. If one area of the codebase is painful and shows too much risk to add new code, then block out some spike time for redesign and refactoring. All fixed bugs should have failing tests written first , and new features should target a high level of coverage, ~90% or higher. (The last 10% of the fabled "100%" coverage is often very costly, as it likely involves GUI layers and integration stuffs. This is a controversial opinion, but I've found it holds true for the most part. Be happy with 90% or higher on new code.) The CI server for the project I'm on currently will fail the build if coverage falls below a threshold, but that's on a project that started off with good TDD practice. Large legacy apps with lots of technical debt tend to come booby-trapped with unstable areas and political consequences that don't need any more trauma than they already have. Set a goal of gradual improvement over time rather than a one-time catch up.
