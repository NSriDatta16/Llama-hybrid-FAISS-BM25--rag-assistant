[site]: stackoverflow
[post_id]: 730391
[parent_id]: 730240
[tags]: 
First -- I'm not sure what you mean by recursive annotations. Do you mean annotations that can contain references to other annotations of the same type? Something like @Panel(layout=BorderLayout.class, nested={ @Panel(region=NORTH, layout=FlowLayout.class, ...) @Panel(region=SOUTH, layout=FlowLayout.class, ...) } ) (which would be an example of where I'd like to use it if it were possible...) As for my use of custom annotations (and processors): code generation. See http://code.google.com/p/javadude/wiki/Annotations For example, JavaBean properties: @Bean( properties={ @Property(name="name"), @Property(name="phone", bound=true), @Property(name="friend", type=Person.class, kind=PropertyKind.LIST) } ) public class Person extends PersonGen { // generated superclass PersonGen will contain getters/setters // field definitions, property change support... } or a mix-in example package sample; import java.util.List; public interface IFlightAgent { List getFlight(); void reserve(IFlight flight); } public interface ICarAgent { List getCars(); void reserve(ICar car); } public interface IHotelAgent { List getHotels(); void reserve(IHotel hotel); } package sample; import com.javadude.annotation.Bean; import com.javadude.annotation.Delegate; @Bean(delegates = { @Delegate(type = IHotelAgent.class, property = "hotelAgent", instantiateAs = HotelAgentImpl.class), @Delegate(type = ICarAgent.class, property = "carAgent", instantiateAs = CarAgentImpl.class), @Delegate(type = IFlightAgent.class, property = "flightAgent", instantiateAs = FlightAgentImpl.class) } ) public class TravelAgent extends TravelAgentGen implements IHotelAgent, ICarAgent, IFlightAgent { // generated superclass TravelAgentGen will create instances // of the "instantiateAs" classes and delegate the interface // methods to them } See The drawbacks of annotation processing in Java? and my answer to it for some potential issues with their usage.
