[site]: stackoverflow
[post_id]: 4617686
[parent_id]: 4075525
[tags]: 
FWIW here is some code that NLog uses to get the timestamp for each log message. In this case, the "work" is the actual retrieval of the current time (granted, it happens in the context of probably a much more expensive bit of "work", the logging of a message). NLog minimizes the cost of getting the current time by only getting the "real" time (via DateTime.Now ) if the current tick count is different than the previous tick count. This does not really apply directly to your question, but it is an interesting way to "speed up" current time retrieval. internal class CurrentTimeGetter { private static int lastTicks = -1; private static DateTime lastDateTime = DateTime.MinValue; /// /// Gets the current time in an optimized fashion. /// /// Current time. public static DateTime Now { get { int tickCount = Environment.TickCount; if (tickCount == lastTicks) { return lastDateTime; } DateTime dt = DateTime.Now; lastTicks = tickCount; lastDateTime = dt; return dt; } } } // It would be used like this: DateTime timeToLog = CurrentTimeGetter.Now; In the context of your question, you could probably "improve" the performance of your time looping code like this: private static void MethodA_PrecalcEndTime() { int cnt = 0; var doneTime = DateTime.Now.AddSeconds(1); var startDT = CurrentTimeGetter.Now; while (CurrentTimeGetter.Now If CurrentTimeGetter.Now is called so frequently that the returned time would be the same many times in a row, only the cost of Environment.TickCount must be paid. I can't say if it really helps with performance of NLog logging such that you would notice or not. I don't know that it really helps on your question, or if you even need any help anymore, but I thought that it would serve as an interesting example of leveraging a faster operation ( Environment.Ticks ) to potentially speed up a relatively slow operation ( DateTime.Now ) in some circumstances.
