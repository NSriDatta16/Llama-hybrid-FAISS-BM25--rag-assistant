[site]: stackoverflow
[post_id]: 3258768
[parent_id]: 3258733
[tags]: 
My tests just seems so tightly bound to the method (testing all codepath, expecting some inner methods to be called a number of times, with certain arguments), that it seems that if I ever refactor the method, the tests will fail even if the final behavior of the method did not change. I think you are doing it wrong. A unit test should: test one method provide some specific arguments to that method test that the result is as expected It should not look inside the method to see what it is doing, so changing the internals should not cause the test to fail. You should not directly test that private methods are being called. If you are interested in finding out whether your private code is being tested then use a code coverage tool. But don't get obsessed by this: 100% coverage is not a requirement. If your method calls public methods in other classes, and these calls are guaranteed by your interface, then you can test that these calls are being made by using a mocking framework. You should not use the method itself (or any of the internal code it uses) to generate the expected result dynamically. The expected result should be hard-coded into your test case so that it does not change when the implementation changes. Here's a simplified example of what a unit test should do: testAdd() { int x = 5; int y = -2; int expectedResult = 3; Calculator calculator = new Calculator(); int actualResult = calculator.Add(x, y); Assert.AreEqual(expectedResult, actualResult); } Note that how the result is calculated is not checked - only that the result is correct. Keep adding more and more simple test cases like the above until you have have covered as many scenarios as possible. Use your code coverage tool to see if you have missed any interesting paths.
