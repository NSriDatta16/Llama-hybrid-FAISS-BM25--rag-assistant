[site]: stackoverflow
[post_id]: 3775358
[parent_id]: 3774757
[tags]: 
I would go for a simple hash table based solution. A structure for hash table containing a number and corresponding frequency. Plus a pointer to the next element for chaining in the hash bucket. struct ItemFreq { struct ItemFreq * next_; int number_; int frequency_; }; The processing starts with max_freq_so_far = 0; It goes through the list of numbers. For each number , the hash table is looked up for a ItemFreq element x such that x.number_ == number . If no such x is found, then a ItemFreq element is created as { number_ = number, frequency_ = 1} and inserted into the hash table. If some x was found then its frequency_ is incremented. If frequency_ > max_freq_so_far then max_freq_so_far = frequency Once traversing through the list of numbers of complete, we traverse through the hash table and print the ItemFreq items whose frequency_ == max_freq_so_far The complexity of the algorithm is O(N) where N is the number of items in the input list. For a simple and elegant construction of hash table, see section 6.6 of K&R (The C Programming Language) .
