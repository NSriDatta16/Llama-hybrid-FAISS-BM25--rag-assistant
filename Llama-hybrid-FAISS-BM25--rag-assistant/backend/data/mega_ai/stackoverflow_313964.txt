[site]: stackoverflow
[post_id]: 313964
[parent_id]: 106237
[tags]: 
Below is my java code adapted from C code in the paper "Encoding and decoding the Hilbert order" by Xian Lu and Gunther Schrack, published in Software: Practice and Experience Vol. 26 pp 1335-46 (1996). Hope this helps. Improvements welcome ! Michael /** * Find the Hilbert order (=vertex index) for the given grid cell * coordinates. * @param x cell column (from 0) * @param y cell row (from 0) * @param r resolution of Hilbert curve (grid will have Math.pow(2,r) * rows and cols) * @return Hilbert order */ public static int encode(int x, int y, int r) { int mask = (1 > 1; v0 = ((v0 & (v1 ^ notx)) | (~v0 & (v1 ^ noty))) >> 1; } hodd = (~v0 & (v1 ^ x)) | (v0 & (v1 ^ noty)); return interleaveBits(hodd, heven); } /** * Interleave the bits from two input integer values * @param odd integer holding bit values for odd bit positions * @param even integer holding bit values for even bit positions * @return the integer that results from interleaving the input bits * * @todo: I'm sure there's a more elegant way of doing this ! */ private static int interleaveBits(int odd, int even) { int val = 0; // Replaced this line with the improved code provided by Tuska // int n = Math.max(Integer.highestOneBit(odd), Integer.highestOneBit(even)); int max = Math.max(odd, even); int n = 0; while (max > 0) { n++; max >>= 1; } for (int i = 0; i 0 ? (1 0 ? (1
