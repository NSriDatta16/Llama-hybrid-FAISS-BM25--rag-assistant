[site]: crossvalidated
[post_id]: 639078
[parent_id]: 639072
[tags]: 
I would organize the dataset differently. The easiest would be to have one line per Petri dish and per time point. Each Petri dish should have a unique identifier, meaning this identifier will come back 2 times in your ID column, since you have 2 time points per Petri dish, meaning that each Petri dish would have 2 lines, one for the number of dead aphids at 2 hours, one line for the number of dead aphids at 18 hours. Then there should be a time column which contains the information about the time point (2 or 18 hours). Then finally, one column with the number of dead aphids, and one column with the number of live aphids. And finally, a column containing the starting number of aphids there were in the dish. The Petri dish should be a random factor in a GLM for a binomial distribution, since it is repeated twice (2 time points). Then it is possible to analyse the proportion of dead aphids with cbind in the glmer function of the lme4 package. It should look a bit like : glmer(cbind(number_of_dead_aphids, number_of_live_aphids) ~ time*starting_number_of_aphids + (1|Petri_dish)), data=your_data,family=binomial Edit: to go further, you should then try to know whether the interaction is significant, and which effects are in general. For this you could build all possible models: glmer(cbind(number_of_dead_aphids, number_of_live_aphids) ~ time+starting_number_of_aphids + (1|Petri_dish)), data=your_data,family=binomial glmer(cbind(number_of_dead_aphids, number_of_live_aphids) ~ time + (1|Petri_dish)), data=your_data,family=binomial glmer(cbind(number_of_dead_aphids, number_of_live_aphids) ~ starting_number_of_aphids + (1|Petri_dish)), data=your_data,family=binomial glmer(cbind(number_of_dead_aphids, number_of_live_aphids) ~ 1 + (1|Petri_dish)), data=your_data,family=binomial The last one is the null model. You could then compare the AICs of all these models and chose the one with the lowest AIC/the simplest one with the lowest AIC in a delta AIC of 2. You could use the effects package to plot(allEffects(your_model)) in order to have an idea of what the graphical representation would look like.
