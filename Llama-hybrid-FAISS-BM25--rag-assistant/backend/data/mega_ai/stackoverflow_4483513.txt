[site]: stackoverflow
[post_id]: 4483513
[parent_id]: 4482113
[tags]: 
While I agree with the fact that default constructors should be frowned upon if there is no canonical meaning to them (complex numbers should have a default constructor that makes them zero, to mimic built in types semantics), there are a few scenarios where they are mandatory. Quite a few standard library constructs mandate default constructible objects, especially iterators and containers' value types (at least for some methods: resize for instance). Sometimes, you may want objects (or are forced by the standard to want) to have a "null" state, which is only reachable by a default constructor. Then you have to write safe bool idioms , use smart pointers and pimpl idioms, etc. This can be good, or not. I agree, it is not good practice to add the complexity of null states (and the errors they can induce) to objects which don't need them, but sometimes, you are forced to. For the record, complex classes should look like: struct complex { // Allow default initialization, and standard embedding // of real numbers in complex numbers complex(float real = 0., float imag = 0.) : real(real), imag(imag) {} float real, imag; // no need for privacy here }; // Operators are defined outside the class complex operator+(complex x, complex y) { return complex(x.real + y.real, x.imag + y.imag); } // etc std::ostream& operator Note that since complex is a POD type, you should even be able to do complex x = { 2., 3. }; and have them zero-initialized for you in static arrays.
