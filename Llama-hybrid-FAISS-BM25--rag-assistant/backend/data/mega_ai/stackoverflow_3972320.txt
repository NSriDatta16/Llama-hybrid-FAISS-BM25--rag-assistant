[site]: stackoverflow
[post_id]: 3972320
[parent_id]: 3971698
[tags]: 
The way you're doing it, you won't ever hit dealloc . A timer retains its target. In this case, that means the timer has retained you. It will not release you until it is invalidated. Since you created the timer, you must also invalidate it at some point prior to dealloc , because the timer's retain will prevent your object's being dealloc ed. You have two options: find another place to invalidate the timer (view goes offscreen, application is terminating, what have you) set something else as the timer's target. As an example of the latter: @interface GameLoopTimerTarget : NSObject { id owner; /* not retained! */ } - (id)initWithOwner:(id)owner; - (void)timerDidFire:(NSTimer *)t; @end @implementation GameLoopTimerTarget - (id)initWithOwner:(id)owner_ { self = [super init]; if (!self) return nil; owner = owner_; return self; } - (void)timerDidFire:(NSTimer *)t { #pragma unused (t) [owner performSelector:@selector(gameLoop)]; } @end /* In your main objectâ€¦ */ /* assume synthesized: @property (retain, NS_NONATOMIC_IPHONE_ONLY) GameLoopTimer *mainTimerTarget; */ - (void)mainTimerLoop { self.mainTimerTarget = [[[GameLoopTimerTarget alloc] initWithOwner:self] autorelease]; mainTimer = [NSTimer scheduledTimerWithTimeInterval:1.0/10.0 target:self.mainTimerTarget selector:@selector(timerDidFire:) userInfo:nil repeats:YES]; } - (void)dealloc { /* other stuff */ [timer invalidate], timer = nil; [mainTimerTarget release], mainTimerTarget = nil; /* more stuff */ [super dealloc]; } Notice how the time interval is 1.0/10.0 - this could also be written 0.1 , but it cannot be written 1/10 , as that division will truncate to 0.0 . Also notice how this breaks the retain cycle: Both you and your timer retain the timer target. You hit dealloc at the normal time. You then invalidate the timer and release the timer target. The timer target is then deallocated.
