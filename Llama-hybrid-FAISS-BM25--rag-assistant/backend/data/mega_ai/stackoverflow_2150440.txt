[site]: stackoverflow
[post_id]: 2150440
[parent_id]: 2150291
[tags]: 
Here's a header file I wrote to do some simple performance profiling (using manual timers): #ifndef __ZENTIMER_H__ #define __ZENTIMER_H__ #ifdef ENABLE_ZENTIMER #include #ifdef WIN32 #include #else #include #endif #ifdef HAVE_STDINT_H #include #elif HAVE_INTTYPES_H #include #else typedef unsigned char uint8_t; typedef unsigned long int uint32_t; typedef unsigned long long uint64_t; #endif #ifdef __cplusplus extern "C" { #pragma } #endif /* __cplusplus */ #define ZTIME_USEC_PER_SEC 1000000 /* ztime_t represents usec */ typedef uint64_t ztime_t; #ifdef WIN32 static uint64_t ztimer_freq = 0; #endif static void ztime (ztime_t *ztimep) { #ifdef WIN32 QueryPerformanceCounter ((LARGE_INTEGER *) ztimep); #else struct timeval tv; gettimeofday (&tv, NULL); *ztimep = ((uint64_t) tv.tv_sec * ZTIME_USEC_PER_SEC) + tv.tv_usec; #endif } enum { ZTIMER_INACTIVE = 0, ZTIMER_ACTIVE = (1 state = ZTIMER_ACTIVE; ztime (&ztimer->start); } static void ZenTimerStop (ztimer_t *ztimer) { ztimer = ztimer ? ztimer : &__ztimer; ztime (&ztimer->stop); ztimer->state = ZTIMER_INACTIVE; } static void ZenTimerPause (ztimer_t *ztimer) { ztimer = ztimer ? ztimer : &__ztimer; ztime (&ztimer->stop); ztimer->state |= ZTIMER_PAUSED; } static void ZenTimerResume (ztimer_t *ztimer) { ztime_t now, delta; ztimer = ztimer ? ztimer : &__ztimer; /* unpause */ ztimer->state &= ~ZTIMER_PAUSED; ztime (&now); /* calculate time since paused */ delta = now - ztimer->stop; /* adjust start time to account for time elapsed since paused */ ztimer->start += delta; } static double ZenTimerElapsed (ztimer_t *ztimer, uint64_t *usec) { #ifdef WIN32 static uint64_t freq = 0; ztime_t delta, stop; if (freq == 0) QueryPerformanceFrequency ((LARGE_INTEGER *) &freq); #else #define freq ZTIME_USEC_PER_SEC ztime_t delta, stop; #endif ztimer = ztimer ? ztimer : &__ztimer; if (ztimer->state != ZTIMER_ACTIVE) stop = ztimer->stop; else ztime (&stop); delta = stop - ztimer->start; if (usec != NULL) *usec = (uint64_t) (delta * ((double) ZTIME_USEC_PER_SEC / (double) freq)); return (double) delta / (double) freq; } static void ZenTimerReport (ztimer_t *ztimer, const char *oper) { fprintf (stderr, "ZenTimer: %s took %.6f seconds\n", oper, ZenTimerElapsed (ztimer, NULL)); } #ifdef __cplusplus } #endif /* __cplusplus */ #else /* ! ENABLE_ZENTIMER */ #define ZenTimerStart(ztimerp) #define ZenTimerStop(ztimerp) #define ZenTimerPause(ztimerp) #define ZenTimerResume(ztimerp) #define ZenTimerElapsed(ztimerp, usec) #define ZenTimerReport(ztimerp, oper) #endif /* ENABLE_ZENTIMER */ #endif /* __ZENTIMER_H__ */ The ztime() function is the main logic you need â€” it gets the current time and stores it in a 64bit uint measured in microseconds. You can then later do simple math to find out the elapsed time. The ZenTimer*() functions are just helper functions to take a pointer to a simple timer struct, ztimer_t , which records the start time and the end time. The ZenTimerPause() / ZenTimerResume() functions allow you to, well, pause and resume the timer in case you want to print out some debugging information that you don't want timed, for example. You can find a copy of the original header file at http://www.gnome.org/~fejj/code/zentimer.h in the off chance that I messed up the html escaping of
