[site]: stackoverflow
[post_id]: 4778102
[parent_id]: 
[tags]: 
Need help with update for observer c++

I have a order beverage type program. I am tryig to implement observer pattern so when the order is placed the cellphone /observer will display the order, basically letting them know of an update.. I just dont know how to do this. If i pass TheOrder class in update()order classes..i get a slew of errors. too many to post.. update() is in observer and cellphone and in the TheOrder class.. here is my observer classes: #ifndef _OBSERVER_ #define _OBSERVER_ #include //#include "TheOrder.h" namespace CoffeeHouse { namespace Observers { //class Subject; class Observer { protected: virtual ~Observer() = 0 { }; public: // virtual virtual void update()= 0; }; } // namespace Observer } // namespace HeadFirstDesignPatterns #endif here is the observer concrete class #ifndef _CELLPHONE1_ #define _CELLPHONE1_ #include using namespace std; namespace CoffeeHouse { namespace Observers { class CellPhone1: public Observer { public: std::string _number; CellPhone1(std::string number){ _number = number; } void update() { std::cout here is the subject class #ifndef _SUBJECT_ #define _SUBJECT_ #include "Starbuzz.h" //#include "Starbuzz2.h" #include "Observer.h" #include #include "Beverage.h" namespace CoffeeHouse { namespace Observers { class Subject { protected: virtual ~Subject() = 0 { }; public: virtual void registerObserver( Observer* o ) = 0; public: virtual void removeObserver( Observer* o ) = 0; public: virtual void notifyObservers() = 0; }; } // namespace Observer } #endif here is the subjects concrete class #ifndef _THE_ORDER_ #define _THE_ORDER_ #include "Beverage.h" #include #include #include "Order.h" #pragma once; //class Order; using namespace CoffeeHouse::Decorator; namespace CoffeeHouse { namespace Observers { class TheOrder : public Subject { private: mutable std::list _observers; private: mutable std::list _orders; //public: virtual ~Order() = 0 //public: ~TheOrder(); public: void NewOrder(Beverage* bev, Observer* cellphone) { // _orders.push_front(new Order(bev, cellphone)); //_//observers.push_front(new Order(bev)); } public: void registerObserver( Observer* o ) { assert( o ); _observers.push_back(o); } public: void removeObserver( Observer* o ) { assert( o ); _observers.remove(o); } public: void notifyObservers() { for( std::list ::iterator iterator = _observers.begin(); _observers.end() != iterator; ++iterator ) { Observer* observer = *iterator; observer->update(); } } }; //} } // namespace Observer } // namespace CoffeeHouse #endif here is the observer concrete class #ifndef _CELLPHONE1_ #define _CELLPHONE1_ #include using namespace std; namespace CoffeeHouse { namespace Observers { class CellPhone1: public Observer { public: std::string _number; CellPhone1(std::string number){ _number = number; } void update() { std::cout main() #include "Starbuzz.h" //just header files #include "Starbuzz2.h" // just header files #include "Subject.h" #include "TheOrder.h" #include "CellPhone2.h" #include "CellPhone1.h" using namespace CoffeeHouse::Decorator; using namespace CoffeeHouse::Observers; int main( int argc, char* argv[] ) { Beverage* beverage2 = new DarkRoast(); beverage2 = new Mocha(beverage2); beverage2 = new Mocha(beverage2); beverage2 = new Whip(beverage2); std::cout getDescription() cost() getDescription() cost() getDescription() cost() getDescription() cost() getDescription() cost() registerObserver(cellphone1); orders->notifyObservers(); TheOrder* order = new TheOrder(); CellPhone1* obj2 = new CellPhone1("3"); order->registerObserver(obj2); order->notifyObservers(); return 0; } i just would like to send the order into cellphone1 class so i can display each different order.. i think i need to send it in through the update function.. because in cellphone1 is the observer so i wold like to display the order there.. In the TheOrder class there is a notifyObservers() function do i need to pass this pointer? also
