[site]: stackoverflow
[post_id]: 3159806
[parent_id]: 3157454
[tags]: 
You can use explicit template instantiation of an additional static member whose constructor takes care of filling out the entries: template class myClass{ public: static int array[length]; typedef enum{LENGTH=length} size_; struct filler { filler(void) { for(int i=0;i int myClass ::array[length]; //static member definition template typename myClass ::filler myClass ::fill_; //explicit template instantiation template myClass ::filler myClass ::fill_; int main(void) { for(int i=0;i ::LENGTH;++i) cout ::array[i] Or, since a similar (probably better) solution has been already shown above by Benoit, here's a template recursive version, just for fun: //recursive version: template class myClass{ public: static int array[length]; typedef enum{LENGTH=length} size_; static void do_fill(int* the_array) { the_array[LENGTH-1]=LENGTH; myClass ::do_fill(the_array); } struct filler { filler(void) { /*for(int i=0;i class myClass { public: static int array[1]; typedef enum{LENGTH=1} size_; static void do_fill(int* the_array) { the_array[LENGTH-1]=LENGTH; } }; //definition of the explicitly specialized version of the array //to make the linker happy: int myClass ::array[1]; // of course, the line below does not work as intended. template int myClass ::array[length]; //static member definition template typename myClass ::filler myClass ::fill_; //explicit template instantiation template myClass ::filler myClass ::fill_; int main(void) { for(int i=0;i ::LENGTH;++i) cout ::array[i] Now, different compilers support different levels of template recursion (and this technique is compiler expensive) so, careful..."Here Be Dragons" ;-) Oh, one more thing, you don't need to redefine the array in the specialized version of myClass, so you can get rid of instantiating array[1]: //explicit specialization to end the recursion template<> class myClass { public: typedef enum{LENGTH=1} size_; static void do_fill(int* the_array) { the_array[LENGTH-1]=LENGTH; } };
