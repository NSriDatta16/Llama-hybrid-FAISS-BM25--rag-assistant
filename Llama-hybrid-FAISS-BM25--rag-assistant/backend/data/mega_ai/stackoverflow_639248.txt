[site]: stackoverflow
[post_id]: 639248
[parent_id]: 
[tags]: 
C++ covariant templates

I feel like this one has been asked before, but I'm unable to find it on SO, nor can I find anything useful on Google. Maybe "covariant" isn't the word I'm looking for, but this concept is very similar to covariant return types on functions, so I think it's probably correct. Here's what I want to do and it gives me a compiler error: class Base; class Derived : public Base; SmartPtr d = new Derived; SmartPtr b = d; // compiler error Assume those classes are fully fleshed out... I think you get the idea. It can't convert a SmartPtr into a SmartPtr for some unclear reason. I recall that this is normal in C++ and many other languages, though at the moment I can't remember why. My root question is: what is the best way to perform this assignment operation? Currently, I'm pulling the pointer out of the SmartPtr , explicitly upcasting it to the base type, then wrapping it in a new SmartPtr of the appropriate type (note that this is not leaking resources because our home-grown SmartPtr class uses intrusive reference counting). That's long and messy, especially when I then need to wrap the SmartPtr in yet another object... any shortcuts?
