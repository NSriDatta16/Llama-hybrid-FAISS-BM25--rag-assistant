[site]: stackoverflow
[post_id]: 3291112
[parent_id]: 3290770
[tags]: 
First off, let me explain how a compiler works. The first thing we do is break up the source code into tokens . Then we organize the tokens into a parse tree . Then we do a semantic analysis of the parse tree, and then we generate code based on that semantic analysis. Any of those stages - lexing, parsing or analyzing - can produce errors. Here's the important part: we do not go back and re-do a previous stage if a later stage got an error . The lexer is "greedy" - it attempts to make the biggest token it can at every stage of the way. So Daniel is right. The lexer breaks i+++++i up into i / ++ / ++ / + / i Then the parser tries to turn that into a parse tree and it comes up with + / \ ++ i / ++ / i That is, equivalent to (((i++)++) + i). Now the semantic analyzer looks at that and says "i++ is fine because i is a variable. But i++ is not a variable, it's a value. You cannot do ++ on a value, so the second ++ is illegal." The semantic analyzer then gives the error: the operand of an increment must be a variable . The semantic analyzer does not then re-do the lex and say you know, this could have been i / ++ / + / ++ / i, which would parse differently and be legal. We don't backtrack because there could be billions of possible ways to re-lex and re-parse a program and we don't want to have to try all of them. Just consider your case; i+++++i could be (((i++)++)+i) or )((i++)+(+(+i))) or (i+(+(+(+(+i)))) or... remember, + can be part of a unary plus, binary plus, pre-increment or post-increment, and therefore there are a lot of possible combinations for these five plusses.
