[site]: stackoverflow
[post_id]: 1132488
[parent_id]: 1132350
[tags]: 
Iterating with recursion is a trivial transformation, so we'll assume you know how to do that. If you use your "one pass" to build your own array of "sum to this index", and can make another pass on that array, I could see how to do it. Just iterate through that second array and subtract sum[x] from sum[last]. If you ever find a situation where the result = sum[x] you return x. If you don't then return -1. As Neil N mentioned, if you define "pass" very loosely for recursion, such that the entire recursion can actually visit indices multiple times, then you could dispense with the second array. After thinking about this a bit, I suspect the idea is to get you to only visit every array element once (in order), and to use recursion's built-in stack property to get rid of the need for any second array. What you do is write your recursive routine to save off it's current index's array value in a local, add that value to a passed in "sum_of_array" value, then call itself on the next highest index (if there is one). If there isn't a next highest index, it saves the sum into a global, which is now available to every stacked recursive call. Each routine finishes by checking its sum against the global sum. If it is half, then it returns its index. Otherwise it returns -1. If a non -1 was returned from a call to itself, this last step is skipped and that value is returned. I'll show in pseudo-Ada Total_Sum : integer; function Split (Subject : Integer_Array; After : Integer := 0; Running_Sum : Integer := 0) is begin Running_Sum := Running_Sum + Subject(After); if (After This code should have the properties that: Calling it with just an array will return the described "split" index, or -1 if there isn't one. It only reads from any element in the source array once It reads the source array elements in strict index order. No extra structured data storage (array) is required.
