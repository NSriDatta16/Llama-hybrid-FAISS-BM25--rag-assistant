[site]: stackoverflow
[post_id]: 3294771
[parent_id]: 3293841
[tags]: 
Stax solution : Parse document public void parseXML(InputStream xml) { try { DOMResult result = new DOMResult(); XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance(); XMLEventReader reader = xmlInputFactory.createXMLEventReader(new StreamSource(xml)); TransformerFactory transFactory = TransformerFactory.newInstance(); Transformer transformer = transFactory.newTransformer(); transformer.transform(new StAXSource(reader), result); Document document = (Document) result.getNode(); NodeList startlist = document.getChildNodes(); processNodeList(startlist); } catch (Exception e) { System.err.println("Something went wrong, this might help :\n" + e.getMessage()); } } Now all nodes from the document are in a NodeList so do this next : private void processNodeList(NodeList nodelist) { for (int i = 0; i Then for each element node with valid text get name and value public void getNodeNamesAndValues(Node n) { String nodeValue = null; String nodeName = null; if (hasValidText(n)) { while (n != null && isWhiteSpace(n.getTextContent()) == true && StringUtils.isWhitespace(n.getTextContent()) && n.getNodeType() != Node.ELEMENT_NODE) { n = n.getFirstChild(); } nodeValue = StringUtils.strip(n.getTextContent()); nodeName = n.getLocalName(); System.out.println(nodeName + " " + nodeValue); } } Bunch of useful methods to check nodes : private static boolean hasValidAttributes(Node node) { return (node.getAttributes().getLength() > 0); } private boolean hasValidText(Node node) { String textValue = node.getTextContent(); return (textValue != null && textValue != "" && isWhiteSpace(textValue) == false && !StringUtils.isWhitespace(textValue) && node.hasChildNodes()); } private boolean isWhiteSpace(String nodeText) { if (nodeText.startsWith("\r") || nodeText.startsWith("\t") || nodeText.startsWith("\n") || nodeText.startsWith(" ")) return true; else return false; } I also used StringUtils, you can get that by including this in your pom.xml if you're using maven : commons-lang commons-lang 2.5 This is inefficient if you're reading huge files, but not so much if you split them first. This is what I've come with(with google). There are more better solutions this is mine, I'm an amateur(for now).
