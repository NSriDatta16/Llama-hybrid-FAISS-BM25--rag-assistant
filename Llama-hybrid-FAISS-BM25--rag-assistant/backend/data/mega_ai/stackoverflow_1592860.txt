[site]: stackoverflow
[post_id]: 1592860
[parent_id]: 289347
[tags]: 
There is a more elegant solution. With std::string you can use resize() to allocate a suitably large buffer, and &s[0] to get a pointer to the internal buffer. At this point many fine folks will jump and yell at the screen. But this is the fact. About 2 years ago the library working group decided (meeting at Lillehammer) that just like for std::vector, std::string should also formally, not just in practice, have a guaranteed contiguous buffer. The other concern is does strtok() increases the size of the string. The MSDN documentation says: Each call to strtok modifies strToken by inserting a null character after the token returned by that call. But this is not correct. Actually the function replaces the first occurrence of a separator character with \0. No change in the size of the string. If we have this string: one-two---three--four we will end up with one\0two\0--three\0-four So my solution is very simple: std::string str("some-text-to-split"); char seps[] = "-"; char *token; token = strtok( &str[0], seps ); while( token != NULL ) { /* Do your thing */ token = strtok( NULL, seps ); } Read the discussion on http://www.archivum.info/comp.lang.c++/2008-05/02889/does_std::string_have_something_like_CString::GetBuffer
