[site]: stackoverflow
[post_id]: 1446170
[parent_id]: 1445989
[tags]: 
n.b. see 2018 update at the bottom I recommend against putting much JavaScript in your Django templates - it tends to be hard to write and debug, particularly as your project expands. Instead, try writing all of your JavaScript in a separate script file which your template loads and simply including just a JSON data object in the template. This allows you to do things like run your entire JavaScript app through something like JSLint , minify it, etc. and you can test it with a static HTML file without any dependencies on your Django app. Using a library like simplejson also saves you the time spent writing tedious serialization code. If you aren't assuming that you're building an AJAX app this might simply be done like this: In the view: from django.utils import simplejson def view(request, …): js_data = simplejson.dumps(my_dict) … render_template_to_response("my_template.html", {"my_data": js_data, …}) In the template: data_from_django = {{ my_data }}; widget.init(data_from_django); Note that the type of data matters: if my_data is a simple number or a string from a controlled source which doesn't contain HTML, such as a formatted date, no special handling is required. If it's possible to have untrusted data provided by a user you will need to sanitize it using something like the escape or escapejs filters and ensure that your JavaScript handles the data safely to avoid cross-site scripting attacks. As far as dates go, you might also want to think about how you pass dates around. I've almost always found it easiest to pass them as Unix timestamps: In Django: time_t = time.mktime(my_date.timetuple()) In JavaScript, assuming you've done something like time_t = {{ time_t }} with the results of the snippet above: my_date = new Date(); my_date.setTime(time_t*1000); Finally, pay attention to UTC - you'll want to have the Python and Django date functions exchange data in UTC to avoid embarrassing shifts from the user's local time. EDIT : Note that the setTime in javascript is in millisecond whereas the output of time.mktime is seconds. That's why we need to multiply by 1000 2018 Update: I still like JSON for complex values but in the intervening decade the HTML5 data API has attained near universal browser support and it's very convenient for passing simple (non-list/dict) values around, especially if you might want to have CSS rules apply based on those values and you don't care about unsupported versions of Internet Explorer. … let myWidget = document.getElementById("my-widget"); console.log(myWidget.dataset.viewMode); // Prints tabular somethingElse.addEventListener('click', evt => { myWidget.dataset.viewMode = "list"; }); This is a neat way to expose data to CSS if you want to set the initial view state in your Django template and have it automatically update when JavaScript updates the data- attribute. I use this for things like hiding a progress widget until the user selects something to process or to conditionally show/hide errors based on fetch outcomes or even something like displaying an active record count using CSS like #some-element::after { content: attr(data-active-transfers); } .
