[site]: stackoverflow
[post_id]: 4145254
[parent_id]: 
[tags]: 
Using C# types to express units of measure

I'm trying to get what I call measurement units system by wrapping double into struct. I have C# structures like Meter, Second, Degree, etc. My original idea was that after compiler is inlined everything I would have a performance the same as if double were used. My explicit and implicit operators are simple and straightforward, and compiler does actually inline them, yet the code with Meter and Second is 10 times slower than the same code using double. My question is being: why cannot C# compiler make the code using Second as optimal as the code using double if it inlines everything anyway? Second is defined as following: struct Second { double _value; // no more fields. public static Second operator + (Second left, Second right) { return left._value + right._value; } public static implicit Second operator (double value) { // This seems to be faster than having constructor :) return new Second { _value = value }; } // plenty of similar operators } Update: I didn't ask if struct fits here. It does. I didn't ask if code is going to be inlined. JIT does inline it. I checked assembly operations emitted in runtime. They were different for code like this: var x = new double(); for (var i = 0; i and like this: var x = new Second(); for (var i = 0; i There were no call instructions in disassembly, so operations were in fact inlined. Yet the difference is significant. Performance tests show that using Second is like 10 times slower than using double. So my questions are (attention!): why is JIT generated IA64 code is different for the cases above? What can be done to make struct run as fast as double? It seems there no theoretical difference between double and Second, what is the deep reason of difference I saw?
