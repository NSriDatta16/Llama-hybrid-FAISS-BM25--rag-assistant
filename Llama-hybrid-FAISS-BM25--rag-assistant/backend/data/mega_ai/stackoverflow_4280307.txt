[site]: stackoverflow
[post_id]: 4280307
[parent_id]: 4280231
[tags]: 
The example you are looking at has no depth buffer and a perspective matrix intended for 2D GL. Look at the aurioTouch example instead. in the EAGLView class you will notice an option to implement the depth buffer. The two combined (since aurioTouch doesn't implement shaders) should give a better understanding I think the order of operations you have in your method are causing the problem. Here's the code I use in my app "Live Effects Cam" which places the live camera as a GL Texture on shapes: #define DEGREES_TO_RADIANS(__ANGLE__) ((__ANGLE__) / 180.0 * M_PI) @interface GLView : UIView { @private /* The pixel dimensions of the backbuffer */ GLint backingWidth; GLint backingHeight; EAGLContext *context; /* OpenGL names for the renderbuffer and framebuffers used to render to this view */ GLuint viewRenderbuffer; GLuint viewFramebuffer; GLuint depthRenderbuffer; /* OpenGL name for the sprite texture */ GLuint spriteTexture; } @property (readonly) GLint backingWidth; @property (readonly) GLint backingHeight; @property (readonly) EAGLContext *context; - (void) drawView; - (BOOL) createFramebuffer; - (void) destroyFramebuffer; + (UIImage *) snapshot:(GLView *)eaglview; @end @implementation GLView @synthesize backingWidth; @synthesize backingHeight; @synthesize context; + (Class) layerClass { return [CAEAGLLayer class]; } - (id)init { self = [[super init] initWithFrame:CGRectMake(0.0, 0.0, 480.0, 640.0)]; // size of the camera image being captures if ( self==nil ) return self; // Set Content Scaling // if ( HIRESDEVICE ) { self.contentScaleFactor = (CGFloat)2.0; } // Get our backing layer // CAEAGLLayer *eaglLayer = (CAEAGLLayer*) self.layer; // Configure it so that it is opaque, does not retain the contents of the backbuffer when displayed, and uses RGBA8888 color. // eaglLayer.opaque = YES; eaglLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithBool:FALSE], kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil]; // Create our EAGLContext, and if successful make it current and create our framebuffer. // context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1]; if(!context || ![EAGLContext setCurrentContext:context] || ![self createFramebuffer]) { [self release]; return nil; } // Final View Settings // [self setOpaque:YES]; self.multipleTouchEnabled = YES; self.backgroundColor = [UIColor clearColor]; [EAGLContext setCurrentContext:context]; glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer); glMatrixMode(GL_PROJECTION); glLoadIdentity(); GLfloat zNear = 1.0; GLfloat zFar = 1000.0; GLfloat fieldOfView = 90; // Lens Angle of View GLfloat size = zNear * tanf(DEGREES_TO_RADIANS(fieldOfView) / 2.0); CGRect rect = CGRectMake( (CGFloat)0.0, (CGFloat)0.0, backingWidth, backingHeight); glFrustumf(-size, size, -size / (rect.size.width / rect.size.height), size / (rect.size.width / rect.size.height), zNear, zFar); glViewport(0, 0, backingWidth, backingHeight); glClearColor(0.0f, 0.0f, 0.0f, 0.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LESS); glEnable(GL_MULTISAMPLE); glEnable(GL_LINE_SMOOTH); glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); glHint(GL_LINE_SMOOTH_HINT, GL_NICEST); glHint(GL_POINT_SMOOTH_HINT, GL_NICEST); glDisable(GL_ALPHA_TEST); // Turn Translucent Textures: OFF // glDisable(GL_BLEND); // // Turn Translucent Textures: ON // // // glEnable(GL_BLEND); // glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA); return self; } - (void) drawView { [context presentRenderbuffer:GL_RENDERBUFFER_OES]; } - (BOOL)createFramebuffer { // Generate IDs for a framebuffer object and a color renderbuffer // glGenFramebuffersOES(1, &viewFramebuffer); glGenRenderbuffersOES(1, &viewRenderbuffer); glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer); // This call associates the storage for the current render buffer with the EAGLDrawable (our CAEAGLLayer) // allowing us to draw into a buffer that will later be rendered to screen whereever the layer is (which corresponds with our view). // [context renderbufferStorage:GL_RENDERBUFFER_OES fromDrawable:(CAEAGLLayer*)self.layer]; glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, viewRenderbuffer); glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_WIDTH_OES, &backingWidth); glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_HEIGHT_OES, &backingHeight); // If this app uses a depth buffer, we'll create and attach one via another renderbuffer. // if ( YES ) { glGenRenderbuffersOES(1, &depthRenderbuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, depthRenderbuffer); glRenderbufferStorageOES(GL_RENDERBUFFER_OES, GL_DEPTH_COMPONENT16_OES, backingWidth, backingHeight); glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_DEPTH_ATTACHMENT_OES, GL_RENDERBUFFER_OES, depthRenderbuffer); } if(glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES) != GL_FRAMEBUFFER_COMPLETE_OES) { NSLog(@"failed to make complete framebuffer object %x", glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES)); return NO; } return YES; } - (void) destroyFramebuffer { glDeleteFramebuffersOES(1, &viewFramebuffer); viewFramebuffer = 0; glDeleteRenderbuffersOES(1, &viewRenderbuffer); viewRenderbuffer = 0; if(depthRenderbuffer) { glDeleteRenderbuffersOES(1, &depthRenderbuffer); depthRenderbuffer = 0; } } + (UIImage *) snapshot:(GLView *)eaglview { NSInteger x = 0; NSInteger y = 0; NSInteger width = [eaglview backingWidth]; NSInteger height = [eaglview backingHeight]; NSInteger dataLength = width * height * 4; // Need to do this to get it to flush before taking the snapshit // NSUInteger i; for ( i=0; i
