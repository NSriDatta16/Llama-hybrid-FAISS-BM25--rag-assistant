[site]: stackoverflow
[post_id]: 3894231
[parent_id]: 3893293
[tags]: 
I would have thought that this would be the type of problem that many others had run into before, but I've had a hard time finding anyone talking about the "kill the parent" problems. I initially thought that you should be able to do this with a (not quite so, but sort of) simple call to clone , like this: pid_t new_vfork(void) { return clone(child_func, /* child function */ child_stack, /* child stack */ SIGCHLD | CLONE_VM, /* flags */ NULL, /* argument to child */ NULL, /* pid of the child */ NULL, /* thread local storage for child */ NULL); /* thread id of child in child's mem */ } Except that determining the child_stack and the child_func to work the way that it does with vfork is pretty difficult since child_func would need to be the return address from the clone call and the child_stack would need to be the top of the stack at the point that the actual system call (sys_clone) is made. You could probably try to call sys_clone directly with pid_t new_vfork(void) { return sys_clone( SIGCHLD | CLONE_VM, NULL); } Which I think might get what you want. Passing NULL as the second argument, which is the child_stack pointer, causes the kernel to do the same thing as it does in vfork and fork, which is to use the same stack as the parent. I've never used sys_clone directly and haven't tested this, but I think it should work. I believe that: sys_clone( SIGCHLD | CLONE_VM | CLONE_VFORK, NULL); is equivalent to vfork . If this doesn't work (and you can't figure out how to do something similar) then you may be able to use the regular clone call along with setjump and longjmp calls to emulate it, or you may be able to get around the need for the "return's twice" semantics of fork and vfork .
