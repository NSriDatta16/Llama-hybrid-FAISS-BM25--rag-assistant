[site]: stackoverflow
[post_id]: 5438613
[parent_id]: 
[tags]: 
Why can't I use a boost::function in an Objective-C++ block?

The following code throws an exception terminate called after throwing an instance of 'boost::exception_detail::clone_impl >' what(): call to empty boost::function at the line f() (while executing the block): void foo(); // assume this is defined somewhere boost::function f = boost::bind(&foo); ^(void) { f(); }(); However, according to the documentation on blocks , In general you can use C++ objects within a block. Within a member function, references to member variables and functions are via an implicitly imported this pointer and thus appear mutable. There are two considerations that apply if a block is copied: If you have a __block storage class for what would have been a stack-based C++ object, then the usual copy constructor is used. If you use any other C++ stack-based object from within a block, it must have a const copy constructor. The C++ object is then copied using that constructor. This seems to be true normally; if I replace f above with an instance of a simple class with an operator()() , the above code runs as expected. Why doesn't the version with boost::function work?
