[site]: stackoverflow
[post_id]: 299585
[parent_id]: 
[tags]: 
C++ Multiple Virtual Inheritance vs. COM

The net is overflowing with explanations of the "dreaded diamond problem" . So is StackOverflow. I think I understand that bit, but I fail to translate that knowledge into comprehending something similar yet different. My question begins as a pure C++ question, but the answer might well branch over into MS-COM specifics. The general problem question goes: class Base { /* pure virtual stuff */ }; class Der1 : Base /* Non-virtual! */ { /* pure virtual stuff */ }; class Der2 : Base /* Non-virtual! */ { /* pure virtual stuff */ }; class Join : virtual Der1, virtual Der2 { /* implementation stuff */ }; class Join2 : Join { /* more implementation stuff + overides */ }; This is not the classic diamond solution. Exactly what does "virtual" do here? My real problem is trying to understand a discussion over at our friends' place at CodeProject. It involves a custom class for creating a transparent container for the Flash player. I thought I would try this place for fun. It turns out that the following declaration crashes your app, with version 10 of the Flash player. class FlashContainerWnd: virtual public IOleClientSite, virtual public IOleInPlaceSiteWindowless, virtual public IOleInPlaceFrame, virtual public IStorage Debugging shows that when entering the function implementations (QueryInterface etc), from different callers, I get different "this"-pointer values for different calls. But removing "virtual" does the trick! No crashes, and same "this"-pointer. I would like to clearly understand exactly what is going on. Thanks a lot. Cheers Adam
