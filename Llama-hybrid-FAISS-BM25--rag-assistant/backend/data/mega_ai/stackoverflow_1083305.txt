[site]: stackoverflow
[post_id]: 1083305
[parent_id]: 1082913
[tags]: 
I did something similar years ago for a full-text search engine. In my case, each indexed word generated a record which consisted of a record number (document id) and a word number (it could just as easily have stored word offsets) which needed to be compressed as much as possible. I used a delta-compression technique which took advantage of the fact that there would be a number of occurrences of the same word within a document, so the record number often did not need to be repeated at all. And the word offset delta would often fit within one or two bytes. Here is the code I used. Since it's in C++, the code may is not going to be useful to you as is, but can be a good starting point for writing compressions routines. Please excuse the hungarian notation and the magic numbers strewn within the code. Like I said, I wrote this many years ago :-) IndexCompressor.h // // index compressor class // #pragma once #include "File.h" const int IC_BUFFER_SIZE = 8192; // // index compressor // class IndexCompressor { private : File *m_pFile; WA_DWORD m_dwRecNo; WA_DWORD m_dwWordNo; WA_DWORD m_dwRecordCount; WA_DWORD m_dwHitCount; WA_BYTE m_byBuffer[IC_BUFFER_SIZE]; WA_DWORD m_dwBytes; bool m_bDebugDump; void FlushBuffer(void); public : IndexCompressor(void) { m_pFile = 0; m_bDebugDump = false; } ~IndexCompressor(void) {} void Attach(File& File) { m_pFile = &File; } void Begin(void); void Add(WA_DWORD dwRecNo, WA_DWORD dwWordNo); void End(void); WA_DWORD GetRecordCount(void) { return m_dwRecordCount; } WA_DWORD GetHitCount(void) { return m_dwHitCount; } void DebugDump(void) { m_bDebugDump = true; } }; IndexCompressor.cpp // // index compressor class // #include "stdafx.h" #include "IndexCompressor.h" void IndexCompressor::FlushBuffer(void) { ASSERT(m_pFile != 0); if (m_dwBytes > 0) { m_pFile->Write(m_byBuffer, m_dwBytes); m_dwBytes = 0; } } void IndexCompressor::Begin(void) { ASSERT(m_pFile != 0); m_dwRecNo = m_dwWordNo = m_dwRecordCount = m_dwHitCount = 0; m_dwBytes = 0; } void IndexCompressor::Add(WA_DWORD dwRecNo, WA_DWORD dwWordNo) { ASSERT(m_pFile != 0); WA_BYTE buffer[16]; int nbytes = 1; ASSERT(dwRecNo >= m_dwRecNo); if (dwRecNo != m_dwRecNo) m_dwWordNo = 0; if (m_dwRecordCount == 0 || dwRecNo != m_dwRecNo) ++m_dwRecordCount; ++m_dwHitCount; WA_DWORD dwRecNoDelta = dwRecNo - m_dwRecNo; WA_DWORD dwWordNoDelta = dwWordNo - m_dwWordNo; if (m_bDebugDump) { TRACE("%8X[%8X] %8X[%8X] : ", dwRecNo, dwRecNoDelta, dwWordNo, dwWordNoDelta); } // 1WWWWWWW if (dwRecNoDelta == 0 && dwWordNoDelta > 8); buffer[1] = WA_BYTE(dwWordNoDelta & 0x00ff); nbytes += sizeof(WA_BYTE); } // 001RRRRR WWWWWWWW WWWWWWWW else if (dwRecNoDelta 0 && nbytes IC_BUFFER_SIZE) FlushBuffer(); CopyMemory(m_byBuffer + m_dwBytes, buffer, nbytes); m_dwBytes += nbytes; if (m_bDebugDump) { for (int i = 0; i Write(WA_BYTE(0)); }
