[site]: stackoverflow
[post_id]: 3045273
[parent_id]: 3043012
[tags]: 
I don't know if this is a "more Ruby way". At least at is a more "higher-order" way, FWIW. # first line is number of inputs (Don't need it), thus drop the first line # read inputs as ints h = ARGF.drop(1).reduce(Hash.new(0)) {|h, n| h.tap {|h| h[n.to_i] += 1 }} Not much to say here. Instead of simply looping over ARGF and setting the hash keys, we use reduce to let it do the work for us. And we use a hash with a default value of 0 instead of manually checking the keys for existence. We use Enumerable#drop to simply drop the first line. ARGF is a really cool feature stolen (like most of the scripting features) from Perl: if you simply call the script as script.rb without arguments, then ARGF is the standard input. If, however, you call your script like script.rb a.txt b.txt , then Ruby will interpret all the arguments as filenames, open all the files for reading and ARGF will be the concatenation of their contents. This allows you to very quickly write scripts that can take their input either via standard input or a file. # find smallest mode modes = h.group_by(&:last).sort.last.last.map(&:first).sort puts "Mode is: #{modes.first}" Ruby doesn't have an explicit key-value-pair type, instead most looping operations on hashes use two-element arrays. This allows us to refer to the key and the value with Array#first and Array#last . In this particular case, we are using Enumerable#group_by to group the hash into different buckets, and the grouping criterion we use is the last method, i.e. the value which in our hash is the frequency. In other words, we group by frequency. If we now sort the resulting hash, the very last element is the one with the highest frequency (i.e. the mode). We take the last element (the value of the key-value-pair) of that, and then the last element of that, which is an array of key-value-pairs ( number => frequency ) of which we extract the keys (the numbers) and sort them. [Note: simply print out the results at every intermediate stage and it's much easier to understand. Just replace the modes = ... line above with something like this: p modes = h.tap(&method(:p)). group_by(&:last).tap(&method(:p)). sort.tap(&method(:p)). last.tap(&method(:p)). last.tap(&method(:p)). map(&:first).tap(&method(:p)). sort ] modes is now a sorted array with all the numbers which have that particular frequency. If we take the first element, we have the smallest mode. # mode unique? puts "Mode is #{unless modes.size == 1 then '*not* ' end}unique." And if the size of the array is not 1 , then the mode was not unique. # print number of singleton odds, # odd elems repeated odd number times in desc order # even singletons in desc order odds, evens = h.select {|_,f|f==1}.map(&:first).sort.reverse.partition(&:odd?) It looks like there is a lot going on here, but it's actually straightforward. You start reading after the equals sign and simply read left to right. we select all items in the hash whose value (i.e. frequency) is 1 . IOW, we select all the singletons. we map all the resulting key-value-pairs just to their first element, i.e. the number â€“ IOW we throw away the frequency. we sort the list and then reverse it (for larger lists we should sort in reverse to begin with, since this is quite a waste of CPU cycles and memory) lastly, we partition the array into two arrays, one containing all the odd numbers and the other all the even numbers now we finally look to the left side of the equals sign: Enumerable#partition returns a two-element array containing the two arrays with the partitioned elements and we use Ruby's destructuring assignment to assign the two arrays to two variables puts "Number of elements with an odd value that appear only once: #{odds.size}" Now that we have a list of odd singletons, their number is simply the size of the list. puts "Elements repeated an odd number of times: #{ h.select {|_, f| f.odd?}.map(&:first).sort.reverse.join(', ') }" This is very similar to the above: select all numbers with an odd frequency, map out the keys (i.e. numbers), sort, reverse and then convert them to a string by joining them together with a comma and space in between. puts "Elements with an even value that appear exactly once: #{evens.join(', ')}" Again, now that we have a list of even singletons, printing them is just a matter of joining the list elements with commas. # print fib numbers in the hash I didn't feel like refactoring this algorithm to be more efficient and specifically to memoize. I just made some small adjustments. class Integer There was nothing in the algorithm that depended on the number being a certain size, so I pulled the method up into the Integer class. def fib? And I dropped the is_ prefix. The fact that this is a boolean method is already explicit in the question mark. l, h = 0, 1 while h This probably doesn't need much explanation: take the keys, sort them, select all Fibonacci numbers and join them together with commas. Here is an idea for how to refactor this algorithm. There is a very interesting implementation of Fibonacci using a Hash with default values for memoizing: fibs = {0 => 0, 1 => 1}.tap do |fibs| fibs.default_proc = ->(fibs, n) { fibs[n] = fibs[n-1] + fibs[n-2] } end It would look a little like this: class Integer @@fibs = {0 => 0, 1 => 1}.tap do |fibs| fibs.default_proc = ->(fibs, n) { fibs[n] = fibs[n-1] + fibs[n-2] } end def fib? i = 0 until @@fibs[i += 1] > self break true if @@fibs[i] == self end end end puts "Fibonacci numbers: #{h.keys.sort.select(&:fib?).join(', ')}" If anyone can think of an elegant way to get rid of the i = 0 , i += 1 and the whole until loop, I'd appreciate it.
