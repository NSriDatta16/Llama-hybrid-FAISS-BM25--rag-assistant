[site]: stackoverflow
[post_id]: 3774414
[parent_id]: 3774139
[tags]: 
This part of your code doesn’t make sense: static void doSomething () where T : Child // ^^^^^^^^^^^^^^^ This says that T must be a Child, // which necessarily means it is not // going to be a Parent { if (typeof(T) == typeof(Parent)) // You definitely need to define the constraint as T : Parent if you want to be able to pass in a Parent . You said that your problem is that you can’t cast the output of orm.GetObject to Child . You are right, you can’t cast it directly — but you can cast it to Parent first and then to Child . I think this should work: static void doSomething () where T : Parent { if (typeof(T) == typeof(Parent)) { Parent obj = (Parent) orm.GetObject (criteria); } else if (typeof(T) == typeof(Child)) { Child obj = (Child) (Parent) orm.GetObject (criteria); } } From the point of view of the compiler, T is like a member of the class hierarchy, a bit like this: ┌──────────┐ | Parent | └─┬──────┬─┘ │ │ ↓ ↓ ┌─────────┐ ┌───────┐ | Child | | T | └─────────┘ └───────┘ I think this shows you why you can’t cast directly from T to Child , but you can upcast to Parent (which always succeeds because T is a Parent ) and then downcast to Child (which does the runtime check for whether it really is a Child , which of course in your case it will be). (By the way, I am assuming that you need to use orm.GetObject and you can’t use orm.GetObject . If you can, that would make it simpler, but maybe you can’t because the criteria depend on T .)
