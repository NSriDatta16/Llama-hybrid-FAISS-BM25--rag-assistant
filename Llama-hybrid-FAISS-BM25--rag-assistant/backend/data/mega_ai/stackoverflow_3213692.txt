[site]: stackoverflow
[post_id]: 3213692
[parent_id]: 3213378
[tags]: 
There are really two questions here. The first one regarding signals/slots with QTableWidgetItem, and the second regarding handling mouse clicks on the QTableWidget. Signals Slots on a QTableWidgetItem note: I don't recommend doing it this way, read all the way to the bottom* Using signals and slots requires that the object that emits the signal, have the signal defined in the class definition. Likewise the object that receives a slot, must have that slot declared in the class definition. You'll notice (on the Qt docs) that QTableWidgetItem doesn't have a signals or slots to set/remove the background brush you are using to draw your picture. So, you will have to subclass QTableWidgetItem, and provide this signals/slots yourself. Example: class ChessItem : public QTableWidgetItem { // constructor / destructor // other methods public slots: void slotChangeBackground( const QBrush & brush ) { setBackground( brush ); } }; Handling Mouse Clicks on the QTableWidget edit: I removed the event handling paragraph, because using QTableWidget's builtin signals is easier QTableWidget offers the cell clicked signal: void QTableWidget::cellClicked ( int row, int column ) So in your Table class add a slot, then connect it the cellClicked signal to it: // in your Table's constructor: connect( table, SIGNAL( cellClicked(int, int) ), this, SLOT( slotCellClicked(int,int) ) ) ); // elsewhere... void slotCellClicked(int row, int column) { // handle mouse clicking here } The problem as I see it is you don't want to just connect any ol signal to slotChangeBackground, because that would change every background. So I suggest not using signals/slots for changing the background, and instead use QTableWidget::itemAt ( int ax, int ay ) in your slotCellClicked(x,y) to retrieve the item at a coordinate, then call setBackground on it.
