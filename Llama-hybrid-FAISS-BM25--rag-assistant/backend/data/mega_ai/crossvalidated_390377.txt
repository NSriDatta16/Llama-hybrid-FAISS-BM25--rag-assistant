[site]: crossvalidated
[post_id]: 390377
[parent_id]: 192731
[tags]: 
If you like, you could do this by writing a special processing function for this gist I wrote: https://gist.github.com/CharlieCodex/f494b27698157ec9a802bc231d8dcf31 import tensorflow as tf def self_feeding_rnn(cell, seqlen, Hin, Xin, processing=tf.identity): '''Unroll cell by feeding output (hidden_state) of cell back into in as input. Outputs are passed through `processing`. It is up to the caller to ensure that the processed outputs have suitable shape to be input.''' veclen = tf.shape(Xin)[-1] # this will grow from [ BATCHSIZE, 0, VELCEN ] to [ BATCHSIZE, SEQLEN, VECLEN ] buffer = tf.TensorArray(dtype=tf.float32, size=seqlen) initial_state = (0, Hin, Xin, buffer) condition = lambda i, *_: i If your code is something like: # how your network might work: W = tf.Variable(shape=(state_size, 3), ... ) B = tf.Variable(shape=(3,), ... ) Yo, Ho = tf.nn.dynamic_rnn( cell, input, state ) # ( lat lon temp ) 3-vectors predictions = tf.nn.matmul(Yo, W) + B You could use the gist as: # using self_feeding_rnn from magic import temperature_sampler def process_yt(yt): p = tf.nn.matmul(yt, W) + B real_temp = temperature_sampler[p[...,0],p[...,1]] # remove final element (temp) and add on proper temp return tf.concat((p[...,:-1], real_temp), axis=-1) Yo, Ho = self_feeding_rnn(cell, seed, initial_state, processing=process_yt) This makes the crux of your problem getting the temperature data into a tensorflow understandable format (some sort of 2D sampler). I have no experience working with such things, but in the worst case, you can just round your lat,lon to integers and grab from a constant array (using tf.constant , not np.ndarray so that you can index with tensors). If you are still working on this I would love to help and feel free to ask me any questions!
