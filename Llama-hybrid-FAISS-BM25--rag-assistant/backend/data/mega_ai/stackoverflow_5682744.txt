[site]: stackoverflow
[post_id]: 5682744
[parent_id]: 5627819
[tags]: 
Since I've wasted considerably more time investigating than the problem warranted, I'll post my conclusions here. First, to try to reiterate the rationale for the question: I have abstracted argument-handling, I/O, and other shared tasks into an abstract superclass, which I expect others to extend. After performing argument parsing and shared setup, a static method in the superclass instantiates an instance of the subclass and calls its run() method. Authors of subclasses are encouraged to implement public static void main(String[]) and call the superclass's primary entry point. But, unlike the requirement that all subclasses implement run() , we cannot enforce that requirement statically at compile time (since Java has no concept of an abstract static method). So I'm trying to implement a main(String[]) method in the superclass which can determine the name of the subclass which was requested on the command-line and instantiate the appropriate class. I've found two methods, both specific to the Sun / Oracle JVM. The first uses internal sun.jvmstat classes: import java.lang.management.ManagementFactory; import sun.jvmstat.monitor.MonitoredVmUtil; import sun.jvmstat.monitor.VmIdentifier; import sun.jvmstat.perfdata.monitor.protocol.local.LocalMonitoredVm; ... public static String jvmstatMainClass() { // Determine the VMID (on most platforms, this will be the PID) final String pid = ManagementFactory.getRuntimeMXBean().getName().split("@")[0]; // Connect to the virtual machine by VMID final VmIdentifier vmId = new VmIdentifier(pid); final LocalMonitoredVm lmVm = new LocalMonitoredVm(vmId, 1000); // Find the requested main-class String mainClass = MonitoredVmUtil.mainClass(lmVm, true); // And detach from the VM lmVm.detach(); return mainClass; } The second uses Sun's jps utility: import java.io.BufferedReader; import java.io.InputStreamReader; ... public static String jpsMainClass() { // Determine the VMID (on most platforms, this will be the PID) final String pid = ManagementFactory.getRuntimeMXBean().getName().split("@")[0]; // Execute the 'jps' utility final Process jps = Runtime.getRuntime().exec(new String[] { "jps", "-l" }); final BufferedReader br = new BufferedReader(new InputStreamReader(jps.getInputStream())); // Parse the output of jps to find the current VM by PID for (String line = br.readLine(); line != null; line = br.readLine()) { final String[] split = line.split(" "); if (pid.equals(split[0])) { return split[1]; } } } return null; } Hopefully my wasted time will prove helpful to someone else.
