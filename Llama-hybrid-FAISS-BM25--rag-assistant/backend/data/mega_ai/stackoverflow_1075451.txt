[site]: stackoverflow
[post_id]: 1075451
[parent_id]: 515305
[tags]: 
You might make your extension method generic, e.g.: public static void AddPhoneNumberToContact ( this T contact, PhoneType type, String number ) { PhoneRow pr = PhoneRow.CreateNew(); pr.SetDefaults(); pr.PtypeIdx = type; pr.PhoneNumber = number; ((T)contact).Phones.Add(pr); pr = null; } You won't be able to use lock because "'T' is not a reference type as required by the lock statement", so you might have to return some value. If it complains about not being able to resolve the Phones method on type T, you could: Pass in some function delegate that would take type T, return nothing, and perform the action ((T)contact).Phones.Add(pr); . Or you could create an interface like the following: public interface IPhoneable { IList Phones(); } Then, once you have that interface, you can add the following to your generic extension method: public static void AddPhoneNumberToContact ( this T contact, PhoneType type, String number ) where T : IPhoneable {...} Here, T is still a generic type, but now your AddPhoneNumberToContact method has the requirement that, whatever T is, it inherits from the IPhoneable interface, which you just defined to have the Phones() method. See also C# Extension Method for Generic Collections .
