[site]: stackoverflow
[post_id]: 3662418
[parent_id]: 
[tags]: 
Changetracking and concurrency - can this fail?

I've been messing around with Expressions - and I may have gone beyond my capabilities - but here goes... I've implemented 'type-safe' INotifyPropertyChanged implementation (an example is here ), but gone a bit farther and included changetracking: public abstract BaseViewModel :INotifyPropertyChanged { private readonly IBaseChangeTracker _changeTracker; protected void OnPropertyChanged (Expression > property, T value) { _changeTracker.AddChange(property, value); OnPropertyChanged(property); } protected virtual void OnPropertyChanged (Expression > property) { if (PropertyChanged == null) return; PropertyChanged(this, new PropertyChangedEventArgs(property.GetMemberInfo().Name)); } public event PropertyChangedEventHandler PropertyChanged; } public abstract class BaseChangeTracker :IBaseChangeTracker { private readonly IDictionary _changes = new Dictionary (); public void AddChange (Expression > expression, T newValue) { _changes.Add(expression, newValue); } public void ApplyChanges(TEntity entity) { foreach (var change in _changes) { var property = typeof(TEntity).GetProperty(change.Key.GetMemberInfo().Name); property.SetValue(entity, change.Value, null); } } public virtual void CopyCurrentState(TEntity entity) { _changes.Clear(); } public virtual void ResetEntity(TEntity entity) { _changes.Clear(); } public bool HasUnsavedChanges { get { return _changes.Any(); } } } This may seem a bit excessive - each entity will have it it's own ChangeTracker keeping the original state of the entity when loaded and can reset it back to these, but the idea is that if there is a concurrency conflict when it tries to save the updated entity, I reload the entity from the database and run it through .ApplyChanges and try to save it again. This will remove about 95% of my concurrency problems... if it works. My tests show that for limited entities it works, but that is with simple property-changes. Known issue: I have yet to find an elegant way of handling collections. What else am I missing - or are there obvious flaws in my design?
