[site]: stackoverflow
[post_id]: 4890133
[parent_id]: 
[tags]: 
Is it really worth implementing toString() for entity classes

It is consistently advised to override (implement) the toString() method of a class. The Java API documentation itself says "It is recommended that all subclasses override this method.". Bloch, in Effective Java has the item "Always override toString". And only a fool contradicts Bloch, right? I am however coming to doubt this advice: is it really worth implementing toString() for entity classes ? I'll try to lay out my reasoning. An entity object has a unique identity; it is never the same as another object, even if the two entites have equivalent attribute values. That is, (for non-null x ), the following invariant applies for an entity class (by definition): x.equals(y) == (x == y) The toString() method returns a string that "textually represents" its object (in the words of the Java API). A good representation captures the essentials of the object, so if two representations are different they are representaions of different (non-equivalent) objects, and conversely if two represenations are equivalent they are representations of equivalent objects. That suggests the following invariant for a good representation (for non-null x , y ): x.toString().equals(y.toString()) == x.equals(y) Thus for entities we expect x.toString().equals(y.toString()) == (x == y) that is, each entity object should have a unique textual representation, which toString() returns. Some entity classes will have a unique name or numeric ID field, so their toString() method could return a representation that includes that name or numeric ID. But in general, the toString() method does not have access to such a field. Without a unique field for an entity, the best that toString() can do is to include a field that is unlikely to be the same for different objects. But that is exactly the requirement of System.identityHashCode() , which is what Object.toString() provides. So Object.toString() is OK for an entity object that has no data members, but for most classes you would want to include them in the text representation, right? In fact, you'd want to include all of them: if the type has a (non null) data member x , you would want to include x.toString() in the representation. But this creates a problem for data members that hold references to other entities: that is, which are associations . If a Person object has a Person father data member, the naive implementation will produce a fragment of that person's family tree, not of the Person itself. If there are two-way assocaitions, a naive implementation will recurse until you get stack overflow So maybe skip the data members that hold associations? But what about a value type Marriage having Person husband and Person wife data members? Those associations ought to be reported by Marriage.toString() . The simplest way to make all the toString() methods work is for Person.toString() to report only the identity fields ( Person.name or System.identityhashCode(this) ) of the Person . So it seems that the provided implementation of toString() is actually not too bad for entity classes. In that case, why override it? To make it concrete, consider the following code: public final class Person { public void marry(Person spouse) { if (spouse == this) { throw new IlegalArgumentException(this + " may not marry self"); } // more... } // more... } Just how useful would an override of toString() be when debugging an IlegalArgumentException thrown by Person.marry() ?
