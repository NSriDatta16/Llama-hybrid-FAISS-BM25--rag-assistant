[site]: stackoverflow
[post_id]: 1523523
[parent_id]: 1510041
[tags]: 
I started doing WPF applications in a FFA (free-for-all) design pattern like this and I won't go back it, even for a small projects. Though it feels like you are more productive going right to the source, bare-metal UI, I came to the conclusion it's more a perception of productivity because you get instant gratification . Consider: TextBlock.Text = "HelloWorld" . No ViewModel to construct, no gluing the V and VM or binding setups. Hit F5 and we see "HelloWorld" in all it's glory. My problem with this is multifaceted. Here is a couple of my biggest issues: Separation of concerns . Without it, code navigation, bug fixing, extensibility and general maintenance is severely hindered. Adding a feature to an application would be more liken to a choose-your-own-adventure book or an exercise in quantum physics than it is actually getting something done. If you have a predictable way to build your app, you have a predictable way to work on it. Flexibility of the UI . When using the FFA pattern, I found my ability to design UI in my applications was near impossible. Too many times did I have a control I couldn't design in Blend. It would just give a red border with an exception. Some code-behind I had used something else that wasn't usable in design mode causing an issue. Moving to MVVM magically fixed all my Blend issues. If I get a red border in Blend now, I KNOW it's a problem with my presentation code. Not anything else. So using FFA may get your V1 out the door quick, but the PHBs will be wondering why v1.5 is going to take four times longer than v1. We've all been there :) I think if you want to do something like this, I would work with lookless controls, where you define UI "PARTS", making it very Blendable. You get reference to the UI controls via the OnApplyTemplate. These controls are totally stylable and inheritable. It is your View where you would use these controls and pull data from binding, passing it to your lookless controls. The View, IMO, should always be glue for the VM to bind to these kinds of controls. For the Infragistics controls you are having problems with, assuming you are using Prism, you should make a custom region adaptor for it. This lets you code EXACTLY how controls will be added to the Infragistics. No binding involved. View injection will just work like you are used to once you get that built in. I've seen some people have problems like these in MVVM, but I believe it's just taking MVVM too literally. Not everything gets evented by a messenger. My ~40 view (and growing) application has around 5 composite events. I inherit controls, I use view injection on things that aren't even panels or content controls. Sometimes I have codebehind handle presentation related code/events...And...really, I advocate MVVM and I don't give a @$&% about testing :)
