[site]: stackoverflow
[post_id]: 979079
[parent_id]: 979034
[tags]: 
This is a classic hurdle that most MySQL programmers bump into. You have a column ticket_id that is the argument to GROUP BY . Distinct values in this column define the groups. You have a column incoming_time that is the argument to MAX() . The greatest value in this column over the rows in each group is returned as the value of MAX() . You have all other columns of table article. The values returned for these columns are arbitrary, not from the same row where the MAX() value occurs. The database cannot infer that you want values from the same row where the max value occurs. Think about the following cases: There are multiple rows where the same max value occurs. Which row should be used to show the columns of article.* ? You write a query that returns both the MIN() and the MAX() . This is legal, but which row should article.* show? SELECT article.* , MIN(article.incoming_time), MAX(article.incoming_time) FROM ticket, article WHERE ticket.id = article.ticket_id AND ticket.queue_id = 1 GROUP BY article.ticket_id You use an aggregate function such as AVG() or SUM() , where no row has that value. How is the database to guess which row to display? SELECT article.* , AVG(article.incoming_time) FROM ticket, article WHERE ticket.id = article.ticket_id AND ticket.queue_id = 1 GROUP BY article.ticket_id In most brands of database -- as well as the SQL standard itself -- you aren't allowed to write a query like this, because of the ambiguity. You can't include any column in the select-list that isn't inside an aggregate function or named in the GROUP BY clause. MySQL is more permissive. It lets you do this, and leaves it up to you to write queries without ambiguity. If you do have ambiguity, it selects values from the row that is physically first in the group (but this is up to the storage engine). For what it's worth, SQLite also has this behavior, but it chooses the last row in the group to resolve the ambiguity. Go figure. If the SQL standard doesn't say what to do, it's up to the vendor implementation. Here's a query that can solve your problem for you: SELECT a1.* , a1.incoming_time AS maxtime FROM ticket t JOIN article a1 ON (t.id = a1.ticket_id) LEFT OUTER JOIN article a2 ON (t.id = a2.ticket_id AND a1.incoming_time In other words, look for a row ( a1 ) for which there is no other row ( a2 ) with the same ticket_id and a greater incoming_time . If no greater incoming_time is found, the LEFT OUTER JOIN returns NULL instead of a match.
