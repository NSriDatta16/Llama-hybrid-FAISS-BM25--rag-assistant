[site]: stackoverflow
[post_id]: 3755161
[parent_id]: 3755111
[tags]: 
How can you overload double brackets? I didn't fully understand your question, but you have to overload brackets, and make them return an object who overloads its own bracket operator. For example, if you have a vector of vectors, the work is already done: vector > overloads operator[] , which returns a vector ; this, in turn, has its bracket operator overloaded (and it returns a something object), so you can simply do: vector > vec; // ... something s = vec[2][3]; Example with a proxy object: template class Container { private: // ... public: // Proxy object used to provide the second brackets template class OperatorBracketHelper { Container & parent; size_t firstIndex; public: OperatorBracketHelper(Container & Parent, size_t FirstIndex) : parent(Parent), firstIndex(FirstIndex) {} // This is the method called for the "second brackets" T & operator[](size_t SecondIndex) { // Call the parent GetElement method which will actually retrieve the element return parent.GetElement(firstIndex, SecondIndex); } } // This is the method called for the "first brackets" OperatorBracketHelper operator[](size_t FirstIndex) { // Return a proxy object that "knows" to which container it has to ask the element // and which is the first index (specified in this call) return OperatorBracketHelper (*this, FirstIndex); } T & GetElement(size_t FirstIndex, size_t SecondIndex) { // Here the actual element retrieval is done // ... } } (add overloaded const methods wherever appropriate :) ) Note that with this method you lose almost nothing in respect to an operator() implementation, since the retrieval is still done in one single place, without constraints on the usage of the two indexes, having both indexes at the moment of performing the retrieval, and without returning "fat" temporary objects ( OperatorBracketHelper is just as big as two pointers, and can be easily optimized away by the compiler).
