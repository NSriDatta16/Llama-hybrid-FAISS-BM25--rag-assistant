[site]: stackoverflow
[post_id]: 3820214
[parent_id]: 
[tags]: 
Cross Reference and Passing the This Pointer between Classes [NS2/C++]

------------ ------------ | TclObjct | | Handler | ------------ ------------ |__________________________________| | -------------- | NsObject |---> virtual void recv(Packet*,Handler* callback = 0) = 0; -------------- | -------------- | Connector | -------------- | ________________________________ | | | ------------- | | Agent | | ------------- | | | ------------- | | OLSR | ------------- ------------- | Queue |-----> virtual void recv(Packet*, Handler*); ------------- | ------------- | DropTail | ------------- | ------------- | PriQueue |-----> void recv(Packet* p, Handler* h); -------------- Dear all, I am using NS2 to implement a network coding protocol. But I have been stuck on a problem for days regarding to cross reference between classes and the way to pass the "this" pointer. The class hierarchy is shown in the above figure (Please excuse me it looks like that, I am a new user of this site, and is not allowed to post images). In the program I have to create a connection from the "PriQueue" class to the "OLSR" class, which I think cross reference might be a nice way (The connection from OLSR to PriQueue is automatically set in NS2 using the pointer 'target_', which is of type NsObject*). Part of the code is giving below. But the problem is, the pointer "olsr_callback" is always NULL. As a result, when calling function add_rr_ack() from the PriQueue object, the line accessing the 'ra_addr_' variable will generates a segmentation error . (The program works fine if the line " nsaddr_t addr = ra_addr(); " is blocked) The cross reference mechanism is obtained from this page: cross reference as stated in post 4 I guess it is the problem of the way I tried to pass the "this" pointer in send_pkt(). But I can't figure out what is wrong. If you have any idea in mind, please help me. Any help will be appreciated. Shu. //------OLSR.h--------// class PriQueue; class OLSR : public Agent { ...... nsaddr_t ra_addr_; void send_pkt(); ...... public: inline nsaddr_t& ra_addr() { return ra_addr_; } Packet* add_rr_ack(Packet*,PriQueue*); ...... } //------OLSR.cc------// #include #include void OLSR::send_pkt() { ...... ...... target_->recv(p,this); // 'target_' points to the respective priqueue object // during the runtime } Packet* OLSR::add_rr_ack(Packet* p, PriQueue*) { ...... nsaddr_t addr = ra_addr(); // Generate a segmentation error!!!!! ....... return p; } ...... //------priqueue.h------// class OLSR; class PriQueue : public DropTail { public: void recv(Packet* p, Handler* h); ...... Packet* deque(); OLSR* olsr_callback; ...... } //------priqueue.cc------// #include #include "priqueue.h" PriQueue::PriQueue() : DropTail(),olsr_callback(NULL) {......} PriQueue::recv(Packet* p, Handler* h) { ...... olsr_callback = dynamic_cast (h); //Debug printf("Packet received through recv() in PriQueue. \n"); ...... } PriQueue::deque() { ..... Packet* p = q_->deque(); if(olsr_callback == NULL) printf("CALLBACK is NULL. \n"); Packet* p1 = olsr_callback->add_rr_ack(p); ..... } P.S: I also tried to change the recv() function in class PriQueue as follows: //------priqueue.h------// void recv(Packet* p, OLSR* h); // ------priqueue.cc-----// void PriQueue::recv(Packet* p, OLSR*h) { ...... olsr_callback = h; ...... } // However, in this case, when we call the recv() function from send_pkt(). It will actually invoke the recv() function of the base class Queue, not the recv() function of the PriQueue as expected.
