[site]: stackoverflow
[post_id]: 3189337
[parent_id]: 3181821
[tags]: 
This thread on the Apple Developer Forums may be of interest, in which it is suggested that you run a kqueue in its own thread, tracking the app's Documents folder. An Apple tech followed up with some sample code here : - (void)kqueueFired { int kq; struct kevent event; struct timespec timeout = { 0, 0 }; int eventCount; kq = CFFileDescriptorGetNativeDescriptor(self->_kqRef); assert(kq >= 0); eventCount = kevent(kq, NULL, 0, &event, 1, &timeout); assert( (eventCount >= 0) && (eventCount _kqRef, kCFFileDescriptorReadCallBack); } static void KQCallback(CFFileDescriptorRef kqRef, CFOptionFlags callBackTypes, void *info) { ViewController * obj; obj = (ViewController *) info; assert([obj isKindOfClass:[ViewController class]]); assert(kqRef == obj->_kqRef); assert(callBackTypes == kCFFileDescriptorReadCallBack); [obj kqueueFired]; } - (IBAction)testAction:(id)sender { #pragma unused(sender) NSString * docPath; int dirFD; int kq; int retVal; struct kevent eventToAdd; CFFileDescriptorContext context = { 0, self, NULL, NULL, NULL }; CFRunLoopSourceRef rls; docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; assert(docPath != 0); NSLog(@"%@", docPath); dirFD = open([docPath fileSystemRepresentation], O_EVTONLY); assert(dirFD >= 0); kq = kqueue(); assert(kq >= 0); eventToAdd.ident = dirFD; eventToAdd.filter = EVFILT_VNODE; eventToAdd.flags = EV_ADD | EV_CLEAR; eventToAdd.fflags = NOTE_WRITE; eventToAdd.data = 0; eventToAdd.udata = NULL; retVal = kevent(kq, &eventToAdd, 1, NULL, 0, NULL); assert(retVal == 0); assert(self->_kqRef == NULL); self->_kqRef = CFFileDescriptorCreate(NULL, kq, true, KQCallback, &context); assert(self->_kqRef != NULL); rls = CFFileDescriptorCreateRunLoopSource(NULL, self->_kqRef, 0); assert(rls != NULL); CFRunLoopAddSource(CFRunLoopGetCurrent(), rls, kCFRunLoopDefaultMode); CFRelease(rls); CFFileDescriptorEnableCallBacks(self->_kqRef, kCFFileDescriptorReadCallBack); }
