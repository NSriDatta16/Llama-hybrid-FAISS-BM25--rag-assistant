[site]: stackoverflow
[post_id]: 5271202
[parent_id]: 
[tags]: 
When running a perl script on C program, I get GLOB(0x1a6a8830) as my output

For one of my projects, we had to write a multi-threaded program in C. Everything seemed to be going well. The professor then gave us a perl script to run with our C code once we were finished. However, on the console where I run the script, whenever my program should be outputting(i think), I get GLOB(0x1a6a8830) all over the place. Here is the output. GLOB(0x1a6a8830) TRANS 995 -589398 987 154107 472 435291 GLOB(0x1a6a8830) TRANS 397 -557927 559 798860 989 -240933 GLOB(0x1a6a8830) TRANS 289 -368267 408 139828 419 842413 277 -598329 613 372608 285 508034 256 -896287 With the TRANS (then numbers) being an input that is being captured by my C program. Does anyone know what this GLOB is???? use strict; use warnings; use integer; if (@ARGV [ [ [ ]]]\n"; exit 1; } my($prgm, $thread, $accts, $seed) = @ARGV; $thread ||= 10; $accts ||= 1000; $seed ||= 0; srand($seed); my $outfile = 'testout-'.$$; my($c_in, $f_in, $c_out, $f_out); pipe $f_in, $c_in; pipe $c_out, $f_out; my $pid = fork; `if ($pid == 0) { open STDIN, ' &', $f_out; close $c_in; close $c_out; close $f_in; close $f_out; exec $prgm, $thread, $accts, $outfile; exit 1; } else { close $f_in; close $f_out; } # make the pipes autoflush select $c_in; $| = 1; select $c_out; $| = 1; select STDOUT; sub sr { my $line = shift; print "\e[33m$line\e[m\n"; print $c_in "$line\n"; my $resp = $c_out; chomp $resp; print "\e[32m$resp\e[m\n"; return $resp; } my $init_skip = 0; for my $id (0..($accts/10 - 1)) { my $line = 'TRANS'; $line .= ' '.($id*10 + $_).' 10000000' for 1..10; sr $line; $init_skip++; } print "\e[35mWaiting for initial deposits to complete...\e[m\n"; sleep 60; for my $line (1..1000) { my $line = "TRANS"; my $bal = 0; my $len = int rand 8; my %dups; for (0..$len) { my $acct = 1 + int rand $accts; my $amt = 1_000_000 - int rand 2_000_000; next if $dups{$acct}++; $bal += -$amt; $line .= " $acct $amt"; } my $acct = 1 + int rand $accts; next if $dups{$acct}; $line .= " $acct $bal"; sr $line; } print "\e[35mWaiting for transactions to complete...\e[m\n"; sleep 60; for my $id (1..$accts) { sr "CHECK $id"; } print "\e[33mEND\e[m\n"; print $c_in "END\n"; print "\e[35mWaiting for program to exit...\e[m\n"; wait; no integer; print "\e[35mChecking output file:\e[m\n"; open F, $outfile; my $trcount = 0; my $trtime = 0; my $balcount = 0; my $baltime = 0; my $total = 0; while ( ) { if ($init_skip-- > 0) { die "Bad (initial deposit) output line: $_" unless /^\d+ OK TIME/; } elsif (/ (OK|ISF \d+) TIME (\d+)(\.\d+) (\d+)(\.\d+)/) { $trtime += ($4 - $2) + ($5 - $3); $trcount++; } elsif (/^\d+ BAL (\d+) TIME (\d+)(\.\d+) (\d+)(\.\d+)/) { $total += $1; $baltime += ($4 - $2) + ($5 - $3); $balcount++; } else { die "Bad output line: $_"; } } close F; if ($balcount != $accts) { print "ERR: There were $accts accounts but only $balcount balance queries\n"; } print "Final balance of all $accts accounts is $total\n"; my $travg = $trtime / $trcount; printf 'The %d transactions took %.2fs total, or an average of %.4fs each'."\n", $trcount, $trtime, $travg; my $balavg = $baltime / $balcount; printf 'The %d balance checks took %.2fs total, or an average of %.4fs each'."\n", $balcount, $baltime, $balavg; That is the entire perl script My program acts as a multithreaded bank server, and accepts the commands TRANS and CHECK
