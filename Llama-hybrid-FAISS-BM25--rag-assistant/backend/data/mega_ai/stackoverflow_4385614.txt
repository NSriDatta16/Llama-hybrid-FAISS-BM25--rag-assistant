[site]: stackoverflow
[post_id]: 4385614
[parent_id]: 4385521
[tags]: 
For single-dimension arrays you can do something like this: struct TEST { ... int size; char string[]; } where the size field indicates how many characters there are in the string array. The array has to be the last member of the struct, and you have to allocate the struct's memory dynamically. The allocated size should be sizeof(struct TEST) + size * sizeof(char) in this case. You cannot have more than one variable size array in the struct. Multi-dimension variable-size arrays are trickier. It cannot be done unless only one dimension size is unknown, specifically that of the first dimension. struct TEST { ... int size; char string[][100]; } EDIT: As other posters mentioned, you can have pointers to one or more arrays, at the cost of having to manage their memory areas separately from the struct. EDIT 2: This is part of at least the ISO C99 standard. Shamelessly copying from paragraph 6.7.2.1, sub-paragraph 16: 16 As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. With two exceptions, the flexible array member is ignored. First, the size of the structure shall be equal to the offset of the last element of an otherwise identical structure that replaces the flexible array member with an array of unspecified length.106)...
