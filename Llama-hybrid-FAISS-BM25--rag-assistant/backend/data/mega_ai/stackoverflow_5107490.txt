[site]: stackoverflow
[post_id]: 5107490
[parent_id]: 5101986
[tags]: 
As emgu website state there are primarly two strategies: The safe (slow) way Suppose you are working on an Image . You can obtain the pixel on the y-th row and x-th column by calling Bgr color = img[y, x]; Setting the pixel on the y-th row and x-th column is also simple img[y,x] = color; The fast way The Image pixels values are stored in the Data property, a 3D array. Ok so this is true but does not tell how to do it in a real scenario. So let's see some working code and then discuss performance and optimization: Image original = newImage (1024, 768); Stopwatch evaluator = newStopwatch(); int repetitions = 20; Bgr color = newBgr(100, 40, 243); evaluator.Start(); for (int run = 0; run So this is the average running time that you have after 20 runs using the safe slow way of setting image pixel On my machine it takes 1021ms ... So 1021 milliseconds as average time for looping and setting a number of pixels equal to 1024*768. We could have done a little bit better by looping on row by row So let's refactor a little bit our code and let's use the faster way using directly Image.Data property: evaluator.Reset(); evaluator.Start(); for (int run = 0; run On my machine it takes 519ms . So we have gained a performance boost of 50%. The execution time has been decreased by a factor of two. So looking carefully at the code keeping in mind that we are using C#, we can do a minor change that will drastically boost again our image pixel setting performance... we should not use c# property inside a loop!!! evaluator.Reset(); evaluator.Start(); byte[,,] data = original.Data; for (int run = repetitions - 1; run >= 0; run--) { for (int i = original.Rows - 1; i >= 0; i--) { for (int j = original.Cols - 1; j >= 0; j--) { data[i, j, 0] = 100; data[i, j, 1] = 40; data[i, j, 2] = 243; } } } evaluator.Stop(); With this latest piece of code you will have a huge performance boost (73ms) due to correct use of C# language.
