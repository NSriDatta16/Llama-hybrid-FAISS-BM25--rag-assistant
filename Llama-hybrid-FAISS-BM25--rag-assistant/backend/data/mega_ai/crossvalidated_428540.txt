[site]: crossvalidated
[post_id]: 428540
[parent_id]: 273132
[tags]: 
Let's begin by restating the problem more simply. At the end of one draw you have observed a quantity $X$ in the set $\{0,1,5,10\}.$ You have provided enough information to obtain their chances: The quantity $0$ is observed when $A$ is not drawn, which has chance $p(0)=19/20.$ The quantity $1$ is observed when $A$ is drawn and (independently of that) the value $1$ is pulled out of the second bag with probability $1/10.$ Thus, the chance of a $1$ is $p(1) = 1/20 \times 1/10.$ Similarly, $p(5)=1/20\times 4/10$ and $p(10)=1/20\times 5/10.$ After $n=0, 1, 2,\ldots $ draws where quantities $X_1, X_2, \ldots, X_n$ have been independently observed, you will have accumulated the sum of your observations, $S_n = X_1+X_2+\cdots+X_n.$ The number of draws $N$ needed for that sum to equal or exceed the target $T=20$ is a random variable. What is its expected value? More generally, given a probability distribution $p$ for the integral values $0,1,\ldots,M;$ a sequence of independent random variables $(X_i)$ that follow that distribution; and a target $T,$ we may define $N$ to be the first $n$ for which $S_n\ge T$ and ask for the expected value of $N$ , $E[N].$ This problem can be solved recursively by defining the sequence $(f_k)$ of expected numbers of draws needed to reach or exceed $T$ beginning with the values $T-k.$ Obviously when $k\le 0,$ $f_k=0$ because the target $T$ has already been reached. For positive $k$ consider what can happen on the next draw. Its value can be any integer between $0$ and $M$ inclusive, taking value $i$ with probability $p(i).$ At this point one more draw has been made, increasing the current value from $T-k$ to $T-k+i.$ Thus $$f_k = 1 + p(0) f_k + \sum_{i=1}^M p(i) f_{k-i},$$ allowing $f_k$ to be expressed in terms of the $M$ preceding values in terms of constants $\alpha$ and $\beta_1, \beta_2, \ldots, \beta_M$ as $$f_k = \frac{1}{1-p(0)} + \sum_{i=1}^M \frac{p(i)}{1-p(0)} f_{k-i} = \alpha + \sum_{i=1}^M \beta_i f_{k-i}.$$ By applying this recursion $T$ times for $k=1, 2, \ldots, T,$ we may compute the answer $f_{T}.$ To see how simple and fast this can be, here is a working R solution. Its input is the vector p = $p(0), p(1), \ldots, p(M)$ of probabilities and the target value. It initializes an array x to hold the values $f(1-M), f(2-M), \ldots, f(0), f(1), f(2), \ldots, f(T),$ and then applies the recursion to compute $f(1)$ through $f(T)$ : # Initialize the array of expected values. m For the data in the question the output is a row of values of $k$ above a row of values of $f_k:$ -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 22.0 22.2 22.2 22.2 30.2 31.8 32.1 32.1 32.1 45.3 48.3 48.8 48.8 48.8 58.1 61.0 61.6 61.7 61.8 The last element of x , $61.7560991680985,$ is the computed expectation $f_{20}.$ For larger targets there's a faster way. These recursions have formulas of the form $$f_k = \phi_0(k-k_0)^s + \sum_{i=1}^M \phi_i \lambda_i^{k-k_0}$$ where $s$ is an integer between $0$ and $M-1$ (equal to $1$ in this application), $k_0$ is an offset just to get the indexing correct, and the $\lambda_i$ and $\phi_i$ are suitable numbers (which may be, and often are, complex). The $\lambda_i$ are roots of a polynomial determined by the recursion coefficients and the $\phi_i$ are determined by the starting values of the sequence. For instance, $f_{10^{30}},$ which would be impossible to compute via the recursion, is equal to $2.8169014084507 \times 10^{30}$ (in double precision). One principal advantage of obtaining such a formula is to obtain a good understanding of how $f_k$ behaves as $k$ grows. One of the $\lambda$ will equal $1$ (let this be $\lambda_1$ and all the others will be smaller than that in size. For large $k,$ this yields the approximation $$f_k \approx \phi_0(k-k_0)^s + \phi_1.$$ That is, for large targets, each step takes you $E[X]$ closer to the target on average, which is an intuitively obvious result. For smallish targets like $T=20$ this isn't too far off: $20\times 200/71 = 56.33803$ is a little smaller than the correct value, but it's within 90% of it. Indeed, in the present case $k_0=-10,$ $s=1,$ $$\phi_0 = \frac{1}{\sum_{i=1}^M i p(i)} = \frac{1}{1/200 + 4/200\times 5 + 5/200\times 10} = \frac{200}{71} \approx 2.8169014084507$$ is the reciprocal of the expectation of $X,$ and $\phi_1 = -17.655227.$ Code The following R code implements three solution methods: solution of the recurrence equation, direct recursion, and simulation. The recurrence solution is coded more generally than needed: it should work for any linear recurrence, no matter how it arises. # # Solve linear recurrences of the form # f(k) = a + (f(k-1), f(k-2), ..., f(k-p)) * (b(1), b(2), ..., b(p)) # with starting values f(offset+1), f(offset+2), ..., f(offset+p). # lrsolve $coefficients[1]) + f$ gamma * f $offset, b=f$ gamma, lwd=2) # # Solve via direct recursion (for smallish target values). # m $f(target)) repeat { x =nmax) nmax = nmax) { maxcount = nmax) warning("Mean may be underestimated; max reached ", maxcount, " time", ifelse(maxcount==1, "", "s"), ".") } # hist(x) se f(target))/se))
