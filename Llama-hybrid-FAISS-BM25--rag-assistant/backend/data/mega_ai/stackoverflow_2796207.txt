[site]: stackoverflow
[post_id]: 2796207
[parent_id]: 2791833
[tags]: 
Although Robert P 's answer might work for you, it has the problem of fixing the dispatch very early in the process. I tend to resolve the methods as late as I can, so I would leave the things in the tests array as method names until you want to use them: $self->{tests} = [ qw( _sub1 _sub2 ) ]; The strength of a dynamic language is that you can wait as long as you like to decide what's going to happen. When you want to run them, you can go through the same process that Robert already noted. I'd add an interface to it though: foreach my $method_name ( $obj->get_test_methods ) { $obj->$method_name(); } That might even be better as not tying the test to an existing method name: foreach my $method_name ( $obj->get_test_methods ) { $obj->run_test_named( $method_name ); } That run_test_named could then be your dispatcher, and it can be very flexible: sub run_test_named { my( $self, $name ) = @_; # do anything you want, like in Robert's answer } Some things you might want to do: Run a method on an object Pass the object as an argument to something else Temporarily override a test Do nothing etc, etc When you separate what you decide to do from its implementation, you have a lot more freedom. Not only that, the next time you call the same test name, you can do something different.
