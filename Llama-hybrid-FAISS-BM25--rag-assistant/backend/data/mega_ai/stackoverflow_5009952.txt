[site]: stackoverflow
[post_id]: 5009952
[parent_id]: 
[tags]: 
How to delete an member variable consisting of an array of pointers

Good afternoon, I am trying to delete a C++ class member variable consisting of an array of pointers. Here is an excerpt of the code: class NFA { public: dict *, dict *> *> *> *transitions; auto_vector *> *> > *tmpautovector; NFA() {} ~NFA() { delete this->tmpautovector NFA(tuple2 *start_state) { this->__class__ = cl_NFA; __init__(start_state); } void *add_transition(tuple2 *src, str *input, tuple2 *dest); } void *NFA::add_transition(tuple2 *src, str *input, tuple2 *dest) { dict *> *> *tmpdict; if ((!(this->transitions)->__contains__(src))) { tmpdict = new dict *> *>(); this->transitions->__setitem__(src, tmpdict); tmpautovector->push_back(tmpdict); } return NULL; } I am trying to use the auto_vector class to store an array of pointers. Here are some of the functions of the auto_vector class. The documentation for this class says that this is not a STL vector of auto_ptr's . The use of STL vectors to store auto_ptr's is strongly discouraged > I keep getting a segmentation fault when I access the auto_vector::operator member function > The GDB stack trace, shown below shows the segmentation fault. I am wondering whether it is possible to fix this segmentation fault or whether are better approaches to deleting member variables consisting of array of pointers. Thank you. // auto_vector.h // This file is (C) 2002-2004 Royce Mitchell III // and released under the LGPL & BSD licenses #ifndef AUTO_VECTOR_H #define AUTO_VECTOR_H #include #include template class auto_vector { public: explicit auto_vector ( size_t capacity = 0 ) : _arr(0), _capacity(0), _end(0) { if ( capacity != 0 ) _arr = new std::auto_ptr [capacity]; _capacity = capacity; } ~auto_vector() { delete []_arr; } size_t size() const { return _end; } const std::auto_ptr & operator [] ( size_t i ) { return _arr[i]; } std::auto_ptr & operator [] ( size_t i ) { return _arr[i]; } void push_back ( std::auto_ptr & p ) { reserve ( _end + 1 ); _arr[_end++] = p; } void push_back ( T * p ) { reserve ( _end + 1 ); std::auto_ptr tmp(p); _arr[_end++] = tmp; //GCC is pedantic, this is an error. //_arr[_end++] = auto_ptr (p); } void reserve ( size_t reqCapacity ) { if ( reqCapacity newCapacity ) newCapacity = reqCapacity; // allocate new array std::auto_ptr * arrNew = new std::auto_ptr [newCapacity]; // transfer all entries for ( size_t i = 0; i *_arr; size_t _capacity; size_t _end; }; #endif//AUTO_VECTOR_H Program received signal SIGSEGV, Segmentation fault. 0x0806b85a in std::auto_ptr *> >::get (this=0x0) at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:300 300 get() const throw() { return _M_ptr; } (gdb) bt #0 0x0806b85a in std::auto_ptr *> >::get (this=0x0) at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:300 #1 0x0806be61 in __shedskin__::set *>::lookup (this=0x80a3c58, key=0x80a3c40, hash=-1919631394) at ../Include/builtin.hpp:3223 #2 0x0806bfc7 in __shedskin__::set *>::insert_key (this=0x80a3c58, key=0x80a3c40, hash=-1919631394) at ../Include/builtin.hpp:3258 #3 0x080728ea in __shedskin__::set *>::add (this=0x80a3c58, key=0x80a3c40) at ../Include/builtin.hpp:3278 #4 0x0806af0c in main (Argc_= , Argv_= ) at ../Source/mdMatchupTest.cpp:93 (gdb) frame 1 #1 0x0806be61 in __shedskin__::set *>::lookup (this=0x80a3c58, key=0x80a3c40, hash=-1919631394) at ../Include/builtin.hpp:3223 3223 setentry * entry = table->operator[](i)->get(); // &table[i]
