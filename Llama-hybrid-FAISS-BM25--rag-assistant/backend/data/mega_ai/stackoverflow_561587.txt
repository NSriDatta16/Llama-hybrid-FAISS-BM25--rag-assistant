[site]: stackoverflow
[post_id]: 561587
[parent_id]: 561227
[tags]: 
I thought I was onto something - sizeof() will work for structs, but only in unsafe blocks. So I tried: // compile with /unsafe public unsafe void Foo (T val) where T : struct { // Works! int size1 = sizeof(SomeStruct); // Doesn't work, alas int size2 = sizeof(T); } It seems sizeof has an issue with generic type parameters. So no go. As I commented in norheim.se's answer, you should be aware that Marshal.SizeOf() won't necessarily give you the size of your type in the runtime, so I wouldn't recommend it. Risking ridicule for unelegance, I would honestly consider a simple switch statement. If your value types will be stock int s, long s, byte s etc, there's a manageable number of possibilities. And you should keep in mind that setting a bit pattern might be a different task depending on whether the type is signed or not! Switching will make it easy to deal with suchlike.
