[site]: stackoverflow
[post_id]: 3711342
[parent_id]: 3707746
[tags]: 
The concepts you mention (event-driven, non-blocking, async, callbacks) aren't specific to JavaScript and understanding them in a more general context is valuable. They all revolve around gracefully handling resources over which we have no control. Imagine waiting for data from a TCP connection, waiting for the OS to delete a file, or waiting for a user to click a button. If you programmed this in a step-by-step fashion (step-by-step is synchronous ), you'd cruise along - "do step 1", "do step 2", "do step 3" - until you hit the step "wait for something to happen". At that point, your program would stop and refuse to budge until it received the data, received delete confirmation, or received the button click. In other words, the call blocks the program from proceeding. This is pretty inefficient considering there are likely other TCP connections, file operations, and UI actions that need our attention and don't depend on the item we're waiting for. In many cases, it would be better to indicate we're interested in a resource and receive notifications outside of step-by-step instructions when the resource changes. From your list of concepts: Events are changes in the resources we're interested in - our TCP connection received some data, the file delete is complete, or a user clicked a button. Asynchronous calls tell the OS or runtime that we're interested in doing something with a resource. They are non-blocking - our program can work on something else while it waits for a change in the resource. Callbacks are functions to be executed when the resource changes. An asynchronous resource call often accepts one or more references to callback functions (one for success, one for an error, etc...). When the resource changes, the runtime calls the appropriate callback. We can see these concepts illustrated by renaming a file with node.js: var fs = require('fs'); // args (current file name, new file name, callback function) fs.rename('/tmp/hello', '/tmp/world', function (err) { // this occurs when the rename is complete if (err) throw err; console.log('rename complete'); }); console.log('step after rename'); The third argument may look strange. It's an unnamed ( anonymous ) function that will be called when the rename is complete. Note that since fs.rename is asynchronous, it's impossible to tell if we'll see the 'rename complete' or 'step after rename' message first. That's the downside to event-driven/asynchronous programming - if we have a complex set of interdependent tasks, we need to be extremely careful to insure dependent tasks complete before the tasks that depend on them. The fact that the order of async call completion can change can lead to very subtle bugs. See also: An event-driven programming tutorial Closures - more complicated manipulation of first-class functions Edit per donald's request: The best way to understand node.js is to download, build, install, and use it. You'll need: Mac OS or Linux. If your comfortable with Cygwin, that may also be an option but if you're running Windows I find it easier to run Linux in a virtual machine. Git - not required but it makes fetching the code repository easy. A way to debug your application. See this question . Initially, writing debug info to the console may work. Eventually, you'll want robust debugging. An idea - what is it you want to do with node.js? If you're interested in an overview of its capabilities, browse its API . Most tutorials focus on node.js's ability to quickly build an Http server: Going evented with Node.js (shows a simple version of downloading the repository, building, and installing) A game lobby An Http server with Html templating Keep in mind that node.js fills a very particular niche - it's designed to build network programs. It may not be the right tool for other types of programs.
