[site]: stackoverflow
[post_id]: 2789036
[parent_id]: 2526051
[tags]: 
My solution was to use a custom UIGestureRecognizer for tracking the touch events, and a separate view for drawing the dragging operation. This works because UIGestureRecognizer doesn't block the responder chain. From the UIGestureRecognizer documentation: UIGestureRecognizer objects are not in the responder chain, yet observe touches hit-tested to their view and their view's subviews. Create a custom UIViewController (DragAndDropViewController) and add its view to the parent view of the views you want the drag & drop operation to occur in. Use your custom gesture recognizer class to forward the touch information to your DragAndDropViewController. The source tells your DragAndDropViewController where the the drag originates from (and any custom info). The controller should also have a delegate reference to the drop destination. When the drop occurs, send the delegate the UITouch event (not recommended according to Apple, but the UITouch object is needed to get the correct location in the destination view). This is what my DragAndDropViewController looks like: @protocol DragAndDropDestination (void)droppedItem:(NSDictionary *)item withTouch:(UITouch *)touch; @end @interface DragAndDropViewController : UIViewController { id _dropDestination; NSDictionary *_draggedItem; UIImageView *_icon; } @property (nonatomic, assign) id dropDestination; @property (nonatomic, retain) NSDictionary *draggedItem; // Source sends this message - (void)startDraggingWithItem:(NSDictionary *)item; @end Once the destination gets the message, you can use - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event to get the exact view at the drop destination. Also make sure you disable cancelsTouchesInView in the gesture recognizer if you want other UI operations to happen normally in your table views.
