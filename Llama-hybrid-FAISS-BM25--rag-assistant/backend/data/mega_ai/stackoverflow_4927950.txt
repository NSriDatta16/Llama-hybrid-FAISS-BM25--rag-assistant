[site]: stackoverflow
[post_id]: 4927950
[parent_id]: 4918147
[tags]: 
I don't know for certain if this is the problem, but I can see a logic flow that isn't going to work very well... First: 400-SALESMAN-NAME reads salesmen records from a file into working storage table SALESMAN-TABLE . The file probably looks something like: 01Sales Guy One 02Lance Winslow 03Scott Peterson 04Willy Loman When the read loop is done, SALESMAN-NUMBER will equal the table index because of the way you load the table (using SM-NUMBER-IN to set the table subscript). No problem so far... Next: 500-PROCESS-FILE loops through all rows in the SALESMAN-TABLE by running subscript ROUTINE-CHECK from 1 to 99 and performing 510-TABLE-SEARCH to write out the report for the salesman where the subscript equals SALESMAN-NUMBER ... Next: The SEARCH statement. This is where it all goes strange and never performs 520-WRITE-FILE . This is why. The SEARCH statement implements a linear search ( SEARCH ALL is a binary search). SEARCH just increments the index associated with the searched table and then runs through a bunch of WHEN tests until one of them "fires" or the index runs off the end of the table. The index for your TABLE-ENTRIES table is IND-TABLE-ENTRIES . But you never set or reference it (this is the root of the problem). I will explain in a moment... Notice that the WHEN part of your SEARCH is using subscript ROUTINE-CHECK . ROUTINE-CHECK was set in 500-PROCESS-FILE . Also notice that you only get to 520-WRITE-FILE if the SALESMAN-NUMBER matches the value of ROUTINE-CHECK - which it will do if a salesman with that number was read from the input file. This could work because you loaded the table such that the row number equals the salesman number back in 450-TABLE-LOAD . Now, what happens if the input file does not contain a salesman where SM-NUMBER-IN equals 01? Lets go through it, blow by blow... ROUTINE-CHECK is set to 1, SEARCH is invoked and because the IND-TABLE-ENTRIES index associated with the searched table is less than the number of occurs in the table (it got initialized to zero on program load), the WHEN clauses are executed. The first test is WHEN SALESMAN-NUMBER (ROUTINE-CHECK) = ROUTINE-CHECK . Since Salesman 1 doesn't exist, the SALESMAN-NUMBER will be zero and the test fails (0<>1). The next WHEN clause is tried and it succeeds because (0=0); but this is a 'do nothing' option so another cycle of SEARCH is entered after IND-TABLE-ENTRIES is incremented . Same results on this and all subsequent iterations through the SEARCH ed WHEN list (none of the clauses match)... Repeat this loop until IND-TABLE-ENTRIES is incremented beyond the end of the table. At this point the SEARCH terminates and control flows back to the next loop in 500-PROCESS-FILE . Nothing has been printed. 500-PROCESS-FILE then increments ROUTINE-CHECK by 1 (now it is 2). We have a salesman with a SALESMAN-NUMBER of 02 so we should get some output - right? Wrong! But why? If you read up on the SEARCH verb you will find it does not reset the table index (in this case: IND-TABLE-ENTRIES ). It starts using whatever value it has when the SEARCH is entered. You never reset it so it is already set beyond the end of the table. SEARCH just terminates and nothing gets printed - ever again. Fixing the problem Given that you have loaded TABLE-ENTRIES by salesman number in the first place, I don't see the purpose of using SEARCH. Just do something like: 500-PROCESS-FILE. PERFORM VARYING ROUTINE-CHECK FROM 1 BY 1 UNTIL ROUTINE-CHECK > 99 IF SALESMAN-NUMBER (ROUTINE-CHECK) = ZERO CONTINUE ELSE PERFORM 520-WRITE-FILE END-IF END-PERFORM. Might also be a good idea to have an initialization loop for the table so that every SALESMAN-NUMBER is explicitly set to zero before you read the salesman file. If you must use SEARCH in this program, then don't forget to set and use the associated table index variable when referencing the table being searched.
