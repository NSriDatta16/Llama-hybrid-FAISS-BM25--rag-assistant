[site]: stackoverflow
[post_id]: 4382625
[parent_id]: 4370464
[tags]: 
I got it to work under Visual studio 2008. Below are the details: interface.h #ifndef INTERFACE_H #define INTERFACE_H #if defined( WIN32 ) || defined ( WIN64 ) #ifdef DLL_EXPORTS #define DECLSPECIFIER __declspec( dllexport ) #define EXPIMP_TEMPLATE #else // DLL_EXPORTS #define DECLSPECIFIER __declspec( dllimport ) #define EXPIMP_TEMPLATE extern #endif // DLL_EXPORTS #else // defined( WIN32 ) || defined ( WIN64 ) #define DECLSPECIFIER #define EXPIMP_TEMPLATE #endif // defined( WIN32 ) || defined ( WIN64 ) // This class is exported from the dll. template class DECLSPECIFIER InterfaceClass { public: static InterfaceClass* factoryMethod( ); virtual ~InterfaceClass( ) { } virtual void someMethod( ) { } protected: InterfaceClass( ) { } private: InterfaceClass( const InterfaceClass& ); InterfaceClass& operator=( const InterfaceClass& ); }; #if defined( WIN32 ) || defined ( WIN64 ) #pragma warning( push ) #pragma warning( disable: 4231 ) // "nonstandard extension used : 'extern' // ok per [link text][1] #endif #include EXPIMP_TEMPLATE template class DECLSPECIFIER InterfaceClass >; EXPIMP_TEMPLATE template class DECLSPECIFIER InterfaceClass >; EXPIMP_TEMPLATE template class DECLSPECIFIER InterfaceClass >; EXPIMP_TEMPLATE template class DECLSPECIFIER InterfaceClass >; EXPIMP_TEMPLATE template class DECLSPECIFIER InterfaceClass >; EXPIMP_TEMPLATE template class DECLSPECIFIER InterfaceClass >; EXPIMP_TEMPLATE template class DECLSPECIFIER InterfaceClass >; EXPIMP_TEMPLATE template class DECLSPECIFIER InterfaceClass >; #if defined( WIN32 ) || defined ( WIN64 ) #pragma warning( pop ) #endif #endif derived.h #ifndef DERIVED_H #define DERIVED_H #include #include "interface.h" template class DerivedClass : public InterfaceClass { public: DerivedClass( ) { std::cout interface.cpp #include "interface.h" #include "derived.h" template DECLSPECIFIER InterfaceClass * InterfaceClass ::factoryMethod( ) { return new DerivedClass ( ); } client.cpp #include #include "interface.h" typedef InterfaceClass > IntVectorType; int main(int argc, char* argv[]) { IntVectorType* ptrTest = NULL; try { ptrTest = IntVectorType::factoryMethod( ); } catch ( std::bad_alloc& ) { return 1; } ptrTest->someMethod( ); delete ptrTest; return 0; } This may be non-standard but it is very useful.
