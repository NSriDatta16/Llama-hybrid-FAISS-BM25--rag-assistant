[site]: stackoverflow
[post_id]: 3528736
[parent_id]: 3528715
[tags]: 
Because 'A' is not a pointer, it's a char , 65 or 41 16 if the underlying character set is ASCII. "Stack" , on the other hand, is string, basically the character array {'S', 't', 'a', 'c', 'k', '\0'} , which degrades to a pointer to its first character. Your "difference between static_cast and () " has been answered here , far better than I could. The reason why you get rubbish with a char var = 'x'; cout is because &var is a char * which means it's being treated as a string - in that case, cout outputs characters up to the final nul character \0 which isn't there, or is there beyond the character. The following code shows this: #include int main() { //int q1 = 0; char xx = 'x'; //int q2 = 0; std::cout outputting: x~√ç" When you uncomment the q lines, it works, because it's putting zeros around the character, outputting x on its own). Keep in mind this is not kosher C, it's only working because of the way my stack is organised. Don't use this is real code.
