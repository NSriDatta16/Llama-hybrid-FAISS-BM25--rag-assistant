[site]: crossvalidated
[post_id]: 531632
[parent_id]: 
[tags]: 
Is my Stan model correct? The Jeffreys prior for a heteroscedastic mixed-effects model

I am using rstan to obtain MCMC samples from a heteroscedastic mixed-effects model with different residual variances $\sigma_j^2$ for each experimental condition $j$ . One assumption is the Jeffreys prior for the grand mean and the residual variances, $\pi(\mu,\sigma_1^2,\dotsb,\sigma_C^2)\varpropto\prod_{j=1}^{C}\sigma_j^{-2}$ , where $C$ is the number of conditions. Could you help me check if my rstan model file is correct (perhaps not) ? Thanks. Reference: https://osf.io/mrud9/ data { int N; // number of subjects int C; // number of conditions vector[C] Y[N]; // responses real tcrit; // critical value real ht; // (square root of) scale parameter of the standardized treatment effects real hb; // (square root of) scale parameter of the standardized subject-specific random effects } parameters { real mu; // grand mean vector [C] sigma_squared; // error variances real gt; // variance of the standardized treatment effects real gb; // variance of the standardized subject-specific random effects vector[C] t; // treatment effects vector[N] b; // subject-specific random effects } transformed parameters { vector [C] sigma; // error sd real va; // average error variance vector [C] eta; // sd of the treatment effects real tau; // sd of the subject-specific random effects sigma = sqrt(sigma_squared); va = sum(sigma_squared) / C; eta = sigma * sqrt(gt); tau = sqrt(va * gb); } model { // linear mixed-effects model for (i in 1:N) { Y[i] ~ normal(mu + t + b[i], sigma); } t ~ normal(0, eta); b ~ normal(0, tau); // priors // mu ~ implicit uniform prior // Jeffreys prior target += -2 * sum(log(sigma)); // Jeffreys prior gt ~ scaled_inv_chi_square(1, ht); gb ~ scaled_inv_chi_square(1, hb); // Rouder et al. (2012) } // compute HDI boundaries based on Nathoo, Kilshaw, & Masson (2018) and Heck (2019) generated quantities { vector [C] se; matrix[C,2] hdi_se; vector[C] mu_t; // condition means se = sigma / sqrt(N); mu_t = mu + t; hdi_se[,1] = mu_t - tcrit * se; // lower bound hdi_se[,2] = mu_t + tcrit * se; // upper bound } So far, it is syntactically correct. Edit: I have changed target += -2 * (log(prod(sigma)); into target += -2 * sum(log(sigma)); according to the comment below. However, I still wonder this target += is correct or not.
