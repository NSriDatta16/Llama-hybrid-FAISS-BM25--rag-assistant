[site]: stackoverflow
[post_id]: 3147233
[parent_id]: 3147156
[tags]: 
See this answer to the question When should static_cast , dynamic_cast and reinterpret_cast be used? on the meaning of each kind of casts. what's Objective-C missing that it doesn't seem to have (or need?) this many casting types? C++ focuses a lot more in type safety than C. The many cast operators are added to make the many different casting intentions clear (and to discourage people from using it due to its ugly form). And, There is no const objects ( const NSObject* ) in Objective-C, and other const parameters aren't so emphasized unlike in C++, so const_cast is useless. Objective-C instances always use dynamic typing, so dynamic_cast is not needed. (Type checking in ObjC is usually done with -isKindOfClass: .) static_cast and reinterpret_cast are the same in C, but not so in C++. Because C++ supports multiple inheritance (missing in ObjC), a pointer casting is not as simple as a no-op: #include struct A { int x; A() : x(12) {} }; struct B { int y; B() : y(33) {} int get() const { return y; } }; struct C : A, B { int z; C() : A(), B(), z(41) {} }; int main () { C* c = new C; printf("%d\n", c->get()); // 33 printf("%d\n", static_cast (c)->get()); // 33 printf("%d\n", reinterpret_cast (c)->get()); // 12 }
