[site]: stackoverflow
[post_id]: 654355
[parent_id]: 653700
[tags]: 
For anyone interested, here is my final solution. It is for a .NET user control. It uses a single pattern with a match evaluator, as suggested by Tomalak, so there is no foreach loop. It's an elegant solution, and it gives me the correct output for the sample input while preserving correct casing for matched strings. public partial class Abbreviations : System.Web.UI.UserControl { private Dictionary dictionary = DataHelper.GetAbbreviations(); protected void Page_Load(object sender, EventArgs e) { string input = "This is just a little test of the memb. And another memb, but not amemba to see if it gets picked up. Deb of course should also be caught here.deb!"; var regex = "\\b(?:" + String.Join("|", dictionary.Keys.ToArray()) + ")\\b"; MatchEvaluator myEvaluator = new MatchEvaluator(GetExplanationMarkup); input = Regex.Replace(input, regex, myEvaluator, RegexOptions.IgnoreCase); litContent.Text = input; } private string GetExplanationMarkup(Match m) { return string.Format(" {1} ", dictionary[m.Value.ToLower()], m.Value); } } The output looks like this (below). Note that it only matches full words, and that the casing is preserved from the original string: This is just a little test of the memb . And another memb , but not amemba to see if it gets picked up. Deb of course should also be caught here. deb !
