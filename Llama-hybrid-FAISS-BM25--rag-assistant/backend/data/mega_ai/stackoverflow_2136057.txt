[site]: stackoverflow
[post_id]: 2136057
[parent_id]: 2131750
[tags]: 
The KVO flow for bindings isn't orthogonal; a binding isn't a property , it's a reference to a property. This is the shorthand to remember for how bindings work: KVO is used to communicate changes from model to controller & view. KVC is used to communicate changes from view to controller & model. Thus when a view with bindings handles events, it needs to propagate changes to the properties its bindings reference itself. Here's what your code might look like, with a utility method for doing the heavy lifting of propagating changes through bindings: - (void)magnifyWithEvent:(NSEvent *)event { if ([event magnification] > 0) { if ([self zoomValue] 0.1) { [self setZoomValue: [self zoomValue] + [event magnification]]; } else { [self setZoomValue: 0.1]; } } // Update whatever is bound to our zoom value. [self updateValue:[NSNumber numberWithFloat:[self zoomValue]] forBinding:@"zoomValue"]; } It's a little unfortunate that ImageKit requires the use of @"zoomValue" to reference the Zoom Value binding of an IKImageBrowserView, most bindings in AppKit have their own global string constant like NSContentBinding . And here's that generic utility method to propagate the change through the binding: - (void)updateValue:(id)value forBinding:(NSString *)binding { NSDictionary *bindingInfo = [self infoForBinding:binding]; if (bindingInfo) { NSObject *object = [bindingInfo objectForKey:NSObservedObjectKey]; NSString *keyPath = [bindingInfo objectForKey:NSObservedKeyPathKey]; NSDictionary *options = [bindingInfo objectForKey:NSOptionsKey]; // Use options to apply value transformer, placeholder, etc. to value id transformedValue = value; // exercise for the reader // Tell the model or controller object the new value [object setValue:transformedValue forKeyPath:keyPath]; } } Actually applying placeholders, value transformers, and the like is left as an exercise for the reader.
