[site]: stackoverflow
[post_id]: 3336859
[parent_id]: 
[tags]: 
Testing a c++ class for features

I have a set of classes that describe a set of logical boxes that can hold things and do things to them. I have struct IBox // all boxes do these { .... } struct IBoxCanDoX // the power to do X { void x(); } struct IBoxCanDoY // the power to do Y { void y(); } I wonder what is the 'best' or maybe its just 'favorite' idiom for a client of these classes to deal with these optional capabilities a) if(typeid(box) == typeid(IBoxCanDoX)) { IBoxCanDoX *ix = static_cast (box); ix->x(); } b) IBoxCanDoX *ix = dynamic_cast (box); if(ix) { ix->x(); } c) if(box->canDoX()) { IBoxCanDoX *ix = static_cast (box); ix->x(); } d) different class struct now struct IBox { void x(); void y(); } ... box->x(); /// ignored by implementations that dont do x e) same except box->x() // 'not implemented' exception thrown f) explicit test function if(box->canDoX()) { box->x(); } I am sure there are others too. EDIT: Just to make the use case clearer I am exposing this stuff to end users via interactive ui. They can type 'make box do X'. I need to know if box can do x. Or I need to disable the 'make current box do X' command EDIT2: Thx to all answerers as Noah Roberts pointed out (a) doesnt work (explains some of my issues !). I ended up doing (b) and a slight variant template T* GetCurrentBox() { if (!current_box) throw "current box not set"; T* ret = dynamic_cast (current_box); if(!ret) throw "current box doesnt support requested operation"; return ret; } ... IBoxCanDoX *ix = GetCurrentBox (); ix->x(); and let the UI plumbing deal nicely with the exceptions (I am not really throwing naked strings). I also intend to explore Visitor
