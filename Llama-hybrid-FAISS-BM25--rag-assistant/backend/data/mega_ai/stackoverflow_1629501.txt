[site]: stackoverflow
[post_id]: 1629501
[parent_id]: 
[tags]: 
Using the same service & DAO from two threads

I've made a very simple REST controller method with Spring 3.0.0.RC1 that uses hibernate to perform a query. The query takes about ten seconds to complete. I've made this with intent so that I can fire up two requests to my controller. Then I fire up the two requests, and query in MySQL (my DB backend) "show full processlist", and to my big surprise, there is only one request going on. One request will succeed, one request will fail with with the exception "org.hibernate.SessionException: Session is closed!" If I do more than two requests, only one will succeed, the others will fail in the same way. And there will always be just one query at a time, even though there should be multiple. How can this be? Any suggestions? To tell you a bit about my configuration, here is configuration that I use for the controller: tld.mydomain.sample.entities.User tld.mydomain.sample.entities.Role org.hibernate.dialect.MySQLDialect false PROPAGATION_REQUIRED PROPAGATION_REQUIRED PROPAGATION_REQUIRED PROPAGATION_SUPPORTS,readOnly and finally my controller code: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.view.json.JsonView; import tld.mydomain.sample.business.UserService; @Controller @RequestMapping("/exp/*") public class ExperimentsController { @Autowired private UserService userService; @Autowired private JsonView jsonView; @RequestMapping(value="/long", method = RequestMethod.GET) public ModelAndView lang() { ModelAndView mav = new ModelAndView(jsonView); userService.longQuery("UserA"); userService.longQuery("UserB"); return mav; } } UPDATE: Here is UserServiceImpl public class UserServiceImpl extends AbstractCRUDServiceImpl { @SuppressWarnings("unchecked") @Override public List longQuery(String username) { String like = "0" + username + "-%"; return DAO.getSession().createCriteria(User.class).setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY).addOrder(Order.asc("name")) .createCriteria("interests").add(Restrictions.like("userPrefixedId", like)) .createCriteria("community").add(Restrictions.like("userPrefixedAuthorId", like)) .createCriteria("member").add(Restrictions.like("userPrefixedGroupId", like)) .add(Restrictions.isNotEmpty("skills")) .list(); } } (The query is intentionally made slow so that I could easily reproduce the error for having multiple requests running at the same time and seeing how many simultaneous queries were running in the database) And you'll need my AbstractCRUDServiceImpl and GenericCRUDDAO as well: public abstract class AbstractCRUDServiceImpl implements CRUDService { protected GenericCRUDDAO DAO = new GenericCRUDDAO (dataType()); @Override public void create(Entity entity) { DAO.create(entity); } @Override public void delete(Entity entity) { DAO.create(entity); } @Override public Entity read(PkID entityPk) { return DAO.read(entityPk); } @Override public void update(Entity entity) { DAO.update(entity); } private Class pkType = null; @SuppressWarnings("unchecked") public Class pkType() { if(pkType != null) return pkType; // Backup solution in case datatype hasn't been set Type type = getClass().getGenericSuperclass(); if (type instanceof ParameterizedType) { ParameterizedType paramType = (ParameterizedType) type; pkType = (Class ) paramType.getActualTypeArguments()[1]; } else if (type instanceof Class) { pkType = (Class ) type; } return pkType; } private Class dataType = null; @SuppressWarnings("unchecked") private Class dataType() { if(dataType != null) return dataType; // Backup solution in case datatype hasn't been set Type type = getClass().getGenericSuperclass(); if (type instanceof ParameterizedType) { ParameterizedType paramType = (ParameterizedType) type; dataType = (Class ) paramType.getActualTypeArguments()[0]; } else if (type instanceof Class) { dataType = (Class ) type; } return dataType; } } In GenericCRUDDAO, PublishableEntity is where all my entities descend from. It has a few simple convenience-methods such as checking if the entity is valid and what parts of it should be published vs kept to itself when used in a toString or similar public class GenericCRUDDAO implements CRUDDAO { public GenericCRUDDAO() {} public GenericCRUDDAO(Class datatype) { this.setDataType(datatype); } private static SessionFactory sessionFactory = null; public void setSessionFactory(SessionFactory sf) { System.err.println("Setting SessionFactory for class " + this.getClass().getName()); sessionFactory = sf; } private Session session = null; public Session getSession() { if(session != null) { if(session.isOpen()) return session; } if(sessionFactory == null) Util.logError("sessionFactory is null"); session = ((SessionFactory) sessionFactory).getCurrentSession(); return session; } public void create(EntityType entity) { getSession().save(entity); } @SuppressWarnings("unchecked") public EntityType read(PkID id) { return (EntityType) getSession().get(dataType(), id); } public void update(EntityType entity) { getSession().update(entity); } public void delete(EntityType entity) { getSession().delete(entity); } public void delete(PkID id) { EntityType entity = read(id); getSession().delete(entity); } private Class dataType = null; @SuppressWarnings("unchecked") private Class dataType() { if(dataType != null) return dataType; // Backup solution in case datatype hasn't been set Type type = getClass().getGenericSuperclass(); if (type instanceof ParameterizedType) { ParameterizedType paramType = (ParameterizedType) type; dataType = (Class ) paramType.getActualTypeArguments()[0]; } else if (type instanceof Class) { dataType = (Class ) type; } return dataType; } public void setDataType(Class datatype) { this.dataType = datatype; } } I hope the configuration and code make it obvious why I only seem to be able to do one query at a time without them going into one-anothers feet. Cheers Nik
