[site]: stackoverflow
[post_id]: 5436963
[parent_id]: 5436730
[tags]: 
The distinction here is IPC mechanisms for signalling versus shared state. Signalling (signals, message queues, pipes, etc.) is appropriate for information that tends to be short, timely and directed. Events over these mechanisms tend to wake up or interrupt another program. The analogy would be, "what would one program SMS to another?" Hey, I added a new entry to the hash table! Hey, I finished that work you asked me to do! Hey, here's a picture of my cat. Isn't he cute? Hey, would you like to go out, tonight? There's this new place called the hard drive. Shared memory , compared with the above, is more effective for sharing relatively large, stable objects that change in small parts or are read repeatedly. Programs might consult shared memory from time to time or after receiving some other signal. Consider, what would a family of programs write on a (large) whiteboard in their home's kitchen? Our favorite recipes. Things we know. Our friends' phone numbers and other contact information. The latest manuscript of our family's illustrious history, organized by prison time served. With these examples, you might say that shared memory is closer to a file than to an IPC mechanism in the strictest sense, with the obvious exceptions that shared memory is Random access, whereas files are sequential. Volatile, whereas files tend to survive program crashes.
