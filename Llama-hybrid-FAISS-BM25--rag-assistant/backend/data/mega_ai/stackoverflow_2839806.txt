[site]: stackoverflow
[post_id]: 2839806
[parent_id]: 2839551
[tags]: 
Use of new and delete in C++ combines two responsibility - allocating/releasing dynamic memory, and initialising/releasing an object. As all the other answers say, the most common way to allocate and release dynamic memory is calling malloc and free . You also can use OS-specific functions to get a large chunk of memory and allocate your objects in that, but that is rarer - only if you have fairly specific requirements that malloc does not satisfy. In C, most APIs will provide a pair of functions which fulfil the other roles of new and delete . For example, the file api uses a pair of open and close functions: // C++ fstream* fp = new fstream("c:\\test.txt", "r"); delete fp; // C FILE *fp=fopen("c:\\test.txt", "r"); fclose(fp); It may be that fopen uses malloc to allocate the storage for the FILE struct, or it may statically allocate a table for the maximum number of file pointers on process start. The point is, the API doesn't require the client to use malloc and free . Other APIs provide functions which just perform the initialisation and releasing part of the contract - equivalent to the constructor and destructor, which allows the client code to use either automatic , static or dynamic storage. One example is the pthreads API: pthread_t thread; pthread_create( &thread, NULL, thread_function, (void*) param); This allows the client more flexibility, but increases the coupling between the library and the client - the client needs to know the size of the pthread_t type, whereas if the library handles both allocation and initialisation the client does not need to know the size of the type, so the implementation can vary without changing the client at all. Neither introduces as much coupling between the client and the implementation as C++ does. (It's often better to think of C++ as a template metaprogramming language with vtables than an OO language)
