[site]: stackoverflow
[post_id]: 4218676
[parent_id]: 4158486
[tags]: 
I am using isset() only for $_GET and $_SERVER variables, where the data comes from outside the control of my application. And I am using it in some other situation when I don't have time to write a proper OOP solution to avoid it, but I'm sure that it can be avoided in most if not all places. For example it's better to use classes instead of associative arrays, this way you don't need to check the existence of an array key. My advices are: Avoid using the @ operator . Use Xdebug . First, it prints easily readable and easily noticeable messages about every notice/warnig, and it prints a very useful stack trace on exceptions (you can configure it to print out every method parameter and every local variable ( xdebug.collect_params=4 and xdebug.show_local_vars=on configuration parameters). Second, it can disable the @ operator with xdebug.scream=1 config value. You can use Xdebug for profiling and for code coverage analysis as well. It's a must have on your development machine. For debugging, I am also using FirePHP , because it works with Firebug , and is able to print messages to the Firebug console , so it can be used for AJAX debugging as well. With a custom error handler , you can catch and filter any error and warning, and you can log them into a file or display them with FirePHP, or you can use for example jGrowl or Gritter to nicely display them on the web page. I am using a modified version of the example in the PHP manual : \n"; // filter out getImageSize() function with non existent files (because I'am avoiding using file_exists(), which is a costly operation) if ( mb_stripos($errstr, 'getimagesize') !== false ) return true; // filter out filesize() function with non existent files if ( mb_stripos($errstr, 'filesize') !== false ) return true; // consoleWriter is my class which sends the messages with FirePHP if (class_exists('consoleWriter')) consoleWriter::debug(array('errno'=>$errno, 'errstr'=>$errstr, 'errfile'=>$errfile, 'errline'=>$errline, 'trace'=>debug_backtrace()), "errorHandler"); switch ($errno) { case E_USER_ERROR: $out .= " FATAL_ERROR $errno $errstr \n"; $out .= "Fatal error on line $errline in file $errfile"; echo " $out"; // if we were in a script tag, then the print is not visible without this //writeErrorLog($out); echo " "; var_export(debug_backtrace()); echo " "; exit(1); break; case E_USER_WARNING: $out .= " WARNING $errno $errstr \n"; $out .= "On line $errline in file $errfile \n"; break; case E_USER_NOTICE: $out .= " NOTICE $errno $errstr \n"; $out .= "On line $errline in file $errfile \n"; break; default: $out .= " Unknown $errno $errstr \n"; $out .= "On line $errline in file $errfile \n"; break; } if (!class_exists('consoleWriter')) echo $out; //writeErrorLog($out); //addJGrowlMessage($out); // Don't execute PHP internal error handler return true; } function testNotice($a) { echo $a; } testNotice(); One more advice is not to use the closing ?> tag at the end of the php-only files, because it can cause headers already sent errors on configurations where the output buffering is disabled by default.
