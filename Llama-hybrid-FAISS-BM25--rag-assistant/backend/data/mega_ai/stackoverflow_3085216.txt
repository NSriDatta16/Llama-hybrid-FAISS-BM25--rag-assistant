[site]: stackoverflow
[post_id]: 3085216
[parent_id]: 3038351
[tags]: 
This is the answer I got from Silje Johansen - Support Engineer - Trolltech ASA (in March 2008 though) However. the complexity of including locale settings and finding a unified way to query the filesystems on Linux/Unix about their functionality is close to impossible. However, to my knowledge, all applications I know of ignore this problem. (read: they aren't going to implement it) Boost doesn't solve the problem either, they give only some vague notion of the maximum length of paths, especially if you want to be cross platform. As far as I know many have tried and failed to crack this problem (at least in theory, in practice it is most definitely possible to write a program that creates valid filenames in most cases . If you want to implement this yourself, it might be worth considering a few not immediately obvious things such as: Complications with invalid characters The difference between file system limitations and OS and software limitations. Windows Explorer, which I consider part of the Windows OS does not fully support NTFS for example. Files containing ':' and '?', etc... can happily reside on an ntfs partition, but Explorer just chokes on them. Other than that, you can play safe and use the recommendations from Boost Filesystem . Complications with path length The second problem not fully tackled by the boost page is length of the full path. Probably the only thing that is certain at this moment is that no OS/filesystem combination supports indefinite path lengths. However, statements like "Windows maximum paths are limited to 260 chars" are wrong. The unicode API from Windows does allow you to create paths up to 32,767 utf-16 characters long. I haven't checked, but I imagine Explorer choking equally devoted, which would make this feature utterly useless for software having any users other than yourself (on the other hand you might prefer not to have your software choke in chorus). There exists an old variable that goes by the name of PATH_MAX, which sounds promising, but the problem is that PATH_MAX simply isn't . To end with a constructive note, here are some ideas on possible ways to code a solution. Use defines to make OS specific sections. ( Qt can help you with this ) Use the advice given on the boost page and OS and filesystem documentation to decide on your illegal characters For path length the only workable idea that springs to my mind is a binary tree trial an error approach using the system call's error handling to check on a valid path length. This is quite aloof, but might be the only possibility of getting accurate results on a variety of systems. Get good at elegant error handling. Hope this has given some insights.
