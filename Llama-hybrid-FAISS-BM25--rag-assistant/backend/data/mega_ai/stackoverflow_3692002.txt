[site]: stackoverflow
[post_id]: 3692002
[parent_id]: 3674637
[tags]: 
So here's what I came up with after reading [Jérôme Radix][1]'s excellent reply. Especially the pointer to after-change-major-mode-hook has helped a lot. I now define my buffer-specific settings in a list like this: ;; no `highlight-beyond-fill-column' for w3m and gnus '((((:not ((:mode "^gnus") (:mode w3m-mode)))) (lambda () (highlight-beyond-fill-column))) ;; `flyspell-mode` and `auto-fill-mode` for text-ish buffers (((:mode message-mode) (:mode org-mode) (:mode pod-mode) (:mode markdown-mode) (:name "\\.\\(txt\\|mkn\\)$")) (lambda () (flyspell-mode) (auto-fill-mode))) ;; indenting with tabs for certain projects (((:name t :fun (lambda () (and (not eproject-root) (eproject-maybe-turn-on))))) (lambda () (setq indent-tabs-mode t))) When the major mode changes, I then iterate over all those settings, evaluate the defined conditions in the buffer, and call the appropriate lambda if a condition matches: (add-hook 'after-change-major-mode-hook (lambda () (rafl:apply-buffer-settings rafl:buffer-settings))) (defun rafl:apply-buffer-settings (settings) (dolist (setting rafl:buffer-settings) (let ((condition (car setting)) (action (cadr setting))) (when (rafl:evaluate-buffer-condition condition) (funcall action))))) Evaluating those conditions is a little messy, but works rather well for me. (defun rafl:evaluate-buffer-condition (con) (cond ((functionp con) (funcall con)) ((listp con) (cond ((listp (car con)) (reduce (lambda (a b) (or a b)) (cons nil (mapcar #'rafl:evaluate-buffer-condition con)))) (t (reduce (lambda (a b) (and a b)) (cons t (let (ret) (while con (let ((k (pop con)) (v (pop con))) (push (cond ((eq k :fun) (funcall v)) ((eq k :not) (when (not (listp v)) (error ":not requires a list")) (not (rafl:evaluate-buffer-condition v))) ((eq k :mode) (if (stringp v) (string-match-p v (symbol-name major-mode)) (eq v major-mode))) ((eq k :name) (cond ((and (buffer-file-name) (stringp v)) (string-match-p v (buffer-file-name))) ((buffer-file-name) v) (t (not v)))) (t (error "unknown cond"))) ret))) ret)))))) (t (error "invalid condition")))) It also turns out that I could do all my per-project setting, which I did quite differently before, using this mechanism. I'm very happy about that. 1: Enabling certain emacs modes or features *almost* always
