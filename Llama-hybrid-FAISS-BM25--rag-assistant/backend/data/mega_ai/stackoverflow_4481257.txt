[site]: stackoverflow
[post_id]: 4481257
[parent_id]: 4480994
[tags]: 
No, it is not tail recursive. Neither ANSI Common Lisp says anything about it nor your code: (defun collect (func args num) (if (= 0 num) () (cons (apply func args) (collect func args (- num 1))))) If you look at your code, there is a CONS around your call to COLLECT. This CONS receives the value of the recursive call to COLLECT. So COLLECT can't be tail recursive. It's relatively simple to rewrite your function to something that looks tail recursive by introducing an accumulator variable. The various Lisp or Scheme literature should describe that. In Common Lisp the default way to program an iterative computation is by using one of the several iterative constructs: DO, DOTIMES, DOLIST, LOOP, MAP, MAPCAR, ... The Common Lisp standard does not provide tail call optimization (TCO). It would have to be specified what TCO should do in the presence of several other language features. For example dynamic binding and special variables have an effect on TCO. But the Common Lisp standard says simply nothing about TCO in general and about possible effects of TCO. TCO is not a part of the ANSI Common Lisp standard. Several Common Lisp implementations have a way to enable various tail call optimizations with compiler switches. Note that both the way to enable those and the limitations are implementation specific. Summary : In Common Lisp use iteration constructs and not recursion. (defun collect (func args num) (loop repeat num collect (apply #'func args))) Added bonus: it is easier to read.
