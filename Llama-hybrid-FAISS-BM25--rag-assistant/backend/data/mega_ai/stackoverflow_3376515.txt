[site]: stackoverflow
[post_id]: 3376515
[parent_id]: 
[tags]: 
Extending Type Safety to prevent dirty data coming from being used against functions that require "clean" data

Can .NET or one of it's many languages enforce the cleaning of untrusted data... or prevent accidental variable use in the wrong locations? One example of this is when a user POST's data and the "raw" response is used within a SQL transaction. This could cause anything from a client-side scripting vulnerability to the entire server being compromised. Another example is where I have to pass the data to a COM object for further processing. What are my options as a C#, ASP.net, and SQL developer to make sure that my user's dirty bits don't touch anything internal before it's cleaned? Is there a feature of the runtime (or compiler) I could leverage? Short of having the language actually enforce it, perhaps I could just add a suffix of _dirty to my incoming variables. Is this something you would recommend as a best practice? How do the pros approach this problem? Update Here is the conceptual direction I was going This is somewhat inspired based on the answers given so far (specifically SteveCzetty and Erlend) For example: public Interface ICleanForJavascript { bool IsCleanForJavascript(); } public Interface ICleanForXSS { bool IsCleanForJavascript(); } public class DirtyData { string Name {get; set;} } public class CleanData { private CleanData() {} string Name {get; private set;} // Perhaps use casting to support the conversion from Dirty to Clean data // Might use this in an option explicit DirtyData CleanData(object o); command public static CleanData Validate(DirtyData d) { CleanData data = new CleanData(); if (ValidateString(d.Name)) { data.Name = d.Name } else { throw new ValidationException(); } return CleanData; } } [RequiresCleanedDataAttribute(ICleanForJavascript )] public void DoSomething(CleanData data) { //... } Attribute RequiresCleanedDataAttribute(object arrayOfCleanings[]) { // do some reflection on the method signature and see if the object supports the required interfaces } With the above, then: DoSomething(new DirtyData()); // Compiler Error, or runtime error if Attribute validation fails DoSomething(CleanData.Validate(new DirtyData())); // Compiles
