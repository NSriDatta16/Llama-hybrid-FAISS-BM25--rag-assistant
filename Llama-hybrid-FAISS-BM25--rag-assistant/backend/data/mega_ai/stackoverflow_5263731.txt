[site]: stackoverflow
[post_id]: 5263731
[parent_id]: 5261027
[tags]: 
If you want to keep all your objects in contiguous memory and, at the same time, avoid using an indirection (a vector of base class pointers), you can use a union-style container, e.g. a vector boost::variant . This will, of course, assume that there is a limited and known number of derived classes and that their sizes are comparable. The drawback is that each element of the vector will take as much memory as the biggest derived class, regardless of their actual class (and it also assumes your classes are reasonable cheap to copy). The advantages are that you have contiguous heterogeneous storage of the polymorphic objects, type-safety, and no indirection when accessing elements. Here is a basic example with boost::variant and three classes A , B , C , where both B and C inherit from A , and they are all polymorphic (and, of course, this could be much nicer with some sugar-coating and/or something more specialized for your purpose, not boost::variant which is not really appropriate for this purpose): #include #include #include #include struct A { int v1; A(int aV1 = 0) : v1(aV1) { }; virtual ~A() { }; virtual void print() { std::cout A& operator()(T& obj) const { return obj; }; }; }; struct B : A { float f1; B(float aF1 = 0.0) : A(42), f1(aF1) { }; ~B() { }; virtual void print() { std::cout value_type; typedef std::vector vect_type; vect_type arr(15); int i=0; for(;i
