[site]: stackoverflow
[post_id]: 746180
[parent_id]: 745925
[tags]: 
Did this even compile under a recent g++? I tried it on my MacBook Pro and: xxx.cpp: In function ‘AutoString func()’: xxx.cpp:52: error: no matching function for call to ‘AutoPtr ::AutoPtr(AutoString)’ xxx.cpp:12: note: candidates are: AutoPtr ::AutoPtr(AutoPtr &) [with T = char, bool isArray = true] xxx.cpp:9: note: AutoPtr ::AutoPtr(T*) [with T = char, bool isArray = true] xxx.cpp:52: error: initializing temporary from result of ‘AutoPtr ::AutoPtr(T*) [with T = char, bool isArray = true]’ The only way that I can get this to compile is by making the copy constructor take a const reference which is what I had suspected. It looks like Herb Sutter posted about something very similar to this in his most recent GotW. I wouldn't try to replicate the ownership transfer semantic of std::auto_ptr without a very good reason. You might want to look at the various goodies in Boost.SmartPtr . If possible, use them instead. If you can't Boost for whatever reason, then read your favorite std::auto_ptr implementation and pay particular attention to the std::auto_ptr_ref class. Once you understand why it is there and exactly how it does what it does, then go back and write an auto-ptr class. This class exists to get around the problem that you are seeing. IIRC, this is discussed in some detail in Josuttis': The Standard C++ Library . I think that is where I really understood it for the first time.
