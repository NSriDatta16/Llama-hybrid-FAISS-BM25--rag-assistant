[site]: stackoverflow
[post_id]: 2788306
[parent_id]: 2785724
[tags]: 
Just for completeness, here is a version that does the same thing directly using the fold function. This can be done quite elegantly, because methods of StringBuilder return the StringBuilder (which allows you to chain them in C#). This can be also used nicely for folding. Let's assume that we have the list of tuples from the solution by Mauricio: let properties = [ (oldUser.FirstName, newUser.FirstName, "first_name") (oldUser.LastName, newUser.LastName, "last_name") (oldUser.UserName, newUser.UserName, "username") ] Now you can write the following code (it also returns a flag whether anything has changed): let init = false, new StringBuilder() let anyChange, formatted = properties |> Seq.fold (fun (anyChange, sb) (oldVal, newVal, name) -> if (oldVal = newVal) anyChange, sb else true, sb.AppendFormat("{0} = '{1}'", name, newVal)) init The state kept during folding has type bool * StringBuilder and we start with an initial value containing empty string builder and false. In each step, we either return the original state (if value is the same as previous) or a new state containing true and a new version of the StringBuilder returned by AppendFormat . Using recursion explicitly would also work, but when you can use some built-in F# function, it is usually easier to use this approach. If you needed to process nested entities of each entity, you could use the Seq.collect function together with recursion to get a list of properties that you need to process using fold . Pseudo-code might look like this: let rec processEntities list names = // Pair matching entity with the name from the list of names List.zip list names |> List.collect (fun (entity, name) -> // Current element containing old value, new value and property name let current = (entity.OldValue, entity.NewValue, name) // Recursively proces nested entitites let nested = processEntities entity.Nested current::nested) This can be more elegantly written using sequence expressions: let rec processEntities list = seq { for entity, name in List.zip list names do yield (entity.OldValue, entity.NewValue, name) yield! processEntities entity.Nested } Then you could simply call processEntities which returns a flat list of entities and process the entities using fold as in the first case.
