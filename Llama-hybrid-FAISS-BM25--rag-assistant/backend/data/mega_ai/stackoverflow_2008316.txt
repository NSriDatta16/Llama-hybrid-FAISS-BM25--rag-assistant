[site]: stackoverflow
[post_id]: 2008316
[parent_id]: 2008131
[tags]: 
What you want to do is to try to distribute the hash values as evenly as possible over the range. Some of the built in hashing methods are fairly good at this, so you could perhaps try something like getting the hash code of the string representation, and simply throw away half of the bits: ushort code = (ushort)value.ToString().GetHashCode(); However, it also depends on what you are going to use the hash code for. The built in hash codes are not intended to be stored permanently. The algorithms for calculating the hash codes can change with any new version of the framework, so if you store the hash codes in the database they may become useless in the future. In that case you would instead have to create the hashing algorithm yourself from scratch, or use some hashing algorithm that was designed for permanent storage. One simple algorithm that is used for hash codes for some values in the framework is to use exclusive or to make all bits in the value matter when the hash code is smaller than the data: byte[] b = BitConverter.GetBytes(value); ushort code = (ushort)(BitConverter.ToUInt16(b, 0) ^ BitConverter.ToUInt16(b, 2)); or the more efficient but less obvious way to do the same: ushort code = (ushort)((value >> 16) ^ value); This of course has no obfuscating properties for small values, so you might want to throw in some "random" bits to make the hash code significantly different from the value: ushort code = (ushort)(0x56D4 ^ (value >> 16) ^ value);
