[site]: stackoverflow
[post_id]: 5119033
[parent_id]: 
[tags]: 
Calling c++ runtime from DllMain or global initializers

The question is inspired by this discussion . It seems that fears concerning C++ runtime invokations from DllMain (or from global variables ctor's) are sligtly outdated. I'm using global initializers in dlls frequently without any faults, and now I've run a special test program (compiled with VC2010 Express w/o SP) containing exe module with static runtime linkage and dll with dynamic one. Dll is manualy loaded from exe by LoadLibrary(). Dll creates and fills a map object during global initialization (and therefore uses runtime library, at least memory allocatiion functions). Dll code: #include using namespace std; struct A{ char* p; static const int num=1000; map m; A(){ for(int i=0; i Exe code (for Release configuration; change runtime library name to MSVCR100D.DLL for Debug): #include typedef const char* (*pfunc_t)(int idx); int main(int argc, TCHAR* argv[]) { HMODULE h_crt= GetModuleHandle("MSVCR100.DLL"); // ensure that runtime library is NOT loaded yet: MessageBox(NULL,(NULL==h_crt)? "CRT NOT loaded by .exe module": "CRT Loaded by .exe module" ,"before LoadLibrary",MB_OK); HMODULE hlib=LoadLibrary("dll_example.dll"); h_crt= GetModuleHandle("MSVCR100.DLL"); MessageBox(NULL,(NULL==h_crt)? "CRT NOT loaded": "CRT Loaded" ,"after LoadLibrary",MB_OK); pfunc_t pfunc= (pfunc_t)(void*)GetProcAddress(hlib,"getText"); MessageBox(NULL,pfunc(99),"map[99]",MB_OK); return 0; } The output is as expected: before LoadLibrary: CRT NOT loaded by .exe module after LoadLibrary: CRT Loaded map[99]: some text No failures, nullpointers, pagefaults, etc. Profiling with DependencyWalker also confirms that runtime lib(MSVCR100.DLL) is loaded only after LoadLibrary call (and is not preloaded and initialized by exe). It seems that dynamic runtime library is loaded and initialized correctly during the dll_example.dll loading process before global initialization phase. any thoughts? PS. I don't encourage to move any heavyweight initialization code to global init phase; but I suppose that simple memory allocation code is safe enough (?).
