[site]: stackoverflow
[post_id]: 1852348
[parent_id]: 1851630
[tags]: 
I'd probably just have a template for generating a test: template void enforceConstructors() { T t1; T t2(0); QString q; T t3(0, q); } Then somewhere in your tests, do: enforceConstructors (); enforceConstructors (); enforceConstructors (); Those might be all together, or in separate places for each of the classes X, Y, Z. Depends how you want to organise your tests. If the values I used aren't suitable, either put in some values which are, or else compile that test but don't run it. If you don't have unit tests either get some, or else add the following to the class (instead of inheriting from the base class): #ifndef NDEBUG static void test() { enforceConstructors (); } #endif You don't usually need to make constructors part of an interface defined by an abstract base class. The reason is that such interfaces are for dynamic polymorphism - you pass an object to some function, and it calls functions on it. You can't "pass" a class to a function and have it instantiate the class other than with templates. Templates mostly enforce their interfaces at compile time anyway - if you instantiate the template and it uses the constructor, then the constructor has to be there.
