[site]: stackoverflow
[post_id]: 4167158
[parent_id]: 4167108
[tags]: 
float and int convert automatically in C - you can assign either one to the other, and the only thing to watch out for is that if you assign too large a float to an int, then you get undefined behavior (or possibly an unspecified result, I forget. Either way it's not good). So, your powerArgs function can just be: float powerArgs(float a, int b) { // do some stuff and return a value } Then you can call it as powerArgs(parmA, parmB) , even though parmA is an int. Edit: if you can't change the call parameters, you can do this instead float powerArgs(int *a, int *b) { float base = *a; int exponent = *b; ... } If your professor has really set you code where the function is called as *powerArgs(int *a, int *b) , then your professor is a menace. There is no earthly reason why an exponentiation function should return a pointer to a float. There's an ugly workaround you could use: float *powerArgs(int *a, int *b) { static float result; ... result = /* the result of the calculation */; return &result; } The problem with this is, all calls to powerArgs share the same object result . static stops it from ceasing to exist at the end of the call, but the sharing will introduce problems in the long run. It is not good practice to do this, but it might be the best solution to the problem you've been set. C++ sneaky solution: struct FloatWrapper { float value; float operator*() { return value; } FloatWrapper(float f) : value(f) {} }; FloatWrapper powerArgs(int *a, int *b) { ... float result = /* whatever */; ... return result; } This returns an object of class FloatWrapper, by value, and FloatWrapper overloads the * operator. This means that *powerArgs(...) evaluates to the float that the function should have returned by value in the first place, without needing a pointer to any special storage place. By the way, you might want to check what your function does when parmB is 0.
