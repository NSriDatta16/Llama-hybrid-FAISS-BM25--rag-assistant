[site]: stackoverflow
[post_id]: 3470978
[parent_id]: 3470910
[tags]: 
I would implement this as a ragged array, with A[n][0] always returning the element on the diagonal. A[n][1] will return the item just to the right of the diagonal, A[n][2] will return the item to the left of the diagonal, and so. Then, you just need a function that maps matrix index [i,j] to ragged array index[r][s]. This has the advantage of sparsity, and if your values stay close to the diagonal the arrays are not very long. Alternatively, you could have this definition: struct Row { int InitialOffset; int NumElements; int[] Values; } Then you would have a Row[]. Retrieving a value based on matrix index would look like this: //matrix is merely an array of rows... int GetValue(*matrix this, int i, int j) { Row CurrentRow = (*this)[i]; if (CurrentRow.InitialOffset > j) return 0; else if (CurrentRow.InitialOffset + CurrentRow.NumElements My C syntax is a little hazy, but you should get the idea. Based on your demonstration, I would recommend this: struct Matrix { int[,] Data int[] StartOffset; int[] NumberElements; } Used as follows... int GetValue(*Matrix this, int i, int j) { if (this.StartOffset[i] > j) return 0; else if (this.StartOffset[i] + this.NumberElements[i] Your initialization procedure would look something like this //Data is a struct that holds row index, col index, and value Matrix* InitMatrix (*Data values, int numVals) { //loop through values to find longest row and number of rows //create new matrix, malloc matrix for longrow * numRows //malloc numrows elements for StartOffset and NumItems //foreach row, find min() and max()-min() of col indexs and //store in StartOffset and NumItems } You need to do some processing, but data compression isn't cheap.
