[site]: stackoverflow
[post_id]: 4895766
[parent_id]: 4895567
[tags]: 
I solved this problem by introducing the concept of an 'aggregate' annotation that represent annotations that would otherwise be too close together to distinguish. I employed a simple (aka. naive) algorithm where by when I add a new annotation, I check to see if it is with in distance d of an existing annotation. If it is, I create a new aggregate annotation, place under it the existing annotation and the new annotation. Then I remove the existing annotation and add the aggregate annotation instead. The aggregate annotation has coordinate which is average of its members. This particular algorithm is easy to implement, but has pretty terrible complexity since it checks every existing annotation for each annotation added. An optimisation would be to employ a kd tree to reduce the search space. User interface wise, tapping on such an aggregate annotation would show a callout that shows the number of annotation aggregated, and some summary information about the aggregated annotations. Additionally, the callout's MKAnnotationView 's rightCalloutAccessoryView can drill down into a table view listing the members of the aggregate annotation so user can chose a specific member to examine. One further consideration is how you determine when two annotations are too close. You can do it based on actual distance, in which case if you are zoomed out annotations would still overlap; or you can do it based on logical distance on the screen, taking into account the logical size of your annotation views. The latter can ensure you never have overlapping annotations, but is more computationally expensive as you need to recompute the aggregations when the map region changes.
