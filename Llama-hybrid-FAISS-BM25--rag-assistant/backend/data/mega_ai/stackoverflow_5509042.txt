[site]: stackoverflow
[post_id]: 5509042
[parent_id]: 
[tags]: 
Is my Linq-SQL breaking my MVC2 model binding?

I am trying to handle the http-post from a web form using MVC 2s built in model binding. From what I have been searching through for the past few hours I have figured it is a bit finicky with "objects within objects." I'm looking for any kind of answers or links to resources that may help me figure this out. I'm still in the early stages of this also so if there is a better way - I'm all ears. I have been writing the Linq-SQL myself and not using the code generation. I think the closest answer I'm looking for is here , but I'm still not getting it. Model Client (my best guess for where the issue is): public class Client { public int ClientID { get; set; } ... [Column(Name = "Address_id")] internal int AddressID { get; set; } internal EntityRef _address; [System.Data.Linq.Mapping.Association(ThisKey = "AddressID", Storage = "_address")] public Address Address { get { return _address.Entity; } internal set { _address.Entity = value; AddressID = value.AddressID; } } } Model Address (within client entity) public class Address { [Column] public string Address1 { get; set; } [Column] public string Address2 { get; set; } [Column] public string City { get; set; } ... View Model: public class ClientFormViewModel { public Client Client { get; set; } ... } View: m.Client.ClientID) %> ... m.Client.Address.AddressID) %> m.Client.Address.Address1) %> m.Client.Address.Address1) %> m.Client.Address.Address2) %> m.Client.Address.Address2) %> ... Controller: public ViewResult Edit(int clientId) { var client = clientsRepository.Clients.First(x => x.ClientID == clientId); ... // create view model var viewModel = new ClientFormViewModel { Client = client, ... }; return View(viewModel); } [HttpPost] public ActionResult Edit(ClientFormViewModel clientForm) { if (ModelState.IsValid) { clientsRepository.SaveClient(clientForm.Client); return RedirectToAction("List"); } else // validation error, so redisplay the same view ... } So my issue is... when I get into the HttpPost action, the clientForm.Client.Address is always null . Although, when I look into the ModelState (which is valid), or use Request.["key"] , all of the keys match the structure of my object. For example, I see ModelState["Client.Address.Address1"] , "Client.Address.Address2" , etc. All other basic properties are filled in fine, which make me think the linq-sql code is breaking the model binding. But how? And is there a way to fix it? If those keys are within the Request/ModelState dictionary, why are they not being mapped to the object? Am I totally missing something obvious?
