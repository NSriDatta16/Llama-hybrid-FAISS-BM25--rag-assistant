[site]: stackoverflow
[post_id]: 2486015
[parent_id]: 2485962
[tags]: 
It's probably because bubble sort is an algorithm for arrays, but you're using a linked list: swapping two items in an array (which is what C uses) is O(1) time and requires no extraneous space, but swapping two items in a linked list (which is what Haskell uses) is O(n) time and O(n) space (and this is heap space, not stack space). However, I'm having a little trouble following your code (are you absolutely sure it's the same algorithm?), and it's possible your accumulator deals with the swap's time complexity. However, even if it does, you're allocating a new accumulator list; this will definitely still allocate extra space, and I think this may very well still be one of the reasons for Haskell's worse performance. Also, why do you have rev and rev2 , rather than just using reverse in both places? If it's because you wanted to profile them separately, then you should instead use the SCC (" S et C ost C enter") pragma, described in chapter 5 of the GHC User's Guide: sort ({-# SCC "rev" #-} reverse acc) [] False and {-# SCC "rev2" #-} reverse acc . Each cost center is profiled separately; -auto-all is just implicitly adding cost centers around each function. If you have these functions for some other reason, you still probably shouldn't (why do you?), but my explanation is irrelevant :)
