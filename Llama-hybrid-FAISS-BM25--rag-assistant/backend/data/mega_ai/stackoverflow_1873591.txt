[site]: stackoverflow
[post_id]: 1873591
[parent_id]: 1873470
[tags]: 
Since you are asking: Yes, it is possible. Create an abstract class A with an abstract method that returns ActionResult, created via a factory method that uses a dictionary of Func's that creates A-subclassed instances based on Controller state computed from model (in your case, from the controllerInstance.Model.IsValid property value). Sample code: public abstract class ModelStateValidator { private Controller controller; protected Controller Controller { get { return controller; } } public abstract ActionResult GetResult(); #region initialization static ModelStateValidator() { creators[ControllerState.InvalidModel] = () => new InvalidModelState(); creators[ControllerState.ValidModel] = () => new ValidModelState(); } #endregion #region Creation private static Dictionary > creators = new Dictionary >(); public static ModelStateValidator Create(Controller controller) { return creators[GetControllerState(controller)](); } private static ControllerState GetControllerState(Controller c) { return new ControllerState(c); } internal class ControllerState { private readonly Controller controller; private readonly bool isModelValid; public ControllerState(Controller controller) : this(controller.ModelState.IsValid) { this.controller = controller; } private ControllerState(bool isModelValid) { this.isModelValid = isModelValid; } public static ControllerState ValidModel { get { return new ControllerState(true); } } public static ControllerState InvalidModel { get { return new ControllerState(false); } } public override bool Equals(object obj) { if (obj == null || GetType() != obj.GetType()) //I can show you how to remove this one if you are interested ;) { return false; } return this.isModelValid == ((ControllerState)obj).isModelValid; } public override int GetHashCode() { return this.isModelValid.GetHashCode(); } } #endregion } class InvalidModelState : ModelStateValidator { public override ActionResult GetResult() { return Controller.View(organisationInput.RebuildInput ()); } } class ValidModelState : ModelStateValidator { public override ActionResult GetResult() { return this.Controller.RedirectToAction("Index"); } } 80 additional lines, 4 new classes to remove a single if. your usage then, instead of if, calls the method like this: ActionResult res = ModelStateValidator.Create(this).GetResult(); NOTE: Of course it should be tweaked to acommodate the code that is between the ifs in your original question, this is only a sample code :) Adds additional unnecessary complexity? YES. Contains ifs? NO. Should you use it? Answer that yourself :)
