[site]: stackoverflow
[post_id]: 1432712
[parent_id]: 1426285
[tags]: 
I have used both experimentally . For the second-level-cache i can't compare it with any other option, as it was the only one i used, except perhaps of not having one: It will deliver performance gains immediately, but they will be more noticeable for scenarios where you mostly read than insert/update, when dealing with large datasets and when having a cluster. Specifically for memcached its a sound solution as the application can be run virtually on any kind of machine (like a cheap-o Linux machine) For Lucene.NET i've used it both vanilla (no nhibernate though, but on production not just experiments) and in the form of NHibernate.Search whereas the integration with nhibernate is seamless: the indexes are generated and manipulated behind the curtain and everything is configured at the Class declaration (unfortunately with class and property attributes, would have preferred on the mapping). Comparing it with Sql-Server's Fulltext Search engine i think it is more maintainable as you don't have to write normal SQL to fetch using the FT Engine, you just use the Criteria mechanism as well as an exposed mechanism for Lucene queries. Sync'ing with the database is automatically done during update/insert/delete. Performance of the Lucene.NET engine depends both on the cpu/ram configuration of the machine as well as the speed of the storage medium and i find it comparable if not faster than SqlServer's FullText Engine. As a note, NHibernate.Search indexes are simple and each indexed Class has its own index file making development and peeking in the index easier.
