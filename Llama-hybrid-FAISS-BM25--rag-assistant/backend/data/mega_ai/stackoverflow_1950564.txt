[site]: stackoverflow
[post_id]: 1950564
[parent_id]: 1950386
[tags]: 
One of the reasons Duck Typing is encouraged in Python is that someone might wrap one of your objects, and then it will look like the wrong type, but still work. Here is an example of a class that wraps an object. A LoggedObject acts in all ways like the object it wraps, but when you call the LoggedObject , it logs the call before performing the call. from somewhere import log from myclass import A class LoggedObject(object): def __init__(self, obj, name=None): if name is None: self.name = str(id(obj)) else: self.name = name self.obj = obj def __call__(self, *args, **kwargs): log("%s: called with %d args" % (self.name, len(args))) return self.obj(*args, **kwargs) a = LoggedObject(A(), name="a") a(1, 2, 3) # calls: log("a: called with 3 args") If you explicitly test for isinstance(a, A) it will fail, because a is an instance of LoggedObject . If you just let the duck typing do its thing, this will work. If someone passes the wrong kind of object by mistake, some exception like AttributeError will be raised. The exception might be clearer if you check for types explicitly, but I think overall this case is a win for duck typing. There are times when you really need to test the type. The one I learned recently is: when you are writing code that works with sequences, sometimes you really need to know if you have a string, or it's any other kind of sequence. Consider this: def llen(arg): try: return max(len(arg), max(llen(x) for x in arg)) except TypeError: # catch error when len() fails return 0 # not a sequence so length is 0 This is supposed to return the longest length of a sequence, or any sequence nested inside it. It works: lst = [0, 1, [0, 1, 2], [0, 1, 2, 3, 4, 5, 6]] llen(lst) # returns 7 But if you call llen("foo") , it will recurse forever until stack overflow. The problem is that strings have the special property that they always act like a sequence, even when you take the smallest element from the string; a one-character string is still a sequence. So we cannot write llen() without an explicit test for a string. def llen(arg): if isinstance(arg, str): # Python 3.x; for 2.x use isinstance(arg, basestring) return len(arg) try: return max(len(arg), max(llen(x) for x in arg)) except TypeError: # catch error when len() fails return 0 # not a sequence so length is 0
