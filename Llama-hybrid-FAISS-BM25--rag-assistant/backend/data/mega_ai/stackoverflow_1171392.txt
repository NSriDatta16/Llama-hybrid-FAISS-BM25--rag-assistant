[site]: stackoverflow
[post_id]: 1171392
[parent_id]: 1117537
[tags]: 
If you don't want to use opengl/directx/gdi+ but are stuck in DIBs, I found the fastest is to just do it yourself. Only thing is you need access to the actual bytes of the image. Furthermore, the destination needs to be a DIBbitmap, since this needs to be blitted (not stretchblitted) to your windows form. so given you have 2 byte pointers, 1 src and 1 dest. Both pointing to the rawbytes (each pixel consists of 3 bytes (RGB)) then your algorithm would look like this //these need to be filled out by you //byte *src; //points to the first raw byte of your source RGB picture //byte *dest; //points to the first raw byte of your destination RGB picture //int srcWidth = 640; //width of original image //int srcHeight = 480; //height of original image //int destWidth = 200; //width of destination image //int destHeight = 100; //height of destination image void scaleImage(byte *src, byte*dest, int srcWidth, int srcHeight, int destWidth, int destHeight) { //these are internal counters register int srcx; register int srcy; register int skipx; register int skipy; skipx = (destWidth>>8)/srcWidth; skipy = (destHeight>>8)/srcHeight; for(int y=0; y >8)*srcWidth*3); for(int x=0; x >8)*3); //copy rgb *dest++ = *src3++; *dest++ = *src3++; *dest++ = *src3++; //go to next x pixel srcx += skipx; } //go to next y pixel srcy += skipy; } } The >>8 and To make the scaling look better (since this scale is done using 'nearest neighbour'), you should take the average between the adjacent right pixel, the adjacent bottom pixel and the adjacent bottom right pixel. Make sure not to use a division ('/') but use >>2 which is much faster. p.s. ah right..the code is off the top of my head so beware of small typos
