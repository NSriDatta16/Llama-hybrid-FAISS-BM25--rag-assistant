[site]: stackoverflow
[post_id]: 4219232
[parent_id]: 4219142
[tags]: 
Yes, for every new there needs to be a corresponding delete . (And a delete[] for every new[] .) However, the C++ way would be to avoid dynamic storage as much as possible and rather employ local, automatic variables : for(int i = 0; i If you need to allocate that object dynamically (which I doubt, but there are such cases), then use a smart pointer . A smart pointer will execute the delete for you, no matter which way you leave the scope it belongs to: for(int i = 0; i object(new some_class()); //use object } // object gets destroyed here automatically The current standard only knows one smart pointer, named std::auto_ptr , which would would do what you need in this case. The next standard will come with several more, among them a replacement for std::auto_ptr , named std::unique_ptr , and one with shared ownership semantic, named std::shared_ptr . Your compiler/std lib might actually already support them. If not, you can find them among the many great libraries to be found at boost . BTW, note that I have replaced your i++ with ++i . In case of an int this doesn't make any difference in your scenario, but there are types for which i++ might create an unnecessary copy. (If efficiency wouldn't concern you, why program in C++?)
