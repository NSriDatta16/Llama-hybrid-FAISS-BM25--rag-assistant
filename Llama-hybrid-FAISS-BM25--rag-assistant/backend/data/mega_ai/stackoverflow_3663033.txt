[site]: stackoverflow
[post_id]: 3663033
[parent_id]: 
[tags]: 
component getting items from array before its needed

I have an app where a user puts in the required info into text inputs inside a titlewindow pop up and it sends the data entered into a datagrid. This first time when I call for the popup and enter info it works fine. Here's the problem: the next time I call the component pop up and click anywhere on the popup, including textInputs, the first the item in the array is automatically entered into the textInput where the user is supposed to enter the data themselves (BTW this textInput is also a autocomplete component).What I want is nothing to entered into textinput until the user inputs the data themselves. I've been tweaking with it for hours and im stumped. Any suggestions would be highly appreciated. Here's the code: (this is main page) Here's the pop up component code: [Event(name="SaveTrade")] Long Short Finally the code for the Autocomplete component (AutocompleteModified): package com.adobe.flex.extras.controls { import flash.events.Event; import flash.events.FocusEvent; import flash.events.KeyboardEvent; import flash.net.SharedObject; import flash.ui.Keyboard; import mx.collections.ListCollectionView; import mx.controls.ComboBox; import mx.core.UIComponent; [Event(name="typedTextChange", type="flash.events.Event")] public class AutoCompleteModified extends ComboBox { public function AutoCompleteModified() { super(); //Make ComboBox look like a normal text field editable = true; if(keepLocalHistory) addEventListener("focusOut",focusOutHandler); setStyle("arrowButtonWidth",0); setStyle("fontWeight","normal"); setStyle("cornerRadius",0); setStyle("paddingLeft",0); setStyle("paddingRight",0); rowCount = 7; } private var cursorPosition:Number=0; private var prevIndex:Number = -1; private var removeHighlight:Boolean = false; private var showDropdown:Boolean=false; private var showingDropdown:Boolean=false; private var tempCollection:Object; private var usingLocalHistory:Boolean=false; private var dropdownClosed:Boolean=true; //---------------------------------- // editable //---------------------------------- /** * @private */ override public function set editable(value:Boolean):void { //This is done to prevent user from resetting the value to false super.editable = true; } /** * @private */ override public function set dataProvider(value:Object):void { super.dataProvider = value; if(!usingLocalHistory) tempCollection = value; } //---------------------------------- // labelField //---------------------------------- /** * @private */ override public function set labelField(value:String):void { super.labelField = value; invalidateProperties(); invalidateDisplayList(); } //-------------------------------------------------------------------------- // // Properties // //-------------------------------------------------------------------------- //---------------------------------- // filterFunction //---------------------------------- /** * @private * Storage for the filterFunction property. */ private var _filterFunction:Function = defaultFilterFunction; /** * @private */ private var filterFunctionChanged:Boolean = true; [Bindable("filterFunctionChange")] [Inspectable(category="General")] /** * A function that is used to select items that match the * function's criteria. * A filterFunction is expected to have the following signature: * * f(item:~~, text:String):Boolean * * where the return value is true if the specified item * should displayed as a suggestion. * Whenever there is a change in text in the AutoComplete control, this * filterFunction is run on each item in the dataProvider . * * The default implementation for filterFunction works as follows: * If "AB" has been typed, it will display all the items matching * "AB~~" (ABaa, ABcc, abAc etc.). * * An example usage of a customized filterFunction is when text typed * is a regular expression and we want to display all the * items which come in the set. * * @example * * public function myFilterFunction(item:~~, text:String):Boolean * { * public var regExp:RegExp = new RegExp(text,""); * return regExp.test(item); * } * * */ public function get filterFunction():Function { return _filterFunction; } /** * @private */ public function set filterFunction(value:Function):void { //An empty filterFunction is allowed but not a null filterFunction if(value!=null) { _filterFunction = value; filterFunctionChanged = true; invalidateProperties(); invalidateDisplayList(); dispatchEvent(new Event("filterFunctionChange")); } else _filterFunction = defaultFilterFunction; } //---------------------------------- // filterFunction //---------------------------------- /** * @private * Storage for the keepLocalHistory property. */ private var _keepLocalHistory:Boolean = false; /** * @private */ private var keepLocalHistoryChanged:Boolean = true; [Bindable("keepLocalHistoryChange")] [Inspectable(category="General")] /** * When true, this causes the control to keep track of the * entries that are typed into the control, and saves the * history as a local shared object. When true, the * completionFunction and dataProvider are ignored. * * @default "false" */ public function get keepLocalHistory():Boolean { return _keepLocalHistory; } /** * @private */ public function set keepLocalHistory(value:Boolean):void { _keepLocalHistory = value; } //---------------------------------- // lookAhead //---------------------------------- /** * @private * Storage for the lookAhead property. */ private var _lookAhead:Boolean=false; /** * @private */ private var lookAheadChanged:Boolean; [Bindable("lookAheadChange")] [Inspectable(category="Data")] /** * lookAhead decides whether to auto complete the text in the text field * with the first item in the drop down list or not. * * @default "false" */ public function get lookAhead():Boolean { return _lookAhead; } /** * @private */ public function set lookAhead(value:Boolean):void { _lookAhead = value; lookAheadChanged = true; } //---------------------------------- // typedText //---------------------------------- /** * @private * Storage for the typedText property. */ private var _typedText:String=""; /** * @private */ private var typedTextChanged:Boolean; [Bindable("typedTextChange")] [Inspectable(category="Data")] /** * A String to keep track of the text changed as * a result of user interaction. */ public function get typedText():String { return _typedText; } /** * @private */ public function set typedText(input:String):void { _typedText = input; typedTextChanged = true; invalidateProperties(); invalidateDisplayList(); dispatchEvent(new Event("typedTextChange")); } override protected function commitProperties():void { super.commitProperties(); if(!dropdown) selectedIndex=-1; if(dropdown) { if(typedTextChanged) { cursorPosition = textInput.selectionBeginIndex; updateDataProvider(); //In case there are no suggestions there is no need to show the dropdown if(collection.length==0 || typedText==""|| typedText==null) { dropdownClosed=true; showDropdown=false; } else { showDropdown = true; selectedIndex = 0; } } } } override protected function focusOutHandler(event:FocusEvent):void { super.focusOutHandler(event) if(keepLocalHistory && dataProvider.length==0) addToLocalHistory(); } override public function getStyle(styleProp:String):* { if(styleProp != "openDuration") return super.getStyle(styleProp); else { if(dropdownClosed) return super.getStyle(styleProp); else return 0; } } override protected function keyDownHandler(event:KeyboardEvent):void { super.keyDownHandler(event); if(!event.ctrlKey) { //An UP "keydown" event on the top-most item in the drop-down //or an ESCAPE "keydown" event should change the text in text // field to original text if(event.keyCode == Keyboard.UP && prevIndex==0) { textInput.text = _typedText; textInput.setSelection(textInput.text.length, textInput.text.length); selectedIndex = -1; } else if(event.keyCode==Keyboard.ESCAPE && showingDropdown) { textInput.text = _typedText; textInput.setSelection(textInput.text.length, textInput.text.length); showingDropdown = false; dropdownClosed=true; } else if(event.keyCode == Keyboard.ENTER) { if(keepLocalHistory && dataProvider.length==0) addToLocalHistory(); /* textInput.text = selectedLabel; textInput.setSelection(cursorPosition, textInput.text.length); textInput.setSelection(textInput.text.length,_typedText.length); */ } else if(lookAhead && event.keyCode == Keyboard.BACKSPACE || event.keyCode == Keyboard.DELETE) removeHighlight = true; } else if(event.ctrlKey && event.keyCode == Keyboard.UP) dropdownClosed=true; prevIndex = selectedIndex; } override protected function measure():void { super.measure(); measuredWidth = mx.core.UIComponent.DEFAULT_MEASURED_WIDTH; } override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void { super.updateDisplayList(unscaledWidth, unscaledHeight); //An UP "keydown" event on the top-most item in the drop //down list otherwise changes the text in the text field to "" if(selectedIndex == -1) textInput.text = typedText; if(dropdown) { if(typedTextChanged) { //This is needed because a call to super.updateDisplayList() set the text // in the textInput to "" and thus the value //typed by the user losts if(lookAhead && showDropdown && typedText!="" && !removeHighlight) { var label:String = itemToLabel(collection[0]); var index:Number = label.toLowerCase().indexOf(_typedText.toLowerCase()); if(index==0) { textInput.text = _typedText+label.substr(_typedText.length); textInput.setSelection(textInput.text.length,_typedText.length); } else { textInput.text = _typedText; textInput.setSelection(cursorPosition, cursorPosition); removeHighlight = false; } } else { textInput.text = _typedText; textInput.setSelection(cursorPosition, cursorPosition); removeHighlight = false; } typedTextChanged= false; } else if(typedText) textInput.setSelection(_typedText.length,textInput.text.length); } if(showDropdown && !dropdown.visible) { super.open(); showDropdown = false; showingDropdown = true; if(dropdownClosed) dropdownClosed=false; } } override protected function textInput_changeHandler(event:Event):void { super.textInput_changeHandler(event); //Stores the text typed by the user in a variable typedText=text; } private function addToLocalHistory():void { if (id != null && id != "" && text != null && text != "") { var so:SharedObject = SharedObject.getLocal("AutoCompleteData"); var savedData : Array = so.data.suggestions; //No shared object has been created so far if (savedData == null) savedData = new Array(); var i:Number=0; var flag:Boolean=false; //Check if this entry is there in the previously saved shared object data for(i=0;i } }
