[site]: stackoverflow
[post_id]: 4236298
[parent_id]: 4041220
[tags]: 
I was having the same trouble until I read that when you subclass CCSprite you must setup initWithTexture and then use it in your custom init method. Mine is a little different because I am not using a sprite sheet, here is how I did it with my CCSprite subclass: Header: #import "cocos2d.h" typedef enum tagButtonState { kButtonStatePressed, kButtonStateNotPressed } ButtonState; typedef enum tagButtonStatus { kButtonStatusEnabled, kButtonStatusDisabled } ButtonStatus; @interface spuButton : CCSprite { @private ButtonState state; CCTexture2D *buttonNormal; CCTexture2D *buttonLit; ButtonStatus buttonStatus; } @property(nonatomic, readonly) CGRect rect; + (id)spuButtonWithTexture:(CCTexture2D *)normalTexture; - (void)setNormalTexture:(CCTexture2D *)normalTexture; - (void)setLitTexture:(CCTexture2D *)litTexture; - (BOOL)isPressed; - (BOOL)isNotPressed; @end .m file: #import "spuButton.h" #import "cocos2d.h" @implementation spuButton - (CGRect)rect { CGSize s = [self.texture contentSize]; return CGRectMake(-s.width / 2, -s.height / 2, s.width, s.height); } + (id)spuButtonWithTexture:(CCTexture2D *)normalTexture { return [[[self alloc] initWithTexture:normalTexture] autorelease]; } - (void)setNormalTexture:(CCTexture2D *)normalTexture { buttonNormal = normalTexture; } - (void)setLitTexture:(CCTexture2D *)litTexture { buttonLit = litTexture; } - (BOOL)isPressed { if (state == kButtonStateNotPressed) return NO; if (state == kButtonStatePressed) return YES; return NO; } - (BOOL)isNotPressed { if (state == kButtonStateNotPressed) return YES; if (state == kButtonStatePressed) return NO; return YES; } - (id)initWithTexture:(CCTexture2D *)aTexture { if ((self = [super initWithTexture:aTexture]) ) { state = kButtonStateNotPressed; } return self; } - (void)onEnter { [[CCTouchDispatcher sharedDispatcher] addTargetedDelegate:self priority:0 swallowsTouches:YES]; [super onEnter]; } - (void)onExit { [[CCTouchDispatcher sharedDispatcher] removeDelegate:self]; [super onExit]; } - (BOOL)containsTouchLocation:(UITouch *)touch { return CGRectContainsPoint(self.rect, [self convertTouchToNodeSpaceAR:touch]); } - (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event { if (state == kButtonStatePressed) return NO; if ( ![self containsTouchLocation:touch] ) return NO; if (buttonStatus == kButtonStatusDisabled) return NO; state = kButtonStatePressed; [self setTexture:buttonLit]; return YES; } - (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event { // If it weren't for the TouchDispatcher, you would need to keep a reference // to the touch from touchBegan and check that the current touch is the same // as that one. // Actually, it would be even more complicated since in the Cocos dispatcher // you get NSSets instead of 1 UITouch, so you'd need to loop through the set // in each touchXXX method. if ([self containsTouchLocation:touch]) return; state = kButtonStateNotPressed; [self setTexture:buttonNormal]; } - (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event { state = kButtonStateNotPressed; [self setTexture:buttonNormal]; } @end Then in my main program init: CCTexture2D *redButtonNormal = [[CCTextureCache sharedTextureCache] addImage:@"RedButtonNormal.png"]; spuButton *redButton = [spuButton spuButtonWithTexture:redButtonNormal]; [self addChild:redButton]; You would do the same thing but incorporate it into your animations too. Does this help? I hope so. Happy coding!
