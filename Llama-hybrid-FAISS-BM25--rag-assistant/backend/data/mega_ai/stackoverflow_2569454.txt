[site]: stackoverflow
[post_id]: 2569454
[parent_id]: 2568070
[tags]: 
I don't think this is Java byte code that you are trying to create, right? This is actually byte-code for your specific CPU. This greatly simplifies your project. This also looks like it may have a stack architecture, thus you only have single operands. Since your input is text and just the assembly language defined for your custom CPU you should be able to read and parse the text quite easily and write out the binary. Here's some pseud code that should help. initialize Map of instruction names (keys) to instruction op codes (ByteCodeInfo); initialize empty bytecode-operations list; open input text file; while (more to read) { read next line; split line by spaces; lookup ByteCodeInfo in the Map; if (num actual operands != num expected operands - from ByteCodeInfo) throw exception(parse failed on line ####); add new operation to list of operations (each element in the list is an address) if there is a variable reference (e.g. "X") add this to a symbol Map; if this is a variable declaration (DC...) update the symbol object with the address; } close input text file; open output binary file (the byte-code file); for each element in operation list { write address, byte-code, operands (if any); } close byte-code file; You will have to keep track of your storage addresses and instruction addresses This is not an impossible task so take courage and it is possible to do this in a day or so, if you have experience with creating those other classes you show. EDIT : Added ByteCodeInfo class which represents information about your byte-codes, such as the id, number of operands, expected types of operand, etc. This class could also be used to emit the byte code based on the parsed line information. This would provide a better abstraction then just storing an opcode int in the Map as I had original suggested.
