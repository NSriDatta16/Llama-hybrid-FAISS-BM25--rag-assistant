nd reduction systems to expert systems. A simple string rewriting production system example This example shows a set of production rules for reversing a string from an alphabet that does not contain the symbols "$" and "*" (which are used as marker symbols). P1: $$ -> * P2: *$ -> * P3: *x -> x* P4: * -> null & halt P5: $xy -> y$x P6: null -> $ In this example, production rules are chosen for testing according to their order in this production list. For each rule, the input string is examined from left to right with a moving window to find a match with the LHS of the production rule. When a match is found, the matched substring in the input string is replaced with the RHS of the production rule. In this production system, x and y are variables matching any character of the input string alphabet. Matching resumes with P1 once the replacement has been made. The string "ABC", for instance, undergoes the following sequence of transformations under these production rules: $ABC (P6) B$AC (P5) BC$A (P5) $BC$A (P6) C$B$A (P5) $C$B$A (P6) $$C$B$A (P6) *C$B$A (P1) C*$B$A (P3) C*B$A (P2) CB*$A (P3) CB*A (P2) CBA* (P3) CBA (P4) In such a simple system, the ordering of the production rules is crucial. Often, the lack of control structure makes production systems difficult to design. It is, of course, possible to add control structure to the production systems model, namely in the inference engine, or in the working memory. An OPS5 production rule example In a toy simulation world where a monkey in a room can grab different objects and climb on others, an example production rule to grab an object suspended from the ceiling would look like: (p Holds::Object-Ceiling {(goal ^status active ^type holds ^objid <O1>) <goal>} {(physical-object ^id <O1> ^weight light ^at <p> ^on ceiling) <object-1>} {(physical-object ^id ladder ^at <p> ^on floor) <object-2>} {(monkey ^on ladder ^holds NIL) <monkey>} -(physical-object ^on <O1>) --> (write (crlf) Grab <O1> (crlf)) (modify <object1> ^on NIL) (modify <monkey> ^holds <O1>) (modify <goal> ^status satisfied) ) In this example, data in working memory is structured and variables appear between angle brackets. The name of the data structure, such as "goal" and "physical-object", is the first literal in conditions; the fields of a structure are prefixed with "^". The "-" indicates a negative condition. Production rules in OPS5 apply to all instances of data structures that match conditions and conform to variable bindings. In this example, should several objects be suspended from the ceiling, each with a different ladder nearby supporting an empty-handed monkey, the conflict set would contain as many production rule instances derived from the same production "Holds::Object-Ceiling". The conflict resolution step would later select which production instances to fire. The binding of variables resulting from the pattern matching in the LHS is used in the RHS to refer to the data to be modified. The working memory contains explicit control structure data in the form of "goal" data structure instances. In the example, once a monkey holds the suspended object, the status of the goal is set to "satisfied" and the same production rule can no longer apply as its first condition fails. Relationship with logic Both Russell and Norvig's Artificial Intelligence: A Modern Approach and John Sowa's Knowledge Representation: Logical, Philosophical, and Computational Foundations characterize production systems as systems of logic that perform reasoning by means of forward chaining. However, Stewart Shapiro, reviewing Sowa's book, argues that this is a misrepresentation. Similarly, Kowalski and Sadri argue that, because actions in production systems are understood as imperatives, production systems do not have a logical semantics. Their logic and computer language Logic Production System (LPS) combines logic programs, interpreted as an agent's beliefs, with reactive rules, interpreted as an agent's goals. They argue that reactive 