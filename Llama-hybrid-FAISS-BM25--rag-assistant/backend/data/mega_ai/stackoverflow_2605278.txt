[site]: stackoverflow
[post_id]: 2605278
[parent_id]: 2605130
[tags]: 
You need to decide exactly what you want to do - and preferably explain it a bit more clearly. Option 1: File If you know which file you want the output of the executed command to go to, then: Ensure that the parent and child agree on the name (parent decides name before forking). Parent forks - you have two processes. Child reorganizes things so that file descriptor 1 (standard output) goes to the file. Usually, you can leave standard error alone; you might redirect standard input from /dev/null. Child then execs relevant command; said command runs and any standard output goes to the file (this is the basic shell I/O redirection). Executed process then terminates. Meanwhile, the parent process can adopt one of two main strategies: Open the file for reading, and keep reading until it reaches an EOF. It then needs to double check whether the child died (so there won't be any more data to read), or hang around waiting for more input from the child. Wait for the child to die and then open the file for reading. The advantage of the first is that the parent can do some of its work while the child is also running; the advantage of the second is that you don't have to diddle with the I/O system (repeatedly reading past EOF). Option 2: Pipe If you want the parent to read the output from the child, arrange for the child to pipe its output back to the parent. Use popen() to do this the easy way. It will run the process and send the output to your parent process. Note that the parent must be active while the child is generating the output since pipes have a small buffer size (often 4-5 KB) and if the child generates more data than that while the parent is not reading, the child will block until the parent reads. If the parent is waiting for the child to die, you have a deadlock. Use pipe() etc to do this the hard way. Parent calls pipe(), then forks. The child sorts out the plumbing so that the write end of the pipe is its standard output, and ensures that all other file descriptors relating to the pipe are closed. This might well use the dup2() system call. It then executes the required process, which sends its standard output down the pipe. Meanwhile, the parent also closes the unwanted ends of the pipe, and then starts reading. When it gets EOF on the pipe, it knows the child has finished and closed the pipe; it can close its end of the pipe too.
