[site]: stackoverflow
[post_id]: 4658900
[parent_id]: 
[tags]: 
Secure Equals: Why is inequality still consistently less time?

I have a method that compares two byte arrays for equality, with the major caveat that it does not fail and exit early when it detects inequality. Basically the code is used to compare Cross-Site Request Forgery tokens, and avoid (as much as possible) the ability to use timing to hack the key. I wish I could find the link to the paper that discusses the attack in detail, but the important thing is that the code I have still has a statistically measurable bias for returning sooner if the two byte arrays are equal--although it is an order of magnitude better. So without further ado, here is the code: public static bool SecureEquals(byte[] original, byte[] potential) { // They should be the same size, but we don't want to throw an // exception if we are wrong. bool isEqual = original.Length == potential.Length; int maxLenth = Math.Max(original.Length, potential.Length); for(int i=0; i The difference in average timing between equal and unequal tokens is consistently 10-25ms (depending on garbage collection cycles) shorter for unequal tokens. This is precisely what I want to avoid. If the relative timing were equal, or the average timing swapped based on the run I would be happy. The problem is that we are consistently running shorter for unequal tokens. In contrast, if we stopped the loop on the first unequal token, we could have up to an 80x difference in timing. While this equality check is a major improvement over the typical eager return, it is still not good enough. Essentially, I don't want any consistent result for equality or inequality returning faster. If I could get the results into the range where garbage collection cycles will mask any consistent bias, I will be happy. Anyone have a clue what is causing the timing bias toward inequality being faster? At first I thought it was the ternary operator returning an access to the array or a constant if the arrays were of unequal size. The problem is that I still get this bias if the two arrays are the same size. NOTE: As requested, the links to the articals on Timing Attacks: http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf (official paper, linked to from the blog post below) http://codahale.com/a-lesson-in-timing-attacks/ (talks about the failure in Java's library) http://en.wikipedia.org/wiki/Timing_attack (more general, but not as complete)
