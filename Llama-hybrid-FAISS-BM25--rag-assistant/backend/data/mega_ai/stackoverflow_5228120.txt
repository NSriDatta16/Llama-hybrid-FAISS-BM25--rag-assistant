[site]: stackoverflow
[post_id]: 5228120
[parent_id]: 
[tags]: 
Texture Projection in GLSL

I'm trying to implement texture projection based directly on this example at oZone3d . My environment is OpenGL ES 2.0 on Android 2.2. Matrix math has never been my strong point and I suspect that my problem lies somewhere in the texture projection matrix setup (texGenMatrix). I have tried everything imaginable to get this working but the projection doesn't come out correctly. I'd greatly appreciate some extra eyes on my code. Thanks. Not shown here is my geometry (a horizontal plane through the origin), and some other plumbing like shader uniform/attribute binds. Camera Setup : // Set the camera projection matrix Matrix.frustumM(cameraProjMatrix, 0, -nearPlaneSize.x, nearPlaneSize.x, // near plane left/right -nearPlaneSize.y, nearPlaneSize.y, // near plane bottom/top nearPlaneDistance, farPlaneDistance // near/far plane distance ); // Set the camera view matrix Matrix.setLookAtM(cameraViewMatrix, 0, 0, 100, 100, // eye 0, 0, 0, // center 0, 1, 0 // up-vector ); // Translate the model as needed Matrix.translateM(modelMatrix, 0, x, y, z); // Calculate the model * view matrix Matrix.multiplyMM(modelViewMatrix, 0, cameraViewMatrix, 0, modelMatrix, 0); // Calculate the inverse camera view matrix (needed in the vert shader) Matrix.invertM(inverseCameraViewMatrix, 0, cameraViewMatrix, 0); Texture Projection setup : // Set a texture projection matrix Matrix.frustumM(texProjMatrix, 0, -nearPlaneSize.x, nearPlaneSize.x, // near plane left/right -nearPlaneSize.y, nearPlaneSize.y, // near plane bottom/top nearPlaneDistance, farPlaneDistance // near/far plane distance ); // Set the texture projection to point down at the origin Matrix.setLookAtM(texViewMatrix, 0, 0, 100, 10, // eye 0, 0, 0, // center 0, 1, 0 // up-vector ); // scale bias float[] scaleBiasMatrix = new float[] { 0.5f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f }; // calculate the TexGenMatrix Matrix.multiplyMM(texGenMatrix, 0, scaleBiasMatrix, 0, texProjMatrix, 0); Matrix.multiplyMM(texGenMatrix, 0, texGenMatrix, 0, texViewMatrix, 0); The vertex shader : attribute vec3 aPosition; // vertex x y z uniform mat4 texGenMatrix; uniform mat4 modelViewMatrix; uniform mat4 cameraProjMatrix; varying vec4 vProjCoord; void main() { gl_Position = cameraProjMatrix * modelViewMatrix * aPosition; vec4 posEye = modelViewMatrix * aPosition; vec4 posWorld = inverseCameraViewMatrix * posEye; vProjCoord = texGenMatrix * posWorld; } Fragment shader : uniform sampler2D projectionMap; varying vec4 vProjCoord; void main() { vec3 finalColor = vec3( 0.5, 0.5, 0.5); if (vProjCoord.q > 0.0) { vec4 ProjMapColor = texture2DProj(projectionMap, vProjCoord); finalColor += ProjMapColor.rgb; } gl_FragColor = vec4(finalColor, 1.0); }
