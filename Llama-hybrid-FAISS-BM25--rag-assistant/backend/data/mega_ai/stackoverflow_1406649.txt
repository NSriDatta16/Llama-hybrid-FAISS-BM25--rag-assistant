[site]: stackoverflow
[post_id]: 1406649
[parent_id]: 
[tags]: 
Wanted: Elegant solution to race condition

I have the following code: class TimeOutException {}; template class MultiThreadedBuffer { public: MultiThreadedBuffer() { InitializeCriticalSection(&m_csBuffer); m_evtDataAvail = CreateEvent(NULL, TRUE, FALSE, NULL); } ~MultiThreadedBuffer() { CloseHandle(m_evtDataAvail); DeleteCriticalSection(&m_csBuffer); } void LockBuffer() { EnterCriticalSection(&m_csBuffer); } void UnlockBuffer() { LeaveCriticalSection(&m_csBuffer); } void Add(T val) { LockBuffer(); m_buffer.push_back(val); SetEvent(m_evtDataAvail); UnlockBuffer(); } T Get(DWORD timeout) { T val; if (WaitForSingleObject(m_evtDataAvail, timeout) == WAIT_OBJECT_0) { LockBuffer(); if (!m_buffer.empty()) { val = m_buffer.front(); m_buffer.pop_front(); } if (m_buffer.empty()) { ResetEvent(m_evtDataAvail); } UnlockBuffer(); } else { throw TimeOutException(); } return val; } bool IsDataAvail() { return (WaitForSingleObject(m_evtDataAvail, 0) == WAIT_OBJECT_0); } std::list m_buffer; CRITICAL_SECTION m_csBuffer; HANDLE m_evtDataAvail; }; Unit testing shows that this code works fine when used on a single thread as long as T's default constructor and copy/assignment operators don't throw. Since I'm writting T, that is acceptable. My problem is the Get method. If there is no data available (i.e. m_evtDataAvail is not set), then a couple of threads can block on the WaitForSingleObject call. When new data becomes available, they all fall through to the Lock() call. Only one will pass and can get the data out and move on. After the Unlock() another thread can move on through and will find that there is no data. Currently it will return the default object. What I want to happen is for that second thread (and others) to go back to the WaitForSingleObject call. I could add an else block that unlocked and did a goto but that just feels evil. That solution also adds the possibility for an endless loop since each trip back would restart the timeout. I could add some code to check the clock on entry and adjust the timeout on each trip back but then this simple Get method starts to get very complicated. Any ideas on how to solve these problems while maintaining testability and simplicity? Oh, for anyone wondering, the IsDataAvail function only exists for testing. It won't be used in production code. The Add and Get are the only methods that will be used in a non-testing environment.
