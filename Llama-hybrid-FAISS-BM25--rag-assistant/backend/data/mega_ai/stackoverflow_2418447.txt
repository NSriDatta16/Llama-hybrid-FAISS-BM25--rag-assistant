[site]: stackoverflow
[post_id]: 2418447
[parent_id]: 2418262
[tags]: 
You unittest things where you want to make sure your algorithm works want to safeguard against accidental changes in the future So in your example it would not make much sense to test the generated classes. Test the generator instead. It's good practice to test the main use cases (what the tested function was designed for) first. Then you test the main error cases. Then you write tests for corner cases (i.e. lower and upper bounds). The unusual error cases are normally so hard to produce that it doesn't make sense to unit-test them. If you need to verify a large range of parameter sets, use data-driven testing. How many things you test is a matter of effort vs. return, so it really depends on the individual project. Normally you try to follow the 80/20 rule, but there may be applications where you need more test coverage because a failure would have very serious consequences. You can dramatically reduce the time you need to write tests if you use a test-driven approach (TDD). That's because code that isn't written with testability in mind is much harder, sometimes near to impossible to test. But since nothing in life is free, the code developed with TDD tends to be more complex itself.
