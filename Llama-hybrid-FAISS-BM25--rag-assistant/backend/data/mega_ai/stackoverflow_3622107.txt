[site]: stackoverflow
[post_id]: 3622107
[parent_id]: 3619921
[tags]: 
layoutTarget /** * @private * Work-around the Player globalToLocal and scrollRect changing before * a frame is updated. */ private function globalToLocal(x:Number, y:Number):Point { var layoutTarget:GroupBase = target; var parent:DisplayObject = layoutTarget.parent; var local:Point = parent.globalToLocal(new Point(x, y)); local.x -= layoutTarget.x; local.y -= layoutTarget.y; var scrollRect:Rectangle = getScrollRect(); if (scrollRect) { local.x += scrollRect.x; local.y += scrollRect.y; } return local; } and this too /** * Calculates how much to scroll for the specified dropLocation * during a drag and drop gesture. * * Called by the showDropIndicator() method to calculate the scroll * during drag-scrolling. * * @param context A valid DropLocation object previously obtained * by calling the calculateDropLocation() method. * * @param elapsedTime The duration, in milliseconds, since the drag scrolling start. * * @return How much to drag scroll, or null if drag-scrolling is not needed. * * @see spark.layouts.supportClasses.DropLocation * @see #calculateDropIndex() * @see #calculateDropIndicatorBounds() * * @langversion 3.0 * @playerversion Flash 10 * @playerversion AIR 1.5 * @productversion Flex 4 */ protected function calculateDragScrollDelta(dropLocation:DropLocation, elapsedTime:Number):Point { var layoutTarget:GroupBase = target; if (layoutTarget.numElements == 0) return null; var scrollRect:Rectangle = getScrollRect(); if (!scrollRect) return null; // Make sure that the drag-scrolling regions don't overlap var x:Number = dropLocation.dropPoint.x; var y:Number = dropLocation.dropPoint.y; var horizontalRegionSize:Number = Math.min(dragScrollRegionSizeHorizontal, layoutTarget.width/2); var verticalRegionSize:Number = Math.min(dragScrollRegionSizeVertical, layoutTarget.height/2); // Return early if the mouse is outside of the drag-scroll region. if (scrollRect.left + horizontalRegionSize horizontalScrollPosition /** * @private * Updates the scroll position and dispatches a DragEvent. */ private function dragScroll(event:TimerEvent):void { // Scroll the target horizontalScrollPosition += _dragScrollDelta.x; verticalScrollPosition += _dragScrollDelta.y; // Validate target before dispatching the event target.validateNow(); // Re-dispatch the event so that the drag initiator handles it as if // the DragProxy is dispatching in response to user input. // Always switch over to DRAG_OVER, don't re-dispatch DRAG_ENTER var dragEvent:DragEvent = new DragEvent(DragEvent.DRAG_OVER, _dragScrollEvent.bubbles, _dragScrollEvent.cancelable, _dragScrollEvent.dragInitiator, _dragScrollEvent.dragSource, _dragScrollEvent.action, _dragScrollEvent.ctrlKey, _dragScrollEvent.altKey, _dragScrollEvent.shiftKey); dragEvent.draggedItem = _dragScrollEvent.draggedItem; dragEvent.localX = _dragScrollEvent.localX; dragEvent.localY = _dragScrollEvent.localY; dragEvent.relatedObject = _dragScrollEvent.relatedObject; _dragScrollEvent.target.dispatchEvent(dragEvent); } and this too: public function set horizontalScrollPosition(value:Number):void { if (value == _horizontalScrollPosition) return; _horizontalScrollPosition = value; scrollPositionChanged(); } lets look too scrollPositionChanged(); /** * Called when the verticalScrollPosition or * horizontalScrollPosition properties change. * * The default implementation updates the target's scrollRect property by * calling updateScrollRect() . * Subclasses can override this method to compute other values that are * based on the current scrollPosition or scrollRect . * * @see #updateScrollRect() * * @langversion 3.0 * @playerversion Flash 10 * @playerversion AIR 1.5 * @productversion Flex 4 */ protected function scrollPositionChanged():void { var g:GroupBase = target; if (!g) return; updateScrollRect(g.width, g.height); } also lets look at this part of code /** * Computes the verticalScrollPosition and * horizontalScrollPosition deltas needed to * scroll the element at the specified index into view. * * This method attempts to minimize the change to verticalScrollPosition * and horizontalScrollPosition . * * If clipAndEnableScrolling is true * and the element at the specified index is not * entirely visible relative to the target's scroll rectangle, then * return the delta to be added to horizontalScrollPosition and * verticalScrollPosition that scrolls the element completely * within the scroll rectangle's bounds. * * @param index The index of the element to be scrolled into view. * * @return A Point that contains offsets to horizontalScrollPosition * and verticalScrollPosition that will scroll the specified * element into view, or null if no change is needed. * If the specified element is partially visible and larger than the * scroll rectangle, meaning it is already the only element visible, then * return null. * If the specified index is invalid, or target is null, then * return null. * If the element at the specified index is null or includeInLayout * false, then return null. * * @see #clipAndEnableScrolling * @see #verticalScrollPosition * @see #horizontalScrollPosition * @see #udpdateScrollRect() * * @langversion 3.0 * @playerversion Flash 10 * @playerversion AIR 1.5 * @productversion Flex 4 */ public function getScrollPositionDeltaToElement(index:int):Point and so, what if we will talk about difference of these params in LayoutBase and HorizontalLayout? in HL it used in private function updateDisplayListVirtual():void but there are no such function in LayoutBase, because LayoutBase just a Base class as it is, but it have another one which called as public function updateDisplayList(width:Number, height:Number):void but its empty. So, if we will try to think what does all these functions do, imho, HL just extending standart updateDisplayList to two functions one is the same and another one is virtual. Whats for HL needs virtual? Lets see: override public function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void { super.updateDisplayList(unscaledWidth, unscaledHeight); var layoutTarget:GroupBase = target; if (!layoutTarget) return; if ((layoutTarget.numElements == 0) || (unscaledWidth == 0) || (unscaledHeight == 0)) { setColumnCount(0); setIndexInView(-1, -1); if (layoutTarget.numElements == 0) layoutTarget.setContentSize(paddingLeft + paddingRight, paddingTop + paddingBottom); return; } if (useVirtualLayout) updateDisplayListVirtual(); else updateDisplayListReal(); } so all stuff is useVirtualLayout , but its from LayoutBase and lets see: /** * A container can hold any number of children. * However, each child requires an instance of an item renderer. * If the container has many children, you might notice performance degradation * as you add more children to the container. * * Instead of creating an item renderer for each child, * you can configure the container to use a virtual layout. * With virtual layout, the container reuses item renderers so that it only creates * item renderers for the currently visible children of the container. * As a child is moved off the screen, possible by scrolling the container, * a new child being scrolled onto the screen can reuse its item renderer. * * To configure a container to use virtual layout, set the useVirtualLayout property * to true for the layout associated with the container. * Only the DataGroup or SkinnableDataContainer with the VerticalLayout, * HorizontalLayout, and TileLayout supports virtual layout. * Layout subclasses that do not support virtualization must prevent changing * this property. * * Note: The BasicLayout class throws a run-time error if you set * useVirtualLayout to true . * * When true , layouts that support virtualization must use * the target.getVirtualElementAt() method, * rather than getElementAt() , and must only get the * elements they anticipate will be visible given the value of getScrollRect() . * * When true , the layout class must be able to compute * the indices of the layout elements that overlap the scrollRect in its * updateDisplayList() method based exclusively on cached information, not * by getting layout elements and examining their bounds. * * Typically virtual layouts update their cached information * in the updateDisplayList() method, * based on the sizes and locations computed for the elements in view. * * Similarly, in the measure() method, virtual layouts should update the target's * measured size properties based on the typicalLayoutElement and other * cached layout information, not by measuring elements. * * Containers cooperate with layouts that have useVirtualLayout = true by * recycling item renderers that were previously constructed, but are no longer in use. * An item is considered to be no longer in use if its index is not * within the range of getVirtualElementAt() indices requested during * the container's most recent updateDisplayList() invocation. * * @default false * * @see #getScrollRect * @see #typicalLayoutElement * * @langversion 3.0 * @playerversion Flash 10 * @playerversion AIR 1.5 * @productversion Flex 4 */ so it is your answer, i think, also i think that people who wrote this Spark system will explain more widely, and this is only my little pleasure to help you to get the right answers. Regards Eugene
