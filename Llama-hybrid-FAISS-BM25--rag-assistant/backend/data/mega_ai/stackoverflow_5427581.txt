[site]: stackoverflow
[post_id]: 5427581
[parent_id]: 5427459
[tags]: 
If you are writing your own, as I assume you intend to, I would make a class that contains a TDateTime, and other fields, and I would base it on the functionality in the very nicely written mxDateTime extension for Python, which is very easily readable, open source, C code, that you could use to extract the gregorian calendar logic you are going to need. Within certain limits, TDateTime is always right. It's epoch value (0) is December 30, 1899 at midnight. From there, you can calculate other julian day numbers. It supports negative values, and thus it will support more than 400 years. I believe you will start having to do corrections, at the time of the last Gregorian calendar reforms. If you go from Friday, 15 October 1582, and figure out its julian day number, and the reforms before and after that, you should be able to do all that you require. Be aware that the time of day runs "backwards" before 1899, but that this is purely a problem in human heads, the computer will be accurate, and will calculate the number of minutes and seconds, up to the limit of double precision floating point math for you. Stick with TDateTime as your base. I found some really old BorlandPascal/TurboPascal code that handles a really wide range of dates here . If you need to handle arabic, jewish, and other calendars, again, I refer you to Python as a great source of working examples. Not just the mxdatetime extension, but stuff like this . For database persistence, you might want to base your date storage around julian day numbers, and your time as C-like seconds since midnight, if the maximum resolution you need is 1 second. Here's a snippet I would start with, and do code completion on: TCalendarDisplaySubtype = ( cdsGregorian,cdsHebrew,cdsArabic,cdsAztec, cdsValveSoftwareCompany, cdsWhoTheHeckKnows ); TDateInformation = class private FBaseDateTime:TDateTime; FYear,FMonth,FDay:Integer; // if -1 then not calculated yet. FCalendarDisplaySubtype:TCalendarDisplaySubtype; public function SetByDateInCE(Y,M,D,h,m,s:Integer):Boolean; function GetAsDateInCE(var Y,M,D,h,m,s:Integer):Boolean; function DisplayStr:String; function SetByDateInJewishCalendar( ... ); property BaseDateTime:TDateTime read FDateTime write FDateTime; property JulianDayNumber:Integer read GetJulianDayNumber write SetJulianDayNumber; property CalendarDisplaySubType:TCalendarDisplaySubtype; end; I see no reason to STORE both the julian day number, and the TDateTime, just use a constant, subtract/add from the Trunc(FBaseDateTime) value, and return that, in the GetJulianDayNumber,SetJulianDayNumber functions. It might be worth having fields where you calculate the year, month, day, for the given calendar, once, and store them, making the display as string function much simpler and faster. Update: It looks like you're better at ER Modelling than me, so if you posted that diagram, I'd upvote it, and that would be it. As for me, I'd be storing three fields; A Datetime field that is normalized to modern calendar standards, a text field (free form) containing the original scholarly date in whatever form, and a few other fields, that are subtype lookup table Foreign keys, to help me organize, and search on dates by the date and subtype. That would be IT for me.
