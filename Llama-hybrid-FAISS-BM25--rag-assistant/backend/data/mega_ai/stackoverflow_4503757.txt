[site]: stackoverflow
[post_id]: 4503757
[parent_id]: 
[tags]: 
When implementing time-constrained methods, should I abort the worker thread or let it run its course?

I'm currently writing a web services based front-end to an existing application. To do that, I'm using the WCF LOB Adapter SDK , which allows one to create custom WCF bindings that expose external data and operations as web services. The SDK provides a few interfaces to implement, and some of their methods are time-constrained: the implementation is expected to complete its work within a specified timespan or throw a TimeoutException . Investigations led me to the question " Implement C# Generic Timeout ", which wisely advises to use a worker thread. Armed with that knowledge, I can write: public MetadataRetrievalNode[] Browse(string nodeId, int childStartIndex, int maxChildNodes, TimeSpan timeout) { Func work = () => { // Return computed metadata... }; IAsyncResult result = work.BeginInvoke(null, null); if (result.AsyncWaitHandle.WaitOne(timeout)) { return work.EndInvoke(result); } else { throw new TimeoutException(); } } However, the consensus is not clear about what to do with the worker thread if it times out. One can just forget about it, like the code above does, or one can abort it: public MetadataRetrievalNode[] Browse(string nodeId, int childStartIndex, int maxChildNodes, TimeSpan timeout) { Thread workerThread = null; Func work = () => { workerThread = Thread.CurrentThread; // Return computed metadata... }; IAsyncResult result = work.BeginInvoke(null, null); if (result.AsyncWaitHandle.WaitOne(timeout)) { return work.EndInvoke(result); } else { workerThread.Abort(); throw new TimeoutException(); } } Now, aborting a thread is widely considered as wrong . It breaks work in progress, leaks resources, messes with locking and does not even guarantee the thread will actually stop running. That said, HttpResponse.Redirect() aborts a thread every time it's called, and IIS seems to be perfectly happy with that. Maybe it's prepared to deal with it somehow. My external application probably isn't. On the other hand, if I let the worker thread run its course, apart from the resource contention increase (less available threads in the pool), wouldn't memory be leaked anyway, because work.EndInvoke() never gets called? More specifically, wouldn't the MetadataRetrievalNode[] array returned by work remain around forever? Is this only a matter of choosing the lesser of two evils, or is there a way not to abort the worker thread and still reclaim the memory used by BeginInvoke() ?
