[site]: stackoverflow
[post_id]: 2136083
[parent_id]: 2135863
[tags]: 
In my opinion, when it comes to potentially complex rules-based string matching and replacing - you can't get much better than a Regex-based solution (despite the fact that they are so hard to read!). This offers the best performance and memory efficiency, in my opinion - you'll be surprised at just how fast this'll be. I'd use the Regex.Replace overload that accepts an input string, regex pattern and a MatchEvaluator delegate . A MatchEvaluator is a function that accepts a Match object as input and returns a string replacement. Here's the code: public static string Capitalise(string input) { //now the first character return Regex.Replace(input, @"(? { return match.Value.ToUpper(); }); } The regex uses the (? [.;:] bit you can add the extra ones you want (e.g. [.;:?."] to add ? and " characters. This means, also, that your MatchEvaluator doesn't have to do any unnecessary string joining (which you want to avoid for performance reasons). All the other stuff mentioned by one of the other answerers about using the RegexOptions.Compiled is also relevant from a performance point of view. The static Regex.Replace method does offer very similar performance benefits, though (there's just an additional dictionary lookup). Like I say - I'll be surprised if any of the other non-regex solutions here will work better and be as fast. EDIT Have put this solution up against Ahmad's as he quite rightly pointed out that a look-around might be less efficient than doing it his way. Here's the crude benchmark I did: public string LowerCaseLipsum { get { //went to lipsum.com and generated 10 paragraphs of lipsum //which I then initialised into the backing field with @"[lipsumtext]".ToLower() return _lowerCaseLipsum; } } [TestMethod] public void CapitaliseAhmadsWay() { List results = new List (); DateTime start = DateTime.Now; Regex r = new Regex(@"(^|\p{P}\s+)(\w+)", RegexOptions.Compiled); for (int f = 0; f m.Groups[1].Value + m.Groups[2].Value.Substring(0, 1).ToUpper() + m.Groups[2].Value.Substring(1))); } TimeSpan duration = DateTime.Now - start; Console.WriteLine("Operation took {0} seconds", duration.TotalSeconds); } [TestMethod] public void CapitaliseLookAroundWay() { List results = new List (); DateTime start = DateTime.Now; Regex r = new Regex(@"(? m.Value.ToUpper())); } TimeSpan duration = DateTime.Now - start; Console.WriteLine("Operation took {0} seconds", duration.TotalSeconds); } In a release build, the my solution was about 12% faster than the Ahmad's (1.48 seconds as opposed to 1.68 seconds). Interestingly, however, if it was done through the static Regex.Replace method, both were about 80% slower, and my solution was slower than Ahmad's.
