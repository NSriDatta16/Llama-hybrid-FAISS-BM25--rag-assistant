[site]: stackoverflow
[post_id]: 3735774
[parent_id]: 3732577
[tags]: 
I am going to present two patterns. Both of these patterns are highly scalable in that they can handle hundreds or even thousands of simultaneous work items. You must follow the patterns exactly. Any deviation might result in a race condition between the signaling of the event and the waiting of it. I have presented the patterns in the context of a loop to generalize it, but in your case you would replace the loop with two individual calls to ThreadPool.QueueUserWorkItem . The first pattern requires the CountdownEvent class which is available in .NET 4.0 or as part of the Reactive Extensions download. var finished = new CountdownEvent(1); for (int i = 0; i { try { // Your work item code goes here. // Call Count, Count2, or whatever. } finally { finished.Signal(); } }); } finished.Signal(); finished.WaitOne(); The following pattern will work with any version of the .NET Framework 1 . It is not as elegant though. int count = 1; var finished = new ManualResetEvent(false); for (int i = 0; i { try { // Your work item code goes here. // Call Count, Count2, or whatever. } finally { if (Interlocked.Decrement(ref count) == 0) finished.Set(); } }); } if (Interlocked.Decrement(ref count) == 0) finished.Set(); finished.WaitOne(); 1 Naturally you would have to replace the lambda expression with an anonymous method or even a real method if using much earlier versions.
