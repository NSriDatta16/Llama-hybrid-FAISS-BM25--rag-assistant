[site]: stackoverflow
[post_id]: 3832428
[parent_id]: 3832290
[tags]: 
My first thought is, if you are statically linking a dll, it isnt a plugin. Just put the dll in the EXE folder and be done with it. That is the deployment configuration supported by windows for statically loaded DLLs. That said, there are ways to achieve what you want. But they are mostly stupid, or complicated for no good reason: Your options are: Don't statically link. Use LoadLibrary("plugins/Plugin.dll") & GetProcAddress to access plugin content. Add "the path to your plugins folder" to the systems PATH environment variable. Use the delay load mechanism to delay accessing the plugins functionality, set a custom helper function that can load the dll(s) using a provided path. Turn the plugins folder into an assembly (by creating a .manifest file in it that lists the plugin.dll). Add "plugins" as a dependent assembly to your app. Now it will look in the plugins folder. Split your application into a stub exe and a dynamically loaded part. In the stub exe call SetDllDirectory to point to the plugin folder, then call LoadLibrary passing the full path to "appstub.dll". To turn a folder, with one or more dll's into an "assembly", simply add a file to the folder with the folders name.manifest. So, plugins.manifest :- It is a VERY good idea to ensure that the folder and the dll's name is different as if the dll name is the assembly name windows starts looking at its embedded manifest file for information about the assembly. Assuming you are using Visual Studio 7 or later, the following directive added to a .c/.cpp or .h file in the project will then make your application attempt to load dlls from the assembly rather than just the local directory: #pragma comment(linker, "/manifestdependency:\"name='Plugins' "\ "processorArchitecture='*' version='1.0.0.0' "\ "type='win32'\"")
