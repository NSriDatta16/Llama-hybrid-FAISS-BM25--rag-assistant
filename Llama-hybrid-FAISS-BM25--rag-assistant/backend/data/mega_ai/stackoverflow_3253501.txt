[site]: stackoverflow
[post_id]: 3253501
[parent_id]: 1694717
[tags]: 
Funny how most of these answers do nothing but try to put the matter of iterating over an array more elegantly, when that's not even what GeorgeG needs. Assuming you have a huge JSON, you want something fast. Iterating is not that. You need jOrder ( http://github.com/danstocker/jorder ), that does search 100 times faster on a 1000 row table than iterative filtering. The bigger the table the higher the ratio. Here's what you do. Since jOrder can't handle more than one inequality filter at a time you'll have to do it in three steps but it will still be magnitudes faster. First, create a jOrder table based on your raw data, and add a price index on it: var table = jOrder(data.homes) .index('price', ['price'], { ordered: true, grouped: true, type: jOrder.number }); You can re-use this table in future searches. Now you start by getting the price filtered results, and wrapping it in another jOrder table, and finally adding a bathroom index: var price_filtered = jOrder(table.where([{ price: { lower: 150000, upper: 400000 } }])) .index('bathrooms', ['num_of_baths'], { ordered: true, grouped: true, type: jOrder.number }); Then we go on by doing the same for bathrooms, adding an index on bedrooms, which doesn't have to be ordered since we won't use inequality filters here: var bath_filtered = jOrder(price_filtered.where([{ num_of_baths: { lower: 2.5 } }])) .index('bedrooms', ['num_of_beds'], { grouped: true }); Finally, you get the fully filtered set by: var filtered = jOrder(bath_filtered.where([{ num_of_beds: 1 }, { num_of_beds: 3 }])); Of course you can wrap all this into a function that takes the three arguments: { price: { lower: 150000, upper: 400000 } } { num_of_baths: { lower: 2.5 } } [{ num_of_beds: 1 }, { num_of_beds: 3 }] and returns filtered .
