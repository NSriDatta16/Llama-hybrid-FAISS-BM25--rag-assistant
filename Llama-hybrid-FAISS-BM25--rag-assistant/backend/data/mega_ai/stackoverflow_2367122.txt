[site]: stackoverflow
[post_id]: 2367122
[parent_id]: 
[tags]: 
All valid combinations of points, in the most (speed) effective way

I know there are quite some questions out there on generating combinations of elements, but I think this one has a certain twist to be worth a new question: For a pet proejct of mine I've to pre-compute a lot of state to improve the runtime behavior of the application later. One of the steps I struggle with is this: Given N tuples of two integers (lets call them points from here on, although they aren't in my use case. They roughly are X/Y related, though) I need to compute all valid combinations for a given rule. The rule might be something like "Every point included excludes every other point with the same X coordinate" "Every point included excludes every other point with an odd X coordinate" I hope and expect that this fact leads to an improvement in the selection process, but my math skills are just being resurrected as I type and I'm unable to come up with an elegant algorithm. The set of points (N) starts small, but outgrows 64 soon (for the "use long as bitmask" solutions) I'm doing this in C#, but solutions in any language should be fine if it explains the underlying idea Thanks. Update in response to Vlad's answer: Maybe my idea to generalize the question was a bad one. My rules above were invented on the fly and just placeholders. One realistic rule would look like this: "Every point included excludes every other point in the triagle above the chosen point" By that rule and by choosing (2,1) I'd exclude (2,2) - directly above (1,3) (2,3) (3,3) - next line and so on So the rules are fixed, not general. They are unfortunately more complex than the X/Y samples I initially gave.
