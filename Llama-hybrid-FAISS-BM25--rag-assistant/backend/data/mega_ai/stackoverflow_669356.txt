[site]: stackoverflow
[post_id]: 669356
[parent_id]: 666374
[tags]: 
If you typically retrieve all (or most) the data for one entity Id you should consider making the index just entity id and not (entity_id,date_id) -- unless you need the database to do unique checks. The effect is to make the index smaller so you get more of it in memory. Your goal should be to get the index to be in memory. Even if you need to do SELECT..ORDER BY DATE you will find that MySQL can order 3650 values in a fraction of a second on the fly (without the index). This issue is the time to read the rows from disk. However your main performance issue is that the INSERTs result in data for one entity spread out across the disk requiring a disk access of each (entity,date) which will make your query run at a few hundred rows per second. Your partitioning wont help this becaause each entity is in a single partition and the rows are spread across its disk. (RAID0 on the disks will help a bit). To get efficient retrieval you need to get the data for a entity to be contiguous on disk, which means reordering the data from the INSERT order. You can do this with MySQL ALTER TABLE.. ORDER BY ... but it takes forever. I have had a 182M row table doing a ALTER TABLE.. ORDER BY running for the last 2 weeks and it hasn't finished yet. That's why I wrote a custom storage engine! By the way, I'm not sure that you gain anything at all by partitioning unless you are partitioning across multiple servers -- or at least multiple disks. The hard work that MySQL has to do isn't made any easier by partitioning. It's all about disk access times. Putting each partition on a different disk might help. I would not have more than twice as many partitions as you have physical disks. 2 times, rather than 1 times, would give some queuing benefits, but I doubt that would have much effect. I doubt you get much better than a single non-partitioned table using RAID0 across as many disks as you can. The performance of this application is determined by the number of disk seeks, and therefore helped if you can do more seeks per second. You gain some processing parallelism (assuming you have multiple processors) with partitioning but your system is going to be I/O bound, not processor bound. If you get your processor utilization as high as 2% you are probably doing something you don't need do (or something that isn't your application). I have been writing, optimizing and operating this kind of application for the nine years using MySQL ... and I have all the scars you might expect from the experience. Once your data is vastly larger than the size of your memory (which is my definition of "huge"), the entire performance issue is Disk I/O which means primary the number of disk seeks . Good luck!!
