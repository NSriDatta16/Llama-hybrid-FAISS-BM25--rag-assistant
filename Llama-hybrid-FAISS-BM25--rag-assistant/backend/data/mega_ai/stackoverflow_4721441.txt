[site]: stackoverflow
[post_id]: 4721441
[parent_id]: 4720218
[tags]: 
I exceeded the character limit on my original answer with this unit, so here it is in a separate answer. {=============================================================================== Copyright Â© BJM Software http://www.bjmsoftware.com ===============================================================================} unit BaseTree_fr; interface uses Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, Dialogs, StdCtrls, ExtCtrls, ImgList, VirtualTrees, Contnrs , DomainObject_intf, Base_fr ; type RTreeData = record CDO: TCustomDomainObject; end; PTreeData = ^RTreeData; TBaseTreeEvent = procedure of object; TCDONodeList = class(TObject) private FCDOs: TObjectList; FNodes: TList; protected public constructor Create; destructor Destroy; override; procedure Add(ACDO: TCustomDomainObject; ANode: PVirtualNode); procedure Clear; function IndexOfCDO(ACDO: TCustomDomainObject): Integer; function NodeOf(ACDO: TCustomDomainObject): PVirtualNode; procedure Remove(ACDO: TCustomDomainObject); procedure InvalidateNodeFor(ACDO: TCustomDomainObject; AEvent: TCDOEvent); function IndexOfNode(ANode: PVirtualNode): Integer; function CDOOf(ANode: PVirtualNode): TCustomDomainObject; procedure InvalidateNode(ANode: PVirtualNode); end; TBaseTreeFrame = class(TBaseFrame, ICDOObserver) Frame_Vst: TVirtualStringTree; procedure Frame_VstGetImageIndex(Sender: TBaseVirtualTree; Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex; var Ghosted: Boolean; var ImageIndex: Integer); procedure Frame_VstGetText(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType; var CellText: WideString); procedure Frame_VstFocusChanged(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex); procedure Frame_VstDblClick(Sender: TObject); procedure Frame_VstInitNode(Sender: TBaseVirtualTree; ParentNode, Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates); procedure Frame_VstInitChildren(Sender: TBaseVirtualTree; Node: PVirtualNode; var ChildCount: Cardinal); procedure Frame_VstCompareNodes(Sender: TBaseVirtualTree; Node1, Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer); procedure Frame_VstChecked(Sender: TBaseVirtualTree; Node: PVirtualNode); private FNodeCheckType: TCheckType; FOnCDOChanged: TCDONotifyEvent; FOnDoubleClicked: TCDONotifyEvent; FOnSelectionChanged: TCDONotifyEvent; FOnShowColumnHeaders: TBaseTreeEvent; protected FNodeList: TCDONodeList; procedure ClearFrame; override; procedure ClearHeaders; override; function FindParentNode(ACDO: TCustomDomainObject; AParent: TCustomDomainObject): PVirtualNode; function GetImageIndexFor(ACDO: TCustomDomainObject; Selected: boolean): Integer; virtual; procedure ShowDobs(ACDO: TCustomDomainObject; AParent: TCustomDomainObject); override; procedure ShowDomainObject(ACDO: TCustomDomainObject; AParent: TCustomDomainObject); override; procedure RemoveDomainObject(ACDO: TCustomDomainObject; AParent: TCustomDomainObject); procedure SetCDO(const Value: TCustomDomainObject); override; function ShowChildrenOfList(AFromCDO: TCustomDomainObject): TCustomDomainObject; virtual; procedure UpdateCDO(ACDO: TCustomDomainObject; AEvent: TCDOEvent); procedure HandleDoubleClicked(ACDO: TCustomDomainObject); virtual; procedure HandleSelectionChanged(ACDO: TCustomDomainObject); virtual; procedure DoCDOChanged(ACDO: TCustomDomainObject); procedure DoDoubleClicked(ACDO: TCustomDomainObject); procedure DoSelectionChanged(ACDO: TCustomDomainObject); procedure DoShowColumnHeaders; procedure BeginLoad; override; procedure EndLoad; override; procedure ShowColumnHeaders; override; procedure AddDomainObject(ACDO: TCustomDomainObject; AParent: TCustomDomainObject); public constructor Create(AOwner: TComponent); override; destructor Destroy; override; procedure CheckAll; function CheckedCount: integer; procedure FocusOn(ACDO: TCustomDomainObject); function GetTree: TCustomDomainObject; function GetSelection: TCustomDomainObject; procedure UncheckAll; property NodeCheckType: TCheckType read FNodeCheckType write FNodeCheckType; property OnCDOChanged: TCDONotifyEvent read FOnCDOChanged write FOnCDOChanged; property OnDoubleClicked: TCDONotifyEvent read FOnDoubleClicked write FOnDoubleClicked; property OnSelectionChanged: TCDONotifyEvent read FOnSelectionChanged write FOnSelectionChanged; property OnShowColumnHeaders: TBaseTreeEvent read FOnShowColumnHeaders write FOnShowColumnHeaders; end; implementation {$R *.dfm} uses BaseGUIApp_fm , DomainObject_cls , GUIApplication_cls ; constructor TCDONodeList.Create; begin FCDOs := TObjectList.Create( false ); FNodes := TList.Create; end; destructor TCDONodeList.Destroy; begin FCDOs.Free; FNodes.Free; inherited; end; procedure TCDONodeList.Add(ACDO: TCustomDomainObject; ANode: PVirtualNode); begin FCDOs.Add( ACDO ); FNodes.Add( ANode ); end; function TCDONodeList.CDOOf(ANode: PVirtualNode): TCustomDomainObject; var Idx: integer; begin Idx := FNodes.IndexOf( ANode ); if Idx = -1 then begin Result := nil; end else begin Result := TCustomDomainObject( FCDOs[Idx] ); end; end; function TCDONodeList.IndexOfCDO(ACDO: TCustomDomainObject): Integer; begin Result := FCDOs.IndexOf( ACDO ); end; function TCDONodeList.IndexOfNode(ANode: PVirtualNode): Integer; begin Result := FNodes.IndexOf( ANode ); end; procedure TCDONodeList.InvalidateNode(ANode: PVirtualNode); var Tree: TBaseVirtualTree; begin Tree := TreeFromNode( ANode ); Tree.InvalidateNode( ANode ); end; procedure TCDONodeList.InvalidateNodeFor(ACDO: TCustomDomainObject; AEvent: TCDOEvent); var Idx: integer; Node: PVirtualNode; Tree: TBaseVirtualTree; begin Idx := FCDOs.IndexOf( ACDO ); if Idx > -1 then begin // Just in case Node := PVirtualNode( FNodes[Idx] ); Tree := TreeFromNode( Node ); Tree.InvalidateNode( Node ); end; end; function TCDONodeList.NodeOf(ACDO: TCustomDomainObject): PVirtualNode; var Idx: integer; begin Idx := FCDOs.IndexOf( ACDO ); if Idx = -1 then begin Result := nil; end else begin Result := PVirtualNode( FNodes[Idx] ); end; end; procedure TCDONodeList.Remove(ACDO: TCustomDomainObject); begin FNodes.Delete( FCDOs.Remove( ACDO ) ); end; procedure TBaseTreeFrame.ClearFrame; begin inherited; Frame_Vst.Clear; FNodeList.Clear; DoSelectionChanged( nil ); end; constructor TBaseTreeFrame.Create(AOwner: TComponent); begin FNodeList := TCDONodeList.Create; inherited; Frame_Vst.DefaultText := ''; Frame_Vst.DragOperations := []; Frame_Vst.NodeDataSize := SizeOf( RTreeData ); // // This is causing heavy recursions and InitNode executions!!! // Frame_Vst.TreeOptions.AutoOptions := Frame_Vst.TreeOptions.AutoOptions // + [toAutoSort]; Frame_Vst.TreeOptions.MiscOptions := Frame_Vst.TreeOptions.MiscOptions - [toEditable] + [toCheckSupport{, toReadOnly}] ; Frame_Vst.TreeOptions.PaintOptions := Frame_Vst.TreeOptions.PaintOptions - [toHideFocusRect, toHideSelection]; Frame_Vst.TreeOptions.SelectionOptions := Frame_Vst.TreeOptions.SelectionOptions // - [] + [toFullRowSelect] ; Frame_Vst.Images := TBaseGUIAppForm( GUIApp.MainForm ).Images; Frame_Vst.Header.Images := TBaseGUIAppForm( GUIApp.MainForm ).HeaderImages; Frame_Vst.NodeDataSize := sizeof( RTreeData ); end; destructor TBaseTreeFrame.Destroy; begin FNodeList.Free; inherited; end; procedure TBaseTreeFrame.RemoveDomainObject(ACDO: TCustomDomainObject; AParent: TCustomDomainObject); var Node: PVirtualNode; begin Node := FNodeList.NodeOf( ACDO ); if Node <> nil then begin FNodeList.Remove( ACDO ); Frame_Vst.DeleteNode( Node ); end; end; procedure TBaseTreeFrame.SetCDO(const Value: TCustomDomainObject); begin if Value <> FCDO then begin if FCDO <> nil then begin FCDO.DetachObserver( self ); end; inherited; if FCDO <> nil then begin FCDO.AttachObserver( self ); end; end; end; procedure TBaseTreeFrame.ShowDomainObject(ACDO: TCustomDomainObject; AParent: TCustomDomainObject); begin // We are dealing with a virtual tree that asks for its data, and so we don't // need to do anything here. end; procedure TBaseTreeFrame.UpdateCDO(ACDO: TCustomDomainObject; AEvent: TCDOEvent); //var // Node: PVirtualNode; begin if ACDO = CDO then begin // Root that isn't shown. end else begin case AEvent of ceAddedToList: begin AddDomainObject( ACDO, ACDO.Container ); FocusOn( ACDO ); end; ceSaved: begin FNodeList.InvalidateNodeFor( ACDO, AEvent ); DoCDOChanged( ACDO ); end; ceRemovedFromList: begin RemoveDomainObject( ACDO, ACDO.Container ); end; // ceCheckStateChanged: begin // FNodeList.InvalidateNodeFor( ACDO, AEvent ); // end; (* ceListReloaded: begin Node := FNodeList.NodeOf( ACDO ); Frame_Vst.ReInitNode( Node, true ); // FNodeList.InvalidateNodeFor( ACDO, AEvent ); end; *) end; end; end; procedure TBaseTreeFrame.Frame_VstGetImageIndex(Sender: TBaseVirtualTree; Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex; var Ghosted: Boolean; var ImageIndex: Integer); var ACDO: TCustomDomainObject; NodeData: ^RTreeData; begin inherited; Case Column of -1, 0 : begin NodeData := Sender.GetNodeData( Node ); ACDO := NodeData.CDO; case Kind of ikState: ImageIndex := -1; ikNormal: ImageIndex := GetImageIndexFor( ACDO, false ); ikSelected: ImageIndex := GetImageIndexFor( ACDO, true ); ikOverlay: ImageIndex := -1; else ImageIndex := -1; end; end; else end; end; procedure TBaseTreeFrame.Frame_VstGetText(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType; var CellText: WideString); begin inherited; // Should be abstract. end; procedure TBaseTreeFrame.Frame_VstFocusChanged(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex); var ACDO: TCustomDomainObject; NodeData: ^RTreeData; begin inherited; NodeData := Sender.GetNodeData( Node ); ACDO := NodeData.CDO; HandleSelectionChanged( ACDO ); end; procedure TBaseTreeFrame.HandleSelectionChanged(ACDO: TCustomDomainObject); begin DoSelectionChanged( ACDO ); end; function TBaseTreeFrame.GetSelection: TCustomDomainObject; var Node: PVirtualNode; NodeData: ^RTreeData; begin Node := Frame_Vst.FocusedNode; if Node = nil then begin Result := nil; end else begin NodeData := Frame_Vst.GetNodeData( Node ); Result := NodeData.CDO; end; end; procedure TBaseTreeFrame.DoSelectionChanged(ACDO: TCustomDomainObject); begin if assigned( FOnSelectionChanged ) then begin FOnSelectionChanged( ACDO ); end; end; procedure TBaseTreeFrame.DoCDOChanged(ACDO: TCustomDomainObject); begin if assigned( FOnCDOChanged ) then begin FOnCDOChanged( ACDO ); end; end; procedure TBaseTreeFrame.Frame_VstDblClick(Sender: TObject); var ACDO: TCustomDomainObject; NodeData: ^RTreeData; Tree: TBaseVirtualTree; begin inherited; if Sender is TBaseVirtualTree then begin Tree := TBaseVirtualTree( Sender ); if Tree.FocusedNode <> nil then begin NodeData := Tree.GetNodeData( Tree.FocusedNode ); ACDO := NodeData.CDO; HandleDoubleClicked( ACDO ); end; end; end; procedure TBaseTreeFrame.HandleDoubleClicked(ACDO: TCustomDomainObject); begin DoDoubleClicked( ACDO ); end; procedure TBaseTreeFrame.DoDoubleClicked(ACDO: TCustomDomainObject); begin if assigned( FOnDoubleClicked ) then begin FOnDoubleClicked( ACDO ); end; end; procedure TBaseTreeFrame.BeginLoad; begin inherited; Frame_Vst.BeginUpdate; end; procedure TBaseTreeFrame.EndLoad; begin Frame_Vst.EndUpdate; inherited; end; procedure TBaseTreeFrame.DoShowColumnHeaders; begin if assigned( FOnShowColumnHeaders ) then begin FOnShowColumnHeaders; end; end; procedure TBaseTreeFrame.ShowColumnHeaders; begin inherited; DoShowColumnHeaders; end; procedure TBaseTreeFrame.ClearHeaders; begin inherited; Frame_Vst.Header.Columns.Clear; end; procedure TCDONodeList.Clear; begin FCDOs.Clear; FNodes.Clear; end; function TBaseTreeFrame.GetImageIndexFor(ACDO: TCustomDomainObject; Selected: boolean): Integer; begin // Should be abstract. Result := -1; end; procedure TBaseTreeFrame.ShowDobs(ACDO, AParent: TCustomDomainObject); begin // We are dealing with a virtual tree that asks for its data, so we don't // need to do anything here. inherited; if CDO <> nil then begin Frame_Vst.RootNodeCount := CDO.CDOCount; end else begin Frame_Vst.RootNodeCount := 0; end; end; procedure TBaseTreeFrame.Frame_VstInitNode(Sender: TBaseVirtualTree; ParentNode, Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates); var ParentNodeData: ^RTreeData; ParentNodeCDO: TCustomDomainObject; NodeData: ^RTreeData; ChildCDO: TCustomDomainObject; ChildCDOCount: Cardinal; begin // Attach CDO to Node, but wich CDO??? // And tell Node whether it can have children. We don't care yet how many. inherited; if ParentNode = nil then begin ParentNodeCDO := CDO; end else begin ParentNodeData := Frame_Vst.GetNodeData( ParentNode ); ParentNodeCDO := ParentNodeData.CDO; end; NodeData := Frame_Vst.GetNodeData( Node ); if NodeData.CDO = nil then begin ChildCDO := ShowChildrenOfList( ParentNodeCDO ); if ( ChildCDO <> nil ) then begin // Prevent warning on comparing signed/unsiged types. ChildCDOCount := ChildCDO.CDOCount; if ( ChildCDOCount > Node.Index ) then begin // if ChildCDO is TDomainObject then begin // NodeData.CDO := ParentNodeCDO.CDO[Node.Index]; // end else if NodeData.CDO is TDomainObjectList then begin NodeData.CDO := ChildCDO.CDO[Node.Index]; // end; FNodeList.Add( NodeData.CDO, Node ); end; end; end else begin // CDO is already set when node was added through AddDomainObject. end; Node.CheckType := NodeCheckType; Sender.CheckState[Node] := csUncheckedNormal; end; procedure TBaseTreeFrame.Frame_VstInitChildren(Sender: TBaseVirtualTree; Node: PVirtualNode; var ChildCount: Cardinal); begin inherited; // This is called when user has clicked on a plus sign. // We only need to tell the tree for how many children to prepare. { TODO -cWishList : This could be defaulted to something like var NodeData: ^RTreeData; begin inherited; NodeData := Sender.GetNodeData( Node ); ChildCount := 0; if NodeData.CDO is TCustomDomainObjectList then begin ChildCount := NodeData.CDO.CDOCount; end; } end; procedure TBaseTreeFrame.AddDomainObject(ACDO: TCustomDomainObject; AParent: TCustomDomainObject); var Node: PVirtualNode; NodeData: ^RTreeData; ParentNode: PVirtualNode; begin inherited; Node := FNodeList.NodeOf( ACDO ); ParentNode := FindParentNode( ACDO, AParent ); if Node = nil then begin Frame_Vst.BeginUpdate; // Prevent auto sorting try if ParentNode = nil then begin // we need the tree's root ParentNode := Frame_Vst.RootNode; Frame_Vst.RootNodeCount := Frame_Vst.RootNodeCount + 1; end else begin Frame_Vst.ChildCount[ParentNode] := Frame_Vst.ChildCount[ParentNode] + 1; end; Node := Frame_Vst.GetLastChild( ParentNode ); finally Frame_Vst.EndUpdate; end; NodeData := Frame_Vst.GetNodeData( Node ); NodeData.CDO := ACDO; FNodeList.Add( ACDO, Node ); end else begin // it exists, so nothing to do. end; end; procedure TBaseTreeFrame.Frame_VstCompareNodes(Sender: TBaseVirtualTree; Node1, Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer); var Node1Data: ^RTreeData; Node2Data: ^RTreeData; Node1CDO: TCustomDomainObject; Node2CDO: TCustomDomainObject; begin inherited; Node1Data := Frame_Vst.GetNodeData( Node1 ); Node2Data := Frame_Vst.GetNodeData( Node2 ); Node1CDO := Node1Data.CDO; Node2CDO := Node2Data.CDO; // if ( Node1CDO = nil ) or ( Node2CDO = nil ) then begin Result := 0; end else if ( Node1CDO is TDomainObjectList ) <> ( Node2CDO is TDomainObjectList ) then begin if Node1CDO is TDomainObjectList then begin Result := -1; end else begin Result := 1; end; end else begin Result := AnsiCompareText( Node1CDO.SortString, Node2CDO.SortString ); end; end; function TBaseTreeFrame.ShowChildrenOfList(AFromCDO: TCustomDomainObject): TCustomDomainObject; begin // Should be abstract? Result := AFromCDO; end; procedure TBaseTreeFrame.FocusOn(ACDO: TCustomDomainObject); var FocusOnNode: PVirtualNode; begin FocusOnNode := FNodeList.NodeOf( ACDO ); if FocusOnNode <> nil then begin Frame_Vst.FocusedNode := FocusOnNode; Frame_Vst.ClearSelection; Frame_Vst.Selected[FocusOnNode] := true; end; end; function TBaseTreeFrame.FindParentNode(ACDO, AParent: TCustomDomainObject): PVirtualNode; begin Result := FNodeList.NodeOf( AParent ); if Result = nil then begin if AParent.Container <> nil then begin Result := FindParentNode( AParent, AParent.Container ); end; end; end; function TBaseTreeFrame.GetTree: TCustomDomainObject; begin Result := CDO; end; procedure TBaseTreeFrame.CheckAll; var Run: PVirtualNode; begin Frame_Vst.BeginUpdate; try Run := Frame_Vst.GetFirstVisible; while Assigned( Run ) do begin Run.CheckState := csCheckedNormal; Run := Frame_Vst.GetNextVisible( Run ); end; GetTree.CheckAll; finally Frame_Vst.EndUpdate; end; end; procedure TBaseTreeFrame.UncheckAll; var Run: PVirtualNode; begin Frame_Vst.BeginUpdate; try Run := Frame_Vst.GetFirstVisible; while Assigned( Run ) do begin Run.CheckState := csUncheckedNormal; Run := Frame_Vst.GetNextVisible( Run ); end; GetTree.UncheckAll; finally Frame_Vst.EndUpdate; end; end; function TBaseTreeFrame.CheckedCount: integer; var Run: PVirtualNode; begin Result := 0; Run := Frame_Vst.GetFirstVisible; while Assigned( Run ) do begin if Run.CheckState in [csCheckedNormal, csCheckedPressed] then begin inc( Result ); end; Run := Frame_Vst.GetNextVisible( Run ); end; end; procedure TBaseTreeFrame.Frame_VstChecked(Sender: TBaseVirtualTree; Node: PVirtualNode); var ACDO: TCustomDomainObject; NodeData: ^RTreeData; begin inherited; NodeData := Sender.GetNodeData( Node ); ACDO := NodeData.CDO; if ACDO <> nil then begin ACDO.Checked := ( Node.CheckState in [csCheckedNormal, csCheckedPressed] ); end; end; end.
