[site]: stackoverflow
[post_id]: 142253
[parent_id]: 141970
[tags]: 
Honestly, it sounds like you really want these Column s to be classes, but don't want to pay the runtime cost associated with classes, so you're trying to make them be structs. I don't think you're going to find an elegant way to do what you want. Structs are supposed to be value types, and you want to make them behave like reference types. You cannot efficiently store your Columns in an array of IColumn s, so no array approach is going to work well. The compiler has no way to know that the IColumn array will only hold structs, and indeed, it wouldn't help if it did, because there are still different types of structs you are trying to jam in there. Every time someone calls AcceptChanges() or HasChanges() , you're going to end up boxing and cloning your structs anyway, so I seriously doubt that making your Column a struct instead of a class is going to save you much memory. However, you could probably store your Column s directly in an array and index them with an enum. E.g: public class Record { public enum ColumnNames { ID = 0, Name, Date, Int, NumCols }; private IColumn [] columns; public Record() { columns = new IColumn[ColumnNames.NumCols]; columns[ID] = ... } public bool HasChanges { get { bool has = false; for (int i = 0; i I don't have a C# compiler handy, so I can't check to see if that will work or not, but the basic idea should work, even if I didn't get all the details right. However, I'd just go ahead and make them classes. You're paying for it anyway.
