[site]: stackoverflow
[post_id]: 3667288
[parent_id]: 3666986
[tags]: 
In architectures like CQRS there isn't need for such a conversion at all cause read & write sides of app are separated. But in Your case, You can't runaway from translation. First of all - You should be more specific when defining repositories. Repository signature is thing You want to keep explicit instead of generic. Common example to show this idea - can You tell what indexes You need in Your database when You look at Your repository signature (maybe looking at repository implementation, but certainly w/o looking at client code)? You can't. Cause it's too generic and client side can search by anything. In Your example it's a bit better cause expression genericness is tied with dto instead of entity. This is what I do (using NHibernate.Linq, but the idea remains) public class Application{ public Project Project {get;set;} } public class ApplicationRepository{ public IEnumerable Search(SearchCriteria inp){ var c=Session.Linq (); var q=c.AsQueryable(); if(!string.IsNullOrEmpty(inp.Acronym)) q=q.Where(a=>a.Project.Acronym.Contains(inp.Acronym)); /*~20 lines of similar code snipped*/ return q.AsQueryable(); } } //used by client public class SearchCriteria{ public string Acronym{get;set;} /*some more fields that defines how we can search Applications*/ } If You do want to keep Your expressions, one way would be to define dictionary manually like this: var d=new Dictionary >, Expression >{ {x=>x.DtoPropNumberOne,x=>x.EntityPropNumberOne} /*, {2}, {3}, etc.*/ }; And use it later: //can You spot it? //client does not know explicitly what expressions dictionary contains _dataModel.Videos.Where(d[exp]).ToList (); //and I'm not 100% sure checking expression equality would actually work If You don't want to write mapping dictionary manually, You will need some advanced techniques. One idea would be to translate dto expression to string and then back to entity expression. Here are some ideas (sorting related though) that might help. Expressions are quite complicated beasts. Anyway - as I said, You should avoid this. Otherwise - You will produce really fragile code.
