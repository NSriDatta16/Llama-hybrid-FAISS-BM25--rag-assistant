[site]: stackoverflow
[post_id]: 4425026
[parent_id]: 
[tags]: 
Resultset from MySql using Java/Spring is empty, and it should not have been

I am building code to access a database using Spring and Java from my standard dataobjects. My local setup uses a MySQL-installation, for simplicity. I have been able to perform inserts fine using my code, but I cannot get data out of select-operations... I have a table in MySql. The database is called jonathan, the table is called Project, and it has an id column in it. There was originally one row, but I have now inserted three rows in the table, which have been inserted using my java/spring-code. I have singled out my problem and condensed the testing of the particular problem here, I have removed any where-clause to make sure there is no parameter-mapping problem involved. I have debugged the code to make sure I do receive a datasource. public class TestDb extends MappingSqlQuery { public TestDb() { super(StorageFactory.getDataSource(), "Select id from jonathan.Project"); } @Override protected Object mapRow(ResultSet arg0, int arg1) throws SQLException { System.out.println(arg1+" rows"); for(int i=0;i When I test this public static void main(String[] args) { TestDb t = new TestDb(); t.execute(); System.out.println("Test done"); } I get 0 rows Test done I have tried different casings on the table name also. Solution: I confirmed that I could select the data using only jdbc, so the problem was how I accessed the results. I found that the following worked: public class TestDb extends MappingSqlQuery { public TestDb() { super(StorageFactory.getDataSource(), "Select id from jonathan.project"); } @Override protected Object mapRow(ResultSet arg0, int arg1) throws SQLException { System.out.println(arg1 + " rows?"); boolean b=arg0.first(); while (b) { System.out.println(arg0.getInt(1)); b=arg0.next(); } return null; } } The print says 0 rows? 100000 100001 100002 Test done I still wonder what arg1 is supposed to give me, because as far as I can tell it always says 0. I expected it to hold the number of rows selected. Also, the documentation for ResultSet says A ResultSet cursor is initially positioned before the first row; the first call to the method next makes the first row the current row; the second call makes the second row the current row, and so on. giving me the idea I could just next() through the whole ResultSet, but if I do first() and then next() it appears to work just fine.
