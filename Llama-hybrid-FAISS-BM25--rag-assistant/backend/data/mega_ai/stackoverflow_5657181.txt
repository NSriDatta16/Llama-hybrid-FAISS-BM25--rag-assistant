[site]: stackoverflow
[post_id]: 5657181
[parent_id]: 
[tags]: 
Use XSLT to pretty print XML/XHTML without corrupting namespace info

I'm trying to use XSLTs (in Javascript) to pretty-print an XHTML doc that has been machine generated. However, the various XSLTs I've tried to use, all mangle the xmlns attributes (see below). Here is a sample of desired output (made by hand from unindented, compact, XHTML). New Form1 .... Here is what I'm getting instead: New Form1 ... Notice the xmlns attributes are altered in the 'h:html' tag in the second code snippet. Also the beginning tag is missing. This is (one of many) XSLTs I've used with similar results: \ Any ideas on what I'm doing wrong? Am I trying to do the impossible? If you're wondering why I'm trying to do this: I have to use GWT as the framework for designing a FormDesigner web app. This is the output, but needs to be human readable for the more technically inclined users that want to do by-hand edits. GWT just doesn't do xml pretty printing (as far as I can tell in my searching so far). Thus, we go native to JS land and try for a solution there. Ideas/solutions would be greatly appreciated! Edit: Here is the Javascript that makes use of the XSLT. I call the beautifyXML() function to actual perform the indentation: //var xsl_string = ' '; // from: http://www.xml.com/pub/a/2006/11/29/xslt-xml-pretty-printer.html?page=3 var xsl_string = ' \ \ \ \ \ \ '; var xsl = (new DOMParser()).parseFromString(xsl_string, "text/xml"); function stringToXml(xml_string) { return (new DOMParser()).parseFromString(xml_string, "text/xml"); } function xmlToString(xml) { return (new XMLSerializer()).serializeToString(xml); } function isParseError(xml) { try { // console.log( xml.documentElement.firstChild.firstChild.tagName); return xml.documentElement.tagName == "parsererror" || xml.documentElement.firstChild.firstChild.tagName == "parsererror"; } catch (ex) { return false; } } function beautifyXml(input) { var xml = stringToXml(input); if (isParseError(xml)) { return input; } var transformedXml = xslTransformation(xml, xsl); return xmlToString(transformedXml); } /** * @param xml * @param xsl */ function xslTransformation(xml, xsl) { // code for IE if (window.ActiveXObject) { var ex = xml.transformNode(xsl); return ex; } // code for Mozilla, Firefox, Opera, etc. else if (document.implementation && document.implementation.createDocument) { var xsltProcessor = new XSLTProcessor(); xsltProcessor.importStylesheet(xsl); var resultDocument = xsltProcessor.transformToFragment(xml, document); return resultDocument; } }
