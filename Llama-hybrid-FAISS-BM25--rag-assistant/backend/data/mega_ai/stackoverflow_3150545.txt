[site]: stackoverflow
[post_id]: 3150545
[parent_id]: 3150381
[tags]: 
1 A generic linked list implementation already exists in the .NET framework: LinkedList . But you already know that; your code wraps it. 2 OK, so you know that. Why would you wrap it, then? The only functionality you appear to have implemented is AddtoList , which doesn't do anything the LinkedList doesn't already do itself (after all, this is only a thin wrapper around LinkedList .AddLast ). What this means is that your GenLinkedList class really doesn't offer the functionality of a linked list; it's basically an add-only collection (which could just as easily have been implemented with a List , or a Stack , or a Queue -- anything, really). 3 Assuming you do have a good reason to wrap a LinkedList (e.g., you're planning to add more functionality down the line that would actually leverage the behavior of a LinkedList and/or -- here's a key ingredient -- you want to restrict the way calling code is able to interact with the list (e.g., no removals)), you really shouldn't expose your LinkedList member at all . The purpose of a wrapper is just that: to wrap. You take an existing class and basically give it a new kind of interface. By exposing the underlying object directly, you cripple your wrapper. Any additional restrictions/validation/logic you have in your wrapper can be bypassed. So, for example, if you want to be able to copy your list to an array, instead of doing this: list.LinkedList.CopyTo(arr,0); You would implement a CopyTo method within your GenLinkedList class (which could simply call _linkedlist.CopyTo ) and use that. But I really think the first question you should be asking yourself is what you want to accomplish by wrapping LinkedList in the first place.
