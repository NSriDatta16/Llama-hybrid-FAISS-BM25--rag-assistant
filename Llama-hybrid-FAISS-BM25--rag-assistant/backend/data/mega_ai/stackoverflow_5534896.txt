[site]: stackoverflow
[post_id]: 5534896
[parent_id]: 5533713
[tags]: 
Your question is very unclear. You are saying that you are generating the code from your schema and in the same time you are asking if there is a way to map it with code first. DbContext API != the code first approach. People should differ between Fluent / Annotations mapping and the code-first approach where the database is generated from the code. If you generate the code from the database you are obviously using the database first approach. Solution for the database-first: Database view but it will make your entity readonly. Imho you should not have problems even if the table changes. If you need just two columns and nobody will change these two columns or create new required columns your mapped enity should still work. If somebody changes your column there will be no effective way to avoid breaking your code. You can also use advanced EDMX features like QueryView (view in mapping description) and DefiningQuery (custom select in storage description) but those are probably overkill for your scenario. Solution for the code-first: Turn off model metadata validation and database initialization. It requires setting initializer to null : // Use this code in the application start up Database.SetInitializer (null); and removing IncludeMetadataConvetion : public class MyContext : DbContext { ... protedte override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Conventions.Remove (); } } In both approaches you can also use custom SQL query or custom linq projection.
