[site]: stackoverflow
[post_id]: 3405980
[parent_id]: 
[tags]: 
Updated DLL causes JNI to throw "Exception c0000005"

Here's my problem. I have a third part DLL (to which I do not have the source) that I have to use JNI to talk to. The people that supply this DLL are not a Java-house. I discovered a bug in their DLL, so wrote some C++ which exercised their DLL, exposed the bug and sent it to them for a fix. I finally got an updated DLL back from them, ran my C++ code (which worked fine) and discovered that bug had indeed been fixed. However, now when I use this new DLL inside my JNI code I get the following exception thrown; Exception c0000005, at 1EEE3416 Access violation: attempting to read memory at address 00000004 Native function stack data: 0,3f49c0,20201,801c6,65637845,6f697470,3063206e,30303030 com.jniwrapper.FunctionExecutionException: c0000005 at com.jniwrapper.Function.invokeCFunc(Native Method) at com.jniwrapper.FunctionCall.a(SourceFile:127) at com.jniwrapper.FunctionCall.call(SourceFile:35) at com.jniwrapper.Function.invoke(SourceFile:188) at com.tme.techdoc3.diagnostic.api.denso.DensoApiInvoker.invoke(DensoApiInvoker.java:78) at com.tme.techdoc3.diagnostic.api.denso.NewDensoApi.invoke(NewDensoApi.java:106) at com.tme.techdoc3.diagnostic.api.denso.NewDensoApi.connect(NewDensoApi.java:46) at ConsoleApiRunner.main(ConsoleApiRunner.java:59) I'm actually using JNIWrapper to provide my JNI code and so to rule their product out as causing a problem I wrote my own JNI code instead; but I still get this same error. This convinces me that the problem is in the third party DLL. I'm getting this exception from the very first function I call on the DLL (incidentally, this function did not have the bug in it...). The place we get the DLL from has expressly said that they will not support it's use in a JNI environment, even so far as they will not send me any kind of release notes or list of changes between the fixed and non-fixed DLLs. Politically, there is nothing I can do about this. Practically, I'm limited to this supplier for the DLL. Can anyone think of any reason why this DLL would work when called from C++ but not when called in JNI? I've been playing with the JNI stack size (-Xss) and some other JVM parameters, but I've either not hit on the right settings yet or I'm looking at the wrong thing. Any ideas are greatly appreciated. Many thanks. EDIT: Adding in my own JNI code to see if someone can spot a mistake. EDIT 2: Corrected code copy-n-paste error. When I use my own JNI code, here's the implementation of the .cpp file I'm using; #include "stdafx.h" #include "windows.h" #include "MyJniApi.h" #include "ThirdParty.h" #pragma comment(lib, "ThirdParty.lib"); ThirdPartyThing* thirdParty; JNIEXPORT jlong JNICALL Java_com_mycompany_jni_MyJniApi_connect(JNIEnv *, jobject) { long connId = 0L; thirdParty = new ThirdPartyThing(); long retval = thirdParty->GetConnection(&connId); if(0 == retval) { return connId; } else { return retval; } } As you can see, it's pretty simple and I can't see any place there when I've got my pointers etc mixed up. (Disclaimer: this is pretty much the sum of me C++ skills!)
