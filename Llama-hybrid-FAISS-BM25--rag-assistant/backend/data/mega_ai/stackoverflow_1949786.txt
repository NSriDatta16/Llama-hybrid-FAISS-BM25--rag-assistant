[site]: stackoverflow
[post_id]: 1949786
[parent_id]: 1945846
[tags]: 
Fact is, in C++, this is somewhat more complicated that the C header/source organization. What does the compiler see? The compiler sees one big source (.cpp) file with its headers properly included. The source file is the compilation unit that will be compiled into an object file. So, why are headers necessary? Because one compilation unit could need information about an implementation in another compilation unit. So one can write for example the implementation of a function in one source, and write the declaration of this function in another source needing to use it. In this case, there are two copies of the same information. Which is evil... The solution is to share some details. While the implementation should remain in the Source, the declaration of shared symbols, like functions, or definition of structures, classes, enums, etc., could need to be shared. Headers are used to put those shared details. Move to the header the declarations of what need to be shared between multiple sources Nothing more? In C++, there are some other things that could be put in the header because, they need, too, be shared: inline code templates constants (usually those you want to use inside switches...) Move to the header EVERYTHING what need to be shared, including shared implementations Does it then mean that there could be sources inside the headers? Yes. In fact, there are a lot of different things that could be inside a "header" (i.e. shared between sources). Forward declarations declarations/definition of functions/structs/classes/templates implementation of inline and templated code It becomes complicated, and in some cases (circular dependencies between symbols), impossible to keep it in one header. Headers can be broken down into three parts This means that, in an extreme case, you could have: a forward declaration header a declaration/definition header an implementation header an implementation source Let's imagine we have a templated MyObject. We could have: // - - - - MyObject_forward.hpp - - - - // This header is included by the code which need to know MyObject // does exist, but nothing more. template class MyObject ; . // - - - - MyObject_declaration.hpp - - - - // This header is included by the code which need to know how // MyObject is defined, but nothing more. #include template class MyObject { public : MyObject() ; // Etc. } ; void doSomething() ; . // - - - - MyObject_implementation.hpp - - - - // This header is included by the code which need to see // the implementation of the methods/functions of MyObject, // but nothing more. #include template MyObject ::MyObject() { doSomething() ; } // etc. . // - - - - MyObject_source.cpp - - - - // This source will have implementation that does not need to // be shared, which, for templated code, usually means nothing... #include void doSomething() { // etc. } ; // etc. Wow! In the "real life", it is usually less complicated. Most code will have only a simple header/source organisation, with some inlined code in the source. But in other cases (templated objects knowing each others), I had to have for each object separate declaration and implementation headers, with an empty source including those headers just to help me see some compilation errors. Another reason to break down headers into separate headers could be to speed up the compilation, limiting the quantity of symbols parsed to the strict necessary, and avoiding unecessary recompilation of a source who cares only for the forward declaration when an inline method implementation changed. Conclusion You should make your code organization both as simple as possible, and as modular as possible. Put as much as possible in the source file. Only expose in headers what needs to be shared. But the day you'll have circular dependancies between templated objects, don't be surprised if your code organization becomes somewhat more "interesting" that the plain header/source organization... ^_^
