[site]: stackoverflow
[post_id]: 3423699
[parent_id]: 3417769
[tags]: 
In my opinion you are talking about implementation details, not about your abstract interfaces and your model. Your interface seems to look like this: public interface ICustomersRepository { //... other methods Boat GetBoat(int id); //... other methods } and the model like this: public class Customer { //... other stuff ICollection Boats; // or another collection type //... other stuff } I my opinion it isn't against any design rules to implement the ICustomerRepository completely different for your SQLCustomersRepository and for your FakeCustomersRepository and to find an implementation which is optimal with respect to your underlying data storage. Since you seem to have a primary key on the Boat table in your SQL-DB I would definitely take advantage of this and implement the first option: return db.Boats.SingleOrDefault(x => x.ID == id); But it's not necessary to have a Boat collection in your FakeCustomersRepository . If it is easier for you just to have a list of Customers and to populate the Boats collection in each Customer with test boats, why not? In this case your GetBoat implementation in the FakeCustomersRepository could be implemented with the second LINQ query you described. Keep in mind that Unit testing in MVC doesn't intend to test your specific Repository implementations but your business logic, and a business action is more a chain of various domain object and repository method calls. If a single repository method does what it is supposed to do (for instance if GetBoat really returns a boat with the correct ID) is more a matter of a later integration test to prove that your database calls work properly.
