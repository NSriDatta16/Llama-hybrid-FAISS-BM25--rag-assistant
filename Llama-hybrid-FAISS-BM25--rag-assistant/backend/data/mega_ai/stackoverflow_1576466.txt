[site]: stackoverflow
[post_id]: 1576466
[parent_id]: 1576409
[tags]: 
It's usually easier to work with implicit rules. There are a lot of predefined ones, where you'll only need to specify variables. CXX=g++ CXXFLAGS=$(UTIL_FLAGS) Then you need to define an executable, like this myutil: $(UTIL_OBJS) Since you're not storing your objects in the same directory, you'll need to specify a new implicit rule as well though (otherwise, we'd be done now). utils/obj/%.o: utils/obj/%.cpp % is a pattern-match, it'll match the same text on both left and right side, so this rule will make foo.o out of foo.cpp. Try if that'll work without the command (it might have grabbed that from another rule, I'm not sure), otherwise let it say: utils/obj/%.o: utils/obj/%.cpp $(CXX) $(CXXFLAGS) -o $@ $^ $@ is the target of the rule (e.g. foo.o), and $^ is all files on the right hand side. I'm writing this off the top of my head, without the possibility to test it, so please let me know how it turned out.. :) To make it even more elegant, you can include a dependency file include .depend If you're running GNU make, it'll try to make the .depend file if it can't find it (with old school make, you need to create it yourself first, it can be just a dummy though, if you'd like to manage it through the makefile) .depend: $(UTIL_SRC) $(CXX) -MM -o $@ $^ The dependency file will contain lines for each .cpp file, telling make what header files it needs, which will allow make to recompile the necessary files when you change something. This doesn't help with your original question though, just thought it might come in handy. EDIT: As a response to your edit. You could probably drop the commands for creating the .a-file as well, that too is already available as an implicit rule. Not sure exactly how it works though, haven't used it much. I do know that there are a bunch of quirks in make for dealing with .a(rchive?)-files.
