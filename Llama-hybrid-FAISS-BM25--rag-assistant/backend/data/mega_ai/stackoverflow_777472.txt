[site]: stackoverflow
[post_id]: 777472
[parent_id]: 777261
[tags]: 
int Result = Func(); assert( Result == 1 ); This situation means that in release mode, you really want: Func(); But Func is non-void, i.e. it returns a result, i.e. it is a query . Presumably, besides returning a result, Func modifies something (otherwise, why bother calling it and not using its result?), i.e. it is a command . By the command-query separation principle , Func shouldn't be a command and a query at the same time. In other words, queries shouldn't have side effects, and the "result" of commands should be represented by the available queries on the object's state. Cloth c; c.Wash(); // Wash is void assert(c.IsClean()); Is better than Cloth c; bool is_clean = c.Wash(); // Wash returns a bool assert(is_clean); The former doesn't give you any warning of your kind, the latter does. So, in short, my answer is: don't write code like this :) Update (1): You asked for references about the Command-Query Separation Principle . Wikipedia is rather informative. I read about this design technique in Object Oriented Software Construction, 2nd Editon by Bertrand Meyer. Update (2): j_random_hacker comments "OTOH, every "command" function f() that previously returned a value must now set some variable last_call_to_f_succeeded or similar". This is only true for functions that don't promise anything in their contract, i.e. functions that might "succeed" or not, or a similar concept. With Design by Contract , a relevant number of functions will have postconditions , so after "Empty()" the object will be "IsEmpty()", and after "Encode()" the message string will be "IsEncoded()", with no need to check. In the same way, and somewhat symetrically, you don't call a special function "IsXFeasible()" before each and every call to a procedure "X()"; because you usually know by design that you're fulfilling X's preconditions at the point of your call.
