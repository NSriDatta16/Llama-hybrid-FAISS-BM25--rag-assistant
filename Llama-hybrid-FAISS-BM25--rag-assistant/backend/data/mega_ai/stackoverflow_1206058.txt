[site]: stackoverflow
[post_id]: 1206058
[parent_id]: 1205518
[tags]: 
I'll post my own implementation here, if anyone's interested. This is heavily influenced and copied from Marc's answer, which I accepted. The code can be used to wrap a set of objects, all implementing a common interface, inside a new object, also implementing said interface. When methods and properties on the returned object is accessed, the corresponding methods and properties on the underlying objects are accessed in the same way. Here there be dragons : This is for a specific usage. There's potential for odd problems with this, in particular since the code does not ensure that all underlying objects are given the exact same objects as the callee is passing (or rather, it does not prohibit one of the underlying objects from messing with the arguments), and for methods that returns a value, only the last return value will be returned. As for out/ref arguments, I haven't even tested how that works, but it probably doesn't. You have been warned. #region Using using System; using System.Linq; using System.Diagnostics; using System.Reflection; using System.Reflection.Emit; using LVK.Collections; #endregion namespace LVK.IoC { /// /// This class implements a service wrapper that can wrap multiple services into a single multicast /// service, that will in turn dispatch all method calls down into all the underlying services. /// /// /// This code is heavily influenced and copied from Marc Gravell's implementation which he /// posted on Stack Overflow here: http://stackoverflow.com/questions/847809 /// public static class MulticastService { /// /// Wrap the specified services in a single multicast service object. /// /// /// The type of service to implement a multicast service for. /// /// /// The underlying service objects to multicast all method calls to. /// /// /// The multicast service instance. /// /// /// is null . /// - or - /// contains a null reference. /// /// /// is not an interface type. /// public static TService Wrap (params TService[] services) where TService: class { return (TService)Wrap(typeof(TService), (Object[])services); } /// /// Wrap the specified services in a single multicast service object. /// /// /// The object for the service interface to implement a multicast service for. /// /// /// The underlying service objects to multicast all method calls to. /// /// /// The multicast service instance. /// /// /// is null . /// - or - /// is null . /// - or - /// contains a null reference. /// /// /// is not an interface type. /// /// /// One or more of the service objects in does not implement /// the interface. /// public static Object Wrap(Type serviceInterfaceType, params Object[] services) { #region Parameter Validation if (Object.ReferenceEquals(null, serviceInterfaceType)) throw new ArgumentNullException("serviceInterfaceType"); if (!serviceInterfaceType.IsInterface) throw new ArgumentException("serviceInterfaceType"); if (Object.ReferenceEquals(null, services) || services.Length == 0) throw new ArgumentNullException("services"); foreach (var service in services) { if (Object.ReferenceEquals(null, service)) throw new ArgumentNullException("services"); if (!serviceInterfaceType.IsAssignableFrom(service.GetType())) throw new InvalidOperationException("One of the specified services does not implement the specified service interface"); } #endregion if (services.Length == 1) return services[0]; AssemblyName assemblyName = new AssemblyName(String.Format("tmp_{0}", serviceInterfaceType.FullName)); String moduleName = String.Format("{0}.dll", assemblyName.Name); String ns = serviceInterfaceType.Namespace; if (!String.IsNullOrEmpty(ns)) ns += "."; var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave); var module = assembly.DefineDynamicModule(moduleName, false); var type = module.DefineType(String.Format("{0}Multicast_{1}", ns, serviceInterfaceType.Name), TypeAttributes.Class | TypeAttributes.AnsiClass | TypeAttributes.Sealed | TypeAttributes.NotPublic); type.AddInterfaceImplementation(serviceInterfaceType); var ar = Array.CreateInstance(serviceInterfaceType, services.Length); for (Int32 index = 0; index
