[site]: stackoverflow
[post_id]: 2342091
[parent_id]: 2341998
[tags]: 
"The downside in both cases is that our team's business-wise productivity could either slow down significantly or evaporate entirely during any testing push." This is a common misinterpretation of the facts. Right now you have code you don't like and struggle to maintain. "hellish dependency graph", etc. So, the "crunch" development you've been doing has lead to expensive rework. Rework so expensive you don't dare attempt it. That says that your crunch development isn't very effective. It appears cheap at the time, but in retrospect, you note that you're really throwing development money away because you've created problematic, expensive software instead of creating good software. TDD can change this so that you aren't producing crunch software that's expensive to maintain. It can't fix everything, but it can make it clear that changing your focus from "crunch" can produce better software that's less expensive in the long run. From your description, some (or all) of your current code base is a liability, not an asset. Now think what TDD (or any discipline) will do to reduce the cost of that liability. The question of "productivity" doesn't apply when you're producing a liability. The Golden Rule of TDD: If you stop creating code that's a liability, the organization has a positive ROI. Be careful of asking how to keep up your current pace of productivity. Some of that "productivity" is producing cost with no value. "Almost none of our components can be tested in isolation; we don't know all the use cases" Correct. Retro-fitting unit tests to an existing code base is really hard. "There's a risk of leading the team into a false sense of security whereby subtle bugs will creep in without anyone noticing" False. There's no "false sense of security". Everyone knows the testing is rocky at best. Further, now you have horrifying bugs. You have problems so bad you don't even know what they are, because you have no test coverage. Trading up to a few subtle bugs is still a huge improvement over code you cannot test. I'll take subtle bugs over unknown bugs any day. "Method (2) is more attractive" Yes. But. Your previous testing efforts were subverted by a culture that rewards crunch programming. Has anything changed? I doubt it. Your culture still rewards crunch programming. Your testing initiative may still get subverted. You should look at a middle ground. You can't be expected to "fanatically adhering to TDD principles" overnight. That takes time, and a significant cultural change. What you need to do is break your applications into pieces. Consider, for example, the Model - Services - View tiers. You have core application model (persistent things, core classes, etc.) that requires extensive, rigorous trustworthy testing. You have application services that require some testing, but are subject to "the uses cases will likely change during the testing push due to business requirements or as a reaction to unforeseen issues". Test as much as you can, but don't run afoul of the imperative to ship stuff on time for the next season. You have view/presentation stuff that needs some testing, but isn't core processing. It's just presentation. It will change constantly as people want different options, views, reports, analysis, RIA, GUI, glitz, and sizzle.
