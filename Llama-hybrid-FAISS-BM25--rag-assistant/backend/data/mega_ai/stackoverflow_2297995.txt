[site]: stackoverflow
[post_id]: 2297995
[parent_id]: 2297829
[tags]: 
I use my own version of Python's time_it function. The advantage of this function is that it repeats a computation as many times as necessary to obtain meaningful results. If the computation is very fast, it will be repeated many times. In the end you obtain the average time of all the repetitions. It does not use any non-standard functionality: #include double clock_diff_to_sec(long clock_diff) { return double(clock_diff) / CLOCKS_PER_SEC; } template double time_it(Proc proc, int N=1) // returns time in microseconds { std::clock_t const start = std::clock(); for(int i = 0; i The following example uses the time_it function to measure the performance of different STL containers: void dummy_op(int i) { if(i == -1) std::cout void test(Container const & c) { std::for_each(c.begin(), c.end(), &dummy_op); } template void init(OutIt it) { for(int i = 0; i c; init(std::back_inserter(c)); std::cout >, c)) c; init(std::back_inserter(c)); std::cout >, c)) c; init(std::back_inserter(c)); std::cout >, c)) c; init(std::inserter(c, c.begin())); std::cout >, c)) c; init(std::inserter(c, c.begin())); std::cout >, c)) In case anyone is curious here is the output I get (compiled with VS2008 in release mode): vector: 8.7168 list: 27.776 deque: 91.52 set: 103.04 unordered_set: 29.76
