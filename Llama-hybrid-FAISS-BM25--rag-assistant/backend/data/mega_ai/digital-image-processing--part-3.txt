ature matching Principal components analysis Self-organizing maps Wavelets Digital image transformations Filtering Digital filters are used to blur and sharpen digital images. Filtering can be performed by: convolution with specifically designed kernels (filter array) in the spatial domain masking specific frequency regions in the frequency (Fourier) domain The following examples show both methods: Image padding in Fourier domain filtering Images are typically padded before being transformed to the Fourier space, the highpass filtered images below illustrate the consequences of different padding techniques: Notice that the highpass filter shows extra edges when zero padded compared to the repeated edge padding. Filtering code examples MATLAB example for spatial domain highpass filtering. Affine transformations Affine transformations enable basic image transformations including scale, rotate, translate, mirror and shear as is shown in the following examples: To apply the affine matrix to an image, the image is converted to matrix in which each entry corresponds to the pixel intensity at that location. Then each pixel's location can be represented as a vector indicating the coordinates of that pixel in the image, [x, y], where x and y are the row and column of a pixel in the image matrix. This allows the coordinate to be multiplied by an affine-transformation matrix, which gives the position that the pixel value will be copied to in the output image. However, to allow transformations that require translation transformations, 3-dimensional homogeneous coordinates are needed. The third dimension is usually set to a non-zero constant, usually 1, so that the new coordinate is [x, y, 1]. This allows the coordinate vector to be multiplied by a 3×3 matrix, enabling translation shifts. Thus, the third dimension, i.e. the constant 1, allows translation. Because matrix multiplication is associative, multiple affine transformations can be combined into a single affine transformation by multiplying the matrix of each individual transformation in the order that the transformations are done. This results in a single matrix that, when applied to a point vector, gives the same result as all the individual transformations performed on the vector [x, y, 1] in sequence. Thus a sequence of affine transformation matrices can be reduced to a single affine transformation matrix. For example, 2-dimensional coordinates only permit rotation about the origin (0, 0). But 3-dimensional homogeneous coordinates can be used to first translate any point to (0, 0), then perform the rotation, and lastly translate the origin (0, 0) back to the original point (the opposite of the first translation). These three affine transformations can be combined into a single matrix—thus allowing rotation around any point in the image. Image denoising with mathematical morphology Mathematical morphology (MM) is a nonlinear image processing framework that analyzes shapes within images by probing local pixel neighborhoods using a small, predefined function called a structuring element. In the context of grayscale images, MM is especially useful for denoising through dilation and erosion—primitive operators that can be combined to build more complex filters. Suppose we have: A discrete grayscale image: f = [ 45 50 65 40 60 55 25 15 5 ] , f : Ω → R , Ω = { 0 , 1 , 2 } 2 , {\displaystyle f={\begin{bmatrix}45&50&65\\40&60&55\\25&15&5\end{bmatrix}},\quad f:\Omega \rightarrow \mathbb {R} ,\quad \Omega =\{0,1,2\}^{2},} A structuring element: B = [ 1 2 1 2 1 1 1 0 3 ] , B : S → R , S = { − 1 , 0 , 1 } 2 . {\displaystyle B={\begin{bmatrix}1&2&1\\2&1&1\\1&0&3\end{bmatrix}},\quad B:{\mathcal {S}}\rightarrow \mathbb {R} ,\quad {\mathcal {S}}=\{-1,0,1\}^{2}.} Here, S {\displaystyle {\mathcal {S}}} defines the neighborhood of relative coordinates ( m , n ) {\displaystyle (m,n)} over which local operations are computed. The values of B ( m , n ) {\displaystyle B(m,n)} bias the image during dila