[site]: stackoverflow
[post_id]: 3938984
[parent_id]: 
[tags]: 
Managing NHibernate sessions for a multi-tenant ASP.NET application

I have an existing multi-tenant ASP.NET application where all users authenticate against a single SQL Server database. This database also contains several other settings type data that is used within the application. Each client after authentication, utilizes their own SQL Server database for data storage, for isolation purposes. Essentially all of the client database are identical and reside on the same server, but reside on one or more servers as well. The application is currently written in asp.net 2.5 framework and utilizes the Microsoft Practices Enterprise Library for DAL, and we are looking to migrate to 4.0 and implement NHibernate to replace the MPEL. I have implemented a solution already using NHibernate and the 4.0 framework, so I am familiar with the concepts. I found the resources for my current session manager here as a matter of fact. But that application only had a single database, so not much too it. The implementation is essentially what you see here: http://www.lostechies.com/blogs/nelson_montalvo/archive/2007/03/30/simple-nhibernate-example-part-4-session-management.aspx The other solutions that I have seen suggest multiple config entries and/or files to manage this, but that is not desirable, since we may add new clients frequently and all of the connection information is already maintained in the authentication database. Does anyone have any suggestions on how I might be able to pass in the client's connection string to a session manager? The following is my current session manager class, which is based on the article mentioned above. using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Runtime.Remoting.Messaging; using System.Web; using NHibernate; using NHibernate.Cfg; using NHibernate.Cache; using singlepoint.timeclock.domain; namespace singlepoint.timeclock.repositories { /// /// Handles creation and management of sessions and transactions. It is a singleton because /// building the initial session factory is very expensive. Inspiration for this class came /// from Chapter 8 of Hibernate in Action by Bauer and King. Although it is a sealed singleton /// you can use TypeMock (http://www.typemock.com) for more flexible testing. /// public sealed class nHibernateSessionManager { private ISessionFactory idadSessionFactory; private ISessionFactory clientSessionFactory; private string _client; #region Thread-safe, lazy Singleton // lazy initialisation, therefore initialised to null private static nHibernateSessionManager instance = null; /// /// This is a thread-safe, lazy singleton. See http://www.yoda.arachsys.com/csharp/singleton.html /// for more details about its implementation. /// public static nHibernateSessionManager Instance { get { return GetInstance(); } } public static nHibernateSessionManager GetInstance() { // lazy init. if (instance == null) instance = new nHibernateSessionManager(); return instance; } // GetInstance /// /// Initializes the NHibernate session factory upon instantiation. /// private nHibernateSessionManager() { InitSessionFactory(); } /// /// Initializes the NHibernate session factory upon instantiation. /// private nHibernateSessionManager(string client) { InitSessionFactory(); InitClientSessionFactory(client); } /// /// Assists with ensuring thread-safe, lazy singleton /// private class Nested { static Nested() { } internal static readonly nHibernateSessionManager nHibernatenHibernateSessionManager = new nHibernateSessionManager(); } #endregion private void InitSessionFactory() { var configuration = new Configuration(); configuration.Configure(System.Configuration.ConfigurationManager.AppSettings["IDAD_HBM"]); configuration.AddAssembly(typeof(enterprise).Assembly); idadSessionFactory = configuration.BuildSessionFactory(); } private void InitClientSessionFactory(string client) { var configuration = new Configuration(); configuration.Configure(System.Configuration.ConfigurationManager.AppSettings["Client_IDAD_HBM"]); configuration.SetProperty("connection.connection_string", client); configuration.AddAssembly(typeof(enterprise).Assembly); clientSessionFactory = configuration.BuildSessionFactory(); } /// /// Allows you to register an interceptor on a new session. This may not be called if there is already /// an open session attached to the HttpContext. If you have an interceptor to be used, modify /// the HttpModule to call this before calling BeginTransaction(). /// public void RegisterInterceptor(IInterceptor interceptor) { ISession session = ThreadSession; if (session != null && session.IsOpen) { throw new CacheException("You cannot register an interceptor once a session has already been opened"); } GetSession(interceptor); } public ISession GetSession() { return GetSession(null); } /// /// Gets a session with or without an interceptor. This method is not called directly; instead, /// it gets invoked from other public methods. /// private ISession GetSession(IInterceptor interceptor) { ISession session = ThreadSession; if (session == null) { if (interceptor != null) { session = idadSessionFactory.OpenSession(interceptor); } else { session = idadSessionFactory.OpenSession(); } ThreadSession = session; } return session; } public void CloseSession() { ISession session = ThreadSession; ThreadSession = null; if (session != null && session.IsOpen) { session.Close(); } } public void BeginTransaction() { ITransaction transaction = ThreadTransaction; if (transaction == null) { transaction = GetSession().BeginTransaction(); ThreadTransaction = transaction; } } public void CommitTransaction() { ITransaction transaction = ThreadTransaction; try { if (transaction != null && !transaction.WasCommitted && !transaction.WasRolledBack) { transaction.Commit(); ThreadTransaction = null; } } catch (HibernateException ex) { RollbackTransaction(); throw ex; } } public void RollbackTransaction() { ITransaction transaction = ThreadTransaction; try { ThreadTransaction = null; if (transaction != null && !transaction.WasCommitted && !transaction.WasRolledBack) { transaction.Rollback(); } } catch (HibernateException ex) { throw ex; } finally { CloseSession(); } } /// /// If within a web context, this uses instead of the WinForms /// specific . Discussion concerning this found at /// http://forum.springframework.net/showthread.php?t=572. /// private ITransaction ThreadTransaction { get { if (IsInWebContext()) { return (ITransaction)HttpContext.Current.Items[TRANSACTION_KEY]; } else { return (ITransaction)CallContext.GetData(TRANSACTION_KEY); } } set { if (IsInWebContext()) { HttpContext.Current.Items[TRANSACTION_KEY] = value; } else { CallContext.SetData(TRANSACTION_KEY, value); } } } /// /// If within a web context, this uses instead of the WinForms /// specific . Discussion concerning this found at /// http://forum.springframework.net/showthread.php?t=572. /// private ISession ThreadSession { get { if (IsInWebContext()) { return (ISession)HttpContext.Current.Items[SESSION_KEY]; } else { return (ISession)CallContext.GetData(SESSION_KEY); } } set { if (IsInWebContext()) { HttpContext.Current.Items[SESSION_KEY] = value; } else { CallContext.SetData(SESSION_KEY, value); } } } private static bool IsInWebContext() { return HttpContext.Current != null; } private const string TRANSACTION_KEY = "CONTEXT_TRANSACTION"; private const string SESSION_KEY = "CONTEXT_SESSION"; [Obsolete("only until we can fix the session issue globally")] internal ISession OpenSession() { return idadSessionFactory.OpenSession(); } } } This is being called from a repository class like so: public string getByName(string name) { return getByName(nHibernateSessionManager.Instance.GetSession(), name); } What I would really like to be able to do is the following: public string getByName(string name, string clientConnectionString) { return getByName(nHibernateSessionManager.Instance.GetSession(clientConnectionString), name); } But I am having trouble modifying my existing session manager to accomodate this.
